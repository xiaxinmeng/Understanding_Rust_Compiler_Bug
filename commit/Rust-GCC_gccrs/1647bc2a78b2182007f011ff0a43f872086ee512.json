{"sha": "1647bc2a78b2182007f011ff0a43f872086ee512", "node_id": "C_kwDOANBUbNoAKDE2NDdiYzJhNzhiMjE4MjAwN2YwMTFmZjBhNDNmODcyMDg2ZWU1MTI", "commit": {"author": {"name": "Pierre-Alexandre Bazin", "email": "bazin@adacore.com", "date": "2021-07-02T13:43:44Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-22T15:01:48Z"}, "message": "[Ada] Contracts written for the Ada.Strings.Bounded library\n\ngcc/ada/\n\n\t* libgnat/a-strbou.adb: Turn SPARK_Mode on.\n\t* libgnat/a-strbou.ads: Write contracts.\n\t* libgnat/a-strfix.ads (Index): Fix grammar error in a comment.\n\t* libgnat/a-strsea.ads (Index): Likewise.\n\t* libgnat/a-strsup.adb: Rewrite the body to take into account\n\tthe new definition of Super_String using Relaxed_Initialization\n\tand a predicate.\n\t(Super_Replicate, Super_Translate, Times): Added loop\n\tinvariants, and ghost lemmas for Super_Replicate and Times.\n\t(Super_Trim): Rewrite the body using search functions to\n\tdetermine the cutting points.\n\t(Super_Element, Super_Length, Super_Slice, Super_To_String):\n\tRemove (now written as expression functions in a-strsup.ads).\n\t* libgnat/a-strsup.ads: Added contracts.\n\t(Super_Element, Super_Length, Super_Slice, Super_To_String):\n\tRewrite as expression functions.", "tree": {"sha": "670c2c96daf0797b252ea5787c729194d78a676a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/670c2c96daf0797b252ea5787c729194d78a676a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1647bc2a78b2182007f011ff0a43f872086ee512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1647bc2a78b2182007f011ff0a43f872086ee512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1647bc2a78b2182007f011ff0a43f872086ee512", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1647bc2a78b2182007f011ff0a43f872086ee512/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f325f5e6fd091f73f5be6ef30d27e22e4b59a74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f325f5e6fd091f73f5be6ef30d27e22e4b59a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f325f5e6fd091f73f5be6ef30d27e22e4b59a74"}], "stats": {"total": 5634, "additions": 4911, "deletions": 723}, "files": [{"sha": "01a2002673b7566323b83ab7588a648ba83f671e", "filename": "gcc/ada/libgnat/a-strbou.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strbou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strbou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strbou.adb?ref=1647bc2a78b2182007f011ff0a43f872086ee512", "patch": "@@ -29,7 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body Ada.Strings.Bounded is\n+package body Ada.Strings.Bounded with SPARK_Mode is\n \n    package body Generic_Bounded_Length is\n "}, {"sha": "b88e04935b1056562535b95214e025cc5e7a40e0", "filename": "gcc/ada/libgnat/a-strbou.ads", "status": "modified", "additions": 1865, "deletions": 209, "changes": 2074, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strbou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strbou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strbou.ads?ref=1647bc2a78b2182007f011ff0a43f872086ee512"}, {"sha": "168a8e0dddab77d68666bb39dcbc9e1c3085cc76", "filename": "gcc/ada/libgnat/a-strfix.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strfix.ads?ref=1647bc2a78b2182007f011ff0a43f872086ee512", "patch": "@@ -382,7 +382,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a index in the range of Source is returned\n+        --  Otherwise, an index in the range of Source is returned\n \n         others\n         =>\n@@ -392,7 +392,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n           Index'Result in Source'Range\n \n             --  The character at the returned index satisfies the property\n-            --  Test on Set\n+            --  Test on Set.\n \n             and then\n               (Test = Inside)\n@@ -433,7 +433,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a index in the considered range of Source is returned\n+        --  Otherwise, an index in the considered range of Source is returned\n \n         others\n         =>"}, {"sha": "f4e7d361408cfdb0ce1b6969dbabbbe2995006aa", "filename": "gcc/ada/libgnat/a-strsea.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strsea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strsea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strsea.ads?ref=1647bc2a78b2182007f011ff0a43f872086ee512", "patch": "@@ -213,7 +213,7 @@ package Ada.Strings.Search with SPARK_Mode is\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a index in the range of Source is returned\n+        --  Otherwise, an index in the range of Source is returned\n \n         others =>\n \n@@ -222,7 +222,7 @@ package Ada.Strings.Search with SPARK_Mode is\n           Index'Result in Source'Range\n \n             --  The character at the returned index satisfies the property\n-            --  Test on Set\n+            --  Test on Set.\n \n             and then (Test = Inside)\n               = Ada.Strings.Maps.Is_In (Source (Index'Result), Set)\n@@ -377,7 +377,7 @@ package Ada.Strings.Search with SPARK_Mode is\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a index in the considered range of Source is returned\n+        --  Otherwise, an index in the considered range of Source is returned\n \n         others =>\n "}, {"sha": "a94d6cad4e02899b997dcbfe3cf120187002bb36", "filename": "gcc/ada/libgnat/a-strsup.adb", "status": "modified", "additions": 737, "deletions": 426, "changes": 1163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strsup.adb?ref=1647bc2a78b2182007f011ff0a43f872086ee512", "patch": "@@ -29,10 +29,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Strings.Maps;   use Ada.Strings.Maps;\n-with Ada.Strings.Search;\n+--  Ghost code, loop invariants and assertions in this unit are meant for\n+--  analysis only, not for run-time checking, as it would be too costly\n+--  otherwise. This is enforced by setting the assertion policy to Ignore.\n \n-package body Ada.Strings.Superbounded is\n+pragma Assertion_Policy (Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n+with Ada.Strings.Maps; use Ada.Strings.Maps;\n+\n+package body Ada.Strings.Superbounded with SPARK_Mode is\n \n    ------------\n    -- Concat --\n@@ -53,9 +60,13 @@ package body Ada.Strings.Superbounded is\n                raise Ada.Strings.Length_Error;\n             end if;\n \n-            Result.Current_Length := Nlen;\n             Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-            Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+\n+            if Rlen > 0 then\n+               Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+            end if;\n+\n+            Result.Current_Length := Nlen;\n          end;\n       end return;\n    end Concat;\n@@ -74,9 +85,13 @@ package body Ada.Strings.Superbounded is\n                raise Ada.Strings.Length_Error;\n             end if;\n \n-            Result.Current_Length := Nlen;\n             Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-            Result.Data (Llen + 1 .. Nlen) := Right;\n+\n+            if Right'Length > 0 then\n+               Result.Data (Llen + 1 .. Nlen) := Super_String_Data (Right);\n+            end if;\n+\n+            Result.Current_Length := Nlen;\n          end;\n       end return;\n    end Concat;\n@@ -97,9 +112,13 @@ package body Ada.Strings.Superbounded is\n                raise Ada.Strings.Length_Error;\n             end if;\n \n+            Result.Data (1 .. Llen) := Super_String_Data (Left);\n+\n+            if Rlen > 0 then\n+               Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n+            end if;\n+\n             Result.Current_Length := Nlen;\n-            Result.Data (1 .. Llen) := Left;\n-            Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n          end;\n       end return;\n    end Concat;\n@@ -117,9 +136,9 @@ package body Ada.Strings.Superbounded is\n                raise Ada.Strings.Length_Error;\n             end if;\n \n-            Result.Current_Length := Llen + 1;\n             Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-            Result.Data (Result.Current_Length) := Right;\n+            Result.Data (Llen + 1) := Right;\n+            Result.Current_Length := Llen + 1;\n          end;\n       end return;\n    end Concat;\n@@ -137,10 +156,9 @@ package body Ada.Strings.Superbounded is\n                raise Ada.Strings.Length_Error;\n             end if;\n \n-            Result.Current_Length := Rlen + 1;\n             Result.Data (1) := Left;\n-            Result.Data (2 .. Result.Current_Length) :=\n-              Right.Data (1 .. Rlen);\n+            Result.Data (2 .. Rlen + 1) := Right.Data (1 .. Rlen);\n+            Result.Current_Length := Rlen + 1;\n          end;\n       end return;\n    end Concat;\n@@ -154,27 +172,23 @@ package body Ada.Strings.Superbounded is\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left.Current_Length = Right.Current_Length\n-        and then Left.Data (1 .. Left.Current_Length) =\n-                   Right.Data (1 .. Right.Current_Length);\n+      return Super_To_String (Left) = Super_To_String (Right);\n    end \"=\";\n \n    function Equal\n      (Left  : Super_String;\n       Right : String) return Boolean\n    is\n    begin\n-      return Left.Current_Length = Right'Length\n-        and then Left.Data (1 .. Left.Current_Length) = Right;\n+      return Super_To_String (Left) = Right;\n    end Equal;\n \n    function Equal\n      (Left  : String;\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left'Length = Right.Current_Length\n-        and then Left = Right.Data (1 .. Right.Current_Length);\n+      return Left = Super_To_String (Right);\n    end Equal;\n \n    -------------\n@@ -186,24 +200,23 @@ package body Ada.Strings.Superbounded is\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) >\n-               Right.Data (1 .. Right.Current_Length);\n+      return Super_To_String (Left) > Super_To_String (Right);\n    end Greater;\n \n    function Greater\n      (Left  : Super_String;\n       Right : String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) > Right;\n+      return Super_To_String (Left) > Right;\n    end Greater;\n \n    function Greater\n      (Left  : String;\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left > Right.Data (1 .. Right.Current_Length);\n+      return Left > Super_To_String (Right);\n    end Greater;\n \n    ----------------------\n@@ -215,24 +228,23 @@ package body Ada.Strings.Superbounded is\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) >=\n-               Right.Data (1 .. Right.Current_Length);\n+      return Super_To_String (Left) >= Super_To_String (Right);\n    end Greater_Or_Equal;\n \n    function Greater_Or_Equal\n      (Left  : Super_String;\n       Right : String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) >= Right;\n+      return Super_To_String (Left) >= Right;\n    end Greater_Or_Equal;\n \n    function Greater_Or_Equal\n      (Left  : String;\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left >= Right.Data (1 .. Right.Current_Length);\n+      return Left >= Super_To_String (Right);\n    end Greater_Or_Equal;\n \n    ----------\n@@ -244,24 +256,23 @@ package body Ada.Strings.Superbounded is\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) <\n-               Right.Data (1 .. Right.Current_Length);\n+      return Super_To_String (Left) < Super_To_String (Right);\n    end Less;\n \n    function Less\n      (Left  : Super_String;\n       Right : String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) < Right;\n+      return Super_To_String (Left) < Right;\n    end Less;\n \n    function Less\n      (Left  : String;\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left < Right.Data (1 .. Right.Current_Length);\n+      return Left < Super_To_String (Right);\n    end Less;\n \n    -------------------\n@@ -273,24 +284,23 @@ package body Ada.Strings.Superbounded is\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) <=\n-               Right.Data (1 .. Right.Current_Length);\n+      return Super_To_String (Left) <= Super_To_String (Right);\n    end Less_Or_Equal;\n \n    function Less_Or_Equal\n      (Left  : Super_String;\n       Right : String) return Boolean\n    is\n    begin\n-      return Left.Data (1 .. Left.Current_Length) <= Right;\n+      return Super_To_String (Left) <= Right;\n    end Less_Or_Equal;\n \n    function Less_Or_Equal\n      (Left  : String;\n       Right : Super_String) return Boolean\n    is\n    begin\n-      return Left <= Right.Data (1 .. Right.Current_Length);\n+      return Left <= Super_To_String (Right);\n    end Less_Or_Equal;\n \n    ----------------------\n@@ -307,20 +317,20 @@ package body Ada.Strings.Superbounded is\n \n    begin\n       if Slen <= Max_Length then\n+         Target.Data (1 .. Slen) := Super_String_Data (Source);\n          Target.Current_Length := Slen;\n-         Target.Data (1 .. Slen) := Source;\n \n       else\n          case Drop is\n             when Strings.Right =>\n+               Target.Data (1 .. Max_Length) := Super_String_Data\n+                 (Source (Source'First .. Source'First - 1 + Max_Length));\n                Target.Current_Length := Max_Length;\n-               Target.Data (1 .. Max_Length) :=\n-                 Source (Source'First .. Source'First - 1 + Max_Length);\n \n             when Strings.Left =>\n+               Target.Data (1 .. Max_Length) := Super_String_Data\n+                 (Source (Source'Last - (Max_Length - 1) .. Source'Last));\n                Target.Current_Length := Max_Length;\n-               Target.Data (1 .. Max_Length) :=\n-                 Source (Source'Last - (Max_Length - 1) .. Source'Last);\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n@@ -343,17 +353,18 @@ package body Ada.Strings.Superbounded is\n       Result : Super_String (Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n       Rlen   : constant Natural := Right.Current_Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n \n    begin\n-      if Nlen <= Max_Length then\n-         Result.Current_Length := Nlen;\n+      if Llen <= Max_Length - Rlen then\n          Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right.Data (1 .. Rlen);\n \n-      else\n-         Result.Current_Length := Max_Length;\n+         if Rlen > 0 then\n+            Result.Data (Llen + 1 .. Llen + Rlen) := Right.Data (1 .. Rlen);\n+         end if;\n+\n+         Result.Current_Length := Llen + Rlen;\n \n+      else\n          case Drop is\n             when Strings.Right =>\n                if Llen >= Max_Length then -- only case is Llen = Max_Length\n@@ -379,6 +390,8 @@ package body Ada.Strings.Superbounded is\n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n       end if;\n \n       return Result;\n@@ -392,16 +405,15 @@ package body Ada.Strings.Superbounded is\n       Max_Length : constant Positive := Source.Max_Length;\n       Llen       : constant Natural := Source.Current_Length;\n       Rlen       : constant Natural := New_Item.Current_Length;\n-      Nlen       : constant Natural := Llen + Rlen;\n \n    begin\n-      if Nlen <= Max_Length then\n-         Source.Current_Length := Nlen;\n-         Source.Data (Llen + 1 .. Nlen) := New_Item.Data (1 .. Rlen);\n+      if Llen <= Max_Length - Rlen then\n+         if Rlen > 0 then\n+            Source.Data (Llen + 1 .. Llen + Rlen) := New_Item.Data (1 .. Rlen);\n+            Source.Current_Length := Llen + Rlen;\n+         end if;\n \n       else\n-         Source.Current_Length := Max_Length;\n-\n          case Drop is\n             when Strings.Right =>\n                if Llen < Max_Length then\n@@ -423,6 +435,8 @@ package body Ada.Strings.Superbounded is\n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Source.Current_Length := Max_Length;\n       end if;\n \n    end Super_Append;\n@@ -438,45 +452,48 @@ package body Ada.Strings.Superbounded is\n       Result : Super_String (Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n       Rlen   : constant Natural := Right'Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n \n    begin\n-      if Nlen <= Max_Length then\n-         Result.Current_Length := Nlen;\n+      if Llen <= Max_Length - Rlen then\n          Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-         Result.Data (Llen + 1 .. Nlen) := Right;\n \n-      else\n-         Result.Current_Length := Max_Length;\n+         if Rlen > 0 then\n+            Result.Data (Llen + 1 .. Llen + Rlen) := Super_String_Data (Right);\n+         end if;\n+\n+         Result.Current_Length := Llen + Rlen;\n \n+      else\n          case Drop is\n             when Strings.Right =>\n                if Llen >= Max_Length then -- only case is Llen = Max_Length\n                   Result.Data := Left.Data;\n \n                else\n                   Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n-                  Result.Data (Llen + 1 .. Max_Length) :=\n-                    Right (Right'First .. Right'First - 1 +\n-                             Max_Length - Llen);\n+                  Result.Data (Llen + 1 .. Max_Length) := Super_String_Data\n+                    (Right\n+                       (Right'First .. Right'First - 1 - Llen + Max_Length));\n \n                end if;\n \n             when Strings.Left =>\n                if Rlen >= Max_Length then\n-                  Result.Data (1 .. Max_Length) :=\n-                    Right (Right'Last - (Max_Length - 1) .. Right'Last);\n+                  Result.Data (1 .. Max_Length) := Super_String_Data\n+                    (Right (Right'Last - (Max_Length - 1) .. Right'Last));\n \n                else\n                   Result.Data (1 .. Max_Length - Rlen) :=\n                     Left.Data (Llen - (Max_Length - Rlen - 1) .. Llen);\n                   Result.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n-                    Right;\n+                    Super_String_Data (Right);\n                end if;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n       end if;\n \n       return Result;\n@@ -490,40 +507,42 @@ package body Ada.Strings.Superbounded is\n       Max_Length : constant Positive := Source.Max_Length;\n       Llen   : constant Natural := Source.Current_Length;\n       Rlen   : constant Natural := New_Item'Length;\n-      Nlen   : constant Natural := Llen + Rlen;\n \n    begin\n-      if Nlen <= Max_Length then\n-         Source.Current_Length := Nlen;\n-         Source.Data (Llen + 1 .. Nlen) := New_Item;\n+      if Llen <= Max_Length - Rlen then\n+         if Rlen > 0 then\n+            Source.Data (Llen + 1 .. Llen + Rlen) :=\n+              Super_String_Data (New_Item);\n+            Source.Current_Length := Llen + Rlen;\n+         end if;\n \n       else\n-         Source.Current_Length := Max_Length;\n-\n          case Drop is\n             when Strings.Right =>\n                if Llen < Max_Length then\n-                  Source.Data (Llen + 1 .. Max_Length) :=\n-                    New_Item (New_Item'First ..\n-                                New_Item'First - 1 + Max_Length - Llen);\n+                  Source.Data (Llen + 1 .. Max_Length) := Super_String_Data\n+                    (New_Item (New_Item'First ..\n+                                New_Item'First - 1 - Llen + Max_Length));\n                end if;\n \n             when Strings.Left =>\n                if Rlen >= Max_Length then\n-                  Source.Data (1 .. Max_Length) :=\n-                    New_Item (New_Item'Last - (Max_Length - 1) ..\n-                                New_Item'Last);\n+                  Source.Data (1 .. Max_Length) := Super_String_Data\n+                    (New_Item (New_Item'Last - (Max_Length - 1) ..\n+                                New_Item'Last));\n \n                else\n                   Source.Data (1 .. Max_Length - Rlen) :=\n                     Source.Data (Llen - (Max_Length - Rlen - 1) .. Llen);\n                   Source.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n-                    New_Item;\n+                    Super_String_Data (New_Item);\n                end if;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Source.Current_Length := Max_Length;\n       end if;\n \n    end Super_Append;\n@@ -539,25 +558,25 @@ package body Ada.Strings.Superbounded is\n       Result     : Super_String (Max_Length);\n       Llen       : constant Natural := Left'Length;\n       Rlen       : constant Natural := Right.Current_Length;\n-      Nlen       : constant Natural := Llen + Rlen;\n \n    begin\n-      if Nlen <= Max_Length then\n-         Result.Current_Length := Nlen;\n-         Result.Data (1 .. Llen) := Left;\n-         Result.Data (Llen + 1 .. Llen + Rlen) := Right.Data (1 .. Rlen);\n+      if Llen <= Max_Length - Rlen then\n+         Result.Data (1 .. Llen) := Super_String_Data (Left);\n \n-      else\n-         Result.Current_Length := Max_Length;\n+         if Rlen > 0 then\n+            Result.Data (Llen + 1 .. Llen + Rlen) := Right.Data (1 .. Rlen);\n+         end if;\n \n+         Result.Current_Length := Llen + Rlen;\n+      else\n          case Drop is\n             when Strings.Right =>\n                if Llen >= Max_Length then\n-                  Result.Data (1 .. Max_Length) :=\n-                    Left (Left'First .. Left'First + (Max_Length - 1));\n+                  Result.Data (1 .. Max_Length) := Super_String_Data\n+                    (Left (Left'First .. Left'First + (Max_Length - 1)));\n \n                else\n-                  Result.Data (1 .. Llen) := Left;\n+                  Result.Data (1 .. Llen) := Super_String_Data (Left);\n                   Result.Data (Llen + 1 .. Max_Length) :=\n                     Right.Data (1 .. Max_Length - Llen);\n                end if;\n@@ -568,15 +587,17 @@ package body Ada.Strings.Superbounded is\n                     Right.Data (Rlen - (Max_Length - 1) .. Rlen);\n \n                else\n-                  Result.Data (1 .. Max_Length - Rlen) :=\n-                    Left (Left'Last - (Max_Length - Rlen - 1) .. Left'Last);\n+                  Result.Data (1 .. Max_Length - Rlen) := Super_String_Data\n+                    (Left (Left'Last - (Max_Length - Rlen - 1) .. Left'Last));\n                   Result.Data (Max_Length - Rlen + 1 .. Max_Length) :=\n                     Right.Data (1 .. Rlen);\n                end if;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n       end if;\n \n       return Result;\n@@ -595,9 +616,9 @@ package body Ada.Strings.Superbounded is\n \n    begin\n       if Llen  < Max_Length then\n-         Result.Current_Length := Llen + 1;\n          Result.Data (1 .. Llen) := Left.Data (1 .. Llen);\n          Result.Data (Llen + 1) := Right;\n+         Result.Current_Length := Llen + 1;\n          return Result;\n \n       else\n@@ -606,10 +627,10 @@ package body Ada.Strings.Superbounded is\n                return Left;\n \n             when Strings.Left =>\n-               Result.Current_Length := Max_Length;\n                Result.Data (1 .. Max_Length - 1) :=\n                  Left.Data (2 .. Max_Length);\n                Result.Data (Max_Length) := Right;\n+               Result.Current_Length := Max_Length;\n                return Result;\n \n             when Strings.Error =>\n@@ -628,12 +649,10 @@ package body Ada.Strings.Superbounded is\n \n    begin\n       if Llen  < Max_Length then\n-         Source.Current_Length := Llen + 1;\n          Source.Data (Llen + 1) := New_Item;\n+         Source.Current_Length := Llen + 1;\n \n       else\n-         Source.Current_Length := Max_Length;\n-\n          case Drop is\n             when Strings.Right =>\n                null;\n@@ -663,18 +682,18 @@ package body Ada.Strings.Superbounded is\n \n    begin\n       if Rlen < Max_Length then\n-         Result.Current_Length := Rlen + 1;\n          Result.Data (1) := Left;\n          Result.Data (2 .. Rlen + 1) := Right.Data (1 .. Rlen);\n+         Result.Current_Length := Rlen + 1;\n          return Result;\n \n       else\n          case Drop is\n             when Strings.Right =>\n-               Result.Current_Length := Max_Length;\n                Result.Data (1) := Left;\n                Result.Data (2 .. Max_Length) :=\n                  Right.Data (1 .. Max_Length - 1);\n+               Result.Current_Length := Max_Length;\n                return Result;\n \n             when Strings.Left =>\n@@ -696,9 +715,7 @@ package body Ada.Strings.Superbounded is\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    is\n    begin\n-      return\n-        Search.Count\n-          (Source.Data (1 .. Source.Current_Length), Pattern, Mapping);\n+      return Search.Count (Super_To_String (Source), Pattern, Mapping);\n    end Super_Count;\n \n    function Super_Count\n@@ -707,17 +724,15 @@ package body Ada.Strings.Superbounded is\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    is\n    begin\n-      return\n-        Search.Count\n-          (Source.Data (1 .. Source.Current_Length), Pattern, Mapping);\n+      return Search.Count (Super_To_String (Source), Pattern, Mapping);\n    end Super_Count;\n \n    function Super_Count\n      (Source : Super_String;\n       Set    : Maps.Character_Set) return Natural\n    is\n    begin\n-      return Search.Count (Source.Data (1 .. Source.Current_Length), Set);\n+      return Search.Count (Super_To_String (Source), Set);\n    end Super_Count;\n \n    ------------------\n@@ -737,19 +752,19 @@ package body Ada.Strings.Superbounded is\n       if Num_Delete <= 0 then\n          return Source;\n \n-      elsif From > Slen + 1 then\n+      elsif From - 1 > Slen then\n          raise Ada.Strings.Index_Error;\n \n       elsif Through >= Slen then\n-         Result.Current_Length := From - 1;\n          Result.Data (1 .. From - 1) := Source.Data (1 .. From - 1);\n+         Result.Current_Length := From - 1;\n          return Result;\n \n       else\n-         Result.Current_Length := Slen - Num_Delete;\n          Result.Data (1 .. From - 1) := Source.Data (1 .. From - 1);\n-         Result.Data (From .. Result.Current_Length) :=\n+         Result.Data (From .. Slen - Num_Delete) :=\n            Source.Data (Through + 1 .. Slen);\n+         Result.Current_Length := Slen - Num_Delete;\n          return Result;\n       end if;\n    end Super_Delete;\n@@ -766,7 +781,7 @@ package body Ada.Strings.Superbounded is\n       if Num_Delete <= 0 then\n          return;\n \n-      elsif From > Slen + 1 then\n+      elsif From - 1 > Slen then\n          raise Ada.Strings.Index_Error;\n \n       elsif Through >= Slen then\n@@ -779,22 +794,6 @@ package body Ada.Strings.Superbounded is\n       end if;\n    end Super_Delete;\n \n-   -------------------\n-   -- Super_Element --\n-   -------------------\n-\n-   function Super_Element\n-     (Source : Super_String;\n-      Index  : Positive) return Character\n-   is\n-   begin\n-      if Index <= Source.Current_Length then\n-         return Source.Data (Index);\n-      else\n-         raise Strings.Index_Error;\n-      end if;\n-   end Super_Element;\n-\n    ----------------------\n    -- Super_Find_Token --\n    ----------------------\n@@ -809,7 +808,7 @@ package body Ada.Strings.Superbounded is\n    is\n    begin\n       Search.Find_Token\n-        (Source.Data (From .. Source.Current_Length), Set, Test, First, Last);\n+        (Super_To_String (Source), Set, From, Test, First, Last);\n    end Super_Find_Token;\n \n    procedure Super_Find_Token\n@@ -820,8 +819,7 @@ package body Ada.Strings.Superbounded is\n       Last   : out Natural)\n    is\n    begin\n-      Search.Find_Token\n-        (Source.Data (1 .. Source.Current_Length), Set, Test, First, Last);\n+      Search.Find_Token (Super_To_String (Source), Set, Test, First, Last);\n    end Super_Find_Token;\n \n    ----------------\n@@ -841,21 +839,22 @@ package body Ada.Strings.Superbounded is\n \n    begin\n       if Npad <= 0 then\n-         Result.Current_Length := Count;\n          Result.Data (1 .. Count) := Source.Data (1 .. Count);\n+         Result.Current_Length := Count;\n \n       elsif Count <= Max_Length then\n-         Result.Current_Length := Count;\n          Result.Data (1 .. Slen) := Source.Data (1 .. Slen);\n          Result.Data (Slen + 1 .. Count) := (others => Pad);\n+         Result.Current_Length := Count;\n \n       else\n-         Result.Current_Length := Max_Length;\n-\n          case Drop is\n             when Strings.Right =>\n                Result.Data (1 .. Slen) := Source.Data (1 .. Slen);\n-               Result.Data (Slen + 1 .. Max_Length) := (others => Pad);\n+\n+               if Slen < Max_Length then\n+                  Result.Data (Slen + 1 .. Max_Length) := (others => Pad);\n+               end if;\n \n             when Strings.Left =>\n                if Npad >= Max_Length then\n@@ -871,6 +870,8 @@ package body Ada.Strings.Superbounded is\n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n       end if;\n \n       return Result;\n@@ -885,22 +886,22 @@ package body Ada.Strings.Superbounded is\n       Max_Length : constant Positive := Source.Max_Length;\n       Slen       : constant Natural  := Source.Current_Length;\n       Npad       : constant Integer  := Count - Slen;\n-      Temp       : String (1 .. Max_Length);\n+      Temp       : Super_String_Data (1 .. Max_Length);\n \n    begin\n       if Npad <= 0 then\n          Source.Current_Length := Count;\n \n       elsif Count <= Max_Length then\n-         Source.Current_Length := Count;\n          Source.Data (Slen + 1 .. Count) := (others => Pad);\n+         Source.Current_Length := Count;\n \n       else\n-         Source.Current_Length := Max_Length;\n-\n          case Drop is\n             when Strings.Right =>\n-               Source.Data (Slen + 1 .. Max_Length) := (others => Pad);\n+               if Slen < Max_Length then\n+                  Source.Data (Slen + 1 .. Max_Length) := (others => Pad);\n+               end if;\n \n             when Strings.Left =>\n                if Npad > Max_Length then\n@@ -910,15 +911,15 @@ package body Ada.Strings.Superbounded is\n                   Temp := Source.Data;\n                   Source.Data (1 .. Max_Length - Npad) :=\n                     Temp (Count - Max_Length + 1 .. Slen);\n-\n-                  for J in Max_Length - Npad + 1 .. Max_Length loop\n-                     Source.Data (J) := Pad;\n-                  end loop;\n+                  Source.Data (Max_Length - Npad + 1 .. Max_Length) :=\n+                    (others => Pad);\n                end if;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Source.Current_Length := Max_Length;\n       end if;\n    end Super_Head;\n \n@@ -933,8 +934,7 @@ package body Ada.Strings.Superbounded is\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    is\n    begin\n-      return Search.Index\n-        (Source.Data (1 .. Source.Current_Length), Pattern, Going, Mapping);\n+      return Search.Index (Super_To_String (Source), Pattern, Going, Mapping);\n    end Super_Index;\n \n    function Super_Index\n@@ -944,8 +944,7 @@ package body Ada.Strings.Superbounded is\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    is\n    begin\n-      return Search.Index\n-        (Source.Data (1 .. Source.Current_Length), Pattern, Going, Mapping);\n+      return Search.Index (Super_To_String (Source), Pattern, Going, Mapping);\n    end Super_Index;\n \n    function Super_Index\n@@ -955,8 +954,7 @@ package body Ada.Strings.Superbounded is\n       Going  : Strings.Direction  := Strings.Forward) return Natural\n    is\n    begin\n-      return Search.Index\n-        (Source.Data (1 .. Source.Current_Length), Set, Test, Going);\n+      return Search.Index (Super_To_String (Source), Set, Test, Going);\n    end Super_Index;\n \n    function Super_Index\n@@ -968,8 +966,7 @@ package body Ada.Strings.Superbounded is\n    is\n    begin\n       return Search.Index\n-        (Source.Data (1 .. Source.Current_Length),\n-         Pattern, From, Going, Mapping);\n+        (Super_To_String (Source), Pattern, From, Going, Mapping);\n    end Super_Index;\n \n    function Super_Index\n@@ -981,8 +978,7 @@ package body Ada.Strings.Superbounded is\n    is\n    begin\n       return Search.Index\n-        (Source.Data (1 .. Source.Current_Length),\n-         Pattern, From, Going, Mapping);\n+        (Super_To_String (Source), Pattern, From, Going, Mapping);\n    end Super_Index;\n \n    function Super_Index\n@@ -993,8 +989,15 @@ package body Ada.Strings.Superbounded is\n       Going  : Direction := Forward) return Natural\n    is\n    begin\n-      return Search.Index\n-        (Source.Data (1 .. Source.Current_Length), Set, From, Test, Going);\n+      return Result : Natural do\n+         Result :=\n+           Search.Index (Super_To_String (Source), Set, From, Test, Going);\n+         pragma Assert\n+           (if (for all J in 1 .. Super_Length (Source) =>\n+                  (if J = From or else (J > From) = (Going = Forward) then\n+                     (Test = Inside) /= Maps.Is_In (Source.Data (J), Set)))\n+            then Result = 0);\n+      end return;\n    end Super_Index;\n \n    ---------------------------\n@@ -1006,9 +1009,7 @@ package body Ada.Strings.Superbounded is\n       Going  : Strings.Direction := Strings.Forward) return Natural\n    is\n    begin\n-      return\n-        Search.Index_Non_Blank\n-          (Source.Data (1 .. Source.Current_Length), Going);\n+      return Search.Index_Non_Blank (Super_To_String (Source), Going);\n    end Super_Index_Non_Blank;\n \n    function Super_Index_Non_Blank\n@@ -1017,9 +1018,7 @@ package body Ada.Strings.Superbounded is\n       Going  : Direction := Forward) return Natural\n    is\n    begin\n-      return\n-        Search.Index_Non_Blank\n-          (Source.Data (1 .. Source.Current_Length), From, Going);\n+      return Search.Index_Non_Blank (Super_To_String (Source), From, Going);\n    end Super_Index_Non_Blank;\n \n    ------------------\n@@ -1031,67 +1030,80 @@ package body Ada.Strings.Superbounded is\n       Before   : Positive;\n       New_Item : String;\n       Drop     : Strings.Truncation := Strings.Error) return Super_String\n+   with SPARK_Mode => Off\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n       Slen       : constant Natural := Source.Current_Length;\n       Nlen       : constant Natural := New_Item'Length;\n-      Tlen       : constant Natural := Slen + Nlen;\n       Blen       : constant Natural := Before - 1;\n       Alen       : constant Integer := Slen - Blen;\n-      Droplen    : constant Integer := Tlen - Max_Length;\n+      Droplen    : constant Integer := Slen - Max_Length + Nlen;\n \n-      --  Tlen is the length of the total string before possible truncation.\n       --  Blen, Alen are the lengths of the before and after pieces of the\n-      --  source string.\n+      --  source string. The number of dropped characters is Natural'Max (0,\n+      --  Droplen).\n \n    begin\n       if Alen < 0 then\n          raise Ada.Strings.Index_Error;\n \n       elsif Droplen <= 0 then\n-         Result.Current_Length := Tlen;\n          Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n-         Result.Data (Before .. Before + Nlen - 1) := New_Item;\n-         Result.Data (Before + Nlen .. Tlen) :=\n-           Source.Data (Before .. Slen);\n+         Result.Data (Before .. Before - 1 + Nlen) :=\n+           Super_String_Data (New_Item);\n \n-      else\n-         Result.Current_Length := Max_Length;\n+         if Before <= Slen then\n+            Result.Data (Before + Nlen .. Slen + Nlen) :=\n+              Source.Data (Before .. Slen);\n+         end if;\n \n+         Result.Current_Length := Slen + Nlen;\n+\n+      else\n          case Drop is\n             when Strings.Right =>\n                Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n \n-               if Droplen > Alen then\n-                  Result.Data (Before .. Max_Length) :=\n-                    New_Item (New_Item'First\n-                                .. New_Item'First + Max_Length - Before);\n+               if Droplen >= Alen then\n+                  Result.Data (Before .. Max_Length) := Super_String_Data\n+                    (New_Item (New_Item'First\n+                               .. New_Item'First - Before + Max_Length));\n+                  pragma Assert\n+                    (String (Result.Data (Before .. Max_Length)) =\n+                       New_Item (New_Item'First\n+                                 .. New_Item'First - Before + Max_Length));\n                else\n-                  Result.Data (Before .. Before + Nlen - 1) := New_Item;\n+                  Result.Data (Before .. Before - 1 + Nlen) :=\n+                    Super_String_Data (New_Item);\n                   Result.Data (Before + Nlen .. Max_Length) :=\n                     Source.Data (Before .. Slen - Droplen);\n                end if;\n \n             when Strings.Left =>\n-               Result.Data (Max_Length - (Alen - 1) .. Max_Length) :=\n-                 Source.Data (Before .. Slen);\n+               if Alen > 0 then\n+                  Result.Data (Max_Length - (Alen - 1) .. Max_Length) :=\n+                    Source.Data (Before .. Slen);\n+               end if;\n \n-               if Droplen >= Blen then\n-                  Result.Data (1 .. Max_Length - Alen) :=\n-                    New_Item (New_Item'Last - (Max_Length - Alen) + 1\n-                                .. New_Item'Last);\n+               if Droplen > Blen then\n+                  if Alen < Max_Length then\n+                     Result.Data (1 .. Max_Length - Alen) := Super_String_Data\n+                       (New_Item (New_Item'Last - (Max_Length - Alen) + 1\n+                                  .. New_Item'Last));\n+                  end if;\n                else\n-                  Result.Data\n-                    (Blen - Droplen + 1 .. Max_Length - Alen) :=\n-                    New_Item;\n+                  Result.Data (Blen - Droplen + 1 .. Max_Length - Alen) :=\n+                    Super_String_Data (New_Item);\n                   Result.Data (1 .. Blen - Droplen) :=\n                     Source.Data (Droplen + 1 .. Blen);\n                end if;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n       end if;\n \n       return Result;\n@@ -1111,15 +1123,6 @@ package body Ada.Strings.Superbounded is\n       Source := Super_Insert (Source, Before, New_Item, Drop);\n    end Super_Insert;\n \n-   ------------------\n-   -- Super_Length --\n-   ------------------\n-\n-   function Super_Length (Source : Super_String) return Natural is\n-   begin\n-      return Source.Current_Length;\n-   end Super_Length;\n-\n    ---------------------\n    -- Super_Overwrite --\n    ---------------------\n@@ -1132,61 +1135,61 @@ package body Ada.Strings.Superbounded is\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n-      Endpos     : constant Natural  := Position + New_Item'Length - 1;\n       Slen       : constant Natural  := Source.Current_Length;\n       Droplen    : Natural;\n \n    begin\n-      if Position > Slen + 1 then\n+      if Position - 1 > Slen then\n          raise Ada.Strings.Index_Error;\n \n       elsif New_Item'Length = 0 then\n          return Source;\n \n-      elsif Endpos <= Slen then\n-         Result.Current_Length := Source.Current_Length;\n+      elsif Position - 1 <= Slen - New_Item'Length then\n          Result.Data (1 .. Slen) := Source.Data (1 .. Slen);\n-         Result.Data (Position .. Endpos) := New_Item;\n+         Result.Data (Position .. Position - 1 + New_Item'Length) :=\n+           Super_String_Data (New_Item);\n+         Result.Current_Length := Source.Current_Length;\n          return Result;\n \n-      elsif Endpos <= Max_Length then\n-         Result.Current_Length := Endpos;\n+      elsif Position - 1 <= Max_Length - New_Item'Length then\n          Result.Data (1 .. Position - 1) := Source.Data (1 .. Position - 1);\n-         Result.Data (Position .. Endpos) := New_Item;\n+         Result.Data (Position .. Position - 1 + New_Item'Length) :=\n+           Super_String_Data (New_Item);\n+         Result.Current_Length := Position - 1 + New_Item'Length;\n          return Result;\n \n       else\n-         Result.Current_Length := Max_Length;\n-         Droplen := Endpos - Max_Length;\n+         Droplen := Position - 1 - Max_Length + New_Item'Length;\n \n          case Drop is\n             when Strings.Right =>\n                Result.Data (1 .. Position - 1) :=\n                  Source.Data (1 .. Position - 1);\n \n-               Result.Data (Position .. Max_Length) :=\n-                 New_Item (New_Item'First .. New_Item'Last - Droplen);\n-               return Result;\n+               Result.Data (Position .. Max_Length) := Super_String_Data\n+                 (New_Item (New_Item'First .. New_Item'Last - Droplen));\n \n             when Strings.Left =>\n                if New_Item'Length >= Max_Length then\n-                  Result.Data (1 .. Max_Length) :=\n-                    New_Item (New_Item'Last - Max_Length + 1 ..\n-                                New_Item'Last);\n-                  return Result;\n+                  Result.Data (1 .. Max_Length) := Super_String_Data\n+                    (New_Item (New_Item'Last - Max_Length + 1 ..\n+                                New_Item'Last));\n \n                else\n                   Result.Data (1 .. Max_Length - New_Item'Length) :=\n                     Source.Data (Droplen + 1 .. Position - 1);\n                   Result.Data\n                     (Max_Length - New_Item'Length + 1 .. Max_Length) :=\n-                    New_Item;\n-                  return Result;\n+                    Super_String_Data (New_Item);\n                end if;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n+         return Result;\n       end if;\n    end Super_Overwrite;\n \n@@ -1195,50 +1198,52 @@ package body Ada.Strings.Superbounded is\n       Position  : Positive;\n       New_Item  : String;\n       Drop      : Strings.Truncation := Strings.Error)\n+   with SPARK_Mode => Off\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n-      Endpos     : constant Positive := Position + New_Item'Length - 1;\n       Slen       : constant Natural  := Source.Current_Length;\n       Droplen    : Natural;\n \n    begin\n-      if Position > Slen + 1 then\n+      if Position - 1 > Slen then\n          raise Ada.Strings.Index_Error;\n \n-      elsif Endpos <= Slen then\n-         Source.Data (Position .. Endpos) := New_Item;\n+      elsif Position - 1 <= Slen - New_Item'Length then\n+         Source.Data (Position .. Position - 1 + New_Item'Length) :=\n+           Super_String_Data (New_Item);\n \n-      elsif Endpos <= Max_Length then\n-         Source.Data (Position .. Endpos) := New_Item;\n-         Source.Current_Length := Endpos;\n+      elsif Position - 1 <= Max_Length - New_Item'Length then\n+         Source.Data (Position .. Position - 1 + New_Item'Length) :=\n+           Super_String_Data (New_Item);\n+         Source.Current_Length := Position - 1 + New_Item'Length;\n \n       else\n-         Source.Current_Length := Max_Length;\n-         Droplen := Endpos - Max_Length;\n+         Droplen := Position - 1 - Max_Length + New_Item'Length;\n \n          case Drop is\n             when Strings.Right =>\n-               Source.Data (Position .. Max_Length) :=\n-                 New_Item (New_Item'First .. New_Item'Last - Droplen);\n+               Source.Data (Position .. Max_Length) := Super_String_Data\n+                 (New_Item (New_Item'First .. New_Item'Last - Droplen));\n \n             when Strings.Left =>\n                if New_Item'Length > Max_Length then\n-                  Source.Data (1 .. Max_Length) :=\n-                    New_Item (New_Item'Last - Max_Length + 1 ..\n-                                New_Item'Last);\n+                  Source.Data (1 .. Max_Length) := Super_String_Data\n+                    (New_Item\n+                      (New_Item'Last - Max_Length + 1 .. New_Item'Last));\n \n                else\n                   Source.Data (1 .. Max_Length - New_Item'Length) :=\n                     Source.Data (Droplen + 1 .. Position - 1);\n-\n                   Source.Data\n                     (Max_Length - New_Item'Length + 1 .. Max_Length) :=\n-                    New_Item;\n+                    Super_String_Data (New_Item);\n                end if;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Source.Current_Length := Max_Length;\n       end if;\n    end Super_Overwrite;\n \n@@ -1269,71 +1274,81 @@ package body Ada.Strings.Superbounded is\n       High   : Natural;\n       By     : String;\n       Drop   : Strings.Truncation := Strings.Error) return Super_String\n+   with SPARK_Mode => Off\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Slen       : constant Natural  := Source.Current_Length;\n \n    begin\n-      if Low > Slen + 1 then\n+      if Low - 1 > Slen then\n          raise Strings.Index_Error;\n \n       elsif High < Low then\n          return Super_Insert (Source, Low, By, Drop);\n \n       else\n          declare\n-            Blen    : constant Natural := Natural'Max (0, Low - 1);\n+            Blen    : constant Natural := Low - 1;\n             Alen    : constant Natural := Natural'Max (0, Slen - High);\n-            Tlen    : constant Natural := Blen + By'Length + Alen;\n-            Droplen : constant Integer := Tlen - Max_Length;\n+            Droplen : constant Integer := Blen + Alen - Max_Length + By'Length;\n             Result  : Super_String (Max_Length);\n \n-            --  Tlen is the total length of the result string before any\n-            --  truncation. Blen and Alen are the lengths of the pieces\n-            --  of the original string that end up in the result string\n-            --  before and after the replaced slice.\n+            --  Blen and Alen are the lengths of the pieces of the original\n+            --  string that end up in the result string before and after the\n+            --  replaced slice. The number of dropped characters is Natural'Max\n+            --  (0, Droplen).\n \n          begin\n             if Droplen <= 0 then\n-               Result.Current_Length := Tlen;\n                Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n-               Result.Data (Low .. Low + By'Length - 1) := By;\n-               Result.Data (Low + By'Length .. Tlen) :=\n-                 Source.Data (High + 1 .. Slen);\n+               Result.Data (Low .. Blen + By'Length) :=\n+                 Super_String_Data (By);\n \n-            else\n-               Result.Current_Length := Max_Length;\n+               if Alen > 0 then\n+                  Result.Data (Low + By'Length .. Blen + By'Length + Alen) :=\n+                    Source.Data (High + 1 .. Slen);\n+               end if;\n \n+               Result.Current_Length := Blen + By'Length + Alen;\n+\n+            else\n                case Drop is\n                   when Strings.Right =>\n                      Result.Data (1 .. Blen) := Source.Data (1 .. Blen);\n \n-                     if Droplen > Alen then\n-                        Result.Data (Low .. Max_Length) :=\n-                          By (By'First .. By'First + Max_Length - Low);\n+                     if Droplen >= Alen then\n+                        Result.Data (Low .. Max_Length) := Super_String_Data\n+                          (By (By'First .. By'First - Low + Max_Length));\n                      else\n-                        Result.Data (Low .. Low + By'Length - 1) := By;\n+                        Result.Data (Low .. Low - 1 + By'Length) :=\n+                          Super_String_Data (By);\n                         Result.Data (Low + By'Length .. Max_Length) :=\n                           Source.Data (High + 1 .. Slen - Droplen);\n                      end if;\n \n                   when Strings.Left =>\n-                     Result.Data (Max_Length - (Alen - 1) .. Max_Length) :=\n-                       Source.Data (High + 1 .. Slen);\n+                     if Alen > 0 then\n+                        Result.Data (Max_Length - (Alen - 1) .. Max_Length) :=\n+                          Source.Data (High + 1 .. Slen);\n+                     end if;\n \n                      if Droplen >= Blen then\n                         Result.Data (1 .. Max_Length - Alen) :=\n-                          By (By'Last - (Max_Length - Alen) + 1 .. By'Last);\n+                          Super_String_Data (By\n+                            (By'Last - (Max_Length - Alen) + 1 .. By'Last));\n                      else\n                         Result.Data\n-                          (Blen - Droplen + 1 .. Max_Length - Alen) := By;\n+                          (Blen - Droplen + 1 .. Max_Length - Alen) :=\n+                            Super_String_Data (By);\n                         Result.Data (1 .. Blen - Droplen) :=\n                           Source.Data (Droplen + 1 .. Blen);\n                      end if;\n \n                   when Strings.Error =>\n                      raise Ada.Strings.Length_Error;\n                end case;\n+\n+               Result.Current_Length := Max_Length;\n             end if;\n \n             return Result;\n@@ -1370,16 +1385,17 @@ package body Ada.Strings.Superbounded is\n \n    begin\n       if Count <= Max_Length then\n+         Result.Data (1 .. Count) := (others => Item);\n          Result.Current_Length := Count;\n \n       elsif Drop = Strings.Error then\n          raise Ada.Strings.Length_Error;\n \n       else\n+         Result.Data (1 .. Max_Length) := (others => Item);\n          Result.Current_Length := Max_Length;\n       end if;\n \n-      Result.Data (1 .. Result.Current_Length) := (others => Item);\n       return Result;\n    end Super_Replicate;\n \n@@ -1389,52 +1405,203 @@ package body Ada.Strings.Superbounded is\n       Drop       : Truncation := Error;\n       Max_Length : Positive) return Super_String\n    is\n-      Length : constant Integer := Count * Item'Length;\n       Result : Super_String (Max_Length);\n-      Indx   : Positive;\n+      Indx   : Natural;\n+      Ilen   : constant Natural := Item'Length;\n+\n+      --  Parts of the proof involving manipulations with the modulo operator\n+      --  are complicated for the prover and can't be done automatically in\n+      --  the global subprogram. That's why we isolate them in these two ghost\n+      --  lemmas.\n+\n+      procedure Lemma_Mod (K : Natural; Q : Natural) with\n+        Ghost,\n+        Pre  => Ilen /= 0\n+          and then Q mod Ilen = 0\n+          and then K - Q in 0 .. Ilen - 1,\n+        Post => K mod Ilen = K - Q;\n+      --  Lemma_Mod is applied to an index considered in Lemma_Split to prove\n+      --  that it has the right value modulo Item'Length.\n+\n+      procedure Lemma_Mod_Zero (X : Natural) with\n+        Ghost,\n+        Pre  => Ilen /= 0\n+          and then X mod Ilen = 0\n+          and then X <= Natural'Last - Ilen,\n+        Post => (X + Ilen) mod Ilen = 0;\n+      --  Lemma_Mod_Zero is applied to prove that the length of the range\n+      --  of indexes considered in the loop, when dropping on the Left, is\n+      --  a multiple of Item'Length.\n+\n+      procedure Lemma_Split (Going : Direction) with\n+        Ghost,\n+        Pre  =>\n+          Ilen /= 0\n+            and then Indx in 0 .. Max_Length - Ilen\n+            and then\n+              (if Going = Forward\n+               then Indx mod Ilen = 0\n+               else (Max_Length - Indx - Ilen) mod Ilen = 0)\n+            and then Result.Data (Indx + 1 .. Indx + Ilen)'Initialized\n+            and then String (Result.Data (Indx + 1 .. Indx + Ilen)) = Item,\n+        Post =>\n+          (if Going = Forward then\n+             (for all J in Indx + 1 .. Indx + Ilen =>\n+                Result.Data (J) = Item (Item'First + (J - 1) mod Ilen))\n+           else\n+             (for all J in Indx + 1 .. Indx + Ilen =>\n+                Result.Data (J) =\n+                  Item (Item'Last - (Max_Length - J) mod Ilen)));\n+      --  Lemma_Split is used after Result.Data (Indx + 1 .. Indx + Ilen) is\n+      --  updated to Item and concludes that the characters match for each\n+      --  index when taken modulo Item'Length, as the considered slice starts\n+      --  at index 1 (or ends at index Max_Length, if Going = Backward) modulo\n+      --  Item'Length.\n+\n+      ---------------\n+      -- Lemma_Mod --\n+      ---------------\n+\n+      procedure Lemma_Mod (K : Natural; Q : Natural) is null;\n+\n+      --------------------\n+      -- Lemma_Mod_Zero --\n+      --------------------\n+\n+      procedure Lemma_Mod_Zero (X : Natural) is null;\n+\n+      -----------------\n+      -- Lemma_Split --\n+      -----------------\n+\n+      procedure Lemma_Split (Going : Direction) is\n+      begin\n+         if Going = Forward then\n+            for K in Indx + 1 .. Indx + Ilen loop\n+               Lemma_Mod (K - 1, Indx);\n+               pragma Loop_Invariant\n+                 (for all J in Indx + 1 .. K =>\n+                    Result.Data (J) = Item (Item'First + (J - 1) mod Ilen));\n+            end loop;\n+         else\n+            for K in Indx + 1 .. Indx + Ilen loop\n+               Lemma_Mod (Max_Length - K, Max_Length - Indx - Ilen);\n+               pragma Loop_Invariant\n+                 (for all J in Indx + 1 .. K =>\n+                    Result.Data (J) =\n+                      Item (Item'Last - (Max_Length - J) mod Ilen));\n+            end loop;\n+         end if;\n+      end Lemma_Split;\n \n    begin\n-      if Length <= Max_Length then\n-         Result.Current_Length := Length;\n-\n-         if Length > 0 then\n-            Indx := 1;\n+      if Count = 0 or else Ilen <= Max_Length / Count then\n+         if Count * Ilen > 0 then\n+            Indx := 0;\n \n             for J in 1 .. Count loop\n-               Result.Data (Indx .. Indx + Item'Length - 1) := Item;\n-               Indx := Indx + Item'Length;\n+               Result.Data (Indx + 1 .. Indx + Ilen) :=\n+                 Super_String_Data (Item);\n+               pragma Assert\n+                 (for all K in 1 .. Ilen =>\n+                    Result.Data (Indx + K) = Item (Item'First - 1 + K));\n+               pragma Assert\n+                 (String (Result.Data (Indx + 1 .. Indx + Ilen)) = Item);\n+               Lemma_Split (Forward);\n+               Indx := Indx + Ilen;\n+               pragma Loop_Invariant (Indx = J * Ilen);\n+               pragma Loop_Invariant (Result.Data (1 .. Indx)'Initialized);\n+               pragma Loop_Invariant\n+                 (for all K in 1 .. Indx =>\n+                    Result.Data (K) =\n+                      Item (Item'First + (K - 1) mod Ilen));\n             end loop;\n          end if;\n \n-      else\n-         Result.Current_Length := Max_Length;\n+         Result.Current_Length := Count * Ilen;\n \n+      else\n          case Drop is\n             when Strings.Right =>\n-               Indx := 1;\n-\n-               while Indx + Item'Length <= Max_Length + 1 loop\n-                  Result.Data (Indx .. Indx + Item'Length - 1) := Item;\n-                  Indx := Indx + Item'Length;\n+               Indx := 0;\n+\n+               while Indx < Max_Length - Ilen loop\n+                  Result.Data (Indx + 1 .. Indx + Ilen) :=\n+                    Super_String_Data (Item);\n+                  pragma Assert\n+                    (for all K in 1 .. Ilen =>\n+                       Result.Data (Indx + K) = Item (Item'First - 1 + K));\n+                  pragma Assert\n+                    (String (Result.Data (Indx + 1 .. Indx + Ilen)) = Item);\n+                  Lemma_Split (Forward);\n+                  Indx := Indx + Ilen;\n+                  pragma Loop_Invariant (Indx mod Ilen = 0);\n+                  pragma Loop_Invariant (Indx in 0 .. Max_Length - 1);\n+                  pragma Loop_Invariant (Result.Data (1 .. Indx)'Initialized);\n+                  pragma Loop_Invariant\n+                    (for all K in 1 .. Indx =>\n+                       Result.Data (K) =\n+                         Item (Item'First + (K - 1) mod Ilen));\n                end loop;\n \n-               Result.Data (Indx .. Max_Length) :=\n-                 Item (Item'First .. Item'First + Max_Length - Indx);\n+               Result.Data (Indx + 1 .. Max_Length) := Super_String_Data\n+                 (Item (Item'First .. Item'First + (Max_Length - Indx - 1)));\n+               pragma Assert\n+                 (for all J in Indx + 1 .. Max_Length =>\n+                    Result.Data (J) = Item (Item'First - 1 - Indx + J));\n+\n+               for J in Indx + 1 .. Max_Length loop\n+                  Lemma_Mod (J - 1, Indx);\n+                  pragma Loop_Invariant\n+                    (for all K in 1 .. J =>\n+                       Result.Data (K) =\n+                         Item (Item'First + (K - 1) mod Ilen));\n+               end loop;\n \n             when Strings.Left =>\n                Indx := Max_Length;\n \n-               while Indx - Item'Length >= 1 loop\n-                  Result.Data (Indx - (Item'Length - 1) .. Indx) := Item;\n-                  Indx := Indx - Item'Length;\n+               while Indx > Ilen loop\n+                  Indx := Indx - Ilen;\n+                  Result.Data (Indx + 1 .. Indx + Ilen) :=\n+                    Super_String_Data (Item);\n+                  pragma Assert\n+                    (for all K in 1 .. Ilen =>\n+                       Result.Data (Indx + K) = Item (Item'First - 1 + K));\n+                  pragma Assert\n+                    (String (Result.Data (Indx + 1 .. Indx + Ilen)) = Item);\n+                  Lemma_Split (Backward);\n+                  Lemma_Mod_Zero (Max_Length - Indx - Ilen);\n+                  pragma Loop_Invariant\n+                    ((Max_Length - Indx) mod Ilen = 0);\n+                  pragma Loop_Invariant (Indx in 1 .. Max_Length);\n+                  pragma Loop_Invariant\n+                    (Result.Data (Indx + 1 .. Max_Length)'Initialized);\n+                  pragma Loop_Invariant\n+                    (for all K in Indx + 1 .. Max_Length =>\n+                       Result.Data (K) =\n+                         Item (Item'Last - (Max_Length - K) mod Ilen));\n                end loop;\n \n                Result.Data (1 .. Indx) :=\n-                 Item (Item'Last - Indx + 1 .. Item'Last);\n+                 Super_String_Data (Item (Item'Last - Indx + 1 .. Item'Last));\n+               pragma Assert\n+                 (for all J in 1 .. Indx =>\n+                    Result.Data (J) = Item (Item'Last - Indx + J));\n+\n+               for J in reverse 1 .. Indx loop\n+                  Lemma_Mod (Max_Length - J, Max_Length - Indx);\n+                  pragma Loop_Invariant\n+                    (for all K in J .. Max_Length =>\n+                       Result.Data (K) =\n+                         Item (Item'Last - (Max_Length - K) mod Ilen));\n+               end loop;\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n       end if;\n \n       return Result;\n@@ -1447,56 +1614,30 @@ package body Ada.Strings.Superbounded is\n    is\n    begin\n       return\n-        Super_Replicate\n-          (Count,\n-           Item.Data (1 .. Item.Current_Length),\n-           Drop,\n-           Item.Max_Length);\n+        Super_Replicate (Count, Super_To_String (Item), Drop, Item.Max_Length);\n    end Super_Replicate;\n \n    -----------------\n    -- Super_Slice --\n    -----------------\n \n-   function Super_Slice\n-     (Source : Super_String;\n-      Low    : Positive;\n-      High   : Natural) return String\n-   is\n-   begin\n-      --  Note: test of High > Length is in accordance with AI95-00128\n-\n-      return R : String (Low .. High) do\n-         if Low > Source.Current_Length + 1\n-           or else High > Source.Current_Length\n-         then\n-            raise Index_Error;\n-         end if;\n-\n-         --  Note: in this case, superflat bounds are not a problem, we just\n-         --  get the null string in accordance with normal Ada slice rules.\n-\n-         R := Source.Data (Low .. High);\n-      end return;\n-   end Super_Slice;\n-\n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n       High   : Natural) return Super_String\n    is\n    begin\n       return Result : Super_String (Source.Max_Length) do\n-         if Low > Source.Current_Length + 1\n+         if Low - 1 > Source.Current_Length\n            or else High > Source.Current_Length\n          then\n             raise Index_Error;\n          end if;\n \n-         --  Note: the Max operation here deals with the superflat case\n-\n-         Result.Current_Length := Integer'Max (0, High - Low + 1);\n-         Result.Data (1 .. Result.Current_Length) := Source.Data (Low .. High);\n+         if High >= Low then\n+            Result.Data (1 .. High - Low + 1) := Source.Data (Low .. High);\n+            Result.Current_Length := High - Low + 1;\n+         end if;\n       end return;\n    end Super_Slice;\n \n@@ -1507,16 +1648,18 @@ package body Ada.Strings.Superbounded is\n       High   : Natural)\n    is\n    begin\n-      if Low > Source.Current_Length + 1\n+      if Low - 1 > Source.Current_Length\n         or else High > Source.Current_Length\n       then\n          raise Index_Error;\n       end if;\n \n-      --  Note: the Max operation here deals with the superflat case\n-\n-      Target.Current_Length := Integer'Max (0, High - Low + 1);\n-      Target.Data (1 .. Target.Current_Length) := Source.Data (Low .. High);\n+      if High >= Low then\n+         Target.Data (1 .. High - Low + 1) := Source.Data (Low .. High);\n+         Target.Current_Length := High - Low + 1;\n+      else\n+         Target.Current_Length := 0;\n+      end if;\n    end Super_Slice;\n \n    ----------------\n@@ -1536,18 +1679,22 @@ package body Ada.Strings.Superbounded is\n \n    begin\n       if Npad <= 0 then\n-         Result.Current_Length := Count;\n-         Result.Data (1 .. Count) :=\n-           Source.Data (Slen - (Count - 1) .. Slen);\n+         if Count > 0 then\n+            Result.Data (1 .. Count) :=\n+              Source.Data (Slen - (Count - 1) .. Slen);\n+            Result.Current_Length := Count;\n+         end if;\n \n       elsif Count <= Max_Length then\n-         Result.Current_Length := Count;\n          Result.Data (1 .. Npad) := (others => Pad);\n-         Result.Data (Npad + 1 .. Count) := Source.Data (1 .. Slen);\n \n-      else\n-         Result.Current_Length := Max_Length;\n+         if Slen > 0 then\n+            Result.Data (Npad + 1 .. Count) := Source.Data (1 .. Slen);\n+         end if;\n+\n+         Result.Current_Length := Count;\n \n+      else\n          case Drop is\n             when Strings.Right =>\n                if Npad >= Max_Length then\n@@ -1567,6 +1714,8 @@ package body Ada.Strings.Superbounded is\n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Result.Current_Length := Max_Length;\n       end if;\n \n       return Result;\n@@ -1582,22 +1731,27 @@ package body Ada.Strings.Superbounded is\n       Slen       : constant Natural  := Source.Current_Length;\n       Npad       : constant Integer  := Count - Slen;\n \n-      Temp : constant String (1 .. Max_Length) := Source.Data;\n+      Temp : constant Super_String_Data (1 .. Max_Length) := Source.Data;\n \n    begin\n       if Npad <= 0 then\n          Source.Current_Length := Count;\n-         Source.Data (1 .. Count) :=\n-           Temp (Slen - (Count - 1) .. Slen);\n+\n+         if Count > 0 then\n+            Source.Data (1 .. Count) :=\n+              Temp (Slen - (Count - 1) .. Slen);\n+         end if;\n \n       elsif Count <= Max_Length then\n-         Source.Current_Length := Count;\n          Source.Data (1 .. Npad) := (others => Pad);\n-         Source.Data (Npad + 1 .. Count) := Temp (1 .. Slen);\n \n-      else\n-         Source.Current_Length := Max_Length;\n+         if Slen > 0 then\n+            Source.Data (Npad + 1 .. Count) := Temp (1 .. Slen);\n+         end if;\n \n+         Source.Current_Length := Count;\n+\n+      else\n          case Drop is\n             when Strings.Right =>\n                if Npad >= Max_Length then\n@@ -1610,30 +1764,18 @@ package body Ada.Strings.Superbounded is\n                end if;\n \n             when Strings.Left =>\n-               for J in 1 .. Max_Length - Slen loop\n-                  Source.Data (J) := Pad;\n-               end loop;\n-\n+               Source.Data (1 .. Max_Length - Slen) := (others => Pad);\n                Source.Data (Max_Length - Slen + 1 .. Max_Length) :=\n                  Temp (1 .. Slen);\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;\n          end case;\n+\n+         Source.Current_Length := Max_Length;\n       end if;\n    end Super_Tail;\n \n-   ---------------------\n-   -- Super_To_String --\n-   ---------------------\n-\n-   function Super_To_String (Source : Super_String) return String is\n-   begin\n-      return R : String (1 .. Source.Current_Length) do\n-         R := Source.Data (1 .. Source.Current_Length);\n-      end return;\n-   end Super_To_String;\n-\n    ---------------------\n    -- Super_Translate --\n    ---------------------\n@@ -1645,12 +1787,15 @@ package body Ada.Strings.Superbounded is\n       Result : Super_String (Source.Max_Length);\n \n    begin\n-      Result.Current_Length := Source.Current_Length;\n-\n       for J in 1 .. Source.Current_Length loop\n          Result.Data (J) := Value (Mapping, Source.Data (J));\n+         pragma Loop_Invariant (Result.Data (1 .. J)'Initialized);\n+         pragma Loop_Invariant\n+           (for all K in 1 .. J =>\n+              Result.Data (K) = Value (Mapping, Source.Data (K)));\n       end loop;\n \n+      Result.Current_Length := Source.Current_Length;\n       return Result;\n    end Super_Translate;\n \n@@ -1661,6 +1806,9 @@ package body Ada.Strings.Superbounded is\n    begin\n       for J in 1 .. Source.Current_Length loop\n          Source.Data (J) := Value (Mapping, Source.Data (J));\n+         pragma Loop_Invariant\n+           (for all K in 1 .. J =>\n+              Source.Data (K) = Value (Mapping, Source'Loop_Entry.Data (K)));\n       end loop;\n    end Super_Translate;\n \n@@ -1671,12 +1819,15 @@ package body Ada.Strings.Superbounded is\n       Result : Super_String (Source.Max_Length);\n \n    begin\n-      Result.Current_Length := Source.Current_Length;\n-\n       for J in 1 .. Source.Current_Length loop\n          Result.Data (J) := Mapping.all (Source.Data (J));\n+         pragma Loop_Invariant (Result.Data (1 .. J)'Initialized);\n+         pragma Loop_Invariant\n+           (for all K in 1 .. J =>\n+              Result.Data (K) = Mapping (Source.Data (K)));\n       end loop;\n \n+      Result.Current_Length := Source.Current_Length;\n       return Result;\n    end Super_Translate;\n \n@@ -1687,6 +1838,9 @@ package body Ada.Strings.Superbounded is\n    begin\n       for J in 1 .. Source.Current_Length loop\n          Source.Data (J) := Mapping.all (Source.Data (J));\n+         pragma Loop_Invariant\n+           (for all K in 1 .. J =>\n+              Source.Data (K) = Mapping (Source'Loop_Entry.Data (K)));\n       end loop;\n    end Super_Translate;\n \n@@ -1699,53 +1853,117 @@ package body Ada.Strings.Superbounded is\n       Side   : Trim_End) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n-      Last   : Natural := Source.Current_Length;\n-      First  : Positive := 1;\n+      Last   : constant Natural := Source.Current_Length;\n \n    begin\n-      if Side = Left or else Side = Both then\n-         while First <= Last and then Source.Data (First) = ' ' loop\n-            First := First + 1;\n-         end loop;\n-      end if;\n+      case Side is\n+         when Strings.Left =>\n+            declare\n+               Low : constant Natural :=\n+                 Super_Index_Non_Blank (Source, Forward);\n+            begin\n+               --  All blanks case\n \n-      if Side = Right or else Side = Both then\n-         while Last >= First and then Source.Data (Last) = ' ' loop\n-            Last := Last - 1;\n-         end loop;\n-      end if;\n+               if Low = 0 then\n+                  return Result;\n+               end if;\n+\n+               Result.Data (1 .. Last - Low + 1) := Source.Data (Low .. Last);\n+               Result.Current_Length := Last - Low + 1;\n+            end;\n+\n+         when Strings.Right =>\n+            declare\n+               High : constant Natural :=\n+                 Super_Index_Non_Blank (Source, Backward);\n+            begin\n+               --  All blanks case\n+\n+               if High = 0 then\n+                  return Result;\n+               end if;\n+\n+               Result.Data (1 .. High) := Source.Data (1 .. High);\n+               Result.Current_Length := High;\n+            end;\n+\n+         when Strings.Both =>\n+            declare\n+               Low : constant Natural :=\n+                 Super_Index_Non_Blank (Source, Forward);\n+            begin\n+               --  All blanks case\n+\n+               if Low = 0 then\n+                  return Result;\n+               end if;\n+\n+               declare\n+                  High : constant Natural :=\n+                    Super_Index_Non_Blank (Source, Backward);\n+               begin\n+                  Result.Data (1 .. High - Low + 1) :=\n+                    Source.Data (Low .. High);\n+                  Result.Current_Length := High - Low + 1;\n+               end;\n+            end;\n+      end case;\n \n-      Result.Current_Length := Last - First + 1;\n-      Result.Data (1 .. Result.Current_Length) := Source.Data (First .. Last);\n       return Result;\n    end Super_Trim;\n \n    procedure Super_Trim\n      (Source : in out Super_String;\n       Side   : Trim_End)\n    is\n-      Max_Length : constant Positive := Source.Max_Length;\n-      Last       : Natural           := Source.Current_Length;\n-      First      : Positive          := 1;\n-      Temp       : String (1 .. Max_Length);\n-\n+      Last : constant Natural := Source.Current_Length;\n    begin\n-      Temp (1 .. Last) := Source.Data (1 .. Last);\n-\n-      if Side = Left or else Side = Both then\n-         while First <= Last and then Temp (First) = ' ' loop\n-            First := First + 1;\n-         end loop;\n-      end if;\n+      case Side is\n+         when Strings.Left =>\n+            declare\n+               Low : constant Natural :=\n+                 Super_Index_Non_Blank (Source, Forward);\n+            begin\n+               --  All blanks case\n \n-      if Side = Right or else Side = Both then\n-         while Last >= First and then Temp (Last) = ' ' loop\n-            Last := Last - 1;\n-         end loop;\n-      end if;\n-\n-      Source.Current_Length := Last - First + 1;\n-      Source.Data (1 .. Source.Current_Length) := Temp (First .. Last);\n+               if Low = 0 then\n+                  Source.Current_Length := 0;\n+               else\n+                  Source.Data (1 .. Last - Low + 1) :=\n+                    Source.Data (Low .. Last);\n+                  Source.Current_Length := Last - Low + 1;\n+               end if;\n+            end;\n+\n+         when Strings.Right =>\n+            declare\n+               High : constant Natural :=\n+                 Super_Index_Non_Blank (Source, Backward);\n+            begin\n+               Source.Current_Length := High;\n+            end;\n+\n+         when Strings.Both =>\n+            declare\n+               Low : constant Natural :=\n+                 Super_Index_Non_Blank (Source, Forward);\n+            begin\n+               --  All blanks case\n+\n+               if Low = 0 then\n+                  Source.Current_Length := 0;\n+               else\n+                  declare\n+                     High : constant Natural :=\n+                       Super_Index_Non_Blank (Source, Backward);\n+                  begin\n+                     Source.Data (1 .. High - Low + 1) :=\n+                       Source.Data (Low .. High);\n+                     Source.Current_Length := High - Low + 1;\n+                  end;\n+               end if;\n+            end;\n+      end case;\n    end Super_Trim;\n \n    function Super_Trim\n@@ -1754,22 +1972,31 @@ package body Ada.Strings.Superbounded is\n       Right  : Maps.Character_Set) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n+      Low    : Natural;\n+      High   : Natural;\n \n    begin\n-      for First in 1 .. Source.Current_Length loop\n-         if not Is_In (Source.Data (First), Left) then\n-            for Last in reverse First .. Source.Current_Length loop\n-               if not Is_In (Source.Data (Last), Right) then\n-                  Result.Current_Length := Last - First + 1;\n-                  Result.Data (1 .. Result.Current_Length) :=\n-                    Source.Data (First .. Last);\n-                  return Result;\n-               end if;\n-            end loop;\n-         end if;\n-      end loop;\n+      Low := Super_Index (Source, Left, Outside, Forward);\n+\n+      --  Case where source comprises only characters in Left\n+\n+      if Low = 0 then\n+         return Result;\n+      end if;\n+\n+      High := Super_Index (Source, Right, Outside, Backward);\n+\n+      --  Case where source comprises only characters in Right\n+\n+      if High = 0 then\n+         return Result;\n+      end if;\n+\n+      if High >= Low then\n+         Result.Data (1 .. High - Low + 1) := Source.Data (Low .. High);\n+         Result.Current_Length := High - Low + 1;\n+      end if;\n \n-      Result.Current_Length := 0;\n       return Result;\n    end Super_Trim;\n \n@@ -1778,29 +2005,39 @@ package body Ada.Strings.Superbounded is\n       Left   : Maps.Character_Set;\n       Right  : Maps.Character_Set)\n    is\n+      Last : constant Natural := Source.Current_Length;\n+      Temp : Super_String_Data (1 .. Last);\n+      Low  : Natural;\n+      High : Natural;\n+\n    begin\n-      for First in 1 .. Source.Current_Length loop\n-         if not Is_In (Source.Data (First), Left) then\n-            for Last in reverse First .. Source.Current_Length loop\n-               if not Is_In (Source.Data (Last), Right) then\n-                  if First = 1 then\n-                     Source.Current_Length := Last;\n-                     return;\n-                  else\n-                     Source.Current_Length := Last - First + 1;\n-                     Source.Data (1 .. Source.Current_Length) :=\n-                       Source.Data (First .. Last);\n-                     return;\n-                  end if;\n-               end if;\n-            end loop;\n+      Temp := Source.Data (1 .. Last);\n+      Low := Super_Index (Source, Left, Outside, Forward);\n+\n+      --  Case where source comprises only characters in Left\n+\n+      if Low = 0 then\n+         Source.Current_Length := 0;\n+\n+      else\n+         High := Super_Index (Source, Right, Outside, Backward);\n \n+         --  Case where source comprises only characters in Right\n+\n+         if High = 0 then\n             Source.Current_Length := 0;\n-            return;\n-         end if;\n-      end loop;\n \n-      Source.Current_Length := 0;\n+         elsif Low = 1 then\n+            Source.Current_Length := High;\n+\n+         elsif High < Low then\n+            Source.Current_Length := 0;\n+\n+         else\n+            Source.Data (1 .. High - Low + 1) := Temp (Low .. High);\n+            Source.Current_Length := High - Low + 1;\n+         end if;\n+      end if;\n    end Super_Trim;\n \n    -----------\n@@ -1819,11 +2056,14 @@ package body Ada.Strings.Superbounded is\n          raise Ada.Strings.Length_Error;\n \n       else\n-         Result.Current_Length := Left;\n-\n          for J in 1 .. Left loop\n             Result.Data (J) := Right;\n+            pragma Loop_Invariant (Result.Data (1 .. J)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in 1 .. J => Result.Data (K) = Right);\n          end loop;\n+\n+         Result.Current_Length := Left;\n       end if;\n \n       return Result;\n@@ -1835,23 +2075,88 @@ package body Ada.Strings.Superbounded is\n       Max_Length : Positive) return Super_String\n    is\n       Result : Super_String (Max_Length);\n-      Pos    : Positive         := 1;\n+      Pos    : Natural          := 0;\n       Rlen   : constant Natural := Right'Length;\n       Nlen   : constant Natural := Left * Rlen;\n \n+      --  Parts of the proof involving manipulations with the modulo operator\n+      --  are complicated for the prover and can't be done automatically in\n+      --  the global subprogram. That's why we isolate them in these two ghost\n+      --  lemmas.\n+\n+      procedure Lemma_Mod (K : Integer) with\n+        Ghost,\n+        Pre =>\n+          Rlen /= 0\n+          and then Pos mod Rlen = 0\n+          and then Pos in 0 .. Max_Length - Rlen\n+          and then K in Pos .. Pos + Rlen - 1,\n+        Post => K mod Rlen = K - Pos;\n+      --  Lemma_Mod is applied to an index considered in Lemma_Split to prove\n+      --  that it has the right value modulo Right'Length.\n+\n+      procedure Lemma_Split with\n+        Ghost,\n+        Pre  =>\n+          Rlen /= 0\n+            and then Pos mod Rlen = 0\n+            and then Pos in 0 .. Max_Length - Rlen\n+            and then Result.Data (1 .. Pos + Rlen)'Initialized\n+            and then String (Result.Data (Pos + 1 .. Pos + Rlen)) = Right,\n+        Post =>\n+          (for all K in Pos + 1 .. Pos + Rlen =>\n+            Result.Data (K) = Right (Right'First + (K - 1) mod Rlen));\n+      --  Lemma_Split is used after Result.Data (Pos + 1 .. Pos + Rlen) is\n+      --  updated to Right and concludes that the characters match for each\n+      --  index when taken modulo Right'Length, as the considered slice starts\n+      --  at index 1 modulo Right'Length.\n+\n+      ---------------\n+      -- Lemma_Mod --\n+      ---------------\n+\n+      procedure Lemma_Mod (K : Integer) is null;\n+\n+      -----------------\n+      -- Lemma_Split --\n+      -----------------\n+\n+      procedure Lemma_Split is\n+      begin\n+         for K in Pos + 1 .. Pos + Rlen loop\n+            Lemma_Mod (K - 1);\n+            pragma Loop_Invariant\n+              (for all J in Pos + 1 .. K =>\n+                 Result.Data (J) = Right (Right'First + (J - 1) mod Rlen));\n+         end loop;\n+      end Lemma_Split;\n+\n    begin\n       if Nlen > Max_Length then\n          raise Ada.Strings.Length_Error;\n \n       else\n-         Result.Current_Length := Nlen;\n-\n          if Nlen > 0 then\n             for J in 1 .. Left loop\n-               Result.Data (Pos .. Pos + Rlen - 1) := Right;\n+               Result.Data (Pos + 1 .. Pos + Rlen) :=\n+                 Super_String_Data (Right);\n+               pragma Assert\n+                 (for all K in 1 .. Rlen => Result.Data (Pos + K) =\n+                    Right (Right'First - 1 + K));\n+               pragma Assert\n+                 (String (Result.Data (Pos + 1 .. Pos + Rlen)) = Right);\n+               Lemma_Split;\n                Pos := Pos + Rlen;\n+               pragma Loop_Invariant (Pos = J * Rlen);\n+               pragma Loop_Invariant (Result.Data (1 .. Pos)'Initialized);\n+               pragma Loop_Invariant\n+                 (for all K in 1 .. Pos =>\n+                    Result.Data (K) =\n+                      Right (Right'First + (K - 1) mod Rlen));\n             end loop;\n          end if;\n+\n+         Result.Current_Length := Nlen;\n       end if;\n \n       return Result;\n@@ -1862,7 +2167,7 @@ package body Ada.Strings.Superbounded is\n       Right : Super_String) return Super_String\n    is\n       Result : Super_String (Right.Max_Length);\n-      Pos    : Positive := 1;\n+      Pos    : Natural          := 0;\n       Rlen   : constant Natural := Right.Current_Length;\n       Nlen   : constant Natural := Left * Rlen;\n \n@@ -1871,15 +2176,21 @@ package body Ada.Strings.Superbounded is\n          raise Ada.Strings.Length_Error;\n \n       else\n-         Result.Current_Length := Nlen;\n-\n          if Nlen > 0 then\n             for J in 1 .. Left loop\n-               Result.Data (Pos .. Pos + Rlen - 1) :=\n+               Result.Data (Pos + 1 .. Pos + Rlen) :=\n                  Right.Data (1 .. Rlen);\n                Pos := Pos + Rlen;\n+               pragma Loop_Invariant (Pos = J * Rlen);\n+               pragma Loop_Invariant (Result.Data (1 .. Pos)'Initialized);\n+               pragma Loop_Invariant\n+                 (for all K in 1 .. Pos =>\n+                    Result.Data (K) =\n+                      Right.Data (1 + (K - 1) mod Rlen));\n             end loop;\n          end if;\n+\n+         Result.Current_Length := Nlen;\n       end if;\n \n       return Result;\n@@ -1891,28 +2202,28 @@ package body Ada.Strings.Superbounded is\n \n    function To_Super_String\n      (Source     : String;\n-      Max_Length : Natural;\n+      Max_Length : Positive;\n       Drop       : Truncation := Error) return Super_String\n    is\n       Result : Super_String (Max_Length);\n       Slen   : constant Natural := Source'Length;\n \n    begin\n       if Slen <= Max_Length then\n+         Result.Data (1 .. Slen) := Super_String_Data (Source);\n          Result.Current_Length := Slen;\n-         Result.Data (1 .. Slen) := Source;\n \n       else\n          case Drop is\n             when Strings.Right =>\n+               Result.Data (1 .. Max_Length) := Super_String_Data\n+                 (Source (Source'First .. Source'First - 1 + Max_Length));\n                Result.Current_Length := Max_Length;\n-               Result.Data (1 .. Max_Length) :=\n-                 Source (Source'First .. Source'First - 1 + Max_Length);\n \n             when Strings.Left =>\n+               Result.Data (1 .. Max_Length) := Super_String_Data\n+                 (Source (Source'Last - (Max_Length - 1) .. Source'Last));\n                Result.Current_Length := Max_Length;\n-               Result.Data (1 .. Max_Length) :=\n-                 Source (Source'Last - (Max_Length - 1) .. Source'Last);\n \n             when Strings.Error =>\n                raise Ada.Strings.Length_Error;"}, {"sha": "7428e9c2cd7ee17b7cb25aa1500a9e0514e61df6", "filename": "gcc/ada/libgnat/a-strsup.ads", "status": "modified", "additions": 2302, "deletions": 81, "changes": 2383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strsup.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1647bc2a78b2182007f011ff0a43f872086ee512/gcc%2Fada%2Flibgnat%2Fa-strsup.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strsup.ads?ref=1647bc2a78b2182007f011ff0a43f872086ee512"}]}