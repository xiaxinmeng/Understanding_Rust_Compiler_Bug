{"sha": "8229306b8bf013abab6c77e56f486097075f6161", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIyOTMwNmI4YmYwMTNhYmFiNmM3N2U1NmY0ODYwOTcwNzVmNjE2MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-04T18:52:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-04T18:52:39Z"}, "message": "bitmap.h (enum bitmap_bits): Add BITMAP_XOR.\n\n        * bitmap.h (enum bitmap_bits): Add BITMAP_XOR.\n        * bitmap.c (bitmap_operation): Return true iff TO changed.\n        (bitmap_equal_p): New.\n        (bitmap_bit_p): Tidy arithmetic.\n        (debug_bitmap_file): Likewise.\n\nFrom-SVN: r29808", "tree": {"sha": "b9773a5f631cc19430069bdb2fe20c2fddbf3d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9773a5f631cc19430069bdb2fe20c2fddbf3d0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8229306b8bf013abab6c77e56f486097075f6161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8229306b8bf013abab6c77e56f486097075f6161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8229306b8bf013abab6c77e56f486097075f6161", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8229306b8bf013abab6c77e56f486097075f6161/comments", "author": null, "committer": null, "parents": [{"sha": "393f3ad5b9faca002ce01cd61db226174f01f44a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393f3ad5b9faca002ce01cd61db226174f01f44a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/393f3ad5b9faca002ce01cd61db226174f01f44a"}], "stats": {"total": 183, "additions": 114, "deletions": 69}, "files": [{"sha": "71c02a8479b227a9ea1d0a6c80af06fc1f8f6245", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8229306b8bf013abab6c77e56f486097075f6161/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8229306b8bf013abab6c77e56f486097075f6161/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8229306b8bf013abab6c77e56f486097075f6161", "patch": "@@ -1,3 +1,13 @@\n+Mon Oct  4 11:38:33 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sbitmap.c (sbitmap_ones): Don't set too many bits.\n+\n+\t* bitmap.h (enum bitmap_bits): Add BITMAP_XOR.\n+\t* bitmap.c (bitmap_operation): Return true iff TO changed.\n+\t(bitmap_equal_p): New.\n+\t(bitmap_bit_p): Tidy arithmetic.\n+\t(debug_bitmap_file): Likewise.\n+\n Mon Oct  4 11:28:37 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* toplev.c (rest_of_compilation): Turn on cse_not_expected"}, {"sha": "37815e6df44b8b8cf46231247834969c91e25730", "filename": "gcc/bitmap.c", "status": "modified", "additions": 98, "deletions": 67, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8229306b8bf013abab6c77e56f486097075f6161/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8229306b8bf013abab6c77e56f486097075f6161/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=8229306b8bf013abab6c77e56f486097075f6161", "patch": "@@ -382,44 +382,62 @@ bitmap_bit_p (head, bit)\n   word_num\n     = ((bit / (unsigned) HOST_BITS_PER_WIDE_INT) % BITMAP_ELEMENT_WORDS);\n \n-  return\n-    (ptr->bits[word_num] & (((unsigned HOST_WIDE_INT) 1) << bit_num)) != 0;\n+  return (ptr->bits[word_num] >> bit_num) & 1;\n }\n \f\n-/* Store in bitmap TO the result of combining bitmap FROM1 and\n-   FROM2 using a specific bit manipulation.  */\n+/* Store in bitmap TO the result of combining bitmap FROM1 and FROM2 using\n+   a specific bit manipulation.  Return true if TO changes.  */\n \n-void\n+int\n bitmap_operation (to, from1, from2, operation)\n      bitmap to;\n      bitmap from1;\n      bitmap from2;\n      enum bitmap_bits operation;\n {\n-  bitmap_element *delete_list = 0;\n   bitmap_element *from1_ptr = from1->first;\n   bitmap_element *from2_ptr = from2->first;\n-  unsigned int indx1\n-    = (from1_ptr) ? from1_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n-  unsigned int indx2\n-    = (from2_ptr) ? from2_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n-  bitmap_element *to_ptr = 0;\n+  unsigned int indx1 = (from1_ptr) ? from1_ptr->indx : -1;\n+  unsigned int indx2 = (from2_ptr) ? from2_ptr->indx : -1;\n+  bitmap_element *to_ptr = to->first;\n   bitmap_element *from1_tmp;\n   bitmap_element *from2_tmp;\n+  bitmap_element *to_tmp;\n   unsigned int indx;\n-#if BITMAP_ELEMENT_WORDS != 2\n-  int i;\n+  int changed = 0;\n+\n+#if BITMAP_ELEMENT_WORDS == 2\n+#define DOIT(OP)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    unsigned HOST_WIDE_INT t0, t1, f10, f11, f20, f21;\t\\\n+    f10 = from1_tmp->bits[0];\t\t\t\t\\\n+    f20 = from2_tmp->bits[0];\t\t\t\t\\\n+    t0 = f10 OP f20;\t\t\t\t\t\\\n+    changed |= (t0 != to_tmp->bits[0]);\t\t\t\\\n+    f11 = from1_tmp->bits[1];\t\t\t\t\\\n+    f21 = from2_tmp->bits[1];\t\t\t\t\\\n+    t1 = f11 OP f21;\t\t\t\t\t\\\n+    changed |= (t1 != to_tmp->bits[1]);\t\t\t\\\n+    to_tmp->bits[0] = t0;\t\t\t\t\\\n+    to_tmp->bits[1] = t1;\t\t\t\t\\\n+  } while (0)\n+#else\n+#define DOIT(OP)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    unsigned HOST_WIDE_INT t, f1, f2;\t\t\t\\\n+    int i;\t\t\t\t\t\t\\\n+    for (i = 0; i < BITMAP_ELEMENT_WORDS; ++i)\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tf1 = from1_tmp->bits[i];\t\t\t\\\n+\tf2 = from2_tmp->bits[i];\t\t\t\\\n+\tt = f1 OP f2;\t\t\t\t\t\\\n+\tchanged |= (t != to_tmp->bits[i]);\t\t\\\n+\tto_tmp->bits[i] = t;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n-  /* To simplify things, always create a new list.  If the old list was one\n-     of the inputs, free it later.  Otherwise, free it now.  */\n-  if (to == from1 || to == from2)\n-    {\n-      delete_list = to->first;\n-      to->first = to->current = 0;\n-    }\n-  else\n-    bitmap_clear (to);\n+  to->first = to->current = 0;\n \n   while (from1_ptr != 0 || from2_ptr != 0)\n     {\n@@ -431,29 +449,44 @@ bitmap_operation (to, from1, from2, operation)\n \t  from1_tmp = from1_ptr;\n \t  from2_tmp = from2_ptr;\n \t  from1_ptr = from1_ptr->next;\n-\t  indx1 = (from1_ptr) ? from1_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t  indx1 = (from1_ptr) ? from1_ptr->indx : -1;\n \t  from2_ptr = from2_ptr->next;\n-\t  indx2 = (from2_ptr) ? from2_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t  indx2 = (from2_ptr) ? from2_ptr->indx : -1;\n \t}\n       else if (indx1 < indx2)\n \t{\n \t  indx = indx1;\n \t  from1_tmp = from1_ptr;\n \t  from2_tmp = &bitmap_zero;\n \t  from1_ptr = from1_ptr->next;\n-\t  indx1 = (from1_ptr) ? from1_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t  indx1 = (from1_ptr) ? from1_ptr->indx : -1;\n \t}\n       else\n \t{\n \t  indx = indx2;\n \t  from1_tmp = &bitmap_zero;\n \t  from2_tmp = from2_ptr;\n \t  from2_ptr = from2_ptr->next;\n-\t  indx2 = (from2_ptr) ? from2_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t  indx2 = (from2_ptr) ? from2_ptr->indx : -1;\n \t}\n \n-      if (to_ptr == 0)\n-\tto_ptr = bitmap_element_allocate ();\n+      /* Find the appropriate element from TO.  Begin by discarding\n+\t elements that we've skipped. */\n+      while (to_ptr && to_ptr->indx < indx)\n+\t{\n+\t  changed = 1;\n+\t  to_tmp = to_ptr;\n+\t  to_ptr = to_ptr->next;\n+\t  to_tmp = bitmap_free;\n+\t  bitmap_free = to_tmp;\n+\t}\n+      if (to_ptr && to_ptr->indx == indx)\n+\t{\n+\t  to_tmp = to_ptr;\n+\t  to_ptr = to_ptr->next;\n+\t}\n+      else\n+\tto_tmp = bitmap_element_allocate ();\n \n       /* Do the operation, and if any bits are set, link it into the\n \t linked list.  */\n@@ -463,61 +496,59 @@ bitmap_operation (to, from1, from2, operation)\n \t  abort ();\n \n \tcase BITMAP_AND:\n-#if BITMAP_ELEMENT_WORDS == 2\n-\t  to_ptr->bits[0] = from1_tmp->bits[0] & from2_tmp->bits[0];\n-\t  to_ptr->bits[1] = from1_tmp->bits[1] & from2_tmp->bits[1];\n-#else\n-\t  for (i = BITMAP_ELEMENT_WORDS - 1; i >= 0; i--)\n-\t    to_ptr->bits[i] = from1_tmp->bits[i] & from2_tmp->bits[i];\n-#endif\n+\t  DOIT (&);\n \t  break;\n \n \tcase BITMAP_AND_COMPL:\n-#if BITMAP_ELEMENT_WORDS == 2\n-\t  to_ptr->bits[0] = from1_tmp->bits[0] & ~ from2_tmp->bits[0];\n-\t  to_ptr->bits[1] = from1_tmp->bits[1] & ~ from2_tmp->bits[1];\n-#else\n-\t  for (i = BITMAP_ELEMENT_WORDS - 1; i >= 0; i--)\n-\t    to_ptr->bits[i] = from1_tmp->bits[i] & ~ from2_tmp->bits[i];\n-#endif\n+\t  DOIT (&~);\n \t  break;\n \n \tcase BITMAP_IOR:\n-#if BITMAP_ELEMENT_WORDS == 2\n-\t  to_ptr->bits[0] = from1_tmp->bits[0] | from2_tmp->bits[0];\n-\t  to_ptr->bits[1] = from1_tmp->bits[1] | from2_tmp->bits[1];\n-#else\n-\t  for (i = BITMAP_ELEMENT_WORDS - 1; i >= 0; i--)\n-\t    to_ptr->bits[i] = from1_tmp->bits[i] | from2_tmp->bits[i];\n-#endif\n+\t  DOIT (|);\n+\t  break;\n+\n+\tcase BITMAP_XOR:\n+\t  DOIT (^);\n \t  break;\n \t}\n \n-      if (! bitmap_element_zerop (to_ptr))\n+      if (! bitmap_element_zerop (to_tmp))\n \t{\n-\t  to_ptr->indx = indx;\n-\t  bitmap_element_link (to, to_ptr);\n-\t  to_ptr = 0;\n+\t  to_tmp->indx = indx;\n+\t  bitmap_element_link (to, to_tmp);\n \t}\n     }\n \n-  /* If we have an unallocated element due to the last element being 0,\n-     release it back to the free pool.  Don't bother calling\n-     bitmap_element_free since it was never linked into a bitmap.  */\n-  if (to_ptr != 0)\n+  /* If we have elements of TO left over, free the lot.  */\n+  if (to_ptr)\n     {\n-      to_ptr->next = bitmap_free;\n+      changed = 1;\n+      for (to_tmp = to_ptr; to_tmp->next ; to_tmp = to_tmp->next)\n+\tcontinue;\n+      to_tmp->next = bitmap_free;\n       bitmap_free = to_ptr;\n     }\n \n-  /* If the output bitmap was one of the inputs, free up its\n-     elements now that we're done.  */\n-  for (; delete_list != 0; delete_list = to_ptr)\n-    {\n-      to_ptr = delete_list->next;\n-      delete_list->next = bitmap_free;\n-      bitmap_free = delete_list;\n-    }\n+#undef DOIT\n+\n+  return changed;\n+}\n+\n+/* Return true if two bitmaps are identical.  */\n+\n+int\n+bitmap_equal_p (a, b)\n+     bitmap a;\n+     bitmap b;\n+{\n+  bitmap_head c;\n+  int ret;\n+\n+  c.first = c.current = 0;\n+  ret = ! bitmap_operation (&c, a, b, BITMAP_XOR);\n+  bitmap_clear (&c);\n+\n+  return ret;\n }\n \f\n /* Or into bitmap TO bitmap FROM1 and'ed with the complement of\n@@ -578,7 +609,7 @@ debug_bitmap_file (file, head)\n \n       for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n \tfor (j = 0; j < HOST_BITS_PER_WIDE_INT; j++)\n-\t  if ((ptr->bits[i] & (((unsigned HOST_WIDE_INT) 1) << j)) != 0)\n+\t  if ((ptr->bits[i] >> j) & 1)\n \t    {\n \t      if (col > 70)\n \t\t{"}, {"sha": "286c75e98aae035fb533af18a85430cd627c9366", "filename": "gcc/bitmap.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8229306b8bf013abab6c77e56f486097075f6161/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8229306b8bf013abab6c77e56f486097075f6161/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=8229306b8bf013abab6c77e56f486097075f6161", "patch": "@@ -55,7 +55,8 @@ typedef struct bitmap_head_def {\n enum bitmap_bits {\n   BITMAP_AND,\t\t\t/* TO = FROM1 & FROM2 */\n   BITMAP_AND_COMPL,\t\t/* TO = FROM1 & ~ FROM2 */\n-  BITMAP_IOR\t\t\t/* TO = FROM1 | FROM2 */\n+  BITMAP_IOR,\t\t\t/* TO = FROM1 | FROM2 */\n+  BITMAP_XOR\t\t\t/* TO = FROM1 ^ FROM2 */\n };\n \n /* Global data */\n@@ -68,8 +69,11 @@ extern void bitmap_clear PROTO((bitmap));\n /* Copy a bitmap to another bitmap. */\n extern void bitmap_copy PROTO((bitmap, bitmap));\n \n+/* True if two bitmaps are identical.  */\n+extern int bitmap_equal_p PROTO((bitmap, bitmap));\n+\n /* Perform an operation on two bitmaps, yielding a third.  */\n-extern void bitmap_operation PROTO((bitmap, bitmap, bitmap, enum bitmap_bits));\n+extern int bitmap_operation PROTO((bitmap, bitmap, bitmap, enum bitmap_bits));\n \n /* `or' into one bitmap the `and' of a second bitmap witih the complement\n    of a third.  */"}]}