{"sha": "93b09bf3246f413b8e469ebfd8ce43947c0073a6", "node_id": "C_kwDOANBUbNoAKDkzYjA5YmYzMjQ2ZjQxM2I4ZTQ2OWViZmQ4Y2U0Mzk0N2MwMDczYTY", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-09-13T05:25:24Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-09-14T07:44:48Z"}, "message": "Check another epilog variable peeling case in vectorizable_nonlinear_induction.\n\nin vectorizable_nonlinear_induction, r13-2503-gc13223b790bbc5 prevent variable peeling by\nonly checking LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo). But when\n\"!vect_use_loop_mask_for_alignment_p (loop_vinfo) &&\nLOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0\", vectorizer will\nstill do variable peeling for epilog, and it hits gcc_assert in\nvect_peel_nonlinear_iv_init.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/106905\n\t* tree-vect-loop.cc (vectorizable_nonlinear_induction): Return\n\tfalse when !vect_use_loop_mask_for_alignment_p (loop_vinfo) &&\n\tLOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr106905.c: New test.\n\t* gcc.target/ia64/pr106905.c: New test.", "tree": {"sha": "c05d14fea44dca329703f92cc6de94d033ead4fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c05d14fea44dca329703f92cc6de94d033ead4fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93b09bf3246f413b8e469ebfd8ce43947c0073a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b09bf3246f413b8e469ebfd8ce43947c0073a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93b09bf3246f413b8e469ebfd8ce43947c0073a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b09bf3246f413b8e469ebfd8ce43947c0073a6/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d503515ceebc778a5c2958f7459367c34f1fed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d503515ceebc778a5c2958f7459367c34f1fed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d503515ceebc778a5c2958f7459367c34f1fed0"}], "stats": {"total": 40, "additions": 38, "deletions": 2}, "files": [{"sha": "a190a1c84e6f32443009a24504a633ff2c567685", "filename": "gcc/testsuite/gcc.target/i386/pr106905.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b09bf3246f413b8e469ebfd8ce43947c0073a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr106905.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b09bf3246f413b8e469ebfd8ce43947c0073a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr106905.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr106905.c?ref=93b09bf3246f413b8e469ebfd8ce43947c0073a6", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=silvermont -O2 -fvect-cost-model=dynamic\" } */\n+\n+void\n+foo_mul_peel (int *a, int b)\n+{\n+  int i;\n+\n+  for (i = 0; i < 7; ++i)\n+    {\n+      b *= 2;\n+      a[i] = b;\n+    }\n+}"}, {"sha": "1b9656e1203b80dfddfc9b3874e1cda84533d38a", "filename": "gcc/testsuite/gcc.target/ia64/pr106905.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b09bf3246f413b8e469ebfd8ce43947c0073a6/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr106905.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b09bf3246f413b8e469ebfd8ce43947c0073a6/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr106905.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr106905.c?ref=93b09bf3246f413b8e469ebfd8ce43947c0073a6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -O3 -fPIC\" } */\n+long ZDICT_fillNoise_p, ZDICT_trainFromBuffer_legacy_result;\n+unsigned ZDICT_fillNoise_acc;\n+int ZDICT_totalSampleSize_nbFiles;\n+static void ZDICT_fillNoise(void *buffer, long length) {\n+  unsigned prime2 = 9;\n+  for (ZDICT_fillNoise_p = 0; ZDICT_fillNoise_p < length; ZDICT_fillNoise_p++)\n+    ZDICT_fillNoise_acc *= ((char *)buffer)[ZDICT_fillNoise_p] = prime2;\n+}\n+long ZDICT_trainFromBuffer_legacy() {\n+  void *newBuff;\n+  long total = 0;\n+  for (; ZDICT_totalSampleSize_nbFiles;)\n+    total += 0;\n+  long sBuffSize = total;\n+  newBuff = 0;\n+  ZDICT_fillNoise(newBuff + sBuffSize, 32);\n+  return ZDICT_trainFromBuffer_legacy_result;\n+}"}, {"sha": "9c434b66c5be9bf07ecfda23933202f68f4c0163", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b09bf3246f413b8e469ebfd8ce43947c0073a6/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b09bf3246f413b8e469ebfd8ce43947c0073a6/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=93b09bf3246f413b8e469ebfd8ce43947c0073a6", "patch": "@@ -8646,8 +8646,10 @@ vectorizable_nonlinear_induction (loop_vec_info loop_vinfo,\n   /* Also doens't support peel for neg when niter is variable.\n      ??? generate something like niter_expr & 1 ? init_expr : -init_expr?  */\n   niters_skip = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n-  if (niters_skip != NULL_TREE\n-      && TREE_CODE (niters_skip) != INTEGER_CST)\n+  if ((niters_skip != NULL_TREE\n+       && TREE_CODE (niters_skip) != INTEGER_CST)\n+      || (!vect_use_loop_mask_for_alignment_p (loop_vinfo)\n+\t  && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}]}