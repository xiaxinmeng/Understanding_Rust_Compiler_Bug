{"sha": "3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I0MjYzOTFkM2VmYTVjZmQwMzg4ZjZjNDgxOTJmZTBlNjExZGZhOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-02-04T04:24:53Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-02-04T04:24:53Z"}, "message": "class.c, [...]: Follow spelling conventions.\n\n\t* class.c, cp-tree.h, decl.c, decl2.c, g++spec.c, init.c,\n\tparser.c, pt.c, tree.c, typeck.c: Follow spelling conventions.\n\nFrom-SVN: r121566", "tree": {"sha": "36d9dce14dcb16195a245143b39159a1ce9dac6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d9dce14dcb16195a245143b39159a1ce9dac6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/comments", "author": null, "committer": null, "parents": [{"sha": "85f650932f2e85b08877241f919939f8a3009ae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f650932f2e85b08877241f919939f8a3009ae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f650932f2e85b08877241f919939f8a3009ae4"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "4e9db1770ee20f36bbeab56b81d31540e1e5eab5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -1,3 +1,8 @@\n+2007-02-04  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* class.c, cp-tree.h, decl.c, decl2.c, g++spec.c, init.c,\n+\tparser.c, pt.c, tree.c, typeck.c: Follow spelling conventions.\n+\n 2007-02-03  Douglas Gregor  <doug.gregor@gmail.com>\n \n        * parser.c (cp_lexer_get_preprocessor_token): Attach the C++0x"}, {"sha": "0f19b67c74f5a5e21b9763c8448615273c7bedd2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -430,8 +430,8 @@ build_simple_base_path (tree expr, tree binfo)\n \n       /* Transform `(a, b).x' into `(*(a, &b)).x', `(a ? b : c).x'\n \t into `(*(a ?  &b : &c)).x', and so on.  A COND_EXPR is only\n-\t an lvalue in the frontend; only _DECLs and _REFs are lvalues\n-\t in the backend.  */\n+\t an lvalue in the front end; only _DECLs and _REFs are lvalues\n+\t in the back end.  */\n       temp = unary_complex_lvalue (ADDR_EXPR, expr);\n       if (temp)\n \texpr = build_indirect_ref (temp, NULL);\n@@ -1725,7 +1725,7 @@ finish_struct_methods (tree t)\n }\n \n /* Make BINFO's vtable have N entries, including RTTI entries,\n-   vbase and vcall offsets, etc.  Set its type and call the backend\n+   vbase and vcall offsets, etc.  Set its type and call the back end\n    to lay it out.  */\n \n static void\n@@ -4586,7 +4586,7 @@ layout_class_type (tree t, tree *virtuals_p)\n       tree padding;\n \n       /* We still pass things that aren't non-static data members to\n-\t the back-end, in case it wants to do something with them.  */\n+\t the back end, in case it wants to do something with them.  */\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n \t  place_field (rli, field);\n@@ -4894,7 +4894,7 @@ layout_class_type (tree t, tree *virtuals_p)\n     place_field (rli,\n \t\t build_decl (FIELD_DECL, NULL_TREE, char_type_node));\n \n-  /* Let the back-end lay out the type.  */\n+  /* Let the back end lay out the type.  */\n   finish_record_layout (rli, /*free_p=*/true);\n \n   /* Warn about bases that can't be talked about due to ambiguity.  */"}, {"sha": "08d22d59eb1a704fbf9807f7fc850d449588dd43", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -472,7 +472,7 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       break;\n \n     case THROW_EXPR:\n-      /* FIXME communicate throw type to backend, probably by moving\n+      /* FIXME communicate throw type to back end, probably by moving\n \t THROW_EXPR into ../tree.def.  */\n       *expr_p = TREE_OPERAND (*expr_p, 0);\n       ret = GS_OK;"}, {"sha": "2fdea26810623dc5c676cba65fed4d93e6d9015d", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -68,7 +68,7 @@ cxx_warn_unused_global_decl (tree decl)\n   return true;\n }\n \n-/* Langhook for expr_size: Tell the backend that the value of an expression\n+/* Langhook for expr_size: Tell the back end that the value of an expression\n    of non-POD class type does not include any tail padding; a derived class\n    might have allocated something there.  */\n \n@@ -79,7 +79,7 @@ cp_expr_size (tree exp)\n \n   if (CLASS_TYPE_P (type))\n     {\n-      /* The backend should not be interested in the size of an expression\n+      /* The back end should not be interested in the size of an expression\n \t of a type with both of these set; all copies of such types must go\n \t through a constructor or assignment op.  */\n       if (!TYPE_HAS_COMPLEX_INIT_REF (type)"}, {"sha": "7eb26c5957988dfca2329048ba535e96b916ef95", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -345,7 +345,7 @@ struct tree_overload GTY(())\n    requested.  */\n #define BASELINK_OPTYPE(NODE) \\\n   (TREE_CHAIN (BASELINK_CHECK (NODE)))\n-/* Non-zero if this baselink was from a qualified lookup.  */\n+/* Nonzero if this baselink was from a qualified lookup.  */\n #define BASELINK_QUALIFIED_P(NODE) \\\n   TREE_LANG_FLAG_0 (BASELINK_CHECK (NODE))\n \n@@ -2109,7 +2109,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n \n /* If non-NULL for a VAR_DECL, FUNCTION_DECL, TYPE_DECL or\n    TEMPLATE_DECL, the entity is either a template specialization (if\n-   DECL_USE_TEMPLATE is non-zero) or the abstract instance of the\n+   DECL_USE_TEMPLATE is nonzero) or the abstract instance of the\n    template itself.\n \n    In either case, DECL_TEMPLATE_INFO is a TREE_LIST, whose\n@@ -2868,7 +2868,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n /* Returns nonzero if NODE is a primary template.  */\n #define PRIMARY_TEMPLATE_P(NODE) (DECL_PRIMARY_TEMPLATE (NODE) == (NODE))\n \n-/* Non-zero iff NODE is a specialization of a template.  The value\n+/* Nonzero iff NODE is a specialization of a template.  The value\n    indicates the type of specializations:\n \n      1=implicit instantiation\n@@ -2892,7 +2892,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n     \n    both O<int>::f and O<int>::I will be marked as instantiations.\n \n-   If DECL_USE_TEMPLATE is non-zero, then DECL_TEMPLATE_INFO will also\n+   If DECL_USE_TEMPLATE is nonzero, then DECL_TEMPLATE_INFO will also\n    be non-NULL.  */\n #define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.use_template)\n \n@@ -4573,7 +4573,7 @@ extern void cp_genericize\t\t\t(tree);\n \n /* -- end of C++ */\n \n-/* In order for the format checking to accept the C++ frontend\n+/* In order for the format checking to accept the C++ front end\n    diagnostic framework extensions, you must include this file before\n    toplev.h, not after.  We override the definition of GCC_DIAG_STYLE\n    in c-common.h.  */"}, {"sha": "220edddb535f622ba1a3fc9715deb33ab9ebc30c", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -994,7 +994,7 @@ convert_to_void (tree expr, const char *implicit)\n \n    Most of this routine is from build_reinterpret_cast.\n \n-   The backend cannot call cp_convert (what was convert) because\n+   The back end cannot call cp_convert (what was convert) because\n    conversions to/from basetypes may involve memory references\n    (vbases) and adding or subtracting small values (multiple\n    inheritance), but it calls convert from the constant folding code"}, {"sha": "01398f2fa930edbdc50b4005f4eb248fe176c8cf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -713,7 +713,7 @@ poplevel (int keep, int reverse, int functionbody)\n \n   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n      list if a `using' declaration put them there.  The debugging\n-     back-ends won't understand OVERLOAD, so we remove them here.\n+     back ends won't understand OVERLOAD, so we remove them here.\n      Because the BLOCK_VARS are (temporarily) shared with\n      CURRENT_BINDING_LEVEL->NAMES we must do this fixup after we have\n      popped all the bindings.  */\n@@ -3044,7 +3044,7 @@ record_builtin_java_type (const char* name, int size)\n   return type;\n }\n \n-/* Push a type into the namespace so that the back-ends ignore it.  */\n+/* Push a type into the namespace so that the back ends ignore it.  */\n \n static void\n record_unknown_type (tree type, const char* name)\n@@ -3955,7 +3955,7 @@ start_decl (const cp_declarator *declarator,\n   if (tem == error_mark_node)\n     return error_mark_node;\n \n-  /* Tell the back-end to use or not use .common as appropriate.  If we say\n+  /* Tell the back end to use or not use .common as appropriate.  If we say\n      -fconserve-space, we want this to save .data space, at the expense of\n      wrong semantics.  If we say -fno-conserve-space, we want this to\n      produce errors about redefs; to do this we force variables into the\n@@ -5582,7 +5582,7 @@ register_dtor_fn (tree decl)\n \n   /* Now, recompute the cleanup.  It may contain SAVE_EXPRs that refer\n      to the original function, rather than the anonymous one.  That\n-     will make the back-end think that nested functions are in use,\n+     will make the back end think that nested functions are in use,\n      which causes confusion.  */\n \n   push_deferring_access_checks (dk_no_check);\n@@ -6440,7 +6440,7 @@ build_ptrmemfunc_type (tree type)\n   t = make_aggr_type (RECORD_TYPE);\n   xref_basetypes (t, NULL_TREE);\n \n-  /* Let the front-end know this is a pointer to member function...  */\n+  /* Let the front end know this is a pointer to member function...  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n   /* ... and not really an aggregate.  */\n   SET_IS_AGGR_TYPE (t, 0);\n@@ -6454,7 +6454,7 @@ build_ptrmemfunc_type (tree type)\n \n   finish_builtin_struct (t, \"__ptrmemfunc_type\", fields, ptr_type_node);\n \n-  /* Zap out the name so that the back-end will give us the debugging\n+  /* Zap out the name so that the back end will give us the debugging\n      information for this anonymous RECORD_TYPE.  */\n   TYPE_NAME (t) = NULL_TREE;\n \n@@ -10766,7 +10766,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tDECL_EXTERNAL (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n       /* If this function is in an interface implemented in this file,\n-\t make sure that the backend knows to emit this function\n+\t make sure that the back end knows to emit this function\n \t here.  */\n       if (!DECL_EXTERNAL (decl1))\n \tmark_needed (decl1);"}, {"sha": "4e4f6a5642bf1d9cb545f26cf718affbb7017d92", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -1394,7 +1394,7 @@ import_export_class (tree ctype)\n   if (MULTIPLE_SYMBOL_SPACES && import_export == -1)\n     import_export = 0;\n \n-  /* Allow backends the chance to overrule the decision.  */\n+  /* Allow back ends the chance to overrule the decision.  */\n   if (targetm.cxx.import_export_class)\n     import_export = targetm.cxx.import_export_class (ctype, import_export);\n \n@@ -1446,7 +1446,7 @@ decl_needed_p (tree decl)\n      emitted; they may be referred to from other object files.  */\n   if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl))\n     return true;\n-  /* If this entity was used, let the back-end see it; it will decide\n+  /* If this entity was used, let the back end see it; it will decide\n      whether or not to emit it into the object file.  */\n   if (TREE_USED (decl)\n       || (DECL_ASSEMBLER_NAME_SET_P (decl)\n@@ -2922,7 +2922,7 @@ generate_ctor_and_dtor_functions_for_priority (splay_tree_node n, void * data)\n }\n \n /* Called via LANGHOOK_CALLGRAPH_ANALYZE_EXPR.  It is supposed to mark\n-   decls referenced from frontend specific constructs; it will be called\n+   decls referenced from front-end specific constructs; it will be called\n    only for language-specific tree nodes.\n \n    Here we must deal with member pointers.  */\n@@ -3135,7 +3135,7 @@ cp_write_global_declarations (void)\n \t     through the loop.  That's because we need to know which\n \t     vtables have been referenced, and TREE_SYMBOL_REFERENCED\n \t     isn't computed until a function is finished, and written\n-\t     out.  That's a deficiency in the back-end.  When this is\n+\t     out.  That's a deficiency in the back end.  When this is\n \t     fixed, these initialization functions could all become\n \t     inline, with resulting performance improvements.  */\n \t  tree ssdf_body;\n@@ -3210,7 +3210,7 @@ cp_write_global_declarations (void)\n \t  if (!DECL_SAVED_TREE (decl))\n \t    continue;\n \n-\t  /* We lie to the back-end, pretending that some functions\n+\t  /* We lie to the back end, pretending that some functions\n \t     are not defined when they really are.  This keeps these\n \t     functions from being put out unnecessarily.  But, we must\n \t     stop lying when the functions are referenced, or if they"}, {"sha": "2ddc62c1e20f0ee3a4234b294e336d80de730ac1", "filename": "gcc/cp/g++spec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fg%2B%2Bspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fg%2B%2Bspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -1,4 +1,4 @@\n-/* Specific flags and argument handling of the C++ front-end.\n+/* Specific flags and argument handling of the C++ front end.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n "}, {"sha": "1ca07989babfc20edf0b9ada34acd7300affd632", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -863,7 +863,7 @@ construct_virtual_base (tree vbase, tree arguments)\n      confuses the sjlj exception-handling code.  Therefore, we do not\n      create a single conditional block, but one for each\n      initialization.  (That way the cleanup regions always begin\n-     in the outer block.)  We trust the back-end to figure out\n+     in the outer block.)  We trust the back end to figure out\n      that the FLAG will not change across initializations, and\n      avoid doing multiple tests.  */\n   flag = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n@@ -1522,7 +1522,7 @@ integral_constant_value (tree decl)\n }\n \n /* A more relaxed version of integral_constant_value, used by the\n-   common C/C++ code and by the C++ front-end for optimization\n+   common C/C++ code and by the C++ front end for optimization\n    purposes.  */\n \n tree\n@@ -2478,7 +2478,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n      When copying from array to another, when the array elements have\n      only trivial copy constructors, we should use __builtin_memcpy\n      rather than generating a loop.  That way, we could take advantage\n-     of whatever cleverness the back-end has for dealing with copies\n+     of whatever cleverness the back end has for dealing with copies\n      of blocks of memory.  */\n \n   is_global = begin_init_stmts (&stmt_expr, &compound_stmt);"}, {"sha": "2f619be9645f710e9b4b685ff522f02f99449697", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -679,7 +679,7 @@ build_lang_decl (enum tree_code code, tree name, tree type)\n }\n \n /* Add DECL_LANG_SPECIFIC info to T.  Called from build_lang_decl\n-   and pushdecl (for functions generated by the backend).  */\n+   and pushdecl (for functions generated by the back end).  */\n \n void\n retrofit_lang_decl (tree t)"}, {"sha": "7d5c4e8f680f96f60c2fce20f9ef690691d7b6f9", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -432,7 +432,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       DECL_RESULT (thunk_fndecl)\n \t= build_decl (RESULT_DECL, 0, integer_type_node);\n       fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n-      /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n+      /* The back end expects DECL_INITIAL to contain a BLOCK, so we\n \t create one.  */\n       fn_block = make_node (BLOCK);\n       BLOCK_VARS (fn_block) = a;"}, {"sha": "08f1c90f7a0222a20705d1384c17f6956074ab8b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -771,7 +771,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \n       check_template_shadow (x);\n \n-      /* If this is a function conjured up by the backend, massage it\n+      /* If this is a function conjured up by the back end, massage it\n \t so it looks friendly.  */\n       if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_LANG_SPECIFIC (x))\n \t{"}, {"sha": "f7bff071a6a43637eaf02c92359ddab33ca9ecbb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -14609,7 +14609,7 @@ cp_parser_function_try_block (cp_parser* parser)\n   /* Look for the `try' keyword.  */\n   if (!cp_parser_require_keyword (parser, RID_TRY, \"`try'\"))\n     return false;\n-  /* Let the rest of the front-end know where we are.  */\n+  /* Let the rest of the front end know where we are.  */\n   try_block = begin_function_try_block (&compound_stmt);\n   /* Parse the function-body.  */\n   ctor_initializer_p\n@@ -17418,7 +17418,7 @@ cp_parser_objc_identifier_list (cp_parser* parser)\n    objc-alias-declaration:\n      @compatibility_alias identifier identifier ;\n \n-   This function registers the alias mapping with the Objective-C front-end.\n+   This function registers the alias mapping with the Objective-C front end.\n    It returns nothing.  */\n \n static void\n@@ -17439,7 +17439,7 @@ cp_parser_objc_alias_declaration (cp_parser* parser)\n      @class objc-identifier-list ;\n \n    The function registers the forward declarations with the Objective-C\n-   front-end.  It returns nothing.  */\n+   front end.  It returns nothing.  */\n \n static void\n cp_parser_objc_class_declaration (cp_parser* parser)"}, {"sha": "21e014bea53beab1c75405c93cad2cebf9aa7abf", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -1608,7 +1608,7 @@ determine_specialization (tree template_id,\n \t This extension can only serve to make invalid programs valid,\n \t so it's safe.  And, there is strong anecdotal evidence that\n \t the committee intended the partial ordering rules to apply;\n-\t the EDG front-end has that behavior, and John Spicer claims\n+\t the EDG front end has that behavior, and John Spicer claims\n \t that the committee simply forgot to delete the wording in\n \t [temp.expl.spec].  */\n       tree tmpl = most_specialized_instantiation (templates);"}, {"sha": "78545e13a4a6469c900c520c7ef23d60d6260570", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -973,7 +973,7 @@ build_qualified_name (tree type, tree scope, tree name, bool template_p)\n   return t;\n }\n \n-/* Returns non-zero if X is an expression for a (possibly overloaded)\n+/* Returns nonzero if X is an expression for a (possibly overloaded)\n    function.  If \"f\" is a function or function template, \"f\", \"c->f\",\n    \"c.f\", \"C::f\", and \"f<int>\" will all be considered possibly\n    overloaded functions.  Returns 2 if the function is actually"}, {"sha": "68b7a04eff4d7c807d01f2ffb548115b5b118f6b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -1836,7 +1836,7 @@ build_class_member_access_expr (tree object, tree member,\n \n   /* Transform `(a, b).x' into `(*(a, &b)).x', `(a ? b : c).x' into\n      `(*(a ?  &b : &c)).x', and so on.  A COND_EXPR is only an lvalue\n-     in the frontend; only _DECLs and _REFs are lvalues in the backend.  */\n+     in the front end; only _DECLs and _REFs are lvalues in the back end.  */\n   {\n     tree temp = unary_complex_lvalue (ADDR_EXPR, object);\n     if (temp)\n@@ -5337,7 +5337,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \t\t \"target type\",\n \t\t intype, type);\n \n-      /* We need to strip nops here, because the frontend likes to\n+      /* We need to strip nops here, because the front end likes to\n \t create (int *)&a for array-to-pointer decay, instead of &a[0].  */\n       STRIP_NOPS (sexpr);\n       strict_aliasing_warning (intype, type, sexpr);"}, {"sha": "e31d87b16986074aea3913bf60f2f240d6af2456", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b426391d3efa5cfd0388f6c48192fe0e611dfa9/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=3b426391d3efa5cfd0388f6c48192fe0e611dfa9", "patch": "@@ -838,7 +838,7 @@ process_init_constructor_array (tree type, tree init)\n \tif (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (type)))\n \t  {\n \t    /* If this type needs constructors run for default-initialization,\n-\t      we can't rely on the backend to do it for us, so build up\n+\t      we can't rely on the back end to do it for us, so build up\n \t      TARGET_EXPRs.  If the type in question is a class, just build\n \t      one up; if it's an array, recurse.  */\n \t    if (IS_AGGR_TYPE (TREE_TYPE (type)))\n@@ -925,7 +925,7 @@ process_init_constructor_record (tree type, tree init)\n       else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n \t{\n \t  /* If this type needs constructors run for\n-\t     default-initialization, we can't rely on the backend to do it\n+\t     default-initialization, we can't rely on the back end to do it\n \t     for us, so build up TARGET_EXPRs.  If the type in question is\n \t     a class, just build one up; if it's an array, recurse.  */\n \t  if (IS_AGGR_TYPE (TREE_TYPE (field)))"}]}