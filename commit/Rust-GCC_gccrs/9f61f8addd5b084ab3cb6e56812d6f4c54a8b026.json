{"sha": "9f61f8addd5b084ab3cb6e56812d6f4c54a8b026", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY2MWY4YWRkZDViMDg0YWIzY2I2ZTU2ODEyZDZmNGM1NGE4YjAyNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-13T23:08:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-13T23:08:44Z"}, "message": "Use GEN_INT when appropriate.\n\n(define_attr type): New types for SQRT.\n(call patterns): Use SCRATCH for LR0.\nUse new predicate call_operand so that some integers can be\nused as addresses; fix CALLI so it doesn't accept constant.\n(EXBYTE, EXTHW, INBYTE, INHW): Use ZERO_EXTEND instead of AND\nwhen combine will make it.\nUse PSImode for BP value and don't reference BP explicitly.\nClean up define_expands for these operations.\n(rotlsi3): Use PSImode pseudo for FC.\n(sign_extend): Sign extension insns clobber BP.\n({load,store}_multiple): Use PSImode pseudo for CR.\n(MTSR): Add pattern for TRUNCATE from SImode to PSImode.\n(sqrtsf2, sqrtdf2, movpsi): New patterns.\n(load/store bytes/halfword): Clean up to accept temporaries as\ninput and use PSImode when required.\n(movhi, movqi): Allocate temporaries here.\n(reload_inqi, reload_outqi, reload_inhi, reload_outhi): New patterns.\n(movdf, movdi, movti): Use SCRATCH for BP register.\n(reload_{in,out}{df,di,ti}): New patterns.\n\nFrom-SVN: r2445", "tree": {"sha": "65ae5f5d813f0435fdd5d6349232d5e9e0257323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ae5f5d813f0435fdd5d6349232d5e9e0257323"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f61f8addd5b084ab3cb6e56812d6f4c54a8b026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f61f8addd5b084ab3cb6e56812d6f4c54a8b026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f61f8addd5b084ab3cb6e56812d6f4c54a8b026", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f61f8addd5b084ab3cb6e56812d6f4c54a8b026/comments", "author": null, "committer": null, "parents": [{"sha": "100fcf4cb386189e5d352bcce2770d8e778773fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/100fcf4cb386189e5d352bcce2770d8e778773fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/100fcf4cb386189e5d352bcce2770d8e778773fc"}], "stats": {"total": 897, "additions": 527, "deletions": 370}, "files": [{"sha": "c99fa01dce182ea0f8ed8a42af77593fb04dacfb", "filename": "gcc/config/a29k/a29k.md", "status": "modified", "additions": 527, "deletions": 370, "changes": 897, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f61f8addd5b084ab3cb6e56812d6f4c54a8b026/gcc%2Fconfig%2Fa29k%2Fa29k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f61f8addd5b084ab3cb6e56812d6f4c54a8b026/gcc%2Fconfig%2Fa29k%2Fa29k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.md?ref=9f61f8addd5b084ab3cb6e56812d6f4c54a8b026", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for AMD Am29000 for GNU C compiler\n-;;   Copyright (C) 1991 Free Software Foundation, Inc.\n+;;   Copyright (C) 1991, 1992 Free Software Foundation, Inc.\n ;;   Contributed by Richard Kenner (kenner@nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -31,7 +31,7 @@\n ;; Everything else is miscellaneous.\n \n (define_attr \"type\"\n-  \"call,branch,load,store,fadd,fmul,fam,fdiv,dmul,dam,ddiv,multi,misc\"\n+  \"call,branch,load,store,fadd,fmul,fam,fdiv,fsqrt,dmul,dam,ddiv,dsqrt,multi,misc\"\n   (const_string \"misc\"))\n \n ;; ASM insns cannot go into a delay slot, so call them \"multi\".\n@@ -69,7 +69,9 @@\n (define_function_unit \"adder\" 1 0 (eq_attr \"type\" \"fadd,fam,dam\") 3 0)\n \n (define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"fdiv\") 11 10)\n+(define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"fsqrt\") 28 27)\n (define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"ddiv\") 18 17)\n+(define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"dsqrt\") 57 56)\n \f\n ;; ADD\n (define_insn \"addsi3\"\n@@ -134,80 +136,77 @@\n   DONE;\n }\")\n \n+;; We indicate that LR0 is clobbered in the CALL_INSN itself.  Otherwise,\n+;; reorg will think it is just clobbered by the called function.\n+\n (define_expand \"call\"\n   [(parallel [(call (match_operand:SI 0 \"\" \"\")\n \t\t    (match_operand 1 \"\" \"\"))\n-\t      (clobber (reg:SI 32))])\n+\t      (clobber (scratch:SI))])\n    (match_operand 2 \"\" \"\")]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[0]) != MEM)\n     abort ();\n \n-  if (! TARGET_SMALL_MEMORY\n-      && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n-    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n+  if (! call_operand (XEXP (operands[0], 0), SImode))\n+    operands[0] = gen_rtx (MEM, SImode,\n \t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n \n   operands[2] = gen_clobbers_to (operands[2]);\n }\")\n  \n-(define_insn \"\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:SI 32))]\n-  \"\"\n-  \"calli lr0,%0%#\"\n-  [(set_attr \"type\" \"call\")])\n-\n (define_expand \"call_value\"\n   [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t\t   (call (match_operand:SI 1 \"\" \"\")\n \t\t\t (match_operand 2 \"\" \"\")))\n-\t\t   (clobber (reg:SI 32))])\n+\t\t   (clobber (scratch:SI))])\n    (match_operand 3 \"\" \"\")]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[1]) != MEM)\n     abort ();\n \n-  if (! TARGET_SMALL_MEMORY\n-      && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n-    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n+  if (! call_operand (XEXP (operands[1], 0), SImode))\n+    operands[1] = gen_rtx (MEM, SImode,\n \t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n \n   operands[3] = gen_clobbers_to (operands[3]);\n }\")\n  \n (define_insn \"\"\n-  [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:SI 32))]\n-  \"\"\n-  \"calli lr0,%1%#\"\n+  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_scratch:SI 2 \"=l\"))]\n+  \"GET_CODE (XEXP (operands[0], 0)) != CONST_INT\"\n+  \"calli lr0,%0%#\"\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"immediate_operand\" \"i\"))\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"i\"))\n \t (match_operand:SI 1 \"general_operand\" \"g\"))\n-   (clobber (reg:SI 32))]\n-  \"GET_CODE (operands[0]) == SYMBOL_REF\n-   && (TARGET_SMALL_MEMORY\n-       || ! strcmp (XSTR (operands[0], 0), current_function_name))\"\n+   (clobber (match_scratch:SI 2 \"=l\"))]\n+  \"\"\n   \"call lr0,%F0\"\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n-\t(call (mem:SI (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n+  \"GET_CODE (XEXP (operands[1], 0)) != CONST_INT\"\n+  \"calli lr0,%1%#\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"i\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))\n-   (clobber (reg:SI 32))]\n-  \"GET_CODE (operands[1]) == SYMBOL_REF\n-   && (TARGET_SMALL_MEMORY\n-       || ! strcmp (XSTR (operands[1], 0), current_function_name))\"\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n+  \"\"\n   \"call lr0,%F1\"\n   [(set_attr \"type\" \"call\")])\n \n@@ -248,31 +247,25 @@\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n \t\t\t (const_int 16)\n-\t\t\t (match_operand:SI 1 \"const_0_operand\" \"\"))\n+\t\t\t (match_operand:SI 1 \"const_0_operand\" \"I\"))\n \t(match_operand:SI 2 \"cint_16_operand\" \"J\"))]\n   \"\"\n-  \"*\n-{ operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) << 16);\n-  return \\\"consth %0,%2\\\";\n-}\")\n+  \"consth %0,%m2\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0\")\n-\t\t\t(const_int 65535))\n+\t(ior:SI (zero_extend:SI (match_operand:HI 1 \"gpc_reg_operand\" \"0\"))\n \t\t(match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(INTVAL (operands[1]) & 0xffff) == 0\"\n+  \"(INTVAL (operands[2]) & 0xffff) == 0\"\n   \"consth %0,%2\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0\")\n-\t\t\t(const_int 65535))\n+\t(ior:SI (zero_extend:SI (match_operand:HI 1 \"gpc_reg_operand\" \"0\"))\n \t\t(and:SI (match_operand:SI 2 \"immediate_operand\" \"i\")\n \t\t\t(const_int -65536))))]\n   \"\"\n   \"consth %0,%2\")\n-\n \f\n ;; CONVERT\n (define_insn \"fix_truncsfsi2\"\n@@ -591,28 +584,31 @@\n \t\t\t(const_int -256))\n \t\t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n \t\t\t\t (const_int 8)\n-\t\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t\t    (const_int 3)))))]\n+\t\t\t\t (ashift:PSI\n+\t\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n+\t\t\t\t  (const_int 3)))))]\n   \"\"\n   \"exbyte %0,%2,%1\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(zero_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t (const_int 8)\n-\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n-\t\t\t\t    (const_int 3))))]\n+\t\t\t (ashift:PSI\n+\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n+\t\t\t  (const_int 3))))]\n   \"\"\n   \"exbyte %0,%1,0\")\n \n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n \t\t\t (const_int 8)\n-\t\t\t (match_operand:SI 1 \"const_24_operand\" \"\"))\n+\t\t\t (match_operand:PSI 1 \"const_24_operand\" \"\"))\n \t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n \t\t\t (const_int 8)\n-\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t    (const_int 3))))]\n+\t\t\t (ashift:PSI\n+\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n+\t\t\t  (const_int 3))))]\n   \"\"\n   \"exbyte %0,%2,%0\")\n \n@@ -632,37 +628,19 @@\n \n   size = INTVAL (operands[2]);\n   pos = INTVAL (operands[3]);\n-  if ((size != 8 && size != 16) || pos % size != 0)\n-    FAIL;\n \n-  operands[3] = gen_rtx (ASHIFT, SImode,\n-\t\t\t force_reg (SImode,\n-\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, pos / 8)),\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, 3));\n-}\")\n-\n-(define_expand \"extv\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(zero_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  int pos;\n+  /* Can't do this unless a byte extraction.  If extracting the high\n+     or low byte, don't do this because a shift or AND is shorter.\n+     Don't do 16-bit extracts, since the only two are the high and low\n+     ends, and it is faster to do them with CONSTH and SRL.  */\n \n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || GET_CODE (operands[3]) != CONST_INT)\n+  if (size != 8 || (pos != 8 && pos != 16))\n     FAIL;\n \n-  pos = INTVAL (operands[3]);\n-  if (INTVAL (operands[2]) != 16 || pos % 16 != 0)\n-    FAIL;\n+  operands[3] = gen_rtx (ASHIFT, PSImode,\n+\t\t\t force_reg (PSImode, GEN_INT (pos / 8)),\n+\t\t\t GEN_INT (3));\n \n-  operands[3] = gen_rtx (ASHIFT, SImode,\n-\t\t\t force_reg (SImode,\n-\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, pos / 8)),\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, 3));\n }\")\n \n ;; EXHW\n@@ -672,58 +650,75 @@\n \t\t(const_int -65536))\n \t\t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n \t\t\t\t (const_int 16)\n-\t\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t\t    (const_int 3)))))]\n+\t\t\t\t (ashift:PSI\n+\t\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n+\t\t\t\t  (const_int 3)))))]\n   \"\"\n   \"exhw %0,%2,%1\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(zero_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t (const_int 16)\n-\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n-\t\t\t\t    (const_int 3))))]\n+\t\t\t (ashift:PSI\n+\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n+\t\t\t  (const_int 3))))]\n   \"\"\n   \"exhw %0,%1,0\")\n \n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n \t\t\t (const_int 16)\n-\t\t\t (match_operand:SI 1 \"const_16_operand\" \"\"))\n+\t\t\t (match_operand:PSI 1 \"const_16_operand\" \"\"))\n \t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n \t\t\t (const_int 16)\n-\t\t\t (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t    (const_int 3))))]\n+\t\t\t (ashift:PSI\n+\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n+\t\t\t  (const_int 3))))]\n   \"\"\n   \"exhw %0,%2,%0\")\n \n ;; EXHWS\n+;;\n+;; This is probably unused.  The high-order 16-bits are obtained with an SRA\n+;; insn.  The low-order 16 bits are a sign-extend, which is a pair of\n+;; shifts.  Setting BP followed by the insn is equivalent, so we don't\n+;; bother going to any trouble to generate this insn.\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t (const_int 16)\n-\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n-\t\t\t\t    (const_int 3))))]\n+\t\t\t (ashift:PSI\n+\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n+\t\t\t  (const_int 3))))]\n   \"\"\n   \"exhws %0,%1\")\n \f\n ;; EXTRACT\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t   (reg:QI 178)))]\n+\t\t   (match_operand:PSI 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"extract %0,%1,%1\")\n \n (define_expand \"rotlsi3\"\n-  [(set (reg:QI 178)\n-\t(match_operand: SI 2 \"gpc_reg_or_immediate_operand\" \"\"))\n+  [(set (match_dup 3)\n+\t(match_operand:SI 2 \"gpc_reg_or_immediate_operand\" \"\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t   (reg:QI 178)))]\n+\t\t   (match_dup 3)))]\n   \"\"\n   \"\n-{ operands[2] = gen_lowpart (QImode, operands[2]); }\")\n+{ operands[2] = gen_lowpart (PSImode, operands[2]);\n+  operands[3] = gen_reg_rtx (PSImode);\n+}\")\n+\n+;; It would be nice to be able to have a define_split corresponding to the\n+;; above, but there is no way to tell combine we need a PSImode temporary.\n+;; If we put a (clobber (scratch:PSI)) there, combine would merge the above\n+;; two insns.  This is bad because it then thinks only one insn is needed.\n \f\n ;; FADD\n (define_expand \"addsf3\"\n@@ -898,65 +893,51 @@\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n \t\t\t (const_int 8)\n-\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n-\t\t\t\t    (const_int 3)))\n+\t\t\t (ashift:PSI\n+\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n+\t\t\t  (const_int 3)))\n \t(match_operand:SI 1 \"srcb_operand\" \"rI\"))]\n   \"\"\n   \"inbyte %0,%0,%1\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 255)\n-\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t\t\t      (const_int 3))))\n-\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(ashift:SI (and:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n-\t\t\t\t   (const_int 255))\n-\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n-  \"\"\n-  \"inbyte %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 255)\n-\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t\t\t      (const_int 3))))\n-\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(ashift:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n-\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n+\t(ior:SI (and:SI\n+\t\t (not:SI\n+\t\t  (ashift:SI (const_int 255)\n+\t\t\t     (ashift:PSI\n+\t\t\t      (match_operand:PSI 3 \"register_operand\" \"b\")\n+\t\t\t      (const_int 3))))\n+\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t(ashift:SI (zero_extend:SI\n+\t\t\t    (match_operand:QI 2 \"srcb_operand\" \"rI\"))\n+\t\t\t   (ashift:PSI (match_dup 3) (const_int 3)))))]\n   \"\"\n   \"inbyte %0,%1,%2\")\n \n ;; INHW\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n \t\t\t (const_int 16)\n-\t\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"b\")\n-\t\t\t\t    (const_int 3)))\n+\t\t\t (ashift:PSI\n+\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n+\t\t\t  (const_int 3)))\n \t(match_operand:SI 1 \"srcb_operand\" \"rI\"))]\n   \"\"\n   \"inhw %0,%0,%1\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 65535)\n-\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t\t\t      (const_int 3))))\n-\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(ashift:SI (and:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n-\t\t\t\t   (const_int 65535))\n-\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n-  \"\"\n-  \"inhw %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 65535)\n-\t\t\t\t\t   (ashift:SI (match_operand:SI 3 \"register_operand\" \"b\")\n-\t\t\t\t\t\t      (const_int 3))))\n-\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(ashift:SI (match_operand:SI 2 \"srcb_operand\" \"rI\")\n-\t\t\t   (match_operand:SI 4 \"const_24_operand\" \"\"))))]\n+\t(ior:SI (and:SI\n+\t\t (not:SI\n+\t\t  (ashift:SI (const_int 65535)\n+\t\t\t     (ashift:PSI\n+\t\t\t      (match_operand:PSI 3 \"register_operand\" \"b\")\n+\t\t\t      (const_int 3))))\n+\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t(ashift:SI (zero_extend:SI\n+\t\t\t    (match_operand:HI 2 \"srcb_operand\" \"rI\"))\n+\t\t\t   (ashift:PSI (match_dup 3) (const_int 3)))))]\n   \"\"\n   \"inhw %0,%1,%2\")\n \n@@ -979,47 +960,71 @@\n   if ((size != 8 && size != 16) || pos % size != 0)\n     FAIL;\n \n-  operands[2] = gen_rtx (ASHIFT, SImode,\n-\t\t\t force_reg (SImode,\n-\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, pos / 8)),\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, 3));\n+  operands[2] = gen_rtx (ASHIFT, PSImode,\n+\t\t\t force_reg (PSImode, GEN_INT (pos / 8)),\n+\t\t\t GEN_INT (3));\n }\")\n \f\n ;; LOAD (also used by move insn).\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(mem:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t(const_int -4))))\n-   (set (reg:SI 177)\n-\t(and:SI (match_dup 1)\n-\t\t(const_int 3)))]\n+   (set (match_operand:PSI 2 \"register_operand\" \"=b\")\n+\t(truncate:PSI (match_dup 1)))]\n   \"! TARGET_DW_ENABLE\"\n-  \"load 0,17,%0,%1\"\n+  \"load 0,16,%0,%1\"\n   [(set_attr \"type\" \"load\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(mem:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(const_int -4))))\n-   (set (reg:SI 177)\n-\t(and:SI (match_dup 1)\n-\t\t(const_int 2)))]\n-  \"! TARGET_DW_ENABLE\"\n-  \"load 0,18,%0,%1\"\n+\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_DW_ENABLE\"\n+  \"load 0,1,%0,%1\"\n   [(set_attr \"type\" \"load\")])\n \n (define_insn \"\"\n-  [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operator 2 \"extend_operator\"\n-\t\t\t[(match_operand 1 \"memory_operand\" \"m\")]))]\n-  \"TARGET_DW_ENABLE && GET_MODE (operands[0]) == GET_MODE (operands[2])\"\n-  \"load 0,%X2,%0,%1\"\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_DW_ENABLE\"\n+  \"load 0,1,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_DW_ENABLE\"\n+  \"load 0,2,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:PSI 2 \"=b\"))]\n+  \"TARGET_DW_ENABLE\"\n+  \"load 0,17,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:PSI 2 \"=b\"))]\n+  \"TARGET_DW_ENABLE\"\n+  \"load 0,17,%0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:PSI 2 \"=b\"))]\n+  \"TARGET_DW_ENABLE\"\n+  \"load 0,18,%0,%1\"\n   [(set_attr \"type\" \"load\")])\n \f\n ;; LOADM\n (define_expand \"load_multiple\"\n-  [(set (reg:SI 179)\n-\t(match_operand:SI 2 \"const_int_operand\" \"\"))\n+  [(set (match_dup 4)\n+\t(match_operand:PSI 2 \"const_int_operand\" \"\"))\n    (match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n \t\t\t  (match_operand:SI 1 \"\" \"\"))])]\n   \"\"\n@@ -1042,17 +1047,17 @@\n   regno = REGNO (operands[0]);\n \n   /* CR gets set to the number of registers minus one.  */\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode, count - 1);\n+  operands[2] = GEN_INT(count - 1);\n \n   operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 2));\n   from = memory_address (SImode, XEXP (operands[1], 0));\n   XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n \t\t\t\t\t gen_rtx (REG, SImode, regno),\n \t\t\t\t\t gen_rtx (MEM, SImode, from));\n-  XVECEXP (operands[3], 0, 1)\n-    = gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, R_CR));\n-  XVECEXP (operands[3], 0, 2)\n-    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+  operands[4] = gen_reg_rtx (PSImode);\n+\n+  XVECEXP (operands[3], 0, 1) = gen_rtx (USE, VOIDmode, operands[4]);\n+  XVECEXP (operands[3], 0, 2) = gen_rtx (CLOBBER, VOIDmode, operands[4]);\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 2)\n@@ -1064,8 +1069,8 @@\n (define_insn \"\"\n   [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n \t(match_operand 1 \"memory_operand\" \"m\"))\n-   (use (reg:SI 179))\n-   (clobber (reg:SI 179))]\n+   (use (match_operand:PSI 2 \"register_operand\" \"+c\"))\n+   (clobber (match_dup 2))]\n   \"GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\n    && ! TARGET_29050\"\n@@ -1075,8 +1080,8 @@\n (define_insn \"\"\n   [(set (match_operand 0 \"gpc_reg_operand\" \"=&r\")\n \t(match_operand 1 \"memory_operand\" \"m\"))\n-   (use (reg:SI 179))\n-   (clobber (reg:SI 179))]\n+   (use (match_operand:PSI 2 \"register_operand\" \"+c\"))\n+   (clobber (match_dup 2))]\n   \"GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\n    && TARGET_29050\"\n@@ -1087,8 +1092,8 @@\n   [(match_parallel 0 \"load_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"gpc_reg_operand\" \"=r\")\n \t\t\t (match_operand:SI 2 \"memory_operand\" \"m\"))\n-\t\t    (use (reg:SI 179))\n-\t\t    (clobber (reg:SI 179))])]\n+\t\t    (use (match_operand:PSI 3 \"register_operand\" \"+c\"))\n+\t\t    (clobber (match_dup 3))])]\n   \"! TARGET_29050\"\n   \"loadm 0,0,%1,%2\"\n   [(set_attr \"type\" \"load\")])\n@@ -1097,8 +1102,8 @@\n   [(match_parallel 0 \"load_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"gpc_reg_operand\" \"=&r\")\n \t\t\t (match_operand:SI 2 \"memory_operand\" \"m\"))\n-\t\t    (use (reg:SI 179))\n-\t\t    (clobber (reg:SI 179))])]\n+\t\t    (use (match_operand:PSI 3 \"register_operand\" \"+c\"))\n+\t\t    (clobber (match_dup 3))])]\n   \"TARGET_29050\"\n   \"loadm 0,0,%1,%2\"\n   [(set_attr \"type\" \"load\")])\n@@ -1112,6 +1117,15 @@\n   \"@\n    mtsr %0,%1\n    mtsrim %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=h,h\")\n+\t(truncate:PSI\n+\t (match_operand:SI 1 \"gpc_reg_or_immediate_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+   mtsr %0,%1\n+   mtsrim %0,%1\")\n \f\n ;; MULTIPLY, MULTM, MULTMU\n (define_insn \"mulsi3\"\n@@ -1258,6 +1272,21 @@\n   \"\"\n   \"sll %0,%1,%Q2\")\n \n+;; SQRT\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n+\t(sqrt:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_29050\"\n+  \"sqrt %0,%1,1\"\n+  [(set_attr \"type\" \"fsqrt\")])\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n+\t(sqrt:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_29050\"\n+  \"sqrt %0,%1,2\"\n+  [(set_attr \"type\" \"dsqrt\")])\n+\n ;; SRA\n (define_insn \"ashrsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n@@ -1317,8 +1346,8 @@\n }\")\n \n (define_expand \"store_multiple_no_bug\"\n-  [(set (reg:SI 179)\n-\t(match_operand:SI 2 \"const_int_operand\" \"\"))\n+  [(set (match_dup 4)\n+\t(match_operand:PSI 2 \"const_int_operand\" \"\"))\n    (match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n \t\t\t  (match_operand:SI 1 \"\" \"\"))])]\n   \"\"\n@@ -1341,17 +1370,16 @@\n   regno = REGNO (operands[1]);\n \n   /* CR gets set to the number of registers minus one.  */\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode, count - 1);\n+  operands[2] = GEN_INT(count - 1);\n \n   operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 2));\n   from = memory_address (SImode, XEXP (operands[0], 0));\n   XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n \t\t\t\t\t gen_rtx (MEM, SImode, from),\n \t\t\t\t\t gen_rtx (REG, SImode, regno));\n-  XVECEXP (operands[3], 0, 1)\n-    = gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, R_CR));\n-  XVECEXP (operands[3], 0, 2)\n-    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+  operands[4] = gen_reg_rtx (PSImode);\n+  XVECEXP (operands[3], 0, 1) = gen_rtx (USE, VOIDmode, operands[4]);\n+  XVECEXP (operands[3], 0, 2) = gen_rtx (CLOBBER, VOIDmode, operands[4]);\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 2)\n@@ -1389,7 +1417,7 @@\n \t\t\t\t\t gen_rtx (MEM, SImode, from),\n \t\t\t\t\t gen_rtx (REG, SImode, regno));\n   XVECEXP (operands[3], 0, 1)\n-    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, R_CR));\n+    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, PSImode));\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 1)\n@@ -1401,7 +1429,7 @@\n (define_insn \"\"\n   [(set (match_operand 0 \"memory_operand\" \"=m\")\n \t(match_operand 1 \"gpc_reg_operand\" \"r\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"=c\"))]\n   \"!TARGET_NO_STOREM_BUG\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\"\n@@ -1412,16 +1440,16 @@\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-\t\t    (clobber (reg:SI 179))])]\n+\t\t    (clobber (match_scratch:PSI 3 \"=c\"))])]\n   \"!TARGET_NO_STOREM_BUG\"\n   \"mtsrim cr,%V0\\;storem 0,0,%2,%1\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"memory_operand\" \"=m\")\n \t(match_operand 1 \"gpc_reg_operand\" \"r\"))\n-   (use (reg:SI 179))\n-   (clobber (reg:SI 179))]\n+   (use (match_operand:PSI 2 \"register_operand\" \"+c\"))\n+   (clobber (match_dup 2))]\n   \"TARGET_NO_STOREM_BUG\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\"\n@@ -1432,8 +1460,8 @@\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-\t\t    (use (reg:SI 179))\n-\t\t    (clobber (reg:SI 179))])]\n+\t\t    (use (match_operand:PSI 3 \"register_operand\" \"+c\"))\n+\t\t    (clobber (match_dup 3))])]\n   \"TARGET_NO_STOREM_BUG\"\n   \"storem 0,0,%2,%1\"\n   [(set_attr \"type\" \"store\")])\n@@ -1519,8 +1547,7 @@\n       target = operand_subword_force (operands[0], 0, SFmode);\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, SFmode),\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode, 0x80000000),\n-\t\t\t     target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -1550,8 +1577,7 @@\n       target = operand_subword (operands[0], 0, 1, DFmode);\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, DFmode),\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode, 0x80000000),\n-\t\t\t     target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -1644,6 +1670,21 @@\n     operands[1] = force_reg (SImode, operands[1]);\n }\")\n \n+(define_expand \"movpsi\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n+\t(match_operand:PSI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! gpc_reg_operand (operands[1], PSImode))\n+    operands[1] = copy_to_mode_reg (PSImode, operands[1]);\n+  else if (spec_reg_operand (operands[0], PSImode)\n+\t   && ! (register_operand (operands[1], PSImode)\n+\t\t || cint_16_operand (operands[1], PSImode)))\n+    operands[1] = force_reg (PSImode, operands[1]);\n+}\")\n+\n (define_split\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:SI 1 \"long_const_operand\" \"\"))]\n@@ -1652,86 +1693,66 @@\n \t(and:SI (match_dup 1)\n \t\t(const_int 65535)))\n    (set (match_dup 0)\n-\t(ior:SI (and:SI (match_dup 0)\n-\t\t\t(const_int 65535))\n+\t(ior:SI (zero_extend:SI (subreg:HI (match_dup 0) 0))\n \t\t(and:SI (match_dup 1)\n \t\t\t(const_int -65536))))]\n   \"\")\n \f\n-;; Subroutines to load/store halfwords.  Use TAV (gr121) as scratch.  We have\n-;; two versions of storehi, one when halfword writes are supported and one\n-;; where they aren't.\n+;; Subroutines to load/store halfwords.  Operands 0 and 1 are the output and\n+;; input, respectively, except that the address is passed for a MEM instead \n+;; of the MEM itself and the short item is passed in QImode.\n+;;\n+;; Operand 2 is a scratch general register and operand 3 is a scratch register\n+;; used for BP.  When called before reload, pseudos are passed for both\n+;; operands.  During reload, R_TAV is used for the general register, and\n+;; a reload register of class BR_REGS (R_VP) for BP.\n+;;\n+;; We have two versions of the store operations, for when halfword writes are\n+;; supported and when they are not.\n (define_expand \"loadhi\"\n-  [(parallel [(set (match_dup 2)\n-\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+  [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+\t\t   (mem:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t   (const_int -4))))\n-\t      (set (reg:SI 177)\n-\t\t   (and:SI (match_dup 0)\n-\t\t\t   (const_int 2)))])\n-   (set (match_operand:HI 1 \"gpc_reg_operand\" \"\")\n+\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n+\t\t   (truncate:PSI (match_dup 1)))])\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(zero_extract:SI (match_dup 2)\n \t\t\t (const_int 16)\n-\t\t\t (ashift:SI (reg:SI 177)\n-\t\t\t\t    (const_int 3))))]\n+\t\t\t (ashift:PSI (match_dup 3) (const_int 3))))]\n   \"\"\n-  \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-\n-  if (reload_in_progress)\n-    operands[2] = gen_rtx (REG, SImode, R_TAV);\n-  else\n-    operands[2] = gen_reg_rtx (SImode);\n-}\")\n+  \"\")\n \n (define_expand \"storehinhww\"\n-  [(parallel [(set (match_dup 2)\n+ [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n \t\t   (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t\t\t\t   (const_int -4))))\n-\t      (set (reg:SI 177)\n-\t\t   (and:SI (match_dup 0)\n-\t\t\t     (const_int 2)))])\n+\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n+\t\t   (truncate:PSI (match_dup 0)))])\n    (set (zero_extract:SI (match_dup 2)\n \t\t\t (const_int 16)\n-\t\t\t (ashift:SI (reg:SI 177)\n-\t\t\t\t    (const_int 3)))\n-\t(match_operand:HI 1 \"gpc_reg_operand\" \"\"))\n+\t\t\t (ashift:PSI (match_dup 3) (const_int 3)))\n+\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n    (set (mem:SI (match_dup 0))\n \t(match_dup 2))]\n   \"\"\n-  \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-\n-  if (reload_in_progress)\n-    operands[2] = gen_rtx (REG, SImode, R_TAV);\n-  else\n-    operands[2] = gen_reg_rtx (SImode);\n-}\")\n+  \"\")\n \n (define_expand \"storehihww\"\n-  [(set (reg:SI 177)\n-\t(and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t(const_int 3)))\n-   (set (match_dup 2)\n+  [(set (match_operand:PSI 3 \"register_operand\" \"\")\n+\t(truncate:PSI (match_operand:SI 0 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n \t(ior:SI (and:SI (not:SI (ashift:SI (const_int 65535)\n-\t\t\t\t\t   (ashift:SI (reg:SI 177)\n-\t\t\t\t\t\t      (const_int 3))))\n-\t\t\t(match_operand:HI 1 \"gpc_reg_operand\" \"\"))\n-\t\t(ashift:SI (and:SI (match_dup 1)\n-\t\t\t\t   (const_int 65535))\n-\t\t\t   (ashift:SI (reg:SI 177)\n-\t\t\t\t      (const_int 3)))))\n+\t\t\t\t\t   (ashift:PSI (match_dup 3)\n+\t\t\t\t\t\t       (const_int 3))))\n+\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n+\t\t(ashift:SI (zero_extend:SI (match_dup 4))\n+\t\t\t   (ashift:PSI (match_dup 3) (const_int 3)))))\n    (set (mem:SI (and:SI (match_dup 0)\n \t\t\t(const_int -3)))\n \t(match_dup 2))]\n   \"\"\n   \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-\n-  if (reload_in_progress)\n-    operands[2] = gen_rtx (REG, SImode, R_TAV);\n-  else\n-    operands[2] = gen_reg_rtx (SImode);\n-}\")\n+{ operands[4] = gen_lowpart (HImode, operands[1]); }\")\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n@@ -1744,95 +1765,123 @@\n \toperands[1] = copy_to_mode_reg (HImode, operands[1]);\n       if (! TARGET_DW_ENABLE)\n \t{\n+\t  rtx general = gen_reg_rtx (SImode);\n+\t  rtx bp = gen_reg_rtx (PSImode);\n+\n \t  if (TARGET_BYTE_WRITES)\n-\t    emit_insn (gen_storehihww (XEXP (operands[0], 0), operands[1]));\n+\t    emit_insn (gen_storehihww (XEXP (operands[0], 0),\n+\t\t\t\t       gen_lowpart (SImode, operands[1]),\n+\t\t\t\t       general, bp));\n \t  else\n-\t    emit_insn (gen_storehinhww (XEXP (operands[0], 0), operands[1]));\n+\t    emit_insn (gen_storehinhww (XEXP (operands[0], 0),\n+\t\t\t\t\tgen_lowpart (SImode, operands[1]),\n+\t\t\t\t\tgeneral, bp));\n \t  DONE;\n \t}\n     }\n   else if (GET_CODE (operands[1]) == MEM)\n     {\n       if (! TARGET_DW_ENABLE)\n \t{\n-\t  emit_insn (gen_loadhi (XEXP (operands[1], 0), operands[0]));\n+\t  rtx general = gen_reg_rtx (SImode);\n+\t  rtx bp = gen_reg_rtx (PSImode);\n+\n+\t  emit_insn (gen_loadqi (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t XEXP (operands[1], 0), general, bp));\n \t  DONE;\n \t}\n     }\n }\")\n+\n+(define_expand \"reload_inhi\"\n+  [(parallel [(match_operand:SI 0 \"register_operand\" \"=r\")\n+\t      (match_operand:SI 1 \"reload_memory_operand\" \"m\")\n+\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n+  \"! TARGET_DW_ENABLE\"\n+  \"\n+{ emit_insn (gen_loadhi (gen_lowpart (SImode, operands[0]),\n+\t\t\t a29k_get_reloaded_address (operands[1]),\n+\t\t\t gen_rtx (REG, SImode, R_TAV),\n+\t\t\t operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outhi\"\n+  [(parallel [(match_operand:SI 0 \"reload_memory_operand\" \"=m\")\n+\t      (match_operand:SI 1 \"register_operand\" \"m\")\n+\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n+  \"! TARGET_DW_ENABLE\"\n+  \"\n+{ if (TARGET_BYTE_WRITES)\n+    emit_insn (gen_storehihww (a29k_get_reloaded_address (operands[0]),\n+\t\t\t       gen_lowpart (SImode, operands[1]),\n+\t\t\t       gen_rtx (REG, SImode, R_TAV),\n+\t\t\t       operands[2]));\n+  else\n+    emit_insn (gen_storehinhww (a29k_get_reloaded_address (operands[0]),\n+\t\t\t\tgen_lowpart (SImode, operands[1]),\n+\t\t\t\tgen_rtx (REG, SImode, R_TAV),\n+\t\t\t\toperands[2]));\n+  DONE;\n+}\")\n \f\n-;; Subroutines to load/store bytes.  Use TAV (gr121) as scratch.\n+;; Subroutines to load/store bytes.  Operands 0 and 1 are the output and\n+;; input, respectively, except that the address is passed for a MEM instead \n+;; of the MEM itself and the short item is passed in QImode.\n+;;\n+;; Operand 2 is a scratch general register and operand 3 is a scratch register\n+;; used for BP.  When called before reload, pseudos are passed for both\n+;; operands.  During reload, R_TAV is used for the general register, and\n+;; a reload register of class BR_REGS (R_VP) for BP.\n+;;\n+;; We have two versions of the store operations, for when byte writes are\n+;; supported and when they are not.\n (define_expand \"loadqi\"\n-  [(parallel [(set (match_dup 2)\n-\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+  [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+\t\t   (mem:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t   (const_int -4))))\n-\t      (set (reg:SI 177)\n-\t\t   (and:SI (match_dup 0)\n-\t\t\t   (const_int 3)))])\n-   (set (match_operand:QI 1 \"gpc_reg_operand\" \"\")\n+\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n+\t\t   (truncate:PSI (match_dup 1)))])\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(zero_extract:SI (match_dup 2)\n \t\t\t (const_int 8)\n-\t\t\t (ashift:SI (reg:SI 177)\n-\t\t\t\t    (const_int 3))))]\n+\t\t\t (ashift:PSI (match_dup 3) (const_int 3))))]\n   \"\"\n-  \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-\n-  if (reload_in_progress)\n-    operands[2] = gen_rtx (REG, SImode, R_TAV);\n-  else\n-    operands[2] = gen_reg_rtx (SImode);\n-}\")\n+  \"\")\n \n (define_expand \"storeqinhww\"\n-  [(parallel [(set (match_dup 2)\n+  [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n \t\t   (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t\t\t\t   (const_int -4))))\n-\t      (set (reg:SI 177)\n-\t\t   (and:SI (match_dup 0)\n-\t\t\t   (const_int 3)))])\n+\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n+\t\t   (truncate:PSI (match_dup 0)))])\n    (set (zero_extract:SI (match_dup 2)\n \t\t\t (const_int 8)\n-\t\t\t (ashift:SI (reg:SI 177)\n-\t\t\t\t    (const_int 3)))\n-\t(match_operand:QI 1 \"gpc_reg_operand\" \"\"))\n+\t\t\t (ashift:PSI (match_dup 3)\n+\t\t\t\t     (const_int 3)))\n+\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n    (set (mem:SI (match_dup 0))\n \t(match_dup 2))]\n   \"\"\n-  \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-\n-  if (reload_in_progress)\n-    operands[2] = gen_rtx (REG, SImode, R_TAV);\n-  else\n-    operands[2] = gen_reg_rtx (SImode);\n-}\")\n+  \"\")\n \n (define_expand \"storeqihww\"\n-  [(set (reg:SI 177)\n-\t(and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t(const_int 3)))\n-   (set (match_dup 2)\n+  [(set (match_operand:PSI 3 \"register_operand\" \"\")\n+\t(truncate:PSI (match_operand:SI 0 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n \t(ior:SI (and:SI (not:SI (ashift:SI (const_int 255)\n-\t\t\t\t\t   (ashift:SI (reg:SI 177)\n-\t\t\t\t\t\t      (const_int 3))))\n-\t\t\t(match_operand:HI 1 \"gpc_reg_operand\" \"\"))\n-\t\t(ashift:SI (and:SI (match_dup 1)\n-\t\t\t\t   (const_int 255))\n-\t\t\t   (ashift:SI (reg:SI 177)\n-\t\t\t\t      (const_int 3)))))\n+\t\t\t\t\t   (ashift:PSI (match_dup 3)\n+\t\t\t\t\t\t       (const_int 3))))\n+\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n+\t\t(ashift:SI (zero_extend:SI (match_dup 4))\n+\t\t\t   (ashift:PSI (match_dup 3)\n+\t\t\t\t       (const_int 3)))))\n    (set (mem:SI (and:SI (match_dup 0)\n \t\t        (const_int -4)))\n \t(match_dup 2))]\n   \"\"\n   \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-\n-  if (reload_in_progress)\n-    operands[2] = gen_rtx (REG, SImode, R_TAV);\n-  else\n-    operands[2] = gen_reg_rtx (SImode);\n-}\")\n+{ operands[4] = gen_lowpart (QImode, operands[1]); }\")\n \f\n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n@@ -1845,22 +1894,65 @@\n \toperands[1] = copy_to_mode_reg (QImode, operands[1]);\n       if (! TARGET_DW_ENABLE)\n \t{\n+\t  rtx general = gen_reg_rtx (SImode);\n+\t  rtx bp = gen_reg_rtx (PSImode);\n+\n \t  if (TARGET_BYTE_WRITES)\n-\t    emit_insn (gen_storeqihww (XEXP (operands[0], 0), operands[1]));\n+\t    emit_insn (gen_storeqihww (XEXP (operands[0], 0),\n+\t\t\t\t       gen_lowpart (SImode, operands[1]),\n+\t\t\t\t       general, bp));\n \t  else\n-\t    emit_insn (gen_storeqinhww (XEXP (operands[0], 0), operands[1]));\n+\t    emit_insn (gen_storeqinhww (XEXP (operands[0], 0),\n+\t\t\t\t\tgen_lowpart (SImode, operands[1]),\n+\t\t\t\t\tgeneral, bp));\n \t  DONE;\n \t}\n     }\n   else if (GET_CODE (operands[1]) == MEM)\n     {\n       if (! TARGET_DW_ENABLE)\n \t{\n-\t  emit_insn (gen_loadqi (XEXP (operands[1], 0), operands[0]));\n+\t  rtx general = gen_reg_rtx (SImode);\n+\t  rtx bp = gen_reg_rtx (PSImode);\n+\n+\t  emit_insn (gen_loadqi (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t XEXP (operands[1], 0), general, bp));\n \t  DONE;\n \t}\n     }\n }\")\n+\n+(define_expand \"reload_inqi\"\n+  [(parallel [(match_operand:SI 0 \"register_operand\" \"=r\")\n+\t      (match_operand:SI 1 \"reload_memory_operand\" \"m\")\n+\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n+  \"! TARGET_DW_ENABLE\"\n+  \"\n+{ emit_insn (gen_loadqi (gen_lowpart (SImode, operands[0]),\n+\t\t\t a29k_get_reloaded_address (operands[1]),\n+\t\t\t gen_rtx (REG, SImode, R_TAV),\n+\t\t\t operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outqi\"\n+  [(parallel [(match_operand:SI 0 \"reload_memory_operand\" \"=m\")\n+\t      (match_operand:SI 1 \"register_operand\" \"m\")\n+\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n+  \"! TARGET_DW_ENABLE\"\n+  \"\n+{ if (TARGET_BYTE_WRITES)\n+    emit_insn (gen_storeqihww (a29k_get_reloaded_address (operands[0]),\n+\t\t\t       gen_lowpart (SImode, operands[1]),\n+\t\t\t       gen_rtx (REG, SImode, R_TAV),\n+\t\t\t       operands[2]));\n+  else\n+    emit_insn (gen_storeqinhww (a29k_get_reloaded_address (operands[0]),\n+\t\t\t\tgen_lowpart (SImode, operands[1]),\n+\t\t\t\tgen_rtx (REG, SImode, R_TAV),\n+\t\t\t\toperands[2]));\n+  DONE;\n+}\")\n \f\n ;; Now the actual insns used to move data around.  We include here the\n ;; DEFINE_SPLITs that may be needed.  In some cases these will be\n@@ -1912,9 +2004,9 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"out_operand\" \"=r,r,r,m\")\n+  [(set (match_operand:DF 0 \"out_operand\" \"=?r,?r,r,m\")\n \t(match_operand:DF 1 \"in_operand\" \"rE,F,m,r\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"=X,X,&c,&c\"))]\n   \"(gpc_reg_operand (operands[0], DFmode)\n     || gpc_reg_operand (operands[1], DFmode))\n    && ! TARGET_29050\"\n@@ -1926,9 +2018,9 @@\n   [(set_attr \"type\" \"multi\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"out_operand\" \"=r,r,&r,m,*a,r\")\n+  [(set (match_operand:DF 0 \"out_operand\" \"=?r,?r,&r,m,?*a,?r\")\n \t(match_operand:DF 1 \"in_operand\" \"rE,F,m,r,r,*a\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"=X,X,&c,&c,X,X\"))]\n   \"(gpc_reg_operand (operands[0], DFmode)\n     || gpc_reg_operand (operands[1], DFmode))\n    && TARGET_29050\"\n@@ -1951,51 +2043,51 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"gpc_reg_or_float_constant_operand\" \"\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"\"))]\n   \"reload_completed\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))]\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 5) (match_dup 6))]\n   \"\n { if (GET_CODE (operands[1]) == REG\n       && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n     {\n-      operands[2] = operand_subword (operands[0], 1, 1, DFmode);\n-      operands[3] = operand_subword (operands[1], 1, 1, DFmode);\n-      operands[4] = operand_subword (operands[0], 0, 1, DFmode);\n-      operands[5] = operand_subword (operands[1], 0, 1, DFmode);\n+      operands[3] = operand_subword (operands[0], 1, 1, DFmode);\n+      operands[4] = operand_subword (operands[1], 1, 1, DFmode);\n+      operands[5] = operand_subword (operands[0], 0, 1, DFmode);\n+      operands[6] = operand_subword (operands[1], 0, 1, DFmode);\n     }\n   else\n     {\n-      operands[2] = operand_subword (operands[0], 0, 1, DFmode);\n-      operands[3] = operand_subword (operands[1], 0, 1, DFmode);\n-      operands[4] = operand_subword (operands[0], 1, 1, DFmode);\n-      operands[5] = operand_subword (operands[1], 1, 1, DFmode);\n+      operands[3] = operand_subword (operands[0], 0, 1, DFmode);\n+      operands[4] = operand_subword (operands[1], 0, 1, DFmode);\n+      operands[5] = operand_subword (operands[0], 1, 1, DFmode);\n+      operands[6] = operand_subword (operands[1], 1, 1, DFmode);\n     }\n \n-  if (operands[2] == 0 || operands[3] == 0\n-      || operands[4] == 0 || operands[5] == 0)\n+  if (operands[3] == 0 || operands[4] == 0\n+      || operands[5] == 0 || operands[6] == 0)\n     FAIL;\n }\")\n \n ;; Split memory loads and stores into the MTSR and LOADM/STOREM.\n (define_split\n   [(set (match_operand:DF 0 \"out_operand\" \"\")\n \t(match_operand:DF 1 \"in_operand\" \"\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (reg:PSI 179))]\n   \"TARGET_NO_STOREM_BUG\n    && (memory_operand (operands[0], DFmode)\n        || memory_operand (operands[1], DFmode))\"\n-  [(set (reg:SI 179) (const_int 1))\n+  [(set (reg:PSI 179) (const_int 1))\n    (parallel [(set (match_dup 0) (match_dup 1))\n-\t      (use (reg:SI 179))\n-\t      (clobber (reg:SI 179))])]\n+\t      (use (reg:PSI 179))\n+\t      (clobber (reg:PSI 179))])]\n   \"\")\n \n ;; DI move is similar to DF move.\n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"out_operand\" \"=r,r,m\")\n+  [(set (match_operand:DI 0 \"out_operand\" \"=?r,r,m\")\n \t(match_operand:DI 1 \"in_operand\" \"rn,m,r\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"=X,&c,&c\"))]\n   \"(gpc_reg_operand (operands[0], DImode)\n      || gpc_reg_operand (operands[1], DImode))\n    && ! TARGET_29050\"\n@@ -2006,9 +2098,9 @@\n   [(set_attr \"type\" \"multi\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"out_operand\" \"=r,&r,m\")\n+  [(set (match_operand:DI 0 \"out_operand\" \"=?r,&r,m\")\n \t(match_operand:DI 1 \"in_operand\" \"rn,m,r\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"=X,&c,&c\"))]\n   \"(gpc_reg_operand (operands[0], DImode)\n      || gpc_reg_operand (operands[1], DImode))\n    && TARGET_29050\"\n@@ -2021,47 +2113,47 @@\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DI 1 \"gpc_reg_or_integer_constant_operand\" \"\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"\"))]\n   \"reload_completed\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))]\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 5) (match_dup 6))]\n   \"\n { if (GET_CODE (operands[1]) == REG\n       && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n     {\n-      operands[2] = operand_subword (operands[0], 1, 1, DImode);\n-      operands[3] = operand_subword (operands[1], 1, 1, DImode);\n-      operands[4] = operand_subword (operands[0], 0, 1, DImode);\n-      operands[5] = operand_subword (operands[1], 0, 1, DImode);\n+      operands[3] = operand_subword (operands[0], 1, 1, DImode);\n+      operands[4] = operand_subword (operands[1], 1, 1, DImode);\n+      operands[5] = operand_subword (operands[0], 0, 1, DImode);\n+      operands[6] = operand_subword (operands[1], 0, 1, DImode);\n     }\n   else\n     {\n-      operands[2] = operand_subword (operands[0], 0, 1, DImode);\n-      operands[3] = operand_subword (operands[1], 0, 1, DImode);\n-      operands[4] = operand_subword (operands[0], 1, 1, DImode);\n-      operands[5] = operand_subword (operands[1], 1, 1, DImode);\n+      operands[3] = operand_subword (operands[0], 0, 1, DImode);\n+      operands[4] = operand_subword (operands[1], 0, 1, DImode);\n+      operands[5] = operand_subword (operands[0], 1, 1, DImode);\n+      operands[6] = operand_subword (operands[1], 1, 1, DImode);\n     }\n }\")\n \n (define_split\n   [(set (match_operand:DI 0 \"out_operand\" \"\")\n \t(match_operand:DI 1 \"in_operand\" \"\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (reg:PSI 179))]\n   \"TARGET_NO_STOREM_BUG\n    && (memory_operand (operands[0], DImode)\n        || memory_operand (operands[1], DImode))\"\n-  [(set (reg:SI 179) (const_int 1))\n+  [(set (reg:PSI 179) (const_int 1))\n    (parallel [(set (match_dup 0) (match_dup 1))\n-\t      (use (reg:SI 179))\n-\t      (clobber (reg:SI 179))])]\n+\t      (use (reg:PSI 179))\n+\t      (clobber (reg:PSI 179))])]\n   \"\")\n \n ;; TImode moves are very similar to DImode moves, except that we can't\n ;; have constants.\n (define_insn \"\"\n-  [(set (match_operand:TI 0 \"out_operand\" \"=r,r,m\")\n+  [(set (match_operand:TI 0 \"out_operand\" \"=?r,r,m\")\n \t(match_operand:TI 1 \"in_operand\" \"r,m,r\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"=X,&c,&c\"))]\n   \"(gpc_reg_operand (operands[0], TImode)\n     || gpc_reg_operand (operands[1], TImode))\n    && ! TARGET_29050\"\n@@ -2072,9 +2164,9 @@\n   [(set_attr \"type\" \"multi,multi,multi\")])\n \n (define_insn \"\"\n-  [(set (match_operand:TI 0 \"out_operand\" \"=r,&r,m\")\n+  [(set (match_operand:TI 0 \"out_operand\" \"=?r,&r,m\")\n \t(match_operand:TI 1 \"in_operand\" \"r,m,r\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"=X,&c,&c\"))]\n   \"(gpc_reg_operand (operands[0], TImode)\n     || gpc_reg_operand (operands[1], TImode))\n    && TARGET_29050\"\n@@ -2087,50 +2179,50 @@\n (define_split\n   [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:TI 1 \"gpc_reg_operand\" \"\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (match_scratch:PSI 2 \"\"))]\n   \"reload_completed\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))\n-   (set (match_dup 6) (match_dup 7))\n-   (set (match_dup 8) (match_dup 9))]\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 5) (match_dup 6))\n+   (set (match_dup 7) (match_dup 8))\n+   (set (match_dup 9) (match_dup 10))]\n   \"\n {\n   if (REGNO (operands[0]) >= REGNO (operands[1]) + 1\n       && REGNO (operands[0]) <= REGNO (operands[1]) + 3)\n     {\n-      operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n-      operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3);\n-      operands[4] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n-      operands[5] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n-      operands[6] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-      operands[7] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n-      operands[8] = gen_rtx (REG, SImode, REGNO (operands[0]));\n-      operands[9] = gen_rtx (REG, SImode, REGNO (operands[1]));\n+      operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n+      operands[4] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3);\n+      operands[5] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+      operands[6] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+      operands[7] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      operands[8] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      operands[9] = gen_rtx (REG, SImode, REGNO (operands[0]));\n+      operands[10] = gen_rtx (REG, SImode, REGNO (operands[1]));\n     }\n   else\n     {\n-      operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]));\n-      operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]));\n-      operands[4] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-      operands[5] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n-      operands[6] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n-      operands[7] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n-      operands[8] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n-      operands[9] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3); \n+      operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]));\n+      operands[4] = gen_rtx (REG, SImode, REGNO (operands[1]));\n+      operands[5] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      operands[6] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      operands[7] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+      operands[8] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+      operands[9] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n+      operands[10] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3); \n     }\n }\")\n \n (define_split\n   [(set (match_operand:TI 0 \"out_operand\" \"\")\n \t(match_operand:TI 1 \"in_operand\" \"\"))\n-   (clobber (reg:SI 179))]\n+   (clobber (reg:PSI 179))]\n   \"TARGET_NO_STOREM_BUG\n    && (memory_operand (operands[0], TImode)\n        || memory_operand (operands[1], TImode))\"\n-  [(set (reg:SI 179) (const_int 1))\n+  [(set (reg:PSI 179) (const_int 1))\n    (parallel [(set (match_dup 0) (match_dup 1))\n-\t      (use (reg:SI 179))\n-\t      (clobber (reg:SI 179))])]\n+\t      (use (reg:PSI 179))\n+\t      (clobber (reg:PSI 179))])]\n   \"\")\n \n (define_insn \"\"\n@@ -2175,11 +2267,30 @@\n    mtsrim %0,%1\"\n   [(set_attr \"type\" \"misc,misc,misc,misc,multi,load,misc,store,misc,misc\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"out_operand\" \"=*r,*r,*r,*r,m,h,h\")\n+        (match_operand:PSI 1 \"in_operand\" \"r,i,m,h,r,r,J\"))]\n+  \"(gpc_reg_operand (operands[0], PSImode)\n+    || gpc_reg_operand (operands[1], PSImode)\n+    || (spec_reg_operand (operands[0], PSImode)\n+        && cint_16_operand (operands[1], PSImode)))\"\n+  \"@\n+   sll %0,%1,0\n+   const %0,%1\n+   load 0,0,%0,%1\n+   mfsr %0,%1\n+   store 0,0,%1,%0\n+   mtsr %0,%1\n+   mtsrim %0,%1\"\n+  [(set_attr \"type\" \"misc,multi,load,misc,store,misc,misc\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"out_operand\" \"=r,r,r,m,r,*h,*h\")\n         (match_operand:HI 1 \"in_operand\" \"r,i,m,r,*h,r,i\"))]\n   \"gpc_reg_operand (operands[0], HImode)\n-   || gpc_reg_operand (operands[1], HImode)\"\n+   || gpc_reg_operand (operands[1], HImode)\n+   || (spec_reg_operand (operands[0], HImode)\n+       && cint_16_operand (operands[1], HImode))\"\n   \"@\n    sll %0,%1,0\n    const %0,%1\n@@ -2194,7 +2305,9 @@\n   [(set (match_operand:QI 0 \"out_operand\" \"=r,r,r,m,r,*h,*h\")\n         (match_operand:QI 1 \"in_operand\" \"r,i,m,r,*h,r,i\"))]\n   \"gpc_reg_operand (operands[0], QImode)\n-   || gpc_reg_operand (operands[1], QImode)\"\n+   || gpc_reg_operand (operands[1], QImode)\n+   || (spec_reg_operand (operands[0], HImode)\n+       && cint_16_operand (operands[1], HImode))\"\n   \"@\n    sll %0,%1,0\n    const %0,%1\n@@ -2214,11 +2327,11 @@\n ;;\n ;; In other cases, handle similarly to SImode moves.\n ;;\n-;; However, indicate that DI, TI, and DF moves (can) clobber CR (reg 179).\n+;; However, indicate that DI, TI, and DF moves may clobber CR (reg 179).\n (define_expand \"movdi\"\n   [(parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n \t\t   (match_operand:DI 1 \"general_operand\" \"\"))\n-\t      (clobber (reg:SI 179))])]\n+\t      (clobber (scratch:PSI))])]\n   \"\"\n   \"\n {\n@@ -2238,7 +2351,7 @@\n (define_expand \"movdf\"\n   [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t\t   (match_operand:DF 1 \"general_operand\" \"\"))\n-\t      (clobber (reg:SI 179))])]\n+\t      (clobber (scratch:PSI))])]\n   \"\"\n   \"\n { if (GET_CODE (operands[0]) == MEM)\n@@ -2248,7 +2361,7 @@\n (define_expand \"movti\"\n   [(parallel [(set (match_operand:TI 0 \"general_operand\" \"\")\n \t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n-\t      (clobber (reg:SI 179))])]\n+\t      (clobber (scratch:PSI))])]\n   \"\"\n   \"\n {\n@@ -2285,6 +2398,50 @@\n     }\n }\")\n \f\n+;; Here are the variants of the above for use during reload.\n+\n+(define_expand \"reload_indf\"\n+  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t\t   (match_operand:DF 1 \"reload_memory_operand\" \"m\"))\n+\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&b\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outdf\"\n+  [(parallel [(set (match_operand:DF 0 \"reload_memory_operand\" \"=m\")\n+\t\t   (match_operand:DF 1 \"register_operand\" \"r\"))\n+\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&b\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_indi\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t\t   (match_operand:DI 1 \"reload_memory_operand\" \"m\"))\n+\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&b\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outdi\"\n+  [(parallel [(set (match_operand:DI 0 \"reload_memory_operand\" \"=m\")\n+\t\t   (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&b\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_inti\"\n+  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t\t   (match_operand:TI 1 \"reload_memory_operand\" \"m\"))\n+\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&b\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outti\"\n+  [(parallel [(set (match_operand:TI 0 \"reload_memory_operand\" \"=m\")\n+\t\t   (match_operand:TI 1 \"register_operand\" \"r\"))\n+\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&b\"))])]\n+  \"\"\n+  \"\")\n+\f\n ;; For compare operations, we simply store the comparison operands and\n ;; do nothing else.  The following branch or scc insn will output whatever\n ;; is needed."}]}