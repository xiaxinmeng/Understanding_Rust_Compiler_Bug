{"sha": "b383fcb4f80a95b55a3202c18f71919025e1dd0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4M2ZjYjRmODBhOTViNTVhMzIwMmMxOGY3MTkxOTAyNWUxZGQwZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-08-13T08:47:40Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-08-13T08:47:40Z"}, "message": "parser.c (cp_parser_elaborated_type_specifier): Handle specially cp_parser_template_id returning a BASELINK.\n\n2014-08-13  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* parser.c (cp_parser_elaborated_type_specifier): Handle\n\tspecially cp_parser_template_id returning a BASELINK.\n\n2014-08-13  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* parser.c (cp_parser_diagnose_invalid_type_name,\n\tcp_parser_make_typename_type): Remove scope parameter.\n\t(cp_parser_parse_and_diagnose_invalid_type_name,\n\tcp_parser_elaborated_type_specifier): Adjust calls.\n\nFrom-SVN: r213897", "tree": {"sha": "62b86b2739267d03d636f2c9bc2ee3e76dfe937f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62b86b2739267d03d636f2c9bc2ee3e76dfe937f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b383fcb4f80a95b55a3202c18f71919025e1dd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b383fcb4f80a95b55a3202c18f71919025e1dd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b383fcb4f80a95b55a3202c18f71919025e1dd0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b383fcb4f80a95b55a3202c18f71919025e1dd0d/comments", "author": null, "committer": null, "parents": [{"sha": "945da8c7eaa27c50976d75500def6f60bb17117f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/945da8c7eaa27c50976d75500def6f60bb17117f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/945da8c7eaa27c50976d75500def6f60bb17117f"}], "stats": {"total": 55, "additions": 35, "deletions": 20}, "files": [{"sha": "9d24958ee491b0b54faf87107474665b5bab34c5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b383fcb4f80a95b55a3202c18f71919025e1dd0d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b383fcb4f80a95b55a3202c18f71919025e1dd0d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b383fcb4f80a95b55a3202c18f71919025e1dd0d", "patch": "@@ -1,3 +1,15 @@\n+2014-08-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* parser.c (cp_parser_elaborated_type_specifier): Handle\n+\tspecially cp_parser_template_id returning a BASELINK.\n+\n+2014-08-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* parser.c (cp_parser_diagnose_invalid_type_name,\n+\tcp_parser_make_typename_type): Remove scope parameter.\n+\t(cp_parser_parse_and_diagnose_invalid_type_name,\n+\tcp_parser_elaborated_type_specifier): Adjust calls.\n+\n 2014-08-12  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tReject virt-specifiers on friends and member templates"}, {"sha": "4c04de7f9965156d5bcba8fe83448ec8a72954fa", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b383fcb4f80a95b55a3202c18f71919025e1dd0d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b383fcb4f80a95b55a3202c18f71919025e1dd0d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b383fcb4f80a95b55a3202c18f71919025e1dd0d", "patch": "@@ -2454,7 +2454,7 @@ static void cp_parser_check_for_invalid_template_id\n static bool cp_parser_non_integral_constant_expression\n   (cp_parser *, non_integral_constant);\n static void cp_parser_diagnose_invalid_type_name\n-  (cp_parser *, tree, tree, location_t);\n+  (cp_parser *, tree, location_t);\n static bool cp_parser_parse_and_diagnose_invalid_type_name\n   (cp_parser *);\n static int cp_parser_skip_to_closing_parenthesis\n@@ -2482,7 +2482,7 @@ static bool cp_parser_is_string_literal\n static bool cp_parser_is_keyword\n   (cp_token *, enum rid);\n static tree cp_parser_make_typename_type\n-  (cp_parser *, tree, tree, location_t location);\n+  (cp_parser *, tree, location_t location);\n static cp_declarator * cp_parser_make_indirect_declarator\n   (enum tree_code, tree, cp_cv_quals, cp_declarator *, tree);\n static bool cp_parser_compound_literal_p\n@@ -2881,28 +2881,23 @@ cp_parser_non_integral_constant_expression (cp_parser  *parser,\n   return false;\n }\n \n-/* Emit a diagnostic for an invalid type name.  SCOPE is the\n-   qualifying scope (or NULL, if none) for ID.  This function commits\n+/* Emit a diagnostic for an invalid type name.  This function commits\n    to the current active tentative parse, if any.  (Otherwise, the\n    problematic construct might be encountered again later, resulting\n    in duplicate error messages.) LOCATION is the location of ID.  */\n \n static void\n-cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n-\t\t\t\t      tree scope, tree id,\n+cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n \t\t\t\t      location_t location)\n {\n-  tree decl, old_scope, ambiguous_decls;\n+  tree decl, ambiguous_decls;\n   cp_parser_commit_to_tentative_parse (parser);\n   /* Try to lookup the identifier.  */\n-  old_scope = parser->scope;\n-  parser->scope = scope;\n   decl = cp_parser_lookup_name (parser, id, none_type,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\t/*check_dependency=*/true,\n \t\t\t\t&ambiguous_decls, location);\n-  parser->scope = old_scope;\n   if (ambiguous_decls)\n     /* If the lookup was ambiguous, an error will already have\n        been issued.  */\n@@ -3063,8 +3058,7 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n     return false;\n \n   /* Emit a diagnostic for the invalid type.  */\n-  cp_parser_diagnose_invalid_type_name (parser, parser->scope,\n-\t\t\t\t\tid, token->location);\n+  cp_parser_diagnose_invalid_type_name (parser, id, token->location);\n  out:\n   /* If we aren't in the middle of a declarator (i.e. in a\n      parameter-declaration-clause), skip to the end of the declaration;\n@@ -3376,19 +3370,19 @@ cp_parser_require_pragma_eol (cp_parser *parser, cp_token *pragma_tok)\n    using cp_parser_diagnose_invalid_type_name.  */\n \n static tree\n-cp_parser_make_typename_type (cp_parser *parser, tree scope,\n-\t\t\t      tree id, location_t id_location)\n+cp_parser_make_typename_type (cp_parser *parser, tree id,\n+\t\t\t      location_t id_location)\n {\n   tree result;\n   if (identifier_p (id))\n     {\n-      result = make_typename_type (scope, id, typename_type,\n+      result = make_typename_type (parser->scope, id, typename_type,\n \t\t\t\t   /*complain=*/tf_none);\n       if (result == error_mark_node)\n-\tcp_parser_diagnose_invalid_type_name (parser, scope, id, id_location);\n+\tcp_parser_diagnose_invalid_type_name (parser, id, id_location);\n       return result;\n     }\n-  return make_typename_type (scope, id, typename_type, tf_error);\n+  return make_typename_type (parser->scope, id, typename_type, tf_error);\n }\n \n /* This is a wrapper around the\n@@ -15194,6 +15188,17 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t identifier.  */\n       if (!template_p && !cp_parser_parse_definitely (parser))\n \t;\n+      /* We can get here when cp_parser_template_id, called by\n+\t cp_parser_class_name with tag_type == none_type, succeeds\n+\t and caches a BASELINK.  Then, when called again here,\n+\t instead of failing and returning an error_mark_node\n+\t returns it (see template/typename17.C in C++11).\n+\t ??? Could we diagnose this earlier?  */\n+      else if (tag_type == typename_type && BASELINK_P (decl))\n+\t{\n+\t  cp_parser_diagnose_invalid_type_name (parser, decl, token->location);\n+\t  type = error_mark_node;\n+\t}\n       /* If DECL is a TEMPLATE_ID_EXPR, and the `typename' keyword is\n \t in effect, then we must assume that, upon instantiation, the\n \t template will correspond to a class.  */\n@@ -15227,8 +15232,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       /* For a `typename', we needn't call xref_tag.  */\n       if (tag_type == typename_type\n \t  && TREE_CODE (parser->scope) != NAMESPACE_DECL)\n-\treturn cp_parser_make_typename_type (parser, parser->scope,\n-\t\t\t\t\t     identifier,\n+\treturn cp_parser_make_typename_type (parser, identifier,\n \t\t\t\t\t     token->location);\n \n       /* Template parameter lists apply only if we are not within a\n@@ -15289,7 +15293,6 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t  if (TREE_CODE (decl) != TYPE_DECL)\n \t    {\n \t      cp_parser_diagnose_invalid_type_name (parser,\n-\t\t\t\t\t\t    parser->scope,\n \t\t\t\t\t\t    identifier,\n \t\t\t\t\t\t    token->location);\n \t      return error_mark_node;"}]}