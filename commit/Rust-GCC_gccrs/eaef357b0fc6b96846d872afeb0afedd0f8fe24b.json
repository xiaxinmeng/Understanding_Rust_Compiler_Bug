{"sha": "eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlZjM1N2IwZmM2Yjk2ODQ2ZDg3MmFmZWIwYWZlZGQwZjhmZTI0Yg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@verizon.net", "date": "2005-05-28T16:41:31Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-05-28T16:41:31Z"}, "message": "intrinsic.texi: added documentation for BIT_SIZE, BTEST, CHAR, CEILING and CMPLX\n\n* intrinsic.texi: added documentation for BIT_SIZE, BTEST, CHAR, CEILING\n  and CMPLX\n\nCo-Authored-By: Steven G. Kargl <kargls@comcast.net>\n\nFrom-SVN: r100297", "tree": {"sha": "dc4ace3669b986dc50c71576c486a36e1a5fd95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc4ace3669b986dc50c71576c486a36e1a5fd95a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaef357b0fc6b96846d872afeb0afedd0f8fe24b/comments", "author": null, "committer": null, "parents": [{"sha": "c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9"}], "stats": {"total": 435, "additions": 328, "deletions": 107}, "files": [{"sha": "ed4f712a5c369d9f7a0bf5265dae977458e14796", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaef357b0fc6b96846d872afeb0afedd0f8fe24b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaef357b0fc6b96846d872afeb0afedd0f8fe24b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "patch": "@@ -1,3 +1,9 @@\n+2005-05-28  Jerry DeLisle   <jvdelisle@verizon.net>\n+            Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* intrinsic.texi: added documentation for BIT_SIZE, BTEST, CHAR, CEILING\n+\tand CMPLX\n+\n 2005-05-27  Steven G. Kargl  <kargls@comcast.net>\n \n \t* trans-array.c (gfc_trans_deferred_array): Use build_int_cst to force"}, {"sha": "31a4c51580b77232fbaeb447b3536919d59cba45", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 322, "deletions": 107, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaef357b0fc6b96846d872afeb0afedd0f8fe24b/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaef357b0fc6b96846d872afeb0afedd0f8fe24b/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "patch": "@@ -32,41 +32,46 @@ This portion of the document is incomplete and undergoing massive expansion\n and editing.  All contributions and corrections are strongly encouraged. \n \n @menu\n-* Introduction:     Introduction\n-* @code{ABORT}:     ABORT,     Abort the program     \n-* @code{ABS}:       ABS,       Absolute value     \n-* @code{ACHAR}:     ACHAR,     Character in @acronym{ASCII} collating sequence\n-* @code{ACOS}:      ACOS,      Arccosine function\n-* @code{ADJUSTL}:   ADJUSTL,   Left adjust a string\n-* @code{ADJUSTR}:   ADJUSTR,   Right adjust a string\n-* @code{AIMAG}:     AIMAG,     Imaginary part of complex number\n-* @code{AINT}:      AINT,      Truncate to a whole number\n-* @code{ALL}:       ALL,       Determine if all values are true\n-* @code{ALLOCATED}: ALLOCATED, Status of allocatable entity\n-* @code{ANINT}:     ANINT,     Nearest whole number\n-* @code{ANY}:       ANY,       Determine if any values are true\n-* @code{ASIN}:      ASIN,      Arcsine function\n-* @code{ASSOCIATED}: ASSOCIATED, Status of a pointer or pointer/target pair\n-* @code{ATAN}:       ATAN,      Arctangent function\n-* @code{ATAN2}:      ATAN2,      Arctangent function\n-* @code{BESJ0}:     BESJ0,     Bessel function of the first kind of order 0\n-* @code{BESJ1}:     BESJ1,     Bessel function of the first kind of order 1\n-* @code{BESJN}:     BESJN,     Bessel function of the first kind\n-* @code{BESY0}:     BESY0,     Bessel function of the second kind of order 0\n-* @code{BESY1}:     BESY1,     Bessel function of the second kind of order 1\n-* @code{BESYN}:     BESYN,     Bessel function of the second kind\n-* @code{COS}:       COS,       Cosine function\n-* @code{COSH}:      COSH,      Hyperbolic cosine function\n-* @code{ERF}:       ERF,       Error function\n-* @code{ERFC}:      ERFC,      Complementary error function\n-* @code{EXP}:       EXP,       Cosine function\n-* @code{LOG}:       LOG,       Logarithm function\n-* @code{LOG10}:     LOG10,     Base 10 logarithm function \n-* @code{SQRT}:      SQRT,      Square-root function\n-* @code{SIN}:       SIN,       Sine function\n-* @code{SINH}:      SINH,      Hyperbolic sine function\n-* @code{TAN}:       TAN,       Tangent function\n-* @code{TANH}:      TANH,      Hyperbolic tangent function\n+* Introduction:         Introduction\n+* @code{ABORT}:         ABORT,     Abort the program     \n+* @code{ABS}:           ABS,       Absolute value     \n+* @code{ACHAR}:         ACHAR,     Character in @acronym{ASCII} collating sequence\n+* @code{ACOS}:          ACOS,      Arccosine function\n+* @code{ADJUSTL}:       ADJUSTL,   Left adjust a string\n+* @code{ADJUSTR}:       ADJUSTR,   Right adjust a string\n+* @code{AIMAG}:         AIMAG,     Imaginary part of complex number\n+* @code{AINT}:          AINT,      Truncate to a whole number\n+* @code{ALL}:           ALL,       Determine if all values are true\n+* @code{ALLOCATED}:     ALLOCATED, Status of allocatable entity\n+* @code{ANINT}:         ANINT,     Nearest whole number\n+* @code{ANY}:           ANY,       Determine if any values are true\n+* @code{ASIN}:          ASIN,      Arcsine function\n+* @code{ASSOCIATED}:    ASSOCIATED, Status of a pointer or pointer/target pair\n+* @code{ATAN}:          ATAN,      Arctangent function\n+* @code{ATAN2}:         ATAN2,     Arctangent function\n+* @code{BESJ0}:         BESJ0,     Bessel function of the first kind of order 0\n+* @code{BESJ1}:         BESJ1,     Bessel function of the first kind of order 1\n+* @code{BESJN}:         BESJN,     Bessel function of the first kind\n+* @code{BESY0}:         BESY0,     Bessel function of the second kind of order 0\n+* @code{BESY1}:         BESY1,     Bessel function of the second kind of order 1\n+* @code{BESYN}:         BESYN,     Bessel function of the second kind\n+* @code{BIT_SIZE}:      BIT_SIZE,  Bit size inquiry function\n+* @code{BTEST}:         BTEST,     Bit test function\n+* @code{CEILING}:       CEILING,   Integer ceiling function\n+* @code{CHAR}:          CHAR,      Character conversion function\n+* @code{CMPLX}:         CMPLX,     Complex conversion function\n+* @code{COS}:           COS,       Cosine function\n+* @code{COSH}:          COSH,      Hyperbolic cosine function\n+* @code{ERF}:           ERF,       Error function\n+* @code{ERFC}:          ERFC,      Complementary error function\n+* @code{EXP}:           EXP,       Cosine function\n+* @code{LOG}:           LOG,       Logarithm function\n+* @code{LOG10}:         LOG10,     Base 10 logarithm function \n+* @code{SQRT}:          SQRT,      Square-root function\n+* @code{SIN}:           SIN,       Sine function\n+* @code{SINH}:          SINH,      Hyperbolic sine function\n+* @code{TAN}:           TAN,       Tangent function\n+* @code{TANH}:          TANH,      Hyperbolic tangent function\n @end menu\n \n @node Introduction\n@@ -124,7 +129,7 @@ which is suitable for debugging purposes.\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n non-elemental subroutine\n \n @item @emph{Syntax}:\n@@ -161,7 +166,7 @@ end program test_abort\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n@@ -216,15 +221,15 @@ in the @acronym{ASCII} collating sequence.\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{C = ACHAR(I)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{I} @tab The type shall be an @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -255,15 +260,15 @@ end program test_achar\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = ACOS(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and a magnitude that is\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and a magnitude that is\n less than one.\n @end multitable\n \n@@ -302,7 +307,7 @@ Spaces are inserted at the end of the string as needed.\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n@@ -329,6 +334,7 @@ end program test_adjustl\n @end table\n \n \n+\n @node ADJUSTR\n @section @code{ADJUSTR} --- Right adjust a string \n @findex @code{ADJUSTR} intrinsic\n@@ -342,7 +348,7 @@ Spaces are inserted at the start of the string as needed.\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n@@ -369,6 +375,7 @@ end program test_adjustr\n @end table\n \n \n+\n @node AIMAG\n @section @code{AIMAG} --- Imaginary part of complex number  \n @findex @code{AIMAG} intrinsic\n@@ -382,7 +389,7 @@ end program test_adjustr\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n@@ -416,6 +423,7 @@ end program test_aimag\n @end table\n \n \n+\n @node AINT\n @section @code{AINT} --- Imaginary part of complex number  \n @findex @code{AINT} intrinsic\n@@ -429,7 +437,7 @@ end program test_aimag\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n@@ -472,6 +480,7 @@ end program test_aint\n @end table\n \n \n+\n @node ALL\n @section @code{ALL} --- All values in @var{MASK} along @var{DIM} are true \n @findex @code{ALL} intrinsic\n@@ -485,7 +494,7 @@ in the array along dimension @var{DIM}.\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n transformational function\n \n @item @emph{Syntax}:\n@@ -551,7 +560,7 @@ end program test_all\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n inquiry function\n \n @item @emph{Syntax}:\n@@ -578,6 +587,7 @@ end program test_allocated\n @end table\n \n \n+\n @node ANINT\n @section @code{ANINT} --- Imaginary part of complex number  \n @findex @code{ANINT} intrinsic\n@@ -591,7 +601,7 @@ end program test_allocated\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n@@ -632,6 +642,7 @@ end program test_anint\n @end table\n \n \n+\n @node ANY\n @section @code{ANY} --- Any value in @var{MASK} along @var{DIM} is true \n @findex @code{ANY} intrinsic\n@@ -645,7 +656,7 @@ in the array along dimension @var{DIM}.\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n transformational function\n \n @item @emph{Syntax}:\n@@ -698,6 +709,7 @@ end program test_any\n @end table\n \n \n+\n @node ASIN\n @section @code{ASIN} --- Arcsine function \n @findex @code{ASIN} intrinsic\n@@ -711,15 +723,15 @@ end program test_any\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = ASIN(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and a magnitude that is\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and a magnitude that is\n less than one.\n @end multitable\n \n@@ -744,6 +756,7 @@ end program test_asin\n @end table\n \n \n+\n @node ASSOCIATED\n @section @code{ASSOCIATED} --- Status of a pointer or pointer/target pair \n @findex @code{ASSOCIATED} intrinsic\n@@ -757,7 +770,7 @@ or if @var{PTR} is associated with the target @var{TGT}.\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n inquiry function\n \n @item @emph{Syntax}:\n@@ -816,6 +829,7 @@ end program test_associated\n @end table\n \n \n+\n @node ATAN\n @section @code{ATAN} --- Arctangent function \n @findex @code{ATAN} intrinsic\n@@ -829,15 +843,15 @@ end program test_associated\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = ATAN(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -860,6 +874,7 @@ end program test_atan\n @end table\n \n \n+\n @node ATAN2\n @section @code{ATAN2} --- Arctangent function \n @findex @code{ATAN2} intrinsic\n@@ -873,7 +888,7 @@ end program test_atan\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n@@ -911,6 +926,7 @@ end program test_atan2\n @end table\n \n \n+\n @node BESJ0\n @section @code{BESJ0} --- Bessel function of the first kind of order 0\n @findex @code{BESJ0} intrinsic\n@@ -925,15 +941,15 @@ of @var{X}.\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = BESJ0(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -971,15 +987,15 @@ of @var{X}.\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = BESJ1(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1017,16 +1033,16 @@ end program test_besj1\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{Y = BESJN(N, X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{N} @tab The type shall be an @code{INTEGER(*)}, and it shall be scalar.\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{N} @tab The type shall be @code{INTEGER(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1064,15 +1080,15 @@ of @var{X}.\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = BESY0(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1109,15 +1125,15 @@ of @var{X}.\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = BESY1(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1154,16 +1170,16 @@ end program test_besy1\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{Y = BESYN(N, X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{N} @tab The type shall be an @code{INTEGER(*)}, and it shall be scalar.\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{N} @tab The type shall be @code{INTEGER(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1186,6 +1202,214 @@ end program test_besyn\n @end table\n \n \n+\n+@node BIT_SIZE\n+@section @code{BIT_SIZE} --- Bit size inquiry function\n+@findex @code{BIT_SIZE} intrinsic\n+@cindex bit_size\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{BIT_SIZE(I)} returns the number of bits (integer precision plus sign bit) represented by the type of @var{I}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{I = BIT_SIZE(I)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER(*)}\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_bit_size\n+    integer :: i = 123\n+    integer :: size\n+    size = bit_size(i)\n+    print *, size\n+end program test_bit_size\n+@end smallexample\n+@end table\n+\n+\n+\n+@node BTEST\n+@section @code{BTEST} --- Bit test function\n+@findex @code{BTEST} intrinsic\n+@cindex BTEST\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{BTEST(I,POS)} returns logical .TRUE. if the bit at @var{POS} in @var{I} is set.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{I = BTEST(I,POS)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{LOGICAL}\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_btest\n+    integer :: i = 32768 + 1024 + 64\n+    integer :: pos\n+    logical :: bool\n+    do pos=0,16\n+        bool = btest(i, pos) \n+        print *, pos, bool\n+    end do\n+end program test_btest\n+@end smallexample\n+@end table\n+\n+\n+\n+@node CEILING\n+@section @code{CEILING} --- Integer ceiling function\n+@findex @code{CEILING} intrinsic\n+@cindex CEILING\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{CEILING(X,[KIND])} returns the least integer greater than or equal to @var{X}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{X = CEILING(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{KIND} @tab Optional scaler integer initialization expression.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER(KIND)}\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_ceiling\n+    real :: x = 63.29\n+    real :: y = -63.59\n+    print *, ceiling(x) ! returns 64\n+    print *, ceiling(y) ! returns -63\n+end program test_ceiling\n+@end smallexample\n+@end table\n+\n+\n+\n+@node CHAR\n+@section @code{CHAR} --- Character conversion function\n+@findex @code{CHAR} intrinsic\n+@cindex CHAR\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{CHAR(I,[KIND])} returns the character represented by the integer @var{I}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{C = CHAR(I)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{KIND} @tab Optional scaler integer initialization expression.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{CHARACTER(1)}\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_char\n+    integer :: i = 74\n+    character(1) :: c\n+    c = char(i)\n+    print *, i, c ! returns 'J'\n+end program test_char\n+@end smallexample\n+@end table\n+\n+\n+\n+@node CMPLX\n+@section @code{CMPLX} --- Complex conversion function\n+@findex @code{CMPLX} intrinsic\n+@cindex CMPLX\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{CMPLX(X,[Y,KIND])} returns a complex number where @var{X} is converted to the real component.  If @var{Y} is present it is converted to the imaginary component.  If @var{Y} is not present then the imaginary component is set to\n+0.0.  If @var{X} is complex then @var{Y} must not be present.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{C = CMPLX(X)}\n+@code{C = CMPLX(X,Y)}\n+@code{C = CMPLX(X,Y,KIND)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type may be @code{INTEGER(*)} or @code{REAL(*)} or @code{COMPLEX(*)}.\n+@item @var{Y} @tab Optional, allowed if @var{X} is not @code{COMPLEX(*)}.  May be @code{INTEGER(*)} or @code{REAL(*)}. \n+@item @var{KIND} @tab Optional scaler integer initialization expression.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{COMPLEX(*)}\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_cmplx\n+    integer :: i = 42\n+    real :: x = 3.14\n+    complex :: z\n+    z = cmplx(i, x)\n+    print *, z, cmplx(x)\n+end program test_cmplx\n+@end smallexample\n+@end table\n+\n+\n+\n @node COS\n @section @code{COS} --- Cosine function \n @findex @code{COS} intrinsic\n@@ -1201,15 +1425,15 @@ end program test_besyn\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = COS(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)} or\n+@item @var{X} @tab The type shall be @code{REAL(*)} or\n @code{COMPLEX(*)}.\n @end multitable\n \n@@ -1235,6 +1459,7 @@ end program test_cos\n @end table\n \n \n+\n @node COSH\n @section @code{COSH} --- Hyperbolic cosine function \n @findex @code{COSH} intrinsic\n@@ -1248,15 +1473,15 @@ end program test_cos\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = COSH(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1279,6 +1504,7 @@ end program test_cosh\n @end table\n \n \n+\n @node ERF\n @section @code{ERF} --- Error function \n @findex @code{ERF} intrinsic\n@@ -1291,15 +1517,15 @@ end program test_cosh\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = ERF(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1335,15 +1561,15 @@ end program test_erf\n @item @emph{Option}:\n gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = ERFC(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1382,20 +1608,20 @@ end program test_erfc\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = EXP(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)} or\n+@item @var{X} @tab The type shall be @code{REAL(*)} or\n @code{COMPLEX(*)}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value has same type and kind than @var{X}.\n+The return value has same type and kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1416,6 +1642,7 @@ end program test_exp\n @end table\n \n \n+\n @node LOG\n @section @code{LOG} --- Logarithm function\n @findex @code{LOG} intrinsic\n@@ -1433,15 +1660,15 @@ end program test_exp\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = LOG(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)} or\n+@item @var{X} @tab The type shall be @code{REAL(*)} or\n @code{COMPLEX(*)}.\n @end multitable\n \n@@ -1486,15 +1713,15 @@ end program test_log\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = LOG10(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)} or\n+@item @var{X} @tab The type shall be @code{REAL(*)} or\n @code{COMPLEX(*)}.\n @end multitable\n \n@@ -1535,15 +1762,15 @@ end program test_log10\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = SIN(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)} or\n+@item @var{X} @tab The type shall be @code{REAL(*)} or\n @code{COMPLEX(*)}.\n @end multitable\n \n@@ -1570,7 +1797,6 @@ end program test_sin\n \n \n \n-\n @node SINH\n @section @code{SINH} --- Hyperbolic sine function \n @findex @code{SINH} intrinsic\n@@ -1584,15 +1810,15 @@ end program test_sin\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = SINH(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1631,15 +1857,15 @@ end program test_sinh\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = SQRT(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)} or\n+@item @var{X} @tab The type shall be @code{REAL(*)} or\n @code{COMPLEX(*)}.\n @end multitable\n \n@@ -1682,15 +1908,15 @@ end program test_sqrt\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = TAN(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1713,6 +1939,7 @@ end program test_tan\n @end table\n \n \n+\n @node TANH\n @section @code{TANH} --- Hyperbolic tangent function \n @findex @code{TANH} intrinsic\n@@ -1726,15 +1953,15 @@ end program test_tan\n @item @emph{Option}:\n f95, gnu\n \n-@item @emph{Type}:\n+@item @emph{Class}:\n elemental function\n \n @item @emph{Syntax}:\n @code{X = TANH(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1758,18 +1985,6 @@ end program test_tanh\n \n \n \n-\n-\n-@comment gen   bit_size \n-@comment \n-@comment gen   btest\n-@comment \n-@comment gen   ceiling\n-@comment \n-@comment gen   char\n-@comment \n-@comment gen   cmplx \n-@comment \n @comment gen   command_argument_count\n @comment \n @comment gen   conjg"}]}