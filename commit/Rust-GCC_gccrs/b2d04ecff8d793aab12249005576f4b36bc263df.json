{"sha": "b2d04ecff8d793aab12249005576f4b36bc263df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJkMDRlY2ZmOGQ3OTNhYWIxMjI0OTAwNTU3NmY0YjM2YmMyNjNkZg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-05-10T14:26:50Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-05-10T14:26:50Z"}, "message": "rs6000.c (function_arg_boundary): Always align AltiVec vectors.\n\n\t* config/rs6000/rs6000.c (function_arg_boundary): Always align\n\tAltiVec vectors.\n\t(function_arg_advance): Pass TARGET_32BIT -mabi=no-altivec AltiVec\n\tvectors by refererence.  Align the same for TARGET_64BIT to a 16\n\tbyte boundary.  Remove useless code.  Add function comment.\n\t(function_arg): Similarly.  Move gpr rs6000_mixed_function_arg\n\tcall to where it belongs.\n\t(function_arg_partial_nregs): Return true for all TARGET_32BIT\n\t-mabi=no-altivec AltiVec vectors.  Fix debug output.\n\t(rs6000_va_arg): Adjust for AltiVec change.\n\nFrom-SVN: r81666", "tree": {"sha": "b91c0a516954519112bdd143f83a329712f73857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b91c0a516954519112bdd143f83a329712f73857"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2d04ecff8d793aab12249005576f4b36bc263df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d04ecff8d793aab12249005576f4b36bc263df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2d04ecff8d793aab12249005576f4b36bc263df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d04ecff8d793aab12249005576f4b36bc263df/comments", "author": null, "committer": null, "parents": [{"sha": "b6685939515a82257ce895032e981c34b3b71b39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6685939515a82257ce895032e981c34b3b71b39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6685939515a82257ce895032e981c34b3b71b39"}], "stats": {"total": 107, "additions": 61, "deletions": 46}, "files": [{"sha": "294337fa0a14a72f756eb7a0e75a72b5719094a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d04ecff8d793aab12249005576f4b36bc263df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d04ecff8d793aab12249005576f4b36bc263df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2d04ecff8d793aab12249005576f4b36bc263df", "patch": "@@ -1,3 +1,16 @@\n+2004-05-10  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (function_arg_boundary): Always align\n+\tAltiVec vectors.\n+\t(function_arg_advance): Pass TARGET_32BIT -mabi=no-altivec AltiVec\n+\tvectors by refererence.  Align the same for TARGET_64BIT to a 16\n+\tbyte boundary.  Remove useless code.  Add function comment.\n+\t(function_arg): Similarly.  Move gpr rs6000_mixed_function_arg\n+\tcall to where it belongs.\n+\t(function_arg_partial_nregs): Return true for all TARGET_32BIT\n+\t-mabi=no-altivec AltiVec vectors.  Fix debug output.\n+\t(rs6000_va_arg): Adjust for AltiVec change.\n+\n 2004-05-10  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (arm_promote_prototypes): Use TARGET_AAPCS_BASED."}, {"sha": "e1a55e4a99ef0a88cc34592dd2a56a50eae33238", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d04ecff8d793aab12249005576f4b36bc263df/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d04ecff8d793aab12249005576f4b36bc263df/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b2d04ecff8d793aab12249005576f4b36bc263df", "patch": "@@ -4192,7 +4192,7 @@ function_arg_boundary (enum machine_mode mode, tree type ATTRIBUTE_UNUSED)\n     return 64;\n   else if (SPE_VECTOR_MODE (mode))\n     return 64;\n-  else if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n+  else if (ALTIVEC_VECTOR_MODE (mode))\n     return 128;\n   else\n     return PARM_BOUNDARY;\n@@ -4218,7 +4218,11 @@ rs6000_arg_size (enum machine_mode mode, tree type)\n \f\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+   (TYPE is null for libcalls where that information may not be available.)\n+\n+   Note that for args passed by reference, function_arg will be called\n+   with MODE and TYPE set to that of the pointer to the arg, not the arg\n+   itself.  */\n \n void\n function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n@@ -4295,18 +4299,9 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t}\n       else\n \t{\n-\t  int n_words;\n+\t  int n_words = rs6000_arg_size (mode, type);\n \t  int gregno = cum->sysv_gregno;\n \n-\t  /* Aggregates, IEEE quad, and AltiVec vectors get passed by\n-\t     reference.  */\n-\t  if ((type && AGGREGATE_TYPE_P (type))\n-\t      || mode == TFmode\n-\t      || ALTIVEC_VECTOR_MODE (mode))\n-\t    n_words = 1;\n-\t  else \n-\t    n_words = rs6000_arg_size (mode, type);\n-\n \t  /* Long long and SPE vectors are put in (r3,r4), (r5,r6),\n \t     (r7,r8) or (r9,r10).  As does any other 2 word item such\n \t     as complex int due to a historical mistake.  */\n@@ -4342,10 +4337,16 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n   else\n     {\n-      int align = (TARGET_32BIT && (cum->words & 1) != 0\n-\t\t   && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+      int n_words = rs6000_arg_size (mode, type);\n+      int align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n \n-      cum->words += align + rs6000_arg_size (mode, type);\n+      /* The simple alignment calculation here works because\n+\t function_arg_boundary / PARM_BOUNDARY will only be 1 or 2.\n+\t If we ever want to handle alignments larger than 8 bytes for\n+\t 32-bit or 16 bytes for 64-bit, then we'll need to take into\n+\t account the offset to the start of the parm save area.  */\n+      align &= cum->words;\n+      cum->words += align + n_words;\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n@@ -4544,7 +4545,11 @@ rs6000_mixed_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    both an FP and integer register (or possibly FP reg and stack).  Library\n    functions (when CALL_LIBCALL is set) always have the proper types for args,\n    so we can pass the FP value just in one register.  emit_library_function\n-   doesn't support PARALLEL anyway.  */\n+   doesn't support PARALLEL anyway.\n+\n+   Note that for args passed by reference, function_arg will be called\n+   with MODE and TYPE set to that of the pointer to the arg, not the arg\n+   itself.  */\n \n struct rtx_def *\n function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n@@ -4658,18 +4663,9 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t}\n       else\n \t{\n-\t  int n_words;\n+\t  int n_words = rs6000_arg_size (mode, type);\n \t  int gregno = cum->sysv_gregno;\n \n-\t  /* Aggregates, IEEE quad, and AltiVec vectors get passed by\n-\t     reference.  */\n-\t  if ((type && AGGREGATE_TYPE_P (type))\n-\t      || mode == TFmode\n-\t      || ALTIVEC_VECTOR_MODE (mode))\n-\t    n_words = 1;\n-\t  else \n-\t    n_words = rs6000_arg_size (mode, type);\n-\n \t  /* Long long and SPE vectors are put in (r3,r4), (r5,r6),\n \t     (r7,r8) or (r9,r10).  As does any other 2 word item such\n \t     as complex int due to a historical mistake.  */\n@@ -4685,16 +4681,8 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n   else\n     {\n-      int align = (TARGET_32BIT && (cum->words & 1) != 0\n-\t           && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n-      int align_words = cum->words + align;\n-\n-      if (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-        return NULL_RTX;\n-\n-      if (TARGET_32BIT && TARGET_POWERPC64\n-\t  && (mode == DImode || mode == BLKmode))\n-\treturn rs6000_mixed_function_arg (cum, mode, type, align_words);\n+      int align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n+      int align_words = cum->words + (cum->words & align);\n \n       if (USE_FP_FOR_ARG_P (cum, mode, type))\n \t{\n@@ -4763,7 +4751,13 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (n, r));\n \t}\n       else if (align_words < GP_ARG_NUM_REG)\n-\treturn gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+\t{\n+\t  if (TARGET_32BIT && TARGET_POWERPC64\n+\t      && (mode == DImode || mode == BLKmode))\n+\t    return rs6000_mixed_function_arg (cum, mode, type, align_words);\n+\n+\t  return gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+\t}\n       else\n \treturn NULL_RTX;\n     }\n@@ -4810,7 +4804,10 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    the argument itself.  The pointer is passed in whatever way is\n    appropriate for passing a pointer to that type.\n \n-   Under V.4, structures and unions are passed by reference.\n+   Under V.4, aggregates and long double are passed by reference.\n+\n+   As an extension to all 32-bit ABIs, AltiVec vectors are passed by\n+   reference unless the AltiVec vector extension ABI is in force.\n \n    As an extension to all ABIs, variable sized types are passed by\n    reference.  */\n@@ -4820,17 +4817,18 @@ function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED, \n \t\t\t\ttree type, int named ATTRIBUTE_UNUSED)\n {\n-  if (DEFAULT_ABI == ABI_V4\n-      && ((type && AGGREGATE_TYPE_P (type))\n-\t  || mode == TFmode\n-\t  || (!TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))))\n+  if ((DEFAULT_ABI == ABI_V4\n+       && ((type && AGGREGATE_TYPE_P (type))\n+\t   || mode == TFmode))\n+      || (TARGET_32BIT && !TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n+      || (type && int_size_in_bytes (type) < 0))\n     {\n       if (TARGET_DEBUG_ARG)\n-\tfprintf (stderr, \"function_arg_pass_by_reference: aggregate\\n\");\n+\tfprintf (stderr, \"function_arg_pass_by_reference\\n\");\n \n       return 1;\n     }\n-  return type && int_size_in_bytes (type) < 0;\n+  return 0;\n }\n \n static void\n@@ -5081,8 +5079,12 @@ rs6000_va_arg (tree valist, tree type)\n \n   if (DEFAULT_ABI != ABI_V4)\n     {\n-      /* Variable sized types are passed by reference.  */\n-      if (int_size_in_bytes (type) < 0)\n+      /* Variable sized types are passed by reference, as are AltiVec\n+\t vectors when 32-bit and not using the AltiVec ABI extension.  */\n+      if (int_size_in_bytes (type) < 0\n+\t  || (TARGET_32BIT\n+\t      && !TARGET_ALTIVEC_ABI\n+\t      && ALTIVEC_VECTOR_MODE (TYPE_MODE (type))))\n \t{\n \t  u = build_pointer_type (type);\n "}]}