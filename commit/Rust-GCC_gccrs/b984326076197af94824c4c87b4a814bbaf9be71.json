{"sha": "b984326076197af94824c4c87b4a814bbaf9be71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4NDMyNjA3NjE5N2FmOTQ4MjRjNGM4N2I0YTgxNGJiYWY5YmU3MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-04-16T10:43:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-04-16T10:43:04Z"}, "message": "lto.c (lto_balanced_map): Fix typos in head comment.\n\n\t* lto.c (lto_balanced_map): Fix typos in head comment.\n\t(lto_promote_cross_file_statics): Fix long lines and remove redundant\n\ttest.\n\nFrom-SVN: r172584", "tree": {"sha": "c42fe8509dc7722c0865c734046791e5be5b5a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c42fe8509dc7722c0865c734046791e5be5b5a63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b984326076197af94824c4c87b4a814bbaf9be71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b984326076197af94824c4c87b4a814bbaf9be71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b984326076197af94824c4c87b4a814bbaf9be71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b984326076197af94824c4c87b4a814bbaf9be71/comments", "author": null, "committer": null, "parents": [{"sha": "e7f2301855b432e057acd267e5df455fee60abef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f2301855b432e057acd267e5df455fee60abef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f2301855b432e057acd267e5df455fee60abef"}], "stats": {"total": 126, "additions": 70, "deletions": 56}, "files": [{"sha": "507e9b22fd732a8baefde840c0a1e60ef52ae271", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b984326076197af94824c4c87b4a814bbaf9be71/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b984326076197af94824c4c87b4a814bbaf9be71/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b984326076197af94824c4c87b4a814bbaf9be71", "patch": "@@ -1,11 +1,18 @@\n+2011-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* lto.c (lto_balanced_map): Fix typos in head comment.\n+\t(lto_promote_cross_file_statics): Fix long lines and remove redundant\n+\ttest.\n+\n 2011-04-16  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (lto_balanced_map): Update.\n \n 2011-04-14  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c: Include ipa-inline.h\n-\t(add_cgraph_node_to_partition, undo_partition): Use inline_summary accessor.\n+\t(add_cgraph_node_to_partition, undo_partition): Use inline_summary\n+\taccessor.\n \t(ipa_node_duplication_hook): Fix declaration.\n \t* Make-lang.in (lto.o): Update dependencies.\n \n@@ -77,8 +84,8 @@\n \n \tPR lto/45721\n \tPR lto/45375\n-\t* lto.c (partition_cgraph_node_p, partition_varpool_node_p): Weakrefs are\n-\tnot partitioned.\n+\t* lto.c (partition_cgraph_node_p, partition_varpool_node_p): Weakrefs\n+\tare not partitioned.\n \n 2010-12-22  Nathan Froyd  <froydnj@codesourcery.com>\n \n@@ -376,11 +383,12 @@\n \t* lto.c (add_cgraph_node_to_partition): Forward declare; walk also\n \tnodes from same comdat group as well as all comdat functions referenced\n \there.\n-\t(add_varpool_node_to_partition, add_references_to_partition): New function.\n-\t(lto_1_1_map): Skip COMDAT fnctions/variables; use add_varpool_node_to_partition;\n-\tclear aux flags when done.\n-\t(lto_promote_cross_file_statics): Do not promote stuff that gets duplicated to\n-\teach ltrans.\n+\t(add_varpool_node_to_partition, add_references_to_partition): New\n+\tfunction.\n+\t(lto_1_1_map): Skip COMDAT fnctions/variables; use\n+\tadd_varpool_node_to_partition; clear aux flags when done.\n+\t(lto_promote_cross_file_statics): Do not promote stuff that gets\n+\tduplicated to each ltrans.\n \n 2010-07-04  Jan Hubicka  <jh@suse.cz>\n \n@@ -588,8 +596,8 @@\n \n 2010-04-30  Jan Hubicka  <jh@suse.cz>\n \n-\t* lto.c (get_filename_for_set): Look for cgraph node and if none found, use\n-\tdefault name.\n+\t* lto.c (get_filename_for_set): Look for cgraph node and if none found,\n+\tuse default name.\n \t(lto_wpa_write_files): Write any non-empty partition.\n \n 2010-04-30  Jan Hubicka  <jh@suse.cz>"}, {"sha": "8215c02ca5b6f39ff87892af323a54c3a4a8bdf1", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b984326076197af94824c4c87b4a814bbaf9be71/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b984326076197af94824c4c87b4a814bbaf9be71/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b984326076197af94824c4c87b4a814bbaf9be71", "patch": "@@ -1,5 +1,5 @@\n /* Top-level LTO routines.\n-   Copyright 2009, 2010 Free Software Foundation, Inc.\n+   Copyright 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by CodeSourcery, Inc.\n \n This file is part of GCC.\n@@ -962,40 +962,43 @@ lto_1_to_1_map (void)\n }\n \n \n-/* Group cgraph nodes in qually sized partitions.\n+/* Group cgraph nodes into equally-sized partitions.\n \n-   The algorithm deciding paritions are simple: nodes are taken in predefined\n-   order.  The order correspond to order we wish to have functions in final\n-   output.  In future this will be given by function reordering pass, but at\n-   the moment we use topological order that serve a good approximation.\n+   The partitioning algorithm is simple: nodes are taken in predefined order.\n+   The order corresponds to the order we want functions to have in the final\n+   output.  In the future this will be given by function reordering pass, but\n+   at the moment we use the topological order, which is a good approximation.\n \n-   The goal is to partition this linear order into intervals (partitions) such\n-   that all partitions have approximately the same size and that the number of\n-   callgraph or IPA reference edgess crossing boundaries is minimal.\n+   The goal is to partition this linear order into intervals (partitions) so\n+   that all the partitions have approximately the same size and the number of\n+   callgraph or IPA reference edges crossing boundaries is minimal.\n \n    This is a lot faster (O(n) in size of callgraph) than algorithms doing\n-   priority based graph clustering that are generally O(n^2) and since WHOPR\n-   is designed to make things go well across partitions, it leads to good results.\n-\n-   We compute the expected size of partition as\n-   max (total_size / lto_partitions, min_partition_size).\n-   We use dynamic expected size of partition, so small programs\n-   are partitioning into enough partitions to allow use of multiple CPUs while\n-   large programs are not partitioned too much. Creating too many partition\n-   increase streaming overhead significandly.\n-\n-   In the future we would like to bound maximal size of partition to avoid\n-   ltrans stage consuming too much memory.  At the moment however WPA stage is\n-   most memory intensive phase at large benchmark since too many types and\n-   declarations are read into memory.\n-\n-   The function implement simple greedy algorithm.  Nodes are begin added into\n-   current partition until 3/4th of expected partition size is reached.\n-   After this threshold we keep track of boundary size (number of edges going to\n-   other partitions) and continue adding functions until the current partition\n-   grows into a double of expected partition size.  Then the process is undone\n-   till the point when minimal ration of boundary size and in partition calls\n-   was reached.  */\n+   priority-based graph clustering that are generally O(n^2) and, since\n+   WHOPR is designed to make things go well across partitions, it leads\n+   to good results.\n+\n+   We compute the expected size of a partition as:\n+\n+     max (total_size / lto_partitions, min_partition_size)\n+\n+   We use dynamic expected size of partition so small programs are partitioned\n+   into enough partitions to allow use of multiple CPUs, while large programs\n+   are not partitioned too much.  Creating too many partitions significantly\n+   increases the streaming overhead.\n+\n+   In the future, we would like to bound the maximal size of partitions so as\n+   to prevent the LTRANS stage from consuming too much memory.  At the moment,\n+   however, the WPA stage is the most memory intensive for large benchmarks,\n+   since too many types and declarations are read into memory.\n+\n+   The function implements a simple greedy algorithm.  Nodes are being added\n+   to the current partition until after 3/4 of the expected partition size is\n+   reached.  Past this threshold, we keep track of boundary size (number of\n+   edges going to other partitions) and continue adding functions until after\n+   the current partition has grown to twice the expected partition size.  Then\n+   the process is undone to the point where the minimal ratio of boundary size\n+   and in-partition calls was reached.  */\n \n static void\n lto_balanced_map (void)\n@@ -1330,7 +1333,8 @@ lto_promote_cross_file_statics (void)\n   n_sets = VEC_length (ltrans_partition, ltrans_partitions);\n   for (i = 0; i < n_sets; i++)\n     {\n-      ltrans_partition part = VEC_index (ltrans_partition, ltrans_partitions, i);\n+      ltrans_partition part\n+\t= VEC_index (ltrans_partition, ltrans_partitions, i);\n       set = part->cgraph_set;\n       vset = part->varpool_set;\n \n@@ -1361,30 +1365,32 @@ lto_promote_cross_file_statics (void)\n \t    promote_var (vnode);\n \t}\n \n-      /* We export initializers of read-only var into each partition\n-\t referencing it.  Folding might take declarations from the\n-\t initializers and use it; so everything referenced from the\n-\t initializers needs can be accessed from this partition after\n-\t folding.\n+      /* We export the initializer of a read-only var into each partition\n+\t referencing the var.  Folding might take declarations from the\n+\t initializer and use them, so everything referenced from the\n+\t initializer can be accessed from this partition after folding.\n \n \t This means that we need to promote all variables and functions\n-\t referenced from all initializers from readonly vars referenced\n-\t from this partition that are not in this partition.\n-\t This needs to be done recursively.  */\n+\t referenced from all initializers of read-only vars referenced\n+\t from this partition that are not in this partition.  This needs\n+\t to be done recursively.  */\n       for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n \tif (const_value_known_p (vnode->decl)\n \t    && DECL_INITIAL (vnode->decl)\n \t    && !varpool_node_in_set_p (vnode, vset)\n \t    && referenced_from_this_partition_p (&vnode->ref_list, set, vset)\n \t    && !pointer_set_insert (inserted, vnode))\n \tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n+\n       while (!VEC_empty (varpool_node_ptr, promoted_initializers))\n \t{\n \t  int i;\n \t  struct ipa_ref *ref;\n \n \t  vnode = VEC_pop (varpool_node_ptr, promoted_initializers);\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref); i++)\n+\t  for (i = 0;\n+\t       ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref);\n+\t       i++)\n \t    {\n \t      if (ref->refered_type == IPA_REF_CGRAPH)\n \t\t{\n@@ -1399,17 +1405,17 @@ lto_promote_cross_file_statics (void)\n \t\t  struct varpool_node *v = ipa_ref_varpool_node (ref);\n \t\t  if (varpool_node_in_set_p (v, vset))\n \t\t    continue;\n-\t\t  /* Constant pool references use internal labels and thus can not\n-\t\t     be made global.  It is sensible to keep those ltrans local to\n-\t\t     allow better optimization.  */\n+\n+\t\t  /* Constant pool references use internal labels and thus\n+\t\t     cannot be made global.  It is sensible to keep those\n+\t\t     ltrans local to allow better optimization.  */\n \t\t  if (DECL_IN_CONSTANT_POOL (v->decl))\n \t\t    {\n \t\t      if (!pointer_set_insert (inserted, vnode))\n \t\t\tVEC_safe_push (varpool_node_ptr, heap,\n \t\t\t\t       promoted_initializers, v);\n \t\t    }\n-\t\t  else if (!DECL_IN_CONSTANT_POOL (v->decl)\n-\t\t\t   && !v->externally_visible && v->analyzed)\n+\t\t  else if (!v->externally_visible && v->analyzed)\n \t\t    {\n \t\t      if (promote_var (v)\n \t\t\t  && DECL_INITIAL (v->decl)"}]}