{"sha": "66d6cbaa5612d12933f42472a2ee93de920fb1d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZkNmNiYWE1NjEyZDEyOTMzZjQyNDcyYTJlZTkzZGU5MjBmYjFkMg==", "commit": {"author": {"name": "Ilya Enkovich", "email": "ilya.enkovich@intel.com", "date": "2013-10-25T05:37:57Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2013-10-25T05:37:57Z"}, "message": "constraints.md (B): New.\n\n\t* config/i386/constraints.md (B): New.\n\t(Ti): New.\n\t(Tb): New.\n\t* config/i386/i386-c.c (ix86_target_macros_internal): Add __MPX__.\n\t* config/i386/i386-modes.def (BND32): New.\n\t(BND64): New.\n\t* config/i386/i386-protos.h (ix86_bnd_prefixed_insn_p): New.\n\t* config/i386/i386.c (isa_opts): Add mmpx.\n\t(regclass_map): Add bound registers.\n\t(dbx_register_map): Likewise.\n\t(dbx64_register_map): Likewise.\n\t(svr4_dbx_register_map): Likewise.\n\t(PTA_MPX): New.\n\t(ix86_option_override_internal): Support MPX ISA.\n\t(ix86_conditional_register_usage): Support bound registers.\n\t(print_reg): Likewise.\n\t(ix86_code_end): Add MPX bnd prefix.\n\t(output_set_got): Likewise.\n\t(ix86_output_call_insn): Likewise.\n\t(ix86_print_operand): Add '!' (MPX bnd) print prefix support.\n\t(ix86_print_operand_punct_valid_p): Likewise.\n\t(ix86_print_operand_address): Support UNSPEC_BNDMK_ADDR and\n\tUNSPEC_BNDMK_ADDR.\n\t(ix86_class_likely_spilled_p): Add bound regs support.\n\t(ix86_hard_regno_mode_ok): Likewise.\n\t(x86_order_regs_for_local_alloc): Likewise.\n\t(ix86_bnd_prefixed_insn_p): New.\n\t* config/i386/i386.h (FIRST_PSEUDO_REGISTER): Fix to new value.\n\t(FIXED_REGISTERS): Add bound registers.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(REG_ALLOC_ORDER): Likewise.\n\t(HARD_REGNO_NREGS): Likewise.\n\t(TARGET_MPX): New.\n\t(VALID_BND_REG_MODE): New.\n\t(FIRST_BND_REG): New.\n\t(LAST_BND_REG): New.\n\t(reg_class): Add BND_REGS.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(BND_REGNO_P): New.\n\t(ANY_BND_REG_P): New.\n\t(BNDmode): New.\n\t(HI_REGISTER_NAMES): Add bound registers.\n\t* config/i386/i386.md (UNSPEC_BNDMK): New.\n\t(UNSPEC_BNDMK_ADDR): New.\n\t(UNSPEC_BNDSTX): New.\n\t(UNSPEC_BNDLDX): New.\n\t(UNSPEC_BNDLDX_ADDR): New.\n\t(UNSPEC_BNDCL): New.\n\t(UNSPEC_BNDCU): New.\n\t(UNSPEC_BNDCN): New.\n\t(UNSPEC_MPX_FENCE): New.\n\t(BND0_REG): New.\n\t(BND1_REG): New.\n\t(type): Add mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n\t(length_immediate): Likewise.\n\t(prefix_0f): Likewise.\n\t(memory): Likewise.\n\t(prefix_rep): Check for bnd prefix.\n\t(length_nobnd): New.\n\t(length): Use length_nobnd if specified.\n\t(BND): New.\n\t(bnd_ptr): New.\n\t(BNDCHECK): New.\n\t(bndcheck): New.\n\t(*jcc_1): Add bnd prefix and rename length attr to length_nobnd.\n\t(*jcc_2): Likewise.\n\t(jump): Likewise.\n\t(simple_return_internal): Likewise.\n\t(simple_return_pop_internal): Likewise.\n\t(*indirect_jump): Add MPX bnd prefix.\n\t(*tablejump_1): Likewise.\n\t(simple_return_internal_long): Likewise.\n\t(simple_return_indirect_internal): Likewise.\n\t(<mode>_mk): New.\n\t(*<mode>_mk): New.\n\t(mov<mode>): New.\n\t(*mov<mode>_internal_mpx): New.\n\t(<mode>_<bndcheck>): New.\n\t(*<mode>_<bndcheck>): New.\n\t(<mode>_ldx): New.\n\t(*<mode>_ldx): New.\n\t(<mode>_stx): New.\n\t(*<mode>_stx): New.\n\t* config/i386/predicates.md (lea_address_operand): Rename to...\n\t(address_no_seg_operand): ... this.\n\t(address_mpx_no_base_operand): New.\n\t(address_mpx_no_index_operand): New.\n\t(bnd_mem_operator): New.\n\t* config/i386/i386.opt (mmpx): New.\n\t* doc/invoke.texi: Add documentation for the flags -mmpx, -mno-mpx.\n\t* doc/rtl.texi Add documentation for BND32mode and BND64mode.\n\nFrom-SVN: r204046", "tree": {"sha": "1b27bbb3edda5c779a77ecbab7f71a5dde4ae3df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b27bbb3edda5c779a77ecbab7f71a5dde4ae3df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66d6cbaa5612d12933f42472a2ee93de920fb1d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d6cbaa5612d12933f42472a2ee93de920fb1d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d6cbaa5612d12933f42472a2ee93de920fb1d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d6cbaa5612d12933f42472a2ee93de920fb1d2/comments", "author": {"login": "ienkovich", "id": 18308708, "node_id": "MDQ6VXNlcjE4MzA4NzA4", "avatar_url": "https://avatars.githubusercontent.com/u/18308708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ienkovich", "html_url": "https://github.com/ienkovich", "followers_url": "https://api.github.com/users/ienkovich/followers", "following_url": "https://api.github.com/users/ienkovich/following{/other_user}", "gists_url": "https://api.github.com/users/ienkovich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ienkovich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ienkovich/subscriptions", "organizations_url": "https://api.github.com/users/ienkovich/orgs", "repos_url": "https://api.github.com/users/ienkovich/repos", "events_url": "https://api.github.com/users/ienkovich/events{/privacy}", "received_events_url": "https://api.github.com/users/ienkovich/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65f55baca45eab3a999918e37c3853f5cc8ab3ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f55baca45eab3a999918e37c3853f5cc8ab3ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f55baca45eab3a999918e37c3853f5cc8ab3ae"}], "stats": {"total": 587, "additions": 517, "deletions": 70}, "files": [{"sha": "6702604ef551487fd51037ff7d30539719610ea0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -1,3 +1,98 @@\n+2013-10-24  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\n+\t* config/i386/constraints.md (B): New.\n+\t(Ti): New.\n+\t(Tb): New.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Add __MPX__.\n+\t* config/i386/i386-modes.def (BND32): New.\n+\t(BND64): New.\n+\t* config/i386/i386-protos.h (ix86_bnd_prefixed_insn_p): New.\n+\t* config/i386/i386.c (isa_opts): Add mmpx.\n+\t(regclass_map): Add bound registers.\n+\t(dbx_register_map): Likewise.\n+\t(dbx64_register_map): Likewise.\n+\t(svr4_dbx_register_map): Likewise.\n+\t(PTA_MPX): New.\n+\t(ix86_option_override_internal): Support MPX ISA.\n+\t(ix86_conditional_register_usage): Support bound registers.\n+\t(print_reg): Likewise.\n+\t(ix86_code_end): Add MPX bnd prefix.\n+\t(output_set_got): Likewise.\n+\t(ix86_output_call_insn): Likewise.\n+\t(ix86_print_operand): Add '!' (MPX bnd) print prefix support.\n+\t(ix86_print_operand_punct_valid_p): Likewise.\n+\t(ix86_print_operand_address): Support UNSPEC_BNDMK_ADDR and\n+\tUNSPEC_BNDMK_ADDR.\n+\t(ix86_class_likely_spilled_p): Add bound regs support.\n+\t(ix86_hard_regno_mode_ok): Likewise.\n+\t(x86_order_regs_for_local_alloc): Likewise.\n+\t(ix86_bnd_prefixed_insn_p): New.\n+\t* config/i386/i386.h (FIRST_PSEUDO_REGISTER): Fix to new value.\n+\t(FIXED_REGISTERS): Add bound registers.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(REG_ALLOC_ORDER): Likewise.\n+\t(HARD_REGNO_NREGS): Likewise.\n+\t(TARGET_MPX): New.\n+\t(VALID_BND_REG_MODE): New.\n+\t(FIRST_BND_REG): New.\n+\t(LAST_BND_REG): New.\n+\t(reg_class): Add BND_REGS.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(BND_REGNO_P): New.\n+\t(ANY_BND_REG_P): New.\n+\t(BNDmode): New.\n+\t(HI_REGISTER_NAMES): Add bound registers.\n+\t* config/i386/i386.md (UNSPEC_BNDMK): New.\n+\t(UNSPEC_BNDMK_ADDR): New.\n+\t(UNSPEC_BNDSTX): New.\n+\t(UNSPEC_BNDLDX): New.\n+\t(UNSPEC_BNDLDX_ADDR): New.\n+\t(UNSPEC_BNDCL): New.\n+\t(UNSPEC_BNDCU): New.\n+\t(UNSPEC_BNDCN): New.\n+\t(UNSPEC_MPX_FENCE): New.\n+\t(BND0_REG): New.\n+\t(BND1_REG): New.\n+\t(type): Add mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n+\t(length_immediate): Likewise.\n+\t(prefix_0f): Likewise.\n+\t(memory): Likewise.\n+\t(prefix_rep): Check for bnd prefix.\n+\t(length_nobnd): New.\n+\t(length): Use length_nobnd if specified.\n+\t(BND): New.\n+\t(bnd_ptr): New.\n+\t(BNDCHECK): New.\n+\t(bndcheck): New.\n+\t(*jcc_1): Add bnd prefix and rename length attr to length_nobnd.\n+\t(*jcc_2): Likewise.\n+\t(jump): Likewise.\n+\t(simple_return_internal): Likewise.\n+\t(simple_return_pop_internal): Likewise.\n+\t(*indirect_jump): Add MPX bnd prefix.\n+\t(*tablejump_1): Likewise.\n+\t(simple_return_internal_long): Likewise.\n+\t(simple_return_indirect_internal): Likewise.\n+\t(<mode>_mk): New.\n+\t(*<mode>_mk): New.\n+\t(mov<mode>): New.\n+\t(*mov<mode>_internal_mpx): New.\n+\t(<mode>_<bndcheck>): New.\n+\t(*<mode>_<bndcheck>): New.\n+\t(<mode>_ldx): New.\n+\t(*<mode>_ldx): New.\n+\t(<mode>_stx): New.\n+\t(*<mode>_stx): New.\n+\t* config/i386/predicates.md (lea_address_operand): Rename to...\n+\t(address_no_seg_operand): ... this.\n+\t(address_mpx_no_base_operand): New.\n+\t(address_mpx_no_index_operand): New.\n+\t(bnd_mem_operator): New.\n+\t* config/i386/i386.opt (mmpx): New.\n+\t* doc/invoke.texi: Add documentation for the flags -mmpx, -mno-mpx.\n+\t* doc/rtl.texi Add documentation for BND32mode and BND64mode.\n+\n 2013-10-24  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* mode-classes.def (MODE_POINTER_BOUNDS): New."}, {"sha": "ddfd402ba11391b6feff8310fe4313acae056a95", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -18,7 +18,7 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;;; Unused letters:\n-;;;     B     H           T\n+;;;           H\n ;;;           h j\n \n ;; Integer register constraints.\n@@ -91,6 +91,9 @@\n (define_register_constraint \"x\" \"TARGET_SSE ? SSE_REGS : NO_REGS\"\n  \"Any SSE register.\")\n \n+(define_register_constraint \"B\" \"TARGET_MPX ? BND_REGS : NO_REGS\"\n+ \"@internal Any bound register.\")\n+\n ;; We use the Y prefix to denote any number of conditional register sets:\n ;;  z\tFirst SSE register.\n ;;  i\tSSE2 inter-unit moves to SSE register enabled\n@@ -232,3 +235,15 @@\n    to fit that range (for immediate operands in zero-extending x86-64\n    instructions).\"\n   (match_operand 0 \"x86_64_zext_immediate_operand\"))\n+\n+;; T prefix is used for different address constraints\n+;;   i - address with no index and no rip\n+;;   b - address with no base and no rip\n+\n+(define_address_constraint \"Ti\"\n+  \"MPX address operand without index\"\n+  (match_operand 0 \"address_mpx_no_index_operand\"))\n+\n+(define_address_constraint \"Tb\"\n+  \"MPX address operand without base\"\n+  (match_operand 0 \"address_mpx_no_base_operand\"))"}, {"sha": "a6eaf8ad34a0b216ee53174dc8983e7318e7491d", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -358,6 +358,8 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__SSE_MATH__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))\n     def_or_undef (parse_in, \"__SSE2_MATH__\");\n+  if (isa_flag & OPTION_MASK_ISA_MPX)\n+    def_or_undef (parse_in, \"__MPX__\");\n }\n \n \f"}, {"sha": "a73730e08e20ce7ffd39d4981d2c167f947d183f", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -87,6 +87,9 @@ VECTOR_MODE (INT, DI, 1);     /*                   V1DI */\n VECTOR_MODE (INT, SI, 1);     /*                   V1SI */\n VECTOR_MODE (INT, QI, 2);     /*                   V2QI */\n \n+POINTER_BOUNDS_MODE (BND32, 8);\n+POINTER_BOUNDS_MODE (BND64, 16);\n+\n INT_MODE (OI, 32);\n INT_MODE (XI, 64);\n "}, {"sha": "b1d014a1a27f558716968c92beee10848956d95b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -241,6 +241,8 @@ extern void ix86_expand_mul_widen_hilo (rtx, rtx, rtx, bool, bool);\n extern void ix86_expand_sse2_mulv4si3 (rtx, rtx, rtx);\n extern void ix86_expand_sse2_mulvxdi3 (rtx, rtx, rtx);\n \n+extern bool ix86_bnd_prefixed_insn_p (rtx);\n+\n /* In i386-c.c  */\n extern void ix86_target_macros (void);\n extern void ix86_register_pragmas (void);"}, {"sha": "4a185bfe535b5a4cf01251e926f45dc0ab7d778c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -1943,6 +1943,8 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   /* Mask registers.  */\n   MASK_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n   MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n+  /* MPX bound registers */\n+  BND_REGS, BND_REGS, BND_REGS, BND_REGS,\n };\n \n /* The \"default\" register map used in 32bit mode.  */\n@@ -1959,6 +1961,7 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n   93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n+  101, 102, 103, 104,\t\t\t/* bound registers */\n };\n \n /* The \"default\" register map used in 64bit mode.  */\n@@ -1975,6 +1978,7 @@ int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n   67, 68, 69, 70, 71, 72, 73, 74,       /* AVX-512 registers 16-23 */\n   75, 76, 77, 78, 79, 80, 81, 82,       /* AVX-512 registers 24-31 */\n   118, 119, 120, 121, 122, 123, 124, 125, /* Mask registers */\n+  126, 127, 128, 129,\t\t\t/* bound registers */\n };\n \n /* Define the register numbers to be used in Dwarf debugging information.\n@@ -2043,6 +2047,7 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n   93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n+  -1, -1, -1, -1,                       /* bound registers */\n };\n \n /* Define parameter passing and return registers.  */\n@@ -2469,6 +2474,7 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, const char *arch,\n     { \"-mrtm\",\t\tOPTION_MASK_ISA_RTM },\n     { \"-mxsave\",\tOPTION_MASK_ISA_XSAVE },\n     { \"-mxsaveopt\",\tOPTION_MASK_ISA_XSAVEOPT },\n+    { \"-mmpx\",          OPTION_MASK_ISA_MPX },\n   };\n \n   /* Flag options.  */\n@@ -2963,6 +2969,7 @@ ix86_option_override_internal (bool main_args_p,\n #define PTA_AVX512ER\t\t(HOST_WIDE_INT_1 << 41)\n #define PTA_AVX512PF\t\t(HOST_WIDE_INT_1 << 42)\n #define PTA_AVX512CD\t\t(HOST_WIDE_INT_1 << 43)\n+#define PTA_MPX\t\t\t(HOST_WIDE_INT_1 << 44)\n \n /* if this reaches 64, need to widen struct pta flags below */\n \n@@ -4148,6 +4155,11 @@ ix86_conditional_register_usage (void)\n       for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n \tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n     }\n+\n+  /* If MPX is disabled, squash the registers.  */\n+  if (! TARGET_MPX)\n+    for (i = FIRST_BND_REG; i <= LAST_BND_REG; i++)\n+      fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n }\n \n \f\n@@ -8870,7 +8882,7 @@ ix86_code_end (void)\n       xops[0] = gen_rtx_REG (Pmode, regno);\n       xops[1] = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n       output_asm_insn (\"mov%z0\\t{%1, %0|%0, %1}\", xops);\n-      fputs (\"\\tret\\n\", asm_out_file);\n+      output_asm_insn (\"%!ret\", NULL);\n       final_end_function ();\n       init_insn_lengths ();\n       free_after_compilation (cfun);\n@@ -8928,7 +8940,7 @@ output_set_got (rtx dest, rtx label)\n \n       xops[2] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n       xops[2] = gen_rtx_MEM (QImode, xops[2]);\n-      output_asm_insn (\"call\\t%X2\", xops);\n+      output_asm_insn (\"%!call\\t%X2\", xops);\n \n #if TARGET_MACHO\n       /* Output the Mach-O \"canonical\" pic base label name (\"Lxx$pb\") here.\n@@ -14281,7 +14293,7 @@ print_reg (rtx x, int code, FILE *file)\n     case 8:\n     case 4:\n     case 12:\n-      if (! ANY_FP_REG_P (x))\n+      if (! ANY_FP_REG_P (x) &&  ! ANY_BND_REG_P (x))\n \tputc (code == 8 && TARGET_64BIT ? 'r' : 'e', file);\n       /* FALLTHRU */\n     case 16:\n@@ -14404,6 +14416,7 @@ get_some_local_dynamic_name (void)\n    ~ -- print \"i\" if TARGET_AVX2, \"f\" otherwise.\n    @ -- print a segment register of thread base pointer load\n    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n+   ! -- print MPX prefix for jxx/call/ret instructions if required.\n  */\n \n void\n@@ -14898,6 +14911,11 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    fputs (\"addr32 \", file);\n \t  return;\n \n+\tcase '!':\n+\t  if (ix86_bnd_prefixed_insn_p (NULL_RTX))\n+\t    fputs (\"bnd \", file);\n+\t  return;\n+\n \tdefault:\n \t    output_operand_lossage (\"invalid operand code '%c'\", code);\n \t}\n@@ -15040,7 +15058,7 @@ static bool\n ix86_print_operand_punct_valid_p (unsigned char code)\n {\n   return (code == '@' || code == '*' || code == '+' || code == '&'\n-\t  || code == ';' || code == '~' || code == '^');\n+\t  || code == ';' || code == '~' || code == '^' || code == '!');\n }\n \f\n /* Print a memory operand whose address is ADDR.  */\n@@ -15070,6 +15088,25 @@ ix86_print_operand_address (FILE *file, rtx addr)\n       ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n       code = 'q';\n     }\n+  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDMK_ADDR)\n+    {\n+      ok = ix86_decompose_address (XVECEXP (addr, 0, 1), &parts);\n+      gcc_assert (parts.base == NULL_RTX || parts.index == NULL_RTX);\n+      if (parts.base != NULL_RTX)\n+\t{\n+\t  parts.index = parts.base;\n+\t  parts.scale = 1;\n+\t}\n+      parts.base = XVECEXP (addr, 0, 0);\n+      addr = XVECEXP (addr, 0, 0);\n+    }\n+  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDLDX_ADDR)\n+    {\n+      ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n+      gcc_assert (parts.index == NULL_RTX);\n+      parts.index = XVECEXP (addr, 0, 1);\n+      addr = XVECEXP (addr, 0, 0);\n+    }\n   else\n     ok = ix86_decompose_address (addr, &parts);\n \n@@ -24284,13 +24321,13 @@ ix86_output_call_insn (rtx insn, rtx call_op)\n   if (SIBLING_CALL_P (insn))\n     {\n       if (direct_p)\n-\txasm = \"jmp\\t%P0\";\n+\txasm = \"%!jmp\\t%P0\";\n       /* SEH epilogue detection requires the indirect branch case\n \t to include REX.W.  */\n       else if (TARGET_SEH)\n-\txasm = \"rex.W jmp %A0\";\n+\txasm = \"%!rex.W jmp %A0\";\n       else\n-\txasm = \"jmp\\t%A0\";\n+\txasm = \"%!jmp\\t%A0\";\n \n       output_asm_insn (xasm, &call_op);\n       return \"\";\n@@ -24327,9 +24364,9 @@ ix86_output_call_insn (rtx insn, rtx call_op)\n     }\n \n   if (direct_p)\n-    xasm = \"call\\t%P0\";\n+    xasm = \"%!call\\t%P0\";\n   else\n-    xasm = \"call\\t%A0\";\n+    xasm = \"%!call\\t%A0\";\n \n   output_asm_insn (xasm, &call_op);\n \n@@ -34320,6 +34357,7 @@ ix86_class_likely_spilled_p (reg_class_t rclass)\n       case SSE_FIRST_REG:\n       case FP_TOP_REG:\n       case FP_SECOND_REG:\n+      case BND_REGS:\n \treturn true;\n \n       default:\n@@ -34668,6 +34706,8 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     return VALID_FP_MODE_P (mode);\n   if (MASK_REGNO_P (regno))\n     return VALID_MASK_REG_MODE (mode);\n+  if (BND_REGNO_P (regno))\n+    return VALID_BND_REG_MODE (mode);\n   if (SSE_REGNO_P (regno))\n     {\n       /* We implement the move patterns for all vector modes into and\n@@ -35481,6 +35521,10 @@ x86_order_regs_for_local_alloc (void)\n    for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n      reg_alloc_order [pos++] = i;\n \n+   /* MPX bound registers.  */\n+   for (i = FIRST_BND_REG; i <= LAST_BND_REG; i++)\n+     reg_alloc_order [pos++] = i;\n+\n    /* x87 registers.  */\n    if (TARGET_SSE_MATH)\n      for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n@@ -41914,6 +41958,18 @@ ix86_expand_sse2_mulvxdi3 (rtx op0, rtx op1, rtx op2)\n \t\t       gen_rtx_MULT (mode, op1, op2));\n }\n \n+/* Return 1 if control tansfer instruction INSN\n+   should be encoded with bnd prefix.\n+   If insn is NULL then return 1 when control\n+   transfer instructions should be prefixed with\n+   bnd by default for current function.  */\n+\n+bool\n+ix86_bnd_prefixed_insn_p (rtx insn ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* Expand an insert into a vector register through pinsr insn.\n    Return true if successful.  */\n "}, {"sha": "92299a2f77f8ce4f4f1b146fde089b1e50f2a7d3", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -945,7 +945,7 @@ enum target_cpu_default\n    eliminated during reloading in favor of either the stack or frame\n    pointer.  */\n \n-#define FIRST_PSEUDO_REGISTER 77\n+#define FIRST_PSEUDO_REGISTER 81\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -977,7 +977,9 @@ enum target_cpu_default\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n /*  k0,  k1, k2, k3, k4, k5, k6, k7*/\t\t\t\t\\\n-     0,  0,   0,  0,  0,  0,  0,  0 }\n+     0,  0,   0,  0,  0,  0,  0,  0,\t\t\t\t\\\n+/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n+     0,  0,  0,  0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -1011,7 +1013,9 @@ enum target_cpu_default\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      6,    6,     6,    6,    6,    6,    6,    6,\t\t\\\n  /* k0,  k1,  k2,  k3,  k4,  k5,  k6,  k7*/\t\t\t\\\n-     1,   1,   1,   1,   1,   1,   1,   1 }\n+     1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n+/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n+     1,  1,  1,  1 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -1027,7 +1031,8 @@ enum target_cpu_default\n    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\t\\\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \\\n    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n-   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76 }\n+   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,  \\\n+   78, 79, 80 }\n \n /* ADJUST_REG_ALLOC_ORDER is a macro which permits reg_alloc_order\n    to be rearranged based on a particular function.  When using sse math,\n@@ -1049,6 +1054,7 @@ enum target_cpu_default\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (STACK_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n+   || BND_REGNO_P (REGNO)\t\t\t\t\t\t\\\n    ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n    : ((MODE) == XFmode\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n@@ -1098,6 +1104,9 @@ enum target_cpu_default\n    || (MODE) == V2SImode || (MODE) == SImode\t\t\t\t\\\n    || (MODE) == V4HImode || (MODE) == V8QImode)\n \n+#define VALID_BND_REG_MODE(MODE) \\\n+  (TARGET_64BIT ? (MODE) == BND64mode : (MODE) == BND32mode)\n+\n #define VALID_DFP_MODE_P(MODE) \\\n   ((MODE) == SDmode || (MODE) == DDmode || (MODE) == TDmode)\n \n@@ -1204,6 +1213,9 @@ enum target_cpu_default\n #define FIRST_MASK_REG  (LAST_EXT_REX_SSE_REG + 1) /*69*/\n #define LAST_MASK_REG   (FIRST_MASK_REG + 7) /*76*/\n \n+#define FIRST_BND_REG  (LAST_MASK_REG + 1) /*77*/\n+#define LAST_BND_REG   (FIRST_BND_REG + 3) /*80*/\n+\n /* Override this in other tm.h files to cope with various OS lossage\n    requiring a frame pointer.  */\n #ifndef SUBTARGET_FRAME_POINTER_REQUIRED\n@@ -1284,6 +1296,7 @@ enum reg_class\n   SSE_FIRST_REG,\n   SSE_REGS,\n   EVEX_SSE_REGS,\n+  BND_REGS,\n   ALL_SSE_REGS,\n   MMX_REGS,\n   FP_TOP_SSE_REGS,\n@@ -1341,6 +1354,7 @@ enum reg_class\n    \"SSE_FIRST_REG\",\t\t\t\\\n    \"SSE_REGS\",\t\t\t\t\\\n    \"EVEX_SSE_REGS\",\t\t\t\\\n+   \"BND_REGS\",\t\t\t\t\\\n    \"ALL_SSE_REGS\",\t\t\t\\\n    \"MMX_REGS\",\t\t\t\t\\\n    \"FP_TOP_SSE_REGS\",\t\t\t\\\n@@ -1360,37 +1374,38 @@ enum reg_class\n    TARGET_CONDITIONAL_REGISTER_USAGE.  */\n \n #define REG_CLASS_CONTENTS                                              \\\n-{     { 0x00,       0x0,   0x0 },                                       \\\n-      { 0x01,       0x0,   0x0 },       /* AREG */                      \\\n-      { 0x02,       0x0,   0x0 },       /* DREG */                      \\\n-      { 0x04,       0x0,   0x0 },       /* CREG */                      \\\n-      { 0x08,       0x0,   0x0 },       /* BREG */                      \\\n-      { 0x10,       0x0,   0x0 },       /* SIREG */                     \\\n-      { 0x20,       0x0,   0x0 },       /* DIREG */                     \\\n-      { 0x03,       0x0,   0x0 },       /* AD_REGS */                   \\\n-      { 0x0f,       0x0,   0x0 },       /* Q_REGS */                    \\\n-  { 0x1100f0,    0x1fe0,   0x0 },       /* NON_Q_REGS */                \\\n-      { 0x7f,    0x1fe0,   0x0 },       /* INDEX_REGS */                \\\n-  { 0x1100ff,       0x0,   0x0 },       /* LEGACY_REGS */               \\\n-      { 0x07,       0x0,   0x0 },       /* CLOBBERED_REGS */            \\\n-  { 0x1100ff,    0x1fe0,   0x0 },       /* GENERAL_REGS */              \\\n-     { 0x100,       0x0,   0x0 },       /* FP_TOP_REG */                \\\n-    { 0x0200,       0x0,   0x0 },       /* FP_SECOND_REG */             \\\n-    { 0xff00,       0x0,   0x0 },       /* FLOAT_REGS */                \\\n-  { 0x200000,       0x0,   0x0 },       /* SSE_FIRST_REG */             \\\n-{ 0x1fe00000,  0x1fe000,   0x0 },       /* SSE_REGS */                  \\\n-       { 0x0,0xffe00000,  0x1f },       /* EVEX_SSE_REGS */             \\\n-{ 0x1fe00000,0xffffe000,  0x1f },       /* ALL_SSE_REGS */              \\\n-{ 0xe0000000,      0x1f,   0x0 },       /* MMX_REGS */                  \\\n-{ 0x1fe00100,0xffffe000,  0x1f },       /* FP_TOP_SSE_REG */            \\\n-{ 0x1fe00200,0xffffe000,  0x1f },       /* FP_SECOND_SSE_REG */         \\\n-{ 0x1fe0ff00,0xffffe000,  0x1f },       /* FLOAT_SSE_REGS */            \\\n-{   0x11ffff,    0x1fe0,   0x0 },       /* FLOAT_INT_REGS */            \\\n-{ 0x1ff100ff,0xffffffe0,  0x1f },       /* INT_SSE_REGS */              \\\n-{ 0x1ff1ffff,0xffffffe0,  0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n-       { 0x0,       0x0,0x1fc0 },       /* MASK_EVEX_REGS */           \\\n-       { 0x0,       0x0,0x1fe0 },       /* MASK_REGS */                 \\\n-{ 0xffffffff,0xffffffff,0x1fff }                                        \\\n+{     { 0x00,       0x0,    0x0 },                                       \\\n+      { 0x01,       0x0,    0x0 },       /* AREG */                      \\\n+      { 0x02,       0x0,    0x0 },       /* DREG */                      \\\n+      { 0x04,       0x0,    0x0 },       /* CREG */                      \\\n+      { 0x08,       0x0,    0x0 },       /* BREG */                      \\\n+      { 0x10,       0x0,    0x0 },       /* SIREG */                     \\\n+      { 0x20,       0x0,    0x0 },       /* DIREG */                     \\\n+      { 0x03,       0x0,    0x0 },       /* AD_REGS */                   \\\n+      { 0x0f,       0x0,    0x0 },       /* Q_REGS */                    \\\n+  { 0x1100f0,    0x1fe0,    0x0 },       /* NON_Q_REGS */                \\\n+      { 0x7f,    0x1fe0,    0x0 },       /* INDEX_REGS */                \\\n+  { 0x1100ff,       0x0,    0x0 },       /* LEGACY_REGS */               \\\n+      { 0x07,       0x0,    0x0 },       /* CLOBBERED_REGS */            \\\n+  { 0x1100ff,    0x1fe0,    0x0 },       /* GENERAL_REGS */              \\\n+     { 0x100,       0x0,    0x0 },       /* FP_TOP_REG */                \\\n+    { 0x0200,       0x0,    0x0 },       /* FP_SECOND_REG */             \\\n+    { 0xff00,       0x0,    0x0 },       /* FLOAT_REGS */                \\\n+  { 0x200000,       0x0,    0x0 },       /* SSE_FIRST_REG */             \\\n+{ 0x1fe00000,  0x1fe000,    0x0 },       /* SSE_REGS */                  \\\n+       { 0x0,0xffe00000,   0x1f },       /* EVEX_SSE_REGS */             \\\n+       { 0x0,       0x0,0x1e000 },       /* BND_REGS */\t\t\t \\\n+{ 0x1fe00000,0xffffe000,   0x1f },       /* ALL_SSE_REGS */              \\\n+{ 0xe0000000,      0x1f,    0x0 },       /* MMX_REGS */                  \\\n+{ 0x1fe00100,0xffffe000,   0x1f },       /* FP_TOP_SSE_REG */            \\\n+{ 0x1fe00200,0xffffe000,   0x1f },       /* FP_SECOND_SSE_REG */         \\\n+{ 0x1fe0ff00,0xffffe000,   0x1f },       /* FLOAT_SSE_REGS */            \\\n+{   0x11ffff,    0x1fe0,    0x0 },       /* FLOAT_INT_REGS */            \\\n+{ 0x1ff100ff,0xffffffe0,   0x1f },       /* INT_SSE_REGS */              \\\n+{ 0x1ff1ffff,0xffffffe0,   0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n+       { 0x0,       0x0, 0x1fc0 },       /* MASK_EVEX_REGS */           \\\n+       { 0x0,       0x0, 0x1fe0 },       /* MASK_REGS */                 \\\n+{ 0xffffffff,0xffffffff, 0x1fff }                                        \\\n }\n \n /* The same information, inverted:\n@@ -1466,6 +1481,9 @@ enum reg_class\n #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)\n \n+#define BND_REGNO_P(N) IN_RANGE ((N), FIRST_BND_REG, LAST_BND_REG)\n+#define ANY_BND_REG_P(X) (REG_P (X) && BND_REGNO_P (REGNO (X)))\n+\n /* The class value for index registers, and the one for base regs.  */\n \n #define INDEX_REG_CLASS INDEX_REGS\n@@ -1910,6 +1928,9 @@ do {\t\t\t\t\t\t\t\\\n    between pointers and any other objects of this machine mode.  */\n #define Pmode (ix86_pmode == PMODE_DI ? DImode : SImode)\n \n+/* Specify the machine mode that bounds have.  */\n+#define BNDmode (ix86_pmode == PMODE_DI ? BND64mode : BND32mode)\n+\n /* A C expression whose value is zero if pointers that need to be extended\n    from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and\n    greater then zero if they are zero-extended and less then zero if the\n@@ -2020,7 +2041,8 @@ do {\t\t\t\t\t\t\t\\\n  \"xmm20\", \"xmm21\", \"xmm22\", \"xmm23\",\t\t\t\t\t\\\n  \"xmm24\", \"xmm25\", \"xmm26\", \"xmm27\",\t\t\t\t\t\\\n  \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\",\t\t\t\t\t\\\n- \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\" }\n+ \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\",\t\t\t\\\n+ \"bnd0\", \"bnd1\", \"bnd2\", \"bnd3\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n "}, {"sha": "bb2581bcfad52a2b923e36ef584ccd06c946d4f7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 196, "deletions": 21, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -63,6 +63,7 @@\n ;; ~ -- print \"i\" if TARGET_AVX2, \"f\" otherwise.\n ;; @ -- print a segment register of thread base pointer load\n ;; ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n+;; ! -- print MPX prefix for jxx/call/ret instructions if required.\n \n (define_c_enum \"unspec\" [\n   ;; Relocation specifiers\n@@ -178,6 +179,16 @@\n   ;; For BMI2 support\n   UNSPEC_PDEP\n   UNSPEC_PEXT\n+\n+  UNSPEC_BNDMK\n+  UNSPEC_BNDMK_ADDR\n+  UNSPEC_BNDSTX\n+  UNSPEC_BNDLDX\n+  UNSPEC_BNDLDX_ADDR\n+  UNSPEC_BNDCL\n+  UNSPEC_BNDCU\n+  UNSPEC_BNDCN\n+  UNSPEC_MPX_FENCE\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -336,6 +347,8 @@\n    (MASK5_REG\t\t\t74)\n    (MASK6_REG\t\t\t75)\n    (MASK7_REG\t\t\t76)\n+   (BND0_REG\t\t\t77)\n+   (BND1_REG\t\t\t78)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n@@ -369,7 +382,8 @@\n    ssecvt,ssecvt1,sseicvt,sseins,\n    sseshuf,sseshuf1,ssemuladd,sse4arg,\n    lwp,mskmov,msklog,\n-   mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft\"\n+   mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft,\n+   mpxmov,mpxmk,mpxchk,mpxld,mpxst\"\n   (const_string \"other\"))\n \n ;; Main data type used by the insn\n@@ -398,7 +412,8 @@\n ;; The (bounding maximum) length of an instruction immediate.\n (define_attr \"length_immediate\" \"\"\n   (cond [(eq_attr \"type\" \"incdec,setcc,icmov,str,lea,other,multi,idiv,leave,\n-\t\t\t  bitmanip,imulx,msklog,mskmov\")\n+\t\t\t  bitmanip,imulx,msklog,mskmov,mpxmk,mpxmov,mpxchk,\n+\t\t\t  mpxld,mpxst\")\n \t   (const_int 0)\n \t (eq_attr \"unit\" \"i387,sse,mmx\")\n \t   (const_int 0)\n@@ -453,13 +468,17 @@\n \t   (const_int 0)\n \t (and (eq_attr \"unit\" \"sse\") (eq_attr \"mode\" \"SF,DF\"))\n \t   (const_int 1)\n+\t (and (eq_attr \"type\" \"ibr,call,callv\")\n+\t      (match_test \"ix86_bnd_prefixed_insn_p (insn)\"))\n+\t   (const_int 1)\n \t]\n \t(const_int 0)))\n \n ;; Set when 0f opcode prefix is used.\n (define_attr \"prefix_0f\" \"\"\n   (if_then_else\n-    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip,msklog,mskmov\")\n+    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip,msklog,mskmov,\n+\t\t\t  mpxmk,mpxmov,mpxchk,mpxld,mpxst\")\n \t (eq_attr \"unit\" \"sse,mmx\"))\n     (const_int 1)\n     (const_int 0)))\n@@ -562,12 +581,19 @@\n \t ]\n \t (const_int 1)))\n \n+;; When this attribute is set, calculate total insn length from\n+;; length_nobnd attribute, prefixed with eventual bnd prefix byte\n+(define_attr \"length_nobnd\" \"\" (const_int 0))\n+\n ;; The (bounding maximum) length of an instruction in bytes.\n ;; ??? fistp and frndint are in fact fldcw/{fistp,frndint}/fldcw sequences.\n ;; Later we may want to split them and compute proper length as for\n ;; other insns.\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"other,multi,fistp,frndint\")\n+  (cond [(eq_attr \"length_nobnd\" \"!0\")\n+\t   (plus (symbol_ref (\"ix86_bnd_prefixed_insn_p (insn)\"))\n+\t\t (attr \"length_nobnd\"))\n+\t (eq_attr \"type\" \"other,multi,fistp,frndint\")\n \t   (const_int 16)\n \t (eq_attr \"type\" \"fcmp\")\n \t   (const_int 4)\n@@ -608,12 +634,16 @@\n (define_attr \"memory\" \"none,load,store,both,unknown\"\n   (cond [(eq_attr \"type\" \"other,multi,str,lwp\")\n \t   (const_string \"unknown\")\n-\t (eq_attr \"type\" \"lea,fcmov,fpspc\")\n+\t (eq_attr \"type\" \"lea,fcmov,fpspc,mpxmk,mpxchk\")\n \t   (const_string \"none\")\n \t (eq_attr \"type\" \"fistp,leave\")\n \t   (const_string \"both\")\n \t (eq_attr \"type\" \"frndint\")\n \t   (const_string \"load\")\n+\t (eq_attr \"type\" \"mpxld\")\n+\t   (const_string \"load\")\n+\t (eq_attr \"type\" \"mpxst\")\n+\t   (const_string \"store\")\n \t (eq_attr \"type\" \"push\")\n \t   (if_then_else (match_operand 1 \"memory_operand\")\n \t     (const_string \"both\")\n@@ -659,7 +689,7 @@\n \t\t   fmov,fcmp,fsgn,\n \t\t   sse,ssemov,ssecmp,ssecomi,ssecvt,ssecvt1,sseicvt,\n \t\t   sselog1,sseshuf1,sseadd1,sseiadd1,sseishft1,\n-\t\t   mmx,mmxmov,mmxcmp,mmxcvt,mskmov,msklog\")\n+\t\t   mmx,mmxmov,mmxcmp,mmxcvt,mskmov,msklog,mpxmov\")\n \t      (match_operand 2 \"memory_operand\"))\n \t   (const_string \"load\")\n \t (and (eq_attr \"type\" \"icmov,ssemuladd,sse4arg\")\n@@ -893,6 +923,21 @@\n (define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n \t\t\t    (DI \"TARGET_64BIT\")])\n \n+;; Bound modes.\n+(define_mode_iterator BND [(BND32 \"!TARGET_LP64\")\n+\t\t\t   (BND64 \"TARGET_LP64\")])\n+\n+;; Pointer mode corresponding to bound mode.\n+(define_mode_attr bnd_ptr [(BND32 \"SI\") (BND64 \"DI\")])\n+\n+;; MPX check types\n+(define_int_iterator BNDCHECK [UNSPEC_BNDCL UNSPEC_BNDCU UNSPEC_BNDCN])\n+\n+;; Check name\n+(define_int_attr bndcheck [(UNSPEC_BNDCL \"cl\")\n+\t\t\t   (UNSPEC_BNDCU \"cu\")\n+\t\t\t   (UNSPEC_BNDCN \"cn\")])\n+\n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n \n@@ -5347,7 +5392,7 @@\n \n (define_insn_and_split \"*lea<mode>\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n-\t(match_operand:SWI48 1 \"lea_address_operand\" \"p\"))]\n+\t(match_operand:SWI48 1 \"address_no_seg_operand\" \"p\"))]\n   \"\"\n {\n   if (SImode_address_operand (operands[1], VOIDmode))\n@@ -10734,10 +10779,10 @@\n \t\t      (label_ref (match_operand 0))\n \t\t      (pc)))]\n   \"\"\n-  \"%+j%C1\\t%l0\"\n+  \"%!%+j%C1\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"modrm\" \"0\")\n-   (set (attr \"length\")\n+   (set (attr \"length_nobnd\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -10752,10 +10797,10 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0))))]\n   \"\"\n-  \"%+j%c1\\t%l0\"\n+  \"%!%+j%c1\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"modrm\" \"0\")\n-   (set (attr \"length\")\n+   (set (attr \"length_nobnd\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -11218,9 +11263,9 @@\n   [(set (pc)\n \t(label_ref (match_operand 0)))]\n   \"\"\n-  \"jmp\\t%l0\"\n+  \"%!jmp\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n-   (set (attr \"length\")\n+   (set (attr \"length_nobnd\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -11240,7 +11285,7 @@\n (define_insn \"*indirect_jump\"\n   [(set (pc) (match_operand:W 0 \"indirect_branch_operand\" \"rw\"))]\n   \"\"\n-  \"jmp\\t%A0\"\n+  \"%!jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -11289,7 +11334,7 @@\n   [(set (pc) (match_operand:W 0 \"indirect_branch_operand\" \"rw\"))\n    (use (label_ref (match_operand 1)))]\n   \"\"\n-  \"jmp\\t%A0\"\n+  \"%!jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \f\n@@ -11676,8 +11721,8 @@\n (define_insn \"simple_return_internal\"\n   [(simple_return)]\n   \"reload_completed\"\n-  \"ret\"\n-  [(set_attr \"length\" \"1\")\n+  \"%!ret\"\n+  [(set_attr \"length_nobnd\" \"1\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"modrm\" \"0\")])\n@@ -11689,7 +11734,12 @@\n   [(simple_return)\n    (unspec [(const_int 0)] UNSPEC_REP)]\n   \"reload_completed\"\n-  \"rep%; ret\"\n+{\n+  if (ix86_bnd_prefixed_insn_p (insn))\n+    return \"%!ret\";\n+\n+  return \"rep%; ret\";\n+}\n   [(set_attr \"length\" \"2\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"0\")\n@@ -11700,8 +11750,8 @@\n   [(simple_return)\n    (use (match_operand:SI 0 \"const_int_operand\"))]\n   \"reload_completed\"\n-  \"ret\\t%0\"\n-  [(set_attr \"length\" \"3\")\n+  \"%!ret\\t%0\"\n+  [(set_attr \"length_nobnd\" \"3\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"2\")\n    (set_attr \"modrm\" \"0\")])\n@@ -11710,7 +11760,7 @@\n   [(simple_return)\n    (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"reload_completed\"\n-  \"jmp\\t%A0\"\n+  \"%!jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -18173,6 +18223,131 @@\n   [(set_attr \"type\" \"other\")\n    (set_attr \"length\" \"3\")])\n \n+;; MPX instructions\n+\n+(define_expand \"<mode>_mk\"\n+  [(set (match_operand:BND 0 \"register_operand\")\n+    (unspec:BND\n+      [(mem:<bnd_ptr>\n+       (match_par_dup 3\n+        [(match_operand:<bnd_ptr> 1 \"register_operand\")\n+\t (match_operand:<bnd_ptr> 2 \"address_mpx_no_base_operand\")]))]\n+      UNSPEC_BNDMK))]\n+  \"TARGET_MPX\"\n+{\n+  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[1],\n+\t\t\t\t\t\t  operands[2]),\n+                                UNSPEC_BNDMK_ADDR);\n+})\n+\n+(define_insn \"*<mode>_mk\"\n+  [(set (match_operand:BND 0 \"register_operand\" \"=B\")\n+    (unspec:BND\n+      [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n+        [(unspec:<bnd_ptr>\n+\t   [(match_operand:<bnd_ptr> 1 \"register_operand\" \"r\")\n+            (match_operand:<bnd_ptr> 2 \"address_mpx_no_base_operand\" \"Tb\")]\n+\t   UNSPEC_BNDMK_ADDR)])]\n+      UNSPEC_BNDMK))]\n+  \"TARGET_MPX\"\n+  \"bndmk\\t{%3, %0|%0, %3}\"\n+  [(set_attr \"type\" \"mpxmk\")])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:BND 0 \"general_operand\")\n+        (match_operand:BND 1 \"general_operand\"))]\n+  \"TARGET_MPX\"\n+{\n+  ix86_expand_move (<MODE>mode, operands);DONE;\n+})\n+\n+(define_insn \"*mov<mode>_internal_mpx\"\n+  [(set (match_operand:BND 0 \"nonimmediate_operand\" \"=B,m\")\n+        (match_operand:BND 1 \"general_operand\" \"Bm,B\"))]\n+  \"TARGET_MPX\"\n+  \"bndmov\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mpxmov\")])\n+\n+(define_expand \"<mode>_<bndcheck>\"\n+  [(parallel [(unspec [(match_operand:BND 0 \"register_operand\")\n+                       (match_operand:<bnd_ptr> 1 \"address_no_seg_operand\")] BNDCHECK)\n+              (set (match_dup 2)\n+                   (unspec:BLK [(match_dup 2)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+{\n+  operands[2] = gen_rtx_MEM (BLKmode, operands[1]);\n+  MEM_VOLATILE_P (operands[2]) = 1;\n+})\n+\n+(define_insn \"*<mode>_<bndcheck>\"\n+  [(parallel [(unspec [(match_operand:BND 0 \"register_operand\" \"B\")\n+                       (match_operand:<bnd_ptr> 1 \"address_no_seg_operand\" \"p\")] BNDCHECK)\n+              (set (match_operand:BLK 2 \"bnd_mem_operator\")\n+                   (unspec:BLK [(match_dup 2)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+  \"bnd<bndcheck>\\t{%a1, %0|%0, %a1}\"\n+  [(set_attr \"type\" \"mpxchk\")])\n+\n+(define_expand \"<mode>_ldx\"\n+  [(parallel [(set:BND (match_operand:BND 0 \"register_operand\")\n+                       (unspec:BND\n+\t\t         [(mem:<bnd_ptr>\n+\t\t\t   (match_par_dup 3\n+\t\t\t     [(match_operand:<bnd_ptr> 1 \"address_mpx_no_index_operand\")\n+\t                      (match_operand:<bnd_ptr> 2 \"register_operand\")]))]\n+\t\t\t UNSPEC_BNDLDX))\n+              (use (mem:BLK (match_dup 1)))])]\n+  \"TARGET_MPX\"\n+{\n+  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[1],\n+                                                  operands[2]),\n+\t\t\t\tUNSPEC_BNDLDX_ADDR);\n+})\n+\n+(define_insn \"*<mode>_ldx\"\n+  [(parallel [(set:BND (match_operand:BND 0 \"register_operand\" \"=B\")\n+                       (unspec:BND\n+\t\t         [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n+\t\t\t   [(unspec:<bnd_ptr>\n+\t\t\t     [(match_operand:<bnd_ptr> 1 \"address_mpx_no_index_operand\" \"Ti\")\n+\t                      (match_operand:<bnd_ptr> 2 \"register_operand\" \"l\")]\n+\t\t\t    UNSPEC_BNDLDX_ADDR)])]\n+\t\t\t UNSPEC_BNDLDX))\n+              (use (mem:BLK (match_dup 1)))])]\n+  \"TARGET_MPX\"\n+  \"bndldx\\t{%3, %0|%0, %3}\"\n+  [(set_attr \"type\" \"mpxld\")])\n+\n+(define_expand \"<mode>_stx\"\n+  [(parallel [(unspec [(mem:<bnd_ptr>\n+\t\t\t (match_par_dup 3\n+\t\t\t   [(match_operand:<bnd_ptr> 0 \"address_mpx_no_index_operand\")\n+\t                    (match_operand:<bnd_ptr> 1 \"register_operand\")]))\n+\t               (match_operand:BND 2 \"register_operand\")] UNSPEC_BNDSTX)\n+              (set (match_dup 4)\n+                   (unspec:BLK [(match_dup 4)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+{\n+  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[0],\n+                                                  operands[1]),\n+\t\t\t\tUNSPEC_BNDLDX_ADDR);\n+  operands[4] = gen_rtx_MEM (BLKmode, operands[0]);\n+  MEM_VOLATILE_P (operands[4]) = 1;\n+})\n+\n+(define_insn \"*<mode>_stx\"\n+  [(parallel [(unspec [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n+\t\t\t [(unspec:<bnd_ptr>\n+\t\t\t  [(match_operand:<bnd_ptr> 0 \"address_mpx_no_index_operand\" \"Ti\")\n+\t                   (match_operand:<bnd_ptr> 1 \"register_operand\" \"l\")]\n+\t\t\t UNSPEC_BNDLDX_ADDR)])\n+\t               (match_operand:BND 2 \"register_operand\" \"B\")] UNSPEC_BNDSTX)\n+              (set (match_operand:BLK 4 \"bnd_mem_operator\")\n+                   (unspec:BLK [(match_dup 4)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+  \"bndstx\\t{%2, %3|%3, %2}\"\n+  [(set_attr \"type\" \"mpxst\")])\n+\n (include \"mmx.md\")\n (include \"sse.md\")\n (include \"sync.md\")"}, {"sha": "1a1b8abefdcfde2f7fb3172030cefca616a1346e", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -669,6 +669,10 @@ mrtm\n Target Report Mask(ISA_RTM) Var(ix86_isa_flags) Save\n Support RTM built-in functions and code generation\n \n+mmpx\n+Target Report Mask(ISA_MPX) Var(ix86_isa_flags) Save\n+Support MPX code generation\n+\n mstack-protector-guard=\n Target RejectNegative Joined Enum(stack_protector_guard) Var(ix86_stack_protector_guard) Init(SSP_TLS)\n Use given stack-protector guard"}, {"sha": "d1a4f6639d28460501f7042edd9539fd00780b64", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -875,7 +875,7 @@\n ;; Return true if op if a valid address for LEA, and does not contain\n ;; a segment override.  Defined as a special predicate to allow\n ;; mode-less const_int operands pass to address_operand.\n-(define_special_predicate \"lea_address_operand\"\n+(define_special_predicate \"address_no_seg_operand\"\n   (match_operand 0 \"address_operand\")\n {\n   struct ix86_address parts;\n@@ -932,9 +932,74 @@\n   return true;\n })\n \n+;; Return true if op is valid MPX address operand without base\n+(define_predicate \"address_mpx_no_base_operand\"\n+  (match_operand 0 \"address_operand\")\n+{\n+  struct ix86_address parts;\n+  int ok;\n+\n+  ok = ix86_decompose_address (op, &parts);\n+  gcc_assert (ok);\n+\n+  if (parts.index && parts.base)\n+    return false;\n+\n+  if (parts.seg != SEG_DEFAULT)\n+    return false;\n+\n+  /* Do not support (%rip).  */\n+  if (parts.disp && flag_pic && TARGET_64BIT\n+      && SYMBOLIC_CONST (parts.disp))\n+    {\n+      if (GET_CODE (parts.disp) != CONST\n+\t  || GET_CODE (XEXP (parts.disp, 0)) != PLUS\n+\t  || GET_CODE (XEXP (XEXP (parts.disp, 0), 0)) != UNSPEC\n+\t  || !CONST_INT_P (XEXP (XEXP (parts.disp, 0), 1))\n+\t  || (XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_DTPOFF\n+\t      && XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_NTPOFF))\n+\treturn false;\n+    }\n+\n+  return true;\n+})\n+\n+;; Return true if op is valid MPX address operand without index\n+(define_predicate \"address_mpx_no_index_operand\"\n+  (match_operand 0 \"address_operand\")\n+{\n+  struct ix86_address parts;\n+  int ok;\n+\n+  ok = ix86_decompose_address (op, &parts);\n+  gcc_assert (ok);\n+\n+  if (parts.index)\n+    return false;\n+\n+  if (parts.seg != SEG_DEFAULT)\n+    return false;\n+\n+  /* Do not support (%rip).  */\n+  if (parts.disp && flag_pic && TARGET_64BIT\n+      && SYMBOLIC_CONST (parts.disp)\n+      && (GET_CODE (parts.disp) != CONST\n+\t  || GET_CODE (XEXP (parts.disp, 0)) != PLUS\n+\t  || GET_CODE (XEXP (XEXP (parts.disp, 0), 0)) != UNSPEC\n+\t  || !CONST_INT_P (XEXP (XEXP (parts.disp, 0), 1))\n+\t  || (XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_DTPOFF\n+\t      && XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_NTPOFF)))\n+    return false;\n+\n+  return true;\n+})\n+\n (define_predicate \"vsib_mem_operator\"\n   (match_code \"mem\"))\n \n+(define_predicate \"bnd_mem_operator\"\n+  (match_code \"mem\"))\n+\n ;; Return true if the rtx is known to be at least 32 bits aligned.\n (define_predicate \"aligned_operand\"\n   (match_operand 0 \"general_operand\")"}, {"sha": "9b5b0775c4c54ba7461d2eb537d60db259eb7680", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -668,7 +668,7 @@ Objective-C and Objective-C++ Dialects}.\n -mavx2 -mavx512f -mavx512pf -mavx512er -mavx512cd @gol\n -maes -mpclmul -mfsgsbase -mrdrnd -mf16c -mfma @gol\n -msse4a -m3dnow -mpopcnt -mabm -mbmi -mtbm -mfma4 -mxop -mlzcnt @gol\n--mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mthreads @gol\n+-mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mmpx -mthreads @gol\n -mno-align-stringops  -minline-all-stringops @gol\n -minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol\n -mmemcpy-strategy=@var{strategy} -mmemset-strategy=@var{strategy}\n@@ -14992,6 +14992,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mrtm\n @itemx -mtbm\n @itemx -mno-tbm\n+@itemx -mmpx\n+@itemx -mno-mpx\n @opindex mmmx\n @opindex mno-mmx\n @opindex msse\n@@ -15001,7 +15003,7 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n These switches enable or disable the use of instructions in the MMX, SSE,\n SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD,\n AES, PCLMUL, FSGSBASE, RDRND, F16C, FMA, SSE4A, FMA4, XOP, LWP, ABM, BMI, BMI2,\n-FXSR, XSAVE, XSAVEOPT, LZCNT, RTM or 3DNow!@:\n+FXSR, XSAVE, XSAVEOPT, LZCNT, RTM, MPX or 3DNow!@:\n extended instruction sets.\n These extensions are also available as built-in functions: see\n @ref{X86 Built-in Functions}, for details of the functions enabled and"}, {"sha": "df2bb6806dc2740db4e0c7ae875f8a24359acaa8", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d6cbaa5612d12933f42472a2ee93de920fb1d2/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=66d6cbaa5612d12933f42472a2ee93de920fb1d2", "patch": "@@ -1295,6 +1295,12 @@ These modes stand for a complex number represented as a pair of integer\n values.  The integer values are in @code{QImode}, @code{HImode},\n @code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},\n respectively.\n+\n+@findex BND32mode\n+@findex BND64mode\n+@item BND32mode BND64mode\n+These modes stand for bounds for pointer of 32 and 64 bit size respectively.\n+Mode size is double pointer mode size.\n @end table\n \n The machine description defines @code{Pmode} as a C macro which expands"}]}