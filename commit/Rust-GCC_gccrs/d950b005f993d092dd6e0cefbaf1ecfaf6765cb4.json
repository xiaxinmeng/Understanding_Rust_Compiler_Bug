{"sha": "d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk1MGIwMDVmOTkzZDA5MmRkNmUwY2VmYmFmMWVjZmFmNjc2NWNiNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-02-12T21:18:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-02-12T21:18:51Z"}, "message": "PR c++/89144 - link error with constexpr initializer_list.\n\nIn this PR, we were unnecessarily rejecting a constexpr initializer_list\nwith no elements.  This seems like a fairly useless degenerate case, but it\nmakes sense to avoid allocating an underlying array at all if there are no\nelements and instead use a null pointer, like the initializer_list default\nconstructor.\n\nIf the (automatic storage duration) list does have initializer elements, we\ncontinue to reject the declaration, because the initializer_list ends up\nreferring to an automatic storage duration temporary array, which is not a\nsuitable constant initializer.  If we make it static, it should be OK\nbecause we refer to a static array.  The second hunk fixes that case.  It\nalso means we won't diagnose some real errors in templates, but those\ndiagnostics aren't required, and we'll get them when the template is\ninstantiated.\n\n\t* call.c (convert_like_real) [ck_list]: Don't allocate a temporary\n\tarray for an empty list.\n\t* typeck2.c (store_init_value): Don't use cxx_constant_init in a\n\ttemplate.\n\nFrom-SVN: r268827", "tree": {"sha": "8672ef152764d8e8920214c9d589230803191a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8672ef152764d8e8920214c9d589230803191a12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "705c92a2ab98d373c8500fd096cd49e8cc97c070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705c92a2ab98d373c8500fd096cd49e8cc97c070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/705c92a2ab98d373c8500fd096cd49e8cc97c070"}], "stats": {"total": 95, "additions": 69, "deletions": 26}, "files": [{"sha": "cb74761571682fb0c21da27e652e072307b2cfbb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "patch": "@@ -1,3 +1,11 @@\n+2019-02-12  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/89144 - link error with constexpr initializer_list.\n+\t* call.c (convert_like_real) [ck_list]: Don't allocate a temporary\n+\tarray for an empty list.\n+\t* typeck2.c (store_init_value): Don't use cxx_constant_init in a\n+\ttemplate.\n+\n 2019-02-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/89241 - ICE with __func__ in lambda in template."}, {"sha": "c53eb582aac9a3509f1f4296d82e3dc35e5e8899", "filename": "gcc/cp/call.c", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "patch": "@@ -7085,34 +7085,42 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       {\n \t/* Conversion to std::initializer_list<T>.  */\n \ttree elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (totype), 0);\n-\ttree new_ctor = build_constructor (init_list_type_node, NULL);\n \tunsigned len = CONSTRUCTOR_NELTS (expr);\n-\ttree array, val, field;\n-\tvec<constructor_elt, va_gc> *vec = NULL;\n-\tunsigned ix;\n+\ttree array;\n \n-\t/* Convert all the elements.  */\n-\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), ix, val)\n+\tif (len)\n \t  {\n-\t    tree sub = convert_like_real (convs->u.list[ix], val, fn, argnum,\n-\t\t\t\t\t  false, false, complain);\n-\t    if (sub == error_mark_node)\n-\t      return sub;\n-\t    if (!BRACE_ENCLOSED_INITIALIZER_P (val)\n-\t\t&& !check_narrowing (TREE_TYPE (sub), val, complain))\n-\t      return error_mark_node;\n-\t    CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_ctor), NULL_TREE, sub);\n-\t    if (!TREE_CONSTANT (sub))\n-\t      TREE_CONSTANT (new_ctor) = false;\n+\t    tree val; unsigned ix;\n+\n+\t    tree new_ctor = build_constructor (init_list_type_node, NULL);\n+\n+\t    /* Convert all the elements.  */\n+\t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), ix, val)\n+\t      {\n+\t\ttree sub = convert_like_real (convs->u.list[ix], val, fn,\n+\t\t\t\t\t      argnum, false, false, complain);\n+\t\tif (sub == error_mark_node)\n+\t\t  return sub;\n+\t\tif (!BRACE_ENCLOSED_INITIALIZER_P (val)\n+\t\t    && !check_narrowing (TREE_TYPE (sub), val, complain))\n+\t\t  return error_mark_node;\n+\t\tCONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_ctor),\n+\t\t\t\t\tNULL_TREE, sub);\n+\t\tif (!TREE_CONSTANT (sub))\n+\t\t  TREE_CONSTANT (new_ctor) = false;\n+\t      }\n+\t    /* Build up the array.  */\n+\t    elttype = cp_build_qualified_type\n+\t      (elttype, cp_type_quals (elttype) | TYPE_QUAL_CONST);\n+\t    array = build_array_of_n_type (elttype, len);\n+\t    array = finish_compound_literal (array, new_ctor, complain);\n+\t    /* Take the address explicitly rather than via decay_conversion\n+\t       to avoid the error about taking the address of a temporary.  */\n+\t    array = cp_build_addr_expr (array, complain);\n \t  }\n-\t/* Build up the array.  */\n-\telttype = cp_build_qualified_type\n-\t  (elttype, cp_type_quals (elttype) | TYPE_QUAL_CONST);\n-\tarray = build_array_of_n_type (elttype, len);\n-\tarray = finish_compound_literal (array, new_ctor, complain);\n-\t/* Take the address explicitly rather than via decay_conversion\n-\t   to avoid the error about taking the address of a temporary.  */\n-\tarray = cp_build_addr_expr (array, complain);\n+\telse\n+\t  array = nullptr_node;\n+\n \tarray = cp_convert (build_pointer_type (elttype), array, complain);\n \tif (array == error_mark_node)\n \t  return error_mark_node;\n@@ -7123,11 +7131,12 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \ttotype = complete_type_or_maybe_complain (totype, NULL_TREE, complain);\n \tif (!totype)\n \t  return error_mark_node;\n-\tfield = next_initializable_field (TYPE_FIELDS (totype));\n+\ttree field = next_initializable_field (TYPE_FIELDS (totype));\n+\tvec<constructor_elt, va_gc> *vec = NULL;\n \tCONSTRUCTOR_APPEND_ELT (vec, field, array);\n \tfield = next_initializable_field (DECL_CHAIN (field));\n \tCONSTRUCTOR_APPEND_ELT (vec, field, size_int (len));\n-\tnew_ctor = build_constructor (totype, vec);\n+\ttree new_ctor = build_constructor (totype, vec);\n \treturn get_target_expr_sfinae (new_ctor, complain);\n       }\n "}, {"sha": "ac2c253196b3bb2e559550b7bcbf760867e3ea81", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "patch": "@@ -850,6 +850,11 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n \t     non-inline in-class-initialized static data member.  */\n \t  if (!require_constant_expression (value))\n \t    value = error_mark_node;\n+\t  else if (processing_template_decl)\n+\t    /* In a template we might not have done the necessary\n+\t       transformations to make value actually constant,\n+\t       e.g. extend_ref_init_temps.  */\n+\t    value = maybe_constant_init (value, decl, true);\n \t  else\n \t    value = cxx_constant_init (value, decl);\n \t}"}, {"sha": "da5eab241de48dc1ca796717df2ddd834bbc0947", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-initlist11.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist11.C?ref=d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/89144\n+// { dg-do link { target c++11 } }\n+\n+#include <initializer_list>\n+\n+template <class> void b() {\n+  static constexpr std::initializer_list<int> c{ 42 };\n+  constexpr std::initializer_list<int> l { };\n+}\n+\n+int main() { b<int>(); }"}, {"sha": "2597c3836ed18b1ac439f31fd51369a60bea74ed", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-initlist11a.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist11a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d950b005f993d092dd6e0cefbaf1ecfaf6765cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist11a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist11a.C?ref=d950b005f993d092dd6e0cefbaf1ecfaf6765cb4", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/89144\n+// { dg-do link { target c++11 } }\n+\n+#include <initializer_list>\n+\n+template <class> void b() {\n+  constexpr std::initializer_list<int> l { 42 }; // { dg-error \"\" }\n+}\n+\n+int main() { b<int>(); }"}]}