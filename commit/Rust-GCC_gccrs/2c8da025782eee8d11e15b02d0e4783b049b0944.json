{"sha": "2c8da025782eee8d11e15b02d0e4783b049b0944", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4ZGEwMjU3ODJlZWU4ZDExZTE1YjAyZDBlNDc4M2IwNDliMDk0NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-21T22:59:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-21T22:59:56Z"}, "message": "(emit_call_1): Added function declaration node argument passed to\nRETURN_POPS_ARGS; also effects calls to emit_call_1.\n\nFrom-SVN: r8997", "tree": {"sha": "f1b36c5475466a2b9a5dcf73e820b314c44f50df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1b36c5475466a2b9a5dcf73e820b314c44f50df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c8da025782eee8d11e15b02d0e4783b049b0944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8da025782eee8d11e15b02d0e4783b049b0944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c8da025782eee8d11e15b02d0e4783b049b0944", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8da025782eee8d11e15b02d0e4783b049b0944/comments", "author": null, "committer": null, "parents": [{"sha": "2a4f6a6151e9e1c87817e113aca30f58ff9eb676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4f6a6151e9e1c87817e113aca30f58ff9eb676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a4f6a6151e9e1c87817e113aca30f58ff9eb676"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "e59205fb9a29d4a40611349096d85e50c720d4df", "filename": "gcc/calls.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8da025782eee8d11e15b02d0e4783b049b0944/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8da025782eee8d11e15b02d0e4783b049b0944/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2c8da025782eee8d11e15b02d0e4783b049b0944", "patch": "@@ -124,7 +124,7 @@ int stack_arg_under_construction;\n \n static int calls_function\tPROTO((tree, int));\n static int calls_function_1\tPROTO((tree, int));\n-static void emit_call_1\t\tPROTO((rtx, tree, int, int, rtx, rtx, int,\n+static void emit_call_1\t\tPROTO((rtx, tree, tree, int, int, rtx, rtx, int,\n \t\t\t\t       rtx, int));\n static void store_one_arg\tPROTO ((struct arg_data *, rtx, int, int,\n \t\t\t\t\ttree, int));\n@@ -301,6 +301,9 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n    and optionally pop the results.\n    The CALL_INSN is the first insn generated.\n \n+   FNDECL is the declaration node of the function.  This is given ot the\n+   macro RETURN_POPS_ARGS to determine whether this function pops its own args.\n+\n    FUNTYPE is the data type of the function, or, for a library call,\n    the identifier for the name of the call.  This is given to the\n    macro RETURN_POPS_ARGS to determine whether this function pops its own args.\n@@ -334,9 +337,11 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n    IS_CONST is true if this is a `const' call.  */\n \n static void\n-emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n+emit_call_1 (funexp, fndecl, funtype, stack_size, struct_value_size, \n+             next_arg_reg,\n \t     valreg, old_inhibit_defer_pop, call_fusage, is_const)\n      rtx funexp;\n+     tree fndecl;\n      tree funtype;\n      int stack_size;\n      int struct_value_size;\n@@ -360,13 +365,15 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n #ifndef ACCUMULATE_OUTGOING_ARGS\n #if defined (HAVE_call_pop) && defined (HAVE_call_value_pop)\n   if (HAVE_call_pop && HAVE_call_value_pop\n-      && (RETURN_POPS_ARGS (funtype, stack_size) > 0 || stack_size == 0))\n+      && (RETURN_POPS_ARGS (fndecl, funtype, stack_size) > 0 \n+          || stack_size == 0))\n     {\n-      rtx n_pop = GEN_INT (RETURN_POPS_ARGS (funtype, stack_size));\n+      rtx n_pop = GEN_INT (RETURN_POPS_ARGS (fndecl, funtype, stack_size));\n       rtx pat;\n \n       /* If this subroutine pops its own args, record that in the call insn\n \t if possible, for the sake of frame pointer elimination.  */\n+\n       if (valreg)\n \tpat = gen_call_value_pop (valreg,\n \t\t\t\t  gen_rtx (MEM, FUNCTION_MODE, funexp),\n@@ -439,14 +446,14 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n      If returning from the subroutine does pop the args, indicate that the\n      stack pointer will be changed.  */\n \n-  if (stack_size != 0 && RETURN_POPS_ARGS (funtype, stack_size) > 0)\n+  if (stack_size != 0 && RETURN_POPS_ARGS (fndecl, funtype, stack_size) > 0)\n     {\n       if (!already_popped)\n \tCALL_INSN_FUNCTION_USAGE (call_insn) =\n \t   gen_rtx (EXPR_LIST, VOIDmode,\n \t\t    gen_rtx (CLOBBER, VOIDmode, stack_pointer_rtx),\n \t\t    CALL_INSN_FUNCTION_USAGE (call_insn));\n-      stack_size -= RETURN_POPS_ARGS (funtype, stack_size);\n+      stack_size -= RETURN_POPS_ARGS (fndecl, funtype, stack_size);\n       stack_size_rtx = GEN_INT (stack_size);\n     }\n \n@@ -1892,7 +1899,7 @@ expand_call (exp, target, ignore)\n   /* All arguments and registers used for the call must be set up by now!  */\n \n   /* Generate the actual call instruction.  */\n-  emit_call_1 (funexp, funtype, args_size.constant, struct_value_size,\n+  emit_call_1 (funexp, fndecl, funtype, args_size.constant, struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       valreg, old_inhibit_defer_pop, call_fusage, is_const);\n \n@@ -2446,7 +2453,9 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n      will set inhibit_defer_pop to that value.  */\n \n-  emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n+  emit_call_1 (fun, \n+               get_identifier (XSTR (orgfun, 0)), \n+               get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n \t       old_inhibit_defer_pop + 1, call_fusage, no_queue);\n@@ -2807,7 +2816,9 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n      will set inhibit_defer_pop to that value.  */\n \n-  emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant,\n+  emit_call_1 (fun, \n+               get_identifier (XSTR (orgfun, 0)),\n+               get_identifier (XSTR (orgfun, 0)), args_size.constant,\n \t       struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       (outmode != VOIDmode && mem_value == 0"}]}