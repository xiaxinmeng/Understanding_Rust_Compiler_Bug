{"sha": "cab411a2b4b4f6a6b619d0650fade85288a31f9e", "node_id": "C_kwDOANBUbNoAKGNhYjQxMWEyYjRiNGY2YTZiNjE5ZDA2NTBmYWRlODUyODhhMzFmOWU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-12T08:16:03Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-12T14:40:51Z"}, "message": "Set nonzero bits from bitwise and operator in range-ops.\n\nNow that nonzero bits are first class citizens in the range, we can\nkeep better track of them in range-ops, especially the bitwise and\noperator.\n\nThis patch sets the nonzero mask for the trivial case.  In doing so,\nI've removed some old dead code that was an attempt to keep better\ntrack of masks.\n\nI'm sure there are tons of optimizations throughout range-ops that\ncould be implemented, especially the op1_range methods, but those\nalways make my head hurt.  I'll leave them to the smarter hackers\nout there.\n\nI've removed the restriction that nonzero bits can't be queried from\nlegacy.  This was causing special casing all over the place, and\nit's not like we can generate incorrect code.  We just silently\ndrop nonzero bits to -1 in some of the legacy code.  The end result\nis that VRP1, and other users of legacy, may not benefit from these\nimprovements.\n\nTested and benchmarked on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* range-op.cc (unsigned_singleton_p): Remove.\n\t(operator_bitwise_and::remove_impossible_ranges): Remove.\n\t(operator_bitwise_and::fold_range): Set nonzero bits.  *\n\t* value-range.cc (irange::get_nonzero_bits): Remove\n\tlegacy_mode_p assert.\n\t(irange::dump_bitmasks): Remove legacy_mode_p check.", "tree": {"sha": "20ef2d8a96f990a4565e1153b78bb7f4179eb8e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20ef2d8a96f990a4565e1153b78bb7f4179eb8e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cab411a2b4b4f6a6b619d0650fade85288a31f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab411a2b4b4f6a6b619d0650fade85288a31f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cab411a2b4b4f6a6b619d0650fade85288a31f9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab411a2b4b4f6a6b619d0650fade85288a31f9e/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32a753506be1d5265b657b4b80aeeae57871bb4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a753506be1d5265b657b4b80aeeae57871bb4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32a753506be1d5265b657b4b80aeeae57871bb4c"}], "stats": {"total": 76, "additions": 4, "deletions": 72}, "files": [{"sha": "0e16408027ceb5fdd0c64e6a61d0f0b8cf5fb659", "filename": "gcc/range-op.cc", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab411a2b4b4f6a6b619d0650fade85288a31f9e/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab411a2b4b4f6a6b619d0650fade85288a31f9e/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=cab411a2b4b4f6a6b619d0650fade85288a31f9e", "patch": "@@ -2604,72 +2604,8 @@ class operator_bitwise_and : public range_operator\n   void simple_op1_range_solver (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n \t\t\t\tconst irange &op2) const;\n-  void remove_impossible_ranges (irange &r, const irange &rh) const;\n } op_bitwise_and;\n \n-static bool\n-unsigned_singleton_p (const irange &op)\n-{\n-  tree mask;\n-  if (op.singleton_p (&mask))\n-    {\n-      wide_int x = wi::to_wide (mask);\n-      return wi::ge_p (x, 0, TYPE_SIGN (op.type ()));\n-    }\n-  return false;\n-}\n-\n-// Remove any ranges from R that are known to be impossible when an\n-// range is ANDed with MASK.\n-\n-void\n-operator_bitwise_and::remove_impossible_ranges (irange &r,\n-\t\t\t\t\t\tconst irange &rmask) const\n-{\n-  if (r.undefined_p () || !unsigned_singleton_p (rmask))\n-    return;\n-\n-  wide_int mask = rmask.lower_bound ();\n-  tree type = r.type ();\n-  int prec = TYPE_PRECISION (type);\n-  int leading_zeros = wi::clz (mask);\n-  int_range_max impossible_ranges;\n-\n-  /* We know that starting at the most significant bit, any 0 in the\n-     mask means the resulting range cannot contain a 1 in that same\n-     position.  This means the following ranges are impossible:\n-\n-\tx & 0b1001 1010\n-\t\t\t  IMPOSSIBLE RANGES\n-\t      01xx xxxx   [0100 0000, 0111 1111]\n-\t      001x xxxx   [0010 0000, 0011 1111]\n-\t      0000 01xx   [0000 0100, 0000 0111]\n-\t      0000 0001   [0000 0001, 0000 0001]\n-  */\n-  wide_int one = wi::one (prec);\n-  for (int i = 0; i < prec - leading_zeros - 1; ++i)\n-    if (wi::bit_and (mask, wi::lshift (one, wi::uhwi (i, prec))) == 0)\n-      {\n-\ttree lb = fold_build2 (LSHIFT_EXPR, type,\n-\t\t\t       build_one_cst (type),\n-\t\t\t       build_int_cst (type, i));\n-\ttree ub_left = fold_build1 (BIT_NOT_EXPR, type,\n-\t\t\t\t    fold_build2 (LSHIFT_EXPR, type,\n-\t\t\t\t\t\t build_minus_one_cst (type),\n-\t\t\t\t\t\t build_int_cst (type, i)));\n-\ttree ub_right = fold_build2 (LSHIFT_EXPR, type,\n-\t\t\t\t     build_one_cst (type),\n-\t\t\t\t     build_int_cst (type, i));\n-\ttree ub = fold_build2 (BIT_IOR_EXPR, type, ub_left, ub_right);\n-\timpossible_ranges.union_ (int_range<1> (lb, ub));\n-      }\n-  if (!impossible_ranges.undefined_p ())\n-    {\n-      impossible_ranges.invert ();\n-      r.intersect (impossible_ranges);\n-    }\n-}\n-\n bool\n operator_bitwise_and::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n@@ -2678,9 +2614,9 @@ operator_bitwise_and::fold_range (irange &r, tree type,\n {\n   if (range_operator::fold_range (r, type, lh, rh))\n     {\n-      // FIXME: This is temporarily disabled because, though it\n-      // generates better ranges, it's noticeably slower for evrp.\n-      // remove_impossible_ranges (r, rh);\n+      if (!lh.undefined_p () && !rh.undefined_p ())\n+\tr.set_nonzero_bits (wi::bit_and (lh.get_nonzero_bits (),\n+\t\t\t\t\t rh.get_nonzero_bits ()));\n       return true;\n     }\n   return false;"}, {"sha": "2aa973b2af2eb08f0b624d6526e4a84dedfcaa2b", "filename": "gcc/value-range.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab411a2b4b4f6a6b619d0650fade85288a31f9e/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab411a2b4b4f6a6b619d0650fade85288a31f9e/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=cab411a2b4b4f6a6b619d0650fade85288a31f9e", "patch": "@@ -2388,10 +2388,6 @@ wide_int\n irange::get_nonzero_bits () const\n {\n   gcc_checking_assert (!undefined_p ());\n-  // Nonzero bits are unsupported in legacy mode.  The mask may be set\n-  // as a consequence of propagation or reading global ranges, but no\n-  // one from legacy land should be querying this.\n-  gcc_checking_assert (!legacy_mode_p ());\n \n   // Calculate the nonzero bits inherent in the range.\n   wide_int min = lower_bound ();\n@@ -2509,7 +2505,7 @@ irange::dump (FILE *file) const\n void\n irange::dump_bitmasks (FILE *file) const\n {\n-  if (m_nonzero_mask && !legacy_mode_p ())\n+  if (m_nonzero_mask)\n     {\n       wide_int nz = get_nonzero_bits ();\n       if (nz != -1)"}]}