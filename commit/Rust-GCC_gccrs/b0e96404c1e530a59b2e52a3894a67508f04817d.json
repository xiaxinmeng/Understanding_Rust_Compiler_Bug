{"sha": "b0e96404c1e530a59b2e52a3894a67508f04817d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBlOTY0MDRjMWU1MzBhNTliMmU1MmEzODk0YTY3NTA4ZjA0ODE3ZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-09-29T14:29:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-09-29T14:29:10Z"}, "message": "alias.c (ao_ref_from_mem): Properly deal with off decl accesses resulting from stack temporaries on...\n\n2009-09-29  Richard Guenther  <rguenther@suse.de>\n\n\t* alias.c (ao_ref_from_mem): Properly deal with off decl accesses\n\tresulting from stack temporaries on STRICT_ALIGNMENT targets.\n\nFrom-SVN: r152278", "tree": {"sha": "8c4c73f3b4d3a8dec8a928d7d5e7fe50afb453b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c4c73f3b4d3a8dec8a928d7d5e7fe50afb453b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0e96404c1e530a59b2e52a3894a67508f04817d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e96404c1e530a59b2e52a3894a67508f04817d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e96404c1e530a59b2e52a3894a67508f04817d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e96404c1e530a59b2e52a3894a67508f04817d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b653ed5a4a7478172199ac88a6a0811bb862f1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b653ed5a4a7478172199ac88a6a0811bb862f1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b653ed5a4a7478172199ac88a6a0811bb862f1e"}], "stats": {"total": 73, "additions": 35, "deletions": 38}, "files": [{"sha": "7088e56678ff4fb2544fbb04629c94c56db86adc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e96404c1e530a59b2e52a3894a67508f04817d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e96404c1e530a59b2e52a3894a67508f04817d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0e96404c1e530a59b2e52a3894a67508f04817d", "patch": "@@ -1,3 +1,8 @@\n+2009-09-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* alias.c (ao_ref_from_mem): Properly deal with off decl accesses\n+\tresulting from stack temporaries on STRICT_ALIGNMENT targets.\n+\n 2009-09-29  Nick Clifton  <nickc@redhat.com>\n \n \t* function.c (current_function_name): If there is no current"}, {"sha": "694498ab55ab99d30b339deafc570868fbd2d40d", "filename": "gcc/alias.c", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e96404c1e530a59b2e52a3894a67508f04817d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e96404c1e530a59b2e52a3894a67508f04817d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b0e96404c1e530a59b2e52a3894a67508f04817d", "patch": "@@ -265,6 +265,11 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n   if (!expr)\n     return false;\n \n+  /* If MEM_OFFSET or MEM_SIZE are NULL punt.  */\n+  if (!MEM_OFFSET (mem)\n+      || !MEM_SIZE (mem))\n+    return false;\n+\n   ao_ref_init (ref, expr);\n \n   /* Get the base of the reference and see if we have to reject or\n@@ -302,45 +307,32 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n \n   ref->ref_alias_set = MEM_ALIAS_SET (mem);\n \n-  /* For NULL MEM_OFFSET the MEM_EXPR may have been stripped arbitrarily\n-     without recording offset or extent adjustments properly.  */\n-  if (MEM_OFFSET (mem) == NULL_RTX)\n-    {\n-      ref->offset = 0;\n-      ref->max_size = -1;\n-    }\n-  else if (INTVAL (MEM_OFFSET (mem)) < 0\n-\t   && MEM_EXPR (mem) != get_spill_slot_decl (false))\n-    {\n-      /* Negative MEM_OFFSET happens for promoted subregs on bigendian\n-         targets.  We need to compensate both the size and the offset here,\n-\t which get_ref_base_and_extent will have done based on the MEM_EXPR\n-\t already.  */\n-      gcc_assert (((INTVAL (MEM_SIZE (mem)) + INTVAL (MEM_OFFSET (mem)))\n-\t\t   * BITS_PER_UNIT)\n-\t\t  == ref->size);\n-      return true;\n-    }\n-  else\n-    {\n-      ref->offset += INTVAL (MEM_OFFSET (mem)) * BITS_PER_UNIT;\n-    }\n+  /* If the base decl is a parameter we can have negative MEM_OFFSET in\n+     case of promoted subregs on bigendian targets.  Trust the MEM_EXPR\n+     here.  */\n+  if (INTVAL (MEM_OFFSET (mem)) < 0\n+      && ((INTVAL (MEM_SIZE (mem)) + INTVAL (MEM_OFFSET (mem)))\n+\t  * BITS_PER_UNIT) == ref->size)\n+    return true;\n \n-  /* NULL MEM_SIZE should not really happen with a non-NULL MEM_EXPR,\n-     but just play safe here.  The size may have been adjusted together\n-     with the offset, so we need to take it if it is set and not rely\n-     on MEM_EXPR here (which has the size determining parts potentially\n-     stripped anyway).  We lose precision for max_size which is only\n-     available from the remaining MEM_EXPR.  */\n-  if (MEM_SIZE (mem) == NULL_RTX)\n-    {\n-      ref->size = -1;\n-      ref->max_size = -1;\n-    }\n-  else\n-    {\n-      ref->size = INTVAL (MEM_SIZE (mem)) * BITS_PER_UNIT;\n-    }\n+  ref->offset += INTVAL (MEM_OFFSET (mem)) * BITS_PER_UNIT;\n+  ref->size = INTVAL (MEM_SIZE (mem)) * BITS_PER_UNIT;\n+\n+  /* The MEM may extend into adjacent fields, so adjust max_size if\n+     necessary.  */\n+  if (ref->max_size != -1\n+      && ref->size > ref->max_size)\n+    ref->max_size = ref->size;\n+\n+  /* If MEM_OFFSET and MEM_SIZE get us outside of the base object of\n+     the MEM_EXPR punt.  This happens for STRICT_ALIGNMENT targets a lot.  */\n+  if (MEM_EXPR (mem) != get_spill_slot_decl (false)\n+      && (ref->offset < 0\n+\t  || (DECL_P (ref->base)\n+\t      && (!host_integerp (DECL_SIZE (ref->base), 1)\n+\t\t  || (TREE_INT_CST_LOW (DECL_SIZE ((ref->base)))\n+\t\t      < (unsigned HOST_WIDE_INT)(ref->offset + ref->size))))))\n+    return false;\n \n   return true;\n }"}]}