{"sha": "c0e5ca327ba69655de7eae9628b85ad5a615dd77", "node_id": "C_kwDOANBUbNoAKGMwZTVjYTMyN2JhNjk2NTVkZTdlYWU5NjI4Yjg1YWQ1YTYxNWRkNzc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-11T14:51:22Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-11T15:34:17Z"}, "message": "Support deref_mut lang item during method resolution\n\nWhen we have method resolution we need to look at any deref lang items for\nthe receiver. The precise rules need to be tested rigorously to ensure this is right.\n\nFixes #890", "tree": {"sha": "59405bd9b3abb50f0db69d80c6c924c0a4ed2c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59405bd9b3abb50f0db69d80c6c924c0a4ed2c68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e5ca327ba69655de7eae9628b85ad5a615dd77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e5ca327ba69655de7eae9628b85ad5a615dd77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e5ca327ba69655de7eae9628b85ad5a615dd77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e5ca327ba69655de7eae9628b85ad5a615dd77/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9023bb8687347559702340c24cd72301f0656a59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9023bb8687347559702340c24cd72301f0656a59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9023bb8687347559702340c24cd72301f0656a59"}], "stats": {"total": 927, "additions": 605, "deletions": 322}, "files": [{"sha": "5d02f060d29424d0b233ce5d1e0ef24862c4592b", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -89,6 +89,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n     rust/rust-hir-type-check-pattern.o \\\n+    rust/rust-hir-dot-operator.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\"}, {"sha": "54116daa37eb89ecf7c6ffcd55c7a17d470736a6", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -67,6 +67,9 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n   tree resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \t\t\t\t tree expression, Location locus);\n \n+  tree resolve_indirection_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t       tree expression, Location locus);\n+\n   static void setup_attributes_on_fndecl (\n     tree fndecl, bool is_main_entry_point, bool has_visibility,\n     const HIR::FunctionQualifiers &qualifiers, const AST::AttrVec &attrs);"}, {"sha": "65f159ef60361f4d78d6c9521ba95c3764c4eea3", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -1199,9 +1199,14 @@ HIRCompileBase::resolve_adjustements (\n \t  e = address_expression (e, locus);\n \t  break;\n \n-\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF:\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_MUT:\n \t  e = resolve_deref_adjustment (adjustment, e, locus);\n \t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::INDIRECTION:\n+\t  e = resolve_indirection_adjustment (adjustment, e, locus);\n+\t  break;\n \t}\n     }\n \n@@ -1212,17 +1217,9 @@ tree\n HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \t\t\t\t\t  tree expression, Location locus)\n {\n-  rust_assert (adjustment.is_deref_adjustment ());\n-\n-  tree expected_type\n-    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-  if (!adjustment.has_operator_overload ())\n-    {\n-      return ctx->get_backend ()->indirect_expression (expected_type,\n-\t\t\t\t\t\t       expression,\n-\t\t\t\t\t\t       true, /* known_valid*/\n-\t\t\t\t\t\t       locus);\n-    }\n+  rust_assert (adjustment.is_deref_adjustment ()\n+\t       || adjustment.is_deref_mut_adjustment ());\n+  rust_assert (adjustment.has_operator_overload ());\n \n   TyTy::FnType *lookup = adjustment.get_deref_operator_fn ();\n   HIR::ImplItem *resolved_item = adjustment.get_deref_hir_item ();\n@@ -1246,13 +1243,19 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \n   // make the call\n   auto fncontext = ctx->peek_fn ();\n-  tree deref_call\n-    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n-\t\t\t\t\t    {adjusted_argument}, nullptr,\n-\t\t\t\t\t    locus);\n+  return ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n+\t\t\t\t\t       {adjusted_argument}, nullptr,\n+\t\t\t\t\t       locus);\n+}\n+\n+tree\n+HIRCompileBase::resolve_indirection_adjustment (\n+  Resolver::Adjustment &adjustment, tree expression, Location locus)\n+{\n+  tree expected_type\n+    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \n-  // do the indirect expression\n-  return ctx->get_backend ()->indirect_expression (expected_type, deref_call,\n+  return ctx->get_backend ()->indirect_expression (expected_type, expression,\n \t\t\t\t\t\t   true, /* known_valid*/\n \t\t\t\t\t\t   locus);\n }"}, {"sha": "286225266a2bbabb1844ba0dfea23dfb51b8e9ca", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -19,6 +19,7 @@\n #include \"rust-autoderef.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-dot-operator.h\"\n+#include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -29,26 +30,6 @@ resolve_operator_overload_fn (\n   TyTy::FnType **resolved_fn, HIR::ImplItem **impl_item,\n   Adjustment::AdjustmentType *requires_ref_adjustment);\n \n-bool\n-Adjuster::needs_address (const std::vector<Adjustment> &adjustments)\n-{\n-  for (auto &adjustment : adjustments)\n-    {\n-      switch (adjustment.get_type ())\n-\t{\n-\tcase Adjustment::AdjustmentType::IMM_REF:\n-\tcase Adjustment::AdjustmentType::MUT_REF:\n-\tcase Adjustment::AdjustmentType::DEREF_REF:\n-\t  return true;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n TyTy::BaseType *\n Adjuster::adjust_type (const std::vector<Adjustment> &adjustments)\n {\n@@ -59,36 +40,64 @@ Adjuster::adjust_type (const std::vector<Adjustment> &adjustments)\n }\n \n Adjustment\n-Adjuster::try_deref_type (const TyTy::BaseType *ty)\n+Adjuster::try_deref_type (const TyTy::BaseType *ty,\n+\t\t\t  Analysis::RustLangItem::ItemType deref_lang_item)\n {\n-  // probe for the lang-item\n-  TyTy::BaseType *resolved_base = ty->clone ();\n-\n   HIR::ImplItem *impl_item = nullptr;\n   TyTy::FnType *fn = nullptr;\n   Adjustment::AdjustmentType requires_ref_adjustment\n     = Adjustment::AdjustmentType::ERROR;\n   bool operator_overloaded\n-    = resolve_operator_overload_fn (Analysis::RustLangItem::ItemType::DEREF, ty,\n-\t\t\t\t    &fn, &impl_item, &requires_ref_adjustment);\n-  if (operator_overloaded)\n+    = resolve_operator_overload_fn (deref_lang_item, ty, &fn, &impl_item,\n+\t\t\t\t    &requires_ref_adjustment);\n+  if (!operator_overloaded)\n     {\n-      resolved_base = fn->get_return_type ()->clone ();\n+      return Adjustment::get_error ();\n     }\n \n+  auto resolved_base = fn->get_return_type ()->clone ();\n   bool is_valid_type = resolved_base->get_kind () == TyTy::TypeKind::REF;\n   if (!is_valid_type)\n     return Adjustment::get_error ();\n \n   TyTy::ReferenceType *ref_base\n     = static_cast<TyTy::ReferenceType *> (resolved_base);\n \n-  auto infered = ref_base->get_base ()->clone ();\n+  Adjustment::AdjustmentType adjustment_type\n+    = Adjustment::AdjustmentType::ERROR;\n+  switch (deref_lang_item)\n+    {\n+    case Analysis::RustLangItem::ItemType::DEREF:\n+      adjustment_type = Adjustment::AdjustmentType::DEREF;\n+      break;\n \n-  return Adjustment::get_op_overload_deref_adjustment (infered, fn, impl_item,\n+    case Analysis::RustLangItem::ItemType::DEREF_MUT:\n+      adjustment_type = Adjustment::AdjustmentType::DEREF_MUT;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return Adjustment::get_op_overload_deref_adjustment (adjustment_type,\n+\t\t\t\t\t\t       ref_base, fn, impl_item,\n \t\t\t\t\t\t       requires_ref_adjustment);\n }\n \n+Adjustment\n+Adjuster::try_raw_deref_type (const TyTy::BaseType *ty)\n+{\n+  bool is_valid_type = ty->get_kind () == TyTy::TypeKind::REF;\n+  if (!is_valid_type)\n+    return Adjustment::get_error ();\n+\n+  const TyTy::ReferenceType *ref_base\n+    = static_cast<const TyTy::ReferenceType *> (ty);\n+  auto infered = ref_base->get_base ()->clone ();\n+\n+  return Adjustment (Adjustment::AdjustmentType::INDIRECTION, infered);\n+}\n+\n static bool\n resolve_operator_overload_fn (\n   Analysis::RustLangItem::ItemType lang_item_type, const TyTy::BaseType *ty,"}, {"sha": "f389aff62c0cd7871c4e3d56b4ce7eba72365d5c", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -33,7 +33,9 @@ class Adjustment\n \n     IMM_REF,\n     MUT_REF,\n-    DEREF_REF\n+    DEREF,\n+    DEREF_MUT,\n+    INDIRECTION,\n   };\n \n   // ctor for all adjustments except derefs\n@@ -42,11 +44,12 @@ class Adjustment\n   {}\n \n   static Adjustment get_op_overload_deref_adjustment (\n-    const TyTy::BaseType *expected, TyTy::FnType *fn, HIR::ImplItem *deref_item,\n+    AdjustmentType type, const TyTy::BaseType *expected, TyTy::FnType *fn,\n+    HIR::ImplItem *deref_item,\n     Adjustment::AdjustmentType requires_ref_adjustment)\n   {\n-    return Adjustment (Adjustment::DEREF_REF, expected, fn, deref_item,\n-\t\t       requires_ref_adjustment);\n+    rust_assert (type == DEREF || type == DEREF_MUT);\n+    return Adjustment (type, expected, fn, deref_item, requires_ref_adjustment);\n   }\n \n   AdjustmentType get_type () const { return type; }\n@@ -69,8 +72,12 @@ class Adjustment\n \treturn \"IMM_REF\";\n       case AdjustmentType::MUT_REF:\n \treturn \"MUT_REF\";\n-      case AdjustmentType::DEREF_REF:\n-\treturn \"DEREF_REF\";\n+      case AdjustmentType::DEREF:\n+\treturn \"DEREF\";\n+      case AdjustmentType::DEREF_MUT:\n+\treturn \"DEREF_MUT\";\n+      case AdjustmentType::INDIRECTION:\n+\treturn \"INDIRECTION\";\n       }\n     gcc_unreachable ();\n     return \"\";\n@@ -80,7 +87,9 @@ class Adjustment\n \n   bool is_error () const { return type == ERROR; }\n \n-  bool is_deref_adjustment () const { return type == DEREF_REF; }\n+  bool is_deref_adjustment () const { return type == DEREF; }\n+\n+  bool is_deref_mut_adjustment () const { return type == DEREF_MUT; }\n \n   bool has_operator_overload () const { return deref_operator_fn != nullptr; }\n \n@@ -120,9 +129,11 @@ class Adjuster\n \n   TyTy::BaseType *adjust_type (const std::vector<Adjustment> &adjustments);\n \n-  static bool needs_address (const std::vector<Adjustment> &adjustments);\n+  static Adjustment\n+  try_deref_type (const TyTy::BaseType *ty,\n+\t\t  Analysis::RustLangItem::ItemType deref_lang_item);\n \n-  static Adjustment try_deref_type (const TyTy::BaseType *ty);\n+  static Adjustment try_raw_deref_type (const TyTy::BaseType *ty);\n \n private:\n   const TyTy::BaseType *base;"}, {"sha": "84bbc0c4e0a9e5028fc4c8673c9154043e55b2d1", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -0,0 +1,359 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-dot-operator.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+MethodCandidate\n+MethodResolver::Probe (const TyTy::BaseType *receiver,\n+\t\t       const HIR::PathIdentSegment &segment_name,\n+\t\t       bool autoderef_flag)\n+{\n+  const TyTy::BaseType *r = receiver;\n+  std::vector<Adjustment> adjustments;\n+  while (true)\n+    {\n+      auto res = Try (r, segment_name, adjustments);\n+      if (!res.is_error ())\n+\treturn res;\n+\n+      // 4. deref to to 1, if cannot deref then quit\n+      if (autoderef_flag)\n+\treturn MethodCandidate::get_error ();\n+\n+      Adjustment deref\n+\t= Adjuster::try_deref_type (r, Analysis::RustLangItem::ItemType::DEREF);\n+      if (!deref.is_error ())\n+\t{\n+\t  auto deref_r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\t  auto res = Try (deref_r, segment_name, adjustments);\n+\t  if (!res.is_error ())\n+\t    {\n+\t      return res;\n+\t    }\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      Adjustment deref_mut = Adjuster::try_deref_type (\n+\tr, Analysis::RustLangItem::ItemType::DEREF_MUT);\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\t  auto res = Try (deref_r, segment_name, adjustments);\n+\t  if (!res.is_error ())\n+\t    {\n+\t      return res;\n+\t    }\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\t  Adjustment raw_deref = Adjuster::try_raw_deref_type (deref_r);\n+\t  adjustments.push_back (raw_deref);\n+\t  deref_r = raw_deref.get_expected ();\n+\n+\t  auto res = Try (deref_r, segment_name, adjustments);\n+\t  if (!res.is_error ())\n+\t    {\n+\t      return res;\n+\t    }\n+\n+\t  adjustments.pop_back ();\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref.is_error ())\n+\t{\n+\t  r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\t}\n+      Adjustment raw_deref = Adjuster::try_raw_deref_type (r);\n+      if (raw_deref.is_error ())\n+\treturn MethodCandidate::get_error ();\n+\n+      r = raw_deref.get_expected ();\n+      adjustments.push_back (raw_deref);\n+    }\n+  return MethodCandidate::get_error ();\n+}\n+\n+MethodCandidate\n+MethodResolver::Try (const TyTy::BaseType *r,\n+\t\t     const HIR::PathIdentSegment &segment_name,\n+\t\t     std::vector<Adjustment> &adjustments)\n+{\n+  PathProbeCandidate c = PathProbeCandidate::get_error ();\n+  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds\n+    = r->get_specified_bounds ();\n+\n+  // 1. try raw\n+  MethodResolver raw (*r, segment_name, specified_bounds);\n+  c = raw.select ();\n+  if (!c.is_error ())\n+    {\n+      return MethodCandidate{c, adjustments};\n+    }\n+\n+  // 2. try ref\n+  TyTy::ReferenceType *r1\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Imm);\n+  MethodResolver imm_ref (*r1, segment_name, specified_bounds);\n+  c = imm_ref.select ();\n+  if (!c.is_error ())\n+    {\n+      adjustments.push_back (\n+\tAdjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n+      return MethodCandidate{c, adjustments};\n+    }\n+\n+  // 3. try mut ref\n+  TyTy::ReferenceType *r2\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Mut);\n+  MethodResolver mut_ref (*r2, segment_name, specified_bounds);\n+  c = mut_ref.select ();\n+  if (!c.is_error ())\n+    {\n+      adjustments.push_back (\n+\tAdjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n+      return MethodCandidate{c, adjustments};\n+    }\n+\n+  return MethodCandidate::get_error ();\n+}\n+\n+PathProbeCandidate\n+MethodResolver::select ()\n+{\n+  struct impl_item_candidate\n+  {\n+    HIR::Function *item;\n+    HIR::ImplBlock *impl_block;\n+    TyTy::FnType *ty;\n+  };\n+\n+  // assemble inherent impl items\n+  std::vector<impl_item_candidate> inherent_impl_fns;\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      bool is_trait_impl = impl->has_trait_ref ();\n+      if (is_trait_impl)\n+\treturn true;\n+\n+      bool is_fn\n+\t= item->get_impl_item_type () == HIR::ImplItem::ImplItemType::FUNCTION;\n+      if (!is_fn)\n+\treturn true;\n+\n+      HIR::Function *func = static_cast<HIR::Function *> (item);\n+      if (!func->is_method ())\n+\treturn true;\n+\n+      bool name_matches\n+\t= func->get_function_name ().compare (segment_name.as_string ()) == 0;\n+      if (!name_matches)\n+\treturn true;\n+\n+      TyTy::BaseType *ty = nullptr;\n+      if (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+\treturn true;\n+      if (ty->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn true;\n+\n+      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+      inherent_impl_fns.push_back ({func, impl, fnty});\n+\n+      return true;\n+    });\n+\n+  struct trait_item_candidate\n+  {\n+    const HIR::TraitItemFunc *item;\n+    const HIR::Trait *trait;\n+    TyTy::FnType *ty;\n+    const TraitReference *reference;\n+    const TraitItemReference *item_ref;\n+  };\n+\n+  std::vector<trait_item_candidate> trait_fns;\n+  mappings->iterate_impl_blocks ([&] (HirId id,\n+\t\t\t\t      HIR::ImplBlock *impl) mutable -> bool {\n+    bool is_trait_impl = impl->has_trait_ref ();\n+    if (!is_trait_impl)\n+      return true;\n+\n+    // look for impl implementation else lookup the associated trait item\n+    for (auto &impl_item : impl->get_impl_items ())\n+      {\n+\tbool is_fn = impl_item->get_impl_item_type ()\n+\t\t     == HIR::ImplItem::ImplItemType::FUNCTION;\n+\tif (!is_fn)\n+\t  continue;\n+\n+\tHIR::Function *func = static_cast<HIR::Function *> (impl_item.get ());\n+\tif (!func->is_method ())\n+\t  continue;\n+\n+\tbool name_matches\n+\t  = func->get_function_name ().compare (segment_name.as_string ()) == 0;\n+\tif (!name_matches)\n+\t  continue;\n+\n+\tTyTy::BaseType *ty = nullptr;\n+\tif (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+\t  continue;\n+\tif (ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  continue;\n+\n+\trust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+\tTyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+\tinherent_impl_fns.push_back ({func, impl, fnty});\n+\treturn true;\n+      }\n+\n+    TraitReference *trait_ref\n+      = TraitResolver::Resolve (*impl->get_trait_ref ().get ());\n+    rust_assert (!trait_ref->is_error ());\n+\n+    auto item_ref\n+      = trait_ref->lookup_trait_item (segment_name.as_string (),\n+\t\t\t\t      TraitItemReference::TraitItemType::FN);\n+    if (item_ref->is_error ())\n+      return true;\n+\n+    const HIR::Trait *trait = trait_ref->get_hir_trait_ref ();\n+    HIR::TraitItem *item = item_ref->get_hir_trait_item ();\n+    rust_assert (item->get_item_kind () == HIR::TraitItem::TraitItemKind::FUNC);\n+    HIR::TraitItemFunc *func = static_cast<HIR::TraitItemFunc *> (item);\n+\n+    TyTy::BaseType *ty = item_ref->get_tyty ();\n+    rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+    trait_item_candidate candidate{func, trait, fnty, trait_ref, item_ref};\n+    trait_fns.push_back (candidate);\n+\n+    return true;\n+  });\n+\n+  // lookup specified bounds for an associated item\n+  struct precdicate_candidate\n+  {\n+    TyTy::TypeBoundPredicateItem lookup;\n+    TyTy::FnType *fntype;\n+  };\n+\n+  std::vector<precdicate_candidate> predicate_items;\n+  for (auto &bound : specified_bounds)\n+    {\n+      TyTy::TypeBoundPredicateItem lookup\n+\t= bound.lookup_associated_item (segment_name.as_string ());\n+      if (lookup.is_error ())\n+\tcontinue;\n+\n+      bool is_fn = lookup.get_raw_item ()->get_trait_item_type ()\n+\t\t   == TraitItemReference::TraitItemType::FN;\n+      if (!is_fn)\n+\tcontinue;\n+\n+      TyTy::BaseType *ty = lookup.get_raw_item ()->get_tyty ();\n+      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+      precdicate_candidate candidate{lookup, fnty};\n+      predicate_items.push_back (candidate);\n+    }\n+\n+  for (auto impl_item : inherent_impl_fns)\n+    {\n+      TyTy::FnType *fn = impl_item.ty;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n+\t\t\t\t\t\t  impl_item.impl_block};\n+\t  return PathProbeCandidate (\n+\t    PathProbeCandidate::CandidateType::IMPL_FUNC, fn,\n+\t    impl_item.item->get_locus (), c);\n+\t}\n+    }\n+\n+  for (auto trait_item : trait_fns)\n+    {\n+      TyTy::FnType *fn = trait_item.ty;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n+\t\t\t\t\t\t   trait_item.item_ref,\n+\t\t\t\t\t\t   nullptr};\n+\t  return PathProbeCandidate (\n+\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, fn,\n+\t    trait_item.item->get_locus (), c);\n+\t}\n+    }\n+\n+  for (auto predicate : predicate_items)\n+    {\n+      TyTy::FnType *fn = predicate.fntype;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  const TraitReference *trait_ref\n+\t    = predicate.lookup.get_parent ()->get ();\n+\t  const TraitItemReference *trait_item\n+\t    = predicate.lookup.get_raw_item ();\n+\n+\t  TyTy::BaseType *subst = predicate.lookup.get_tyty_for_receiver (\n+\t    receiver.get_root (),\n+\t    predicate.lookup.get_parent ()->get_generic_args ());\n+\n+\t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n+\t\t\t\t\t\t   nullptr};\n+\t  return PathProbeCandidate (\n+\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, subst,\n+\t    trait_item->get_locus (), c);\n+\t}\n+    }\n+\n+  return PathProbeCandidate::get_error ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "f14300a4bfec806c99cb496920066aedba98fcd6", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 5, "deletions": 265, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -20,7 +20,6 @@\n #define RUST_HIR_DOT_OPERATOR\n \n #include \"rust-hir-path-probe.h\"\n-#include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -46,273 +45,14 @@ class MethodResolver : public TypeCheckBase\n public:\n   static MethodCandidate Probe (const TyTy::BaseType *receiver,\n \t\t\t\tconst HIR::PathIdentSegment &segment_name,\n-\t\t\t\tbool autoderef_flag = false)\n-  {\n-    const TyTy::BaseType *r = receiver;\n-    std::vector<Adjustment> adjustments;\n-    while (true)\n-      {\n-\tPathProbeCandidate c = PathProbeCandidate::get_error ();\n-\tconst std::vector<TyTy::TypeBoundPredicate> &specified_bounds\n-\t  = r->get_specified_bounds ();\n-\n-\t// 1. try raw\n-\tMethodResolver raw (*r, segment_name, specified_bounds);\n-\tc = raw.select ();\n-\tif (!c.is_error ())\n-\t  return MethodCandidate{c, adjustments};\n-\n-\t// 2. try ref\n-\tTyTy::ReferenceType *r1\n-\t  = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n-\t\t\t\t     Mutability::Imm);\n-\tMethodResolver imm_ref (*r1, segment_name, specified_bounds);\n-\tc = imm_ref.select ();\n-\tif (!c.is_error ())\n-\t  {\n-\t    adjustments.push_back (\n-\t      Adjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n-\t    return MethodCandidate{c, adjustments};\n-\t  }\n-\n-\t// 3. try mut ref\n-\tTyTy::ReferenceType *r2\n-\t  = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n-\t\t\t\t     Mutability::Mut);\n-\tMethodResolver mut_ref (*r2, segment_name, specified_bounds);\n-\tc = mut_ref.select ();\n-\tif (!c.is_error ())\n-\t  {\n-\t    adjustments.push_back (\n-\t      Adjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n-\t    return MethodCandidate{c, adjustments};\n-\t  }\n-\n-\t// 4. deref to to 1, if cannot deref then quit\n-\tif (autoderef_flag)\n-\t  {\n-\t    return MethodCandidate::get_error ();\n-\t  }\n-\telse\n-\t  {\n-\t    Adjustment deref = Adjuster::try_deref_type (r);\n-\t    if (deref.is_error ())\n-\t      return MethodCandidate::get_error ();\n-\n-\t    r = deref.get_expected ();\n-\t    adjustments.push_back (deref);\n-\t  }\n-      }\n-    return MethodCandidate::get_error ();\n-  }\n+\t\t\t\tbool autoderef_flag = false);\n \n protected:\n-  PathProbeCandidate select ()\n-  {\n-    struct impl_item_candidate\n-    {\n-      HIR::Function *item;\n-      HIR::ImplBlock *impl_block;\n-      TyTy::FnType *ty;\n-    };\n-\n-    // assemble inherent impl items\n-    std::vector<impl_item_candidate> inherent_impl_fns;\n-    mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n-\t\t\t\t       HIR::ImplBlock *impl) mutable -> bool {\n-      bool is_trait_impl = impl->has_trait_ref ();\n-      if (is_trait_impl)\n-\treturn true;\n-\n-      bool is_fn\n-\t= item->get_impl_item_type () == HIR::ImplItem::ImplItemType::FUNCTION;\n-      if (!is_fn)\n-\treturn true;\n-\n-      HIR::Function *func = static_cast<HIR::Function *> (item);\n-      if (!func->is_method ())\n-\treturn true;\n-\n-      bool name_matches\n-\t= func->get_function_name ().compare (segment_name.as_string ()) == 0;\n-      if (!name_matches)\n-\treturn true;\n-\n-      TyTy::BaseType *ty = nullptr;\n-      if (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n-\treturn true;\n-      if (ty->get_kind () == TyTy::TypeKind::ERROR)\n-\treturn true;\n-\n-      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n-      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n-\n-      inherent_impl_fns.push_back ({func, impl, fnty});\n-\n-      return true;\n-    });\n-\n-    struct trait_item_candidate\n-    {\n-      const HIR::TraitItemFunc *item;\n-      const HIR::Trait *trait;\n-      TyTy::FnType *ty;\n-      const TraitReference *reference;\n-      const TraitItemReference *item_ref;\n-    };\n-\n-    std::vector<trait_item_candidate> trait_fns;\n-    mappings->iterate_impl_blocks ([&] (HirId id,\n-\t\t\t\t\tHIR::ImplBlock *impl) mutable -> bool {\n-      bool is_trait_impl = impl->has_trait_ref ();\n-      if (!is_trait_impl)\n-\treturn true;\n-\n-      // look for impl implementation else lookup the associated trait item\n-      for (auto &impl_item : impl->get_impl_items ())\n-\t{\n-\t  bool is_fn = impl_item->get_impl_item_type ()\n-\t\t       == HIR::ImplItem::ImplItemType::FUNCTION;\n-\t  if (!is_fn)\n-\t    continue;\n-\n-\t  HIR::Function *func = static_cast<HIR::Function *> (impl_item.get ());\n-\t  if (!func->is_method ())\n-\t    continue;\n-\n-\t  bool name_matches\n-\t    = func->get_function_name ().compare (segment_name.as_string ())\n-\t      == 0;\n-\t  if (!name_matches)\n-\t    continue;\n-\n-\t  TyTy::BaseType *ty = nullptr;\n-\t  if (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n-\t    continue;\n-\t  if (ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t    continue;\n+  static MethodCandidate Try (const TyTy::BaseType *r,\n+\t\t\t      const HIR::PathIdentSegment &segment_name,\n+\t\t\t      std::vector<Adjustment> &adjustments);\n \n-\t  rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n-\t  TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n-\n-\t  inherent_impl_fns.push_back ({func, impl, fnty});\n-\t  return true;\n-\t}\n-\n-      TraitReference *trait_ref\n-\t= TraitResolver::Resolve (*impl->get_trait_ref ().get ());\n-      rust_assert (!trait_ref->is_error ());\n-\n-      auto item_ref\n-\t= trait_ref->lookup_trait_item (segment_name.as_string (),\n-\t\t\t\t\tTraitItemReference::TraitItemType::FN);\n-      if (item_ref->is_error ())\n-\treturn true;\n-\n-      const HIR::Trait *trait = trait_ref->get_hir_trait_ref ();\n-      HIR::TraitItem *item = item_ref->get_hir_trait_item ();\n-      rust_assert (item->get_item_kind ()\n-\t\t   == HIR::TraitItem::TraitItemKind::FUNC);\n-      HIR::TraitItemFunc *func = static_cast<HIR::TraitItemFunc *> (item);\n-\n-      TyTy::BaseType *ty = item_ref->get_tyty ();\n-      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n-      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n-\n-      trait_item_candidate candidate{func, trait, fnty, trait_ref, item_ref};\n-      trait_fns.push_back (candidate);\n-\n-      return true;\n-    });\n-\n-    // lookup specified bounds for an associated item\n-    struct precdicate_candidate\n-    {\n-      TyTy::TypeBoundPredicateItem lookup;\n-      TyTy::FnType *fntype;\n-    };\n-\n-    std::vector<precdicate_candidate> predicate_items;\n-    for (auto &bound : specified_bounds)\n-      {\n-\tTyTy::TypeBoundPredicateItem lookup\n-\t  = bound.lookup_associated_item (segment_name.as_string ());\n-\tif (lookup.is_error ())\n-\t  continue;\n-\n-\tbool is_fn = lookup.get_raw_item ()->get_trait_item_type ()\n-\t\t     == TraitItemReference::TraitItemType::FN;\n-\tif (!is_fn)\n-\t  continue;\n-\n-\tTyTy::BaseType *ty = lookup.get_raw_item ()->get_tyty ();\n-\trust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n-\tTyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n-\n-\tprecdicate_candidate candidate{lookup, fnty};\n-\tpredicate_items.push_back (candidate);\n-      }\n-\n-    for (auto impl_item : inherent_impl_fns)\n-      {\n-\tTyTy::FnType *fn = impl_item.ty;\n-\trust_assert (fn->is_method ());\n-\n-\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\tif (fn_self->can_eq (&receiver, false))\n-\t  {\n-\t    PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n-\t\t\t\t\t\t    impl_item.impl_block};\n-\t    return PathProbeCandidate (\n-\t      PathProbeCandidate::CandidateType::IMPL_FUNC, fn,\n-\t      impl_item.item->get_locus (), c);\n-\t  }\n-      }\n-\n-    for (auto trait_item : trait_fns)\n-      {\n-\tTyTy::FnType *fn = trait_item.ty;\n-\trust_assert (fn->is_method ());\n-\n-\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\tif (fn_self->can_eq (&receiver, false))\n-\t  {\n-\t    PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n-\t\t\t\t\t\t     trait_item.item_ref,\n-\t\t\t\t\t\t     nullptr};\n-\t    return PathProbeCandidate (\n-\t      PathProbeCandidate::CandidateType::TRAIT_FUNC, fn,\n-\t      trait_item.item->get_locus (), c);\n-\t  }\n-      }\n-\n-    for (auto predicate : predicate_items)\n-      {\n-\tTyTy::FnType *fn = predicate.fntype;\n-\trust_assert (fn->is_method ());\n-\n-\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\tif (fn_self->can_eq (&receiver, false))\n-\t  {\n-\t    const TraitReference *trait_ref\n-\t      = predicate.lookup.get_parent ()->get ();\n-\t    const TraitItemReference *trait_item\n-\t      = predicate.lookup.get_raw_item ();\n-\n-\t    TyTy::BaseType *subst = predicate.lookup.get_tyty_for_receiver (\n-\t      receiver.get_root (),\n-\t      predicate.lookup.get_parent ()->get_generic_args ());\n-\n-\t    PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n-\t\t\t\t\t\t     nullptr};\n-\t    return PathProbeCandidate (\n-\t      PathProbeCandidate::CandidateType::TRAIT_FUNC, subst,\n-\t      trait_item->get_locus (), c);\n-\t  }\n-      }\n-\n-    return PathProbeCandidate::get_error ();\n-  }\n+  PathProbeCandidate select ();\n \n   MethodResolver (const TyTy::BaseType &receiver,\n \t\t  const HIR::PathIdentSegment &segment_name,"}, {"sha": "a4b8f0ac53066d8a76381ba8466b326dc0f717ac", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -258,6 +258,7 @@ class TypeCheckExpr : public TypeCheckBase\n     // Get the adjusted self\n     Adjuster adj (receiver_tyty);\n     TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+    adjusted_self->debug ();\n \n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),"}, {"sha": "0e9e8ff42a0d3811bca63fdde095a61add19eab8", "filename": "gcc/testsuite/rust/execute/torture/method3.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod3.rs?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -0,0 +1,78 @@\n+// { dg-additional-options \"-w\" }\n+// { dg-output \"mut_deref\\nfoobar: 123\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang = \"deref_mut\"]\n+pub trait DerefMut: Deref {\n+    fn deref_mut(&mut self) -> &mut Self::Target;\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n+}\n+\n+pub struct Bar(i32);\n+impl Bar {\n+    pub fn foobar(&mut self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+pub struct Foo<T>(T);\n+impl<T> Deref for Foo<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<T> DerefMut for Foo<T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        &mut self.0\n+    }\n+}\n+\n+pub fn main() -> i32 {\n+    let bar = Bar(123);\n+    let mut foo: Foo<Bar> = Foo(bar);\n+    let foobar = foo.foobar();\n+\n+    unsafe {\n+        let a = \"foobar: %i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, foobar);\n+    }\n+\n+    foobar - 123\n+}"}, {"sha": "5c6fdfe02c3b89d02d1b3fbc46c3a4c0ab634f9c", "filename": "gcc/testsuite/rust/execute/torture/method4.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e5ca327ba69655de7eae9628b85ad5a615dd77/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod4.rs?ref=c0e5ca327ba69655de7eae9628b85ad5a615dd77", "patch": "@@ -0,0 +1,78 @@\n+// { dg-additional-options \"-w\" }\n+// { dg-output \"mut_deref\\nfoobar: 123\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang = \"deref_mut\"]\n+pub trait DerefMut: Deref {\n+    fn deref_mut(&mut self) -> &mut Self::Target;\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n+}\n+\n+pub struct Bar(i32);\n+impl Bar {\n+    pub fn foobar(&mut self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+pub struct Foo<T>(T);\n+impl<T> Deref for Foo<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<T> DerefMut for Foo<T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        &mut self.0\n+    }\n+}\n+\n+pub fn main() -> i32 {\n+    let mut bar = Bar(123);\n+    let mut foo: Foo<&mut Bar> = Foo(&mut bar);\n+    let foobar = foo.foobar();\n+\n+    unsafe {\n+        let a = \"foobar: %i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, foobar);\n+    }\n+\n+    foobar - 123\n+}"}]}