{"sha": "49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDliYjRiYmU5MGRmZjhiMWNjNzFlMDg2OTNlZDI0ZTAwYjBmNjQ4ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-07-05T19:39:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-07-05T19:39:01Z"}, "message": "re PR c++/50852 (ICE: internal compiler error: in tsubst, at cp/pt.c:11030)\n\n\tPR c++/50852\n\tPR c++/53039\n\t* tree.c (strip_typedefs_expr): New.\n\t* cp-tree.h: Declare it.\n\t* pt.c (convert_template_argument, unify): Use it.\n\t* parser.c (cp_parser_template_declaration_after_export): Don't call\n\tfixup_template_parms.\n\nFrom-SVN: r189298", "tree": {"sha": "eac4bef2b1fb114469b47e65ace6322e35ef5692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eac4bef2b1fb114469b47e65ace6322e35ef5692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40264d66fbdd7b44119f7b9c07f12fb31c8baedd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40264d66fbdd7b44119f7b9c07f12fb31c8baedd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40264d66fbdd7b44119f7b9c07f12fb31c8baedd"}], "stats": {"total": 281, "additions": 276, "deletions": 5}, "files": [{"sha": "91df62da41b0353d1b9343c9f6243de108057423", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -1,3 +1,13 @@\n+2012-07-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/50852\n+\tPR c++/53039\n+\t* tree.c (strip_typedefs_expr): New.\n+\t* cp-tree.h: Declare it.\n+\t* pt.c (convert_template_argument, unify): Use it.\n+\t* parser.c (cp_parser_template_declaration_after_export): Don't call\n+\tfixup_template_parms.\n+\n 2012-07-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/53848"}, {"sha": "e53f185d428f8d79144fd7bbc50a1a8c1040b804", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -5692,6 +5692,7 @@ extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern tree strip_typedefs\t\t\t(tree);\n+extern tree strip_typedefs_expr\t\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(const_tree);"}, {"sha": "4c2167aa7f616c17da02461ace3d28dd96a78436", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -21207,7 +21207,6 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n     {\n       /* Parse the template parameters.  */\n       parameter_list = cp_parser_template_parameter_list (parser);\n-      fixup_template_parms ();\n     }\n \n   /* Get the deferred access checks from the parameter list.  These"}, {"sha": "550a1cb021c7338cf170db922472a8496e363d7b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -6600,7 +6600,7 @@ convert_template_argument (tree parm,\n \t   argument specification is valid.  */\n \tval = convert_nontype_argument (t, orig_arg, complain);\n       else\n-\tval = orig_arg;\n+\tval = strip_typedefs_expr (orig_arg);\n \n       if (val == NULL_TREE)\n \tval = error_mark_node;\n@@ -16598,6 +16598,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t  && !TEMPLATE_PARM_PARAMETER_PACK (parm))\n \treturn unify_parameter_pack_mismatch (explain_p, parm, arg);\n \n+      arg = strip_typedefs_expr (arg);\n       TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;\n       return unify_success (explain_p);\n "}, {"sha": "15effe41555ba1a1522cb24599bf92a4090ab9d3", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 191, "deletions": 1, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -1094,7 +1094,7 @@ cv_unqualified (tree type)\n     * If T is a type that needs structural equality\n       its TYPE_CANONICAL (T) will be NULL.\n     * TYPE_CANONICAL (T) desn't carry type attributes\n-      and looses template parameter names.   */\n+      and loses template parameter names.   */\n \n tree\n strip_typedefs (tree t)\n@@ -1184,6 +1184,16 @@ strip_typedefs (tree t)\n \t\t\t\t   TYPENAME_TYPE_FULLNAME (t),\n \t\t\t\t   typename_type, tf_none);\n       break;\n+    case DECLTYPE_TYPE:\n+      result = strip_typedefs_expr (DECLTYPE_TYPE_EXPR (t));\n+      if (result == DECLTYPE_TYPE_EXPR (t))\n+\treturn t;\n+      else\n+\tresult = (finish_decltype_type\n+\t\t  (result,\n+\t\t   DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t),\n+\t\t   tf_none));\n+      break;\n     default:\n       break;\n     }\n@@ -1205,6 +1215,186 @@ strip_typedefs (tree t)\n   return cp_build_qualified_type (result, cp_type_quals (t));\n }\n \n+/* Like strip_typedefs above, but works on expressions, so that in\n+\n+   template<class T> struct A\n+   {\n+     typedef T TT;\n+     B<sizeof(TT)> b;\n+   };\n+\n+   sizeof(TT) is replaced by sizeof(T).  */\n+\n+tree\n+strip_typedefs_expr (tree t)\n+{\n+  unsigned i,n;\n+  tree r, type, *ops;\n+  enum tree_code code;\n+\n+  if (t == NULL_TREE || t == error_mark_node)\n+    return t;\n+\n+  if (DECL_P (t) || CONSTANT_CLASS_P (t))\n+    return t;\n+\n+  /* Some expressions have type operands, so let's handle types here rather\n+     than check TYPE_P in multiple places below.  */\n+  if (TYPE_P (t))\n+    return strip_typedefs (t);\n+\n+  code = TREE_CODE (t);\n+  switch (code)\n+    {\n+    case IDENTIFIER_NODE:\n+    case TEMPLATE_PARM_INDEX:\n+    case OVERLOAD:\n+    case BASELINK:\n+    case ARGUMENT_PACK_SELECT:\n+      return t;\n+\n+    case TRAIT_EXPR:\n+      {\n+\ttree type1 = strip_typedefs (TRAIT_EXPR_TYPE1 (t));\n+\ttree type2 = strip_typedefs (TRAIT_EXPR_TYPE2 (t));\n+\tif (type1 == TRAIT_EXPR_TYPE1 (t)\n+\t    && type2 == TRAIT_EXPR_TYPE2 (t))\n+\t  return t;\n+\tr = copy_node (t);\n+\tTRAIT_EXPR_TYPE1 (t) = type1;\n+\tTRAIT_EXPR_TYPE2 (t) = type2;\n+\treturn r;\n+      }\n+\n+    case TREE_LIST:\n+      {\n+\tVEC(tree,gc) *vec = make_tree_vector ();\n+\tbool changed = false;\n+\ttree it;\n+\tfor (it = t; it; it = TREE_CHAIN (it))\n+\t  {\n+\t    tree val = strip_typedefs_expr (TREE_VALUE (t));\n+\t    VEC_safe_push (tree, gc, vec, val);\n+\t    if (val != TREE_VALUE (t))\n+\t      changed = true;\n+\t    gcc_assert (TREE_PURPOSE (it) == NULL_TREE);\n+\t  }\n+\tif (changed)\n+\t  {\n+\t    r = NULL_TREE;\n+\t    FOR_EACH_VEC_ELT_REVERSE (tree, vec, i, it)\n+\t      r = tree_cons (NULL_TREE, it, r);\n+\t  }\n+\telse\n+\t  r = t;\n+\trelease_tree_vector (vec);\n+\treturn r;\n+      }\n+\n+    case TREE_VEC:\n+      {\n+\tbool changed = false;\n+\tVEC(tree,gc)* vec = make_tree_vector ();\n+\tn = TREE_VEC_LENGTH (t);\n+\tVEC_reserve (tree, gc, vec, n);\n+\tfor (i = 0; i < n; ++i)\n+\t  {\n+\t    tree op = strip_typedefs_expr (TREE_VEC_ELT (t, i));\n+\t    VEC_quick_push (tree, vec, op);\n+\t    if (op != TREE_VEC_ELT (t, i))\n+\t      changed = true;\n+\t  }\n+\tif (changed)\n+\t  {\n+\t    r = copy_node (t);\n+\t    for (i = 0; i < n; ++i)\n+\t      TREE_VEC_ELT (r, i) = VEC_index (tree, vec, i);\n+\t  }\n+\telse\n+\t  r = t;\n+\trelease_tree_vector (vec);\n+\treturn r;\n+      }\n+\n+    case CONSTRUCTOR:\n+      {\n+\tbool changed = false;\n+\tVEC(constructor_elt,gc) *vec\n+\t  = VEC_copy (constructor_elt, gc, CONSTRUCTOR_ELTS (t));\n+\tn = CONSTRUCTOR_NELTS (t);\n+\ttype = strip_typedefs (TREE_TYPE (t));\n+\tfor (i = 0; i < n; ++i)\n+\t  {\n+\t    constructor_elt *e = VEC_index (constructor_elt, vec, i);\n+\t    tree op = strip_typedefs_expr (e->value);\n+\t    if (op != e->value)\n+\t      {\n+\t\tchanged = true;\n+\t\te->value = op;\n+\t      }\n+\t    gcc_checking_assert (e->index == strip_typedefs_expr (e->index));\n+\t  }\n+\n+\tif (!changed && type == TREE_TYPE (t))\n+\t  {\n+\t    VEC_free (constructor_elt, gc, vec);\n+\t    return t;\n+\t  }\n+\telse\n+\t  {\n+\t    r = copy_node (t);\n+\t    TREE_TYPE (r) = type;\n+\t    CONSTRUCTOR_ELTS (r) = vec;\n+\t    return r;\n+\t  }\n+      }\n+\n+    case LAMBDA_EXPR:\n+      gcc_unreachable ();\n+\n+    default:\n+      break;\n+    }\n+\n+  gcc_assert (EXPR_P (t));\n+\n+  n = TREE_OPERAND_LENGTH (t);\n+  ops = XALLOCAVEC (tree, n);\n+  type = TREE_TYPE (t);\n+\n+  switch (code)\n+    {\n+    CASE_CONVERT:\n+    case IMPLICIT_CONV_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+    case CAST_EXPR:\n+    case NEW_EXPR:\n+      type = strip_typedefs (type);\n+      /* fallthrough */\n+\n+    default:\n+      for (i = 0; i < n; ++i)\n+\tops[i] = strip_typedefs_expr (TREE_OPERAND (t, i));\n+      break;\n+    }\n+\n+  /* If nothing changed, return t.  */\n+  for (i = 0; i < n; ++i)\n+    if (ops[i] != TREE_OPERAND (t, i))\n+      break;\n+  if (i == n && type == TREE_TYPE (t))\n+    return t;\n+\n+  r = copy_node (t);\n+  TREE_TYPE (r) = type;\n+  for (i = 0; i < n; ++i)\n+    TREE_OPERAND (r, i) = ops[i];\n+  return r;\n+}\n+\n /* Makes a copy of BINFO and TYPE, which is to be inherited into a\n    graph dominated by T.  If BINFO is NULL, TYPE is a dependent base,\n    and we do a shallow copy.  If BINFO is non-NULL, we do a deep copy."}, {"sha": "a3c9f61fdbd926e9e0631c3071b1bf695ed77fb7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -1,3 +1,12 @@\n+2012-07-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/50852\n+\t* g++.dg/template/typedef39.C: New.\n+\n+\tPR c++/53039\n+\t* g++.dg/cpp0x/variadic133.C: New.\n+\t* g++.dg/template/param1.C: Adjust.\n+\n 2012-07-05  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n         PR target/48941"}, {"sha": "0265f0991c186d249cb12c01c596dad7f5710604", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic133.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic133.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic133.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic133.C?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -0,0 +1,46 @@\n+// PR c++/53039\n+// { dg-do compile { target c++11 } }\n+\n+template <class, class>\n+struct is_convertible\n+{\n+  static const bool value = true;\n+};\n+\n+template<bool, class T>\n+struct enable_if\n+{\n+  typedef T type;\n+};\n+\n+template <bool...>\n+struct Xs\n+{\n+  static const bool value = true;\n+};\n+\n+template<typename... BTs>\n+  class BType\n+    {\n+      template <typename... BUs,\n+        typename enable_if<\n+               Xs<is_convertible<BUs, BTs>::value...>::value,\n+               bool>::type = false>\n+        void fooX(BUs&&...);\n+    };\n+\n+template <typename... ATs>\n+  struct AType\n+    {\n+      template <typename... AUs,\n+    typename enable_if<\n+               Xs<is_convertible<AUs, ATs>::value...>::value,\n+               bool>::type = false>\n+        void foo(AUs&&...);\n+    };\n+\n+int main()\n+{\n+  AType<int, int> t;\n+  t.foo(1, 1);\n+}"}, {"sha": "e3784736fc440fab7780915e292967e978c2db20", "filename": "gcc/testsuite/g++.dg/template/param1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparam1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparam1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparam1.C?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -2,11 +2,11 @@\n // Origin: Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n // { dg-do compile }\n \n-template<int> struct A // { dg-error \"declaration\" }\n+template<int> struct A\n {\n   A();\n };\n \n-template<int N, char> A<N>::A() {}  // { dg-error \"invalid use of incomplete type\" }\n+template<int N, char> A<N>::A() {}  // { dg-error \"got 2 template parameters|1 required\" }\n \n A<0> a;"}, {"sha": "71d8bdb1bef7f0ea2839ad6f3383f84ceb676a5d", "filename": "gcc/testsuite/g++.dg/template/typedef39.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49bb4bbe90dff8b1cc71e08693ed24e00b0f648e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef39.C?ref=49bb4bbe90dff8b1cc71e08693ed24e00b0f648e", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/50852\n+\n+template<int d> class A;\n+template<class T> struct B {typedef int K;typedef int L;};\n+template<class U,class V> struct C\n+{\n+    typedef typename U::L X;\n+    typedef A<X::a-1> W;\t// { dg-error \"not a member\" }\n+};\n+template<class U,int d> struct D\n+{\n+    typedef typename U::L X;\n+    typedef A<X::a-1> W;\t// the error should really be on this line\n+};\n+template class D<B<A<1> >,3>;"}]}