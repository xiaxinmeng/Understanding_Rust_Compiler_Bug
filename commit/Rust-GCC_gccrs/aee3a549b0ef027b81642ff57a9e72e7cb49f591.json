{"sha": "aee3a549b0ef027b81642ff57a9e72e7cb49f591", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVlM2E1NDliMGVmMDI3YjgxNjQyZmY1N2E5ZTcyZTdjYjQ5ZjU5MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-11T19:41:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-11T19:41:46Z"}, "message": "(find_a_file): Always reject \"./ld\".\n\n(main): Pass short name of program as first arg to fork_execute; ensure\nargv[0] always gets filename.\n(fork_execute): Print name for diagnostic from PROG; filename comes from\nargv[0].\n\nFrom-SVN: r3463", "tree": {"sha": "24a29bdf4a14dd204842b933b603bbe3a0b749b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a29bdf4a14dd204842b933b603bbe3a0b749b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aee3a549b0ef027b81642ff57a9e72e7cb49f591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee3a549b0ef027b81642ff57a9e72e7cb49f591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee3a549b0ef027b81642ff57a9e72e7cb49f591", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee3a549b0ef027b81642ff57a9e72e7cb49f591/comments", "author": null, "committer": null, "parents": [{"sha": "a27901721d141b30dfe1825a6ae9810c720e90ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27901721d141b30dfe1825a6ae9810c720e90ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a27901721d141b30dfe1825a6ae9810c720e90ab"}], "stats": {"total": 24, "additions": 13, "deletions": 11}, "files": [{"sha": "deb5ab8b398f4eec5c94218e05e54ec57a2f2106", "filename": "gcc/collect2.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee3a549b0ef027b81642ff57a9e72e7cb49f591/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee3a549b0ef027b81642ff57a9e72e7cb49f591/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=aee3a549b0ef027b81642ff57a9e72e7cb49f591", "patch": "@@ -571,6 +571,8 @@ find_a_file (pprefix, name)\n \tstrcat (temp, name);\n \tif (strcmp (temp, our_file_name) != 0\n \t    && ! (last_file_name != 0 && strcmp (temp, last_file_name) == 0)\n+\t    /* This is a kludge, but there seems no way around it.  */\n+\t    && strcmp (temp, \"./ld\") != 0\n \t    && access (temp, X_OK) == 0)\n \t  return temp;\n \n@@ -1020,7 +1022,7 @@ main (argc, argv)\n      and destructors to call.\n      Write the constructor and destructor tables to a .s file and reload. */\n \n-  fork_execute (ld_file_name, ld1_argv);\n+  fork_execute (\"ld\", ld1_argv);\n \n   /* If -r, don't build the constructor or destructor list, just return now.  */\n   if (rflag)\n@@ -1040,10 +1042,10 @@ main (argc, argv)\n       if (strip_flag)\n \t{\n \t  char **strip_argv = (char **) xcalloc (sizeof (char *), 3);\n-\t  strip_argv[0] = \"strip\";\n+\t  strip_argv[0] = strip_file_name;\n \t  strip_argv[1] = outfile;\n \t  strip_argv[2] = (char *) 0;\n-\t  fork_execute (strip_file_name, strip_argv);\n+\t  fork_execute (\"strip\", strip_argv);\n \t}\n       return 0;\n     }\n@@ -1067,8 +1069,8 @@ main (argc, argv)\n   /* Assemble the constructor and destructor tables.\n      Link the tables in with the rest of the program. */\n \n-  fork_execute (c_file_name,  c_argv);\n-  fork_execute (ld_file_name, ld2_argv);\n+  fork_execute (\"gcc\",  c_argv);\n+  fork_execute (\"ld\", ld2_argv);\n \n   /* Let scan_prog_file do any final mods (OSF/rose needs this for\n      constructors/destructors in shared libraries.  */\n@@ -1136,10 +1138,10 @@ fork_execute (prog, argv)\n       char **p_argv;\n       char *str;\n \n-      if (prog)\n-\tfprintf (stderr, \"%s\", prog);\n+      if (argv[0])\n+\tfprintf (stderr, \"%s\", argv[0]);\n       else\n-\tfprintf (stderr, \"[cannot find %s]\", argv[0]);\n+\tfprintf (stderr, \"[cannot find %s]\", prog);\n \n       for (p_argv = &argv[1]; (str = *p_argv) != (char *)0; p_argv++)\n \tfprintf (stderr, \" %s\", str);\n@@ -1153,16 +1155,16 @@ fork_execute (prog, argv)\n   /* If we can't find a program we need, complain error.  Do this here\n      since we might not end up needing something that we couldn't find.  */\n \n-  if (prog == 0)\n-    fatal (\"cannot find `%s'\", argv[0]);\n+  if (argv[0] == 0)\n+    fatal (\"cannot find `%s'\", prog);\n \n   pid = vfork ();\n   if (pid == -1)\n     fatal_perror (\"vfork\");\n \n   if (pid == 0)\t\t\t/* child context */\n     {\n-      execvp (prog, argv);\n+      execvp (argv[0], argv);\n       fatal_perror (\"executing %s\", prog);\n     }\n "}]}