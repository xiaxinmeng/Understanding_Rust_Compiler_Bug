{"sha": "cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RmNWI4ODUxYzlhMTljMTdmZTg2NWZhN2JiMWRjM2I3ZWUzMDQzMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-05T18:07:00Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-05T18:07:00Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11672", "tree": {"sha": "8a343198dabd156e47435a027112d522a10d8bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a343198dabd156e47435a027112d522a10d8bf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/comments", "author": null, "committer": null, "parents": [{"sha": "97c5ec1d11af40a9a835c4d737a8048818f23849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c5ec1d11af40a9a835c4d737a8048818f23849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c5ec1d11af40a9a835c4d737a8048818f23849"}], "stats": {"total": 191, "additions": 66, "deletions": 125}, "files": [{"sha": "80d94b48f05cf33dfaad91e98d21a9cd495c089b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "patch": "@@ -1,3 +1,31 @@\n+Thu Apr  4 13:33:10 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* typeck.c (mark_addressable, convert_for_assignment,\n+\tconvert_for_initialization, pointer_int_sum, pointer_diff,\n+\tunary_complex_lvalue): Add prototypes wrapped by PROTO.\n+\t(convert_sequence): #if 0 fn decl, since definition also is.\n+\n+Thu Apr  4 11:00:53 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* rtti.c (build_dynamic_cast): Make sure we strip qualifiers on\n+\tcast to pointer types for type searching.\n+\n+Wed Apr  3 17:10:57 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* typeck.c (get_delta_difference): Use cp_error, not error, in the\n+\tcase where BINFO == 0.\n+\n+Wed Apr  3 12:01:02 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (build_method_call): Fix wording of error messages so\n+\tconstructors come out right.\n+\n+Tue Apr  2 16:06:59 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* decl.c (push_overloaded_decl): Don't warn about hidden\n+\tconstructors when both the type and the function are declared\n+\tin a system header file.\n+\n Mon Apr  1 09:03:13 1996  Bob Manson  <manson@charmed.cygnus.com>\n \n \t* class.c (finish_struct_1): Propagate the TYPE_PACKED"}, {"sha": "55994c6cbdfcfda4f3e45b8632a5eeafa5aa4b16", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 105, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "patch": "@@ -433,13 +433,6 @@ convert_harshness (type, parmtype, parm)\n \t      == TYPE_MAIN_VARIANT (type_promotes_to (parmtype)))\n \t    {\n \t      h.code = PROMO_CODE;\n-#if 0 /* What purpose does this serve?  -jason */\n-\t      /* A char, short, wchar_t, etc., should promote to an int if\n-\t\t it can handle it, otherwise to an unsigned.  So we'll make\n-\t\t an unsigned.  */\n-\t      if (type != integer_type_node)\n-\t\th.int_penalty = 1;\n-#endif\n \t    }\n \t  else\n \t    h.code = STD_CODE;\n@@ -475,10 +468,6 @@ convert_harshness (type, parmtype, parm)\n     }\n \n   /* Convert arrays which have not previously been converted.  */\n-#if 0\n-  if (codel == ARRAY_TYPE)\n-    codel = POINTER_TYPE;\n-#endif\n   if (coder == ARRAY_TYPE)\n     {\n       coder = POINTER_TYPE;\n@@ -1104,36 +1093,9 @@ ideal_candidate (candidates, n_candidates, len)\n      list for the last argument is the intersection of all the best-liked\n      functions.  */\n \n-#if 0\n-  for (i = 0; i < len; i++)\n-    {\n-      qsort (candidates, n_candidates, sizeof (struct candidate),\n-\t     rank_for_overload);\n-      best_code = cp[-1].h.code;\n-\n-      /* To find out functions that are worse than that represented\n-\t by BEST_CODE, we can't just do a comparison like h.code>best_code.\n-\t The total harshness for the \"best\" fn may be 8|8 for two args, and\n-\t the harshness for the next-best may be 8|2.  If we just compared,\n-\t that would be checking 8>10, which would lead to the next-best\n-\t being disqualified.  What we actually want to do is get rid\n-\t of functions that are definitely worse than that represented\n-\t by best_code, i.e. those which have bits set higher than the\n-\t highest in best_code.  Sooooo, what we do is clear out everything\n-\t represented by best_code, and see if we still come up with something\n-\t higher.  If so (e.g., 8|8 vs 8|16), it'll disqualify it properly.  */\n-      for (j = n_candidates-2; j >= 0; j--)\n-\tif ((candidates[j].h.code & ~best_code) > best_code)\n-\t  candidates[j].h.code = EVIL_CODE;\n-    }\n-\n-  if (cp[-1].h.code & EVIL_CODE)\n-    return NULL;\n-#else\n   qsort (candidates, n_candidates, sizeof (struct candidate),\n \t rank_for_overload);\n   best_code = cp[-1].h.code;\n-#endif\n \n   /* If they're at least as good as each other, do an arg-by-arg check.  */\n   if (! strictly_better (cp[-1].h.code, cp[-2].h.code))\n@@ -1608,9 +1570,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   register tree function, fntype, value_type;\n   register tree basetype, save_basetype;\n   register tree baselink, result, parmtypes, parm;\n-#if 0\n-  register tree method_name;\n-#endif\n   tree last;\n   int pass;\n   tree access = access_public_node;\n@@ -1620,6 +1579,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   enum vtable_needs need_vtbl = not_needed;\n \n   char *name_kind;\n+  tree save_name = name;\n   int ever_seen = 0;\n   tree instance_ptr = NULL_TREE;\n   int all_virtual = flag_all_virtual;\n@@ -1747,7 +1707,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       else if (basetype_path)\n \t{\n \t  basetype = BINFO_TYPE (basetype_path);\n-\t  if (name == DECL_NAME (TYPE_NAME (basetype)))\n+\t  if (name == TYPE_IDENTIFIER (basetype))\n \t    name = ctor_identifier;\n \t}\n       else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n@@ -1961,6 +1921,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t}\n     }\n \n+  if (save_name == ctor_identifier)\n+    save_name = TYPE_IDENTIFIER (basetype);\n+\n   if (TYPE_SIZE (complete_type (basetype)) == 0)\n     {\n       /* This is worth complaining about, I think.  */\n@@ -1970,15 +1933,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   save_basetype = TYPE_MAIN_VARIANT (basetype);\n \n-#if 0\n-  if (all_virtual == 1\n-      && (! strncmp (IDENTIFIER_POINTER (name), OPERATOR_METHOD_FORMAT,\n-\t\t     OPERATOR_METHOD_LENGTH)\n-\t  || instance_ptr == NULL_TREE\n-\t  || (TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype) == 0)))\n-    all_virtual = 0;\n-#endif\n-\n   last = NULL_TREE;\n   for (parmtypes = NULL_TREE, parm = parms; parm; parm = TREE_CHAIN (parm))\n     {\n@@ -2187,12 +2141,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t  && ! DECL_STATIC_FUNCTION_P (function))\n \t\tcontinue;\n \n-#if 0\n-\t      if (pass == 0\n-\t\t  && DECL_ASSEMBLER_NAME (function) == method_name)\n-\t\tgoto found;\n-#endif\n-\n \t      if (pass > 0)\n \t\t{\n \t\t  tree these_parms = parms;\n@@ -2254,10 +2202,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      TREE_CHAIN (last) = void_list_node;\n \t      if (flags & LOOKUP_GLOBAL)\n \t\tcp_error (\"no global or member function `%D(%A)' defined\",\n-\t\t\t  name, parmtypes);\n+\t\t\t  save_name, parmtypes);\n \t      else\n \t\tcp_error (\"no member function `%T::%D(%A)' defined\",\n-\t\t\t  save_basetype, name, TREE_CHAIN (parmtypes));\n+\t\t\t  save_basetype, save_name, TREE_CHAIN (parmtypes));\n \t      return error_mark_node;\n \t    }\n \t  continue;\n@@ -2282,7 +2230,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t    {\n \t\t      TREE_CHAIN (last) = void_list_node;\n \t\t      cp_error (\"call of overloaded %s `%D(%A)' is ambiguous\",\n-\t\t\t\tname_kind, name, TREE_CHAIN (parmtypes));\n+\t\t\t\tname_kind, save_name, TREE_CHAIN (parmtypes));\n \t\t      print_n_candidates (candidates, n_candidates);\n \t\t    }\n \t\t  return error_mark_node;\n@@ -2304,7 +2252,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)\n \t\tcp_error (\"ambiguous type conversion requested for %s `%D'\",\n-\t\t\t  name_kind, name);\n+\t\t\t  name_kind, save_name);\n \t      return error_mark_node;\n \t    }\n \t  else\n@@ -2349,7 +2297,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t  TREE_CHAIN (last) = void_list_node;\n \t\t  cp_error (\"no matching function for call to `%T::%D (%A)%V'\",\n \t\t\t    TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (instance_ptr))),\n-\t\t\t    name, TREE_CHAIN (parmtypes),\n+\t\t\t    save_name, TREE_CHAIN (parmtypes),\n \t\t\t    TREE_TYPE (TREE_TYPE (instance_ptr)));\n \t\t  TREE_CHAIN (last) = NULL_TREE;\n \t\t  print_candidates (found_fns);\n@@ -2362,7 +2310,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  if ((flags & (LOOKUP_SPECULATIVELY|LOOKUP_COMPLAIN))\n \t      == LOOKUP_COMPLAIN)\n \t    {\n-\t      cp_error (\"%T has no method named %D\", save_basetype, name);\n+\t      cp_error (\"%T has no method named %D\", save_basetype, save_name);\n \t      return error_mark_node;\n \t    }\n \t  return NULL_TREE;\n@@ -2428,7 +2376,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   if (IS_SIGNATURE (basetype) && static_call_context)\n     {\n       cp_error (\"cannot call signature member function `%T::%D' without signature pointer/reference\",\n-\t\tbasetype, name);\n+\t\tbasetype, save_name);\n       return error_mark_node;\n \t}\n   else if (IS_SIGNATURE (basetype))\n@@ -2575,47 +2523,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t\t convert_arguments (NULL_TREE, TREE_CHAIN (TYPE_ARG_TYPES (fntype)), TREE_CHAIN (parms), function, LOOKUP_NORMAL));\n     }\n \n-#if 0\n-  /* Constructors do not overload method calls.  */\n-  else if (TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype)\n-\t   && name != TYPE_IDENTIFIER (basetype)\n-\t   && (TREE_CODE (function) != FUNCTION_DECL\n-\t       || strncmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function)),\n-\t\t\t   OPERATOR_METHOD_FORMAT,\n-\t\t\t   OPERATOR_METHOD_LENGTH))\n-  \t   && (may_be_remote (basetype) || instance != C_C_D))\n-    {\n-      tree fn_as_int;\n-\n-      parms = TREE_CHAIN (parms);\n-\n-      if (!all_virtual && TREE_CODE (function) == FUNCTION_DECL)\n-\tfn_as_int = build_unary_op (ADDR_EXPR, function, 0);\n-      else\n-\tfn_as_int = convert (TREE_TYPE (default_conversion (function)), DECL_VINDEX (function));\n-      if (all_virtual == 1)\n-\tfn_as_int = convert (integer_type_node, fn_as_int);\n-\n-      result = build_opfncall (METHOD_CALL_EXPR, LOOKUP_NORMAL, instance, fn_as_int, parms);\n-\n-      if (result == NULL_TREE)\n-\t{\n-\t  compiler_error (\"could not overload `operator->()(...)'\");\n-\t  return error_mark_node;\n-\t}\n-      else if (result == error_mark_node)\n-\treturn error_mark_node;\n-\n-#if 0\n-      /* Do this if we want the result of operator->() to inherit\n-\t the type of the function it is subbing for.  */\n-      TREE_TYPE (result) = value_type;\n-#endif\n-\n-      return result;\n-    }\n-#endif\n-\n   if (parms == error_mark_node\n       || (parms && TREE_CHAIN (parms) == error_mark_node))\n     return error_mark_node;"}, {"sha": "c5274b49eb4e7ca42b20f81c19b768763332ef67", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "patch": "@@ -3605,7 +3605,9 @@ push_overloaded_decl (decl, forgettable)\n       if (TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n \t{\n \t  tree t = TREE_TYPE (old);\n-\t  if (IS_AGGR_TYPE (t) && warn_shadow)\n+\t  if (IS_AGGR_TYPE (t) && warn_shadow\n+\t      && (! DECL_IN_SYSTEM_HEADER (decl)\n+\t\t  || ! DECL_IN_SYSTEM_HEADER (old)))\n \t    cp_warning (\"`%#D' hides constructor for `%#T'\", decl, t);\n \t  old = NULL_TREE;\n \t}"}, {"sha": "bd6a0acaf019c455a8330f9b60cdff33c6fa2667", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "patch": "@@ -196,7 +196,7 @@ build_dynamic_cast (type, expr)\n \tgoto fail;\n       if (TREE_CODE (TREE_TYPE (exprtype)) != RECORD_TYPE)\n \tgoto fail;\n-      if (TYPE_SIZE (TREE_TYPE (exprtype)) == 0)\n+      if (TYPE_SIZE (TREE_TYPE (exprtype)) == NULL_TREE)\n \tgoto fail;\n       if (TREE_READONLY (TREE_TYPE (exprtype)) &&\n \t  ! TYPE_READONLY (TREE_TYPE (type)))\n@@ -205,9 +205,11 @@ build_dynamic_cast (type, expr)\n \tbreak;\n       /* else fall through */\n     case REFERENCE_TYPE:\n-      if (TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n-\t  && TYPE_SIZE (TREE_TYPE (type)) != NULL_TREE)\n-\tbreak;\n+      if (TREE_CODE (TREE_TYPE (type)) != RECORD_TYPE)\n+\tgoto fail;\n+      if (TYPE_SIZE (TREE_TYPE (type)) == NULL_TREE)\n+\tgoto fail;\n+      break;\n       /* else fall through */\n     default:\n       goto fail;\n@@ -230,7 +232,7 @@ build_dynamic_cast (type, expr)\n \tgoto fail;\n       if (TREE_CODE (TREE_TYPE (exprtype)) != RECORD_TYPE)\n \tgoto fail;\n-      if (TYPE_SIZE (TREE_TYPE (exprtype)) == 0)\n+      if (TYPE_SIZE (TREE_TYPE (exprtype)) == NULL_TREE)\n \tgoto fail;\n       if (TREE_READONLY (TREE_TYPE (exprtype)) &&\n \t  ! TYPE_READONLY (TREE_TYPE (type)))\n@@ -308,10 +310,7 @@ build_dynamic_cast (type, expr)\n \t  else\n \t    td1 = build_typeid (expr);\n \t  \n-\t  if (tc == POINTER_TYPE)\n-\t    td2 = get_typeid (TREE_TYPE (type));\n-\t  else\n-\t    td2 = get_typeid (TYPE_MAIN_VARIANT (TREE_TYPE (type)));\n+\t  td2 = get_typeid (TYPE_MAIN_VARIANT (TREE_TYPE (type)));\n \n           elems = tree_cons (NULL_TREE, td2,\n             tree_cons (NULL_TREE, build_int_2 (1, 0),"}, {"sha": "762a0aa7fd8c9e269e040f40eb4c9e14ca9fff41", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cdf5b8851c9a19c17fe865fa7bb1dc3b7ee30432", "patch": "@@ -40,15 +40,17 @@ extern void warning ();\n #include \"flags.h\"\n #include \"output.h\"\n \n-int mark_addressable ();\n-static tree convert_for_assignment ();\n-/* static */ tree convert_for_initialization ();\n+int mark_addressable PROTO((tree));\n+static tree convert_for_assignment PROTO((tree, tree, char*, tree, int));\n+/* static */ tree convert_for_initialization PROTO((tree, tree, tree, int, char*, tree, int));\n extern tree shorten_compare ();\n extern void binary_op_error ();\n-static tree pointer_int_sum ();\n-static tree pointer_diff ();\n+static tree pointer_int_sum PROTO((enum tree_code, register tree, register tree));\n+static tree pointer_diff PROTO((register tree, register tree));\n+#if 0\n static tree convert_sequence ();\n-/* static */ tree unary_complex_lvalue ();\n+#endif\n+/* static */ tree unary_complex_lvalue PROTO((enum tree_code, tree));\n static tree get_delta_difference PROTO((tree, tree, int));\n \n extern rtx original_result_rtx;\n@@ -5065,13 +5067,15 @@ build_compound_expr (list)\n \t\tbreak_out_cleanups (TREE_VALUE (list)), rest);\n }\n \n-tree build_static_cast (type, expr)\n+tree\n+build_static_cast (type, expr)\n    tree type, expr;\n {\n   return build_c_cast (type, expr, 0);\n }\n \n-tree build_reinterpret_cast (type, expr)\n+tree\n+build_reinterpret_cast (type, expr)\n    tree type, expr;\n {\n   tree intype = TREE_TYPE (expr);\n@@ -5117,7 +5121,8 @@ tree build_reinterpret_cast (type, expr)\n   return build_c_cast (type, expr, 0);\n }\n \n-tree build_const_cast (type, expr)\n+tree\n+build_const_cast (type, expr)\n    tree type, expr;\n {\n   tree intype = TREE_TYPE (expr);\n@@ -5948,7 +5953,7 @@ get_delta_difference (from, to, force)\n \t}\n       if (binfo == 0)\n \t{\n-\t  error (\"cannot convert pointer to member of type %T to unrelated pointer to member of type %T\", from, to);\n+\t  cp_error (\"cannot convert pointer to member of type %T to unrelated pointer to member of type %T\", from, to);\n \t  return delta;\n \t}\n       if (TREE_VIA_VIRTUAL (binfo))"}]}