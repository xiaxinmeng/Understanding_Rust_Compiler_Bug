{"sha": "b2e9a2fdc876ea464044c9e2338313cff1a4a679", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJlOWEyZmRjODc2ZWE0NjQwNDRjOWUyMzM4MzEzY2ZmMWE0YTY3OQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-02-08T14:50:03Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-02-08T14:50:03Z"}, "message": "c4x.md (all call patterns): Add constraints \"Ur\".\n\n\t* config/c4x/c4x.md (all call patterns): Add constraints \"Ur\".\n\t(call, call_value): Force address into a register if not valid\n\tfor a call instruction.\n\t(load_immed_address): Emit a USE of the SYMBOL_REF that is\n\tforced into memory.\n\t* config/c4x/c4x.c (c4x_print_operand): Fix 'C' and 'U' modifiers.\n\nFrom-SVN: r25090", "tree": {"sha": "1271eaa03ac0eb1486c3dea126ddd354cf9aaa6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1271eaa03ac0eb1486c3dea126ddd354cf9aaa6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2e9a2fdc876ea464044c9e2338313cff1a4a679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e9a2fdc876ea464044c9e2338313cff1a4a679", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e9a2fdc876ea464044c9e2338313cff1a4a679", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e9a2fdc876ea464044c9e2338313cff1a4a679/comments", "author": null, "committer": null, "parents": [{"sha": "55310df79f85c115160cbf9dc505f8ca5df10fd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55310df79f85c115160cbf9dc505f8ca5df10fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55310df79f85c115160cbf9dc505f8ca5df10fd4"}], "stats": {"total": 60, "additions": 38, "deletions": 22}, "files": [{"sha": "8d18280eb9c9a9777171678c0be6bc2656ad140c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e9a2fdc876ea464044c9e2338313cff1a4a679/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e9a2fdc876ea464044c9e2338313cff1a4a679/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2e9a2fdc876ea464044c9e2338313cff1a4a679", "patch": "@@ -1,3 +1,12 @@\n+Tue Feb  9 11:34:15 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.md (all call patterns): Add constraints \"Ur\".\n+\t(call, call_value): Force address into a register if not valid\n+\tfor a call instruction.\n+\t(load_immed_address): Emit a USE of the SYMBOL_REF that is\n+\tforced into memory.\n+\t* config/c4x/c4x.c (c4x_print_operand): Fix 'C' and 'U' modifiers.\n+\n Tue Feb  9 11:08:41 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (call_address_operand, symbolic_address_operand):"}, {"sha": "d12d985d61ed7b08e2e5eb53d279a7c3773725b6", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e9a2fdc876ea464044c9e2338313cff1a4a679/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e9a2fdc876ea464044c9e2338313cff1a4a679/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=b2e9a2fdc876ea464044c9e2338313cff1a4a679", "patch": "@@ -1701,16 +1701,10 @@ c4x_print_operand (file, op, letter)\n       return;\n \n     case 'C':\t\t\t/* call */\n-      if (code != MEM)\n-\tfatal_insn (\"c4x_print_operand: %%C inconsistency\", op);\n-      op = XEXP (op, 0);\n-      code = GET_CODE (op);\n       break;\n \n     case 'U':\t\t\t/* call/callu */\n-      if (code != MEM)\n-\tfatal_insn (\"c4x_print_operand: %%U inconsistency\", op);\n-      if (GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n+      if (code != SYMBOL_REF)\n \tasm_fprintf (file, \"u\");\n       return;\n \n@@ -2100,7 +2094,7 @@ c4x_process_after_reload (first)\n \n \t  if (1)\n \t    {\n-\t      char *template;\n+\t      const char *template;\n \n \t      template = insn_template[insn_code_number];\n \t      if (template && template[0] == '#' && template[1] == '\\0')"}, {"sha": "3d7b0f78d452a43078a9bbcb692c0a8ad9b42ea6", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e9a2fdc876ea464044c9e2338313cff1a4a679/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e9a2fdc876ea464044c9e2338313cff1a4a679/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=b2e9a2fdc876ea464044c9e2338313cff1a4a679", "patch": "@@ -1158,14 +1158,15 @@\n   \"TARGET_SMALL\n    && (TARGET_C3X || (reload_completed\n                       && ! std_reg_operand (operands[0], QImode)))\"\n-  [(set (match_dup 0) (match_dup 1))]\n+  [(set (match_dup 0) (match_dup 2))\n+   (use (match_dup 1))]\n   \"\n {  \n    rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n-   operands[1] = force_const_mem (Pmode, operands[1]);\n-   operands[1] = change_address (operands[1], QImode,\n+   operands[2] = force_const_mem (Pmode, operands[1]);\n+   operands[2] = change_address (operands[2], QImode,\n \t\t\t         gen_rtx_LO_SUM (Pmode, dp_reg,\n-                                                 XEXP (operands[1], 0)));\n+                                                 XEXP (operands[2], 0)));\n }\")\n \n (define_insn \"load_immed_address\"\n@@ -4355,7 +4356,7 @@\n ; CALL\n ;\n (define_insn \"*call_c3x\"\n- [(call (mem:QI (match_operand:QI 0 \"call_address_operand\" \"\"))\n+ [(call (mem:QI (match_operand:QI 0 \"call_address_operand\" \"Ur\"))\n         (match_operand:QI 1 \"general_operand\" \"\"))\n   (clobber (reg:QI 31))]\n   ;; Operand 1 not really used on the C4x.  The C30 doesn't have reg 31.\n@@ -4366,7 +4367,7 @@\n \n ; LAJ requires R11 (31) for the return address\n (define_insn \"*laj\"\n- [(call (mem:QI (match_operand:QI 0 \"call_address_operand\" \"\"))\n+ [(call (mem:QI (match_operand:QI 0 \"call_address_operand\" \"Ur\"))\n         (match_operand:QI 1 \"general_operand\" \"\"))\n   (clobber (reg:QI 31))]\n   ;; Operand 1 not really used on the C4x.\n@@ -4380,15 +4381,21 @@\n   [(set_attr \"type\" \"laj\")])\n \n (define_expand \"call\"\n- [(parallel [(call (mem:QI (match_operand:QI 0 \"call_address_operand\" \"\"))\n+ [(parallel [(call (match_operand:QI 0 \"\" \"\")\n                    (match_operand:QI 1 \"general_operand\" \"\"))\n              (clobber (reg:QI 31))])]\n  \"\"\n- \"\")\n+ \"\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! call_address_operand (XEXP (operands[0], 0), Pmode))\n+    operands[0] = gen_rtx_MEM (GET_MODE (operands[0]),\n+\t\t\t       force_reg (Pmode, XEXP (operands[0], 0)));\n+}\")\n \n (define_insn \"*callv_c3x\"\n  [(set (match_operand 0 \"\" \"=r\")\n-       (call (mem:QI (match_operand:QI 1 \"call_address_operand\" \"\"))\n+       (call (mem:QI (match_operand:QI 1 \"call_address_operand\" \"Ur\"))\n              (match_operand:QI 2 \"general_operand\" \"\")))\n   (clobber (reg:QI 31))]\n   ;; Operand 0 and 2 not really used for the C4x. \n@@ -4401,7 +4408,7 @@\n ; LAJ requires R11 (31) for the return address\n (define_insn \"*lajv\"\n  [(set (match_operand 0 \"\" \"=r\")\n-       (call (mem:QI (match_operand:QI 1 \"call_address_operand\" \"\"))\n+       (call (mem:QI (match_operand:QI 1 \"call_address_operand\" \"Ur\"))\n              (match_operand:QI 2 \"general_operand\" \"\")))\n   (clobber (reg:QI 31))]\n   ;; Operand 0 and 2 not really used in the C30 instruction.\n@@ -4416,11 +4423,17 @@\n \n (define_expand \"call_value\"\n  [(parallel [(set (match_operand 0 \"\" \"\")\n-                  (call (mem:QI (match_operand:QI 1 \"call_address_operand\" \"\"))\n+                  (call (match_operand:QI 1 \"\" \"\")\n                         (match_operand:QI 2 \"general_operand\" \"\")))\n              (clobber (reg:QI 31))])]\n  \"\"\n- \"\")\n+ \"\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! call_address_operand (XEXP (operands[1], 0), Pmode))\n+    operands[0] = gen_rtx_MEM (GET_MODE (operands[1]),\n+                               force_reg (Pmode, XEXP (operands[1], 0)));\n+}\")\n \n (define_insn \"return\"\n   [(return)]\n@@ -6229,7 +6242,7 @@\n    (return)]\n   \"c4x_null_epilogue_p ()\"\n   \"*\n-   if (GET_CODE (XEXP (operands[0], 0)) == REG)\n+   if (REG_P (operands[0]))\n      return \\\"bu%#\\\\t%C0\\\";\n    else\n      return \\\"br%#\\\\t%C0\\\";\"\n@@ -6243,7 +6256,7 @@\n    (return)]\n   \"c4x_null_epilogue_p ()\"\n   \"*\n-   if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+   if (REG_P (operands[1]))\n      return \\\"bu%#\\\\t%C1\\\";\n    else\n      return \\\"br%#\\\\t%C1\\\";\""}]}