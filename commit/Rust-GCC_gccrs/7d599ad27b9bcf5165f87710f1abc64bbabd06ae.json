{"sha": "7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q1OTlhZDI3YjliY2Y1MTY1Zjg3NzEwZjFhYmM2NGJiYWJkMDZhZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-08-01T11:41:28Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-08-01T11:41:28Z"}, "message": "c: Fix bogus vector initialisation error [PR96377]\n\nOne of the problems in this PR was that if we had:\n\n  vector_type1 array[] = { vector_value1 };\n\nprocess_init_element would only treat vector_value1 as initialising\na vector_type1 if they had the same TYPE_MAIN_VARIANT.  This has\nseveral problems:\n\n(1) It gives confusing error messages if the vector types are\n    incompatible.  (Tested by gcc.dg/pr96377-1.c.)\n\n(2) It means that we reject code that should be valid with\n    -flax-vector-conversions.  (Tested by gcc.dg/pr96377-2.c.)\n\n(3) On arm and aarch64 targets, it means that we reject some\n    initializers that mix Advanced SIMD and standard GNU vectors.\n    These vectors have traditionally had different TYPE_MAIN_VARIANTs\n    because they have different mangling schemes.  (Tested by\n    gcc.dg/pr96377-[3-6].c.)\n\n(4) It means that we reject SVE initializers that should be valid.\n    (Tested by gcc.target/aarch64/sve/gnu_vectors_[34].c.)\n\n(5) After r11-1741-g:31427b974ed7b7dd54e2 we reject:\n\n      arm_neon_type1 array[] = { k ^ arm_neon_value1 };\n\n    because applying the binary operator to arm_neon_value1 strips\n    the \"Advanced SIMD type\" attributes that were added in that patch.\n    Stripping the attributes is problematic for other reasons though,\n    so that still needs to be fixed separately.\n\ng++.target/aarch64/sve/gnu_vectors_[34].C already pass.\n\ngcc/c/\n\tPR c/96377\n\t* c-typeck.c (process_init_element): Split test for whether to\n\trecurse into a record, union or array into...\n\t(initialize_elementwise_p): ...this new function.  Don't recurse\n\tinto a vector type if the initialization value is also a vector.\n\ngcc/testsuite/\n\tPR c/96377\n\t* gcc.dg/pr96377-1.c: New test.\n\t* gcc.dg/pr96377-2.c: Likewise.\n\t* gcc.dg/pr96377-3.c: Likewise.\n\t* gcc.dg/pr96377-4.c: Likewise.\n\t* gcc.dg/pr96377-5.c: Likewise.\n\t* gcc.dg/pr96377-6.c: Likewise.\n\t* gcc.target/aarch64/pr96377-1.c: Likewise.\n\t* gcc.target/aarch64/sve/acle/general-c/gnu_vectors_3.c: Likewise.\n\t* gcc.target/aarch64/sve/acle/general-c/gnu_vectors_4.c: Likewise.\n\t* g++.target/aarch64/sve/acle/general-c++/gnu_vectors_3.C: Likewise.\n\t* g++.target/aarch64/sve/acle/general-c++/gnu_vectors_4.C: Likewise.", "tree": {"sha": "78482380b2a17a1775290b757897bdf39bbbbaef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78482380b2a17a1775290b757897bdf39bbbbaef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "197f1e8c14306fc97ff91f9fb4262e70f45eedef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197f1e8c14306fc97ff91f9fb4262e70f45eedef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/197f1e8c14306fc97ff91f9fb4262e70f45eedef"}], "stats": {"total": 332, "additions": 317, "deletions": 15}, "files": [{"sha": "0d639b60ea32eb1628f64e099189d889da301087", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -9956,6 +9956,47 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n   goto retry;\n }\n \f\n+/* Expression VALUE coincides with the start of type TYPE in a braced\n+   initializer.  Return true if we should treat VALUE as initializing\n+   the first element of TYPE, false if we should treat it as initializing\n+   TYPE as a whole.\n+\n+   If the initializer is clearly invalid, the question becomes:\n+   which choice gives the best error message?  */\n+\n+static bool\n+initialize_elementwise_p (tree type, tree value)\n+{\n+  if (type == error_mark_node || value == error_mark_node)\n+    return false;\n+\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (type) == type);\n+\n+  tree value_type = TREE_TYPE (value);\n+  if (value_type == error_mark_node)\n+    return false;\n+\n+  /* GNU vectors can be initialized elementwise.  However, treat any\n+     kind of vector value as initializing the vector type as a whole,\n+     regardless of whether the value is a GNU vector.  Such initializers\n+     are valid if and only if they would have been valid in a non-braced\n+     initializer like:\n+\n+\tTYPE foo = VALUE;\n+\n+     so recursing into the vector type would be at best confusing or at\n+     worst wrong.  For example, when -flax-vector-conversions is in effect,\n+     it's possible to initialize a V8HI from a V4SI, even though the vectors\n+     have different element types and different numbers of elements.  */\n+  if (gnu_vector_type_p (type))\n+    return !VECTOR_TYPE_P (value_type);\n+\n+  if (AGGREGATE_TYPE_P (type))\n+    return type != TYPE_MAIN_VARIANT (value_type);\n+\n+  return false;\n+}\n+\n /* Add one non-braced element to the current constructor level.\n    This adjusts the current position within the constructor's type.\n    This may also start or terminate implicit levels\n@@ -10135,11 +10176,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n \t  else if (value.value != NULL_TREE\n-\t\t   && value.value != error_mark_node\n-\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n-\t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n-\t\t       || fieldcode == UNION_TYPE\n-\t\t       || gnu_vector_type_p (fieldtype)))\n+\t\t   && initialize_elementwise_p (fieldtype, value.value))\n \t    {\n \t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n@@ -10227,11 +10264,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n \t  else if (value.value != NULL_TREE\n-\t\t   && value.value != error_mark_node\n-\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n-\t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n-\t\t       || fieldcode == UNION_TYPE\n-\t\t       || gnu_vector_type_p (fieldtype)))\n+\t\t   && initialize_elementwise_p (fieldtype, value.value))\n \t    {\n \t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;\n@@ -10270,11 +10303,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n \t  else if (value.value != NULL_TREE\n-\t\t   && value.value != error_mark_node\n-\t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != elttype\n-\t\t   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n-\t\t       || eltcode == UNION_TYPE\n-\t\t       || gnu_vector_type_p (elttype)))\n+\t\t   && initialize_elementwise_p (elttype, value.value))\n \t    {\n \t      push_init_level (loc, 1, braced_init_obstack);\n \t      continue;"}, {"sha": "e607d58d7269d01333cc1f2376cb7474bf4bb89c", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/gnu_vectors_3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_3.C?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-msve-vector-bits=256\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1)\n+{\n+  gnu_uint8_t arr1[] = { gnu_u1, sve_u1 };\n+  gnu_uint8_t arr2[] = { gnu_s1 }; // { dg-error \"cannot convert\" }\n+  gnu_uint8_t arr3[] = { sve_s1 }; // { dg-error \"cannot convert\" }\n+}"}, {"sha": "ac4e0d12ff8d713ce3ed2c1f0f70be00d8e3266f", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/gnu_vectors_4.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fgnu_vectors_4.C?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-msve-vector-bits=256 -flax-vector-conversions\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1)\n+{\n+  gnu_uint8_t arr1[] = { gnu_u1, sve_u1 };\n+  gnu_uint8_t arr2[] = { gnu_s1 };\n+  gnu_uint8_t arr3[] = { sve_s1 };\n+}"}, {"sha": "2bf3f816331636c6c1c1430199cce0ce3aa34454", "filename": "gcc/testsuite/gcc.dg/pr96377-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-1.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-options \"-fno-lax-vector-conversions\" } */\n+/* { dg-message \"use '-flax-vector-conversions' to permit conversions\" \"\" { target *-*-* } 0 } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef short v8hi __attribute__((vector_size(16)));\n+\n+struct s { v8hi x; v4si y; };\n+union u1 { v8hi x; v4si y; };\n+union u2 { v4si s; v8hi y; };\n+\n+void\n+foo (v4si i, v8hi h)\n+{\n+  struct s x1 = { i, i }; // { dg-error \"incompatible types when initializing type '__vector\" }\n+  struct s x2 = { h, h }; // { dg-error \"incompatible types\" }\n+  struct s x3 = { i, h }; // { dg-error \"incompatible types\" }\n+  struct s x4 = { h, i };\n+\n+  union u1 y1 = { i }; // { dg-error \"incompatible types\" }\n+  union u1 y2 = { h };\n+  union u2 y3 = { i };\n+  union u2 y4 = { h }; // { dg-error \"incompatible types\" }\n+\n+  v4si z1[] = { i, i };\n+  v4si z2[] = { i, h }; // { dg-error \"incompatible types\" }\n+  v4si z3[] = { h, i }; // { dg-error \"incompatible types\" }\n+  v4si z4[] = { h, h }; // { dg-error \"incompatible types\" }\n+  v8hi z5[] = { i, i }; // { dg-error \"incompatible types\" }\n+  v8hi z6[] = { i, h }; // { dg-error \"incompatible types\" }\n+  v8hi z7[] = { h, i }; // { dg-error \"incompatible types\" }\n+  v8hi z8[] = { h, h };\n+}"}, {"sha": "f58b06d9076da3a2732143a4c6e57cf3ec666ad3", "filename": "gcc/testsuite/gcc.dg/pr96377-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-2.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-options \"-flax-vector-conversions\" } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef short v8hi __attribute__((vector_size(16)));\n+\n+struct s { v8hi x; v4si y; };\n+union u1 { v8hi x; v4si y; };\n+union u2 { v4si s; v8hi y; };\n+\n+void\n+foo (v4si i, v8hi h)\n+{\n+  struct s x1 = { i, i };\n+  struct s x2 = { h, h };\n+  struct s x3 = { i, h };\n+  struct s x4 = { h, i };\n+\n+  union u1 y1 = { i };\n+  union u1 y2 = { h };\n+  union u2 y3 = { i };\n+  union u2 y4 = { h };\n+\n+  v4si z1[] = { i, i };\n+  v4si z2[] = { i, h };\n+  v4si z3[] = { h, i };\n+  v4si z4[] = { h, h };\n+  v8hi z5[] = { i, i };\n+  v8hi z6[] = { i, h };\n+  v8hi z7[] = { h, i };\n+  v8hi z8[] = { h, h };\n+}"}, {"sha": "66dce01f277eb846ac6a35061496cc7057c0f840", "filename": "gcc/testsuite/gcc.dg/pr96377-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-3.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile { target aarch64*-*-* } } */\n+/* { dg-options \"-fno-lax-vector-conversions\" } */\n+/* { dg-message \"use '-flax-vector-conversions' to permit conversions\" \"\" { target *-*-* } 0 } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef short v8hi __attribute__((vector_size(16)));\n+\n+struct s { v8hi x; v4si y; };\n+union u1 { v8hi x; v4si y; };\n+union u2 { v4si s; v8hi y; };\n+\n+void\n+foo (__Int32x4_t i, __Int16x8_t h)\n+{\n+  struct s x1 = { i, i }; // { dg-error \"incompatible types when initializing type '__vector\" }\n+  struct s x2 = { h, h }; // { dg-error \"incompatible types\" }\n+  struct s x3 = { i, h }; // { dg-error \"incompatible types\" }\n+  struct s x4 = { h, i };\n+\n+  union u1 y1 = { i }; // { dg-error \"incompatible types\" }\n+  union u1 y2 = { h };\n+  union u2 y3 = { i };\n+  union u2 y4 = { h }; // { dg-error \"incompatible types\" }\n+\n+  v4si z1[] = { i, i };\n+  v4si z2[] = { i, h }; // { dg-error \"incompatible types\" }\n+  v4si z3[] = { h, i }; // { dg-error \"incompatible types\" }\n+  v4si z4[] = { h, h }; // { dg-error \"incompatible types\" }\n+  v8hi z5[] = { i, i }; // { dg-error \"incompatible types\" }\n+  v8hi z6[] = { i, h }; // { dg-error \"incompatible types\" }\n+  v8hi z7[] = { h, i }; // { dg-error \"incompatible types\" }\n+  v8hi z8[] = { h, h };\n+}"}, {"sha": "f7aaf4900310dad0258b3a380cd42c809afabafc", "filename": "gcc/testsuite/gcc.dg/pr96377-4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-4.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target aarch64*-*-* } } */\n+/* { dg-options \"-flax-vector-conversions\" } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef short v8hi __attribute__((vector_size(16)));\n+\n+struct s { v8hi x; v4si y; };\n+union u1 { v8hi x; v4si y; };\n+union u2 { v4si s; v8hi y; };\n+\n+void\n+foo (__Int32x4_t i, __Int16x8_t h)\n+{\n+  struct s x1 = { i, i };\n+  struct s x2 = { h, h };\n+  struct s x3 = { i, h };\n+  struct s x4 = { h, i };\n+\n+  union u1 y1 = { i };\n+  union u1 y2 = { h };\n+  union u2 y3 = { i };\n+  union u2 y4 = { h };\n+\n+  v4si z1[] = { i, i };\n+  v4si z2[] = { i, h };\n+  v4si z3[] = { h, i };\n+  v4si z4[] = { h, h };\n+  v8hi z5[] = { i, i };\n+  v8hi z6[] = { i, h };\n+  v8hi z7[] = { h, i };\n+  v8hi z8[] = { h, h };\n+}"}, {"sha": "3d0c24befa67c1ca82a3ad5232374c7f84485716", "filename": "gcc/testsuite/gcc.dg/pr96377-5.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-5.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile { target aarch64*-*-* } } */\n+/* { dg-options \"-fno-lax-vector-conversions\" } */\n+/* { dg-message \"use '-flax-vector-conversions' to permit conversions\" \"\" { target *-*-* } 0 } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef short v8hi __attribute__((vector_size(16)));\n+\n+struct s { __Int16x8_t x; __Int32x4_t y; };\n+union u1 { __Int16x8_t x; __Int32x4_t y; };\n+union u2 { __Int32x4_t s; __Int16x8_t y; };\n+\n+void\n+foo (v4si i, v8hi h)\n+{\n+  struct s x1 = { i, i }; // { dg-error \"incompatible types when initializing type '__Int16x8_t\" }\n+  struct s x2 = { h, h }; // { dg-error \"incompatible types\" }\n+  struct s x3 = { i, h }; // { dg-error \"incompatible types\" }\n+  struct s x4 = { h, i };\n+\n+  union u1 y1 = { i }; // { dg-error \"incompatible types\" }\n+  union u1 y2 = { h };\n+  union u2 y3 = { i };\n+  union u2 y4 = { h }; // { dg-error \"incompatible types\" }\n+\n+  v4si z1[] = { i, i };\n+  v4si z2[] = { i, h }; // { dg-error \"incompatible types\" }\n+  v4si z3[] = { h, i }; // { dg-error \"incompatible types\" }\n+  v4si z4[] = { h, h }; // { dg-error \"incompatible types\" }\n+  v8hi z5[] = { i, i }; // { dg-error \"incompatible types\" }\n+  v8hi z6[] = { i, h }; // { dg-error \"incompatible types\" }\n+  v8hi z7[] = { h, i }; // { dg-error \"incompatible types\" }\n+  v8hi z8[] = { h, h };\n+}"}, {"sha": "165327fa292f219bdbc08195c80e87102367b284", "filename": "gcc/testsuite/gcc.dg/pr96377-6.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96377-6.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target aarch64*-*-* } } */\n+/* { dg-options \"-flax-vector-conversions\" } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef short v8hi __attribute__((vector_size(16)));\n+\n+struct s { __Int16x8_t x; __Int32x4_t y; };\n+union u1 { __Int16x8_t x; __Int32x4_t y; };\n+union u2 { __Int32x4_t s; __Int16x8_t y; };\n+\n+void\n+foo (v4si i, v8hi h)\n+{\n+  struct s x1 = { i, i };\n+  struct s x2 = { h, h };\n+  struct s x3 = { i, h };\n+  struct s x4 = { h, i };\n+\n+  union u1 y1 = { i };\n+  union u1 y2 = { h };\n+  union u2 y3 = { i };\n+  union u2 y4 = { h };\n+\n+  v4si z1[] = { i, i };\n+  v4si z2[] = { i, h };\n+  v4si z3[] = { h, i };\n+  v4si z4[] = { h, h };\n+  v8hi z5[] = { i, i };\n+  v8hi z6[] = { i, h };\n+  v8hi z7[] = { h, i };\n+  v8hi z8[] = { h, h };\n+}"}, {"sha": "51e3e36edfcef0c7e0437b65a5f70395c8f10315", "filename": "gcc/testsuite/gcc.target/aarch64/pr96377-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr96377-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr96377-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr96377-1.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"\" } */\n+\n+#include <arm_neon.h>\n+\n+struct aegis128_state {\n+ uint8x16_t v[5];\n+};\n+\n+void foo(const void *key, const void *iv, const void *const0, const void *const1)\n+{\n+ uint8x16_t k = vld1q_u8(key);\n+ uint8x16_t kiv = k ^ vld1q_u8(iv);\n+ struct aegis128_state st = {{\n+  kiv,\n+  vld1q_u8(const1),\n+  vld1q_u8(const0),\n+  k ^ vld1q_u8(const0),\n+  k ^ vld1q_u8(const1),\n+ }};\n+}"}, {"sha": "0f1a2b0e46b3df9bbe66961a042a211dd635acca", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/gnu_vectors_3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_3.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-msve-vector-bits=256\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1)\n+{\n+  gnu_uint8_t arr1[] = { gnu_u1, sve_u1 };\n+  gnu_uint8_t arr2[] = { gnu_s1 }; // { dg-error \"incompatible types\" }\n+  gnu_uint8_t arr3[] = { sve_s1 }; // { dg-error \"incompatible types\" }\n+}"}, {"sha": "ac4e0d12ff8d713ce3ed2c1f0f70be00d8e3266f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/gnu_vectors_4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d599ad27b9bcf5165f87710f1abc64bbabd06ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fgnu_vectors_4.c?ref=7d599ad27b9bcf5165f87710f1abc64bbabd06ae", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-msve-vector-bits=256 -flax-vector-conversions\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef uint8_t gnu_uint8_t __attribute__ ((vector_size (32)));\n+typedef int8_t gnu_int8_t __attribute__ ((vector_size (32)));\n+\n+void\n+f (svuint8_t sve_u1, svint8_t sve_s1,\n+   gnu_uint8_t gnu_u1, gnu_int8_t gnu_s1)\n+{\n+  gnu_uint8_t arr1[] = { gnu_u1, sve_u1 };\n+  gnu_uint8_t arr2[] = { gnu_s1 };\n+  gnu_uint8_t arr3[] = { sve_s1 };\n+}"}]}