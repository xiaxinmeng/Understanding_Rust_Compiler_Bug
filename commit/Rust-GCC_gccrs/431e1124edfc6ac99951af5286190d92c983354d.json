{"sha": "431e1124edfc6ac99951af5286190d92c983354d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMxZTExMjRlZGZjNmFjOTk5NTFhZjUyODYxOTBkOTJjOTgzMzU0ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-12-12T15:18:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-12-12T15:18:24Z"}, "message": "re PR tree-optimization/50873 (The fix to PR50730 causes gcc.c-torture/unsorted/dilayout.c to ICE)\n\ngcc/\n\tPR middle-end/50873\n\t* optabs.c (maybe_legitimize_operand_same_code): Use copy_to_mode_reg\n\tinstead of force_reg.  Do nothing if the address is already a\n\tnon-virtual pseudo register.\n\nFrom-SVN: r182244", "tree": {"sha": "f8c089b7b2a05d80f4b553ce58b696eb40d98e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8c089b7b2a05d80f4b553ce58b696eb40d98e5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/431e1124edfc6ac99951af5286190d92c983354d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431e1124edfc6ac99951af5286190d92c983354d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431e1124edfc6ac99951af5286190d92c983354d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431e1124edfc6ac99951af5286190d92c983354d/comments", "author": null, "committer": null, "parents": [{"sha": "c9556982a79dfb432240760740c9c2ccdb88e336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9556982a79dfb432240760740c9c2ccdb88e336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9556982a79dfb432240760740c9c2ccdb88e336"}], "stats": {"total": 46, "additions": 30, "deletions": 16}, "files": [{"sha": "d02c8df3eb2067640acc1367ff68b09ae7a5bc1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431e1124edfc6ac99951af5286190d92c983354d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431e1124edfc6ac99951af5286190d92c983354d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=431e1124edfc6ac99951af5286190d92c983354d", "patch": "@@ -1,3 +1,10 @@\n+2011-12-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR middle-end/50873\n+\t* optabs.c (maybe_legitimize_operand_same_code): Use copy_to_mode_reg\n+\tinstead of force_reg.  Do nothing if the address is already a\n+\tnon-virtual pseudo register.\n+\n 2011-12-12  Torvald Riegel  <triegel@redhat.com>\n \n \t* gimplify.c (voidify_wrapper_expr): Add default handling for"}, {"sha": "0d5cd73c3a2417de85df24dfbd5dab7c6ffc5dd0", "filename": "gcc/optabs.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431e1124edfc6ac99951af5286190d92c983354d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431e1124edfc6ac99951af5286190d92c983354d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=431e1124edfc6ac99951af5286190d92c983354d", "patch": "@@ -8242,24 +8242,31 @@ maybe_legitimize_operand_same_code (enum insn_code icode, unsigned int opno,\n     return true;\n \n   /* If the operand is a memory whose address has no side effects,\n-     try forcing the address into a register.  The check for side\n-     effects is important because force_reg cannot handle things\n-     like auto-modified addresses.  */\n-  if (insn_data[(int) icode].operand[opno].allows_mem\n-      && MEM_P (op->value)\n-      && !side_effects_p (XEXP (op->value, 0)))\n-    {\n-      rtx addr, mem, last;\n-\n-      last = get_last_insn ();\n-      addr = force_reg (Pmode, XEXP (op->value, 0));\n-      mem = replace_equiv_address (op->value, addr);\n-      if (insn_operand_matches (icode, opno, mem))\n+     try forcing the address into a non-virtual pseudo register.\n+     The check for side effects is important because copy_to_mode_reg\n+     cannot handle things like auto-modified addresses.  */\n+  if (insn_data[(int) icode].operand[opno].allows_mem && MEM_P (op->value))\n+    {\n+      rtx addr, mem;\n+\n+      mem = op->value;\n+      addr = XEXP (mem, 0);\n+      if (!(REG_P (addr) && REGNO (addr) > LAST_VIRTUAL_REGISTER)\n+\t  && !side_effects_p (addr))\n \t{\n-\t  op->value = mem;\n-\t  return true;\n+\t  rtx last;\n+\t  enum machine_mode mode;\n+\n+\t  last = get_last_insn ();\n+\t  mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+\t  mem = replace_equiv_address (mem, copy_to_mode_reg (mode, addr));\n+\t  if (insn_operand_matches (icode, opno, mem))\n+\t    {\n+\t      op->value = mem;\n+\t      return true;\n+\t    }\n+\t  delete_insns_since (last);\n \t}\n-      delete_insns_since (last);\n     }\n \n   return false;"}]}