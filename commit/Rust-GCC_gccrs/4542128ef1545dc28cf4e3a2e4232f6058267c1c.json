{"sha": "4542128ef1545dc28cf4e3a2e4232f6058267c1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU0MjEyOGVmMTU0NWRjMjhjZjRlM2EyZTQyMzJmNjA1ODI2N2MxYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-01-02T11:32:34Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-01-02T11:32:34Z"}, "message": "re PR c++/4379 (Member pointer to member reference not allowed when declared directly, but allowed as template parameter.)\n\ncp:\n\tPR c++/4379\n\t* typeck.c (build_x_unary_op): Don't destroy the OFFSET_REF on a\n\tsingle non-static member.\n\t(unary_complex_lvalue): If it cannot be a pointer to member, don't\n\tmake it so. Check it is not pointer to reference.\ntestsuite:\n\t* g++.dg/other/ptrmem1.C: New test.\n\t* g++.dg/other/ptrmem2.C: New test.\n\nFrom-SVN: r48465", "tree": {"sha": "a3bb69f29f4f3a59bc319decb285e61679f8d216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3bb69f29f4f3a59bc319decb285e61679f8d216"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4542128ef1545dc28cf4e3a2e4232f6058267c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4542128ef1545dc28cf4e3a2e4232f6058267c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4542128ef1545dc28cf4e3a2e4232f6058267c1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4542128ef1545dc28cf4e3a2e4232f6058267c1c/comments", "author": null, "committer": null, "parents": [{"sha": "903c623438e8f4ce15639fffed80f9ced73a8bf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/903c623438e8f4ce15639fffed80f9ced73a8bf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/903c623438e8f4ce15639fffed80f9ced73a8bf7"}], "stats": {"total": 145, "additions": 141, "deletions": 4}, "files": [{"sha": "14194c7eb55e9bbd078bbfb5e2dda26e53bceda9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4542128ef1545dc28cf4e3a2e4232f6058267c1c", "patch": "@@ -1,3 +1,11 @@\n+2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/4379\n+\t* typeck.c (build_x_unary_op): Don't destroy the OFFSET_REF on a\n+\tsingle non-static member.\n+\t(unary_complex_lvalue): If it cannot be a pointer to member, don't\n+\tmake it so. Check it is not pointer to reference.\n+\n 2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/5132"}, {"sha": "9fdd168343c74ed82f1ef583e26eef2c69af397b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4542128ef1545dc28cf4e3a2e4232f6058267c1c", "patch": "@@ -1,6 +1,6 @@\n /* Build expressions with type checking for C++ compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -4286,9 +4286,15 @@ build_x_unary_op (code, xarg)\n           \n           if (!ptrmem && !flag_ms_extensions\n               && TREE_CODE (TREE_TYPE (TREE_OPERAND (xarg, 1))) == METHOD_TYPE)\n-            /* A single non-static member, make sure we don't allow a\n-               pointer-to-member.  */\n-            xarg = ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE);\n+\t    {\n+\t      /* A single non-static member, make sure we don't allow a\n+                 pointer-to-member.  */\n+\t      xarg = build (OFFSET_REF, TREE_TYPE (xarg),\n+\t\t\t    TREE_OPERAND (xarg, 0),\n+\t\t\t    ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE));\n+\t      PTRMEM_OK_P (xarg) = ptrmem;\n+\t    }\n+\t      \n         }\n       else if (TREE_CODE (xarg) == TARGET_EXPR)\n \twarning (\"taking address of temporary\");\n@@ -4849,6 +4855,22 @@ unary_complex_lvalue (code, arg)\n \t      error (\"taking address of bound pointer-to-member expression\");\n \t      return error_mark_node;\n \t    }\n+\t  if (!PTRMEM_OK_P (arg))\n+\t    {\n+\t      /* This cannot form a pointer to method, so we must\n+\t         resolve the offset ref, and take the address of the\n+\t\t result.  For instance,\n+\t\t \t&(C::m)\t      */\n+\t      arg = resolve_offset_ref (arg);\n+\n+\t      return build_unary_op (code, arg, 0);\n+\t    }\n+\t  \n+\t  if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+\t    {\n+\t      error (\"cannot create pointer to reference member `%D'\", t);\n+\t      return error_mark_node;\n+\t    }\n \n \t  type = build_offset_type (DECL_FIELD_CONTEXT (t), TREE_TYPE (t));\n \t  type = build_pointer_type (type);"}, {"sha": "e75984c11eaf93f7c358547a00e6a32cbbb2f5e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4542128ef1545dc28cf4e3a2e4232f6058267c1c", "patch": "@@ -1,3 +1,8 @@\n+2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/other/ptrmem1.C: New test.\n+\t* g++.dg/other/ptrmem2.C: New test.\n+\n 2002-01-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/template/ctor1.C: New test."}, {"sha": "fa9115e506c1e8fbad42edff8afab7e5027c8677", "filename": "gcc/testsuite/g++.dg/other/ptrmem1.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem1.C?ref=4542128ef1545dc28cf4e3a2e4232f6058267c1c", "patch": "@@ -0,0 +1,66 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 31 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 4379. We created pointers to member references and pointers to\n+// member fields when we shouldn't have.\n+\n+int gs;\n+int gm;\n+\n+struct D {\n+  D () :m (gm) {}\n+  \n+  int &m;\n+  static int &s;\n+  \n+  int Foo ();\n+};\n+\n+int &D::s = gs;\n+\n+template<class T> int f1(T x)\n+{\n+  return x != &gm;\n+}\n+template<class T> int f2(T x) \n+{\n+  return x != &gs;\n+}\n+\n+int D::Foo ()\n+{\n+  int r;\n+  \n+  if (f1( &(D::m)))\n+    return 3;\n+  \n+  if (f2( &D::s))\n+    return 1;\n+  if (f2( &(D::s)))\n+    return 2;\n+  return 0;\n+}\n+\n+int Foo ()\n+{\n+  if (f2( &D::s))\n+    return 4;\n+  if (f2( &(D::s)))\n+    return 5;\n+  return 0;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  int r = d.Foo ();\n+  if (r)\n+    return r;\n+  r = Foo ();\n+  if (r)\n+    return r;\n+  return 0;\n+  \n+}"}, {"sha": "ec451be39da88791cace4dfa1b58f263e3627f5b", "filename": "gcc/testsuite/g++.dg/other/ptrmem2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542128ef1545dc28cf4e3a2e4232f6058267c1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem2.C?ref=4542128ef1545dc28cf4e3a2e4232f6058267c1c", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 31 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 4379. We created pointers to member references and pointers to\n+// member fields when we shouldn't have.\n+\n+struct D {\n+  \n+  int &m;   // { dg-error \"member `D::m' is non-static\" \"\" }\n+  static int &s;\n+  \n+  int Foo ();\n+};\n+\n+template<class T> int f1(T x);\n+template<class T> int f2(T x);\n+\n+int D::Foo ()\n+{\n+  f1( &D::m);   // { dg-error \"cannot create pointer to ref\" \"\" }\n+  f1( &(D::m));\t// ok\n+  f2( &D::s);   // ok\n+  f2( &(D::s)); // ok\n+  return 0;\n+}\n+\n+int Foo ()\n+{\n+  f1( &D::m);    // { dg-error \"cannot create pointer to ref\" \"\" }\n+  f1( &(D::m));  // { dg-error \"at this point\" \"\" }\n+  f2( &D::s);    // ok\n+  f2( &(D::s));  // ok\n+  return 0;\n+}"}]}