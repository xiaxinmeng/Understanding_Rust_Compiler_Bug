{"sha": "385b6e2d89aafa6135634bf661b1b559dedc8de8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg1YjZlMmQ4OWFhZmE2MTM1NjM0YmY2NjFiMWI1NTlkZWRjOGRlOA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@redhat.com", "date": "2001-09-21T00:45:30Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2001-09-21T00:45:30Z"}, "message": "integrate.c (allocate_initial_values): New function.\n\n\t* integrate.c (allocate_initial_values): New function.\n\t* integrate.h (allocate_initial_values): Declare.\n\t* local-alloc.c (local_alloc): Move call to allocate_reg_info from\n\there...\n\t* reload1.c (reload): And initialization of reg_equiv_memory_loc\n\tfrom here...\n\t* toplev.c (rest_of_compilation): To here.\n\tCall allocate_initial_values.\n\t* tm.texi: add description for ALLOCATE_INITIAL_VALUE.\n\nFrom-SVN: r45716", "tree": {"sha": "17d728b05bed014f8620fd0df4576c3c1a968f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17d728b05bed014f8620fd0df4576c3c1a968f86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/385b6e2d89aafa6135634bf661b1b559dedc8de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385b6e2d89aafa6135634bf661b1b559dedc8de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385b6e2d89aafa6135634bf661b1b559dedc8de8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385b6e2d89aafa6135634bf661b1b559dedc8de8/comments", "author": null, "committer": null, "parents": [{"sha": "a4b5b2ae8d59dbaf8c855590cbd78ad3f5c47b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b5b2ae8d59dbaf8c855590cbd78ad3f5c47b64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4b5b2ae8d59dbaf8c855590cbd78ad3f5c47b64"}], "stats": {"total": 80, "additions": 76, "deletions": 4}, "files": [{"sha": "af47279de4144546b583c61cc584048499bb69b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=385b6e2d89aafa6135634bf661b1b559dedc8de8", "patch": "@@ -1,3 +1,15 @@\n+Fri Sep 21 01:13:56 2001  J\"orn Rennecke <amylaar@redhat.com>\n+\n+\t* integrate.c (allocate_initial_values): New function.\n+\t* integrate.h (allocate_initial_values): Declare.\n+\t* local-alloc.c (local_alloc): Move call to allocate_reg_info from\n+\there...\n+\t* reload1.c (reload): And initialization of reg_equiv_memory_loc\n+\tfrom here...\n+\t* toplev.c (rest_of_compilation): To here.\n+\tCall allocate_initial_values.\n+\t* tm.texi: add description for ALLOCATE_INITIAL_VALUE.\n+\n Thu Sep 20 09:00:27 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* ggc-page.c (ggc_marked_p): Properly convert return to boolean."}, {"sha": "71e4cd953a1815041e1ca3aff9bcf9d830a8f1b0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=385b6e2d89aafa6135634bf661b1b559dedc8de8", "patch": "@@ -8760,4 +8760,24 @@ On some targets, branches may have a limited range.  Optimizing the\n filling of delay slots can result in branches being redirected, and this\n may in turn cause a branch offset to overflow.\n \n+@findex ALLOCATE_INITIAL_VALUE\n+@item ALLOCATE_INITIAL_VALUE(@var{hard_reg})\n+\n+When the initial value of a hard register has been copied in a pseudo\n+register, it is often not necessary to actually allocate a another register\n+to this pseudo register, because the original hard register or a stack slot\n+it has been saved into can be used.  @code{ALLOCATE_INITIAL_VALUE}, if\n+defined, is called at the start of register allocation once for each\n+hard register that had its initial value copied by using\n+@code{get_func_hard_reg_initial_val} or @code{get_hard_reg_initial_val}.\n+Possible values are @code{NULL_RTX}, if you don't want\n+to do any special allocation, a @code{REG} rtx---that would typically be\n+the hard register itself, if it is known not to be clobbered---or a\n+@code{MEM}.\n+If you are returning a @code{MEM}, this is only a hint for the allocator;\n+it might decide to use another register anyways.\n+You may use @code{current_function_leaf_function} in the definition of the\n+macro, functions that use @code{REG_N_SETS}, to determine if the hard\n+register in question will not be clobbered.\n+\n @end table"}, {"sha": "db5993580d367417213a4907585a45433bd81da0", "filename": "gcc/integrate.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=385b6e2d89aafa6135634bf661b1b559dedc8de8", "patch": "@@ -3037,3 +3037,37 @@ emit_initial_value_sets ()\n \n   emit_insns_after (seq, get_insns ());\n }\n+\n+/* If the backend knows where to allocate pseudos for hard\n+   register initial values, register these allocations now.  */\n+void\n+allocate_initial_values (reg_equiv_memory_loc)\n+     rtx *reg_equiv_memory_loc;\n+{\n+#ifdef ALLOCATE_INITIAL_VALUE\n+  struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;\n+  int i;\n+\n+  if (ivs == 0)\n+    return;\n+\n+  for (i = 0; i < ivs->num_entries; i++)\n+    {\n+      int regno = REGNO (ivs->entries[i].pseudo);\n+      rtx x = ALLOCATE_INITIAL_VALUE (ivs->entries[i].hard_reg);\n+\n+      if (x == NULL_RTX || REG_N_SETS (REGNO (ivs->entries[i].pseudo)) > 1)\n+\t; /* Do nothing.  */\n+      else if (GET_CODE (x) == MEM)\n+\treg_equiv_memory_loc[regno] = x;\n+      else if (GET_CODE (x) == REG)\n+\t{\n+\t  reg_renumber[regno] = REGNO (x);\n+\t  /* Poke the regno right into regno_reg_rtx\n+\t     so that even fixed regs are accepted.  */\n+\t  REGNO (ivs->entries[i].pseudo) = REGNO (x);\n+\t}\n+      else abort ();\n+    }\n+#endif\n+}"}, {"sha": "c88e2cd9e0cfc8969d8b15fc0506a647a377e0a4", "filename": "gcc/integrate.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=385b6e2d89aafa6135634bf661b1b559dedc8de8", "patch": "@@ -144,6 +144,7 @@ extern rtx has_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n extern void mark_hard_reg_initial_vals\t\tPARAMS ((struct function *));\n /* Called from rest_of_compilation.  */\n extern void emit_initial_value_sets\t\tPARAMS ((void));\n+extern void allocate_initial_values\t\tPARAMS ((rtx *));\n \n /* Copy a declaration when one function is substituted inline into\n    another.  */"}, {"sha": "1df88db3340461146bbfe2391e305b3265ff2255", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=385b6e2d89aafa6135634bf661b1b559dedc8de8", "patch": "@@ -372,9 +372,6 @@ local_alloc ()\n   reg_offset = (char *) xmalloc (max_regno * sizeof (char));\n   reg_next_in_qty = (int *) xmalloc (max_regno * sizeof (int));\n \n-  /* Allocate the reg_renumber array.  */\n-  allocate_reg_info (max_regno, FALSE, TRUE);\n-\n   /* Determine which pseudo-registers can be allocated by local-alloc.\n      In general, these are the registers used only in a single block and\n      which only die once."}, {"sha": "11010e21738a00830c308f919531c85bf6473b87", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=385b6e2d89aafa6135634bf661b1b559dedc8de8", "patch": "@@ -733,7 +733,6 @@ reload (first, global)\n      be substituted eventually by altering the REG-rtx's.  */\n \n   reg_equiv_constant = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_memory_loc = (rtx *) xcalloc (max_regno, sizeof (rtx));\n   reg_equiv_mem = (rtx *) xcalloc (max_regno, sizeof (rtx));\n   reg_equiv_init = (rtx *) xcalloc (max_regno, sizeof (rtx));\n   reg_equiv_address = (rtx *) xcalloc (max_regno, sizeof (rtx));"}, {"sha": "dc3bf74945cdeac1c59e9d75dfd7989f8d3e527a", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385b6e2d89aafa6135634bf661b1b559dedc8de8/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=385b6e2d89aafa6135634bf661b1b559dedc8de8", "patch": "@@ -3430,6 +3430,15 @@ rest_of_compilation (decl)\n \n   if (! register_life_up_to_date)\n     recompute_reg_usage (insns, ! optimize_size);\n+\n+  /* Allocate the reg_renumber array.  */\n+  allocate_reg_info (max_regno, FALSE, TRUE);\n+\n+  /* And the reg_equiv_memory_loc array.  */\n+  reg_equiv_memory_loc = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+\n+  allocate_initial_values (reg_equiv_memory_loc);\n+\n   regclass (insns, max_reg_num (), rtl_dump_file);\n   rebuild_label_notes_after_reload = local_alloc ();\n "}]}