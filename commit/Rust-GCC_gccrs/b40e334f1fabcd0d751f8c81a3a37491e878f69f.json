{"sha": "b40e334f1fabcd0d751f8c81a3a37491e878f69f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwZTMzNGYxZmFiY2QwZDc1MWY4YzgxYTNhMzc0OTFlODc4ZjY5Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-04-24T16:25:15Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-04-24T16:25:15Z"}, "message": "re PR c++/52363 (Presence/absence of -pedantic compilation affects run-time behavior)\n\n/cp\n2012-04-24  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/52363\n\t* call.c (tourney, perform_overload_resolution,\n\tbuild_operator_new_call, build_user_type_conversion_1,\n\tbuild_user_type_conversion, perform_overload_resolution,\n\tadd_template_candidate, add_template_candidate_real,\n\tadd_template_conv_candidate, add_builtin_candidates,\n\tadd_builtin_candidate, build_builtin_candidate,\n\tadd_conv_candidate, add_function_candidate, implicit_conversion,\n\treference_binding, build_list_conv, conditional_conversion,\n\tadd_candidates, can_convert_array, build_aggr_conv,\n\tbuild_array_conv, build_complex_conv, conditional_conversion):\n\tAdd tsubst_flags_t parameter.\n\t(joust): Likewise, use it to handle SFINAE as if pedantic.\n\t(add_list_candidates, build_integral_nontype_arg_conv,\n\tperform_overload_resolution, build_new_function_call,\n\tbuild_operator_new_call, build_op_call_1,\n\tbuild_conditional_expr_1, build_new_op_1, convert_like_real,\n\tconvert_arg_to_ellipsis, convert_default_arg,\n\tconvert_for_arg_passing, build_over_call,\n\tbuild_new_method_call_1, can_convert_arg, can_convert_arg_bad,\n\tperform_implicit_conversion_flags,\n\tperform_direct_initialization_if_possible,\n\tinitialize_reference): Adjust.\n\t* typeck.c (casts_away_constness, casts_away_constness_r):\n\tAdd tsubst_flags_t parameter.\n\t(convert_arguments, check_for_casting_away_constness,\n\tbuild_static_cast_1, build_ptrmemfunc, convert_for_assignment):\n\tAdjust.\n\t* decl.c (reshape_init_r, check_default_argument): Likewise.\n\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Likewise.\n\t* pt.c (convert_nontype_argument, check_non_deducible_conversion):\n\tLikewise.\n\t* init.c (build_new_1): Likewise.\n\t* cvt.c (convert_to_reference, ocp_convert, build_type_conversion,\n\tbuild_expr_type_conversion, ): Likewise.\n\t* search.c (check_final_overrider): Likewise.\n\t* cp-tree.h (build_user_type_conversion,\n\tbuild_operator_new_call, can_convert, can_convert_arg,\n\tcan_convert_arg_bad, convert_default_arg,\n\tconvert_arg_to_ellipsis, convert_for_arg_passing):\n\tAdjust declaration.\n\n/testsuite\n2012-04-24  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/52363\n\t* g++.dg/cpp0x/sfinae35.C: New.\n\t* g++.dg/cpp0x/sfinae36.C: Likewise.\n\nFrom-SVN: r186774", "tree": {"sha": "e6624c8acded44cfe59898448175ad6c47ed2150", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6624c8acded44cfe59898448175ad6c47ed2150"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b40e334f1fabcd0d751f8c81a3a37491e878f69f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40e334f1fabcd0d751f8c81a3a37491e878f69f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40e334f1fabcd0d751f8c81a3a37491e878f69f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40e334f1fabcd0d751f8c81a3a37491e878f69f/comments", "author": null, "committer": null, "parents": [{"sha": "5ada012290883e98d76a3ac6dcd34e56d50057e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ada012290883e98d76a3ac6dcd34e56d50057e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ada012290883e98d76a3ac6dcd34e56d50057e3"}], "stats": {"total": 565, "additions": 360, "deletions": 205}, "files": [{"sha": "86e44fc0fc62f452a06a61fa70502cb9e88157ee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -1,3 +1,47 @@\n+2012-04-24  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/52363\n+\t* call.c (tourney, perform_overload_resolution,\n+\tbuild_operator_new_call, build_user_type_conversion_1,\n+\tbuild_user_type_conversion, perform_overload_resolution,\n+\tadd_template_candidate, add_template_candidate_real,\n+\tadd_template_conv_candidate, add_builtin_candidates,\n+\tadd_builtin_candidate, build_builtin_candidate,\n+\tadd_conv_candidate, add_function_candidate, implicit_conversion,\n+\treference_binding, build_list_conv, conditional_conversion,\n+\tadd_candidates, can_convert_array, build_aggr_conv,\n+\tbuild_array_conv, build_complex_conv, conditional_conversion):\n+\tAdd tsubst_flags_t parameter.\n+\t(joust): Likewise, use it to handle SFINAE as if pedantic.\n+\t(add_list_candidates, build_integral_nontype_arg_conv,\n+\tperform_overload_resolution, build_new_function_call,\n+\tbuild_operator_new_call, build_op_call_1,\n+\tbuild_conditional_expr_1, build_new_op_1, convert_like_real,\n+\tconvert_arg_to_ellipsis, convert_default_arg,\n+\tconvert_for_arg_passing, build_over_call,\n+\tbuild_new_method_call_1, can_convert_arg, can_convert_arg_bad,\n+\tperform_implicit_conversion_flags,\n+\tperform_direct_initialization_if_possible,\n+\tinitialize_reference): Adjust.\n+\t* typeck.c (casts_away_constness, casts_away_constness_r):\n+\tAdd tsubst_flags_t parameter.\n+\t(convert_arguments, check_for_casting_away_constness,\n+\tbuild_static_cast_1, build_ptrmemfunc, convert_for_assignment):\n+\tAdjust.\n+\t* decl.c (reshape_init_r, check_default_argument): Likewise.\n+\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Likewise.\n+\t* pt.c (convert_nontype_argument, check_non_deducible_conversion):\n+\tLikewise.\n+\t* init.c (build_new_1): Likewise.\n+\t* cvt.c (convert_to_reference, ocp_convert, build_type_conversion,\n+\tbuild_expr_type_conversion, ): Likewise.\n+\t* search.c (check_final_overrider): Likewise.\n+\t* cp-tree.h (build_user_type_conversion,\n+\tbuild_operator_new_call, can_convert, can_convert_arg,\n+\tcan_convert_arg_bad, convert_default_arg,\n+\tconvert_arg_to_ellipsis, convert_for_arg_passing):\n+\tAdjust declaration.\n+\n 2012-04-22  Jan Hubicka  <jh@suse.cz>\n \n \t* decl2.c (maybe_make_one_only): Mark keyed COMDATs as USED so they"}, {"sha": "f9a7f08b8d389a8514d2b9b49fb01dccaacc2e0d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 219, "deletions": 160, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -142,9 +142,10 @@ static struct obstack conversion_obstack;\n static bool conversion_obstack_initialized;\n struct rejection_reason;\n \n-static struct z_candidate * tourney (struct z_candidate *);\n+static struct z_candidate * tourney (struct z_candidate *, tsubst_flags_t);\n static int equal_functions (tree, tree);\n-static int joust (struct z_candidate *, struct z_candidate *, bool);\n+static int joust (struct z_candidate *, struct z_candidate *, bool,\n+\t\t  tsubst_flags_t);\n static int compare_ics (conversion *, conversion *);\n static tree build_over_call (struct z_candidate *, int, tsubst_flags_t);\n static tree build_java_interface_fn_ref (tree, tree);\n@@ -160,42 +161,45 @@ static tree convert_like_real (conversion *, tree, tree, int, int, bool,\n \t\t\t       bool, tsubst_flags_t);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n \t\t      tree, bool);\n-static struct z_candidate *build_user_type_conversion_1 (tree, tree, int);\n+static struct z_candidate *build_user_type_conversion_1 (tree, tree, int,\n+\t\t\t\t\t\t\t tsubst_flags_t);\n static void print_z_candidate (const char *, struct z_candidate *);\n static void print_z_candidates (location_t, struct z_candidate *);\n static tree build_this (tree);\n static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, const VEC(tree,gc) *,\n-\t tree, tree, tree, int, unification_kind_t);\n+\t tree, tree, tree, int, unification_kind_t, tsubst_flags_t);\n static struct z_candidate *add_template_candidate_real\n \t(struct z_candidate **, tree, tree, tree, tree, const VEC(tree,gc) *,\n-\t tree, tree, tree, int, tree, unification_kind_t);\n+\t tree, tree, tree, int, tree, unification_kind_t, tsubst_flags_t);\n static struct z_candidate *add_template_conv_candidate\n \t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n-\t tree, tree);\n+\t tree, tree, tsubst_flags_t);\n static void add_builtin_candidates\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n-\t tree, tree *, int);\n+\t tree, tree *, int, tsubst_flags_t);\n static void add_builtin_candidate\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n-\t tree, tree, tree, tree *, tree *, int);\n+\t tree, tree, tree, tree *, tree *, int, tsubst_flags_t);\n static bool is_complete (tree);\n static void build_builtin_candidate\n \t(struct z_candidate **, tree, tree, tree, tree *, tree *,\n-\t int);\n+\t int, tsubst_flags_t);\n static struct z_candidate *add_conv_candidate\n \t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n-\t tree);\n+\t tree, tsubst_flags_t);\n static struct z_candidate *add_function_candidate\n \t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n-\t tree, int);\n-static conversion *implicit_conversion (tree, tree, tree, bool, int);\n+\t tree, int, tsubst_flags_t);\n+static conversion *implicit_conversion (tree, tree, tree, bool, int,\n+\t\t\t\t\ttsubst_flags_t);\n static conversion *standard_conversion (tree, tree, tree, bool, int);\n-static conversion *reference_binding (tree, tree, tree, bool, int);\n+static conversion *reference_binding (tree, tree, tree, bool, int,\n+\t\t\t\t      tsubst_flags_t);\n static conversion *build_conv (conversion_kind, tree, conversion *);\n-static conversion *build_list_conv (tree, tree, int);\n+static conversion *build_list_conv (tree, tree, int, tsubst_flags_t);\n static conversion *next_conversion (conversion *);\n static bool is_subseq (conversion *, conversion *);\n static conversion *maybe_handle_ref_bind (conversion **);\n@@ -208,11 +212,12 @@ static void add_warning (struct z_candidate *, struct z_candidate *);\n static bool reference_compatible_p (tree, tree);\n static conversion *direct_reference_binding (tree, conversion *);\n static bool promoted_arithmetic_type_p (tree);\n-static conversion *conditional_conversion (tree, tree);\n+static conversion *conditional_conversion (tree, tree, tsubst_flags_t);\n static char *name_as_c_string (tree, tree, bool *);\n static tree prep_operand (tree);\n static void add_candidates (tree, tree, const VEC(tree,gc) *, tree, tree, bool,\n-\t\t\t    tree, tree, int, struct z_candidate **);\n+\t\t\t    tree, tree, int, struct z_candidate **,\n+\t\t\t    tsubst_flags_t);\n static conversion *merge_conversion_sequences (conversion *, conversion *);\n static bool magic_varargs_p (tree);\n static tree build_temp (tree, tree, int, diagnostic_t *, tsubst_flags_t);\n@@ -793,7 +798,7 @@ build_conv (conversion_kind code, tree type, conversion *from)\n    possible.  */\n \n static conversion *\n-build_list_conv (tree type, tree ctor, int flags)\n+build_list_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n {\n   tree elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (type), 0);\n   unsigned len = CONSTRUCTOR_NELTS (ctor);\n@@ -812,7 +817,7 @@ build_list_conv (tree type, tree ctor, int flags)\n     {\n       conversion *sub\n \t= implicit_conversion (elttype, TREE_TYPE (val), val,\n-\t\t\t       false, flags);\n+\t\t\t       false, flags, complain);\n       if (sub == NULL)\n \treturn NULL;\n \n@@ -857,7 +862,7 @@ next_conversion (conversion *conv)\n    is a valid aggregate initializer for array type ATYPE.  */\n \n static bool\n-can_convert_array (tree atype, tree ctor, int flags)\n+can_convert_array (tree atype, tree ctor, int flags, tsubst_flags_t complain)\n {\n   unsigned i;\n   tree elttype = TREE_TYPE (atype);\n@@ -867,9 +872,10 @@ can_convert_array (tree atype, tree ctor, int flags)\n       bool ok;\n       if (TREE_CODE (elttype) == ARRAY_TYPE\n \t  && TREE_CODE (val) == CONSTRUCTOR)\n-\tok = can_convert_array (elttype, val, flags);\n+\tok = can_convert_array (elttype, val, flags, complain);\n       else\n-\tok = can_convert_arg (elttype, TREE_TYPE (val), val, flags);\n+\tok = can_convert_arg (elttype, TREE_TYPE (val), val, flags,\n+\t\t\t      complain);\n       if (!ok)\n \treturn false;\n     }\n@@ -880,7 +886,7 @@ can_convert_array (tree atype, tree ctor, int flags)\n    aggregate class, if such a conversion is possible.  */\n \n static conversion *\n-build_aggr_conv (tree type, tree ctor, int flags)\n+build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n {\n   unsigned HOST_WIDE_INT i = 0;\n   conversion *c;\n@@ -909,9 +915,10 @@ build_aggr_conv (tree type, tree ctor, int flags)\n \n       if (TREE_CODE (ftype) == ARRAY_TYPE\n \t  && TREE_CODE (val) == CONSTRUCTOR)\n-\tok = can_convert_array (ftype, val, flags);\n+\tok = can_convert_array (ftype, val, flags, complain);\n       else\n-\tok = can_convert_arg (ftype, TREE_TYPE (val), val, flags);\n+\tok = can_convert_arg (ftype, TREE_TYPE (val), val, flags,\n+\t\t\t      complain);\n \n       if (!ok)\n \treturn NULL;\n@@ -935,7 +942,7 @@ build_aggr_conv (tree type, tree ctor, int flags)\n    array type, if such a conversion is possible.  */\n \n static conversion *\n-build_array_conv (tree type, tree ctor, int flags)\n+build_array_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n {\n   conversion *c;\n   unsigned HOST_WIDE_INT len = CONSTRUCTOR_NELTS (ctor);\n@@ -957,7 +964,7 @@ build_array_conv (tree type, tree ctor, int flags)\n     {\n       conversion *sub\n \t= implicit_conversion (elttype, TREE_TYPE (val), val,\n-\t\t\t       false, flags);\n+\t\t\t       false, flags, complain);\n       if (sub == NULL)\n \treturn NULL;\n \n@@ -982,7 +989,8 @@ build_array_conv (tree type, tree ctor, int flags)\n    complex type, if such a conversion is possible.  */\n \n static conversion *\n-build_complex_conv (tree type, tree ctor, int flags)\n+build_complex_conv (tree type, tree ctor, int flags,\n+\t\t    tsubst_flags_t complain)\n {\n   conversion *c;\n   unsigned HOST_WIDE_INT len = CONSTRUCTOR_NELTS (ctor);\n@@ -1000,7 +1008,7 @@ build_complex_conv (tree type, tree ctor, int flags)\n     {\n       conversion *sub\n \t= implicit_conversion (elttype, TREE_TYPE (val), val,\n-\t\t\t       false, flags);\n+\t\t\t       false, flags, complain);\n       if (sub == NULL)\n \treturn NULL;\n \n@@ -1438,7 +1446,8 @@ direct_reference_binding (tree type, conversion *conv)\n    conversion is coming from a C-style cast.  */\n \n static conversion *\n-reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n+reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n+\t\t   tsubst_flags_t complain)\n {\n   conversion *conv = NULL;\n   tree to = TREE_TYPE (rto);\n@@ -1461,7 +1470,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n     {\n       maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n       conv = implicit_conversion (to, from, expr, c_cast_p,\n-\t\t\t\t  flags);\n+\t\t\t\t  flags, complain);\n       if (!CLASS_TYPE_P (to)\n \t  && CONSTRUCTOR_NELTS (expr) == 1)\n \t{\n@@ -1597,7 +1606,8 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \n \tthe reference is bound to the lvalue result of the conversion\n \tin the second case.  */\n-      z_candidate *cand = build_user_type_conversion_1 (rto, expr, flags);\n+      z_candidate *cand = build_user_type_conversion_1 (rto, expr, flags,\n+\t\t\t\t\t\t\tcomplain);\n       if (cand)\n \treturn cand->second_conv;\n     }\n@@ -1652,7 +1662,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \n   if (!conv)\n     conv = implicit_conversion (to, from, expr, c_cast_p,\n-\t\t\t\tflags);\n+\t\t\t\tflags, complain);\n   if (!conv)\n     return NULL;\n \n@@ -1672,7 +1682,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \n static conversion *\n implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n-\t\t     int flags)\n+\t\t     int flags, tsubst_flags_t complain)\n {\n   conversion *conv;\n \n@@ -1687,7 +1697,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t    |LOOKUP_NO_NARROWING|LOOKUP_PROTECT);\n \n   if (TREE_CODE (to) == REFERENCE_TYPE)\n-    conv = reference_binding (to, from, expr, c_cast_p, flags);\n+    conv = reference_binding (to, from, expr, c_cast_p, flags, complain);\n   else\n     conv = standard_conversion (to, from, expr, c_cast_p, flags);\n \n@@ -1697,12 +1707,12 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   if (expr && BRACE_ENCLOSED_INITIALIZER_P (expr))\n     {\n       if (is_std_init_list (to))\n-\treturn build_list_conv (to, expr, flags);\n+\treturn build_list_conv (to, expr, flags, complain);\n \n       /* As an extension, allow list-initialization of _Complex.  */\n       if (TREE_CODE (to) == COMPLEX_TYPE)\n \t{\n-\t  conv = build_complex_conv (to, expr, flags);\n+\t  conv = build_complex_conv (to, expr, flags, complain);\n \t  if (conv)\n \t    return conv;\n \t}\n@@ -1722,7 +1732,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t    elt = error_mark_node;\n \n \t  conv = implicit_conversion (to, TREE_TYPE (elt), elt,\n-\t\t\t\t      c_cast_p, flags);\n+\t\t\t\t      c_cast_p, flags, complain);\n \t  if (conv)\n \t    {\n \t      conv->check_narrowing = true;\n@@ -1733,7 +1743,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t    }\n \t}\n       else if (TREE_CODE (to) == ARRAY_TYPE)\n-\treturn build_array_conv (to, expr, flags);\n+\treturn build_array_conv (to, expr, flags, complain);\n     }\n \n   if (expr != NULL_TREE\n@@ -1746,9 +1756,9 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       if (CLASS_TYPE_P (to)\n \t  && BRACE_ENCLOSED_INITIALIZER_P (expr)\n \t  && !CLASSTYPE_NON_AGGREGATE (complete_type (to)))\n-\treturn build_aggr_conv (to, expr, flags);\n+\treturn build_aggr_conv (to, expr, flags, complain);\n \n-      cand = build_user_type_conversion_1 (to, expr, flags);\n+      cand = build_user_type_conversion_1 (to, expr, flags, complain);\n       if (cand)\n \tconv = cand->second_conv;\n \n@@ -1818,7 +1828,8 @@ static struct z_candidate *\n add_function_candidate (struct z_candidate **candidates,\n \t\t\ttree fn, tree ctype, tree first_arg,\n \t\t\tconst VEC(tree,gc) *args, tree access_path,\n-\t\t\ttree conversion_path, int flags)\n+\t\t\ttree conversion_path, int flags,\n+\t\t\ttsubst_flags_t complain)\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   int i, len;\n@@ -1977,7 +1988,7 @@ add_function_candidate (struct z_candidate **candidates,\n \t    lflags |= LOOKUP_ONLYCONVERTING;\n \n \t  t = implicit_conversion (parmtype, argtype, arg,\n-\t\t\t\t   /*c_cast_p=*/false, lflags);\n+\t\t\t\t   /*c_cast_p=*/false, lflags, complain);\n \t  to_type = parmtype;\n \t}\n       else\n@@ -2025,7 +2036,8 @@ add_function_candidate (struct z_candidate **candidates,\n static struct z_candidate *\n add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n \t\t    tree first_arg, const VEC(tree,gc) *arglist,\n-\t\t    tree access_path, tree conversion_path)\n+\t\t    tree access_path, tree conversion_path,\n+\t\t    tsubst_flags_t complain)\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   int i, len, viable, flags;\n@@ -2065,15 +2077,15 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n       if (i == 0)\n \t{\n \t  t = implicit_conversion (totype, argtype, arg, /*c_cast_p=*/false,\n-\t\t\t\t   flags);\n+\t\t\t\t   flags, complain);\n \t  convert_type = totype;\n \t}\n       else if (parmnode == void_list_node)\n \tbreak;\n       else if (parmnode)\n \t{\n \t  t = implicit_conversion (TREE_VALUE (parmnode), argtype, arg,\n-\t\t\t\t   /*c_cast_p=*/false, flags);\n+\t\t\t\t   /*c_cast_p=*/false, flags, complain);\n \t  convert_type = TREE_VALUE (parmnode);\n \t}\n       else\n@@ -2115,7 +2127,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n static void\n build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \t\t\t tree type1, tree type2, tree *args, tree *argtypes,\n-\t\t\t int flags)\n+\t\t\t int flags, tsubst_flags_t complain)\n {\n   conversion *t;\n   conversion **convs;\n@@ -2144,18 +2156,20 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \tbreak;\n \n       t = implicit_conversion (types[i], argtypes[i], args[i],\n-\t\t\t       /*c_cast_p=*/false, flags);\n+\t\t\t       /*c_cast_p=*/false, flags, complain);\n       if (! t)\n \t{\n \t  viable = 0;\n \t  /* We need something for printing the candidate.  */\n \t  t = build_identity_conv (types[i], NULL_TREE);\n-\t  reason = arg_conversion_rejection (NULL_TREE, i, argtypes[i], types[i]);\n+\t  reason = arg_conversion_rejection (NULL_TREE, i, argtypes[i],\n+\t\t\t\t\t     types[i]);\n \t}\n       else if (t->bad_p)\n \t{\n \t  viable = 0;\n-\t  reason = bad_arg_conversion_rejection (NULL_TREE, i, argtypes[i], types[i]);\n+\t  reason = bad_arg_conversion_rejection (NULL_TREE, i, argtypes[i],\n+\t\t\t\t\t\t types[i]);\n \t}\n       convs[i] = t;\n     }\n@@ -2166,7 +2180,8 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n       convs[2] = convs[1];\n       convs[1] = convs[0];\n       t = implicit_conversion (boolean_type_node, argtypes[2], args[2],\n-\t\t\t       /*c_cast_p=*/false, flags);\n+\t\t\t       /*c_cast_p=*/false, flags,\n+\t\t\t       complain);\n       if (t)\n \tconvs[0] = t;\n       else\n@@ -2220,7 +2235,8 @@ promoted_arithmetic_type_p (tree type)\n static void\n add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t\t       enum tree_code code2, tree fnname, tree type1,\n-\t\t       tree type2, tree *args, tree *argtypes, int flags)\n+\t\t       tree type2, tree *args, tree *argtypes, int flags,\n+\t\t       tsubst_flags_t complain)\n {\n   switch (code)\n     {\n@@ -2614,20 +2630,21 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t  if (cptype != error_mark_node)\n \t    {\n \t      build_builtin_candidate\n-\t\t(candidates, fnname, cptype, cptype, args, argtypes, flags);\n+\t\t(candidates, fnname, cptype, cptype, args, argtypes,\n+\t\t flags, complain);\n \t      return;\n \t    }\n \t}\n \n       build_builtin_candidate\n-\t(candidates, fnname, type1, type1, args, argtypes, flags);\n+\t(candidates, fnname, type1, type1, args, argtypes, flags, complain);\n       build_builtin_candidate\n-\t(candidates, fnname, type2, type2, args, argtypes, flags);\n+\t(candidates, fnname, type2, type2, args, argtypes, flags, complain);\n       return;\n     }\n \n   build_builtin_candidate\n-    (candidates, fnname, type1, type2, args, argtypes, flags);\n+    (candidates, fnname, type1, type2, args, argtypes, flags, complain);\n }\n \n tree\n@@ -2656,7 +2673,7 @@ type_decays_to (tree type)\n static void\n add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t\t\tenum tree_code code2, tree fnname, tree *args,\n-\t\t\tint flags)\n+\t\t\tint flags, tsubst_flags_t complain)\n {\n   int ref1, i;\n   int enum_p = 0;\n@@ -2697,14 +2714,14 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n     case TRUTH_NOT_EXPR:\n       build_builtin_candidate\n \t(candidates, fnname, boolean_type_node,\n-\t NULL_TREE, args, argtypes, flags);\n+\t NULL_TREE, args, argtypes, flags, complain);\n       return;\n \n     case TRUTH_ORIF_EXPR:\n     case TRUTH_ANDIF_EXPR:\n       build_builtin_candidate\n \t(candidates, fnname, boolean_type_node,\n-\t boolean_type_node, args, argtypes, flags);\n+\t boolean_type_node, args, argtypes, flags, complain);\n       return;\n \n     case ADDR_EXPR:\n@@ -2810,11 +2827,11 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \tFOR_EACH_VEC_ELT_REVERSE (tree, types[1], jx, u)\n \t  add_builtin_candidate\n \t    (candidates, code, code2, fnname, t,\n-\t     u, args, argtypes, flags);\n+\t     u, args, argtypes, flags, complain);\n       else\n \tadd_builtin_candidate\n \t  (candidates, code, code2, fnname, t,\n-\t   NULL_TREE, args, argtypes, flags);\n+\t   NULL_TREE, args, argtypes, flags, complain);\n     }\n \n   release_tree_vector (types[0]);\n@@ -2837,7 +2854,8 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \t\t\t     tree ctype, tree explicit_targs, tree first_arg,\n \t\t\t     const VEC(tree,gc) *arglist, tree return_type,\n \t\t\t     tree access_path, tree conversion_path,\n-\t\t\t     int flags, tree obj, unification_kind_t strict)\n+\t\t\t     int flags, tree obj, unification_kind_t strict,\n+\t\t\t     tsubst_flags_t complain)\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_tree_vec (ntparms);\n@@ -2958,11 +2976,11 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   if (obj != NULL_TREE)\n     /* Aha, this is a conversion function.  */\n     cand = add_conv_candidate (candidates, fn, obj, first_arg, arglist,\n-\t\t\t       access_path, conversion_path);\n+\t\t\t       access_path, conversion_path, complain);\n   else\n     cand = add_function_candidate (candidates, fn, ctype,\n \t\t\t\t   first_arg, arglist, access_path,\n-\t\t\t\t   conversion_path, flags);\n+\t\t\t\t   conversion_path, flags, complain);\n   if (DECL_TI_TEMPLATE (fn) != tmpl)\n     /* This situation can occur if a member template of a template\n        class is specialized.  Then, instantiate_template might return\n@@ -2998,13 +3016,13 @@ add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n \t\t\ttree explicit_targs, tree first_arg,\n \t\t\tconst VEC(tree,gc) *arglist, tree return_type,\n \t\t\ttree access_path, tree conversion_path, int flags,\n-\t\t\tunification_kind_t strict)\n+\t\t\tunification_kind_t strict, tsubst_flags_t complain)\n {\n   return\n     add_template_candidate_real (candidates, tmpl, ctype,\n \t\t\t\t explicit_targs, first_arg, arglist,\n \t\t\t\t return_type, access_path, conversion_path,\n-\t\t\t\t flags, NULL_TREE, strict);\n+\t\t\t\t flags, NULL_TREE, strict, complain);\n }\n \n \n@@ -3013,12 +3031,13 @@ add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n \t\t\t     tree obj, tree first_arg,\n \t\t\t     const VEC(tree,gc) *arglist,\n \t\t\t     tree return_type, tree access_path,\n-\t\t\t     tree conversion_path)\n+\t\t\t     tree conversion_path, tsubst_flags_t complain)\n {\n   return\n     add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,\n \t\t\t\t first_arg, arglist, return_type, access_path,\n-\t\t\t\t conversion_path, 0, obj, DEDUCE_CONV);\n+\t\t\t\t conversion_path, 0, obj, DEDUCE_CONV,\n+\t\t\t\t complain);\n }\n \n /* The CANDS are the set of candidates that were considered for\n@@ -3341,7 +3360,8 @@ add_list_candidates (tree fns, tree first_arg,\n \t\t     tree explicit_targs, bool template_only,\n \t\t     tree conversion_path, tree access_path,\n \t\t     int flags,\n-\t\t     struct z_candidate **candidates)\n+\t\t     struct z_candidate **candidates,\n+\t\t     tsubst_flags_t complain)\n {\n   VEC(tree,gc) *args;\n \n@@ -3365,7 +3385,7 @@ add_list_candidates (tree fns, tree first_arg,\n       args = make_tree_vector_single (init_list);\n       add_candidates (fns, first_arg, args, NULL_TREE,\n \t\t      explicit_targs, template_only, conversion_path,\n-\t\t      access_path, flags, candidates);\n+\t\t      access_path, flags, candidates, complain);\n       if (any_strictly_viable (*candidates))\n \treturn;\n     }\n@@ -3379,7 +3399,7 @@ add_list_candidates (tree fns, tree first_arg,\n \n   add_candidates (fns, first_arg, args, NULL_TREE,\n \t\t  explicit_targs, template_only, conversion_path,\n-\t\t  access_path, flags, candidates);\n+\t\t  access_path, flags, candidates, complain);\n }\n \n /* Returns the best overload candidate to perform the requested\n@@ -3389,7 +3409,8 @@ add_list_candidates (tree fns, tree first_arg,\n    per [dcl.init.ref], so we ignore temporary bindings.  */\n \n static struct z_candidate *\n-build_user_type_conversion_1 (tree totype, tree expr, int flags)\n+build_user_type_conversion_1 (tree totype, tree expr, int flags,\n+\t\t\t      tsubst_flags_t complain)\n {\n   struct z_candidate *candidates, *cand;\n   tree fromtype;\n@@ -3460,14 +3481,14 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t  /* List-initialization.  */\n \t  add_list_candidates (ctors, first_arg, expr, totype, NULL_TREE,\n \t\t\t       false, TYPE_BINFO (totype), TYPE_BINFO (totype),\n-\t\t\t       ctorflags, &candidates);\n+\t\t\t       ctorflags, &candidates, complain);\n \t}\n       else\n \t{\n \t  args = make_tree_vector_single (expr);\n \t  add_candidates (ctors, first_arg, args, NULL_TREE, NULL_TREE, false,\n \t\t\t  TYPE_BINFO (totype), TYPE_BINFO (totype),\n-\t\t\t  ctorflags, &candidates);\n+\t\t\t  ctorflags, &candidates, complain);\n \t}\n \n       for (cand = candidates; cand; cand = cand->next)\n@@ -3508,7 +3529,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       add_candidates (TREE_VALUE (conv_fns), first_arg, NULL, totype,\n \t\t      NULL_TREE, false,\n \t\t      conversion_path, TYPE_BINFO (fromtype),\n-\t\t      flags, &candidates);\n+\t\t      flags, &candidates, complain);\n \n       for (cand = candidates; cand != old_candidates; cand = cand->next)\n \t{\n@@ -3517,7 +3538,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t    = implicit_conversion (totype,\n \t\t\t\t   rettype,\n \t\t\t\t   0,\n-\t\t\t\t   /*c_cast_p=*/false, convflags);\n+\t\t\t\t   /*c_cast_p=*/false, convflags,\n+\t\t\t\t   complain);\n \n \t  /* If LOOKUP_NO_TEMP_BIND isn't set, then this is\n \t     copy-initialization.  In that case, \"The result of the\n@@ -3582,13 +3604,14 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       return NULL;\n     }\n \n-  cand = tourney (candidates);\n+  cand = tourney (candidates, complain);\n   if (cand == 0)\n     {\n-      if (flags & LOOKUP_COMPLAIN)\n+      if ((flags & LOOKUP_COMPLAIN)\n+\t  && (complain & tf_error))\n \t{\n \t  error (\"conversion from %qT to %qT is ambiguous\",\n-\t\t    fromtype, totype);\n+\t\t fromtype, totype);\n \t  print_z_candidates (location_of (expr), candidates);\n \t}\n \n@@ -3628,21 +3651,22 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n /* Wrapper for above. */\n \n tree\n-build_user_type_conversion (tree totype, tree expr, int flags)\n+build_user_type_conversion (tree totype, tree expr, int flags,\n+\t\t\t    tsubst_flags_t complain)\n {\n   struct z_candidate *cand;\n   tree ret;\n \n   bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  cand = build_user_type_conversion_1 (totype, expr, flags);\n+  cand = build_user_type_conversion_1 (totype, expr, flags, complain);\n \n   if (cand)\n     {\n       if (cand->second_conv->kind == ck_ambig)\n \tret = error_mark_node;\n       else\n         {\n-          expr = convert_like (cand->second_conv, expr, tf_warning_or_error);\n+          expr = convert_like (cand->second_conv, expr, complain);\n           ret = convert_from_reference (expr);\n         }\n     }\n@@ -3679,7 +3703,7 @@ build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n \n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      /*c_cast_p=*/false,\n-\t\t\t      LOOKUP_IMPLICIT);\n+\t\t\t      LOOKUP_IMPLICIT, complain);\n \n   /* for a non-type template-parameter of integral or\n      enumeration type, integral promotions (4.5) and integral\n@@ -3763,7 +3787,7 @@ static struct z_candidate *\n perform_overload_resolution (tree fn,\n \t\t\t     const VEC(tree,gc) *args,\n \t\t\t     struct z_candidate **candidates,\n-\t\t\t     bool *any_viable_p)\n+\t\t\t     bool *any_viable_p, tsubst_flags_t complain)\n {\n   struct z_candidate *cand;\n   tree explicit_targs;\n@@ -3796,11 +3820,11 @@ perform_overload_resolution (tree fn,\n \t\t  /*conversion_path=*/NULL_TREE,\n \t\t  /*access_path=*/NULL_TREE,\n \t\t  LOOKUP_NORMAL,\n-\t\t  candidates);\n+\t\t  candidates, complain);\n \n   *candidates = splice_viable (*candidates, pedantic, any_viable_p);\n   if (*any_viable_p)\n-    cand = tourney (*candidates);\n+    cand = tourney (*candidates, complain);\n   else\n     cand = NULL;\n \n@@ -3872,7 +3896,8 @@ build_new_function_call (tree fn, VEC(tree,gc) **args, bool koenig_p,\n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n-  cand = perform_overload_resolution (fn, *args, &candidates, &any_viable_p);\n+  cand = perform_overload_resolution (fn, *args, &candidates, &any_viable_p,\n+\t\t\t\t      complain);\n \n   if (!cand)\n     {\n@@ -3918,7 +3943,7 @@ build_new_function_call (tree fn, VEC(tree,gc) **args, bool koenig_p,\n tree\n build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n \t\t\t tree *size, tree *cookie_size,\n-\t\t\t tree *fn)\n+\t\t\t tree *fn, tsubst_flags_t complain)\n {\n   tree fns;\n   struct z_candidate *candidates;\n@@ -3928,7 +3953,7 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n   if (fn)\n     *fn = NULL_TREE;\n   VEC_safe_insert (tree, gc, *args, 0, *size);\n-  *args = resolve_args (*args, tf_warning_or_error);\n+  *args = resolve_args (*args, complain);\n   if (*args == NULL)\n     return error_mark_node;\n \n@@ -3944,13 +3969,15 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n   fns = lookup_function_nonclass (fnname, *args, /*block_p=*/false);\n \n   /* Figure out what function is being called.  */\n-  cand = perform_overload_resolution (fns, *args, &candidates, &any_viable_p);\n+  cand = perform_overload_resolution (fns, *args, &candidates, &any_viable_p,\n+\t\t\t\t      complain);\n \n   /* If no suitable function could be found, issue an error message\n      and give up.  */\n   if (!cand)\n     {\n-      print_error_for_call_failure (fns, *args, any_viable_p, candidates);\n+      if (complain & tf_error)\n+\tprint_error_for_call_failure (fns, *args, any_viable_p, candidates);\n       return error_mark_node;\n     }\n \n@@ -4001,7 +4028,7 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n      *fn = cand->fn;\n \n    /* Build the CALL_EXPR.  */\n-   return build_over_call (cand, LOOKUP_NORMAL, tf_warning_or_error);\n+   return build_over_call (cand, LOOKUP_NORMAL, complain);\n }\n \n /* Build a new call to operator().  This may change ARGS.  */\n@@ -4057,7 +4084,7 @@ build_op_call_1 (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n \t\t      first_mem_arg, *args, NULL_TREE,\n \t\t      NULL_TREE, false,\n \t\t      BASELINK_BINFO (fns), BASELINK_ACCESS_BINFO (fns),\n-\t\t      LOOKUP_NORMAL, &candidates);\n+\t\t      LOOKUP_NORMAL, &candidates, complain);\n     }\n \n   convs = lookup_conversions (type);\n@@ -4085,11 +4112,11 @@ build_op_call_1 (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n \t      add_template_conv_candidate\n \t\t(&candidates, fn, obj, NULL_TREE, *args, totype,\n \t\t /*access_path=*/NULL_TREE,\n-\t\t /*conversion_path=*/NULL_TREE);\n+\t\t /*conversion_path=*/NULL_TREE, complain);\n \t    else\n \t      add_conv_candidate (&candidates, fn, obj, NULL_TREE,\n \t\t\t\t  *args, /*conversion_path=*/NULL_TREE,\n-\t\t\t\t  /*access_path=*/NULL_TREE);\n+\t\t\t\t  /*access_path=*/NULL_TREE, complain);\n \t  }\n     }\n \n@@ -4106,7 +4133,7 @@ build_op_call_1 (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n     }\n   else\n     {\n-      cand = tourney (candidates);\n+      cand = tourney (candidates, complain);\n       if (cand == 0)\n \t{\n           if (complain & tf_error)\n@@ -4251,7 +4278,7 @@ op_error (enum tree_code code, enum tree_code code2,\n    convert E1 to E2 in [expr.cond].  */\n \n static conversion *\n-conditional_conversion (tree e1, tree e2)\n+conditional_conversion (tree e1, tree e2, tsubst_flags_t complain)\n {\n   tree t1 = non_reference (TREE_TYPE (e1));\n   tree t2 = non_reference (TREE_TYPE (e2));\n@@ -4271,7 +4298,8 @@ conditional_conversion (tree e1, tree e2)\n \t\t\t\t  e1,\n \t\t\t\t  /*c_cast_p=*/false,\n \t\t\t\t  LOOKUP_NO_TEMP_BIND|LOOKUP_NO_RVAL_BIND\n-\t\t\t\t  |LOOKUP_ONLYCONVERTING);\n+\t\t\t\t  |LOOKUP_ONLYCONVERTING,\n+\t\t\t\t  complain);\n       if (conv)\n \treturn conv;\n     }\n@@ -4309,7 +4337,7 @@ conditional_conversion (tree e1, tree e2)\n        converted to the type that expression E2 would have if E2 were\n        converted to an rvalue (or the type it has, if E2 is an rvalue).  */\n     return implicit_conversion (t2, t1, e1, /*c_cast_p=*/false,\n-\t\t\t\tLOOKUP_IMPLICIT);\n+\t\t\t\tLOOKUP_IMPLICIT, complain);\n }\n \n /* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three\n@@ -4455,8 +4483,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n       /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n       p = conversion_obstack_alloc (0);\n \n-      conv2 = conditional_conversion (arg2, arg3);\n-      conv3 = conditional_conversion (arg3, arg2);\n+      conv2 = conditional_conversion (arg2, arg3, complain);\n+      conv3 = conditional_conversion (arg3, arg2, complain);\n \n       /* [expr.cond]\n \n@@ -4568,7 +4596,7 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t\t\t      NOP_EXPR,\n \t\t\t      ansi_opname (COND_EXPR),\n \t\t\t      args,\n-\t\t\t      LOOKUP_NORMAL);\n+\t\t\t      LOOKUP_NORMAL, complain);\n \n       /* [expr.cond]\n \n@@ -4584,7 +4612,7 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n             }\n \t  return error_mark_node;\n \t}\n-      cand = tourney (candidates);\n+      cand = tourney (candidates, complain);\n       if (!cand)\n \t{\n           if (complain & tf_error)\n@@ -4793,7 +4821,8 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n \t\ttree explicit_targs, bool template_only,\n \t\ttree conversion_path, tree access_path,\n \t\tint flags,\n-\t\tstruct z_candidate **candidates)\n+\t\tstruct z_candidate **candidates,\n+\t\ttsubst_flags_t complain)\n {\n   tree ctype;\n   const VEC(tree,gc) *non_static_args;\n@@ -4899,7 +4928,8 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n \t\t\t\tflags,\n-\t\t\t\tstrict);\n+\t\t\t\tstrict,\n+\t\t\t\tcomplain);\n       else if (!template_only)\n \tadd_function_candidate (candidates,\n \t\t\t\tfn,\n@@ -4908,7 +4938,8 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n \t\t\t\tfn_args,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n-\t\t\t\tflags);\n+\t\t\t\tflags,\n+\t\t\t\tcomplain);\n     }\n }\n \n@@ -4999,7 +5030,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   add_candidates (lookup_function_nonclass (fnname, arglist, /*block_p=*/true),\n \t\t  NULL_TREE, arglist, NULL_TREE,\n \t\t  NULL_TREE, false, NULL_TREE, NULL_TREE,\n-\t\t  flags, &candidates);\n+\t\t  flags, &candidates, complain);\n   /* Add class-member operators to the candidate set.  */\n   if (CLASS_TYPE_P (TREE_TYPE (arg1)))\n     {\n@@ -5017,14 +5048,15 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t\t\tNULL_TREE, false,\n \t\t\tBASELINK_BINFO (fns),\n \t\t\tBASELINK_ACCESS_BINFO (fns),\n-\t\t\tflags, &candidates);\n+\t\t\tflags, &candidates, complain);\n     }\n \n   args[0] = arg1;\n   args[1] = arg2;\n   args[2] = NULL_TREE;\n \n-  add_builtin_candidates (&candidates, code, code2, fnname, args, flags);\n+  add_builtin_candidates (&candidates, code, code2, fnname, args,\n+\t\t\t  flags, complain);\n \n   switch (code)\n     {\n@@ -5113,7 +5145,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     }\n   else\n     {\n-      cand = tourney (candidates);\n+      cand = tourney (candidates, complain);\n       if (cand == 0)\n \t{\n \t  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))\n@@ -5140,7 +5172,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t    {\n \t      struct candidate_warning *w;\n \t      for (w = cand->warnings; w; w = w->next)\n-\t\tjoust (cand, w->loser, 1);\n+\t\tjoust (cand, w->loser, 1, complain);\n \t    }\n \n \t  /* Check for comparison of different enum types.  */\n@@ -5770,7 +5802,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       if (complain & tf_error)\n \t{\n \t  /* Call build_user_type_conversion again for the error.  */\n-\t  build_user_type_conversion (totype, convs->u.expr, LOOKUP_NORMAL);\n+\t  build_user_type_conversion (totype, convs->u.expr, LOOKUP_NORMAL,\n+\t\t\t\t      complain);\n \t  if (fn)\n \t    error (\"  initializing argument %P of %q+D\", argnum, fn);\n \t}\n@@ -6010,15 +6043,15 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n    required.  Return the converted value.  */\n \n tree\n-convert_arg_to_ellipsis (tree arg)\n+convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n {\n   tree arg_type;\n \n   /* [expr.call]\n \n      The lvalue-to-rvalue, array-to-pointer, and function-to-pointer\n      standard conversions are performed.  */\n-  arg = decay_conversion (arg, tf_warning_or_error);\n+  arg = decay_conversion (arg, complain);\n   arg_type = TREE_TYPE (arg);\n   /* [expr.call]\n \n@@ -6032,7 +6065,8 @@ convert_arg_to_ellipsis (tree arg)\n \t  < TYPE_PRECISION (double_type_node))\n       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (arg_type)))\n     {\n-      if (warn_double_promotion && !c_inhibit_evaluation_warnings)\n+      if ((complain & tf_warning)\n+\t  && warn_double_promotion && !c_inhibit_evaluation_warnings)\n \twarning (OPT_Wdouble_promotion,\n \t\t \"implicit conversion from %qT to %qT when passing \"\n \t\t \"argument to function\",\n@@ -6045,8 +6079,9 @@ convert_arg_to_ellipsis (tree arg)\n     {\n       if (SCOPED_ENUM_P (arg_type) && !abi_version_at_least (6))\n \t{\n-\t  warning (OPT_Wabi, \"scoped enum %qT will not promote to an \"\n-\t\t   \"integral type in a future version of GCC\", arg_type);\n+\t  if (complain & tf_warning)\n+\t    warning (OPT_Wabi, \"scoped enum %qT will not promote to an \"\n+\t\t     \"integral type in a future version of GCC\", arg_type);\n \t  arg = cp_convert (ENUM_UNDERLYING_TYPE (arg_type), arg);\n \t}\n       arg = perform_integral_promotions (arg);\n@@ -6064,7 +6099,7 @@ convert_arg_to_ellipsis (tree arg)\n       /* Build up a real lvalue-to-rvalue conversion in case the\n \t copy constructor is trivial but not callable.  */\n       if (!cp_unevaluated_operand && CLASS_TYPE_P (arg_type))\n-\tforce_rvalue (arg, tf_warning_or_error);\n+\tforce_rvalue (arg, complain);\n \n       /* [expr.call] 5.2.2/7:\n \t Passing a potentially-evaluated argument of class type (Clause 9)\n@@ -6080,8 +6115,13 @@ convert_arg_to_ellipsis (tree arg)\n       if (cp_unevaluated_operand == 0\n \t  && (type_has_nontrivial_copy_init (arg_type)\n \t      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (arg_type)))\n-\terror (\"cannot pass objects of non-trivially-copyable \"\n-\t       \"type %q#T through %<...%>\", arg_type);\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"cannot pass objects of non-trivially-copyable \"\n+\t\t   \"type %q#T through %<...%>\", arg_type);\n+\t  else\n+\t    return error_mark_node;\n+\t}\n     }\n \n   return arg;\n@@ -6153,7 +6193,8 @@ pop_defarg_context (void)\n { VEC_pop (tree, default_arg_context); }\n \n tree\n-convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n+convert_default_arg (tree type, tree arg, tree fn, int parmnum,\n+\t\t     tsubst_flags_t complain)\n {\n   int i;\n   tree t;\n@@ -6165,16 +6206,18 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n   FOR_EACH_VEC_ELT (tree, default_arg_context, i, t)\n     if (t == fn)\n       {\n-\terror (\"recursive evaluation of default argument for %q#D\", fn);\n+\tif (complain & tf_error)\n+\t  error (\"recursive evaluation of default argument for %q#D\", fn);\n \treturn error_mark_node;\n       }\n \n   /* If the ARG is an unparsed default argument expression, the\n      conversion cannot be performed.  */\n   if (TREE_CODE (arg) == DEFAULT_ARG)\n     {\n-      error (\"call to %qD uses the default argument for parameter %P, which \"\n-\t     \"is not yet defined\", fn, parmnum);\n+      if (complain & tf_error)\n+\terror (\"call to %qD uses the default argument for parameter %P, which \"\n+\t       \"is not yet defined\", fn, parmnum);\n       return error_mark_node;\n     }\n \n@@ -6198,17 +6241,17 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n   arg = break_out_target_exprs (arg);\n   if (TREE_CODE (arg) == CONSTRUCTOR)\n     {\n-      arg = digest_init (type, arg, tf_warning_or_error);\n+      arg = digest_init (type, arg, complain);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_IMPLICIT,\n \t\t\t\t\tICR_DEFAULT_ARGUMENT, fn, parmnum,\n-                                        tf_warning_or_error);\n+                                        complain);\n     }\n   else\n     {\n       arg = convert_for_initialization (0, type, arg, LOOKUP_IMPLICIT,\n \t\t\t\t\tICR_DEFAULT_ARGUMENT, fn, parmnum,\n-                                        tf_warning_or_error);\n-      arg = convert_for_arg_passing (type, arg);\n+                                        complain);\n+      arg = convert_for_arg_passing (type, arg, complain);\n     }\n   pop_deferring_access_checks();\n \n@@ -6243,7 +6286,7 @@ type_passed_as (tree type)\n /* Actually perform the appropriate conversion.  */\n \n tree\n-convert_for_arg_passing (tree type, tree val)\n+convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n {\n   tree bitfield_type;\n \n@@ -6277,7 +6320,8 @@ convert_for_arg_passing (tree type, tree val)\n \t   && INT_CST_LT_UNSIGNED (TYPE_SIZE (type),\n \t\t\t\t   TYPE_SIZE (integer_type_node)))\n     val = perform_integral_promotions (val);\n-  if (warn_missing_format_attribute)\n+  if ((complain & tf_warning)\n+      && warn_missing_format_attribute)\n     {\n       tree rhstype = TREE_TYPE (val);\n       const enum tree_code coder = TREE_CODE (rhstype);\n@@ -6383,7 +6427,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     {\n       struct candidate_warning *w;\n       for (w = cand->warnings; w; w = w->next)\n-\tjoust (cand, w->loser, 1);\n+\tjoust (cand, w->loser, 1, complain);\n     }\n \n   /* Make =delete work with SFINAE.  */\n@@ -6611,7 +6655,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t\t\t       ? complain\n \t\t\t\t       : complain & (~tf_warning));\n \n-      val = convert_for_arg_passing (type, val);\n+      val = convert_for_arg_passing (type, val, complain);\n       if (val == error_mark_node)\n         return error_mark_node;\n       else\n@@ -6625,7 +6669,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \treturn error_mark_node;\n       argarray[j++] = convert_default_arg (TREE_VALUE (parm),\n \t\t\t\t\t   TREE_PURPOSE (parm),\n-\t\t\t\t\t   fn, i - is_method);\n+\t\t\t\t\t   fn, i - is_method,\n+\t\t\t\t\t   complain);\n     }\n \n   /* Ellipsis */\n@@ -6636,7 +6681,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t/* Do no conversions for magic varargs.  */\n \ta = mark_type_use (a);\n       else\n-\ta = convert_arg_to_ellipsis (a);\n+\ta = convert_arg_to_ellipsis (a, complain);\n       argarray[j++] = a;\n     }\n \n@@ -7275,13 +7320,14 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n       /* Otherwise go ahead with overload resolution.  */\n       add_list_candidates (fns, first_mem_arg, init_list,\n \t\t\t   basetype, explicit_targs, template_only,\n-\t\t\t   conversion_path, access_binfo, flags, &candidates);\n+\t\t\t   conversion_path, access_binfo, flags,\n+\t\t\t   &candidates, complain);\n     }\n   else\n     {\n       add_candidates (fns, first_mem_arg, user_args, optype,\n \t\t      explicit_targs, template_only, conversion_path,\n-\t\t      access_binfo, flags, &candidates);\n+\t\t      access_binfo, flags, &candidates, complain);\n     }\n   any_viable_p = false;\n   candidates = splice_viable (candidates, pedantic, &any_viable_p);\n@@ -7318,7 +7364,7 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n     }\n   else\n     {\n-      cand = tourney (candidates);\n+      cand = tourney (candidates, complain);\n       if (cand == 0)\n \t{\n \t  char *pretty_name;\n@@ -8013,7 +8059,8 @@ add_warning (struct z_candidate *winner, struct z_candidate *loser)\n       0: cand1 and cand2 are indistinguishable */\n \n static int\n-joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n+joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n+       tsubst_flags_t complain)\n {\n   int winner = 0;\n   int off1 = 0, off2 = 0;\n@@ -8076,7 +8123,8 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \n       if (comp != 0)\n \t{\n-\t  if (warn_sign_promo\n+\t  if ((complain & tf_warning)\n+\t      && warn_sign_promo\n \t      && (CONVERSION_RANK (t1) + CONVERSION_RANK (t2)\n \t\t  == cr_std + cr_promotion)\n \t      && t1->kind == ck_std\n@@ -8121,7 +8169,8 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   /* warn about confusing overload resolution for user-defined conversions,\n      either between a constructor and a conversion op, or between two\n      conversion ops.  */\n-  if (winner && warn_conversion && cand1->second_conv\n+  if ((complain & tf_warning)\n+      && winner && warn_conversion && cand1->second_conv\n       && (!DECL_CONSTRUCTOR_P (cand1->fn) || !DECL_CONSTRUCTOR_P (cand2->fn))\n       && winner != compare_ics (cand1->second_conv, cand2->second_conv))\n     {\n@@ -8283,12 +8332,18 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t    {\n \t      if (warn)\n \t\t{\n-\t\t  permerror (input_location, \"default argument mismatch in \"\n-\t\t\t     \"overload resolution\");\n-\t\t  inform (input_location,\n-\t\t\t  \" candidate 1: %q+#F\", cand1->fn);\n-\t\t  inform (input_location,\n-\t\t\t  \" candidate 2: %q+#F\", cand2->fn);\n+\t\t  if (complain & tf_error)\n+\t\t    {\n+\t\t      permerror (input_location,\n+\t\t\t\t \"default argument mismatch in \"\n+\t\t\t\t \"overload resolution\");\n+\t\t      inform (input_location,\n+\t\t\t      \" candidate 1: %q+#F\", cand1->fn);\n+\t\t      inform (input_location,\n+\t\t\t      \" candidate 2: %q+#F\", cand2->fn);\n+\t\t    }\n+\t\t  else\n+\t\t    return 0;\n \t\t}\n \t      else\n \t\tadd_warning (cand1, cand2);\n@@ -8305,7 +8360,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \n   /* Extension: If the worst conversion for one candidate is worse than the\n      worst conversion for the other, take the first.  */\n-  if (!pedantic)\n+  if (!pedantic && (complain & tf_warning_or_error))\n     {\n       conversion_rank rank1 = cr_identity, rank2 = cr_identity;\n       struct z_candidate *w = 0, *l = 0;\n@@ -8351,7 +8406,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n    algorithm.  */\n \n static struct z_candidate *\n-tourney (struct z_candidate *candidates)\n+tourney (struct z_candidate *candidates, tsubst_flags_t complain)\n {\n   struct z_candidate *champ = candidates, *challenger;\n   int fate;\n@@ -8362,7 +8417,7 @@ tourney (struct z_candidate *candidates)\n \n   for (challenger = champ->next; challenger; )\n     {\n-      fate = joust (champ, challenger, 0);\n+      fate = joust (champ, challenger, 0, complain);\n       if (fate == 1)\n \tchallenger = challenger->next;\n       else\n@@ -8392,7 +8447,7 @@ tourney (struct z_candidate *candidates)\n \t && !(champ_compared_to_predecessor && challenger->next == champ);\n        challenger = challenger->next)\n     {\n-      fate = joust (champ, challenger, 0);\n+      fate = joust (champ, challenger, 0, complain);\n       if (fate != 1)\n \treturn NULL;\n     }\n@@ -8403,15 +8458,16 @@ tourney (struct z_candidate *candidates)\n /* Returns nonzero if things of type FROM can be converted to TO.  */\n \n bool\n-can_convert (tree to, tree from)\n+can_convert (tree to, tree from, tsubst_flags_t complain)\n {\n-  return can_convert_arg (to, from, NULL_TREE, LOOKUP_IMPLICIT);\n+  return can_convert_arg (to, from, NULL_TREE, LOOKUP_IMPLICIT, complain);\n }\n \n /* Returns nonzero if ARG (of type FROM) can be converted to TO.  */\n \n bool\n-can_convert_arg (tree to, tree from, tree arg, int flags)\n+can_convert_arg (tree to, tree from, tree arg, int flags,\n+\t\t tsubst_flags_t complain)\n {\n   conversion *t;\n   void *p;\n@@ -8421,7 +8477,7 @@ can_convert_arg (tree to, tree from, tree arg, int flags)\n   p = conversion_obstack_alloc (0);\n \n   t  = implicit_conversion (to, from, arg, /*c_cast_p=*/false,\n-\t\t\t    flags);\n+\t\t\t    flags, complain);\n   ok_p = (t && !t->bad_p);\n \n   /* Free all the conversions we allocated.  */\n@@ -8433,7 +8489,8 @@ can_convert_arg (tree to, tree from, tree arg, int flags)\n /* Like can_convert_arg, but allows dubious conversions as well.  */\n \n bool\n-can_convert_arg_bad (tree to, tree from, tree arg, int flags)\n+can_convert_arg_bad (tree to, tree from, tree arg, int flags,\n+\t\t     tsubst_flags_t complain)\n {\n   conversion *t;\n   void *p;\n@@ -8442,7 +8499,7 @@ can_convert_arg_bad (tree to, tree from, tree arg, int flags)\n   p = conversion_obstack_alloc (0);\n   /* Try to perform the conversion.  */\n   t  = implicit_conversion (to, from, arg, /*c_cast_p=*/false,\n-\t\t\t    flags);\n+\t\t\t    flags, complain);\n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n \n@@ -8456,7 +8513,8 @@ can_convert_arg_bad (tree to, tree from, tree arg, int flags)\n    doing a bad conversion, convert_like will complain.  */\n \n tree\n-perform_implicit_conversion_flags (tree type, tree expr, tsubst_flags_t complain, int flags)\n+perform_implicit_conversion_flags (tree type, tree expr,\n+\t\t\t\t   tsubst_flags_t complain, int flags)\n {\n   conversion *conv;\n   void *p;\n@@ -8469,7 +8527,7 @@ perform_implicit_conversion_flags (tree type, tree expr, tsubst_flags_t complain\n \n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      /*c_cast_p=*/false,\n-\t\t\t      flags);\n+\t\t\t      flags, complain);\n \n   if (!conv)\n     {\n@@ -8510,7 +8568,8 @@ perform_implicit_conversion_flags (tree type, tree expr, tsubst_flags_t complain\n tree\n perform_implicit_conversion (tree type, tree expr, tsubst_flags_t complain)\n {\n-  return perform_implicit_conversion_flags (type, expr, complain, LOOKUP_IMPLICIT);\n+  return perform_implicit_conversion_flags (type, expr, complain,\n+\t\t\t\t\t    LOOKUP_IMPLICIT);\n }\n \n /* Convert EXPR to TYPE (as a direct-initialization) if that is\n@@ -8554,7 +8613,7 @@ perform_direct_initialization_if_possible (tree type,\n \n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      c_cast_p,\n-\t\t\t      LOOKUP_NORMAL);\n+\t\t\t      LOOKUP_NORMAL, complain);\n   if (!conv || conv->bad_p)\n     expr = NULL_TREE;\n   else\n@@ -8768,7 +8827,7 @@ initialize_reference (tree type, tree expr,\n   p = conversion_obstack_alloc (0);\n \n   conv = reference_binding (type, TREE_TYPE (expr), expr, /*c_cast_p=*/false,\n-\t\t\t    flags);\n+\t\t\t    flags, complain);\n   if (!conv || conv->bad_p)\n     {\n       if (complain & tf_error)"}, {"sha": "c3d1f23184be088bb4ae42f85196dc0a08ab6a60", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -1273,7 +1273,8 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n       for (parm = defparm; parm && parm != void_list_node;\n \t   parm = TREE_CHAIN (parm), i++)\n \targarray[i] = convert_default_arg (TREE_VALUE (parm),\n-\t\t\t\t\t   TREE_PURPOSE (parm), fn, i);\n+\t\t\t\t\t   TREE_PURPOSE (parm), fn, i,\n+\t\t\t\t\t   tf_warning_or_error);\n       t = build_call_a (fn, i, argarray);\n       t = fold_convert (void_type_node, t);\n       t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n@@ -1306,7 +1307,7 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n \t   parm = TREE_CHAIN (parm), i++)\n \targarray[i] = convert_default_arg (TREE_VALUE (parm),\n \t\t\t\t\t   TREE_PURPOSE (parm),\n-\t\t\t\t\t   fn, i);\n+\t\t\t\t\t   fn, i, tf_warning_or_error);\n       t = build_call_a (fn, i, argarray);\n       t = fold_convert (void_type_node, t);\n       return fold_build_cleanup_point_expr (TREE_TYPE (t), t);"}, {"sha": "e046069182c2748169392246943f087d27711b8f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -4862,11 +4862,13 @@ extern bool null_ptr_cst_p\t\t\t(tree);\n extern bool null_member_pointer_value_p\t\t(tree);\n extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n-extern tree build_user_type_conversion\t\t(tree, tree, int);\n+extern tree build_user_type_conversion\t\t(tree, tree, int,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_function_call\t\t(tree, VEC(tree,gc) **, bool, \n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_operator_new_call\t\t(tree, VEC(tree,gc) **, tree *,\n-\t\t\t\t\t\t tree *, tree *);\n+\t\t\t\t\t\t tree *, tree *,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_method_call\t\t(tree, tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tree, int, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n@@ -4878,18 +4880,21 @@ extern tree build_new_op\t\t\t(enum tree_code, int, tree,\n extern tree build_op_call\t\t\t(tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_delete_call\t\t(enum tree_code, tree, tree, bool, tree, tree);\n-extern bool can_convert\t\t\t\t(tree, tree);\n-extern bool can_convert_arg\t\t\t(tree, tree, tree, int);\n-extern bool can_convert_arg_bad\t\t\t(tree, tree, tree, int);\n+extern bool can_convert\t\t\t\t(tree, tree, tsubst_flags_t);\n+extern bool can_convert_arg\t\t\t(tree, tree, tree, int,\n+\t\t\t\t\t\t tsubst_flags_t);\n+extern bool can_convert_arg_bad\t\t\t(tree, tree, tree, int,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern bool enforce_access\t\t\t(tree, tree, tree);\n extern void push_defarg_context\t\t\t(tree);\n extern void pop_defarg_context\t\t\t(void);\n-extern tree convert_default_arg\t\t\t(tree, tree, tree, int);\n-extern tree convert_arg_to_ellipsis\t\t(tree);\n+extern tree convert_default_arg\t\t\t(tree, tree, tree, int,\n+\t\t\t\t\t\t tsubst_flags_t);\n+extern tree convert_arg_to_ellipsis\t\t(tree, tsubst_flags_t);\n extern tree build_x_va_arg\t\t\t(tree, tree);\n extern tree cxx_type_promotes_to\t\t(tree);\n extern tree type_passed_as\t\t\t(tree);\n-extern tree convert_for_arg_passing\t\t(tree, tree);\n+extern tree convert_for_arg_passing\t\t(tree, tree, tsubst_flags_t);\n extern bool is_properly_derived_from\t\t(tree, tree);\n extern tree initialize_reference\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);"}, {"sha": "3dab372a301921e68754fd67844408be198a7316", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -408,12 +408,12 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   tree rval = NULL_TREE;\n   tree rval_as_conversion = NULL_TREE;\n   bool can_convert_intype_to_type;\n+  tsubst_flags_t complain = ((flags & LOOKUP_COMPLAIN)\n+\t\t\t     ? tf_warning_or_error : tf_none);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       && TREE_TYPE (expr) == unknown_type_node)\n-    expr = instantiate_type (type, expr,\n-\t\t\t     (flags & LOOKUP_COMPLAIN)\n-\t\t\t     ? tf_warning_or_error : tf_none);\n+    expr = instantiate_type (type, expr, complain);\n \n   if (expr == error_mark_node)\n     return error_mark_node;\n@@ -425,7 +425,8 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n   intype = TYPE_MAIN_VARIANT (intype);\n \n-  can_convert_intype_to_type = can_convert (type, intype);\n+  can_convert_intype_to_type = can_convert (type, intype, complain);\n+\n   if (!can_convert_intype_to_type\n       && (convtype & CONV_IMPLICIT) && MAYBE_CLASS_TYPE_P (intype)\n       && ! (flags & LOOKUP_NO_CONVERSION))\n@@ -445,7 +446,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t}\n     }\n \n-  if (((convtype & CONV_STATIC) && can_convert (intype, type))\n+  if (((convtype & CONV_STATIC) && can_convert (intype, type, complain))\n       || ((convtype & CONV_IMPLICIT) && can_convert_intype_to_type))\n     {\n       if (flags & LOOKUP_COMPLAIN)\n@@ -821,7 +822,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t/* For copy-initialization, first we create a temp of the proper type\n \t   with a user-defined conversion sequence, then we direct-initialize\n \t   the target with the temp (see [dcl.init]).  */\n-\tctor = build_user_type_conversion (type, ctor, flags);\n+\tctor = build_user_type_conversion (type, ctor, flags,\n+\t\t\t\t\t   tf_warning_or_error);\n       else\n \t{\n \t  VEC(tree,gc) *ctor_vec = make_tree_vector_single (ctor);\n@@ -1451,7 +1453,8 @@ build_type_conversion (tree xtype, tree expr)\n {\n   /* C++: check to see if we can convert this aggregate type\n      into the required type.  */\n-  return build_user_type_conversion (xtype, expr, LOOKUP_NORMAL);\n+  return build_user_type_conversion (xtype, expr, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n }\n \n /* Convert the given EXPR to one of a group of types suitable for use in an\n@@ -1609,7 +1612,8 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n   if (winner)\n     {\n       tree type = non_reference (TREE_TYPE (TREE_TYPE (winner)));\n-      return build_user_type_conversion (type, expr, LOOKUP_NORMAL);\n+      return build_user_type_conversion (type, expr, LOOKUP_NORMAL,\n+\t\t\t\t\t tf_warning_or_error);\n     }\n \n   return NULL_TREE;"}, {"sha": "28c7cee4d90f981c836ddb326986402793335702", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -5266,7 +5266,8 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n \t valid aggregate initialization.  */\n       && !first_initializer_p\n       && (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (init))\n-\t  || can_convert_arg (type, TREE_TYPE (init), init, LOOKUP_NORMAL)))\n+\t  || can_convert_arg (type, TREE_TYPE (init), init, LOOKUP_NORMAL,\n+\t\t\t      complain)))\n     {\n       d->cur++;\n       return init;\n@@ -10602,7 +10603,8 @@ check_default_argument (tree decl, tree arg)\n      A default argument expression is implicitly converted to the\n      parameter type.  */\n   if (!TREE_TYPE (arg)\n-      || !can_convert_arg (decl_type, TREE_TYPE (arg), arg, LOOKUP_NORMAL))\n+      || !can_convert_arg (decl_type, TREE_TYPE (arg), arg, LOOKUP_NORMAL,\n+\t\t\t   tf_warning_or_error))\n     {\n       if (decl)\n \terror (\"default argument for %q#D has type %qT\","}, {"sha": "e8debb870d6626b4737cb9e4dc59c34b0948bc28", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -2381,7 +2381,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \n \t  alloc_call = build_operator_new_call (fnname, placement,\n \t\t\t\t\t\t&size, &cookie_size,\n-\t\t\t\t\t\t&alloc_fn);\n+\t\t\t\t\t\t&alloc_fn, complain);\n \t}\n     }\n "}, {"sha": "409e6b9cd52923dd4e823577dffc0c54f75a15fd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -6063,7 +6063,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t\t \"because it is of type %qT\", expr, type,\n \t\t TREE_TYPE (expr));\n \t  /* If we are just one standard conversion off, explain.  */\n-\t  if (can_convert (type, TREE_TYPE (expr)))\n+\t  if (can_convert (type, TREE_TYPE (expr), complain))\n \t    inform (input_location,\n \t\t    \"standard conversions are not allowed in this context\");\n \t  return NULL_TREE;\n@@ -15128,14 +15128,15 @@ check_non_deducible_conversion (tree parm, tree arg, int strict,\n \n   if (strict == DEDUCE_CONV)\n     {\n-      if (can_convert_arg (type, parm, NULL_TREE, flags))\n+      if (can_convert_arg (type, parm, NULL_TREE, flags,\n+\t\t\t   explain_p ? tf_warning_or_error : tf_none))\n \treturn unify_success (explain_p);\n     }\n   else if (strict != DEDUCE_EXACT)\n     {\n       if (can_convert_arg (parm, type,\n \t\t\t   TYPE_P (arg) ? NULL_TREE : arg,\n-\t\t\t   flags))\n+\t\t\t   flags, explain_p ? tf_warning_or_error : tf_none))\n \treturn unify_success (explain_p);\n     }\n "}, {"sha": "19ef5967a80c8b3130384ecb9ffb1c95742207eb", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -1,7 +1,8 @@\n /* Breadth-first and depth-first routines for\n    searching multiple-inheritance lattice for GNU C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n+   1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011,\n+   2012\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -1891,7 +1892,8 @@ check_final_overrider (tree overrider, tree basefn)\n \t    }\n \t}\n       else if (!pedantic\n-\t       && can_convert (TREE_TYPE (base_type), TREE_TYPE (over_type)))\n+\t       && can_convert (TREE_TYPE (base_type), TREE_TYPE (over_type),\n+\t\t\t       tf_warning_or_error))\n \t/* GNU extension, allow trivial pointer conversions such as\n \t   converting to void *, or qualification conversion.  */\n \t{"}, {"sha": "fb2f1bc6bbbffb9787abc77282af9bced3dcd49b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -55,8 +55,8 @@ static bool comp_except_types (tree, tree, bool);\n static bool comp_array_types (const_tree, const_tree, bool);\n static tree pointer_diff (tree, tree, tree);\n static tree get_delta_difference (tree, tree, bool, bool, tsubst_flags_t);\n-static void casts_away_constness_r (tree *, tree *);\n-static bool casts_away_constness (tree, tree);\n+static void casts_away_constness_r (tree *, tree *, tsubst_flags_t);\n+static bool casts_away_constness (tree, tree, tsubst_flags_t);\n static void maybe_warn_about_returning_address_of_local (tree);\n static tree lookup_destructor (tree, tree, tree);\n static void warn_args_num (location_t, tree, bool);\n@@ -3500,7 +3500,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t      parmval = convert_for_initialization\n \t\t(NULL_TREE, type, val, flags,\n \t\t ICR_ARGPASS, fndecl, i, complain);\n-\t      parmval = convert_for_arg_passing (type, parmval);\n+\t      parmval = convert_for_arg_passing (type, parmval, complain);\n \t    }\n \n \t  if (parmval == error_mark_node)\n@@ -3517,7 +3517,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t       types.  */\n \t    val = require_complete_type_sfinae (val, complain);\n \t  else\n-\t    val = convert_arg_to_ellipsis (val);\n+\t    val = convert_arg_to_ellipsis (val, complain);\n \n \t  VEC_replace (tree, *values, i, val);\n \t}\n@@ -3543,7 +3543,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t      tree parmval\n \t\t= convert_default_arg (TREE_VALUE (typetail),\n \t\t\t\t       TREE_PURPOSE (typetail),\n-\t\t\t\t       fndecl, i);\n+\t\t\t\t       fndecl, i, complain);\n \n \t      if (parmval == error_mark_node)\n \t\treturn -1;\n@@ -5782,7 +5782,7 @@ check_for_casting_away_constness (tree src_type, tree dest_type,\n   if (cast == CAST_EXPR && !warn_cast_qual)\n     return false;\n   \n-  if (!casts_away_constness (src_type, dest_type))\n+  if (!casts_away_constness (src_type, dest_type, complain))\n     return false;\n \n   switch (cast)\n@@ -5932,7 +5932,8 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       && DERIVED_FROM_P (intype, TREE_TYPE (type))\n       && can_convert (build_pointer_type (TYPE_MAIN_VARIANT (intype)),\n \t\t      build_pointer_type (TYPE_MAIN_VARIANT\n-\t\t\t\t\t  (TREE_TYPE (type))))\n+\t\t\t\t\t  (TREE_TYPE (type))),\n+\t\t      complain)\n       && (c_cast_p\n \t  || at_least_as_qualified_p (TREE_TYPE (type), intype)))\n     {\n@@ -6059,7 +6060,8 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       && can_convert (build_pointer_type (TYPE_MAIN_VARIANT\n \t\t\t\t\t  (TREE_TYPE (intype))),\n \t\t      build_pointer_type (TYPE_MAIN_VARIANT\n-\t\t\t\t\t  (TREE_TYPE (type)))))\n+\t\t\t\t\t  (TREE_TYPE (type))),\n+\t\t      complain))\n     {\n       tree base;\n \n@@ -6100,7 +6102,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t  t1 = intype;\n \t  t2 = type;\n \t}\n-      if (can_convert (t1, t2) || can_convert (t2, t1))\n+      if (can_convert (t1, t2, complain) || can_convert (t2, t1, complain))\n \t{\n \t  if (!c_cast_p\n \t      && check_for_casting_away_constness (intype, type,\n@@ -7301,7 +7303,8 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p,\n       tree n;\n \n       if (!force\n-\t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn, LOOKUP_NORMAL))\n+\t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn,\n+\t\t\t       LOOKUP_NORMAL, complain))\n \terror (\"invalid conversion to type %qT from type %qT\",\n \t       to_type, pfn_type);\n \n@@ -7566,7 +7569,7 @@ convert_for_assignment (tree type, tree rhs,\n      We allow bad conversions here because by the time we get to this point\n      we are committed to doing the conversion.  If we end up doing a bad\n      conversion, convert_like will complain.  */\n-  if (!can_convert_arg_bad (type, rhstype, rhs, flags))\n+  if (!can_convert_arg_bad (type, rhstype, rhs, flags, complain))\n     {\n       /* When -Wno-pmf-conversions is use, we just silently allow\n \t conversions from pointers-to-members to plain pointers.  If\n@@ -8419,7 +8422,7 @@ cp_apply_type_quals_to_decl (int type_quals, tree decl)\n    if and only if there is no implicit conversion from T1 to T2.  */\n \n static void\n-casts_away_constness_r (tree *t1, tree *t2)\n+casts_away_constness_r (tree *t1, tree *t2, tsubst_flags_t complain)\n {\n   int quals1;\n   int quals2;\n@@ -8469,7 +8472,7 @@ casts_away_constness_r (tree *t1, tree *t2)\n   else\n     *t2 = TREE_TYPE (*t2);\n \n-  casts_away_constness_r (t1, t2);\n+  casts_away_constness_r (t1, t2, complain);\n   *t1 = build_pointer_type (*t1);\n   *t2 = build_pointer_type (*t2);\n   *t1 = cp_build_qualified_type (*t1, quals1);\n@@ -8485,7 +8488,7 @@ casts_away_constness_r (tree *t1, tree *t2)\n */\n \n static bool\n-casts_away_constness (tree t1, tree t2)\n+casts_away_constness (tree t1, tree t2, tsubst_flags_t complain)\n {\n   if (TREE_CODE (t2) == REFERENCE_TYPE)\n     {\n@@ -8497,7 +8500,8 @@ casts_away_constness (tree t1, tree t2)\n \t casts away constness.  */\n       t1 = (TREE_CODE (t1) == REFERENCE_TYPE ? TREE_TYPE (t1) : t1);\n       return casts_away_constness (build_pointer_type (t1),\n-\t\t\t\t   build_pointer_type (TREE_TYPE (t2)));\n+\t\t\t\t   build_pointer_type (TREE_TYPE (t2)),\n+\t\t\t\t   complain);\n     }\n \n   if (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2))\n@@ -8510,7 +8514,8 @@ casts_away_constness (tree t1, tree t2)\n        constness.  */\n     return casts_away_constness\n       (build_pointer_type (TYPE_PTRMEM_POINTED_TO_TYPE (t1)),\n-       build_pointer_type (TYPE_PTRMEM_POINTED_TO_TYPE (t2)));\n+       build_pointer_type (TYPE_PTRMEM_POINTED_TO_TYPE (t2)),\n+       complain);\n \n   /* Casting away constness is only something that makes sense for\n      pointer or reference types.  */\n@@ -8521,8 +8526,8 @@ casts_away_constness (tree t1, tree t2)\n   /* Top-level qualifiers don't matter.  */\n   t1 = TYPE_MAIN_VARIANT (t1);\n   t2 = TYPE_MAIN_VARIANT (t2);\n-  casts_away_constness_r (&t1, &t2);\n-  if (!can_convert (t2, t1))\n+  casts_away_constness_r (&t1, &t2, complain);\n+  if (!can_convert (t2, t1, complain))\n     return true;\n \n   return false;"}, {"sha": "5f14b79cdd753189a7ecd8d360cc3d009ed176d7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -1,8 +1,14 @@\n+2012-04-24  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/52363\n+\t* g++.dg/cpp0x/sfinae35.C: New.\n+\t* g++.dg/cpp0x/sfinae36.C: Likewise.\n+\n 2012-04-24  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/47197\n \t* gcc.target/powerpc/pr47197.c: New test.\n-\t\n+\n 2012-04-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/53085"}, {"sha": "21df10cf435a0384ea064f6cd37ac93bc6b1d5e4", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae35.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae35.C?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/52363\n+// { dg-options -std=c++11 }\n+\n+#include <type_traits>\n+\n+struct proxy\n+{\n+  void operator=(int const&);\n+  void operator=(int&&) const;\n+};\n+\n+static_assert( !std::is_assignable<proxy, int>::value, \"\" );\n+static_assert( std::is_assignable<const proxy, int>::value, \"\" );"}, {"sha": "79509a1d1e2bf79f10405ad66d40e7eccd495ce8", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae36.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40e334f1fabcd0d751f8c81a3a37491e878f69f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae36.C?ref=b40e334f1fabcd0d751f8c81a3a37491e878f69f", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/52363\n+// { dg-options \"-std=c++11 -pedantic\" }\n+\n+#include <type_traits>\n+\n+struct proxy\n+{\n+  void operator=(int const&);\n+  void operator=(int&&) const;\n+};\n+\n+static_assert( !std::is_assignable<proxy, int>::value, \"\" );\n+static_assert( std::is_assignable<const proxy, int>::value, \"\" );"}]}