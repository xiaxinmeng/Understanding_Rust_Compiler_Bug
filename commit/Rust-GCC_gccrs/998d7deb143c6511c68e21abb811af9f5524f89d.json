{"sha": "998d7deb143c6511c68e21abb811af9f5524f89d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk4ZDdkZWIxNDNjNjUxMWM2OGUyMWFiYjgxMWFmOWY1NTI0Zjg5ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-12-02T19:04:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-02T19:04:23Z"}, "message": "rtl.h (mem_attrs): Rename decl to expr; adjust all users.\n\n        * rtl.h (mem_attrs): Rename decl to expr; adjust all users.\n        (MEM_EXPR): Rename from MEM_DECL; adjust all users.\n        * emit-rtl.c (set_mem_expr): Rename from set_mem_decl.\n        * expr.h, final.c, reload1.c: Adjust users.\n\n        * alias.c (nonoverlapping_component_refs_p): New.\n        (decl_for_component_ref, adjust_offset_for_component_ref): New.\n        (nonoverlapping_memrefs_p): Use them.\n        * emit-rtl.c (component_ref_for_mem_expr): New.\n        (set_mem_attributes): Use it.\n        (set_mem_offset): New.\n        * expr.c (expand_assignment): Call set_mem_attributes for\n        inner references; adjust the memory offset as needed.\n        * print-rtl.c (print_mem_expr): New.\n        (print_rtx): Use it.\n\nFrom-SVN: r47534", "tree": {"sha": "7dcf60eaed1d63b62946ca9c11cf34b2d9ceaa21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dcf60eaed1d63b62946ca9c11cf34b2d9ceaa21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/998d7deb143c6511c68e21abb811af9f5524f89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998d7deb143c6511c68e21abb811af9f5524f89d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/998d7deb143c6511c68e21abb811af9f5524f89d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998d7deb143c6511c68e21abb811af9f5524f89d/comments", "author": null, "committer": null, "parents": [{"sha": "3d55d212918e4f8853365fbf7531d30b9d88a82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d55d212918e4f8853365fbf7531d30b9d88a82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d55d212918e4f8853365fbf7531d30b9d88a82f"}], "stats": {"total": 399, "additions": 335, "deletions": 64}, "files": [{"sha": "f7c1b463d74cba80153be2725c1c3ccf29d51ad9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -1,3 +1,21 @@\n+2001-12-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (mem_attrs): Rename decl to expr; adjust all users.\n+\t(MEM_EXPR): Rename from MEM_DECL; adjust all users.\n+\t* emit-rtl.c (set_mem_expr): Rename from set_mem_decl.\n+\t* expr.h, final.c, reload1.c: Adjust users.\n+\n+\t* alias.c (nonoverlapping_component_refs_p): New.\n+\t(decl_for_component_ref, adjust_offset_for_component_ref): New.\n+\t(nonoverlapping_memrefs_p): Use them.\n+\t* emit-rtl.c (component_ref_for_mem_expr): New.\n+\t(set_mem_attributes): Use it.\n+\t(set_mem_offset): New.\n+\t* expr.c (expand_assignment): Call set_mem_attributes for \n+\tinner references; adjust the memory offset as needed.\n+\t* print-rtl.c (print_mem_expr): New.\n+\t(print_rtx): Use it.\n+\n Sun Dec  2 09:22:25 2001  Douglas B. Rupp  <rupp@gnat.com>\n \n \t* config/x-interix3 (SYSTEM_HEADER_DIR): Put back default."}, {"sha": "21563ec565e669c8e033174a5d4fc3f79e61388b", "filename": "gcc/alias.c", "status": "modified", "additions": 151, "deletions": 13, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -103,6 +103,9 @@ static alias_set_entry get_alias_set_entry PARAMS ((HOST_WIDE_INT));\n static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t      int (*) (rtx, int)));\n static int aliases_everything_p         PARAMS ((rtx));\n+static bool nonoverlapping_component_refs_p PARAMS ((tree, tree));\n+static tree decl_for_component_ref\tPARAMS ((tree));\n+static rtx adjust_offset_for_component_ref PARAMS ((tree, rtx));\n static int nonoverlapping_memrefs_p\tPARAMS ((rtx, rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n static int nonlocal_mentioned_p         PARAMS ((rtx));\n@@ -1736,23 +1739,158 @@ aliases_everything_p (mem)\n   return 0;\n }\n \n-/* Return nonzero if we can deterimine the decls corresponding to memrefs\n+/* Return true if we can determine that the fields referenced cannot\n+   overlap for any pair of objects.  */\n+\n+static bool\n+nonoverlapping_component_refs_p (x, y)\n+     tree x, y;\n+{\n+  tree fieldx, fieldy, typex, typey, orig_y;\n+\n+  do\n+    {\n+      /* The comparison has to be done at a common type, since we don't\n+\t know how the inheritance heirarchy works.  */\n+      orig_y = y;\n+      do\n+\t{\n+\t  fieldx = TREE_OPERAND (x, 1);\n+\t  typex = DECL_FIELD_CONTEXT (fieldx);\n+\n+\t  y = orig_y;\n+\t  do\n+\t    {\n+\t      fieldy = TREE_OPERAND (y, 1);\n+\t      typey = DECL_FIELD_CONTEXT (fieldy);\n+\n+\t      if (typex == typey)\n+\t\tgoto found;\n+\n+\t      y = TREE_OPERAND (y, 0);\n+\t    }\n+\t  while (y && TREE_CODE (y) == COMPONENT_REF);\n+\n+\t  x = TREE_OPERAND (x, 0);\n+\t}\n+      while (x && TREE_CODE (x) == COMPONENT_REF);\n+\n+      /* Never found a common type.  */\n+      return false;\n+\n+    found:\n+      /* If we're left with accessing different fields of a structure,\n+\t then no overlap.  */\n+      if (TREE_CODE (typex) == RECORD_TYPE\n+\t  && fieldx != fieldy)\n+\treturn true;\n+\n+      /* The comparison on the current field failed.  If we're accessing\n+\t a very nested structure, look at the next outer level.  */\n+      x = TREE_OPERAND (x, 0);\n+      y = TREE_OPERAND (y, 0);\n+    }\n+  while (x && y\n+\t && TREE_CODE (x) == COMPONENT_REF\n+\t && TREE_CODE (y) == COMPONENT_REF);\n+  \n+  return false;\n+}\n+\n+/* Look at the bottom of the COMPONENT_REF list for a DECL, and return it.  */\n+\n+static tree\n+decl_for_component_ref (x)\n+     tree x;\n+{\n+  do\n+    {\n+      x = TREE_OPERAND (x, 0);\n+    }\n+  while (x && TREE_CODE (x) == COMPONENT_REF);\n+\n+  return x && DECL_P (x) ? x : NULL_TREE;\n+}\n+\n+/* Walk up the COMPONENT_REF list and adjust OFFSET to compensate for the\n+   offset of the field reference.  */\n+\n+static rtx\n+adjust_offset_for_component_ref (x, offset)\n+     tree x;\n+     rtx offset;\n+{\n+  HOST_WIDE_INT ioffset;\n+\n+  if (! offset)\n+    return NULL_RTX;\n+\n+  ioffset = INTVAL (offset);\n+  do \n+    {\n+      tree field = TREE_OPERAND (x, 1);\n+\n+      if (! host_integerp (DECL_FIELD_OFFSET (field), 1))\n+\treturn NULL_RTX;\n+      ioffset += (tree_low_cst (DECL_FIELD_OFFSET (field), 1)\n+\t\t  + (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n+\t\t     / BITS_PER_UNIT));\n+\n+      x = TREE_OPERAND (x, 0);\n+    }\n+  while (x && TREE_CODE (x) == COMPONENT_REF);\n+\n+  return GEN_INT (ioffset);\n+}\n+\n+/* Return nonzero if we can deterimine the exprs corresponding to memrefs\n    X and Y and they do not overlap.  */\n \n static int\n nonoverlapping_memrefs_p (x, y)\n      rtx x, y;\n {\n+  tree exprx = MEM_EXPR (x), expry = MEM_EXPR (y);\n   rtx rtlx, rtly;\n   rtx basex, basey;\n+  rtx moffsetx, moffsety;\n   HOST_WIDE_INT offsetx = 0, offsety = 0, sizex, sizey, tem;\n \n-  /* Unless both have decls, we can't tell anything.  */\n-  if (MEM_DECL (x) == 0 || MEM_DECL (y) == 0)\n+  /* Unless both have exprs, we can't tell anything.  */\n+  if (exprx == 0 || expry == 0)\n+    return 0;\n+\n+  /* If both are field references, we may be able to determine something.  */\n+  if (TREE_CODE (exprx) == COMPONENT_REF\n+      && TREE_CODE (expry) == COMPONENT_REF\n+      && nonoverlapping_component_refs_p (exprx, expry))\n+    return 1;\n+\n+  /* If the field reference test failed, look at the DECLs involved.  */\n+  moffsetx = MEM_OFFSET (x);\n+  if (TREE_CODE (exprx) == COMPONENT_REF)\n+    {\n+      tree t = decl_for_component_ref (exprx);\n+      if (! t)\n+\treturn 0;\n+      moffsetx = adjust_offset_for_component_ref (exprx, moffsetx);\n+      exprx = t;\n+    }\n+  moffsety = MEM_OFFSET (y);\n+  if (TREE_CODE (expry) == COMPONENT_REF)\n+    {\n+      tree t = decl_for_component_ref (expry);\n+      if (! t)\n+\treturn 0;\n+      moffsety = adjust_offset_for_component_ref (expry, moffsety);\n+      expry = t;\n+    }\n+\n+  if (! DECL_P (exprx) || ! DECL_P (expry))\n     return 0;\n \n-  rtlx = DECL_RTL (MEM_DECL (x));\n-  rtly = DECL_RTL (MEM_DECL (y));\n+  rtlx = DECL_RTL (exprx);\n+  rtly = DECL_RTL (expry);\n \n   /* If either RTL is not a MEM, it must be a REG or CONCAT, meaning they\n      can't overlap unless they are the same because we never reuse that part\n@@ -1784,26 +1922,26 @@ nonoverlapping_memrefs_p (x, y)\n \t      || (CONSTANT_P (basey) && REG_P (basex)\n \t\t  && REGNO_PTR_FRAME_P (REGNO (basex))));\n \n-  sizex = (GET_CODE (rtlx) != MEM ? GET_MODE_SIZE (GET_MODE (rtlx))\n+  sizex = (GET_CODE (rtlx) != MEM ? (int) GET_MODE_SIZE (GET_MODE (rtlx))\n \t   : MEM_SIZE (rtlx) ? INTVAL (MEM_SIZE (rtlx))\n \t   : -1);\n-  sizey = (GET_CODE (rtly) != MEM ? GET_MODE_SIZE (GET_MODE (rtly))\n+  sizey = (GET_CODE (rtly) != MEM ? (int) GET_MODE_SIZE (GET_MODE (rtly))\n \t   : MEM_SIZE (rtly) ? INTVAL (MEM_SIZE (rtly)) :\n \t   -1);\n \n   /* If we have an offset for either memref, it can update the values computed\n      above.  */\n-  if (MEM_OFFSET (x))\n-    offsetx += INTVAL (MEM_OFFSET (x)), sizex -= INTVAL (MEM_OFFSET (x));\n-  if (MEM_OFFSET (y))\n-    offsety += INTVAL (MEM_OFFSET (y)), sizey -= INTVAL (MEM_OFFSET (y));\n+  if (moffsetx)\n+    offsetx += INTVAL (moffsetx), sizex -= INTVAL (moffsetx);\n+  if (moffsety)\n+    offsety += INTVAL (moffsety), sizey -= INTVAL (moffsety);\n \n   /* If a memref has both a size and an offset, we can use the smaller size.\n      We can't do this if the offset isn't known because we must view this\n      memref as being anywhere inside the DECL's MEM.  */\n-  if (MEM_SIZE (x) && MEM_OFFSET (x))\n+  if (MEM_SIZE (x) && moffsetx)\n     sizex = INTVAL (MEM_SIZE (x));\n-  if (MEM_SIZE (y) && MEM_OFFSET (y))\n+  if (MEM_SIZE (y) && moffsety)\n     sizey = INTVAL (MEM_SIZE (y));\n \n   /* Put the values of the memref with the lower offset in X's values.  */"}, {"sha": "d25e5496c88089ff4f63d77d6f07463fa33ad09b", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 92, "deletions": 20, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -195,6 +195,7 @@ static void mem_attrs_mark\t\tPARAMS ((const void *));\n static mem_attrs *get_mem_attrs\t\tPARAMS ((HOST_WIDE_INT, tree, rtx,\n \t\t\t\t\t\t rtx, unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n+static tree component_ref_for_mem_expr\tPARAMS ((tree));\n \n /* Probability of the conditional branch currently proceeded by try_split.\n    Set to -1 otherwise.  */\n@@ -232,7 +233,7 @@ mem_attrs_htab_hash (x)\n   return (p->alias ^ (p->align * 1000)\n \t  ^ ((p->offset ? INTVAL (p->offset) : 0) * 50000)\n \t  ^ ((p->size ? INTVAL (p->size) : 0) * 2500000)\n-\t  ^ (long) p->decl);\n+\t  ^ (size_t) p->expr);\n }\n \n /* Returns non-zero if the value represented by X (which is really a\n@@ -247,7 +248,7 @@ mem_attrs_htab_eq (x, y)\n   mem_attrs *p = (mem_attrs *) x;\n   mem_attrs *q = (mem_attrs *) y;\n \n-  return (p->alias == q->alias && p->decl == q->decl && p->offset == q->offset\n+  return (p->alias == q->alias && p->expr == q->expr && p->offset == q->offset\n \t  && p->size == q->size && p->align == q->align);\n }\n \n@@ -260,8 +261,8 @@ mem_attrs_mark (x)\n {\n   mem_attrs *p = (mem_attrs *) x;\n \n-  if (p->decl)\n-    ggc_mark_tree (p->decl);\n+  if (p->expr)\n+    ggc_mark_tree (p->expr);\n \n   if (p->offset)\n     ggc_mark_rtx (p->offset);\n@@ -275,9 +276,9 @@ mem_attrs_mark (x)\n    MEM of mode MODE.  */\n \n static mem_attrs *\n-get_mem_attrs (alias, decl, offset, size, align, mode)\n+get_mem_attrs (alias, expr, offset, size, align, mode)\n      HOST_WIDE_INT alias;\n-     tree decl;\n+     tree expr;\n      rtx offset;\n      rtx size;\n      unsigned int align;\n@@ -287,15 +288,15 @@ get_mem_attrs (alias, decl, offset, size, align, mode)\n   void **slot;\n \n   /* If everything is the default, we can just return zero.  */\n-  if (alias == 0 && decl == 0 && offset == 0\n+  if (alias == 0 && expr == 0 && offset == 0\n       && (size == 0\n \t  || (mode != BLKmode && GET_MODE_SIZE (mode) == INTVAL (size)))\n       && (align == BITS_PER_UNIT\n \t  || (mode != BLKmode && align == GET_MODE_ALIGNMENT (mode))))\n     return 0;\n \n   attrs.alias = alias;\n-  attrs.decl = decl;\n+  attrs.expr = expr;\n   attrs.offset = offset;\n   attrs.size = size;\n   attrs.align = align;\n@@ -1636,6 +1637,26 @@ reverse_comparison (insn)\n     }\n }\n \f\n+/* Within a MEM_EXPR, we care about either (1) a component ref of a decl,\n+   or (2) a component ref of something variable.  Represent the later with\n+   a NULL expression.  */\n+\n+static tree\n+component_ref_for_mem_expr (ref)\n+     tree ref;\n+{\n+  tree inner = TREE_OPERAND (ref, 0);\n+\n+  if (TREE_CODE (inner) == COMPONENT_REF)\n+    inner = component_ref_for_mem_expr (inner);\n+  else if (! DECL_P (inner))\n+    inner = NULL_TREE;\n+\n+  if (inner == TREE_OPERAND (ref, 0))\n+    return ref;\n+  else\n+    return build (COMPONENT_REF, TREE_TYPE (ref), inner, TREE_OPERAND (ref, 1));\n+}\n \n /* Given REF, a MEM, and T, either the type of X or the expression\n    corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n@@ -1648,7 +1669,7 @@ set_mem_attributes (ref, t, objectp)\n      int objectp;\n {\n   HOST_WIDE_INT alias = MEM_ALIAS_SET (ref);\n-  tree decl = MEM_DECL (ref);\n+  tree expr = MEM_EXPR (ref);\n   rtx offset = MEM_OFFSET (ref);\n   rtx size = MEM_SIZE (ref);\n   unsigned int align = MEM_ALIGN (ref);\n@@ -1716,8 +1737,8 @@ set_mem_attributes (ref, t, objectp)\n       /* If this is a decl, set the attributes of the MEM from it.  */\n       if (DECL_P (t))\n \t{\n-\t  decl = t;\n-\t  offset = GEN_INT (0);\n+\t  expr = t;\n+\t  offset = const0_rtx;\n \t  size = (DECL_SIZE_UNIT (t)\n \t\t  && host_integerp (DECL_SIZE_UNIT (t), 1)\n \t\t  ? GEN_INT (tree_low_cst (DECL_SIZE_UNIT (t), 1)) : 0);\n@@ -1732,11 +1753,51 @@ set_mem_attributes (ref, t, objectp)\n \t  align = CONSTANT_ALIGNMENT (t, align);\n #endif\n \t}\n+\n+      /* If this is a field reference and not a bit-field, record it.  */\n+      /* ??? There is some information that can be gleened from bit-fields,\n+\t such as the word offset in the structure that might be modified.\n+\t But skip it for now.  */\n+      else if (TREE_CODE (t) == COMPONENT_REF\n+\t       && ! DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n+\t{\n+\t  expr = component_ref_for_mem_expr (t);\n+\t  offset = const0_rtx;\n+\t  /* ??? Any reason the field size would be different than\n+\t     the size we got from the type?  */\n+\t}\n+\n+      /* If this is an array reference, look for an outer field reference.  */\n+      else if (TREE_CODE (t) == ARRAY_REF)\n+\t{\n+\t  tree off_tree = size_zero_node;\n+\n+\t  do\n+\t    {\n+\t      off_tree\n+\t\t= fold (build (PLUS_EXPR, sizetype,\n+\t\t\t       fold (build (MULT_EXPR, sizetype,\n+\t\t\t\t\t    TREE_OPERAND (t, 1),\n+\t\t\t\t\t    TYPE_SIZE_UNIT (TREE_TYPE (t)))),\n+\t\t\t       off_tree));\n+\t      t = TREE_OPERAND (t, 0);\n+\t    }\n+\t  while (TREE_CODE (t) == ARRAY_REF);\n+\n+\t  if (TREE_CODE (t) == COMPONENT_REF)\n+\t    {\n+\t      expr = component_ref_for_mem_expr (t);\n+\t      if (host_integerp (off_tree, 1))\n+\t\toffset = GEN_INT (tree_low_cst (off_tree, 1));\n+\t      /* ??? Any reason the field size would be different than\n+\t\t the size we got from the type?  */\n+\t    }\n+\t}\n     }\n \n   /* Now set the attributes we computed above.  */\n   MEM_ATTRS (ref)\n-    = get_mem_attrs (alias, decl, offset, size, align, GET_MODE (ref));\n+    = get_mem_attrs (alias, expr, offset, size, align, GET_MODE (ref));\n \n   /* If this is already known to be a scalar or aggregate, we are done.  */\n   if (MEM_IN_STRUCT_P (ref) || MEM_SCALAR_P (ref))\n@@ -1763,7 +1824,7 @@ set_mem_alias_set (mem, set)\n     abort ();\n #endif\n \n-  MEM_ATTRS (mem) = get_mem_attrs (set, MEM_DECL (mem), MEM_OFFSET (mem),\n+  MEM_ATTRS (mem) = get_mem_attrs (set, MEM_EXPR (mem), MEM_OFFSET (mem),\n \t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem),\n \t\t\t\t   GET_MODE (mem));\n }\n@@ -1775,22 +1836,33 @@ set_mem_align (mem, align)\n      rtx mem;\n      unsigned int align;\n {\n-  MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_DECL (mem),\n+  MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n \t\t\t\t   MEM_OFFSET (mem), MEM_SIZE (mem), align,\n \t\t\t\t   GET_MODE (mem));\n }\n \n-/* Set the decl for MEM to DECL.  */\n+/* Set the expr for MEM to EXPR.  */\n \n void\n-set_mem_decl (mem, decl)\n+set_mem_expr (mem, expr)\n      rtx mem;\n-     tree decl;\n+     tree expr;\n {\n   MEM_ATTRS (mem)\n-    = get_mem_attrs (MEM_ALIAS_SET (mem), decl, MEM_OFFSET (mem),\n+    = get_mem_attrs (MEM_ALIAS_SET (mem), expr, MEM_OFFSET (mem),\n \t\t     MEM_SIZE (mem), MEM_ALIGN (mem), GET_MODE (mem));\n }\n+\n+/* Set the offset of MEM to OFFSET.  */\n+\n+void\n+set_mem_offset (mem, offset)\n+     rtx mem, offset;\n+{\n+  MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n+\t\t\t\t   offset, MEM_SIZE (mem), MEM_ALIGN (mem),\n+\t\t\t\t   GET_MODE (mem));\n+}\n \f\n /* Return a memory reference like MEMREF, but with its mode changed to MODE\n    and its address changed to ADDR.  (VOIDmode means don't change the mode.\n@@ -1907,7 +1979,7 @@ adjust_address_1 (memref, mode, offset, validate, adjust)\n   else if (MEM_SIZE (memref))\n     size = plus_constant (MEM_SIZE (memref), -offset);\n \n-  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref),\n+  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref),\n \t\t\t\t   memoffset, size, memalign, GET_MODE (new));\n \n   /* At some point, we should validate that this offset is within the object,\n@@ -1948,7 +2020,7 @@ offset_address (memref, offset, pow2)\n \n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */\n-  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref),\n+  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref),\n \t\t\t\t   0, 0, MIN (MEM_ALIGN (memref),\n \t\t\t\t\t      pow2 * BITS_PER_UNIT),\n \t\t\t\t   GET_MODE (new));"}, {"sha": "659ff032db4f2f48ed3b8194fd22f32ca7a9fdc5", "filename": "gcc/expr.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -3603,7 +3603,6 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t    }\n \n \t  emit_move_insn (dest, x);\n-\n \t}\n \n       if (current_function_check_memory_usage && ! in_check_memory_usage)\n@@ -3768,6 +3767,26 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t\t\t\t   highest_pow2_factor (offset));\n \t}\n \n+      if (GET_CODE (to_rtx) == MEM)\n+\t{\n+\t  tree old_expr = MEM_EXPR (to_rtx);\n+\n+\t  /* If the field is at offset zero, we could have been given the\n+\t     DECL_RTX of the parent struct.  Don't munge it.  */\n+\t  to_rtx = shallow_copy_rtx (to_rtx);\n+\n+\t  set_mem_attributes (to_rtx, to, 0);\n+\n+\t  /* If we changed MEM_EXPR, that means we're now referencing\n+\t     the COMPONENT_REF, which means that MEM_OFFSET must be\n+\t     relative to that field.  But we've not yet reflected BITPOS\n+\t     in TO_RTX.  This will be done in store_field.  Adjust for\n+\t     that by biasing MEM_OFFSET by -bitpos.  */\n+\t  if (MEM_EXPR (to_rtx) != old_expr && MEM_OFFSET (to_rtx)\n+\t      && (bitpos / BITS_PER_UNIT) != 0)\n+\t    set_mem_offset (to_rtx, GEN_INT (INTVAL (MEM_OFFSET (to_rtx))\n+\t\t\t\t\t     - (bitpos / BITS_PER_UNIT)));\n+\t}\n \n       /* Deal with volatile and readonly fields.  The former is only done\n \t for MEM.  Also set MEM_KEEP_ALIAS_SET_P if needed.  */"}, {"sha": "aa4bde69fdb14fc77a3a9507f7c93516f7d196c7", "filename": "gcc/expr.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -614,8 +614,11 @@ extern void set_mem_alias_set PARAMS ((rtx, HOST_WIDE_INT));\n /* Set the alignment of MEM to ALIGN bits.  */\n extern void set_mem_align PARAMS ((rtx, unsigned int));\n \n-/* Set the DECL for MEM to DECL.  */\n-extern void set_mem_decl PARAMS ((rtx, tree));\n+/* Set the expr for MEM to EXPR.  */\n+extern void set_mem_expr PARAMS ((rtx, tree));\n+\n+/* Set the offset for MEM to OFFSET.  */\n+extern void set_mem_offset PARAMS ((rtx, rtx));\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR."}, {"sha": "158da0b858bd6c527230e9d1507d14a09201e227", "filename": "gcc/final.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -245,7 +245,7 @@ static int add_bb_string\tPARAMS ((const char *, int));\n static void notice_source_line\tPARAMS ((rtx));\n static rtx walk_alter_subreg\tPARAMS ((rtx *));\n static void output_asm_name\tPARAMS ((void));\n-static tree get_decl_from_op\tPARAMS ((rtx, int *));\n+static tree get_mem_expr_from_op\tPARAMS ((rtx, int *));\n static void output_asm_operand_names PARAMS ((rtx *, int *, int));\n static void output_operand\tPARAMS ((rtx, int));\n #ifdef LEAF_REGISTERS\n@@ -3302,16 +3302,16 @@ output_asm_name ()\n     }\n }\n \n-/* If OP is a REG or MEM and we can find a decl corresponding to it or\n-   its address, return that decl.  Set *PADDRESSP to 1 if the decl\n+/* If OP is a REG or MEM and we can find a MEM_EXPR corresponding to it\n+   or its address, return that expr .  Set *PADDRESSP to 1 if the expr\n    corresponds to the address of the object and 0 if to the object.  */\n \n static tree\n-get_decl_from_op (op, paddressp)\n+get_mem_expr_from_op (op, paddressp)\n      rtx op;\n      int *paddressp;\n {\n-  tree decl;\n+  tree expr;\n   int inner_addressp;\n \n   *paddressp = 0;\n@@ -3321,8 +3321,8 @@ get_decl_from_op (op, paddressp)\n   else if (GET_CODE (op) != MEM)\n     return 0;\n \n-  if (MEM_DECL (op) != 0)\n-    return MEM_DECL (op);\n+  if (MEM_EXPR (op) != 0)\n+    return MEM_EXPR (op);\n \n   /* Otherwise we have an address, so indicate it and look at the address.  */\n   *paddressp = 1;\n@@ -3331,18 +3331,18 @@ get_decl_from_op (op, paddressp)\n   /* First check if we have a decl for the address, then look at the right side\n      if it is a PLUS.  Otherwise, strip off arithmetic and keep looking.\n      But don't allow the address to itself be indirect.  */\n-  if ((decl = get_decl_from_op (op, &inner_addressp)) && ! inner_addressp)\n-    return decl;\n+  if ((expr = get_mem_expr_from_op (op, &inner_addressp)) && ! inner_addressp)\n+    return expr;\n   else if (GET_CODE (op) == PLUS\n-\t   && (decl = get_decl_from_op (XEXP (op, 1), &inner_addressp)))\n-    return decl;\n+\t   && (expr = get_mem_expr_from_op (XEXP (op, 1), &inner_addressp)))\n+    return expr;\n \n   while (GET_RTX_CLASS (GET_CODE (op)) == '1'\n \t || GET_RTX_CLASS (GET_CODE (op)) == '2')\n     op = XEXP (op, 0);\n \n-  decl = get_decl_from_op (op, &inner_addressp);\n-  return inner_addressp ? 0 : decl;\n+  expr = get_mem_expr_from_op (op, &inner_addressp);\n+  return inner_addressp ? 0 : expr;\n }\n   \n /* Output operand names for assembler instructions.  OPERANDS is the\n@@ -3361,13 +3361,14 @@ output_asm_operand_names (operands, oporder, nops)\n   for (i = 0; i < nops; i++)\n     {\n       int addressp;\n-      tree decl = get_decl_from_op (operands[oporder[i]], &addressp);\n+      tree expr = get_mem_expr_from_op (operands[oporder[i]], &addressp);\n \n-      if (decl && DECL_NAME (decl))\n+      if (expr)\n \t{\n-\t  fprintf (asm_out_file, \"%c%s %s%s\",\n+\t  fprintf (asm_out_file, \"%c%s %s\",\n \t\t   wrote ? ',' : '\\t', wrote ? \"\" : ASM_COMMENT_START,\n-\t\t   addressp ? \"*\" : \"\", IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t\t   addressp ? \"*\" : \"\");\n+\t  print_mem_expr (asm_out_file, expr);\n \t  wrote = 1;\n \t}\n     }"}, {"sha": "b819d143a340c88d89b7d916bfa97ec239d29369", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -77,6 +77,28 @@ int dump_for_graph;\n /* Nonzero to dump all call_placeholder alternatives.  */\n static int debug_call_placeholder_verbose;\n \n+void\n+print_mem_expr (outfile, expr)\n+     FILE *outfile;\n+     tree expr;\n+{\n+  if (TREE_CODE (expr) == COMPONENT_REF)\n+    {\n+      if (TREE_OPERAND (expr, 0))\n+        print_mem_expr (outfile, TREE_OPERAND (expr, 0));\n+      else\n+\tfputs (\" <variable>\", outfile);\n+      fprintf (outfile, \".%s\",\n+\t       IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (expr, 1))));\n+    }\n+  else if (DECL_NAME (expr))\n+    fprintf (outfile, \" %s\", IDENTIFIER_POINTER (DECL_NAME (expr)));\n+  else if (TREE_CODE (expr) == RESULT_DECL)\n+    fputs (\" <result>\", outfile);\n+  else\n+    fputs (\" <anonymous>\", outfile);\n+}\n+\n /* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n \n static void\n@@ -456,12 +478,9 @@ print_rtx (in_rtx)\n     case MEM:\n       fputs (\" [\", outfile);\n       fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, MEM_ALIAS_SET (in_rtx));\n-      if (MEM_DECL (in_rtx))\n-\tfprintf (outfile, \" %s\",\n-\t\t DECL_NAME (MEM_DECL (in_rtx))\n-\t\t ? IDENTIFIER_POINTER (DECL_NAME (MEM_DECL (in_rtx)))\n-\t\t : TREE_CODE (MEM_DECL (in_rtx)) == RESULT_DECL ? \"<result>\"\n-\t\t : \"<anonymous>\");\n+\n+      if (MEM_EXPR (in_rtx))\n+\tprint_mem_expr (outfile, MEM_EXPR (in_rtx));\n \n       if (MEM_OFFSET (in_rtx))\n \t{"}, {"sha": "58019b042066268a2199c4f42a6a964b99f9db71", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -2059,7 +2059,7 @@ alter_reg (i, from_reg)\n \t  if (from_reg != -1 && spill_stack_slot[from_reg] == x)\n \t    x = copy_rtx (x);\n \n-\t  set_mem_decl (x, REGNO_DECL (i));\n+\t  set_mem_expr (x, REGNO_DECL (i));\n \t}\n \n       /* Save the stack slot for later.  */"}, {"sha": "baafcdce2b50ac238b842c213ee54768030cb51f", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d7deb143c6511c68e21abb811af9f5524f89d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=998d7deb143c6511c68e21abb811af9f5524f89d", "patch": "@@ -92,7 +92,7 @@ typedef struct\n typedef struct\n {\n   HOST_WIDE_INT alias;\t\t/* Memory alias set.  */\n-  tree decl;\t\t\t/* decl corresponding to MEM.  */\n+  tree expr;\t\t\t/* expr corresponding to MEM.  */\n   rtx offset;\t\t\t/* Offset from start of DECL, as CONST_INT.  */\n   rtx size;\t\t\t/* Size in bytes, as a CONST_INT.  */\n   unsigned int align;\t\t/* Alignment of MEM in bits.  */\n@@ -904,10 +904,10 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n #define MEM_ALIAS_SET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->alias)\n \n /* For a MEM rtx, the decl it is known to refer to, if it is known to\n-   refer to part of a DECL.  */\n-#define MEM_DECL(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->decl)\n+   refer to part of a DECL.  It may also be a COMPONENT_REF.  */\n+#define MEM_EXPR(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->expr)\n \n-/* For a MEM rtx, the offset from the start of MEM_DECL, if known, as a\n+/* For a MEM rtx, the offset from the start of MEM_EXPR, if known, as a\n    RTX that is always a CONST_INT.  */\n #define MEM_OFFSET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->offset)\n \n@@ -1865,6 +1865,7 @@ extern void debug_rtx_list\t\tPARAMS ((rtx, int));\n extern void debug_rtx_range\t\tPARAMS ((rtx, rtx));\n extern rtx debug_rtx_find\t\tPARAMS ((rtx, int));\n #ifdef BUFSIZ\n+extern void print_mem_expr\t\tPARAMS ((FILE *, tree));\n extern void print_rtl\t\t\tPARAMS ((FILE *, rtx));\n extern void print_simple_rtl\t\tPARAMS ((FILE *, rtx));\n extern int print_rtl_single\t\tPARAMS ((FILE *, rtx));"}]}