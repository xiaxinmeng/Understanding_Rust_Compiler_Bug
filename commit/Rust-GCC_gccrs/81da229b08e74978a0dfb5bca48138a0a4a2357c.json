{"sha": "81da229b08e74978a0dfb5bca48138a0a4a2357c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFkYTIyOWIwOGU3NDk3OGEwZGZiNWJjYTQ4MTM4YTBhNGEyMzU3Yw==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-10-14T00:34:01Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-10-14T00:34:01Z"}, "message": "c-tree.h (enum c_typespec_kind, [...]): New.\n\n\t* c-tree.h (enum c_typespec_kind, struct c_typespec,\n\tparser_xref_tag): New.\n\t(struct c_declspecs): Add tag_defined_p.  Adjust definition of\n\ttypedef_p.\n\t(declspecs_add_type): Adjust prototypes.\n\t* c-parse.in (%union): Add tstype.\n\t(typespec_nonattr, typespec_attr, typespec_reserved_nonattr,\n\ttypespec_reserved_attr, typespec_nonreserved_nonattr,\n\tstructsp_attr, structsp_nonattr): Change to tstype.  Update\n\tactions.\n\t* c-decl.c (build_null_declspecs): Initialize tag_defined_p.\n\t(declspecs_add_type): Update to take struct c_typespec argument.\n\tSet tag_defined_p and typedef_p as appropriate.\n\t(xref_tag): Rename to parser_xref_tag and replace by wrapper.\n\tUpdate to return struct c_typespec.\n\t(shadow_tag_warned): Don't let empty declarations with qualifiers\n\tor storage class specifiers redeclare a tag if a previous\n\tdeclaration is visible.\n\ntestsuite:\n\t* gcc.dg/c99-tag-3.c, gcc.dg/declspec-14.c: New tests.\n\nFrom-SVN: r89021", "tree": {"sha": "d480ea1c4408842eab54602e3d430ca39cc2a0b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d480ea1c4408842eab54602e3d430ca39cc2a0b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81da229b08e74978a0dfb5bca48138a0a4a2357c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81da229b08e74978a0dfb5bca48138a0a4a2357c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81da229b08e74978a0dfb5bca48138a0a4a2357c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81da229b08e74978a0dfb5bca48138a0a4a2357c/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "599a049f76abea81f4e5534520529aa9f5fadf0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599a049f76abea81f4e5534520529aa9f5fadf0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599a049f76abea81f4e5534520529aa9f5fadf0d"}], "stats": {"total": 292, "additions": 246, "deletions": 46}, "files": [{"sha": "465b25d3e29ace259e82e6436e2a51d49db1afa1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81da229b08e74978a0dfb5bca48138a0a4a2357c", "patch": "@@ -1,3 +1,24 @@\n+2004-10-14  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-tree.h (enum c_typespec_kind, struct c_typespec,\n+\tparser_xref_tag): New.\n+\t(struct c_declspecs): Add tag_defined_p.  Adjust definition of\n+\ttypedef_p.\n+\t(declspecs_add_type): Adjust prototypes.\n+\t* c-parse.in (%union): Add tstype.\n+\t(typespec_nonattr, typespec_attr, typespec_reserved_nonattr,\n+\ttypespec_reserved_attr, typespec_nonreserved_nonattr,\n+\tstructsp_attr, structsp_nonattr): Change to tstype.  Update\n+\tactions.\n+\t* c-decl.c (build_null_declspecs): Initialize tag_defined_p.\n+\t(declspecs_add_type): Update to take struct c_typespec argument.\n+\tSet tag_defined_p and typedef_p as appropriate.\n+\t(xref_tag): Rename to parser_xref_tag and replace by wrapper.\n+\tUpdate to return struct c_typespec.\n+\t(shadow_tag_warned): Don't let empty declarations with qualifiers\n+\tor storage class specifiers redeclare a tag if a previous\n+\tdeclaration is visible.\n+\n 2004-10-13  Richard Henderson  <rth@redhat.com>\n \n \tPR debug/15860"}, {"sha": "30a154cd9961cd1f228bcd590e5260a25d861924", "filename": "gcc/c-decl.c", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=81da229b08e74978a0dfb5bca48138a0a4a2357c", "patch": "@@ -2696,8 +2696,6 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n {\n   bool found_tag = false;\n \n-  pending_invalid_xref = 0;\n-\n   if (declspecs->type && !declspecs->default_int_p && !declspecs->typedef_p)\n     {\n       tree value = declspecs->type;\n@@ -2721,8 +2719,29 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t\t  warned = 1;\n \t\t}\n \t    }\n+\t  else if (!declspecs->tag_defined_p\n+\t\t   && declspecs->storage_class != csc_none)\n+\t    {\n+\t      if (warned != 1)\n+\t\tpedwarn (\"empty declaration with storage class specifier \"\n+\t\t\t \"does not redeclare tag\");\n+\t      warned = 1;\n+\t      pending_xref_error ();\n+\t    }\n+\t  else if (!declspecs->tag_defined_p\n+\t\t   && (declspecs->const_p\n+\t\t       || declspecs->volatile_p\n+\t\t       || declspecs->restrict_p))\n+\t    {\n+\t      if (warned != 1)\n+\t\tpedwarn (\"empty declaration with type qualifier \"\n+\t\t\t \"does not redeclare tag\");\n+\t      warned = 1;\n+\t      pending_xref_error ();\n+\t    }\n \t  else\n \t    {\n+\t      pending_invalid_xref = 0;\n \t      t = lookup_tag (code, name, 1);\n \n \t      if (t == 0)\n@@ -2747,6 +2766,8 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 1;\n     }\n \n+  pending_invalid_xref = 0;\n+\n   if (declspecs->inline_p)\n     {\n       error (\"%<inline%> in empty declaration\");\n@@ -4877,11 +4898,13 @@ get_parm_info (bool ellipsis)\n }\n \f\n /* Get the struct, enum or union (CODE says which) with tag NAME.\n-   Define the tag as a forward-reference if it is not defined.  */\n+   Define the tag as a forward-reference if it is not defined.\n+   Return a c_typespec structure for the type specifier.  */\n \n-tree\n-xref_tag (enum tree_code code, tree name)\n+struct c_typespec\n+parser_xref_tag (enum tree_code code, tree name)\n {\n+  struct c_typespec ret;\n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n \n@@ -4897,8 +4920,12 @@ xref_tag (enum tree_code code, tree name)\n      this would not work properly if we return the reference found.\n      (For example, with \"struct foo\" in an outer scope, \"union foo;\"\n      must shadow that tag with a new one of union type.)  */\n+  ret.kind = (ref ? ctsk_tagref : ctsk_tagfirstref);\n   if (ref && TREE_CODE (ref) == code)\n-    return ref;\n+    {\n+      ret.spec = ref;\n+      return ret;\n+    }\n \n   /* If no such tag is yet defined, create a forward-reference node\n      and record it as the \"definition\".\n@@ -4921,7 +4948,18 @@ xref_tag (enum tree_code code, tree name)\n \n   pushtag (name, ref);\n \n-  return ref;\n+  ret.spec = ref;\n+  return ret;\n+}\n+\n+/* Get the struct, enum or union (CODE says which) with tag NAME.\n+   Define the tag as a forward-reference if it is not defined.\n+   Return a tree for the type.  */\n+\n+tree\n+xref_tag (enum tree_code code, tree name)\n+{\n+  return parser_xref_tag (code, name).spec;\n }\n \f\n /* Make sure that the tag NAME is defined *in the current scope*\n@@ -6643,6 +6681,7 @@ build_null_declspecs (void)\n   ret->storage_class = csc_none;\n   ret->non_sc_seen_p = false;\n   ret->typedef_p = false;\n+  ret->tag_defined_p = false;\n   ret->explicit_signed_p = false;\n   ret->deprecated_p = false;\n   ret->default_int_p = false;\n@@ -6698,8 +6737,9 @@ declspecs_add_qual (struct c_declspecs *specs, tree qual)\n    returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_type (struct c_declspecs *specs, tree type)\n+declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n {\n+  tree type = spec.spec;\n   specs->non_sc_seen_p = true;\n   if (TREE_DEPRECATED (type))\n     specs->deprecated_p = true;\n@@ -6975,7 +7015,13 @@ declspecs_add_type (struct c_declspecs *specs, tree type)\n \tspecs->type = TREE_TYPE (t);\n     }\n   else if (TREE_CODE (type) != ERROR_MARK)\n-    specs->type = type;\n+    {\n+      if (spec.kind == ctsk_tagdef || spec.kind == ctsk_tagfirstref)\n+\tspecs->tag_defined_p = true;\n+      if (spec.kind == ctsk_typeof)\n+\tspecs->typedef_p = true;\n+      specs->type = type;\n+    }\n \n   return specs;\n }"}, {"sha": "7542c3959fbffa306d0f001ae2597635ccdd388b", "filename": "gcc/c-parse.in", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=81da229b08e74978a0dfb5bca48138a0a4a2357c", "patch": "@@ -101,8 +101,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n %union {long itype; tree ttype; void *otype; struct c_expr exprtype;\n \tstruct c_arg_info *arginfotype; struct c_declarator *dtrtype;\n \tstruct c_type_name *typenametype; struct c_parm *parmtype;\n-\tstruct c_declspecs *dsptype; enum tree_code code;\n-\tlocation_t location; }\n+\tstruct c_declspecs *dsptype; struct c_typespec tstype;\n+\tenum tree_code code; location_t location; }\n \n /* All identifiers that are not reserved words\n    and are not declared typedefs in the current block */\n@@ -202,9 +202,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <dsptype> declspecs_ts_nosa declspecs_nots_nosa\n %type <dsptype> declspecs_nosc_ts declspecs_nosc_nots declspecs_nosc declspecs\n %type <dsptype> maybe_type_quals_attrs\n-%type <ttype> typespec_nonattr typespec_attr\n-%type <ttype> typespec_reserved_nonattr typespec_reserved_attr\n-%type <ttype> typespec_nonreserved_nonattr\n+%type <tstype> typespec_nonattr typespec_attr\n+%type <tstype> typespec_reserved_nonattr typespec_reserved_attr\n+%type <tstype> typespec_nonreserved_nonattr\n %type <ttype> offsetof_member_designator\n \n %type <ttype> scspec SCSPEC STATIC TYPESPEC TYPE_QUAL maybe_volatile\n@@ -226,7 +226,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <dtrtype> parm_declarator_starttypename parm_declarator_nostarttypename\n %type <dtrtype> array_declarator\n \n-%type <ttype> structsp_attr structsp_nonattr\n+%type <tstype> structsp_attr structsp_nonattr\n %type <ttype> component_decl_list component_decl_list2\n %type <ttype> component_decl components components_notype component_declarator\n %type <ttype> component_notype_declarator\n@@ -1262,7 +1262,9 @@ typespec_attr:\n \n typespec_reserved_nonattr:\n \t  TYPESPEC\n-\t\t{ OBJC_NEED_RAW_IDENTIFIER (1);\t}\n+\t\t{ OBJC_NEED_RAW_IDENTIFIER (1);\n+\t\t  $$.kind = ctsk_resword;\n+\t\t  $$.spec = $1; }\n \t| structsp_nonattr\n \t;\n \n@@ -1274,29 +1276,39 @@ typespec_nonreserved_nonattr:\n \t  TYPENAME\n \t\t{ /* For a typedef name, record the meaning, not the name.\n \t\t     In case of `foo foo, bar;'.  */\n-\t\t  $$ = lookup_name ($1); }\n+\t\t  $$.kind = ctsk_typedef;\n+\t\t  $$.spec = lookup_name ($1); }\n @@ifobjc\n \t| CLASSNAME protocolrefs\n-\t\t{ $$ = objc_get_protocol_qualified_type ($1, $2); }\n+\t\t{ $$.kind = ctsk_objc;\n+\t\t  $$.spec = objc_get_protocol_qualified_type ($1, $2); }\n \t| OBJECTNAME protocolrefs\n-\t\t{ $$ = objc_get_protocol_qualified_type ($1, $2); }\n+\t\t{ $$.kind = ctsk_objc;\n+\t\t  $$.spec = objc_get_protocol_qualified_type ($1, $2); }\n \n /* Make \"<SomeProtocol>\" equivalent to \"id <SomeProtocol>\"\n    - nisse@lysator.liu.se */\n         | non_empty_protocolrefs\n-                { $$ = objc_get_protocol_qualified_type (NULL_TREE, $1); }\n+                { $$.kind = ctsk_objc;\n+\t\t  $$.spec = objc_get_protocol_qualified_type (NULL_TREE, $1); }\n @@end_ifobjc\n \t| typeof '(' expr ')'\n \t\t{ skip_evaluation--;\n \t\t  in_typeof--;\n \t\t  if (TREE_CODE ($3.value) == COMPONENT_REF\n \t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($3.value, 1)))\n \t\t    error (\"%<typeof%> applied to a bit-field\");\n-\t\t  $$ = TREE_TYPE ($3.value);\n-\t\t  pop_maybe_used (variably_modified_type_p ($$, NULL_TREE)); }\n+\t\t  $$.kind = ctsk_typeof;\n+\t\t  $$.spec = TREE_TYPE ($3.value);\n+\t\t  pop_maybe_used (variably_modified_type_p ($$.spec,\n+\t\t\t\t\t\t\t    NULL_TREE)); }\n \t| typeof '(' typename ')'\n-\t\t{ skip_evaluation--; in_typeof--; $$ = groktypename ($3);\n-\t\t  pop_maybe_used (variably_modified_type_p ($$, NULL_TREE)); }\n+\t\t{ skip_evaluation--;\n+\t\t  in_typeof--;\n+\t\t  $$.kind = ctsk_typeof;\n+\t\t  $$.spec = groktypename ($3);\n+\t\t  pop_maybe_used (variably_modified_type_p ($$.spec,\n+\t\t\t\t\t\t\t    NULL_TREE)); }\n \t;\n \n /* typespec_nonreserved_attr does not exist.  */\n@@ -1639,47 +1651,55 @@ enum_head:\n \n structsp_attr:\n \t  struct_head identifier '{'\n-\t\t{ $$ = start_struct (RECORD_TYPE, $2);\n+\t\t{ $<ttype>$ = start_struct (RECORD_TYPE, $2);\n \t\t  /* Start scope of tag before parsing components.  */\n \t\t}\n \t  component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct ($<ttype>4, nreverse ($5),\n-\t\t\t\t      chainon ($1, $7)); }\n+\t\t{ $$.spec = finish_struct ($<ttype>4, nreverse ($5),\n+\t\t\t\t\t   chainon ($1, $7));\n+\t\t  $$.kind = ctsk_tagdef; }\n \t| struct_head '{' component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n-\t\t\t\t      nreverse ($3), chainon ($1, $5));\n+\t\t{ $$.spec = finish_struct (start_struct (RECORD_TYPE,\n+\t\t\t\t\t\t\t NULL_TREE),\n+\t\t\t\t\t   nreverse ($3), chainon ($1, $5));\n+\t\t  $$.kind = ctsk_tagdef;\n \t\t}\n \t| union_head identifier '{'\n-\t\t{ $$ = start_struct (UNION_TYPE, $2); }\n+\t\t{ $<ttype>$ = start_struct (UNION_TYPE, $2); }\n \t  component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct ($<ttype>4, nreverse ($5),\n-\t\t\t\t      chainon ($1, $7)); }\n+\t\t{ $$.spec = finish_struct ($<ttype>4, nreverse ($5),\n+\t\t\t\t\t   chainon ($1, $7));\n+\t\t  $$.kind = ctsk_tagdef; }\n \t| union_head '{' component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct (start_struct (UNION_TYPE, NULL_TREE),\n-\t\t\t\t      nreverse ($3), chainon ($1, $5));\n+\t\t{ $$.spec = finish_struct (start_struct (UNION_TYPE,\n+\t\t\t\t\t\t\t NULL_TREE),\n+\t\t\t\t\t   nreverse ($3), chainon ($1, $5));\n+\t\t  $$.kind = ctsk_tagdef;\n \t\t}\n \t| enum_head identifier '{'\n-\t\t{ $$ = start_enum ($2); }\n+\t\t{ $<ttype>$ = start_enum ($2); }\n \t  enumlist maybecomma_warn '}' maybe_attribute\n-\t\t{ $$ = finish_enum ($<ttype>4, nreverse ($5),\n-\t\t\t\t    chainon ($1, $8)); }\n+\t\t{ $$.spec = finish_enum ($<ttype>4, nreverse ($5),\n+\t\t\t\t\t chainon ($1, $8));\n+\t\t  $$.kind = ctsk_tagdef; }\n \t| enum_head '{'\n-\t\t{ $$ = start_enum (NULL_TREE); }\n+\t\t{ $<ttype>$ = start_enum (NULL_TREE); }\n \t  enumlist maybecomma_warn '}' maybe_attribute\n-\t\t{ $$ = finish_enum ($<ttype>3, nreverse ($4),\n-\t\t\t\t    chainon ($1, $7)); }\n+\t\t{ $$.spec = finish_enum ($<ttype>3, nreverse ($4),\n+\t\t\t\t\t chainon ($1, $7));\n+\t\t  $$.kind = ctsk_tagdef; }\n \t;\n \n structsp_nonattr:\n \t  struct_head identifier\n-\t\t{ $$ = xref_tag (RECORD_TYPE, $2); }\n+\t\t{ $$ = parser_xref_tag (RECORD_TYPE, $2); }\n \t| union_head identifier\n-\t\t{ $$ = xref_tag (UNION_TYPE, $2); }\n+\t\t{ $$ = parser_xref_tag (UNION_TYPE, $2); }\n \t| enum_head identifier\n-\t\t{ $$ = xref_tag (ENUMERAL_TYPE, $2);\n+\t\t{ $$ = parser_xref_tag (ENUMERAL_TYPE, $2);\n \t\t  /* In ISO C, enumerated types can be referred to\n \t\t     only if already defined.  */\n-\t\t  if (pedantic && !COMPLETE_TYPE_P ($$))\n+\t\t  if (pedantic && !COMPLETE_TYPE_P ($$.spec))\n \t\t    pedwarn (\"ISO C forbids forward references to %<enum%> types\"); }\n \t;\n "}, {"sha": "18d200fb5921cd04e9cc62acab58614cb4c8c5ba", "filename": "gcc/c-tree.h", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=81da229b08e74978a0dfb5bca48138a0a4a2357c", "patch": "@@ -131,6 +131,39 @@ struct c_expr\n   enum tree_code original_code;\n };\n \n+/* A kind of type specifier.  Note that this information is currently\n+   only used to distinguish tag definitions, tag references and typeof\n+   uses.  */\n+enum c_typespec_kind {\n+  /* A reserved keyword type specifier.  */\n+  ctsk_resword,\n+  /* A reference to a tag, previously declared, such as \"struct foo\".\n+     This includes where the previous declaration was as a different\n+     kind of tag, in which case this is only valid if shadowing that\n+     tag in an inner scope.  */\n+  ctsk_tagref,\n+  /* A reference to a tag, not previously declared in a visible\n+     scope.  */\n+  ctsk_tagfirstref,\n+  /* A definition of a tag such as \"struct foo { int a; }\".  */\n+  ctsk_tagdef,\n+  /* A typedef name.  */\n+  ctsk_typedef,\n+  /* An ObjC-specific kind of type specifier.  */\n+  ctsk_objc,\n+  /* A typeof specifier.  */\n+  ctsk_typeof\n+};\n+\n+/* A type specifier: this structure is created in the parser and\n+   passed to declspecs_add_type only.  */\n+struct c_typespec {\n+  /* What kind of type specifier this is.  */\n+  enum c_typespec_kind kind;\n+  /* The specifier itself.  */\n+  tree spec;\n+};\n+\n /* A storage class specifier.  */\n enum c_storage_class {\n   csc_none,\n@@ -178,8 +211,12 @@ struct c_declspecs {\n      specifiers to be handled separately from storage class\n      specifiers.)  */\n   BOOL_BITFIELD non_sc_seen_p : 1;\n-  /* Whether the type is specified by a typedef.  */\n+  /* Whether the type is specified by a typedef or typeof name.  */\n   BOOL_BITFIELD typedef_p : 1;\n+  /* Whether a struct, union or enum type either had its content\n+     defined by a type specifier in the list or was the first visible\n+     declaration of its tag.  */\n+  BOOL_BITFIELD tag_defined_p : 1;\n   /* Whether the type is explicitly \"signed\" or specified by a typedef\n      whose type is explicitly \"signed\".  */\n   BOOL_BITFIELD explicit_signed_p : 1;\n@@ -371,6 +408,7 @@ extern tree start_struct (enum tree_code, tree);\n extern void store_parm_decls (void);\n extern void store_parm_decls_from (struct c_arg_info *);\n extern tree xref_tag (enum tree_code, tree);\n+extern struct c_typespec parser_xref_tag (enum tree_code, tree);\n extern int c_expand_decl (tree);\n extern struct c_parm *build_c_parm (struct c_declspecs *, tree,\n \t\t\t\t    struct c_declarator *);\n@@ -383,7 +421,8 @@ extern struct c_declarator *make_pointer_declarator (struct c_declspecs *,\n \t\t\t\t\t\t     struct c_declarator *);\n extern struct c_declspecs *build_null_declspecs (void);\n extern struct c_declspecs *declspecs_add_qual (struct c_declspecs *, tree);\n-extern struct c_declspecs *declspecs_add_type (struct c_declspecs *, tree);\n+extern struct c_declspecs *declspecs_add_type (struct c_declspecs *,\n+\t\t\t\t\t       struct c_typespec);\n extern struct c_declspecs *declspecs_add_scspec (struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_attrs (struct c_declspecs *, tree);\n extern struct c_declspecs *finish_declspecs (struct c_declspecs *);"}, {"sha": "b31a43c2f1a5b4fd912cd69f34a0ca4bf4dee14f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=81da229b08e74978a0dfb5bca48138a0a4a2357c", "patch": "@@ -1,3 +1,7 @@\n+2004-10-14  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* gcc.dg/c99-tag-3.c, gcc.dg/declspec-14.c: New tests.\n+\n 2004-10-14  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR target/17984"}, {"sha": "12eff6e126896beb37c6a558b80256f0508e63c1", "filename": "gcc/testsuite/gcc.dg/c99-tag-3.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-3.c?ref=81da229b08e74978a0dfb5bca48138a0a4a2357c", "patch": "@@ -0,0 +1,59 @@\n+/* Test for handling of tags.  \"const struct foo;\" and similar does\n+   not redeclare an existing tag.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+/* Plain \"struct s;\" always declares a tag: the same as one declared\n+   in that scope, or shadowing one from an outer scope.  */\n+struct s0;\n+struct s0 { int a; };\n+struct s0;\n+void f (void) { struct s0; }\n+\n+/* A declaration with a qualifier or storage class specifier declares\n+   the tag if no other declaration of it is visible.  */\n+const union u0; /* { dg-warning \"warning: useless type qualifier in empty declaration\" } */\n+union u0 { long b; };\n+\n+extern struct s1; /* { dg-warning \"warning: useless storage class specifier in empty declaration\" } */\n+\n+/* But if a declaration of the tag is visible, whether at the same\n+   scope or an outer scope, the declaration specifies the same type as\n+   the previous declaration and does not redeclare the tag (C99\n+   6.7.2.3#8).  Thus, as it does not declare a declarator, a tag or\n+   the members of an enumeration, it is a constraint violation.  */\n+\n+struct s2 { char x; };\n+const struct s2; /* { dg-error \"error: empty declaration with type qualifier does not redeclare tag\" } */\n+\n+union u1;\n+extern union u1; /* { dg-error \"error: empty declaration with storage class specifier does not redeclare tag\" } */\n+\n+union u2 { long b; };\n+void g(void) { const union u2; } /* { dg-error \"error: empty declaration with type qualifier does not redeclare tag\" } */\n+\n+/* And it does not redeclare the tag either if the outer tag is the\n+   wrong kind of tag.  This also yields an error for the reference to\n+   the wrong kind of tag in addition to the pedwarn for the empty\n+   declaration.  */\n+\n+union u3 { float v; };\n+void h(void) { const struct u3; } /* { dg-error \"'u3' defined as wrong kind of tag\" } */\n+/* { dg-error \"error: empty declaration with type qualifier does not redeclare tag\" \"wrong tag empty\" { target *-*-* } 42 } */\n+\n+/* However, such useless specifiers are OK if the contents of the tag\n+   are being defined, or shadowed in an inner scope with the contents\n+   included in the shadowing.  */\n+\n+struct s3;\n+const struct s3 { int a; }; /* { dg-warning \"warning: useless type qualifier in empty declaration\" } */\n+\n+union u4;\n+extern union u4 { int z; }; /* { dg-warning \"warning: useless storage class specifier in empty declaration\" } */\n+\n+enum e0 { E0 };\n+void i(void) { const enum e0 { E1 }; } /* { dg-warning \"warning: useless type qualifier in empty declaration\" } */\n+\n+union u5 { int p; };\n+void j(void) { extern struct u5 { int q; }; } /* { dg-warning \"warning: useless storage class specifier in empty declaration\" } */"}, {"sha": "a19b9de37713166568edf2f82dc0c4b4320b2604", "filename": "gcc/testsuite/gcc.dg/declspec-14.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81da229b08e74978a0dfb5bca48138a0a4a2357c/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-14.c?ref=81da229b08e74978a0dfb5bca48138a0a4a2357c", "patch": "@@ -0,0 +1,11 @@\n+/* Test that \"typeof(struct foo)\" and similar as declaration\n+   specifiers act like typedef.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+typeof(struct foo); /* { dg-warning \"warning: useless type name in empty declaration\" } */\n+\n+struct bar { int a; } x;\n+\n+typeof(x); /* { dg-warning \"warning: useless type name in empty declaration\" } */"}]}