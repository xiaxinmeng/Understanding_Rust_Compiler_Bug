{"sha": "e96ce650a83492661331c551dc767179eab5f8b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2Y2U2NTBhODM0OTI2NjEzMzFjNTUxZGM3NjcxNzllYWI1ZjhiNw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2009-12-19T22:40:37Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2009-12-19T22:40:37Z"}, "message": "Fix PR c++/42225, take 2\n\ngcc/cp/ChangeLog:\n\tPR c++/42225\n\t* pt.c (push_template_decl_real): Set DECL_CONTEXT of template type\n\tparms to their containing template decl.\n\t* typeck.c (comp_template_parms_position): Split this from\n\tstructural_comptypes.\n\t(incompatible_template_type_parms_p): Renamed\n\tincompatible_dependent_typedefs_p into this. Change the function to\n\thandle comparison between TEMPLATE_TYPE_PARMs only.\n\t(structural_comptypes): Use comp_template_parms_position in\n\tTEMPLATE_TEMPLATE_PARM and BOUND_TEMPLATE_TEMPLATE_PARM cases.\n\tUse incompatible_template_type_parms_p in TEMPLATE_TYPE_PARM case.\n\t* mangle.c (decl_mangling_context): Template type parms don't have\n\ta mangling context.\n\t* tree.c (cp_set_underlying_type): Set type structural equality\n\tonly for TEMPLATE_TYPE_PARMs.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/42225\n\t* g++.dg/template/typedef26.C: New test.\n\nFrom-SVN: r155363", "tree": {"sha": "1dea0c05df1cc3687feff71c23514edde26e0836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dea0c05df1cc3687feff71c23514edde26e0836"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e96ce650a83492661331c551dc767179eab5f8b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96ce650a83492661331c551dc767179eab5f8b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e96ce650a83492661331c551dc767179eab5f8b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96ce650a83492661331c551dc767179eab5f8b7/comments", "author": null, "committer": null, "parents": [{"sha": "b0ce048a3f7a78329145d0f48d63d3cabab8908b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ce048a3f7a78329145d0f48d63d3cabab8908b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ce048a3f7a78329145d0f48d63d3cabab8908b"}], "stats": {"total": 189, "additions": 150, "deletions": 39}, "files": [{"sha": "7b752cf94cb87a9cb5bbf32b3731dc1d3c62ee76", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e96ce650a83492661331c551dc767179eab5f8b7", "patch": "@@ -1,3 +1,21 @@\n+2009-12-19  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42225\n+\t* pt.c (push_template_decl_real): Set DECL_CONTEXT of template type parms\n+\tto their containing template decl.\n+\t* typeck.c (comp_template_parms_position): Split this from\n+\tstructural_comptypes.\n+\t(incompatible_template_type_parms_p): Renamed\n+\tincompatible_dependent_typedefs_p into this. Change the function to\n+\thandle comparison between TEMPLATE_TYPE_PARMs only.\n+\t(structural_comptypes): Use comp_template_parms_position in\n+\tTEMPLATE_TEMPLATE_PARM and BOUND_TEMPLATE_TEMPLATE_PARM cases.\n+\tUse incompatible_template_type_parms_p in TEMPLATE_TYPE_PARM case.\n+\t* mangle.c (decl_mangling_context): Template type parms don't have\n+\ta mangling context.\n+\t* tree.c (cp_set_underlying_type): Set type structural equality\n+\tonly for TEMPLATE_TYPE_PARMs.\n+\n 2009-12-18  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/28300"}, {"sha": "d673c6ea8b3644a86080dff182968125b85a70f0", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=e96ce650a83492661331c551dc767179eab5f8b7", "patch": "@@ -743,6 +743,10 @@ decl_mangling_context (tree decl)\n       if (extra)\n \treturn extra;\n     }\n+    else if (TREE_CODE (decl) == TYPE_DECL\n+\t     && TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TYPE_PARM)\n+     /* template type parms have no mangling context.  */\n+      return NULL_TREE;\n   return CP_DECL_CONTEXT (decl);\n }\n "}, {"sha": "bb7c167ebe04308014bf15e44b98cc53cee40694", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e96ce650a83492661331c551dc767179eab5f8b7", "patch": "@@ -4514,6 +4514,9 @@ template arguments to %qD do not match original template %qD\",\n \t  tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n \t  if (TREE_CODE (parm) == TEMPLATE_DECL)\n \t    DECL_CONTEXT (parm) = tmpl;\n+\n+\t  if (TREE_CODE (TREE_TYPE (parm)) == TEMPLATE_TYPE_PARM)\n+\t    DECL_CONTEXT (TYPE_NAME (TREE_TYPE (parm))) = tmpl;\n \t}\n     }\n "}, {"sha": "35d53e862a00460919560df04bd441b12f778dc8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e96ce650a83492661331c551dc767179eab5f8b7", "patch": "@@ -1083,12 +1083,11 @@ void\n cp_set_underlying_type (tree t)\n {\n   set_underlying_type (t);\n-  /* If the typedef variant type is dependent, make it require\n-     structural equality.\n-     This is useful when comparing two dependent typedef variant types,\n+  /* If T is a template type parm, make it require structural equality.\n+     This is useful when comparing two template type parms,\n      because it forces the comparison of the template parameters of their\n-     decls for instance.  */\n-  if (dependent_type_p (TREE_TYPE (t)))\n+     decls.  */\n+  if (TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n     SET_TYPE_STRUCTURAL_EQUALITY (TREE_TYPE (t));\n }\n "}, {"sha": "402f9e4ce819c3b860648cc6fe7489d4aa080cd7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 76, "deletions": 34, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e96ce650a83492661331c551dc767179eab5f8b7", "patch": "@@ -1073,45 +1073,96 @@ comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)\n   return true;\n }\n \n+/* Compare the relative position of T1 and T2 into their respective\n+   template parameter list.\n+   T1 and T2 must be template parameter types.\n+   Return TRUE if T1 and T2 have the same position, FALSE otherwise.  */\n+\n+static bool\n+comp_template_parms_position (tree t1, tree t2)\n+{\n+  gcc_assert (t1 && t2\n+\t      && TREE_CODE (t1) == TREE_CODE (t2)\n+\t      && (TREE_CODE (t1) == BOUND_TEMPLATE_TEMPLATE_PARM\n+\t\t  || TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM\n+\t\t  || TREE_CODE (t1) == TEMPLATE_TYPE_PARM));\n+\n+      if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n+\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2)\n+          || (TEMPLATE_TYPE_PARAMETER_PACK (t1) \n+              != TEMPLATE_TYPE_PARAMETER_PACK (t2)))\n+\treturn false;\n+\n+      return true;\n+}\n+\n /* Subroutine of structural_comptypes.\n-   Compare the template parameters of the\n-   typedef decl of T1 and T2. \n-   Return TRUE if the template parameters of the typedef decls of T1 and T2 are\n-   different, FALSE otherwise.  */\n+   Compare the template type parameters T1 and T2.\n+   Return TRUE if we are sure they can't be equal, FALSE otherwise.  */\n \n static bool\n-incompatible_dependent_typedefs_p (tree t1, tree t2)\n+incompatible_template_type_parms_p (tree t1, tree t2)\n {\n-  tree decl1, tinfo1,\n-       decl2, tinfo2;\n+  tree decl1, tparms1 = NULL_TREE,\n+       decl2, tparms2 = NULL_TREE;\n+\n+  gcc_assert (t1 && TREE_CODE (t1) == TEMPLATE_TYPE_PARM\n+\t      && t2 && TREE_CODE (t2) == TEMPLATE_TYPE_PARM);\n+\n+  /* If T1 and T2 don't have the same relative position in their\n+     template parameters set, they can't be equal.  */\n+  if (!comp_template_parms_position (t1, t2))\n+    return true;\n \n-  if (!typedef_variant_p (t1)\n-      || !typedef_variant_p (t2)\n-      || !dependent_type_p (t1)\n-      || !dependent_type_p (t2))\n+  if (!typedef_variant_p (t1) && !typedef_variant_p (t2))\n+    /* If neither T1 nor T2 is a typedef we cannot know more\n+       about their incompatibility than what comp_template_parms_position\n+       told us above. If we try to keep going nonetheless, the call to\n+       comp_template_parms at the end of this function might lead to an\n+       infinite recursion.  */\n     return false;\n \n   decl1 = TYPE_NAME (t1);\n   decl2 = TYPE_NAME (t2);\n-  if (decl1 == decl2)\n+  if (decl1 == NULL_TREE || decl2 == NULL_TREE || decl1 == decl2)\n     return false ;\n \n-  tinfo1 = get_template_info (decl1);\n-  if (!tinfo1)\n-    tinfo1 = get_template_info (DECL_CONTEXT (decl1));\n+  /* So if we reach this point, it means either T1 or T2 is a typedef variant.\n+     Let's compare their template parameters.  */\n \n-  tinfo2 = get_template_info (decl2);\n-  if (!tinfo2)\n-    tinfo2 = get_template_info (DECL_CONTEXT (decl2));\n+  /* If T1 is not a typedef, there possibly is a delay between the\n+     creation of DECL1 and the setting of DECL_CONTEXT (DECL1) to its\n+     template decl so DECL_CONTEXT (DECL1) can be empty for\n+     a little while.  */\n+  if (DECL_CONTEXT (decl1))\n+    {\n+      if (TREE_CODE (DECL_CONTEXT (decl1)) == TEMPLATE_DECL)\n+\ttparms1 = DECL_TEMPLATE_PARMS (DECL_CONTEXT (decl1));\n+      else\n+\t/* T1 is a typedef variant type. Get the parms of its context.  */\n+\ttparms1 =\n+\t  DECL_TEMPLATE_PARMS (TI_TEMPLATE\n+\t\t\t\t (get_template_info (DECL_CONTEXT (decl1))));\n+    }\n \n-  gcc_assert (tinfo1 != NULL_TREE\n-\t      && tinfo2 != NULL_TREE);\n+  /* Do the same thing for DECL2.  */\n+  if (DECL_CONTEXT (decl2))\n+    {\n+      if (TREE_CODE (DECL_CONTEXT (decl2)) == TEMPLATE_DECL)\n+\ttparms2 = DECL_TEMPLATE_PARMS (DECL_CONTEXT (decl2));\n+      else\n+\ttparms2 =\n+\t  DECL_TEMPLATE_PARMS (TI_TEMPLATE\n+\t\t\t\t(get_template_info (DECL_CONTEXT (decl2))));\n+    }\n \n-  if (tinfo1 == tinfo2)\n+  if (tparms1 == NULL_TREE\n+      || tparms2 == NULL_TREE\n+      || tparms1 == tparms2)\n     return false;\n \n-  return !comp_template_parms (DECL_TEMPLATE_PARMS (TI_TEMPLATE (tinfo1)),\n-\t\t\t       DECL_TEMPLATE_PARMS (TI_TEMPLATE (tinfo2)));\n+  /* And now compare the mighty template parms!  */\n+  return !comp_template_parms (tparms1, tparms2);\n }\n \n /* Subroutine in comptypes.  */\n@@ -1161,9 +1212,6 @@ structural_comptypes (tree t1, tree t2, int strict)\n       && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return true;\n \n-  if (incompatible_dependent_typedefs_p (t1, t2))\n-    return false;\n-\n   /* Compare the types.  Break out if they could be the same.  */\n   switch (TREE_CODE (t1))\n     {\n@@ -1193,10 +1241,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n \n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n-      if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n-\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2)\n-          || (TEMPLATE_TYPE_PARAMETER_PACK (t1) \n-              != TEMPLATE_TYPE_PARAMETER_PACK (t2)))\n+      if (!comp_template_parms_position (t1, t2))\n \treturn false;\n       if (!comp_template_parms\n \t  (DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t1)),\n@@ -1258,10 +1303,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n-\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2)\n-          || (TEMPLATE_TYPE_PARAMETER_PACK (t1) \n-              != TEMPLATE_TYPE_PARAMETER_PACK (t2)))\n+      if (incompatible_template_type_parms_p (t1, t2))\n \treturn false;\n       break;\n "}, {"sha": "462eee1ee2623b4d728bebd81b8473369a6f4ef2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e96ce650a83492661331c551dc767179eab5f8b7", "patch": "@@ -1,3 +1,8 @@\n+2009-12-19  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42225\n+\t* g++.dg/template/typedef26.C: New test.\n+\n 2009-12-19  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/42401"}, {"sha": "7f4bc6b5ceaf1cb6dafd2ae77609750636f0cc6b", "filename": "gcc/testsuite/g++.dg/template/typedef26.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96ce650a83492661331c551dc767179eab5f8b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef26.C?ref=e96ce650a83492661331c551dc767179eab5f8b7", "patch": "@@ -0,0 +1,40 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/42225\n+// { dg-do compile }\n+\n+struct A\n+{\n+    typedef int TI;\n+};\n+\n+template<class T0>\n+struct S0\n+{\n+    int i;\n+};\n+\n+template<class _T, int>\n+struct S1\n+{\n+    typedef _T T;\n+    typedef typename T::TI TTI;\n+    typedef S0<TTI> TT0;\n+    typedef S0<typename T::TI> TT1;\n+};\n+\n+template<class T>\n+void\n+foo(const T&)\n+{\n+    typedef typename T::TI TTI;\n+    typedef S0<TTI> TT1;\n+    typedef S0<typename T::TI> TT2;\n+}\n+\n+int\n+main()\n+{\n+    A a;\n+    foo (a);\n+}\n+"}]}