{"sha": "db61b7f923b769142156eab047c94b04bb7adaae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI2MWI3ZjkyM2I3NjkxNDIxNTZlYWIwNDdjOTRiMDRiYjdhZGFhZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:19:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:19:39Z"}, "message": "[66/77] Use scalar_mode for constant integers\n\nThis patch treats the mode associated with an integer constant as a\nscalar_mode.  We can't use the more natural-sounding scalar_int_mode\nbecause we also use (const_int 0) for bounds-checking modes.  (It might\nbe worth adding a bounds-specific code instead, but that's for another\nday.)\n\nThis exposes a latent bug in simplify_immed_subreg, which for\nvectors of CONST_WIDE_INTs would pass the vector mode rather than\nthe element mode to rtx_mode_t.\n\nI think the:\n\n\t\t  /* We can get a 0 for an error mark.  */\n\t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n\t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT\n\nin immed_double_const is dead.  trunc_int_mode (via gen_int_mode)\nwould go on to ICE if the mode fitted in a HWI, and surely plenty\nof other code would be confused to see a const_int be interpreted\nas a vector.  We should instead be using CONST0_RTX (mode) if we\nneed a safe constant for a particular mode.\n\nWe didn't try to make these functions take scalar_mode arguments\nbecause in many cases that would be too invasive at this stage.\nMaybe it would become feasible in future.  Also, the long-term\ndirection should probably be to add modes to constant integers\nrather than have then as VOIDmode odd-ones-out.  That would remove\nthe need for rtx_mode_t and thus remove the question whether they\nshould use scalar_int_mode, scalar_mode or machine_mode.\n\nThe patch also uses scalar_mode for the CONST_DOUBLE handling\nin loc_descriptor.  In that case the mode can legitimately be\neither floating-point or integral.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* emit-rtl.c (immed_double_const): Use is_a <scalar_mode> instead\n\tof separate mode class checks.  Do not allow vector modes here.\n\t(immed_wide_int_const): Use as_a <scalar_mode>.\n\t* explow.c (trunc_int_for_mode): Likewise.\n\t* rtl.h (wi::int_traits<rtx_mode_t>::get_precision): Likewise.\n\t(wi::shwi): Likewise.\n\t(wi::min_value): Likewise.\n\t(wi::max_value): Likewise.\n\t* dwarf2out.c (loc_descriptor): Likewise.\n\t* simplify-rtx.c (simplify_immed_subreg): Fix rtx_mode_t argument\n\tfor CONST_WIDE_INT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251517", "tree": {"sha": "522f1a6eed83a6d3571b7d5746f0fbeb9c488141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/522f1a6eed83a6d3571b7d5746f0fbeb9c488141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db61b7f923b769142156eab047c94b04bb7adaae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db61b7f923b769142156eab047c94b04bb7adaae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db61b7f923b769142156eab047c94b04bb7adaae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db61b7f923b769142156eab047c94b04bb7adaae/comments", "author": null, "committer": null, "parents": [{"sha": "b397965cae46d88d4c274fb2ecdde9a4714a4e6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b397965cae46d88d4c274fb2ecdde9a4714a4e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b397965cae46d88d4c274fb2ecdde9a4714a4e6a"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "ed48b55cab9fa0c57dd43670eb017a266bc5925e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db61b7f923b769142156eab047c94b04bb7adaae", "patch": "@@ -1,3 +1,19 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* emit-rtl.c (immed_double_const): Use is_a <scalar_mode> instead\n+\tof separate mode class checks.  Do not allow vector modes here.\n+\t(immed_wide_int_const): Use as_a <scalar_mode>.\n+\t* explow.c (trunc_int_for_mode): Likewise.\n+\t* rtl.h (wi::int_traits<rtx_mode_t>::get_precision): Likewise.\n+\t(wi::shwi): Likewise.\n+\t(wi::min_value): Likewise.\n+\t(wi::max_value): Likewise.\n+\t* dwarf2out.c (loc_descriptor): Likewise.\n+\t* simplify-rtx.c (simplify_immed_subreg): Fix rtx_mode_t argument\n+\tfor CONST_WIDE_INT.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "42da36ca62e96dd01f6785074639d542eae72691", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=db61b7f923b769142156eab047c94b04bb7adaae", "patch": "@@ -15863,10 +15863,11 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \t     or a floating-point constant.  A CONST_DOUBLE is used whenever\n \t     the constant requires more than one word in order to be\n \t     adequately represented.  We output CONST_DOUBLEs as blocks.  */\n+\t  scalar_mode smode = as_a <scalar_mode> (mode);\n \t  loc_result = new_loc_descr (DW_OP_implicit_value,\n-\t\t\t\t      GET_MODE_SIZE (mode), 0);\n+\t\t\t\t      GET_MODE_SIZE (smode), 0);\n #if TARGET_SUPPORTS_WIDE_INT == 0\n-\t  if (!SCALAR_FLOAT_MODE_P (mode))\n+\t  if (!SCALAR_FLOAT_MODE_P (smode))\n \t    {\n \t      loc_result->dw_loc_oprnd2.val_class = dw_val_class_const_double;\n \t      loc_result->dw_loc_oprnd2.v.val_double\n@@ -15875,7 +15876,7 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \t  else\n #endif\n \t    {\n-\t      unsigned int length = GET_MODE_SIZE (mode);\n+\t      unsigned int length = GET_MODE_SIZE (smode);\n \t      unsigned char *array = ggc_vec_alloc<unsigned char> (length);\n \n \t      insert_float (rtl, array);"}, {"sha": "15c25ec4b4c8910ed5e479cd7dec19d03ade22bf", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=db61b7f923b769142156eab047c94b04bb7adaae", "patch": "@@ -599,7 +599,8 @@ rtx\n immed_wide_int_const (const wide_int_ref &v, machine_mode mode)\n {\n   unsigned int len = v.get_len ();\n-  unsigned int prec = GET_MODE_PRECISION (mode);\n+  /* Not scalar_int_mode because we also allow pointer bound modes.  */\n+  unsigned int prec = GET_MODE_PRECISION (as_a <scalar_mode> (mode));\n \n   /* Allow truncation but not extension since we do not know if the\n      number is signed or unsigned.  */\n@@ -659,18 +660,10 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, machine_mode mode)\n         (i.e., i1 consists only from copies of the sign bit, and sign\n \tof i0 and i1 are the same), then we return a CONST_INT for i0.\n      3) Otherwise, we create a CONST_DOUBLE for i0 and i1.  */\n-  if (mode != VOIDmode)\n-    {\n-      gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n-\t\t  || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT\n-\t\t  /* We can get a 0 for an error mark.  */\n-\t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT\n-\t\t  || GET_MODE_CLASS (mode) == MODE_POINTER_BOUNDS);\n-\n-      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-\treturn gen_int_mode (i0, mode);\n-    }\n+  scalar_mode smode;\n+  if (is_a <scalar_mode> (mode, &smode)\n+      && GET_MODE_BITSIZE (smode) <= HOST_BITS_PER_WIDE_INT)\n+    return gen_int_mode (i0, mode);\n \n   /* If this integer fits in one word, return a CONST_INT.  */\n   if ((i1 == 0 && i0 >= 0) || (i1 == ~0 && i0 < 0))"}, {"sha": "ee20969d23a52e642b39d188d380e2388635a76c", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=db61b7f923b769142156eab047c94b04bb7adaae", "patch": "@@ -49,14 +49,16 @@ static rtx break_out_memory_refs (rtx);\n HOST_WIDE_INT\n trunc_int_for_mode (HOST_WIDE_INT c, machine_mode mode)\n {\n-  int width = GET_MODE_PRECISION (mode);\n+  /* Not scalar_int_mode because we also allow pointer bound modes.  */\n+  scalar_mode smode = as_a <scalar_mode> (mode);\n+  int width = GET_MODE_PRECISION (smode);\n \n   /* You want to truncate to a _what_?  */\n   gcc_assert (SCALAR_INT_MODE_P (mode)\n \t      || POINTER_BOUNDS_MODE_P (mode));\n \n   /* Canonicalize BImode to 0 and STORE_FLAG_VALUE.  */\n-  if (mode == BImode)\n+  if (smode == BImode)\n     return c & 1 ? STORE_FLAG_VALUE : 0;\n \n   /* Sign-extend for the requested mode.  */"}, {"sha": "b8ba49fe2c5b84dffbdc4febb16250dedf46168a", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=db61b7f923b769142156eab047c94b04bb7adaae", "patch": "@@ -2120,8 +2120,7 @@ namespace wi\n inline unsigned int\n wi::int_traits <rtx_mode_t>::get_precision (const rtx_mode_t &x)\n {\n-  gcc_checking_assert (x.second != BLKmode && x.second != VOIDmode);\n-  return GET_MODE_PRECISION (x.second);\n+  return GET_MODE_PRECISION (as_a <scalar_mode> (x.second));\n }\n \n inline wi::storage_ref\n@@ -2166,23 +2165,23 @@ namespace wi\n inline wi::hwi_with_prec\n wi::shwi (HOST_WIDE_INT val, machine_mode mode)\n {\n-  return shwi (val, GET_MODE_PRECISION (mode));\n+  return shwi (val, GET_MODE_PRECISION (as_a <scalar_mode> (mode)));\n }\n \n /* Produce the smallest number that is represented in MODE.  The precision\n    is taken from MODE and the sign from SGN.  */\n inline wide_int\n wi::min_value (machine_mode mode, signop sgn)\n {\n-  return min_value (GET_MODE_PRECISION (mode), sgn);\n+  return min_value (GET_MODE_PRECISION (as_a <scalar_mode> (mode)), sgn);\n }\n \n /* Produce the largest number that is represented in MODE.  The precision\n    is taken from MODE and the sign from SGN.  */\n inline wide_int\n wi::max_value (machine_mode mode, signop sgn)\n {\n-  return max_value (GET_MODE_PRECISION (mode), sgn);\n+  return max_value (GET_MODE_PRECISION (as_a <scalar_mode> (mode)), sgn);\n }\n \n extern void init_rtlanal (void);"}, {"sha": "60ea9a12f57396f4d9a1a4b6b72f26beba464e48", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61b7f923b769142156eab047c94b04bb7adaae/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=db61b7f923b769142156eab047c94b04bb7adaae", "patch": "@@ -5794,7 +5794,7 @@ simplify_immed_subreg (machine_mode outermode, rtx op,\n \n \tcase CONST_WIDE_INT:\n \t  {\n-\t    rtx_mode_t val = rtx_mode_t (el, innermode);\n+\t    rtx_mode_t val = rtx_mode_t (el, GET_MODE_INNER (innermode));\n \t    unsigned char extend = wi::sign_mask (val);\n \t    int prec = wi::get_precision (val);\n "}]}