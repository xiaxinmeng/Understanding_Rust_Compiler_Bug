{"sha": "933a73251d95fb930028cb76eee7a892f41f867b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMzYTczMjUxZDk1ZmI5MzAwMjhjYjc2ZWVlN2E4OTJmNDFmODY3Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-11-30T11:46:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-11-30T11:46:32Z"}, "message": "gigi.h (is_simple_additive_expression): Declare.\n\n\t* gcc-interface/gigi.h (is_simple_additive_expression): Declare.\n\t* gcc-interface/trans.c (struct range_check_info_d): Add DISP and\n\tNEG_P fields.\n\t(find_loop_for): Add DISP and NEG_P parameters with default value.\n\tCall is_simple_additive_expression to handle additive expressions.\n\t(Loop_Statement_to_gnu): Deal with displacement in range checks.\n\t(Raise_Error_to_gnu): Likewise.\n\t(gnat_to_gnu): Add call to find_loop_for.\n\t(is_simple_additive_expression): New function extracted from...\n\t(gnat_invariant_expr): ...here.  Call it on the expression.\n\nFrom-SVN: r231064", "tree": {"sha": "04f64660b152400aaf2762b907ade2f74782d611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f64660b152400aaf2762b907ade2f74782d611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/933a73251d95fb930028cb76eee7a892f41f867b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933a73251d95fb930028cb76eee7a892f41f867b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933a73251d95fb930028cb76eee7a892f41f867b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933a73251d95fb930028cb76eee7a892f41f867b/comments", "author": null, "committer": null, "parents": [{"sha": "f8125f0c9ce43aac6d7a96753e4617af68ee0009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8125f0c9ce43aac6d7a96753e4617af68ee0009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8125f0c9ce43aac6d7a96753e4617af68ee0009"}], "stats": {"total": 170, "additions": 136, "deletions": 34}, "files": [{"sha": "fa64fd5b1109f0a868fcdc8749f83b65f07412d3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=933a73251d95fb930028cb76eee7a892f41f867b", "patch": "@@ -1,3 +1,16 @@\n+2015-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (is_simple_additive_expression): Declare.\n+\t* gcc-interface/trans.c (struct range_check_info_d): Add DISP and\n+\tNEG_P fields.\n+\t(find_loop_for): Add DISP and NEG_P parameters with default value.\n+\tCall is_simple_additive_expression to handle additive expressions.\n+\t(Loop_Statement_to_gnu): Deal with displacement in range checks.\n+\t(Raise_Error_to_gnu): Likewise.\n+\t(gnat_to_gnu): Add call to find_loop_for.\n+\t(is_simple_additive_expression): New function extracted from...\n+\t(gnat_invariant_expr): ...here.  Call it on the expression.\n+\n 2015-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c (gnat_invariant_expr): Add type conversions."}, {"sha": "e98e7e6c8dd38031ccc7a273c13ad59ba2c38a2e", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=933a73251d95fb930028cb76eee7a892f41f867b", "patch": "@@ -962,6 +962,12 @@ extern tree gnat_rewrite_reference (tree ref, rewrite_fn func, void *data,\n    i.e. if it doesn't depend on the context in which it is evaluated.  */\n extern tree get_inner_constant_reference (tree exp);\n \n+/* Return true if EXPR is the addition or the subtraction of a constant and,\n+   if so, set *ADD to the addend, *CST to the constant and *MINUS_P to true\n+   if this is a subtraction.  */\n+extern bool is_simple_additive_expression (tree expr, tree *add, tree *cst,\n+\t\t\t\t\t   bool *minus_p);\n+\n /* If EXPR is an expression that is invariant in the current function, in the\n    sense that it can be evaluated anywhere in the function and any number of\n    times, return EXPR or an equivalent expression.  Otherwise return NULL.  */"}, {"sha": "4c1e3aa54dbcb770455e88149a2c976d1fa12f4a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=933a73251d95fb930028cb76eee7a892f41f867b", "patch": "@@ -180,6 +180,8 @@ static GTY(()) vec<tree, va_gc> *gnu_return_var_stack;\n struct GTY(()) range_check_info_d {\n   tree low_bound;\n   tree high_bound;\n+  tree disp;\n+  bool neg_p;\n   tree type;\n   tree invariant_cond;\n   tree inserted_cond;\n@@ -2638,15 +2640,36 @@ inside_loop_p (void)\n   return !vec_safe_is_empty (gnu_loop_stack);\n }\n \n-/* Find out whether VAR is the iteration variable of an enclosing loop in the\n-   current function.  If so, return the loop; otherwise, return NULL.  */\n+/* Find out whether EXPR is a simple additive expression based on the iteration\n+   variable of some enclosing loop in the current function.  If so, return the\n+   loop and set *DISP to the displacement and *NEG_P to true if this is for a\n+   subtraction; otherwise, return NULL.  */\n \n static struct loop_info_d *\n-find_loop_for (tree var)\n+find_loop_for (tree expr, tree *disp = NULL, bool *neg_p = NULL)\n {\n+  tree var, add, cst;\n+  bool minus_p;\n   struct loop_info_d *iter = NULL;\n   unsigned int i;\n \n+  if (is_simple_additive_expression (expr, &add, &cst, &minus_p))\n+    {\n+      var = add;\n+      if (disp)\n+\t*disp = cst;\n+      if (neg_p)\n+\t*neg_p = minus_p;\n+    }\n+  else\n+    {\n+      var = expr;\n+      if (disp)\n+\t*disp =  NULL_TREE;\n+      if (neg_p)\n+\t*neg_p = false;\n+    }\n+\n   var = remove_conversions (var, false);\n \n   if (TREE_CODE (var) != VAR_DECL)\n@@ -3123,19 +3146,35 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n \t  FOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)\n \t    {\n-\t      tree low_ok\n-\t\t= rci->low_bound\n-\t\t  ? build_binary_op (GE_EXPR, boolean_type_node,\n-\t\t\t\t     convert (rci->type, gnu_low),\n-\t\t\t\t     rci->low_bound)\n-\t\t  : boolean_true_node;\n-\n-\t      tree high_ok\n-\t\t= rci->high_bound\n-\t\t  ? build_binary_op (LE_EXPR, boolean_type_node,\n-\t\t\t\t     convert (rci->type, gnu_high),\n-\t\t\t\t     rci->high_bound)\n-\t\t  : boolean_true_node;\n+\t      tree low_ok, high_ok;\n+\n+\t      if (rci->low_bound)\n+\t\t{\n+\t\t  tree gnu_adjusted_low = convert (rci->type, gnu_low);\n+\t\t  if (rci->disp)\n+\t\t    gnu_adjusted_low\n+\t\t      = fold_build2 (rci->neg_p ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\t     rci->type, gnu_adjusted_low, rci->disp);\n+\t\t  low_ok\n+\t\t    = build_binary_op (GE_EXPR, boolean_type_node,\n+\t\t\t\t       gnu_adjusted_low, rci->low_bound);\n+\t\t}\n+\t      else\n+\t\tlow_ok = boolean_true_node;\n+\n+\t      if (rci->high_bound)\n+\t\t{\n+\t\t  tree gnu_adjusted_high = convert (rci->type, gnu_high);\n+\t\t  if (rci->disp)\n+\t\t    gnu_adjusted_high\n+\t\t      = fold_build2 (rci->neg_p ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\t     rci->type, gnu_adjusted_high, rci->disp);\n+\t\t  high_ok\n+\t\t    = build_binary_op (LE_EXPR, boolean_type_node,\n+\t\t\t\t       gnu_adjusted_high, rci->high_bound);\n+\t\t}\n+\t      else\n+\t\thigh_ok = boolean_true_node;\n \n \t      tree range_ok\n \t\t= build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n@@ -5492,7 +5531,8 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       if (Present (gnat_cond) && Nkind (gnat_cond) == N_Op_Not)\n \t{\n \t  Node_Id gnat_range, gnat_index, gnat_type;\n-\t  tree gnu_index, gnu_low_bound, gnu_high_bound;\n+\t  tree gnu_index, gnu_low_bound, gnu_high_bound, disp;\n+\t  bool neg_p;\n \t  struct loop_info_d *loop;\n \n \t  switch (Nkind (Right_Opnd (gnat_cond)))\n@@ -5559,11 +5599,13 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t  || (gnu_low_bound = gnat_invariant_expr (gnu_low_bound)))\n \t      && (!gnu_high_bound\n \t\t  || (gnu_high_bound = gnat_invariant_expr (gnu_high_bound)))\n-\t      && (loop = find_loop_for (gnu_index)))\n+\t      && (loop = find_loop_for (gnu_index, &disp, &neg_p)))\n \t    {\n \t      struct range_check_info_d *rci = ggc_alloc<range_check_info_d> ();\n \t      rci->low_bound = gnu_low_bound;\n \t      rci->high_bound = gnu_high_bound;\n+\t      rci->disp = disp;\n+\t      rci->neg_p = neg_p;\n \t      rci->type = get_unpadded_type (gnat_type);\n \t      rci->inserted_cond\n \t\t= build1 (SAVE_EXPR, boolean_type_node, boolean_true_node);\n@@ -6197,7 +6239,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t&& tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_type)),\n \t\t\t\t       TYPE_MAX_VALUE (TYPE_DOMAIN (gnu_type)))\n \t\t&& !array_at_struct_end_p (gnu_result)\n-\t\t&& (loop = find_loop_for (skip_simple_arithmetic (gnu_expr)))\n+\t\t&& (loop = find_loop_for (gnu_expr))\n \t\t&& !loop->artificial\n \t\t&& !loop->has_checks\n \t\t&& tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_type)),"}, {"sha": "ca307f36b4b0abab3ddc53fbc767153d8ab52ce2", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=933a73251d95fb930028cb76eee7a892f41f867b", "patch": "@@ -2813,6 +2813,52 @@ get_inner_constant_reference (tree exp)\n   return exp;\n }\n \n+/* Return true if EXPR is the addition or the subtraction of a constant and,\n+   if so, set *ADD to the addend, *CST to the constant and *MINUS_P to true\n+   if this is a subtraction.  */\n+\n+bool\n+is_simple_additive_expression (tree expr, tree *add, tree *cst, bool *minus_p)\n+{\n+  /* Skip overflow checks.  */\n+  if (TREE_CODE (expr) == COND_EXPR\n+      && TREE_CODE (COND_EXPR_THEN (expr)) == COMPOUND_EXPR\n+      && TREE_CODE (TREE_OPERAND (COND_EXPR_THEN (expr), 0)) == CALL_EXPR\n+      && get_callee_fndecl (TREE_OPERAND (COND_EXPR_THEN (expr), 0))\n+         == gnat_raise_decls[CE_Overflow_Check_Failed])\n+    expr = COND_EXPR_ELSE (expr);\n+\n+  if (TREE_CODE (expr) == PLUS_EXPR)\n+    {\n+      if (TREE_CONSTANT (TREE_OPERAND (expr, 0)))\n+\t{\n+\t  *add = TREE_OPERAND (expr, 1);\n+\t  *cst = TREE_OPERAND (expr, 0);\n+\t  *minus_p = false;\n+\t  return true;\n+\t}\n+      else if (TREE_CONSTANT (TREE_OPERAND (expr, 1)))\n+\t{\n+\t  *add = TREE_OPERAND (expr, 0);\n+\t  *cst = TREE_OPERAND (expr, 1);\n+\t  *minus_p = false;\n+\t  return true;\n+\t}\n+    }\n+  else if (TREE_CODE (expr) == MINUS_EXPR)\n+    {\n+      if (TREE_CONSTANT (TREE_OPERAND (expr, 1)))\n+\t{\n+\t  *add = TREE_OPERAND (expr, 0);\n+\t  *cst = TREE_OPERAND (expr, 1);\n+\t  *minus_p = true;\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* If EXPR is an expression that is invariant in the current function, in the\n    sense that it can be evaluated anywhere in the function and any number of\n    times, return EXPR or an equivalent expression.  Otherwise return NULL.  */\n@@ -2821,6 +2867,8 @@ tree\n gnat_invariant_expr (tree expr)\n {\n   const tree type = TREE_TYPE (expr);\n+  tree add, cst;\n+  bool minus_p;\n \n   expr = remove_conversions (expr, false);\n \n@@ -2846,23 +2894,14 @@ gnat_invariant_expr (tree expr)\n   if (TREE_CONSTANT (expr))\n     return fold_convert (type, expr);\n \n-  /* Skip overflow checks since they don't change the invariantness.  */\n-  if (TREE_CODE (expr) == COND_EXPR\n-      && TREE_CODE (COND_EXPR_THEN (expr)) == COMPOUND_EXPR\n-      && TREE_CODE (TREE_OPERAND (COND_EXPR_THEN (expr), 0)) == CALL_EXPR\n-      && get_callee_fndecl (TREE_OPERAND (COND_EXPR_THEN (expr), 0))\n-         == gnat_raise_decls[CE_Overflow_Check_Failed])\n-    expr = COND_EXPR_ELSE (expr);\n-\n   /* Deal with addition or subtraction of constants.  */\n-  if (TREE_CODE (expr) == PLUS_EXPR || TREE_CODE (expr) == MINUS_EXPR)\n+  if (is_simple_additive_expression (expr, &add, &cst, &minus_p))\n     {\n-      tree op0 = gnat_invariant_expr (TREE_OPERAND (expr, 0));\n-      tree op1 = TREE_OPERAND (expr, 1);\n-      if (op0 && TREE_CONSTANT (op1))\n+      add = gnat_invariant_expr (add);\n+      if (add)\n \treturn\n-\t  fold_build2 (TREE_CODE (expr), type,\n-\t\t       fold_convert (type, op0), fold_convert (type, op1));\n+\t  fold_build2 (minus_p ? MINUS_EXPR : PLUS_EXPR, type,\n+\t\t       fold_convert (type, add), fold_convert (type, cst));\n       else\n \treturn NULL_TREE;\n     }"}, {"sha": "008d07360a8af0d1feb44e3828fc57db2e9adaf5", "filename": "gcc/testsuite/gnat.dg/loop_optimization22.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization22.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933a73251d95fb930028cb76eee7a892f41f867b/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization22.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization22.adb?ref=933a73251d95fb930028cb76eee7a892f41f867b", "patch": "@@ -1,5 +1,5 @@\n -- { dg-do compile }\n--- { dg-options \"-O\" }\n+-- { dg-options \"-O -fdump-tree-optimized\" }\n \n pragma Overflow_Mode (Minimized);\n \n@@ -14,3 +14,5 @@ package body Loop_Optimization22 is\n    end;\n \n end Loop_Optimization22;\n+\n+-- { dg-final { scan-tree-dump-not \"Index_Check\" \"optimized\" } }"}]}