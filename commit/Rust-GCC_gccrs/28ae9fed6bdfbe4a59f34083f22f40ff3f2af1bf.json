{"sha": "28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhhZTlmZWQ2YmRmYmU0YTU5ZjM0MDgzZjIyZjQwZmYzZjJhZjFiZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-02-28T00:30:50Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-02-28T00:30:50Z"}, "message": "reload1.c (sext_for_mode): Remove.\n\n\t* reload1.c (sext_for_mode): Remove.\n\t(reload_cse_move2add): Use trunc_int_for_mode instead of\n\tsext_for_mode.\n\t(move2add_note_store): Likewise.\n\tReset register information if we see a set in non-integer\n\tmode.\n\nFrom-SVN: r63540", "tree": {"sha": "f573a168a5ffcef1116b0a72802ec931307b32bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f573a168a5ffcef1116b0a72802ec931307b32bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf/comments", "author": null, "committer": null, "parents": [{"sha": "c5cf6d7d480ab1f1d3b9922741db419aa616b934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cf6d7d480ab1f1d3b9922741db419aa616b934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5cf6d7d480ab1f1d3b9922741db419aa616b934"}], "stats": {"total": 61, "additions": 26, "deletions": 35}, "files": [{"sha": "46814ac11bfa5ee015ec33a7cceb81a0dcd83be5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf", "patch": "@@ -1,3 +1,12 @@\n+2003-02-27  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* reload1.c (sext_for_mode): Remove.\n+\t(reload_cse_move2add): Use trunc_int_for_mode instead of\n+\tsext_for_mode.\n+\t(move2add_note_store): Likewise.\n+\tReset register information if we see a set in non-integer\n+\tmode.\n+\n 2003-02-27  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/aix43.h (ASM_SPEC): Only emit -mppc64 if no -mcpu"}, {"sha": "06b53f73597a41e4c197620f2982d5b22af0f216", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=28ae9fed6bdfbe4a59f34083f22f40ff3f2af1bf", "patch": "@@ -455,8 +455,6 @@ static void move2add_note_store\t\tPARAMS ((rtx, rtx, void *));\n static void add_auto_inc_notes\t\tPARAMS ((rtx, rtx));\n #endif\n static void copy_eh_notes\t\tPARAMS ((rtx, rtx));\n-static HOST_WIDE_INT sext_for_mode\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n static void failed_reload\t\tPARAMS ((rtx, int));\n static int set_reload_reg\t\tPARAMS ((int, int));\n static void reload_cse_simplify\t\tPARAMS ((rtx, rtx));\n@@ -9084,25 +9082,6 @@ static int move2add_luid;\n    invalidate all previously collected reg_offset data.  */\n static int move2add_last_label_luid;\n \n-/* Generate a CONST_INT and force it in the range of MODE.  */\n-\n-static HOST_WIDE_INT\n-sext_for_mode (mode, value)\n-     enum machine_mode mode;\n-     HOST_WIDE_INT value;\n-{\n-  HOST_WIDE_INT cval = value & GET_MODE_MASK (mode);\n-  int width = GET_MODE_BITSIZE (mode);\n-\n-  /* If MODE is narrower than HOST_WIDE_INT and CVAL is a negative number,\n-     sign extend it.  */\n-  if (width > 0 && width < HOST_BITS_PER_WIDE_INT\n-      && (cval & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n-    cval |= (HOST_WIDE_INT) -1 << width;\n-\n-  return cval;\n-}\n-\n /* ??? We don't know how zero / sign extension is handled, hence we\n    can't go from a narrower to a wider mode.  */\n #define MODES_OK_FOR_MOVE2ADD(OUTMODE, INMODE) \\\n@@ -9169,9 +9148,10 @@ reload_cse_move2add (first)\n \t      if (GET_CODE (src) == CONST_INT && reg_base_reg[regno] < 0)\n \t\t{\n \t\t  int success = 0;\n-\t\t  rtx new_src = GEN_INT (sext_for_mode (GET_MODE (reg),\n-\t\t\t\t\t\t\tINTVAL (src)\n-\t\t\t\t\t\t\t- reg_offset[regno]));\n+\t\t  rtx new_src =\n+\t\t    GEN_INT (trunc_int_for_mode (INTVAL (src)\n+\t\t\t\t\t\t - reg_offset[regno],\n+\t\t\t\t\t\t GET_MODE (reg)));\n \t\t  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n \t\t     use (set (reg) (reg)) instead.\n \t\t     We don't delete this insn, nor do we convert it into a\n@@ -9250,10 +9230,11 @@ reload_cse_move2add (first)\n \t\t      HOST_WIDE_INT added_offset = INTVAL (src3);\n \t\t      HOST_WIDE_INT base_offset = reg_offset[REGNO (src)];\n \t\t      HOST_WIDE_INT regno_offset = reg_offset[regno];\n-\t\t      rtx new_src = GEN_INT (sext_for_mode (GET_MODE (reg),\n-\t\t\t\t\t\t\t    added_offset\n-\t\t\t\t\t\t\t    + base_offset\n-\t\t\t\t\t\t\t    - regno_offset));\n+\t\t      rtx new_src =\n+\t\t\tGEN_INT (trunc_int_for_mode (added_offset\n+\t\t\t\t\t\t     + base_offset\n+\t\t\t\t\t\t     - regno_offset,\n+\t\t\t\t\t\t     GET_MODE (reg)));\n \t\t      int success = 0;\n \n \t\t      if (new_src == const0_rtx)\n@@ -9270,9 +9251,9 @@ reload_cse_move2add (first)\n \t\t\tdelete_insn (insn);\n \t\t      insn = next;\n \t\t      reg_mode[regno] = GET_MODE (reg);\n-\t\t      reg_offset[regno] = sext_for_mode (GET_MODE (reg),\n-\t\t\t\t\t\t\t added_offset\n-\t\t\t\t\t\t\t + base_offset);\n+\t\t      reg_offset[regno] =\n+\t\t\ttrunc_int_for_mode (added_offset + base_offset,\n+\t\t\t\t\t    GET_MODE (reg));\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -9342,7 +9323,8 @@ move2add_note_store (dst, set, data)\n \n   regno += REGNO (dst);\n \n-  if (HARD_REGNO_NREGS (regno, mode) == 1 && GET_CODE (set) == SET\n+  if (SCALAR_INT_MODE_P (mode)\n+      && HARD_REGNO_NREGS (regno, mode) == 1 && GET_CODE (set) == SET\n       && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n       && GET_CODE (SET_DEST (set)) != SIGN_EXTRACT\n       && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n@@ -9437,9 +9419,9 @@ move2add_note_store (dst, set, data)\n       reg_base_reg[regno] = reg_base_reg[base_regno];\n \n       /* Compute the sum of the offsets or constants.  */\n-      reg_offset[regno] = sext_for_mode (dst_mode,\n-\t\t\t\t\t offset\n-\t\t\t\t\t + reg_offset[base_regno]);\n+      reg_offset[regno] = trunc_int_for_mode (offset\n+\t\t\t\t\t      + reg_offset[base_regno],\n+\t\t\t\t\t      dst_mode);\n     }\n   else\n     {"}]}