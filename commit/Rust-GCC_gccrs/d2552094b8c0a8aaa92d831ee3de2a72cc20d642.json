{"sha": "d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI1NTIwOTRiOGMwYThhYWE5MmQ4MzFlZTNkZTJhNzJjYzIwZDY0Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-09-27T11:09:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-09-27T11:09:41Z"}, "message": "invoke.texi (graphite-max-bbs-per-function): Remove.\n\n2017-09-27  Richard Biener  <rguenther@suse.de>\n\n\t* doc/invoke.texi (graphite-max-bbs-per-function): Remove.\n\t(graphite-max-nb-scop-params): Document special value zero.\n\t* domwalk.h (dom_walker::STOP): New symbolical constant.\n\t(dom_walker::dom_walker): Add optional parameter for bb to\n\tRPO mapping.\n\t(dom_walker::~dom_walker): Declare.\n\t(dom_walker::before_dom_children): Document STOP return value.\n\t(dom_walker::m_user_bb_to_rpo): New member.\n\t(dom_walker::m_bb_to_rpo): Likewise.\n\t* domwalk.c (dom_walker::dom_walker): Compute bb to RPO\n\tmapping here if not provided by the user.\n\t(dom_walker::~dom_walker): Free bb to RPO mapping if not\n\tprovided by the user.\n\t(dom_walker::STOP): Define.\n\t(dom_walker::walk): Do not compute bb to RPO mapping here.\n\tSupport STOP return value from before_dom_children to stop\n\twalking.\n\t* graphite-optimize-isl.c (optimize_isl): If the schedule\n\tis the same still generate code if -fgraphite-identity\n\tor -floop-parallelize-all are given.\n\t* graphite-scop-detection.c: Include cfganal.h.\n\t(gather_bbs::gather_bbs): Get and pass through bb to RPO\n\tmapping.\n\t(gather_bbs::before_dom_children): Return STOP for BBs\n\tnot in the region.\n\t(build_scops): Compute bb to RPO mapping and pass it to\n\tthe domwalk.  Treat --param graphite-max-nb-scop-params=0\n\tas not limiting the number of params.\n\t* graphite.c (graphite_initialize): Remove limit on the\n\tnumber of basic-blocks in a function.\n\t* params.def (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION): Remove.\n\t(PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS): Adjust to documented\n\tdefault value of 10.\n\nFrom-SVN: r253226", "tree": {"sha": "3e306d8393299ba97b86fc3fe866102ac26afda8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e306d8393299ba97b86fc3fe866102ac26afda8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04620f22b03308e89d0cc2ceefd8bc8eca19979d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04620f22b03308e89d0cc2ceefd8bc8eca19979d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04620f22b03308e89d0cc2ceefd8bc8eca19979d"}], "stats": {"total": 184, "additions": 121, "deletions": 63}, "files": [{"sha": "8d2edda74ee9002b420dcce2f473a8adca305140", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -1,3 +1,39 @@\n+2017-09-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* doc/invoke.texi (graphite-max-bbs-per-function): Remove.\n+\t(graphite-max-nb-scop-params): Document special value zero.\n+\t* domwalk.h (dom_walker::STOP): New symbolical constant.\n+\t(dom_walker::dom_walker): Add optional parameter for bb to\n+\tRPO mapping.\n+\t(dom_walker::~dom_walker): Declare.\n+\t(dom_walker::before_dom_children): Document STOP return value.\n+\t(dom_walker::m_user_bb_to_rpo): New member.\n+\t(dom_walker::m_bb_to_rpo): Likewise.\n+\t* domwalk.c (dom_walker::dom_walker): Compute bb to RPO\n+\tmapping here if not provided by the user.\n+\t(dom_walker::~dom_walker): Free bb to RPO mapping if not\n+\tprovided by the user.\n+\t(dom_walker::STOP): Define.\n+\t(dom_walker::walk): Do not compute bb to RPO mapping here.\n+\tSupport STOP return value from before_dom_children to stop\n+\twalking.\n+\t* graphite-optimize-isl.c (optimize_isl): If the schedule\n+\tis the same still generate code if -fgraphite-identity\n+\tor -floop-parallelize-all are given.\n+\t* graphite-scop-detection.c: Include cfganal.h.\n+\t(gather_bbs::gather_bbs): Get and pass through bb to RPO\n+\tmapping.\n+\t(gather_bbs::before_dom_children): Return STOP for BBs\n+\tnot in the region.\n+\t(build_scops): Compute bb to RPO mapping and pass it to\n+\tthe domwalk.  Treat --param graphite-max-nb-scop-params=0\n+\tas not limiting the number of params.\n+\t* graphite.c (graphite_initialize): Remove limit on the\n+\tnumber of basic-blocks in a function.\n+\t* params.def (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION): Remove.\n+\t(PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS): Adjust to documented\n+\tdefault value of 10.\n+\n 2017-09-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/vsx.md (peephole for optimizing move SF to GPR):"}, {"sha": "f862b7f8c99e7e9cca200fbe5b7d969748fed3f9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -10512,13 +10512,9 @@ sequence pairs.  This option only applies when using\n @item graphite-max-nb-scop-params\n To avoid exponential effects in the Graphite loop transforms, the\n number of parameters in a Static Control Part (SCoP) is bounded.  The\n-default value is 10 parameters.  A variable whose value is unknown at\n-compilation time and defined outside a SCoP is a parameter of the SCoP.\n-\n-@item graphite-max-bbs-per-function\n-To avoid exponential effects in the detection of SCoPs, the size of\n-the functions analyzed by Graphite is bounded.  The default value is\n-100 basic blocks.\n+default value is 10 parameters, a value of zero can be used to lift\n+the bound.  A variable whose value is unknown at compilation time and\n+defined outside a SCoP is a parameter of the SCoP.\n \n @item loop-block-tile-size\n Loop blocking or strip mining transforms, enabled with"}, {"sha": "102a2936ba43679cdc8c3952ae3d0053fe946055", "filename": "gcc/domwalk.c", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -174,13 +174,29 @@ sort_bbs_postorder (basic_block *bbs, int n)\n    If SKIP_UNREACHBLE_BLOCKS is true, then we need to set\n    EDGE_EXECUTABLE on every edge in the CFG. */\n dom_walker::dom_walker (cdi_direction direction,\n-\t\t\tbool skip_unreachable_blocks)\n+\t\t\tbool skip_unreachable_blocks,\n+\t\t\tint *bb_index_to_rpo)\n   : m_dom_direction (direction),\n     m_skip_unreachable_blocks (skip_unreachable_blocks),\n-    m_unreachable_dom (NULL)\n+    m_user_bb_to_rpo (bb_index_to_rpo != NULL),\n+    m_unreachable_dom (NULL),\n+    m_bb_to_rpo (bb_index_to_rpo)\n {\n+  /* Compute the basic-block index to RPO mapping if not provided by\n+     the user.  */\n+  if (! m_bb_to_rpo && direction == CDI_DOMINATORS)\n+    {\n+      int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n+      int postorder_num = pre_and_rev_post_order_compute (NULL, postorder,\n+\t\t\t\t\t\t\t  true);\n+      m_bb_to_rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+      for (int i = 0; i < postorder_num; ++i)\n+\tm_bb_to_rpo[postorder[i]] = i;\n+      free (postorder);\n+    }\n+\n   /* If we are not skipping unreachable blocks, then there is nothing\n-     to do.  */\n+     further to do.  */\n   if (!m_skip_unreachable_blocks)\n     return;\n \n@@ -194,6 +210,14 @@ dom_walker::dom_walker (cdi_direction direction,\n     }\n }\n \n+/* Destructor.  */\n+\n+dom_walker::~dom_walker ()\n+{\n+  if (! m_user_bb_to_rpo)\n+    free (m_bb_to_rpo);\n+}\n+\n /* Return TRUE if BB is reachable, false otherwise.  */\n \n bool\n@@ -254,6 +278,8 @@ dom_walker::propagate_unreachable_to_edges (basic_block bb,\n     m_unreachable_dom = bb;\n }\n \n+const edge dom_walker::STOP = (edge)-1;\n+\n /* Recursively walk the dominator tree.\n    BB is the basic block we are currently visiting.  */\n \n@@ -264,17 +290,7 @@ dom_walker::walk (basic_block bb)\n   basic_block *worklist = XNEWVEC (basic_block,\n \t\t\t\t   n_basic_blocks_for_fn (cfun) * 2);\n   int sp = 0;\n-  int *postorder, postorder_num;\n-\n-  if (m_dom_direction == CDI_DOMINATORS)\n-    {\n-      postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n-      postorder_num = pre_and_rev_post_order_compute (NULL, postorder, true);\n-      bb_postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-      for (int i = 0; i < postorder_num; ++i)\n-\tbb_postorder[postorder[i]] = i;\n-      free (postorder);\n-    }\n+  bb_postorder = m_bb_to_rpo;\n \n   while (true)\n     {\n@@ -283,13 +299,14 @@ dom_walker::walk (basic_block bb)\n \t  || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n+\t  edge taken_edge = NULL;\n \n \t  /* Callback for subclasses to do custom things before we have walked\n \t     the dominator children, but before we walk statements.  */\n \t  if (this->bb_reachable (cfun, bb))\n \t    {\n-\t      edge taken_edge = before_dom_children (bb);\n-\t      if (taken_edge)\n+\t      taken_edge = before_dom_children (bb);\n+\t      if (taken_edge && taken_edge != STOP)\n \t\t{\n \t\t  edge_iterator ei;\n \t\t  edge e;\n@@ -306,12 +323,17 @@ dom_walker::walk (basic_block bb)\n \t  worklist[sp++] = bb;\n \t  worklist[sp++] = NULL;\n \n-\t  int saved_sp = sp;\n-\t  for (dest = first_dom_son (m_dom_direction, bb);\n-\t       dest; dest = next_dom_son (m_dom_direction, dest))\n-\t    worklist[sp++] = dest;\n-\t  if (sp - saved_sp > 1 && m_dom_direction == CDI_DOMINATORS)\n-\t    sort_bbs_postorder (&worklist[saved_sp], sp - saved_sp);\n+\t  /* If the callback returned NONE then we are supposed to\n+\t     stop and not even propagate EDGE_EXECUTABLE further.  */\n+\t  if (taken_edge != STOP)\n+\t    {\n+\t      int saved_sp = sp;\n+\t      for (dest = first_dom_son (m_dom_direction, bb);\n+\t\t   dest; dest = next_dom_son (m_dom_direction, dest))\n+\t\tworklist[sp++] = dest;\n+\t      if (sp - saved_sp > 1 && m_dom_direction == CDI_DOMINATORS)\n+\t\tsort_bbs_postorder (&worklist[saved_sp], sp - saved_sp);\n+\t    }\n \t}\n       /* NULL is used to mark pop operations in the recursion stack.  */\n       while (sp > 0 && !worklist[sp - 1])\n@@ -331,10 +353,6 @@ dom_walker::walk (basic_block bb)\n       else\n \tbreak;\n     }\n-  if (m_dom_direction == CDI_DOMINATORS)\n-    {\n-      free (bb_postorder);\n-      bb_postorder = NULL;\n-    }\n+  bb_postorder = NULL;\n   free (worklist);\n }"}, {"sha": "6ac93eb06ad6aa45ae21c0c47de4e1e12b89b53d", "filename": "gcc/domwalk.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -30,14 +30,22 @@ along with GCC; see the file COPYING3.  If not see\n class dom_walker\n {\n public:\n+  static const edge STOP;\n+\n   /* Use SKIP_UNREACHBLE_BLOCKS = true when your client can discover\n      that some edges are not executable.\n \n      If a client can discover that a COND, SWITCH or GOTO has a static\n      target in the before_dom_children callback, the taken edge should\n      be returned.  The generic walker will clear EDGE_EXECUTABLE on all\n-     edges it can determine are not executable.  */\n-  dom_walker (cdi_direction direction, bool skip_unreachable_blocks = false);\n+     edges it can determine are not executable.\n+     \n+     You can provide a mapping of basic-block index to RPO if you\n+     have that readily available or you do multiple walks.  */\n+  dom_walker (cdi_direction direction, bool skip_unreachable_blocks = false,\n+\t      int *bb_index_to_rpo = NULL);\n+\n+  ~dom_walker ();\n \n   /* Walk the dominator tree.  */\n   void walk (basic_block);\n@@ -48,7 +56,10 @@ class dom_walker\n      edges, NULL otherwise.  When skipping unreachable blocks, the walker\n      uses the taken edge information to clear EDGE_EXECUTABLE on the other\n      edges, exposing unreachable blocks.  A NULL return value means all\n-     outgoing edges should still be considered executable.  */\n+     outgoing edges should still be considered executable.  A return value\n+     of STOP means to stop the domwalk from processing dominated blocks from\n+     here.  This can be used to process a SEME region only (note domwalk\n+     will still do work linear in function size).  */\n   virtual edge before_dom_children (basic_block) { return NULL; }\n \n   /* Function to call after the recursive walk of the dominator children.  */\n@@ -61,7 +72,9 @@ class dom_walker\n      dominator tree.  */\n   const ENUM_BITFIELD (cdi_direction) m_dom_direction : 2;\n   bool m_skip_unreachable_blocks;\n+  bool m_user_bb_to_rpo;\n   basic_block m_unreachable_dom;\n+  int *m_bb_to_rpo;\n \n   /* Query whether or not the given block is reachable or not.  */\n   bool bb_reachable (struct function *, basic_block);"}, {"sha": "2f3c4fc533f1dd00b75eef045cb7e380b23e8c9f", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -189,7 +189,7 @@ optimize_isl (scop_p scop)\n \tprint_schedule_ast (dump_file, scop->original_schedule, scop);\n       isl_schedule_free (scop->transformed_schedule);\n       scop->transformed_schedule = isl_schedule_copy (scop->original_schedule);\n-      return false;\n+      return flag_graphite_identity || flag_loop_parallelize_all;\n     }\n \n   return true;"}, {"sha": "3b1492fbfa8b167d324e495752f778931019da8c", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"cfganal.h\"\n #include \"graphite.h\"\n \n class debug_printer\n@@ -1544,7 +1545,7 @@ build_alias_set (scop_p scop)\n class gather_bbs : public dom_walker\n {\n public:\n-  gather_bbs (cdi_direction, scop_p);\n+  gather_bbs (cdi_direction, scop_p, int *);\n \n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n@@ -1554,8 +1555,8 @@ class gather_bbs : public dom_walker\n   scop_p scop;\n };\n }\n-gather_bbs::gather_bbs (cdi_direction direction, scop_p scop)\n-  : dom_walker (direction), scop (scop)\n+gather_bbs::gather_bbs (cdi_direction direction, scop_p scop, int *bb_to_rpo)\n+  : dom_walker (direction, false, bb_to_rpo), scop (scop)\n {\n }\n \n@@ -1589,7 +1590,7 @@ gather_bbs::before_dom_children (basic_block bb)\n {\n   sese_info_p region = scop->scop_info;\n   if (!bb_in_sese_p (bb, region->region))\n-    return NULL;\n+    return dom_walker::STOP;\n \n   record_loop_in_sese (bb, region);\n \n@@ -1708,14 +1709,23 @@ build_scops (vec<scop_p> *scops)\n \n   /* Now create scops from the lightweight SESEs.  */\n   vec<sese_l> scops_l = sb.get_scops ();\n+\n+  /* Domwalk needs a bb to RPO mapping.  Compute it once here.  */\n+  int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n+  int postorder_num = pre_and_rev_post_order_compute (NULL, postorder, true);\n+  int *bb_to_rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  for (int i = 0; i < postorder_num; ++i)\n+    bb_to_rpo[postorder[i]] = i;\n+  free (postorder);\n+\n   int i;\n   sese_l *s;\n   FOR_EACH_VEC_ELT (scops_l, i, s)\n     {\n       scop_p scop = new_scop (s->entry, s->exit);\n \n       /* Record all basic blocks and their conditions in REGION.  */\n-      gather_bbs (CDI_DOMINATORS, scop).walk (s->entry->dest);\n+      gather_bbs (CDI_DOMINATORS, scop, bb_to_rpo).walk (s->entry->dest);\n \n       /* domwalk does not fulfil our code-generations constraints on the\n          order of pbb which is to produce sth like execution order, delaying\n@@ -1757,8 +1767,8 @@ build_scops (vec<scop_p> *scops)\n \n       find_scop_parameters (scop);\n       graphite_dim_t max_dim = PARAM_VALUE (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS);\n-\n-      if (scop_nb_params (scop) > max_dim)\n+      if (max_dim > 0\n+\t  && scop_nb_params (scop) > max_dim)\n \t{\n \t  DEBUG_PRINT (dp << \"[scop-detection-fail] too many parameters: \"\n \t\t\t  << scop_nb_params (scop)\n@@ -1771,6 +1781,7 @@ build_scops (vec<scop_p> *scops)\n       scops->safe_push (scop);\n     }\n \n+  free (bb_to_rpo);\n   DEBUG_PRINT (dp << \"number of SCoPs: \" << (scops ? scops->length () : 0););\n }\n "}, {"sha": "0bdcc28cba8a3f0f775bbbae88aaa0c0365fbabb", "filename": "gcc/graphite.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -218,14 +218,9 @@ static bool\n graphite_initialize (void)\n {\n   int min_loops = PARAM_VALUE (PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION);\n-  int max_bbs = PARAM_VALUE (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION);\n-  int nbbs = n_basic_blocks_for_fn (cfun);\n   int nloops = number_of_loops (cfun);\n \n-  if (nloops <= min_loops\n-      /* FIXME: This limit on the number of basic blocks of a function\n-\t should be removed when the SCOP detection is faster.  */\n-      || (nbbs > max_bbs))\n+  if (nloops <= min_loops)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -234,10 +229,6 @@ graphite_initialize (void)\n \t\t     \"PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION = %d.\\n\",\n \t\t     min_loops);\n \n-\t  else if (nbbs > max_bbs)\n-\t    fprintf (dump_file, \"\\nFunction has too many basic blocks: \"\n-\t\t     \"PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION = %d.\\n\", max_bbs);\n-\n \t  fprintf (dump_file, \"\\nnumber of SCoPs: 0\\n\");\n \t  print_global_statistics (dump_file);\n \t}"}, {"sha": "136f9270366c796108565a3d40f2df842a0fe589", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2552094b8c0a8aaa92d831ee3de2a72cc20d642/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=d2552094b8c0a8aaa92d831ee3de2a72cc20d642", "patch": "@@ -873,14 +873,7 @@ DEFPARAM (PARAM_LOOP_BLOCK_TILE_SIZE,\n DEFPARAM (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS,\n \t  \"graphite-max-nb-scop-params\",\n \t  \"maximum number of parameters in a SCoP.\",\n-\t  7, 0, 0)\n-\n-/* Maximal number of basic blocks in the functions analyzed by Graphite.  */\n-\n-DEFPARAM (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION,\n-\t  \"graphite-max-bbs-per-function\",\n-\t  \"maximum number of basic blocks per function to be analyzed by Graphite.\",\n-\t  100, 0, 0)\n+\t  10, 0, 0)\n \n /* Maximal number of array references in a scop.  */\n "}]}