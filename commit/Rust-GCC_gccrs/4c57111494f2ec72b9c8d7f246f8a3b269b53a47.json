{"sha": "4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM1NzExMTQ5NGYyZWM3MmI5YzhkN2YyNDZmOGEzYjI2OWI1M2E0Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-01-06T23:38:05Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-01-06T23:38:05Z"}, "message": "cp-tree.h (IDENTIFIER_TYPENAME_P): Use OPERATOR_TYPENAME_FORMAT here.\n\n        * cp-tree.h (IDENTIFIER_TYPENAME_P): Use OPERATOR_TYPENAME_FORMAT\n\there.\n\t(lang_type): Add is_partial_instantiation.  Decrease width of\n\tdummy.\n\t(PARTIAL_INSTANTIATION_P): New macro.\n\t(OPERATOR_TYPENAME_P): Remove.\n\t* decl.c (unary_op_p): Use IDENTIFIER_TYPENAME_P, not\n\tOPERATOR_TYPENAME_P.\n\t(grok_op_properties): Likewise.\n\t* friend.c (do_friend): Handle friends that are member functions\n\tcorrectly.\n\t* lex.c (init_parse): Use OPERATOR_TYPENAME_FORMAT.\n\t* pt.c (instantiate_class_template): Rework for clarity.  Avoid\n\tleaving TYPE_BEING_DEFINED set in obscure cases.  Don't do\n\tany more partial instantiation than is absolutely necessary for\n\timplicit typename.  Set PARTIAL_INSTANTIATION_P.\n\t(tsubst_decl): Use IDENTIFIER_TYPENAME_P.\n\t* semantics.c (begin_class_definition): Handle partial\n\tspecializations of a type that was previously partially\n\tinstantiated.\n\nFrom-SVN: r24548", "tree": {"sha": "54971386a4f6d1b749198b7ad7cac52a63c0a7d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54971386a4f6d1b749198b7ad7cac52a63c0a7d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/comments", "author": null, "committer": null, "parents": [{"sha": "70186b342c44e983d7005488b9427f0d00907ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70186b342c44e983d7005488b9427f0d00907ae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70186b342c44e983d7005488b9427f0d00907ae8"}], "stats": {"total": 280, "additions": 207, "deletions": 73}, "files": [{"sha": "478180ab80ea5cf4883973883a655ed7d0f29ebe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -1,3 +1,26 @@\n+1999-01-06  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (IDENTIFIER_TYPENAME_P): Use OPERATOR_TYPENAME_FORMAT\n+\there. \n+\t(lang_type): Add is_partial_instantiation.  Decrease width of\n+\tdummy. \n+\t(PARTIAL_INSTANTIATION_P): New macro.\n+\t(OPERATOR_TYPENAME_P): Remove.\n+\t* decl.c (unary_op_p): Use IDENTIFIER_TYPENAME_P, not\n+\tOPERATOR_TYPENAME_P. \n+\t(grok_op_properties): Likewise.\n+\t* friend.c (do_friend): Handle friends that are member functions\n+\tcorrectly. \n+\t* lex.c (init_parse): Use OPERATOR_TYPENAME_FORMAT.\n+\t* pt.c (instantiate_class_template): Rework for clarity.  Avoid\n+\tleaving TYPE_BEING_DEFINED set in obscure cases.  Don't do\n+\tany more partial instantiation than is absolutely necessary for\n+\timplicit typename.  Set PARTIAL_INSTANTIATION_P.\n+\t(tsubst_decl): Use IDENTIFIER_TYPENAME_P.\n+\t* semantics.c (begin_class_definition): Handle partial\n+\tspecializations of a type that was previously partially\n+\tinstantiated. \n+\t\n Wed Jan  6 03:18:53 1999  Mark Elbrecht  <snowball3@usa.net.\n \n \t* g++spec.c (LIBSTDCXX): Provide default definition."}, {"sha": "db6e2281577340f17e16916dd0d8db33ee85ea4b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for C++ parsing and type checking.\n-   Copyright (C) 1987, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 92-97, 1998, 1999 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -293,10 +293,12 @@ struct tree_srcloc\n /* Nonzero if this identifier is the prefix for a mangled C++ operator name.  */\n #define IDENTIFIER_OPNAME_P(NODE) TREE_LANG_FLAG_2(NODE)\n \n-#define IDENTIFIER_TYPENAME_P(NODE)\t\\\n-  (! strncmp (IDENTIFIER_POINTER (NODE),\t\t\t\\\n-\t      IDENTIFIER_POINTER (ansi_opname[(int) TYPE_EXPR]),\t\\\n-\t      IDENTIFIER_LENGTH (ansi_opname[(int) TYPE_EXPR])))\n+/* Nonzero if this identifier is the name of a type-conversion\n+   operator.  */\n+#define IDENTIFIER_TYPENAME_P(NODE)\t\t\t\\\n+  (! strncmp (IDENTIFIER_POINTER (NODE),\t\t\\\n+              OPERATOR_TYPENAME_FORMAT,\t\t\t\\\n+\t      strlen (OPERATOR_TYPENAME_FORMAT)))\n \n /* Nonzero means reject anything that ANSI standard C forbids.  */\n extern int pedantic;\n@@ -723,11 +725,12 @@ struct lang_type\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n       unsigned non_aggregate : 1;\n+      unsigned is_partial_instantiation : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 12;\n+      unsigned dummy : 11;\n     } type_flags;\n \n   int n_ancestors;\n@@ -1913,6 +1916,12 @@ extern int flag_new_for_scope;\n #define DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION(DECL) \\\n   (DECL_TEMPLATE_INFO (DECL) && !DECL_USE_TEMPLATE (DECL))\n \n+/* Non-zero if TYPE is a partial instantiation of a template class,\n+   i.e., an instantiation whose instantiation arguments involve\n+   template types.  */\n+#define PARTIAL_INSTANTIATION_P(TYPE) \\\n+  (TYPE_LANG_SPECIFIC (TYPE)->type_flags.is_partial_instantiation)\n+\n /* Non-zero iff we are currently processing a declaration for an\n    entity with its own template parameter list, and which is not a\n    full specialization.  */\n@@ -2189,12 +2198,6 @@ extern int current_function_parms_stored;\n #define OPERATOR_ASSIGN_FORMAT \"__a%s\"\n #define OPERATOR_FORMAT \"__%s\"\n #define OPERATOR_TYPENAME_FORMAT \"__op\"\n-#define OPERATOR_TYPENAME_P(ID_NODE) \\\n-  (IDENTIFIER_POINTER (ID_NODE)[0] == '_'\t\\\n-   && IDENTIFIER_POINTER (ID_NODE)[1] == '_'\t\\\n-   && IDENTIFIER_POINTER (ID_NODE)[2] == 'o'\t\\\n-   && IDENTIFIER_POINTER (ID_NODE)[3] == 'p')\n-\n \n /* Cannot use '$' up front, because this confuses gdb\n    (names beginning with '$' are gdb-local identifiers)."}, {"sha": "edad0a980974c3ae29463ae89206e21c1b25463d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -11653,7 +11653,7 @@ unary_op_p (name)\n   return (name == ansi_opname [(int) TRUTH_NOT_EXPR]\n \t  || name == ansi_opname [(int) BIT_NOT_EXPR]\n \t  || name == ansi_opname [(int) COMPONENT_REF]\n-\t  || OPERATOR_TYPENAME_P (name));\n+\t  || IDENTIFIER_TYPENAME_P (name));\n }\n \n /* Do a little sanity-checking on how they declared their operator.  */\n@@ -11744,7 +11744,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t an enumeration, or a reference to an enumeration.  13.4.0.6 */\n       if (! methodp || DECL_STATIC_FUNCTION_P (decl))\n \t{\n-\t  if (OPERATOR_TYPENAME_P (name)\n+\t  if (IDENTIFIER_TYPENAME_P (name)\n \t      || name == ansi_opname[(int) CALL_EXPR]\n \t      || name == ansi_opname[(int) MODIFY_EXPR]\n \t      || name == ansi_opname[(int) COMPONENT_REF]"}, {"sha": "c26d6956c116175c2ec795d85de91ef9f2c13f49", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -1,5 +1,5 @@\n /* Help friends in C++.\n-   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -370,16 +370,20 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \n \t  if (is_friend_template)\n \t    decl = DECL_TI_TEMPLATE (push_template_decl (decl));\n-\n+\t  else if (template_class_depth (current_class_type))\n+\t    decl = push_template_decl_real (decl, /*is_friend=*/1);\n+\n+\t  /* We can't do lookup in a type that involves template\n+\t     parameters.  Instead, we rely on tsubst_friend_function\n+\t     to check the validity of the declaration later.  */\n+\t  if (uses_template_parms (ctype))\n+\t    add_friend (current_class_type, decl);\n \t  /* A nested class may declare a member of an enclosing class\n \t     to be a friend, so we do lookup here even if CTYPE is in\n \t     the process of being defined.  */\n-\t  if (TYPE_SIZE (ctype) != 0 || TYPE_BEING_DEFINED (ctype))\n+\t  else if (TYPE_SIZE (ctype) != 0 || TYPE_BEING_DEFINED (ctype))\n \t    {\n-\t      /* But, we defer looup in template specializations until\n-\t\t they are fully specialized.  */\n-\t      if (template_class_depth (ctype) == 0)\n-\t\tdecl = check_classfn (ctype, decl);\n+\t      decl = check_classfn (ctype, decl);\n \n \t      if (decl)\n \t\tadd_friend (current_class_type, decl);"}, {"sha": "505fbba5fed47f31e08231d7ace2b4bb114ad760", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -1,5 +1,5 @@\n /* Separate lexical analyzer for GNU C++.\n-   Copyright (C) 1987, 89, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92-97, 1998, 1999 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -650,7 +650,7 @@ init_parse (filename)\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) VEC_NEW_EXPR]) = 1;\n   ansi_opname[(int) VEC_DELETE_EXPR] = get_identifier (\"__vd\");\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) VEC_DELETE_EXPR]) = 1;\n-  ansi_opname[(int) TYPE_EXPR] = get_identifier (\"__op\");\n+  ansi_opname[(int) TYPE_EXPR] = get_identifier (OPERATOR_TYPENAME_FORMAT);\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) TYPE_EXPR]) = 1;\n \n   /* This is not true: these operators are not defined in ANSI,"}, {"sha": "9a0545ecd9f3a331b4a66e126fe94a26c2899899", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -1,5 +1,5 @@\n /* Handle parameterized types (templates) for GNU C++.\n-   Copyright (C) 1992, 93-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-97, 1998, 1999 Free Software Foundation, Inc.\n    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n    Rewritten by Jason Merrill (jason@cygnus.com).\n \n@@ -4436,7 +4436,6 @@ instantiate_class_template (type)\n {\n   tree template, args, pattern, t;\n   tree typedecl;\n-  int is_partial_instantiation;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n@@ -4457,9 +4456,33 @@ instantiate_class_template (type)\n   /* Figure out which arguments are being used to do the\n      instantiation.  */\n   args = CLASSTYPE_TI_ARGS (type);\n-  is_partial_instantiation = uses_template_parms (args);\n+  PARTIAL_INSTANTIATION_P (type) = uses_template_parms (args);\n \n-  if (is_partial_instantiation)\n+  if (pedantic && PARTIAL_INSTANTIATION_P (type))\n+    /* If this is a partial instantiation, then we can't instantiate\n+       the type; there's no telling whether or not one of the\n+       template parameters might eventually be instantiated to some\n+       value that results in a specialization being used.  For\n+       example, consider:\n+\n+         template <class T>\n+         struct S {};\n+\n+         template <class U> \n+         void f(S<U>);\n+\t     \n+         template <> \n+         struct S<int> {};\n+\n+       Now, the `S<U>' in `f<int>' is the specialization, not an\n+       instantiation of the original template.  Mark the type as\n+       complete, in the same way that we do for a definition of a\n+       template class.  */\n+    goto end;\n+\n+  /* Determine what specialization of the original template to\n+     instantiate.  */\n+  if (PARTIAL_INSTANTIATION_P (type))\n     /* There's no telling which specialization is appropriate at this\n        point.  Since all peeking at the innards of this partial\n        instantiation are extensions (like the \"implicit typename\"\n@@ -4500,9 +4523,39 @@ instantiate_class_template (type)\n   else\n     pattern = TREE_TYPE (template);\n \n+  /* If the template we're instantiating is incomplete, then clearly\n+     there's nothing we can do.  */\n   if (TYPE_SIZE (pattern) == NULL_TREE)\n     goto end;\n \n+  /* If this is a partial instantiation, don't tsubst anything.  We will\n+     only use this type for implicit typename, so the actual contents don't\n+     matter.  All that matters is whether a particular name is a type.  */\n+  if (PARTIAL_INSTANTIATION_P (type))\n+    {\n+      /* The fields set here must be kept in sync with those cleared\n+\t in begin_class_definition.  */\n+      TYPE_BINFO_BASETYPES (type) = TYPE_BINFO_BASETYPES (pattern);\n+      TYPE_FIELDS (type) = TYPE_FIELDS (pattern);\n+      TYPE_METHODS (type) = TYPE_METHODS (pattern);\n+      CLASSTYPE_TAGS (type) = CLASSTYPE_TAGS (pattern);\n+      /* Pretend that the type is complete, so that we will look\n+\t inside it during name lookup and such.  */\n+      TYPE_SIZE (type) = integer_zero_node;\n+      goto end;\n+    }\n+\n+  /* If we've recursively instantiated too many templates, stop.  */\n+  if (! push_tinst_level (type))\n+    goto end;\n+\n+  /* Now we're really doing the instantiation.  Mark the type as in\n+     the process of being defined.  */\n+  TYPE_BEING_DEFINED (type) = 1;\n+\n+  maybe_push_to_top_level (uses_template_parms (type));\n+  pushclass (type, 0);\n+\n   if (t)\n     {\n       /* This TYPE is actually a instantiation of of a partial\n@@ -4531,31 +4584,6 @@ instantiate_class_template (type)\n \targs = inner_args;\n     }\n \n-  if (pedantic && is_partial_instantiation)\n-    {\n-      /* If this is a partial instantiation, then we can't instantiate\n-\t the type; there's no telling whether or not one of the\n-\t template parameters might eventually be instantiated to some\n-\t value that results in a specialization being used.  We do\n-\t mark the type as complete so that, for example, declaring one\n-\t of its members to be a friend will not be rejected.  */\n-      TYPE_SIZE (type) = integer_zero_node;\n-      goto end;\n-    }\n-\n-  TYPE_BEING_DEFINED (type) = 1;\n-\n-  if (! push_tinst_level (type))\n-    goto end;\n-\n-  maybe_push_to_top_level (uses_template_parms (type));\n-  pushclass (type, 0);\n-\n-  /* We must copy the arguments to the permanent obstack since\n-     during the tsubst'ing below they may wind up in the\n-     DECL_TI_ARGS of some instantiated member template.  */\n-  args = copy_to_permanent (args);\n-\n   if (flag_external_templates)\n     {\n       if (flag_alt_external_templates)\n@@ -4608,18 +4636,10 @@ instantiate_class_template (type)\n   TYPE_ALIGN (type) = TYPE_ALIGN (pattern);\n   TYPE_FOR_JAVA (type) = TYPE_FOR_JAVA (pattern); /* For libjava's JArray<T> */\n \n-  /* If this is a partial instantiation, don't tsubst anything.  We will\n-     only use this type for implicit typename, so the actual contents don't\n-     matter.  All that matters is whether a particular name is a type.  */\n-  if (is_partial_instantiation)\n-    {\n-      TYPE_BINFO_BASETYPES (type) = TYPE_BINFO_BASETYPES (pattern);\n-      TYPE_FIELDS (type) = TYPE_FIELDS (pattern);\n-      TYPE_METHODS (type) = TYPE_METHODS (pattern);\n-      CLASSTYPE_TAGS (type) = CLASSTYPE_TAGS (pattern);\n-      TYPE_SIZE (type) = integer_zero_node;\n-      goto done_with_instantiation;\n-    }\n+  /* We must copy the arguments to the permanent obstack since\n+     during the tsubst'ing below they may wind up in the\n+     DECL_TI_ARGS of some instantiated member template.  */\n+  args = copy_to_permanent (args);\n \n   {\n     tree binfo = TYPE_BINFO (type);\n@@ -4850,10 +4870,7 @@ instantiate_class_template (type)\n   TYPE_BEING_DEFINED (type) = 0;\n   repo_template_used (type);\n \n- done_with_instantiation:\n-  TYPE_BEING_DEFINED (type) = 0;\n   popclass (0);\n-\n   pop_from_top_level ();\n   pop_tinst_level ();\n \n@@ -5382,9 +5399,7 @@ tsubst_decl (t, args, type, in_decl)\n \t  = tsubst_aggr_type (DECL_CONTEXT (t), args, t, /*entering_scope=*/1);\n \tDECL_CLASS_CONTEXT (r) = ctx;\n \n-\tif (member && !strncmp (OPERATOR_TYPENAME_FORMAT,\n-\t\t\t\tIDENTIFIER_POINTER (DECL_NAME (r)),\n-\t\t\t\tsizeof (OPERATOR_TYPENAME_FORMAT) - 1))\n+\tif (member && IDENTIFIER_TYPENAME_P (DECL_NAME (r)))\n \t  /* Type-conversion operator.  Reconstruct the name, in\n \t     case it's the name of one of the template's parameters.  */\n \t  DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));"}, {"sha": "4bd997df447406ee7ad5f27fa0d267ade4e49ab8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -3,7 +3,7 @@\n    building RTL.  These routines are used both during actual parsing\n    and during the instantiation of template functions. \n \n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n    Written by Mark Mitchell (mmitchell@usa.net) based on code found\n    formerly in parse.y and pt.c.  \n \n@@ -1222,10 +1222,58 @@ begin_class_definition (t)\n      implicit typename, a TYPENAME_TYPE with a type.  */\n   if (TREE_CODE (t) == TYPENAME_TYPE)\n     t = TREE_TYPE (t);\n+  \n+  /* If we generated a partial instantiation of this type, but now\n+     we're seeing a real definition, we're actually looking at a\n+     partial specialization.  Consider:\n+\n+       template <class T, class U>\n+       struct Y {};\n+\n+       template <class T>\n+       struct X {};\n+\n+       template <class T, class U>\n+       void f()\n+       {\n+\t typename X<Y<T, U> >::A a;\n+       }\n+\n+       template <class T, class U>\n+       struct X<Y<T, U> >\n+       {\n+       };\n+\n+     We have to undo the effects of the previous partial\n+     instantiation.  */\n+  if (PARTIAL_INSTANTIATION_P (t))\n+    {\n+      if (!pedantic) \n+\t{\n+\t  /* Unfortunately, when we're not in pedantic mode, we\n+\t     attempt to actually fill in some of the fields of the\n+\t     partial instantiation, in order to support the implicit\n+\t     typename extension.  Clear those fields now, in\n+\t     preparation for the definition here.  The fields cleared\n+\t     here must match those set in instantiate_class_template.\n+\t     Look for a comment mentioning begin_class_definition\n+\t     there.  */\n+\t  TYPE_BINFO_BASETYPES (t) = NULL_TREE;\n+\t  TYPE_FIELDS (t) = NULL_TREE;\n+\t  TYPE_METHODS (t) = NULL_TREE;\n+\t  CLASSTYPE_TAGS (t) = NULL_TREE;\n+\t  TYPE_SIZE (t) = NULL_TREE;\n+\t}\n \n-  if (TYPE_SIZE (t))\n+      /* This isn't a partial instantiation any more.  */\n+      PARTIAL_INSTANTIATION_P (t) = 0;\n+    }\n+  /* If this type was already complete, and we see another definition,\n+     that's an error.  */\n+  else if (TYPE_SIZE (t))\n     duplicate_tag_error (t);\n-  if (TYPE_SIZE (t) || TYPE_BEING_DEFINED (t))\n+\n+  if (TYPE_BEING_DEFINED (t))\n     {\n       t = make_lang_type (TREE_CODE (t));\n       pushtag (TYPE_IDENTIFIER (t), t, 0);"}, {"sha": "836c83054bb8544ab06e9118ed2f602f781aa3d5", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend39.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend39.C?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -0,0 +1,23 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S;\n+\n+template <class T>\n+class C\n+{\n+  friend void S<T>::f();\n+  \n+  int i;\n+};\n+\n+template <class T>\n+struct S\n+{\n+  void f() {\n+    C<T> c;\n+    c.i = 3;\n+  }\n+};\n+\n+template void S<int>::f();"}, {"sha": "63aae4c9bf65c6c52636b4214c01fa839167679e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec27.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c57111494f2ec72b9c8d7f246f8a3b269b53a47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec27.C?ref=4c57111494f2ec72b9c8d7f246f8a3b269b53a47", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+template <class T, class U>\n+struct Y {};\n+\n+template <class T>\n+struct X {};\n+\n+template <class T, class U>\n+void f()\n+{\n+  typename X<Y<T, U> >::A a;\n+}\n+\n+template <class T, class U>\n+struct X<Y<T, U> >\n+{\n+};"}]}