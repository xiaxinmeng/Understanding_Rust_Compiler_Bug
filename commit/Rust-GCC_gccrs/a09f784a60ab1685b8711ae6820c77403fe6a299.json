{"sha": "a09f784a60ab1685b8711ae6820c77403fe6a299", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA5Zjc4NGE2MGFiMTY4NWI4NzExYWU2ODIwYzc3NDAzZmU2YTI5OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-08-29T05:03:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-08-29T05:03:22Z"}, "message": "tree-ssa-dom.c (class edge_info): Changed from a struct to a class.\n\n\t* tree-ssa-dom.c (class edge_info): Changed from a struct\n\tto a class.  Add ctor/dtor, methods and data members.\n\t(edge_info::edge_info): Renamed from allocate_edge_info.\n\tInitialize additional members.\n\t(edge_info::~edge_info): New.\n\t(free_dom_edge_info): Delete the edge info.\n\t(record_edge_info): Use new class & associated member functions.\n\tTighten forms for testing for edge equivalences.\n\t(record_temporary_equivalences): Iterate over the simple\n\tequivalences rather than assuming there's only one per edge.\n\t(cprop_into_successor_phis): Iterate over the simple\n\tequivalences rather than assuming there's only one per edge.\n\t(optimize_stmt): Use operand_equal_p rather than pointer\n\tequality for mini-DSE code.\n\nFrom-SVN: r251396", "tree": {"sha": "a087278536787a055aca7fca3c2991a1967270fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a087278536787a055aca7fca3c2991a1967270fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a09f784a60ab1685b8711ae6820c77403fe6a299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09f784a60ab1685b8711ae6820c77403fe6a299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a09f784a60ab1685b8711ae6820c77403fe6a299", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09f784a60ab1685b8711ae6820c77403fe6a299/comments", "author": null, "committer": null, "parents": [{"sha": "f73e77f714ffa30c2f73dadb61750c6b59e1fd39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f73e77f714ffa30c2f73dadb61750c6b59e1fd39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f73e77f714ffa30c2f73dadb61750c6b59e1fd39"}], "stats": {"total": 289, "additions": 163, "deletions": 126}, "files": [{"sha": "258d4242f301523a5fff7fb57011d7c4477017ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a09f784a60ab1685b8711ae6820c77403fe6a299/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a09f784a60ab1685b8711ae6820c77403fe6a299/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a09f784a60ab1685b8711ae6820c77403fe6a299", "patch": "@@ -1,3 +1,20 @@\n+2017-08-28  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (class edge_info): Changed from a struct\n+\tto a class.  Add ctor/dtor, methods and data members.\n+\t(edge_info::edge_info): Renamed from allocate_edge_info.\n+\tInitialize additional members.\n+\t(edge_info::~edge_info): New.\n+\t(free_dom_edge_info): Delete the edge info.\n+\t(record_edge_info): Use new class & associated member functions.\n+\tTighten forms for testing for edge equivalences.\n+\t(record_temporary_equivalences): Iterate over the simple\n+\tequivalences rather than assuming there's only one per edge.\n+\t(cprop_into_successor_phis): Iterate over the simple\n+\tequivalences rather than assuming there's only one per edge.\n+\t(optimize_stmt): Use operand_equal_p rather than pointer\n+\tequality for mini-DSE code.\n+\n 2017-08-28  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcc.c (execute): Fold SIGPIPE handling into switch"}, {"sha": "403485b3c553bb00b20a06155b313d6ce86b9f93", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 146, "deletions": 126, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a09f784a60ab1685b8711ae6820c77403fe6a299/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a09f784a60ab1685b8711ae6820c77403fe6a299/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=a09f784a60ab1685b8711ae6820c77403fe6a299", "patch": "@@ -58,17 +58,28 @@ along with GCC; see the file COPYING3.  If not see\n    These structures live for a single iteration of the dominator\n    optimizer in the edge's AUX field.  At the end of an iteration we\n    free each of these structures.  */\n-\n-struct edge_info\n+class edge_info\n {\n-  /* If this edge creates a simple equivalence, the LHS and RHS of\n-     the equivalence will be stored here.  */\n-  tree lhs;\n-  tree rhs;\n+ public:\n+  typedef std::pair <tree, tree> equiv_pair;\n+  edge_info (edge);\n+  ~edge_info ();\n+\n+  /* Record a simple LHS = RHS equivalence.  This may trigger\n+     calls to derive_equivalences.  */\n+  void record_simple_equiv (tree, tree);\n+\n+  /* If traversing this edge creates simple equivalences, we store\n+     them as LHS/RHS pairs within this vector.  */\n+  vec<equiv_pair> simple_equivalences;\n \n   /* Traversing an edge may also indicate one or more particular conditions\n      are true or false.  */\n   vec<cond_equivalence> cond_equivalences;\n+\n+ private:\n+  /* Derive equivalences by walking the use-def chains.  */\n+  void derive_equivalences (tree, tree, int);\n };\n \n /* Track whether or not we have changed the control flow graph.  */\n@@ -109,36 +120,46 @@ static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n static void dump_dominator_optimization_stats (FILE *file,\n \t\t\t\t\t       hash_table<expr_elt_hasher> *);\n \n+/* Constructor for EDGE_INFO.  An EDGE_INFO instance is always\n+   associated with an edge E.  */\n \n-/* Free the edge_info data attached to E, if it exists.  */\n-\n-void\n-free_dom_edge_info (edge e)\n+edge_info::edge_info (edge e)\n {\n-  struct edge_info *edge_info = (struct edge_info *)e->aux;\n+  /* Free the old one associated with E, if it exists and\n+     associate our new object with E.  */\n+  free_dom_edge_info (e);\n+  e->aux = this;\n \n-  if (edge_info)\n-    {\n-      edge_info->cond_equivalences.release ();\n-      free (edge_info);\n-    }\n+  /* And initialize the embedded vectors.  */\n+  simple_equivalences = vNULL;\n+  cond_equivalences = vNULL;\n }\n \n-/* Allocate an EDGE_INFO for edge E and attach it to E.\n-   Return the new EDGE_INFO structure.  */\n+/* Destructor just needs to release the vectors.  */\n+edge_info::~edge_info (void)\n+{\n+  this->cond_equivalences.release ();\n+  this->simple_equivalences.release ();\n+}\n+\n+/* Record that LHS is known to be equal to RHS at runtime when the\n+   edge associated with THIS is traversed.  */\n \n-static struct edge_info *\n-allocate_edge_info (edge e)\n+void\n+edge_info::record_simple_equiv (tree lhs, tree rhs)\n {\n-  struct edge_info *edge_info;\n+  simple_equivalences.safe_push (equiv_pair (lhs, rhs));\n+}\n \n-  /* Free the old one, if it exists.  */\n-  free_dom_edge_info (e);\n+/* Free the edge_info data attached to E, if it exists.  */\n \n-  edge_info = XCNEW (struct edge_info);\n+void\n+free_dom_edge_info (edge e)\n+{\n+  class edge_info *edge_info = (struct edge_info *)e->aux;\n \n-  e->aux = edge_info;\n-  return edge_info;\n+  if (edge_info)\n+    delete edge_info;\n }\n \n /* Free all EDGE_INFO structures associated with edges in the CFG.\n@@ -171,7 +192,7 @@ static void\n record_edge_info (basic_block bb)\n {\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  struct edge_info *edge_info;\n+  class edge_info *edge_info;\n \n   if (! gsi_end_p (gsi))\n     {\n@@ -212,9 +233,8 @@ record_edge_info (basic_block bb)\n \t\t    {\n \t\t      tree x = fold_convert_loc (loc, TREE_TYPE (index),\n \t\t\t\t\t\t CASE_LOW (label));\n-\t\t      edge_info = allocate_edge_info (e);\n-\t\t      edge_info->lhs = index;\n-\t\t      edge_info->rhs = x;\n+\t\t      edge_info = new class edge_info (e);\n+\t\t      edge_info->record_simple_equiv (index, x);\n \t\t    }\n \t\t}\n \t      free (info);\n@@ -251,28 +271,32 @@ record_edge_info (basic_block bb)\n \n               if (code == EQ_EXPR)\n                 {\n-                  edge_info = allocate_edge_info (true_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1) ? false_val : true_val);\n-\n-                  edge_info = allocate_edge_info (false_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1) ? true_val : false_val);\n+\t\t  edge_info = new class edge_info (true_edge);\n+\t\t  edge_info->record_simple_equiv (op0,\n+\t\t\t\t\t\t  (integer_zerop (op1)\n+\t\t\t\t\t\t   ? false_val : true_val));\n+\t\t  edge_info = new class edge_info (false_edge);\n+\t\t  edge_info->record_simple_equiv (op0,\n+\t\t\t\t\t\t  (integer_zerop (op1)\n+\t\t\t\t\t\t   ? true_val : false_val));\n                 }\n               else\n                 {\n-                  edge_info = allocate_edge_info (true_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1) ? true_val : false_val);\n-\n-                  edge_info = allocate_edge_info (false_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1) ? false_val : true_val);\n+\t\t  edge_info = new class edge_info (true_edge);\n+\t\t  edge_info->record_simple_equiv (op0,\n+\t\t\t\t\t\t  (integer_zerop (op1)\n+\t\t\t\t\t\t   ? true_val : false_val));\n+\t\t  edge_info = new class edge_info (false_edge);\n+\t\t  edge_info->record_simple_equiv (op0,\n+\t\t\t\t\t\t  (integer_zerop (op1)\n+\t\t\t\t\t\t   ? false_val : true_val));\n                 }\n             }\n+\t  /* This can show up in the IL as a result of copy propagation\n+\t     it will eventually be canonicalized, but we have to cope\n+\t     with this case within the pass.  */\n           else if (is_gimple_min_invariant (op0)\n-                   && (TREE_CODE (op1) == SSA_NAME\n-                       || is_gimple_min_invariant (op1)))\n+                   && TREE_CODE (op1) == SSA_NAME)\n             {\n               tree cond = build2 (code, boolean_type_node, op0, op1);\n               tree inverted = invert_truthvalue_loc (loc, cond);\n@@ -281,23 +305,17 @@ record_edge_info (basic_block bb)\n                     && real_zerop (op0));\n               struct edge_info *edge_info;\n \n-              edge_info = allocate_edge_info (true_edge);\n+\t      edge_info = new class edge_info (true_edge);\n               record_conditions (&edge_info->cond_equivalences, cond, inverted);\n \n               if (can_infer_simple_equiv && code == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op1;\n-                  edge_info->rhs = op0;\n-                }\n+\t\tedge_info->record_simple_equiv (op1, op0);\n \n-              edge_info = allocate_edge_info (false_edge);\n+\t      edge_info = new class edge_info (false_edge);\n               record_conditions (&edge_info->cond_equivalences, inverted, cond);\n \n               if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op1;\n-                  edge_info->rhs = op0;\n-                }\n+\t\tedge_info->record_simple_equiv (op1, op0);\n             }\n \n           else if (TREE_CODE (op0) == SSA_NAME\n@@ -311,27 +329,19 @@ record_edge_info (basic_block bb)\n                     && (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));\n               struct edge_info *edge_info;\n \n-              edge_info = allocate_edge_info (true_edge);\n+\t      edge_info = new class edge_info (true_edge);\n               record_conditions (&edge_info->cond_equivalences, cond, inverted);\n \n               if (can_infer_simple_equiv && code == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = op1;\n-                }\n+\t\tedge_info->record_simple_equiv (op0, op1);\n \n-              edge_info = allocate_edge_info (false_edge);\n+\t      edge_info = new class edge_info (false_edge);\n               record_conditions (&edge_info->cond_equivalences, inverted, cond);\n \n               if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = op1;\n-                }\n+\t\tedge_info->record_simple_equiv (op0, op1);\n             }\n         }\n-\n-      /* ??? TRUTH_NOT_EXPR can create an equivalence too.  */\n     }\n }\n \n@@ -738,7 +748,7 @@ record_temporary_equivalences (edge e,\n \t\t\t       class avail_exprs_stack *avail_exprs_stack)\n {\n   int i;\n-  struct edge_info *edge_info = (struct edge_info *) e->aux;\n+  class edge_info *edge_info = (class edge_info *) e->aux;\n \n   /* If we have info associated with this edge, record it into\n      our equivalence tables.  */\n@@ -771,68 +781,73 @@ record_temporary_equivalences (edge e,\n \t    }\n \t}\n \n-      tree lhs = edge_info->lhs;\n-      if (!lhs || TREE_CODE (lhs) != SSA_NAME)\n-\treturn;\n+      edge_info::equiv_pair *seq;\n+      for (i = 0; edge_info->simple_equivalences.iterate (i, &seq); ++i)\n+\t{\n+\t  tree lhs = seq->first;\n+\t  if (!lhs || TREE_CODE (lhs) != SSA_NAME)\n+\t    continue;\n \n-      /* Record the simple NAME = VALUE equivalence.  */\n-      tree rhs = edge_info->rhs;\n+\t  /* Record the simple NAME = VALUE equivalence.  */\n+\t  tree rhs = seq->second;\n \n-      /* If this is a SSA_NAME = SSA_NAME equivalence and one operand is\n-\t cheaper to compute than the other, then set up the equivalence\n-\t such that we replace the expensive one with the cheap one.\n+\t  /* If this is a SSA_NAME = SSA_NAME equivalence and one operand is\n+\t     cheaper to compute than the other, then set up the equivalence\n+\t     such that we replace the expensive one with the cheap one.\n \n-\t If they are the same cost to compute, then do not record anything.  */\n-      if (TREE_CODE (lhs) == SSA_NAME && TREE_CODE (rhs) == SSA_NAME)\n-\t{\n-\t  gimple *rhs_def = SSA_NAME_DEF_STMT (rhs);\n-\t  int rhs_cost = estimate_num_insns (rhs_def, &eni_size_weights);\n+\t     If they are the same cost to compute, then do not record\n+\t     anything.  */\n+\t  if (TREE_CODE (lhs) == SSA_NAME && TREE_CODE (rhs) == SSA_NAME)\n+\t    {\n+\t      gimple *rhs_def = SSA_NAME_DEF_STMT (rhs);\n+\t      int rhs_cost = estimate_num_insns (rhs_def, &eni_size_weights);\n \n-\t  gimple *lhs_def = SSA_NAME_DEF_STMT (lhs);\n-\t  int lhs_cost = estimate_num_insns (lhs_def, &eni_size_weights);\n+\t      gimple *lhs_def = SSA_NAME_DEF_STMT (lhs);\n+\t      int lhs_cost = estimate_num_insns (lhs_def, &eni_size_weights);\n \n-\t  if (rhs_cost > lhs_cost)\n-\t    record_equality (rhs, lhs, const_and_copies);\n-\t  else if (rhs_cost < lhs_cost)\n+\t      if (rhs_cost > lhs_cost)\n+\t\trecord_equality (rhs, lhs, const_and_copies);\n+\t      else if (rhs_cost < lhs_cost)\n+\t\trecord_equality (lhs, rhs, const_and_copies);\n+\t    }\n+\t  else\n \t    record_equality (lhs, rhs, const_and_copies);\n-\t}\n-      else\n-\trecord_equality (lhs, rhs, const_and_copies);\n \n-      /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n-\t set via a widening type conversion, then we may be able to record\n-\t additional equivalences.  */\n-      if (TREE_CODE (rhs) == INTEGER_CST)\n-\t{\n-\t  gimple *defstmt = SSA_NAME_DEF_STMT (lhs);\n-\n-\t  if (defstmt\n-\t      && is_gimple_assign (defstmt)\n-\t      && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (defstmt)))\n+\t  /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n+\t     set via a widening type conversion, then we may be able to record\n+\t     additional equivalences.  */\n+\t  if (TREE_CODE (rhs) == INTEGER_CST)\n \t    {\n-\t      tree old_rhs = gimple_assign_rhs1 (defstmt);\n-\n-\t      /* If the conversion widens the original value and\n-\t\t the constant is in the range of the type of OLD_RHS,\n-\t\t then convert the constant and record the equivalence.\n-\n-\t\t Note that int_fits_type_p does not check the precision\n-\t\t if the upper and lower bounds are OK.  */\n-\t      if (INTEGRAL_TYPE_P (TREE_TYPE (old_rhs))\n-\t\t  && (TYPE_PRECISION (TREE_TYPE (lhs))\n-\t\t      > TYPE_PRECISION (TREE_TYPE (old_rhs)))\n-\t\t  && int_fits_type_p (rhs, TREE_TYPE (old_rhs)))\n+\t      gimple *defstmt = SSA_NAME_DEF_STMT (lhs);\n+\n+\t      if (defstmt\n+\t\t  && is_gimple_assign (defstmt)\n+\t\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (defstmt)))\n \t\t{\n-\t\t  tree newval = fold_convert (TREE_TYPE (old_rhs), rhs);\n-\t\t  record_equality (old_rhs, newval, const_and_copies);\n+\t\t  tree old_rhs = gimple_assign_rhs1 (defstmt);\n+\n+\t\t  /* If the conversion widens the original value and\n+\t\t     the constant is in the range of the type of OLD_RHS,\n+\t\t     then convert the constant and record the equivalence.\n+\n+\t\t     Note that int_fits_type_p does not check the precision\n+\t\t     if the upper and lower bounds are OK.  */\n+\t\t  if (INTEGRAL_TYPE_P (TREE_TYPE (old_rhs))\n+\t\t      && (TYPE_PRECISION (TREE_TYPE (lhs))\n+\t\t\t  > TYPE_PRECISION (TREE_TYPE (old_rhs)))\n+\t\t      && int_fits_type_p (rhs, TREE_TYPE (old_rhs)))\n+\t\t    {\n+\t\t      tree newval = fold_convert (TREE_TYPE (old_rhs), rhs);\n+\t\t      record_equality (old_rhs, newval, const_and_copies);\n+\t\t    }\n \t\t}\n \t    }\n-\t}\n \n-      /* Any equivalence found for LHS may result in additional\n-\t equivalences for other uses of LHS that we have already\n-\t processed.  */\n-      back_propagate_equivalences (lhs, e, const_and_copies);\n+\t  /* Any equivalence found for LHS may result in additional\n+\t     equivalences for other uses of LHS that we have already\n+\t     processed.  */\n+\t  back_propagate_equivalences (lhs, e, const_and_copies);\n+\t}\n     }\n }\n \n@@ -1124,14 +1139,20 @@ cprop_into_successor_phis (basic_block bb,\n \n \t Don't bother with [01] = COND equivalences, they're not useful\n \t here.  */\n-      struct edge_info *edge_info = (struct edge_info *) e->aux;\n+      class edge_info *edge_info = (class edge_info *) e->aux;\n+\n       if (edge_info)\n \t{\n-\t  tree lhs = edge_info->lhs;\n-\t  tree rhs = edge_info->rhs;\n+\t  edge_info::equiv_pair *seq;\n+\t  for (int i = 0; edge_info->simple_equivalences.iterate (i, &seq); ++i)\n+\t    {\n+\t      tree lhs = seq->first;\n+\t      tree rhs = seq->second;\n+\n+\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\t\tconst_and_copies->record_const_or_copy (lhs, rhs);\n+\t    }\n \n-\t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t    const_and_copies->record_const_or_copy (lhs, rhs);\n \t}\n \n       indx = e->dest_idx;\n@@ -1701,8 +1722,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n \t  cached_lhs = avail_exprs_stack->lookup_avail_expr (new_stmt, false,\n \t\t\t\t\t\t\t     false);\n-\t  if (cached_lhs\n-\t      && rhs == cached_lhs)\n+\t  if (cached_lhs && operand_equal_p (rhs, cached_lhs, 0))\n \t    {\n \t      basic_block bb = gimple_bb (stmt);\n \t      unlink_stmt_vdef (stmt);"}]}