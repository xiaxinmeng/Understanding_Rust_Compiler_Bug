{"sha": "022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyYWEwY2U1ZWViYWZlNjBmMjAyNDVjOGZmMjZiNjBhNTA3NGRmZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-14T03:57:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-14T03:57:18Z"}, "message": "compiler, runtime: simplify select and channel operations\n    \n    In preparation for upgrading libgo to the 1.9 release, this\n    approximately incorporates https://golang.org/cl/37661 and\n    https://golang.org/cl/38351.\n    \n    CL 37661 changed the gc compiler such that the select statement simply\n    returns an integer which is then used as the argument for a switch.\n    Since gccgo already worked that way, this just adjusts the switch code\n    to look like the gc switch code by removing the explicit case index\n    expression and calculating it from the order of calls to selectsend,\n    selectrecv, and selectdefault.\n    \n    CL 38351 simplifies the channel code by not passing the unused channel\n    type descriptor pointer.\n    \n    Reviewed-on: https://go-review.googlesource.com/62730\n\nFrom-SVN: r252749", "tree": {"sha": "4cff4e3e7be2beb8a86e66e9f1d6346a9e55fb36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cff4e3e7be2beb8a86e66e9f1d6346a9e55fb36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/comments", "author": null, "committer": null, "parents": [{"sha": "0468f67f27f49972dcd77758284a2709bd9249fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0468f67f27f49972dcd77758284a2709bd9249fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0468f67f27f49972dcd77758284a2709bd9249fe"}], "stats": {"total": 305, "additions": 122, "deletions": 183}, "files": [{"sha": "b07bce8518714158299ff2df980c20599616befe", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -1,4 +1,4 @@\n-0176cbc6dbd2170bfe2eb8904b80ddfe4c946997\n+199f175f4239d1ca6d7e80d08639955d41c3b09f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "88162327b5fb1153e3e58ae45dafcb9c52b2bce7", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -14463,15 +14463,14 @@ Receive_expression::do_get_backend(Translate_context* context)\n       go_assert(this->channel_->type()->is_error());\n       return context->backend()->error_expression();\n     }\n-  Expression* td = Expression::make_type_descriptor(channel_type, loc);\n \n   Expression* recv_ref =\n     Expression::make_temporary_reference(this->temp_receiver_, loc);\n   Expression* recv_addr =\n     Expression::make_temporary_reference(this->temp_receiver_, loc);\n   recv_addr = Expression::make_unary(OPERATOR_AND, recv_addr, loc);\n-  Expression* recv = Runtime::make_call(Runtime::CHANRECV1, loc, 3,\n-\t\t\t\t\ttd, this->channel_, recv_addr);\n+  Expression* recv = Runtime::make_call(Runtime::CHANRECV1, loc, 2,\n+\t\t\t\t\tthis->channel_, recv_addr);\n   return Expression::make_compound(recv, recv_ref, loc)->get_backend(context);\n }\n "}, {"sha": "6df53498d720072507370e2e469fe77c6bf94dd6", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -137,39 +137,31 @@ DEF_GO_RUNTIME(MAPITERNEXT, \"runtime.mapiternext\", P1(POINTER), R0())\n DEF_GO_RUNTIME(MAKECHAN, \"runtime.makechan\", P2(TYPE, INT64), R1(CHAN))\n \n // Send a value on a channel.\n-DEF_GO_RUNTIME(CHANSEND, \"runtime.chansend1\", P3(TYPE, CHAN, POINTER), R0())\n+DEF_GO_RUNTIME(CHANSEND, \"runtime.chansend1\", P2(CHAN, POINTER), R0())\n \n // Receive a value from a channel.\n-DEF_GO_RUNTIME(CHANRECV1, \"runtime.chanrecv1\", P3(TYPE, CHAN, POINTER), R0())\n+DEF_GO_RUNTIME(CHANRECV1, \"runtime.chanrecv1\", P2(CHAN, POINTER), R0())\n \n // Receive a value from a channel returning whether it is closed.\n-DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P3(TYPE, CHAN, POINTER),\n-\t       R1(BOOL))\n+DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P2(CHAN, POINTER), R1(BOOL))\n \n \n // Start building a select statement.\n DEF_GO_RUNTIME(NEWSELECT, \"runtime.newselect\", P3(POINTER, INT64, INT32), R0())\n \n // Add a default clause to a select statement.\n-DEF_GO_RUNTIME(SELECTDEFAULT, \"runtime.selectdefault\",\n-\t       P2(POINTER, INT32), R0())\n+DEF_GO_RUNTIME(SELECTDEFAULT, \"runtime.selectdefault\", P1(POINTER), R0())\n \n // Add a send clause to a select statement.\n-DEF_GO_RUNTIME(SELECTSEND, \"runtime.selectsend\",\n-\t       P4(POINTER, CHAN, POINTER, INT32), R0())\n+DEF_GO_RUNTIME(SELECTSEND, \"runtime.selectsend\", P3(POINTER, CHAN, POINTER),\n+\t       R0())\n \n-// Add a receive clause to a select statement, for a clause which does\n-// not check whether the channel is closed.\n+// Add a receive clause to a select statement.\n DEF_GO_RUNTIME(SELECTRECV, \"runtime.selectrecv\",\n-\t       P4(POINTER, CHAN, POINTER, INT32), R0())\n-\n-// Add a receive clause to a select statement, for a clause which does\n-// check whether the channel is closed.\n-DEF_GO_RUNTIME(SELECTRECV2, \"runtime.selectrecv2\",\n-\t       P5(POINTER, CHAN, POINTER, BOOLPTR, INT32), R0())\n+\t       P4(POINTER, CHAN, POINTER, BOOLPTR), R0())\n \n // Run a select, returning the index of the selected clause.\n-DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P1(POINTER), R1(INT32))\n+DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P1(POINTER), R1(INT))\n \n \n // Panic."}, {"sha": "eb370f844812c7fce41faf253286a8617f77318b", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -1517,14 +1517,12 @@ Tuple_receive_assignment_statement::do_lower(Gogo*, Named_object*,\n \t\t\t      NULL, loc);\n   b->add_statement(closed_temp);\n \n-  // closed_temp = chanrecv2(type, channel, &val_temp)\n-  Expression* td = Expression::make_type_descriptor(this->channel_->type(),\n-\t\t\t\t\t\t    loc);\n+  // closed_temp = chanrecv2(channel, &val_temp)\n   Temporary_reference_expression* ref =\n     Expression::make_temporary_reference(val_temp, loc);\n   Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n   Expression* call = Runtime::make_call(Runtime::CHANRECV2,\n-\t\t\t\t\tloc, 3, td, this->channel_, p2);\n+\t\t\t\t\tloc, 2, this->channel_, p2);\n   ref = Expression::make_temporary_reference(closed_temp, loc);\n   ref->set_is_lvalue();\n   Statement* s = Statement::make_assignment(ref, call, loc);\n@@ -4516,9 +4514,6 @@ Send_statement::do_get_backend(Translate_context* context)\n       && val->temporary_reference_expression() == NULL)\n     can_take_address = false;\n \n-  Expression* td = Expression::make_type_descriptor(this->channel_->type(),\n-\t\t\t\t\t\t    loc);\n-\n   Bstatement* btemp = NULL;\n   if (can_take_address)\n     {\n@@ -4539,7 +4534,7 @@ Send_statement::do_get_backend(Translate_context* context)\n       btemp = temp->get_backend(context);\n     }\n \n-  Expression* call = Runtime::make_call(Runtime::CHANSEND, loc, 3, td,\n+  Expression* call = Runtime::make_call(Runtime::CHANSEND, loc, 2,\n \t\t\t\t\tthis->channel_, val);\n \n   context->gogo()->lower_expression(context->function(), NULL, &call);\n@@ -4621,13 +4616,10 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n   Expression* selref = Expression::make_temporary_reference(sel, loc);\n   selref = Expression::make_unary(OPERATOR_AND, selref, loc);\n \n-  Expression* index_expr = Expression::make_integer_ul(this->index_, NULL,\n-\t\t\t\t\t\t       loc);\n-\n   if (this->is_default_)\n     {\n       go_assert(this->channel_ == NULL && this->val_ == NULL);\n-      this->lower_default(b, selref, index_expr);\n+      this->lower_default(b, selref);\n       this->is_lowered_ = true;\n       return;\n     }\n@@ -4641,9 +4633,9 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n \t\t\t\t\t\t\t     loc);\n \n   if (this->is_send_)\n-    this->lower_send(b, selref, chanref, index_expr);\n+    this->lower_send(b, selref, chanref);\n   else\n-    this->lower_recv(gogo, function, b, selref, chanref, index_expr);\n+    this->lower_recv(gogo, function, b, selref, chanref);\n \n   // Now all references should be handled through the statements, not\n   // through here.\n@@ -4654,21 +4646,19 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n // Lower a default clause in a select statement.\n \n void\n-Select_clauses::Select_clause::lower_default(Block* b, Expression* selref,\n-\t\t\t\t\t     Expression* index_expr)\n+Select_clauses::Select_clause::lower_default(Block* b, Expression* selref)\n {\n   Location loc = this->location_;\n-  Expression* call = Runtime::make_call(Runtime::SELECTDEFAULT, loc, 2, selref,\n-\t\t\t\t\tindex_expr);\n+  Expression* call = Runtime::make_call(Runtime::SELECTDEFAULT, loc, 1,\n+\t\t\t\t\tselref);\n   b->add_statement(Statement::make_statement(call, true));\n }\n \n // Lower a send clause in a select statement.\n \n void\n Select_clauses::Select_clause::lower_send(Block* b, Expression* selref,\n-\t\t\t\t\t  Expression* chanref,\n-\t\t\t\t\t  Expression* index_expr)\n+\t\t\t\t\t  Expression* chanref)\n {\n   Location loc = this->location_;\n \n@@ -4687,8 +4677,8 @@ Select_clauses::Select_clause::lower_send(Block* b, Expression* selref,\n   Expression* valref = Expression::make_temporary_reference(val, loc);\n   Expression* valaddr = Expression::make_unary(OPERATOR_AND, valref, loc);\n \n-  Expression* call = Runtime::make_call(Runtime::SELECTSEND, loc, 4, selref,\n-\t\t\t\t\tchanref, valaddr, index_expr);\n+  Expression* call = Runtime::make_call(Runtime::SELECTSEND, loc, 3, selref,\n+\t\t\t\t\tchanref, valaddr);\n   b->add_statement(Statement::make_statement(call, true));\n }\n \n@@ -4697,8 +4687,7 @@ Select_clauses::Select_clause::lower_send(Block* b, Expression* selref,\n void\n Select_clauses::Select_clause::lower_recv(Gogo* gogo, Named_object* function,\n \t\t\t\t\t  Block* b, Expression* selref,\n-\t\t\t\t\t  Expression* chanref,\n-\t\t\t\t\t  Expression* index_expr)\n+\t\t\t\t\t  Expression* chanref)\n {\n   Location loc = this->location_;\n \n@@ -4715,22 +4704,22 @@ Select_clauses::Select_clause::lower_recv(Gogo* gogo, Named_object* function,\n \n   Temporary_statement* closed_temp = NULL;\n \n-  Expression* call;\n+  Expression* caddr;\n   if (this->closed_ == NULL && this->closedvar_ == NULL)\n-    call = Runtime::make_call(Runtime::SELECTRECV, loc, 4, selref, chanref,\n-\t\t\t      valaddr, index_expr);\n+    caddr = Expression::make_nil(loc);\n   else\n     {\n       closed_temp = Statement::make_temporary(Type::lookup_bool_type(), NULL,\n \t\t\t\t\t      loc);\n       b->add_statement(closed_temp);\n       Expression* cref = Expression::make_temporary_reference(closed_temp,\n \t\t\t\t\t\t\t      loc);\n-      Expression* caddr = Expression::make_unary(OPERATOR_AND, cref, loc);\n-      call = Runtime::make_call(Runtime::SELECTRECV2, loc, 5, selref, chanref,\n-\t\t\t\tvaladdr, caddr, index_expr);\n+      caddr = Expression::make_unary(OPERATOR_AND, cref, loc);\n     }\n \n+  Expression* call = Runtime::make_call(Runtime::SELECTRECV, loc, 4, selref,\n+\t\t\t\t\tchanref, valaddr, caddr);\n+\n   b->add_statement(Statement::make_statement(call, true));\n \n   // If the block of statements is executed, arrange for the received\n@@ -4958,15 +4947,14 @@ Select_clauses::get_backend(Translate_context* context,\n   std::vector<std::vector<Bexpression*> > cases(count);\n   std::vector<Bstatement*> clauses(count);\n \n-  Type* int32_type = Type::lookup_integer_type(\"int32\");\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n \n   int i = 0;\n   for (Clauses::iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n        ++p, ++i)\n     {\n-      int index = p->index();\n-      Expression* index_expr = Expression::make_integer_ul(index, int32_type,\n+      Expression* index_expr = Expression::make_integer_ul(i, int_type,\n \t\t\t\t\t\t\t   location);\n       cases[i].push_back(index_expr->get_backend(context));\n "}, {"sha": "852ab43ce2a2e5eab6285efb548bc2995fcfc694", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -899,10 +899,9 @@ class Select_clauses\n       Named_object* var, Named_object* closedvar, bool is_default,\n       Block* statements, Location location)\n   {\n-    int index = static_cast<int>(this->clauses_.size());\n-    this->clauses_.push_back(Select_clause(index, is_send, channel, val,\n-\t\t\t\t\t   closed, var, closedvar, is_default,\n-\t\t\t\t\t   statements, location));\n+    this->clauses_.push_back(Select_clause(is_send, channel, val, closed, var,\n+\t\t\t\t\t   closedvar, is_default, statements,\n+\t\t\t\t\t   location));\n   }\n \n   size_t\n@@ -950,21 +949,15 @@ class Select_clauses\n \tis_default_(false)\n     { }\n \n-    Select_clause(int index, bool is_send, Expression* channel,\n-\t\t  Expression* val, Expression* closed, Named_object* var,\n+    Select_clause(bool is_send, Expression* channel, Expression* val,\n+\t\t  Expression* closed, Named_object* var,\n \t\t  Named_object* closedvar, bool is_default, Block* statements,\n \t\t  Location location)\n-      : index_(index), channel_(channel), val_(val), closed_(closed),\n-\tvar_(var), closedvar_(closedvar), statements_(statements),\n-\tlocation_(location), is_send_(is_send), is_default_(is_default),\n-\tis_lowered_(false)\n+      : channel_(channel), val_(val), closed_(closed), var_(var),\n+\tclosedvar_(closedvar), statements_(statements), location_(location),\n+\tis_send_(is_send), is_default_(is_default), is_lowered_(false)\n     { go_assert(is_default ? channel == NULL : channel != NULL); }\n \n-    // Return the index of this clause.\n-    int\n-    index() const\n-    { return this->index_; }\n-\n     // Traverse the select clause.\n     int\n     traverse(Traverse*);\n@@ -1025,17 +1018,14 @@ class Select_clauses\n \n    private:\n     void\n-    lower_default(Block*, Expression*, Expression*);\n+    lower_default(Block*, Expression*);\n \n     void\n-    lower_send(Block*, Expression*, Expression*, Expression*);\n+    lower_send(Block*, Expression*, Expression*);\n \n     void\n-    lower_recv(Gogo*, Named_object*, Block*, Expression*, Expression*,\n-\t       Expression*);\n+    lower_recv(Gogo*, Named_object*, Block*, Expression*, Expression*);\n \n-    // The index of this case in the generated switch statement.\n-    int index_;\n     // The channel.\n     Expression* channel_;\n     // The value to send or the lvalue to receive into."}, {"sha": "8f6a93b3848fe0d8a0a5cc28fc75068db80d6d60", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -1160,7 +1160,7 @@ func (v Value) recv(nb bool) (val Value, ok bool) {\n \t} else {\n \t\tp = unsafe.Pointer(&val.ptr)\n \t}\n-\tselected, ok := chanrecv(v.typ, v.pointer(), nb, p)\n+\tselected, ok := chanrecv(v.pointer(), nb, p)\n \tif !selected {\n \t\tval = Value{}\n \t}\n@@ -1191,7 +1191,7 @@ func (v Value) send(x Value, nb bool) (selected bool) {\n \t} else {\n \t\tp = unsafe.Pointer(&x.ptr)\n \t}\n-\treturn chansend(v.typ, v.pointer(), p, nb)\n+\treturn chansend(v.pointer(), p, nb)\n }\n \n // Set assigns x to the value v.\n@@ -2327,10 +2327,10 @@ func chanlen(ch unsafe.Pointer) int\n // (due to the escapes() call in ValueOf).\n \n //go:noescape\n-func chanrecv(t *rtype, ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected, received bool)\n+func chanrecv(ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected, received bool)\n \n //go:noescape\n-func chansend(t *rtype, ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool\n+func chansend(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool\n \n func makechan(typ *rtype, size uint64) (ch unsafe.Pointer)\n func makemap(t *rtype) (m unsafe.Pointer)"}, {"sha": "d2470bd0442d77678ffe7c46123288f52cfec84b", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -118,8 +118,8 @@ func chanbuf(c *hchan, i uint) unsafe.Pointer {\n \n // entry point for c <- x from compiled code\n //go:nosplit\n-func chansend1(t *chantype, c *hchan, elem unsafe.Pointer) {\n-\tchansend(t, c, elem, true, getcallerpc(unsafe.Pointer(&t)))\n+func chansend1(c *hchan, elem unsafe.Pointer) {\n+\tchansend(c, elem, true, getcallerpc(unsafe.Pointer(&c)))\n }\n \n /*\n@@ -134,14 +134,7 @@ func chansend1(t *chantype, c *hchan, elem unsafe.Pointer) {\n  * been closed.  it is easiest to loop and re-run\n  * the operation; we'll see that it's now closed.\n  */\n-func chansend(t *chantype, c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n-\tif raceenabled {\n-\t\traceReadObjectPC(t.elem, ep, callerpc, funcPC(chansend))\n-\t}\n-\tif msanenabled {\n-\t\tmsanread(ep, t.elem.size)\n-\t}\n-\n+func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n \tif c == nil {\n \t\tif !block {\n \t\t\treturn false\n@@ -400,13 +393,13 @@ func closechan(c *hchan) {\n \n // entry points for <- c from compiled code\n //go:nosplit\n-func chanrecv1(t *chantype, c *hchan, elem unsafe.Pointer) {\n-\tchanrecv(t, c, elem, true)\n+func chanrecv1(c *hchan, elem unsafe.Pointer) {\n+\tchanrecv(c, elem, true)\n }\n \n //go:nosplit\n-func chanrecv2(t *chantype, c *hchan, elem unsafe.Pointer) (received bool) {\n-\t_, received = chanrecv(t, c, elem, true)\n+func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {\n+\t_, received = chanrecv(c, elem, true)\n \treturn\n }\n \n@@ -416,7 +409,7 @@ func chanrecv2(t *chantype, c *hchan, elem unsafe.Pointer) (received bool) {\n // Otherwise, if c is closed, zeros *ep and returns (true, false).\n // Otherwise, fills in *ep with an element and returns (true, true).\n // A non-nil ep must point to the heap or the caller's stack.\n-func chanrecv(t *chantype, c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {\n+func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {\n \t// raceenabled: don't need to check ep, as it is always on the stack\n \t// or is new memory allocated by reflect.\n \n@@ -609,8 +602,8 @@ func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func()) {\n //\t\t... bar\n //\t}\n //\n-func selectnbsend(t *chantype, c *hchan, elem unsafe.Pointer) (selected bool) {\n-\treturn chansend(t, c, elem, false, getcallerpc(unsafe.Pointer(&t)))\n+func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) {\n+\treturn chansend(c, elem, false, getcallerpc(unsafe.Pointer(&c)))\n }\n \n // compiler implements\n@@ -630,8 +623,8 @@ func selectnbsend(t *chantype, c *hchan, elem unsafe.Pointer) (selected bool) {\n //\t\t... bar\n //\t}\n //\n-func selectnbrecv(t *chantype, elem unsafe.Pointer, c *hchan) (selected bool) {\n-\tselected, _ = chanrecv(t, c, elem, false)\n+func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) {\n+\tselected, _ = chanrecv(c, elem, false)\n \treturn\n }\n \n@@ -652,20 +645,20 @@ func selectnbrecv(t *chantype, elem unsafe.Pointer, c *hchan) (selected bool) {\n //\t\t... bar\n //\t}\n //\n-func selectnbrecv2(t *chantype, elem unsafe.Pointer, received *bool, c *hchan) (selected bool) {\n+func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) {\n \t// TODO(khr): just return 2 values from this function, now that it is in Go.\n-\tselected, *received = chanrecv(t, c, elem, false)\n+\tselected, *received = chanrecv(c, elem, false)\n \treturn\n }\n \n //go:linkname reflect_chansend reflect.chansend\n-func reflect_chansend(t *chantype, c *hchan, elem unsafe.Pointer, nb bool) (selected bool) {\n-\treturn chansend(t, c, elem, !nb, getcallerpc(unsafe.Pointer(&t)))\n+func reflect_chansend(c *hchan, elem unsafe.Pointer, nb bool) (selected bool) {\n+\treturn chansend(c, elem, !nb, getcallerpc(unsafe.Pointer(&c)))\n }\n \n //go:linkname reflect_chanrecv reflect.chanrecv\n-func reflect_chanrecv(t *chantype, c *hchan, nb bool, elem unsafe.Pointer) (selected bool, received bool) {\n-\treturn chanrecv(t, c, elem, !nb)\n+func reflect_chanrecv(c *hchan, nb bool, elem unsafe.Pointer) (selected bool, received bool) {\n+\treturn chanrecv(c, elem, !nb)\n }\n \n //go:linkname reflect_chanlen reflect.chanlen"}, {"sha": "f0cad1bf9906a25d4a3c64ed63c8b959d317fc89", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 56, "deletions": 79, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/022aa0ce5eebafe60f20245c8ff26b60a5074dfd/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=022aa0ce5eebafe60f20245c8ff26b60a5074dfd", "patch": "@@ -18,14 +18,14 @@ import (\n //go:linkname selectdefault runtime.selectdefault\n //go:linkname selectsend runtime.selectsend\n //go:linkname selectrecv runtime.selectrecv\n-//go:linkname selectrecv2 runtime.selectrecv2\n //go:linkname selectgo runtime.selectgo\n \n-const (\n-\tdebugSelect = false\n+const debugSelect = false\n \n+const (\n \t// scase.kind\n-\tcaseRecv = iota\n+\tcaseNil = iota\n+\tcaseRecv\n \tcaseSend\n \tcaseDefault\n )\n@@ -47,10 +47,9 @@ type hselect struct {\n type scase struct {\n \telem        unsafe.Pointer // data element\n \tc           *hchan         // chan\n-\tpc          uintptr        // return pc\n+\tpc          uintptr        // return pc (for race detector / msan)\n \tkind        uint16\n-\tindex       uint16 // case index\n-\treceivedp   *bool  // pointer to received bool (recv2)\n+\treceivedp   *bool // pointer to received bool, if any\n \treleasetime int64\n }\n \n@@ -88,88 +87,64 @@ func newselect(sel *hselect, selsize int64, size int32) {\n \t}\n }\n \n-func selectsend(sel *hselect, c *hchan, elem unsafe.Pointer, index int32) {\n-\t// nil cases do not compete\n-\tif c != nil {\n-\t\tselectsendImpl(sel, c, getcallerpc(unsafe.Pointer(&sel)), elem, index)\n-\t}\n-\treturn\n-}\n-\n-// cut in half to give stack a chance to split\n-func selectsendImpl(sel *hselect, c *hchan, pc uintptr, elem unsafe.Pointer, index int32) {\n+func selectsend(sel *hselect, c *hchan, elem unsafe.Pointer) {\n+\tpc := getcallerpc(unsafe.Pointer(&sel))\n \ti := sel.ncase\n \tif i >= sel.tcase {\n \t\tthrow(\"selectsend: too many cases\")\n \t}\n \tsel.ncase = i + 1\n+\tif c == nil {\n+\t\treturn\n+\t}\n \tcas := (*scase)(add(unsafe.Pointer(&sel.scase), uintptr(i)*unsafe.Sizeof(sel.scase[0])))\n \n \tcas.pc = pc\n \tcas.c = c\n-\tcas.index = uint16(index)\n \tcas.kind = caseSend\n \tcas.elem = elem\n \n \tif debugSelect {\n-\t\tprint(\"selectsend s=\", sel, \" pc=\", hex(cas.pc), \" chan=\", cas.c, \" index=\", cas.index, \"\\n\")\n-\t}\n-}\n-\n-func selectrecv(sel *hselect, c *hchan, elem unsafe.Pointer, index int32) {\n-\t// nil cases do not compete\n-\tif c != nil {\n-\t\tselectrecvImpl(sel, c, getcallerpc(unsafe.Pointer(&sel)), elem, nil, index)\n+\t\tprint(\"selectsend s=\", sel, \" pc=\", hex(cas.pc), \" chan=\", cas.c, \"\\n\")\n \t}\n-\treturn\n }\n \n-func selectrecv2(sel *hselect, c *hchan, elem unsafe.Pointer, received *bool, index int32) {\n-\t// nil cases do not compete\n-\tif c != nil {\n-\t\tselectrecvImpl(sel, c, getcallerpc(unsafe.Pointer(&sel)), elem, received, index)\n-\t}\n-\treturn\n-}\n-\n-func selectrecvImpl(sel *hselect, c *hchan, pc uintptr, elem unsafe.Pointer, received *bool, index int32) {\n+func selectrecv(sel *hselect, c *hchan, elem unsafe.Pointer, received *bool) {\n+\tpc := getcallerpc(unsafe.Pointer(&sel))\n \ti := sel.ncase\n \tif i >= sel.tcase {\n \t\tthrow(\"selectrecv: too many cases\")\n \t}\n \tsel.ncase = i + 1\n+\tif c == nil {\n+\t\treturn\n+\t}\n \tcas := (*scase)(add(unsafe.Pointer(&sel.scase), uintptr(i)*unsafe.Sizeof(sel.scase[0])))\n \tcas.pc = pc\n \tcas.c = c\n-\tcas.index = uint16(index)\n \tcas.kind = caseRecv\n \tcas.elem = elem\n \tcas.receivedp = received\n \n \tif debugSelect {\n-\t\tprint(\"selectrecv s=\", sel, \" pc=\", hex(cas.pc), \" chan=\", cas.c, \" index=\", cas.index, \"\\n\")\n+\t\tprint(\"selectrecv s=\", sel, \" pc=\", hex(cas.pc), \" chan=\", cas.c, \"\\n\")\n \t}\n }\n \n-func selectdefault(sel *hselect, index int32) {\n-\tselectdefaultImpl(sel, getcallerpc(unsafe.Pointer(&sel)), index)\n-\treturn\n-}\n-\n-func selectdefaultImpl(sel *hselect, callerpc uintptr, index int32) {\n+func selectdefault(sel *hselect) {\n+\tpc := getcallerpc(unsafe.Pointer(&sel))\n \ti := sel.ncase\n \tif i >= sel.tcase {\n \t\tthrow(\"selectdefault: too many cases\")\n \t}\n \tsel.ncase = i + 1\n \tcas := (*scase)(add(unsafe.Pointer(&sel.scase), uintptr(i)*unsafe.Sizeof(sel.scase[0])))\n-\tcas.pc = callerpc\n+\tcas.pc = pc\n \tcas.c = nil\n-\tcas.index = uint16(index)\n \tcas.kind = caseDefault\n \n \tif debugSelect {\n-\t\tprint(\"selectdefault s=\", sel, \" pc=\", hex(cas.pc), \" index=\", cas.index, \"\\n\")\n+\t\tprint(\"selectdefault s=\", sel, \" pc=\", hex(cas.pc), \"\\n\")\n \t}\n }\n \n@@ -193,14 +168,11 @@ func selunlock(scases []scase, lockorder []uint16) {\n \t// the G that calls select runnable again and schedules it for execution.\n \t// When the G runs on another M, it locks all the locks and frees sel.\n \t// Now if the first M touches sel, it will access freed memory.\n-\tn := len(scases)\n-\tr := 0\n-\t// skip the default case\n-\tif n > 0 && scases[lockorder[0]].c == nil {\n-\t\tr = 1\n-\t}\n-\tfor i := n - 1; i >= r; i-- {\n+\tfor i := len(scases) - 1; i >= 0; i-- {\n \t\tc := scases[lockorder[i]].c\n+\t\tif c == nil {\n+\t\t\tbreak\n+\t\t}\n \t\tif i > 0 && c == scases[lockorder[i-1]].c {\n \t\t\tcontinue // will unlock it on the next iteration\n \t\t}\n@@ -241,20 +213,15 @@ func block() {\n // *sel is on the current goroutine's stack (regardless of any\n // escaping in selectgo).\n //\n-// selectgo does not return. Instead, it overwrites its return PC and\n-// returns directly to the triggered select case. Because of this, it\n-// cannot appear at the top of a split stack.\n-func selectgo(sel *hselect) int32 {\n-\t_, index := selectgoImpl(sel)\n-\treturn int32(index)\n-}\n-\n-// selectgoImpl returns scase.pc and scase.so for the select\n-// case which fired.\n-func selectgoImpl(sel *hselect) (uintptr, uint16) {\n+// selectgo returns the index of the chosen scase, which matches the\n+// ordinal position of its respective select{recv,send,default} call.\n+func selectgo(sel *hselect) int {\n \tif debugSelect {\n \t\tprint(\"select: sel=\", sel, \"\\n\")\n \t}\n+\tif sel.ncase != sel.tcase {\n+\t\tthrow(\"selectgo: case count mismatch\")\n+\t}\n \n \tscaseslice := slice{unsafe.Pointer(&sel.scase), int(sel.ncase), int(sel.ncase)}\n \tscases := *(*[]scase)(unsafe.Pointer(&scaseslice))\n@@ -347,13 +314,19 @@ func selectgoImpl(sel *hselect) (uintptr, uint16) {\n \n loop:\n \t// pass 1 - look for something already waiting\n+\tvar dfli int\n \tvar dfl *scase\n+\tvar casi int\n \tvar cas *scase\n \tfor i := 0; i < int(sel.ncase); i++ {\n-\t\tcas = &scases[pollorder[i]]\n+\t\tcasi = int(pollorder[i])\n+\t\tcas = &scases[casi]\n \t\tc = cas.c\n \n \t\tswitch cas.kind {\n+\t\tcase caseNil:\n+\t\t\tcontinue\n+\n \t\tcase caseRecv:\n \t\t\tsg = c.sendq.dequeue()\n \t\t\tif sg != nil {\n@@ -382,12 +355,14 @@ loop:\n \t\t\t}\n \n \t\tcase caseDefault:\n+\t\t\tdfli = casi\n \t\t\tdfl = cas\n \t\t}\n \t}\n \n \tif dfl != nil {\n \t\tselunlock(scases, lockorder)\n+\t\tcasi = dfli\n \t\tcas = dfl\n \t\tgoto retc\n \t}\n@@ -400,7 +375,11 @@ loop:\n \t}\n \tnextp = &gp.waiting\n \tfor _, casei := range lockorder {\n-\t\tcas = &scases[casei]\n+\t\tcasi = int(casei)\n+\t\tcas = &scases[casi]\n+\t\tif cas.kind == caseNil {\n+\t\t\tcontinue\n+\t\t}\n \t\tc = cas.c\n \t\tsg := acquireSudog()\n \t\tsg.g = gp\n@@ -494,6 +473,7 @@ loop:\n \t// otherwise they stack up on quiet channels\n \t// record the successful case, if any.\n \t// We singly-linked up the SudoGs in lock order.\n+\tcasi = -1\n \tcas = nil\n \tsglist = gp.waiting\n \t// Clear all elem before unlinking from gp.waiting.\n@@ -506,11 +486,15 @@ loop:\n \n \tfor _, casei := range lockorder {\n \t\tk = &scases[casei]\n+\t\tif k.kind == caseNil {\n+\t\t\tcontinue\n+\t\t}\n \t\tif sglist.releasetime > 0 {\n \t\t\tk.releasetime = sglist.releasetime\n \t\t}\n \t\tif sg == sglist {\n \t\t\t// sg has already been dequeued by the G that woke us up.\n+\t\t\tcasi = int(casei)\n \t\t\tcas = k\n \t\t} else {\n \t\t\tc = k.c\n@@ -659,7 +643,7 @@ retc:\n \tif cas.releasetime > 0 {\n \t\tblockevent(cas.releasetime-t0, 2)\n \t}\n-\treturn cas.pc, cas.index\n+\treturn casi\n \n sclose:\n \t// send on closed channel\n@@ -703,22 +687,15 @@ func reflect_rselect(cases []runtimeSelect) (chosen int, recvOK bool) {\n \t\trc := &cases[i]\n \t\tswitch rc.dir {\n \t\tcase selectDefault:\n-\t\t\tselectdefaultImpl(sel, uintptr(i), 0)\n+\t\t\tselectdefault(sel)\n \t\tcase selectSend:\n-\t\t\tif rc.ch == nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tselectsendImpl(sel, rc.ch, uintptr(i), rc.val, 0)\n+\t\t\tselectsend(sel, rc.ch, rc.val)\n \t\tcase selectRecv:\n-\t\t\tif rc.ch == nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tselectrecvImpl(sel, rc.ch, uintptr(i), rc.val, r, 0)\n+\t\t\tselectrecv(sel, rc.ch, rc.val, r)\n \t\t}\n \t}\n \n-\tpc, _ := selectgoImpl(sel)\n-\tchosen = int(pc)\n+\tchosen = selectgo(sel)\n \trecvOK = *r\n \treturn\n }"}]}