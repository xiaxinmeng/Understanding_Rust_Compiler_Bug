{"sha": "738f25224b78c40ba48d6debd95946bf73f89e53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM4ZjI1MjI0Yjc4YzQwYmE0OGQ2ZGViZDk1OTQ2YmY3M2Y4OWU1Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2014-11-10T16:12:42Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2014-11-10T16:12:42Z"}, "message": "Add the nvptx port.\n\n\t* configure.ac: Handle nvptx-*-*.\n\t* configure: Regenerate.\n\n\tgcc/\n\t* config/nvptx/nvptx.c: New file.\n\t* config/nvptx/nvptx.h: New file.\n\t* config/nvptx/nvptx-protos.h: New file.\n\t* config/nvptx/nvptx.md: New file.\n\t* config/nvptx/t-nvptx: New file.\n\t* config/nvptx/nvptx.opt: New file.\n\t* common/config/nvptx/nvptx-common.c: New file.\n\t* config.gcc: Handle nvptx-*-*.\n\n\tlibgcc/\n\t* config.host: Handle nvptx-*-*.\n\t* shared-object.mk (as-flags-$o): Define.\n\t($(base)$(objext), $(base)_s$(objext)): Use it instead of\n\t-xassembler-with-cpp.\n\t* static-object.mk: Identical changes.\n\t* config/nvptx/t-nvptx: New file.\n\t* config/nvptx/crt0.s: New file.\n\t* config/nvptx/free.asm: New file.\n\t* config/nvptx/malloc.asm: New file.\n\t* config/nvptx/realloc.c: New file.\n\nFrom-SVN: r217295", "tree": {"sha": "64dd54686832409d0db5195b6155c4b408fed0d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64dd54686832409d0db5195b6155c4b408fed0d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/738f25224b78c40ba48d6debd95946bf73f89e53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/738f25224b78c40ba48d6debd95946bf73f89e53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/738f25224b78c40ba48d6debd95946bf73f89e53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/738f25224b78c40ba48d6debd95946bf73f89e53/comments", "author": null, "committer": null, "parents": [{"sha": "c81b4a0e83c8577ba09767ded86f715b6fcd21b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81b4a0e83c8577ba09767ded86f715b6fcd21b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c81b4a0e83c8577ba09767ded86f715b6fcd21b4"}], "stats": {"total": 4264, "additions": 4260, "deletions": 4}, "files": [{"sha": "e83d1e6f79631d9725971dfe8b20c21eb295a499", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -1,3 +1,8 @@\n+2014-11-06  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* configure.ac: Handle nvptx-*-*.\n+\t* configure: Regenerate.\n+\n 2014-11-06  Prachi Godbole  <prachi.godbole@imgtec.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "0e014a3e110ad1c2263ec22cf51801a7c798b664", "filename": "configure", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -3779,6 +3779,10 @@ case \"${target}\" in\n   mips*-*-*)\n     noconfigdirs=\"$noconfigdirs gprof\"\n     ;;\n+  nvptx*-*-*)\n+    # nvptx is just a compiler\n+    noconfigdirs=\"$noconfigdirs target-libssp target-libstdc++-v3 target-libobjc\"\n+    ;;\n   sh-*-* | sh64-*-*)\n     case \"${target}\" in\n       sh*-*-elf)"}, {"sha": "b1ef069b1db2db98271767b9c481937e12e2b9af", "filename": "configure.ac", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -1138,6 +1138,10 @@ case \"${target}\" in\n   mips*-*-*)\n     noconfigdirs=\"$noconfigdirs gprof\"\n     ;;\n+  nvptx*-*-*)\n+    # nvptx is just a compiler\n+    noconfigdirs=\"$noconfigdirs target-libssp target-libstdc++-v3 target-libobjc\"\n+    ;;\n   sh-*-* | sh64-*-*)\n     case \"${target}\" in\n       sh*-*-elf)"}, {"sha": "c170e69f25177cbaef85defb1d92f1bba83c3ee8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -1,3 +1,14 @@\n+2014-11-10  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* config/nvptx/nvptx.c: New file.\n+\t* config/nvptx/nvptx.h: New file.\n+\t* config/nvptx/nvptx-protos.h: New file.\n+\t* config/nvptx/nvptx.md: New file.\n+\t* config/nvptx/t-nvptx: New file.\n+\t* config/nvptx/nvptx.opt: New file.\n+\t* common/config/nvptx/nvptx-common.c: New file.\n+\t* config.gcc: Handle nvptx-*-*.\n+\n 2014-11-10  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-operands.c (finalize_ssa_uses): Properly put"}, {"sha": "80ab076aaf3108543a5307ba41c66f759505c0b6", "filename": "gcc/common/config/nvptx/nvptx-common.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fcommon%2Fconfig%2Fnvptx%2Fnvptx-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fcommon%2Fconfig%2Fnvptx%2Fnvptx-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fnvptx%2Fnvptx-common.c?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,38 @@\n+/* NVPTX common hooks.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Bernd Schmidt <bernds@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"tm.h\"\n+#include \"tm_p.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+\n+#undef TARGET_HAVE_NAMED_SECTIONS\n+#define TARGET_HAVE_NAMED_SECTIONS false\n+\n+#undef TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS MASK_ABI64\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "2284b9ee2970bc6599a3e387348604636e2b2349", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -422,6 +422,9 @@ nios2-*-*)\n \tcpu_type=nios2\n \textra_options=\"${extra_options} g.opt\"\n \t;;\n+nvptx-*-*)\n+\tcpu_type=nvptx\n+\t;;\n powerpc*-*-*)\n \tcpu_type=rs6000\n \textra_headers=\"ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h htmintrin.h htmxlintrin.h\"\n@@ -2153,6 +2156,10 @@ nios2-*-*)\n \t\t;;\n         esac\n \t;;\n+nvptx-*)\n+\ttm_file=\"${tm_file} newlib-stdint.h\"\n+\ttmake_file=\"nvptx/t-nvptx\"\n+\t;;\n pdp11-*-*)\n \ttm_file=\"${tm_file} newlib-stdint.h\"\n \tuse_gcc_stdint=wrap"}, {"sha": "bd5a920303b59c75881782abe49fcbad81e833b1", "filename": "gcc/config/nvptx/nvptx-protos.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,46 @@\n+/* Prototypes for exported functions defined in nvptx.c.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Bernd Schmidt <bernds@codesourcery.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_NVPTX_PROTOS_H\n+#define GCC_NVPTX_PROTOS_H\n+\n+extern void nvptx_declare_function_name (FILE *, const char *, const_tree decl);\n+extern void nvptx_declare_object_name (FILE *file, const char *name,\n+\t\t\t\t       const_tree decl);\n+extern void nvptx_record_needed_fndecl (tree decl);\n+extern void nvptx_function_end (FILE *);\n+extern void nvptx_output_skip (FILE *, unsigned HOST_WIDE_INT);\n+extern void nvptx_output_ascii (FILE *, const char *, unsigned HOST_WIDE_INT);\n+extern void nvptx_register_pragmas (void);\n+extern const char *nvptx_section_for_decl (const_tree);\n+\n+#ifdef RTX_CODE\n+extern void nvptx_expand_call (rtx, rtx);\n+extern rtx nvptx_expand_compare (rtx);\n+extern const char *nvptx_ptx_type_from_mode (machine_mode, bool);\n+extern const char *nvptx_output_call_insn (rtx_insn *, rtx, rtx);\n+extern const char *nvptx_output_return (void);\n+extern machine_mode nvptx_underlying_object_mode (rtx);\n+extern const char *nvptx_section_from_addr_space (addr_space_t);\n+extern bool nvptx_hard_regno_mode_ok (int, machine_mode);\n+extern addr_space_t nvptx_addr_space_from_address (rtx);\n+extern rtx nvptx_maybe_convert_symbolic_operand (rtx);\n+#endif\n+#endif"}, {"sha": "9382812b36ab33f7a420e11e6c0b7cac89e66f6f", "filename": "gcc/config/nvptx/nvptx.c", "status": "added", "additions": 2120, "deletions": 0, "changes": 2120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,2120 @@\n+/* Target code for NVPTX.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Bernd Schmidt <bernds@codesourcery.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+#include \"expr.h\"\n+#include \"regs.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n+#include \"ggc.h\"\n+#include \"timevar.h\"\n+#include \"tm_p.h\"\n+#include \"tm-preds.h\"\n+#include \"tm-constrs.h\"\n+#include \"function.h\"\n+#include \"langhooks.h\"\n+#include \"dbxout.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"diagnostic.h\"\n+#include \"predict.h\"\n+#include \"basic-block.h\"\n+#include \"cfgrtl.h\"\n+#include \"stor-layout.h\"\n+#include \"calls.h\"\n+#include \"df.h\"\n+#include \"builtins.h\"\n+#include \"hashtab.h\"\n+#include <sstream>\n+\n+/* Record the function decls we've written, and the libfuncs and function\n+   decls corresponding to them.  */\n+static std::stringstream func_decls;\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n+  htab_t declared_libfuncs_htab;\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+  htab_t declared_fndecls_htab;\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+  htab_t needed_fndecls_htab;\n+\n+/* Allocate a new, cleared machine_function structure.  */\n+\n+static struct machine_function *\n+nvptx_init_machine_status (void)\n+{\n+  struct machine_function *p = ggc_cleared_alloc<machine_function> ();\n+  p->ret_reg_mode = VOIDmode;\n+  return p;\n+}\n+\n+/* Implement TARGET_OPTION_OVERRIDE.  */\n+\n+static void\n+nvptx_option_override (void)\n+{\n+  init_machine_status = nvptx_init_machine_status;\n+  /* Gives us a predictable order, which we need especially for variables.  */\n+  flag_toplevel_reorder = 1;\n+  /* Assumes that it will see only hard registers.  */\n+  flag_var_tracking = 0;\n+  write_symbols = NO_DEBUG;\n+  debug_info_level = DINFO_LEVEL_NONE;\n+\n+  declared_fndecls_htab\n+    = htab_create_ggc (17, htab_hash_pointer, htab_eq_pointer, NULL);\n+  needed_fndecls_htab\n+    = htab_create_ggc (17, htab_hash_pointer, htab_eq_pointer, NULL);\n+  declared_libfuncs_htab\n+    = htab_create_ggc (17, htab_hash_pointer, htab_eq_pointer, NULL);\n+}\n+\n+/* Return the mode to be used when declaring a ptx object for OBJ.\n+   For objects with subparts such as complex modes this is the mode\n+   of the subpart.  */\n+\n+machine_mode\n+nvptx_underlying_object_mode (rtx obj)\n+{\n+  if (GET_CODE (obj) == SUBREG)\n+    obj = SUBREG_REG (obj);\n+  machine_mode mode = GET_MODE (obj);\n+  if (mode == TImode)\n+    return DImode;\n+  if (COMPLEX_MODE_P (mode))\n+    return GET_MODE_INNER (mode);\n+  return mode;\n+}\n+\n+/* Return a ptx type for MODE.  If PROMOTE, then use .u32 for QImode to\n+   deal with ptx ideosyncracies.  */\n+\n+const char *\n+nvptx_ptx_type_from_mode (machine_mode mode, bool promote)\n+{\n+  switch (mode)\n+    {\n+    case BLKmode:\n+      return \".b8\";\n+    case BImode:\n+      return \".pred\";\n+    case QImode:\n+      if (promote)\n+\treturn \".u32\";\n+      else\n+\treturn \".u8\";\n+    case HImode:\n+      return \".u16\";\n+    case SImode:\n+      return \".u32\";\n+    case DImode:\n+      return \".u64\";\n+\n+    case SFmode:\n+      return \".f32\";\n+    case DFmode:\n+      return \".f64\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return the number of pieces to use when dealing with a pseudo of *PMODE.\n+   Alter *PMODE if we return a number greater than one.  */\n+\n+static int\n+maybe_split_mode (machine_mode *pmode)\n+{\n+  machine_mode mode = *pmode;\n+\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      *pmode = GET_MODE_INNER (mode);\n+      return 2;\n+    }\n+  else if (mode == TImode)\n+    {\n+      *pmode = DImode;\n+      return 2;\n+    }\n+  return 1;\n+}\n+\n+/* Like maybe_split_mode, but only return whether or not the mode\n+   needs to be split.  */\n+static bool\n+nvptx_split_reg_p (machine_mode mode)\n+{\n+  if (COMPLEX_MODE_P (mode))\n+    return true;\n+  if (mode == TImode)\n+    return true;\n+  return false;\n+}\n+\n+#define PASS_IN_REG_P(MODE, TYPE)\t\t\t\t\\\n+  ((GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\\\n+    || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n+    || ((GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT\t\t\\\n+\t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\\\n+\t&& !AGGREGATE_TYPE_P (TYPE)))\t\t\t\t\\\n+   && (MODE) != TImode)\n+\n+#define RETURN_IN_REG_P(MODE)\t\t\t\\\n+  ((GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+    || GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\\\n+   && GET_MODE_SIZE (MODE) <= 8)\n+\f\n+/* Perform a mode promotion for a function argument with MODE.  Return\n+   the promoted mode.  */\n+\n+static machine_mode\n+arg_promotion (machine_mode mode)\n+{\n+  if (mode == QImode || mode == HImode)\n+    return SImode;\n+  return mode;\n+}\n+\n+/* Write the declaration of a function arg of TYPE to S.  I is the index\n+   of the argument, MODE its mode.  NO_ARG_TYPES is true if this is for\n+   a decl with zero TYPE_ARG_TYPES, i.e. an old-style C decl.  */\n+\n+static int\n+write_one_arg (std::stringstream &s, tree type, int i, machine_mode mode,\n+\t       bool no_arg_types)\n+{\n+  if (!PASS_IN_REG_P (mode, type))\n+    mode = Pmode;\n+\n+  int count = maybe_split_mode (&mode);\n+\n+  if (count == 2)\n+    {\n+      write_one_arg (s, NULL_TREE, i, mode, false);\n+      write_one_arg (s, NULL_TREE, i + 1, mode, false);\n+      return i + 1;\n+    }\n+\n+  if (no_arg_types && !AGGREGATE_TYPE_P (type))\n+    {\n+      if (mode == SFmode)\n+\tmode = DFmode;\n+      mode = arg_promotion (mode);\n+    }\n+\n+  if (i > 0)\n+    s << \", \";\n+  s << \".param\" << nvptx_ptx_type_from_mode (mode, false) << \" %in_ar\"\n+    << (i + 1) << (mode == QImode || mode == HImode ? \"[1]\" : \"\");\n+  if (mode == BLKmode)\n+    s << \"[\" << int_size_in_bytes (type) << \"]\";\n+  return i;\n+}\n+\n+/* Look for attributes in ATTRS that would indicate we must write a function\n+   as a .entry kernel rather than a .func.  Return true if one is found.  */\n+\n+static bool\n+write_as_kernel (tree attrs)\n+{\n+  return (lookup_attribute (\"kernel\", attrs) != NULL_TREE\n+\t  || lookup_attribute (\"omp target entrypoint\", attrs) != NULL_TREE);\n+}\n+\n+/* Write a function decl for DECL to S, where NAME is the name to be used.  */\n+\n+static void\n+nvptx_write_function_decl (std::stringstream &s, const char *name, const_tree decl)\n+{\n+  tree fntype = TREE_TYPE (decl);\n+  tree result_type = TREE_TYPE (fntype);\n+  tree args = TYPE_ARG_TYPES (fntype);\n+  tree attrs = DECL_ATTRIBUTES (decl);\n+  bool kernel = write_as_kernel (attrs);\n+  bool is_main = strcmp (name, \"main\") == 0;\n+  bool args_from_decl = false;\n+\n+  /* We get:\n+     NULL in TYPE_ARG_TYPES, for old-style functions\n+     NULL in DECL_ARGUMENTS, for builtin functions without another\n+       declaration.\n+     So we have to pick the best one we have.  */\n+  if (args == 0)\n+    {\n+      args = DECL_ARGUMENTS (decl);\n+      args_from_decl = true;\n+    }\n+\n+  if (DECL_EXTERNAL (decl))\n+    s << \".extern \";\n+  else if (TREE_PUBLIC (decl))\n+    s << \".visible \";\n+\n+  if (kernel)\n+    s << \".entry \";\n+  else\n+    s << \".func \";\n+\n+  /* Declare the result.  */\n+  bool return_in_mem = false;\n+  if (TYPE_MODE (result_type) != VOIDmode)\n+    {\n+      machine_mode mode = TYPE_MODE (result_type);\n+      if (!RETURN_IN_REG_P (mode))\n+\treturn_in_mem = true;\n+      else\n+\t{\n+\t  mode = arg_promotion (mode);\n+\t  s << \"(.param\" << nvptx_ptx_type_from_mode (mode, false)\n+\t    << \" %out_retval)\";\n+\t}\n+    }\n+\n+  if (name[0] == '*')\n+    s << (name + 1);\n+  else\n+    s << name;\n+\n+  /* Declare argument types.  */\n+  if ((args != NULL_TREE\n+       && !(TREE_CODE (args) == TREE_LIST && TREE_VALUE (args) == void_type_node))\n+      || is_main\n+      || return_in_mem\n+      || DECL_STATIC_CHAIN (decl))\n+    {\n+      s << \"(\";\n+      int i = 0;\n+      bool any_args = false;\n+      if (return_in_mem)\n+\t{\n+\t  s << \".param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_ar1\";\n+\t  i++;\n+\t}\n+      while (args != NULL_TREE)\n+\t{\n+\t  tree type = args_from_decl ? TREE_TYPE (args) : TREE_VALUE (args);\n+\t  machine_mode mode = TYPE_MODE (type);\n+\n+\t  if (mode != VOIDmode)\n+\t    {\n+\t      i = write_one_arg (s, type, i, mode,\n+\t\t\t\t TYPE_ARG_TYPES (fntype) == 0);\n+\t      any_args = true;\n+\t      i++;\n+\t    }\n+\t  args = TREE_CHAIN (args);\n+\t}\n+      if (stdarg_p (fntype))\n+\t{\n+\t  gcc_assert (i > 0);\n+\t  s << \", .param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_argp\";\n+\t}\n+      if (DECL_STATIC_CHAIN (decl))\n+\t{\n+\t  if (i > 0)\n+\t    s << \", \";\n+\t  s << \".reg.u\" << GET_MODE_BITSIZE (Pmode)\n+\t    << reg_names [STATIC_CHAIN_REGNUM];\n+\t}\n+      if (!any_args && is_main)\n+\ts << \".param.u32 %argc, .param.u\" << GET_MODE_BITSIZE (Pmode)\n+\t  << \" %argv\";\n+      s << \")\";\n+    }\n+}\n+\n+/* Walk either ARGTYPES or ARGS if the former is null, and write out part of\n+   the function header to FILE.  If WRITE_COPY is false, write reg\n+   declarations, otherwise write the copy from the incoming argument to that\n+   reg.  RETURN_IN_MEM indicates whether to start counting arg numbers at 1\n+   instead of 0.  */\n+\n+static void\n+walk_args_for_param (FILE *file, tree argtypes, tree args, bool write_copy,\n+\t\t     bool return_in_mem)\n+{\n+  int i;\n+\n+  bool args_from_decl = false;\n+  if (argtypes == 0)\n+    args_from_decl = true;\n+  else\n+    args = argtypes;\n+\n+  for (i = return_in_mem ? 1 : 0; args != NULL_TREE; args = TREE_CHAIN (args))\n+    {\n+      tree type = args_from_decl ? TREE_TYPE (args) : TREE_VALUE (args);\n+      machine_mode mode = TYPE_MODE (type);\n+\n+      if (mode == VOIDmode)\n+\tbreak;\n+\n+      if (!PASS_IN_REG_P (mode, type))\n+\tmode = Pmode;\n+\n+      int count = maybe_split_mode (&mode);\n+      if (count == 1)\n+\t{\n+\t  if (argtypes == NULL && !AGGREGATE_TYPE_P (type))\n+\t    {\n+\t      if (mode == SFmode)\n+\t\tmode = DFmode;\n+\n+\t    }\n+\t  mode = arg_promotion (mode);\n+\t}\n+      while (count-- > 0)\n+\t{\n+\t  i++;\n+\t  if (write_copy)\n+\t    fprintf (file, \"\\tld.param%s %%ar%d, [%%in_ar%d];\\n\",\n+\t\t     nvptx_ptx_type_from_mode (mode, false), i, i);\n+\t  else\n+\t    fprintf (file, \"\\t.reg%s %%ar%d;\\n\",\n+\t\t     nvptx_ptx_type_from_mode (mode, false), i);\n+\t}\n+    }\n+}\n+\n+/* Write a .func or .kernel declaration (not a definition) along with\n+   a helper comment for use by ld.  S is the stream to write to, DECL\n+   the decl for the function with name NAME.  */\n+\n+static void\n+write_function_decl_and_comment (std::stringstream &s, const char *name, const_tree decl)\n+{\n+  s << \"// BEGIN\";\n+  if (TREE_PUBLIC (decl))\n+    s << \" GLOBAL\";\n+  s << \" FUNCTION DECL: \";\n+  if (name[0] == '*')\n+    s << (name + 1);\n+  else\n+    s << name;\n+  s << \"\\n\";\n+  nvptx_write_function_decl (s, name, decl);\n+  s << \";\\n\";\n+}\n+\n+/* Check NAME for special function names and redirect them by returning a\n+   replacement.  This applies to malloc, free and realloc, for which we\n+   want to use libgcc wrappers, and call, which triggers a bug in ptxas.  */\n+\n+static const char *\n+nvptx_name_replacement (const char *name)\n+{\n+  if (strcmp (name, \"call\") == 0)\n+    return \"__nvptx_call\";\n+  if (strcmp (name, \"malloc\") == 0)\n+    return \"__nvptx_malloc\";\n+  if (strcmp (name, \"free\") == 0)\n+    return \"__nvptx_free\";\n+  if (strcmp (name, \"realloc\") == 0)\n+    return \"__nvptx_realloc\";\n+  return name;\n+}\n+\n+/* If DECL is a FUNCTION_DECL, check the hash table to see if we\n+   already encountered it, and if not, insert it and write a ptx\n+   declarations that will be output at the end of compilation.  */\n+\n+static bool\n+nvptx_record_fndecl (tree decl, bool force = false)\n+{\n+  if (decl == NULL_TREE || TREE_CODE (decl) != FUNCTION_DECL\n+      || !DECL_EXTERNAL (decl))\n+    return true;\n+\n+  if (!force && TYPE_ARG_TYPES (TREE_TYPE (decl)) == NULL_TREE)\n+    return false;\n+\n+  void **slot = htab_find_slot (declared_fndecls_htab, decl, INSERT);\n+  if (*slot == NULL)\n+    {\n+      *slot = decl;\n+      const char *name = get_fnname_from_decl (decl);\n+      name = nvptx_name_replacement (name);\n+      write_function_decl_and_comment (func_decls, name, decl);\n+    }\n+  return true;\n+}\n+\n+/* Record that we need to emit a ptx decl for DECL.  Either do it now, or\n+   record it for later in case we have no argument information at this\n+   point.  */\n+\n+void\n+nvptx_record_needed_fndecl (tree decl)\n+{\n+  if (nvptx_record_fndecl (decl))\n+    return;\n+\n+  void **slot = htab_find_slot (needed_fndecls_htab, decl, INSERT);\n+  if (*slot == NULL)\n+    *slot = decl;\n+}\n+\n+/* Implement ASM_DECLARE_FUNCTION_NAME.  Writes the start of a ptx\n+   function, including local var decls and copies from the arguments to\n+   local regs.  */\n+\n+void\n+nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n+{\n+  tree fntype = TREE_TYPE (decl);\n+  tree result_type = TREE_TYPE (fntype);\n+\n+  name = nvptx_name_replacement (name);\n+\n+  std::stringstream s;\n+  write_function_decl_and_comment (s, name, decl);\n+  s << \"// BEGIN\";\n+  if (TREE_PUBLIC (decl))\n+    s << \" GLOBAL\";\n+  s << \" FUNCTION DEF: \";\n+\n+  if (name[0] == '*')\n+    s << (name + 1);\n+  else\n+    s << name;\n+  s << \"\\n\";\n+\n+  nvptx_write_function_decl (s, name, decl);\n+  fprintf (file, \"%s\", s.str().c_str());\n+\n+  bool return_in_mem = false;\n+  if (TYPE_MODE (result_type) != VOIDmode)\n+    {\n+      machine_mode mode = TYPE_MODE (result_type);\n+      if (!RETURN_IN_REG_P (mode))\n+\treturn_in_mem = true;\n+    }\n+\n+  fprintf (file, \"\\n{\\n\");\n+\n+  /* Ensure all arguments that should live in a register have one\n+     declared.  We'll emit the copies below.  */\n+  walk_args_for_param (file, TYPE_ARG_TYPES (fntype), DECL_ARGUMENTS (decl),\n+\t\t       false, return_in_mem);\n+  if (return_in_mem)\n+    fprintf (file, \"\\t.reg.u%d %%ar1;\\n\", GET_MODE_BITSIZE (Pmode));\n+  else if (TYPE_MODE (result_type) != VOIDmode)\n+    {\n+      machine_mode mode = arg_promotion (TYPE_MODE (result_type));\n+      fprintf (file, \".reg%s %%retval;\\n\",\n+\t       nvptx_ptx_type_from_mode (mode, false));\n+    }\n+\n+  if (stdarg_p (fntype))\n+    fprintf (file, \"\\t.reg.u%d %%argp;\\n\", GET_MODE_BITSIZE (Pmode));\n+\n+  fprintf (file, \"\\t.reg.u%d %s;\\n\", GET_MODE_BITSIZE (Pmode),\n+\t   reg_names[OUTGOING_STATIC_CHAIN_REGNUM]);\n+\n+  /* Declare the pseudos we have as ptx registers.  */\n+  int maxregs = max_reg_num ();\n+  for (int i = LAST_VIRTUAL_REGISTER + 1; i < maxregs; i++)\n+    {\n+      if (regno_reg_rtx[i] != const0_rtx)\n+\t{\n+\t  machine_mode mode = PSEUDO_REGNO_MODE (i);\n+\t  int count = maybe_split_mode (&mode);\n+\t  if (count > 1)\n+\t    {\n+\t      while (count-- > 0)\n+\t\tfprintf (file, \"\\t.reg%s %%r%d$%d;\\n\",\n+\t\t\t nvptx_ptx_type_from_mode (mode, true),\n+\t\t\t i, count);\n+\t    }\n+\t  else\n+\t    fprintf (file, \"\\t.reg%s %%r%d;\\n\",\n+\t\t     nvptx_ptx_type_from_mode (mode, true),\n+\t\t     i);\n+\t}\n+    }\n+\n+  /* The only reason we might be using outgoing args is if we call a stdargs\n+     function.  Allocate the space for this.  If we called varargs functions\n+     without passing any variadic arguments, we'll see a reference to outargs\n+     even with a zero outgoing_args_size.  */\n+  HOST_WIDE_INT sz = crtl->outgoing_args_size;\n+  if (sz == 0)\n+    sz = 1;\n+  if (cfun->machine->has_call_with_varargs)\n+    fprintf (file, \"\\t.reg.u%d %%outargs;\\n\"\n+\t     \"\\t.local.align 8 .b8 %%outargs_ar[\"HOST_WIDE_INT_PRINT_DEC\"];\\n\",\n+\t     BITS_PER_WORD, sz);\n+  if (cfun->machine->punning_buffer_size > 0)\n+    fprintf (file, \"\\t.reg.u%d %%punbuffer;\\n\"\n+\t     \"\\t.local.align 8 .b8 %%punbuffer_ar[%d];\\n\",\n+\t     BITS_PER_WORD, cfun->machine->punning_buffer_size);\n+\n+  /* Declare a local variable for the frame.  */\n+  sz = get_frame_size ();\n+  if (sz > 0 || cfun->machine->has_call_with_sc)\n+    {\n+      fprintf (file, \"\\t.reg.u%d %%frame;\\n\"\n+\t       \"\\t.local.align 8 .b8 %%farray[\"HOST_WIDE_INT_PRINT_DEC\"];\\n\",\n+\t       BITS_PER_WORD, sz == 0 ? 1 : sz);\n+      fprintf (file, \"\\tcvta.local.u%d %%frame, %%farray;\\n\",\n+\t       BITS_PER_WORD);\n+    }\n+\n+  if (cfun->machine->has_call_with_varargs)\n+      fprintf (file, \"\\tcvta.local.u%d %%outargs, %%outargs_ar;\\n\",\n+\t       BITS_PER_WORD);\n+  if (cfun->machine->punning_buffer_size > 0)\n+      fprintf (file, \"\\tcvta.local.u%d %%punbuffer, %%punbuffer_ar;\\n\",\n+\t       BITS_PER_WORD);\n+\n+  /* Now emit any copies necessary for arguments.  */\n+  walk_args_for_param (file, TYPE_ARG_TYPES (fntype), DECL_ARGUMENTS (decl),\n+\t\t       true, return_in_mem);\n+  if (return_in_mem)\n+    fprintf (file, \"ld.param.u%d %%ar1, [%%in_ar1];\\n\",\n+\t     GET_MODE_BITSIZE (Pmode));\n+  if (stdarg_p (fntype))\n+    fprintf (file, \"ld.param.u%d %%argp, [%%in_argp];\\n\",\n+\t     GET_MODE_BITSIZE (Pmode));\n+}\n+\n+/* Output a return instruction.  Also copy the return value to its outgoing\n+   location.  */\n+\n+const char *\n+nvptx_output_return (void)\n+{\n+  tree fntype = TREE_TYPE (current_function_decl);\n+  tree result_type = TREE_TYPE (fntype);\n+  if (TYPE_MODE (result_type) != VOIDmode)\n+    {\n+      machine_mode mode = TYPE_MODE (result_type);\n+      if (RETURN_IN_REG_P (mode))\n+\t{\n+\t  mode = arg_promotion (mode);\n+\t  fprintf (asm_out_file, \"\\tst.param%s\\t[%%out_retval], %%retval;\\n\",\n+\t\t   nvptx_ptx_type_from_mode (mode, false));\n+\t}\n+    }\n+\n+  return \"ret;\";\n+}\n+\n+/* Construct a function declaration from a call insn.  This can be\n+   necessary for two reasons - either we have an indirect call which\n+   requires a .callprototype declaration, or we have a libcall\n+   generated by emit_library_call for which no decl exists.  */\n+\n+static void\n+write_func_decl_from_insn (std::stringstream &s, rtx result, rtx pat,\n+\t\t\t   rtx callee)\n+{\n+  bool callprototype = register_operand (callee, Pmode);\n+  const char *name = \"_\";\n+  if (!callprototype)\n+    {\n+      name = XSTR (callee, 0);\n+      name = nvptx_name_replacement (name);\n+      s << \"// BEGIN GLOBAL FUNCTION DECL: \" << name << \"\\n\";\n+    }\n+  s << (callprototype ? \"\\t.callprototype\\t\" : \"\\t.extern .func \");\n+\n+  if (result != NULL_RTX)\n+    {\n+      s << \"(.param\";\n+      s << nvptx_ptx_type_from_mode (arg_promotion (GET_MODE (result)),\n+\t\t\t\t     false);\n+      s << \" \";\n+      if (callprototype)\n+\ts << \"_\";\n+      else\n+\ts << \"%out_retval\";\n+      s << \")\";\n+    }\n+\n+  s << name;\n+\n+  int nargs = XVECLEN (pat, 0) - 1;\n+  if (nargs > 0)\n+    {\n+      s << \" (\";\n+      for (int i = 0; i < nargs; i++)\n+\t{\n+\t  rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+\t  machine_mode mode = GET_MODE (t);\n+\t  int count = maybe_split_mode (&mode);\n+\n+\t  while (count-- > 0)\n+\t    {\n+\t      s << \".param\";\n+\t      s << nvptx_ptx_type_from_mode (mode, false);\n+\t      s << \" \";\n+\t      if (callprototype)\n+\t\ts << \"_\";\n+\t      else\n+\t\ts << \"%arg\" << i;\n+\t      if (mode == QImode || mode == HImode)\n+\t\ts << \"[1]\";\n+\t      if (i + 1 < nargs || count > 0)\n+\t\ts << \", \";\n+\t    }\n+\t}\n+      s << \")\";\n+    }\n+  s << \";\\n\";\n+}\n+\n+/* Terminate a function by writing a closing brace to FILE.  */\n+\n+void\n+nvptx_function_end (FILE *file)\n+{\n+  fprintf (file, \"\\t}\\n\");\n+}\n+\f\n+/* Decide whether we can make a sibling call to a function.  For ptx, we\n+   can't.  */\n+\n+static bool\n+nvptx_function_ok_for_sibcall (tree, tree)\n+{\n+  return false;\n+}\n+\n+/* Implement the TARGET_CALL_ARGS hook.  Record information about one\n+   argument to the next call.  */\n+\n+static void\n+nvptx_call_args (rtx arg, tree funtype)\n+{\n+  if (cfun->machine->start_call == NULL_RTX)\n+    {\n+      cfun->machine->call_args = NULL;\n+      cfun->machine->funtype = funtype;\n+      cfun->machine->start_call = const0_rtx;\n+    }\n+  if (arg == pc_rtx)\n+    return;\n+\n+  rtx_expr_list *args_so_far = cfun->machine->call_args;\n+  if (REG_P (arg))\n+    cfun->machine->call_args = alloc_EXPR_LIST (VOIDmode, arg, args_so_far);\n+}\n+\n+/* Implement the corresponding END_CALL_ARGS hook.  Clear and free the\n+   information we recorded.  */\n+\n+static void\n+nvptx_end_call_args (void)\n+{\n+  cfun->machine->start_call = NULL_RTX;\n+  free_EXPR_LIST_list (&cfun->machine->call_args);\n+}\n+\n+/* Emit the sequence for a call.  */\n+\n+void\n+nvptx_expand_call (rtx retval, rtx address)\n+{\n+  int nargs;\n+  rtx callee = XEXP (address, 0);\n+  rtx pat, t;\n+  rtvec vec;\n+  bool external_decl = false;\n+\n+  nargs = 0;\n+  for (t = cfun->machine->call_args; t; t = XEXP (t, 1))\n+    nargs++;\n+\n+  bool has_varargs = false;\n+  tree decl_type = NULL_TREE;\n+\n+  if (!call_insn_operand (callee, Pmode))\n+    {\n+      callee = force_reg (Pmode, callee);\n+      address = change_address (address, QImode, callee);\n+    }\n+\n+  if (GET_CODE (callee) == SYMBOL_REF)\n+    {\n+      tree decl = SYMBOL_REF_DECL (callee);\n+      if (decl != NULL_TREE)\n+\t{\n+\t  decl_type = TREE_TYPE (decl);\n+\t  if (DECL_STATIC_CHAIN (decl))\n+\t    cfun->machine->has_call_with_sc = true;\n+\t  if (DECL_EXTERNAL (decl))\n+\t    external_decl = true;\n+\t}\n+    }\n+  if (cfun->machine->funtype\n+      /* It's possible to construct testcases where we call a variable.\n+\t See compile/20020129-1.c.  stdarg_p will crash so avoid calling it\n+\t in such a case.  */\n+      && (TREE_CODE (cfun->machine->funtype) == FUNCTION_TYPE\n+\t  || TREE_CODE (cfun->machine->funtype) == METHOD_TYPE)\n+      && stdarg_p (cfun->machine->funtype))\n+    {\n+      has_varargs = true;\n+      cfun->machine->has_call_with_varargs = true;\n+    }\n+  vec = rtvec_alloc (nargs + 1 + (has_varargs ? 1 : 0));\n+  pat = gen_rtx_PARALLEL (VOIDmode, vec);\n+  if (has_varargs)\n+    {\n+      rtx this_arg = gen_reg_rtx (Pmode);\n+      if (Pmode == DImode)\n+\temit_move_insn (this_arg, stack_pointer_rtx);\n+      else\n+\temit_move_insn (this_arg, stack_pointer_rtx);\n+      XVECEXP (pat, 0, nargs + 1) = gen_rtx_USE (VOIDmode, this_arg);\n+    }\n+\n+  int i;\n+  rtx arg;\n+  for (i = 1, arg = cfun->machine->call_args; arg; arg = XEXP (arg, 1), i++)\n+    {\n+      rtx this_arg = XEXP (arg, 0);\n+      XVECEXP (pat, 0, i) = gen_rtx_USE (VOIDmode, this_arg);\n+    }\n+\n+  rtx tmp_retval = retval;\n+  t = gen_rtx_CALL (VOIDmode, address, const0_rtx);\n+  if (retval != NULL_RTX)\n+    {\n+      if (!nvptx_register_operand (retval, GET_MODE (retval)))\n+\ttmp_retval = gen_reg_rtx (GET_MODE (retval));\n+      t = gen_rtx_SET (VOIDmode, tmp_retval, t);\n+    }\n+  XVECEXP (pat, 0, 0) = t;\n+  if (!REG_P (callee)\n+      && (decl_type == NULL_TREE\n+\t  || (external_decl && TYPE_ARG_TYPES (decl_type) == NULL_TREE)))\n+    {\n+      void **slot = htab_find_slot (declared_libfuncs_htab, callee, INSERT);\n+      if (*slot == NULL)\n+\t{\n+\t  *slot = callee;\n+\t  write_func_decl_from_insn (func_decls, retval, pat, callee);\n+\t}\n+    }\n+  emit_call_insn (pat);\n+  if (tmp_retval != retval)\n+    emit_move_insn (retval, tmp_retval);\n+}\n+\n+/* Implement TARGET_FUNCTION_ARG.  */\n+\n+static rtx\n+nvptx_function_arg (cumulative_args_t, machine_mode mode,\n+\t\t    const_tree, bool named)\n+{\n+  if (mode == VOIDmode)\n+    return NULL_RTX;\n+\n+  if (named)\n+    return gen_reg_rtx (mode);\n+  return NULL_RTX;\n+}\n+\n+/* Implement TARGET_FUNCTION_INCOMING_ARG.  */\n+\n+static rtx\n+nvptx_function_incoming_arg (cumulative_args_t cum_v, machine_mode mode,\n+\t\t\t     const_tree, bool named)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  if (mode == VOIDmode)\n+    return NULL_RTX;\n+\n+  if (!named)\n+    return NULL_RTX;\n+\n+  /* No need to deal with split modes here, the only case that can\n+     happen is complex modes and those are dealt with by\n+     TARGET_SPLIT_COMPLEX_ARG.  */\n+  return gen_rtx_UNSPEC (mode,\n+\t\t\t gen_rtvec (1, GEN_INT (1 + cum->count)),\n+\t\t\t UNSPEC_ARG_REG);\n+}\n+\n+/* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n+\n+static void\n+nvptx_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n+\t\t\t    const_tree type ATTRIBUTE_UNUSED,\n+\t\t\t    bool named ATTRIBUTE_UNUSED)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  if (mode == TImode)\n+    cum->count += 2;\n+  else\n+    cum->count++;\n+}\n+\n+/* Handle the TARGET_STRICT_ARGUMENT_NAMING target hook.\n+\n+   For nvptx, we know how to handle functions declared as stdarg: by\n+   passing an extra pointer to the unnamed arguments.  However, the\n+   Fortran frontend can produce a different situation, where a\n+   function pointer is declared with no arguments, but the actual\n+   function and calls to it take more arguments.  In that case, we\n+   want to ensure the call matches the definition of the function.  */\n+\n+static bool\n+nvptx_strict_argument_naming (cumulative_args_t cum_v)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  return cum->fntype == NULL_TREE || stdarg_p (cum->fntype);\n+}\n+\n+/* Implement TARGET_FUNCTION_ARG_BOUNDARY.  */\n+\n+static unsigned int\n+nvptx_function_arg_boundary (machine_mode mode, const_tree type)\n+{\n+  unsigned int boundary = type ? TYPE_ALIGN (type) : GET_MODE_BITSIZE (mode);\n+\n+  if (boundary > BITS_PER_WORD)\n+    return 2 * BITS_PER_WORD;\n+\n+  if (mode == BLKmode)\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      if (size > 4)\n+        return 2 * BITS_PER_WORD;\n+      if (boundary < BITS_PER_WORD)\n+        {\n+          if (size >= 3)\n+            return BITS_PER_WORD;\n+          if (size >= 2)\n+            return 2 * BITS_PER_UNIT;\n+        }\n+    }\n+  return boundary;\n+}\n+\n+/* TARGET_FUNCTION_VALUE implementation.  Returns an RTX representing the place\n+   where function FUNC returns or receives a value of data type TYPE.  */\n+\n+static rtx\n+nvptx_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED,\n+\t\t      bool outgoing)\n+{\n+  int unsignedp = TYPE_UNSIGNED (type);\n+  machine_mode orig_mode = TYPE_MODE (type);\n+  machine_mode mode = promote_function_mode (type, orig_mode,\n+\t\t\t\t\t     &unsignedp, NULL_TREE, 1);\n+  if (outgoing)\n+    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n+  if (cfun->machine->start_call == NULL_RTX)\n+    /* Pretend to return in a hard reg for early uses before pseudos can be\n+       generated.  */\n+    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n+  return gen_reg_rtx (mode);\n+}\n+\n+/* Implement TARGET_LIBCALL_VALUE.  */\n+\n+static rtx\n+nvptx_libcall_value (machine_mode mode, const_rtx)\n+{\n+  if (cfun->machine->start_call == NULL_RTX)\n+    /* Pretend to return in a hard reg for early uses before pseudos can be\n+       generated.  */\n+    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n+  return gen_reg_rtx (mode);\n+}\n+\n+/* Implement TARGET_FUNCTION_VALUE_REGNO_P.  */\n+\n+static bool\n+nvptx_function_value_regno_p (const unsigned int regno)\n+{\n+  return regno == NVPTX_RETURN_REGNUM;\n+}\n+\n+/* Types with a mode other than those supported by the machine are passed by\n+   reference in memory.  */\n+\n+static bool\n+nvptx_pass_by_reference (cumulative_args_t, machine_mode mode,\n+\t\t\t const_tree type, bool)\n+{\n+  return !PASS_IN_REG_P (mode, type);\n+}\n+\n+/* Implement TARGET_RETURN_IN_MEMORY.  */\n+\n+static bool\n+nvptx_return_in_memory (const_tree type, const_tree)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+  if (!RETURN_IN_REG_P (mode))\n+    return true;\n+  return false;\n+}\n+\n+/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */\n+\n+static machine_mode\n+nvptx_promote_function_mode (const_tree type, machine_mode mode,\n+\t\t\t     int *punsignedp,\n+\t\t\t     const_tree funtype, int for_return)\n+{\n+  if (type == NULL_TREE)\n+    return mode;\n+  if (for_return)\n+    return promote_mode (type, mode, punsignedp);\n+  /* For K&R-style functions, try to match the language promotion rules to\n+     minimize type mismatches at assembly time.  */\n+  if (TYPE_ARG_TYPES (funtype) == NULL_TREE\n+      && type != NULL_TREE\n+      && !AGGREGATE_TYPE_P (type))\n+    {\n+      if (mode == SFmode)\n+\tmode = DFmode;\n+      mode = arg_promotion (mode);\n+    }\n+\n+  return mode;\n+}\n+\n+/* Implement TARGET_STATIC_CHAIN.  */\n+\n+static rtx\n+nvptx_static_chain (const_tree fndecl, bool incoming_p)\n+{\n+  if (!DECL_STATIC_CHAIN (fndecl))\n+    return NULL;\n+\n+  if (incoming_p)\n+    return gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+  else\n+    return gen_rtx_REG (Pmode, OUTGOING_STATIC_CHAIN_REGNUM);\n+}\n+\f\n+/* Emit a comparison COMPARE, and return the new test to be used in the\n+   jump.  */\n+\n+rtx\n+nvptx_expand_compare (rtx compare)\n+{\n+  rtx pred = gen_reg_rtx (BImode);\n+  rtx cmp = gen_rtx_fmt_ee (GET_CODE (compare), BImode,\n+\t\t\t    XEXP (compare, 0), XEXP (compare, 1));\n+  emit_insn (gen_rtx_SET (VOIDmode, pred, cmp));\n+  return gen_rtx_NE (BImode, pred, const0_rtx);\n+}\n+\n+/* When loading an operand ORIG_OP, verify whether an address space\n+   conversion to generic is required, and if so, perform it.  Also\n+   check for SYMBOL_REFs for function decls and call\n+   nvptx_record_needed_fndecl as needed.\n+   Return either the original operand, or the converted one.  */\n+\n+rtx\n+nvptx_maybe_convert_symbolic_operand (rtx orig_op)\n+{\n+  if (GET_MODE (orig_op) != Pmode)\n+    return orig_op;\n+\n+  rtx op = orig_op;\n+  while (GET_CODE (op) == PLUS || GET_CODE (op) == CONST)\n+    op = XEXP (op, 0);\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return orig_op;\n+\n+  tree decl = SYMBOL_REF_DECL (op);\n+  if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      nvptx_record_needed_fndecl (decl);\n+      return orig_op;\n+    }\n+\n+  addr_space_t as = nvptx_addr_space_from_address (op);\n+  if (as == ADDR_SPACE_GENERIC)\n+    return orig_op;\n+\n+  enum unspec code;\n+  code = (as == ADDR_SPACE_GLOBAL ? UNSPEC_FROM_GLOBAL\n+\t  : as == ADDR_SPACE_LOCAL ? UNSPEC_FROM_LOCAL\n+\t  : as == ADDR_SPACE_SHARED ? UNSPEC_FROM_SHARED\n+\t  : as == ADDR_SPACE_CONST ? UNSPEC_FROM_CONST\n+\t  : UNSPEC_FROM_PARAM);\n+  rtx dest = gen_reg_rtx (Pmode);\n+  emit_insn (gen_rtx_SET (VOIDmode, dest,\n+\t\t\t  gen_rtx_UNSPEC (Pmode, gen_rtvec (1, orig_op),\n+\t\t\t\t\t  code)));\n+  return dest;\n+}\n+\f\n+/* Returns true if X is a valid address for use in a memory reference.  */\n+\n+static bool\n+nvptx_legitimate_address_p (machine_mode, rtx x, bool)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+      return true;\n+\n+    case PLUS:\n+      if (REG_P (XEXP (x, 0)) && CONST_INT_P (XEXP (x, 1)))\n+\treturn true;\n+      return false;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Implement HARD_REGNO_MODE_OK.  We barely use hard regs, but we want\n+   to ensure that the return register's mode isn't changed.  */\n+\n+bool\n+nvptx_hard_regno_mode_ok (int regno, machine_mode mode)\n+{\n+  if (regno != NVPTX_RETURN_REGNUM\n+      || cfun == NULL || cfun->machine->ret_reg_mode == VOIDmode)\n+    return true;\n+  return mode == cfun->machine->ret_reg_mode;\n+}\n+\f\n+/* Convert an address space AS to the corresponding ptx string.  */\n+\n+const char *\n+nvptx_section_from_addr_space (addr_space_t as)\n+{\n+  switch (as)\n+    {\n+    case ADDR_SPACE_CONST:\n+      return \".const\";\n+\n+    case ADDR_SPACE_GLOBAL:\n+      return \".global\";\n+\n+    case ADDR_SPACE_SHARED:\n+      return \".shared\";\n+\n+    case ADDR_SPACE_GENERIC:\n+      return \"\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Determine whether DECL goes into .const or .global.  */\n+\n+const char *\n+nvptx_section_for_decl (const_tree decl)\n+{\n+  bool is_const = (CONSTANT_CLASS_P (decl)\n+\t\t   || TREE_CODE (decl) == CONST_DECL\n+\t\t   || TREE_READONLY (decl));\n+  if (is_const)\n+    return \".const\";\n+\n+  return \".global\";\n+}\n+\n+/* Look for a SYMBOL_REF in ADDR and return the address space to be used\n+   for the insn referencing this address.  */\n+\n+addr_space_t\n+nvptx_addr_space_from_address (rtx addr)\n+{\n+  while (GET_CODE (addr) == PLUS || GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+  if (GET_CODE (addr) != SYMBOL_REF)\n+    return ADDR_SPACE_GENERIC;\n+\n+  tree decl = SYMBOL_REF_DECL (addr);\n+  if (decl == NULL_TREE || TREE_CODE (decl) == FUNCTION_DECL)\n+    return ADDR_SPACE_GENERIC;\n+\n+  bool is_const = (CONSTANT_CLASS_P (decl)\n+\t\t   || TREE_CODE (decl) == CONST_DECL\n+\t\t   || TREE_READONLY (decl));\n+  if (is_const)\n+    return ADDR_SPACE_CONST;\n+\n+  return ADDR_SPACE_GLOBAL;\n+}\n+\f\n+/* Machinery to output constant initializers.  */\n+\n+/* Used when assembling integers to ensure data is emitted in\n+   pieces whose size matches the declaration we printed.  */\n+static unsigned int decl_chunk_size;\n+static machine_mode decl_chunk_mode;\n+/* Used in the same situation, to keep track of the byte offset\n+   into the initializer.  */\n+static unsigned HOST_WIDE_INT decl_offset;\n+/* The initializer part we are currently processing.  */\n+static HOST_WIDE_INT init_part;\n+/* The total size of the object.  */\n+static unsigned HOST_WIDE_INT object_size;\n+/* True if we found a skip extending to the end of the object.  Used to\n+   assert that no data follows.  */\n+static bool object_finished;\n+\n+/* Write the necessary separator string to begin a new initializer value.  */\n+\n+static void\n+begin_decl_field (void)\n+{\n+  /* We never see decl_offset at zero by the time we get here.  */\n+  if (decl_offset == decl_chunk_size)\n+    fprintf (asm_out_file, \" = { \");\n+  else\n+    fprintf (asm_out_file, \", \");\n+}\n+\n+/* Output the currently stored chunk as an initializer value.  */\n+\n+static void\n+output_decl_chunk (void)\n+{\n+  begin_decl_field ();\n+  output_address (gen_int_mode (init_part, decl_chunk_mode));\n+  init_part = 0;\n+}\n+\n+/* Add value VAL sized SIZE to the data we're emitting, and keep writing\n+   out chunks as they fill up.  */\n+\n+static void\n+nvptx_assemble_value (HOST_WIDE_INT val, unsigned int size)\n+{\n+  unsigned HOST_WIDE_INT chunk_offset = decl_offset % decl_chunk_size;\n+  gcc_assert (!object_finished);\n+  while (size > 0)\n+    {\n+      int this_part = size;\n+      if (chunk_offset + this_part > decl_chunk_size)\n+\tthis_part = decl_chunk_size - chunk_offset;\n+      HOST_WIDE_INT val_part;\n+      HOST_WIDE_INT mask = 2;\n+      mask <<= this_part * BITS_PER_UNIT - 1;\n+      val_part = val & (mask - 1);\n+      init_part |= val_part << (BITS_PER_UNIT * chunk_offset);\n+      val >>= BITS_PER_UNIT * this_part;\n+      size -= this_part;\n+      decl_offset += this_part;\n+      if (decl_offset % decl_chunk_size == 0)\n+\toutput_decl_chunk ();\n+\n+      chunk_offset = 0;\n+    }\n+}\n+\n+/* Target hook for assembling integer object X of size SIZE.  */\n+\n+static bool\n+nvptx_assemble_integer (rtx x, unsigned int size, int ARG_UNUSED (aligned_p))\n+{\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST)\n+    {\n+      gcc_assert (size = decl_chunk_size);\n+      if (decl_offset % decl_chunk_size != 0)\n+\tsorry (\"cannot emit unaligned pointers in ptx assembly\");\n+      decl_offset += size;\n+      begin_decl_field ();\n+\n+      HOST_WIDE_INT off = 0;\n+      if (GET_CODE (x) == CONST)\n+\tx = XEXP (x, 0);\n+      if (GET_CODE (x) == PLUS)\n+\t{\n+\t  off = INTVAL (XEXP (x, 1));\n+\t  x = XEXP (x, 0);\n+\t}\n+      if (GET_CODE (x) == SYMBOL_REF)\n+\t{\n+\t  nvptx_record_needed_fndecl (SYMBOL_REF_DECL (x));\n+\t  fprintf (asm_out_file, \"generic(\");\n+\t  output_address (x);\n+\t  fprintf (asm_out_file, \")\");\n+\t}\n+      if (off != 0)\n+\tfprintf (asm_out_file, \" + \" HOST_WIDE_INT_PRINT_DEC, off);\n+      return true;\n+    }\n+\n+  HOST_WIDE_INT val;\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+      val = INTVAL (x);\n+      break;\n+    case CONST_DOUBLE:\n+      gcc_unreachable ();\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  nvptx_assemble_value (val, size);\n+  return true;\n+}\n+\n+/* Output SIZE zero bytes.  We ignore the FILE argument since the\n+   functions we're calling to perform the output just use\n+   asm_out_file.  */\n+\n+void\n+nvptx_output_skip (FILE *, unsigned HOST_WIDE_INT size)\n+{\n+  if (decl_offset + size >= object_size)\n+    {\n+      if (decl_offset % decl_chunk_size != 0)\n+\tnvptx_assemble_value (0, decl_chunk_size);\n+      object_finished = true;\n+      return;\n+    }\n+\n+  while (size > decl_chunk_size)\n+    {\n+      nvptx_assemble_value (0, decl_chunk_size);\n+      size -= decl_chunk_size;\n+    }\n+  while (size-- > 0)\n+    nvptx_assemble_value (0, 1);\n+}\n+\n+/* Output a string STR with length SIZE.  As in nvptx_output_skip we\n+   ignore the FILE arg.  */\n+\n+void\n+nvptx_output_ascii (FILE *, const char *str, unsigned HOST_WIDE_INT size)\n+{\n+  for (unsigned HOST_WIDE_INT i = 0; i < size; i++)\n+    nvptx_assemble_value (str[i], 1);\n+}\n+\n+/* Called when the initializer for a decl has been completely output through\n+   combinations of the three functions above.  */\n+\n+static void\n+nvptx_assemble_decl_end (void)\n+{\n+  if (decl_offset != 0)\n+    {\n+      if (!object_finished && decl_offset % decl_chunk_size != 0)\n+\tnvptx_assemble_value (0, decl_chunk_size);\n+\n+      fprintf (asm_out_file, \" }\");\n+    }\n+  fprintf (asm_out_file, \";\\n\");\n+}\n+\n+/* Start a declaration of a variable of TYPE with NAME to\n+   FILE.  IS_PUBLIC says whether this will be externally visible.\n+   Here we just write the linker hint and decide on the chunk size\n+   to use.  */\n+\n+static void\n+init_output_initializer (FILE *file, const char *name, const_tree type,\n+\t\t\t bool is_public)\n+{\n+  fprintf (file, \"// BEGIN%s VAR DEF: \", is_public ? \" GLOBAL\" : \"\");\n+  assemble_name_raw (file, name);\n+  fputc ('\\n', file);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+  int sz = int_size_in_bytes (type);\n+  if ((TREE_CODE (type) != INTEGER_TYPE\n+       && TREE_CODE (type) != ENUMERAL_TYPE\n+       && TREE_CODE (type) != REAL_TYPE)\n+      || sz < 0\n+      || sz > HOST_BITS_PER_WIDE_INT)\n+    type = ptr_type_node;\n+  decl_chunk_size = int_size_in_bytes (type);\n+  decl_chunk_mode = int_mode_for_mode (TYPE_MODE (type));\n+  decl_offset = 0;\n+  init_part = 0;\n+  object_finished = false;\n+}\n+\n+/* Implement TARGET_ASM_DECLARE_CONSTANT_NAME.  Begin the process of\n+   writing a constant variable EXP with NAME and SIZE and its\n+   initializer to FILE.  */\n+\n+static void\n+nvptx_asm_declare_constant_name (FILE *file, const char *name,\n+\t\t\t\t const_tree exp, HOST_WIDE_INT size)\n+{\n+  tree type = TREE_TYPE (exp);\n+  init_output_initializer (file, name, type, false);\n+  fprintf (file, \"\\t.const .align %d .u%d \",\n+\t   TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT,\n+\t   decl_chunk_size * BITS_PER_UNIT);\n+  assemble_name (file, name);\n+  fprintf (file, \"[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n+\t   (size + decl_chunk_size - 1) / decl_chunk_size);\n+  object_size = size;\n+}\n+\n+/* Implement the ASM_DECLARE_OBJECT_NAME macro.  Used to start writing\n+   a variable DECL with NAME to FILE.  */\n+\n+void\n+nvptx_declare_object_name (FILE *file, const char *name, const_tree decl)\n+{\n+  if (decl && DECL_SIZE (decl))\n+    {\n+      tree type = TREE_TYPE (decl);\n+      unsigned HOST_WIDE_INT size;\n+\n+      init_output_initializer (file, name, type, TREE_PUBLIC (decl));\n+      size = tree_to_uhwi (DECL_SIZE_UNIT (decl));\n+      const char *section = nvptx_section_for_decl (decl);\n+      fprintf (file, \"\\t%s%s .align %d .u%d \",\n+\t       TREE_PUBLIC (decl) ? \" .visible\" : \"\", section,\n+\t       DECL_ALIGN (decl) / BITS_PER_UNIT,\n+\t       decl_chunk_size * BITS_PER_UNIT);\n+      assemble_name (file, name);\n+      if (size > 0)\n+\tfprintf (file, \"[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n+\t\t (size + decl_chunk_size - 1) / decl_chunk_size);\n+      else\n+\tobject_finished = true;\n+      object_size = size;\n+    }\n+}\n+\n+/* Implement TARGET_ASM_GLOBALIZE_LABEL by doing nothing.  */\n+\n+static void\n+nvptx_globalize_label (FILE *, const char *)\n+{\n+}\n+\n+/* Implement TARGET_ASM_ASSEMBLE_UNDEFINED_DECL.  Write an extern\n+   declaration only for variable DECL with NAME to FILE.  */\n+static void\n+nvptx_assemble_undefined_decl (FILE *file, const char *name, const_tree decl)\n+{\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return;\n+  const char *section = nvptx_section_for_decl (decl);\n+  fprintf (file, \"// BEGIN%s VAR DECL: \", TREE_PUBLIC (decl) ? \" GLOBAL\" : \"\");\n+  assemble_name_raw (file, name);\n+  fputs (\"\\n\", file);\n+  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));\n+  fprintf (file, \".extern %s .b8 \", section);\n+  assemble_name_raw (file, name);\n+  if (size > 0)\n+    fprintf (file, \"[\"HOST_WIDE_INT_PRINT_DEC\"]\", size);\n+  fprintf (file, \";\\n\\n\");\n+}\n+\n+/* Output INSN, which is a call to CALLEE with result RESULT.  For ptx, this\n+   involves writing .param declarations and in/out copies into them.  */\n+\n+const char *\n+nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n+{\n+  char buf[256];\n+  static int labelno;\n+  bool needs_tgt = register_operand (callee, Pmode);\n+  rtx pat = PATTERN (insn);\n+  int nargs = XVECLEN (pat, 0) - 1;\n+  tree decl = NULL_TREE;\n+\n+  fprintf (asm_out_file, \"\\t{\\n\");\n+  if (result != NULL)\n+    {\n+      fprintf (asm_out_file, \"\\t\\t.param%s %%retval_in;\\n\",\n+\t       nvptx_ptx_type_from_mode (arg_promotion (GET_MODE (result)),\n+\t\t\t\t\t false));\n+    }\n+\n+  if (GET_CODE (callee) == SYMBOL_REF)\n+    {\n+      decl = SYMBOL_REF_DECL (callee);\n+      if (decl && DECL_EXTERNAL (decl))\n+\tnvptx_record_fndecl (decl);\n+    }\n+\n+  if (needs_tgt)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCT\", labelno);\n+      labelno++;\n+      ASM_OUTPUT_LABEL (asm_out_file, buf);\n+      std::stringstream s;\n+      write_func_decl_from_insn (s, result, pat, callee);\n+      fputs (s.str().c_str(), asm_out_file);\n+    }\n+\n+  for (int i = 0, argno = 0; i < nargs; i++)\n+    {\n+      rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+      machine_mode mode = GET_MODE (t);\n+      int count = maybe_split_mode (&mode);\n+\n+      while (count-- > 0)\n+\tfprintf (asm_out_file, \"\\t\\t.param%s %%out_arg%d%s;\\n\",\n+\t\t nvptx_ptx_type_from_mode (mode, false), argno++,\n+\t\t mode == QImode || mode == HImode ? \"[1]\" : \"\");\n+    }\n+  for (int i = 0, argno = 0; i < nargs; i++)\n+    {\n+      rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+      gcc_assert (REG_P (t));\n+      machine_mode mode = GET_MODE (t);\n+      int count = maybe_split_mode (&mode);\n+\n+      if (count == 1)\n+\tfprintf (asm_out_file, \"\\t\\tst.param%s [%%out_arg%d], %%r%d;\\n\",\n+\t\t nvptx_ptx_type_from_mode (mode, false), argno++,\n+\t\t REGNO (t));\n+      else\n+\t{\n+\t  int n = 0;\n+\t  while (count-- > 0)\n+\t    fprintf (asm_out_file, \"\\t\\tst.param%s [%%out_arg%d], %%r%d$%d;\\n\",\n+\t\t     nvptx_ptx_type_from_mode (mode, false), argno++,\n+\t\t     REGNO (t), n++);\n+\t}\n+    }\n+\n+  fprintf (asm_out_file, \"\\t\\tcall \");\n+  if (result != NULL_RTX)\n+    fprintf (asm_out_file, \"(%%retval_in), \");\n+\n+  if (decl)\n+    {\n+      const char *name = get_fnname_from_decl (decl);\n+      name = nvptx_name_replacement (name);\n+      assemble_name (asm_out_file, name);\n+    }\n+  else\n+    output_address (callee);\n+\n+  if (nargs > 0 || (decl && DECL_STATIC_CHAIN (decl)))\n+    {\n+      fprintf (asm_out_file, \", (\");\n+      int i, argno;\n+      for (i = 0, argno = 0; i < nargs; i++)\n+\t{\n+\t  rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+\t  machine_mode mode = GET_MODE (t);\n+\t  int count = maybe_split_mode (&mode);\n+\n+\t  while (count-- > 0)\n+\t    {\n+\t      fprintf (asm_out_file, \"%%out_arg%d\", argno++);\n+\t      if (i + 1 < nargs || count > 0)\n+\t\tfprintf (asm_out_file, \", \");\n+\t    }\n+\t}\n+      if (decl && DECL_STATIC_CHAIN (decl))\n+\t{\n+\t  if (i > 0)\n+\t    fprintf (asm_out_file, \", \");\n+\t  fprintf (asm_out_file, \"%s\",\n+\t\t   reg_names [OUTGOING_STATIC_CHAIN_REGNUM]);\n+\t}\n+\n+      fprintf (asm_out_file, \")\");\n+    }\n+  if (needs_tgt)\n+    {\n+      fprintf (asm_out_file, \", \");\n+      assemble_name (asm_out_file, buf);\n+    }\n+  fprintf (asm_out_file, \";\\n\");\n+  if (result != NULL_RTX)\n+    return \"ld.param%t0\\t%0, [%%retval_in];\\n\\t}\";\n+\n+  return \"}\";\n+}\n+\n+/* Implement TARGET_PRINT_OPERAND_PUNCT_VALID_P.  */\n+\n+static bool\n+nvptx_print_operand_punct_valid_p (unsigned char c)\n+{\n+  return c == '.' || c== '#';\n+}\n+\n+static void nvptx_print_operand (FILE *, rtx, int);\n+\n+/* Subroutine of nvptx_print_operand; used to print a memory reference X to FILE.  */\n+\n+static void\n+nvptx_print_address_operand (FILE *file, rtx x, machine_mode)\n+{\n+  rtx off;\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+  switch (GET_CODE (x))\n+    {\n+    case PLUS:\n+      off = XEXP (x, 1);\n+      output_address (XEXP (x, 0));\n+      fprintf (file, \"+\");\n+      output_address (off);\n+      break;\n+\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      output_addr_const (file, x);\n+      break;\n+\n+    default:\n+      gcc_assert (GET_CODE (x) != MEM);\n+      nvptx_print_operand (file, x, 0);\n+      break;\n+    }\n+}\n+\n+/* Write assembly language output for the address ADDR to FILE.  */\n+\n+static void\n+nvptx_print_operand_address (FILE *file, rtx addr)\n+{\n+  nvptx_print_address_operand (file, addr, VOIDmode);\n+}\n+\n+/* Print an operand, X, to FILE, with an optional modifier in CODE.\n+\n+   Meaning of CODE:\n+   . -- print the predicate for the instruction or an emptry string for an\n+        unconditional one.\n+   # -- print a rounding mode for the instruction\n+\n+   A -- print an address space identifier for a MEM\n+   c -- print an opcode suffix for a comparison operator, including a type code\n+   d -- print a CONST_INT as a vector dimension (x, y, or z)\n+   f -- print a full reg even for something that must always be split\n+   t -- print a type opcode suffix, promoting QImode to 32 bits\n+   T -- print a type size in bits\n+   u -- print a type opcode suffix without promotions.  */\n+\n+static void\n+nvptx_print_operand (FILE *file, rtx x, int code)\n+{\n+  rtx orig_x = x;\n+  machine_mode op_mode;\n+\n+  if (code == '.')\n+    {\n+      x = current_insn_predicate;\n+      if (x)\n+\t{\n+\t  unsigned int regno = REGNO (XEXP (x, 0));\n+\t  fputs (\"[\", file);\n+\t  if (GET_CODE (x) == EQ)\n+\t    fputs (\"!\", file);\n+\t  fputs (reg_names [regno], file);\n+\t  fputs (\"]\", file);\n+\t}\n+      return;\n+    }\n+  else if (code == '#')\n+    {\n+      fputs (\".rn\", file);\n+      return;\n+    }\n+\n+  enum rtx_code x_code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case 'A':\n+      {\n+\taddr_space_t as = nvptx_addr_space_from_address (XEXP (x, 0));\n+\tfputs (nvptx_section_from_addr_space (as), file);\n+      }\n+      break;\n+\n+    case 'd':\n+      gcc_assert (x_code == CONST_INT);\n+      if (INTVAL (x) == 0)\n+\tfputs (\".x\", file);\n+      else if (INTVAL (x) == 1)\n+\tfputs (\".y\", file);\n+      else if (INTVAL (x) == 2)\n+\tfputs (\".z\", file);\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case 't':\n+      op_mode = nvptx_underlying_object_mode (x);\n+      fprintf (file, \"%s\", nvptx_ptx_type_from_mode (op_mode, true));\n+      break;\n+\n+    case 'u':\n+      op_mode = nvptx_underlying_object_mode (x);\n+      fprintf (file, \"%s\", nvptx_ptx_type_from_mode (op_mode, false));\n+      break;\n+\n+    case 'T':\n+      fprintf (file, \"%d\", GET_MODE_BITSIZE (GET_MODE (x)));\n+      break;\n+\n+    case 'j':\n+      fprintf (file, \"@\");\n+      goto common;\n+\n+    case 'J':\n+      fprintf (file, \"@!\");\n+      goto common;\n+\n+    case 'c':\n+      op_mode = GET_MODE (XEXP (x, 0));\n+      switch (x_code)\n+\t{\n+\tcase EQ:\n+\t  fputs (\".eq\", file);\n+\t  break;\n+\tcase NE:\n+\t  if (FLOAT_MODE_P (op_mode))\n+\t    fputs (\".neu\", file);\n+\t  else\n+\t    fputs (\".ne\", file);\n+\t  break;\n+\tcase LE:\n+\t  fputs (\".le\", file);\n+\t  break;\n+\tcase GE:\n+\t  fputs (\".ge\", file);\n+\t  break;\n+\tcase LT:\n+\t  fputs (\".lt\", file);\n+\t  break;\n+\tcase GT:\n+\t  fputs (\".gt\", file);\n+\t  break;\n+\tcase LEU:\n+\t  fputs (\".ls\", file);\n+\t  break;\n+\tcase GEU:\n+\t  fputs (\".hs\", file);\n+\t  break;\n+\tcase LTU:\n+\t  fputs (\".lo\", file);\n+\t  break;\n+\tcase GTU:\n+\t  fputs (\".hi\", file);\n+\t  break;\n+\tcase LTGT:\n+\t  fputs (\".ne\", file);\n+\t  break;\n+\tcase UNEQ:\n+\t  fputs (\".equ\", file);\n+\t  break;\n+\tcase UNLE:\n+\t  fputs (\".leu\", file);\n+\t  break;\n+\tcase UNGE:\n+\t  fputs (\".geu\", file);\n+\t  break;\n+\tcase UNLT:\n+\t  fputs (\".ltu\", file);\n+\t  break;\n+\tcase UNGT:\n+\t  fputs (\".gtu\", file);\n+\t  break;\n+\tcase UNORDERED:\n+\t  fputs (\".nan\", file);\n+\t  break;\n+\tcase ORDERED:\n+\t  fputs (\".num\", file);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      if (FLOAT_MODE_P (op_mode)\n+\t  || x_code == EQ || x_code == NE\n+\t  || x_code == GEU || x_code == GTU\n+\t  || x_code == LEU || x_code == LTU)\n+\tfputs (nvptx_ptx_type_from_mode (op_mode, true), file);\n+      else\n+\tfprintf (file, \".s%d\", GET_MODE_BITSIZE (op_mode));\n+      break;\n+    default:\n+    common:\n+      switch (x_code)\n+\t{\n+\tcase SUBREG:\n+\t  x = SUBREG_REG (x);\n+\t  /* fall through */\n+\n+\tcase REG:\n+\t  if (HARD_REGISTER_P (x))\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  else\n+\t    fprintf (file, \"%%r%d\", REGNO (x));\n+\t  if (code != 'f' && nvptx_split_reg_p (GET_MODE (x)))\n+\t    {\n+\t      gcc_assert (GET_CODE (orig_x) == SUBREG\n+\t\t\t  && !nvptx_split_reg_p (GET_MODE (orig_x)));\n+\t      fprintf (file, \"$%d\", SUBREG_BYTE (orig_x) / UNITS_PER_WORD);\n+\t    }\n+\t  break;\n+\n+\tcase MEM:\n+\t  fputc ('[', file);\n+\t  nvptx_print_address_operand (file, XEXP (x, 0), GET_MODE (x));\n+\t  fputc (']', file);\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  output_addr_const (file, x);\n+\t  break;\n+\n+\tcase CONST:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  /* We could use output_addr_const, but that can print things like\n+\t     \"x-8\", which breaks ptxas.  Need to ensure it is output as\n+\t     \"x+-8\".  */\n+\t  nvptx_print_address_operand (file, x, VOIDmode);\n+\t  break;\n+\n+\tcase CONST_DOUBLE:\n+\t  long vals[2];\n+\t  REAL_VALUE_TYPE real;\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (real, x);\n+\t  real_to_target (vals, &real, GET_MODE (x));\n+\t  vals[0] &= 0xffffffff;\n+\t  vals[1] &= 0xffffffff;\n+\t  if (GET_MODE (x) == SFmode)\n+\t    fprintf (file, \"0f%08lx\", vals[0]);\n+\t  else\n+\t    fprintf (file, \"0d%08lx%08lx\", vals[1], vals[0]);\n+\t  break;\n+\n+\tdefault:\n+\t  output_addr_const (file, x);\n+\t}\n+    }\n+}\n+\f\n+/* Record replacement regs used to deal with subreg operands.  */\n+struct reg_replace\n+{\n+  rtx replacement[MAX_RECOG_OPERANDS];\n+  machine_mode mode;\n+  int n_allocated;\n+  int n_in_use;\n+};\n+\n+/* Allocate or reuse a replacement in R and return the rtx.  */\n+\n+static rtx\n+get_replacement (struct reg_replace *r)\n+{\n+  if (r->n_allocated == r->n_in_use)\n+    r->replacement[r->n_allocated++] = gen_reg_rtx (r->mode);\n+  return r->replacement[r->n_in_use++];\n+}\n+\n+/* Clean up subreg operands.  In ptx assembly, everything is typed, and\n+   the presence of subregs would break the rules for most instructions.\n+   Replace them with a suitable new register of the right size, plus\n+   conversion copyin/copyout instructions.  */\n+\n+static void\n+nvptx_reorg (void)\n+{\n+  struct reg_replace qiregs, hiregs, siregs, diregs;\n+  rtx_insn *insn, *next;\n+\n+  /* We are freeing block_for_insn in the toplev to keep compatibility\n+     with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n+  compute_bb_for_insn ();\n+\n+  df_clear_flags (DF_LR_RUN_DCE);\n+  df_analyze ();\n+\n+  thread_prologue_and_epilogue_insns ();\n+\n+  qiregs.n_allocated = 0;\n+  hiregs.n_allocated = 0;\n+  siregs.n_allocated = 0;\n+  diregs.n_allocated = 0;\n+  qiregs.mode = QImode;\n+  hiregs.mode = HImode;\n+  siregs.mode = SImode;\n+  diregs.mode = DImode;\n+\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (!NONDEBUG_INSN_P (insn)\n+\t  || asm_noperands (insn) >= 0\n+\t  || GET_CODE (PATTERN (insn)) == USE\n+\t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n+\tcontinue;\n+      qiregs.n_in_use = 0;\n+      hiregs.n_in_use = 0;\n+      siregs.n_in_use = 0;\n+      diregs.n_in_use = 0;\n+      extract_insn (insn);\n+      enum attr_subregs_ok s_ok = get_attr_subregs_ok (insn);\n+      for (int i = 0; i < recog_data.n_operands; i++)\n+\t{\n+\t  rtx op = recog_data.operand[i];\n+\t  if (GET_CODE (op) != SUBREG)\n+\t    continue;\n+\n+\t  rtx inner = SUBREG_REG (op);\n+\n+\t  machine_mode outer_mode = GET_MODE (op);\n+\t  machine_mode inner_mode = GET_MODE (inner);\n+\t  gcc_assert (s_ok);\n+\t  if (s_ok\n+\t      && (GET_MODE_PRECISION (inner_mode)\n+\t\t  >= GET_MODE_PRECISION (outer_mode)))\n+\t    continue;\n+\t  gcc_assert (SCALAR_INT_MODE_P (outer_mode));\n+\t  struct reg_replace *r = (outer_mode == QImode ? &qiregs\n+\t\t\t\t   : outer_mode == HImode ? &hiregs\n+\t\t\t\t   : outer_mode == SImode ? &siregs\n+\t\t\t\t   : &diregs);\n+\t  rtx new_reg = get_replacement (r);\n+\n+\t  if (recog_data.operand_type[i] != OP_OUT)\n+\t    {\n+\t      enum rtx_code code;\n+\t      if (GET_MODE_PRECISION (inner_mode)\n+\t\t  < GET_MODE_PRECISION (outer_mode))\n+\t\tcode = ZERO_EXTEND;\n+\t      else\n+\t\tcode = TRUNCATE;\n+\n+\t      rtx pat = gen_rtx_SET (VOIDmode, new_reg,\n+\t\t\t\t     gen_rtx_fmt_e (code, outer_mode, inner));\n+\t      emit_insn_before (pat, insn);\n+\t    }\n+\n+\t  if (recog_data.operand_type[i] != OP_IN)\n+\t    {\n+\t      enum rtx_code code;\n+\t      if (GET_MODE_PRECISION (inner_mode)\n+\t\t  < GET_MODE_PRECISION (outer_mode))\n+\t\tcode = TRUNCATE;\n+\t      else\n+\t\tcode = ZERO_EXTEND;\n+\n+\t      rtx pat = gen_rtx_SET (VOIDmode, inner,\n+\t\t\t\t     gen_rtx_fmt_e (code, inner_mode, new_reg));\n+\t      emit_insn_after (pat, insn);\n+\t    }\n+\t  validate_change (insn, recog_data.operand_loc[i], new_reg, false);\n+\t}\n+    }\n+\n+  int maxregs = max_reg_num ();\n+  regstat_init_n_sets_and_refs ();\n+\n+  for (int i = LAST_VIRTUAL_REGISTER + 1; i < maxregs; i++)\n+    if (REG_N_SETS (i) == 0 && REG_N_REFS (i) == 0)\n+      regno_reg_rtx[i] = const0_rtx;\n+  regstat_free_n_sets_and_refs ();\n+}\n+\f\n+/* Handle a \"kernel\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+nvptx_handle_kernel_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error (\"%qE attribute only applies to functions\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  else if (TREE_TYPE (TREE_TYPE (decl)) != void_type_node)\n+    {\n+      error (\"%qE attribute requires a void return type\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Table of valid machine attributes.  */\n+static const struct attribute_spec nvptx_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+       affects_type_identity } */\n+  { \"kernel\", 0, 0, true, false,  false, nvptx_handle_kernel_attribute, false },\n+  { NULL, 0, 0, false, false, false, NULL, false }\n+};\n+\f\n+/* Limit vector alignments to BIGGEST_ALIGNMENT.  */\n+\n+static HOST_WIDE_INT\n+nvptx_vector_alignment (const_tree type)\n+{\n+  HOST_WIDE_INT align = tree_to_shwi (TYPE_SIZE (type));\n+\n+  return MIN (align, BIGGEST_ALIGNMENT);\n+}\n+\f\n+/* Implement TARGET_ASM_FILE_START.  Write the kinds of things ptxas expects\n+   at the start of a file.  */\n+\n+static void\n+nvptx_file_start (void)\n+{\n+  fputs (\"// BEGIN PREAMBLE\\n\", asm_out_file);\n+  fputs (\"\\t.version\\t3.1\\n\", asm_out_file);\n+  fputs (\"\\t.target\\tsm_30\\n\", asm_out_file);\n+  fprintf (asm_out_file, \"\\t.address_size %d\\n\", GET_MODE_BITSIZE (Pmode));\n+  fputs (\"// END PREAMBLE\\n\", asm_out_file);\n+}\n+\n+/* Called through htab_traverse; call nvptx_record_fndecl for every\n+   SLOT.  */\n+\n+static int\n+write_one_fndecl (void **slot, void *)\n+{\n+  tree decl = (tree)*slot;\n+  nvptx_record_fndecl (decl, true);\n+  return 1;\n+}\n+\n+/* Write out the function declarations we've collected.  */\n+\n+static void\n+nvptx_file_end (void)\n+{\n+  htab_traverse (needed_fndecls_htab,\n+\t\t write_one_fndecl,\n+\t\t NULL);\n+  fputs (func_decls.str().c_str(), asm_out_file);\n+}\n+\f\n+#undef TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE nvptx_option_override\n+\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE nvptx_attribute_table\n+\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P nvptx_legitimate_address_p\n+\n+#undef  TARGET_PROMOTE_FUNCTION_MODE\n+#define TARGET_PROMOTE_FUNCTION_MODE nvptx_promote_function_mode\n+\n+#undef TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG nvptx_function_arg\n+#undef TARGET_FUNCTION_INCOMING_ARG\n+#define TARGET_FUNCTION_INCOMING_ARG nvptx_function_incoming_arg\n+#undef TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE nvptx_function_arg_advance\n+#undef TARGET_FUNCTION_ARG_BOUNDARY\n+#define TARGET_FUNCTION_ARG_BOUNDARY nvptx_function_arg_boundary\n+#undef TARGET_FUNCTION_ARG_ROUND_BOUNDARY\n+#define TARGET_FUNCTION_ARG_ROUND_BOUNDARY nvptx_function_arg_boundary\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE nvptx_pass_by_reference\n+#undef TARGET_FUNCTION_VALUE_REGNO_P\n+#define TARGET_FUNCTION_VALUE_REGNO_P nvptx_function_value_regno_p\n+#undef TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE nvptx_function_value\n+#undef TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE nvptx_libcall_value\n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL nvptx_function_ok_for_sibcall\n+#undef TARGET_SPLIT_COMPLEX_ARG\n+#define TARGET_SPLIT_COMPLEX_ARG hook_bool_const_tree_true\n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY nvptx_return_in_memory\n+#undef TARGET_OMIT_STRUCT_RETURN_REG\n+#define TARGET_OMIT_STRUCT_RETURN_REG true\n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING nvptx_strict_argument_naming\n+#undef TARGET_STATIC_CHAIN\n+#define TARGET_STATIC_CHAIN nvptx_static_chain\n+\n+#undef TARGET_CALL_ARGS\n+#define TARGET_CALL_ARGS nvptx_call_args\n+#undef TARGET_END_CALL_ARGS\n+#define TARGET_END_CALL_ARGS nvptx_end_call_args\n+\n+#undef TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START nvptx_file_start\n+#undef TARGET_ASM_FILE_END\n+#define TARGET_ASM_FILE_END nvptx_file_end\n+#undef TARGET_ASM_GLOBALIZE_LABEL\n+#define TARGET_ASM_GLOBALIZE_LABEL nvptx_globalize_label\n+#undef TARGET_ASM_ASSEMBLE_UNDEFINED_DECL\n+#define TARGET_ASM_ASSEMBLE_UNDEFINED_DECL nvptx_assemble_undefined_decl\n+#undef  TARGET_PRINT_OPERAND\n+#define TARGET_PRINT_OPERAND nvptx_print_operand\n+#undef  TARGET_PRINT_OPERAND_ADDRESS\n+#define TARGET_PRINT_OPERAND_ADDRESS nvptx_print_operand_address\n+#undef  TARGET_PRINT_OPERAND_PUNCT_VALID_P\n+#define TARGET_PRINT_OPERAND_PUNCT_VALID_P nvptx_print_operand_punct_valid_p\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER nvptx_assemble_integer\n+#undef TARGET_ASM_DECL_END\n+#define TARGET_ASM_DECL_END nvptx_assemble_decl_end\n+#undef TARGET_ASM_DECLARE_CONSTANT_NAME\n+#define TARGET_ASM_DECLARE_CONSTANT_NAME nvptx_asm_declare_constant_name\n+#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_const_rtx_true\n+#undef TARGET_ASM_NEED_VAR_DECL_BEFORE_USE\n+#define TARGET_ASM_NEED_VAR_DECL_BEFORE_USE true\n+\n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG nvptx_reorg\n+#undef TARGET_NO_REGISTER_ALLOCATION\n+#define TARGET_NO_REGISTER_ALLOCATION true\n+\n+#undef TARGET_VECTOR_ALIGNMENT\n+#define TARGET_VECTOR_ALIGNMENT nvptx_vector_alignment\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+#include \"gt-nvptx.h\""}, {"sha": "c222375acb3b9e11d37d26769b5135f8880a074d", "filename": "gcc/config/nvptx/nvptx.h", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,356 @@\n+/* Target Definitions for NVPTX.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Bernd Schmidt <bernds@codesourcery.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_NVPTX_H\n+#define GCC_NVPTX_H\n+\n+/* Run-time Target.  */\n+\n+#define STARTFILE_SPEC \"%{mmainkernel:crt0.o}\"\n+\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      builtin_assert (\"machine=nvptx\");\t\t\\\n+      builtin_assert (\"cpu=nvptx\");\t\t\\\n+      builtin_define (\"__nvptx__\");\t\t\\\n+    } while (0)\n+\n+/* Storage Layout.  */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Chosen such that we won't have to deal with multi-word subregs.  */\n+#define UNITS_PER_WORD 8\n+\n+#define PARM_BOUNDARY 8\n+#define STACK_BOUNDARY 64\n+#define FUNCTION_BOUNDARY 32\n+#define BIGGEST_ALIGNMENT 64\n+#define STRICT_ALIGNMENT 1\n+\n+/* Copied from elf.h and other places.  We'd otherwise use\n+   BIGGEST_ALIGNMENT and fail a number of testcases.  */\n+#define MAX_OFILE_ALIGNMENT (32768 * 8)\n+\n+/* Type Layout.  */\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE 32\n+#define LONG_TYPE_SIZE (TARGET_ABI64 ? 64 : 32)\n+#define LONG_LONG_TYPE_SIZE 64\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE (TARGET_ABI64 ? \"long unsigned int\" : \"unsigned int\")\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_ABI64 ? \"long int\" : \"int\")\n+\n+#define POINTER_SIZE (TARGET_ABI64 ? 64 : 32)\n+\n+#define Pmode (TARGET_ABI64 ? DImode : SImode)\n+\n+/* Registers.  Since ptx is a virtual target, we just define a few\n+   hard registers for special purposes and leave pseudos unallocated.  */\n+\n+#define FIRST_PSEUDO_REGISTER 16\n+#define FIXED_REGISTERS\t\t\t\t\t\\\n+  { 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }\n+#define CALL_USED_REGISTERS\t\t\t\t\\\n+  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n+\n+#define HARD_REGNO_NREGS(regno, mode)\t1\n+#define CANNOT_CHANGE_MODE_CLASS(M1, M2, CLS) ((CLS) == RETURN_REG)\n+#define HARD_REGNO_MODE_OK(REG, MODE) nvptx_hard_regno_mode_ok (REG, MODE)\n+\n+/* Register Classes.  */\n+\n+enum reg_class\n+  {\n+    NO_REGS,\n+    RETURN_REG,\n+    ALL_REGS,\n+    LIM_REG_CLASSES\n+  };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES {\t  \\\n+    \"RETURN_REG\",\t\t  \\\n+    \"NO_REGS\",\t\t\t  \\\n+    \"ALL_REGS\" }\n+\n+#define REG_CLASS_CONTENTS\t\\\n+{\t\t\t\t\\\n+  /* NO_REGS.  */\t\t\\\n+  { 0x0000 },\t\t\t\\\n+  /* RETURN_REG.  */\t\t\\\n+  { 0x0008 },\t\t\t\\\n+  /* ALL_REGS.  */\t\t\\\n+  { 0xFFFF },\t\t\t\\\n+}\n+\n+#define GENERAL_REGS ALL_REGS\n+\n+#define REGNO_REG_CLASS(R) ((R) == 4 ? RETURN_REG : ALL_REGS)\n+\n+#define BASE_REG_CLASS ALL_REGS\n+#define INDEX_REG_CLASS NO_REGS\n+\n+#define REGNO_OK_FOR_BASE_P(X) true\n+#define REGNO_OK_FOR_INDEX_P(X) false\n+\n+#define CLASS_MAX_NREGS(class, mode) \\\n+  ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define MODES_TIEABLE_P(M1, M2) false\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n+      && GET_MODE_SIZE (MODE) < GET_MODE_SIZE (SImode))\t\\\n+    {\t\t\t\t\t\t\t\\\n+      (MODE) = SImode;\t\t\t\t\t\\\n+    }\n+\n+/* Address spaces.  */\n+#define ADDR_SPACE_GLOBAL 1\n+#define ADDR_SPACE_SHARED 3\n+#define ADDR_SPACE_CONST 4\n+#define ADDR_SPACE_LOCAL 5\n+#define ADDR_SPACE_PARAM 101\n+\n+/* Stack and Calling.  */\n+\n+#define STARTING_FRAME_OFFSET 0\n+#define FRAME_GROWS_DOWNWARD 0\n+#define STACK_GROWS_DOWNWARD\n+\n+#define STACK_POINTER_REGNUM 1\n+#define HARD_FRAME_POINTER_REGNUM 2\n+#define NVPTX_PUNNING_BUFFER_REGNUM 3\n+#define NVPTX_RETURN_REGNUM 4\n+#define FRAME_POINTER_REGNUM 15\n+#define ARG_POINTER_REGNUM 14\n+#define RETURN_ADDR_REGNO 13\n+\n+#define STATIC_CHAIN_REGNUM 12\n+#define OUTGOING_ARG_POINTER_REGNUM 11\n+#define OUTGOING_STATIC_CHAIN_REGNUM 10\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+#define PUSH_ARGS_REVERSED 1\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#ifdef HOST_WIDE_INT\n+struct nvptx_args {\n+  union tree_node *fntype;\n+  /* Number of arguments passed in registers so far.  */\n+  int count;\n+  /* Offset into the stdarg area so far.  */\n+  HOST_WIDE_INT off;\n+};\n+#endif\n+\n+#define CUMULATIVE_ARGS struct nvptx_args\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n+  do { (CUM).fntype = (FNTYPE); (CUM).count = 0; (CUM).off = 0; } while (0)\n+\n+#define FUNCTION_ARG_REGNO_P(r) 0\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+#define FUNCTION_PROFILER(file, labelno) \\\n+  fatal_error (\"profiling is not yet implemented for this architecture\")\n+\n+#define TRAMPOLINE_SIZE 32\n+#define TRAMPOLINE_ALIGNMENT 256\n+\f\n+/* We don't run reload, so this isn't actually used, but it still needs to be\n+   defined.  Showing an argp->fp elimination also stops\n+   expand_builtin_setjmp_receiver from generating invalid insns.  */\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n+    { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}\t\\\n+  }\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = 0)\n+\f\n+/* Addressing Modes.  */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) 1\n+\f\n+\n+struct nvptx_pseudo_info\n+{\n+  int true_size;\n+  int renumber;\n+};\n+\n+#if defined HOST_WIDE_INT\n+struct GTY(()) machine_function\n+{\n+  rtx_expr_list *call_args;\n+  rtx start_call;\n+  tree funtype;\n+  bool has_call_with_varargs;\n+  bool has_call_with_sc;\n+  struct GTY((skip)) nvptx_pseudo_info *pseudos;\n+  HOST_WIDE_INT outgoing_stdarg_size;\n+  int ret_reg_mode;\n+  int punning_buffer_size;\n+};\n+#endif\n+\f\n+/* Costs.  */\n+\n+#define NO_FUNCTION_CSE 1\n+#define SLOW_BYTE_ACCESS 0\n+#define BRANCH_COST(speed_p, predictable_p) 6\n+\f\n+/* Assembler Format.  */\n+\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\\\n+  nvptx_declare_function_name (FILE, NAME, DECL)\n+\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(STREAM, NAME, DECL) \\\n+  nvptx_function_end (STREAM)\n+\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \"\\t// #APP \\n\"\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF \"\\t// #NO_APP \\n\"\n+\n+#define ASM_OUTPUT_COMMON(stream, name, size, rounded)\n+#define ASM_OUTPUT_LOCAL(stream, name, size, rounded)\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    \"%hr0\", \"%outargs\", \"%hfp\", \"%punbuffer\", \"%retval\", \"%retval_in\", \"%hr6\", \"%hr7\",\t\\\n+    \"%hr8\", \"%hr9\", \"%hr10\", \"%hr11\", \"%hr12\", \"%hr13\", \"%argp\", \"%frame\" \\\n+  }\n+\n+#define DBX_REGISTER_NUMBER(N) N\n+\n+#define TEXT_SECTION_ASM_OP \"\"\n+#define DATA_SECTION_ASM_OP \"\"\n+\n+#undef  ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char *__p;\t\t\t\t\t\t\\\n+      __p = stpcpy (&(LABEL)[1], PREFIX);\t\t\t\\\n+      (LABEL)[0] = '$';\t\t\t\t\t\t\\\n+      sprint_ul (__p, (unsigned long) (NUM));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ALIGN(FILE, POWER)\n+#define ASM_OUTPUT_SKIP(FILE, N)\t\t\\\n+  nvptx_output_skip (FILE, N)\n+#undef  ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\\\n+  nvptx_output_ascii (FILE, STR, LENGTH);\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\\\n+  nvptx_declare_object_name (FILE, NAME, DECL)\n+\n+#undef  ASM_OUTPUT_ALIGNED_DECL_COMMON\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"// BEGIN%s VAR DEF: \",\t\t\t\t\\\n+\t       TREE_PUBLIC (DECL) ? \" GLOBAL\" : \"\");\t\t\t\\\n+      assemble_name_raw (FILE, NAME);\t\t\t\t\t\\\n+      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      const char *sec = nvptx_section_for_decl (DECL);\t\t\t\\\n+      fprintf (FILE, \".visible%s.align %d .b8 \", sec,\t\t\t\\\n+\t       (ALIGN) / BITS_PER_UNIT);\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      if ((SIZE) > 0)\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"[\"HOST_WIDE_INT_PRINT_DEC\"]\", (SIZE));\t\t\\\n+      fprintf (FILE, \";\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  ASM_OUTPUT_ALIGNED_DECL_LOCAL\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"// BEGIN VAR DEF: \");\t\t\t\t\\\n+      assemble_name_raw (FILE, NAME);\t\t\t\t\t\\\n+      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      const char *sec = nvptx_section_for_decl (DECL);\t\t\t\\\n+      fprintf (FILE, \".visible%s.align %d .b8 \", sec,\t\t\t\\\n+\t       (ALIGN) / BITS_PER_UNIT);\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      if ((SIZE) > 0)\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"[\"HOST_WIDE_INT_PRINT_DEC\"]\", (SIZE));\t\t\\\n+      fprintf (FILE, \";\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define CASE_VECTOR_PC_RELATIVE flag_pic\n+#define JUMP_TABLES_IN_TEXT_SECTION flag_pic\n+\n+#define ADDR_VEC_ALIGN(VEC) (JUMP_TABLES_IN_TEXT_SECTION ? 5 : 2)\n+\n+/* Misc.  */\n+\n+#define DWARF2_DEBUGGING_INFO 1\n+\n+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n+  ((VALUE) = GET_MODE_BITSIZE ((MODE)), 2)\n+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n+  ((VALUE) = GET_MODE_BITSIZE ((MODE)), 2)\n+\n+#define NO_DOT_IN_LABEL\n+#define ASM_COMMENT_START \"//\"\n+\n+#define STORE_FLAG_VALUE -1\n+#define FLOAT_STORE_FLAG_VALUE(MODE) REAL_VALUE_ATOF(\"1.0\", (MODE))\n+\n+#define CASE_VECTOR_MODE SImode\n+#define MOVE_MAX 4\n+#define MOVE_RATIO(SPEED) 4\n+#define TRULY_NOOP_TRUNCATION(outprec, inprec) 1\n+#define FUNCTION_MODE QImode\n+#define HAS_INIT_SECTION 1\n+\n+#endif /* GCC_NVPTX_H */"}, {"sha": "966c28be11ef87de0af00e71cae39cce8e380711", "filename": "gcc/config/nvptx/nvptx.md", "status": "added", "additions": 1376, "deletions": 0, "changes": 1376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,1376 @@\n+;; Machine description for NVPTX.\n+;; Copyright (C) 2014 Free Software Foundation, Inc.\n+;; Contributed by Bernd Schmidt <bernds@codesourcery.com>\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_c_enum \"unspec\" [\n+   UNSPEC_ARG_REG\n+   UNSPEC_FROM_GLOBAL\n+   UNSPEC_FROM_LOCAL\n+   UNSPEC_FROM_PARAM\n+   UNSPEC_FROM_SHARED\n+   UNSPEC_FROM_CONST\n+   UNSPEC_TO_GLOBAL\n+   UNSPEC_TO_LOCAL\n+   UNSPEC_TO_PARAM\n+   UNSPEC_TO_SHARED\n+   UNSPEC_TO_CONST\n+\n+   UNSPEC_CPLX_LOWPART\n+   UNSPEC_CPLX_HIGHPART\n+\n+   UNSPEC_COPYSIGN\n+   UNSPEC_LOG2\n+   UNSPEC_EXP2\n+   UNSPEC_SIN\n+   UNSPEC_COS\n+\n+   UNSPEC_FPINT_FLOOR\n+   UNSPEC_FPINT_BTRUNC\n+   UNSPEC_FPINT_CEIL\n+   UNSPEC_FPINT_NEARBYINT\n+\n+   UNSPEC_BITREV\n+\n+   UNSPEC_ALLOCA\n+\n+   UNSPEC_NTID\n+   UNSPEC_TID\n+])\n+\n+(define_c_enum \"unspecv\" [\n+   UNSPECV_LOCK\n+   UNSPECV_CAS\n+   UNSPECV_XCHG\n+])\n+\n+(define_attr \"subregs_ok\" \"false,true\"\n+  (const_string \"false\"))\n+\n+(define_predicate \"nvptx_register_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (REG_P (op))\n+    return !HARD_REGISTER_P (op);\n+  if (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n+    return false;\n+  if (GET_CODE (op) == SUBREG)\n+    return false;\n+  return register_operand (op, mode);\n+})\n+\n+(define_predicate \"nvptx_reg_or_mem_operand\"\n+  (match_code \"mem,reg,subreg\")\n+{\n+  if (REG_P (op))\n+    return !HARD_REGISTER_P (op);\n+  if (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n+    return false;\n+  if (GET_CODE (op) == SUBREG)\n+    return false;\n+  return memory_operand (op, mode) || register_operand (op, mode);\n+})\n+\n+;; Allow symbolic constants.\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,const\"))\n+\n+;; Allow registers or symbolic constants.  We can allow frame, arg or stack\n+;; pointers here since they are actually symbolic constants.\n+(define_predicate \"nvptx_register_or_symbolic_operand\"\n+  (match_code \"reg,subreg,symbol_ref,const\")\n+{\n+  if (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n+    return false;\n+  if (GET_CODE (op) == SUBREG)\n+    return false;\n+  if (CONSTANT_P (op))\n+    return true;\n+  return register_operand (op, mode);\n+})\n+\n+;; Registers or constants for normal instructions.  Does not allow symbolic\n+;; constants.\n+(define_predicate \"nvptx_nonmemory_operand\"\n+  (match_code \"reg,subreg,const_int,const_double\")\n+{\n+  if (REG_P (op))\n+    return !HARD_REGISTER_P (op);\n+  if (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n+    return false;\n+  if (GET_CODE (op) == SUBREG)\n+    return false;\n+  return nonmemory_operand (op, mode);\n+})\n+\n+;; A source operand for a move instruction.  This is the only predicate we use\n+;; that accepts symbolic constants.\n+(define_predicate \"nvptx_general_operand\"\n+  (match_code \"reg,subreg,mem,const,symbol_ref,label_ref,const_int,const_double\")\n+{\n+  if (REG_P (op))\n+    return !HARD_REGISTER_P (op);\n+  return general_operand (op, mode);\n+})\n+\n+;; A destination operand for a move instruction.  This is the only destination\n+;; predicate that accepts the return register since it requires special handling.\n+(define_predicate \"nvptx_nonimmediate_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  if (REG_P (op))\n+    return (op != frame_pointer_rtx\n+\t    && op != arg_pointer_rtx\n+\t    && op != stack_pointer_rtx);\n+  return nonimmediate_operand (op, mode);\n+})\n+\n+(define_predicate \"const_0_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"global_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"MEM_ADDR_SPACE (op) == ADDR_SPACE_GLOBAL\")))\n+\n+(define_predicate \"const_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"MEM_ADDR_SPACE (op) == ADDR_SPACE_CONST\")))\n+\n+(define_predicate \"param_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"MEM_ADDR_SPACE (op) == ADDR_SPACE_PARAM\")))\n+\n+(define_predicate \"shared_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"MEM_ADDR_SPACE (op) == ADDR_SPACE_SHARED\")))\n+\n+(define_predicate \"const0_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"op == const0_rtx\")))\n+\n+;; True if this operator is valid for predication.\n+(define_predicate \"predicate_operator\"\n+  (match_code \"eq,ne\"))\n+\n+(define_predicate \"ne_operator\"\n+  (match_code \"ne\"))\n+\n+(define_predicate \"nvptx_comparison_operator\"\n+  (match_code \"eq,ne,le,ge,lt,gt,leu,geu,ltu,gtu\"))\n+\n+(define_predicate \"nvptx_float_comparison_operator\"\n+  (match_code \"eq,ne,le,ge,lt,gt,uneq,unle,unge,unlt,ungt,unordered,ordered\"))\n+\n+;; Test for a valid operand for a call instruction.\n+(define_special_predicate \"call_insn_operand\"\n+  (match_code \"symbol_ref,reg\")\n+{\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    {\n+      tree decl = SYMBOL_REF_DECL (op);\n+      /* This happens for libcalls.  */\n+      if (decl == NULL_TREE)\n+        return true;\n+      return TREE_CODE (SYMBOL_REF_DECL (op)) == FUNCTION_DECL;\n+    }\n+  return true;\n+})\n+\n+;; Return true if OP is a call with parallel USEs of the argument\n+;; pseudos.\n+(define_predicate \"call_operation\"\n+  (match_code \"parallel\")\n+{\n+  unsigned i;\n+\n+  for (i = 1; i < XVECLEN (op, 0); i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+      enum machine_mode mode;\n+      unsigned regno;\n+\n+      if (GET_CODE (elt) != USE\n+          || GET_CODE (XEXP (elt, 0)) != REG\n+          || XEXP (elt, 0) == frame_pointer_rtx\n+          || XEXP (elt, 0) == arg_pointer_rtx\n+          || XEXP (elt, 0) == stack_pointer_rtx)\n+\n+        return false;\n+    }\n+  return true;\n+})\n+\n+(define_constraint \"P0\"\n+  \"An integer with the value 0.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"P1\"\n+  \"An integer with the value 1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1\")))\n+\n+(define_constraint \"Pn\"\n+  \"An integer with the value -1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == -1\")))\n+\n+(define_constraint \"R\"\n+  \"A pseudo register.\"\n+  (match_code \"reg\"))\n+\n+(define_constraint \"Ia\"\n+  \"Any integer constant.\"\n+  (and (match_code \"const_int\") (match_test \"true\")))\n+\n+(define_mode_iterator QHSDISDFM [QI HI SI DI SF DF])\n+(define_mode_iterator QHSDIM [QI HI SI DI])\n+(define_mode_iterator HSDIM [HI SI DI])\n+(define_mode_iterator BHSDIM [BI HI SI DI])\n+(define_mode_iterator SDIM [SI DI])\n+(define_mode_iterator SDISDFM [SI DI SF DF])\n+(define_mode_iterator QHIM [QI HI])\n+(define_mode_iterator QHSIM [QI HI SI])\n+(define_mode_iterator SDFM [SF DF])\n+(define_mode_iterator SDCM [SC DC])\n+\n+;; This mode iterator allows :P to be used for patterns that operate on\n+;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n+(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+\n+;; We should get away with not defining memory alternatives, since we don't\n+;; get variables in this mode and pseudos are never spilled.\n+(define_insn \"movbi\"\n+  [(set (match_operand:BI 0 \"nvptx_register_operand\" \"=R,R,R\")\n+\t(match_operand:BI 1 \"nvptx_nonmemory_operand\" \"R,P0,Pn\"))]\n+  \"\"\n+  \"@\n+   %.\\\\tmov%t0\\\\t%0, %1;\n+   %.\\\\tsetp.eq.u32\\\\t%0, 1, 0;\n+   %.\\\\tsetp.eq.u32\\\\t%0, 1, 1;\")\n+\n+(define_insn \"*mov<mode>_insn\"\n+  [(set (match_operand:QHSDIM 0 \"nvptx_nonimmediate_operand\" \"=R,R,R,m\")\n+\t(match_operand:QHSDIM 1 \"general_operand\" \"n,Ri,m,R\"))]\n+  \"!(MEM_P (operands[0])\n+     && (!REG_P (operands[1]) || REGNO (operands[1]) <= LAST_VIRTUAL_REGISTER))\"\n+{\n+  if (which_alternative == 2)\n+    return \"%.\\\\tld%A1%u1\\\\t%0, %1;\";\n+  if (which_alternative == 3)\n+    return \"%.\\\\tst%A0%u0\\\\t%0, %1;\";\n+\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+\n+  enum machine_mode dst_mode = nvptx_underlying_object_mode (dst);\n+  enum machine_mode src_mode = nvptx_underlying_object_mode (src);\n+  if (GET_CODE (dst) == SUBREG)\n+    dst = SUBREG_REG (dst);\n+  if (GET_CODE (src) == SUBREG)\n+    src = SUBREG_REG (src);\n+  if (src_mode == QImode)\n+    src_mode = SImode;\n+  if (dst_mode == QImode)\n+    dst_mode = SImode;\n+  if (CONSTANT_P (src))\n+    {\n+      if (GET_MODE_CLASS (dst_mode) != MODE_INT)\n+        return \"%.\\\\tmov.b%T0\\\\t%0, %1;\";\n+      else\n+        return \"%.\\\\tmov%t0\\\\t%0, %1;\";\n+    }\n+\n+  /* Special handling for the return register; we allow this register to\n+     only occur in the destination of a move insn.  */\n+  if (REG_P (dst) && REGNO (dst) == NVPTX_RETURN_REGNUM\n+      && dst_mode == HImode)\n+    dst_mode = SImode;\n+  if (dst_mode == src_mode)\n+    return \"%.\\\\tmov%t0\\\\t%0, %1;\";\n+  /* Mode-punning between floating point and integer.  */\n+  if (GET_MODE_SIZE (dst_mode) == GET_MODE_SIZE (src_mode))\n+    return \"%.\\\\tmov.b%T0\\\\t%0, %1;\";\n+  return \"%.\\\\tcvt%t0%t1\\\\t%0, %1;\";\n+}\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"*mov<mode>_insn\"\n+  [(set (match_operand:SDFM 0 \"nvptx_nonimmediate_operand\" \"=R,R,m\")\n+\t(match_operand:SDFM 1 \"general_operand\" \"RF,m,R\"))]\n+  \"!(MEM_P (operands[0]) && !REG_P (operands[1]))\"\n+{\n+  if (which_alternative == 1)\n+    return \"%.\\\\tld%A1%u0\\\\t%0, %1;\";\n+  if (which_alternative == 2)\n+    return \"%.\\\\tst%A0%u1\\\\t%0, %1;\";\n+\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+  if (GET_CODE (dst) == SUBREG)\n+    dst = SUBREG_REG (dst);\n+  if (GET_CODE (src) == SUBREG)\n+    src = SUBREG_REG (src);\n+  enum machine_mode dst_mode = GET_MODE (dst);\n+  enum machine_mode src_mode = GET_MODE (src);\n+  if (dst_mode == src_mode)\n+    return \"%.\\\\tmov%t0\\\\t%0, %1;\";\n+  if (GET_MODE_SIZE (dst_mode) == GET_MODE_SIZE (src_mode))\n+    return \"%.\\\\tmov.b%T0\\\\t%0, %1;\";\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"load_arg_reg<mode>\"\n+  [(set (match_operand:QHIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:QHIM [(match_operand 1 \"const_int_operand\" \"i\")]\n+\t\t     UNSPEC_ARG_REG))]\n+  \"\"\n+  \"%.\\\\tcvt%t0.u32\\\\t%0, %%ar%1;\")\n+\n+(define_insn \"load_arg_reg<mode>\"\n+  [(set (match_operand:SDISDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SDISDFM [(match_operand 1 \"const_int_operand\" \"i\")]\n+\t\t\tUNSPEC_ARG_REG))]\n+  \"\"\n+  \"%.\\\\tmov%t0\\\\t%0, %%ar%1;\")\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:QHSDISDFM 0 \"nvptx_nonimmediate_operand\" \"\")\n+\t(match_operand:QHSDISDFM 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  operands[1] = nvptx_maybe_convert_symbolic_operand (operands[1]);\n+  /* Record the mode of the return register so that we can prevent\n+     later optimization passes from changing it.  */\n+  if (REG_P (operands[0]) && REGNO (operands[0]) == NVPTX_RETURN_REGNUM\n+      && cfun)\n+    {\n+      if (cfun->machine->ret_reg_mode == VOIDmode)\n+\tcfun->machine->ret_reg_mode = GET_MODE (operands[0]);\n+      else\n+        gcc_assert (cfun->machine->ret_reg_mode == GET_MODE (operands[0]));\n+    }\n+\n+  /* Hard registers are often actually symbolic operands on this target.\n+     Don't allow them when storing to memory.  */\n+  if (MEM_P (operands[0])\n+      && (!REG_P (operands[1])\n+\t  || REGNO (operands[1]) <= LAST_VIRTUAL_REGISTER))\n+    {\n+      rtx tmp = gen_reg_rtx (<MODE>mode);\n+      emit_move_insn (tmp, operands[1]);\n+      emit_move_insn (operands[0], tmp);\n+      DONE;\n+    }\n+  if (GET_CODE (operands[1]) == SYMBOL_REF)\n+    nvptx_record_needed_fndecl (SYMBOL_REF_DECL (operands[1]));\n+})\n+\n+(define_insn \"highpartscsf2\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SF [(match_operand:SC 1 \"nvptx_register_operand\")]\n+\t\t   UNSPEC_CPLX_HIGHPART))]\n+  \"\"\n+  \"%.\\\\tmov%t0\\\\t%0, %f1$1;\")\n+\n+(define_insn \"set_highpartsfsc2\"\n+  [(set (match_operand:SC 0 \"nvptx_register_operand\" \"+R\")\n+\t(unspec:SC [(match_dup 0)\n+\t\t    (match_operand:SF 1 \"nvptx_register_operand\")]\n+\t\t   UNSPEC_CPLX_HIGHPART))]\n+  \"\"\n+  \"%.\\\\tmov%t1\\\\t%f0$1, %1;\")\n+\n+(define_insn \"lowpartscsf2\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SF [(match_operand:SC 1 \"nvptx_register_operand\")]\n+\t\t   UNSPEC_CPLX_LOWPART))]\n+  \"\"\n+  \"%.\\\\tmov%t0\\\\t%0, %f1$0;\")\n+\n+(define_insn \"set_lowpartsfsc2\"\n+  [(set (match_operand:SC 0 \"nvptx_register_operand\" \"+R\")\n+\t(unspec:SC [(match_dup 0)\n+\t\t    (match_operand:SF 1 \"nvptx_register_operand\")]\n+\t\t   UNSPEC_CPLX_LOWPART))]\n+  \"\"\n+  \"%.\\\\tmov%t1\\\\t%f0$0, %1;\")\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:SDCM 0 \"nvptx_nonimmediate_operand\" \"\")\n+\t(match_operand:SDCM 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  enum machine_mode submode = <MODE>mode == SCmode ? SFmode : DFmode;\n+  int sz = GET_MODE_SIZE (submode);\n+  rtx xops[4];\n+  rtx punning_reg = NULL_RTX;\n+  rtx copyback = NULL_RTX;\n+\n+  if (GET_CODE (operands[0]) == SUBREG)\n+    {\n+      rtx inner = SUBREG_REG (operands[0]);\n+      enum machine_mode inner_mode = GET_MODE (inner);\n+      int sz2 = GET_MODE_SIZE (inner_mode);\n+      gcc_assert (sz2 >= sz);\n+      cfun->machine->punning_buffer_size\n+        = MAX (cfun->machine->punning_buffer_size, sz2);\n+      if (punning_reg == NULL_RTX)\n+\tpunning_reg = gen_rtx_REG (Pmode, NVPTX_PUNNING_BUFFER_REGNUM);\n+      copyback = gen_move_insn (inner, gen_rtx_MEM (inner_mode, punning_reg));\n+      operands[0] = gen_rtx_MEM (<MODE>mode, punning_reg);\n+    }\n+  if (GET_CODE (operands[1]) == SUBREG)\n+    {\n+      rtx inner = SUBREG_REG (operands[1]);\n+      enum machine_mode inner_mode = GET_MODE (inner);\n+      int sz2 = GET_MODE_SIZE (inner_mode);\n+      gcc_assert (sz2 >= sz);\n+      cfun->machine->punning_buffer_size\n+        = MAX (cfun->machine->punning_buffer_size, sz2);\n+      if (punning_reg == NULL_RTX)\n+\tpunning_reg = gen_rtx_REG (Pmode, NVPTX_PUNNING_BUFFER_REGNUM);\n+      emit_move_insn (gen_rtx_MEM (inner_mode, punning_reg), inner);\n+      operands[1] = gen_rtx_MEM (<MODE>mode, punning_reg);\n+    }\n+\n+  if (REG_P (operands[0]) && submode == SFmode)\n+    {\n+      xops[0] = gen_reg_rtx (submode);\n+      xops[1] = gen_reg_rtx (submode);\n+    }\n+  else\n+    {\n+      xops[0] = gen_lowpart (submode, operands[0]);\n+      if (MEM_P (operands[0]))\n+\txops[1] = adjust_address_nv (operands[0], submode, sz);\n+      else\n+\txops[1] = gen_highpart (submode, operands[0]);\n+    }\n+\n+  if (REG_P (operands[1]) && submode == SFmode)\n+    {\n+      xops[2] = gen_reg_rtx (submode);\n+      xops[3] = gen_reg_rtx (submode);\n+      emit_insn (gen_lowpartscsf2 (xops[2], operands[1]));\n+      emit_insn (gen_highpartscsf2 (xops[3], operands[1]));\n+    }\n+  else\n+    {\n+      xops[2] = gen_lowpart (submode, operands[1]);\n+      if (MEM_P (operands[1]))\n+\txops[3] = adjust_address_nv (operands[1], submode, sz);\n+      else\n+\txops[3] = gen_highpart (submode, operands[1]);\n+    }\n+\n+  emit_move_insn (xops[0], xops[2]);\n+  emit_move_insn (xops[1], xops[3]);\n+  if (REG_P (operands[0]) && submode == SFmode)\n+    {\n+      emit_insn (gen_set_lowpartsfsc2 (operands[0], xops[0]));\n+      emit_insn (gen_set_highpartsfsc2 (operands[0], xops[1]));\n+    }\n+  if (copyback)\n+    emit_insn (copyback);\n+  DONE;\n+})\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"nvptx_register_operand\" \"=R,R\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nvptx_reg_or_mem_operand\" \"R,m\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt.u16.u%T1\\\\t%0, %1;\n+   %.\\\\tld%A1.u8\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"zero_extend<mode>si2\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R,R\")\n+\t(zero_extend:SI (match_operand:QHIM 1 \"nvptx_reg_or_mem_operand\" \"R,m\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt.u32.u%T1\\\\t%0, %1;\n+   %.\\\\tld%A1.u%T1\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"zero_extend<mode>di2\"\n+  [(set (match_operand:DI 0 \"nvptx_register_operand\" \"=R,R\")\n+\t(zero_extend:DI (match_operand:QHSIM 1 \"nvptx_reg_or_mem_operand\" \"R,m\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt.u64.u%T1\\\\t%0, %1;\n+   %.\\\\tld%A1%u1\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"extend<mode>si2\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R,R\")\n+\t(sign_extend:SI (match_operand:QHIM 1 \"nvptx_reg_or_mem_operand\" \"R,m\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt.s32.s%T1\\\\t%0, %1;\n+   %.\\\\tld%A1.s%T1\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"extend<mode>di2\"\n+  [(set (match_operand:DI 0 \"nvptx_register_operand\" \"=R,R\")\n+\t(sign_extend:DI (match_operand:QHSIM 1 \"nvptx_reg_or_mem_operand\" \"R,m\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt.s64.s%T1\\\\t%0, %1;\n+   %.\\\\tld%A1.s%T1\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"nvptx_reg_or_mem_operand\" \"=R,m\")\n+\t(truncate:QI (match_operand:HI 1 \"nvptx_register_operand\" \"R,R\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt%t0.u16\\\\t%0, %1;\n+   %.\\\\tst%A0.u8\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"truncsi<mode>2\"\n+  [(set (match_operand:QHIM 0 \"nvptx_reg_or_mem_operand\" \"=R,m\")\n+\t(truncate:QHIM (match_operand:SI 1 \"nvptx_register_operand\" \"R,R\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt%t0.u32\\\\t%0, %1;\n+   %.\\\\tst%A0.u%T0\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+(define_insn \"truncdi<mode>2\"\n+  [(set (match_operand:QHSIM 0 \"nvptx_reg_or_mem_operand\" \"=R,m\")\n+\t(truncate:QHSIM (match_operand:DI 1 \"nvptx_register_operand\" \"R,R\")))]\n+  \"\"\n+  \"@\n+   %.\\\\tcvt%t0.u64\\\\t%0, %1;\n+   %.\\\\tst%A0.u%T0\\\\t%0, %1;\"\n+  [(set_attr \"subregs_ok\" \"true\")])\n+\n+;; Pointer address space conversions\n+\n+(define_int_iterator cvt_code\n+  [UNSPEC_FROM_GLOBAL\n+   UNSPEC_FROM_LOCAL\n+   UNSPEC_FROM_SHARED\n+   UNSPEC_FROM_CONST\n+   UNSPEC_TO_GLOBAL\n+   UNSPEC_TO_LOCAL\n+   UNSPEC_TO_SHARED\n+   UNSPEC_TO_CONST])\n+\n+(define_int_attr cvt_name\n+  [(UNSPEC_FROM_GLOBAL \"from_global\")\n+   (UNSPEC_FROM_LOCAL \"from_local\")\n+   (UNSPEC_FROM_SHARED \"from_shared\")\n+   (UNSPEC_FROM_CONST \"from_const\")\n+   (UNSPEC_TO_GLOBAL \"to_global\")\n+   (UNSPEC_TO_LOCAL \"to_local\")\n+   (UNSPEC_TO_SHARED \"to_shared\")\n+   (UNSPEC_TO_CONST \"to_const\")])\n+\n+(define_int_attr cvt_str\n+  [(UNSPEC_FROM_GLOBAL \".global\")\n+   (UNSPEC_FROM_LOCAL \".local\")\n+   (UNSPEC_FROM_SHARED \".shared\")\n+   (UNSPEC_FROM_CONST \".const\")\n+   (UNSPEC_TO_GLOBAL \".to.global\")\n+   (UNSPEC_TO_LOCAL \".to.local\")\n+   (UNSPEC_TO_SHARED \".to.shared\")\n+   (UNSPEC_TO_CONST \".to.const\")])\n+\n+(define_insn \"convaddr_<cvt_name><mode>\"\n+  [(set (match_operand:P 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:P [(match_operand:P 1 \"nvptx_register_or_symbolic_operand\" \"Rs\")] cvt_code))]\n+  \"\"\n+  \"%.\\\\tcvta<cvt_str>%t0\\\\t%0, %1;\")\n+\n+;; Integer arithmetic\n+\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(plus:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tadd%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(minus:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t     (match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tsub%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(mult:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tmul.lo%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"*mad<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(plus:HSDIM (mult:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t\t\t(match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\"))\n+\t\t    (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tmad.lo%t0\\\\t%0, %1, %2, %3;\")\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(div:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t   (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tdiv.s%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"udiv<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(udiv:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t   (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tdiv.u%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"mod<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(mod:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"Ri\")\n+\t\t   (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\trem.s%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"umod<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(umod:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"Ri\")\n+\t\t    (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\trem.u%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"smin<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(smin:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tmin.s%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"umin<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(umin:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tmin.u%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"smax<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(smax:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tmax.s%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"umax<mode>3\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(umax:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:HSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tmax.u%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"abs<mode>2\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(abs:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tabs.s%T0\\\\t%0, %1;\")\n+\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(neg:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tneg.s%T0\\\\t%0, %1;\")\n+\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(not:HSDIM (match_operand:HSDIM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tnot.b%T0\\\\t%0, %1;\")\n+\n+(define_insn \"bitrev<mode>2\"\n+  [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SDIM [(match_operand:SDIM 1 \"nvptx_register_operand\" \"R\")]\n+\t\t     UNSPEC_BITREV))]\n+  \"\"\n+  \"%.\\\\tbrev.b%T0\\\\t%0, %1;\")\n+\n+(define_insn \"clz<mode>2\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(clz:SI (match_operand:SDIM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tclz.b%T0\\\\t%0, %1;\")\n+\n+(define_expand \"ctz<mode>2\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"\")\n+\t(ctz:SI (match_operand:SDIM 1 \"nvptx_register_operand\" \"\")))]\n+  \"\"\n+{\n+  rtx tmpreg = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_bitrev<mode>2 (tmpreg, operands[1]));\n+  emit_insn (gen_clz<mode>2 (operands[0], tmpreg));\n+  DONE;\n+})\n+\n+;; Shifts\n+\n+(define_insn \"ashl<mode>3\"\n+  [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(ashift:SDIM (match_operand:SDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t     (match_operand:SI 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tshl.b%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"ashr<mode>3\"\n+  [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(ashiftrt:SDIM (match_operand:SDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t       (match_operand:SI 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tshr.s%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"lshr<mode>3\"\n+  [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(lshiftrt:SDIM (match_operand:SDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t       (match_operand:SI 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tshr.u%T0\\\\t%0, %1, %2;\")\n+\n+;; Logical operations\n+\n+(define_insn \"and<mode>3\"\n+  [(set (match_operand:BHSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(and:BHSDIM (match_operand:BHSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:BHSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tand.b%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"ior<mode>3\"\n+  [(set (match_operand:BHSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(ior:BHSDIM (match_operand:BHSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:BHSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\tor.b%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"xor<mode>3\"\n+  [(set (match_operand:BHSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(xor:BHSDIM (match_operand:BHSDIM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:BHSDIM 2 \"nvptx_nonmemory_operand\" \"Ri\")))]\n+  \"\"\n+  \"%.\\\\txor.b%T0\\\\t%0, %1, %2;\")\n+\n+;; Comparisons and branches\n+\n+(define_insn \"*cmp<mode>\"\n+  [(set (match_operand:BI 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_operator:BI 1 \"nvptx_comparison_operator\"\n+\t   [(match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")\n+\t    (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\" \"Ri\")]))]\n+  \"\"\n+  \"%.\\\\tsetp%c1 %0,%2,%3;\")\n+\n+(define_insn \"*cmp<mode>\"\n+  [(set (match_operand:BI 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_operator:BI 1 \"nvptx_float_comparison_operator\"\n+\t   [(match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")\n+\t    (match_operand:SDFM 3 \"nvptx_nonmemory_operand\" \"RF\")]))]\n+  \"\"\n+  \"%.\\\\tsetp%c1 %0,%2,%3;\")\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"%.\\\\tbra\\\\t%l0;\")\n+\n+(define_insn \"br_true\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:BI 0 \"nvptx_register_operand\" \"R\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"%j0\\\\tbra\\\\t%l1;\")\n+\n+(define_insn \"br_false\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:BI 0 \"nvptx_register_operand\" \"R\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"%J0\\\\tbra\\\\t%l1;\")\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"nvptx_comparison_operator\"\n+\t\t       [(match_operand:HSDIM 1 \"nvptx_register_operand\" \"\")\n+\t\t\t(match_operand:HSDIM 2 \"nvptx_register_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  rtx t = nvptx_expand_compare (operands[0]);\n+  operands[0] = t;\n+  operands[1] = XEXP (t, 0);\n+  operands[2] = XEXP (t, 1);\n+})\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"nvptx_float_comparison_operator\"\n+\t\t       [(match_operand:SDFM 1 \"nvptx_register_operand\" \"\")\n+\t\t\t(match_operand:SDFM 2 \"nvptx_register_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  rtx t = nvptx_expand_compare (operands[0]);\n+  operands[0] = t;\n+  operands[1] = XEXP (t, 0);\n+  operands[2] = XEXP (t, 1);\n+})\n+\n+(define_expand \"cbranchbi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"predicate_operator\"\n+\t\t       [(match_operand:BI 1 \"nvptx_register_operand\" \"\")\n+\t\t\t(match_operand:BI 2 \"const0_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+;; Conditional stores\n+\n+(define_insn \"setcc_from_bi\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(ne:SI (match_operand:BI 1 \"nvptx_register_operand\" \"R\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"%.\\\\tselp%t0 %0,-1,0,%1;\")\n+\n+(define_insn \"setcc_int<mode>\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_operator:SI 1 \"nvptx_comparison_operator\"\n+\t\t\t   [(match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")\n+\t\t\t    (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\" \"Ri\")]))]\n+  \"\"\n+  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+\n+(define_insn \"setcc_int<mode>\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_operator:SI 1 \"nvptx_float_comparison_operator\"\n+\t\t\t   [(match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")\n+\t\t\t    (match_operand:SDFM 3 \"nvptx_nonmemory_operand\" \"RF\")]))]\n+  \"\"\n+  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+\n+(define_insn \"setcc_float<mode>\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_operator:SF 1 \"nvptx_comparison_operator\"\n+\t\t\t   [(match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")\n+\t\t\t    (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\" \"Ri\")]))]\n+  \"\"\n+  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+\n+(define_insn \"setcc_float<mode>\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_operator:SF 1 \"nvptx_float_comparison_operator\"\n+\t\t\t   [(match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")\n+\t\t\t    (match_operand:SDFM 3 \"nvptx_nonmemory_operand\" \"RF\")]))]\n+  \"\"\n+  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+\n+(define_expand \"cstorebi4\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\")\n+\t(match_operator:SI 1 \"ne_operator\"\n+         [(match_operand:BI 2 \"nvptx_register_operand\")\n+          (match_operand:BI 3 \"const0_operand\")]))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\")\n+\t(match_operator:SI 1 \"nvptx_comparison_operator\"\n+         [(match_operand:HSDIM 2 \"nvptx_register_operand\")\n+          (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\")]))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\")\n+\t(match_operator:SI 1 \"nvptx_float_comparison_operator\"\n+         [(match_operand:SDFM 2 \"nvptx_register_operand\")\n+          (match_operand:SDFM 3 \"nvptx_nonmemory_operand\")]))]\n+  \"\"\n+  \"\")\n+\n+;; Calls\n+\n+(define_insn \"call_insn\"\n+  [(match_parallel 2 \"call_operation\"\n+    [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"Rs\"))\n+\t   (match_operand 1))])]\n+  \"\"\n+{\n+  return nvptx_output_call_insn (insn, NULL_RTX, operands[0]);\n+})\n+\n+(define_insn \"call_value_insn\"\n+  [(match_parallel 3 \"call_operation\"\n+    [(set (match_operand 0 \"nvptx_register_operand\" \"=R\")\n+\t  (call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"Rs\"))\n+\t\t(match_operand 2)))])]\n+  \"\"\n+{\n+  return nvptx_output_call_insn (insn, operands[0], operands[1]);\n+})\n+\n+(define_expand \"call\"\n+ [(match_operand 0 \"\" \"\")]\n+ \"\"\n+{\n+  nvptx_expand_call (NULL_RTX, operands[0]);\n+  DONE;\n+})\n+\n+(define_expand \"call_value\"\n+  [(match_operand 0 \"\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+ \"\"\n+{\n+  nvptx_expand_call (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; Floating point arithmetic.\n+\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(plus:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t   (match_operand:SDFM 2 \"nvptx_nonmemory_operand\" \"RF\")))]\n+  \"\"\n+  \"%.\\\\tadd%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(minus:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tsub%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(mult:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t   (match_operand:SDFM 2 \"nvptx_nonmemory_operand\" \"RF\")))]\n+  \"\"\n+  \"%.\\\\tmul%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"fma<mode>4\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(fma:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t  (match_operand:SDFM 2 \"nvptx_nonmemory_operand\" \"RF\")\n+\t\t  (match_operand:SDFM 3 \"nvptx_nonmemory_operand\" \"RF\")))]\n+  \"\"\n+  \"%.\\\\tfma%#%t0\\\\t%0, %1, %2, %3;\")\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(div:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t  (match_operand:SDFM 2 \"nvptx_nonmemory_operand\" \"RF\")))]\n+  \"\"\n+  \"%.\\\\tdiv%#%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"copysign<mode>3\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SDFM [(match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t      (match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")]\n+\t\t      UNSPEC_COPYSIGN))]\n+  \"\"\n+  \"%.\\\\tcopysign%t0\\\\t%0, %2, %1;\")\n+\n+(define_insn \"smin<mode>3\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(smin:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:SDFM 2 \"nvptx_nonmemory_operand\" \"RF\")))]\n+  \"\"\n+  \"%.\\\\tmin%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"smax<mode>3\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(smax:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")\n+\t\t    (match_operand:SDFM 2 \"nvptx_nonmemory_operand\" \"RF\")))]\n+  \"\"\n+  \"%.\\\\tmax%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"abs<mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(abs:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tabs%t0\\\\t%0, %1;\")\n+\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(neg:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tneg%t0\\\\t%0, %1;\")\n+\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(sqrt:SDFM (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tsqrt%#%t0\\\\t%0, %1;\")\n+\n+(define_insn \"sinsf2\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SF [(match_operand:SF 1 \"nvptx_register_operand\" \"R\")]\n+\t\t   UNSPEC_SIN))]\n+  \"flag_unsafe_math_optimizations\"\n+  \"%.\\\\tsin.approx%t0\\\\t%0, %1;\")\n+\n+(define_insn \"cossf2\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SF [(match_operand:SF 1 \"nvptx_register_operand\" \"R\")]\n+\t\t   UNSPEC_COS))]\n+  \"flag_unsafe_math_optimizations\"\n+  \"%.\\\\tcos.approx%t0\\\\t%0, %1;\")\n+\n+(define_insn \"log2sf2\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SF [(match_operand:SF 1 \"nvptx_register_operand\" \"R\")]\n+\t\t   UNSPEC_LOG2))]\n+  \"flag_unsafe_math_optimizations\"\n+  \"%.\\\\tlg2.approx%t0\\\\t%0, %1;\")\n+\n+(define_insn \"exp2sf2\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SF [(match_operand:SF 1 \"nvptx_register_operand\" \"R\")]\n+\t\t   UNSPEC_EXP2))]\n+  \"flag_unsafe_math_optimizations\"\n+  \"%.\\\\tex2.approx%t0\\\\t%0, %1;\")\n+\n+;; Conversions involving floating point\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"nvptx_register_operand\" \"=R\")\n+\t(float_extend:DF (match_operand:SF 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt%t0%t1\\\\t%0, %1;\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(float_truncate:SF (match_operand:DF 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt%#%t0%t1\\\\t%0, %1;\")\n+\n+(define_insn \"floatunssi<mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unsigned_float:SDFM (match_operand:SI 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt%#%t0.u%T1\\\\t%0, %1;\")\n+\n+(define_insn \"floatsi<mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(float:SDFM (match_operand:SI 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt%#%t0.s%T1\\\\t%0, %1;\")\n+\n+(define_insn \"floatunsdi<mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unsigned_float:SDFM (match_operand:DI 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt%#%t0.u%T1\\\\t%0, %1;\")\n+\n+(define_insn \"floatdi<mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(float:SDFM (match_operand:DI 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt%#%t0.s%T1\\\\t%0, %1;\")\n+\n+(define_insn \"fixuns_trunc<mode>si2\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(unsigned_fix:SI (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt.rzi.u%T0%t1\\\\t%0, %1;\")\n+\n+(define_insn \"fix_trunc<mode>si2\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(fix:SI (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt.rzi.s%T0%t1\\\\t%0, %1;\")\n+\n+(define_insn \"fixuns_trunc<mode>di2\"\n+  [(set (match_operand:DI 0 \"nvptx_register_operand\" \"=R\")\n+\t(unsigned_fix:DI (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt.rzi.u%T0%t1\\\\t%0, %1;\")\n+\n+(define_insn \"fix_trunc<mode>di2\"\n+  [(set (match_operand:DI 0 \"nvptx_register_operand\" \"=R\")\n+\t(fix:DI (match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")))]\n+  \"\"\n+  \"%.\\\\tcvt.rzi.s%T0%t1\\\\t%0, %1;\")\n+\n+(define_int_iterator FPINT [UNSPEC_FPINT_FLOOR UNSPEC_FPINT_BTRUNC\n+\t\t\t    UNSPEC_FPINT_CEIL UNSPEC_FPINT_NEARBYINT])\n+(define_int_attr fpint_name [(UNSPEC_FPINT_FLOOR \"floor\")\n+\t\t\t     (UNSPEC_FPINT_BTRUNC \"btrunc\")\n+\t\t\t     (UNSPEC_FPINT_CEIL \"ceil\")\n+\t\t\t     (UNSPEC_FPINT_NEARBYINT \"nearbyint\")])\n+(define_int_attr fpint_roundingmode [(UNSPEC_FPINT_FLOOR \".rmi\")\n+\t\t\t\t     (UNSPEC_FPINT_BTRUNC \".rzi\")\n+\t\t\t\t     (UNSPEC_FPINT_CEIL \".rpi\")\n+\t\t\t\t     (UNSPEC_FPINT_NEARBYINT \"%#i\")])\n+\n+(define_insn \"<FPINT:fpint_name><SDFM:mode>2\"\n+  [(set (match_operand:SDFM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SDFM [(match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")]\n+\t\t     FPINT))]\n+  \"\"\n+  \"%.\\\\tcvt<FPINT:fpint_roundingmode>%t0%t1\\\\t%0, %1;\")\n+\n+(define_int_iterator FPINT2 [UNSPEC_FPINT_FLOOR UNSPEC_FPINT_CEIL])\n+(define_int_attr fpint2_name [(UNSPEC_FPINT_FLOOR \"lfloor\")\n+\t\t\t     (UNSPEC_FPINT_CEIL \"lceil\")])\n+(define_int_attr fpint2_roundingmode [(UNSPEC_FPINT_FLOOR \".rmi\")\n+\t\t\t\t     (UNSPEC_FPINT_CEIL \".rpi\")])\n+\n+(define_insn \"<FPINT2:fpint2_name><SDFM:mode><SDIM:mode>2\"\n+  [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SDIM [(match_operand:SDFM 1 \"nvptx_register_operand\" \"R\")]\n+\t\t     FPINT2))]\n+  \"\"\n+  \"%.\\\\tcvt<FPINT2:fpint2_roundingmode>.s%T0%t1\\\\t%0, %1;\")\n+\n+;; Miscellaneous\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"\"\n+{\n+  return nvptx_output_return ();\n+})\n+\n+(define_expand \"epilogue\"\n+  [(clobber (const_int 0))]\n+  \"\"\n+{\n+  emit_jump_insn (gen_return ());\n+  DONE;\n+})\n+\n+(define_expand \"nonlocal_goto\"\n+  [(match_operand 0 \"\" \"\")\n+   (match_operand 1 \"\" \"\")\n+   (match_operand 2 \"\" \"\")\n+   (match_operand 3 \"\" \"\")]\n+  \"\"\n+{\n+  sorry (\"target cannot support nonlocal goto.\");\n+  emit_insn (gen_nop ());\n+  DONE;\n+})\n+\n+(define_expand \"nonlocal_goto_receiver\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  sorry (\"target cannot support nonlocal goto.\");\n+})\n+\n+(define_insn \"allocate_stack\"\n+  [(set (match_operand 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec [(match_operand 1 \"nvptx_register_operand\" \"R\")]\n+\t\t  UNSPEC_ALLOCA))]\n+  \"\"\n+  \"%.\\\\tcall (%0), %%alloca, (%1);\")\n+\n+(define_expand \"restore_stack_block\"\n+  [(match_operand 0 \"register_operand\" \"\")\n+   (match_operand 1 \"register_operand\" \"\")]\n+  \"\"\n+{\n+  DONE;\n+})\n+\n+(define_expand \"restore_stack_function\"\n+  [(match_operand 0 \"register_operand\" \"\")\n+   (match_operand 1 \"register_operand\" \"\")]\n+  \"\"\n+{\n+  DONE;\n+})\n+\n+(define_insn \"trap\"\n+  [(trap_if (const_int 1) (const_int 0))]\n+  \"\"\n+  \"trap;\")\n+\n+(define_insn \"trap_if_true\"\n+  [(trap_if (ne (match_operand:BI 0 \"nvptx_register_operand\" \"R\")\n+\t\t(const_int 0))\n+\t    (const_int 0))]\n+  \"\"\n+  \"%j0 trap;\")\n+\n+(define_insn \"trap_if_false\"\n+  [(trap_if (eq (match_operand:BI 0 \"nvptx_register_operand\" \"R\")\n+\t\t(const_int 0))\n+\t    (const_int 0))]\n+  \"\"\n+  \"%J0 trap;\")\n+\n+(define_expand \"ctrap<mode>4\"\n+  [(trap_if (match_operator 0 \"nvptx_comparison_operator\"\n+\t\t\t    [(match_operand:SDIM 1 \"nvptx_register_operand\")\n+\t\t\t     (match_operand:SDIM 2 \"nvptx_nonmemory_operand\")])\n+\t    (match_operand 3 \"const_0_operand\"))]\n+  \"\"\n+{\n+  rtx t = nvptx_expand_compare (operands[0]);\n+  emit_insn (gen_trap_if_true (t));\n+  DONE;\n+})\n+\n+(define_insn \"*oacc_ntid_insn\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SI [(match_operand:SI 1 \"const_int_operand\" \"n\")] UNSPEC_NTID))]\n+  \"\"\n+  \"%.\\\\tmov.u32 %0, %%ntid%d1;\")\n+\n+(define_expand \"oacc_ntid\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"\")\n+\t(unspec:SI [(match_operand:SI 1 \"const_int_operand\" \"\")] UNSPEC_NTID))]\n+  \"\"\n+{\n+  if (INTVAL (operands[1]) < 0 || INTVAL (operands[1]) > 2)\n+    FAIL;\n+})\n+\n+(define_insn \"*oacc_tid_insn\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SI [(match_operand:SI 1 \"const_int_operand\" \"n\")] UNSPEC_TID))]\n+  \"\"\n+  \"%.\\\\tmov.u32 %0, %%tid%d1;\")\n+\n+(define_expand \"oacc_tid\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"\")\n+\t(unspec:SI [(match_operand:SI 1 \"const_int_operand\" \"\")] UNSPEC_TID))]\n+  \"\"\n+{\n+  if (INTVAL (operands[1]) < 0 || INTVAL (operands[1]) > 2)\n+    FAIL;\n+})\n+\n+;; Atomic insns.\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"nvptx_register_operand\")\t;; bool success output\n+   (match_operand:SDIM 1 \"nvptx_register_operand\")\t;; oldval output\n+   (match_operand:SDIM 2 \"memory_operand\")\t\t;; memory\n+   (match_operand:SDIM 3 \"nvptx_register_operand\")\t;; expected input\n+   (match_operand:SDIM 4 \"nvptx_register_operand\")\t;; newval input\n+   (match_operand:SI 5 \"const_int_operand\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\")\t\t;; success model\n+   (match_operand:SI 7 \"const_int_operand\")]\t\t;; failure model\n+  \"\"\n+{\n+  emit_insn (gen_atomic_compare_and_swap<mode>_1 (operands[1], operands[2], operands[3],\n+\t\t\t\t\t          operands[4], operands[6]));\n+\n+  rtx tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+  emit_insn (gen_cstore<mode>4 (tmp,\n+\t\t\t\tgen_rtx_EQ (SImode, operands[1], operands[3]),\n+\t\t\t\toperands[1], operands[3]));\n+  emit_insn (gen_andsi3 (operands[0], tmp, GEN_INT (1)));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_compare_and_swap<mode>_1\"\n+  [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec_volatile:SDIM\n+\t  [(match_operand:SDIM 1 \"memory_operand\" \"+m\")\n+\t   (match_operand:SDIM 2 \"nvptx_register_operand\" \"R\")\n+\t   (match_operand:SDIM 3 \"nvptx_register_operand\" \"R\")\n+\t   (match_operand:SI 4 \"const_int_operand\")]\n+\t  UNSPECV_CAS))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SDIM [(const_int 0)] UNSPECV_CAS))]\n+  \"\"\n+  \"%.\\\\tatom%A1.cas.b%T0\\\\t%0, %1, %2, %3;\")\n+\n+(define_insn \"atomic_exchange<mode>\"\n+  [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\t;; output\n+\t(unspec_volatile:SDIM\n+\t  [(match_operand:SDIM 1 \"memory_operand\" \"+m\")\t\t;; memory\n+\t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+\t  UNSPECV_XCHG))\n+   (set (match_dup 1)\n+\t(match_operand:SDIM 2 \"nvptx_register_operand\" \"R\"))]\t;; input\n+  \"\"\n+  \"%.\\\\tatom%A1.exch.b%T0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"atomic_fetch_add<mode>\"\n+  [(set (match_operand:SDIM 1 \"memory_operand\" \"+m\")\n+\t(unspec_volatile:SDIM\n+\t  [(plus:SDIM (match_dup 1)\n+\t\t      (match_operand:SDIM 2 \"nvptx_nonmemory_operand\" \"Ri\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+\t  UNSPECV_LOCK))\n+   (set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\")\n+\n+(define_insn \"atomic_fetch_addsf\"\n+  [(set (match_operand:SF 1 \"memory_operand\" \"+m\")\n+\t(unspec_volatile:SF\n+\t [(plus:SF (match_dup 1)\n+\t\t   (match_operand:SF 2 \"nvptx_nonmemory_operand\" \"RF\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+\t  UNSPECV_LOCK))\n+   (set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\")\n+\n+(define_code_iterator any_logic [and ior xor])\n+(define_code_attr logic [(and \"and\") (ior \"or\") (xor \"xor\")])\n+\n+;; Currently disabled until we add better subtarget support - requires sm_32.\n+(define_insn \"atomic_fetch_<logic><mode>\"\n+  [(set (match_operand:SDIM 1 \"memory_operand\" \"+m\")\n+\t(unspec_volatile:SDIM\n+\t  [(any_logic:SDIM (match_dup 1)\n+\t\t\t   (match_operand:SDIM 2 \"nvptx_nonmemory_operand\" \"Ri\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+\t  UNSPECV_LOCK))\n+   (set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(match_dup 1))]\n+  \"0\"\n+  \"%.\\\\tatom%A1.b%T0.<logic>\\\\t%0, %1, %2;\")"}, {"sha": "bcdbc8c5d81c400163bee63c07ea0cf6f1c2fabf", "filename": "gcc/config/nvptx/nvptx.opt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,30 @@\n+; Options for the NVPTX port\n+; Copyright 2014 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+m64\n+Target Report RejectNegative Mask(ABI64)\n+Generate code for a 64 bit ABI\n+\n+m32\n+Target Report RejectNegative InverseMask(ABI64)\n+Generate code for a 32 bit ABI\n+\n+mmainkernel\n+Target Report RejectNegative\n+Link in code for a __main kernel."}, {"sha": "8fa2136f688510d6f4367b1c79a06907d4ca8885", "filename": "gcc/config/nvptx/t-nvptx", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,2 @@\n+#\n+"}, {"sha": "17c8bb176781bd9a3438ba29a3b9b9d949659e46", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -1,3 +1,16 @@\n+2014-11-06  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* config.host: Handle nvptx-*-*.\n+\t* shared-object.mk (as-flags-$o): Define.\n+\t($(base)$(objext), $(base)_s$(objext)): Use it instead of\n+\t-xassembler-with-cpp.\n+\t* static-object.mk: Identical changes.\n+\t* config/nvptx/t-nvptx: New file.\n+\t* config/nvptx/crt0.s: New file.\n+\t* config/nvptx/free.asm: New file.\n+\t* config/nvptx/malloc.asm: New file.\n+\t* config/nvptx/realloc.c: New file.\n+\n 2014-10-30  Joseph Myers  <joseph@codesourcery.com>\n \n \t* Makefile.in (libgcc.map.in): New target."}, {"sha": "9903d153792f13e4bac0601d88dec215ae6c3b26", "filename": "libgcc/config.host", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -1256,6 +1256,10 @@ mep*-*-*)\n \ttmake_file=\"mep/t-mep t-fdpbit\"\n \textra_parts=\"crtbegin.o crtend.o\"\n \t;;\n+nvptx-*)\n+\ttmake_file=\"$tmake_file nvptx/t-nvptx\"\n+\textra_parts=\"crt0.o\"\n+\t;;\n *)\n \techo \"*** Configuration ${host} not supported\" 1>&2\n \texit 1"}, {"sha": "38327edcebdd5b847d61939426f44f902e331703", "filename": "libgcc/config/nvptx/crt0.s", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Fcrt0.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Fcrt0.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Fcrt0.s?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,45 @@\n+\t.version 3.1\n+\t.target\tsm_30\n+\t.address_size 64\n+\n+.global .u64 %__exitval;\n+// BEGIN GLOBAL FUNCTION DEF: abort\n+.visible .func abort\n+{\n+        .reg .u64 %rd1;\n+        ld.global.u64   %rd1,[%__exitval];\n+        st.u32   [%rd1], 255;\n+        exit;\n+}\n+// BEGIN GLOBAL FUNCTION DEF: exit\n+.visible .func exit (.param .u32 %arg)\n+{\n+        .reg .u64 %rd1;\n+\t.reg .u32 %val;\n+\tld.param.u32 %val,[%arg];\n+        ld.global.u64   %rd1,[%__exitval];\n+        st.u32   [%rd1], %val;\n+        exit;\n+}\n+\n+.extern .func (.param.u32 retval) main (.param.u32 argc, .param.u64 argv);\n+\n+.visible .entry __main (.param .u64 __retval, .param.u32 __argc, .param.u64 __argv)\n+{\n+        .reg .u32 %r<3>;\n+        .reg .u64 %rd<3>;\n+\t.param.u32 %argc;\n+\t.param.u64 %argp;\n+\t.param.u32 %mainret;\n+        ld.param.u64    %rd0, [__retval];\n+        st.global.u64   [%__exitval], %rd0;\n+\n+\tld.param.u32\t%r1, [__argc];\n+\tld.param.u64\t%rd1, [__argv];\n+\tst.param.u32\t[%argc], %r1;\n+\tst.param.u64\t[%argp], %rd1;\n+        call.uni        (%mainret), main, (%argc, %argp);\n+\tld.param.u32\t%r1,[%mainret];\n+        st.s32   [%rd0], %r1;\n+        exit;\n+}"}, {"sha": "c7c56cf09b497ec582362f4b05664e2da8bd2a8f", "filename": "libgcc/config/nvptx/free.asm", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Ffree.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Ffree.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Ffree.asm?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,50 @@\n+// A wrapper around free to enable a realloc implementation.\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+// This file is free software; you can redistribute it and/or modify it\n+// under the terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option) any\n+// later version.\n+\n+// This file is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+        .version        3.1\n+        .target sm_30\n+        .address_size 64\n+\n+.extern .func free(.param.u64 %in_ar1);\n+\n+// BEGIN GLOBAL FUNCTION DEF: __nvptx_free\n+.visible .func __nvptx_free(.param.u64 %in_ar1)\n+{\n+\t.reg.u64 %ar1;\n+\t.reg.u64 %hr10;\n+\t.reg.u64 %r23;\n+\t.reg.pred %r25;\n+\t.reg.u64 %r27;\n+\tld.param.u64 %ar1, [%in_ar1];\n+\t\tmov.u64\t%r23, %ar1;\n+\t\tsetp.eq.u64 %r25,%r23,0;\n+\t@%r25\tbra\t$L1;\n+\t\tadd.u64\t%r27, %r23, -8;\n+\t{\n+\t\t.param.u64 %out_arg0;\n+\t\tst.param.u64 [%out_arg0], %r27;\n+\t\tcall free, (%out_arg0);\n+\t}\n+$L1:\n+\tret;\n+\t}"}, {"sha": "9d9db10a9e5e4dfd50b44d6b569943b8eb712523", "filename": "libgcc/config/nvptx/malloc.asm", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Fmalloc.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Fmalloc.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Fmalloc.asm?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,55 @@\n+// A wrapper around malloc to enable a realloc implementation.\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+// This file is free software; you can redistribute it and/or modify it\n+// under the terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option) any\n+// later version.\n+\n+// This file is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+        .version        3.1\n+        .target sm_30\n+        .address_size 64\n+\n+.extern .func (.param.u64 %out_retval) malloc(.param.u64 %in_ar1);\n+\n+// BEGIN GLOBAL FUNCTION DEF: __nvptx_malloc\n+.visible .func (.param.u64 %out_retval) __nvptx_malloc(.param.u64 %in_ar1)\n+{\n+        .reg.u64 %ar1;\n+.reg.u64 %retval;\n+        .reg.u64 %hr10;\n+        .reg.u64 %r26;\n+        .reg.u64 %r28;\n+        .reg.u64 %r29;\n+        .reg.u64 %r31;\n+        ld.param.u64 %ar1, [%in_ar1];\n+\t\tmov.u64 %r26, %ar1;\n+\t\tadd.u64 %r28, %r26, 8;\n+        {\n+\t\t.param.u64 %retval_in;\n+\t\t.param.u64 %out_arg0;\n+\t\tst.param.u64 [%out_arg0], %r28;\n+\t\tcall (%retval_in), malloc, (%out_arg0);\n+\t\tld.param.u64    %r29, [%retval_in];\n+        }\n+\t\tst.u64  [%r29], %r26;\n+\t\tadd.u64 %r31, %r29, 8;\n+\t\tmov.u64 %retval, %r31;\n+\t\tst.param.u64    [%out_retval], %retval;\n+\t\tret;\n+}"}, {"sha": "137d73c6d530ca40934519dee1c9984af6e877da", "filename": "libgcc/config/nvptx/nvptx-malloc.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Fnvptx-malloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Fnvptx-malloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Fnvptx-malloc.h?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,26 @@\n+/* Declarations for the malloc wrappers.\n+\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+extern void __nvptx_free (void *);\n+extern void *__nvptx_malloc (size_t);\n+extern void *__nvptx_realloc (void *, size_t);"}, {"sha": "41cf55443ff95ef3bf04871eb8a8f199564b8d6f", "filename": "libgcc/config/nvptx/realloc.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Frealloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Frealloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Frealloc.c?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,51 @@\n+/* Implement realloc with the help of the malloc and free wrappers.\n+\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"nvptx-malloc.h\"\n+\n+void *\n+__nvptx_realloc (void *ptr, size_t newsz)\n+{\n+  if (newsz == 0)\n+    {\n+      __nvptx_free (ptr);\n+      return NULL;\n+    }\n+  void *newptr = __nvptx_malloc (newsz);\n+\n+  size_t oldsz;\n+  if (ptr == NULL)\n+    oldsz = 0;\n+  else\n+    {\n+      size_t *sp = __extension__ (size_t *)(ptr - 8);\n+      oldsz = *sp;\n+    }\n+  if (oldsz != 0)\n+    memcpy (newptr, ptr, oldsz > newsz ? newsz : oldsz);\n+\n+  __nvptx_free (ptr);\n+  return newptr;\n+}"}, {"sha": "08d3a67189ef73e02da822995ebfc118bee19b30", "filename": "libgcc/config/nvptx/t-nvptx", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -0,0 +1,9 @@\n+LIB2ADD=$(srcdir)/config/nvptx/malloc.asm \\\n+\t$(srcdir)/config/nvptx/free.asm \\\n+\t$(srcdir)/config/nvptx/realloc.c\n+\n+LIB2ADDEH=\n+LIB2FUNCS_EXCLUDE=__main\n+\n+crt0.o: $(srcdir)/config/nvptx/crt0.s\n+\tcp $< $@"}, {"sha": "efac7973b2c7f3a4c7fc7eb587bda31193eb5bd1", "filename": "libgcc/shared-object.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fshared-object.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fshared-object.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fshared-object.mk?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -24,13 +24,15 @@ $(error Unsupported file type: $o)\n endif\n endif\n \n+as_flags-$o := -xassembler$(if $(filter .S,$(suffix $o)),-with-cpp)\n+\n $(base)$(objext): $o $(base).vis\n-\t$(gcc_compile) -c -xassembler-with-cpp -include $*.vis $<\n+\t$(gcc_compile) -c $(as_flags-$<) -include $*.vis $<\n \n $(base).vis: $(base)_s$(objext)\n \t$(gen-hide-list)\n \n $(base)_s$(objext): $o\n-\t$(gcc_s_compile) -c -xassembler-with-cpp $<\n+\t$(gcc_s_compile) -c $(as_flags-$<) $<\n \n endif"}, {"sha": "891787e85ac66972ff94ccb2d092f8a3c80080f5", "filename": "libgcc/static-object.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fstatic-object.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738f25224b78c40ba48d6debd95946bf73f89e53/libgcc%2Fstatic-object.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fstatic-object.mk?ref=738f25224b78c40ba48d6debd95946bf73f89e53", "patch": "@@ -24,13 +24,15 @@ $(error Unsupported file type: $o)\n endif\n endif\n \n+as_flags-$o := -xassembler$(if $(filter .S,$(suffix $o)),-with-cpp)\n+\n $(base)$(objext): $o $(base).vis\n-\t$(gcc_compile) -c -xassembler-with-cpp -include $*.vis $<\n+\t$(gcc_compile) -c $(as_flags-$<) -include $*.vis $<\n \n $(base).vis: $(base)_s$(objext)\n \t$(gen-hide-list)\n \n $(base)_s$(objext): $o\n-\t$(gcc_s_compile) -c -xassembler-with-cpp $<\n+\t$(gcc_s_compile) -c $(as_flags-$<) $<\n \n endif"}]}