{"sha": "cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M0Yzg5NzVhYTNlZGFjZDMxY2U4Y2U5ODQ1YTFjNTJiY2QwZjEyNA==", "commit": {"author": {"name": "Kevin B Hendricks", "email": "khendricks@ivey.uwo.ca", "date": "2001-03-24T03:26:28Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-03-24T03:26:28Z"}, "message": "ppc_closure.S: New file.\n\n\t* src/powerpc/ppc_closure.S: New file.\n\t* src/powerpc/ffi.c (ffi_prep_args): Fixed ABI compatibility bug\n\tinvolving long long and register pairs.\n\t(ffi_prep_closure): New function.\n\t(flush_icache): Likewise.\n\t(ffi_closure_helper_SYSV): Likewise.\n\t* include/ffi.h.in (FFI_CLOSURES): Define on PPC.\n\t(FFI_TRAMPOLINE_SIZE): Likewise.\n\t(FFI_NATIVE_RAW_API): Likewise.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (EXTRA_DIST): Added src/powerpc/ppc_closure.S.\n\t(TARGET_SRC_POWERPC): Likewise.\n\nFrom-SVN: r40807", "tree": {"sha": "ed1fbe0280cc5d220154b3aa521122d435ce370e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed1fbe0280cc5d220154b3aa521122d435ce370e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/comments", "author": null, "committer": null, "parents": [{"sha": "75e0407e0106071870ed320eb43ada92f00f9395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e0407e0106071870ed320eb43ada92f00f9395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75e0407e0106071870ed320eb43ada92f00f9395"}], "stats": {"total": 438, "additions": 433, "deletions": 5}, "files": [{"sha": "0e92ba64f85506be8c16d90ebf0b6874bc19230c", "filename": "libffi/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "patch": "@@ -1,3 +1,18 @@\n+2001-03-23  Tom Tromey  <tromey@redhat.com>\n+\n+\t* src/powerpc/ppc_closure.S: New file.\n+\t* src/powerpc/ffi.c (ffi_prep_args): Fixed ABI compatibility bug\n+\tinvolving long long and register pairs.\n+\t(ffi_prep_closure): New function.\n+\t(flush_icache): Likewise.\n+\t(ffi_closure_helper_SYSV): Likewise.\n+\t* include/ffi.h.in (FFI_CLOSURES): Define on PPC.\n+\t(FFI_TRAMPOLINE_SIZE): Likewise.\n+\t(FFI_NATIVE_RAW_API): Likewise.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (EXTRA_DIST): Added src/powerpc/ppc_closure.S.\n+\t(TARGET_SRC_POWERPC): Likewise.\n+\n 2001-03-19  Tom Tromey  <tromey@redhat.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "8d2eb53748689934cea11ad7a27a498678546f7b", "filename": "libffi/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "patch": "@@ -10,7 +10,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/x86/ffi.c src/x86/sysv.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n-\t\tsrc/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/asm.h \\\n+\t\tsrc/powerpc/ffi.c src/powerpc/sysv.S \\\n+                src/powerpc/ppc_closure.S src/powerpc/asm.h \\\n \t\tsrc/arm/ffi.c src/arm/sysv.S\n \n VPATH = @srcdir@:@srcdir@/src:@srcdir@/src/@TARGETDIR@\n@@ -93,7 +94,7 @@ TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n-TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S\n+TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c\n \n ##libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c $(TARGET_SRC_@TARGET@)"}, {"sha": "a064a32662e5863cd6b14bf00ee4f3d3ad0a2369", "filename": "libffi/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "patch": "@@ -86,7 +86,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/x86/ffi.c src/x86/sysv.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n-\t\tsrc/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/asm.h \\\n+\t\tsrc/powerpc/ffi.c src/powerpc/sysv.S \\\n+                src/powerpc/asm.h src/powerpc/ppc_closure.S \\\n \t\tsrc/arm/ffi.c src/arm/sysv.S\n \n \n@@ -159,7 +160,7 @@ TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n-TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S\n+TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c\n \n libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n@@ -206,7 +207,7 @@ libffi_la_LIBADD =\n @MIPS_SGI_TRUE@am_libffi_la_OBJECTS =  debug.lo prep_cif.lo types.lo \\\n @MIPS_SGI_TRUE@raw_api.lo java_raw_api.lo ffi.lo o32.lo n32.lo\n @POWERPC_TRUE@am_libffi_la_OBJECTS =  debug.lo prep_cif.lo types.lo \\\n-@POWERPC_TRUE@raw_api.lo java_raw_api.lo ffi.lo sysv.lo\n+@POWERPC_TRUE@raw_api.lo java_raw_api.lo ffi.lo sysv.lo ppc_closure.lo\n @SPARC_TRUE@am_libffi_la_OBJECTS =  debug.lo prep_cif.lo types.lo \\\n @SPARC_TRUE@raw_api.lo java_raw_api.lo ffi.lo v8.lo v9.lo\n @X86_TRUE@am_libffi_la_OBJECTS =  debug.lo prep_cif.lo types.lo \\"}, {"sha": "7161e51e92a3ebf4e0a5140fe37969c423727587", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "patch": "@@ -372,6 +372,12 @@ struct ffi_ia64_trampoline_struct {\n #define FFI_TRAMPOLINE_SIZE 24\n #define FFI_NATIVE_RAW_API 0\n \n+#elif defined(POWERPC)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 40\n+#define FFI_NATIVE_RAW_API 0\n+\n #else \n \n #define FFI_CLOSURES 0"}, {"sha": "c93aec0ed874b9b31c6d6c0c5419fa4d606bb666", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "patch": "@@ -29,6 +29,9 @@\n #include <ffi_common.h>\n \n #include <stdlib.h>\n+#include <stdio.h>\n+\n+extern void ffi_closure_SYSV(void);\n \n enum {\n   /* The assembly depends on these exact flags.  */\n@@ -172,6 +175,18 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t    }\n \t  else\n \t    {\n+              /* whoops: abi states only certain register pairs\n+               * can be used for passing long long int\n+               * specifically (r3,r4), (r5,r6), (r7,r8), \n+               * (r9,r10) and if next arg is long long but\n+               * not correct starting register of pair then skip\n+               * until the proper starting register\n+\t       */\n+              if (intarg_count%2 != 0)\n+                {\n+                  intarg_count ++;\n+                  gpr_base++;\n+                }\n \t      *(long long *)gpr_base = *(long long *)*p_argv;\n \t      gpr_base += 2;\n \t    }\n@@ -421,3 +436,245 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n       break;\n     }\n }\n+\n+\n+static void flush_icache(char *, int);\n+\n+ffi_status\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t  void *user_data)\n+{\n+  unsigned int *tramp;\n+\n+  FFI_ASSERT (cif->abi == FFI_GCC_SYSV);\n+\n+  tramp = (unsigned int *) &closure->tramp[0];\n+  tramp[0] = 0x7c0802a6;  /*   mflr    r0 */\n+  tramp[1] = 0x4800000d;  /*   bl      10 <trampoline_initial+0x10> */\n+  tramp[4] = 0x7d6802a6;  /*   mflr    r11 */\n+  tramp[5] = 0x7c0803a6;  /*   mtlr    r0 */\n+  tramp[6] = 0x800b0000;  /*   lwz     r0,0(r11) */\n+  tramp[7] = 0x816b0004;  /*   lwz     r11,4(r11) */\n+  tramp[8] = 0x7c0903a6;  /*   mtctr   r0 */\n+  tramp[9] = 0x4e800420;  /*   bctr */\n+  *(void **) &tramp[2] = (void *)ffi_closure_SYSV; /* function */\n+  *(void **) &tramp[3] = (void *)closure;          /* context */\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  /* Flush the icache.  */\n+  flush_icache(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n+\n+  return FFI_OK;\n+}\n+\n+\n+#define MIN_CACHE_LINE_SIZE 8\n+\n+static void flush_icache(char * addr1, int size)\n+{\n+  int i;\n+  char * addr;\n+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE) {\n+     addr = addr1 + i;\n+     __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" : : \"r\"(addr) : \"memory\");\n+  }\n+  addr = addr1 + size - 1;\n+  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" \"sync;\" \"isync;\" : : \"r\"(addr) : \"memory\");\n+}\n+\n+\n+int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*, \n+                                     unsigned long*, unsigned long*);\n+\n+/* Basically the trampoline invokes ffi_closure_SYSV, and on \n+ * entry, r11 holds the address of the closure.\n+ * After storing the registers that could possibly contain\n+ * parameters to be passed into the stack frame and setting\n+ * up space for a return value, ffi_closure_SYSV invokes the \n+ * following helper function to do most of the work\n+ */\n+\n+int\n+ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue, \n+            unsigned long * pgr, unsigned long * pfr, \n+            unsigned long * pst)\n+{\n+  /* rvalue is the pointer to space for return value in closure assembly */\n+  /* pgr is the pointer to where r3-r10 are stored in ffi_closure_SYSV */\n+  /* pfr is the pointer to where f1-f8 are stored in ffi_closure_SYSV  */\n+  /* pst is the pointer to outgoing parameter stack in original caller */\n+\n+  void **          avalue;\n+  ffi_type **      arg_types;\n+  long             i, avn;\n+  long             nf;   /* number of floating registers already used */\n+  long             ng;   /* number of general registers already used */\n+  ffi_cif *        cif; \n+  double           temp; \n+\n+  cif = closure->cif;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n+\n+  nf = 0;\n+  ng = 0;\n+\n+  /* Copy the caller's structure return value address so that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+    {\n+      rvalue = *pgr;\n+      ng++;\n+      pgr++;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+  \n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn)\n+    {\n+      switch (arg_types[i]->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\t/* there are 8 gpr registers used to pass values */\n+          if (ng < 8) {\n+\t     avalue[i] = (((char *)pgr)+3);\n+             ng++;\n+             pgr++;\n+          } else {\n+             avalue[i] = (((char *)pst)+3);\n+             pst++;\n+          }\n+\t  break;\n+           \n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\t/* there are 8 gpr registers used to pass values */\n+          if (ng < 8) {\n+\t     avalue[i] = (((char *)pgr)+2);\n+             ng++;\n+             pgr++;\n+          } else {\n+             avalue[i] = (((char *)pst)+2);\n+             pst++;\n+          }\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_POINTER:\n+\tcase FFI_TYPE_STRUCT:\n+\t/* there are 8 gpr registers used to pass values */\n+          if (ng < 8) {\n+\t     avalue[i] = pgr;\n+             ng++;\n+             pgr++;\n+          } else {\n+             avalue[i] = pst;\n+             pst++;\n+          }\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\t  /* passing long long ints are complex, they must\n+           * be passed in suitable register pairs such as\n+           * (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)\n+           * and if the entire pair aren't available then the outgoing\n+           * parameter stack is used for both but an alignment of 8\n+           * must will be kept.  So we must either look in pgr\n+           * or pst to find the correct address for this type\n+           * of parameter.\n+           */\n+           if (ng < 7) {\n+              if (ng & 0x01) {\n+\t\t/* skip r4, r6, r8 as starting points */\n+                  ng++;\n+                  pgr++;\n+              }\n+              avalue[i] = pgr;\n+              ng+=2;\n+              pgr+=2;\n+           } else {\n+              if (((long)pst) & 4) pst++;\n+              avalue[i] = pst;\n+              pst+=2;\n+           }\n+           break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t    /* unfortunately float values are stored as doubles\n+             * in the ffi_closure_SYSV code (since we don't check\n+             * the type in that routine).  This is also true\n+             * of floats passed on the outgoing parameter stack.\n+             * Also, on the outgoing stack all values are aligned\n+             * to 8\n+             *\n+             * Don't you just love the simplicity of this ABI!\n+             */\n+\n+          /* there are 8 64bit floating point registers */\n+\n+          if (nf < 8) {\n+\t     temp = *(double*)pfr;\n+             *(float*)pfr = (float)temp;\n+\t     avalue[i] = pfr;\n+             nf++;\n+             pfr+=2;\n+          } else {\n+\t    /* FIXME? here we are really changing the values\n+             * stored in the original calling routines outgoing\n+             * parameter stack.  This is probably a really\n+             * naughty thing to do but...\n+             */\n+\t     if (((long)pst) & 4) pst++;\n+\t     temp = *(double*)pst;\n+             *(float*)pst = (float)temp;\n+\t     avalue[i] = pst;\n+             nf++;\n+             pst+=2;\n+          }\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  /* On the outgoing stack all values are aligned to 8 */\n+          /* there are 8 64bit floating point registers */\n+\n+          if (nf < 8) {\n+\t     avalue[i] = pfr;\n+             nf++;\n+             pfr+=2;\n+          } else {\n+\t     if (((long)pst) & 4) pst++;\n+\t     avalue[i] = pst;\n+             nf++;\n+             pst+=2;\n+          }\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      i++;\n+    }\n+\n+\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_osf how to perform return type promotions.  */\n+  return cif->rtype->type;\n+\n+}\n+\n+\n+\n+\n+"}, {"sha": "311857724ccd908388657bf0ba57931a6d7b4982", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=cc4c8975aa3edacd31ce8ce9845a1c52bcd0f124", "patch": "@@ -0,0 +1,148 @@\n+#define LIBFFI_ASM\n+#include <powerpc/asm.h>\n+\n+.globl\tffi_closure_helper_SYSV\n+\n+ENTRY(ffi_closure_SYSV)\n+\tstwu %r1,-144(%r1)\n+\tmflr %r0\n+\tstw %r31,140(%r1)\n+\tstw %r0,148(%r1)\n+\n+# we want to build up an areas for the parameters passed\n+# in registers (both floating point and integer)\n+\t\n+\t# so first save gpr 3 to gpr 10 (aligned to 4)\n+\tstw   %r3, 16(%r1)\n+\tstw   %r4, 20(%r1)\n+\tstw   %r5, 24(%r1) \n+\tstw   %r6, 28(%r1)\n+\tstw   %r7, 32(%r1)\n+\tstw   %r8, 36(%r1) \n+\tstw   %r9, 40(%r1)\n+\tstw   %r10,44(%r1)\n+\n+\t# next save fpr 1 to fpr 8 (aligned to 8)\n+\tstfd  %f1, 48(%r1)\n+\tstfd  %f2, 56(%r1)\n+\tstfd  %f3, 64(%r1)\n+\tstfd  %f4, 72(%r1)\n+\tstfd  %f5, 80(%r1)\n+\tstfd  %f6, 88(%r1)\n+\tstfd  %f7, 96(%r1)\n+\tstfd  %f8, 104(%r1)\n+\n+\t# set up registers for the routine that actually does the work\n+\t# get the context pointer from the trampoline\n+\tmr %r3,%r11\n+\t\n+        # now load up the pointer to the result storage\n+\taddi %r4,%r1,112\n+\t\n+\t# now load up the pointer to the saved gpr registers\n+        addi %r5,%r1,16\n+\n+        # now load up the pointer to the saved fpr registers */\n+        addi %r6,%r1,48\n+\n+\t# now load up the pointer to the outgoing parameter \n+\t# stack in the previous frame\n+\t# i.e. the previous frame pointer + 8\n+\taddi %r7,%r1,152\n+\t\n+        # make the call\n+\tbl JUMPTARGET(ffi_closure_helper_SYSV)\n+\n+\t# now r3 contains the return type\n+\t# so use it to look up in a table\n+\t# so we know how to deal with each type\n+\n+        # look up the proper starting point in table \n+\t# by using return type as offset\n+\taddi %r5,%r1,112   # get pointer to results area\n+\taddis %r4,0,.L60@ha  # get address of jump table\n+\taddi %r4,%r4,.L60@l\n+\tslwi %r3,%r3,2         # now multiply return type by 4\n+\tlwzx %r3,%r4,%r3         # get the contents of that table value\n+\tadd %r3,%r3,%r4          # add contents of table to table address\n+\tmtctr %r3\n+\tbctr               # jump to it\n+\t.align 2\n+.L60:\n+\t.long .L44-.L60    # FFI_TYPE_VOID\n+\t.long .L50-.L60    # FFI_TYPE_INT\n+\t.long .L47-.L60    # FFI_TYPE_FLOAT\n+\t.long .L46-.L60    # FFI_TYPE_DOUBLE\n+\t.long .L46-.L60    # FFI_TYPE_LONGDOUBLE\n+\t.long .L56-.L60    # FFI_TYPE_UINT8\n+\t.long .L55-.L60    # FFI_TYPE_SINT8\n+\t.long .L58-.L60    # FFI_TYPE_UINT16\n+\t.long .L57-.L60    # FFI_TYPE_SINT16\n+\t.long .L50-.L60    # FFI_TYPE_UINT32\n+\t.long .L50-.L60    # FFI_TYPE_SINT32\n+\t.long .L48-.L60    # FFI_TYPE_UINT64\n+\t.long .L48-.L60    # FFI_TYPE_SINT64\n+\t.long .L44-.L60    # FFI_TYPE_STRUCT\n+\t.long .L50-.L60    # FFI_TYPE_POINTER\n+\n+\n+# case double\n+.L46:   \n+        lfd %f1,0(%r5)\n+\tb .L44\n+\n+# case float\n+.L47:\n+\tlfs %f1,0(%r5)\n+\tb .L44\n+\t\n+# case long long\n+.L48:\n+\tlwz %r3,0(%r5)\n+\tlwz %r4,4(%r5)\n+\tb .L44\n+\t\n+# case default / int32 / pointer\n+.L50:\n+\tlwz %r3,0(%r5)\n+\tb .L44\n+\t\n+# case signed int8\t\n+.L55:\n+\taddi %r5,%r5,3\n+\tlbz %r3,0(%r5)\n+\textsb %r3,%r3\n+\tb .L44\n+\n+# case unsigned int8\t\n+.L56:\n+\taddi %r5,%r5,3\n+        lbz %r3,0(%r5)\n+\tb .L44\n+\n+# case signed int16\n+.L57:\n+\taddi %r5,%r5,2\n+\tlhz %r3,0(%r5)\n+\textsh %r3,%r3\n+\tb .L44\n+\n+#case unsigned int16\n+.L58:\t\n+\taddi %r5,%r5,2\n+\tlhz %r3,0(%r5)\n+\n+# case void / done\t\n+.L44:\n+\t\n+\tlwz %r11,0(%r1)\n+\tlwz %r0,4(%r11)\n+\tmtlr %r0\n+\tlwz %r31,-4(%r11)\n+\tmr %r1,%r11\n+\tblr\n+END(ffi_closure_SYSV)\n+\n+\n+\n+"}]}