{"sha": "2cc21497379c4b3fc3884c7e224c5c5a00d61c28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNjMjE0OTczNzljNGIzZmMzODg0YzdlMjI0YzVjNWEwMGQ2MWMyOA==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2002-06-28T20:26:16Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-06-28T20:26:16Z"}, "message": "m68hc11.c (autoinc_mode): New function.\n\n\t* config/m68hc11/m68hc11.c (autoinc_mode): New function.\n\t(m68hc11_make_autoinc_notes): New function.\n\t(m68hc11_split_move): Be very cautious when spliting a move with\n\tauto increment/decrement modes because this may result in incompatible\n\tdirections; add REG_INC notes to the resulting insn for CSE reg.\n\nFrom-SVN: r55076", "tree": {"sha": "26aa611941231af13655b753b6775cf0a700ed8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26aa611941231af13655b753b6775cf0a700ed8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cc21497379c4b3fc3884c7e224c5c5a00d61c28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cc21497379c4b3fc3884c7e224c5c5a00d61c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cc21497379c4b3fc3884c7e224c5c5a00d61c28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cc21497379c4b3fc3884c7e224c5c5a00d61c28/comments", "author": null, "committer": null, "parents": [{"sha": "ba18d6d38bdad235a43eb8bdefa417031d5f042b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba18d6d38bdad235a43eb8bdefa417031d5f042b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba18d6d38bdad235a43eb8bdefa417031d5f042b"}], "stats": {"total": 215, "additions": 165, "deletions": 50}, "files": [{"sha": "502b645d90aaf60ddc8d20f5b0cc52ab9cf449e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cc21497379c4b3fc3884c7e224c5c5a00d61c28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cc21497379c4b3fc3884c7e224c5c5a00d61c28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2cc21497379c4b3fc3884c7e224c5c5a00d61c28", "patch": "@@ -1,3 +1,11 @@\n+2002-06-28  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/m68hc11.c (autoinc_mode): New function.\n+\t(m68hc11_make_autoinc_notes): New function.\n+\t(m68hc11_split_move): Be very cautious when spliting a move with\n+\tauto increment/decrement modes because this may result in incompatible\n+\tdirections; add REG_INC notes to the resulting insn for CSE reg.\n+\n 2002-06-28  Stephane Carrez  <Stephane.Carrez@nerim.fr>\n \n \t* config/m68hc11/m68hc11.c (register_indirect_p): For 68HC12 a constant"}, {"sha": "4fb054d348e0c90438d1263dafb0d401d5965d42", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 157, "deletions": 50, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cc21497379c4b3fc3884c7e224c5c5a00d61c28/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cc21497379c4b3fc3884c7e224c5c5a00d61c28/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=2cc21497379c4b3fc3884c7e224c5c5a00d61c28", "patch": "@@ -2670,38 +2670,46 @@ m68hc11_expand_compare_and_branch (code, op0, op1, label)\n   return 0;\n }\n \n-/* Return 1 if the TO and FROM operands contain compatible address\n-   increment and decrement modes for a split_move.  One of the two\n-   operands must not use an autoinc mode or both must go in the\n-   same direction.  */\n+/* Return the increment/decrement mode of a MEM if it is such.\n+   Return CONST if it is anything else.  */\n static int\n-m68hc11_autoinc_compatible_p (to, from)\n-     rtx to, from;\n+autoinc_mode (x)\n+     rtx x;\n {\n-  enum { INCOP, DECOP } type_to, type_from;\n+  if (GET_CODE (x) != MEM)\n+    return CONST;\n \n-  /* If one of them is not a MEM, it is ok.  */\n-  if (GET_CODE (to) != MEM || GET_CODE (from) != MEM)\n-    return 1;\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) == PRE_INC\n+      || GET_CODE (x) == PRE_DEC\n+      || GET_CODE (x) == POST_INC\n+      || GET_CODE (x) == POST_DEC)\n+    return GET_CODE (x);\n \n-  to = XEXP (to, 0);\n-  from = XEXP (from, 0);\n+  return CONST;\n+}\n \n-  if (GET_CODE (to) == PRE_INC || GET_CODE (to) == POST_INC)\n-    type_to = INCOP;\n-  else if (GET_CODE (to) == PRE_DEC || GET_CODE (to) == POST_DEC)\n-    type_to = DECOP;\n-  else\n-    return 1;\n+static int\n+m68hc11_make_autoinc_notes (x, data)\n+     rtx *x;\n+     void *data;\n+{\n+  rtx insn;\n   \n-  if (GET_CODE (from) == PRE_INC || GET_CODE (from) == POST_INC)\n-    type_from = INCOP;\n-  else if (GET_CODE (from) == PRE_DEC || GET_CODE (from) == POST_DEC)\n-    type_from = DECOP;\n-  else\n-    return 1;\n+  switch (GET_CODE (*x))\n+    {\n+    case PRE_DEC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case POST_INC:\n+      insn = (rtx) data;\n+      REG_NOTES (insn) = alloc_EXPR_LIST (REG_INC, XEXP (*x, 0),\n+                                          REG_NOTES (insn));\n+      return -1;\n \n-  return type_to == type_from;\n+    default:\n+      return 0;\n+    }\n }\n \n /* Split a DI, SI or HI move into several smaller move operations.\n@@ -2713,41 +2721,116 @@ m68hc11_split_move (to, from, scratch)\n {\n   rtx low_to, low_from;\n   rtx high_to, high_from;\n+  rtx insn;\n   enum machine_mode mode;\n   int offset = 0;\n+  int autoinc_from = autoinc_mode (from);\n+  int autoinc_to = autoinc_mode (to);\n \n   mode = GET_MODE (to);\n-  if (GET_MODE_SIZE (mode) == 8)\n-    mode = SImode;\n-  else if (GET_MODE_SIZE (mode) == 4)\n-    mode = HImode;\n-  else\n-    mode = QImode;\n \n   /* If the TO and FROM contain autoinc modes that are not compatible\n      together (one pop and the other a push), we must change one to\n      an offsetable operand and generate an appropriate add at the end.  */\n-  if (TARGET_M6812 && m68hc11_autoinc_compatible_p (to, from) == 0)\n+  if (TARGET_M6812 && GET_MODE_SIZE (mode) > 2)\n     {\n       rtx reg;\n       int code;\n \n-      /* Decide to change the source.  */\n-      code = GET_CODE (XEXP (from, 0));\n-      reg = XEXP (XEXP (from, 0), 0);\n-      offset = GET_MODE_SIZE (GET_MODE (from));\n-      if (code == PRE_DEC || code == POST_DEC)\n-        offset = -offset;\n+      /* The source uses an autoinc mode which is not compatible with\n+         a split (this would result in a word swap).  */\n+      if (autoinc_from == PRE_INC || autoinc_from == POST_DEC)\n+        {\n+          code = GET_CODE (XEXP (from, 0));\n+          reg = XEXP (XEXP (from, 0), 0);\n+          offset = GET_MODE_SIZE (GET_MODE (from));\n+          if (code == POST_DEC)\n+            offset = -offset;\n+\n+          if (code == PRE_INC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+\n+          m68hc11_split_move (to, gen_rtx_MEM (GET_MODE (from), reg), scratch);\n+          if (code == POST_DEC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+          return;\n+        }\n+\n+      /* Likewise for destination.  */\n+      if (autoinc_to == PRE_INC || autoinc_to == POST_DEC)\n+        {\n+          code = GET_CODE (XEXP (to, 0));\n+          reg = XEXP (XEXP (to, 0), 0);\n+          offset = GET_MODE_SIZE (GET_MODE (to));\n+          if (code == POST_DEC)\n+            offset = -offset;\n+\n+          if (code == PRE_INC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+\n+          m68hc11_split_move (gen_rtx_MEM (GET_MODE (to), reg), from, scratch);\n+          if (code == POST_DEC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+          return;\n+        }\n \n-      if (code == PRE_DEC || code == PRE_INC)\n-        emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n-      m68hc11_split_move (to, gen_rtx_MEM (GET_MODE (from), reg), scratch);\n-      if (code == POST_DEC || code == POST_INC)\n-        emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+      /* The source and destination auto increment modes must be compatible\n+         with each other: same direction.  */\n+      if ((autoinc_to != autoinc_from\n+           && autoinc_to != CONST && autoinc_from != CONST)\n+          /* The destination address register must not be used within\n+             the source operand because the source address would change\n+             while doing the copy.  */\n+          || (autoinc_to != CONST\n+              && reg_mentioned_p (XEXP (XEXP (to, 0), 0), from)\n+              && !IS_STACK_PUSH (to)))\n+        {\n+          /* Must change the destination.  */\n+          code = GET_CODE (XEXP (to, 0));\n+          reg = XEXP (XEXP (to, 0), 0);\n+          offset = GET_MODE_SIZE (GET_MODE (to));\n+          if (code == PRE_DEC || code == POST_DEC)\n+            offset = -offset;\n+\n+          if (code == PRE_DEC || code == PRE_INC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+          m68hc11_split_move (gen_rtx_MEM (GET_MODE (to), reg), from, scratch);\n+          if (code == POST_DEC || code == POST_INC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+\n+          return;\n+        }\n \n-      return;\n+      /* Likewise, the source address register must not be used within\n+         the destination operand.  */\n+      if (autoinc_from != CONST\n+          && reg_mentioned_p (XEXP (XEXP (from, 0), 0), to)\n+          && !IS_STACK_PUSH (to))\n+        {\n+          /* Must change the source.  */\n+          code = GET_CODE (XEXP (from, 0));\n+          reg = XEXP (XEXP (from, 0), 0);\n+          offset = GET_MODE_SIZE (GET_MODE (from));\n+          if (code == PRE_DEC || code == POST_DEC)\n+            offset = -offset;\n+\n+          if (code == PRE_DEC || code == PRE_INC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+          m68hc11_split_move (to, gen_rtx_MEM (GET_MODE (from), reg), scratch);\n+          if (code == POST_DEC || code == POST_INC)\n+            emit_insn (gen_addhi3 (reg, reg, GEN_INT (offset)));\n+\n+          return;\n+        }\n     }\n \n+  if (GET_MODE_SIZE (mode) == 8)\n+    mode = SImode;\n+  else if (GET_MODE_SIZE (mode) == 4)\n+    mode = HImode;\n+  else\n+    mode = QImode;\n+\n   if (TARGET_M6812\n       && IS_STACK_PUSH (to)\n       && reg_mentioned_p (gen_rtx (REG, HImode, HARD_SP_REGNUM), from))\n@@ -2783,6 +2866,25 @@ m68hc11_split_move (to, from, scratch)\n       high_from = adjust_address (high_from, mode, offset);\n       low_from = high_from;\n     }\n+\n+  /* When copying with a POST_INC mode, we must copy the\n+     high part and then the low part to guarantee a correct\n+     32/64-bit copy.  */\n+  if (TARGET_M6812\n+      && GET_MODE_SIZE (mode) >= 2\n+      && autoinc_from != autoinc_to\n+      && (autoinc_from == POST_INC || autoinc_to == POST_INC))\n+    {\n+      rtx swap;\n+\n+      swap = low_to;\n+      low_to = high_to;\n+      high_to = swap;\n+\n+      swap = low_from;\n+      low_from = high_from;\n+      high_from = swap;\n+    }\n   if (mode == SImode)\n     {\n       m68hc11_split_move (low_to, low_from, scratch);\n@@ -2800,18 +2902,23 @@ m68hc11_split_move (to, from, scratch)\n \t       && (!m68hc11_register_indirect_p (to, GET_MODE (to))\n \t\t   || m68hc11_small_indexed_indirect_p (to, GET_MODE (to)))))\n     {\n-      emit_move_insn (low_to, low_from);\n-      emit_move_insn (high_to, high_from);\n+      insn = emit_move_insn (low_to, low_from);\n+      for_each_rtx (&PATTERN (insn), m68hc11_make_autoinc_notes, insn);\n+\n+      insn = emit_move_insn (high_to, high_from);\n+      for_each_rtx (&PATTERN (insn), m68hc11_make_autoinc_notes, insn);\n     }\n   else\n     {\n-      rtx insn;\n-\n-      emit_move_insn (scratch, low_from);\n+      insn = emit_move_insn (scratch, low_from);\n+      for_each_rtx (&PATTERN (insn), m68hc11_make_autoinc_notes, insn);\n       insn = emit_move_insn (low_to, scratch);\n+      for_each_rtx (&PATTERN (insn), m68hc11_make_autoinc_notes, insn);\n \n-      emit_move_insn (scratch, high_from);\n+      insn = emit_move_insn (scratch, high_from);\n+      for_each_rtx (&PATTERN (insn), m68hc11_make_autoinc_notes, insn);\n       insn = emit_move_insn (high_to, scratch);\n+      for_each_rtx (&PATTERN (insn), m68hc11_make_autoinc_notes, insn);\n     }\n }\n "}]}