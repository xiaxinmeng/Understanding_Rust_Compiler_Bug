{"sha": "38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiMTlhOTI0NzIzNGU2Y2ZiNTQ3NjZjZjIxYmZkYjZhNDI5ZmJiNA==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2006-07-14T17:14:55Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2006-07-14T17:14:55Z"}, "message": "stacktrace.cc (_Jv_StackTrace::GetStackTrace): Unconditionally use _Unwind_Backtrace().\n\n\t* stacktrace.cc (_Jv_StackTrace::GetStackTrace): Unconditionally use\n\t_Unwind_Backtrace().\n\t(_Jv_StackTrace::GetCallerInfo): Enable even for targets using SJLJ\n\tEH.\n\t(_Jv_StackTrace::GetClassContext): Unconditionally use\n\t_Unwind_Backtrace().\n\t(_Jv_StackTrace::GetFirstNonSystemClassLoader): Likewise.\n\t* sysdep/i386/backtrace.h (HAVE_FALLBACK_BACKTRACE): Do not define.\n\t(_Unwind_GetIPInfo): Define macro if SJLJ EH is in use.\n\t(_Unwind_GetRegionStart): Likewise.\n\t(_Unwind_Backtrace): Likewise.\n\t(fallback_backtrace): Accept additional unwind trace function\n\targument.  Call it during unwinding.  Stop when any of _Jv_RunMain(),\n\t_Jv_ThreadStart() or main() is seen during unwinding.\n\t* sysdep/generic/backtrace.h (fallback_backtrace): Accept an\n\tadditional unwind trace function argument.\n\nFrom-SVN: r115449", "tree": {"sha": "1ac7aeccd28a2e9650dfd7a152bfcbe590ed728e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac7aeccd28a2e9650dfd7a152bfcbe590ed728e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/comments", "author": null, "committer": null, "parents": [{"sha": "47a4949a8ea5f52c72cba00912fd652c57197eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a4949a8ea5f52c72cba00912fd652c57197eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a4949a8ea5f52c72cba00912fd652c57197eae"}], "stats": {"total": 126, "additions": 77, "deletions": 49}, "files": [{"sha": "4e1710515fb72e695bd70bd4a4b77e553478d323", "filename": "libjava/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "patch": "@@ -1,3 +1,22 @@\n+2006-07-14  Ranjit Mathew  <rmathew@gcc.gnu.org>\n+\n+\t* stacktrace.cc (_Jv_StackTrace::GetStackTrace): Unconditionally use\n+\t_Unwind_Backtrace().\n+\t(_Jv_StackTrace::GetCallerInfo): Enable even for targets using SJLJ\n+\tEH.\n+\t(_Jv_StackTrace::GetClassContext): Unconditionally use\n+\t_Unwind_Backtrace().\n+\t(_Jv_StackTrace::GetFirstNonSystemClassLoader): Likewise.\n+\t* sysdep/i386/backtrace.h (HAVE_FALLBACK_BACKTRACE): Do not define.\n+\t(_Unwind_GetIPInfo): Define macro if SJLJ EH is in use.\n+\t(_Unwind_GetRegionStart): Likewise.\n+\t(_Unwind_Backtrace): Likewise.\n+\t(fallback_backtrace): Accept additional unwind trace function\n+\targument.  Call it during unwinding.  Stop when any of _Jv_RunMain(),\n+\t_Jv_ThreadStart() or main() is seen during unwinding.\n+\t* sysdep/generic/backtrace.h (fallback_backtrace): Accept an\n+\tadditional unwind trace function argument.\n+\n 2006-07-14  Gary Benson  <gbenson@redhat.com>\n \n \t* java/io/File.java (internalExists): New method."}, {"sha": "ba971ddc13e8869ec0c7c706cdb6d972d89506a6", "filename": "libjava/stacktrace.cc", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fstacktrace.cc?ref=38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "patch": "@@ -153,13 +153,7 @@ _Jv_StackTrace::GetStackTrace(void)\n   _Jv_UnwindState state (trace_size);\n   state.frames = (_Jv_StackFrame *) &frames;\n \n-#ifdef SJLJ_EXCEPTIONS\n-  // The Unwind interface doesn't work with the SJLJ exception model.\n-  // Fall back to a platform-specific unwinder.\n-  fallback_backtrace (&state);\n-#else /* SJLJ_EXCEPTIONS */  \n   _Unwind_Backtrace (UnwindTraceFn, &state);\n-#endif /* SJLJ_EXCEPTIONS */\n   \n   // Copy the trace and return it.\n   int traceSize = sizeof (_Jv_StackTrace) + \n@@ -423,7 +417,6 @@ void\n _Jv_StackTrace::GetCallerInfo (jclass checkClass, jclass *caller_class,\n   _Jv_Method **caller_meth)\n {\n-#ifndef SJLJ_EXCEPTIONS\n   int trace_size = 20;\n   _Jv_StackFrame frames[trace_size];\n   _Jv_UnwindState state (trace_size);\n@@ -447,9 +440,6 @@ _Jv_StackTrace::GetCallerInfo (jclass checkClass, jclass *caller_class,\n     *caller_class = trace_data.foundClass;\n   if (caller_meth)\n     *caller_meth = trace_data.foundMeth;\n-#else\n-  return;\n-#endif\n }\n \n // Return a java array containing the Java classes on the stack above CHECKCLASS.\n@@ -466,13 +456,7 @@ _Jv_StackTrace::GetClassContext (jclass checkClass)\n   //JvSynchronized (ncodeMap);\n   UpdateNCodeMap ();\n \n-#ifdef SJLJ_EXCEPTIONS\n-  // The Unwind interface doesn't work with the SJLJ exception model.\n-  // Fall back to a platform-specific unwinder.\n-  fallback_backtrace (&state);\n-#else /* SJLJ_EXCEPTIONS */  \n   _Unwind_Backtrace (UnwindTraceFn, &state);\n-#endif /* SJLJ_EXCEPTIONS */  \n \n   // Count the number of Java frames on the stack.\n   int jframe_count = 0;\n@@ -543,13 +527,7 @@ _Jv_StackTrace::GetFirstNonSystemClassLoader ()\n   //JvSynchronized (ncodeMap);\n   UpdateNCodeMap ();\n   \n-#ifdef SJLJ_EXCEPTIONS\n-  // The Unwind interface doesn't work with the SJLJ exception model.\n-  // Fall back to a platform-specific unwinder.\n-  fallback_backtrace (&state);\n-#else /* SJLJ_EXCEPTIONS */  \n   _Unwind_Backtrace (UnwindTraceFn, &state);\n-#endif /* SJLJ_EXCEPTIONS */  \n \n   if (state.trace_data)\n     return (ClassLoader *) state.trace_data;"}, {"sha": "21138aef775300a8cfed4d2584bdfce676eae911", "filename": "libjava/sysdep/generic/backtrace.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2Fsysdep%2Fgeneric%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2Fsysdep%2Fgeneric%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fgeneric%2Fbacktrace.h?ref=38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "patch": "@@ -1,6 +1,6 @@\n // backtrace.h - Fallback backtrace implementation. default implementation.\n \n-/* Copyright (C) 2005  Free Software Foundation\n+/* Copyright (C) 2005, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -13,10 +13,11 @@ details.  */\n \n #include <java-stack.h>\n \n-/* Store return addresses of the current program stack in\n-   STATE and return the exact number of values stored.  */\n-void\n-fallback_backtrace (_Jv_UnwindState *)\n+/* Unwind through the call stack calling TRACE_FN with STATE for every stack\n+   frame.  Returns the reason why the unwinding was stopped.  */\n+_Unwind_Reason_Code\n+fallback_backtrace (_Unwind_Trace_Fn, _Jv_UnwindState *)\n {\n+  return _URC_NO_REASON;\n }\n #endif"}, {"sha": "9fe12b118a9b02fcea8f765cb73d45b06f998b3a", "filename": "libjava/sysdep/i386/backtrace.h", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b19a9247234e6cfb54766cf21bfdb6a429fbb4/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fi386%2Fbacktrace.h?ref=38b19a9247234e6cfb54766cf21bfdb6a429fbb4", "patch": "@@ -13,21 +13,46 @@ details.  */\n \n #include <java-stack.h>\n \n-#define HAVE_FALLBACK_BACKTRACE\n+extern int main (int, char **);\n \n-/* Store return addresses of the current program stack in\n-   STATE and return the exact number of values stored.  */\n-void\n-fallback_backtrace (_Jv_UnwindState *state)\n+/* The context used to keep track of our position while unwinding through\n+   the call stack.  */\n+struct _Unwind_Context\n+{\n+  /* The starting address of the method.  */\n+  _Jv_uintptr_t meth_addr;\n+\n+  /* The return address in the method.  */\n+  _Jv_uintptr_t ret_addr;\n+};\n+\n+#ifdef SJLJ_EXCEPTIONS\n+\n+#undef _Unwind_GetIPInfo\n+#define _Unwind_GetIPInfo(ctx,ip_before_insn) \\\n+  (*(ip_before_insn) = 1, (ctx)->ret_addr)\n+\n+#undef _Unwind_GetRegionStart\n+#define _Unwind_GetRegionStart(ctx) \\\n+  ((ctx)->meth_addr)\n+\n+#undef _Unwind_Backtrace\n+#define _Unwind_Backtrace(trace_fn,state_ptr) \\\n+  (fallback_backtrace (trace_fn, state_ptr))\n+\n+#endif /* SJLJ_EXCEPTIONS */\n+\n+/* Unwind through the call stack calling TRACE_FN with STATE for each stack\n+   frame.  Returns the reason why the unwinding was stopped.  */\n+_Unwind_Reason_Code\n+fallback_backtrace (_Unwind_Trace_Fn trace_fn, _Jv_UnwindState *state)\n {\n   register _Jv_uintptr_t *_ebp __asm__ (\"ebp\");\n   register _Jv_uintptr_t _esp __asm__ (\"esp\");\n   _Jv_uintptr_t rfp;\n+  _Unwind_Context ctx;\n \n-  int i = state->pos;\n-  for (rfp = *_ebp;\n-       rfp && i < state->length;\n-       rfp = *(_Jv_uintptr_t *)rfp)\n+  for (rfp = *_ebp; rfp; rfp = *(_Jv_uintptr_t *)rfp)\n     {\n       /* Sanity checks to eliminate dubious-looking frame pointer chains.\n          The frame pointer should be a 32-bit word-aligned stack address.\n@@ -42,12 +67,7 @@ fallback_backtrace (_Jv_UnwindState *state)\n \n       /* Get the return address in the calling function.  This is stored on\n          the stack just before the value of the old frame pointer.  */\n-      _Jv_uintptr_t ret_addr\n-        = *(_Jv_uintptr_t *)(rfp + sizeof (_Jv_uintptr_t));\n-\n-      state->frames[i].type = frame_native;\n-      state->frames[i].ip = (void *)(ret_addr - 1);\n-      state->frames[i].start_ip = NULL;\n+      ctx.ret_addr = *(_Jv_uintptr_t *)(rfp + sizeof (_Jv_uintptr_t));\n \n       /* Try to locate a \"pushl %ebp; movl %esp, %ebp\" function prologue\n          by scanning backwards at even addresses below the return address.\n@@ -56,7 +76,8 @@ fallback_backtrace (_Jv_UnwindState *state)\n          FIXME: This is not robust and will probably give us false positives,\n          but this is about the best we can do if we do not have DWARF-2 unwind\n          information based exception handling.  */\n-      _Jv_uintptr_t scan_addr = (ret_addr & 0xFFFFFFFE) - 2;\n+      ctx.meth_addr = (_Jv_uintptr_t)NULL;\n+      _Jv_uintptr_t scan_addr = (ctx.ret_addr & 0xFFFFFFFE) - 2;\n       _Jv_uintptr_t limit_addr\n         = (scan_addr > 1024 * 1024) ? (scan_addr - 1024 * 1024) : 2;\n       for ( ; scan_addr >= limit_addr; scan_addr -= 2)\n@@ -65,17 +86,26 @@ fallback_backtrace (_Jv_UnwindState *state)\n           if (scan_bytes[0] == 0x55 && scan_bytes[1] == 0x89\n               && scan_bytes[2] == 0xE5)\n             {\n-              state->frames[i].start_ip = (void *)scan_addr;\n+              ctx.meth_addr = scan_addr;\n               break;\n             }\n         }\n \n-      /* No need to unwind beyond JvRunMain().  */\n-      if (state->frames[i].start_ip == (void *)JvRunMain)\n-        break;\n+      /* Now call the unwinder callback function. */\n+      if (trace_fn != NULL)\n+        (*trace_fn) (&ctx, state);\n \n-      i++;\n+      /* No need to unwind beyond _Jv_RunMain(), _Jv_ThreadStart or\n+         main().  */\n+      void *jv_runmain\n+        = (void *)(void (*)(JvVMInitArgs *, jclass, const char *, int,\n+                            const char **, bool))_Jv_RunMain;\n+      if (ctx.meth_addr == (_Jv_uintptr_t)jv_runmain\n+          || ctx.meth_addr == (_Jv_uintptr_t)_Jv_ThreadStart\n+          || (ctx.meth_addr - (_Jv_uintptr_t)main) < 16)\n+        break;\n     }\n-  state->pos = i;\n+\n+  return _URC_NO_REASON;\n }\n #endif"}]}