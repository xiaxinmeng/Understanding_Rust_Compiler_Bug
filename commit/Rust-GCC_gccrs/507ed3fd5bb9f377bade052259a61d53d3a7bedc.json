{"sha": "507ed3fd5bb9f377bade052259a61d53d3a7bedc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3ZWQzZmQ1YmI5ZjM3N2JhZGUwNTIyNTlhNjFkNTNkM2E3YmVkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T10:30:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T10:30:33Z"}, "message": "Refine previous change.\n\nFrom-SVN: r146099", "tree": {"sha": "1feb3eee42bf093f73ea336321abd01f6e7f7891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1feb3eee42bf093f73ea336321abd01f6e7f7891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/507ed3fd5bb9f377bade052259a61d53d3a7bedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507ed3fd5bb9f377bade052259a61d53d3a7bedc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/507ed3fd5bb9f377bade052259a61d53d3a7bedc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507ed3fd5bb9f377bade052259a61d53d3a7bedc/comments", "author": null, "committer": null, "parents": [{"sha": "8aec446b9825afac7364819ffa8ea00307fbaaff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aec446b9825afac7364819ffa8ea00307fbaaff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aec446b9825afac7364819ffa8ea00307fbaaff"}], "stats": {"total": 105, "additions": 50, "deletions": 55}, "files": [{"sha": "fa76b9630ca70088cb1952eae024636a06814221", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507ed3fd5bb9f377bade052259a61d53d3a7bedc/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507ed3fd5bb9f377bade052259a61d53d3a7bedc/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=507ed3fd5bb9f377bade052259a61d53d3a7bedc", "patch": "@@ -2936,9 +2936,10 @@ package body Exp_Ch4 is\n       --  and their unrestricted access used instead of the coextension.\n \n       function Size_In_Storage_Elements (E : Entity_Id) return Node_Id;\n-      --  Given a type E, returns a node representing the code to compute the\n-      --  size in storage elements for the given type. This is not as trivial\n-      --  as one might expect, as explained in the body.\n+      --  Given a constrained array type E, returns a node representing the\n+      --  code to compute the size in storage elements for the given type.\n+      --  This is done without using the attribute (which malfunctins for\n+      --  large sizes ???)\n \n       ---------------------------------------\n       -- Complete_Coextension_Finalization --\n@@ -3180,10 +3181,7 @@ package body Exp_Ch4 is\n          --  32-bit limit on a 32-bit machine, and precisely the trouble\n          --  is that we get overflows when sizes are greater than 2**31.\n \n-         --  So what we end up doing is using this expression for non-array\n-         --  types, where it is not quite right, but should be good enough\n-         --  most of the time. But for non-packed arrays, instead we compute\n-         --  the expression:\n+         --  So what we end up doing for array types is to use the expression:\n \n          --    number-of-elements * component_type'Max_Size_In_Storage_Elements\n \n@@ -3192,48 +3190,38 @@ package body Exp_Ch4 is\n          --  are too large, and which in the absence of a check results in\n          --  undetected chaos ???\n \n-         if Is_Array_Type (E) and then Is_Constrained (E) then\n-            declare\n-               Len : Node_Id;\n-               Res : Node_Id;\n-\n-            begin\n-               for J in 1 .. Number_Dimensions (E) loop\n-                  Len :=\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix         => New_Occurrence_Of (E, Loc),\n-                      Attribute_Name => Name_Length,\n-                      Expressions    => New_List (\n-                        Make_Integer_Literal (Loc, J)));\n-\n-                  if J = 1 then\n-                     Res := Len;\n+         declare\n+            Len : Node_Id;\n+            Res : Node_Id;\n \n-                  else\n-                     Res :=\n-                       Make_Op_Multiply (Loc,\n-                         Left_Opnd  => Res,\n-                         Right_Opnd => Len);\n-                  end if;\n-               end loop;\n+         begin\n+            for J in 1 .. Number_Dimensions (E) loop\n+               Len :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Occurrence_Of (E, Loc),\n+                   Attribute_Name => Name_Length,\n+                   Expressions    => New_List (\n+                     Make_Integer_Literal (Loc, J)));\n \n-               return\n-                 Make_Op_Multiply (Loc,\n-                   Left_Opnd  => Len,\n-                   Right_Opnd =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix => New_Occurrence_Of (Component_Type (E), Loc),\n-                       Attribute_Name => Name_Max_Size_In_Storage_Elements));\n-            end;\n+               if J = 1 then\n+                  Res := Len;\n \n-            --  Here for other than non-bit-packed array\n+               else\n+                  Res :=\n+                    Make_Op_Multiply (Loc,\n+                      Left_Opnd  => Res,\n+                      Right_Opnd => Len);\n+               end if;\n+            end loop;\n \n-         else\n             return\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Occurrence_Of (E, Loc),\n-                Attribute_Name => Name_Max_Size_In_Storage_Elements);\n-         end if;\n+              Make_Op_Multiply (Loc,\n+                Left_Opnd  => Len,\n+                Right_Opnd =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix => New_Occurrence_Of (Component_Type (E), Loc),\n+                    Attribute_Name => Name_Max_Size_In_Storage_Elements));\n+         end;\n       end Size_In_Storage_Elements;\n \n    --  Start of processing for Expand_N_Allocator\n@@ -3363,18 +3351,25 @@ package body Exp_Ch4 is\n          --    raise Storage_Error;\n          --  end if;\n \n-         --  where 3.5 gigabytes is a constant large enough to accomodate\n-         --  any reasonable request for\n+         --  where 3.5 gigabytes is a constant large enough to accomodate any\n+         --  reasonable request for. But we can't do it this way because at\n+         --  least at the moment we don't compute this attribute right, and\n+         --  can silently give wrong results when the result gets large. Since\n+         --  this is all about large results, that's bad, so instead we only\n+         --  applly the check for constrained arrays, and manually compute the\n+         --  value of the attribute ???\n \n-         Insert_Action (N,\n-           Make_Raise_Storage_Error (Loc,\n-             Condition =>\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd => Size_In_Storage_Elements (Etyp),\n-                 Right_Opnd =>\n-                   Make_Integer_Literal (Loc,\n-                     Intval => Uint_7 * (Uint_2 ** 29))),\n-             Reason    => SE_Object_Too_Large));\n+         if Is_Array_Type (Etyp) and then Is_Constrained (Etyp) then\n+            Insert_Action (N,\n+              Make_Raise_Storage_Error (Loc,\n+                Condition =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd  => Size_In_Storage_Elements (Etyp),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc,\n+                        Intval => Uint_7 * (Uint_2 ** 29))),\n+                Reason    => SE_Object_Too_Large));\n+         end if;\n       end if;\n \n       --  Handle case of qualified expression (other than optimization above)"}]}