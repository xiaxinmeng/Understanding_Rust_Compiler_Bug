{"sha": "8dc2499aa62f768c6395c9754b8cabc1ce25c494", "node_id": "C_kwDOANBUbNoAKDhkYzI0OTlhYTYyZjc2OGM2Mzk1Yzk3NTRiOGNhYmMxY2UyNWM0OTQ", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-02-11T22:53:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-02-11T23:01:19Z"}, "message": "libgo: update to Go1.18beta2\n\ngotools/\n\t* Makefile.am (go_cmd_cgo_files): Add ast_go118.go\n\t(check-go-tool): Copy golang.org/x/tools directories.\n\t* Makefile.in: Regenerate.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/384695", "tree": {"sha": "43d7fd2bbfd7ad8c9625a718a5e8718889351994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43d7fd2bbfd7ad8c9625a718a5e8718889351994"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc2499aa62f768c6395c9754b8cabc1ce25c494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc2499aa62f768c6395c9754b8cabc1ce25c494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc2499aa62f768c6395c9754b8cabc1ce25c494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc2499aa62f768c6395c9754b8cabc1ce25c494/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a56779dbc4e2d9c15be8d31e36f2f59be7331a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8"}], "stats": {"total": 120526, "additions": 84229, "deletions": 36297}, "files": [{"sha": "4e6bac7b7d50838c2993a115fff0aacd28d22bda", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,4 +1,4 @@\n-b0dcd2d1e5e73952408b9f2d4d86ae12d102b20c\n+47380f733ca932384e59492d2f04374edd8ec95e\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "46481cb51739f2352cc9f04bbb47241045b16984", "filename": "gotools/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -62,6 +62,7 @@ go_cmd_gofmt_files = \\\n \n go_cmd_cgo_files = \\\n \t$(cmdsrcdir)/cgo/ast.go \\\n+\t$(cmdsrcdir)/cgo/ast_go118.go \\\n \t$(cmdsrcdir)/cgo/doc.go \\\n \t$(cmdsrcdir)/cgo/gcc.go \\\n \t$(cmdsrcdir)/cgo/godefs.go \\\n@@ -224,6 +225,7 @@ check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \tcp -r $(libgosrcdir)/golang.org/x/mod check-go-dir/src/cmd/vendor/golang.org/x/\n \tcp -r $(libgosrcdir)/golang.org/x/crypto check-go-dir/src/cmd/vendor/golang.org/x/\n \tcp -r $(libgosrcdir)/golang.org/x/xerrors check-go-dir/src/cmd/vendor/golang.org/x/\n+\tcp -r $(libgosrcdir)/golang.org/x/tools check-go-dir/src/cmd/vendor/golang.org/x/\n \tcp $(libgodir)/objabi.go check-go-dir/src/cmd/internal/objabi/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\"}, {"sha": "1bcf8276ca3aee08756c60b5b558f9f6cb12bd4f", "filename": "gotools/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -366,6 +366,7 @@ go_cmd_gofmt_files = \\\n \n go_cmd_cgo_files = \\\n \t$(cmdsrcdir)/cgo/ast.go \\\n+\t$(cmdsrcdir)/cgo/ast_go118.go \\\n \t$(cmdsrcdir)/cgo/doc.go \\\n \t$(cmdsrcdir)/cgo/gcc.go \\\n \t$(cmdsrcdir)/cgo/godefs.go \\\n@@ -896,6 +897,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/mod check-go-dir/src/cmd/vendor/golang.org/x/\n @NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/crypto check-go-dir/src/cmd/vendor/golang.org/x/\n @NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/xerrors check-go-dir/src/cmd/vendor/golang.org/x/\n+@NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/tools check-go-dir/src/cmd/vendor/golang.org/x/\n @NATIVE_TRUE@\tcp $(libgodir)/objabi.go check-go-dir/src/cmd/internal/objabi/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\"}, {"sha": "662af9af882860dfbe5f9122ce5cf7c2c6ea4fec", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,4 +1,4 @@\n-21a4e67ad58e3c4a7c5254f60cda5be5c3c450ff\n+41f485b9a7d8fd647c415be1d11b612063dff21c\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "be889f2a984d91b9e9f4b4415037da235a4067ea", "filename": "libgo/Makefile.am", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -220,6 +220,7 @@ toolexeclibgodatabasesql_DATA = \\\n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n \n toolexeclibgodebug_DATA = \\\n+\tdebug/buildinfo.gox \\\n \tdebug/dwarf.gox \\\n \tdebug/elf.gox \\\n \tdebug/gosym.gox \\\n@@ -325,6 +326,7 @@ toolexeclibgonetdir = $(toolexeclibgodir)/net\n toolexeclibgonet_DATA = \\\n \tnet/http.gox \\\n \tnet/mail.gox \\\n+\tnet/netip.gox \\\n \tnet/rpc.gox \\\n \tnet/smtp.gox \\\n \tnet/textproto.gox \\\n@@ -429,6 +431,7 @@ noinst_DATA = \\\n \tinternal/testenv.gox \\\n \tinternal/trace.gox \\\n \tnet/internal/socktest.gox \\\n+\tos/exec/internal/fdtest.gox \\\n \tos/signal/internal/pty.gox \\\n \treflect/internal/example1.gox \\\n \treflect/internal/example2.gox\n@@ -483,53 +486,68 @@ version.go: s-version; @true\n s-version: Makefile\n \trm -f version.go.tmp\n \techo \"package sys\" > version.go.tmp\n-\techo 'const GOARCH = \"'$(GOARCH)'\"' >> version.go.tmp\n-\techo 'const GOOS = \"'$(GOOS)'\"' >> version.go.tmp\n \techo 'const GccgoToolDir = \"$(libexecsubdir)\"' >> version.go.tmp\n \techo 'const StackGuardMultiplierDefault = 1' >> version.go.tmp\n-\techo >> version.go.tmp\n-\techo \"const (\" >> version.go.tmp\n-\techo \"\tUNKNOWN ArchFamilyType = iota\" >> version.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n+\t$(STAMP) $@\n+\n+zgoarch.go: s-zgoarch; @true\n+s-zgoarch: Makefile goarch.sh\n+\trm -f zgoarch.go.tmp\n+\techo \"package goarch\" > zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n+\techo 'const GOARCH = \"'$(GOARCH)'\"' >> zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n+\techo 'const (' >> zgoarch.go.tmp\n+\techo \"  _ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> zgoarch.go.tmp\n+\techo \"  _BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> zgoarch.go.tmp\n+\techo \"  _DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> zgoarch.go.tmp\n+\techo \"  _Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> zgoarch.go.tmp\n+\techo \"  _MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> zgoarch.go.tmp\n+\techo \"  _PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> zgoarch.go.tmp\n+\techo \"  _StackAlign = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) stackalign`\" >> zgoarch.go.tmp\n+\techo \")\" >> zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n+\techo \"const (\" >> zgoarch.go.tmp\n+\techo \"\tUNKNOWN ArchFamilyType = iota\" >> zgoarch.go.tmp\n \tfor a in $(ALLGOARCHFAMILY); do \\\n-\t  echo \"\t$${a}\" >> version.go.tmp; \\\n+\t  echo \"\t$${a}\" >> zgoarch.go.tmp; \\\n \tdone\n-\techo \")\" >> version.go.tmp\n-\techo >> version.go.tmp\n+\techo \")\" >> zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n \tfor a in $(ALLGOARCH); do \\\n \t  f=`echo $${a} | sed -e 's/\\(.\\).*/\\1/' -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`; \\\n \t  n=\"$${f}`echo $${a} | sed -e 's/.//'`\"; \\\n \t  if test \"$${a}\" = \"$(GOARCH)\"; then \\\n-\t    echo \"const Goarch$${n} = 1\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 1\" >> zgoarch.go.tmp; \\\n \t  else \\\n-\t    echo \"const Goarch$${n} = 0\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 0\" >> zgoarch.go.tmp; \\\n \t  fi; \\\n \tdone\n-\techo >> version.go.tmp\n-\techo \"const (\" >> version.go.tmp\n-\techo \"  _ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> version.go.tmp\n-\techo \"  _BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n-\techo \"  _DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n-\techo \"  _Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n-\techo \"  _MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n-\techo \"  _PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n-\techo \"  _StackAlign = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) stackalign`\" >> version.go.tmp\n-\techo \")\" >> version.go.tmp\n-\techo >> version.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh zgoarch.go.tmp zgoarch.go\n+\t$(STAMP) $@\n+\n+zgoos.go: s-zgoos; @true\n+s-zgoos: Makefile\n+\trm -f zgoos.go.tmp\n+\techo \"package goos\" > zgoos.go.tmp\n+\techo >> zgoos.go.tmp\n+\techo 'const GOOS = \"'$(GOOS)'\"' >> zgoos.go.tmp\n+\techo >> zgoos.go.tmp\n \tfor a in $(ALLGOOS); do \\\n \t  f=`echo $${a} | sed -e 's/\\(.\\).*/\\1/' -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`; \\\n \t  n=\"$${f}`echo $${a} | sed -e 's/.//'`\"; \\\n \t  if test \"$${a}\" = \"$(GOOS)\"; then \\\n-\t    echo \"const Goos$${n} = 1\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 1\" >> zgoos.go.tmp; \\\n \t  else \\\n-\t    echo \"const Goos$${n} = 0\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 0\" >> zgoos.go.tmp; \\\n \t  fi; \\\n \tdone\n-\techo >> version.go.tmp\n-\t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n+\t$(SHELL) $(srcdir)/mvifdiff.sh zgoos.go.tmp zgoos.go\n \t$(STAMP) $@\n \n cpugen.go: s-cpu; @true\n-s-cpu: Makefile\n+s-cpu: Makefile goarch.sh\n \trm -f cpugen.go.tmp\n \techo \"package cpu\" > cpugen.go.tmp\n \techo \"const CacheLinePadSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> cpugen.go.tmp\n@@ -538,7 +556,7 @@ s-cpu: Makefile\n \t$(STAMP) $@\n \n gcpugen.go: s-gcpu; @true\n-s-gcpu: Makefile\n+s-gcpu: Makefile goarch.sh\n \trm -f gcpugen.go.tmp\n \techo \"package cpu\" > gcpugen.go.tmp\n \techo \"const cacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> gcpugen.go.tmp\n@@ -560,6 +578,7 @@ s-buildcfg: Makefile\n \techo \"import \\\"runtime\\\"\" >> buildcfg.go.tmp\n \techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> buildcfg.go.tmp\n \techo 'const defaultGO386 = `sse2`' >> buildcfg.go.tmp\n+\techo 'const defaultGOAMD64 = `v1`' >> buildcfg.go.tmp\n \techo 'const defaultGOARM = `5`' >> buildcfg.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> buildcfg.go.tmp\n \techo 'const defaultGOMIPS64 = `hardfloat`' >> buildcfg.go.tmp\n@@ -813,7 +832,8 @@ libgo_ldflags = \\\n \n libgo_libadd = \\\n \t$(libgo_go_objs) ../libbacktrace/libbacktrace.la \\\n-\t$(LIBATOMIC) $(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS)\n+\t$(LIBATOMIC) $(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) \\\n+\t$(NET_LIBS) $(RT_LIBS)\n \n libgo_la_SOURCES = $(runtime_files)\n libgo_la_LDFLAGS = $(libgo_ldflags)\n@@ -904,7 +924,7 @@ GOBENCH =\n CHECK = \\\n \tGC=\"$(GOC) $(GOCFLAGS) $($(subst /,_,$@)_GOCFLAGS) -L `${PWD_COMMAND}` -L `${PWD_COMMAND}`/.libs\"; \\\n \texport GC; \\\n-\tGOLIBS=\"$(extra_check_libs_$(subst .,_,$(subst /,_,$(@D)))) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS) $(LIBS)\"; \\\n+\tGOLIBS=\"$(extra_check_libs_$(subst .,_,$(subst /,_,$(@D)))) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS) $(RT_LIBS) $(LIBS)\"; \\\n \texport GOLIBS; \\\n \tRUNTESTFLAGS=\"$(RUNTESTFLAGS)\"; \\\n \texport RUNTESTFLAGS; \\\n@@ -1065,6 +1085,12 @@ runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n extra_go_files_internal_cpu = cpugen.go\n internal/cpu.lo.dep: $(extra_go_files_internal_cpu)\n \n+extra_go_files_internal_goarch = zgoarch.go\n+internal/goarch.lo.dep: $(extra_go_files_internal_goarch)\n+\n+extra_go_files_internal_goos = zgoos.go\n+internal/goos.lo.dep: $(extra_go_files_internal_goos)\n+\n extra_go_files_golang_org_x_sys_cpu = gcpugen.go\n golang.org/x/sys/cpu.lo.dep: $(extra_go_files_golang_org_x_sys_cpu)\n "}, {"sha": "216be43f14a0c471b7a2ac6d720b911a3e261fce", "filename": "libgo/Makefile.in", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -233,7 +233,8 @@ am__DEPENDENCIES_4 =\n am__DEPENDENCIES_5 = $(am__DEPENDENCIES_3) \\\n \t../libbacktrace/libbacktrace.la $(am__DEPENDENCIES_4) \\\n \t$(am__DEPENDENCIES_4) $(am__DEPENDENCIES_4) \\\n-\t$(am__DEPENDENCIES_4) $(am__DEPENDENCIES_4)\n+\t$(am__DEPENDENCIES_4) $(am__DEPENDENCIES_4) \\\n+\t$(am__DEPENDENCIES_4)\n libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_5)\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_X86_TRUE@am__objects_1 =  \\\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_X86_TRUE@\truntime/go-context.lo\n@@ -465,6 +466,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PTHREAD_CFLAGS = @PTHREAD_CFLAGS@\n PTHREAD_LIBS = @PTHREAD_LIBS@\n RANLIB = @RANLIB@\n+RT_LIBS = @RT_LIBS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@\n@@ -712,6 +714,7 @@ toolexeclibgodatabasesql_DATA = \\\n \n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n toolexeclibgodebug_DATA = \\\n+\tdebug/buildinfo.gox \\\n \tdebug/dwarf.gox \\\n \tdebug/elf.gox \\\n \tdebug/gosym.gox \\\n@@ -804,6 +807,7 @@ toolexeclibgonetdir = $(toolexeclibgodir)/net\n toolexeclibgonet_DATA = \\\n \tnet/http.gox \\\n \tnet/mail.gox \\\n+\tnet/netip.gox \\\n \tnet/rpc.gox \\\n \tnet/smtp.gox \\\n \tnet/textproto.gox \\\n@@ -892,9 +896,9 @@ toolexeclibgointernal_DATA = \\\n noinst_DATA = golang.org/x/net/nettest.gox internal/cfg.gox \\\n \tinternal/obscuretestdata.gox internal/profile.gox \\\n \tinternal/testenv.gox internal/trace.gox \\\n-\tnet/internal/socktest.gox os/signal/internal/pty.gox \\\n-\treflect/internal/example1.gox reflect/internal/example2.gox \\\n-\tzdefaultcc.go\n+\tnet/internal/socktest.gox os/exec/internal/fdtest.gox \\\n+\tos/signal/internal/pty.gox reflect/internal/example1.gox \\\n+\treflect/internal/example2.gox zdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n runtime_context_asm_file = $(am__append_3)\n@@ -968,7 +972,8 @@ libgo_ldflags = \\\n \n libgo_libadd = \\\n \t$(libgo_go_objs) ../libbacktrace/libbacktrace.la \\\n-\t$(LIBATOMIC) $(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS)\n+\t$(LIBATOMIC) $(LIBFFI) $(PTHREAD_LIBS) $(MATH_LIBS) \\\n+\t$(NET_LIBS) $(RT_LIBS)\n \n libgo_la_SOURCES = $(runtime_files)\n libgo_la_LDFLAGS = $(libgo_ldflags)\n@@ -1042,7 +1047,7 @@ GOBENCH =\n CHECK = \\\n \tGC=\"$(GOC) $(GOCFLAGS) $($(subst /,_,$@)_GOCFLAGS) -L `${PWD_COMMAND}` -L `${PWD_COMMAND}`/.libs\"; \\\n \texport GC; \\\n-\tGOLIBS=\"$(extra_check_libs_$(subst .,_,$(subst /,_,$(@D)))) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS) $(LIBS)\"; \\\n+\tGOLIBS=\"$(extra_check_libs_$(subst .,_,$(subst /,_,$(@D)))) $(PTHREAD_LIBS) $(MATH_LIBS) $(NET_LIBS) $(RT_LIBS) $(LIBS)\"; \\\n \texport GOLIBS; \\\n \tRUNTESTFLAGS=\"$(RUNTESTFLAGS)\"; \\\n \texport RUNTESTFLAGS; \\\n@@ -1138,6 +1143,8 @@ runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n @HAVE_STATIC_LINK_TRUE@syscall_check_GOCFLAGS = -static\n extra_go_files_runtime_internal_sys = version.go\n extra_go_files_internal_cpu = cpugen.go\n+extra_go_files_internal_goarch = zgoarch.go\n+extra_go_files_internal_goos = zgoos.go\n extra_go_files_golang_org_x_sys_cpu = gcpugen.go\n extra_go_files_internal_buildcfg = buildcfg.go\n extra_go_files_internal_goroot = zstdpkglist.go\n@@ -2692,53 +2699,68 @@ version.go: s-version; @true\n s-version: Makefile\n \trm -f version.go.tmp\n \techo \"package sys\" > version.go.tmp\n-\techo 'const GOARCH = \"'$(GOARCH)'\"' >> version.go.tmp\n-\techo 'const GOOS = \"'$(GOOS)'\"' >> version.go.tmp\n \techo 'const GccgoToolDir = \"$(libexecsubdir)\"' >> version.go.tmp\n \techo 'const StackGuardMultiplierDefault = 1' >> version.go.tmp\n-\techo >> version.go.tmp\n-\techo \"const (\" >> version.go.tmp\n-\techo \"\tUNKNOWN ArchFamilyType = iota\" >> version.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n+\t$(STAMP) $@\n+\n+zgoarch.go: s-zgoarch; @true\n+s-zgoarch: Makefile goarch.sh\n+\trm -f zgoarch.go.tmp\n+\techo \"package goarch\" > zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n+\techo 'const GOARCH = \"'$(GOARCH)'\"' >> zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n+\techo 'const (' >> zgoarch.go.tmp\n+\techo \"  _ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> zgoarch.go.tmp\n+\techo \"  _BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> zgoarch.go.tmp\n+\techo \"  _DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> zgoarch.go.tmp\n+\techo \"  _Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> zgoarch.go.tmp\n+\techo \"  _MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> zgoarch.go.tmp\n+\techo \"  _PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> zgoarch.go.tmp\n+\techo \"  _StackAlign = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) stackalign`\" >> zgoarch.go.tmp\n+\techo \")\" >> zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n+\techo \"const (\" >> zgoarch.go.tmp\n+\techo \"\tUNKNOWN ArchFamilyType = iota\" >> zgoarch.go.tmp\n \tfor a in $(ALLGOARCHFAMILY); do \\\n-\t  echo \"\t$${a}\" >> version.go.tmp; \\\n+\t  echo \"\t$${a}\" >> zgoarch.go.tmp; \\\n \tdone\n-\techo \")\" >> version.go.tmp\n-\techo >> version.go.tmp\n+\techo \")\" >> zgoarch.go.tmp\n+\techo >> zgoarch.go.tmp\n \tfor a in $(ALLGOARCH); do \\\n \t  f=`echo $${a} | sed -e 's/\\(.\\).*/\\1/' -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`; \\\n \t  n=\"$${f}`echo $${a} | sed -e 's/.//'`\"; \\\n \t  if test \"$${a}\" = \"$(GOARCH)\"; then \\\n-\t    echo \"const Goarch$${n} = 1\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 1\" >> zgoarch.go.tmp; \\\n \t  else \\\n-\t    echo \"const Goarch$${n} = 0\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 0\" >> zgoarch.go.tmp; \\\n \t  fi; \\\n \tdone\n-\techo >> version.go.tmp\n-\techo \"const (\" >> version.go.tmp\n-\techo \"  _ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> version.go.tmp\n-\techo \"  _BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n-\techo \"  _DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n-\techo \"  _Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n-\techo \"  _MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n-\techo \"  _PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n-\techo \"  _StackAlign = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) stackalign`\" >> version.go.tmp\n-\techo \")\" >> version.go.tmp\n-\techo >> version.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh zgoarch.go.tmp zgoarch.go\n+\t$(STAMP) $@\n+\n+zgoos.go: s-zgoos; @true\n+s-zgoos: Makefile\n+\trm -f zgoos.go.tmp\n+\techo \"package goos\" > zgoos.go.tmp\n+\techo >> zgoos.go.tmp\n+\techo 'const GOOS = \"'$(GOOS)'\"' >> zgoos.go.tmp\n+\techo >> zgoos.go.tmp\n \tfor a in $(ALLGOOS); do \\\n \t  f=`echo $${a} | sed -e 's/\\(.\\).*/\\1/' -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`; \\\n \t  n=\"$${f}`echo $${a} | sed -e 's/.//'`\"; \\\n \t  if test \"$${a}\" = \"$(GOOS)\"; then \\\n-\t    echo \"const Goos$${n} = 1\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 1\" >> zgoos.go.tmp; \\\n \t  else \\\n-\t    echo \"const Goos$${n} = 0\" >> version.go.tmp; \\\n+\t    echo \"const Is$${n} = 0\" >> zgoos.go.tmp; \\\n \t  fi; \\\n \tdone\n-\techo >> version.go.tmp\n-\t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n+\t$(SHELL) $(srcdir)/mvifdiff.sh zgoos.go.tmp zgoos.go\n \t$(STAMP) $@\n \n cpugen.go: s-cpu; @true\n-s-cpu: Makefile\n+s-cpu: Makefile goarch.sh\n \trm -f cpugen.go.tmp\n \techo \"package cpu\" > cpugen.go.tmp\n \techo \"const CacheLinePadSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> cpugen.go.tmp\n@@ -2747,7 +2769,7 @@ s-cpu: Makefile\n \t$(STAMP) $@\n \n gcpugen.go: s-gcpu; @true\n-s-gcpu: Makefile\n+s-gcpu: Makefile goarch.sh\n \trm -f gcpugen.go.tmp\n \techo \"package cpu\" > gcpugen.go.tmp\n \techo \"const cacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> gcpugen.go.tmp\n@@ -2769,6 +2791,7 @@ s-buildcfg: Makefile\n \techo \"import \\\"runtime\\\"\" >> buildcfg.go.tmp\n \techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> buildcfg.go.tmp\n \techo 'const defaultGO386 = `sse2`' >> buildcfg.go.tmp\n+\techo 'const defaultGOAMD64 = `v1`' >> buildcfg.go.tmp\n \techo 'const defaultGOARM = `5`' >> buildcfg.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> buildcfg.go.tmp\n \techo 'const defaultGOMIPS64 = `hardfloat`' >> buildcfg.go.tmp\n@@ -3019,6 +3042,8 @@ runtime.lo.dep: $(extra_go_files_runtime)\n syscall.lo.dep: $(extra_go_files_syscall)\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n internal/cpu.lo.dep: $(extra_go_files_internal_cpu)\n+internal/goarch.lo.dep: $(extra_go_files_internal_goarch)\n+internal/goos.lo.dep: $(extra_go_files_internal_goos)\n golang.org/x/sys/cpu.lo.dep: $(extra_go_files_golang_org_x_sys_cpu)\n cmd/internal/buildcfg.lo.dep: $(extra_go_files_internal_buildcfg)\n internal/goroot.lo.dep: $(extra_go_files_internal_goroot)"}, {"sha": "301234bc8939630850612c8a5fb679a4bf85bb78", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1 +1 @@\n-go1.17.1\n+go1.18beta2"}, {"sha": "79f21689c52411e21a5a14b1d9193a660a0536e8", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -19,13 +19,13 @@ cmd/go/internal/par\n cmd/go/internal/search\n cmd/go/internal/str\n cmd/go/internal/test\n-cmd/go/internal/txtar\n cmd/go/internal/vcs\n cmd/go/internal/work\n cmd/internal/buildid\n cmd/internal/edit\n cmd/internal/objabi\n cmd/internal/pkgpath\n+cmd/internal/quoted\n cmd/internal/test2json\n compress/bzip2\n compress/flate\n@@ -46,7 +46,7 @@ crypto/ed25519\n crypto/ed25519/internal/edwards25519\n crypto/ed25519/internal/edwards25519/field\n crypto/elliptic\n-crypto/elliptic/internal/fiat\n+crypto/elliptic/internal/nistec\n crypto/hmac\n crypto/internal/subtle\n crypto/md5\n@@ -61,6 +61,7 @@ crypto/tls\n crypto/x509\n database/sql\n database/sql/driver\n+debug/buildinfo\n debug/dwarf\n debug/elf\n debug/macho\n@@ -110,9 +111,13 @@ image/draw\n image/jpeg\n image/png\n index/suffixarray\n+internal/buildcfg\n internal/cpu\n internal/execabs\n internal/fmtsort\n+internal/fuzz\n+internal/godebug\n+internal/intern\n internal/itoa\n internal/poll\n internal/profile\n@@ -147,6 +152,7 @@ net/http/internal/ascii\n net/http/pprof\n net/internal/socktest\n net/mail\n+net/netip\n net/rpc\n net/rpc/jsonrpc\n net/smtp"}, {"sha": "e24036342810a72885dbd1013e11a9652e896e0e", "filename": "libgo/configure", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -649,6 +649,7 @@ HAVE_SYS_MMAN_H_FALSE\n HAVE_SYS_MMAN_H_TRUE\n PTHREAD_LIBS\n PTHREAD_CFLAGS\n+RT_LIBS\n NET_LIBS\n MATH_LIBS\n GOC_IS_LLGO_FALSE\n@@ -2608,7 +2609,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=20:0:0\n+libtool_VERSION=21:0:0\n \n \n # Default to --enable-multilib\n@@ -11544,7 +11545,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11547 \"configure\"\n+#line 11548 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11650,7 +11651,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11653 \"configure\"\n+#line 11654 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -14747,6 +14748,12 @@ $as_echo \"$libgo_cv_lib_sockets\" >&6; }\n NET_LIBS=\"$libgo_cv_lib_sockets\"\n \n \n+RT_LIBS=\n+case ${host} in\n+  *-*-linux*) RT_LIBS=-lrt ;;\n+esac\n+\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether -pthread is supported\" >&5\n $as_echo_n \"checking whether -pthread is supported... \" >&6; }\n if ${libgo_cv_lib_pthread+:} false; then :"}, {"sha": "1b44b226f62e53e3a56bac91005b25a1afc806a1", "filename": "libgo/configure.ac", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=20:0:0\n+libtool_VERSION=21:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)\n@@ -549,6 +549,12 @@ AC_CACHE_CHECK([for socket libraries], libgo_cv_lib_sockets,\n NET_LIBS=\"$libgo_cv_lib_sockets\"\n AC_SUBST(NET_LIBS)\n \n+RT_LIBS=\n+case ${host} in\n+  *-*-linux*) RT_LIBS=-lrt ;;\n+esac\n+AC_SUBST(RT_LIBS)\n+\n dnl Test whether the compiler supports the -pthread option.\n AC_CACHE_CHECK([whether -pthread is supported],\n [libgo_cv_lib_pthread],"}, {"sha": "c99b5c19207f71f4c93455df42adb44cf6c63c69", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -316,10 +316,10 @@ func invertSparseEntries(src []sparseEntry, size int64) []sparseEntry {\n // fileState tracks the number of logical (includes sparse holes) and physical\n // (actual in tar archive) bytes remaining for the current file.\n //\n-// Invariant: LogicalRemaining >= PhysicalRemaining\n+// Invariant: logicalRemaining >= physicalRemaining\n type fileState interface {\n-\tLogicalRemaining() int64\n-\tPhysicalRemaining() int64\n+\tlogicalRemaining() int64\n+\tphysicalRemaining() int64\n }\n \n // allowedFormats determines which formats can be used.\n@@ -413,22 +413,22 @@ func (h Header) allowedFormats() (format Format, paxHdrs map[string]string, err\n \n \t// Check basic fields.\n \tvar blk block\n-\tv7 := blk.V7()\n-\tustar := blk.USTAR()\n-\tgnu := blk.GNU()\n-\tverifyString(h.Name, len(v7.Name()), \"Name\", paxPath)\n-\tverifyString(h.Linkname, len(v7.LinkName()), \"Linkname\", paxLinkpath)\n-\tverifyString(h.Uname, len(ustar.UserName()), \"Uname\", paxUname)\n-\tverifyString(h.Gname, len(ustar.GroupName()), \"Gname\", paxGname)\n-\tverifyNumeric(h.Mode, len(v7.Mode()), \"Mode\", paxNone)\n-\tverifyNumeric(int64(h.Uid), len(v7.UID()), \"Uid\", paxUid)\n-\tverifyNumeric(int64(h.Gid), len(v7.GID()), \"Gid\", paxGid)\n-\tverifyNumeric(h.Size, len(v7.Size()), \"Size\", paxSize)\n-\tverifyNumeric(h.Devmajor, len(ustar.DevMajor()), \"Devmajor\", paxNone)\n-\tverifyNumeric(h.Devminor, len(ustar.DevMinor()), \"Devminor\", paxNone)\n-\tverifyTime(h.ModTime, len(v7.ModTime()), \"ModTime\", paxMtime)\n-\tverifyTime(h.AccessTime, len(gnu.AccessTime()), \"AccessTime\", paxAtime)\n-\tverifyTime(h.ChangeTime, len(gnu.ChangeTime()), \"ChangeTime\", paxCtime)\n+\tv7 := blk.toV7()\n+\tustar := blk.toUSTAR()\n+\tgnu := blk.toGNU()\n+\tverifyString(h.Name, len(v7.name()), \"Name\", paxPath)\n+\tverifyString(h.Linkname, len(v7.linkName()), \"Linkname\", paxLinkpath)\n+\tverifyString(h.Uname, len(ustar.userName()), \"Uname\", paxUname)\n+\tverifyString(h.Gname, len(ustar.groupName()), \"Gname\", paxGname)\n+\tverifyNumeric(h.Mode, len(v7.mode()), \"Mode\", paxNone)\n+\tverifyNumeric(int64(h.Uid), len(v7.uid()), \"Uid\", paxUid)\n+\tverifyNumeric(int64(h.Gid), len(v7.gid()), \"Gid\", paxGid)\n+\tverifyNumeric(h.Size, len(v7.size()), \"Size\", paxSize)\n+\tverifyNumeric(h.Devmajor, len(ustar.devMajor()), \"Devmajor\", paxNone)\n+\tverifyNumeric(h.Devminor, len(ustar.devMinor()), \"Devminor\", paxNone)\n+\tverifyTime(h.ModTime, len(v7.modTime()), \"ModTime\", paxMtime)\n+\tverifyTime(h.AccessTime, len(gnu.accessTime()), \"AccessTime\", paxAtime)\n+\tverifyTime(h.ChangeTime, len(gnu.changeTime()), \"ChangeTime\", paxCtime)\n \n \t// Check for header-only types.\n \tvar whyOnlyPAX, whyOnlyGNU string\n@@ -538,7 +538,7 @@ type headerFileInfo struct {\n func (fi headerFileInfo) Size() int64        { return fi.h.Size }\n func (fi headerFileInfo) IsDir() bool        { return fi.Mode().IsDir() }\n func (fi headerFileInfo) ModTime() time.Time { return fi.h.ModTime }\n-func (fi headerFileInfo) Sys() interface{}   { return fi.h }\n+func (fi headerFileInfo) Sys() any           { return fi.h }\n \n // Name returns the base name of the file.\n func (fi headerFileInfo) Name() string {"}, {"sha": "21b9d9d4dbc628f7f18a370d7bb10f597b0efc70", "filename": "libgo/go/archive/tar/format.go", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -156,28 +156,28 @@ var zeroBlock block\n type block [blockSize]byte\n \n // Convert block to any number of formats.\n-func (b *block) V7() *headerV7       { return (*headerV7)(b) }\n-func (b *block) GNU() *headerGNU     { return (*headerGNU)(b) }\n-func (b *block) STAR() *headerSTAR   { return (*headerSTAR)(b) }\n-func (b *block) USTAR() *headerUSTAR { return (*headerUSTAR)(b) }\n-func (b *block) Sparse() sparseArray { return sparseArray(b[:]) }\n+func (b *block) toV7() *headerV7       { return (*headerV7)(b) }\n+func (b *block) toGNU() *headerGNU     { return (*headerGNU)(b) }\n+func (b *block) toSTAR() *headerSTAR   { return (*headerSTAR)(b) }\n+func (b *block) toUSTAR() *headerUSTAR { return (*headerUSTAR)(b) }\n+func (b *block) toSparse() sparseArray { return sparseArray(b[:]) }\n \n // GetFormat checks that the block is a valid tar header based on the checksum.\n // It then attempts to guess the specific format based on magic values.\n // If the checksum fails, then FormatUnknown is returned.\n-func (b *block) GetFormat() Format {\n+func (b *block) getFormat() Format {\n \t// Verify checksum.\n \tvar p parser\n-\tvalue := p.parseOctal(b.V7().Chksum())\n-\tchksum1, chksum2 := b.ComputeChecksum()\n+\tvalue := p.parseOctal(b.toV7().chksum())\n+\tchksum1, chksum2 := b.computeChecksum()\n \tif p.err != nil || (value != chksum1 && value != chksum2) {\n \t\treturn FormatUnknown\n \t}\n \n \t// Guess the magic values.\n-\tmagic := string(b.USTAR().Magic())\n-\tversion := string(b.USTAR().Version())\n-\ttrailer := string(b.STAR().Trailer())\n+\tmagic := string(b.toUSTAR().magic())\n+\tversion := string(b.toUSTAR().version())\n+\ttrailer := string(b.toSTAR().trailer())\n \tswitch {\n \tcase magic == magicUSTAR && trailer == trailerSTAR:\n \t\treturn formatSTAR\n@@ -190,41 +190,41 @@ func (b *block) GetFormat() Format {\n \t}\n }\n \n-// SetFormat writes the magic values necessary for specified format\n+// setFormat writes the magic values necessary for specified format\n // and then updates the checksum accordingly.\n-func (b *block) SetFormat(format Format) {\n+func (b *block) setFormat(format Format) {\n \t// Set the magic values.\n \tswitch {\n \tcase format.has(formatV7):\n \t\t// Do nothing.\n \tcase format.has(FormatGNU):\n-\t\tcopy(b.GNU().Magic(), magicGNU)\n-\t\tcopy(b.GNU().Version(), versionGNU)\n+\t\tcopy(b.toGNU().magic(), magicGNU)\n+\t\tcopy(b.toGNU().version(), versionGNU)\n \tcase format.has(formatSTAR):\n-\t\tcopy(b.STAR().Magic(), magicUSTAR)\n-\t\tcopy(b.STAR().Version(), versionUSTAR)\n-\t\tcopy(b.STAR().Trailer(), trailerSTAR)\n+\t\tcopy(b.toSTAR().magic(), magicUSTAR)\n+\t\tcopy(b.toSTAR().version(), versionUSTAR)\n+\t\tcopy(b.toSTAR().trailer(), trailerSTAR)\n \tcase format.has(FormatUSTAR | FormatPAX):\n-\t\tcopy(b.USTAR().Magic(), magicUSTAR)\n-\t\tcopy(b.USTAR().Version(), versionUSTAR)\n+\t\tcopy(b.toUSTAR().magic(), magicUSTAR)\n+\t\tcopy(b.toUSTAR().version(), versionUSTAR)\n \tdefault:\n \t\tpanic(\"invalid format\")\n \t}\n \n \t// Update checksum.\n \t// This field is special in that it is terminated by a NULL then space.\n \tvar f formatter\n-\tfield := b.V7().Chksum()\n-\tchksum, _ := b.ComputeChecksum() // Possible values are 256..128776\n+\tfield := b.toV7().chksum()\n+\tchksum, _ := b.computeChecksum() // Possible values are 256..128776\n \tf.formatOctal(field[:7], chksum) // Never fails since 128776 < 262143\n \tfield[7] = ' '\n }\n \n-// ComputeChecksum computes the checksum for the header block.\n+// computeChecksum computes the checksum for the header block.\n // POSIX specifies a sum of the unsigned byte values, but the Sun tar used\n // signed byte values.\n // We compute and return both.\n-func (b *block) ComputeChecksum() (unsigned, signed int64) {\n+func (b *block) computeChecksum() (unsigned, signed int64) {\n \tfor i, c := range b {\n \t\tif 148 <= i && i < 156 {\n \t\t\tc = ' ' // Treat the checksum field itself as all spaces.\n@@ -236,68 +236,68 @@ func (b *block) ComputeChecksum() (unsigned, signed int64) {\n }\n \n // Reset clears the block with all zeros.\n-func (b *block) Reset() {\n+func (b *block) reset() {\n \t*b = block{}\n }\n \n type headerV7 [blockSize]byte\n \n-func (h *headerV7) Name() []byte     { return h[000:][:100] }\n-func (h *headerV7) Mode() []byte     { return h[100:][:8] }\n-func (h *headerV7) UID() []byte      { return h[108:][:8] }\n-func (h *headerV7) GID() []byte      { return h[116:][:8] }\n-func (h *headerV7) Size() []byte     { return h[124:][:12] }\n-func (h *headerV7) ModTime() []byte  { return h[136:][:12] }\n-func (h *headerV7) Chksum() []byte   { return h[148:][:8] }\n-func (h *headerV7) TypeFlag() []byte { return h[156:][:1] }\n-func (h *headerV7) LinkName() []byte { return h[157:][:100] }\n+func (h *headerV7) name() []byte     { return h[000:][:100] }\n+func (h *headerV7) mode() []byte     { return h[100:][:8] }\n+func (h *headerV7) uid() []byte      { return h[108:][:8] }\n+func (h *headerV7) gid() []byte      { return h[116:][:8] }\n+func (h *headerV7) size() []byte     { return h[124:][:12] }\n+func (h *headerV7) modTime() []byte  { return h[136:][:12] }\n+func (h *headerV7) chksum() []byte   { return h[148:][:8] }\n+func (h *headerV7) typeFlag() []byte { return h[156:][:1] }\n+func (h *headerV7) linkName() []byte { return h[157:][:100] }\n \n type headerGNU [blockSize]byte\n \n-func (h *headerGNU) V7() *headerV7       { return (*headerV7)(h) }\n-func (h *headerGNU) Magic() []byte       { return h[257:][:6] }\n-func (h *headerGNU) Version() []byte     { return h[263:][:2] }\n-func (h *headerGNU) UserName() []byte    { return h[265:][:32] }\n-func (h *headerGNU) GroupName() []byte   { return h[297:][:32] }\n-func (h *headerGNU) DevMajor() []byte    { return h[329:][:8] }\n-func (h *headerGNU) DevMinor() []byte    { return h[337:][:8] }\n-func (h *headerGNU) AccessTime() []byte  { return h[345:][:12] }\n-func (h *headerGNU) ChangeTime() []byte  { return h[357:][:12] }\n-func (h *headerGNU) Sparse() sparseArray { return sparseArray(h[386:][:24*4+1]) }\n-func (h *headerGNU) RealSize() []byte    { return h[483:][:12] }\n+func (h *headerGNU) v7() *headerV7       { return (*headerV7)(h) }\n+func (h *headerGNU) magic() []byte       { return h[257:][:6] }\n+func (h *headerGNU) version() []byte     { return h[263:][:2] }\n+func (h *headerGNU) userName() []byte    { return h[265:][:32] }\n+func (h *headerGNU) groupName() []byte   { return h[297:][:32] }\n+func (h *headerGNU) devMajor() []byte    { return h[329:][:8] }\n+func (h *headerGNU) devMinor() []byte    { return h[337:][:8] }\n+func (h *headerGNU) accessTime() []byte  { return h[345:][:12] }\n+func (h *headerGNU) changeTime() []byte  { return h[357:][:12] }\n+func (h *headerGNU) sparse() sparseArray { return sparseArray(h[386:][:24*4+1]) }\n+func (h *headerGNU) realSize() []byte    { return h[483:][:12] }\n \n type headerSTAR [blockSize]byte\n \n-func (h *headerSTAR) V7() *headerV7      { return (*headerV7)(h) }\n-func (h *headerSTAR) Magic() []byte      { return h[257:][:6] }\n-func (h *headerSTAR) Version() []byte    { return h[263:][:2] }\n-func (h *headerSTAR) UserName() []byte   { return h[265:][:32] }\n-func (h *headerSTAR) GroupName() []byte  { return h[297:][:32] }\n-func (h *headerSTAR) DevMajor() []byte   { return h[329:][:8] }\n-func (h *headerSTAR) DevMinor() []byte   { return h[337:][:8] }\n-func (h *headerSTAR) Prefix() []byte     { return h[345:][:131] }\n-func (h *headerSTAR) AccessTime() []byte { return h[476:][:12] }\n-func (h *headerSTAR) ChangeTime() []byte { return h[488:][:12] }\n-func (h *headerSTAR) Trailer() []byte    { return h[508:][:4] }\n+func (h *headerSTAR) v7() *headerV7      { return (*headerV7)(h) }\n+func (h *headerSTAR) magic() []byte      { return h[257:][:6] }\n+func (h *headerSTAR) version() []byte    { return h[263:][:2] }\n+func (h *headerSTAR) userName() []byte   { return h[265:][:32] }\n+func (h *headerSTAR) groupName() []byte  { return h[297:][:32] }\n+func (h *headerSTAR) devMajor() []byte   { return h[329:][:8] }\n+func (h *headerSTAR) devMinor() []byte   { return h[337:][:8] }\n+func (h *headerSTAR) prefix() []byte     { return h[345:][:131] }\n+func (h *headerSTAR) accessTime() []byte { return h[476:][:12] }\n+func (h *headerSTAR) changeTime() []byte { return h[488:][:12] }\n+func (h *headerSTAR) trailer() []byte    { return h[508:][:4] }\n \n type headerUSTAR [blockSize]byte\n \n-func (h *headerUSTAR) V7() *headerV7     { return (*headerV7)(h) }\n-func (h *headerUSTAR) Magic() []byte     { return h[257:][:6] }\n-func (h *headerUSTAR) Version() []byte   { return h[263:][:2] }\n-func (h *headerUSTAR) UserName() []byte  { return h[265:][:32] }\n-func (h *headerUSTAR) GroupName() []byte { return h[297:][:32] }\n-func (h *headerUSTAR) DevMajor() []byte  { return h[329:][:8] }\n-func (h *headerUSTAR) DevMinor() []byte  { return h[337:][:8] }\n-func (h *headerUSTAR) Prefix() []byte    { return h[345:][:155] }\n+func (h *headerUSTAR) v7() *headerV7     { return (*headerV7)(h) }\n+func (h *headerUSTAR) magic() []byte     { return h[257:][:6] }\n+func (h *headerUSTAR) version() []byte   { return h[263:][:2] }\n+func (h *headerUSTAR) userName() []byte  { return h[265:][:32] }\n+func (h *headerUSTAR) groupName() []byte { return h[297:][:32] }\n+func (h *headerUSTAR) devMajor() []byte  { return h[329:][:8] }\n+func (h *headerUSTAR) devMinor() []byte  { return h[337:][:8] }\n+func (h *headerUSTAR) prefix() []byte    { return h[345:][:155] }\n \n type sparseArray []byte\n \n-func (s sparseArray) Entry(i int) sparseElem { return sparseElem(s[i*24:]) }\n-func (s sparseArray) IsExtended() []byte     { return s[24*s.MaxEntries():][:1] }\n-func (s sparseArray) MaxEntries() int        { return len(s) / 24 }\n+func (s sparseArray) entry(i int) sparseElem { return sparseElem(s[i*24:]) }\n+func (s sparseArray) isExtended() []byte     { return s[24*s.maxEntries():][:1] }\n+func (s sparseArray) maxEntries() int        { return len(s) / 24 }\n \n type sparseElem []byte\n \n-func (s sparseElem) Offset() []byte { return s[00:][:12] }\n-func (s sparseElem) Length() []byte { return s[12:][:12] }\n+func (s sparseElem) offset() []byte { return s[00:][:12] }\n+func (s sparseElem) length() []byte { return s[12:][:12] }"}, {"sha": "e73e0d2609e50adcef465d9874980815200d5a27", "filename": "libgo/go/archive/tar/fuzz_test.go", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Ffuzz_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Ffuzz_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ffuzz_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tar\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"testing\"\n+)\n+\n+func FuzzReader(f *testing.F) {\n+\tb := bytes.NewBuffer(nil)\n+\tw := NewWriter(b)\n+\tinp := []byte(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\")\n+\terr := w.WriteHeader(&Header{\n+\t\tName: \"lorem.txt\",\n+\t\tMode: 0600,\n+\t\tSize: int64(len(inp)),\n+\t})\n+\tif err != nil {\n+\t\tf.Fatalf(\"failed to create writer: %s\", err)\n+\t}\n+\t_, err = w.Write(inp)\n+\tif err != nil {\n+\t\tf.Fatalf(\"failed to write file to archive: %s\", err)\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tf.Fatalf(\"failed to write archive: %s\", err)\n+\t}\n+\tf.Add(b.Bytes())\n+\n+\tf.Fuzz(func(t *testing.T, b []byte) {\n+\t\tr := NewReader(bytes.NewReader(b))\n+\t\ttype file struct {\n+\t\t\theader  *Header\n+\t\t\tcontent []byte\n+\t\t}\n+\t\tfiles := []file{}\n+\t\tfor {\n+\t\t\thdr, err := r.Next()\n+\t\t\tif err == io.EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\tif _, err := io.Copy(buf, r); err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfiles = append(files, file{header: hdr, content: buf.Bytes()})\n+\t\t}\n+\n+\t\t// If we were unable to read anything out of the archive don't\n+\t\t// bother trying to roundtrip it.\n+\t\tif len(files) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tout := bytes.NewBuffer(nil)\n+\t\tw := NewWriter(out)\n+\t\tfor _, f := range files {\n+\t\t\tif err := w.WriteHeader(f.header); err != nil {\n+\t\t\t\tt.Fatalf(\"unable to write previously parsed header: %s\", err)\n+\t\t\t}\n+\t\t\tif _, err := w.Write(f.content); err != nil {\n+\t\t\t\tt.Fatalf(\"unable to write previously parsed content: %s\", err)\n+\t\t\t}\n+\t\t}\n+\t\tif err := w.Close(); err != nil {\n+\t\t\tt.Fatalf(\"Unable to write archive: %s\", err)\n+\t\t}\n+\n+\t\t// TODO: We may want to check if the archive roundtrips. This would require\n+\t\t// taking into account addition of the two zero trailer blocks that Writer.Close\n+\t\t// appends.\n+\t})\n+}"}, {"sha": "4b11909bc9527d37af905cba8c33f495b83893ca", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -65,7 +65,7 @@ func (tr *Reader) next() (*Header, error) {\n \tformat := FormatUSTAR | FormatPAX | FormatGNU\n \tfor {\n \t\t// Discard the remainder of the file and any padding.\n-\t\tif err := discard(tr.r, tr.curr.PhysicalRemaining()); err != nil {\n+\t\tif err := discard(tr.r, tr.curr.physicalRemaining()); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\tif _, err := tryReadFull(tr.r, tr.blk[:tr.pad]); err != nil {\n@@ -355,7 +355,7 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n \t}\n \n \t// Verify the header matches a known format.\n-\tformat := tr.blk.GetFormat()\n+\tformat := tr.blk.getFormat()\n \tif format == FormatUnknown {\n \t\treturn nil, nil, ErrHeader\n \t}\n@@ -364,30 +364,30 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n \thdr := new(Header)\n \n \t// Unpack the V7 header.\n-\tv7 := tr.blk.V7()\n-\thdr.Typeflag = v7.TypeFlag()[0]\n-\thdr.Name = p.parseString(v7.Name())\n-\thdr.Linkname = p.parseString(v7.LinkName())\n-\thdr.Size = p.parseNumeric(v7.Size())\n-\thdr.Mode = p.parseNumeric(v7.Mode())\n-\thdr.Uid = int(p.parseNumeric(v7.UID()))\n-\thdr.Gid = int(p.parseNumeric(v7.GID()))\n-\thdr.ModTime = time.Unix(p.parseNumeric(v7.ModTime()), 0)\n+\tv7 := tr.blk.toV7()\n+\thdr.Typeflag = v7.typeFlag()[0]\n+\thdr.Name = p.parseString(v7.name())\n+\thdr.Linkname = p.parseString(v7.linkName())\n+\thdr.Size = p.parseNumeric(v7.size())\n+\thdr.Mode = p.parseNumeric(v7.mode())\n+\thdr.Uid = int(p.parseNumeric(v7.uid()))\n+\thdr.Gid = int(p.parseNumeric(v7.gid()))\n+\thdr.ModTime = time.Unix(p.parseNumeric(v7.modTime()), 0)\n \n \t// Unpack format specific fields.\n \tif format > formatV7 {\n-\t\tustar := tr.blk.USTAR()\n-\t\thdr.Uname = p.parseString(ustar.UserName())\n-\t\thdr.Gname = p.parseString(ustar.GroupName())\n-\t\thdr.Devmajor = p.parseNumeric(ustar.DevMajor())\n-\t\thdr.Devminor = p.parseNumeric(ustar.DevMinor())\n+\t\tustar := tr.blk.toUSTAR()\n+\t\thdr.Uname = p.parseString(ustar.userName())\n+\t\thdr.Gname = p.parseString(ustar.groupName())\n+\t\thdr.Devmajor = p.parseNumeric(ustar.devMajor())\n+\t\thdr.Devminor = p.parseNumeric(ustar.devMinor())\n \n \t\tvar prefix string\n \t\tswitch {\n \t\tcase format.has(FormatUSTAR | FormatPAX):\n \t\t\thdr.Format = format\n-\t\t\tustar := tr.blk.USTAR()\n-\t\t\tprefix = p.parseString(ustar.Prefix())\n+\t\t\tustar := tr.blk.toUSTAR()\n+\t\t\tprefix = p.parseString(ustar.prefix())\n \n \t\t\t// For Format detection, check if block is properly formatted since\n \t\t\t// the parser is more liberal than what USTAR actually permits.\n@@ -396,23 +396,23 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n \t\t\t\thdr.Format = FormatUnknown // Non-ASCII characters in block.\n \t\t\t}\n \t\t\tnul := func(b []byte) bool { return int(b[len(b)-1]) == 0 }\n-\t\t\tif !(nul(v7.Size()) && nul(v7.Mode()) && nul(v7.UID()) && nul(v7.GID()) &&\n-\t\t\t\tnul(v7.ModTime()) && nul(ustar.DevMajor()) && nul(ustar.DevMinor())) {\n+\t\t\tif !(nul(v7.size()) && nul(v7.mode()) && nul(v7.uid()) && nul(v7.gid()) &&\n+\t\t\t\tnul(v7.modTime()) && nul(ustar.devMajor()) && nul(ustar.devMinor())) {\n \t\t\t\thdr.Format = FormatUnknown // Numeric fields must end in NUL\n \t\t\t}\n \t\tcase format.has(formatSTAR):\n-\t\t\tstar := tr.blk.STAR()\n-\t\t\tprefix = p.parseString(star.Prefix())\n-\t\t\thdr.AccessTime = time.Unix(p.parseNumeric(star.AccessTime()), 0)\n-\t\t\thdr.ChangeTime = time.Unix(p.parseNumeric(star.ChangeTime()), 0)\n+\t\t\tstar := tr.blk.toSTAR()\n+\t\t\tprefix = p.parseString(star.prefix())\n+\t\t\thdr.AccessTime = time.Unix(p.parseNumeric(star.accessTime()), 0)\n+\t\t\thdr.ChangeTime = time.Unix(p.parseNumeric(star.changeTime()), 0)\n \t\tcase format.has(FormatGNU):\n \t\t\thdr.Format = format\n \t\t\tvar p2 parser\n-\t\t\tgnu := tr.blk.GNU()\n-\t\t\tif b := gnu.AccessTime(); b[0] != 0 {\n+\t\t\tgnu := tr.blk.toGNU()\n+\t\t\tif b := gnu.accessTime(); b[0] != 0 {\n \t\t\t\thdr.AccessTime = time.Unix(p2.parseNumeric(b), 0)\n \t\t\t}\n-\t\t\tif b := gnu.ChangeTime(); b[0] != 0 {\n+\t\t\tif b := gnu.changeTime(); b[0] != 0 {\n \t\t\t\thdr.ChangeTime = time.Unix(p2.parseNumeric(b), 0)\n \t\t\t}\n \n@@ -439,8 +439,8 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n \t\t\t// See https://golang.org/issues/21005\n \t\t\tif p2.err != nil {\n \t\t\t\thdr.AccessTime, hdr.ChangeTime = time.Time{}, time.Time{}\n-\t\t\t\tustar := tr.blk.USTAR()\n-\t\t\t\tif s := p.parseString(ustar.Prefix()); isASCII(s) {\n+\t\t\t\tustar := tr.blk.toUSTAR()\n+\t\t\t\tif s := p.parseString(ustar.prefix()); isASCII(s) {\n \t\t\t\t\tprefix = s\n \t\t\t\t}\n \t\t\t\thdr.Format = FormatUnknown // Buggy file is not GNU\n@@ -465,38 +465,38 @@ func (tr *Reader) readOldGNUSparseMap(hdr *Header, blk *block) (sparseDatas, err\n \t// Make sure that the input format is GNU.\n \t// Unfortunately, the STAR format also has a sparse header format that uses\n \t// the same type flag but has a completely different layout.\n-\tif blk.GetFormat() != FormatGNU {\n+\tif blk.getFormat() != FormatGNU {\n \t\treturn nil, ErrHeader\n \t}\n \thdr.Format.mayOnlyBe(FormatGNU)\n \n \tvar p parser\n-\thdr.Size = p.parseNumeric(blk.GNU().RealSize())\n+\thdr.Size = p.parseNumeric(blk.toGNU().realSize())\n \tif p.err != nil {\n \t\treturn nil, p.err\n \t}\n-\ts := blk.GNU().Sparse()\n-\tspd := make(sparseDatas, 0, s.MaxEntries())\n+\ts := blk.toGNU().sparse()\n+\tspd := make(sparseDatas, 0, s.maxEntries())\n \tfor {\n-\t\tfor i := 0; i < s.MaxEntries(); i++ {\n+\t\tfor i := 0; i < s.maxEntries(); i++ {\n \t\t\t// This termination condition is identical to GNU and BSD tar.\n-\t\t\tif s.Entry(i).Offset()[0] == 0x00 {\n+\t\t\tif s.entry(i).offset()[0] == 0x00 {\n \t\t\t\tbreak // Don't return, need to process extended headers (even if empty)\n \t\t\t}\n-\t\t\toffset := p.parseNumeric(s.Entry(i).Offset())\n-\t\t\tlength := p.parseNumeric(s.Entry(i).Length())\n+\t\t\toffset := p.parseNumeric(s.entry(i).offset())\n+\t\t\tlength := p.parseNumeric(s.entry(i).length())\n \t\t\tif p.err != nil {\n \t\t\t\treturn nil, p.err\n \t\t\t}\n \t\t\tspd = append(spd, sparseEntry{Offset: offset, Length: length})\n \t\t}\n \n-\t\tif s.IsExtended()[0] > 0 {\n+\t\tif s.isExtended()[0] > 0 {\n \t\t\t// There are more entries. Read an extension header and parse its entries.\n \t\t\tif _, err := mustReadFull(tr.r, blk[:]); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\ts = blk.Sparse()\n+\t\t\ts = blk.toSparse()\n \t\t\tcontinue\n \t\t}\n \t\treturn spd, nil // Done\n@@ -678,11 +678,13 @@ func (fr *regFileReader) WriteTo(w io.Writer) (int64, error) {\n \treturn io.Copy(w, struct{ io.Reader }{fr})\n }\n \n-func (fr regFileReader) LogicalRemaining() int64 {\n+// logicalRemaining implements fileState.logicalRemaining.\n+func (fr regFileReader) logicalRemaining() int64 {\n \treturn fr.nb\n }\n \n-func (fr regFileReader) PhysicalRemaining() int64 {\n+// logicalRemaining implements fileState.physicalRemaining.\n+func (fr regFileReader) physicalRemaining() int64 {\n \treturn fr.nb\n }\n \n@@ -694,9 +696,9 @@ type sparseFileReader struct {\n }\n \n func (sr *sparseFileReader) Read(b []byte) (n int, err error) {\n-\tfinished := int64(len(b)) >= sr.LogicalRemaining()\n+\tfinished := int64(len(b)) >= sr.logicalRemaining()\n \tif finished {\n-\t\tb = b[:sr.LogicalRemaining()]\n+\t\tb = b[:sr.logicalRemaining()]\n \t}\n \n \tb0 := b\n@@ -724,7 +726,7 @@ func (sr *sparseFileReader) Read(b []byte) (n int, err error) {\n \t\treturn n, errMissData // Less data in dense file than sparse file\n \tcase err != nil:\n \t\treturn n, err\n-\tcase sr.LogicalRemaining() == 0 && sr.PhysicalRemaining() > 0:\n+\tcase sr.logicalRemaining() == 0 && sr.physicalRemaining() > 0:\n \t\treturn n, errUnrefData // More data in dense file than sparse file\n \tcase finished:\n \t\treturn n, io.EOF\n@@ -746,15 +748,15 @@ func (sr *sparseFileReader) WriteTo(w io.Writer) (n int64, err error) {\n \n \tvar writeLastByte bool\n \tpos0 := sr.pos\n-\tfor sr.LogicalRemaining() > 0 && !writeLastByte && err == nil {\n+\tfor sr.logicalRemaining() > 0 && !writeLastByte && err == nil {\n \t\tvar nf int64 // Size of fragment\n \t\tholeStart, holeEnd := sr.sp[0].Offset, sr.sp[0].endOffset()\n \t\tif sr.pos < holeStart { // In a data fragment\n \t\t\tnf = holeStart - sr.pos\n \t\t\tnf, err = io.CopyN(ws, sr.fr, nf)\n \t\t} else { // In a hole fragment\n \t\t\tnf = holeEnd - sr.pos\n-\t\t\tif sr.PhysicalRemaining() == 0 {\n+\t\t\tif sr.physicalRemaining() == 0 {\n \t\t\t\twriteLastByte = true\n \t\t\t\tnf--\n \t\t\t}\n@@ -779,18 +781,18 @@ func (sr *sparseFileReader) WriteTo(w io.Writer) (n int64, err error) {\n \t\treturn n, errMissData // Less data in dense file than sparse file\n \tcase err != nil:\n \t\treturn n, err\n-\tcase sr.LogicalRemaining() == 0 && sr.PhysicalRemaining() > 0:\n+\tcase sr.logicalRemaining() == 0 && sr.physicalRemaining() > 0:\n \t\treturn n, errUnrefData // More data in dense file than sparse file\n \tdefault:\n \t\treturn n, nil\n \t}\n }\n \n-func (sr sparseFileReader) LogicalRemaining() int64 {\n+func (sr sparseFileReader) logicalRemaining() int64 {\n \treturn sr.sp[len(sr.sp)-1].endOffset() - sr.pos\n }\n-func (sr sparseFileReader) PhysicalRemaining() int64 {\n-\treturn sr.fr.PhysicalRemaining()\n+func (sr sparseFileReader) physicalRemaining() int64 {\n+\treturn sr.fr.physicalRemaining()\n }\n \n type zeroReader struct{}"}, {"sha": "f21a6065b485706f3e2c2825f1fd8c04472fa275", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1021,32 +1021,32 @@ func TestParsePAX(t *testing.T) {\n \n func TestReadOldGNUSparseMap(t *testing.T) {\n \tpopulateSparseMap := func(sa sparseArray, sps []string) []string {\n-\t\tfor i := 0; len(sps) > 0 && i < sa.MaxEntries(); i++ {\n-\t\t\tcopy(sa.Entry(i), sps[0])\n+\t\tfor i := 0; len(sps) > 0 && i < sa.maxEntries(); i++ {\n+\t\t\tcopy(sa.entry(i), sps[0])\n \t\t\tsps = sps[1:]\n \t\t}\n \t\tif len(sps) > 0 {\n-\t\t\tcopy(sa.IsExtended(), \"\\x80\")\n+\t\t\tcopy(sa.isExtended(), \"\\x80\")\n \t\t}\n \t\treturn sps\n \t}\n \n \tmakeInput := func(format Format, size string, sps ...string) (out []byte) {\n \t\t// Write the initial GNU header.\n \t\tvar blk block\n-\t\tgnu := blk.GNU()\n-\t\tsparse := gnu.Sparse()\n-\t\tcopy(gnu.RealSize(), size)\n+\t\tgnu := blk.toGNU()\n+\t\tsparse := gnu.sparse()\n+\t\tcopy(gnu.realSize(), size)\n \t\tsps = populateSparseMap(sparse, sps)\n \t\tif format != FormatUnknown {\n-\t\t\tblk.SetFormat(format)\n+\t\t\tblk.setFormat(format)\n \t\t}\n \t\tout = append(out, blk[:]...)\n \n \t\t// Write extended sparse blocks.\n \t\tfor len(sps) > 0 {\n \t\t\tvar blk block\n-\t\t\tsps = populateSparseMap(blk.Sparse(), sps)\n+\t\t\tsps = populateSparseMap(blk.toSparse(), sps)\n \t\t\tout = append(out, blk[:]...)\n \t\t}\n \t\treturn out\n@@ -1359,11 +1359,11 @@ func TestFileReader(t *testing.T) {\n \t\t\twantCnt int64\n \t\t\twantErr error\n \t\t}\n-\t\ttestRemaining struct { // LogicalRemaining() == wantLCnt, PhysicalRemaining() == wantPCnt\n+\t\ttestRemaining struct { // logicalRemaining() == wantLCnt, physicalRemaining() == wantPCnt\n \t\t\twantLCnt int64\n \t\t\twantPCnt int64\n \t\t}\n-\t\ttestFnc interface{} // testRead | testWriteTo | testRemaining\n+\t\ttestFnc any // testRead | testWriteTo | testRemaining\n \t)\n \n \ttype (\n@@ -1376,7 +1376,7 @@ func TestFileReader(t *testing.T) {\n \t\t\tspd     sparseDatas\n \t\t\tsize    int64\n \t\t}\n-\t\tfileMaker interface{} // makeReg | makeSparse\n+\t\tfileMaker any // makeReg | makeSparse\n \t)\n \n \tvectors := []struct {\n@@ -1596,11 +1596,11 @@ func TestFileReader(t *testing.T) {\n \t\t\t\t\tt.Errorf(\"test %d.%d, expected %d more operations\", i, j, len(f.ops))\n \t\t\t\t}\n \t\t\tcase testRemaining:\n-\t\t\t\tif got := fr.LogicalRemaining(); got != tf.wantLCnt {\n-\t\t\t\t\tt.Errorf(\"test %d.%d, LogicalRemaining() = %d, want %d\", i, j, got, tf.wantLCnt)\n+\t\t\t\tif got := fr.logicalRemaining(); got != tf.wantLCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, logicalRemaining() = %d, want %d\", i, j, got, tf.wantLCnt)\n \t\t\t\t}\n-\t\t\t\tif got := fr.PhysicalRemaining(); got != tf.wantPCnt {\n-\t\t\t\t\tt.Errorf(\"test %d.%d, PhysicalRemaining() = %d, want %d\", i, j, got, tf.wantPCnt)\n+\t\t\t\tif got := fr.physicalRemaining(); got != tf.wantPCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, physicalRemaining() = %d, want %d\", i, j, got, tf.wantPCnt)\n \t\t\t\t}\n \t\t\tdefault:\n \t\t\t\tt.Fatalf(\"test %d.%d, unknown test operation: %T\", i, j, tf)"}, {"sha": "5e4a00dc4d2e3099ce810c216991c3343f1c6aea", "filename": "libgo/go/archive/tar/stat_actime1.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build aix || hurd || linux || dragonfly || openbsd || solaris\n-// +build aix hurd linux dragonfly openbsd solaris\n \n package tar\n "}, {"sha": "f76d6be220f87f89c55e553e88b5e4737484001f", "filename": "libgo/go/archive/tar/stat_actime2.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build darwin || freebsd || netbsd\n-// +build darwin freebsd netbsd\n \n package tar\n "}, {"sha": "1349f3e8b7d3f39e28716576a636e16c2a904169", "filename": "libgo/go/archive/tar/stat_unix.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build aix || hurd || linux || darwin || dragonfly || freebsd || openbsd || netbsd || solaris\n-// +build aix hurd linux darwin dragonfly freebsd openbsd netbsd solaris\n \n package tar\n "}, {"sha": "275db6f0263f2ce8f165c265bba65a272f951bad", "filename": "libgo/go/archive/tar/strconv.go", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -14,7 +14,7 @@ import (\n \n // hasNUL reports whether the NUL character exists within s.\n func hasNUL(s string) bool {\n-\treturn strings.IndexByte(s, 0) >= 0\n+\treturn strings.Contains(s, \"\\x00\")\n }\n \n // isASCII reports whether the input is an ASCII C-style string.\n@@ -201,10 +201,7 @@ func parsePAXTime(s string) (time.Time, error) {\n \tconst maxNanoSecondDigits = 9\n \n \t// Split string into seconds and sub-seconds parts.\n-\tss, sn := s, \"\"\n-\tif pos := strings.IndexByte(s, '.'); pos >= 0 {\n-\t\tss, sn = s[:pos], s[pos+1:]\n-\t}\n+\tss, sn, _ := strings.Cut(s, \".\")\n \n \t// Parse the seconds.\n \tsecs, err := strconv.ParseInt(ss, 10, 64)\n@@ -254,48 +251,32 @@ func formatPAXTime(ts time.Time) (s string) {\n // return the remainder as r.\n func parsePAXRecord(s string) (k, v, r string, err error) {\n \t// The size field ends at the first space.\n-\tsp := strings.IndexByte(s, ' ')\n-\tif sp == -1 {\n+\tnStr, rest, ok := strings.Cut(s, \" \")\n+\tif !ok {\n \t\treturn \"\", \"\", s, ErrHeader\n \t}\n \n \t// Parse the first token as a decimal integer.\n-\tn, perr := strconv.ParseInt(s[:sp], 10, 0) // Intentionally parse as native int\n-\tif perr != nil || n < 5 || int64(len(s)) < n {\n+\tn, perr := strconv.ParseInt(nStr, 10, 0) // Intentionally parse as native int\n+\tif perr != nil || n < 5 || n > int64(len(s)) {\n \t\treturn \"\", \"\", s, ErrHeader\n \t}\n-\n-\tafterSpace := int64(sp + 1)\n-\tbeforeLastNewLine := n - 1\n-\t// In some cases, \"length\" was perhaps padded/malformed, and\n-\t// trying to index past where the space supposedly is goes past\n-\t// the end of the actual record.\n-\t// For example:\n-\t//    \"0000000000000000000000000000000030 mtime=1432668921.098285006\\n30 ctime=2147483649.15163319\"\n-\t//                                  ^     ^\n-\t//                                  |     |\n-\t//                                  |  afterSpace=35\n-\t//                                  |\n-\t//                          beforeLastNewLine=29\n-\t// yet indexOf(firstSpace) MUST BE before endOfRecord.\n-\t//\n-\t// See https://golang.org/issues/40196.\n-\tif afterSpace >= beforeLastNewLine {\n+\tn -= int64(len(nStr) + 1) // convert from index in s to index in rest\n+\tif n <= 0 {\n \t\treturn \"\", \"\", s, ErrHeader\n \t}\n \n \t// Extract everything between the space and the final newline.\n-\trec, nl, rem := s[afterSpace:beforeLastNewLine], s[beforeLastNewLine:n], s[n:]\n+\trec, nl, rem := rest[:n-1], rest[n-1:n], rest[n:]\n \tif nl != \"\\n\" {\n \t\treturn \"\", \"\", s, ErrHeader\n \t}\n \n \t// The first equals separates the key from the value.\n-\teq := strings.IndexByte(rec, '=')\n-\tif eq == -1 {\n+\tk, v, ok = strings.Cut(rec, \"=\")\n+\tif !ok {\n \t\treturn \"\", \"\", s, ErrHeader\n \t}\n-\tk, v = rec[:eq], rec[eq+1:]\n \n \tif !validPAXRecord(k, v) {\n \t\treturn \"\", \"\", s, ErrHeader\n@@ -333,7 +314,7 @@ func formatPAXRecord(k, v string) (string, error) {\n // for the PAX version of the USTAR string fields.\n // The key must not contain an '=' character.\n func validPAXRecord(k, v string) bool {\n-\tif k == \"\" || strings.IndexByte(k, '=') >= 0 {\n+\tif k == \"\" || strings.Contains(k, \"=\") {\n \t\treturn false\n \t}\n \tswitch k {"}, {"sha": "a476f5eb010f21d7cc4559bf860a83aa516a0553", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -23,7 +23,7 @@ import (\n \n type testError struct{ error }\n \n-type fileOps []interface{} // []T where T is (string | int64)\n+type fileOps []any // []T where T is (string | int64)\n \n // testFile is an io.ReadWriteSeeker where the IO operations performed\n // on it must match the list of operations in ops."}, {"sha": "3729f7e82c192f685e43398a88d2777bde5c17e0", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -50,7 +50,7 @@ func (tw *Writer) Flush() error {\n \tif tw.err != nil {\n \t\treturn tw.err\n \t}\n-\tif nb := tw.curr.LogicalRemaining(); nb > 0 {\n+\tif nb := tw.curr.logicalRemaining(); nb > 0 {\n \t\treturn fmt.Errorf(\"archive/tar: missed writing %d bytes\", nb)\n \t}\n \tif _, tw.err = tw.w.Write(zeroBlock[:tw.pad]); tw.err != nil {\n@@ -117,8 +117,8 @@ func (tw *Writer) writeUSTARHeader(hdr *Header) error {\n \t// Pack the main header.\n \tvar f formatter\n \tblk := tw.templateV7Plus(hdr, f.formatString, f.formatOctal)\n-\tf.formatString(blk.USTAR().Prefix(), namePrefix)\n-\tblk.SetFormat(FormatUSTAR)\n+\tf.formatString(blk.toUSTAR().prefix(), namePrefix)\n+\tblk.setFormat(FormatUSTAR)\n \tif f.err != nil {\n \t\treturn f.err // Should never happen since header is validated\n \t}\n@@ -208,7 +208,7 @@ func (tw *Writer) writePAXHeader(hdr *Header, paxHdrs map[string]string) error {\n \tvar f formatter // Ignore errors since they are expected\n \tfmtStr := func(b []byte, s string) { f.formatString(b, toASCII(s)) }\n \tblk := tw.templateV7Plus(hdr, fmtStr, f.formatOctal)\n-\tblk.SetFormat(FormatPAX)\n+\tblk.setFormat(FormatPAX)\n \tif err := tw.writeRawHeader(blk, hdr.Size, hdr.Typeflag); err != nil {\n \t\treturn err\n \t}\n@@ -250,10 +250,10 @@ func (tw *Writer) writeGNUHeader(hdr *Header) error {\n \tvar spb []byte\n \tblk := tw.templateV7Plus(hdr, f.formatString, f.formatNumeric)\n \tif !hdr.AccessTime.IsZero() {\n-\t\tf.formatNumeric(blk.GNU().AccessTime(), hdr.AccessTime.Unix())\n+\t\tf.formatNumeric(blk.toGNU().accessTime(), hdr.AccessTime.Unix())\n \t}\n \tif !hdr.ChangeTime.IsZero() {\n-\t\tf.formatNumeric(blk.GNU().ChangeTime(), hdr.ChangeTime.Unix())\n+\t\tf.formatNumeric(blk.toGNU().changeTime(), hdr.ChangeTime.Unix())\n \t}\n \t// TODO(dsnet): Re-enable this when adding sparse support.\n \t// See https://golang.org/issue/22735\n@@ -293,7 +293,7 @@ func (tw *Writer) writeGNUHeader(hdr *Header) error {\n \t\t\tf.formatNumeric(blk.GNU().RealSize(), realSize)\n \t\t}\n \t*/\n-\tblk.SetFormat(FormatGNU)\n+\tblk.setFormat(FormatGNU)\n \tif err := tw.writeRawHeader(blk, hdr.Size, hdr.Typeflag); err != nil {\n \t\treturn err\n \t}\n@@ -321,28 +321,28 @@ type (\n // The block returned is only valid until the next call to\n // templateV7Plus or writeRawFile.\n func (tw *Writer) templateV7Plus(hdr *Header, fmtStr stringFormatter, fmtNum numberFormatter) *block {\n-\ttw.blk.Reset()\n+\ttw.blk.reset()\n \n \tmodTime := hdr.ModTime\n \tif modTime.IsZero() {\n \t\tmodTime = time.Unix(0, 0)\n \t}\n \n-\tv7 := tw.blk.V7()\n-\tv7.TypeFlag()[0] = hdr.Typeflag\n-\tfmtStr(v7.Name(), hdr.Name)\n-\tfmtStr(v7.LinkName(), hdr.Linkname)\n-\tfmtNum(v7.Mode(), hdr.Mode)\n-\tfmtNum(v7.UID(), int64(hdr.Uid))\n-\tfmtNum(v7.GID(), int64(hdr.Gid))\n-\tfmtNum(v7.Size(), hdr.Size)\n-\tfmtNum(v7.ModTime(), modTime.Unix())\n+\tv7 := tw.blk.toV7()\n+\tv7.typeFlag()[0] = hdr.Typeflag\n+\tfmtStr(v7.name(), hdr.Name)\n+\tfmtStr(v7.linkName(), hdr.Linkname)\n+\tfmtNum(v7.mode(), hdr.Mode)\n+\tfmtNum(v7.uid(), int64(hdr.Uid))\n+\tfmtNum(v7.gid(), int64(hdr.Gid))\n+\tfmtNum(v7.size(), hdr.Size)\n+\tfmtNum(v7.modTime(), modTime.Unix())\n \n-\tustar := tw.blk.USTAR()\n-\tfmtStr(ustar.UserName(), hdr.Uname)\n-\tfmtStr(ustar.GroupName(), hdr.Gname)\n-\tfmtNum(ustar.DevMajor(), hdr.Devmajor)\n-\tfmtNum(ustar.DevMinor(), hdr.Devminor)\n+\tustar := tw.blk.toUSTAR()\n+\tfmtStr(ustar.userName(), hdr.Uname)\n+\tfmtStr(ustar.groupName(), hdr.Gname)\n+\tfmtNum(ustar.devMajor(), hdr.Devmajor)\n+\tfmtNum(ustar.devMinor(), hdr.Devminor)\n \n \treturn &tw.blk\n }\n@@ -351,7 +351,7 @@ func (tw *Writer) templateV7Plus(hdr *Header, fmtStr stringFormatter, fmtNum num\n // It uses format to encode the header format and will write data as the body.\n // It uses default values for all of the other fields (as BSD and GNU tar does).\n func (tw *Writer) writeRawFile(name, data string, flag byte, format Format) error {\n-\ttw.blk.Reset()\n+\ttw.blk.reset()\n \n \t// Best effort for the filename.\n \tname = toASCII(name)\n@@ -361,15 +361,15 @@ func (tw *Writer) writeRawFile(name, data string, flag byte, format Format) erro\n \tname = strings.TrimRight(name, \"/\")\n \n \tvar f formatter\n-\tv7 := tw.blk.V7()\n-\tv7.TypeFlag()[0] = flag\n-\tf.formatString(v7.Name(), name)\n-\tf.formatOctal(v7.Mode(), 0)\n-\tf.formatOctal(v7.UID(), 0)\n-\tf.formatOctal(v7.GID(), 0)\n-\tf.formatOctal(v7.Size(), int64(len(data))) // Must be < 8GiB\n-\tf.formatOctal(v7.ModTime(), 0)\n-\ttw.blk.SetFormat(format)\n+\tv7 := tw.blk.toV7()\n+\tv7.typeFlag()[0] = flag\n+\tf.formatString(v7.name(), name)\n+\tf.formatOctal(v7.mode(), 0)\n+\tf.formatOctal(v7.uid(), 0)\n+\tf.formatOctal(v7.gid(), 0)\n+\tf.formatOctal(v7.size(), int64(len(data))) // Must be < 8GiB\n+\tf.formatOctal(v7.modTime(), 0)\n+\ttw.blk.setFormat(format)\n \tif f.err != nil {\n \t\treturn f.err // Only occurs if size condition is violated\n \t}\n@@ -511,10 +511,13 @@ func (fw *regFileWriter) ReadFrom(r io.Reader) (int64, error) {\n \treturn io.Copy(struct{ io.Writer }{fw}, r)\n }\n \n-func (fw regFileWriter) LogicalRemaining() int64 {\n+// logicalRemaining implements fileState.logicalRemaining.\n+func (fw regFileWriter) logicalRemaining() int64 {\n \treturn fw.nb\n }\n-func (fw regFileWriter) PhysicalRemaining() int64 {\n+\n+// logicalRemaining implements fileState.physicalRemaining.\n+func (fw regFileWriter) physicalRemaining() int64 {\n \treturn fw.nb\n }\n \n@@ -526,9 +529,9 @@ type sparseFileWriter struct {\n }\n \n func (sw *sparseFileWriter) Write(b []byte) (n int, err error) {\n-\toverwrite := int64(len(b)) > sw.LogicalRemaining()\n+\toverwrite := int64(len(b)) > sw.logicalRemaining()\n \tif overwrite {\n-\t\tb = b[:sw.LogicalRemaining()]\n+\t\tb = b[:sw.logicalRemaining()]\n \t}\n \n \tb0 := b\n@@ -556,7 +559,7 @@ func (sw *sparseFileWriter) Write(b []byte) (n int, err error) {\n \t\treturn n, errMissData // Not possible; implies bug in validation logic\n \tcase err != nil:\n \t\treturn n, err\n-\tcase sw.LogicalRemaining() == 0 && sw.PhysicalRemaining() > 0:\n+\tcase sw.logicalRemaining() == 0 && sw.physicalRemaining() > 0:\n \t\treturn n, errUnrefData // Not possible; implies bug in validation logic\n \tcase overwrite:\n \t\treturn n, ErrWriteTooLong\n@@ -578,12 +581,12 @@ func (sw *sparseFileWriter) ReadFrom(r io.Reader) (n int64, err error) {\n \n \tvar readLastByte bool\n \tpos0 := sw.pos\n-\tfor sw.LogicalRemaining() > 0 && !readLastByte && err == nil {\n+\tfor sw.logicalRemaining() > 0 && !readLastByte && err == nil {\n \t\tvar nf int64 // Size of fragment\n \t\tdataStart, dataEnd := sw.sp[0].Offset, sw.sp[0].endOffset()\n \t\tif sw.pos < dataStart { // In a hole fragment\n \t\t\tnf = dataStart - sw.pos\n-\t\t\tif sw.PhysicalRemaining() == 0 {\n+\t\t\tif sw.physicalRemaining() == 0 {\n \t\t\t\treadLastByte = true\n \t\t\t\tnf--\n \t\t\t}\n@@ -613,18 +616,18 @@ func (sw *sparseFileWriter) ReadFrom(r io.Reader) (n int64, err error) {\n \t\treturn n, errMissData // Not possible; implies bug in validation logic\n \tcase err != nil:\n \t\treturn n, err\n-\tcase sw.LogicalRemaining() == 0 && sw.PhysicalRemaining() > 0:\n+\tcase sw.logicalRemaining() == 0 && sw.physicalRemaining() > 0:\n \t\treturn n, errUnrefData // Not possible; implies bug in validation logic\n \tdefault:\n \t\treturn n, ensureEOF(rs)\n \t}\n }\n \n-func (sw sparseFileWriter) LogicalRemaining() int64 {\n+func (sw sparseFileWriter) logicalRemaining() int64 {\n \treturn sw.sp[len(sw.sp)-1].endOffset() - sw.pos\n }\n-func (sw sparseFileWriter) PhysicalRemaining() int64 {\n-\treturn sw.fw.PhysicalRemaining()\n+func (sw sparseFileWriter) physicalRemaining() int64 {\n+\treturn sw.fw.physicalRemaining()\n }\n \n // zeroWriter may only be written with NULs, otherwise it returns errWriteHole."}, {"sha": "da3fb89e65e51ecd17627d444af95b68e54f4596", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -67,7 +67,7 @@ func TestWriter(t *testing.T) {\n \t\ttestClose struct { // Close() == wantErr\n \t\t\twantErr error\n \t\t}\n-\t\ttestFnc interface{} // testHeader | testWrite | testReadFrom | testClose\n+\t\ttestFnc any // testHeader | testWrite | testReadFrom | testClose\n \t)\n \n \tvectors := []struct {\n@@ -987,11 +987,9 @@ func TestIssue12594(t *testing.T) {\n \t\t// The prefix field should never appear in the GNU format.\n \t\tvar blk block\n \t\tcopy(blk[:], b.Bytes())\n-\t\tprefix := string(blk.USTAR().Prefix())\n-\t\tif i := strings.IndexByte(prefix, 0); i >= 0 {\n-\t\t\tprefix = prefix[:i] // Truncate at the NUL terminator\n-\t\t}\n-\t\tif blk.GetFormat() == FormatGNU && len(prefix) > 0 && strings.HasPrefix(name, prefix) {\n+\t\tprefix := string(blk.toUSTAR().prefix())\n+\t\tprefix, _, _ = strings.Cut(prefix, \"\\x00\") // Truncate at the NUL terminator\n+\t\tif blk.getFormat() == FormatGNU && len(prefix) > 0 && strings.HasPrefix(name, prefix) {\n \t\t\tt.Errorf(\"test %d, found prefix in GNU format: %s\", i, prefix)\n \t\t}\n \n@@ -1029,11 +1027,11 @@ func TestFileWriter(t *testing.T) {\n \t\t\twantCnt int64\n \t\t\twantErr error\n \t\t}\n-\t\ttestRemaining struct { // LogicalRemaining() == wantLCnt, PhysicalRemaining() == wantPCnt\n+\t\ttestRemaining struct { // logicalRemaining() == wantLCnt, physicalRemaining() == wantPCnt\n \t\t\twantLCnt int64\n \t\t\twantPCnt int64\n \t\t}\n-\t\ttestFnc interface{} // testWrite | testReadFrom | testRemaining\n+\t\ttestFnc any // testWrite | testReadFrom | testRemaining\n \t)\n \n \ttype (\n@@ -1046,7 +1044,7 @@ func TestFileWriter(t *testing.T) {\n \t\t\tsph     sparseHoles\n \t\t\tsize    int64\n \t\t}\n-\t\tfileMaker interface{} // makeReg | makeSparse\n+\t\tfileMaker any // makeReg | makeSparse\n \t)\n \n \tvectors := []struct {\n@@ -1292,11 +1290,11 @@ func TestFileWriter(t *testing.T) {\n \t\t\t\t\tt.Errorf(\"test %d.%d, expected %d more operations\", i, j, len(f.ops))\n \t\t\t\t}\n \t\t\tcase testRemaining:\n-\t\t\t\tif got := fw.LogicalRemaining(); got != tf.wantLCnt {\n-\t\t\t\t\tt.Errorf(\"test %d.%d, LogicalRemaining() = %d, want %d\", i, j, got, tf.wantLCnt)\n+\t\t\t\tif got := fw.logicalRemaining(); got != tf.wantLCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, logicalRemaining() = %d, want %d\", i, j, got, tf.wantLCnt)\n \t\t\t\t}\n-\t\t\t\tif got := fw.PhysicalRemaining(); got != tf.wantPCnt {\n-\t\t\t\t\tt.Errorf(\"test %d.%d, PhysicalRemaining() = %d, want %d\", i, j, got, tf.wantPCnt)\n+\t\t\t\tif got := fw.physicalRemaining(); got != tf.wantPCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, physicalRemaining() = %d, want %d\", i, j, got, tf.wantPCnt)\n \t\t\t\t}\n \t\t\tdefault:\n \t\t\t\tt.Fatalf(\"test %d.%d, unknown test operation: %T\", i, j, tf)"}, {"sha": "7dffde69bf5d5f8934298bf69887cb64a525a41c", "filename": "libgo/go/archive/zip/fuzz_test.go", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Ffuzz_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Ffuzz_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ffuzz_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package zip\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+func FuzzReader(f *testing.F) {\n+\ttestdata, err := os.ReadDir(\"testdata\")\n+\tif err != nil {\n+\t\tf.Fatalf(\"failed to read testdata directory: %s\", err)\n+\t}\n+\tfor _, de := range testdata {\n+\t\tif de.IsDir() {\n+\t\t\tcontinue\n+\t\t}\n+\t\tb, err := os.ReadFile(filepath.Join(\"testdata\", de.Name()))\n+\t\tif err != nil {\n+\t\t\tf.Fatalf(\"failed to read testdata: %s\", err)\n+\t\t}\n+\t\tf.Add(b)\n+\t}\n+\n+\tf.Fuzz(func(t *testing.T, b []byte) {\n+\t\tr, err := NewReader(bytes.NewReader(b), int64(len(b)))\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ttype file struct {\n+\t\t\theader  *FileHeader\n+\t\t\tcontent []byte\n+\t\t}\n+\t\tfiles := []file{}\n+\n+\t\tfor _, f := range r.File {\n+\t\t\tfr, err := f.Open()\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcontent, err := io.ReadAll(fr)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfiles = append(files, file{header: &f.FileHeader, content: content})\n+\t\t\tif _, err := r.Open(f.Name); err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If we were unable to read anything out of the archive don't\n+\t\t// bother trying to roundtrip it.\n+\t\tif len(files) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tw := NewWriter(io.Discard)\n+\t\tfor _, f := range files {\n+\t\t\tww, err := w.CreateHeader(f.header)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"unable to write previously parsed header: %s\", err)\n+\t\t\t}\n+\t\t\tif _, err := ww.Write(f.content); err != nil {\n+\t\t\t\tt.Fatalf(\"unable to write previously parsed content: %s\", err)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif err := w.Close(); err != nil {\n+\t\t\tt.Fatalf(\"Unable to write archive: %s\", err)\n+\t\t}\n+\n+\t\t// TODO: We may want to check if the archive roundtrips.\n+\t})\n+}"}, {"sha": "92fd6f6a9252525fb392e982952cfed66ce33e13", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 36, "deletions": 70, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -125,7 +125,6 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tf.readDataDescriptor()\n \t\tz.File = append(z.File, f)\n \t}\n \tif uint16(len(z.File)) != uint16(end.directoryRecords) { // only compare 16 bits here\n@@ -186,10 +185,15 @@ func (f *File) Open() (io.ReadCloser, error) {\n \t\treturn nil, ErrAlgorithm\n \t}\n \tvar rc io.ReadCloser = dcomp(r)\n+\tvar desr io.Reader\n+\tif f.hasDataDescriptor() {\n+\t\tdesr = io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, dataDescriptorLen)\n+\t}\n \trc = &checksumReader{\n \t\trc:   rc,\n \t\thash: crc32.NewIEEE(),\n \t\tf:    f,\n+\t\tdesr: desr,\n \t}\n \treturn rc, nil\n }\n@@ -205,49 +209,13 @@ func (f *File) OpenRaw() (io.Reader, error) {\n \treturn r, nil\n }\n \n-func (f *File) readDataDescriptor() {\n-\tif !f.hasDataDescriptor() {\n-\t\treturn\n-\t}\n-\n-\tbodyOffset, err := f.findBodyOffset()\n-\tif err != nil {\n-\t\tf.descErr = err\n-\t\treturn\n-\t}\n-\n-\t// In section 4.3.9.2 of the spec: \"However ZIP64 format MAY be used\n-\t// regardless of the size of a file.  When extracting, if the zip64\n-\t// extended information extra field is present for the file the\n-\t// compressed and uncompressed sizes will be 8 byte values.\"\n-\t//\n-\t// Historically, this package has used the compressed and uncompressed\n-\t// sizes from the central directory to determine if the package is\n-\t// zip64.\n-\t//\n-\t// For this case we allow either the extra field or sizes to determine\n-\t// the data descriptor length.\n-\tzip64 := f.zip64 || f.isZip64()\n-\tn := int64(dataDescriptorLen)\n-\tif zip64 {\n-\t\tn = dataDescriptor64Len\n-\t}\n-\tsize := int64(f.CompressedSize64)\n-\tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, n)\n-\tdd, err := readDataDescriptor(r, zip64)\n-\tif err != nil {\n-\t\tf.descErr = err\n-\t\treturn\n-\t}\n-\tf.CRC32 = dd.crc32\n-}\n-\n type checksumReader struct {\n \trc    io.ReadCloser\n \thash  hash.Hash32\n \tnread uint64 // number of bytes read so far\n \tf     *File\n-\terr   error // sticky error\n+\tdesr  io.Reader // if non-nil, where to read the data descriptor\n+\terr   error     // sticky error\n }\n \n func (r *checksumReader) Stat() (fs.FileInfo, error) {\n@@ -268,12 +236,12 @@ func (r *checksumReader) Read(b []byte) (n int, err error) {\n \t\tif r.nread != r.f.UncompressedSize64 {\n \t\t\treturn 0, io.ErrUnexpectedEOF\n \t\t}\n-\t\tif r.f.hasDataDescriptor() {\n-\t\t\tif r.f.descErr != nil {\n-\t\t\t\tif r.f.descErr == io.EOF {\n+\t\tif r.desr != nil {\n+\t\t\tif err1 := readDataDescriptor(r.desr, r.f); err1 != nil {\n+\t\t\t\tif err1 == io.EOF {\n \t\t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t\t} else {\n-\t\t\t\t\terr = r.f.descErr\n+\t\t\t\t\terr = err1\n \t\t\t\t}\n \t\t\t} else if r.hash.Sum32() != r.f.CRC32 {\n \t\t\t\terr = ErrChecksum\n@@ -485,10 +453,8 @@ parseExtras:\n \treturn nil\n }\n \n-func readDataDescriptor(r io.Reader, zip64 bool) (*dataDescriptor, error) {\n-\t// Create enough space for the largest possible size\n-\tvar buf [dataDescriptor64Len]byte\n-\n+func readDataDescriptor(r io.Reader, f *File) error {\n+\tvar buf [dataDescriptorLen]byte\n \t// The spec says: \"Although not originally assigned a\n \t// signature, the value 0x08074b50 has commonly been adopted\n \t// as a signature value for the data descriptor record.\n@@ -497,9 +463,10 @@ func readDataDescriptor(r io.Reader, zip64 bool) (*dataDescriptor, error) {\n \t// descriptors and should account for either case when reading\n \t// ZIP files to ensure compatibility.\"\n \t//\n-\t// First read just those 4 bytes to see if the signature exists.\n+\t// dataDescriptorLen includes the size of the signature but\n+\t// first read just those 4 bytes to see if it exists.\n \tif _, err := io.ReadFull(r, buf[:4]); err != nil {\n-\t\treturn nil, err\n+\t\treturn err\n \t}\n \toff := 0\n \tmaybeSig := readBuf(buf[:4])\n@@ -508,28 +475,21 @@ func readDataDescriptor(r io.Reader, zip64 bool) (*dataDescriptor, error) {\n \t\t// bytes.\n \t\toff += 4\n \t}\n-\n-\tend := dataDescriptorLen - 4\n-\tif zip64 {\n-\t\tend = dataDescriptor64Len - 4\n+\tif _, err := io.ReadFull(r, buf[off:12]); err != nil {\n+\t\treturn err\n \t}\n-\tif _, err := io.ReadFull(r, buf[off:end]); err != nil {\n-\t\treturn nil, err\n+\tb := readBuf(buf[:12])\n+\tif b.uint32() != f.CRC32 {\n+\t\treturn ErrChecksum\n \t}\n-\tb := readBuf(buf[:end])\n \n-\tout := &dataDescriptor{\n-\t\tcrc32: b.uint32(),\n-\t}\n+\t// The two sizes that follow here can be either 32 bits or 64 bits\n+\t// but the spec is not very clear on this and different\n+\t// interpretations has been made causing incompatibilities. We\n+\t// already have the sizes from the central directory so we can\n+\t// just ignore these.\n \n-\tif zip64 {\n-\t\tout.compressedSize = b.uint64()\n-\t\tout.uncompressedSize = b.uint64()\n-\t} else {\n-\t\tout.compressedSize = uint64(b.uint32())\n-\t\tout.uncompressedSize = uint64(b.uint32())\n-\t}\n-\treturn out, nil\n+\treturn nil\n }\n \n func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error) {\n@@ -710,7 +670,7 @@ func (f *fileListEntry) Size() int64       { return 0 }\n func (f *fileListEntry) Mode() fs.FileMode { return fs.ModeDir | 0555 }\n func (f *fileListEntry) Type() fs.FileMode { return fs.ModeDir }\n func (f *fileListEntry) IsDir() bool       { return true }\n-func (f *fileListEntry) Sys() interface{}  { return nil }\n+func (f *fileListEntry) Sys() any          { return nil }\n \n func (f *fileListEntry) ModTime() time.Time {\n \tif f.file == nil {\n@@ -741,6 +701,9 @@ func (r *Reader) initFileList() {\n \t\tfor _, file := range r.File {\n \t\t\tisDir := len(file.Name) > 0 && file.Name[len(file.Name)-1] == '/'\n \t\t\tname := toValidName(file.Name)\n+\t\t\tif name == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tfor dir := path.Dir(name); dir != \".\"; dir = path.Dir(dir) {\n \t\t\t\tdirs[dir] = true\n \t\t\t}\n@@ -782,8 +745,11 @@ func fileEntryLess(x, y string) bool {\n func (r *Reader) Open(name string) (fs.File, error) {\n \tr.initFileList()\n \n+\tif !fs.ValidPath(name) {\n+\t\treturn nil, &fs.PathError{Op: \"open\", Path: name, Err: fs.ErrInvalid}\n+\t}\n \te := r.openLookup(name)\n-\tif e == nil || !fs.ValidPath(name) {\n+\tif e == nil {\n \t\treturn nil, &fs.PathError{Op: \"open\", Path: name, Err: fs.ErrNotExist}\n \t}\n \tif e.isDir {\n@@ -797,7 +763,7 @@ func (r *Reader) Open(name string) (fs.File, error) {\n }\n \n func split(name string) (dir, elem string, isDir bool) {\n-\tif name[len(name)-1] == '/' {\n+\tif len(name) > 0 && name[len(name)-1] == '/' {\n \t\tisDir = true\n \t\tname = name[:len(name)-1]\n \t}"}, {"sha": "d1a9bdd3346e519cb8afc75fc13475094e7249ad", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 127, "deletions": 121, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"reflect\"\n \t\"regexp\"\n \t\"strings\"\n \t\"testing\"\n@@ -1202,127 +1203,14 @@ func TestCVE202127919(t *testing.T) {\n \tif err != nil {\n \t\tt.Errorf(\"Error reading file: %v\", err)\n \t}\n-}\n-\n-func TestReadDataDescriptor(t *testing.T) {\n-\ttests := []struct {\n-\t\tdesc    string\n-\t\tin      []byte\n-\t\tzip64   bool\n-\t\twant    *dataDescriptor\n-\t\twantErr error\n-\t}{{\n-\t\tdesc: \"valid 32 bit with signature\",\n-\t\tin: []byte{\n-\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, 0x06, 0x07, // compressed size\n-\t\t\t0x08, 0x09, 0x0a, 0x0b, // uncompressed size\n-\t\t},\n-\t\twant: &dataDescriptor{\n-\t\t\tcrc32:            0x03020100,\n-\t\t\tcompressedSize:   0x07060504,\n-\t\t\tuncompressedSize: 0x0b0a0908,\n-\t\t},\n-\t}, {\n-\t\tdesc: \"valid 32 bit without signature\",\n-\t\tin: []byte{\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, 0x06, 0x07, // compressed size\n-\t\t\t0x08, 0x09, 0x0a, 0x0b, // uncompressed size\n-\t\t},\n-\t\twant: &dataDescriptor{\n-\t\t\tcrc32:            0x03020100,\n-\t\t\tcompressedSize:   0x07060504,\n-\t\t\tuncompressedSize: 0x0b0a0908,\n-\t\t},\n-\t}, {\n-\t\tdesc: \"valid 64 bit with signature\",\n-\t\tin: []byte{\n-\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n-\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, // uncompressed size\n-\t\t},\n-\t\tzip64: true,\n-\t\twant: &dataDescriptor{\n-\t\t\tcrc32:            0x03020100,\n-\t\t\tcompressedSize:   0x0b0a090807060504,\n-\t\t\tuncompressedSize: 0x131211100f0e0d0c,\n-\t\t},\n-\t}, {\n-\t\tdesc: \"valid 64 bit without signature\",\n-\t\tin: []byte{\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n-\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, // uncompressed size\n-\t\t},\n-\t\tzip64: true,\n-\t\twant: &dataDescriptor{\n-\t\t\tcrc32:            0x03020100,\n-\t\t\tcompressedSize:   0x0b0a090807060504,\n-\t\t\tuncompressedSize: 0x131211100f0e0d0c,\n-\t\t},\n-\t}, {\n-\t\tdesc: \"invalid 32 bit with signature\",\n-\t\tin: []byte{\n-\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, // unexpected end\n-\t\t},\n-\t\twantErr: io.ErrUnexpectedEOF,\n-\t}, {\n-\t\tdesc: \"invalid 32 bit without signature\",\n-\t\tin: []byte{\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, // unexpected end\n-\t\t},\n-\t\twantErr: io.ErrUnexpectedEOF,\n-\t}, {\n-\t\tdesc: \"invalid 64 bit with signature\",\n-\t\tin: []byte{\n-\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n-\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, // unexpected end\n-\t\t},\n-\t\tzip64:   true,\n-\t\twantErr: io.ErrUnexpectedEOF,\n-\t}, {\n-\t\tdesc: \"invalid 64 bit without signature\",\n-\t\tin: []byte{\n-\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n-\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n-\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, // unexpected end\n-\t\t},\n-\t\tzip64:   true,\n-\t\twantErr: io.ErrUnexpectedEOF,\n-\t}}\n-\n-\tfor _, test := range tests {\n-\t\tt.Run(test.desc, func(t *testing.T) {\n-\t\t\tr := bytes.NewReader(test.in)\n-\n-\t\t\tdesc, err := readDataDescriptor(r, test.zip64)\n-\t\t\tif err != test.wantErr {\n-\t\t\t\tt.Fatalf(\"got err %v; want nil\", err)\n-\t\t\t}\n-\t\t\tif test.want == nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif desc == nil {\n-\t\t\t\tt.Fatalf(\"got nil DataDescriptor; want non-nil\")\n-\t\t\t}\n-\t\t\tif desc.crc32 != test.want.crc32 {\n-\t\t\t\tt.Errorf(\"got CRC32 %#x; want %#x\", desc.crc32, test.want.crc32)\n-\t\t\t}\n-\t\t\tif desc.compressedSize != test.want.compressedSize {\n-\t\t\t\tt.Errorf(\"got CompressedSize %#x; want %#x\", desc.compressedSize, test.want.compressedSize)\n-\t\t\t}\n-\t\t\tif desc.uncompressedSize != test.want.uncompressedSize {\n-\t\t\t\tt.Errorf(\"got UncompressedSize %#x; want %#x\", desc.uncompressedSize, test.want.uncompressedSize)\n-\t\t\t}\n-\t\t})\n+\tif len(r.File) != 1 {\n+\t\tt.Fatalf(\"No entries in the file list\")\n+\t}\n+\tif r.File[0].Name != \"../test.txt\" {\n+\t\tt.Errorf(\"Unexpected entry name: %s\", r.File[0].Name)\n+\t}\n+\tif _, err := r.File[0].Open(); err != nil {\n+\t\tt.Errorf(\"Error opening file: %v\", err)\n \t}\n }\n \n@@ -1402,3 +1290,121 @@ func TestCVE202139293(t *testing.T) {\n \t\tt.Fatalf(\"unexpected error, got: %v, want: %v\", err, ErrFormat)\n \t}\n }\n+\n+func TestCVE202141772(t *testing.T) {\n+\t// Archive contains a file whose name is exclusively made up of '/', '\\'\n+\t// characters, or \"../\", \"..\\\" paths, which would previously cause a panic.\n+\t//\n+\t//  Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n+\t// --------  ------  ------- ---- ---------- ----- --------  ----\n+\t//        0  Stored        0   0% 08-05-2021 18:32 00000000  /\n+\t//        0  Stored        0   0% 09-14-2021 12:59 00000000  //\n+\t//        0  Stored        0   0% 09-14-2021 12:59 00000000  \\\n+\t//       11  Stored       11   0% 09-14-2021 13:04 0d4a1185  /test.txt\n+\t// --------          -------  ---                            -------\n+\t//       11               11   0%                            4 files\n+\tdata := []byte{\n+\t\t0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x08,\n+\t\t0x00, 0x00, 0x06, 0x94, 0x05, 0x53, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2f, 0x50,\n+\t\t0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x78, 0x67, 0x2e, 0x53, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x02, 0x00, 0x00, 0x00, 0x2f, 0x2f, 0x50,\n+\t\t0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x78, 0x67, 0x2e, 0x53, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x01, 0x00, 0x00, 0x00, 0x5c, 0x50, 0x4b,\n+\t\t0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x91, 0x68, 0x2e, 0x53, 0x85, 0x11, 0x4a, 0x0d,\n+\t\t0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,\n+\t\t0x09, 0x00, 0x00, 0x00, 0x2f, 0x74, 0x65, 0x73,\n+\t\t0x74, 0x2e, 0x74, 0x78, 0x74, 0x68, 0x65, 0x6c,\n+\t\t0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64,\n+\t\t0x50, 0x4b, 0x01, 0x02, 0x14, 0x03, 0x0a, 0x00,\n+\t\t0x00, 0x08, 0x00, 0x00, 0x06, 0x94, 0x05, 0x53,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n+\t\t0xed, 0x41, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x50,\n+\t\t0x4b, 0x01, 0x02, 0x3f, 0x00, 0x0a, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x78, 0x67, 0x2e, 0x53, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x02, 0x00, 0x24, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,\n+\t\t0x00, 0x1f, 0x00, 0x00, 0x00, 0x2f, 0x2f, 0x0a,\n+\t\t0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+\t\t0x00, 0x18, 0x00, 0x93, 0x98, 0x25, 0x57, 0x25,\n+\t\t0xa9, 0xd7, 0x01, 0x93, 0x98, 0x25, 0x57, 0x25,\n+\t\t0xa9, 0xd7, 0x01, 0x93, 0x98, 0x25, 0x57, 0x25,\n+\t\t0xa9, 0xd7, 0x01, 0x50, 0x4b, 0x01, 0x02, 0x3f,\n+\t\t0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,\n+\t\t0x67, 0x2e, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+\t\t0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x20, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00,\n+\t\t0x00, 0x5c, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x93, 0x98,\n+\t\t0x25, 0x57, 0x25, 0xa9, 0xd7, 0x01, 0x93, 0x98,\n+\t\t0x25, 0x57, 0x25, 0xa9, 0xd7, 0x01, 0x93, 0x98,\n+\t\t0x25, 0x57, 0x25, 0xa9, 0xd7, 0x01, 0x50, 0x4b,\n+\t\t0x01, 0x02, 0x3f, 0x00, 0x0a, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x91, 0x68, 0x2e, 0x53, 0x85, 0x11,\n+\t\t0x4a, 0x0d, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00,\n+\t\t0x00, 0x00, 0x09, 0x00, 0x24, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,\n+\t\t0x5e, 0x00, 0x00, 0x00, 0x2f, 0x74, 0x65, 0x73,\n+\t\t0x74, 0x2e, 0x74, 0x78, 0x74, 0x0a, 0x00, 0x20,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18,\n+\t\t0x00, 0xa9, 0x80, 0x51, 0x01, 0x26, 0xa9, 0xd7,\n+\t\t0x01, 0x31, 0xd1, 0x57, 0x01, 0x26, 0xa9, 0xd7,\n+\t\t0x01, 0xdf, 0x48, 0x85, 0xf9, 0x25, 0xa9, 0xd7,\n+\t\t0x01, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x04, 0x00, 0x04, 0x00, 0x31, 0x01, 0x00,\n+\t\t0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\tr, err := NewReader(bytes.NewReader([]byte(data)), int64(len(data)))\n+\tif err != nil {\n+\t\tt.Fatalf(\"Error reading the archive: %v\", err)\n+\t}\n+\tentryNames := []string{`/`, `//`, `\\`, `/test.txt`}\n+\tvar names []string\n+\tfor _, f := range r.File {\n+\t\tnames = append(names, f.Name)\n+\t\tif _, err := f.Open(); err != nil {\n+\t\t\tt.Errorf(\"Error opening %q: %v\", f.Name, err)\n+\t\t}\n+\t\tif _, err := r.Open(f.Name); err == nil {\n+\t\t\tt.Errorf(\"Opening %q with fs.FS API succeeded\", f.Name)\n+\t\t}\n+\t}\n+\tif !reflect.DeepEqual(names, entryNames) {\n+\t\tt.Errorf(\"Unexpected file entries: %q\", names)\n+\t}\n+\tif _, err := r.Open(\"\"); err == nil {\n+\t\tt.Errorf(\"Opening %q with fs.FS API succeeded\", \"\")\n+\t}\n+\tif _, err := r.Open(\"test.txt\"); err != nil {\n+\t\tt.Errorf(\"Error opening %q with fs.FS API: %v\", \"test.txt\", err)\n+\t}\n+\tdirEntries, err := fs.ReadDir(r, \".\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Error reading the root directory: %v\", err)\n+\t}\n+\tif len(dirEntries) != 1 || dirEntries[0].Name() != \"test.txt\" {\n+\t\tt.Errorf(\"Unexpected directory entries\")\n+\t\tfor _, dirEntry := range dirEntries {\n+\t\t\t_, err := r.Open(dirEntry.Name())\n+\t\t\tt.Logf(\"%q (Open error: %v)\", dirEntry.Name(), err)\n+\t\t}\n+\t\tt.FailNow()\n+\t}\n+\tinfo, err := dirEntries[0].Info()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Error reading info entry: %v\", err)\n+\t}\n+\tif name := info.Name(); name != \"test.txt\" {\n+\t\tt.Errorf(\"Inconsistent name in info entry: %v\", name)\n+\t}\n+}"}, {"sha": "6f73fb8376a859235ff3d589a3a0314bc9311721", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -163,7 +163,7 @@ func (fi headerFileInfo) ModTime() time.Time {\n }\n func (fi headerFileInfo) Mode() fs.FileMode { return fi.fh.Mode() }\n func (fi headerFileInfo) Type() fs.FileMode { return fi.fh.Mode().Type() }\n-func (fi headerFileInfo) Sys() interface{}  { return fi.fh }\n+func (fi headerFileInfo) Sys() any          { return fi.fh }\n \n func (fi headerFileInfo) Info() (fs.FileInfo, error) { return fi, nil }\n \n@@ -390,11 +390,3 @@ func unixModeToFileMode(m uint32) fs.FileMode {\n \t}\n \treturn mode\n }\n-\n-// dataDescriptor holds the data descriptor that optionally follows the file\n-// contents in the zip file.\n-type dataDescriptor struct {\n-\tcrc32            uint32\n-\tcompressedSize   uint64\n-\tuncompressedSize uint64\n-}"}, {"sha": "2b73eca814f621a9a0289f24cf0b6bbe8df35c6c", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -362,7 +362,7 @@ func TestWriterDirAttributes(t *testing.T) {\n \t}\n \n \tbinary.LittleEndian.PutUint32(sig[:], uint32(dataDescriptorSignature))\n-\tif bytes.Index(b, sig[:]) != -1 {\n+\tif bytes.Contains(b, sig[:]) {\n \t\tt.Error(\"there should be no data descriptor\")\n \t}\n }"}, {"sha": "7483946fc0aabf3e0dffaa07608369c1f473a0f3", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -68,7 +68,12 @@ func (b *Reader) Size() int { return len(b.buf) }\n \n // Reset discards any buffered data, resets all state, and switches\n // the buffered reader to read from r.\n+// Calling Reset on the zero value of Reader initializes the internal buffer\n+// to the default size.\n func (b *Reader) Reset(r io.Reader) {\n+\tif b.buf == nil {\n+\t\tb.buf = make([]byte, defaultBufSize)\n+\t}\n \tb.reset(b.buf, r)\n }\n \n@@ -168,6 +173,10 @@ func (b *Reader) Discard(n int) (discarded int, err error) {\n \tif n == 0 {\n \t\treturn\n \t}\n+\n+\tb.lastByte = -1\n+\tb.lastRuneSize = -1\n+\n \tremain := n\n \tfor {\n \t\tskip := b.Buffered()\n@@ -235,6 +244,8 @@ func (b *Reader) Read(p []byte) (n int, err error) {\n \t}\n \n \t// copy as much as we can\n+\t// Note: if the slice panics here, it is probably because\n+\t// the underlying reader returned a bad count. See issue 49795.\n \tn = copy(p, b.buf[b.r:b.w])\n \tb.r += n\n \tb.lastByte = int(b.buf[b.r-1])\n@@ -261,8 +272,8 @@ func (b *Reader) ReadByte() (byte, error) {\n // UnreadByte unreads the last byte. Only the most recently read byte can be unread.\n //\n // UnreadByte returns an error if the most recent method called on the\n-// Reader was not a read operation. Notably, Peek is not considered a\n-// read operation.\n+// Reader was not a read operation. Notably, Peek, Discard, and WriteTo are not\n+// considered read operations.\n func (b *Reader) UnreadByte() error {\n \tif b.lastByte < 0 || b.r == 0 && b.w > 0 {\n \t\treturn ErrInvalidUnreadByte\n@@ -497,6 +508,9 @@ func (b *Reader) ReadString(delim byte) (string, error) {\n // If the underlying reader supports the WriteTo method,\n // this calls the underlying WriteTo without buffering.\n func (b *Reader) WriteTo(w io.Writer) (n int64, err error) {\n+\tb.lastByte = -1\n+\tb.lastRuneSize = -1\n+\n \tn, err = b.writeBuf(w)\n \tif err != nil {\n \t\treturn\n@@ -581,6 +595,8 @@ func NewWriterSize(w io.Writer, size int) *Writer {\n }\n \n // NewWriter returns a new Writer whose buffer has the default size.\n+// If the argument io.Writer is already a Writer with large enough buffer size,\n+// it returns the underlying Writer.\n func NewWriter(w io.Writer) *Writer {\n \treturn NewWriterSize(w, defaultBufSize)\n }\n@@ -590,7 +606,12 @@ func (b *Writer) Size() int { return len(b.buf) }\n \n // Reset discards any unflushed buffered data, clears any error, and\n // resets b to write its output to w.\n+// Calling Reset on the zero value of Writer initializes the internal buffer\n+// to the default size.\n func (b *Writer) Reset(w io.Writer) {\n+\tif b.buf == nil {\n+\t\tb.buf = make([]byte, defaultBufSize)\n+\t}\n \tb.err = nil\n \tb.n = 0\n \tb.wr = w\n@@ -623,6 +644,14 @@ func (b *Writer) Flush() error {\n // Available returns how many bytes are unused in the buffer.\n func (b *Writer) Available() int { return len(b.buf) - b.n }\n \n+// AvailableBuffer returns an empty buffer with b.Available() capacity.\n+// This buffer is intended to be appended to and\n+// passed to an immediately succeeding Write call.\n+// The buffer is only valid until the next write operation on b.\n+func (b *Writer) AvailableBuffer() []byte {\n+\treturn b.buf[b.n:][:0]\n+}\n+\n // Buffered returns the number of bytes that have been written into the current buffer.\n func (b *Writer) Buffered() int { return b.n }\n \n@@ -720,26 +749,27 @@ func (b *Writer) WriteString(s string) (int, error) {\n }\n \n // ReadFrom implements io.ReaderFrom. If the underlying writer\n-// supports the ReadFrom method, and b has no buffered data yet,\n-// this calls the underlying ReadFrom without buffering.\n+// supports the ReadFrom method, this calls the underlying ReadFrom.\n+// If there is buffered data and an underlying ReadFrom, this fills\n+// the buffer and writes it before calling ReadFrom.\n func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n \tif b.err != nil {\n \t\treturn 0, b.err\n \t}\n-\tif b.Buffered() == 0 {\n-\t\tif w, ok := b.wr.(io.ReaderFrom); ok {\n-\t\t\tn, err = w.ReadFrom(r)\n-\t\t\tb.err = err\n-\t\t\treturn n, err\n-\t\t}\n-\t}\n+\treaderFrom, readerFromOK := b.wr.(io.ReaderFrom)\n \tvar m int\n \tfor {\n \t\tif b.Available() == 0 {\n \t\t\tif err1 := b.Flush(); err1 != nil {\n \t\t\t\treturn n, err1\n \t\t\t}\n \t\t}\n+\t\tif readerFromOK && b.Buffered() == 0 {\n+\t\t\tnn, err := readerFrom.ReadFrom(r)\n+\t\t\tb.err = err\n+\t\t\tn += nn\n+\t\t\treturn n, err\n+\t\t}\n \t\tnr := 0\n \t\tfor nr < maxConsecutiveEmptyReads {\n \t\t\tm, err = r.Read(b.buf[b.n:])"}, {"sha": "ff3396e94693012bdd5dad047f96aa9db7bb9e60", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 140, "deletions": 2, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -10,6 +10,8 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"math/rand\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n \t\"testing/iotest\"\n@@ -302,6 +304,40 @@ func TestNoUnreadByteAfterPeek(t *testing.T) {\n \t}\n }\n \n+func TestNoUnreadRuneAfterDiscard(t *testing.T) {\n+\tbr := NewReader(strings.NewReader(\"example\"))\n+\tbr.ReadRune()\n+\tbr.Discard(1)\n+\tif err := br.UnreadRune(); err == nil {\n+\t\tt.Error(\"UnreadRune didn't fail after Discard\")\n+\t}\n+}\n+\n+func TestNoUnreadByteAfterDiscard(t *testing.T) {\n+\tbr := NewReader(strings.NewReader(\"example\"))\n+\tbr.ReadByte()\n+\tbr.Discard(1)\n+\tif err := br.UnreadByte(); err == nil {\n+\t\tt.Error(\"UnreadByte didn't fail after Discard\")\n+\t}\n+}\n+\n+func TestNoUnreadRuneAfterWriteTo(t *testing.T) {\n+\tbr := NewReader(strings.NewReader(\"example\"))\n+\tbr.WriteTo(io.Discard)\n+\tif err := br.UnreadRune(); err == nil {\n+\t\tt.Error(\"UnreadRune didn't fail after WriteTo\")\n+\t}\n+}\n+\n+func TestNoUnreadByteAfterWriteTo(t *testing.T) {\n+\tbr := NewReader(strings.NewReader(\"example\"))\n+\tbr.WriteTo(io.Discard)\n+\tif err := br.UnreadByte(); err == nil {\n+\t\tt.Error(\"UnreadByte didn't fail after WriteTo\")\n+\t}\n+}\n+\n func TestUnreadByte(t *testing.T) {\n \tsegments := []string{\"Hello, \", \"world\"}\n \tr := NewReader(&StringReader{data: segments})\n@@ -608,6 +644,37 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n+func TestWriterAppend(t *testing.T) {\n+\tgot := new(bytes.Buffer)\n+\tvar want []byte\n+\trn := rand.New(rand.NewSource(0))\n+\tw := NewWriterSize(got, 64)\n+\tfor i := 0; i < 100; i++ {\n+\t\t// Obtain a buffer to append to.\n+\t\tb := w.AvailableBuffer()\n+\t\tif w.Available() != cap(b) {\n+\t\t\tt.Fatalf(\"Available() = %v, want %v\", w.Available(), cap(b))\n+\t\t}\n+\n+\t\t// While not recommended, it is valid to append to a shifted buffer.\n+\t\t// This forces Write to copy the input.\n+\t\tif rn.Intn(8) == 0 && cap(b) > 0 {\n+\t\t\tb = b[1:1:cap(b)]\n+\t\t}\n+\n+\t\t// Append a random integer of varying width.\n+\t\tn := int64(rn.Intn(1 << rn.Intn(30)))\n+\t\twant = append(strconv.AppendInt(want, n, 10), ' ')\n+\t\tb = append(strconv.AppendInt(b, n, 10), ' ')\n+\t\tw.Write(b)\n+\t}\n+\tw.Flush()\n+\n+\tif !bytes.Equal(got.Bytes(), want) {\n+\t\tt.Errorf(\"output mismatch:\\ngot  %s\\nwant %s\", got.Bytes(), want)\n+\t}\n+}\n+\n // Check that write errors are returned properly.\n \n type errorWriterTest struct {\n@@ -1284,6 +1351,54 @@ func TestWriterReadFromErrNoProgress(t *testing.T) {\n \t}\n }\n \n+type readFromWriter struct {\n+\tbuf           []byte\n+\twriteBytes    int\n+\treadFromBytes int\n+}\n+\n+func (w *readFromWriter) Write(p []byte) (int, error) {\n+\tw.buf = append(w.buf, p...)\n+\tw.writeBytes += len(p)\n+\treturn len(p), nil\n+}\n+\n+func (w *readFromWriter) ReadFrom(r io.Reader) (int64, error) {\n+\tb, err := io.ReadAll(r)\n+\tw.buf = append(w.buf, b...)\n+\tw.readFromBytes += len(b)\n+\treturn int64(len(b)), err\n+}\n+\n+// Test that calling (*Writer).ReadFrom with a partially-filled buffer\n+// fills the buffer before switching over to ReadFrom.\n+func TestWriterReadFromWithBufferedData(t *testing.T) {\n+\tconst bufsize = 16\n+\n+\tinput := createTestInput(64)\n+\trfw := &readFromWriter{}\n+\tw := NewWriterSize(rfw, bufsize)\n+\n+\tconst writeSize = 8\n+\tif n, err := w.Write(input[:writeSize]); n != writeSize || err != nil {\n+\t\tt.Errorf(\"w.Write(%v bytes) = %v, %v; want %v, nil\", writeSize, n, err, writeSize)\n+\t}\n+\tn, err := w.ReadFrom(bytes.NewReader(input[writeSize:]))\n+\tif wantn := len(input[writeSize:]); int(n) != wantn || err != nil {\n+\t\tt.Errorf(\"io.Copy(w, %v bytes) = %v, %v; want %v, nil\", wantn, n, err, wantn)\n+\t}\n+\tif err := w.Flush(); err != nil {\n+\t\tt.Errorf(\"w.Flush() = %v, want nil\", err)\n+\t}\n+\n+\tif got, want := rfw.writeBytes, bufsize; got != want {\n+\t\tt.Errorf(\"wrote %v bytes with Write, want %v\", got, want)\n+\t}\n+\tif got, want := rfw.readFromBytes, len(input)-bufsize; got != want {\n+\t\tt.Errorf(\"wrote %v bytes with ReadFrom, want %v\", got, want)\n+\t}\n+}\n+\n func TestReadZero(t *testing.T) {\n \tfor _, size := range []int{100, 2} {\n \t\tt.Run(fmt.Sprintf(\"bufsize=%d\", size), func(t *testing.T) {\n@@ -1312,6 +1427,7 @@ func TestReaderReset(t *testing.T) {\n \tif string(buf) != \"foo\" {\n \t\tt.Errorf(\"buf = %q; want foo\", buf)\n \t}\n+\n \tr.Reset(strings.NewReader(\"bar bar\"))\n \tall, err := io.ReadAll(r)\n \tif err != nil {\n@@ -1320,12 +1436,23 @@ func TestReaderReset(t *testing.T) {\n \tif string(all) != \"bar bar\" {\n \t\tt.Errorf(\"ReadAll = %q; want bar bar\", all)\n \t}\n+\n+\t*r = Reader{} // zero out the Reader\n+\tr.Reset(strings.NewReader(\"bar bar\"))\n+\tall, err = io.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(all) != \"bar bar\" {\n+\t\tt.Errorf(\"ReadAll = %q; want bar bar\", all)\n+\t}\n }\n \n func TestWriterReset(t *testing.T) {\n-\tvar buf1, buf2 bytes.Buffer\n+\tvar buf1, buf2, buf3 bytes.Buffer\n \tw := NewWriter(&buf1)\n \tw.WriteString(\"foo\")\n+\n \tw.Reset(&buf2) // and not flushed\n \tw.WriteString(\"bar\")\n \tw.Flush()\n@@ -1335,6 +1462,17 @@ func TestWriterReset(t *testing.T) {\n \tif buf2.String() != \"bar\" {\n \t\tt.Errorf(\"buf2 = %q; want bar\", buf2.String())\n \t}\n+\n+\t*w = Writer{}  // zero out the Writer\n+\tw.Reset(&buf3) // and not flushed\n+\tw.WriteString(\"bar\")\n+\tw.Flush()\n+\tif buf1.String() != \"\" {\n+\t\tt.Errorf(\"buf1 = %q; want empty\", buf1.String())\n+\t}\n+\tif buf3.String() != \"bar\" {\n+\t\tt.Errorf(\"buf3 = %q; want bar\", buf3.String())\n+\t}\n }\n \n func TestReaderDiscard(t *testing.T) {\n@@ -1382,7 +1520,7 @@ func TestReaderDiscard(t *testing.T) {\n \t\t\twantBuffered: 0,\n \t\t},\n \t\t// Any error from filling shouldn't show up until we\n-\t\t// get past the valid bytes. Here we return we return 5 valid bytes at the same time\n+\t\t// get past the valid bytes. Here we return 5 valid bytes at the same time\n \t\t// as an error, but test that we don't see the error from Discard.\n \t\t{\n \t\t\tname: \"fill error, discard less\","}, {"sha": "a864d11012e77f96bc2a24dc692ce967c73270e3", "filename": "libgo/go/bufio/example_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbufio%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbufio%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fexample_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -20,6 +20,18 @@ func ExampleWriter() {\n \t// Output: Hello, world!\n }\n \n+func ExampleWriter_AvailableBuffer() {\n+\tw := bufio.NewWriter(os.Stdout)\n+\tfor _, i := range []int64{1, 2, 3, 4} {\n+\t\tb := w.AvailableBuffer()\n+\t\tb = strconv.AppendInt(b, i, 10)\n+\t\tb = append(b, ' ')\n+\t\tw.Write(b)\n+\t}\n+\tw.Flush()\n+\t// Output: 1 2 3 4\n+}\n+\n // The simplest use of a Scanner, to read standard input as a set of lines.\n func ExampleScanner_lines() {\n \tscanner := bufio.NewScanner(os.Stdin)"}, {"sha": "08ae7ed313add4fb435b154605d143188747f302", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -91,6 +91,16 @@ type byte = uint8\n // used, by convention, to distinguish character values from integer values.\n type rune = int32\n \n+// any is an alias for interface{} and is equivalent to interface{} in all ways.\n+type any = interface{}\n+\n+// comparable is an interface that is implemented by all comparable types\n+// (booleans, numbers, strings, pointers, channels, interfaces,\n+// arrays of comparable types, structs whose fields are all comparable types).\n+// The comparable interface may only be used as a type parameter constraint,\n+// not as the type of a variable.\n+type comparable comparable\n+\n // iota is a predeclared identifier representing the untyped integer ordinal\n // number of the current const specification in a (usually parenthesized)\n // const declaration. It is zero-indexed.\n@@ -229,7 +239,7 @@ func close(c chan<- Type)\n // that point, the program is terminated with a non-zero exit code. This\n // termination sequence is called panicking and can be controlled by the\n // built-in function recover.\n-func panic(v interface{})\n+func panic(v any)\n \n // The recover built-in function allows a program to manage behavior of a\n // panicking goroutine. Executing a call to recover inside a deferred\n@@ -240,7 +250,7 @@ func panic(v interface{})\n // panicking, or if the argument supplied to panic was nil, recover returns\n // nil. Thus the return value from recover reports whether the goroutine is\n // panicking.\n-func recover() interface{}\n+func recover() any\n \n // The print built-in function formats its arguments in an\n // implementation-specific way and writes the result to standard error."}, {"sha": "f9855fcb0520f3bdf9082f71ddf794c923c3d0b5", "filename": "libgo/go/bytes/boundary_test.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fboundary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fboundary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fboundary_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n //\n //go:build linux\n-// +build linux\n \n package bytes_test\n \n@@ -66,7 +65,11 @@ func TestIndexByteNearPageBoundary(t *testing.T) {\n \n func TestIndexNearPageBoundary(t *testing.T) {\n \tt.Parallel()\n-\tvar q [64]byte\n+\tq := dangerousSlice(t)\n+\tif len(q) > 64 {\n+\t\t// Only worry about when we're near the end of a page.\n+\t\tq = q[len(q)-64:]\n+\t}\n \tb := dangerousSlice(t)\n \tif len(b) > 256 {\n \t\t// Only worry about when we're near the end of a page.\n@@ -82,4 +85,16 @@ func TestIndexNearPageBoundary(t *testing.T) {\n \t\t}\n \t\tq[j-1] = 0\n \t}\n+\n+\t// Test differing alignments and sizes of q which always end on a page boundary.\n+\tq[len(q)-1] = 1 // difference is only found on the last byte\n+\tfor j := 0; j < len(q); j++ {\n+\t\tfor i := range b {\n+\t\t\tidx := Index(b[i:], q[j:])\n+\t\t\tif idx != -1 {\n+\t\t\t\tt.Fatalf(\"Index(b[%d:], q[%d:])=%d, want -1\\n\", i, j, idx)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tq[len(q)-1] = 0\n }"}, {"sha": "6fdaa49c7344921da2d1c987d714a61884935157", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 121, "deletions": 25, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -21,7 +21,7 @@ func Equal(a, b []byte) bool {\n }\n \n // Compare returns an integer comparing two byte slices lexicographically.\n-// The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n+// The result will be 0 if a == b, -1 if a < b, and +1 if a > b.\n // A nil argument is equivalent to an empty slice.\n func Compare(a, b []byte) int {\n \treturn bytealg.Compare(a, b)\n@@ -699,7 +699,7 @@ func ToValidUTF8(s, replacement []byte) []byte {\n \t\tif c < utf8.RuneSelf {\n \t\t\ti++\n \t\t\tinvalid = false\n-\t\t\tb = append(b, byte(c))\n+\t\t\tb = append(b, c)\n \t\t\tcontinue\n \t\t}\n \t\t_, wid := utf8.DecodeRune(s[i:])\n@@ -746,7 +746,8 @@ func isSeparator(r rune) bool {\n // Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\n // words mapped to their title case.\n //\n-// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n+// Deprecated: The rule Title uses for word boundaries does not handle Unicode\n+// punctuation properly. Use golang.org/x/text/cases instead.\n func Title(s []byte) []byte {\n \t// Use a closure here to remember state.\n \t// Hackish but effective. Depends on Map scanning in order and calling\n@@ -867,6 +868,8 @@ func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int {\n // most-significant bit of the highest word, map to the full range of all\n // 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,\n // ensuring that any non-ASCII character will be reported as not in the set.\n+// This allocates a total of 32 bytes even though the upper half\n+// is unused to avoid bounds checks in asciiSet.contains.\n type asciiSet [8]uint32\n \n // makeASCIISet creates a set of ASCII characters and reports whether all\n@@ -877,53 +880,133 @@ func makeASCIISet(chars string) (as asciiSet, ok bool) {\n \t\tif c >= utf8.RuneSelf {\n \t\t\treturn as, false\n \t\t}\n-\t\tas[c>>5] |= 1 << uint(c&31)\n+\t\tas[c/32] |= 1 << (c % 32)\n \t}\n \treturn as, true\n }\n \n // contains reports whether c is inside the set.\n func (as *asciiSet) contains(c byte) bool {\n-\treturn (as[c>>5] & (1 << uint(c&31))) != 0\n+\treturn (as[c/32] & (1 << (c % 32))) != 0\n }\n \n-func makeCutsetFunc(cutset string) func(r rune) bool {\n-\tif len(cutset) == 1 && cutset[0] < utf8.RuneSelf {\n-\t\treturn func(r rune) bool {\n-\t\t\treturn r == rune(cutset[0])\n-\t\t}\n-\t}\n-\tif as, isASCII := makeASCIISet(cutset); isASCII {\n-\t\treturn func(r rune) bool {\n-\t\t\treturn r < utf8.RuneSelf && as.contains(byte(r))\n-\t\t}\n-\t}\n-\treturn func(r rune) bool {\n-\t\tfor _, c := range cutset {\n-\t\t\tif c == r {\n-\t\t\t\treturn true\n-\t\t\t}\n+// containsRune is a simplified version of strings.ContainsRune\n+// to avoid importing the strings package.\n+// We avoid bytes.ContainsRune to avoid allocating a temporary copy of s.\n+func containsRune(s string, r rune) bool {\n+\tfor _, c := range s {\n+\t\tif c == r {\n+\t\t\treturn true\n \t\t}\n-\t\treturn false\n \t}\n+\treturn false\n }\n \n // Trim returns a subslice of s by slicing off all leading and\n // trailing UTF-8-encoded code points contained in cutset.\n func Trim(s []byte, cutset string) []byte {\n-\treturn TrimFunc(s, makeCutsetFunc(cutset))\n+\tif len(s) == 0 || cutset == \"\" {\n+\t\treturn s\n+\t}\n+\tif len(cutset) == 1 && cutset[0] < utf8.RuneSelf {\n+\t\treturn trimLeftByte(trimRightByte(s, cutset[0]), cutset[0])\n+\t}\n+\tif as, ok := makeASCIISet(cutset); ok {\n+\t\treturn trimLeftASCII(trimRightASCII(s, &as), &as)\n+\t}\n+\treturn trimLeftUnicode(trimRightUnicode(s, cutset), cutset)\n }\n \n // TrimLeft returns a subslice of s by slicing off all leading\n // UTF-8-encoded code points contained in cutset.\n func TrimLeft(s []byte, cutset string) []byte {\n-\treturn TrimLeftFunc(s, makeCutsetFunc(cutset))\n+\tif len(s) == 0 || cutset == \"\" {\n+\t\treturn s\n+\t}\n+\tif len(cutset) == 1 && cutset[0] < utf8.RuneSelf {\n+\t\treturn trimLeftByte(s, cutset[0])\n+\t}\n+\tif as, ok := makeASCIISet(cutset); ok {\n+\t\treturn trimLeftASCII(s, &as)\n+\t}\n+\treturn trimLeftUnicode(s, cutset)\n+}\n+\n+func trimLeftByte(s []byte, c byte) []byte {\n+\tfor len(s) > 0 && s[0] == c {\n+\t\ts = s[1:]\n+\t}\n+\treturn s\n+}\n+\n+func trimLeftASCII(s []byte, as *asciiSet) []byte {\n+\tfor len(s) > 0 {\n+\t\tif !as.contains(s[0]) {\n+\t\t\tbreak\n+\t\t}\n+\t\ts = s[1:]\n+\t}\n+\treturn s\n+}\n+\n+func trimLeftUnicode(s []byte, cutset string) []byte {\n+\tfor len(s) > 0 {\n+\t\tr, n := rune(s[0]), 1\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr, n = utf8.DecodeRune(s)\n+\t\t}\n+\t\tif !containsRune(cutset, r) {\n+\t\t\tbreak\n+\t\t}\n+\t\ts = s[n:]\n+\t}\n+\treturn s\n }\n \n // TrimRight returns a subslice of s by slicing off all trailing\n // UTF-8-encoded code points that are contained in cutset.\n func TrimRight(s []byte, cutset string) []byte {\n-\treturn TrimRightFunc(s, makeCutsetFunc(cutset))\n+\tif len(s) == 0 || cutset == \"\" {\n+\t\treturn s\n+\t}\n+\tif len(cutset) == 1 && cutset[0] < utf8.RuneSelf {\n+\t\treturn trimRightByte(s, cutset[0])\n+\t}\n+\tif as, ok := makeASCIISet(cutset); ok {\n+\t\treturn trimRightASCII(s, &as)\n+\t}\n+\treturn trimRightUnicode(s, cutset)\n+}\n+\n+func trimRightByte(s []byte, c byte) []byte {\n+\tfor len(s) > 0 && s[len(s)-1] == c {\n+\t\ts = s[:len(s)-1]\n+\t}\n+\treturn s\n+}\n+\n+func trimRightASCII(s []byte, as *asciiSet) []byte {\n+\tfor len(s) > 0 {\n+\t\tif !as.contains(s[len(s)-1]) {\n+\t\t\tbreak\n+\t\t}\n+\t\ts = s[:len(s)-1]\n+\t}\n+\treturn s\n+}\n+\n+func trimRightUnicode(s []byte, cutset string) []byte {\n+\tfor len(s) > 0 {\n+\t\tr, n := rune(s[len(s)-1]), 1\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr, n = utf8.DecodeLastRune(s)\n+\t\t}\n+\t\tif !containsRune(cutset, r) {\n+\t\t\tbreak\n+\t\t}\n+\t\ts = s[:len(s)-n]\n+\t}\n+\treturn s\n }\n \n // TrimSpace returns a subslice of s by slicing off all leading and\n@@ -1174,3 +1257,16 @@ func Index(s, sep []byte) int {\n \t}\n \treturn -1\n }\n+\n+// Cut slices s around the first instance of sep,\n+// returning the text before and after sep.\n+// The found result reports whether sep appears in s.\n+// If sep does not appear in s, cut returns s, nil, false.\n+//\n+// Cut returns slices of the original slice s, not copies.\n+func Cut(s, sep []byte) (before, after []byte, found bool) {\n+\tif i := Index(s, sep); i >= 0 {\n+\t\treturn s[:i], s[i+len(sep):], true\n+\t}\n+\treturn s, nil, false\n+}"}, {"sha": "2e6d27cadbaa9cbb807fb26607cd6d1b471b7ebd", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1256,7 +1256,9 @@ var trimTests = []TrimTest{\n \t{\"TrimLeft\", \"abba\", \"ab\", \"\"},\n \t{\"TrimRight\", \"abba\", \"ab\", \"\"},\n \t{\"TrimLeft\", \"abba\", \"a\", \"bba\"},\n+\t{\"TrimLeft\", \"abba\", \"b\", \"abba\"},\n \t{\"TrimRight\", \"abba\", \"a\", \"abb\"},\n+\t{\"TrimRight\", \"abba\", \"b\", \"abba\"},\n \t{\"Trim\", \"<tag>\", \"<>\", \"tag\"},\n \t{\"Trim\", \"* listitem\", \" *\", \"listitem\"},\n \t{\"Trim\", `\"quote\"`, `\"`, \"quote\"},\n@@ -1570,6 +1572,29 @@ func TestEqualFold(t *testing.T) {\n \t}\n }\n \n+var cutTests = []struct {\n+\ts, sep        string\n+\tbefore, after string\n+\tfound         bool\n+}{\n+\t{\"abc\", \"b\", \"a\", \"c\", true},\n+\t{\"abc\", \"a\", \"\", \"bc\", true},\n+\t{\"abc\", \"c\", \"ab\", \"\", true},\n+\t{\"abc\", \"abc\", \"\", \"\", true},\n+\t{\"abc\", \"\", \"\", \"abc\", true},\n+\t{\"abc\", \"d\", \"abc\", \"\", false},\n+\t{\"\", \"d\", \"\", \"\", false},\n+\t{\"\", \"\", \"\", \"\", true},\n+}\n+\n+func TestCut(t *testing.T) {\n+\tfor _, tt := range cutTests {\n+\t\tif before, after, found := Cut([]byte(tt.s), []byte(tt.sep)); string(before) != tt.before || string(after) != tt.after || found != tt.found {\n+\t\t\tt.Errorf(\"Cut(%q, %q) = %q, %q, %v, want %q, %q, %v\", tt.s, tt.sep, before, after, found, tt.before, tt.after, tt.found)\n+\t\t}\n+\t}\n+}\n+\n func TestBufferGrowNegative(t *testing.T) {\n \tdefer func() {\n \t\tif err := recover(); err == nil {\n@@ -1968,6 +1993,13 @@ func BenchmarkTrimASCII(b *testing.B) {\n \t}\n }\n \n+func BenchmarkTrimByte(b *testing.B) {\n+\tx := []byte(\"  the quick brown fox   \")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tTrim(x, \" \")\n+\t}\n+}\n+\n func BenchmarkIndexPeriodic(b *testing.B) {\n \tkey := []byte{1, 1}\n \tfor _, skip := range [...]int{2, 4, 8, 16, 32, 64} {"}, {"sha": "54a7aa6ae6c04960ce88f6b0d9cabbc01b46acbe", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 126, "deletions": 68, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -37,6 +37,16 @@ func ExampleBuffer_Bytes() {\n \t// Output: hello world\n }\n \n+func ExampleBuffer_Cap() {\n+\tbuf1 := bytes.NewBuffer(make([]byte, 10))\n+\tbuf2 := bytes.NewBuffer(make([]byte, 0, 10))\n+\tfmt.Println(buf1.Cap())\n+\tfmt.Println(buf2.Cap())\n+\t// Output:\n+\t// 10\n+\t// 10\n+}\n+\n func ExampleBuffer_Grow() {\n \tvar b bytes.Buffer\n \tb.Grow(64)\n@@ -54,6 +64,52 @@ func ExampleBuffer_Len() {\n \t// Output: 5\n }\n \n+func ExampleBuffer_Next() {\n+\tvar b bytes.Buffer\n+\tb.Grow(64)\n+\tb.Write([]byte(\"abcde\"))\n+\tfmt.Printf(\"%s\\n\", string(b.Next(2)))\n+\tfmt.Printf(\"%s\\n\", string(b.Next(2)))\n+\tfmt.Printf(\"%s\", string(b.Next(2)))\n+\t// Output:\n+\t// ab\n+\t// cd\n+\t// e\n+}\n+\n+func ExampleBuffer_Read() {\n+\tvar b bytes.Buffer\n+\tb.Grow(64)\n+\tb.Write([]byte(\"abcde\"))\n+\trdbuf := make([]byte, 1)\n+\tn, err := b.Read(rdbuf)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tfmt.Println(n)\n+\tfmt.Println(b.String())\n+\tfmt.Println(string(rdbuf))\n+\t// Output\n+\t// 1\n+\t// bcde\n+\t// a\n+}\n+\n+func ExampleBuffer_ReadByte() {\n+\tvar b bytes.Buffer\n+\tb.Grow(64)\n+\tb.Write([]byte(\"abcde\"))\n+\tc, err := b.ReadByte()\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tfmt.Println(c)\n+\tfmt.Println(b.String())\n+\t// Output\n+\t// 97\n+\t// bcde\n+}\n+\n func ExampleCompare() {\n \t// Interpret Compare's result by comparing it to zero.\n \tvar a, b []byte\n@@ -92,36 +148,6 @@ func ExampleCompare_search() {\n \t}\n }\n \n-func ExampleTrimSuffix() {\n-\tvar b = []byte(\"Hello, goodbye, etc!\")\n-\tb = bytes.TrimSuffix(b, []byte(\"goodbye, etc!\"))\n-\tb = bytes.TrimSuffix(b, []byte(\"gopher\"))\n-\tb = append(b, bytes.TrimSuffix([]byte(\"world!\"), []byte(\"x!\"))...)\n-\tos.Stdout.Write(b)\n-\t// Output: Hello, world!\n-}\n-\n-func ExampleTrimPrefix() {\n-\tvar b = []byte(\"Goodbye,, world!\")\n-\tb = bytes.TrimPrefix(b, []byte(\"Goodbye,\"))\n-\tb = bytes.TrimPrefix(b, []byte(\"See ya,\"))\n-\tfmt.Printf(\"Hello%s\", b)\n-\t// Output: Hello, world!\n-}\n-\n-func ExampleFields() {\n-\tfmt.Printf(\"Fields are: %q\", bytes.Fields([]byte(\"  foo bar  baz   \")))\n-\t// Output: Fields are: [\"foo\" \"bar\" \"baz\"]\n-}\n-\n-func ExampleFieldsFunc() {\n-\tf := func(c rune) bool {\n-\t\treturn !unicode.IsLetter(c) && !unicode.IsNumber(c)\n-\t}\n-\tfmt.Printf(\"Fields are: %q\", bytes.FieldsFunc([]byte(\"  foo1;bar2,baz3...\"), f))\n-\t// Output: Fields are: [\"foo1\" \"bar2\" \"baz3\"]\n-}\n-\n func ExampleContains() {\n \tfmt.Println(bytes.Contains([]byte(\"seafood\"), []byte(\"foo\")))\n \tfmt.Println(bytes.Contains([]byte(\"seafood\"), []byte(\"bar\")))\n@@ -168,6 +194,22 @@ func ExampleCount() {\n \t// 5\n }\n \n+func ExampleCut() {\n+\tshow := func(s, sep string) {\n+\t\tbefore, after, found := bytes.Cut([]byte(s), []byte(sep))\n+\t\tfmt.Printf(\"Cut(%q, %q) = %q, %q, %v\\n\", s, sep, before, after, found)\n+\t}\n+\tshow(\"Gopher\", \"Go\")\n+\tshow(\"Gopher\", \"ph\")\n+\tshow(\"Gopher\", \"er\")\n+\tshow(\"Gopher\", \"Badger\")\n+\t// Output:\n+\t// Cut(\"Gopher\", \"Go\") = \"\", \"pher\", true\n+\t// Cut(\"Gopher\", \"ph\") = \"Go\", \"er\", true\n+\t// Cut(\"Gopher\", \"er\") = \"Goph\", \"\", true\n+\t// Cut(\"Gopher\", \"Badger\") = \"Gopher\", \"\", false\n+}\n+\n func ExampleEqual() {\n \tfmt.Println(bytes.Equal([]byte(\"Go\"), []byte(\"Go\")))\n \tfmt.Println(bytes.Equal([]byte(\"Go\"), []byte(\"C++\")))\n@@ -181,6 +223,19 @@ func ExampleEqualFold() {\n \t// Output: true\n }\n \n+func ExampleFields() {\n+\tfmt.Printf(\"Fields are: %q\", bytes.Fields([]byte(\"  foo bar  baz   \")))\n+\t// Output: Fields are: [\"foo\" \"bar\" \"baz\"]\n+}\n+\n+func ExampleFieldsFunc() {\n+\tf := func(c rune) bool {\n+\t\treturn !unicode.IsLetter(c) && !unicode.IsNumber(c)\n+\t}\n+\tfmt.Printf(\"Fields are: %q\", bytes.FieldsFunc([]byte(\"  foo1;bar2,baz3...\"), f))\n+\t// Output: Fields are: [\"foo1\" \"bar2\" \"baz3\"]\n+}\n+\n func ExampleHasPrefix() {\n \tfmt.Println(bytes.HasPrefix([]byte(\"Gopher\"), []byte(\"Go\")))\n \tfmt.Println(bytes.HasPrefix([]byte(\"Gopher\"), []byte(\"C\")))\n@@ -246,6 +301,12 @@ func ExampleIndexRune() {\n \t// -1\n }\n \n+func ExampleJoin() {\n+\ts := [][]byte{[]byte(\"foo\"), []byte(\"bar\"), []byte(\"baz\")}\n+\tfmt.Printf(\"%s\", bytes.Join(s, []byte(\", \")))\n+\t// Output: foo, bar, baz\n+}\n+\n func ExampleLastIndex() {\n \tfmt.Println(bytes.Index([]byte(\"go gopher\"), []byte(\"go\")))\n \tfmt.Println(bytes.LastIndex([]byte(\"go gopher\"), []byte(\"go\")))\n@@ -286,10 +347,12 @@ func ExampleLastIndexFunc() {\n \t// -1\n }\n \n-func ExampleJoin() {\n-\ts := [][]byte{[]byte(\"foo\"), []byte(\"bar\"), []byte(\"baz\")}\n-\tfmt.Printf(\"%s\", bytes.Join(s, []byte(\", \")))\n-\t// Output: foo, bar, baz\n+func ExampleReader_Len() {\n+\tfmt.Println(bytes.NewReader([]byte(\"Hi!\")).Len())\n+\tfmt.Println(bytes.NewReader([]byte(\"\u3053\u3093\u306b\u3061\u306f!\")).Len())\n+\t// Output:\n+\t// 3\n+\t// 16\n }\n \n func ExampleRepeat() {\n@@ -399,20 +462,6 @@ func ExampleTrimFunc() {\n \t// go-gopher!\n }\n \n-func ExampleMap() {\n-\trot13 := func(r rune) rune {\n-\t\tswitch {\n-\t\tcase r >= 'A' && r <= 'Z':\n-\t\t\treturn 'A' + (r-'A'+13)%26\n-\t\tcase r >= 'a' && r <= 'z':\n-\t\t\treturn 'a' + (r-'a'+13)%26\n-\t\t}\n-\t\treturn r\n-\t}\n-\tfmt.Printf(\"%s\", bytes.Map(rot13, []byte(\"'Twas brillig and the slithy gopher...\")))\n-\t// Output: 'Gjnf oevyyvt naq gur fyvgul tbcure...\n-}\n-\n func ExampleTrimLeft() {\n \tfmt.Print(string(bytes.TrimLeft([]byte(\"453gopher8257\"), \"0123456789\")))\n \t// Output:\n@@ -429,11 +478,28 @@ func ExampleTrimLeftFunc() {\n \t// go-gopher!567\n }\n \n+func ExampleTrimPrefix() {\n+\tvar b = []byte(\"Goodbye,, world!\")\n+\tb = bytes.TrimPrefix(b, []byte(\"Goodbye,\"))\n+\tb = bytes.TrimPrefix(b, []byte(\"See ya,\"))\n+\tfmt.Printf(\"Hello%s\", b)\n+\t// Output: Hello, world!\n+}\n+\n func ExampleTrimSpace() {\n \tfmt.Printf(\"%s\", bytes.TrimSpace([]byte(\" \\t\\n a lone gopher \\n\\t\\r\\n\")))\n \t// Output: a lone gopher\n }\n \n+func ExampleTrimSuffix() {\n+\tvar b = []byte(\"Hello, goodbye, etc!\")\n+\tb = bytes.TrimSuffix(b, []byte(\"goodbye, etc!\"))\n+\tb = bytes.TrimSuffix(b, []byte(\"gopher\"))\n+\tb = append(b, bytes.TrimSuffix([]byte(\"world!\"), []byte(\"x!\"))...)\n+\tos.Stdout.Write(b)\n+\t// Output: Hello, world!\n+}\n+\n func ExampleTrimRight() {\n \tfmt.Print(string(bytes.TrimRight([]byte(\"453gopher8257\"), \"0123456789\")))\n \t// Output:\n@@ -450,21 +516,6 @@ func ExampleTrimRightFunc() {\n \t// 1234go-gopher!\n }\n \n-func ExampleToUpper() {\n-\tfmt.Printf(\"%s\", bytes.ToUpper([]byte(\"Gopher\")))\n-\t// Output: GOPHER\n-}\n-\n-func ExampleToUpperSpecial() {\n-\tstr := []byte(\"ahoj v\u00fdvoj\u00e1ri golang\")\n-\ttotitle := bytes.ToUpperSpecial(unicode.AzeriCase, str)\n-\tfmt.Println(\"Original : \" + string(str))\n-\tfmt.Println(\"ToUpper : \" + string(totitle))\n-\t// Output:\n-\t// Original : ahoj v\u00fdvoj\u00e1ri golang\n-\t// ToUpper : AHOJ V\u00ddVOJ\u00c1R\u0130 GOLANG\n-}\n-\n func ExampleToLower() {\n \tfmt.Printf(\"%s\", bytes.ToLower([]byte(\"Gopher\")))\n \t// Output: gopher\n@@ -480,10 +531,17 @@ func ExampleToLowerSpecial() {\n \t// ToLower : ahoj v\u00fdvoj\u00e1ri golang\n }\n \n-func ExampleReader_Len() {\n-\tfmt.Println(bytes.NewReader([]byte(\"Hi!\")).Len())\n-\tfmt.Println(bytes.NewReader([]byte(\"\u3053\u3093\u306b\u3061\u306f!\")).Len())\n+func ExampleToUpper() {\n+\tfmt.Printf(\"%s\", bytes.ToUpper([]byte(\"Gopher\")))\n+\t// Output: GOPHER\n+}\n+\n+func ExampleToUpperSpecial() {\n+\tstr := []byte(\"ahoj v\u00fdvoj\u00e1ri golang\")\n+\ttotitle := bytes.ToUpperSpecial(unicode.AzeriCase, str)\n+\tfmt.Println(\"Original : \" + string(str))\n+\tfmt.Println(\"ToUpper : \" + string(totitle))\n \t// Output:\n-\t// 3\n-\t// 16\n+\t// Original : ahoj v\u00fdvoj\u00e1ri golang\n+\t// ToUpper : AHOJ V\u00ddVOJ\u00c1R\u0130 GOLANG\n }"}, {"sha": "9119c944ace4783ebb9fb3295beb7be23336e009", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -76,7 +76,7 @@ func TestReaderAt(t *testing.T) {\n \t\toff     int64\n \t\tn       int\n \t\twant    string\n-\t\twanterr interface{}\n+\t\twanterr any\n \t}{\n \t\t{0, 10, \"0123456789\", nil},\n \t\t{1, 10, \"123456789\", io.EOF},"}, {"sha": "28879e349c49cf371b40a7fb0d09f2e4b285f549", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -338,8 +338,7 @@ func (f *File) walk(x interface{}, context astContext, visit func(*File, interfa\n \n \t// everything else just recurs\n \tdefault:\n-\t\terror_(token.NoPos, \"unexpected type %T in walk\", x)\n-\t\tpanic(\"unexpected type\")\n+\t\tf.walkUnexpected(x, context, visit)\n \n \tcase nil:\n "}, {"sha": "f52bf00d7cb946e9844f485352daec989435a2db", "filename": "libgo/go/cmd/cgo/ast_go1.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fast_go1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fast_go1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast_go1.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//go:build compiler_bootstrap\n+// +build compiler_bootstrap\n+\n+package main\n+\n+import (\n+\t\"go/token\"\n+)\n+\n+func (f *File) walkUnexpected(x interface{}, context astContext, visit func(*File, interface{}, astContext)) {\n+\terror_(token.NoPos, \"unexpected type %T in walk\", x)\n+\tpanic(\"unexpected type\")\n+}"}, {"sha": "db0108ed7268366a5dc0543645645bed443a3ecb", "filename": "libgo/go/cmd/cgo/ast_go118.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fast_go118.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fast_go118.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast_go118.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//go:build !compiler_bootstrap\n+// +build !compiler_bootstrap\n+\n+package main\n+\n+import (\n+\t\"go/ast\"\n+\t\"go/token\"\n+)\n+\n+func (f *File) walkUnexpected(x interface{}, context astContext, visit func(*File, interface{}, astContext)) {\n+\tswitch n := x.(type) {\n+\tdefault:\n+\t\terror_(token.NoPos, \"unexpected type %T in walk\", x)\n+\t\tpanic(\"unexpected type\")\n+\n+\tcase *ast.IndexListExpr:\n+\t\tf.walk(&n.X, ctxExpr, visit)\n+\t\tf.walk(n.Indices, ctxExpr, visit)\n+\t}\n+}"}, {"sha": "02391495bbebce61d00eb052150f7cb4388edc82", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 132, "deletions": 14, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -23,10 +23,13 @@ import (\n \t\"internal/xcoff\"\n \t\"math\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"strconv\"\n \t\"strings\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n+\n+\t\"cmd/internal/quoted\"\n )\n \n var debugDefine = flag.Bool(\"debug-define\", false, \"print relevant #defines\")\n@@ -400,7 +403,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\tstderr = p.gccErrors(b.Bytes())\n \t}\n \tif stderr == \"\" {\n-\t\tfatalf(\"%s produced no output\\non input:\\n%s\", p.gccBaseCmd()[0], b.Bytes())\n+\t\tfatalf(\"%s produced no output\\non input:\\n%s\", gccBaseCmd[0], b.Bytes())\n \t}\n \n \tcompleted := false\n@@ -475,7 +478,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t}\n \n \tif !completed {\n-\t\tfatalf(\"%s did not produce error at completed:1\\non input:\\n%s\\nfull error output:\\n%s\", p.gccBaseCmd()[0], b.Bytes(), stderr)\n+\t\tfatalf(\"%s did not produce error at completed:1\\non input:\\n%s\\nfull error output:\\n%s\", gccBaseCmd[0], b.Bytes(), stderr)\n \t}\n \n \tfor i, n := range names {\n@@ -506,7 +509,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t// to users debugging preamble mistakes. See issue 8442.\n \t\tpreambleErrors := p.gccErrors([]byte(f.Preamble))\n \t\tif len(preambleErrors) > 0 {\n-\t\t\terror_(token.NoPos, \"\\n%s errors for preamble:\\n%s\", p.gccBaseCmd()[0], preambleErrors)\n+\t\t\terror_(token.NoPos, \"\\n%s errors for preamble:\\n%s\", gccBaseCmd[0], preambleErrors)\n \t\t}\n \n \t\tfatalf(\"unresolved names\")\n@@ -1521,7 +1524,7 @@ func (p *Package) rewriteName(f *File, r *Ref, addPosition bool) ast.Expr {\n \t\t\t\tArgs: []ast.Expr{getNewIdent(name.Mangle)},\n \t\t\t}\n \t\tcase \"type\":\n-\t\t\t// Okay - might be new(T)\n+\t\t\t// Okay - might be new(T), T(x), Generic[T], etc.\n \t\t\tif r.Name.Type == nil {\n \t\t\t\terror_(r.Pos(), \"expression C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n \t\t\t}\n@@ -1563,20 +1566,37 @@ func gofmtPos(n ast.Expr, pos token.Pos) string {\n \treturn fmt.Sprintf(\"/*line :%d:%d*/%s\", p.Line, p.Column, s)\n }\n \n-// gccBaseCmd returns the start of the compiler command line.\n+// checkGCCBaseCmd returns the start of the compiler command line.\n // It uses $CC if set, or else $GCC, or else the compiler recorded\n // during the initial build as defaultCC.\n // defaultCC is defined in zdefaultcc.go, written by cmd/dist.\n-func (p *Package) gccBaseCmd() []string {\n+//\n+// The compiler command line is split into arguments on whitespace. Quotes\n+// are understood, so arguments may contain whitespace.\n+//\n+// checkGCCBaseCmd confirms that the compiler exists in PATH, returning\n+// an error if it does not.\n+func checkGCCBaseCmd() ([]string, error) {\n \t// Use $CC if set, since that's what the build uses.\n-\tif ret := strings.Fields(os.Getenv(\"CC\")); len(ret) > 0 {\n-\t\treturn ret\n+\tvalue := os.Getenv(\"CC\")\n+\tif value == \"\" {\n+\t\t// Try $GCC if set, since that's what we used to use.\n+\t\tvalue = os.Getenv(\"GCC\")\n+\t}\n+\tif value == \"\" {\n+\t\tvalue = defaultCC(goos, goarch)\n \t}\n-\t// Try $GCC if set, since that's what we used to use.\n-\tif ret := strings.Fields(os.Getenv(\"GCC\")); len(ret) > 0 {\n-\t\treturn ret\n+\targs, err := quoted.Split(value)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\treturn strings.Fields(defaultCC(goos, goarch))\n+\tif len(args) == 0 {\n+\t\treturn nil, errors.New(\"CC not set and no default found\")\n+\t}\n+\tif _, err := exec.LookPath(args[0]); err != nil {\n+\t\treturn nil, fmt.Errorf(\"C compiler %q not found: %v\", args[0], err)\n+\t}\n+\treturn args[:len(args):len(args)], nil\n }\n \n // gccMachine returns the gcc -m flag to use, either \"-m32\", \"-m64\" or \"-marm\".\n@@ -1630,7 +1650,7 @@ func gccTmp() string {\n // gccCmd returns the gcc command line to use for compiling\n // the input.\n func (p *Package) gccCmd() []string {\n-\tc := append(p.gccBaseCmd(),\n+\tc := append(gccBaseCmd,\n \t\t\"-w\",          // no warnings\n \t\t\"-Wno-error\",  // warnings are not errors\n \t\t\"-o\"+gccTmp(), // write object to tmp\n@@ -2030,7 +2050,7 @@ func (p *Package) gccDebug(stdin []byte, nnames int) (d *dwarf.Data, ints []int6\n // #defines that gcc encountered while processing the input\n // and its included files.\n func (p *Package) gccDefines(stdin []byte) string {\n-\tbase := append(p.gccBaseCmd(), \"-E\", \"-dM\", \"-xc\")\n+\tbase := append(gccBaseCmd, \"-E\", \"-dM\", \"-xc\")\n \tbase = append(base, p.gccMachine()...)\n \tstdout, _ := runGcc(stdin, append(append(base, p.GccOptions...), \"-\"))\n \treturn stdout\n@@ -2111,6 +2131,9 @@ type typeConv struct {\n \t// Type names X for which there exists an XGetTypeID function with type func() CFTypeID.\n \tgetTypeIDs map[string]bool\n \n+\t// badStructs contains C structs that should be marked NotInHeap.\n+\tnotInHeapStructs map[string]bool\n+\n \t// Predeclared types.\n \tbool                                   ast.Expr\n \tbyte                                   ast.Expr // denotes padding\n@@ -2122,6 +2145,7 @@ type typeConv struct {\n \tstring                                 ast.Expr\n \tgoVoid                                 ast.Expr // _Ctype_void, denotes C's void\n \tgoVoidPtr                              ast.Expr // unsafe.Pointer or *byte\n+\tgoVoidPtrNoHeap                        ast.Expr // *_Ctype_void_notinheap, like goVoidPtr but marked NotInHeap\n \n \tptrSize int64\n \tintSize int64\n@@ -2145,6 +2169,7 @@ func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.m = make(map[string]*Type)\n \tc.ptrs = make(map[string][]*Type)\n \tc.getTypeIDs = make(map[string]bool)\n+\tc.notInHeapStructs = make(map[string]bool)\n \tc.bool = c.Ident(\"bool\")\n \tc.byte = c.Ident(\"byte\")\n \tc.int8 = c.Ident(\"int8\")\n@@ -2163,6 +2188,7 @@ func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.void = c.Ident(\"void\")\n \tc.string = c.Ident(\"string\")\n \tc.goVoid = c.Ident(\"_Ctype_void\")\n+\tc.goVoidPtrNoHeap = c.Ident(\"*_Ctype_void_notinheap\")\n \n \t// Normally cgo translates void* to unsafe.Pointer,\n \t// but for historical reasons -godefs uses *byte instead.\n@@ -2543,6 +2569,7 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\t\ttt.C = &TypeRepr{\"struct %s\", []interface{}{tag}}\n \t\t\t}\n \t\t\ttt.Go = g\n+\t\t\ttt.NotInHeap = c.notInHeapStructs[tag]\n \t\t\ttypedef[name.Name] = &tt\n \t\t}\n \n@@ -2586,6 +2613,30 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\t\toldType.BadPointer = true\n \t\t\t}\n \t\t}\n+\t\tif c.badVoidPointerTypedef(dt) {\n+\t\t\t// Treat this typedef as a pointer to a NotInHeap void.\n+\t\t\ts := *sub\n+\t\t\ts.Go = c.goVoidPtrNoHeap\n+\t\t\tsub = &s\n+\t\t\t// Make sure we update any previously computed type.\n+\t\t\tif oldType := typedef[name.Name]; oldType != nil {\n+\t\t\t\toldType.Go = sub.Go\n+\t\t\t}\n+\t\t}\n+\t\t// Check for non-pointer \"struct <tag>{...}; typedef struct <tag> *<name>\"\n+\t\t// typedefs that should be marked NotInHeap.\n+\t\tif ptr, ok := dt.Type.(*dwarf.PtrType); ok {\n+\t\t\tif strct, ok := ptr.Type.(*dwarf.StructType); ok {\n+\t\t\t\tif c.badStructPointerTypedef(dt.Name, strct) {\n+\t\t\t\t\tc.notInHeapStructs[strct.StructName] = true\n+\t\t\t\t\t// Make sure we update any previously computed type.\n+\t\t\t\t\tname := \"_Ctype_struct_\" + strct.StructName\n+\t\t\t\t\tif oldType := typedef[name]; oldType != nil {\n+\t\t\t\t\t\toldType.NotInHeap = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tt.Go = name\n \t\tt.BadPointer = sub.BadPointer\n \t\tt.NotInHeap = sub.NotInHeap\n@@ -3035,6 +3086,31 @@ func upper(s string) string {\n // so that all fields are exported.\n func godefsFields(fld []*ast.Field) {\n \tprefix := fieldPrefix(fld)\n+\n+\t// Issue 48396: check for duplicate field names.\n+\tif prefix != \"\" {\n+\t\tnames := make(map[string]bool)\n+\tfldLoop:\n+\t\tfor _, f := range fld {\n+\t\t\tfor _, n := range f.Names {\n+\t\t\t\tname := n.Name\n+\t\t\t\tif name == \"_\" {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif name != prefix {\n+\t\t\t\t\tname = strings.TrimPrefix(n.Name, prefix)\n+\t\t\t\t}\n+\t\t\t\tname = upper(name)\n+\t\t\t\tif names[name] {\n+\t\t\t\t\t// Field name conflict: don't remove prefix.\n+\t\t\t\t\tprefix = \"\"\n+\t\t\t\t\tbreak fldLoop\n+\t\t\t\t}\n+\t\t\t\tnames[name] = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tnpad := 0\n \tfor _, f := range fld {\n \t\tfor _, n := range f.Names {\n@@ -3112,6 +3188,48 @@ func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n \treturn false\n }\n \n+// badVoidPointerTypedef is like badPointerTypeDef, but for \"void *\" typedefs that should be NotInHeap.\n+func (c *typeConv) badVoidPointerTypedef(dt *dwarf.TypedefType) bool {\n+\t// Match the Windows HANDLE type (#42018).\n+\tif goos != \"windows\" || dt.Name != \"HANDLE\" {\n+\t\treturn false\n+\t}\n+\t// Check that the typedef is \"typedef void *<name>\".\n+\tif ptr, ok := dt.Type.(*dwarf.PtrType); ok {\n+\t\tif _, ok := ptr.Type.(*dwarf.VoidType); ok {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// badStructPointerTypedef is like badVoidPointerTypedefs but for structs.\n+func (c *typeConv) badStructPointerTypedef(name string, dt *dwarf.StructType) bool {\n+\t// Windows handle types can all potentially contain non-pointers.\n+\t// badVoidPointerTypedef handles the \"void *\" HANDLE type, but other\n+\t// handles are defined as\n+\t//\n+\t// struct <name>__{int unused;}; typedef struct <name>__ *name;\n+\t//\n+\t// by the DECLARE_HANDLE macro in STRICT mode. The macro is declared in\n+\t// the Windows ntdef.h header,\n+\t//\n+\t// https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/shared/ntdef.h#L779\n+\tif goos != \"windows\" {\n+\t\treturn false\n+\t}\n+\tif len(dt.Field) != 1 {\n+\t\treturn false\n+\t}\n+\tif dt.StructName != name+\"__\" {\n+\t\treturn false\n+\t}\n+\tif f := dt.Field[0]; f.Name != \"unused\" || f.Type.Common().Name != \"int\" {\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n // baseBadPointerTypedef reports whether the base of a chain of typedefs is a bad typedef\n // as badPointerTypedef reports.\n func (c *typeConv) baseBadPointerTypedef(dt *dwarf.TypedefType) bool {"}, {"sha": "58477e470453f6f5b0a21e5353065b62616c4f0c", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -21,7 +21,6 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"reflect\"\n \t\"runtime\"\n@@ -252,6 +251,7 @@ var importSyscall = flag.Bool(\"import_syscall\", true, \"import syscall in generat\n var trimpath = flag.String(\"trimpath\", \"\", \"applies supplied rewrites or trims prefixes to recorded source file paths\")\n \n var goarch, goos, gomips, gomips64 string\n+var gccBaseCmd []string\n \n func main() {\n \tobjabi.AddVersionFlag() // -V\n@@ -309,10 +309,10 @@ func main() {\n \tp := newPackage(args[:i])\n \n \t// We need a C compiler to be available. Check this.\n-\tgccName := p.gccBaseCmd()[0]\n-\t_, err := exec.LookPath(gccName)\n+\tvar err error\n+\tgccBaseCmd, err = checkGCCBaseCmd()\n \tif err != nil {\n-\t\tfatalf(\"C compiler %q not found: %v\", gccName, err)\n+\t\tfatalf(\"%v\", err)\n \t\tos.Exit(2)\n \t}\n "}, {"sha": "8d1eb5b6a967a7aae2872a0193f239d27fdc3d33", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -64,9 +64,9 @@ func (p *Package) writeDefs() {\n \t// Write C main file for using gcc to resolve imports.\n \tfmt.Fprintf(fm, \"int main() { return 0; }\\n\")\n \tif *importRuntimeCgo {\n-\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*), void *a, int c, __SIZE_TYPE__ ctxt) { }\\n\")\n+\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*) __attribute__((unused)), void *a __attribute__((unused)), int c __attribute__((unused)), __SIZE_TYPE__ ctxt __attribute__((unused))) { }\\n\")\n \t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done(void) { return 0; }\\n\")\n-\t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__ ctxt) { }\\n\")\n+\t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__ ctxt __attribute__((unused))) { }\\n\")\n \t\tfmt.Fprintf(fm, \"char* _cgo_topofstack(void) { return (char*)0; }\\n\")\n \t} else {\n \t\t// If we're not importing runtime/cgo, we *are* runtime/cgo,\n@@ -75,8 +75,8 @@ func (p *Package) writeDefs() {\n \t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done(void);\\n\")\n \t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__);\\n\")\n \t}\n-\tfmt.Fprintf(fm, \"void _cgo_allocate(void *a, int c) { }\\n\")\n-\tfmt.Fprintf(fm, \"void _cgo_panic(void *a, int c) { }\\n\")\n+\tfmt.Fprintf(fm, \"void _cgo_allocate(void *a __attribute__((unused)), int c __attribute__((unused))) { }\\n\")\n+\tfmt.Fprintf(fm, \"void _cgo_panic(void *a __attribute__((unused)), int c __attribute__((unused))) { }\\n\")\n \tfmt.Fprintf(fm, \"void _cgo_reginit(void) { }\\n\")\n \n \t// Write second Go output: definitions of _C_xxx.\n@@ -140,6 +140,7 @@ func (p *Package) writeDefs() {\n \t\tfmt.Fprintf(fgo2, \"%s\", buf.Bytes())\n \t\tfmt.Fprintf(fgo2, \"\\n\\n\")\n \t}\n+\tfmt.Fprintf(fgo2, \"//go:notinheap\\ntype _Ctype_void_notinheap struct{}\\n\\n\")\n \tif *gccgo {\n \t\tfmt.Fprintf(fgo2, \"type _Ctype_void byte\\n\")\n \t} else {\n@@ -1059,9 +1060,10 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \n \t\tfmt.Fprintf(fm, \"void _cgoexp%s_%s(void* p){}\\n\", cPrefix, exp.ExpName)\n \n+\t\tfmt.Fprintf(fgo2, \"\\t\")\n+\n \t\tif gccResult != \"void\" {\n \t\t\t// Write results back to frame.\n-\t\t\tfmt.Fprintf(fgo2, \"\\t\")\n \t\t\tforFieldList(fntype.Results,\n \t\t\t\tfunc(i int, aname string, atype ast.Expr) {\n \t\t\t\t\tif i > 0 {\n@@ -1463,10 +1465,10 @@ const gccProlog = `\n   (have a negative array count) and an inscrutable error will come\n   out of the compiler and hopefully mention \"name\".\n */\n-#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];\n+#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2UL+1UL];\n \n /* Check at compile time that the sizes we use match our expectations. */\n-#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), n, _cgo_sizeof_##t##_is_not_##n)\n+#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), (size_t)n, _cgo_sizeof_##t##_is_not_##n)\n \n __cgo_size_assert(char, 1)\n __cgo_size_assert(short, 2)"}, {"sha": "48fc888f9492d07e43f774817c955d8608d240db", "filename": "libgo/go/cmd/go.mod", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo.mod?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,15 +1,19 @@\n module cmd\n \n-go 1.17\n+go 1.18\n \n require (\n-\tgithub.com/google/pprof v0.0.0-20210506205249-923b5ab0fc1a\n-\tgithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639 // indirect\n-\tgolang.org/x/arch v0.0.0-20210502124803-cbf565b21d1e\n-\tgolang.org/x/crypto v0.0.0-20210503195802-e9a32991a82e // indirect\n-\tgolang.org/x/mod v0.4.3-0.20210608190319-0f08993efd8a\n-\tgolang.org/x/sys v0.0.0-20210511113859-b0526f3d8744 // indirect\n-\tgolang.org/x/term v0.0.0-20210503060354-a79de5458b56\n-\tgolang.org/x/tools v0.1.2-0.20210519160823-49064d2332f9\n+\tgithub.com/google/pprof v0.0.0-20211104044539-f987b9c94b31\n+\tgolang.org/x/arch v0.0.0-20210923205945-b76863e36670\n+\tgolang.org/x/mod v0.6.0-dev.0.20211102181907-3a5865c02020\n+\tgolang.org/x/sync v0.0.0-20210220032951-036812b2e83c\n+\tgolang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n+\tgolang.org/x/tools v0.1.9-0.20220124164225-97de9ec46646\n+)\n+\n+require (\n+\tgithub.com/ianlancetaylor/demangle v0.0.0-20210905161508-09a460cdf81d // indirect\n+\tgolang.org/x/crypto v0.0.0-20211215153901-e495a2d5b3d3 // indirect\n+\tgolang.org/x/sys v0.0.0-20211205182925-97ca703d548d // indirect\n \tgolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect\n )"}, {"sha": "826b0ccf19ce359c5235a3a7a81b069748caea68", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 353, "deletions": 68, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -25,6 +25,7 @@\n // \tinstall     compile and install packages and dependencies\n // \tlist        list packages or modules\n // \tmod         module maintenance\n+// \twork        workspace maintenance\n // \trun         compile and run Go program\n // \ttest        test packages\n // \ttool        run specified go tool\n@@ -114,13 +115,16 @@\n // \t\tThe default is GOMAXPROCS, normally the number of CPUs available.\n // \t-race\n // \t\tenable data race detection.\n-// \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,\n+// \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, darwin/arm64, windows/amd64,\n // \t\tlinux/ppc64le and linux/arm64 (only for 48-bit VMA).\n // \t-msan\n // \t\tenable interoperation with memory sanitizer.\n // \t\tSupported only on linux/amd64, linux/arm64\n // \t\tand only with Clang/LLVM as the host C compiler.\n // \t\tOn linux/arm64, pie build mode will be used.\n+// \t-asan\n+// \t\tenable interoperation with address sanitizer.\n+// \t\tSupported only on linux/arm64, linux/amd64.\n // \t-v\n // \t\tprint the names of packages as they are compiled.\n // \t-work\n@@ -133,6 +137,12 @@\n // \t\targuments to pass on each go tool asm invocation.\n // \t-buildmode mode\n // \t\tbuild mode to use. See 'go help buildmode' for more.\n+// \t-buildvcs\n+// \t\tWhether to stamp binaries with version control information. By default,\n+// \t\tversion control information is stamped into a binary if the main package\n+// \t\tand the main module containing it are in the repository containing the\n+// \t\tcurrent directory (if there is a repository). Use -buildvcs=false to\n+// \t\tomit version control information.\n // \t-compiler name\n // \t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n // \t-gccgoflags '[pattern=]arg list'\n@@ -144,8 +154,8 @@\n // \t\tin order to keep output separate from default builds.\n // \t\tIf using the -race flag, the install suffix is automatically set to race\n // \t\tor, if set explicitly, has _race appended to it. Likewise for the -msan\n-// \t\tflag. Using a -buildmode option that requires non-default compile flags\n-// \t\thas a similar effect.\n+// \t\tand -asan flags. Using a -buildmode option that requires non-default compile\n+// \t\tflags has a similar effect.\n // \t-ldflags '[pattern=]arg list'\n // \t\targuments to pass on each go tool link invocation.\n // \t-linkshared\n@@ -167,6 +177,14 @@\n // \t\tdirectory, but it is not accessed. When -modfile is specified, an\n // \t\talternate go.sum file is also used: its path is derived from the\n // \t\t-modfile flag by trimming the \".mod\" extension and appending \".sum\".\n+// \t-workfile file\n+// \t\tin module aware mode, use the given go.work file as a workspace file.\n+// \t\tBy default or when -workfile is \"auto\", the go command searches for a\n+// \t\tfile named go.work in the current directory and then containing directories\n+// \t\tuntil one is found. If a valid go.work file is found, the modules\n+// \t\tspecified will collectively be used as the main modules. If -workfile\n+// \t\tis \"off\", or a go.work file is not found in \"auto\" mode, workspace\n+// \t\tmode is disabled.\n // \t-overlay file\n // \t\tread a JSON config file that provides an overlay for build operations.\n // \t\tThe file is a JSON struct with a single field, named 'Replace', that\n@@ -191,9 +209,8 @@\n // \t-trimpath\n // \t\tremove all file system paths from the resulting executable.\n // \t\tInstead of absolute file system paths, the recorded file names\n-// \t\twill begin with either \"go\" (for the standard library),\n-// \t\tor a module path@version (when using modules),\n-// \t\tor a plain import path (when using GOPATH).\n+// \t\twill begin either a module path@version (when using modules),\n+// \t\tor a plain import path (when using the standard library, or GOPATH).\n // \t-toolexec 'cmd args'\n // \t\ta program to use to invoke toolchain programs like vet and asm.\n // \t\tFor example, instead of running asm, the go command will run\n@@ -284,6 +301,13 @@\n // download cache, including unpacked source code of versioned\n // dependencies.\n //\n+// The -fuzzcache flag causes clean to remove files stored in the Go build\n+// cache for fuzz testing. The fuzzing engine caches files that expand\n+// code coverage, so removing them may make fuzzing less effective until\n+// new inputs are found that provide the same coverage. These files are\n+// distinct from those stored in testdata directory; clean does not remove\n+// those files.\n+//\n // For more about build flags, see 'go help build'.\n //\n // For more about specifying packages, see 'go help packages'.\n@@ -338,9 +362,8 @@\n // path. The go tool's usual package mechanism does not apply: package path\n // elements like . and ... are not implemented by go doc.\n //\n-// When run with two arguments, the first must be a full package path (not just a\n-// suffix), and the second is a symbol, or symbol with method or struct field.\n-// This is similar to the syntax accepted by godoc:\n+// When run with two arguments, the first is a package path (full path or suffix),\n+// and the second is a symbol, or symbol with method or struct field:\n //\n // \tgo doc <pkg> <sym>[.<methodOrField>]\n //\n@@ -438,14 +461,18 @@\n //\n // Usage:\n //\n-// \tgo fix [packages]\n+// \tgo fix [-fix list] [packages]\n //\n // Fix runs the Go fix command on the packages named by the import paths.\n //\n+// The -fix flag sets a comma-separated list of fixes to run.\n+// The default is all known fixes.\n+// (Its value is passed to 'go tool fix -r'.)\n+//\n // For more about fix, see 'go doc cmd/fix'.\n // For more about specifying packages, see 'go help packages'.\n //\n-// To run fix with specific options, run 'go tool fix'.\n+// To run fix with other options, run 'go tool fix'.\n //\n // See also: go fmt, go vet.\n //\n@@ -483,7 +510,7 @@\n // files. Those commands can run any process but the intent is to\n // create or update Go source files.\n //\n-// Go generate is never run automatically by go build, go get, go test,\n+// Go generate is never run automatically by go build, go test,\n // and so on. It must be run explicitly.\n //\n // Go generate scans the file for directives, which are lines of\n@@ -598,11 +625,11 @@\n //\n // Usage:\n //\n-// \tgo get [-d] [-t] [-u] [-v] [build flags] [packages]\n+// \tgo get [-t] [-u] [-v] [build flags] [packages]\n //\n // Get resolves its command-line arguments to packages at specific module versions,\n-// updates go.mod to require those versions, downloads source code into the\n-// module cache, then builds and installs the named packages.\n+// updates go.mod to require those versions, and downloads source code into the\n+// module cache.\n //\n // To add a dependency for a package or upgrade it to its latest version:\n //\n@@ -618,17 +645,18 @@\n //\n // See https://golang.org/ref/mod#go-get for details.\n //\n-// The 'go install' command may be used to build and install packages. When a\n-// version is specified, 'go install' runs in module-aware mode and ignores\n-// the go.mod file in the current directory. For example:\n+// In earlier versions of Go, 'go get' was used to build and install packages.\n+// Now, 'go get' is dedicated to adjusting dependencies in go.mod. 'go install'\n+// may be used to build and install commands instead. When a version is specified,\n+// 'go install' runs in module-aware mode and ignores the go.mod file in the\n+// current directory. For example:\n //\n // \tgo install example.com/pkg@v1.2.3\n // \tgo install example.com/pkg@latest\n //\n // See 'go help install' or https://golang.org/ref/mod#go-install for details.\n //\n-// In addition to build flags (listed in 'go help build') 'go get' accepts the\n-// following flags.\n+// 'go get' accepts the following flags.\n //\n // The -t flag instructs get to consider modules needed to build tests of\n // packages specified on the command line.\n@@ -643,15 +671,9 @@\n // When the -t and -u flags are used together, get will update\n // test dependencies as well.\n //\n-// The -d flag instructs get not to build or install packages. get will only\n-// update go.mod and download source code needed to build packages.\n-//\n-// Building and installing packages with get is deprecated. In a future release,\n-// the -d flag will be enabled by default, and 'go get' will be only be used to\n-// adjust dependencies of the current module. To install a package using\n-// dependencies from the current module, use 'go install'. To install a package\n-// ignoring the current module, use 'go install' with an @version suffix like\n-// \"@latest\" after each argument.\n+// The -x flag prints commands as they are executed. This is useful for\n+// debugging version control commands when a module is downloaded directly\n+// from a repository.\n //\n // For more about modules, see https://golang.org/ref/mod.\n //\n@@ -694,14 +716,17 @@\n //\n // - All arguments must refer to packages in the same module at the same version.\n //\n+// - Package path arguments must refer to main packages. Pattern arguments\n+// will only match main packages.\n+//\n // - No module is considered the \"main\" module. If the module containing\n // packages named on the command line has a go.mod file, it must not contain\n // directives (replace and exclude) that would cause it to be interpreted\n // differently than if it were the main module. The module must not require\n // a higher version of itself.\n //\n-// - Package path arguments must refer to main packages. Pattern arguments\n-// will only match main packages.\n+// - Vendor directories are not used in any module. (Vendor directories are not\n+// included in the module zip files downloaded by 'go install'.)\n //\n // If the arguments don't have version suffixes, \"go install\" may run in\n // module-aware mode or GOPATH mode, depending on the GO111MODULE environment\n@@ -1041,8 +1066,11 @@\n //\n // Download downloads the named modules, which can be module patterns selecting\n // dependencies of the main module or module queries of the form path@version.\n-// With no arguments, download applies to all dependencies of the main module\n-// (equivalent to 'go mod download all').\n+//\n+// With no arguments, download applies to the modules needed to build and test\n+// the packages in the main module: the modules explicitly required by the main\n+// module if it is at 'go 1.17' or higher, or all transitively-required modules\n+// if at 'go 1.16' or lower.\n //\n // The go command will automatically download modules as needed during ordinary\n // execution. The \"go mod download\" command is useful mainly for pre-filling\n@@ -1260,7 +1288,7 @@\n //\n // Usage:\n //\n-// \tgo mod vendor [-e] [-v]\n+// \tgo mod vendor [-e] [-v] [-o outdir]\n //\n // Vendor resets the main module's vendor directory to include all packages\n // needed to build and test all the main module's packages.\n@@ -1272,6 +1300,11 @@\n // The -e flag causes vendor to attempt to proceed despite errors\n // encountered while loading packages.\n //\n+// The -o flag causes vendor to create the vendor directory at the given\n+// path instead of \"vendor\". The go command can only use a vendor directory\n+// named \"vendor\" within the module root directory, so this flag is\n+// primarily useful for other tools.\n+//\n // See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'.\n //\n //\n@@ -1329,6 +1362,202 @@\n // See https://golang.org/ref/mod#go-mod-why for more about 'go mod why'.\n //\n //\n+// Workspace maintenance\n+//\n+// Go workspace provides access to operations on workspaces.\n+//\n+// Note that support for workspaces is built into many other commands, not\n+// just 'go work'.\n+//\n+// See 'go help modules' for information about Go's module system of which\n+// workspaces are a part.\n+//\n+// A workspace is specified by a go.work file that specifies a set of\n+// module directories with the \"use\" directive. These modules are used as\n+// root modules by the go command for builds and related operations.  A\n+// workspace that does not specify modules to be used cannot be used to do\n+// builds from local modules.\n+//\n+// go.work files are line-oriented. Each line holds a single directive,\n+// made up of a keyword followed by aruments. For example:\n+//\n+// \tgo 1.18\n+//\n+// \tuse ../foo/bar\n+// \tuse ./baz\n+//\n+// \treplace example.com/foo v1.2.3 => example.com/bar v1.4.5\n+//\n+// The leading keyword can be factored out of adjacent lines to create a block,\n+// like in Go imports.\n+//\n+// \tuse (\n+// \t  ../foo/bar\n+// \t  ./baz\n+// \t)\n+//\n+// The use directive specifies a module to be included in the workspace's\n+// set of main modules. The argument to the use directive is the directory\n+// containing the module's go.mod file.\n+//\n+// The go directive specifies the version of Go the file was written at. It\n+// is possible there may be future changes in the semantics of workspaces\n+// that could be controlled by this version, but for now the version\n+// specified has no effect.\n+//\n+// The replace directive has the same syntax as the replace directive in a\n+// go.mod file and takes precedence over replaces in go.mod files.  It is\n+// primarily intended to override conflicting replaces in different workspace\n+// modules.\n+//\n+// To determine whether the go command is operating in workspace mode, use\n+// the \"go env GOWORK\" command. This will specify the workspace file being\n+// used.\n+//\n+// Usage:\n+//\n+// \tgo work <command> [arguments]\n+//\n+// The commands are:\n+//\n+// \tedit        edit go.work from tools or scripts\n+// \tinit        initialize workspace file\n+// \tsync        sync workspace build list to modules\n+// \tuse         add modules to workspace file\n+//\n+// Use \"go help work <command>\" for more information about a command.\n+//\n+// Edit go.work from tools or scripts\n+//\n+// Usage:\n+//\n+// \tgo work edit [editing flags] [go.work]\n+//\n+// Edit provides a command-line interface for editing go.work,\n+// for use primarily by tools or scripts. It only reads go.work;\n+// it does not look up information about the modules involved.\n+// If no file is specified, Edit looks for a go.work file in the current\n+// directory and its parent directories\n+//\n+// The editing flags specify a sequence of editing operations.\n+//\n+// The -fmt flag reformats the go.work file without making other changes.\n+// This reformatting is also implied by any other modifications that use or\n+// rewrite the go.mod file. The only time this flag is needed is if no other\n+// flags are specified, as in 'go work edit -fmt'.\n+//\n+// The -use=path and -dropuse=path flags\n+// add and drop a use directive from the go.work file's set of module directories.\n+//\n+// The -replace=old[@v]=new[@v] flag adds a replacement of the given\n+// module path and version pair. If the @v in old@v is omitted, a\n+// replacement without a version on the left side is added, which applies\n+// to all versions of the old module path. If the @v in new@v is omitted,\n+// the new path should be a local module root directory, not a module\n+// path. Note that -replace overrides any redundant replacements for old[@v],\n+// so omitting @v will drop existing replacements for specific versions.\n+//\n+// The -dropreplace=old[@v] flag drops a replacement of the given\n+// module path and version pair. If the @v is omitted, a replacement without\n+// a version on the left side is dropped.\n+//\n+// The -use, -dropuse, -replace, and -dropreplace,\n+// editing flags may be repeated, and the changes are applied in the order given.\n+//\n+// The -go=version flag sets the expected Go language version.\n+//\n+// The -print flag prints the final go.work in its text format instead of\n+// writing it back to go.mod.\n+//\n+// The -json flag prints the final go.work file in JSON format instead of\n+// writing it back to go.mod. The JSON output corresponds to these Go types:\n+//\n+// \ttype Module struct {\n+// \t\tPath    string\n+// \t\tVersion string\n+// \t}\n+//\n+// \ttype GoWork struct {\n+// \t\tGo        string\n+// \t\tDirectory []Directory\n+// \t\tReplace   []Replace\n+// \t}\n+//\n+// \ttype Use struct {\n+// \t\tPath       string\n+// \t\tModulePath string\n+// \t}\n+//\n+// \ttype Replace struct {\n+// \t\tOld Module\n+// \t\tNew Module\n+// \t}\n+//\n+// See the workspaces design proposal at\n+// https://go.googlesource.com/proposal/+/master/design/45713-workspace.md for\n+// more information.\n+//\n+//\n+// Initialize workspace file\n+//\n+// Usage:\n+//\n+// \tgo work init [moddirs]\n+//\n+// Init initializes and writes a new go.work file in the\n+// current directory, in effect creating a new workspace at the current\n+// directory.\n+//\n+// go work init optionally accepts paths to the workspace modules as\n+// arguments. If the argument is omitted, an empty workspace with no\n+// modules will be created.\n+//\n+// Each argument path is added to a use directive in the go.work file. The\n+// current go version will also be listed in the go.work file.\n+//\n+//\n+// Sync workspace build list to modules\n+//\n+// Usage:\n+//\n+// \tgo work sync\n+//\n+// Sync syncs the workspace's build list back to the\n+// workspace's modules\n+//\n+// The workspace's build list is the set of versions of all the\n+// (transitive) dependency modules used to do builds in the workspace. go\n+// work sync generates that build list using the Minimal Version Selection\n+// algorithm, and then syncs those versions back to each of modules\n+// specified in the workspace (with use directives).\n+//\n+// The syncing is done by sequentially upgrading each of the dependency\n+// modules specified in a workspace module to the version in the build list\n+// if the dependency module's version is not already the same as the build\n+// list's version. Note that Minimal Version Selection guarantees that the\n+// build list's version of each module is always the same or higher than\n+// that in each workspace module.\n+//\n+//\n+// Add modules to workspace file\n+//\n+// Usage:\n+//\n+// \tgo work use [-r] [moddirs]\n+//\n+// Use provides a command-line interface for adding\n+// directories, optionally recursively, to a go.work file.\n+//\n+// A use directive will be added to the go.work file for each argument\n+// directory listed on the command line go.work file, if it exists on disk,\n+// or removed from the go.work file if it does not exist on disk.\n+//\n+// The -r flag searches recursively for modules in the argument\n+// directories, and the use command operates as if each of the directories\n+// were specified as arguments: namely, use directives will be added for\n+// directories that exist, and removed for directories that do not exist.\n+//\n+//\n // Compile and run Go program\n //\n // Usage:\n@@ -1387,8 +1616,8 @@\n //\n // 'Go test' recompiles each package along with any files with names matching\n // the file pattern \"*_test.go\".\n-// These additional files can contain test functions, benchmark functions, and\n-// example functions. See 'go help testfunc' for more.\n+// These additional files can contain test functions, benchmark functions, fuzz\n+// tests and example functions. See 'go help testfunc' for more.\n // Each listed package causes the execution of a separate test binary.\n // Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n //\n@@ -1405,7 +1634,8 @@\n // used. That subset is: 'atomic', 'bool', 'buildtags', 'errorsas',\n // 'ifaceassert', 'nilfunc', 'printf', and 'stringintconv'. You can see\n // the documentation for these and other vet tests via \"go doc cmd/vet\".\n-// To disable the running of go vet, use the -vet=off flag.\n+// To disable the running of go vet, use the -vet=off flag. To run all\n+// checks, use the -vet=all flag.\n //\n // All test output and summary lines are printed to the go command's\n // standard output, even if the test printed them to its own standard\n@@ -1446,16 +1676,16 @@\n // The rule for a match in the cache is that the run involves the same\n // test binary and the flags on the command line come entirely from a\n // restricted set of 'cacheable' test flags, defined as -benchtime, -cpu,\n-// -list, -parallel, -run, -short, and -v. If a run of go test has any test\n-// or non-test flags outside this set, the result is not cached. To\n-// disable test caching, use any test flag or argument other than the\n-// cacheable flags. The idiomatic way to disable test caching explicitly\n-// is to use -count=1. Tests that open files within the package's source\n-// root (usually $GOPATH) or that consult environment variables only\n-// match future runs in which the files and environment variables are unchanged.\n-// A cached test result is treated as executing in no time at all,\n-// so a successful package test result will be cached and reused\n-// regardless of -timeout setting.\n+// -list, -parallel, -run, -short, -timeout, -failfast, and -v.\n+// If a run of go test has any test or non-test flags outside this set,\n+// the result is not cached. To disable test caching, use any test flag\n+// or argument other than the cacheable flags. The idiomatic way to disable\n+// test caching explicitly is to use -count=1. Tests that open files within\n+// the package's source root (usually $GOPATH) or that consult environment\n+// variables only match future runs in which the files and environment\n+// variables are unchanged. A cached test result is treated as executing\n+// in no time at all,so a successful package test result will be cached and\n+// reused regardless of -timeout setting.\n //\n // In addition to the build flags, the flags handled by 'go test' itself are:\n //\n@@ -1746,6 +1976,13 @@\n // See 'go help test' for details. Running 'go clean -testcache' removes\n // all cached test results (but not cached build results).\n //\n+// The go command also caches values used in fuzzing with 'go test -fuzz',\n+// specifically, values that expanded code coverage when passed to a\n+// fuzz function. These values are not used for regular building and\n+// testing, but they're stored in a subdirectory of the build cache.\n+// Running 'go clean -fuzzcache' removes all cached fuzzing values.\n+// This may make fuzzing less effective, temporarily.\n+//\n // The GODEBUG environment variable can enable printing of debugging\n // information about the state of the cache:\n //\n@@ -1885,6 +2122,10 @@\n // \tGO386\n // \t\tFor GOARCH=386, how to implement floating point instructions.\n // \t\tValid values are sse2 (default), softfloat.\n+// \tGOAMD64\n+// \t\tFor GOARCH=amd64, the microarchitecture level for which to compile.\n+// \t\tValid values are v1 (default), v2, v3, v4.\n+// \t\tSee https://golang.org/wiki/MinimumRequirements#amd64\n // \tGOMIPS\n // \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n // \t\tValid values are hardfloat (default), softfloat.\n@@ -2622,9 +2863,10 @@\n // \t    (for example, -benchtime 100x).\n //\n // \t-count n\n-// \t    Run each test and benchmark n times (default 1).\n+// \t    Run each test, benchmark, and fuzz seed n times (default 1).\n // \t    If -cpu is set, run n times for each GOMAXPROCS value.\n-// \t    Examples are always run once.\n+// \t    Examples are always run once. -count does not apply to\n+// \t    fuzz tests matched by -fuzz.\n //\n // \t-cover\n // \t    Enable coverage analysis.\n@@ -2651,32 +2893,67 @@\n // \t    Sets -cover.\n //\n // \t-cpu 1,2,4\n-// \t    Specify a list of GOMAXPROCS values for which the tests or\n-// \t    benchmarks should be executed. The default is the current value\n-// \t    of GOMAXPROCS.\n+// \t    Specify a list of GOMAXPROCS values for which the tests, benchmarks or\n+// \t    fuzz tests should be executed. The default is the current value\n+// \t    of GOMAXPROCS. -cpu does not apply to fuzz tests matched by -fuzz.\n //\n // \t-failfast\n // \t    Do not start new tests after the first test failure.\n //\n+// \t-fuzz regexp\n+// \t    Run the fuzz test matching the regular expression. When specified,\n+// \t    the command line argument must match exactly one package within the\n+// \t    main module, and regexp must match exactly one fuzz test within\n+// \t    that package. Fuzzing will occur after tests, benchmarks, seed corpora\n+// \t    of other fuzz tests, and examples have completed. See the Fuzzing\n+// \t    section of the testing package documentation for details.\n+//\n+// \t-fuzztime t\n+// \t    Run enough iterations of the fuzz target during fuzzing to take t,\n+// \t    specified as a time.Duration (for example, -fuzztime 1h30s).\n+// \t\tThe default is to run forever.\n+// \t    The special syntax Nx means to run the fuzz target N times\n+// \t    (for example, -fuzztime 1000x).\n+//\n+// \t-fuzzminimizetime t\n+// \t    Run enough iterations of the fuzz target during each minimization\n+// \t    attempt to take t, as specified as a time.Duration (for example,\n+// \t    -fuzzminimizetime 30s).\n+// \t\tThe default is 60s.\n+// \t    The special syntax Nx means to run the fuzz target N times\n+// \t    (for example, -fuzzminimizetime 100x).\n+//\n+// \t-json\n+// \t    Log verbose output and test results in JSON. This presents the\n+// \t    same information as the -v flag in a machine-readable format.\n+//\n // \t-list regexp\n-// \t    List tests, benchmarks, or examples matching the regular expression.\n-// \t    No tests, benchmarks or examples will be run. This will only\n-// \t    list top-level tests. No subtest or subbenchmarks will be shown.\n+// \t    List tests, benchmarks, fuzz tests, or examples matching the regular\n+// \t    expression. No tests, benchmarks, fuzz tests, or examples will be run.\n+// \t    This will only list top-level tests. No subtest or subbenchmarks will be\n+// \t    shown.\n //\n // \t-parallel n\n-// \t    Allow parallel execution of test functions that call t.Parallel.\n+// \t    Allow parallel execution of test functions that call t.Parallel, and\n+// \t    fuzz targets that call t.Parallel when running the seed corpus.\n // \t    The value of this flag is the maximum number of tests to run\n-// \t    simultaneously; by default, it is set to the value of GOMAXPROCS.\n+// \t    simultaneously.\n+// \t    While fuzzing, the value of this flag is the maximum number of\n+// \t    subprocesses that may call the fuzz function simultaneously, regardless of\n+// \t    whether T.Parallel is called.\n+// \t    By default, -parallel is set to the value of GOMAXPROCS.\n+// \t    Setting -parallel to values higher than GOMAXPROCS may cause degraded\n+// \t    performance due to CPU contention, especially when fuzzing.\n // \t    Note that -parallel only applies within a single test binary.\n // \t    The 'go test' command may run tests for different packages\n // \t    in parallel as well, according to the setting of the -p flag\n // \t    (see 'go help build').\n //\n // \t-run regexp\n-// \t    Run only those tests and examples matching the regular expression.\n-// \t    For tests, the regular expression is split by unbracketed slash (/)\n-// \t    characters into a sequence of regular expressions, and each part\n-// \t    of a test's identifier must match the corresponding element in\n+// \t    Run only those tests, examples, and fuzz tests matching the regular\n+// \t    expression. For tests, the regular expression is split by unbracketed\n+// \t    slash (/) characters into a sequence of regular expressions, and each\n+// \t    part of a test's identifier must match the corresponding element in\n // \t    the sequence, if any. Note that possible parents of matches are\n // \t    run too, so that -run=X/Y matches and runs and reports the result\n // \t    of all tests matching X, even those without sub-tests matching Y,\n@@ -2689,11 +2966,11 @@\n // \t    exhaustive tests.\n //\n // \t-shuffle off,on,N\n-// \t\tRandomize the execution order of tests and benchmarks.\n-// \t\tIt is off by default. If -shuffle is set to on, then it will seed\n-// \t\tthe randomizer using the system clock. If -shuffle is set to an\n-// \t\tinteger N, then N will be used as the seed value. In both cases,\n-// \t\tthe seed will be reported for reproducibility.\n+// \t    Randomize the execution order of tests and benchmarks.\n+// \t    It is off by default. If -shuffle is set to on, then it will seed\n+// \t    the randomizer using the system clock. If -shuffle is set to an\n+// \t    integer N, then N will be used as the seed value. In both cases,\n+// \t    the seed will be reported for reproducibility.\n //\n // \t-timeout d\n // \t    If a test binary runs longer than duration d, panic.\n@@ -2789,7 +3066,11 @@\n // When 'go test' runs a test binary, it does so from within the\n // corresponding package's source code directory. Depending on the test,\n // it may be necessary to do the same when invoking a generated test\n-// binary directly.\n+// binary directly. Because that directory may be located within the\n+// module cache, which may be read-only and is verified by checksums, the\n+// test must not write to it or any other directory within the module\n+// unless explicitly requested by the user (such as with the -fuzz flag,\n+// which writes failures to testdata/fuzz).\n //\n // The command-line package list, if present, must appear before any\n // flag not known to the go test command. Continuing the example above,\n@@ -2843,6 +3124,10 @@\n //\n // \tfunc BenchmarkXxx(b *testing.B) { ... }\n //\n+// A fuzz test is one named FuzzXxx and should have the signature,\n+//\n+// \tfunc FuzzXxx(f *testing.F) { ... }\n+//\n // An example function is similar to a test function but, instead of using\n // *testing.T to report success or failure, prints output to os.Stdout.\n // If the last comment in the function starts with \"Output:\" then the output\n@@ -2882,7 +3167,7 @@\n //\n // The entire test file is presented as the example when it contains a single\n // example function, at least one other function, type, variable, or constant\n-// declaration, and no test or benchmark functions.\n+// declaration, and no tests, benchmarks, or fuzz tests.\n //\n // See the documentation of the testing package for more information.\n //"}, {"sha": "9faa7cba42e097b094ca17d41c47dbbb5f54ba62", "filename": "libgo/go/cmd/go/go11.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build go1.1\n-// +build go1.1\n \n package main\n "}, {"sha": "7aaec4eb9864e8a3bd50ef5fa146eff5625ac5df", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"flag\"\n \t\"fmt\"\n \t\"go/format\"\n+\t\"internal/godebug\"\n \t\"internal/race\"\n \t\"internal/testenv\"\n \t\"io\"\n@@ -31,7 +32,6 @@ import (\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/robustio\"\n-\t\"cmd/go/internal/work\"\n \t\"cmd/internal/sys\"\n )\n \n@@ -44,9 +44,12 @@ func init() {\n }\n \n var (\n-\tcanRace = false // whether we can run the race detector\n-\tcanCgo  = false // whether we can use cgo\n-\tcanMSan = false // whether we can run the memory sanitizer\n+\tcanRace          = false // whether we can run the race detector\n+\tcanCgo           = false // whether we can use cgo\n+\tcanMSan          = false // whether we can run the memory sanitizer\n+\tcanASan          = false // whether we can run the address sanitizer\n+\tcanFuzz          = false // whether we can search for new fuzz failures\n+\tfuzzInstrumented = false // whether fuzzing uses instrumentation\n )\n \n var exeSuffix string = func() string {\n@@ -198,13 +201,16 @@ func TestMain(m *testing.M) {\n \t\ttestGOCACHE = strings.TrimSpace(string(out))\n \n \t\tcanMSan = canCgo && sys.MSanSupported(runtime.GOOS, runtime.GOARCH)\n+\t\tcanASan = canCgo && sys.ASanSupported(runtime.GOOS, runtime.GOARCH)\n \t\tcanRace = canCgo && sys.RaceDetectorSupported(runtime.GOOS, runtime.GOARCH)\n \t\t// The race detector doesn't work on Alpine Linux:\n \t\t// golang.org/issue/14481\n \t\t// gccgo does not support the race detector.\n \t\tif isAlpineLinux() || runtime.Compiler == \"gccgo\" {\n \t\t\tcanRace = false\n \t\t}\n+\t\tcanFuzz = sys.FuzzSupported(runtime.GOOS, runtime.GOARCH)\n+\t\tfuzzInstrumented = sys.FuzzInstrumented(runtime.GOOS, runtime.GOARCH)\n \t}\n \t// Don't let these environment variables confuse the test.\n \tos.Setenv(\"GOENV\", \"off\")\n@@ -806,7 +812,9 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t\t\"src/internal/abi\",\n \t\t\"src/internal/bytealg\",\n \t\t\"src/internal/cpu\",\n+\t\t\"src/internal/goarch\",\n \t\t\"src/internal/goexperiment\",\n+\t\t\"src/internal/goos\",\n \t\t\"src/math/bits\",\n \t\t\"src/unsafe\",\n \t\tfilepath.Join(\"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH),\n@@ -1120,11 +1128,11 @@ func TestGoListTest(t *testing.T) {\n \ttg.grepStdoutNot(`^testing \\[sort.test\\]$`, \"unexpected test copy of testing\")\n \ttg.grepStdoutNot(`^testing$`, \"unexpected real copy of testing\")\n \n-\ttg.run(\"list\", \"-test\", \"cmd/dist\", \"cmd/doc\")\n-\ttg.grepStdout(`^cmd/dist$`, \"missing cmd/dist\")\n+\ttg.run(\"list\", \"-test\", \"cmd/buildid\", \"cmd/doc\")\n+\ttg.grepStdout(`^cmd/buildid$`, \"missing cmd/buildid\")\n \ttg.grepStdout(`^cmd/doc$`, \"missing cmd/doc\")\n \ttg.grepStdout(`^cmd/doc\\.test$`, \"missing cmd/doc test\")\n-\ttg.grepStdoutNot(`^cmd/dist\\.test$`, \"unexpected cmd/dist test\")\n+\ttg.grepStdoutNot(`^cmd/buildid\\.test$`, \"unexpected cmd/buildid test\")\n \ttg.grepStdoutNot(`^testing`, \"unexpected testing\")\n \n \ttg.run(\"list\", \"-test\", \"runtime/cgo\")\n@@ -1376,7 +1384,7 @@ func TestLdFlagsLongArgumentsIssue42295(t *testing.T) {\n \t\t}`)\n \ttestStr := \"test test test test test \\n\\\\ \"\n \tvar buf bytes.Buffer\n-\tfor buf.Len() < work.ArgLengthForResponseFile+1 {\n+\tfor buf.Len() < sys.ExecArgLengthLimit+1 {\n \t\tbuf.WriteString(testStr)\n \t}\n \ttg.run(\"run\", \"-ldflags\", fmt.Sprintf(`-X \"main.extern=%s\"`, buf.String()), tg.path(\"main.go\"))\n@@ -2274,7 +2282,7 @@ func TestUpxCompression(t *testing.T) {\n \n func TestCacheListStale(t *testing.T) {\n \ttooSlow(t)\n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\tif godebug.Get(\"gocacheverify\") == \"1\" {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n \ttg := testgo(t)\n@@ -2297,7 +2305,7 @@ func TestCacheListStale(t *testing.T) {\n func TestCacheCoverage(t *testing.T) {\n \ttooSlow(t)\n \n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\tif godebug.Get(\"gocacheverify\") == \"1\" {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n \n@@ -2329,7 +2337,7 @@ func TestIssue22588(t *testing.T) {\n \n func TestIssue22531(t *testing.T) {\n \ttooSlow(t)\n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\tif godebug.Get(\"gocacheverify\") == \"1\" {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n \ttg := testgo(t)\n@@ -2358,7 +2366,7 @@ func TestIssue22531(t *testing.T) {\n \n func TestIssue22596(t *testing.T) {\n \ttooSlow(t)\n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\tif godebug.Get(\"gocacheverify\") == \"1\" {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n \ttg := testgo(t)\n@@ -2388,7 +2396,7 @@ func TestIssue22596(t *testing.T) {\n func TestTestCache(t *testing.T) {\n \ttooSlow(t)\n \n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\tif godebug.Get(\"gocacheverify\") == \"1\" {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n \ttg := testgo(t)"}, {"sha": "29fa343d93154a51dd429dd9691dd058e1cce025", "filename": "libgo/go/cmd/go/go_unix_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build darwin || dragonfly || freebsd || hurd || linux || netbsd || openbsd || solaris\n-// +build darwin dragonfly freebsd hurd linux netbsd openbsd solaris\n \n package main_test\n "}, {"sha": "c2d4e6b258887118b8d0822f6a3c246951b7bb77", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -117,12 +117,12 @@ func Exit() {\n \tos.Exit(exitStatus)\n }\n \n-func Fatalf(format string, args ...interface{}) {\n+func Fatalf(format string, args ...any) {\n \tErrorf(format, args...)\n \tExit()\n }\n \n-func Errorf(format string, args ...interface{}) {\n+func Errorf(format string, args ...any) {\n \tlog.Printf(format, args...)\n \tSetExitStatus(1)\n }\n@@ -151,7 +151,7 @@ func GetExitStatus() int {\n // Run runs the command, with stdout and stderr\n // connected to the go command's own stdout and stderr.\n // If the command fails, Run reports the error using Errorf.\n-func Run(cmdargs ...interface{}) {\n+func Run(cmdargs ...any) {\n \tcmdline := str.StringList(cmdargs...)\n \tif cfg.BuildN || cfg.BuildX {\n \t\tfmt.Printf(\"%s\\n\", strings.Join(cmdline, \" \"))"}, {"sha": "2c72c7e562b7333be43813553321469a555b44a0", "filename": "libgo/go/cmd/go/internal/base/flag.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -9,7 +9,7 @@ import (\n \n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/fsys\"\n-\t\"cmd/go/internal/str\"\n+\t\"cmd/internal/quoted\"\n )\n \n // A StringsFlag is a command-line flag that interprets its argument\n@@ -18,7 +18,7 @@ type StringsFlag []string\n \n func (v *StringsFlag) Set(s string) error {\n \tvar err error\n-\t*v, err = str.SplitQuotedFields(s)\n+\t*v, err = quoted.Split(s)\n \tif *v == nil {\n \t\t*v = []string{}\n \t}\n@@ -62,6 +62,13 @@ func AddModFlag(flags *flag.FlagSet) {\n \tflags.Var(explicitStringFlag{value: &cfg.BuildMod, explicit: &cfg.BuildModExplicit}, \"mod\", \"\")\n }\n \n+// AddWorkfileFlag adds the workfile flag to the flag set. It enables workspace\n+// mode for commands that support it by resetting the cfg.WorkFile variable\n+// to \"\" (equivalent to auto) rather than off.\n+func AddWorkfileFlag(flags *flag.FlagSet) {\n+\tflags.Var(explicitStringFlag{value: &cfg.WorkFile, explicit: &cfg.WorkFileExplicit}, \"workfile\", \"\")\n+}\n+\n // AddModCommonFlags adds the module-related flags common to build commands\n // and 'go mod' subcommands.\n func AddModCommonFlags(flags *flag.FlagSet) {"}, {"sha": "682705f9b2cb41e3a6fc81fd74536a3aa4e42104", "filename": "libgo/go/cmd/go/internal/base/signal_notunix.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build plan9 || windows\n-// +build plan9 windows\n \n package base\n "}, {"sha": "0cf58eb9299ae7fc189976ca2645d4c84fcd0c44", "filename": "libgo/go/cmd/go/internal/base/signal_unix.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build aix || darwin || dragonfly || freebsd || hurd || js || linux || netbsd || openbsd || solaris\n-// +build aix darwin dragonfly freebsd hurd js linux netbsd openbsd solaris\n \n package base\n "}, {"sha": "f927016965051e7d2d8f46c4d2af9b5123c92fe7", "filename": "libgo/go/cmd/go/internal/base/tool.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -36,7 +36,7 @@ func Tool(toolName string) string {\n \t}\n \t// Give a nice message if there is no tool with that name.\n \tif _, err := os.Stat(toolPath); err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n+\t\tfmt.Fprintf(os.Stderr, \"go: no such tool %q\\n\", toolName)\n \t\tSetExitStatus(2)\n \t\tExit()\n \t}"}, {"sha": "702dc2a14acdaad63f13bcd802541dd3141f3362", "filename": "libgo/go/cmd/go/internal/bug/bug.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -40,7 +40,7 @@ func init() {\n \n func runBug(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n-\t\tbase.Fatalf(\"go bug: bug takes no arguments\")\n+\t\tbase.Fatalf(\"go: bug takes no arguments\")\n \t}\n \tvar buf bytes.Buffer\n \tbuf.WriteString(bugHeader)\n@@ -106,8 +106,9 @@ func printGoEnv(w io.Writer) {\n }\n \n func printGoDetails(w io.Writer) {\n-\tprintCmdOut(w, \"GOROOT/bin/go version: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"version\")\n-\tprintCmdOut(w, \"GOROOT/bin/go tool compile -V: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"tool\", \"compile\", \"-V\")\n+\tgocmd := filepath.Join(runtime.GOROOT(), \"bin/go\")\n+\tprintCmdOut(w, \"GOROOT/bin/go version: \", gocmd, \"version\")\n+\tprintCmdOut(w, \"GOROOT/bin/go tool compile -V: \", gocmd, \"tool\", \"compile\", \"-V\")\n }\n \n func printOSDetails(w io.Writer) {"}, {"sha": "93d7c25658fa07eef33d282ff3e61e90cf63d616", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -533,3 +533,15 @@ func (c *Cache) copyFile(file io.ReadSeeker, out OutputID, size int64) error {\n \n \treturn nil\n }\n+\n+// FuzzDir returns a subdirectory within the cache for storing fuzzing data.\n+// The subdirectory may not exist.\n+//\n+// This directory is managed by the internal/fuzz package. Files in this\n+// directory aren't removed by the 'go clean -cache' command or by Trim.\n+// They may be removed with 'go clean -fuzzcache'.\n+//\n+// TODO(#48526): make Trim remove unused files from this directory.\n+func (c *Cache) FuzzDir() string {\n+\treturn filepath.Join(c.dir, \"fuzz\")\n+}"}, {"sha": "426dddfb978624a1843bdc6df66fdd7e96eb2ca6", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -30,6 +30,7 @@ var (\n // README as a courtesy to explain where it came from.\n const cacheREADME = `This directory holds cached build artifacts from the Go build system.\n Run \"go clean -cache\" if the directory is getting too large.\n+Run \"go clean -fuzzcache\" to delete the fuzz cache.\n See golang.org to learn more about Go.\n `\n "}, {"sha": "7f68d7bb62839edb9a6d535773e299e49e138181", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -26,13 +26,15 @@ import (\n var (\n \tBuildA                 bool   // -a flag\n \tBuildBuildmode         string // -buildmode flag\n+\tBuildBuildvcs          bool   // -buildvcs flag\n \tBuildContext           = defaultContext()\n \tBuildMod               string                  // -mod flag\n \tBuildModExplicit       bool                    // whether -mod was set explicitly\n \tBuildModReason         string                  // reason -mod was set, if set by default\n \tBuildI                 bool                    // -i flag\n \tBuildLinkshared        bool                    // -linkshared flag\n \tBuildMSan              bool                    // -msan flag\n+\tBuildASan              bool                    // -asan flag\n \tBuildN                 bool                    // -n flag\n \tBuildO                 string                  // -o flag\n \tBuildP                 = runtime.GOMAXPROCS(0) // -p flag\n@@ -47,17 +49,26 @@ var (\n \tBuildWork              bool // -work flag\n \tBuildX                 bool // -x flag\n \n-\tModCacheRW bool   // -modcacherw flag\n-\tModFile    string // -modfile flag\n+\tModCacheRW       bool   // -modcacherw flag\n+\tModFile          string // -modfile flag\n+\tWorkFile         string // -workfile flag\n+\tWorkFileExplicit bool   // whether -workfile was set explicitly\n \n \tCmdName string // \"build\", \"install\", \"list\", \"mod tidy\", etc.\n \n \tDebugActiongraph string // -debug-actiongraph flag (undocumented, unstable)\n \tDebugTrace       string // -debug-trace flag\n+\n+\t// GoPathError is set when GOPATH is not set. it contains an\n+\t// explanation why GOPATH is unset.\n+\tGoPathError string\n+\n+\tGOEXPERIMENT = envOr(\"GOEXPERIMENT\", buildcfg.DefaultGOEXPERIMENT)\n )\n \n func defaultContext() build.Context {\n \tctxt := build.Default\n+\n \tctxt.JoinPath = filepath.Join // back door to say \"do not use go command\"\n \n \tctxt.GOROOT = findGOROOT()\n@@ -70,7 +81,7 @@ func defaultContext() build.Context {\n \t\tbuild.ToolDir = filepath.Join(ctxt.GOROOT, \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n \t}\n \n-\tctxt.GOPATH = envOr(\"GOPATH\", ctxt.GOPATH)\n+\tctxt.GOPATH = envOr(\"GOPATH\", gopath(ctxt))\n \n \t// Override defaults computed in go/build with defaults\n \t// from go environment configuration file, if known.\n@@ -79,7 +90,7 @@ func defaultContext() build.Context {\n \n \t// The experiments flags are based on GOARCH, so they may\n \t// need to change.  TODO: This should be cleaned up.\n-\tbuildcfg.UpdateExperiments(ctxt.GOOS, ctxt.GOARCH, envOr(\"GOEXPERIMENT\", buildcfg.DefaultGOEXPERIMENT))\n+\tbuildcfg.UpdateExperiments(ctxt.GOOS, ctxt.GOARCH, GOEXPERIMENT)\n \tctxt.ToolTags = nil\n \tfor _, exp := range buildcfg.EnabledExperiments() {\n \t\tctxt.ToolTags = append(ctxt.ToolTags, \"goexperiment.\"+exp)\n@@ -261,6 +272,7 @@ var (\n \t// Used in envcmd.MkEnv and build ID computations.\n \tGOARM    = envOr(\"GOARM\", fmt.Sprint(buildcfg.GOARM))\n \tGO386    = envOr(\"GO386\", buildcfg.GO386)\n+\tGOAMD64  = envOr(\"GOAMD64\", fmt.Sprintf(\"%s%d\", \"v\", buildcfg.GOAMD64))\n \tGOMIPS   = envOr(\"GOMIPS\", buildcfg.GOMIPS)\n \tGOMIPS64 = envOr(\"GOMIPS64\", buildcfg.GOMIPS64)\n \tGOPPC64  = envOr(\"GOPPC64\", fmt.Sprintf(\"%s%d\", \"power\", buildcfg.GOPPC64))\n@@ -287,6 +299,8 @@ func GetArchEnv() (key, val string) {\n \t\treturn \"GOARM\", GOARM\n \tcase \"386\":\n \t\treturn \"GO386\", GO386\n+\tcase \"amd64\":\n+\t\treturn \"GOAMD64\", GOAMD64\n \tcase \"mips\", \"mipsle\":\n \t\treturn \"GOMIPS\", GOMIPS\n \tcase \"mips64\", \"mips64le\":\n@@ -396,3 +410,24 @@ func gopathDir(rel string) string {\n \t}\n \treturn filepath.Join(list[0], rel)\n }\n+\n+func gopath(ctxt build.Context) string {\n+\tif len(ctxt.GOPATH) > 0 {\n+\t\treturn ctxt.GOPATH\n+\t}\n+\tenv := \"HOME\"\n+\tif runtime.GOOS == \"windows\" {\n+\t\tenv = \"USERPROFILE\"\n+\t} else if runtime.GOOS == \"plan9\" {\n+\t\tenv = \"home\"\n+\t}\n+\tif home := os.Getenv(env); home != \"\" {\n+\t\tdef := filepath.Join(home, \"go\")\n+\t\tif filepath.Clean(def) == filepath.Clean(runtime.GOROOT()) {\n+\t\t\tGoPathError = \"cannot set GOROOT as GOPATH\"\n+\t\t}\n+\t\treturn \"\"\n+\t}\n+\tGoPathError = fmt.Sprintf(\"%s is not set\", env)\n+\treturn \"\"\n+}"}, {"sha": "dc93cdf5983126c42adeddb2504276a8a41f834f", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -75,6 +75,13 @@ The -modcache flag causes clean to remove the entire module\n download cache, including unpacked source code of versioned\n dependencies.\n \n+The -fuzzcache flag causes clean to remove files stored in the Go build\n+cache for fuzz testing. The fuzzing engine caches files that expand\n+code coverage, so removing them may make fuzzing less effective until\n+new inputs are found that provide the same coverage. These files are\n+distinct from those stored in testdata directory; clean does not remove\n+those files.\n+\n For more about build flags, see 'go help build'.\n \n For more about specifying packages, see 'go help packages'.\n@@ -85,6 +92,7 @@ var (\n \tcleanI         bool // clean -i flag\n \tcleanR         bool // clean -r flag\n \tcleanCache     bool // clean -cache flag\n+\tcleanFuzzcache bool // clean -fuzzcache flag\n \tcleanModcache  bool // clean -modcache flag\n \tcleanTestcache bool // clean -testcache flag\n )\n@@ -96,6 +104,7 @@ func init() {\n \tCmdClean.Flag.BoolVar(&cleanI, \"i\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanR, \"r\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanCache, \"cache\", false, \"\")\n+\tCmdClean.Flag.BoolVar(&cleanFuzzcache, \"fuzzcache\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanModcache, \"modcache\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanTestcache, \"testcache\", false, \"\")\n \n@@ -112,7 +121,7 @@ func runClean(ctx context.Context, cmd *base.Command, args []string) {\n \t// or no other target (such as a cache) was requested to be cleaned.\n \tcleanPkg := len(args) > 0 || cleanI || cleanR\n \tif (!modload.Enabled() || modload.HasModRoot()) &&\n-\t\t!cleanCache && !cleanModcache && !cleanTestcache {\n+\t\t!cleanCache && !cleanModcache && !cleanTestcache && !cleanFuzzcache {\n \t\tcleanPkg = true\n \t}\n \n@@ -144,7 +153,7 @@ func runClean(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t\t\t\t// This also mimics what os.RemoveAll(dir) would do.\n \t\t\t\t\t\tif err := os.RemoveAll(d); err != nil && !printedErrors {\n \t\t\t\t\t\t\tprintedErrors = true\n-\t\t\t\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\t\t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -157,7 +166,7 @@ func runClean(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tif !cfg.BuildN {\n \t\t\t\tif err := os.RemoveAll(logFile); err != nil && !printedErrors {\n \t\t\t\t\tprintedErrors = true\n-\t\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -187,22 +196,34 @@ func runClean(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t}\n \t\t\tif err != nil {\n \t\t\t\tif _, statErr := os.Stat(dir); !os.IsNotExist(statErr) {\n-\t\t\t\t\tbase.Errorf(\"go clean -testcache: %v\", err)\n+\t\t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \tif cleanModcache {\n \t\tif cfg.GOMODCACHE == \"\" {\n-\t\t\tbase.Fatalf(\"go clean -modcache: no module cache\")\n+\t\t\tbase.Fatalf(\"go: cannot clean -modcache without a module cache\")\n \t\t}\n \t\tif cfg.BuildN || cfg.BuildX {\n \t\t\tb.Showcmd(\"\", \"rm -rf %s\", cfg.GOMODCACHE)\n \t\t}\n \t\tif !cfg.BuildN {\n \t\t\tif err := modfetch.RemoveAll(cfg.GOMODCACHE); err != nil {\n-\t\t\t\tbase.Errorf(\"go clean -modcache: %v\", err)\n+\t\t\t\tbase.Errorf(\"go: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif cleanFuzzcache {\n+\t\tfuzzDir := cache.Default().FuzzDir()\n+\t\tif cfg.BuildN || cfg.BuildX {\n+\t\t\tb.Showcmd(\"\", \"rm -rf %s\", fuzzDir)\n+\t\t}\n+\t\tif !cfg.BuildN {\n+\t\t\tif err := os.RemoveAll(fuzzDir); err != nil {\n+\t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t}\n \t\t}\n \t}\n@@ -245,7 +266,7 @@ func clean(p *load.Package) {\n \t}\n \tdirs, err := os.ReadDir(p.Dir)\n \tif err != nil {\n-\t\tbase.Errorf(\"go clean %s: %v\", p.Dir, err)\n+\t\tbase.Errorf(\"go: %s: %v\", p.Dir, err)\n \t\treturn\n \t}\n \n@@ -334,7 +355,7 @@ func clean(p *load.Package) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif err := os.RemoveAll(filepath.Join(p.Dir, name)); err != nil {\n-\t\t\t\t\tbase.Errorf(\"go clean: %v\", err)\n+\t\t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t\t}\n \t\t\t}\n \t\t\tcontinue\n@@ -386,5 +407,5 @@ func removeFile(f string) {\n \t\t\treturn\n \t\t}\n \t}\n-\tbase.Errorf(\"go clean: %v\", err)\n+\tbase.Errorf(\"go: %v\", err)\n }"}, {"sha": "a634bc1ab8d7ea1a256b386c2c6720009613284c", "filename": "libgo/go/cmd/go/internal/cmdflag/flag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -92,7 +92,7 @@ func ParseOne(fs *flag.FlagSet, args []string) (f *flag.Flag, remainingArgs []st\n \t// Use fs.Set instead of f.Value.Set below so that any subsequent call to\n \t// fs.Visit will correctly visit the flags that have been set.\n \n-\tfailf := func(format string, a ...interface{}) (*flag.Flag, []string, error) {\n+\tfailf := func(format string, a ...any) (*flag.Flag, []string, error) {\n \t\treturn f, args, fmt.Errorf(format, a...)\n \t}\n "}, {"sha": "7741a9022c910a0bee6c4084e55503bc6aea9c09", "filename": "libgo/go/cmd/go/internal/doc/doc.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -60,9 +60,8 @@ The package path must be either a qualified path or a proper suffix of a\n path. The go tool's usual package mechanism does not apply: package path\n elements like . and ... are not implemented by go doc.\n \n-When run with two arguments, the first must be a full package path (not just a\n-suffix), and the second is a symbol, or symbol with method or struct field.\n-This is similar to the syntax accepted by godoc:\n+When run with two arguments, the first is a package path (full path or suffix),\n+and the second is a symbol, or symbol with method or struct field:\n \n \tgo doc <pkg> <sym>[.<methodOrField>]\n "}, {"sha": "e56dd8223f0519e90e9c89cd8e576d5f227becc5", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -26,6 +26,7 @@ import (\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/work\"\n+\t\"cmd/internal/quoted\"\n )\n \n var CmdEnv = &base.Command{\n@@ -104,13 +105,13 @@ func MkEnv() []cfg.EnvVar {\n \t\tenv = append(env, cfg.EnvVar{Name: key, Value: val})\n \t}\n \n-\tcc := cfg.DefaultCC(cfg.Goos, cfg.Goarch)\n-\tif env := strings.Fields(cfg.Getenv(\"CC\")); len(env) > 0 {\n-\t\tcc = env[0]\n+\tcc := cfg.Getenv(\"CC\")\n+\tif cc == \"\" {\n+\t\tcc = cfg.DefaultCC(cfg.Goos, cfg.Goarch)\n \t}\n-\tcxx := cfg.DefaultCXX(cfg.Goos, cfg.Goarch)\n-\tif env := strings.Fields(cfg.Getenv(\"CXX\")); len(env) > 0 {\n-\t\tcxx = env[0]\n+\tcxx := cfg.Getenv(\"CXX\")\n+\tif cxx == \"\" {\n+\t\tcxx = cfg.DefaultCXX(cfg.Goos, cfg.Goarch)\n \t}\n \tenv = append(env, cfg.EnvVar{Name: \"AR\", Value: envOr(\"AR\", \"ar\")})\n \tenv = append(env, cfg.EnvVar{Name: \"CC\", Value: cc})\n@@ -145,13 +146,17 @@ func findEnv(env []cfg.EnvVar, name string) string {\n // ExtraEnvVars returns environment variables that should not leak into child processes.\n func ExtraEnvVars() []cfg.EnvVar {\n \tgomod := \"\"\n+\tmodload.Init()\n \tif modload.HasModRoot() {\n-\t\tgomod = filepath.Join(modload.ModRoot(), \"go.mod\")\n+\t\tgomod = modload.ModFilePath()\n \t} else if modload.Enabled() {\n \t\tgomod = os.DevNull\n \t}\n+\tmodload.InitWorkfile()\n+\tgowork := modload.WorkFilePath()\n \treturn []cfg.EnvVar{\n \t\t{Name: \"GOMOD\", Value: gomod},\n+\t\t{Name: \"GOWORK\", Value: gowork},\n \t}\n }\n \n@@ -191,13 +196,13 @@ func argKey(arg string) string {\n \n func runEnv(ctx context.Context, cmd *base.Command, args []string) {\n \tif *envJson && *envU {\n-\t\tbase.Fatalf(\"go env: cannot use -json with -u\")\n+\t\tbase.Fatalf(\"go: cannot use -json with -u\")\n \t}\n \tif *envJson && *envW {\n-\t\tbase.Fatalf(\"go env: cannot use -json with -w\")\n+\t\tbase.Fatalf(\"go: cannot use -json with -w\")\n \t}\n \tif *envU && *envW {\n-\t\tbase.Fatalf(\"go env: cannot use -u with -w\")\n+\t\tbase.Fatalf(\"go: cannot use -u with -w\")\n \t}\n \n \t// Handle 'go env -w' and 'go env -u' before calling buildcfg.Check,\n@@ -275,7 +280,7 @@ func runEnv(ctx context.Context, cmd *base.Command, args []string) {\n func runEnvW(args []string) {\n \t// Process and sanity-check command line.\n \tif len(args) == 0 {\n-\t\tbase.Fatalf(\"go env -w: no KEY=VALUE arguments given\")\n+\t\tbase.Fatalf(\"go: no KEY=VALUE arguments given\")\n \t}\n \tosEnv := make(map[string]string)\n \tfor _, e := range cfg.OrigEnv {\n@@ -287,14 +292,14 @@ func runEnvW(args []string) {\n \tfor _, arg := range args {\n \t\ti := strings.Index(arg, \"=\")\n \t\tif i < 0 {\n-\t\t\tbase.Fatalf(\"go env -w: arguments must be KEY=VALUE: invalid argument: %s\", arg)\n+\t\t\tbase.Fatalf(\"go: arguments must be KEY=VALUE: invalid argument: %s\", arg)\n \t\t}\n \t\tkey, val := arg[:i], arg[i+1:]\n \t\tif err := checkEnvWrite(key, val); err != nil {\n-\t\t\tbase.Fatalf(\"go env -w: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tif _, ok := add[key]; ok {\n-\t\t\tbase.Fatalf(\"go env -w: multiple values for key: %s\", key)\n+\t\t\tbase.Fatalf(\"go: multiple values for key: %s\", key)\n \t\t}\n \t\tadd[key] = val\n \t\tif osVal := osEnv[key]; osVal != \"\" && osVal != val {\n@@ -303,13 +308,13 @@ func runEnvW(args []string) {\n \t}\n \n \tif err := checkBuildConfig(add, nil); err != nil {\n-\t\tbase.Fatalf(\"go env -w: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tgotmp, okGOTMP := add[\"GOTMPDIR\"]\n \tif okGOTMP {\n \t\tif !filepath.IsAbs(gotmp) && gotmp != \"\" {\n-\t\t\tbase.Fatalf(\"go env -w: GOTMPDIR must be an absolute path\")\n+\t\t\tbase.Fatalf(\"go: GOTMPDIR must be an absolute path\")\n \t\t}\n \t}\n \n@@ -319,18 +324,18 @@ func runEnvW(args []string) {\n func runEnvU(args []string) {\n \t// Process and sanity-check command line.\n \tif len(args) == 0 {\n-\t\tbase.Fatalf(\"go env -u: no arguments given\")\n+\t\tbase.Fatalf(\"go: 'go env -u' requires an argument\")\n \t}\n \tdel := make(map[string]bool)\n \tfor _, arg := range args {\n \t\tif err := checkEnvWrite(arg, \"\"); err != nil {\n-\t\t\tbase.Fatalf(\"go env -u: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tdel[arg] = true\n \t}\n \n \tif err := checkBuildConfig(nil, del); err != nil {\n-\t\tbase.Fatalf(\"go env -u: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tupdateEnvFile(nil, del)\n@@ -414,7 +419,7 @@ func printEnvAsJSON(env []cfg.EnvVar) {\n \tenc := json.NewEncoder(os.Stdout)\n \tenc.SetIndent(\"\", \"\\t\")\n \tif err := enc.Encode(m); err != nil {\n-\t\tbase.Fatalf(\"go env -json: %s\", err)\n+\t\tbase.Fatalf(\"go: %s\", err)\n \t}\n }\n \n@@ -429,7 +434,7 @@ func getOrigEnv(key string) string {\n \n func checkEnvWrite(key, val string) error {\n \tswitch key {\n-\tcase \"GOEXE\", \"GOGCCFLAGS\", \"GOHOSTARCH\", \"GOHOSTOS\", \"GOMOD\", \"GOTOOLDIR\", \"GOVERSION\":\n+\tcase \"GOEXE\", \"GOGCCFLAGS\", \"GOHOSTARCH\", \"GOHOSTOS\", \"GOMOD\", \"GOWORK\", \"GOTOOLDIR\", \"GOVERSION\":\n \t\treturn fmt.Errorf(\"%s cannot be modified\", key)\n \tcase \"GOENV\":\n \t\treturn fmt.Errorf(\"%s can only be set using the OS environment\", key)\n@@ -457,10 +462,23 @@ func checkEnvWrite(key, val string) error {\n \t\tif !filepath.IsAbs(val) && val != \"\" {\n \t\t\treturn fmt.Errorf(\"GOPATH entry is relative; must be absolute path: %q\", val)\n \t\t}\n-\t// Make sure CC and CXX are absolute paths\n-\tcase \"CC\", \"CXX\", \"GOMODCACHE\":\n-\t\tif !filepath.IsAbs(val) && val != \"\" && val != filepath.Base(val) {\n-\t\t\treturn fmt.Errorf(\"%s entry is relative; must be absolute path: %q\", key, val)\n+\tcase \"GOMODCACHE\":\n+\t\tif !filepath.IsAbs(val) && val != \"\" {\n+\t\t\treturn fmt.Errorf(\"GOMODCACHE entry is relative; must be absolute path: %q\", val)\n+\t\t}\n+\tcase \"CC\", \"CXX\":\n+\t\tif val == \"\" {\n+\t\t\tbreak\n+\t\t}\n+\t\targs, err := quoted.Split(val)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"invalid %s: %v\", key, err)\n+\t\t}\n+\t\tif len(args) == 0 {\n+\t\t\treturn fmt.Errorf(\"%s entry cannot contain only space\", key)\n+\t\t}\n+\t\tif !filepath.IsAbs(args[0]) && args[0] != filepath.Base(args[0]) {\n+\t\t\treturn fmt.Errorf(\"%s entry is relative; must be absolute path: %q\", key, args[0])\n \t\t}\n \t}\n \n@@ -479,11 +497,11 @@ func checkEnvWrite(key, val string) error {\n func updateEnvFile(add map[string]string, del map[string]bool) {\n \tfile, err := cfg.EnvFile()\n \tif file == \"\" {\n-\t\tbase.Fatalf(\"go env: cannot find go env config: %v\", err)\n+\t\tbase.Fatalf(\"go: cannot find go env config: %v\", err)\n \t}\n \tdata, err := os.ReadFile(file)\n \tif err != nil && (!os.IsNotExist(err) || len(add) == 0) {\n-\t\tbase.Fatalf(\"go env: reading go env config: %v\", err)\n+\t\tbase.Fatalf(\"go: reading go env config: %v\", err)\n \t}\n \n \tlines := strings.SplitAfter(string(data), \"\\n\")\n@@ -541,7 +559,7 @@ func updateEnvFile(add map[string]string, del map[string]bool) {\n \t\tos.MkdirAll(filepath.Dir(file), 0777)\n \t\terr = os.WriteFile(file, data, 0666)\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go env: writing go env config: %v\", err)\n+\t\t\tbase.Fatalf(\"go: writing go env config: %v\", err)\n \t\t}\n \t}\n }"}, {"sha": "d8ba353de6595091f10b693bcb3aed1fde9d2e0d", "filename": "libgo/go/cmd/go/internal/fix/fix.go", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -11,27 +11,39 @@ import (\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/work\"\n \t\"context\"\n \t\"fmt\"\n+\t\"go/build\"\n \t\"os\"\n )\n \n var CmdFix = &base.Command{\n-\tRun:       runFix,\n-\tUsageLine: \"go fix [packages]\",\n+\tUsageLine: \"go fix [-fix list] [packages]\",\n \tShort:     \"update packages to use new APIs\",\n \tLong: `\n Fix runs the Go fix command on the packages named by the import paths.\n \n+The -fix flag sets a comma-separated list of fixes to run.\n+The default is all known fixes.\n+(Its value is passed to 'go tool fix -r'.)\n+\n For more about fix, see 'go doc cmd/fix'.\n For more about specifying packages, see 'go help packages'.\n \n-To run fix with specific options, run 'go tool fix'.\n+To run fix with other options, run 'go tool fix'.\n \n See also: go fmt, go vet.\n \t`,\n }\n \n+var fixes = CmdFix.Flag.String(\"fix\", \"\", \"comma-separated list of fixes to apply\")\n+\n+func init() {\n+\twork.AddBuildFlags(CmdFix, work.DefaultBuildFlags)\n+\tCmdFix.Run = runFix // fix cycle\n+}\n+\n func runFix(ctx context.Context, cmd *base.Command, args []string) {\n \tpkgs := load.PackagesAndErrors(ctx, load.PackageOpts{}, args)\n \tw := 0\n@@ -58,6 +70,16 @@ func runFix(ctx context.Context, cmd *base.Command, args []string) {\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories.\n \t\tfiles := base.RelPaths(pkg.InternalAllGoFiles())\n-\t\tbase.Run(str.StringList(cfg.BuildToolexec, base.Tool(\"fix\"), files))\n+\t\tgoVersion := \"\"\n+\t\tif pkg.Module != nil {\n+\t\t\tgoVersion = \"go\" + pkg.Module.GoVersion\n+\t\t} else if pkg.Standard {\n+\t\t\tgoVersion = build.Default.ReleaseTags[len(build.Default.ReleaseTags)-1]\n+\t\t}\n+\t\tvar fixArg []string\n+\t\tif *fixes != \"\" {\n+\t\t\tfixArg = []string{\"-r=\" + *fixes}\n+\t\t}\n+\t\tbase.Run(str.StringList(cfg.BuildToolexec, base.Tool(\"fix\"), \"-go=\"+goVersion, fixArg, files))\n \t}\n }"}, {"sha": "19656eab7fc661c4cea1fabf55630f38ab2b3c98", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -11,14 +11,12 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"runtime\"\n-\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/str\"\n+\t\"cmd/internal/sys\"\n )\n \n func init() {\n@@ -53,18 +51,13 @@ See also: go fix, go vet.\n func runFmt(ctx context.Context, cmd *base.Command, args []string) {\n \tprinted := false\n \tgofmt := gofmtPath()\n-\tprocs := runtime.GOMAXPROCS(0)\n-\tvar wg sync.WaitGroup\n-\twg.Add(procs)\n-\tfileC := make(chan string, 2*procs)\n-\tfor i := 0; i < procs; i++ {\n-\t\tgo func() {\n-\t\t\tdefer wg.Done()\n-\t\t\tfor file := range fileC {\n-\t\t\t\tbase.Run(str.StringList(gofmt, \"-l\", \"-w\", file))\n-\t\t\t}\n-\t\t}()\n-\t}\n+\n+\tgofmtArgs := []string{gofmt, \"-l\", \"-w\"}\n+\tgofmtArgLen := len(gofmt) + len(\" -l -w\")\n+\n+\tbaseGofmtArgs := len(gofmtArgs)\n+\tbaseGofmtArgLen := gofmtArgLen\n+\n \tfor _, pkg := range load.PackagesAndErrors(ctx, load.PackageOpts{}, args) {\n \t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n@@ -89,11 +82,18 @@ func runFmt(ctx context.Context, cmd *base.Command, args []string) {\n \t\t// not to packages in subdirectories.\n \t\tfiles := base.RelPaths(pkg.InternalAllGoFiles())\n \t\tfor _, file := range files {\n-\t\t\tfileC <- file\n+\t\t\tgofmtArgs = append(gofmtArgs, file)\n+\t\t\tgofmtArgLen += 1 + len(file) // plus separator\n+\t\t\tif gofmtArgLen >= sys.ExecArgLengthLimit {\n+\t\t\t\tbase.Run(gofmtArgs)\n+\t\t\t\tgofmtArgs = gofmtArgs[:baseGofmtArgs]\n+\t\t\t\tgofmtArgLen = baseGofmtArgLen\n+\t\t\t}\n \t\t}\n \t}\n-\tclose(fileC)\n-\twg.Wait()\n+\tif len(gofmtArgs) > baseGofmtArgs {\n+\t\tbase.Run(gofmtArgs)\n+\t}\n }\n \n func gofmtPath() string {"}, {"sha": "9a1bbf890e1191ebb68b19673f7ea647bae9a899", "filename": "libgo/go/cmd/go/internal/fsys/fsys.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -499,7 +499,7 @@ func (f fakeFile) Size() int64        { return f.real.Size() }\n func (f fakeFile) Mode() fs.FileMode  { return f.real.Mode() }\n func (f fakeFile) ModTime() time.Time { return f.real.ModTime() }\n func (f fakeFile) IsDir() bool        { return f.real.IsDir() }\n-func (f fakeFile) Sys() interface{}   { return f.real.Sys() }\n+func (f fakeFile) Sys() any           { return f.real.Sys() }\n \n // missingFile provides an fs.FileInfo for an overlaid file where the\n // destination file in the overlay doesn't exist. It returns zero values\n@@ -512,7 +512,7 @@ func (f missingFile) Size() int64        { return 0 }\n func (f missingFile) Mode() fs.FileMode  { return fs.ModeIrregular }\n func (f missingFile) ModTime() time.Time { return time.Unix(0, 0) }\n func (f missingFile) IsDir() bool        { return false }\n-func (f missingFile) Sys() interface{}   { return nil }\n+func (f missingFile) Sys() any           { return nil }\n \n // fakeDir provides an fs.FileInfo implementation for directories that are\n // implicitly created by overlaid files. Each directory in the\n@@ -524,7 +524,7 @@ func (f fakeDir) Size() int64        { return 0 }\n func (f fakeDir) Mode() fs.FileMode  { return fs.ModeDir | 0500 }\n func (f fakeDir) ModTime() time.Time { return time.Unix(0, 0) }\n func (f fakeDir) IsDir() bool        { return true }\n-func (f fakeDir) Sys() interface{}   { return nil }\n+func (f fakeDir) Sys() any           { return nil }\n \n // Glob is like filepath.Glob but uses the overlay file system.\n func Glob(pattern string) (matches []string, err error) {"}, {"sha": "c080c14987c37cad5928771d49bb0a4b1b602953", "filename": "libgo/go/cmd/go/internal/fsys/fsys_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,7 +1,6 @@\n package fsys\n \n import (\n-\t\"cmd/go/internal/txtar\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n@@ -12,6 +11,8 @@ import (\n \t\"path/filepath\"\n \t\"reflect\"\n \t\"testing\"\n+\n+\t\"golang.org/x/tools/txtar\"\n )\n \n // initOverlay resets the overlay state to reflect the config."}, {"sha": "54ccfe78f24b66d526bc4b386b8ebc282603a140", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -38,7 +38,7 @@ Generate runs commands described by directives within existing\n files. Those commands can run any process but the intent is to\n create or update Go source files.\n \n-Go generate is never run automatically by go build, go get, go test,\n+Go generate is never run automatically by go build, go test,\n and so on. It must be run explicitly.\n \n Go generate scans the file for directives, which are lines of\n@@ -408,7 +408,7 @@ var stop = fmt.Errorf(\"error in generation\")\n // errorf logs an error message prefixed with the file and line number.\n // It then exits the program (with exit status 1) because generation stops\n // at the first error.\n-func (g *Generator) errorf(format string, args ...interface{}) {\n+func (g *Generator) errorf(format string, args ...any) {\n \tfmt.Fprintf(os.Stderr, \"%s:%d: %s\\n\", base.ShortPath(g.path), g.lineNum,\n \t\tfmt.Sprintf(format, args...))\n \tpanic(stop)"}, {"sha": "8cf8fe6645f369d47d84de3321e195e0b727cf22", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -114,16 +114,16 @@ func init() {\n func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \tif cfg.ModulesEnabled {\n \t\t// Should not happen: main.go should install the separate module-enabled get code.\n-\t\tbase.Fatalf(\"go get: modules not implemented\")\n+\t\tbase.Fatalf(\"go: modules not implemented\")\n \t}\n \n \twork.BuildInit()\n \n \tif *getF && !*getU {\n-\t\tbase.Fatalf(\"go get: cannot use -f flag without -u\")\n+\t\tbase.Fatalf(\"go: cannot use -f flag without -u\")\n \t}\n \tif *getInsecure {\n-\t\tbase.Fatalf(\"go get: -insecure flag is no longer supported; use GOINSECURE instead\")\n+\t\tbase.Fatalf(\"go: -insecure flag is no longer supported; use GOINSECURE instead\")\n \t}\n \n \t// Disable any prompting for passwords by Git itself.\n@@ -214,18 +214,19 @@ func downloadPaths(patterns []string) []string {\n \t\t// if the argument has no slash or refers to an existing file.\n \t\tif strings.HasSuffix(arg, \".go\") {\n \t\t\tif !strings.Contains(arg, \"/\") {\n-\t\t\t\tbase.Errorf(\"go get %s: arguments must be package or module paths\", arg)\n+\t\t\t\tbase.Errorf(\"go: %s: arguments must be package or module paths\", arg)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif fi, err := os.Stat(arg); err == nil && !fi.IsDir() {\n-\t\t\t\tbase.Errorf(\"go get: %s exists as a file, but 'go get' requires package arguments\", arg)\n+\t\t\t\tbase.Errorf(\"go: %s exists as a file, but 'go get' requires package arguments\", arg)\n \t\t\t}\n \t\t}\n \t}\n \tbase.ExitIfErrors()\n \n \tvar pkgs []string\n-\tfor _, m := range search.ImportPathsQuiet(patterns) {\n+\tnoModRoots := []string{}\n+\tfor _, m := range search.ImportPathsQuiet(patterns, noModRoots) {\n \t\tif len(m.Pkgs) == 0 && strings.Contains(m.Pattern(), \"...\") {\n \t\t\tpkgs = append(pkgs, m.Pattern())\n \t\t} else {\n@@ -315,7 +316,8 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t\tif wildcardOkay && strings.Contains(arg, \"...\") {\n \t\t\tmatch := search.NewMatch(arg)\n \t\t\tif match.IsLocal() {\n-\t\t\t\tmatch.MatchDirs()\n+\t\t\t\tnoModRoots := []string{} // We're in gopath mode, so there are no modroots.\n+\t\t\t\tmatch.MatchDirs(noModRoots)\n \t\t\t\targs = match.Dirs\n \t\t\t} else {\n \t\t\t\tmatch.MatchPackages()\n@@ -415,10 +417,10 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n // to make the first copy of or update a copy of the given package.\n func downloadPackage(p *load.Package) error {\n \tvar (\n-\t\tvcsCmd         *vcs.Cmd\n-\t\trepo, rootPath string\n-\t\terr            error\n-\t\tblindRepo      bool // set if the repo has unusual configuration\n+\t\tvcsCmd                  *vcs.Cmd\n+\t\trepo, rootPath, repoDir string\n+\t\terr                     error\n+\t\tblindRepo               bool // set if the repo has unusual configuration\n \t)\n \n \t// p can be either a real package, or a pseudo-package whose \u201cimport path\u201d is\n@@ -444,10 +446,19 @@ func downloadPackage(p *load.Package) error {\n \n \tif p.Internal.Build.SrcRoot != \"\" {\n \t\t// Directory exists. Look for checkout along path to src.\n-\t\tvcsCmd, rootPath, err = vcs.FromDir(p.Dir, p.Internal.Build.SrcRoot)\n+\t\tconst allowNesting = false\n+\t\trepoDir, vcsCmd, err = vcs.FromDir(p.Dir, p.Internal.Build.SrcRoot, allowNesting)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif !str.HasFilePathPrefix(repoDir, p.Internal.Build.SrcRoot) {\n+\t\t\tpanic(fmt.Sprintf(\"repository %q not in source root %q\", repo, p.Internal.Build.SrcRoot))\n+\t\t}\n+\t\trootPath = str.TrimFilePathPrefix(repoDir, p.Internal.Build.SrcRoot)\n+\t\tif err := vcs.CheckGOVCS(vcsCmd, rootPath); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n \t\trepo = \"<local>\" // should be unused; make distinctive\n \n \t\t// Double-check where it came from."}, {"sha": "2a07d2423bdd9e46eb397228214cde2b13226695", "filename": "libgo/go/cmd/go/internal/help/help.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -162,7 +162,7 @@ func (w *errWriter) Write(b []byte) (int, error) {\n }\n \n // tmpl executes the given template text on data, writing the result to w.\n-func tmpl(w io.Writer, text string, data interface{}) {\n+func tmpl(w io.Writer, text string, data any) {\n \tt := template.New(\"top\")\n \tt.Funcs(template.FuncMap{\"trim\": strings.TrimSpace, \"capitalize\": capitalize})\n \ttemplate.Must(t.Parse(text))"}, {"sha": "7dc066cfbad6cc9262a9b3a451c1bf5d618ab95e", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -592,6 +592,10 @@ Architecture-specific environment variables:\n \tGO386\n \t\tFor GOARCH=386, how to implement floating point instructions.\n \t\tValid values are sse2 (default), softfloat.\n+\tGOAMD64\n+\t\tFor GOARCH=amd64, the microarchitecture level for which to compile.\n+\t\tValid values are v1 (default), v2, v3, v4.\n+\t\tSee https://golang.org/wiki/MinimumRequirements#amd64\n \tGOMIPS\n \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n \t\tValid values are hardfloat (default), softfloat.\n@@ -771,6 +775,13 @@ The go command also caches successful package test results.\n See 'go help test' for details. Running 'go clean -testcache' removes\n all cached test results (but not cached build results).\n \n+The go command also caches values used in fuzzing with 'go test -fuzz',\n+specifically, values that expanded code coverage when passed to a\n+fuzz function. These values are not used for regular building and\n+testing, but they're stored in a subdirectory of the build cache.\n+Running 'go clean -fuzzcache' removes all cached fuzzing values.\n+This may make fuzzing less effective, temporarily.\n+\n The GODEBUG environment variable can enable printing of debugging\n information about the state of the cache:\n "}, {"sha": "ff6bea6777dce89c81385f1e38182e43de12f821", "filename": "libgo/go/cmd/go/internal/imports/build.go", "status": "modified", "additions": 151, "deletions": 65, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,17 +2,51 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Copied from Go distribution src/go/build/build.go, syslist.go\n+// Copied from Go distribution src/go/build/build.go, syslist.go.\n+// That package does not export the ability to process raw file data,\n+// although we could fake it with an appropriate build.Context\n+// and a lot of unwrapping.\n+// More importantly, that package does not implement the tags[\"*\"]\n+// special case, in which both tag and !tag are considered to be true\n+// for essentially all tags (except \"ignore\").\n+//\n+// If we added this API to go/build directly, we wouldn't need this\n+// file anymore, but this API is not terribly general-purpose and we\n+// don't really want to commit to any public form of it, nor do we\n+// want to move the core parts of go/build into a top-level internal package.\n+// These details change very infrequently, so the copy is fine.\n \n package imports\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"go/build/constraint\"\n \t\"strings\"\n \t\"unicode\"\n )\n \n-var slashslash = []byte(\"//\")\n+var (\n+\tbSlashSlash = []byte(\"//\")\n+\tbStarSlash  = []byte(\"*/\")\n+\tbSlashStar  = []byte(\"/*\")\n+\tbPlusBuild  = []byte(\"+build\")\n+\n+\tgoBuildComment = []byte(\"//go:build\")\n+\n+\terrGoBuildWithoutBuild = errors.New(\"//go:build comment without // +build comment\")\n+\terrMultipleGoBuild     = errors.New(\"multiple //go:build comments\")\n+)\n+\n+func isGoBuildComment(line []byte) bool {\n+\tif !bytes.HasPrefix(line, goBuildComment) {\n+\t\treturn false\n+\t}\n+\tline = bytes.TrimSpace(line)\n+\trest := line[len(goBuildComment):]\n+\treturn len(rest) == 0 || len(bytes.TrimSpace(rest)) < len(rest)\n+}\n \n // ShouldBuild reports whether it is okay to use this file,\n // The rule is that in the file's leading run of // comments\n@@ -34,10 +68,61 @@ var slashslash = []byte(\"//\")\n // in any build.\n //\n func ShouldBuild(content []byte, tags map[string]bool) bool {\n-\t// Pass 1. Identify leading run of // comments and blank lines,\n+\t// Identify leading run of // comments and blank lines,\n \t// which must be followed by a blank line.\n+\t// Also identify any //go:build comments.\n+\tcontent, goBuild, _, err := parseFileHeader(content)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\n+\t// If //go:build line is present, it controls.\n+\t// Otherwise fall back to +build processing.\n+\tvar shouldBuild bool\n+\tswitch {\n+\tcase goBuild != nil:\n+\t\tx, err := constraint.Parse(string(goBuild))\n+\t\tif err != nil {\n+\t\t\treturn false\n+\t\t}\n+\t\tshouldBuild = eval(x, tags, true)\n+\n+\tdefault:\n+\t\tshouldBuild = true\n+\t\tp := content\n+\t\tfor len(p) > 0 {\n+\t\t\tline := p\n+\t\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n+\t\t\t\tline, p = line[:i], p[i+1:]\n+\t\t\t} else {\n+\t\t\t\tp = p[len(p):]\n+\t\t\t}\n+\t\t\tline = bytes.TrimSpace(line)\n+\t\t\tif !bytes.HasPrefix(line, bSlashSlash) || !bytes.Contains(line, bPlusBuild) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ttext := string(line)\n+\t\t\tif !constraint.IsPlusBuild(text) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif x, err := constraint.Parse(text); err == nil {\n+\t\t\t\tif !eval(x, tags, true) {\n+\t\t\t\t\tshouldBuild = false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn shouldBuild\n+}\n+\n+func parseFileHeader(content []byte) (trimmed, goBuild []byte, sawBinaryOnly bool, err error) {\n \tend := 0\n \tp := content\n+\tended := false       // found non-blank, non-// line, so stopped accepting // +build lines\n+\tinSlashStar := false // in /* */ comment\n+\n+Lines:\n \tfor len(p) > 0 {\n \t\tline := p\n \t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n@@ -46,78 +131,61 @@ func ShouldBuild(content []byte, tags map[string]bool) bool {\n \t\t\tp = p[len(p):]\n \t\t}\n \t\tline = bytes.TrimSpace(line)\n-\t\tif len(line) == 0 { // Blank line\n+\t\tif len(line) == 0 && !ended { // Blank line\n+\t\t\t// Remember position of most recent blank line.\n+\t\t\t// When we find the first non-blank, non-// line,\n+\t\t\t// this \"end\" position marks the latest file position\n+\t\t\t// where a // +build line can appear.\n+\t\t\t// (It must appear _before_ a blank line before the non-blank, non-// line.\n+\t\t\t// Yes, that's confusing, which is part of why we moved to //go:build lines.)\n+\t\t\t// Note that ended==false here means that inSlashStar==false,\n+\t\t\t// since seeing a /* would have set ended==true.\n \t\t\tend = len(content) - len(p)\n-\t\t\tcontinue\n+\t\t\tcontinue Lines\n \t\t}\n-\t\tif !bytes.HasPrefix(line, slashslash) { // Not comment line\n-\t\t\tbreak\n+\t\tif !bytes.HasPrefix(line, bSlashSlash) { // Not comment line\n+\t\t\tended = true\n \t\t}\n-\t}\n-\tcontent = content[:end]\n \n-\t// Pass 2.  Process each line in the run.\n-\tp = content\n-\tallok := true\n-\tfor len(p) > 0 {\n-\t\tline := p\n-\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n-\t\t\tline, p = line[:i], p[i+1:]\n-\t\t} else {\n-\t\t\tp = p[len(p):]\n-\t\t}\n-\t\tline = bytes.TrimSpace(line)\n-\t\tif !bytes.HasPrefix(line, slashslash) {\n-\t\t\tcontinue\n+\t\tif !inSlashStar && isGoBuildComment(line) {\n+\t\t\tif goBuild != nil {\n+\t\t\t\treturn nil, nil, false, errMultipleGoBuild\n+\t\t\t}\n+\t\t\tgoBuild = line\n \t\t}\n-\t\tline = bytes.TrimSpace(line[len(slashslash):])\n-\t\tif len(line) > 0 && line[0] == '+' {\n-\t\t\t// Looks like a comment +line.\n-\t\t\tf := strings.Fields(string(line))\n-\t\t\tif f[0] == \"+build\" {\n-\t\t\t\tok := false\n-\t\t\t\tfor _, tok := range f[1:] {\n-\t\t\t\t\tif matchTags(tok, tags) {\n-\t\t\t\t\t\tok = true\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif !ok {\n-\t\t\t\t\tallok = false\n+\n+\tComments:\n+\t\tfor len(line) > 0 {\n+\t\t\tif inSlashStar {\n+\t\t\t\tif i := bytes.Index(line, bStarSlash); i >= 0 {\n+\t\t\t\t\tinSlashStar = false\n+\t\t\t\t\tline = bytes.TrimSpace(line[i+len(bStarSlash):])\n+\t\t\t\t\tcontinue Comments\n \t\t\t\t}\n+\t\t\t\tcontinue Lines\n \t\t\t}\n+\t\t\tif bytes.HasPrefix(line, bSlashSlash) {\n+\t\t\t\tcontinue Lines\n+\t\t\t}\n+\t\t\tif bytes.HasPrefix(line, bSlashStar) {\n+\t\t\t\tinSlashStar = true\n+\t\t\t\tline = bytes.TrimSpace(line[len(bSlashStar):])\n+\t\t\t\tcontinue Comments\n+\t\t\t}\n+\t\t\t// Found non-comment text.\n+\t\t\tbreak Lines\n \t\t}\n \t}\n \n-\treturn allok\n-}\n-\n-// matchTags reports whether the name is one of:\n-//\n-//\ttag (if tags[tag] is true)\n-//\t!tag (if tags[tag] is false)\n-//\ta comma-separated list of any of these\n-//\n-func matchTags(name string, tags map[string]bool) bool {\n-\tif name == \"\" {\n-\t\treturn false\n-\t}\n-\tif i := strings.Index(name, \",\"); i >= 0 {\n-\t\t// comma-separated list\n-\t\tok1 := matchTags(name[:i], tags)\n-\t\tok2 := matchTags(name[i+1:], tags)\n-\t\treturn ok1 && ok2\n-\t}\n-\tif strings.HasPrefix(name, \"!!\") { // bad syntax, reject always\n-\t\treturn false\n-\t}\n-\tif strings.HasPrefix(name, \"!\") { // negation\n-\t\treturn len(name) > 1 && matchTag(name[1:], tags, false)\n-\t}\n-\treturn matchTag(name, tags, true)\n+\treturn content[:end], goBuild, sawBinaryOnly, nil\n }\n \n-// matchTag reports whether the tag name is valid and satisfied by tags[name]==want.\n-func matchTag(name string, tags map[string]bool, want bool) bool {\n+// matchTag reports whether the tag name is valid and tags[name] is true.\n+// As a special case, if tags[\"*\"] is true and name is not empty or ignore,\n+// then matchTag will return prefer instead of the actual answer,\n+// which allows the caller to pretend in that case that most tags are\n+// both true and false.\n+func matchTag(name string, tags map[string]bool, prefer bool) bool {\n \t// Tags must be letters, digits, underscores or dots.\n \t// Unlike in Go identifiers, all digits are fine (e.g., \"386\").\n \tfor _, c := range name {\n@@ -131,7 +199,7 @@ func matchTag(name string, tags map[string]bool, want bool) bool {\n \t\t// if we put * in the tags map then all tags\n \t\t// except \"ignore\" are considered both present and not\n \t\t// (so we return true no matter how 'want' is set).\n-\t\treturn true\n+\t\treturn prefer\n \t}\n \n \thave := tags[name]\n@@ -144,7 +212,25 @@ func matchTag(name string, tags map[string]bool, want bool) bool {\n \tif name == \"darwin\" {\n \t\thave = have || tags[\"ios\"]\n \t}\n-\treturn have == want\n+\treturn have\n+}\n+\n+// eval is like\n+//\tx.Eval(func(tag string) bool { return matchTag(tag, tags) })\n+// except that it implements the special case for tags[\"*\"] meaning\n+// all tags are both true and false at the same time.\n+func eval(x constraint.Expr, tags map[string]bool, prefer bool) bool {\n+\tswitch x := x.(type) {\n+\tcase *constraint.TagExpr:\n+\t\treturn matchTag(x.Tag, tags, prefer)\n+\tcase *constraint.NotExpr:\n+\t\treturn !eval(x.X, tags, !prefer)\n+\tcase *constraint.AndExpr:\n+\t\treturn eval(x.X, tags, prefer) && eval(x.Y, tags, prefer)\n+\tcase *constraint.OrExpr:\n+\t\treturn eval(x.X, tags, prefer) || eval(x.Y, tags, prefer)\n+\t}\n+\tpanic(fmt.Sprintf(\"unexpected constraint expression %T\", x))\n }\n \n // MatchFile returns false if the name contains a $GOOS or $GOARCH"}, {"sha": "7e69c56513ac01a2acf0d5cd5d4372597abd96f0", "filename": "libgo/go/cmd/go/internal/imports/scan_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -33,7 +33,7 @@ func TestScan(t *testing.T) {\n \t\t}\n \t\tif p == \"net/http\" {\n \t\t\t// A test import but not an import\n-\t\t\tt.Errorf(\"json reported as importing encoding/binary but does not\")\n+\t\t\tt.Errorf(\"json reported as importing net/http but does not\")\n \t\t}\n \t}\n \tif !foundBase64 {"}, {"sha": "f1b9c888c2cafdd83ab651a52f75b31bb1f83516", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/e.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fe.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,3 +1,4 @@\n+//go:build android\n // +build android\n \n package android"}, {"sha": "bb0ff7b73f67c15fffeb5ea95f0628047a794cdf", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/f.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ff.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,3 +1,4 @@\n+//go:build linux\n // +build linux\n \n package android"}, {"sha": "ee19424890a963fa1618310d2875de3438df2a0e", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/g.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fg.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,3 +1,4 @@\n+//go:build !android\n // +build !android\n \n package android"}, {"sha": "fddf2c429909b7776cd4cdddce2ed70f0cd35542", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/e.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fe.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,3 +1,4 @@\n+//go:build illumos\n // +build illumos\n \n package illumos"}, {"sha": "4b6d528e4c2225f29ed67e382a3561586b4f2170", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/f.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ff.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,3 +1,4 @@\n+//go:build solaris\n // +build solaris\n \n package illumos"}, {"sha": "1bf826b81510b42fafb4a11a0e9e92c7ad8d0860", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/g.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fg.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,3 +1,4 @@\n+//go:build !illumos\n // +build !illumos\n \n package illumos"}, {"sha": "eaaea979e9dc82285ab0f830cbc676295d0732d1", "filename": "libgo/go/cmd/go/internal/imports/testdata/star/x1.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx1.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,8 +1,5 @@\n-// +build blahblh\n-// +build linux\n-// +build !linux\n-// +build windows\n-// +build darwin\n+//go:build blahblh && linux && !linux && windows && darwin\n+// +build blahblh,linux,!linux,windows,darwin\n \n package x\n "}, {"sha": "d9a7078ccf29f7aa16d1a9d10e3bf24d486f4495", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -316,6 +316,7 @@ For more about modules, see https://golang.org/ref/mod.\n func init() {\n \tCmdList.Run = runList // break init cycle\n \twork.AddBuildFlags(CmdList, work.DefaultBuildFlags)\n+\tbase.AddWorkfileFlag(&CmdList.Flag)\n }\n \n var (\n@@ -336,6 +337,8 @@ var (\n var nl = []byte{'\\n'}\n \n func runList(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n \tif *listFmt != \"\" && *listJson == true {\n \t\tbase.Fatalf(\"go list -f cannot be used with -json\")\n \t}\n@@ -355,9 +358,9 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n-\tvar do func(interface{})\n+\tvar do func(any)\n \tif *listJson {\n-\t\tdo = func(x interface{}) {\n+\t\tdo = func(x any) {\n \t\t\tb, err := json.MarshalIndent(x, \"\", \"\\t\")\n \t\t\tif err != nil {\n \t\t\t\tout.Flush()\n@@ -383,7 +386,7 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"%s\", err)\n \t\t}\n-\t\tdo = func(x interface{}) {\n+\t\tdo = func(x any) {\n \t\t\tif err := tmpl.Execute(out, x); err != nil {\n \t\t\t\tout.Flush()\n \t\t\t\tbase.Fatalf(\"%s\", err)\n@@ -424,12 +427,12 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t}\n \n \t\tif modload.Init(); !modload.Enabled() {\n-\t\t\tbase.Fatalf(\"go list -m: not using modules\")\n+\t\t\tbase.Fatalf(\"go: list -m cannot be used with GO111MODULE=off\")\n \t\t}\n \n \t\tmodload.LoadModFile(ctx) // Sets cfg.BuildMod as a side-effect.\n \t\tif cfg.BuildMod == \"vendor\" {\n-\t\t\tconst actionDisabledFormat = \"go list -m: can't %s using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\"\n+\t\t\tconst actionDisabledFormat = \"go: can't %s using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\"\n \n \t\t\tif *listVersions {\n \t\t\t\tbase.Fatalf(actionDisabledFormat, \"determine available versions\")\n@@ -468,11 +471,11 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\tif !*listE {\n \t\t\tfor _, m := range mods {\n \t\t\t\tif m.Error != nil {\n-\t\t\t\t\tbase.Errorf(\"go list -m: %v\", m.Error.Err)\n+\t\t\t\t\tbase.Errorf(\"go: %v\", m.Error.Err)\n \t\t\t\t}\n \t\t\t}\n \t\t\tif err != nil {\n-\t\t\t\tbase.Errorf(\"go list -m: %v\", err)\n+\t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t}\n \t\t\tbase.ExitIfErrors()\n \t\t}\n@@ -708,7 +711,7 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t}\n \t\t\trmods, err := modload.ListModules(ctx, args, mode)\n \t\t\tif err != nil && !*listE {\n-\t\t\t\tbase.Errorf(\"go list -retracted: %v\", err)\n+\t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t}\n \t\t\tfor i, arg := range args {\n \t\t\t\trmod := rmods[i]"}, {"sha": "de079decdf2541c6f7ac312e002aec761427bfbc", "filename": "libgo/go/cmd/go/internal/load/flag.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -6,7 +6,7 @@ package load\n \n import (\n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/str\"\n+\t\"cmd/internal/quoted\"\n \t\"fmt\"\n \t\"strings\"\n )\n@@ -22,6 +22,7 @@ var (\n // that allows specifying different effective flags for different packages.\n // See 'go help build' for more details about per-package flags.\n type PerPackageFlag struct {\n+\traw     string\n \tpresent bool\n \tvalues  []ppfValue\n }\n@@ -39,6 +40,7 @@ func (f *PerPackageFlag) Set(v string) error {\n \n // set is the implementation of Set, taking a cwd (current working directory) for easier testing.\n func (f *PerPackageFlag) set(v, cwd string) error {\n+\tf.raw = v\n \tf.present = true\n \tmatch := func(p *Package) bool { return p.Internal.CmdlinePkg || p.Internal.CmdlineFiles } // default predicate with no pattern\n \t// For backwards compatibility with earlier flag splitting, ignore spaces around flags.\n@@ -61,7 +63,7 @@ func (f *PerPackageFlag) set(v, cwd string) error {\n \t\tmatch = MatchPackage(pattern, cwd)\n \t\tv = v[i+1:]\n \t}\n-\tflags, err := str.SplitQuotedFields(v)\n+\tflags, err := quoted.Split(v)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -72,9 +74,7 @@ func (f *PerPackageFlag) set(v, cwd string) error {\n \treturn nil\n }\n \n-// String is required to implement flag.Value.\n-// It is not used, because cmd/go never calls flag.PrintDefaults.\n-func (f *PerPackageFlag) String() string { return \"<PerPackageFlag>\" }\n+func (f *PerPackageFlag) String() string { return f.raw }\n \n // Present reports whether the flag appeared on the command line.\n func (f *PerPackageFlag) Present() bool {"}, {"sha": "67b359d19d2054fbfad513e4de643a9f9d74c784", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 261, "deletions": 24, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -21,9 +21,11 @@ import (\n \tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"runtime/debug\"\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"time\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n \n@@ -38,6 +40,7 @@ import (\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/trace\"\n+\t\"cmd/go/internal/vcs\"\n \t\"cmd/internal/sys\"\n \n \t\"golang.org/x/mod/modfile\"\n@@ -203,6 +206,7 @@ type PackageInternal struct {\n \tLocal             bool                 // imported via local path (./ or ../)\n \tLocalPrefix       string               // interpret ./ and ../ imports relative to this prefix\n \tExeName           string               // desired name for temporary executable\n+\tFuzzInstrument    bool                 // package should be instrumented for fuzzing\n \tCoverMode         string               // preprocess Go source files with the coverage tool in this mode\n \tCoverVars         map[string]*CoverVar // variables created by coverage analysis\n \tOmitDebug         bool                 // tell linker not to write debug information\n@@ -494,7 +498,7 @@ type importError struct {\n \terr        error // created with fmt.Errorf\n }\n \n-func ImportErrorf(path, format string, args ...interface{}) ImportPathError {\n+func ImportErrorf(path, format string, args ...any) ImportPathError {\n \terr := &importError{importPath: path, err: fmt.Errorf(format, args...)}\n \tif errStr := err.Error(); !strings.Contains(errStr, path) {\n \t\tpanic(fmt.Sprintf(\"path %q not in error %q\", path, errStr))\n@@ -585,10 +589,10 @@ func ClearPackageCachePartial(args []string) {\n \t\t\tdelete(packageCache, arg)\n \t\t}\n \t}\n-\tresolvedImportCache.DeleteIf(func(key interface{}) bool {\n+\tresolvedImportCache.DeleteIf(func(key any) bool {\n \t\treturn shouldDelete[key.(importSpec).path]\n \t})\n-\tpackageDataCache.DeleteIf(func(key interface{}) bool {\n+\tpackageDataCache.DeleteIf(func(key any) bool {\n \t\treturn shouldDelete[key.(string)]\n \t})\n }\n@@ -601,7 +605,7 @@ func ReloadPackageNoFlags(arg string, stk *ImportStack) *Package {\n \tp := packageCache[arg]\n \tif p != nil {\n \t\tdelete(packageCache, arg)\n-\t\tresolvedImportCache.DeleteIf(func(key interface{}) bool {\n+\t\tresolvedImportCache.DeleteIf(func(key any) bool {\n \t\t\treturn key.(importSpec).path == p.ImportPath\n \t\t})\n \t\tpackageDataCache.Delete(p.ImportPath)\n@@ -813,7 +817,7 @@ func loadPackageData(ctx context.Context, path, parentPath, parentDir, parentRoo\n \t\tparentIsStd: parentIsStd,\n \t\tmode:        mode,\n \t}\n-\tr := resolvedImportCache.Do(importKey, func() interface{} {\n+\tr := resolvedImportCache.Do(importKey, func() any {\n \t\tvar r resolvedImport\n \t\tif build.IsLocalImport(path) {\n \t\t\tr.dir = filepath.Join(parentDir, path)\n@@ -840,7 +844,7 @@ func loadPackageData(ctx context.Context, path, parentPath, parentDir, parentRoo\n \n \t// Load the package from its directory. If we already found the package's\n \t// directory when resolving its import path, use that.\n-\tdata := packageDataCache.Do(r.path, func() interface{} {\n+\tdata := packageDataCache.Do(r.path, func() any {\n \t\tloaded = true\n \t\tvar data packageData\n \t\tif r.dir != \"\" {\n@@ -1059,7 +1063,7 @@ func cleanImport(path string) string {\n var isDirCache par.Cache\n \n func isDir(path string) bool {\n-\treturn isDirCache.Do(path, func() interface{} {\n+\treturn isDirCache.Do(path, func() any {\n \t\tfi, err := fsys.Stat(path)\n \t\treturn err == nil && fi.IsDir()\n \t}).(bool)\n@@ -1187,7 +1191,7 @@ var (\n \n // goModPath returns the module path in the go.mod in dir, if any.\n func goModPath(dir string) (path string) {\n-\treturn goModPathCache.Do(dir, func() interface{} {\n+\treturn goModPathCache.Do(dir, func() any {\n \t\tdata, err := os.ReadFile(filepath.Join(dir, \"go.mod\"))\n \t\tif err != nil {\n \t\t\treturn \"\"\n@@ -1456,9 +1460,9 @@ func disallowInternal(ctx context.Context, srcDir string, importer *Package, imp\n \t\t\t// The importer is a list of command-line files.\n \t\t\t// Pretend that the import path is the import path of the\n \t\t\t// directory containing them.\n-\t\t\t// If the directory is outside the main module, this will resolve to \".\",\n+\t\t\t// If the directory is outside the main modules, this will resolve to \".\",\n \t\t\t// which is not a prefix of any valid module.\n-\t\t\timporterPath = modload.DirImportPath(ctx, importer.Dir)\n+\t\t\timporterPath, _ = modload.MainModules.DirImportPath(ctx, importer.Dir)\n \t\t}\n \t\tparentOfInternal := p.ImportPath[:i]\n \t\tif str.HasPathPrefix(importerPath, parentOfInternal) {\n@@ -1628,6 +1632,7 @@ var cgoSyscallExclude = map[string]bool{\n \t\"runtime/cgo\":  true,\n \t\"runtime/race\": true,\n \t\"runtime/msan\": true,\n+\t\"runtime/asan\": true,\n }\n \n var foldPath = make(map[string]string)\n@@ -1683,9 +1688,10 @@ func (p *Package) DefaultExecName() string {\n func (p *Package) load(ctx context.Context, opts PackageOpts, path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error) {\n \tp.copyBuild(opts, bp)\n \n-\t// The localPrefix is the path we interpret ./ imports relative to.\n+\t// The localPrefix is the path we interpret ./ imports relative to,\n+\t// if we support them at all (not in module mode!).\n \t// Synthesized main packages sometimes override this.\n-\tif p.Internal.Local {\n+\tif p.Internal.Local && !cfg.ModulesEnabled {\n \t\tp.Internal.LocalPrefix = dirToImportPath(p.Dir)\n \t}\n \n@@ -1925,9 +1931,8 @@ func (p *Package) load(ctx context.Context, opts PackageOpts, path string, stk *\n \t}\n \tp.Internal.Imports = imports\n \tp.collectDeps()\n-\n-\tif cfg.ModulesEnabled && p.Error == nil && p.Name == \"main\" && len(p.DepsErrors) == 0 {\n-\t\tp.Internal.BuildInfo = modload.PackageBuildInfo(pkgPath, p.Deps)\n+\tif p.Error == nil && p.Name == \"main\" && len(p.DepsErrors) == 0 {\n+\t\tp.setBuildInfo()\n \t}\n \n \t// unsafe is a fake package.\n@@ -2018,13 +2023,18 @@ func resolveEmbed(pkgdir string, patterns []string) (files []string, pmap map[st\n \tfor _, pattern = range patterns {\n \t\tpid++\n \n+\t\tglob := pattern\n+\t\tall := strings.HasPrefix(pattern, \"all:\")\n+\t\tif all {\n+\t\t\tglob = pattern[len(\"all:\"):]\n+\t\t}\n \t\t// Check pattern is valid for //go:embed.\n-\t\tif _, err := path.Match(pattern, \"\"); err != nil || !validEmbedPattern(pattern) {\n+\t\tif _, err := path.Match(glob, \"\"); err != nil || !validEmbedPattern(glob) {\n \t\t\treturn nil, nil, fmt.Errorf(\"invalid pattern syntax\")\n \t\t}\n \n \t\t// Glob to find matches.\n-\t\tmatch, err := fsys.Glob(pkgdir + string(filepath.Separator) + filepath.FromSlash(pattern))\n+\t\tmatch, err := fsys.Glob(pkgdir + string(filepath.Separator) + filepath.FromSlash(glob))\n \t\tif err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n@@ -2087,7 +2097,7 @@ func resolveEmbed(pkgdir string, patterns []string) (files []string, pmap map[st\n \t\t\t\t\t}\n \t\t\t\t\trel := filepath.ToSlash(path[len(pkgdir)+1:])\n \t\t\t\t\tname := info.Name()\n-\t\t\t\t\tif path != file && (isBadEmbedName(name) || name[0] == '.' || name[0] == '_') {\n+\t\t\t\t\tif path != file && (isBadEmbedName(name) || ((name[0] == '.' || name[0] == '_') && !all)) {\n \t\t\t\t\t\t// Ignore bad names, assuming they won't go into modules.\n \t\t\t\t\t\t// Also avoid hidden files that user may not know about.\n \t\t\t\t\t\t// See golang.org/issue/42328.\n@@ -2199,6 +2209,229 @@ func (p *Package) collectDeps() {\n \t}\n }\n \n+// vcsStatusCache maps repository directories (string)\n+// to their VCS information (vcsStatusError).\n+var vcsStatusCache par.Cache\n+\n+// setBuildInfo gathers build information, formats it as a string to be\n+// embedded in the binary, then sets p.Internal.BuildInfo to that string.\n+// setBuildInfo should only be called on a main package with no errors.\n+//\n+// This information can be retrieved using debug.ReadBuildInfo.\n+//\n+// Note that the GoVersion field is not set here to avoid encoding it twice.\n+// It is stored separately in the binary, mostly for historical reasons.\n+func (p *Package) setBuildInfo() {\n+\t// TODO: build and vcs information is not embedded for executables in GOROOT.\n+\t// cmd/dist uses -gcflags=all= -ldflags=all= by default, which means these\n+\t// executables always appear stale unless the user sets the same flags.\n+\t// Perhaps it's safe to omit those flags when GO_GCFLAGS and GO_LDFLAGS\n+\t// are not set?\n+\tsetPkgErrorf := func(format string, args ...any) {\n+\t\tif p.Error == nil {\n+\t\t\tp.Error = &PackageError{Err: fmt.Errorf(format, args...)}\n+\t\t}\n+\t}\n+\n+\tvar debugModFromModinfo func(*modinfo.ModulePublic) *debug.Module\n+\tdebugModFromModinfo = func(mi *modinfo.ModulePublic) *debug.Module {\n+\t\tdm := &debug.Module{\n+\t\t\tPath:    mi.Path,\n+\t\t\tVersion: mi.Version,\n+\t\t}\n+\t\tif mi.Replace != nil {\n+\t\t\tdm.Replace = debugModFromModinfo(mi.Replace)\n+\t\t} else {\n+\t\t\tdm.Sum = modfetch.Sum(module.Version{Path: mi.Path, Version: mi.Version})\n+\t\t}\n+\t\treturn dm\n+\t}\n+\n+\tvar main debug.Module\n+\tif p.Module != nil {\n+\t\tmain = *debugModFromModinfo(p.Module)\n+\t}\n+\n+\tvisited := make(map[*Package]bool)\n+\tmdeps := make(map[module.Version]*debug.Module)\n+\tvar q []*Package\n+\tq = append(q, p.Internal.Imports...)\n+\tfor len(q) > 0 {\n+\t\tp1 := q[0]\n+\t\tq = q[1:]\n+\t\tif visited[p1] {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvisited[p1] = true\n+\t\tif p1.Module != nil {\n+\t\t\tm := module.Version{Path: p1.Module.Path, Version: p1.Module.Version}\n+\t\t\tif p1.Module.Path != main.Path && mdeps[m] == nil {\n+\t\t\t\tmdeps[m] = debugModFromModinfo(p1.Module)\n+\t\t\t}\n+\t\t}\n+\t\tq = append(q, p1.Internal.Imports...)\n+\t}\n+\tsortedMods := make([]module.Version, 0, len(mdeps))\n+\tfor mod := range mdeps {\n+\t\tsortedMods = append(sortedMods, mod)\n+\t}\n+\tmodule.Sort(sortedMods)\n+\tdeps := make([]*debug.Module, len(sortedMods))\n+\tfor i, mod := range sortedMods {\n+\t\tdeps[i] = mdeps[mod]\n+\t}\n+\n+\tpkgPath := p.ImportPath\n+\tif p.Internal.CmdlineFiles {\n+\t\tpkgPath = \"command-line-arguments\"\n+\t}\n+\tinfo := &debug.BuildInfo{\n+\t\tPath: pkgPath,\n+\t\tMain: main,\n+\t\tDeps: deps,\n+\t}\n+\tappendSetting := func(key, value string) {\n+\t\tvalue = strings.ReplaceAll(value, \"\\n\", \" \") // make value safe\n+\t\tinfo.Settings = append(info.Settings, debug.BuildSetting{Key: key, Value: value})\n+\t}\n+\n+\t// Add command-line flags relevant to the build.\n+\t// This is informational, not an exhaustive list.\n+\t// Please keep the list sorted.\n+\tif !p.Standard {\n+\t\tif cfg.BuildASan {\n+\t\t\tappendSetting(\"-asan\", \"true\")\n+\t\t}\n+\t\tif BuildAsmflags.present {\n+\t\t\tappendSetting(\"-asmflags\", BuildAsmflags.String())\n+\t\t}\n+\t\tappendSetting(\"-compiler\", cfg.BuildContext.Compiler)\n+\t\tif BuildGccgoflags.present && cfg.BuildContext.Compiler == \"gccgo\" {\n+\t\t\tappendSetting(\"-gccgoflags\", BuildGccgoflags.String())\n+\t\t}\n+\t\tif BuildGcflags.present && cfg.BuildContext.Compiler == \"gc\" {\n+\t\t\tappendSetting(\"-gcflags\", BuildGcflags.String())\n+\t\t}\n+\t\tif BuildLdflags.present {\n+\t\t\tappendSetting(\"-ldflags\", BuildLdflags.String())\n+\t\t}\n+\t\tif cfg.BuildMSan {\n+\t\t\tappendSetting(\"-msan\", \"true\")\n+\t\t}\n+\t\tif cfg.BuildRace {\n+\t\t\tappendSetting(\"-race\", \"true\")\n+\t\t}\n+\t\tif tags := cfg.BuildContext.BuildTags; len(tags) > 0 {\n+\t\t\tappendSetting(\"-tags\", strings.Join(tags, \",\"))\n+\t\t}\n+\t\tcgo := \"0\"\n+\t\tif cfg.BuildContext.CgoEnabled {\n+\t\t\tcgo = \"1\"\n+\t\t}\n+\t\tappendSetting(\"CGO_ENABLED\", cgo)\n+\t\tif cfg.BuildContext.CgoEnabled {\n+\t\t\tfor _, name := range []string{\"CGO_CFLAGS\", \"CGO_CPPFLAGS\", \"CGO_CXXFLAGS\", \"CGO_LDFLAGS\"} {\n+\t\t\t\tappendSetting(name, cfg.Getenv(name))\n+\t\t\t}\n+\t\t}\n+\t\tappendSetting(\"GOARCH\", cfg.BuildContext.GOARCH)\n+\t\tif cfg.GOEXPERIMENT != \"\" {\n+\t\t\tappendSetting(\"GOEXPERIMENT\", cfg.GOEXPERIMENT)\n+\t\t}\n+\t\tappendSetting(\"GOOS\", cfg.BuildContext.GOOS)\n+\t\tif key, val := cfg.GetArchEnv(); key != \"\" && val != \"\" {\n+\t\t\tappendSetting(key, val)\n+\t\t}\n+\t}\n+\n+\t// Add VCS status if all conditions are true:\n+\t//\n+\t// - -buildvcs is enabled.\n+\t// - p is contained within a main module (there may be multiple main modules\n+\t//   in a workspace, but local replacements don't count).\n+\t// - Both the current directory and p's module's root directory are contained\n+\t//   in the same local repository.\n+\t// - We know the VCS commands needed to get the status.\n+\tsetVCSError := func(err error) {\n+\t\tsetPkgErrorf(\"error obtaining VCS status: %v\\n\\tUse -buildvcs=false to disable VCS stamping.\", err)\n+\t}\n+\n+\tvar repoDir string\n+\tvar vcsCmd *vcs.Cmd\n+\tvar err error\n+\tconst allowNesting = true\n+\tif cfg.BuildBuildvcs && p.Module != nil && p.Module.Version == \"\" && !p.Standard {\n+\t\trepoDir, vcsCmd, err = vcs.FromDir(base.Cwd(), \"\", allowNesting)\n+\t\tif err != nil && !errors.Is(err, os.ErrNotExist) {\n+\t\t\tsetVCSError(err)\n+\t\t\treturn\n+\t\t}\n+\t\tif !str.HasFilePathPrefix(p.Module.Dir, repoDir) &&\n+\t\t\t!str.HasFilePathPrefix(repoDir, p.Module.Dir) {\n+\t\t\t// The module containing the main package does not overlap with the\n+\t\t\t// repository containing the working directory. Don't include VCS info.\n+\t\t\t// If the repo contains the module or vice versa, but they are not\n+\t\t\t// the same directory, it's likely an error (see below).\n+\t\t\trepoDir, vcsCmd = \"\", nil\n+\t\t}\n+\t}\n+\tif repoDir != \"\" && vcsCmd.Status != nil {\n+\t\t// Check that the current directory, package, and module are in the same\n+\t\t// repository. vcs.FromDir allows nested Git repositories, but nesting\n+\t\t// is not allowed for other VCS tools. The current directory may be outside\n+\t\t// p.Module.Dir when a workspace is used.\n+\t\tpkgRepoDir, _, err := vcs.FromDir(p.Dir, \"\", allowNesting)\n+\t\tif err != nil {\n+\t\t\tsetVCSError(err)\n+\t\t\treturn\n+\t\t}\n+\t\tif pkgRepoDir != repoDir {\n+\t\t\tsetVCSError(fmt.Errorf(\"main package is in repository %q but current directory is in repository %q\", pkgRepoDir, repoDir))\n+\t\t\treturn\n+\t\t}\n+\t\tmodRepoDir, _, err := vcs.FromDir(p.Module.Dir, \"\", allowNesting)\n+\t\tif err != nil {\n+\t\t\tsetVCSError(err)\n+\t\t\treturn\n+\t\t}\n+\t\tif modRepoDir != repoDir {\n+\t\t\tsetVCSError(fmt.Errorf(\"main module is in repository %q but current directory is in repository %q\", modRepoDir, repoDir))\n+\t\t\treturn\n+\t\t}\n+\n+\t\ttype vcsStatusError struct {\n+\t\t\tStatus vcs.Status\n+\t\t\tErr    error\n+\t\t}\n+\t\tcached := vcsStatusCache.Do(repoDir, func() any {\n+\t\t\tst, err := vcsCmd.Status(vcsCmd, repoDir)\n+\t\t\treturn vcsStatusError{st, err}\n+\t\t}).(vcsStatusError)\n+\t\tif err := cached.Err; err != nil {\n+\t\t\tsetVCSError(err)\n+\t\t\treturn\n+\t\t}\n+\t\tst := cached.Status\n+\n+\t\tappendSetting(\"vcs\", vcsCmd.Cmd)\n+\t\tif st.Revision != \"\" {\n+\t\t\tappendSetting(\"vcs.revision\", st.Revision)\n+\t\t}\n+\t\tif !st.CommitTime.IsZero() {\n+\t\t\tstamp := st.CommitTime.UTC().Format(time.RFC3339Nano)\n+\t\t\tappendSetting(\"vcs.time\", stamp)\n+\t\t}\n+\t\tappendSetting(\"vcs.modified\", strconv.FormatBool(st.Uncommitted))\n+\t}\n+\n+\ttext, err := info.MarshalText()\n+\tif err != nil {\n+\t\tsetPkgErrorf(\"error formatting build info: %v\", err)\n+\t\treturn\n+\t}\n+\tp.Internal.BuildInfo = string(text)\n+}\n+\n // SafeArg reports whether arg is a \"safe\" command-line argument,\n // meaning that when it appears in a command-line, it probably\n // doesn't have some special meaning other than its own name.\n@@ -2237,6 +2470,10 @@ func LinkerDeps(p *Package) []string {\n \tif cfg.BuildMSan {\n \t\tdeps = append(deps, \"runtime/msan\")\n \t}\n+\t// Using address sanitizer forces an import of runtime/asan.\n+\tif cfg.BuildASan {\n+\t\tdeps = append(deps, \"runtime/asan\")\n+\t}\n \n \treturn deps\n }\n@@ -2453,7 +2690,8 @@ func PackagesAndErrors(ctx context.Context, opts PackageOpts, patterns []string)\n \t\t}\n \t\tmatches, _ = modload.LoadPackages(ctx, modOpts, patterns...)\n \t} else {\n-\t\tmatches = search.ImportPaths(patterns)\n+\t\tnoModRoots := []string{}\n+\t\tmatches = search.ImportPaths(patterns, noModRoots)\n \t}\n \n \tvar (\n@@ -2679,10 +2917,7 @@ func GoFilesPackage(ctx context.Context, opts PackageOpts, gofiles []string) *Pa\n \t\tif fi.IsDir() {\n \t\t\tbase.Fatalf(\"%s is a directory, should be a Go file\", file)\n \t\t}\n-\t\tdir1, _ := filepath.Split(file)\n-\t\tif dir1 == \"\" {\n-\t\t\tdir1 = \"./\"\n-\t\t}\n+\t\tdir1 := filepath.Dir(file)\n \t\tif dir == \"\" {\n \t\t\tdir = dir1\n \t\t} else if dir != dir1 {\n@@ -2710,7 +2945,9 @@ func GoFilesPackage(ctx context.Context, opts PackageOpts, gofiles []string) *Pa\n \tpkg.Internal.Local = true\n \tpkg.Internal.CmdlineFiles = true\n \tpkg.load(ctx, opts, \"command-line-arguments\", &stk, nil, bp, err)\n-\tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n+\tif !cfg.ModulesEnabled {\n+\t\tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n+\t}\n \tpkg.ImportPath = \"command-line-arguments\"\n \tpkg.Target = \"\"\n \tpkg.Match = gofiles"}, {"sha": "6122428c9cf0a2f066535fa025153ab0185da82e", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -555,6 +555,7 @@ func formatTestmain(t *testFuncs) ([]byte, error) {\n type testFuncs struct {\n \tTests       []testFunc\n \tBenchmarks  []testFunc\n+\tFuzzTargets []testFunc\n \tExamples    []testFunc\n \tTestMain    *testFunc\n \tPackage     *Package\n@@ -653,6 +654,13 @@ func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n \t\t\t}\n \t\t\tt.Benchmarks = append(t.Benchmarks, testFunc{pkg, name, \"\", false})\n \t\t\t*doImport, *seen = true, true\n+\t\tcase isTest(name, \"Fuzz\"):\n+\t\t\terr := checkTestFunc(n, \"F\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tt.FuzzTargets = append(t.FuzzTargets, testFunc{pkg, name, \"\", false})\n+\t\t\t*doImport, *seen = true, true\n \t\t}\n \t}\n \tex := doc.Examples(f)\n@@ -670,10 +678,16 @@ func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n }\n \n func checkTestFunc(fn *ast.FuncDecl, arg string) error {\n+\tvar why string\n \tif !isTestFunc(fn, arg) {\n-\t\tname := fn.Name.String()\n+\t\twhy = fmt.Sprintf(\"must be: func %s(%s *testing.%s)\", fn.Name.String(), strings.ToLower(arg), arg)\n+\t}\n+\tif fn.Type.TypeParams.NumFields() > 0 {\n+\t\twhy = \"test functions cannot have type parameters\"\n+\t}\n+\tif why != \"\" {\n \t\tpos := testFileSet.Position(fn.Pos())\n-\t\treturn fmt.Errorf(\"%s: wrong signature for %s, must be: func %s(%s *testing.%s)\", pos, name, name, strings.ToLower(arg), arg)\n+\t\treturn fmt.Errorf(\"%s: wrong signature for %s, %s\", pos, fn.Name.String(), why)\n \t}\n \treturn nil\n }\n@@ -716,6 +730,12 @@ var benchmarks = []testing.InternalBenchmark{\n {{end}}\n }\n \n+var fuzzTargets = []testing.InternalFuzzTarget{\n+{{range .FuzzTargets}}\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}},\n+{{end}}\n+}\n+\n var examples = []testing.InternalExample{\n {{range .Examples}}\n \t{\"{{.Name}}\", {{.Package}}.{{.Name}}, {{.Output | printf \"%q\"}}, {{.Unordered}}},\n@@ -774,7 +794,7 @@ func main() {\n \t\tCoveredPackages: {{printf \"%q\" .Covered}},\n \t})\n {{end}}\n-\tm := testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, examples)\n+\tm := testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, fuzzTargets, examples)\n {{with .TestMain}}\n \t{{.Package}}.{{.Name}}(m)\n \tos.Exit(int(reflect.ValueOf(m).Elem().FieldByName(\"exitCode\").Int()))"}, {"sha": "31ab5ea40020f42f3bb679471f0390c421ac7eba", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_fcntl.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build aix || (solaris && !illumos)\n-// +build aix solaris,!illumos\n \n // This code implements the filelock API using POSIX 'fcntl' locks, which attach\n // to an (inode, process) pair rather than a file descriptor. To avoid unlocking"}, {"sha": "4aef110bb1aa90c04c67ac11028b69d1fa72f953", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_other.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !aix && !darwin && !dragonfly && !freebsd && !hurd && !linux && !netbsd && !openbsd && !plan9 && !solaris && !windows\n-// +build !aix,!darwin,!dragonfly,!freebsd,!hurd,!linux,!netbsd,!openbsd,!plan9,!solaris,!windows\n \n package filelock\n "}, {"sha": "54b2c946e0d6b2272e5758ac638e0bef49aa3e8e", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_plan9.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build plan9\n-// +build plan9\n \n package filelock\n "}, {"sha": "7bd7bd28f55ab7830fe9bb0e86327272877de5d5", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !js && !plan9\n-// +build !js,!plan9\n \n package filelock_test\n "}, {"sha": "61427c7c03185580b9a98d327fc45c3f7f2610f4", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_unix.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build darwin || dragonfly || freebsd || hurd || illumos || linux || netbsd || openbsd\n-// +build darwin dragonfly freebsd hurd illumos linux netbsd openbsd\n \n package filelock\n "}, {"sha": "e2ca5383046bbe13bd3dd5bb7d3c43bcab190d22", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_windows.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build windows\n-// +build windows\n \n package filelock\n "}, {"sha": "1a677a7fe4a60d3a98866a846bbd6e39b057cbe9", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_filelock.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !plan9\n-// +build !plan9\n \n package lockedfile\n "}, {"sha": "35669388e0531318a8d3cdb65f2c992bccbe9e7d", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_plan9.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build plan9\n-// +build plan9\n \n package lockedfile\n "}, {"sha": "c9907db46cecb36e043a1ff8105ac386bcec9e95", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -4,7 +4,6 @@\n \n // js does not support inter-process file locking.\n //go:build !js\n-// +build !js\n \n package lockedfile_test\n "}, {"sha": "3c1caa334eb4df6bbaec7f1dae4228286df11067", "filename": "libgo/go/cmd/go/internal/lockedfile/transform_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -4,7 +4,6 @@\n \n // js does not support inter-process file locking.\n //go:build !js\n-// +build !js\n \n package lockedfile_test\n "}, {"sha": "6b8a010fd9d71ca248b91a2ccd7375e3305f432a", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 78, "deletions": 27, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -16,6 +16,7 @@ import (\n \t\"cmd/go/internal/modload\"\n \n \t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var cmdDownload = &base.Command{\n@@ -24,8 +25,11 @@ var cmdDownload = &base.Command{\n \tLong: `\n Download downloads the named modules, which can be module patterns selecting\n dependencies of the main module or module queries of the form path@version.\n-With no arguments, download applies to all dependencies of the main module\n-(equivalent to 'go mod download all').\n+\n+With no arguments, download applies to the modules needed to build and test\n+the packages in the main module: the modules explicitly required by the main\n+module if it is at 'go 1.17' or higher, or all transitively-required modules\n+if at 'go 1.16' or lower.\n \n The go command will automatically download modules as needed during ordinary\n execution. The \"go mod download\" command is useful mainly for pre-filling\n@@ -66,6 +70,7 @@ func init() {\n \t// TODO(jayconrod): https://golang.org/issue/35849 Apply -x to other 'go mod' commands.\n \tcmdDownload.Flag.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n \tbase.AddModCommonFlags(&cmdDownload.Flag)\n+\tbase.AddWorkfileFlag(&cmdDownload.Flag)\n }\n \n type moduleJSON struct {\n@@ -81,27 +86,68 @@ type moduleJSON struct {\n }\n \n func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n \t// Check whether modules are enabled and whether we're in a module.\n \tmodload.ForceUseModules = true\n-\tif !modload.HasModRoot() && len(args) == 0 {\n-\t\tbase.Fatalf(\"go mod download: no modules specified (see 'go help mod download')\")\n-\t}\n+\tmodload.ExplicitWriteGoMod = true\n \thaveExplicitArgs := len(args) > 0\n-\tif !haveExplicitArgs {\n-\t\targs = []string{\"all\"}\n-\t}\n-\tif modload.HasModRoot() {\n-\t\tmodload.LoadModFile(ctx) // to fill Target\n-\t\ttargetAtUpgrade := modload.Target.Path + \"@upgrade\"\n-\t\ttargetAtPatch := modload.Target.Path + \"@patch\"\n-\t\tfor _, arg := range args {\n-\t\t\tswitch arg {\n-\t\t\tcase modload.Target.Path, targetAtUpgrade, targetAtPatch:\n-\t\t\t\tos.Stderr.WriteString(\"go mod download: skipping argument \" + arg + \" that resolves to the main module\\n\")\n+\n+\tif modload.HasModRoot() || modload.WorkFilePath() != \"\" {\n+\t\tmodload.LoadModFile(ctx) // to fill MainModules\n+\n+\t\tif haveExplicitArgs {\n+\t\t\tfor _, mainModule := range modload.MainModules.Versions() {\n+\t\t\t\ttargetAtUpgrade := mainModule.Path + \"@upgrade\"\n+\t\t\t\ttargetAtPatch := mainModule.Path + \"@patch\"\n+\t\t\t\tfor _, arg := range args {\n+\t\t\t\t\tswitch arg {\n+\t\t\t\t\tcase mainModule.Path, targetAtUpgrade, targetAtPatch:\n+\t\t\t\t\t\tos.Stderr.WriteString(\"go: skipping download of \" + arg + \" that resolves to the main module\\n\")\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if modload.WorkFilePath() != \"\" {\n+\t\t\t// TODO(#44435): Think about what the correct query is to download the\n+\t\t\t// right set of modules. Also see code review comment at\n+\t\t\t// https://go-review.googlesource.com/c/go/+/359794/comments/ce946a80_6cf53992.\n+\t\t\targs = []string{\"all\"}\n+\t\t} else {\n+\t\t\tmainModule := modload.MainModules.Versions()[0]\n+\t\t\tmodFile := modload.MainModules.ModFile(mainModule)\n+\t\t\tif modFile.Go == nil || semver.Compare(\"v\"+modFile.Go.Version, modload.ExplicitIndirectVersionV) < 0 {\n+\t\t\t\tif len(modFile.Require) > 0 {\n+\t\t\t\t\targs = []string{\"all\"}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// As of Go 1.17, the go.mod file explicitly requires every module\n+\t\t\t\t// that provides any package imported by the main module.\n+\t\t\t\t// 'go mod download' is typically run before testing packages in the\n+\t\t\t\t// main module, so by default we shouldn't download the others\n+\t\t\t\t// (which are presumed irrelevant to the packages in the main module).\n+\t\t\t\t// See https://golang.org/issue/44435.\n+\t\t\t\t//\n+\t\t\t\t// However, we also need to load the full module graph, to ensure that\n+\t\t\t\t// we have downloaded enough of the module graph to run 'go list all',\n+\t\t\t\t// 'go mod graph', and similar commands.\n+\t\t\t\t_ = modload.LoadModGraph(ctx, \"\")\n+\n+\t\t\t\tfor _, m := range modFile.Require {\n+\t\t\t\t\targs = append(args, m.Mod.Path)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n+\tif len(args) == 0 {\n+\t\tif modload.HasModRoot() {\n+\t\t\tos.Stderr.WriteString(\"go: no module dependencies to download\\n\")\n+\t\t} else {\n+\t\t\tbase.Errorf(\"go: no modules specified (see 'go help mod download')\")\n+\t\t}\n+\t\tbase.Exit()\n+\t}\n+\n \tdownloadModule := func(m *moduleJSON) {\n \t\tvar err error\n \t\tm.Info, err = modfetch.InfoFile(m.Path, m.Version)\n@@ -140,13 +186,16 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \tif !haveExplicitArgs {\n \t\t// 'go mod download' is sometimes run without arguments to pre-populate the\n \t\t// module cache. It may fetch modules that aren't needed to build packages\n-\t\t// in the main mdoule. This is usually not intended, so don't save sums for\n-\t\t// downloaded modules (golang.org/issue/45332).\n-\t\t// TODO(golang.org/issue/45551): For now, in ListModules, save sums needed\n-\t\t// to load the build list (same as 1.15 behavior). In the future, report an\n-\t\t// error if go.mod or go.sum need to be updated after loading the build\n-\t\t// list.\n-\t\tmodload.DisallowWriteGoMod()\n+\t\t// in the main module. This is usually not intended, so don't save sums for\n+\t\t// downloaded modules (golang.org/issue/45332). We do still fix\n+\t\t// inconsistencies in go.mod though.\n+\t\t//\n+\t\t// TODO(#45551): In the future, report an error if go.mod or go.sum need to\n+\t\t// be updated after loading the build list. This may require setting\n+\t\t// the mode to \"mod\" or \"readonly\" depending on haveExplicitArgs.\n+\t\tif err := modload.WriteGoMod(ctx); err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t}\n \t}\n \n \tfor _, info := range infos {\n@@ -183,7 +232,7 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \t\tfor _, m := range mods {\n \t\t\tb, err := json.MarshalIndent(m, \"\", \"\\t\")\n \t\t\tif err != nil {\n-\t\t\t\tbase.Fatalf(\"go mod download: %v\", err)\n+\t\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t\t}\n \t\t\tos.Stdout.Write(append(b, '\\n'))\n \t\t\tif m.Error != \"\" {\n@@ -193,7 +242,7 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \t} else {\n \t\tfor _, m := range mods {\n \t\t\tif m.Error != \"\" {\n-\t\t\t\tbase.Errorf(\"go mod download: %v\", m.Error)\n+\t\t\t\tbase.Errorf(\"go: %v\", m.Error)\n \t\t\t}\n \t\t}\n \t\tbase.ExitIfErrors()\n@@ -206,13 +255,15 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \t//\n \t// Don't save sums for 'go mod download' without arguments; see comment above.\n \tif haveExplicitArgs {\n-\t\tmodload.WriteGoMod(ctx)\n+\t\tif err := modload.WriteGoMod(ctx); err != nil {\n+\t\t\tbase.Errorf(\"go: %v\", err)\n+\t\t}\n \t}\n \n \t// If there was an error matching some of the requested packages, emit it now\n \t// (after we've written the checksums for the modules that were downloaded\n \t// successfully).\n \tif infosErr != nil {\n-\t\tbase.Errorf(\"go mod download: %v\", infosErr)\n+\t\tbase.Errorf(\"go: %v\", infosErr)\n \t}\n }"}, {"sha": "e5182a9590adc866532d0dfde80130808706faad", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -171,15 +171,15 @@ func runEdit(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tlen(edits) > 0\n \n \tif !anyFlags {\n-\t\tbase.Fatalf(\"go mod edit: no flags specified (see 'go help mod edit').\")\n+\t\tbase.Fatalf(\"go: no flags specified (see 'go help mod edit').\")\n \t}\n \n \tif *editJSON && *editPrint {\n-\t\tbase.Fatalf(\"go mod edit: cannot use both -json and -print\")\n+\t\tbase.Fatalf(\"go: cannot use both -json and -print\")\n \t}\n \n \tif len(args) > 1 {\n-\t\tbase.Fatalf(\"go mod edit: too many arguments\")\n+\t\tbase.Fatalf(\"go: too many arguments\")\n \t}\n \tvar gomod string\n \tif len(args) == 1 {\n@@ -190,7 +190,7 @@ func runEdit(ctx context.Context, cmd *base.Command, args []string) {\n \n \tif *editModule != \"\" {\n \t\tif err := module.CheckImportPath(*editModule); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: invalid -module: %v\", err)\n+\t\t\tbase.Fatalf(\"go: invalid -module: %v\", err)\n \t\t}\n \t}\n \n@@ -264,15 +264,15 @@ func runEdit(ctx context.Context, cmd *base.Command, args []string) {\n func parsePathVersion(flag, arg string) (path, version string) {\n \ti := strings.Index(arg, \"@\")\n \tif i < 0 {\n-\t\tbase.Fatalf(\"go mod: -%s=%s: need path@version\", flag, arg)\n+\t\tbase.Fatalf(\"go: -%s=%s: need path@version\", flag, arg)\n \t}\n \tpath, version = strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n \tif err := module.CheckImportPath(path); err != nil {\n-\t\tbase.Fatalf(\"go mod: -%s=%s: invalid path: %v\", flag, arg, err)\n+\t\tbase.Fatalf(\"go: -%s=%s: invalid path: %v\", flag, arg, err)\n \t}\n \n \tif !allowedVersionArg(version) {\n-\t\tbase.Fatalf(\"go mod: -%s=%s: invalid version %q\", flag, arg, version)\n+\t\tbase.Fatalf(\"go: -%s=%s: invalid version %q\", flag, arg, version)\n \t}\n \n \treturn path, version\n@@ -281,11 +281,11 @@ func parsePathVersion(flag, arg string) (path, version string) {\n // parsePath parses -flag=arg expecting arg to be path (not path@version).\n func parsePath(flag, arg string) (path string) {\n \tif strings.Contains(arg, \"@\") {\n-\t\tbase.Fatalf(\"go mod: -%s=%s: need just path, not path@version\", flag, arg)\n+\t\tbase.Fatalf(\"go: -%s=%s: need just path, not path@version\", flag, arg)\n \t}\n \tpath = arg\n \tif err := module.CheckImportPath(path); err != nil {\n-\t\tbase.Fatalf(\"go mod: -%s=%s: invalid path: %v\", flag, arg, err)\n+\t\tbase.Fatalf(\"go: -%s=%s: invalid path: %v\", flag, arg, err)\n \t}\n \treturn path\n }\n@@ -350,7 +350,7 @@ func flagRequire(arg string) {\n \tpath, version := parsePathVersion(\"require\", arg)\n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.AddRequire(path, version); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -require=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -require=%s: %v\", arg, err)\n \t\t}\n \t})\n }\n@@ -360,7 +360,7 @@ func flagDropRequire(arg string) {\n \tpath := parsePath(\"droprequire\", arg)\n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.DropRequire(path); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -droprequire=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -droprequire=%s: %v\", arg, err)\n \t\t}\n \t})\n }\n@@ -370,7 +370,7 @@ func flagExclude(arg string) {\n \tpath, version := parsePathVersion(\"exclude\", arg)\n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.AddExclude(path, version); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -exclude=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -exclude=%s: %v\", arg, err)\n \t\t}\n \t})\n }\n@@ -380,7 +380,7 @@ func flagDropExclude(arg string) {\n \tpath, version := parsePathVersion(\"dropexclude\", arg)\n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.DropExclude(path, version); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -dropexclude=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -dropexclude=%s: %v\", arg, err)\n \t\t}\n \t})\n }\n@@ -389,27 +389,27 @@ func flagDropExclude(arg string) {\n func flagReplace(arg string) {\n \tvar i int\n \tif i = strings.Index(arg, \"=\"); i < 0 {\n-\t\tbase.Fatalf(\"go mod: -replace=%s: need old[@v]=new[@w] (missing =)\", arg)\n+\t\tbase.Fatalf(\"go: -replace=%s: need old[@v]=new[@w] (missing =)\", arg)\n \t}\n \told, new := strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n \tif strings.HasPrefix(new, \">\") {\n-\t\tbase.Fatalf(\"go mod: -replace=%s: separator between old and new is =, not =>\", arg)\n+\t\tbase.Fatalf(\"go: -replace=%s: separator between old and new is =, not =>\", arg)\n \t}\n \toldPath, oldVersion, err := parsePathVersionOptional(\"old\", old, false)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go mod: -replace=%s: %v\", arg, err)\n+\t\tbase.Fatalf(\"go: -replace=%s: %v\", arg, err)\n \t}\n \tnewPath, newVersion, err := parsePathVersionOptional(\"new\", new, true)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go mod: -replace=%s: %v\", arg, err)\n+\t\tbase.Fatalf(\"go: -replace=%s: %v\", arg, err)\n \t}\n \tif newPath == new && !modfile.IsDirectoryPath(new) {\n-\t\tbase.Fatalf(\"go mod: -replace=%s: unversioned new path must be local directory\", arg)\n+\t\tbase.Fatalf(\"go: -replace=%s: unversioned new path must be local directory\", arg)\n \t}\n \n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.AddReplace(oldPath, oldVersion, newPath, newVersion); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -replace=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -replace=%s: %v\", arg, err)\n \t\t}\n \t})\n }\n@@ -418,11 +418,11 @@ func flagReplace(arg string) {\n func flagDropReplace(arg string) {\n \tpath, version, err := parsePathVersionOptional(\"old\", arg, true)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go mod: -dropreplace=%s: %v\", arg, err)\n+\t\tbase.Fatalf(\"go: -dropreplace=%s: %v\", arg, err)\n \t}\n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.DropReplace(path, version); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -dropreplace=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -dropreplace=%s: %v\", arg, err)\n \t\t}\n \t})\n }\n@@ -431,11 +431,11 @@ func flagDropReplace(arg string) {\n func flagRetract(arg string) {\n \tvi, err := parseVersionInterval(arg)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go mod: -retract=%s: %v\", arg, err)\n+\t\tbase.Fatalf(\"go: -retract=%s: %v\", arg, err)\n \t}\n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.AddRetract(vi, \"\"); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -retract=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -retract=%s: %v\", arg, err)\n \t\t}\n \t})\n }\n@@ -444,11 +444,11 @@ func flagRetract(arg string) {\n func flagDropRetract(arg string) {\n \tvi, err := parseVersionInterval(arg)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go mod: -dropretract=%s: %v\", arg, err)\n+\t\tbase.Fatalf(\"go: -dropretract=%s: %v\", arg, err)\n \t}\n \tedits = append(edits, func(f *modfile.File) {\n \t\tif err := f.DropRetract(vi); err != nil {\n-\t\t\tbase.Fatalf(\"go mod: -dropretract=%s: %v\", arg, err)\n+\t\t\tbase.Fatalf(\"go: -dropretract=%s: %v\", arg, err)\n \t\t}\n \t})\n }"}, {"sha": "9b6aa1fb14dddc5ade58f888a5bf01f2ba7ed140", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -42,11 +42,14 @@ var (\n func init() {\n \tcmdGraph.Flag.Var(&graphGo, \"go\", \"\")\n \tbase.AddModCommonFlags(&cmdGraph.Flag)\n+\tbase.AddWorkfileFlag(&cmdGraph.Flag)\n }\n \n func runGraph(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n \tif len(args) > 0 {\n-\t\tbase.Fatalf(\"go mod graph: graph takes no arguments\")\n+\t\tbase.Fatalf(\"go: 'go mod graph' accepts no arguments\")\n \t}\n \tmodload.ForceUseModules = true\n \tmodload.RootMode = modload.NeedRoot"}, {"sha": "bc4620a2a8d3f2121145ee64038ba0329fda599d", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -39,7 +39,7 @@ func init() {\n \n func runInit(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 1 {\n-\t\tbase.Fatalf(\"go mod init: too many arguments\")\n+\t\tbase.Fatalf(\"go: 'go mod init' accepts at most one argument\")\n \t}\n \tvar modPath string\n \tif len(args) == 1 {"}, {"sha": "d35476eb5393d3e92c6e61f384c99f5bf04463a7", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -75,8 +75,8 @@ type goVersionFlag struct {\n \tv string\n }\n \n-func (f *goVersionFlag) String() string   { return f.v }\n-func (f *goVersionFlag) Get() interface{} { return f.v }\n+func (f *goVersionFlag) String() string { return f.v }\n+func (f *goVersionFlag) Get() any       { return f.v }\n \n func (f *goVersionFlag) Set(s string) error {\n \tif s != \"\" {\n@@ -95,7 +95,7 @@ func (f *goVersionFlag) Set(s string) error {\n \n func runTidy(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n-\t\tbase.Fatalf(\"go mod tidy: no arguments allowed\")\n+\t\tbase.Fatalf(\"go: 'go mod tidy' accepts no arguments\")\n \t}\n \n \t// Tidy aims to make 'go test' reproducible for any package in 'all', so we"}, {"sha": "ef123700aa3ca5ae8600f5b09bd84c4f4bc09a6d", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -31,7 +31,7 @@ import (\n )\n \n var cmdVendor = &base.Command{\n-\tUsageLine: \"go mod vendor [-e] [-v]\",\n+\tUsageLine: \"go mod vendor [-e] [-v] [-o outdir]\",\n \tShort:     \"make vendored copy of dependencies\",\n \tLong: `\n Vendor resets the main module's vendor directory to include all packages\n@@ -44,22 +44,29 @@ modules and packages to standard error.\n The -e flag causes vendor to attempt to proceed despite errors\n encountered while loading packages.\n \n+The -o flag causes vendor to create the vendor directory at the given\n+path instead of \"vendor\". The go command can only use a vendor directory\n+named \"vendor\" within the module root directory, so this flag is\n+primarily useful for other tools.\n+\n See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'.\n \t`,\n \tRun: runVendor,\n }\n \n-var vendorE bool // if true, report errors but proceed anyway\n+var vendorE bool   // if true, report errors but proceed anyway\n+var vendorO string // if set, overrides the default output directory\n \n func init() {\n \tcmdVendor.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n \tcmdVendor.Flag.BoolVar(&vendorE, \"e\", false, \"\")\n+\tcmdVendor.Flag.StringVar(&vendorO, \"o\", \"\", \"\")\n \tbase.AddModCommonFlags(&cmdVendor.Flag)\n }\n \n func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) != 0 {\n-\t\tbase.Fatalf(\"go mod vendor: vendor takes no arguments\")\n+\t\tbase.Fatalf(\"go: 'go mod vendor' accepts no arguments\")\n \t}\n \tmodload.ForceUseModules = true\n \tmodload.RootMode = modload.NeedRoot\n@@ -74,15 +81,23 @@ func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \t_, pkgs := modload.LoadPackages(ctx, loadOpts, \"all\")\n \n-\tvdir := filepath.Join(modload.ModRoot(), \"vendor\")\n+\tvar vdir string\n+\tswitch {\n+\tcase filepath.IsAbs(vendorO):\n+\t\tvdir = vendorO\n+\tcase vendorO != \"\":\n+\t\tvdir = filepath.Join(base.Cwd(), vendorO)\n+\tdefault:\n+\t\tvdir = filepath.Join(modload.VendorDir())\n+\t}\n \tif err := os.RemoveAll(vdir); err != nil {\n-\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tmodpkgs := make(map[module.Version][]string)\n \tfor _, pkg := range pkgs {\n \t\tm := modload.PackageModule(pkg)\n-\t\tif m.Path == \"\" || m == modload.Target {\n+\t\tif m.Path == \"\" || m.Version == \"\" && modload.MainModules.Contains(m.Path) {\n \t\t\tcontinue\n \t\t}\n \t\tmodpkgs[m] = append(modpkgs[m], pkg)\n@@ -128,7 +143,8 @@ func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \n \tfor _, m := range vendorMods {\n-\t\tline := moduleLine(m, modload.Replacement(m))\n+\t\treplacement := modload.Replacement(m)\n+\t\tline := moduleLine(m, replacement)\n \t\tio.WriteString(w, line)\n \n \t\tgoVersion := \"\"\n@@ -177,11 +193,11 @@ func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \n \tif err := os.MkdirAll(vdir, 0777); err != nil {\n-\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tif err := os.WriteFile(filepath.Join(vdir, \"modules.txt\"), buf.Bytes(), 0666); err != nil {\n-\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n }\n \n@@ -242,14 +258,14 @@ func vendorPkg(vdir, pkg string) {\n \tif err != nil {\n \t\tif errors.As(err, &noGoError) {\n \t\t\treturn // No source files in this package are built. Skip embeds in ignored files.\n-\t\t} else if !errors.As(err, &multiplePackageError) { // multiplePackgeErrors are okay, but others are not.\n+\t\t} else if !errors.As(err, &multiplePackageError) { // multiplePackageErrors are OK, but others are not.\n \t\t\tbase.Fatalf(\"internal error: failed to find embedded files of %s: %v\\n\", pkg, err)\n \t\t}\n \t}\n \tembedPatterns := str.StringList(bp.EmbedPatterns, bp.TestEmbedPatterns, bp.XTestEmbedPatterns)\n \tembeds, err := load.ResolveEmbed(bp.Dir, embedPatterns)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \tfor _, embed := range embeds {\n \t\tembedDst := filepath.Join(dst, embed)\n@@ -260,21 +276,21 @@ func vendorPkg(vdir, pkg string) {\n \t\t// Copy the file as is done by copyDir below.\n \t\tr, err := os.Open(filepath.Join(src, embed))\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tif err := os.MkdirAll(filepath.Dir(embedDst), 0777); err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tw, err := os.Create(embedDst)\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tif _, err := io.Copy(w, r); err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tr.Close()\n \t\tif err := w.Close(); err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t}\n }\n@@ -353,7 +369,7 @@ func matchPotentialSourceFile(dir string, info fs.DirEntry) bool {\n \tif strings.HasSuffix(info.Name(), \".go\") {\n \t\tf, err := fsys.Open(filepath.Join(dir, info.Name()))\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tdefer f.Close()\n \n@@ -375,10 +391,10 @@ func matchPotentialSourceFile(dir string, info fs.DirEntry) bool {\n func copyDir(dst, src string, match func(dir string, info fs.DirEntry) bool, copiedFiles map[string]bool) {\n \tfiles, err := os.ReadDir(src)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \tif err := os.MkdirAll(dst, 0777); err != nil {\n-\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \tfor _, file := range files {\n \t\tif file.IsDir() || !file.Type().IsRegular() || !match(src, file) {\n@@ -387,20 +403,20 @@ func copyDir(dst, src string, match func(dir string, info fs.DirEntry) bool, cop\n \t\tcopiedFiles[file.Name()] = true\n \t\tr, err := os.Open(filepath.Join(src, file.Name()))\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tdstPath := filepath.Join(dst, file.Name())\n \t\tcopiedFiles[dstPath] = true\n \t\tw, err := os.Create(dstPath)\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tif _, err := io.Copy(w, r); err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tr.Close()\n \t\tif err := w.Close(); err != nil {\n-\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t}\n }"}, {"sha": "3f0c005d5d91482c87d764f155168ed3a579151c", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -39,12 +39,15 @@ See https://golang.org/ref/mod#go-mod-verify for more about 'go mod verify'.\n \n func init() {\n \tbase.AddModCommonFlags(&cmdVerify.Flag)\n+\tbase.AddWorkfileFlag(&cmdVerify.Flag)\n }\n \n func runVerify(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n \tif len(args) != 0 {\n \t\t// NOTE(rsc): Could take a module pattern.\n-\t\tbase.Fatalf(\"go mod verify: verify takes no arguments\")\n+\t\tbase.Fatalf(\"go: verify takes no arguments\")\n \t}\n \tmodload.ForceUseModules = true\n \tmodload.RootMode = modload.NeedRoot"}, {"sha": "d8355cca957a460788b1f7f146679c79bdfe169c", "filename": "libgo/go/cmd/go/internal/modcmd/why.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -12,8 +12,6 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modload\"\n-\n-\t\"golang.org/x/mod/module\"\n )\n \n var cmdWhy = &base.Command{\n@@ -61,11 +59,14 @@ var (\n func init() {\n \tcmdWhy.Run = runWhy // break init cycle\n \tbase.AddModCommonFlags(&cmdWhy.Flag)\n+\tbase.AddWorkfileFlag(&cmdWhy.Flag)\n }\n \n func runWhy(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n \tmodload.ForceUseModules = true\n \tmodload.RootMode = modload.NeedRoot\n+\tmodload.ExplicitWriteGoMod = true // don't write go.mod in ListModules\n \n \tloadOpts := modload.PackageOpts{\n \t\tTags:                     imports.AnyTags(),\n@@ -78,28 +79,28 @@ func runWhy(ctx context.Context, cmd *base.Command, args []string) {\n \tif *whyM {\n \t\tfor _, arg := range args {\n \t\t\tif strings.Contains(arg, \"@\") {\n-\t\t\t\tbase.Fatalf(\"go mod why: module query not allowed\")\n+\t\t\t\tbase.Fatalf(\"go: %s: 'go mod why' requires a module path, not a version query\", arg)\n \t\t\t}\n \t\t}\n \n \t\tmods, err := modload.ListModules(ctx, args, 0)\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go mod why: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \n-\t\tbyModule := make(map[module.Version][]string)\n+\t\tbyModule := make(map[string][]string)\n \t\t_, pkgs := modload.LoadPackages(ctx, loadOpts, \"all\")\n \t\tfor _, path := range pkgs {\n \t\t\tm := modload.PackageModule(path)\n \t\t\tif m.Path != \"\" {\n-\t\t\t\tbyModule[m] = append(byModule[m], path)\n+\t\t\t\tbyModule[m.Path] = append(byModule[m.Path], path)\n \t\t\t}\n \t\t}\n \t\tsep := \"\"\n \t\tfor _, m := range mods {\n \t\t\tbest := \"\"\n \t\t\tbestDepth := 1000000000\n-\t\t\tfor _, path := range byModule[module.Version{Path: m.Path, Version: m.Version}] {\n+\t\t\tfor _, path := range byModule[m.Path] {\n \t\t\t\td := modload.WhyDepth(path)\n \t\t\t\tif d > 0 && d < bestDepth {\n \t\t\t\t\tbest = path"}, {"sha": "e23669fb00c76b7bb5d6a1f20523051354f2f3f5", "filename": "libgo/go/cmd/go/internal/modfetch/bootstrap.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build cmd_go_bootstrap\n-// +build cmd_go_bootstrap\n \n package modfetch\n "}, {"sha": "b0dae1cb3d359c4da1dd0edd6a03fd63c0ffb814", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -204,7 +204,7 @@ func (r *cachingRepo) Versions(prefix string) ([]string, error) {\n \t\tlist []string\n \t\terr  error\n \t}\n-\tc := r.cache.Do(\"versions:\"+prefix, func() interface{} {\n+\tc := r.cache.Do(\"versions:\"+prefix, func() any {\n \t\tlist, err := r.repo().Versions(prefix)\n \t\treturn cached{list, err}\n \t}).(cached)\n@@ -221,7 +221,7 @@ type cachedInfo struct {\n }\n \n func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n-\tc := r.cache.Do(\"stat:\"+rev, func() interface{} {\n+\tc := r.cache.Do(\"stat:\"+rev, func() any {\n \t\tfile, info, err := readDiskStat(r.path, rev)\n \t\tif err == nil {\n \t\t\treturn cachedInfo{info, nil}\n@@ -233,7 +233,7 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \t\t\t// then save the information under the proper version, for future use.\n \t\t\tif info.Version != rev {\n \t\t\t\tfile, _ = CachePath(module.Version{Path: r.path, Version: info.Version}, \"info\")\n-\t\t\t\tr.cache.Do(\"stat:\"+info.Version, func() interface{} {\n+\t\t\t\tr.cache.Do(\"stat:\"+info.Version, func() any {\n \t\t\t\t\treturn cachedInfo{info, err}\n \t\t\t\t})\n \t\t\t}\n@@ -253,12 +253,12 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n }\n \n func (r *cachingRepo) Latest() (*RevInfo, error) {\n-\tc := r.cache.Do(\"latest:\", func() interface{} {\n+\tc := r.cache.Do(\"latest:\", func() any {\n \t\tinfo, err := r.repo().Latest()\n \n \t\t// Save info for likely future Stat call.\n \t\tif err == nil {\n-\t\t\tr.cache.Do(\"stat:\"+info.Version, func() interface{} {\n+\t\t\tr.cache.Do(\"stat:\"+info.Version, func() any {\n \t\t\t\treturn cachedInfo{info, err}\n \t\t\t})\n \t\t\tif file, _, err := readDiskStat(r.path, info.Version); err != nil {\n@@ -281,7 +281,7 @@ func (r *cachingRepo) GoMod(version string) ([]byte, error) {\n \t\ttext []byte\n \t\terr  error\n \t}\n-\tc := r.cache.Do(\"gomod:\"+version, func() interface{} {\n+\tc := r.cache.Do(\"gomod:\"+version, func() any {\n \t\tfile, text, err := readDiskGoMod(r.path, version)\n \t\tif err == nil {\n \t\t\t// Note: readDiskGoMod already called checkGoMod.\n@@ -642,7 +642,7 @@ func rewriteVersionList(dir string) (err error) {\n \t// Lock listfile when writing to it to try to avoid corruption to the file.\n \t// Under rare circumstances, for instance, if the system loses power in the\n \t// middle of a write it is possible for corrupt data to be written. This is\n-\t// not a problem for the go command itself, but may be an issue if the the\n+\t// not a problem for the go command itself, but may be an issue if the\n \t// cache is being served by a GOPROXY HTTP server. This will be corrected\n \t// the next time a new version of the module is fetched and the file is rewritten.\n \t// TODO(matloob): golang.org/issue/43313 covers adding a go mod verify\n@@ -720,7 +720,7 @@ func checkCacheDir() error {\n \tif cfg.GOMODCACHE == \"\" {\n \t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n \t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n-\t\treturn fmt.Errorf(\"internal error: cfg.GOMODCACHE not set\")\n+\t\treturn fmt.Errorf(\"module cache not found: neither GOMODCACHE nor GOPATH is set\")\n \t}\n \tif !filepath.IsAbs(cfg.GOMODCACHE) {\n \t\treturn fmt.Errorf(\"GOMODCACHE entry is relative; must be absolute path: %q.\\n\", cfg.GOMODCACHE)"}, {"sha": "4a0e2241e50ac828a92c5add57d174faa70ba6a9", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -55,21 +55,6 @@ type Repo interface {\n \t// os.IsNotExist(err) returns true.\n \tReadFile(rev, file string, maxSize int64) (data []byte, err error)\n \n-\t// ReadFileRevs reads a single file at multiple versions.\n-\t// It should refuse to read more than maxSize bytes.\n-\t// The result is a map from each requested rev strings\n-\t// to the associated FileRev. The map must have a non-nil\n-\t// entry for every requested rev (unless ReadFileRevs returned an error).\n-\t// A file simply being missing or even corrupted in revs[i]\n-\t// should be reported only in files[revs[i]].Err, not in the error result\n-\t// from ReadFileRevs.\n-\t// The overall call should return an error (and no map) only\n-\t// in the case of a problem with obtaining the data, such as\n-\t// a network failure.\n-\t// Implementations may assume that revs only contain tags,\n-\t// not direct commit hashes.\n-\tReadFileRevs(revs []string, file string, maxSize int64) (files map[string]*FileRev, err error)\n-\n \t// ReadZip downloads a zip file for the subdir subdirectory\n \t// of the given revision to a new file in a given temporary directory.\n \t// It should refuse to read more than maxSize bytes.\n@@ -243,15 +228,15 @@ var dirLock sync.Map\n // It returns the standard output and, for a non-zero exit,\n // a *RunError indicating the command, exit status, and standard error.\n // Standard error is unavailable for commands that exit successfully.\n-func Run(dir string, cmdline ...interface{}) ([]byte, error) {\n+func Run(dir string, cmdline ...any) ([]byte, error) {\n \treturn RunWithStdin(dir, nil, cmdline...)\n }\n \n // bashQuoter escapes characters that have special meaning in double-quoted strings in the bash shell.\n // See https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html.\n var bashQuoter = strings.NewReplacer(`\"`, `\\\"`, `$`, `\\$`, \"`\", \"\\\\`\", `\\`, `\\\\`)\n \n-func RunWithStdin(dir string, stdin io.Reader, cmdline ...interface{}) ([]byte, error) {\n+func RunWithStdin(dir string, stdin io.Reader, cmdline ...any) ([]byte, error) {\n \tif dir != \"\" {\n \t\tmuIface, ok := dirLock.Load(dir)\n \t\tif !ok {"}, {"sha": "34f453c855ef8d6b3dd7f6edbab34f30430b7c08", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 67, "deletions": 194, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -56,7 +56,7 @@ func newGitRepoCached(remote string, localOK bool) (Repo, error) {\n \t\terr  error\n \t}\n \n-\tc := gitRepoCache.Do(key{remote, localOK}, func() interface{} {\n+\tc := gitRepoCache.Do(key{remote, localOK}, func() any {\n \t\trepo, err := newGitRepo(remote, localOK)\n \t\treturn cached{repo, err}\n \t}).(cached)\n@@ -170,59 +170,63 @@ func (r *gitRepo) loadLocalTags() {\n }\n \n // loadRefs loads heads and tags references from the remote into the map r.refs.\n-// Should only be called as r.refsOnce.Do(r.loadRefs).\n-func (r *gitRepo) loadRefs() {\n-\t// The git protocol sends all known refs and ls-remote filters them on the client side,\n-\t// so we might as well record both heads and tags in one shot.\n-\t// Most of the time we only care about tags but sometimes we care about heads too.\n-\tout, gitErr := Run(r.dir, \"git\", \"ls-remote\", \"-q\", r.remote)\n-\tif gitErr != nil {\n-\t\tif rerr, ok := gitErr.(*RunError); ok {\n-\t\t\tif bytes.Contains(rerr.Stderr, []byte(\"fatal: could not read Username\")) {\n-\t\t\t\trerr.HelpText = \"Confirm the import path was entered correctly.\\nIf this is a private repository, see https://golang.org/doc/faq#git_https for additional information.\"\n+// The result is cached in memory.\n+func (r *gitRepo) loadRefs() (map[string]string, error) {\n+\tr.refsOnce.Do(func() {\n+\t\t// The git protocol sends all known refs and ls-remote filters them on the client side,\n+\t\t// so we might as well record both heads and tags in one shot.\n+\t\t// Most of the time we only care about tags but sometimes we care about heads too.\n+\t\tout, gitErr := Run(r.dir, \"git\", \"ls-remote\", \"-q\", r.remote)\n+\t\tif gitErr != nil {\n+\t\t\tif rerr, ok := gitErr.(*RunError); ok {\n+\t\t\t\tif bytes.Contains(rerr.Stderr, []byte(\"fatal: could not read Username\")) {\n+\t\t\t\t\trerr.HelpText = \"Confirm the import path was entered correctly.\\nIf this is a private repository, see https://golang.org/doc/faq#git_https for additional information.\"\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t// If the remote URL doesn't exist at all, ideally we should treat the whole\n-\t\t// repository as nonexistent by wrapping the error in a notExistError.\n-\t\t// For HTTP and HTTPS, that's easy to detect: we'll try to fetch the URL\n-\t\t// ourselves and see what code it serves.\n-\t\tif u, err := url.Parse(r.remoteURL); err == nil && (u.Scheme == \"http\" || u.Scheme == \"https\") {\n-\t\t\tif _, err := web.GetBytes(u); errors.Is(err, fs.ErrNotExist) {\n-\t\t\t\tgitErr = notExistError{gitErr}\n+\t\t\t// If the remote URL doesn't exist at all, ideally we should treat the whole\n+\t\t\t// repository as nonexistent by wrapping the error in a notExistError.\n+\t\t\t// For HTTP and HTTPS, that's easy to detect: we'll try to fetch the URL\n+\t\t\t// ourselves and see what code it serves.\n+\t\t\tif u, err := url.Parse(r.remoteURL); err == nil && (u.Scheme == \"http\" || u.Scheme == \"https\") {\n+\t\t\t\tif _, err := web.GetBytes(u); errors.Is(err, fs.ErrNotExist) {\n+\t\t\t\t\tgitErr = notExistError{gitErr}\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\tr.refsErr = gitErr\n-\t\treturn\n-\t}\n-\n-\tr.refs = make(map[string]string)\n-\tfor _, line := range strings.Split(string(out), \"\\n\") {\n-\t\tf := strings.Fields(line)\n-\t\tif len(f) != 2 {\n-\t\t\tcontinue\n+\t\t\tr.refsErr = gitErr\n+\t\t\treturn\n \t\t}\n-\t\tif f[1] == \"HEAD\" || strings.HasPrefix(f[1], \"refs/heads/\") || strings.HasPrefix(f[1], \"refs/tags/\") {\n-\t\t\tr.refs[f[1]] = f[0]\n+\n+\t\trefs := make(map[string]string)\n+\t\tfor _, line := range strings.Split(string(out), \"\\n\") {\n+\t\t\tf := strings.Fields(line)\n+\t\t\tif len(f) != 2 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif f[1] == \"HEAD\" || strings.HasPrefix(f[1], \"refs/heads/\") || strings.HasPrefix(f[1], \"refs/tags/\") {\n+\t\t\t\trefs[f[1]] = f[0]\n+\t\t\t}\n \t\t}\n-\t}\n-\tfor ref, hash := range r.refs {\n-\t\tif strings.HasSuffix(ref, \"^{}\") { // record unwrapped annotated tag as value of tag\n-\t\t\tr.refs[strings.TrimSuffix(ref, \"^{}\")] = hash\n-\t\t\tdelete(r.refs, ref)\n+\t\tfor ref, hash := range refs {\n+\t\t\tif strings.HasSuffix(ref, \"^{}\") { // record unwrapped annotated tag as value of tag\n+\t\t\t\trefs[strings.TrimSuffix(ref, \"^{}\")] = hash\n+\t\t\t\tdelete(refs, ref)\n+\t\t\t}\n \t\t}\n-\t}\n+\t\tr.refs = refs\n+\t})\n+\treturn r.refs, r.refsErr\n }\n \n func (r *gitRepo) Tags(prefix string) ([]string, error) {\n-\tr.refsOnce.Do(r.loadRefs)\n-\tif r.refsErr != nil {\n-\t\treturn nil, r.refsErr\n+\trefs, err := r.loadRefs()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n \ttags := []string{}\n-\tfor ref := range r.refs {\n+\tfor ref := range refs {\n \t\tif !strings.HasPrefix(ref, \"refs/tags/\") {\n \t\t\tcontinue\n \t\t}\n@@ -237,23 +241,26 @@ func (r *gitRepo) Tags(prefix string) ([]string, error) {\n }\n \n func (r *gitRepo) Latest() (*RevInfo, error) {\n-\tr.refsOnce.Do(r.loadRefs)\n-\tif r.refsErr != nil {\n-\t\treturn nil, r.refsErr\n+\trefs, err := r.loadRefs()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\tif r.refs[\"HEAD\"] == \"\" {\n+\tif refs[\"HEAD\"] == \"\" {\n \t\treturn nil, ErrNoCommits\n \t}\n-\treturn r.Stat(r.refs[\"HEAD\"])\n+\treturn r.Stat(refs[\"HEAD\"])\n }\n \n // findRef finds some ref name for the given hash,\n // for use when the server requires giving a ref instead of a hash.\n // There may be multiple ref names for a given hash,\n // in which case this returns some name - it doesn't matter which.\n func (r *gitRepo) findRef(hash string) (ref string, ok bool) {\n-\tr.refsOnce.Do(r.loadRefs)\n-\tfor ref, h := range r.refs {\n+\trefs, err := r.loadRefs()\n+\tif err != nil {\n+\t\treturn \"\", false\n+\t}\n+\tfor ref, h := range refs {\n \t\tif h == hash {\n \t\t\treturn ref, true\n \t\t}\n@@ -295,29 +302,32 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \t// Maybe rev is the name of a tag or branch on the remote server.\n \t// Or maybe it's the prefix of a hash of a named ref.\n \t// Try to resolve to both a ref (git name) and full (40-hex-digit) commit hash.\n-\tr.refsOnce.Do(r.loadRefs)\n+\trefs, err := r.loadRefs()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \t// loadRefs may return an error if git fails, for example segfaults, or\n \t// could not load a private repo, but defer checking to the else block\n \t// below, in case we already have the rev in question in the local cache.\n \tvar ref, hash string\n-\tif r.refs[\"refs/tags/\"+rev] != \"\" {\n+\tif refs[\"refs/tags/\"+rev] != \"\" {\n \t\tref = \"refs/tags/\" + rev\n-\t\thash = r.refs[ref]\n+\t\thash = refs[ref]\n \t\t// Keep rev as is: tags are assumed not to change meaning.\n-\t} else if r.refs[\"refs/heads/\"+rev] != \"\" {\n+\t} else if refs[\"refs/heads/\"+rev] != \"\" {\n \t\tref = \"refs/heads/\" + rev\n-\t\thash = r.refs[ref]\n+\t\thash = refs[ref]\n \t\trev = hash // Replace rev, because meaning of refs/heads/foo can change.\n-\t} else if rev == \"HEAD\" && r.refs[\"HEAD\"] != \"\" {\n+\t} else if rev == \"HEAD\" && refs[\"HEAD\"] != \"\" {\n \t\tref = \"HEAD\"\n-\t\thash = r.refs[ref]\n+\t\thash = refs[ref]\n \t\trev = hash // Replace rev, because meaning of HEAD can change.\n \t} else if len(rev) >= minHashDigits && len(rev) <= 40 && AllHex(rev) {\n \t\t// At the least, we have a hash prefix we can look up after the fetch below.\n \t\t// Maybe we can map it to a full hash using the known refs.\n \t\tprefix := rev\n \t\t// Check whether rev is prefix of known ref hash.\n-\t\tfor k, h := range r.refs {\n+\t\tfor k, h := range refs {\n \t\t\tif strings.HasPrefix(h, prefix) {\n \t\t\t\tif hash != \"\" && hash != h {\n \t\t\t\t\t// Hash is an ambiguous hash prefix.\n@@ -335,9 +345,6 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \t\t\thash = rev\n \t\t}\n \t} else {\n-\t\tif r.refsErr != nil {\n-\t\t\treturn nil, r.refsErr\n-\t\t}\n \t\treturn nil, &UnknownRevisionError{Rev: rev}\n \t}\n \n@@ -496,7 +503,7 @@ func (r *gitRepo) Stat(rev string) (*RevInfo, error) {\n \t\tinfo *RevInfo\n \t\terr  error\n \t}\n-\tc := r.statCache.Do(rev, func() interface{} {\n+\tc := r.statCache.Do(rev, func() any {\n \t\tinfo, err := r.stat(rev)\n \t\treturn cached{info, err}\n \t}).(cached)\n@@ -516,140 +523,6 @@ func (r *gitRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n \treturn out, nil\n }\n \n-func (r *gitRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[string]*FileRev, error) {\n-\t// Create space to hold results.\n-\tfiles := make(map[string]*FileRev)\n-\tfor _, rev := range revs {\n-\t\tf := &FileRev{Rev: rev}\n-\t\tfiles[rev] = f\n-\t}\n-\n-\t// Collect locally-known revs.\n-\tneed, err := r.readFileRevs(revs, file, files)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif len(need) == 0 {\n-\t\treturn files, nil\n-\t}\n-\n-\t// Build list of known remote refs that might help.\n-\tvar redo []string\n-\tr.refsOnce.Do(r.loadRefs)\n-\tif r.refsErr != nil {\n-\t\treturn nil, r.refsErr\n-\t}\n-\tfor _, tag := range need {\n-\t\tif r.refs[\"refs/tags/\"+tag] != \"\" {\n-\t\t\tredo = append(redo, tag)\n-\t\t}\n-\t}\n-\tif len(redo) == 0 {\n-\t\treturn files, nil\n-\t}\n-\n-\t// Protect r.fetchLevel and the \"fetch more and more\" sequence.\n-\t// See stat method above.\n-\tunlock, err := r.mu.Lock()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdefer unlock()\n-\n-\tif err := r.fetchRefsLocked(); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tif _, err := r.readFileRevs(redo, file, files); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\treturn files, nil\n-}\n-\n-func (r *gitRepo) readFileRevs(tags []string, file string, fileMap map[string]*FileRev) (missing []string, err error) {\n-\tvar stdin bytes.Buffer\n-\tfor _, tag := range tags {\n-\t\tfmt.Fprintf(&stdin, \"refs/tags/%s\\n\", tag)\n-\t\tfmt.Fprintf(&stdin, \"refs/tags/%s:%s\\n\", tag, file)\n-\t}\n-\n-\tdata, err := RunWithStdin(r.dir, &stdin, \"git\", \"cat-file\", \"--batch\")\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tnext := func() (typ string, body []byte, ok bool) {\n-\t\tvar line string\n-\t\ti := bytes.IndexByte(data, '\\n')\n-\t\tif i < 0 {\n-\t\t\treturn \"\", nil, false\n-\t\t}\n-\t\tline, data = string(bytes.TrimSpace(data[:i])), data[i+1:]\n-\t\tif strings.HasSuffix(line, \" missing\") {\n-\t\t\treturn \"missing\", nil, true\n-\t\t}\n-\t\tf := strings.Fields(line)\n-\t\tif len(f) != 3 {\n-\t\t\treturn \"\", nil, false\n-\t\t}\n-\t\tn, err := strconv.Atoi(f[2])\n-\t\tif err != nil || n > len(data) {\n-\t\t\treturn \"\", nil, false\n-\t\t}\n-\t\tbody, data = data[:n], data[n:]\n-\t\tif len(data) > 0 && data[0] == '\\r' {\n-\t\t\tdata = data[1:]\n-\t\t}\n-\t\tif len(data) > 0 && data[0] == '\\n' {\n-\t\t\tdata = data[1:]\n-\t\t}\n-\t\treturn f[1], body, true\n-\t}\n-\n-\tbadGit := func() ([]string, error) {\n-\t\treturn nil, fmt.Errorf(\"malformed output from git cat-file --batch\")\n-\t}\n-\n-\tfor _, tag := range tags {\n-\t\tcommitType, _, ok := next()\n-\t\tif !ok {\n-\t\t\treturn badGit()\n-\t\t}\n-\t\tfileType, fileData, ok := next()\n-\t\tif !ok {\n-\t\t\treturn badGit()\n-\t\t}\n-\t\tf := fileMap[tag]\n-\t\tf.Data = nil\n-\t\tf.Err = nil\n-\t\tswitch commitType {\n-\t\tdefault:\n-\t\t\tf.Err = fmt.Errorf(\"unexpected non-commit type %q for rev %s\", commitType, tag)\n-\n-\t\tcase \"missing\":\n-\t\t\t// Note: f.Err must not satisfy os.IsNotExist. That's reserved for the file not existing in a valid commit.\n-\t\t\tf.Err = fmt.Errorf(\"no such rev %s\", tag)\n-\t\t\tmissing = append(missing, tag)\n-\n-\t\tcase \"tag\", \"commit\":\n-\t\t\tswitch fileType {\n-\t\t\tdefault:\n-\t\t\t\tf.Err = &fs.PathError{Path: tag + \":\" + file, Op: \"read\", Err: fmt.Errorf(\"unexpected non-blob type %q\", fileType)}\n-\t\t\tcase \"missing\":\n-\t\t\t\tf.Err = &fs.PathError{Path: tag + \":\" + file, Op: \"read\", Err: fs.ErrNotExist}\n-\t\t\tcase \"blob\":\n-\t\t\t\tf.Data = fileData\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif len(bytes.TrimSpace(data)) != 0 {\n-\t\treturn badGit()\n-\t}\n-\n-\treturn missing, nil\n-}\n-\n func (r *gitRepo) RecentTag(rev, prefix string, allowed func(string) bool) (tag string, err error) {\n \tinfo, err := r.Stat(rev)\n \tif err != nil {"}, {"sha": "eaa01950b95ef395e57ac6f8d85036c44b6ff911", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/shell.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build ignore\n-// +build ignore\n \n // Interactive debugging shell for codehost.Repo implementations.\n "}, {"sha": "de62265efc5a722abae770da0486ef04c2e5a205", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/vcs.go", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -38,7 +38,7 @@ type VCSError struct {\n \n func (e *VCSError) Error() string { return e.Err.Error() }\n \n-func vcsErrorf(format string, a ...interface{}) error {\n+func vcsErrorf(format string, a ...any) error {\n \treturn &VCSError{Err: fmt.Errorf(format, a...)}\n }\n \n@@ -51,7 +51,7 @@ func NewRepo(vcs, remote string) (Repo, error) {\n \t\trepo Repo\n \t\terr  error\n \t}\n-\tc := vcsRepoCache.Do(key{vcs, remote}, func() interface{} {\n+\tc := vcsRepoCache.Do(key{vcs, remote}, func() any {\n \t\trepo, err := newVCSRepo(vcs, remote)\n \t\tif err != nil {\n \t\t\terr = &VCSError{err}\n@@ -382,19 +382,6 @@ func (r *vcsRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n \treturn out, nil\n }\n \n-func (r *vcsRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[string]*FileRev, error) {\n-\t// We don't technically need to lock here since we're returning an error\n-\t// uncondititonally, but doing so anyway will help to avoid baking in\n-\t// lock-inversion bugs.\n-\tunlock, err := r.mu.Lock()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdefer unlock()\n-\n-\treturn nil, vcsErrorf(\"ReadFileRevs not implemented\")\n-}\n-\n func (r *vcsRepo) RecentTag(rev, prefix string, allowed func(string) bool) (tag string, err error) {\n \t// We don't technically need to lock here since we're returning an error\n \t// uncondititonally, but doing so anyway will help to avoid baking in"}, {"sha": "79da010809b7407b12e2a1a823abb7ee3c022cce", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -321,7 +321,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\treturn ok\n \t}\n \n-\tinvalidf := func(format string, args ...interface{}) error {\n+\tinvalidf := func(format string, args ...any) error {\n \t\treturn &module.ModuleError{\n \t\t\tPath: r.modPath,\n \t\t\tErr: &module.InvalidVersionError{\n@@ -567,11 +567,11 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \tif rev != info.Short {\n \t\tswitch {\n \t\tcase strings.HasPrefix(rev, info.Short):\n-\t\t\treturn fmt.Errorf(\"revision is longer than canonical (%s)\", info.Short)\n+\t\t\treturn fmt.Errorf(\"revision is longer than canonical (expected %s)\", info.Short)\n \t\tcase strings.HasPrefix(info.Short, rev):\n-\t\t\treturn fmt.Errorf(\"revision is shorter than canonical (%s)\", info.Short)\n+\t\t\treturn fmt.Errorf(\"revision is shorter than canonical (expected %s)\", info.Short)\n \t\tdefault:\n-\t\t\treturn fmt.Errorf(\"does not match short name of revision (%s)\", info.Short)\n+\t\t\treturn fmt.Errorf(\"does not match short name of revision (expected %s)\", info.Short)\n \t\t}\n \t}\n \n@@ -1066,7 +1066,7 @@ func (fi dataFileInfo) Size() int64        { return int64(len(fi.f.data)) }\n func (fi dataFileInfo) Mode() fs.FileMode  { return 0644 }\n func (fi dataFileInfo) ModTime() time.Time { return time.Time{} }\n func (fi dataFileInfo) IsDir() bool        { return false }\n-func (fi dataFileInfo) Sys() interface{}   { return nil }\n+func (fi dataFileInfo) Sys() any           { return nil }\n \n // hasPathPrefix reports whether the path s begins with the\n // elements in prefix."}, {"sha": "f5423b48ad3471969766fca883394313835631ae", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 99, "deletions": 21, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -48,7 +48,7 @@ func Download(ctx context.Context, mod module.Version) (dir string, err error) {\n \t\tdir string\n \t\terr error\n \t}\n-\tc := downloadCache.Do(mod, func() interface{} {\n+\tc := downloadCache.Do(mod, func() any {\n \t\tdir, err := download(ctx, mod)\n \t\tif err != nil {\n \t\t\treturn cached{\"\", err}\n@@ -165,7 +165,7 @@ func DownloadZip(ctx context.Context, mod module.Version) (zipfile string, err e\n \t\tzipfile string\n \t\terr     error\n \t}\n-\tc := downloadZipCache.Do(mod, func() interface{} {\n+\tc := downloadZipCache.Do(mod, func() any {\n \t\tzipfile, err := CachePath(mod, \"zip\")\n \t\tif err != nil {\n \t\t\treturn cached{\"\", err}\n@@ -384,7 +384,8 @@ func RemoveAll(dir string) error {\n \treturn robustio.RemoveAll(dir)\n }\n \n-var GoSumFile string // path to go.sum; set by package modload\n+var GoSumFile string             // path to go.sum; set by package modload\n+var WorkspaceGoSumFiles []string // path to module go.sums in workspace; set by package modload\n \n type modSum struct {\n \tmod module.Version\n@@ -393,16 +394,39 @@ type modSum struct {\n \n var goSum struct {\n \tmu        sync.Mutex\n-\tm         map[module.Version][]string // content of go.sum file\n-\tstatus    map[modSum]modSumStatus     // state of sums in m\n-\toverwrite bool                        // if true, overwrite go.sum without incorporating its contents\n-\tenabled   bool                        // whether to use go.sum at all\n+\tm         map[module.Version][]string            // content of go.sum file\n+\tw         map[string]map[module.Version][]string // sum file in workspace -> content of that sum file\n+\tstatus    map[modSum]modSumStatus                // state of sums in m\n+\toverwrite bool                                   // if true, overwrite go.sum without incorporating its contents\n+\tenabled   bool                                   // whether to use go.sum at all\n }\n \n type modSumStatus struct {\n \tused, dirty bool\n }\n \n+// Reset resets globals in the modfetch package, so previous loads don't affect\n+// contents of go.sum files\n+func Reset() {\n+\tGoSumFile = \"\"\n+\tWorkspaceGoSumFiles = nil\n+\n+\t// Uses of lookupCache and downloadCache both can call checkModSum,\n+\t// which in turn sets the used bit on goSum.status for modules.\n+\t// Reset them so used can be computed properly.\n+\tlookupCache = par.Cache{}\n+\tdownloadCache = par.Cache{}\n+\n+\t// Clear all fields on goSum. It will be initialized later\n+\tgoSum.mu.Lock()\n+\tgoSum.m = nil\n+\tgoSum.w = nil\n+\tgoSum.status = nil\n+\tgoSum.overwrite = false\n+\tgoSum.enabled = false\n+\tgoSum.mu.Unlock()\n+}\n+\n // initGoSum initializes the go.sum data.\n // The boolean it returns reports whether the\n // use of go.sum is now enabled.\n@@ -417,23 +441,38 @@ func initGoSum() (bool, error) {\n \n \tgoSum.m = make(map[module.Version][]string)\n \tgoSum.status = make(map[modSum]modSumStatus)\n+\tgoSum.w = make(map[string]map[module.Version][]string)\n+\n+\tfor _, f := range WorkspaceGoSumFiles {\n+\t\tgoSum.w[f] = make(map[module.Version][]string)\n+\t\t_, err := readGoSumFile(goSum.w[f], f)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n+\n+\tenabled, err := readGoSumFile(goSum.m, GoSumFile)\n+\tgoSum.enabled = enabled\n+\treturn enabled, err\n+}\n+\n+func readGoSumFile(dst map[module.Version][]string, file string) (bool, error) {\n \tvar (\n \t\tdata []byte\n \t\terr  error\n \t)\n-\tif actualSumFile, ok := fsys.OverlayPath(GoSumFile); ok {\n+\tif actualSumFile, ok := fsys.OverlayPath(file); ok {\n \t\t// Don't lock go.sum if it's part of the overlay.\n \t\t// On Plan 9, locking requires chmod, and we don't want to modify any file\n \t\t// in the overlay. See #44700.\n \t\tdata, err = os.ReadFile(actualSumFile)\n \t} else {\n-\t\tdata, err = lockedfile.Read(GoSumFile)\n+\t\tdata, err = lockedfile.Read(file)\n \t}\n \tif err != nil && !os.IsNotExist(err) {\n \t\treturn false, err\n \t}\n-\tgoSum.enabled = true\n-\treadGoSum(goSum.m, GoSumFile, data)\n+\treadGoSum(dst, file, data)\n \n \treturn true, nil\n }\n@@ -485,6 +524,16 @@ func HaveSum(mod module.Version) bool {\n \tif err != nil || !inited {\n \t\treturn false\n \t}\n+\tfor _, goSums := range goSum.w {\n+\t\tfor _, h := range goSums[mod] {\n+\t\t\tif !strings.HasPrefix(h, \"h1:\") {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !goSum.status[modSum{mod, h}].dirty {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n \tfor _, h := range goSum.m[mod] {\n \t\tif !strings.HasPrefix(h, \"h1:\") {\n \t\t\tcontinue\n@@ -602,15 +651,32 @@ func checkModSum(mod module.Version, h string) error {\n // If it finds a conflicting pair instead, it calls base.Fatalf.\n // goSum.mu must be locked.\n func haveModSumLocked(mod module.Version, h string) bool {\n+\tsumFileName := \"go.sum\"\n+\tif strings.HasSuffix(GoSumFile, \"go.work.sum\") {\n+\t\tsumFileName = \"go.work.sum\"\n+\t}\n \tfor _, vh := range goSum.m[mod] {\n \t\tif h == vh {\n \t\t\treturn true\n \t\t}\n \t\tif strings.HasPrefix(vh, \"h1:\") {\n-\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\tgo.sum:     %v\"+goSumMismatch, mod.Path, mod.Version, h, vh)\n+\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\t%s:     %v\"+goSumMismatch, mod.Path, mod.Version, h, sumFileName, vh)\n+\t\t}\n+\t}\n+\t// Also check workspace sums.\n+\tfoundMatch := false\n+\t// Check sums from all files in case there are conflicts between\n+\t// the files.\n+\tfor goSumFile, goSums := range goSum.w {\n+\t\tfor _, vh := range goSums[mod] {\n+\t\t\tif h == vh {\n+\t\t\t\tfoundMatch = true\n+\t\t\t} else if strings.HasPrefix(vh, \"h1:\") {\n+\t\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\t%s:     %v\"+goSumMismatch, mod.Path, mod.Version, h, goSumFile, vh)\n+\t\t\t}\n \t\t}\n \t}\n-\treturn false\n+\treturn foundMatch\n }\n \n // addModSumLocked adds the pair mod,h to go.sum.\n@@ -693,19 +759,21 @@ func isValidSum(data []byte) bool {\n \treturn true\n }\n \n+var ErrGoSumDirty = errors.New(\"updates to go.sum needed, disabled by -mod=readonly\")\n+\n // WriteGoSum writes the go.sum file if it needs to be updated.\n //\n // keep is used to check whether a newly added sum should be saved in go.sum.\n // It should have entries for both module content sums and go.mod sums\n // (version ends with \"/go.mod\"). Existing sums will be preserved unless they\n // have been marked for deletion with TrimGoSum.\n-func WriteGoSum(keep map[module.Version]bool) {\n+func WriteGoSum(keep map[module.Version]bool, readonly bool) error {\n \tgoSum.mu.Lock()\n \tdefer goSum.mu.Unlock()\n \n \t// If we haven't read the go.sum file yet, don't bother writing it.\n \tif !goSum.enabled {\n-\t\treturn\n+\t\treturn nil\n \t}\n \n \t// Check whether we need to add sums for which keep[m] is true or remove\n@@ -723,10 +791,10 @@ Outer:\n \t\t}\n \t}\n \tif !dirty {\n-\t\treturn\n+\t\treturn nil\n \t}\n-\tif cfg.BuildMod == \"readonly\" {\n-\t\tbase.Fatalf(\"go: updates to go.sum needed, disabled by -mod=readonly\")\n+\tif readonly {\n+\t\treturn ErrGoSumDirty\n \t}\n \tif _, ok := fsys.OverlayPath(GoSumFile); ok {\n \t\tbase.Fatalf(\"go: updates to go.sum needed, but go.sum is part of the overlay specified with -overlay\")\n@@ -747,7 +815,7 @@ Outer:\n \t\t\tgoSum.m = make(map[module.Version][]string, len(goSum.m))\n \t\t\treadGoSum(goSum.m, GoSumFile, data)\n \t\t\tfor ms, st := range goSum.status {\n-\t\t\t\tif st.used {\n+\t\t\t\tif st.used && !sumInWorkspaceModulesLocked(ms.mod) {\n \t\t\t\t\taddModSumLocked(ms.mod, ms.sum)\n \t\t\t\t}\n \t\t\t}\n@@ -765,7 +833,7 @@ Outer:\n \t\t\tsort.Strings(list)\n \t\t\tfor _, h := range list {\n \t\t\t\tst := goSum.status[modSum{m, h}]\n-\t\t\t\tif !st.dirty || (st.used && keep[m]) {\n+\t\t\t\tif (!st.dirty || (st.used && keep[m])) && !sumInWorkspaceModulesLocked(m) {\n \t\t\t\t\tfmt.Fprintf(&buf, \"%s %s %s\\n\", m.Path, m.Version, h)\n \t\t\t\t}\n \t\t\t}\n@@ -774,11 +842,21 @@ Outer:\n \t})\n \n \tif err != nil {\n-\t\tbase.Fatalf(\"go: updating go.sum: %v\", err)\n+\t\treturn fmt.Errorf(\"updating go.sum: %w\", err)\n \t}\n \n \tgoSum.status = make(map[modSum]modSumStatus)\n \tgoSum.overwrite = false\n+\treturn nil\n+}\n+\n+func sumInWorkspaceModulesLocked(m module.Version) bool {\n+\tfor _, goSums := range goSum.w {\n+\t\tif _, ok := goSums[m]; ok {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n }\n \n // TrimGoSum trims go.sum to contain only the modules needed for reproducible"}, {"sha": "1b42ecb6edb45c0ce6dcf8ee88fdcb047e061b61", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -196,7 +196,7 @@ func Lookup(proxy, path string) Repo {\n \ttype cached struct {\n \t\tr Repo\n \t}\n-\tc := lookupCache.Do(lookupCacheKey{proxy, path}, func() interface{} {\n+\tc := lookupCache.Do(lookupCacheKey{proxy, path}, func() any {\n \t\tr := newCachingRepo(path, func() (Repo, error) {\n \t\t\tr, err := lookup(proxy, path)\n \t\t\tif err == nil && traceRepo {\n@@ -308,7 +308,7 @@ func newLoggingRepo(r Repo) *loggingRepo {\n //\tdefer logCall(\"hello %s\", arg)()\n //\n // Note the final ().\n-func logCall(format string, args ...interface{}) func() {\n+func logCall(format string, args ...any) func() {\n \tstart := time.Now()\n \tfmt.Fprintf(os.Stderr, \"+++ %s\\n\", fmt.Sprintf(format, args...))\n \treturn func() {\n@@ -371,7 +371,7 @@ type notExistError struct {\n \terr error\n }\n \n-func notExistErrorf(format string, args ...interface{}) error {\n+func notExistErrorf(format string, args ...any) error {\n \treturn notExistError{fmt.Errorf(format, args...)}\n }\n "}, {"sha": "492b03bd84ac8b6e0d3758accb79e614dd567fe2", "filename": "libgo/go/cmd/go/internal/modfetch/sumdb.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,7 +5,6 @@\n // Go checksum database lookup\n \n //go:build !cmd_go_bootstrap\n-// +build !cmd_go_bootstrap\n \n package modfetch\n \n@@ -201,7 +200,8 @@ func (c *dbClient) ReadConfig(file string) (data []byte, err error) {\n \t}\n \n \tif cfg.SumdbDir == \"\" {\n-\t\treturn nil, errors.New(\"could not locate sumdb file: missing $GOPATH\")\n+\t\treturn nil, fmt.Errorf(\"could not locate sumdb file: missing $GOPATH: %s\",\n+\t\t\tcfg.GoPathError)\n \t}\n \ttarg := filepath.Join(cfg.SumdbDir, file)\n \tdata, err = lockedfile.Read(targ)\n@@ -220,7 +220,8 @@ func (*dbClient) WriteConfig(file string, old, new []byte) error {\n \t\treturn fmt.Errorf(\"cannot write key\")\n \t}\n \tif cfg.SumdbDir == \"\" {\n-\t\treturn errors.New(\"could not locate sumdb file: missing $GOPATH\")\n+\t\treturn fmt.Errorf(\"could not locate sumdb file: missing $GOPATH: %s\",\n+\t\t\tcfg.GoPathError)\n \t}\n \ttarg := filepath.Join(cfg.SumdbDir, file)\n \tos.MkdirAll(filepath.Dir(targ), 0777)"}, {"sha": "3d8463e892c69ad5fdd5cb7885a7d4b65d6e0893", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 93, "deletions": 127, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -37,7 +37,6 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/imports\"\n-\t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/par\"\n@@ -50,14 +49,14 @@ import (\n )\n \n var CmdGet = &base.Command{\n-\t// Note: -d -u are listed explicitly because they are the most common get flags.\n+\t// Note: flags below are listed explicitly because they're the most common.\n \t// Do not send CLs removing them because they're covered by [get flags].\n-\tUsageLine: \"go get [-d] [-t] [-u] [-v] [build flags] [packages]\",\n+\tUsageLine: \"go get [-t] [-u] [-v] [build flags] [packages]\",\n \tShort:     \"add dependencies to current module and install them\",\n \tLong: `\n Get resolves its command-line arguments to packages at specific module versions,\n-updates go.mod to require those versions, downloads source code into the\n-module cache, then builds and installs the named packages.\n+updates go.mod to require those versions, and downloads source code into the\n+module cache.\n \n To add a dependency for a package or upgrade it to its latest version:\n \n@@ -73,17 +72,18 @@ To remove a dependency on a module and downgrade modules that require it:\n \n See https://golang.org/ref/mod#go-get for details.\n \n-The 'go install' command may be used to build and install packages. When a\n-version is specified, 'go install' runs in module-aware mode and ignores\n-the go.mod file in the current directory. For example:\n+In earlier versions of Go, 'go get' was used to build and install packages.\n+Now, 'go get' is dedicated to adjusting dependencies in go.mod. 'go install'\n+may be used to build and install commands instead. When a version is specified,\n+'go install' runs in module-aware mode and ignores the go.mod file in the\n+current directory. For example:\n \n \tgo install example.com/pkg@v1.2.3\n \tgo install example.com/pkg@latest\n \n See 'go help install' or https://golang.org/ref/mod#go-install for details.\n \n-In addition to build flags (listed in 'go help build') 'go get' accepts the\n-following flags.\n+'go get' accepts the following flags.\n \n The -t flag instructs get to consider modules needed to build tests of\n packages specified on the command line.\n@@ -98,15 +98,9 @@ but changes the default to select patch releases.\n When the -t and -u flags are used together, get will update\n test dependencies as well.\n \n-The -d flag instructs get not to build or install packages. get will only\n-update go.mod and download source code needed to build packages.\n-\n-Building and installing packages with get is deprecated. In a future release,\n-the -d flag will be enabled by default, and 'go get' will be only be used to\n-adjust dependencies of the current module. To install a package using\n-dependencies from the current module, use 'go install'. To install a package\n-ignoring the current module, use 'go install' with an @version suffix like\n-\"@latest\" after each argument.\n+The -x flag prints commands as they are executed. This is useful for\n+debugging version control commands when a module is downloaded directly\n+from a repository.\n \n For more about modules, see https://golang.org/ref/mod.\n \n@@ -218,7 +212,7 @@ variable for future go command invocations.\n }\n \n var (\n-\tgetD        = CmdGet.Flag.Bool(\"d\", false, \"\")\n+\tgetD        = CmdGet.Flag.Bool(\"d\", true, \"\")\n \tgetF        = CmdGet.Flag.Bool(\"f\", false, \"\")\n \tgetFix      = CmdGet.Flag.Bool(\"fix\", false, \"\")\n \tgetM        = CmdGet.Flag.Bool(\"m\", false, \"\")\n@@ -263,30 +257,50 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \tcase \"\", \"upgrade\", \"patch\":\n \t\t// ok\n \tdefault:\n-\t\tbase.Fatalf(\"go get: unknown upgrade flag -u=%s\", getU.rawVersion)\n+\t\tbase.Fatalf(\"go: unknown upgrade flag -u=%s\", getU.rawVersion)\n+\t}\n+\t// TODO(#43684): in the future (Go 1.20), warn that -d is a no-op.\n+\tif !*getD {\n+\t\tbase.Fatalf(\"go: -d flag may not be disabled\")\n \t}\n \tif *getF {\n-\t\tfmt.Fprintf(os.Stderr, \"go get: -f flag is a no-op when using modules\\n\")\n+\t\tfmt.Fprintf(os.Stderr, \"go: -f flag is a no-op when using modules\\n\")\n \t}\n \tif *getFix {\n-\t\tfmt.Fprintf(os.Stderr, \"go get: -fix flag is a no-op when using modules\\n\")\n+\t\tfmt.Fprintf(os.Stderr, \"go: -fix flag is a no-op when using modules\\n\")\n \t}\n \tif *getM {\n-\t\tbase.Fatalf(\"go get: -m flag is no longer supported; consider -d to skip building packages\")\n+\t\tbase.Fatalf(\"go: -m flag is no longer supported\")\n \t}\n \tif *getInsecure {\n-\t\tbase.Fatalf(\"go get: -insecure flag is no longer supported; use GOINSECURE instead\")\n+\t\tbase.Fatalf(\"go: -insecure flag is no longer supported; use GOINSECURE instead\")\n \t}\n \n+\tmodload.ForceUseModules = true\n+\n \t// Do not allow any updating of go.mod until we've applied\n \t// all the requested changes and checked that the result matches\n \t// what was requested.\n-\tmodload.DisallowWriteGoMod()\n+\tmodload.ExplicitWriteGoMod = true\n \n \t// Allow looking up modules for import paths when outside of a module.\n \t// 'go get' is expected to do this, unlike other commands.\n \tmodload.AllowMissingModuleImports()\n \n+\t// 'go get' no longer builds or installs packages, so there's nothing to do\n+\t// if there's no go.mod file.\n+\t// TODO(#40775): make modload.Init return ErrNoModRoot instead of exiting.\n+\t// We could handle that here by printing a different message.\n+\tmodload.Init()\n+\tif !modload.HasModRoot() {\n+\t\tbase.Fatalf(\"go: go.mod file not found in current directory or any parent directory.\\n\" +\n+\t\t\t\"\\t'go get' is no longer supported outside a module.\\n\" +\n+\t\t\t\"\\tTo build and install a command, use 'go install' with a version,\\n\" +\n+\t\t\t\"\\tlike 'go install example.com/cmd@latest'\\n\" +\n+\t\t\t\"\\tFor more information, see https://golang.org/doc/go-get-install-deprecation\\n\" +\n+\t\t\t\"\\tor run 'go help get' or 'go help install'.\")\n+\t}\n+\n \tqueries := parseArgs(ctx, args)\n \n \tr := newResolver(ctx, queries)\n@@ -356,74 +370,12 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \tr.checkPackageProblems(ctx, pkgPatterns)\n \n-\t// We've already downloaded modules (and identified direct and indirect\n-\t// dependencies) by loading packages in findAndUpgradeImports.\n-\t// So if -d is set, we're done after the module work.\n-\t//\n-\t// Otherwise, we need to build and install the packages matched by\n-\t// command line arguments.\n-\t// Note that 'go get -u' without arguments is equivalent to\n-\t// 'go get -u .', so we'll typically build the package in the current\n-\t// directory.\n-\tif !*getD && len(pkgPatterns) > 0 {\n-\t\twork.BuildInit()\n-\n-\t\tpkgOpts := load.PackageOpts{ModResolveTests: *getT}\n-\t\tvar pkgs []*load.Package\n-\t\tfor _, pkg := range load.PackagesAndErrors(ctx, pkgOpts, pkgPatterns) {\n-\t\t\tif pkg.Error != nil {\n-\t\t\t\tvar noGo *load.NoGoError\n-\t\t\t\tif errors.As(pkg.Error.Err, &noGo) {\n-\t\t\t\t\tif m := modload.PackageModule(pkg.ImportPath); m.Path == pkg.ImportPath {\n-\t\t\t\t\t\t// pkg is at the root of a module, and doesn't exist with the current\n-\t\t\t\t\t\t// build tags. Probably the user just wanted to change the version of\n-\t\t\t\t\t\t// that module \u2014 not also build the package \u2014 so suppress the error.\n-\t\t\t\t\t\t// (See https://golang.org/issue/33526.)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tpkgs = append(pkgs, pkg)\n-\t\t}\n-\t\tload.CheckPackageErrors(pkgs)\n-\n-\t\thaveExternalExe := false\n-\t\tfor _, pkg := range pkgs {\n-\t\t\tif pkg.Name == \"main\" && pkg.Module != nil && pkg.Module.Path != modload.Target.Path {\n-\t\t\t\thaveExternalExe = true\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif haveExternalExe {\n-\t\t\tfmt.Fprint(os.Stderr, \"go get: installing executables with 'go get' in module mode is deprecated.\")\n-\t\t\tvar altMsg string\n-\t\t\tif modload.HasModRoot() {\n-\t\t\t\taltMsg = `\n-\tTo adjust and download dependencies of the current module, use 'go get -d'.\n-\tTo install using requirements of the current module, use 'go install'.\n-\tTo install ignoring the current module, use 'go install' with a version,\n-\tlike 'go install example.com/cmd@latest'.\n-`\n-\t\t\t} else {\n-\t\t\t\taltMsg = \"\\n\\tUse 'go install pkg@version' instead.\\n\"\n-\t\t\t}\n-\t\t\tfmt.Fprint(os.Stderr, altMsg)\n-\t\t\tfmt.Fprintf(os.Stderr, \"\\tFor more information, see https://golang.org/doc/go-get-install-deprecation\\n\\tor run 'go help get' or 'go help install'.\\n\")\n-\t\t}\n-\n-\t\twork.InstallPackages(ctx, pkgPatterns, pkgs)\n-\t}\n-\n-\tif !modload.HasModRoot() {\n-\t\treturn\n-\t}\n-\n \t// Everything succeeded. Update go.mod.\n \toldReqs := reqsFromGoMod(modload.ModFile())\n \n-\tmodload.AllowWriteGoMod()\n-\tmodload.WriteGoMod(ctx)\n-\tmodload.DisallowWriteGoMod()\n+\tif err := modload.WriteGoMod(ctx); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n \n \tnewReqs := reqsFromGoMod(modload.ModFile())\n \tr.reportChanges(oldReqs, newReqs)\n@@ -440,7 +392,7 @@ func parseArgs(ctx context.Context, rawArgs []string) []*query {\n \tfor _, arg := range search.CleanPatterns(rawArgs) {\n \t\tq, err := newQuery(arg)\n \t\tif err != nil {\n-\t\t\tbase.Errorf(\"go get: %v\", err)\n+\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\tcontinue\n \t\t}\n \n@@ -455,11 +407,11 @@ func parseArgs(ctx context.Context, rawArgs []string) []*query {\n \t\t// if the argument has no version and either has no slash or refers to an existing file.\n \t\tif strings.HasSuffix(q.raw, \".go\") && q.rawVersion == \"\" {\n \t\t\tif !strings.Contains(q.raw, \"/\") {\n-\t\t\t\tbase.Errorf(\"go get %s: arguments must be package or module paths\", q.raw)\n+\t\t\t\tbase.Errorf(\"go: %s: arguments must be package or module paths\", q.raw)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif fi, err := os.Stat(q.raw); err == nil && !fi.IsDir() {\n-\t\t\t\tbase.Errorf(\"go get: %s exists as a file, but 'go get' requires package arguments\", q.raw)\n+\t\t\t\tbase.Errorf(\"go: %s exists as a file, but 'go get' requires package arguments\", q.raw)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n@@ -649,7 +601,7 @@ func (r *resolver) matchInModule(ctx context.Context, pattern string, m module.V\n \t\terr      error\n \t}\n \n-\te := r.matchInModuleCache.Do(key{pattern, m}, func() interface{} {\n+\te := r.matchInModuleCache.Do(key{pattern, m}, func() any {\n \t\tmatch := modload.MatchInModule(ctx, pattern, m, imports.AnyTags())\n \t\tif len(match.Errs) > 0 {\n \t\t\treturn entry{match.Pkgs, match.Errs[0]}\n@@ -675,7 +627,9 @@ func (r *resolver) queryNone(ctx context.Context, q *query) {\n \n \tif !q.isWildcard() {\n \t\tq.pathOnce(q.pattern, func() pathSet {\n-\t\t\tif modload.HasModRoot() && q.pattern == modload.Target.Path {\n+\t\t\thasModRoot := modload.HasModRoot()\n+\t\t\tif hasModRoot && modload.MainModules.Contains(q.pattern) {\n+\t\t\t\tv := module.Version{Path: q.pattern}\n \t\t\t\t// The user has explicitly requested to downgrade their own module to\n \t\t\t\t// version \"none\". This is not an entirely unreasonable request: it\n \t\t\t\t// could plausibly mean \u201cdowngrade away everything that depends on any\n@@ -686,7 +640,7 @@ func (r *resolver) queryNone(ctx context.Context, q *query) {\n \t\t\t\t// However, neither of those behaviors would be consistent with the\n \t\t\t\t// plain meaning of the query. To try to reduce confusion, reject the\n \t\t\t\t// query explicitly.\n-\t\t\t\treturn errSet(&modload.QueryMatchesMainModuleError{Pattern: q.pattern, Query: q.version})\n+\t\t\t\treturn errSet(&modload.QueryMatchesMainModulesError{MainModules: []module.Version{v}, Pattern: q.pattern, Query: q.version})\n \t\t\t}\n \n \t\t\treturn pathSet{mod: module.Version{Path: q.pattern, Version: \"none\"}}\n@@ -698,8 +652,8 @@ func (r *resolver) queryNone(ctx context.Context, q *query) {\n \t\t\tcontinue\n \t\t}\n \t\tq.pathOnce(curM.Path, func() pathSet {\n-\t\t\tif modload.HasModRoot() && curM == modload.Target {\n-\t\t\t\treturn errSet(&modload.QueryMatchesMainModuleError{Pattern: q.pattern, Query: q.version})\n+\t\t\tif modload.HasModRoot() && curM.Version == \"\" && modload.MainModules.Contains(curM.Path) {\n+\t\t\t\treturn errSet(&modload.QueryMatchesMainModulesError{MainModules: []module.Version{curM}, Pattern: q.pattern, Query: q.version})\n \t\t\t}\n \t\t\treturn pathSet{mod: module.Version{Path: curM.Path, Version: \"none\"}}\n \t\t})\n@@ -718,28 +672,38 @@ func (r *resolver) performLocalQueries(ctx context.Context) {\n \n \t\t\t// Absolute paths like C:\\foo and relative paths like ../foo... are\n \t\t\t// restricted to matching packages in the main module.\n-\t\t\tpkgPattern := modload.DirImportPath(ctx, q.pattern)\n+\t\t\tpkgPattern, mainModule := modload.MainModules.DirImportPath(ctx, q.pattern)\n \t\t\tif pkgPattern == \".\" {\n-\t\t\t\treturn errSet(fmt.Errorf(\"%s%s is not within module rooted at %s\", q.pattern, absDetail, modload.ModRoot()))\n+\t\t\t\tmodload.MustHaveModRoot()\n+\t\t\t\tvar modRoots []string\n+\t\t\t\tfor _, m := range modload.MainModules.Versions() {\n+\t\t\t\t\tmodRoots = append(modRoots, modload.MainModules.ModRoot(m))\n+\t\t\t\t}\n+\t\t\t\tvar plural string\n+\t\t\t\tif len(modRoots) != 1 {\n+\t\t\t\t\tplural = \"s\"\n+\t\t\t\t}\n+\t\t\t\treturn errSet(fmt.Errorf(\"%s%s is not within module%s rooted at %s\", q.pattern, absDetail, plural, strings.Join(modRoots, \", \")))\n \t\t\t}\n \n-\t\t\tmatch := modload.MatchInModule(ctx, pkgPattern, modload.Target, imports.AnyTags())\n+\t\t\tmatch := modload.MatchInModule(ctx, pkgPattern, mainModule, imports.AnyTags())\n \t\t\tif len(match.Errs) > 0 {\n \t\t\t\treturn pathSet{err: match.Errs[0]}\n \t\t\t}\n \n \t\t\tif len(match.Pkgs) == 0 {\n \t\t\t\tif q.raw == \"\" || q.raw == \".\" {\n-\t\t\t\t\treturn errSet(fmt.Errorf(\"no package in current directory\"))\n+\t\t\t\t\treturn errSet(fmt.Errorf(\"no package to get in current directory\"))\n \t\t\t\t}\n \t\t\t\tif !q.isWildcard() {\n-\t\t\t\t\treturn errSet(fmt.Errorf(\"%s%s is not a package in module rooted at %s\", q.pattern, absDetail, modload.ModRoot()))\n+\t\t\t\t\tmodload.MustHaveModRoot()\n+\t\t\t\t\treturn errSet(fmt.Errorf(\"%s%s is not a package in module rooted at %s\", q.pattern, absDetail, modload.MainModules.ModRoot(mainModule)))\n \t\t\t\t}\n \t\t\t\tsearch.WarnUnmatched([]*search.Match{match})\n \t\t\t\treturn pathSet{}\n \t\t\t}\n \n-\t\t\treturn pathSet{pkgMods: []module.Version{modload.Target}}\n+\t\t\treturn pathSet{pkgMods: []module.Version{mainModule}}\n \t\t})\n \t}\n }\n@@ -789,11 +753,12 @@ func (r *resolver) queryWildcard(ctx context.Context, q *query) {\n \t\t\t\treturn pathSet{}\n \t\t\t}\n \n-\t\t\tif curM.Path == modload.Target.Path && !versionOkForMainModule(q.version) {\n+\t\t\tif modload.MainModules.Contains(curM.Path) && !versionOkForMainModule(q.version) {\n \t\t\t\tif q.matchesPath(curM.Path) {\n-\t\t\t\t\treturn errSet(&modload.QueryMatchesMainModuleError{\n-\t\t\t\t\t\tPattern: q.pattern,\n-\t\t\t\t\t\tQuery:   q.version,\n+\t\t\t\t\treturn errSet(&modload.QueryMatchesMainModulesError{\n+\t\t\t\t\t\tMainModules: []module.Version{curM},\n+\t\t\t\t\t\tPattern:     q.pattern,\n+\t\t\t\t\t\tQuery:       q.version,\n \t\t\t\t\t})\n \t\t\t\t}\n \n@@ -928,7 +893,7 @@ func (r *resolver) checkWildcardVersions(ctx context.Context) {\n \t\t\t\t\t// curM at its original version contains a path matching q.pattern,\n \t\t\t\t\t// but at rev.Version it does not, so (somewhat paradoxically) if\n \t\t\t\t\t// we changed the version of curM it would no longer match the query.\n-\t\t\t\t\tvar version interface{} = m\n+\t\t\t\t\tvar version any = m\n \t\t\t\t\tif rev.Version != q.version {\n \t\t\t\t\t\tversion = fmt.Sprintf(\"%s@%s (%s)\", m.Path, q.version, m.Version)\n \t\t\t\t\t}\n@@ -1159,8 +1124,8 @@ func (r *resolver) loadPackages(ctx context.Context, patterns []string, findPack\n \t}\n \n \topts.AllowPackage = func(ctx context.Context, path string, m module.Version) error {\n-\t\tif m.Path == \"\" || m == modload.Target {\n-\t\t\t// Packages in the standard library and main module are already at their\n+\t\tif m.Path == \"\" || m.Version == \"\" {\n+\t\t\t// Packages in the standard library and main modules are already at their\n \t\t\t// latest (and only) available versions.\n \t\t\treturn nil\n \t\t}\n@@ -1327,7 +1292,7 @@ func (r *resolver) applyUpgrades(ctx context.Context, upgrades []pathSet) (chang\n \tvar tentative []module.Version\n \tfor _, cs := range upgrades {\n \t\tif cs.err != nil {\n-\t\t\tbase.Errorf(\"go get: %v\", cs.err)\n+\t\t\tbase.Errorf(\"go: %v\", cs.err)\n \t\t\tcontinue\n \t\t}\n \n@@ -1370,11 +1335,11 @@ func (r *resolver) disambiguate(cs pathSet) (filtered pathSet, isPackage bool, m\n \t\t\tcontinue\n \t\t}\n \n-\t\tif m.Path == modload.Target.Path {\n-\t\t\tif m.Version == modload.Target.Version {\n+\t\tif modload.MainModules.Contains(m.Path) {\n+\t\t\tif m.Version == \"\" {\n \t\t\t\treturn pathSet{}, true, m, true\n \t\t\t}\n-\t\t\t// The main module can only be set to its own version.\n+\t\t\t// A main module can only be set to its own version.\n \t\t\tcontinue\n \t\t}\n \n@@ -1720,13 +1685,13 @@ func (r *resolver) reportChanges(oldReqs, newReqs []module.Version) {\n \t})\n \tfor _, c := range sortedChanges {\n \t\tif c.old == \"\" {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go get: added %s %s\\n\", c.path, c.new)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: added %s %s\\n\", c.path, c.new)\n \t\t} else if c.new == \"none\" || c.new == \"\" {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go get: removed %s %s\\n\", c.path, c.old)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: removed %s %s\\n\", c.path, c.old)\n \t\t} else if semver.Compare(c.new, c.old) > 0 {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go get: upgraded %s %s => %s\\n\", c.path, c.old, c.new)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: upgraded %s %s => %s\\n\", c.path, c.old, c.new)\n \t\t} else {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go get: downgraded %s %s => %s\\n\", c.path, c.old, c.new)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: downgraded %s %s => %s\\n\", c.path, c.old, c.new)\n \t\t}\n \t}\n \n@@ -1744,10 +1709,11 @@ func (r *resolver) resolve(q *query, m module.Version) {\n \t\tpanic(\"internal error: resolving a module.Version with an empty path\")\n \t}\n \n-\tif m.Path == modload.Target.Path && m.Version != modload.Target.Version {\n-\t\treportError(q, &modload.QueryMatchesMainModuleError{\n-\t\t\tPattern: q.pattern,\n-\t\t\tQuery:   q.version,\n+\tif modload.MainModules.Contains(m.Path) && m.Version != \"\" {\n+\t\treportError(q, &modload.QueryMatchesMainModulesError{\n+\t\t\tMainModules: []module.Version{{Path: m.Path}},\n+\t\t\tPattern:     q.pattern,\n+\t\t\tQuery:       q.version,\n \t\t})\n \t\treturn\n \t}\n@@ -1775,7 +1741,7 @@ func (r *resolver) updateBuildList(ctx context.Context, additions []module.Versi\n \n \tresolved := make([]module.Version, 0, len(r.resolvedVersion))\n \tfor mPath, rv := range r.resolvedVersion {\n-\t\tif mPath != modload.Target.Path {\n+\t\tif !modload.MainModules.Contains(mPath) {\n \t\t\tresolved = append(resolved, module.Version{Path: mPath, Version: rv.version})\n \t\t}\n \t}\n@@ -1784,7 +1750,7 @@ func (r *resolver) updateBuildList(ctx context.Context, additions []module.Versi\n \tif err != nil {\n \t\tvar constraint *modload.ConstraintError\n \t\tif !errors.As(err, &constraint) {\n-\t\t\tbase.Errorf(\"go get: %v\", err)\n+\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\treturn false\n \t\t}\n \n@@ -1796,7 +1762,7 @@ func (r *resolver) updateBuildList(ctx context.Context, additions []module.Versi\n \t\t\treturn rv.reason.ResolvedString(module.Version{Path: m.Path, Version: rv.version})\n \t\t}\n \t\tfor _, c := range constraint.Conflicts {\n-\t\t\tbase.Errorf(\"go get: %v requires %v, not %v\", reason(c.Source), c.Dep, reason(c.Constraint))\n+\t\t\tbase.Errorf(\"go: %v requires %v, not %v\", reason(c.Source), c.Dep, reason(c.Constraint))\n \t\t}\n \t\treturn false\n \t}"}, {"sha": "887cb51b317f7f3c46db33192452197571467a09", "filename": "libgo/go/cmd/go/internal/modget/query.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -192,9 +192,9 @@ func (q *query) validate() error {\n \t\t\t// TODO(bcmills): \"all@none\" seems like a totally reasonable way to\n \t\t\t// request that we remove all module requirements, leaving only the main\n \t\t\t// module and standard library. Perhaps we should implement that someday.\n-\t\t\treturn &modload.QueryMatchesMainModuleError{\n-\t\t\t\tPattern: q.pattern,\n-\t\t\t\tQuery:   q.version,\n+\t\t\treturn &modload.QueryUpgradesAllError{\n+\t\t\t\tMainModules: modload.MainModules.Versions(),\n+\t\t\t\tQuery:       q.version,\n \t\t\t}\n \t\t}\n \t}\n@@ -284,21 +284,21 @@ func reportError(q *query, err error) {\n \tpatternRE := regexp.MustCompile(\"(?m)(?:[ \\t(\\\"`]|^)\" + regexp.QuoteMeta(q.pattern) + \"(?:[ @:;)\\\"`]|$)\")\n \tif patternRE.MatchString(errStr) {\n \t\tif q.rawVersion == \"\" {\n-\t\t\tbase.Errorf(\"go get: %s\", errStr)\n+\t\t\tbase.Errorf(\"go: %s\", errStr)\n \t\t\treturn\n \t\t}\n \n \t\tversionRE := regexp.MustCompile(\"(?m)(?:[ @(\\\"`]|^)\" + regexp.QuoteMeta(q.version) + \"(?:[ :;)\\\"`]|$)\")\n \t\tif versionRE.MatchString(errStr) {\n-\t\t\tbase.Errorf(\"go get: %s\", errStr)\n+\t\t\tbase.Errorf(\"go: %s\", errStr)\n \t\t\treturn\n \t\t}\n \t}\n \n \tif qs := q.String(); qs != \"\" {\n-\t\tbase.Errorf(\"go get %s: %s\", qs, errStr)\n+\t\tbase.Errorf(\"go: %s: %s\", qs, errStr)\n \t} else {\n-\t\tbase.Errorf(\"go get: %s\", errStr)\n+\t\tbase.Errorf(\"go: %s\", errStr)\n \t}\n }\n "}, {"sha": "bfc73cc2f9ab59238da44f0aefd58382295d04ea", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 20, "deletions": 104, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,7 +5,6 @@\n package modload\n \n import (\n-\t\"bytes\"\n \t\"context\"\n \t\"encoding/hex\"\n \t\"errors\"\n@@ -80,7 +79,7 @@ func ModuleInfo(ctx context.Context, path string) *modinfo.ModulePublic {\n \t\tv  string\n \t\tok bool\n \t)\n-\tif rs.depth == lazy {\n+\tif rs.pruning == pruned {\n \t\tv, ok = rs.rootSelected(path)\n \t}\n \tif !ok {\n@@ -212,20 +211,20 @@ func addDeprecation(ctx context.Context, m *modinfo.ModulePublic) {\n // in rs (which may be nil to indicate that m was not loaded from a requirement\n // graph).\n func moduleInfo(ctx context.Context, rs *Requirements, m module.Version, mode ListMode) *modinfo.ModulePublic {\n-\tif m == Target {\n+\tif m.Version == \"\" && MainModules.Contains(m.Path) {\n \t\tinfo := &modinfo.ModulePublic{\n \t\t\tPath:    m.Path,\n \t\t\tVersion: m.Version,\n \t\t\tMain:    true,\n \t\t}\n-\t\tif v, ok := rawGoVersion.Load(Target); ok {\n+\t\tif v, ok := rawGoVersion.Load(m); ok {\n \t\t\tinfo.GoVersion = v.(string)\n \t\t} else {\n \t\t\tpanic(\"internal error: GoVersion not set for main module\")\n \t\t}\n-\t\tif HasModRoot() {\n-\t\t\tinfo.Dir = ModRoot()\n-\t\t\tinfo.GoMod = ModFilePath()\n+\t\tif modRoot := MainModules.ModRoot(m); modRoot != \"\" {\n+\t\t\tinfo.Dir = modRoot\n+\t\t\tinfo.GoMod = modFilePath(modRoot)\n \t\t}\n \t\treturn info\n \t}\n@@ -322,7 +321,7 @@ func moduleInfo(ctx context.Context, rs *Requirements, m module.Version, mode Li\n \t\tif filepath.IsAbs(r.Path) {\n \t\t\tinfo.Replace.Dir = r.Path\n \t\t} else {\n-\t\t\tinfo.Replace.Dir = filepath.Join(ModRoot(), r.Path)\n+\t\t\tinfo.Replace.Dir = filepath.Join(replaceRelativeTo(), r.Path)\n \t\t}\n \t\tinfo.Replace.GoMod = filepath.Join(info.Replace.Dir, \"go.mod\")\n \t}\n@@ -336,116 +335,33 @@ func moduleInfo(ctx context.Context, rs *Requirements, m module.Version, mode Li\n \treturn info\n }\n \n-// PackageBuildInfo returns a string containing module version information\n-// for modules providing packages named by path and deps. path and deps must\n-// name packages that were resolved successfully with LoadPackages.\n-func PackageBuildInfo(path string, deps []string) string {\n-\tif isStandardImportPath(path) || !Enabled() {\n-\t\treturn \"\"\n-\t}\n-\n-\ttarget := mustFindModule(loaded, path, path)\n-\tmdeps := make(map[module.Version]bool)\n-\tfor _, dep := range deps {\n-\t\tif !isStandardImportPath(dep) {\n-\t\t\tmdeps[mustFindModule(loaded, path, dep)] = true\n-\t\t}\n-\t}\n-\tvar mods []module.Version\n-\tdelete(mdeps, target)\n-\tfor mod := range mdeps {\n-\t\tmods = append(mods, mod)\n-\t}\n-\tmodule.Sort(mods)\n-\n-\tvar buf bytes.Buffer\n-\tfmt.Fprintf(&buf, \"path\\t%s\\n\", path)\n-\n-\twriteEntry := func(token string, m module.Version) {\n-\t\tmv := m.Version\n-\t\tif mv == \"\" {\n-\t\t\tmv = \"(devel)\"\n-\t\t}\n-\t\tfmt.Fprintf(&buf, \"%s\\t%s\\t%s\", token, m.Path, mv)\n-\t\tif r := Replacement(m); r.Path == \"\" {\n-\t\t\tfmt.Fprintf(&buf, \"\\t%s\\n\", modfetch.Sum(m))\n-\t\t} else {\n-\t\t\tfmt.Fprintf(&buf, \"\\n=>\\t%s\\t%s\\t%s\\n\", r.Path, r.Version, modfetch.Sum(r))\n-\t\t}\n-\t}\n-\n-\twriteEntry(\"mod\", target)\n-\tfor _, mod := range mods {\n-\t\twriteEntry(\"dep\", mod)\n-\t}\n-\n-\treturn buf.String()\n-}\n-\n-// mustFindModule is like findModule, but it calls base.Fatalf if the\n-// module can't be found.\n-//\n-// TODO(jayconrod): remove this. Callers should use findModule and return\n-// errors instead of relying on base.Fatalf.\n-func mustFindModule(ld *loader, target, path string) module.Version {\n-\tpkg, ok := ld.pkgCache.Get(path).(*loadPkg)\n-\tif ok {\n-\t\tif pkg.err != nil {\n-\t\t\tbase.Fatalf(\"build %v: cannot load %v: %v\", target, path, pkg.err)\n-\t\t}\n-\t\treturn pkg.mod\n-\t}\n-\n-\tif path == \"command-line-arguments\" {\n-\t\treturn Target\n-\t}\n-\n-\tbase.Fatalf(\"build %v: cannot find module for path %v\", target, path)\n-\tpanic(\"unreachable\")\n-}\n-\n // findModule searches for the module that contains the package at path.\n // If the package was loaded, its containing module and true are returned.\n-// Otherwise, module.Version{} and false are returend.\n+// Otherwise, module.Version{} and false are returned.\n func findModule(ld *loader, path string) (module.Version, bool) {\n \tif pkg, ok := ld.pkgCache.Get(path).(*loadPkg); ok {\n \t\treturn pkg.mod, pkg.mod != module.Version{}\n \t}\n-\tif path == \"command-line-arguments\" {\n-\t\treturn Target, true\n-\t}\n \treturn module.Version{}, false\n }\n \n func ModInfoProg(info string, isgccgo bool) []byte {\n-\t// Inject a variable with the debug information as runtime.modinfo,\n-\t// but compile it in package main so that it is specific to the binary.\n-\t// The variable must be a literal so that it will have the correct value\n-\t// before the initializer for package main runs.\n-\t//\n-\t// The runtime startup code refers to the variable, which keeps it live\n-\t// in all binaries.\n-\t//\n-\t// Note: we use an alternate recipe below for gccgo (based on an\n-\t// init function) due to the fact that gccgo does not support\n-\t// applying a \"//go:linkname\" directive to a variable. This has\n-\t// drawbacks in that other packages may want to look at the module\n-\t// info in their init functions (see issue 29628), which won't\n-\t// work for gccgo. See also issue 30344.\n-\n-\tif !isgccgo {\n-\t\treturn []byte(fmt.Sprintf(`package main\n-import _ \"unsafe\"\n-//go:linkname __set_modinfo__ runtime.setmodinfo\n-func __set_modinfo__(string)\n-func init() { __set_modinfo__(%q) }\n-\t`, string(infoStart)+info+string(infoEnd)))\n-\t} else {\n+\t// Inject an init function to set runtime.modinfo.\n+\t// This is only used for gccgo - with gc we hand the info directly to the linker.\n+\t// The init function has the drawback that packages may want to\n+\t// look at the module info in their init functions (see issue 29628),\n+\t// which won't work. See also issue 30344.\n+\tif isgccgo {\n \t\treturn []byte(fmt.Sprintf(`package main\n import _ \"unsafe\"\n //go:linkname __set_debug_modinfo__ runtime.setmodinfo\n func __set_debug_modinfo__(string)\n func init() { __set_debug_modinfo__(%q) }\n-`, string(infoStart)+info+string(infoEnd)))\n+`, ModInfoData(info)))\n \t}\n+\treturn nil\n+}\n+\n+func ModInfoData(info string) []byte {\n+\treturn []byte(string(infoStart) + info + string(infoEnd))\n }"}, {"sha": "6f9072c8c48c395a6a1c44f2fd87f0e77390bbcb", "filename": "libgo/go/cmd/go/internal/modload/buildlist.go", "status": "modified", "additions": 317, "deletions": 140, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -30,18 +30,25 @@ func capVersionSlice(s []module.Version) []module.Version {\n \n // A Requirements represents a logically-immutable set of root module requirements.\n type Requirements struct {\n-\t// depth is the depth at which the requirement graph is computed.\n+\t// pruning is the pruning at which the requirement graph is computed.\n \t//\n-\t// If eager, the graph includes all transitive requirements regardless of depth.\n+\t// If unpruned, the graph includes all transitive requirements regardless\n+\t// of whether the requiring module supports pruning.\n \t//\n-\t// If lazy, the graph includes only the root modules, the explicit\n+\t// If pruned, the graph includes only the root modules, the explicit\n \t// requirements of those root modules, and the transitive requirements of only\n-\t// the *non-lazy* root modules.\n-\tdepth modDepth\n-\n-\t// rootModules is the set of module versions explicitly required by the main\n-\t// module, sorted and capped to length. It may contain duplicates, and may\n-\t// contain multiple versions for a given module path.\n+\t// the root modules that do not support pruning.\n+\t//\n+\t// If workspace, the graph includes only the workspace modules, the explicit\n+\t// requirements of the workspace modules, and the transitive requirements of\n+\t// the workspace modules that do not support pruning.\n+\tpruning modPruning\n+\n+\t// rootModules is the set of root modules of the graph, sorted and capped to\n+\t// length. It may contain duplicates, and may contain multiple versions for a\n+\t// given module path. The root modules of the groph are the set of main\n+\t// modules in workspace mode, and the main module's direct requirements\n+\t// outside workspace mode.\n \trootModules    []module.Version\n \tmaxRootVersion map[string]string\n \n@@ -97,10 +104,23 @@ var requirements *Requirements\n //\n // If vendoring is in effect, the caller must invoke initVendor on the returned\n // *Requirements before any other method.\n-func newRequirements(depth modDepth, rootModules []module.Version, direct map[string]bool) *Requirements {\n+func newRequirements(pruning modPruning, rootModules []module.Version, direct map[string]bool) *Requirements {\n+\tif pruning == workspace {\n+\t\treturn &Requirements{\n+\t\t\tpruning:        pruning,\n+\t\t\trootModules:    capVersionSlice(rootModules),\n+\t\t\tmaxRootVersion: nil,\n+\t\t\tdirect:         direct,\n+\t\t}\n+\t}\n+\n+\tif workFilePath != \"\" && pruning != workspace {\n+\t\tpanic(\"in workspace mode, but pruning is not workspace in newRequirements\")\n+\t}\n+\n \tfor i, m := range rootModules {\n-\t\tif m == Target {\n-\t\t\tpanic(fmt.Sprintf(\"newRequirements called with untrimmed build list: rootModules[%v] is Target\", i))\n+\t\tif m.Version == \"\" && MainModules.Contains(m.Path) {\n+\t\t\tpanic(fmt.Sprintf(\"newRequirements called with untrimmed build list: rootModules[%v] is a main module\", i))\n \t\t}\n \t\tif m.Path == \"\" || m.Version == \"\" {\n \t\t\tpanic(fmt.Sprintf(\"bad requirement: rootModules[%v] = %v\", i, m))\n@@ -114,7 +134,7 @@ func newRequirements(depth modDepth, rootModules []module.Version, direct map[st\n \t}\n \n \trs := &Requirements{\n-\t\tdepth:          depth,\n+\t\tpruning:        pruning,\n \t\trootModules:    capVersionSlice(rootModules),\n \t\tmaxRootVersion: make(map[string]string, len(rootModules)),\n \t\tdirect:         direct,\n@@ -135,13 +155,18 @@ func newRequirements(depth modDepth, rootModules []module.Version, direct map[st\n func (rs *Requirements) initVendor(vendorList []module.Version) {\n \trs.graphOnce.Do(func() {\n \t\tmg := &ModuleGraph{\n-\t\t\tg: mvs.NewGraph(cmpVersion, []module.Version{Target}),\n+\t\t\tg: mvs.NewGraph(cmpVersion, MainModules.Versions()),\n \t\t}\n \n-\t\tif rs.depth == lazy {\n-\t\t\t// The roots of a lazy module should already include every module in the\n-\t\t\t// vendor list, because the vendored modules are the same as those\n-\t\t\t// maintained as roots by the lazy loading \u201cimport invariant\u201d.\n+\t\tif MainModules.Len() != 1 {\n+\t\t\tpanic(\"There should be exactly one main module in Vendor mode.\")\n+\t\t}\n+\t\tmainModule := MainModules.Versions()[0]\n+\n+\t\tif rs.pruning == pruned {\n+\t\t\t// The roots of a pruned module should already include every module in the\n+\t\t\t// vendor list, because the vendored modules are the same as those needed\n+\t\t\t// for graph pruning.\n \t\t\t//\n \t\t\t// Just to be sure, we'll double-check that here.\n \t\t\tinconsistent := false\n@@ -156,9 +181,9 @@ func (rs *Requirements) initVendor(vendorList []module.Version) {\n \t\t\t}\n \n \t\t\t// Now we can treat the rest of the module graph as effectively \u201cpruned\n-\t\t\t// out\u201d, like a more aggressive version of lazy loading: in vendor mode,\n-\t\t\t// the root requirements *are* the complete module graph.\n-\t\t\tmg.g.Require(Target, rs.rootModules)\n+\t\t\t// out\u201d, as though we are viewing the main module from outside: in vendor\n+\t\t\t// mode, the root requirements *are* the complete module graph.\n+\t\t\tmg.g.Require(mainModule, rs.rootModules)\n \t\t} else {\n \t\t\t// The transitive requirements of the main module are not in general available\n \t\t\t// from the vendor directory, and we don't actually know how we got from\n@@ -170,7 +195,7 @@ func (rs *Requirements) initVendor(vendorList []module.Version) {\n \t\t\t// graph, but still distinguishes between direct and indirect\n \t\t\t// dependencies.\n \t\t\tvendorMod := module.Version{Path: \"vendor/modules.txt\", Version: \"\"}\n-\t\t\tmg.g.Require(Target, append(rs.rootModules, vendorMod))\n+\t\t\tmg.g.Require(mainModule, append(rs.rootModules, vendorMod))\n \t\t\tmg.g.Require(vendorMod, vendorList)\n \t\t}\n \n@@ -182,8 +207,8 @@ func (rs *Requirements) initVendor(vendorList []module.Version) {\n // path, or the zero module.Version and ok=false if the module is not a root\n // dependency.\n func (rs *Requirements) rootSelected(path string) (version string, ok bool) {\n-\tif path == Target.Path {\n-\t\treturn Target.Version, true\n+\tif MainModules.Contains(path) {\n+\t\treturn \"\", true\n \t}\n \tif v, ok := rs.maxRootVersion[path]; ok {\n \t\treturn v, true\n@@ -197,7 +222,7 @@ func (rs *Requirements) rootSelected(path string) (version string, ok bool) {\n // selection.\n func (rs *Requirements) hasRedundantRoot() bool {\n \tfor i, m := range rs.rootModules {\n-\t\tif m.Path == Target.Path || (i > 0 && m.Path == rs.rootModules[i-1].Path) {\n+\t\tif MainModules.Contains(m.Path) || (i > 0 && m.Path == rs.rootModules[i-1].Path) {\n \t\t\treturn true\n \t\t}\n \t}\n@@ -214,7 +239,7 @@ func (rs *Requirements) hasRedundantRoot() bool {\n // returns a non-nil error of type *mvs.BuildListError.\n func (rs *Requirements) Graph(ctx context.Context) (*ModuleGraph, error) {\n \trs.graphOnce.Do(func() {\n-\t\tmg, mgErr := readModGraph(ctx, rs.depth, rs.rootModules)\n+\t\tmg, mgErr := readModGraph(ctx, rs.pruning, rs.rootModules)\n \t\trs.graph.Store(cachedGraph{mg, mgErr})\n \t})\n \tcached := rs.graph.Load().(cachedGraph)\n@@ -230,7 +255,7 @@ func (rs *Requirements) IsDirect(path string) bool {\n // A ModuleGraph represents the complete graph of module dependencies\n // of a main module.\n //\n-// If the main module is lazily loaded, the graph does not include\n+// If the main module supports module graph pruning, the graph does not include\n // transitive dependencies of non-root (implicit) dependencies.\n type ModuleGraph struct {\n \tg         *mvs.Graph\n@@ -254,8 +279,16 @@ var readModGraphDebugOnce sync.Once\n //\n // Unlike LoadModGraph, readModGraph does not attempt to diagnose or update\n // inconsistent roots.\n-func readModGraph(ctx context.Context, depth modDepth, roots []module.Version) (*ModuleGraph, error) {\n-\tif depth == lazy {\n+func readModGraph(ctx context.Context, pruning modPruning, roots []module.Version) (*ModuleGraph, error) {\n+\tif pruning == pruned {\n+\t\t// Enable diagnostics for lazy module loading\n+\t\t// (https://golang.org/ref/mod#lazy-loading) only if the module graph is\n+\t\t// pruned.\n+\t\t//\n+\t\t// In unpruned modules,we load the module graph much more aggressively (in\n+\t\t// order to detect inconsistencies that wouldn't be feasible to spot-check),\n+\t\t// so it wouldn't be useful to log when that occurs (because it happens in\n+\t\t// normal operation all the time).\n \t\treadModGraphDebugOnce.Do(func() {\n \t\t\tfor _, f := range strings.Split(os.Getenv(\"GODEBUG\"), \",\") {\n \t\t\t\tswitch f {\n@@ -274,21 +307,26 @@ func readModGraph(ctx context.Context, depth modDepth, roots []module.Version) (\n \t\tmu       sync.Mutex // guards mg.g and hasError during loading\n \t\thasError bool\n \t\tmg       = &ModuleGraph{\n-\t\t\tg: mvs.NewGraph(cmpVersion, []module.Version{Target}),\n+\t\t\tg: mvs.NewGraph(cmpVersion, MainModules.Versions()),\n \t\t}\n \t)\n-\tmg.g.Require(Target, roots)\n+\tif pruning != workspace {\n+\t\tif inWorkspaceMode() {\n+\t\t\tpanic(\"pruning is not workspace in workspace mode\")\n+\t\t}\n+\t\tmg.g.Require(MainModules.mustGetSingleMainModule(), roots)\n+\t}\n \n \tvar (\n-\t\tloadQueue    = par.NewQueue(runtime.GOMAXPROCS(0))\n-\t\tloadingEager sync.Map // module.Version \u2192 nil; the set of modules that have been or are being loaded via eager roots\n+\t\tloadQueue       = par.NewQueue(runtime.GOMAXPROCS(0))\n+\t\tloadingUnpruned sync.Map // module.Version \u2192 nil; the set of modules that have been or are being loaded via roots that do not support pruning\n \t)\n \n \t// loadOne synchronously loads the explicit requirements for module m.\n \t// It does not load the transitive requirements of m even if the go version in\n-\t// m's go.mod file indicates eager loading.\n+\t// m's go.mod file indicates that it supports graph pruning.\n \tloadOne := func(m module.Version) (*modFileSummary, error) {\n-\t\tcached := mg.loadCache.Do(m, func() interface{} {\n+\t\tcached := mg.loadCache.Do(m, func() any {\n \t\t\tsummary, err := goModSummary(m)\n \n \t\t\tmu.Lock()\n@@ -305,16 +343,16 @@ func readModGraph(ctx context.Context, depth modDepth, roots []module.Version) (\n \t\treturn cached.summary, cached.err\n \t}\n \n-\tvar enqueue func(m module.Version, depth modDepth)\n-\tenqueue = func(m module.Version, depth modDepth) {\n+\tvar enqueue func(m module.Version, pruning modPruning)\n+\tenqueue = func(m module.Version, pruning modPruning) {\n \t\tif m.Version == \"none\" {\n \t\t\treturn\n \t\t}\n \n-\t\tif depth == eager {\n-\t\t\tif _, dup := loadingEager.LoadOrStore(m, nil); dup {\n-\t\t\t\t// m has already been enqueued for loading. Since eager loading may\n-\t\t\t\t// follow cycles in the the requirement graph, we need to return early\n+\t\tif pruning == unpruned {\n+\t\t\tif _, dup := loadingUnpruned.LoadOrStore(m, nil); dup {\n+\t\t\t\t// m has already been enqueued for loading. Since unpruned loading may\n+\t\t\t\t// follow cycles in the requirement graph, we need to return early\n \t\t\t\t// to avoid making the load queue infinitely long.\n \t\t\t\treturn\n \t\t\t}\n@@ -326,33 +364,82 @@ func readModGraph(ctx context.Context, depth modDepth, roots []module.Version) (\n \t\t\t\treturn // findError will report the error later.\n \t\t\t}\n \n-\t\t\t// If the version in m's go.mod file implies eager loading, then we cannot\n-\t\t\t// assume that the explicit requirements of m (added by loadOne) are\n-\t\t\t// sufficient to build the packages it contains. We must load its full\n+\t\t\t// If the version in m's go.mod file does not support pruning, then we\n+\t\t\t// cannot assume that the explicit requirements of m (added by loadOne)\n+\t\t\t// are sufficient to build the packages it contains. We must load its full\n \t\t\t// transitive dependency graph to be sure that we see all relevant\n \t\t\t// dependencies.\n-\t\t\tif depth == eager || summary.depth == eager {\n+\t\t\tif pruning != pruned || summary.pruning == unpruned {\n+\t\t\t\tnextPruning := summary.pruning\n+\t\t\t\tif pruning == unpruned {\n+\t\t\t\t\tnextPruning = unpruned\n+\t\t\t\t}\n \t\t\t\tfor _, r := range summary.require {\n-\t\t\t\t\tenqueue(r, eager)\n+\t\t\t\t\tenqueue(r, nextPruning)\n \t\t\t\t}\n \t\t\t}\n \t\t})\n \t}\n \n \tfor _, m := range roots {\n-\t\tenqueue(m, depth)\n+\t\tenqueue(m, pruning)\n \t}\n \t<-loadQueue.Idle()\n \n+\t// Reload any dependencies of the main modules which are not\n+\t// at their selected versions at workspace mode, because the\n+\t// requirements don't accurately reflect the transitive imports.\n+\tif pruning == workspace {\n+\t\t// hasDepsInAll contains the set of modules that need to be loaded\n+\t\t// at workspace pruning because any of their dependencies may\n+\t\t// provide packages in all.\n+\t\thasDepsInAll := make(map[string]bool)\n+\t\tseen := map[module.Version]bool{}\n+\t\tfor _, m := range roots {\n+\t\t\thasDepsInAll[m.Path] = true\n+\t\t\tseen[m] = true\n+\t\t}\n+\t\t// This loop will terminate because it will call enqueue on each version of\n+\t\t// each dependency of the modules in hasDepsInAll at most once (and only\n+\t\t// calls enqueue on successively increasing versions of each dependency).\n+\t\tfor {\n+\t\t\tneedsEnqueueing := map[module.Version]bool{}\n+\t\t\tfor p := range hasDepsInAll {\n+\t\t\t\tm := module.Version{Path: p, Version: mg.g.Selected(p)}\n+\t\t\t\treqs, ok := mg.g.RequiredBy(m)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tneedsEnqueueing[m] = true\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tfor _, r := range reqs {\n+\t\t\t\t\ts := module.Version{Path: r.Path, Version: mg.g.Selected(r.Path)}\n+\t\t\t\t\tif cmpVersion(s.Version, r.Version) > 0 && !seen[s] {\n+\t\t\t\t\t\tneedsEnqueueing[s] = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// add all needs enqueueing to paths we care about\n+\t\t\tif len(needsEnqueueing) == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tfor p := range needsEnqueueing {\n+\t\t\t\tenqueue(p, workspace)\n+\t\t\t\tseen[p] = true\n+\t\t\t\thasDepsInAll[p.Path] = true\n+\t\t\t}\n+\t\t\t<-loadQueue.Idle()\n+\t\t}\n+\t}\n+\n \tif hasError {\n \t\treturn mg, mg.findError()\n \t}\n \treturn mg, nil\n }\n \n // RequiredBy returns the dependencies required by module m in the graph,\n-// or ok=false if module m's dependencies are not relevant (such as if they\n-// are pruned out by lazy loading).\n+// or ok=false if module m's dependencies are pruned out.\n //\n // The caller must not modify the returned slice, but may safely append to it\n // and may rely on it not to be modified.\n@@ -404,7 +491,12 @@ func (mg *ModuleGraph) findError() error {\n }\n \n func (mg *ModuleGraph) allRootsSelected() bool {\n-\troots, _ := mg.g.RequiredBy(Target)\n+\tvar roots []module.Version\n+\tif inWorkspaceMode() {\n+\t\troots = MainModules.Versions()\n+\t} else {\n+\t\troots, _ = mg.g.RequiredBy(MainModules.mustGetSingleMainModule())\n+\t}\n \tfor _, m := range roots {\n \t\tif mg.Selected(m.Path) != m.Version {\n \t\t\treturn false\n@@ -427,12 +519,12 @@ func LoadModGraph(ctx context.Context, goVersion string) *ModuleGraph {\n \trs := LoadModFile(ctx)\n \n \tif goVersion != \"\" {\n-\t\tdepth := modDepthFromGoVersion(goVersion)\n-\t\tif depth == eager && rs.depth != eager {\n+\t\tpruning := pruningForGoVersion(goVersion)\n+\t\tif pruning == unpruned && rs.pruning != unpruned {\n \t\t\t// Use newRequirements instead of convertDepth because convertDepth\n \t\t\t// also updates roots; here, we want to report the unmodified roots\n \t\t\t// even though they may seem inconsistent.\n-\t\t\trs = newRequirements(eager, rs.rootModules, rs.direct)\n+\t\t\trs = newRequirements(unpruned, rs.rootModules, rs.direct)\n \t\t}\n \n \t\tmg, err := rs.Graph(ctx)\n@@ -447,17 +539,17 @@ func LoadModGraph(ctx context.Context, goVersion string) *ModuleGraph {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\trequirements = rs\n+\n \treturn mg\n }\n \n // expandGraph loads the complete module graph from rs.\n //\n // If the complete graph reveals that some root of rs is not actually the\n // selected version of its path, expandGraph computes a new set of roots that\n-// are consistent. (When lazy loading is implemented, this may result in\n-// upgrades to other modules due to requirements that were previously pruned\n-// out.)\n+// are consistent. (With a pruned module graph, this may result in upgrades to\n+// other modules due to requirements that were previously pruned out.)\n //\n // expandGraph returns the updated roots, along with the module graph loaded\n // from those roots and any error encountered while loading that graph.\n@@ -473,9 +565,9 @@ func expandGraph(ctx context.Context, rs *Requirements) (*Requirements, *ModuleG\n \n \tif !mg.allRootsSelected() {\n \t\t// The roots of rs are not consistent with the rest of the graph. Update\n-\t\t// them. In an eager module this is a no-op for the build list as a whole \u2014\n+\t\t// them. In an unpruned module this is a no-op for the build list as a whole \u2014\n \t\t// it just promotes what were previously transitive requirements to be\n-\t\t// roots \u2014 but in a lazy module it may pull in previously-irrelevant\n+\t\t// roots \u2014 but in a pruned module it may pull in previously-irrelevant\n \t\t// transitive dependencies.\n \n \t\tnewRS, rsErr := updateRoots(ctx, rs.direct, rs, nil, nil, false)\n@@ -513,7 +605,7 @@ func EditBuildList(ctx context.Context, add, mustSelect []module.Version) (chang\n \tif err != nil {\n \t\treturn false, err\n \t}\n-\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\trequirements = rs\n \treturn changed, err\n }\n \n@@ -544,40 +636,62 @@ type Conflict struct {\n \n // tidyRoots trims the root dependencies to the minimal requirements needed to\n // both retain the same versions of all packages in pkgs and satisfy the\n-// lazy loading invariants (if applicable).\n+// graph-pruning invariants (if applicable).\n func tidyRoots(ctx context.Context, rs *Requirements, pkgs []*loadPkg) (*Requirements, error) {\n-\tif rs.depth == eager {\n-\t\treturn tidyEagerRoots(ctx, rs.direct, pkgs)\n+\tmainModule := MainModules.mustGetSingleMainModule()\n+\tif rs.pruning == unpruned {\n+\t\treturn tidyUnprunedRoots(ctx, mainModule, rs.direct, pkgs)\n \t}\n-\treturn tidyLazyRoots(ctx, rs.direct, pkgs)\n+\treturn tidyPrunedRoots(ctx, mainModule, rs.direct, pkgs)\n }\n \n func updateRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error) {\n-\tif rs.depth == eager {\n-\t\treturn updateEagerRoots(ctx, direct, rs, add)\n+\tswitch rs.pruning {\n+\tcase unpruned:\n+\t\treturn updateUnprunedRoots(ctx, direct, rs, add)\n+\tcase pruned:\n+\t\treturn updatePrunedRoots(ctx, direct, rs, pkgs, add, rootsImported)\n+\tcase workspace:\n+\t\treturn updateWorkspaceRoots(ctx, rs, add)\n+\tdefault:\n+\t\tpanic(fmt.Sprintf(\"unsupported pruning mode: %v\", rs.pruning))\n+\t}\n+}\n+\n+func updateWorkspaceRoots(ctx context.Context, rs *Requirements, add []module.Version) (*Requirements, error) {\n+\tif len(add) != 0 {\n+\t\t// add should be empty in workspace mode because workspace mode implies\n+\t\t// -mod=readonly, which in turn implies no new requirements. The code path\n+\t\t// that would result in add being non-empty returns an error before it\n+\t\t// reaches this point: The set of modules to add comes from\n+\t\t// resolveMissingImports, which in turn resolves each package by calling\n+\t\t// queryImport. But queryImport explicitly checks for -mod=readonly, and\n+\t\t// return an error.\n+\t\tpanic(\"add is not empty\")\n \t}\n-\treturn updateLazyRoots(ctx, direct, rs, pkgs, add, rootsImported)\n+\treturn rs, nil\n }\n \n-// tidyLazyRoots returns a minimal set of root requirements that maintains the\n-// \"lazy loading\" invariants of the go.mod file for the given packages:\n+// tidyPrunedRoots returns a minimal set of root requirements that maintains the\n+// invariants of the go.mod file needed to support graph pruning for the given\n+// packages:\n //\n // \t1. For each package marked with pkgInAll, the module path that provided that\n // \t   package is included as a root.\n // \t2. For all packages, the module that provided that package either remains\n // \t   selected at the same version or is upgraded by the dependencies of a\n // \t   root.\n //\n-// If any module that provided a package has been upgraded above its previous,\n+// If any module that provided a package has been upgraded above its previous\n // version, the caller may need to reload and recompute the package graph.\n //\n // To ensure that the loading process eventually converges, the caller should\n // add any needed roots from the tidy root set (without removing existing untidy\n // roots) until the set of roots has converged.\n-func tidyLazyRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg) (*Requirements, error) {\n+func tidyPrunedRoots(ctx context.Context, mainModule module.Version, direct map[string]bool, pkgs []*loadPkg) (*Requirements, error) {\n \tvar (\n \t\troots        []module.Version\n-\t\tpathIncluded = map[string]bool{Target.Path: true}\n+\t\tpathIncluded = map[string]bool{mainModule.Path: true}\n \t)\n \t// We start by adding roots for every package in \"all\".\n \t//\n@@ -605,7 +719,7 @@ func tidyLazyRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg)\n \t\tqueued[pkg] = true\n \t}\n \tmodule.Sort(roots)\n-\ttidy := newRequirements(lazy, roots, direct)\n+\ttidy := newRequirements(pruned, roots, direct)\n \n \tfor len(queue) > 0 {\n \t\troots = tidy.rootModules\n@@ -641,7 +755,7 @@ func tidyLazyRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg)\n \n \t\tif len(roots) > len(tidy.rootModules) {\n \t\t\tmodule.Sort(roots)\n-\t\t\ttidy = newRequirements(lazy, roots, tidy.direct)\n+\t\t\ttidy = newRequirements(pruned, roots, tidy.direct)\n \t\t}\n \t}\n \n@@ -652,8 +766,8 @@ func tidyLazyRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg)\n \treturn tidy, nil\n }\n \n-// updateLazyRoots returns a set of root requirements that maintains the \u201clazy\n-// loading\u201d invariants of the go.mod file:\n+// updatePrunedRoots returns a set of root requirements that maintains the\n+// invariants of the go.mod file needed to support graph pruning:\n //\n // \t1. The selected version of the module providing each package marked with\n // \t   either pkgInAll or pkgIsRoot is included as a root.\n@@ -670,7 +784,7 @@ func tidyLazyRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg)\n // The packages in pkgs are assumed to have been loaded from either the roots of\n // rs or the modules selected in the graph of rs.\n //\n-// The above invariants together imply the \u201clazy loading\u201d invariants for the\n+// The above invariants together imply the graph-pruning invariants for the\n // go.mod file:\n //\n // \t1. (The import invariant.) Every module that provides a package transitively\n@@ -690,13 +804,13 @@ func tidyLazyRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg)\n // \t   it requires explicitly. This invariant is left up to the caller, who must\n // \t   not load packages from outside the module graph but may add roots to the\n // \t   graph, but is facilited by (3). If the caller adds roots to the graph in\n-// \t   order to resolve missing packages, then updateLazyRoots will retain them,\n+// \t   order to resolve missing packages, then updatePrunedRoots will retain them,\n // \t   the selected versions of those roots cannot regress, and they will\n // \t   eventually be written back to the main module's go.mod file.\n //\n // (See https://golang.org/design/36460-lazy-module-loading#invariants for more\n // detail.)\n-func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error) {\n+func updatePrunedRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error) {\n \troots := rs.rootModules\n \trootsUpgraded := false\n \n@@ -717,11 +831,11 @@ func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requiremen\n \t\t\t// pkg is transitively imported by a package or test in the main module.\n \t\t\t// We need to promote the module that maintains it to a root: if some\n \t\t\t// other module depends on the main module, and that other module also\n-\t\t\t// uses lazy loading, it will expect to find all of our transitive\n-\t\t\t// dependencies by reading just our go.mod file, not the go.mod files of\n-\t\t\t// everything we depend on.\n+\t\t\t// uses a pruned module graph, it will expect to find all of our\n+\t\t\t// transitive dependencies by reading just our go.mod file, not the go.mod\n+\t\t\t// files of everything we depend on.\n \t\t\t//\n-\t\t\t// (This is the \u201cimport invariant\u201d that makes lazy loading possible.)\n+\t\t\t// (This is the \u201cimport invariant\u201d that makes graph pruning possible.)\n \n \t\tcase rootsImported && pkg.flags.has(pkgFromRoot):\n \t\t\t// pkg is a transitive dependency of some root, and we are treating the\n@@ -732,17 +846,18 @@ func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requiremen\n \t\t\t// it matches a command-line argument.) We want future invocations of the\n \t\t\t// 'go' command \u2014 such as 'go test' on the same package \u2014 to continue to\n \t\t\t// use the same versions of its dependencies that we are using right now.\n-\t\t\t// So we need to bring this package's dependencies inside the lazy-loading\n-\t\t\t// horizon.\n+\t\t\t// So we need to bring this package's dependencies inside the pruned\n+\t\t\t// module graph.\n \t\t\t//\n \t\t\t// Making the module containing this package a root of the module graph\n-\t\t\t// does exactly that: if the module containing the package is lazy it\n-\t\t\t// should satisfy the import invariant itself, so all of its dependencies\n-\t\t\t// should be in its go.mod file, and if the module containing the package\n-\t\t\t// is eager then if we make it a root we will load all of its transitive\n-\t\t\t// dependencies into the module graph.\n+\t\t\t// does exactly that: if the module containing the package supports graph\n+\t\t\t// pruning then it should satisfy the import invariant itself, so all of\n+\t\t\t// its dependencies should be in its go.mod file, and if the module\n+\t\t\t// containing the package does not support pruning then if we make it a\n+\t\t\t// root we will load all of its (unpruned) transitive dependencies into\n+\t\t\t// the module graph.\n \t\t\t//\n-\t\t\t// (This is the \u201cargument invariant\u201d of lazy loading, and is important for\n+\t\t\t// (This is the \u201cargument invariant\u201d, and is important for\n \t\t\t// reproducibility.)\n \n \t\tdefault:\n@@ -807,16 +922,15 @@ func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requiremen\n \t\t\t// We've added or upgraded one or more roots, so load the full module\n \t\t\t// graph so that we can update those roots to be consistent with other\n \t\t\t// requirements.\n-\t\t\tif cfg.BuildMod != \"mod\" {\n+\t\t\tif mustHaveCompleteRequirements() {\n \t\t\t\t// Our changes to the roots may have moved dependencies into or out of\n-\t\t\t\t// the lazy-loading horizon, which could in turn change the selected\n-\t\t\t\t// versions of other modules. (Unlike for eager modules, for lazy\n-\t\t\t\t// modules adding or removing an explicit root is a semantic change, not\n-\t\t\t\t// just a cosmetic one.)\n+\t\t\t\t// the graph-pruning horizon, which could in turn change the selected\n+\t\t\t\t// versions of other modules. (For pruned modules adding or removing an\n+\t\t\t\t// explicit root is a semantic change, not just a cosmetic one.)\n \t\t\t\treturn rs, errGoModDirty\n \t\t\t}\n \n-\t\t\trs = newRequirements(lazy, roots, direct)\n+\t\t\trs = newRequirements(pruned, roots, direct)\n \t\t\tvar err error\n \t\t\tmg, err = rs.Graph(ctx)\n \t\t\tif err != nil {\n@@ -831,7 +945,7 @@ func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requiremen\n \t\t\tif rs.graph.Load() != nil {\n \t\t\t\t// We've already loaded the full module graph, which includes the\n \t\t\t\t// requirements of all of the root modules \u2014 even the transitive\n-\t\t\t\t// requirements, if they are eager!\n+\t\t\t\t// requirements, if they are unpruned!\n \t\t\t\tmg, _ = rs.Graph(ctx)\n \t\t\t} else if cfg.BuildMod == \"vendor\" {\n \t\t\t\t// We can't spot-check the requirements of other modules because we\n@@ -855,7 +969,9 @@ func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requiremen\n \t\troots = make([]module.Version, 0, len(rs.rootModules))\n \t\trootsUpgraded = false\n \t\tinRootPaths := make(map[string]bool, len(rs.rootModules)+1)\n-\t\tinRootPaths[Target.Path] = true\n+\t\tfor _, mm := range MainModules.Versions() {\n+\t\t\tinRootPaths[mm.Path] = true\n+\t\t}\n \t\tfor _, m := range rs.rootModules {\n \t\t\tif inRootPaths[m.Path] {\n \t\t\t\t// This root specifies a redundant path. We already retained the\n@@ -908,12 +1024,12 @@ func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requiremen\n \t\t}\n \t}\n \n-\tif rs.depth == lazy && reflect.DeepEqual(roots, rs.rootModules) && reflect.DeepEqual(direct, rs.direct) {\n-\t\t// The root set is unchanged and rs was already lazy, so keep rs to\n+\tif rs.pruning == pruned && reflect.DeepEqual(roots, rs.rootModules) && reflect.DeepEqual(direct, rs.direct) {\n+\t\t// The root set is unchanged and rs was already pruned, so keep rs to\n \t\t// preserve its cached ModuleGraph (if any).\n \t\treturn rs, nil\n \t}\n-\treturn newRequirements(lazy, roots, direct), nil\n+\treturn newRequirements(pruned, roots, direct), nil\n }\n \n // spotCheckRoots reports whether the versions of the roots in rs satisfy the\n@@ -955,17 +1071,37 @@ func spotCheckRoots(ctx context.Context, rs *Requirements, mods map[module.Versi\n \treturn true\n }\n \n-// tidyEagerRoots returns a minimal set of root requirements that maintains the\n-// selected version of every module that provided a package in pkgs, and\n-// includes the selected version of every such module in direct as a root.\n-func tidyEagerRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg) (*Requirements, error) {\n+// tidyUnprunedRoots returns a minimal set of root requirements that maintains\n+// the selected version of every module that provided or lexically could have\n+// provided a package in pkgs, and includes the selected version of every such\n+// module in direct as a root.\n+func tidyUnprunedRoots(ctx context.Context, mainModule module.Version, direct map[string]bool, pkgs []*loadPkg) (*Requirements, error) {\n \tvar (\n+\t\t// keep is a set of of modules that provide packages or are needed to\n+\t\t// disambiguate imports.\n \t\tkeep     []module.Version\n \t\tkeptPath = map[string]bool{}\n-\t)\n-\tvar (\n-\t\trootPaths   []string // module paths that should be included as roots\n+\n+\t\t// rootPaths is a list of module paths that provide packages directly\n+\t\t// imported from the main module. They should be included as roots.\n+\t\trootPaths   []string\n \t\tinRootPaths = map[string]bool{}\n+\n+\t\t// altMods is a set of paths of modules that lexically could have provided\n+\t\t// imported packages. It may be okay to remove these from the list of\n+\t\t// explicit requirements if that removes them from the module graph. If they\n+\t\t// are present in the module graph reachable from rootPaths, they must not\n+\t\t// be at a lower version. That could cause a missing sum error or a new\n+\t\t// import ambiguity.\n+\t\t//\n+\t\t// For example, suppose a developer rewrites imports from example.com/m to\n+\t\t// example.com/m/v2, then runs 'go mod tidy'. Tidy may delete the\n+\t\t// requirement on example.com/m if there is no other transitive requirement\n+\t\t// on it. However, if example.com/m were downgraded to a version not in\n+\t\t// go.sum, when package example.com/m/v2/p is loaded, we'd get an error\n+\t\t// trying to disambiguate the import, since we can't check example.com/m\n+\t\t// without its sum. See #47738.\n+\t\taltMods = map[string]string{}\n \t)\n \tfor _, pkg := range pkgs {\n \t\tif !pkg.fromExternalModule() {\n@@ -979,16 +1115,48 @@ func tidyEagerRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg\n \t\t\t\tinRootPaths[m.Path] = true\n \t\t\t}\n \t\t}\n+\t\tfor _, m := range pkg.altMods {\n+\t\t\taltMods[m.Path] = m.Version\n+\t\t}\n \t}\n \n-\tmin, err := mvs.Req(Target, rootPaths, &mvsReqs{roots: keep})\n+\t// Construct a build list with a minimal set of roots.\n+\t// This may remove or downgrade modules in altMods.\n+\treqs := &mvsReqs{roots: keep}\n+\tmin, err := mvs.Req(mainModule, rootPaths, reqs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn newRequirements(eager, min, direct), nil\n+\tbuildList, err := mvs.BuildList([]module.Version{mainModule}, reqs)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Check if modules in altMods were downgraded but not removed.\n+\t// If so, add them to roots, which will retain an \"// indirect\" requirement\n+\t// in go.mod. See comment on altMods above.\n+\tkeptAltMod := false\n+\tfor _, m := range buildList {\n+\t\tif v, ok := altMods[m.Path]; ok && semver.Compare(m.Version, v) < 0 {\n+\t\t\tkeep = append(keep, module.Version{Path: m.Path, Version: v})\n+\t\t\tkeptAltMod = true\n+\t\t}\n+\t}\n+\tif keptAltMod {\n+\t\t// We must run mvs.Req again instead of simply adding altMods to min.\n+\t\t// It's possible that a requirement in altMods makes some other\n+\t\t// explicit indirect requirement unnecessary.\n+\t\treqs.roots = keep\n+\t\tmin, err = mvs.Req(mainModule, rootPaths, reqs)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn newRequirements(unpruned, min, direct), nil\n }\n \n-// updateEagerRoots returns a set of root requirements that includes the selected\n+// updateUnprunedRoots returns a set of root requirements that includes the selected\n // version of every module path in direct as a root, and maintains the selected\n // version of every module selected in the graph of rs.\n //\n@@ -1002,7 +1170,7 @@ func tidyEagerRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg\n // \t   by a dependency in add.\n // \t4. Every version in add is selected at its given version unless upgraded by\n // \t   (the dependencies of) an existing root or another module in add.\n-func updateEagerRoots(ctx context.Context, direct map[string]bool, rs *Requirements, add []module.Version) (*Requirements, error) {\n+func updateUnprunedRoots(ctx context.Context, direct map[string]bool, rs *Requirements, add []module.Version) (*Requirements, error) {\n \tmg, err := rs.Graph(ctx)\n \tif err != nil {\n \t\t// We can't ignore errors in the module graph even if the user passed the -e\n@@ -1011,7 +1179,7 @@ func updateEagerRoots(ctx context.Context, direct map[string]bool, rs *Requireme\n \t\treturn rs, err\n \t}\n \n-\tif cfg.BuildMod != \"mod\" {\n+\tif mustHaveCompleteRequirements() {\n \t\t// Instead of actually updating the requirements, just check that no updates\n \t\t// are needed.\n \t\tif rs == nil {\n@@ -1067,55 +1235,64 @@ func updateEagerRoots(ctx context.Context, direct map[string]bool, rs *Requireme\n \n \t// \u201cThe selected version of every module path in direct is included as a root.\u201d\n \t//\n-\t// This is only for convenience and clarity for end users: in an eager module,\n+\t// This is only for convenience and clarity for end users: in an unpruned module,\n \t// the choice of explicit vs. implicit dependency has no impact on MVS\n \t// selection (for itself or any other module).\n-\tkeep := append(mg.BuildList()[1:], add...)\n+\tkeep := append(mg.BuildList()[MainModules.Len():], add...)\n \tfor _, m := range keep {\n \t\tif direct[m.Path] && !inRootPaths[m.Path] {\n \t\t\trootPaths = append(rootPaths, m.Path)\n \t\t\tinRootPaths[m.Path] = true\n \t\t}\n \t}\n \n-\tmin, err := mvs.Req(Target, rootPaths, &mvsReqs{roots: keep})\n-\tif err != nil {\n-\t\treturn rs, err\n+\tvar roots []module.Version\n+\tfor _, mainModule := range MainModules.Versions() {\n+\t\tmin, err := mvs.Req(mainModule, rootPaths, &mvsReqs{roots: keep})\n+\t\tif err != nil {\n+\t\t\treturn rs, err\n+\t\t}\n+\t\troots = append(roots, min...)\n \t}\n-\tif rs.depth == eager && reflect.DeepEqual(min, rs.rootModules) && reflect.DeepEqual(direct, rs.direct) {\n-\t\t// The root set is unchanged and rs was already eager, so keep rs to\n+\tif MainModules.Len() > 1 {\n+\t\tmodule.Sort(roots)\n+\t}\n+\tif rs.pruning == unpruned && reflect.DeepEqual(roots, rs.rootModules) && reflect.DeepEqual(direct, rs.direct) {\n+\t\t// The root set is unchanged and rs was already unpruned, so keep rs to\n \t\t// preserve its cached ModuleGraph (if any).\n \t\treturn rs, nil\n \t}\n-\treturn newRequirements(eager, min, direct), nil\n+\n+\treturn newRequirements(unpruned, roots, direct), nil\n }\n \n-// convertDepth returns a version of rs with the given depth.\n-// If rs already has the given depth, convertDepth returns rs unmodified.\n-func convertDepth(ctx context.Context, rs *Requirements, depth modDepth) (*Requirements, error) {\n-\tif rs.depth == depth {\n+// convertPruning returns a version of rs with the given pruning behavior.\n+// If rs already has the given pruning, convertPruning returns rs unmodified.\n+func convertPruning(ctx context.Context, rs *Requirements, pruning modPruning) (*Requirements, error) {\n+\tif rs.pruning == pruning {\n \t\treturn rs, nil\n+\t} else if rs.pruning == workspace || pruning == workspace {\n+\t\tpanic(\"attempthing to convert to/from workspace pruning and another pruning type\")\n \t}\n \n-\tif depth == eager {\n-\t\t// We are converting a lazy module to an eager one. The roots of an eager\n-\t\t// module graph are a superset of the roots of a lazy graph, so we don't\n-\t\t// need to add any new roots \u2014 we just need to prune away the ones that are\n-\t\t// redundant given eager loading, which is exactly what updateEagerRoots\n-\t\t// does.\n-\t\treturn updateEagerRoots(ctx, rs.direct, rs, nil)\n+\tif pruning == unpruned {\n+\t\t// We are converting a pruned module to an unpruned one. The roots of a\n+\t\t// ppruned module graph are a superset of the roots of an unpruned one, so\n+\t\t// we don't need to add any new roots \u2014 we just need to drop the ones that\n+\t\t// are redundant, which is exactly what updateUnprunedRoots does.\n+\t\treturn updateUnprunedRoots(ctx, rs.direct, rs, nil)\n \t}\n \n-\t// We are converting an eager module to a lazy one. The module graph of an\n-\t// eager module includes the transitive dependencies of every module in the\n-\t// build list.\n+\t// We are converting an unpruned module to a pruned one.\n \t//\n-\t// Hey, we can express that as a lazy root set! \u201cInclude the transitive\n-\t// dependencies of every module in the build list\u201d is exactly what happens in\n-\t// a lazy module if we promote every module in the build list to a root!\n+\t// An unpruned module graph includes the transitive dependencies of every\n+\t// module in the build list. As it turns out, we can express that as a pruned\n+\t// root set! \u201cInclude the transitive dependencies of every module in the build\n+\t// list\u201d is exactly what happens in a pruned module if we promote every module\n+\t// in the build list to a root.\n \tmg, err := rs.Graph(ctx)\n \tif err != nil {\n \t\treturn rs, err\n \t}\n-\treturn newRequirements(lazy, mg.BuildList()[1:], rs.direct), nil\n+\treturn newRequirements(pruned, mg.BuildList()[MainModules.Len():], rs.direct), nil\n }"}, {"sha": "0f37e3b2e94773e983fc70f161ea2c768d759833", "filename": "libgo/go/cmd/go/internal/modload/edit.go", "status": "modified", "additions": 84, "deletions": 80, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -21,7 +21,7 @@ import (\n // \t2. Each module version in tryUpgrade is upgraded toward the indicated\n // \t   version as far as can be done without violating (1).\n //\n-// \t3. Each module version in rs.rootModules (or rs.graph, if rs.depth is eager)\n+// \t3. Each module version in rs.rootModules (or rs.graph, if rs is unpruned)\n // \t   is downgraded from its original version only to the extent needed to\n // \t   satisfy (1), or upgraded only to the extent needed to satisfy (1) and\n // \t   (2).\n@@ -69,13 +69,14 @@ func editRequirements(ctx context.Context, rs *Requirements, tryUpgrade, mustSel\n \t}\n \n \tvar roots []module.Version\n-\tif rs.depth == eager {\n-\t\t// In an eager module, modules that provide packages imported by the main\n-\t\t// module may either be explicit roots or implicit transitive dependencies.\n-\t\t// We promote the modules in mustSelect to be explicit requirements.\n+\tif rs.pruning == unpruned {\n+\t\t// In a module without graph pruning, modules that provide packages imported\n+\t\t// by the main module may either be explicit roots or implicit transitive\n+\t\t// dependencies. We promote the modules in mustSelect to be explicit\n+\t\t// requirements.\n \t\tvar rootPaths []string\n \t\tfor _, m := range mustSelect {\n-\t\t\tif m.Version != \"none\" && m.Path != Target.Path {\n+\t\t\tif m.Version != \"none\" && !MainModules.Contains(m.Path) {\n \t\t\t\trootPaths = append(rootPaths, m.Path)\n \t\t\t}\n \t\t}\n@@ -97,13 +98,13 @@ func editRequirements(ctx context.Context, rs *Requirements, tryUpgrade, mustSel\n \t\t\t}\n \t\t}\n \n-\t\troots, err = mvs.Req(Target, rootPaths, &mvsReqs{roots: mods})\n+\t\troots, err = mvs.Req(MainModules.mustGetSingleMainModule(), rootPaths, &mvsReqs{roots: mods})\n \t\tif err != nil {\n \t\t\treturn nil, false, err\n \t\t}\n \t} else {\n-\t\t// In a lazy module, every module that provides a package imported by the\n-\t\t// main module must be retained as a root.\n+\t\t// In a module with a pruned graph, every module that provides a package\n+\t\t// imported by the main module must be retained as a root.\n \t\troots = mods\n \t\tif !changed {\n \t\t\t// Because the roots we just computed are unchanged, the entire graph must\n@@ -126,7 +127,7 @@ func editRequirements(ctx context.Context, rs *Requirements, tryUpgrade, mustSel\n \t\t\tdirect[m.Path] = true\n \t\t}\n \t}\n-\treturn newRequirements(rs.depth, roots, direct), changed, nil\n+\treturn newRequirements(rs.pruning, roots, direct), changed, nil\n }\n \n // limiterForEdit returns a versionLimiter with its max versions set such that\n@@ -149,11 +150,12 @@ func limiterForEdit(ctx context.Context, rs *Requirements, tryUpgrade, mustSelec\n \t\t}\n \t}\n \n-\tif rs.depth == eager {\n-\t\t// Eager go.mod files don't indicate which transitive dependencies are\n-\t\t// actually relevant to the main module, so we have to assume that any module\n-\t\t// that could have provided any package \u2014 that is, any module whose selected\n-\t\t// version was not \"none\" \u2014 may be relevant.\n+\tif rs.pruning == unpruned {\n+\t\t// go.mod files that do not support graph pruning don't indicate which\n+\t\t// transitive dependencies are actually relevant to the main module, so we\n+\t\t// have to assume that any module that could have provided any package \u2014\n+\t\t// that is, any module whose selected version was not \"none\" \u2014 may be\n+\t\t// relevant.\n \t\tfor _, m := range mg.BuildList() {\n \t\t\trestrictTo(m)\n \t\t}\n@@ -175,7 +177,7 @@ func limiterForEdit(ctx context.Context, rs *Requirements, tryUpgrade, mustSelec\n \t\t}\n \t}\n \n-\tif err := raiseLimitsForUpgrades(ctx, maxVersion, rs.depth, tryUpgrade, mustSelect); err != nil {\n+\tif err := raiseLimitsForUpgrades(ctx, maxVersion, rs.pruning, tryUpgrade, mustSelect); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -185,7 +187,7 @@ func limiterForEdit(ctx context.Context, rs *Requirements, tryUpgrade, mustSelec\n \t\trestrictTo(m)\n \t}\n \n-\treturn newVersionLimiter(rs.depth, maxVersion), nil\n+\treturn newVersionLimiter(rs.pruning, maxVersion), nil\n }\n \n // raiseLimitsForUpgrades increases the module versions in maxVersions to the\n@@ -195,12 +197,12 @@ func limiterForEdit(ctx context.Context, rs *Requirements, tryUpgrade, mustSelec\n //\n // Versions not present in maxVersion are unrestricted, and it is assumed that\n // they will not be promoted to root requirements (and thus will not contribute\n-// their own dependencies if the main module is lazy).\n+// their own dependencies if the main module supports graph pruning).\n //\n // These limits provide an upper bound on how far a module may be upgraded as\n // part of an incidental downgrade, if downgrades are needed in order to select\n // the versions in mustSelect.\n-func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, depth modDepth, tryUpgrade []module.Version, mustSelect []module.Version) error {\n+func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, pruning modPruning, tryUpgrade []module.Version, mustSelect []module.Version) error {\n \t// allow raises the limit for m.Path to at least m.Version.\n \t// If m.Path was already unrestricted, it remains unrestricted.\n \tallow := func(m module.Version) {\n@@ -214,21 +216,21 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t}\n \n \tvar (\n-\t\teagerUpgrades  []module.Version\n-\t\tisLazyRootPath map[string]bool\n+\t\tunprunedUpgrades []module.Version\n+\t\tisPrunedRootPath map[string]bool\n \t)\n-\tif depth == eager {\n-\t\teagerUpgrades = tryUpgrade\n+\tif pruning == unpruned {\n+\t\tunprunedUpgrades = tryUpgrade\n \t} else {\n-\t\tisLazyRootPath = make(map[string]bool, len(maxVersion))\n+\t\tisPrunedRootPath = make(map[string]bool, len(maxVersion))\n \t\tfor p := range maxVersion {\n-\t\t\tisLazyRootPath[p] = true\n+\t\t\tisPrunedRootPath[p] = true\n \t\t}\n \t\tfor _, m := range tryUpgrade {\n-\t\t\tisLazyRootPath[m.Path] = true\n+\t\t\tisPrunedRootPath[m.Path] = true\n \t\t}\n \t\tfor _, m := range mustSelect {\n-\t\t\tisLazyRootPath[m.Path] = true\n+\t\t\tisPrunedRootPath[m.Path] = true\n \t\t}\n \n \t\tallowedRoot := map[module.Version]bool{}\n@@ -240,10 +242,10 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t\t\t}\n \t\t\tallowedRoot[m] = true\n \n-\t\t\tif m.Path == Target.Path {\n-\t\t\t\t// Target is already considered to be higher than any possible m, so we\n-\t\t\t\t// won't be upgrading to it anyway and there is no point scanning its\n-\t\t\t\t// dependencies.\n+\t\t\tif MainModules.Contains(m.Path) {\n+\t\t\t\t// The main module versions are already considered to be higher than any\n+\t\t\t\t// possible m, so m cannot be selected as a root and there is no point\n+\t\t\t\t// scanning its dependencies.\n \t\t\t\treturn nil\n \t\t\t}\n \n@@ -253,15 +255,15 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\tif summary.depth == eager {\n-\t\t\t\t// For efficiency, we'll load all of the eager upgrades as one big\n+\t\t\tif summary.pruning == unpruned {\n+\t\t\t\t// For efficiency, we'll load all of the unpruned upgrades as one big\n \t\t\t\t// graph, rather than loading the (potentially-overlapping) subgraph for\n \t\t\t\t// each upgrade individually.\n-\t\t\t\teagerUpgrades = append(eagerUpgrades, m)\n+\t\t\t\tunprunedUpgrades = append(unprunedUpgrades, m)\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tfor _, r := range summary.require {\n-\t\t\t\tif isLazyRootPath[r.Path] {\n+\t\t\t\tif isPrunedRootPath[r.Path] {\n \t\t\t\t\t// r could become a root as the result of an upgrade or downgrade,\n \t\t\t\t\t// in which case its dependencies will not be pruned out.\n \t\t\t\t\t// We need to allow those dependencies to be upgraded too.\n@@ -282,21 +284,19 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t\t}\n \t}\n \n-\tif len(eagerUpgrades) > 0 {\n-\t\t// Compute the max versions for eager upgrades all together.\n-\t\t// Since these modules are eager, we'll end up scanning all of their\n+\tif len(unprunedUpgrades) > 0 {\n+\t\t// Compute the max versions for unpruned upgrades all together.\n+\t\t// Since these modules are unpruned, we'll end up scanning all of their\n \t\t// transitive dependencies no matter which versions end up selected,\n \t\t// and since we have a large dependency graph to scan we might get\n \t\t// a significant benefit from not revisiting dependencies that are at\n \t\t// common versions among multiple upgrades.\n-\t\tupgradeGraph, err := readModGraph(ctx, eager, eagerUpgrades)\n+\t\tupgradeGraph, err := readModGraph(ctx, unpruned, unprunedUpgrades)\n \t\tif err != nil {\n-\t\t\tif go117LazyTODO {\n-\t\t\t\t// Compute the requirement path from a module path in tryUpgrade to the\n-\t\t\t\t// error, and the requirement path (if any) from rs.rootModules to the\n-\t\t\t\t// tryUpgrade module path. Return a *mvs.BuildListError showing the\n-\t\t\t\t// concatenation of the paths (with an upgrade in the middle).\n-\t\t\t}\n+\t\t\t// Compute the requirement path from a module path in tryUpgrade to the\n+\t\t\t// error, and the requirement path (if any) from rs.rootModules to the\n+\t\t\t// tryUpgrade module path. Return a *mvs.BuildListError showing the\n+\t\t\t// concatenation of the paths (with an upgrade in the middle).\n \t\t\treturn err\n \t\t}\n \n@@ -311,7 +311,7 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \tnextRoots := append([]module.Version(nil), mustSelect...)\n \tfor nextRoots != nil {\n \t\tmodule.Sort(nextRoots)\n-\t\trs := newRequirements(depth, nextRoots, nil)\n+\t\trs := newRequirements(pruning, nextRoots, nil)\n \t\tnextRoots = nil\n \n \t\trs, mustGraph, err := expandGraph(ctx, rs)\n@@ -325,7 +325,7 @@ func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, d\n \t\t\t// which case we will error out either way).\n \t\t\tallow(r)\n \n-\t\t\tif isLazyRootPath[r.Path] {\n+\t\t\tif isPrunedRootPath[r.Path] {\n \t\t\t\tif v, ok := rs.rootSelected(r.Path); ok && r.Version == v {\n \t\t\t\t\t// r is already a root, so its requirements are already included in\n \t\t\t\t\t// the build list.\n@@ -365,12 +365,12 @@ func selectPotentiallyImportedModules(ctx context.Context, limiter *versionLimit\n \t}\n \n \tvar initial []module.Version\n-\tif rs.depth == eager {\n+\tif rs.pruning == unpruned {\n \t\tmg, err := rs.Graph(ctx)\n \t\tif err != nil {\n \t\t\treturn nil, false, err\n \t\t}\n-\t\tinitial = mg.BuildList()[1:]\n+\t\tinitial = mg.BuildList()[MainModules.Len():]\n \t} else {\n \t\tinitial = rs.rootModules\n \t}\n@@ -382,7 +382,7 @@ func selectPotentiallyImportedModules(ctx context.Context, limiter *versionLimit\n \n \tmods = make([]module.Version, 0, len(limiter.selected))\n \tfor path, v := range limiter.selected {\n-\t\tif v != \"none\" && path != Target.Path {\n+\t\tif v != \"none\" && !MainModules.Contains(path) {\n \t\t\tmods = append(mods, module.Version{Path: path, Version: v})\n \t\t}\n \t}\n@@ -392,13 +392,13 @@ func selectPotentiallyImportedModules(ctx context.Context, limiter *versionLimit\n \t// downgraded module may require a higher (but still allowed) version of\n \t// another. The lower version may require extraneous dependencies that aren't\n \t// actually relevant, so we need to compute the actual selected versions.\n-\tmg, err := readModGraph(ctx, rs.depth, mods)\n+\tmg, err := readModGraph(ctx, rs.pruning, mods)\n \tif err != nil {\n \t\treturn nil, false, err\n \t}\n \tmods = make([]module.Version, 0, len(limiter.selected))\n \tfor path, _ := range limiter.selected {\n-\t\tif path != Target.Path {\n+\t\tif !MainModules.Contains(path) {\n \t\t\tif v := mg.Selected(path); v != \"none\" {\n \t\t\t\tmods = append(mods, module.Version{Path: path, Version: v})\n \t\t\t}\n@@ -414,16 +414,16 @@ func selectPotentiallyImportedModules(ctx context.Context, limiter *versionLimit\n // A versionLimiter tracks the versions that may be selected for each module\n // subject to constraints on the maximum versions of transitive dependencies.\n type versionLimiter struct {\n-\t// depth is the depth at which the dependencies of the modules passed to\n+\t// pruning is the pruning at which the dependencies of the modules passed to\n \t// Select and UpgradeToward are loaded.\n-\tdepth modDepth\n+\tpruning modPruning\n \n \t// max maps each module path to the maximum version that may be selected for\n \t// that path.\n \t//\n \t// Paths with no entry are unrestricted, and we assume that they will not be\n \t// promoted to root dependencies (so will not contribute dependencies if the\n-\t// main module is lazy).\n+\t// main module supports graph pruning).\n \tmax map[string]string\n \n \t// selected maps each module path to a version of that path (if known) whose\n@@ -475,14 +475,18 @@ func (dq dqState) isDisqualified() bool {\n // in the map are unrestricted. The limiter assumes that unrestricted paths will\n // not be promoted to root dependencies.\n //\n-// If depth is lazy, then if a module passed to UpgradeToward or Select is\n-// itself lazy, its unrestricted dependencies are skipped when scanning\n-// requirements.\n-func newVersionLimiter(depth modDepth, max map[string]string) *versionLimiter {\n+// If module graph pruning is in effect, then if a module passed to\n+// UpgradeToward or Select supports pruning, its unrestricted dependencies are\n+// skipped when scanning requirements.\n+func newVersionLimiter(pruning modPruning, max map[string]string) *versionLimiter {\n+\tselected := make(map[string]string)\n+\tfor _, m := range MainModules.Versions() {\n+\t\tselected[m.Path] = m.Version\n+\t}\n \treturn &versionLimiter{\n-\t\tdepth:     depth,\n+\t\tpruning:   pruning,\n \t\tmax:       max,\n-\t\tselected:  map[string]string{Target.Path: Target.Version},\n+\t\tselected:  selected,\n \t\tdqReason:  map[module.Version]dqState{},\n \t\trequiring: map[module.Version][]module.Version{},\n \t}\n@@ -491,8 +495,8 @@ func newVersionLimiter(depth modDepth, max map[string]string) *versionLimiter {\n // UpgradeToward attempts to upgrade the selected version of m.Path as close as\n // possible to m.Version without violating l's maximum version limits.\n //\n-// If depth is lazy and m itself is lazy, the the dependencies of unrestricted\n-// dependencies of m will not be followed.\n+// If module graph pruning is in effect and m itself supports pruning, the\n+// dependencies of unrestricted dependencies of m will not be followed.\n func (l *versionLimiter) UpgradeToward(ctx context.Context, m module.Version) error {\n \tselected, ok := l.selected[m.Path]\n \tif ok {\n@@ -504,7 +508,7 @@ func (l *versionLimiter) UpgradeToward(ctx context.Context, m module.Version) er\n \t\tselected = \"none\"\n \t}\n \n-\tif l.check(m, l.depth).isDisqualified() {\n+\tif l.check(m, l.pruning).isDisqualified() {\n \t\tcandidates, err := versions(ctx, m.Path, CheckAllowed)\n \t\tif err != nil {\n \t\t\t// This is likely a transient error reaching the repository,\n@@ -521,7 +525,7 @@ func (l *versionLimiter) UpgradeToward(ctx context.Context, m module.Version) er\n \t\t})\n \t\tcandidates = candidates[:i]\n \n-\t\tfor l.check(m, l.depth).isDisqualified() {\n+\t\tfor l.check(m, l.pruning).isDisqualified() {\n \t\t\tn := len(candidates)\n \t\t\tif n == 0 || cmpVersion(selected, candidates[n-1]) >= 0 {\n \t\t\t\t// We couldn't find a suitable candidate above the already-selected version.\n@@ -538,7 +542,7 @@ func (l *versionLimiter) UpgradeToward(ctx context.Context, m module.Version) er\n \n // Select attempts to set the selected version of m.Path to exactly m.Version.\n func (l *versionLimiter) Select(m module.Version) (conflict module.Version, err error) {\n-\tdq := l.check(m, l.depth)\n+\tdq := l.check(m, l.pruning)\n \tif !dq.isDisqualified() {\n \t\tl.selected[m.Path] = m.Version\n \t}\n@@ -548,15 +552,15 @@ func (l *versionLimiter) Select(m module.Version) (conflict module.Version, err\n // check determines whether m (or its transitive dependencies) would violate l's\n // maximum version limits if added to the module requirement graph.\n //\n-// If depth is lazy and m itself is lazy, then the dependencies of unrestricted\n-// dependencies of m will not be followed. If the lazy loading invariants hold\n-// for the main module up to this point, the packages in those modules are at\n-// best only imported by tests of dependencies that are themselves loaded from\n-// outside modules. Although we would like to keep 'go test all' as reproducible\n-// as is feasible, we don't want to retain test dependencies that are only\n-// marginally relevant at best.\n-func (l *versionLimiter) check(m module.Version, depth modDepth) dqState {\n-\tif m.Version == \"none\" || m == Target {\n+// If pruning is in effect and m itself supports graph pruning, the dependencies\n+// of unrestricted dependencies of m will not be followed. If the graph-pruning\n+// invariants hold for the main module up to this point, the packages in those\n+// modules are at best only imported by tests of dependencies that are\n+// themselves loaded from outside modules. Although we would like to keep\n+// 'go test all' as reproducible as is feasible, we don't want to retain test\n+// dependencies that are only marginally relevant at best.\n+func (l *versionLimiter) check(m module.Version, pruning modPruning) dqState {\n+\tif m.Version == \"none\" || m == MainModules.mustGetSingleMainModule() {\n \t\t// version \"none\" has no requirements, and the dependencies of Target are\n \t\t// tautological.\n \t\treturn dqState{}\n@@ -586,20 +590,20 @@ func (l *versionLimiter) check(m module.Version, depth modDepth) dqState {\n \t\treturn l.disqualify(m, dqState{err: err})\n \t}\n \n-\tif summary.depth == eager {\n-\t\tdepth = eager\n+\tif summary.pruning == unpruned {\n+\t\tpruning = unpruned\n \t}\n \tfor _, r := range summary.require {\n-\t\tif depth == lazy {\n+\t\tif pruning == pruned {\n \t\t\tif _, restricted := l.max[r.Path]; !restricted {\n \t\t\t\t// r.Path is unrestricted, so we don't care at what version it is\n \t\t\t\t// selected. We assume that r.Path will not become a root dependency, so\n-\t\t\t\t// since m is lazy, r's dependencies won't be followed.\n+\t\t\t\t// since m supports pruning, r's dependencies won't be followed.\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \n-\t\tif dq := l.check(r, depth); dq.isDisqualified() {\n+\t\tif dq := l.check(r, pruning); dq.isDisqualified() {\n \t\t\treturn l.disqualify(m, dq)\n \t\t}\n "}, {"sha": "812e48a1568f16e62ac33f07a90f8e4d9d8595e7", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -32,6 +32,8 @@ type ImportMissingError struct {\n \tModule   module.Version\n \tQueryErr error\n \n+\tImportingMainModule module.Version\n+\n \t// isStd indicates whether we would expect to find the package in the standard\n \t// library. This is normally true for all dotless import paths, but replace\n \t// directives can cause us to treat the replaced paths as also being in\n@@ -71,6 +73,9 @@ func (e *ImportMissingError) Error() string {\n \t\tif e.QueryErr != nil {\n \t\t\treturn fmt.Sprintf(\"%s: %v\", message, e.QueryErr)\n \t\t}\n+\t\tif e.ImportingMainModule.Path != \"\" && e.ImportingMainModule != MainModules.ModContainingCWD() {\n+\t\t\treturn fmt.Sprintf(\"%s; to add it:\\n\\tcd %s\\n\\tgo get %s\", message, MainModules.ModRoot(e.ImportingMainModule), e.Path)\n+\t\t}\n \t\treturn fmt.Sprintf(\"%s; to add it:\\n\\tgo get %s\", message, e.Path)\n \t}\n \n@@ -238,55 +243,63 @@ func (e *invalidImportError) Unwrap() error {\n //\n // If the package is not present in any module selected from the requirement\n // graph, importFromModules returns an *ImportMissingError.\n-func importFromModules(ctx context.Context, path string, rs *Requirements, mg *ModuleGraph) (m module.Version, dir string, err error) {\n+//\n+// If the package is present in exactly one module, importFromModules will\n+// return the module, its root directory, and a list of other modules that\n+// lexically could have provided the package but did not.\n+func importFromModules(ctx context.Context, path string, rs *Requirements, mg *ModuleGraph) (m module.Version, dir string, altMods []module.Version, err error) {\n \tif strings.Contains(path, \"@\") {\n-\t\treturn module.Version{}, \"\", fmt.Errorf(\"import path should not have @version\")\n+\t\treturn module.Version{}, \"\", nil, fmt.Errorf(\"import path should not have @version\")\n \t}\n \tif build.IsLocalImport(path) {\n-\t\treturn module.Version{}, \"\", fmt.Errorf(\"relative import not supported\")\n+\t\treturn module.Version{}, \"\", nil, fmt.Errorf(\"relative import not supported\")\n \t}\n \tif path == \"C\" {\n \t\t// There's no directory for import \"C\".\n-\t\treturn module.Version{}, \"\", nil\n+\t\treturn module.Version{}, \"\", nil, nil\n \t}\n \t// Before any further lookup, check that the path is valid.\n \tif err := module.CheckImportPath(path); err != nil {\n-\t\treturn module.Version{}, \"\", &invalidImportError{importPath: path, err: err}\n+\t\treturn module.Version{}, \"\", nil, &invalidImportError{importPath: path, err: err}\n \t}\n \n \t// Is the package in the standard library?\n \tpathIsStd := search.IsStandardImportPath(path)\n \tif pathIsStd && goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n-\t\tif targetInGorootSrc {\n-\t\t\tif dir, ok, err := dirInModule(path, targetPrefix, ModRoot(), true); err != nil {\n-\t\t\t\treturn module.Version{}, dir, err\n-\t\t\t} else if ok {\n-\t\t\t\treturn Target, dir, nil\n+\t\tfor _, mainModule := range MainModules.Versions() {\n+\t\t\tif MainModules.InGorootSrc(mainModule) {\n+\t\t\t\tif dir, ok, err := dirInModule(path, MainModules.PathPrefix(mainModule), MainModules.ModRoot(mainModule), true); err != nil {\n+\t\t\t\t\treturn module.Version{}, dir, nil, err\n+\t\t\t\t} else if ok {\n+\t\t\t\t\treturn mainModule, dir, nil, nil\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tdir := filepath.Join(cfg.GOROOT, \"src\", path)\n-\t\treturn module.Version{}, dir, nil\n+\t\treturn module.Version{}, dir, nil, nil\n \t}\n \n \t// -mod=vendor is special.\n \t// Everything must be in the main module or the main module's vendor directory.\n \tif cfg.BuildMod == \"vendor\" {\n-\t\tmainDir, mainOK, mainErr := dirInModule(path, targetPrefix, ModRoot(), true)\n-\t\tvendorDir, vendorOK, _ := dirInModule(path, \"\", filepath.Join(ModRoot(), \"vendor\"), false)\n+\t\tmainModule := MainModules.mustGetSingleMainModule()\n+\t\tmodRoot := MainModules.ModRoot(mainModule)\n+\t\tmainDir, mainOK, mainErr := dirInModule(path, MainModules.PathPrefix(mainModule), modRoot, true)\n+\t\tvendorDir, vendorOK, _ := dirInModule(path, \"\", filepath.Join(modRoot, \"vendor\"), false)\n \t\tif mainOK && vendorOK {\n-\t\t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: []string{mainDir, vendorDir}}\n+\t\t\treturn module.Version{}, \"\", nil, &AmbiguousImportError{importPath: path, Dirs: []string{mainDir, vendorDir}}\n \t\t}\n \t\t// Prefer to return main directory if there is one,\n \t\t// Note that we're not checking that the package exists.\n \t\t// We'll leave that for load.\n \t\tif !vendorOK && mainDir != \"\" {\n-\t\t\treturn Target, mainDir, nil\n+\t\t\treturn mainModule, mainDir, nil, nil\n \t\t}\n \t\tif mainErr != nil {\n-\t\t\treturn module.Version{}, \"\", mainErr\n+\t\t\treturn module.Version{}, \"\", nil, mainErr\n \t\t}\n-\t\treadVendorList()\n-\t\treturn vendorPkgModule[path], vendorDir, nil\n+\t\treadVendorList(mainModule)\n+\t\treturn vendorPkgModule[path], vendorDir, nil, nil\n \t}\n \n \t// Check each module on the build list.\n@@ -307,7 +320,7 @@ func importFromModules(ctx context.Context, path string, rs *Requirements, mg *M\n \t// already non-nil, then we attempt to load the package using the full\n \t// requirements in mg.\n \tfor {\n-\t\tvar sumErrMods []module.Version\n+\t\tvar sumErrMods, altMods []module.Version\n \t\tfor prefix := path; prefix != \".\"; prefix = pathpkg.Dir(prefix) {\n \t\t\tvar (\n \t\t\t\tv  string\n@@ -341,13 +354,15 @@ func importFromModules(ctx context.Context, path string, rs *Requirements, mg *M\n \t\t\t\t// continue the loop and find the package in some other module,\n \t\t\t\t// we need to look at this module to make sure the import is\n \t\t\t\t// not ambiguous.\n-\t\t\t\treturn module.Version{}, \"\", err\n+\t\t\t\treturn module.Version{}, \"\", nil, err\n \t\t\t}\n \t\t\tif dir, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n-\t\t\t\treturn module.Version{}, \"\", err\n+\t\t\t\treturn module.Version{}, \"\", nil, err\n \t\t\t} else if ok {\n \t\t\t\tmods = append(mods, m)\n \t\t\t\tdirs = append(dirs, dir)\n+\t\t\t} else {\n+\t\t\t\taltMods = append(altMods, m)\n \t\t\t}\n \t\t}\n \n@@ -360,23 +375,23 @@ func importFromModules(ctx context.Context, path string, rs *Requirements, mg *M\n \t\t\t\tmods[i], mods[j] = mods[j], mods[i]\n \t\t\t\tdirs[i], dirs[j] = dirs[j], dirs[i]\n \t\t\t}\n-\t\t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: dirs, Modules: mods}\n+\t\t\treturn module.Version{}, \"\", nil, &AmbiguousImportError{importPath: path, Dirs: dirs, Modules: mods}\n \t\t}\n \n \t\tif len(sumErrMods) > 0 {\n \t\t\tfor i := 0; i < len(sumErrMods)/2; i++ {\n \t\t\t\tj := len(sumErrMods) - 1 - i\n \t\t\t\tsumErrMods[i], sumErrMods[j] = sumErrMods[j], sumErrMods[i]\n \t\t\t}\n-\t\t\treturn module.Version{}, \"\", &ImportMissingSumError{\n+\t\t\treturn module.Version{}, \"\", nil, &ImportMissingSumError{\n \t\t\t\timportPath: path,\n \t\t\t\tmods:       sumErrMods,\n \t\t\t\tfound:      len(mods) > 0,\n \t\t\t}\n \t\t}\n \n \t\tif len(mods) == 1 {\n-\t\t\treturn mods[0], dirs[0], nil\n+\t\t\treturn mods[0], dirs[0], altMods, nil\n \t\t}\n \n \t\tif mg != nil {\n@@ -386,7 +401,7 @@ func importFromModules(ctx context.Context, path string, rs *Requirements, mg *M\n \t\t\tif !HasModRoot() {\n \t\t\t\tqueryErr = ErrNoModRoot\n \t\t\t}\n-\t\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: queryErr, isStd: pathIsStd}\n+\t\t\treturn module.Version{}, \"\", nil, &ImportMissingError{Path: path, QueryErr: queryErr, isStd: pathIsStd}\n \t\t}\n \n \t\t// So far we've checked the root dependencies.\n@@ -397,7 +412,7 @@ func importFromModules(ctx context.Context, path string, rs *Requirements, mg *M\n \t\t\t// the module graph, so we can't return an ImportMissingError here \u2014 one\n \t\t\t// of the missing modules might actually contain the package in question,\n \t\t\t// in which case we shouldn't go looking for it in some new dependency.\n-\t\t\treturn module.Version{}, \"\", err\n+\t\t\treturn module.Version{}, \"\", nil, err\n \t\t}\n \t}\n }\n@@ -410,9 +425,9 @@ func importFromModules(ctx context.Context, path string, rs *Requirements, mg *M\n func queryImport(ctx context.Context, path string, rs *Requirements) (module.Version, error) {\n \t// To avoid spurious remote fetches, try the latest replacement for each\n \t// module (golang.org/issue/26241).\n-\tif index != nil {\n-\t\tvar mods []module.Version\n-\t\tfor mp, mv := range index.highestReplaced {\n+\tvar mods []module.Version\n+\tif MainModules != nil { // TODO(#48912): Ensure MainModules exists at this point, and remove the check.\n+\t\tfor mp, mv := range MainModules.HighestReplaced() {\n \t\t\tif !maybeInModule(path, mp) {\n \t\t\t\tcontinue\n \t\t\t}\n@@ -439,40 +454,41 @@ func queryImport(ctx context.Context, path string, rs *Requirements) (module.Ver\n \t\t\t}\n \t\t\tmods = append(mods, module.Version{Path: mp, Version: mv})\n \t\t}\n+\t}\n \n-\t\t// Every module path in mods is a prefix of the import path.\n-\t\t// As in QueryPattern, prefer the longest prefix that satisfies the import.\n-\t\tsort.Slice(mods, func(i, j int) bool {\n-\t\t\treturn len(mods[i].Path) > len(mods[j].Path)\n-\t\t})\n-\t\tfor _, m := range mods {\n-\t\t\tneedSum := true\n-\t\t\troot, isLocal, err := fetch(ctx, m, needSum)\n-\t\t\tif err != nil {\n-\t\t\t\tif sumErr := (*sumMissingError)(nil); errors.As(err, &sumErr) {\n-\t\t\t\t\treturn module.Version{}, &ImportMissingSumError{importPath: path}\n-\t\t\t\t}\n-\t\t\t\treturn module.Version{}, err\n-\t\t\t}\n-\t\t\tif _, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n-\t\t\t\treturn m, err\n-\t\t\t} else if ok {\n-\t\t\t\tif cfg.BuildMod == \"readonly\" {\n-\t\t\t\t\treturn module.Version{}, &ImportMissingError{Path: path, replaced: m}\n-\t\t\t\t}\n-\t\t\t\treturn m, nil\n+\t// Every module path in mods is a prefix of the import path.\n+\t// As in QueryPattern, prefer the longest prefix that satisfies the import.\n+\tsort.Slice(mods, func(i, j int) bool {\n+\t\treturn len(mods[i].Path) > len(mods[j].Path)\n+\t})\n+\tfor _, m := range mods {\n+\t\tneedSum := true\n+\t\troot, isLocal, err := fetch(ctx, m, needSum)\n+\t\tif err != nil {\n+\t\t\tif sumErr := (*sumMissingError)(nil); errors.As(err, &sumErr) {\n+\t\t\t\treturn module.Version{}, &ImportMissingSumError{importPath: path}\n \t\t\t}\n+\t\t\treturn module.Version{}, err\n \t\t}\n-\t\tif len(mods) > 0 && module.CheckPath(path) != nil {\n-\t\t\t// The package path is not valid to fetch remotely,\n-\t\t\t// so it can only exist in a replaced module,\n-\t\t\t// and we know from the above loop that it is not.\n-\t\t\treturn module.Version{}, &PackageNotInModuleError{\n-\t\t\t\tMod:         mods[0],\n-\t\t\t\tQuery:       \"latest\",\n-\t\t\t\tPattern:     path,\n-\t\t\t\tReplacement: Replacement(mods[0]),\n+\t\tif _, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n+\t\t\treturn m, err\n+\t\t} else if ok {\n+\t\t\tif cfg.BuildMod == \"readonly\" {\n+\t\t\t\treturn module.Version{}, &ImportMissingError{Path: path, replaced: m}\n \t\t\t}\n+\t\t\treturn m, nil\n+\t\t}\n+\t}\n+\tif len(mods) > 0 && module.CheckPath(path) != nil {\n+\t\t// The package path is not valid to fetch remotely,\n+\t\t// so it can only exist in a replaced module,\n+\t\t// and we know from the above loop that it is not.\n+\t\treplacement := Replacement(mods[0])\n+\t\treturn module.Version{}, &PackageNotInModuleError{\n+\t\t\tMod:         mods[0],\n+\t\t\tQuery:       \"latest\",\n+\t\t\tPattern:     path,\n+\t\t\tReplacement: replacement,\n \t\t}\n \t}\n \n@@ -596,7 +612,7 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \t// (the main module, and any directory trees pointed at by replace directives).\n \tif isLocal {\n \t\tfor d := dir; d != mdir && len(d) > len(mdir); {\n-\t\t\thaveGoMod := haveGoModCache.Do(d, func() interface{} {\n+\t\t\thaveGoMod := haveGoModCache.Do(d, func() any {\n \t\t\t\tfi, err := fsys.Stat(filepath.Join(d, \"go.mod\"))\n \t\t\t\treturn err == nil && !fi.IsDir()\n \t\t\t}).(bool)\n@@ -619,7 +635,7 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \t// Are there Go source files in the directory?\n \t// We don't care about build tags, not even \"+build ignore\".\n \t// We're just looking for a plausible directory.\n-\tres := haveGoFilesCache.Do(dir, func() interface{} {\n+\tres := haveGoFilesCache.Do(dir, func() any {\n \t\tok, err := fsys.IsDirWithGoFiles(dir)\n \t\treturn goFilesEntry{haveGoFiles: ok, err: err}\n \t}).(goFilesEntry)\n@@ -638,14 +654,14 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n // The isLocal return value reports whether the replacement,\n // if any, is local to the filesystem.\n func fetch(ctx context.Context, mod module.Version, needSum bool) (dir string, isLocal bool, err error) {\n-\tif mod == Target {\n-\t\treturn ModRoot(), true, nil\n+\tif modRoot := MainModules.ModRoot(mod); modRoot != \"\" {\n+\t\treturn modRoot, true, nil\n \t}\n \tif r := Replacement(mod); r.Path != \"\" {\n \t\tif r.Version == \"\" {\n \t\t\tdir = r.Path\n \t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n+\t\t\t\tdir = filepath.Join(replaceRelativeTo(), dir)\n \t\t\t}\n \t\t\t// Ensure that the replacement directory actually exists:\n \t\t\t// dirInModule does not report errors for missing modules,\n@@ -667,7 +683,7 @@ func fetch(ctx context.Context, mod module.Version, needSum bool) (dir string, i\n \t\tmod = r\n \t}\n \n-\tif HasModRoot() && cfg.BuildMod == \"readonly\" && needSum && !modfetch.HaveSum(mod) {\n+\tif HasModRoot() && cfg.BuildMod == \"readonly\" && !inWorkspaceMode() && needSum && !modfetch.HaveSum(mod) {\n \t\treturn \"\", false, module.VersionError(mod, &sumMissingError{})\n \t}\n "}, {"sha": "65a889ec52f11c8355085050833b82ccfee56ddd", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -69,7 +69,7 @@ func TestQueryImport(t *testing.T) {\n \tRootMode = NoRoot\n \n \tctx := context.Background()\n-\trs := newRequirements(eager, nil, nil)\n+\trs := LoadModFile(ctx)\n \n \tfor _, tt := range importTests {\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {"}, {"sha": "cdcfbeb8dedfb47f23a507abf73ac438e2e31260", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 770, "deletions": 255, "changes": 1025, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -12,11 +12,13 @@ import (\n \t\"fmt\"\n \t\"go/build\"\n \t\"internal/lazyregexp\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -43,28 +45,198 @@ var (\n \tForceUseModules bool\n \n \tallowMissingModuleImports bool\n+\n+\t// ExplicitWriteGoMod prevents LoadPackages, ListModules, and other functions\n+\t// from updating go.mod and go.sum or reporting errors when updates are\n+\t// needed. A package should set this if it would cause go.mod to be written\n+\t// multiple times (for example, 'go get' calls LoadPackages multiple times) or\n+\t// if it needs some other operation to be successful before go.mod and go.sum\n+\t// can be written (for example, 'go mod download' must download modules before\n+\t// adding sums to go.sum). Packages that set this are responsible for calling\n+\t// WriteGoMod explicitly.\n+\tExplicitWriteGoMod bool\n )\n \n // Variables set in Init.\n var (\n \tinitialized bool\n-\tmodRoot     string\n-\tgopath      string\n+\n+\t// These are primarily used to initialize the MainModules, and should be\n+\t// eventually superceded by them but are still used in cases where the module\n+\t// roots are required but MainModules hasn't been initialized yet. Set to\n+\t// the modRoots of the main modules.\n+\t// modRoots != nil implies len(modRoots) > 0\n+\tmodRoots []string\n+\tgopath   string\n )\n \n-// Variables set in initTarget (during {Load,Create}ModFile).\n+// EnterModule resets MainModules and requirements to refer to just this one module.\n+func EnterModule(ctx context.Context, enterModroot string) {\n+\tMainModules = nil // reset MainModules\n+\trequirements = nil\n+\tworkFilePath = \"\" // Force module mode\n+\tmodfetch.Reset()\n+\n+\tmodRoots = []string{enterModroot}\n+\tLoadModFile(ctx)\n+}\n+\n+// Variable set in InitWorkfile\n var (\n-\tTarget module.Version\n+\t// Set to the path to the go.work file, or \"\" if workspace mode is disabled.\n+\tworkFilePath string\n+)\n+\n+type MainModuleSet struct {\n+\t// versions are the module.Version values of each of the main modules.\n+\t// For each of them, the Path fields are ordinary module paths and the Version\n+\t// fields are empty strings.\n+\tversions []module.Version\n+\n+\t// modRoot maps each module in versions to its absolute filesystem path.\n+\tmodRoot map[module.Version]string\n \n-\t// targetPrefix is the path prefix for packages in Target, without a trailing\n-\t// slash. For most modules, targetPrefix is just Target.Path, but the\n+\t// pathPrefix is the path prefix for packages in the module, without a trailing\n+\t// slash. For most modules, pathPrefix is just version.Path, but the\n \t// standard-library module \"std\" has an empty prefix.\n-\ttargetPrefix string\n+\tpathPrefix map[module.Version]string\n \n-\t// targetInGorootSrc caches whether modRoot is within GOROOT/src.\n+\t// inGorootSrc caches whether modRoot is within GOROOT/src.\n \t// The \"std\" module is special within GOROOT/src, but not otherwise.\n-\ttargetInGorootSrc bool\n-)\n+\tinGorootSrc map[module.Version]bool\n+\n+\tmodFiles map[module.Version]*modfile.File\n+\n+\tmodContainingCWD module.Version\n+\n+\tworkFileGoVersion string\n+\n+\tworkFileReplaceMap map[module.Version]module.Version\n+\t// highest replaced version of each module path; empty string for wildcard-only replacements\n+\thighestReplaced map[string]string\n+\n+\tindexMu sync.Mutex\n+\tindices map[module.Version]*modFileIndex\n+}\n+\n+func (mms *MainModuleSet) PathPrefix(m module.Version) string {\n+\treturn mms.pathPrefix[m]\n+}\n+\n+// Versions returns the module.Version values of each of the main modules.\n+// For each of them, the Path fields are ordinary module paths and the Version\n+// fields are empty strings.\n+// Callers should not modify the returned slice.\n+func (mms *MainModuleSet) Versions() []module.Version {\n+\tif mms == nil {\n+\t\treturn nil\n+\t}\n+\treturn mms.versions\n+}\n+\n+func (mms *MainModuleSet) Contains(path string) bool {\n+\tif mms == nil {\n+\t\treturn false\n+\t}\n+\tfor _, v := range mms.versions {\n+\t\tif v.Path == path {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func (mms *MainModuleSet) ModRoot(m module.Version) string {\n+\tif mms == nil {\n+\t\treturn \"\"\n+\t}\n+\treturn mms.modRoot[m]\n+}\n+\n+func (mms *MainModuleSet) InGorootSrc(m module.Version) bool {\n+\tif mms == nil {\n+\t\treturn false\n+\t}\n+\treturn mms.inGorootSrc[m]\n+}\n+\n+func (mms *MainModuleSet) mustGetSingleMainModule() module.Version {\n+\tif mms == nil || len(mms.versions) == 0 {\n+\t\tpanic(\"internal error: mustGetSingleMainModule called in context with no main modules\")\n+\t}\n+\tif len(mms.versions) != 1 {\n+\t\tif inWorkspaceMode() {\n+\t\t\tpanic(\"internal error: mustGetSingleMainModule called in workspace mode\")\n+\t\t} else {\n+\t\t\tpanic(\"internal error: multiple main modules present outside of workspace mode\")\n+\t\t}\n+\t}\n+\treturn mms.versions[0]\n+}\n+\n+func (mms *MainModuleSet) GetSingleIndexOrNil() *modFileIndex {\n+\tif mms == nil {\n+\t\treturn nil\n+\t}\n+\tif len(mms.versions) == 0 {\n+\t\treturn nil\n+\t}\n+\treturn mms.indices[mms.mustGetSingleMainModule()]\n+}\n+\n+func (mms *MainModuleSet) Index(m module.Version) *modFileIndex {\n+\tmms.indexMu.Lock()\n+\tdefer mms.indexMu.Unlock()\n+\treturn mms.indices[m]\n+}\n+\n+func (mms *MainModuleSet) SetIndex(m module.Version, index *modFileIndex) {\n+\tmms.indexMu.Lock()\n+\tdefer mms.indexMu.Unlock()\n+\tmms.indices[m] = index\n+}\n+\n+func (mms *MainModuleSet) ModFile(m module.Version) *modfile.File {\n+\treturn mms.modFiles[m]\n+}\n+\n+func (mms *MainModuleSet) Len() int {\n+\tif mms == nil {\n+\t\treturn 0\n+\t}\n+\treturn len(mms.versions)\n+}\n+\n+// ModContainingCWD returns the main module containing the working directory,\n+// or module.Version{} if none of the main modules contain the working\n+// directory.\n+func (mms *MainModuleSet) ModContainingCWD() module.Version {\n+\treturn mms.modContainingCWD\n+}\n+\n+func (mms *MainModuleSet) HighestReplaced() map[string]string {\n+\treturn mms.highestReplaced\n+}\n+\n+// GoVersion returns the go version set on the single module, in module mode,\n+// or the go.work file in workspace mode.\n+func (mms *MainModuleSet) GoVersion() string {\n+\tif !inWorkspaceMode() {\n+\t\treturn modFileGoVersion(mms.ModFile(mms.mustGetSingleMainModule()))\n+\t}\n+\tv := mms.workFileGoVersion\n+\tif v == \"\" {\n+\t\t// Fall back to 1.18 for go.work files.\n+\t\tv = \"1.18\"\n+\t}\n+\treturn v\n+}\n+\n+func (mms *MainModuleSet) WorkFileReplaceMap() map[module.Version]module.Version {\n+\treturn mms.workFileReplaceMap\n+}\n+\n+var MainModules *MainModuleSet\n \n type Root int\n \n@@ -94,6 +266,7 @@ const (\n // in go.mod, edit it before loading.\n func ModFile() *modfile.File {\n \tInit()\n+\tmodFile := MainModules.ModFile(MainModules.mustGetSingleMainModule())\n \tif modFile == nil {\n \t\tdie()\n \t}\n@@ -102,9 +275,38 @@ func ModFile() *modfile.File {\n \n func BinDir() string {\n \tInit()\n+\tif cfg.GOBIN != \"\" {\n+\t\treturn cfg.GOBIN\n+\t}\n+\tif gopath == \"\" {\n+\t\treturn \"\"\n+\t}\n \treturn filepath.Join(gopath, \"bin\")\n }\n \n+// InitWorkfile initializes the workFilePath variable for commands that\n+// operate in workspace mode. It should not be called by other commands,\n+// for example 'go mod tidy', that don't operate in workspace mode.\n+func InitWorkfile() {\n+\tswitch cfg.WorkFile {\n+\tcase \"off\":\n+\t\tworkFilePath = \"\"\n+\tcase \"\", \"auto\":\n+\t\tworkFilePath = findWorkspaceFile(base.Cwd())\n+\tdefault:\n+\t\tif !filepath.IsAbs(cfg.WorkFile) {\n+\t\t\tbase.Fatalf(\"the path provided to -workfile must be an absolute path\")\n+\t\t}\n+\t\tworkFilePath = cfg.WorkFile\n+\t}\n+}\n+\n+// WorkFilePath returns the path of the go.work file, or \"\" if not in\n+// workspace mode. WorkFilePath must be called after InitWorkfile.\n+func WorkFilePath() string {\n+\treturn workFilePath\n+}\n+\n // Init determines whether module mode is enabled, locates the root of the\n // current module (if any), sets environment variables for Git subprocesses, and\n // configures the cfg, codehost, load, modfetch, and search packages for use\n@@ -169,18 +371,18 @@ func Init() {\n \tif os.Getenv(\"GCM_INTERACTIVE\") == \"\" {\n \t\tos.Setenv(\"GCM_INTERACTIVE\", \"never\")\n \t}\n-\n-\tif modRoot != \"\" {\n+\tif modRoots != nil {\n \t\t// modRoot set before Init was called (\"go mod init\" does this).\n \t\t// No need to search for go.mod.\n \t} else if RootMode == NoRoot {\n \t\tif cfg.ModFile != \"\" && !base.InGOFLAGS(\"-modfile\") {\n \t\t\tbase.Fatalf(\"go: -modfile cannot be used with commands that ignore the current module\")\n \t\t}\n-\t\tmodRoot = \"\"\n+\t\tmodRoots = nil\n+\t} else if inWorkspaceMode() {\n+\t\t// We're in workspace mode.\n \t} else {\n-\t\tmodRoot = findModuleRoot(base.Cwd())\n-\t\tif modRoot == \"\" {\n+\t\tif modRoot := findModuleRoot(base.Cwd()); modRoot == \"\" {\n \t\t\tif cfg.ModFile != \"\" {\n \t\t\t\tbase.Fatalf(\"go: cannot find main module, but -modfile was set.\\n\\t-modfile cannot be used to set the module root directory.\")\n \t\t\t}\n@@ -198,11 +400,12 @@ func Init() {\n \t\t\t// will find it and get modules when they're not expecting them.\n \t\t\t// It's a bit of a peculiar thing to disallow but quite mysterious\n \t\t\t// when it happens. See golang.org/issue/26708.\n-\t\t\tmodRoot = \"\"\n \t\t\tfmt.Fprintf(os.Stderr, \"go: warning: ignoring go.mod in system temp root %v\\n\", os.TempDir())\n \t\t\tif !mustUseModules {\n \t\t\t\treturn\n \t\t\t}\n+\t\t} else {\n+\t\t\tmodRoots = []string{modRoot}\n \t\t}\n \t}\n \tif cfg.ModFile != \"\" && !strings.HasSuffix(cfg.ModFile, \".mod\") {\n@@ -213,35 +416,11 @@ func Init() {\n \tcfg.ModulesEnabled = true\n \tsetDefaultBuildMod()\n \tlist := filepath.SplitList(cfg.BuildContext.GOPATH)\n-\tif len(list) == 0 || list[0] == \"\" {\n-\t\tbase.Fatalf(\"missing $GOPATH\")\n-\t}\n-\tgopath = list[0]\n-\tif _, err := fsys.Stat(filepath.Join(gopath, \"go.mod\")); err == nil {\n-\t\tbase.Fatalf(\"$GOPATH/go.mod exists but should not\")\n-\t}\n-\n-\tif modRoot == \"\" {\n-\t\t// We're in module mode, but not inside a module.\n-\t\t//\n-\t\t// Commands like 'go build', 'go run', 'go list' have no go.mod file to\n-\t\t// read or write. They would need to find and download the latest versions\n-\t\t// of a potentially large number of modules with no way to save version\n-\t\t// information. We can succeed slowly (but not reproducibly), but that's\n-\t\t// not usually a good experience.\n-\t\t//\n-\t\t// Instead, we forbid resolving import paths to modules other than std and\n-\t\t// cmd. Users may still build packages specified with .go files on the\n-\t\t// command line, but they'll see an error if those files import anything\n-\t\t// outside std.\n-\t\t//\n-\t\t// This can be overridden by calling AllowMissingModuleImports.\n-\t\t// For example, 'go get' does this, since it is expected to resolve paths.\n-\t\t//\n-\t\t// See golang.org/issue/32027.\n-\t} else {\n-\t\tmodfetch.GoSumFile = strings.TrimSuffix(ModFilePath(), \".mod\") + \".sum\"\n-\t\tsearch.SetModRoot(modRoot)\n+\tif len(list) > 0 && list[0] != \"\" {\n+\t\tgopath = list[0]\n+\t\tif _, err := fsys.Stat(filepath.Join(gopath, \"go.mod\")); err == nil {\n+\t\t\tbase.Fatalf(\"$GOPATH/go.mod exists but should not\")\n+\t\t}\n \t}\n }\n \n@@ -255,7 +434,7 @@ func Init() {\n // be called until the command is installed and flags are parsed. Instead of\n // calling Init and Enabled, the main package can call this function.\n func WillBeEnabled() bool {\n-\tif modRoot != \"\" || cfg.ModulesEnabled {\n+\tif modRoots != nil || cfg.ModulesEnabled {\n \t\t// Already enabled.\n \t\treturn true\n \t}\n@@ -297,34 +476,46 @@ func WillBeEnabled() bool {\n // (usually through MustModRoot).\n func Enabled() bool {\n \tInit()\n-\treturn modRoot != \"\" || cfg.ModulesEnabled\n+\treturn modRoots != nil || cfg.ModulesEnabled\n }\n \n-// ModRoot returns the root of the main module.\n-// It calls base.Fatalf if there is no main module.\n-func ModRoot() string {\n-\tif !HasModRoot() {\n-\t\tdie()\n+func VendorDir() string {\n+\treturn filepath.Join(MainModules.ModRoot(MainModules.mustGetSingleMainModule()), \"vendor\")\n+}\n+\n+func inWorkspaceMode() bool {\n+\tif !initialized {\n+\t\tpanic(\"inWorkspaceMode called before modload.Init called\")\n \t}\n-\treturn modRoot\n+\treturn workFilePath != \"\"\n }\n \n // HasModRoot reports whether a main module is present.\n // HasModRoot may return false even if Enabled returns true: for example, 'get'\n // does not require a main module.\n func HasModRoot() bool {\n \tInit()\n-\treturn modRoot != \"\"\n+\treturn modRoots != nil\n }\n \n-// ModFilePath returns the effective path of the go.mod file. Normally, this\n-// \"go.mod\" in the directory returned by ModRoot, but the -modfile flag may\n-// change its location. ModFilePath calls base.Fatalf if there is no main\n-// module, even if -modfile is set.\n-func ModFilePath() string {\n+// MustHaveModRoot checks that a main module or main modules are present,\n+// and calls base.Fatalf if there are no main modules.\n+func MustHaveModRoot() {\n+\tInit()\n \tif !HasModRoot() {\n \t\tdie()\n \t}\n+}\n+\n+// ModFilePath returns the path that would be used for the go.mod\n+// file, if in module mode. ModFilePath calls base.Fatalf if there is no main\n+// module, even if -modfile is set.\n+func ModFilePath() string {\n+\tMustHaveModRoot()\n+\treturn modFilePath(findModuleRoot(base.Cwd()))\n+}\n+\n+func modFilePath(modRoot string) string {\n \tif cfg.ModFile != \"\" {\n \t\treturn cfg.ModFile\n \t}\n@@ -335,6 +526,9 @@ func die() {\n \tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n \t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t}\n+\tif inWorkspaceMode() {\n+\t\tbase.Fatalf(\"go: no modules were found in the current workspace; see 'go help work'\")\n+\t}\n \tif dir, name := findAltConfig(base.Cwd()); dir != \"\" {\n \t\trel, err := filepath.Rel(base.Cwd(), dir)\n \t\tif err != nil {\n@@ -365,12 +559,81 @@ func (goModDirtyError) Error() string {\n \n var errGoModDirty error = goModDirtyError{}\n \n+func loadWorkFile(path string) (goVersion string, modRoots []string, replaces []*modfile.Replace, err error) {\n+\tworkDir := filepath.Dir(path)\n+\twf, err := ReadWorkFile(path)\n+\tif err != nil {\n+\t\treturn \"\", nil, nil, err\n+\t}\n+\tif wf.Go != nil {\n+\t\tgoVersion = wf.Go.Version\n+\t}\n+\tseen := map[string]bool{}\n+\tfor _, d := range wf.Use {\n+\t\tmodRoot := d.Path\n+\t\tif !filepath.IsAbs(modRoot) {\n+\t\t\tmodRoot = filepath.Join(workDir, modRoot)\n+\t\t}\n+\n+\t\tif seen[modRoot] {\n+\t\t\treturn \"\", nil, nil, fmt.Errorf(\"path %s appears multiple times in workspace\", modRoot)\n+\t\t}\n+\t\tseen[modRoot] = true\n+\t\tmodRoots = append(modRoots, modRoot)\n+\t}\n+\n+\treturn goVersion, modRoots, wf.Replace, nil\n+}\n+\n+// ReadWorkFile reads and parses the go.work file at the given path.\n+func ReadWorkFile(path string) (*modfile.WorkFile, error) {\n+\tworkData, err := ioutil.ReadFile(path)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn modfile.ParseWork(path, workData, nil)\n+}\n+\n+// WriteWorkFile cleans and writes out the go.work file to the given path.\n+func WriteWorkFile(path string, wf *modfile.WorkFile) error {\n+\twf.SortBlocks()\n+\twf.Cleanup()\n+\tout := modfile.Format(wf.Syntax)\n+\n+\treturn ioutil.WriteFile(path, out, 0666)\n+}\n+\n+// UpdateWorkFile updates comments on directory directives in the go.work\n+// file to include the associated module path.\n+func UpdateWorkFile(wf *modfile.WorkFile) {\n+\tmissingModulePaths := map[string]string{} // module directory listed in file -> abspath modroot\n+\n+\tfor _, d := range wf.Use {\n+\t\tmodRoot := d.Path\n+\t\tif d.ModulePath == \"\" {\n+\t\t\tmissingModulePaths[d.Path] = modRoot\n+\t\t}\n+\t}\n+\n+\t// Clean up and annotate directories.\n+\t// TODO(matloob): update x/mod to actually add module paths.\n+\tfor moddir, absmodroot := range missingModulePaths {\n+\t\t_, f, err := ReadModFile(filepath.Join(absmodroot, \"go.mod\"), nil)\n+\t\tif err != nil {\n+\t\t\tcontinue // Error will be reported if modules are loaded.\n+\t\t}\n+\t\twf.AddUse(moddir, f.Module.Mod.Path)\n+\t}\n+}\n+\n // LoadModFile sets Target and, if there is a main module, parses the initial\n // build list from its go.mod file.\n //\n // LoadModFile may make changes in memory, like adding a go directive and\n-// ensuring requirements are consistent, and will write those changes back to\n-// disk unless DisallowWriteGoMod is in effect.\n+// ensuring requirements are consistent. The caller is responsible for ensuring\n+// those changes are written to disk by calling LoadPackages or ListModules\n+// (unless ExplicitWriteGoMod is set) or by calling WriteGoMod directly.\n //\n // As a side-effect, LoadModFile may change cfg.BuildMod to \"vendor\" if\n // -mod wasn't set explicitly and automatic vendoring should be enabled.\n@@ -383,111 +646,142 @@ var errGoModDirty error = goModDirtyError{}\n // it for global consistency. Most callers outside of the modload package should\n // use LoadModGraph instead.\n func LoadModFile(ctx context.Context) *Requirements {\n-\trs, needCommit := loadModFile(ctx)\n-\tif needCommit {\n-\t\tcommitRequirements(ctx, modFileGoVersion(), rs)\n-\t}\n-\treturn rs\n-}\n-\n-// loadModFile is like LoadModFile, but does not implicitly commit the\n-// requirements back to disk after fixing inconsistencies.\n-//\n-// If needCommit is true, after the caller makes any other needed changes to the\n-// returned requirements they should invoke commitRequirements to fix any\n-// inconsistencies that may be present in the on-disk go.mod file.\n-func loadModFile(ctx context.Context) (rs *Requirements, needCommit bool) {\n \tif requirements != nil {\n-\t\treturn requirements, false\n+\t\treturn requirements\n \t}\n \n \tInit()\n-\tif modRoot == \"\" {\n-\t\tTarget = module.Version{Path: \"command-line-arguments\"}\n-\t\ttargetPrefix = \"command-line-arguments\"\n-\t\tgoVersion := LatestGoVersion()\n-\t\trawGoVersion.Store(Target, goVersion)\n-\t\trequirements = newRequirements(modDepthFromGoVersion(goVersion), nil, nil)\n-\t\treturn requirements, false\n-\t}\n-\n-\tgomod := ModFilePath()\n-\tvar data []byte\n-\tvar err error\n-\tif gomodActual, ok := fsys.OverlayPath(gomod); ok {\n-\t\t// Don't lock go.mod if it's part of the overlay.\n-\t\t// On Plan 9, locking requires chmod, and we don't want to modify any file\n-\t\t// in the overlay. See #44700.\n-\t\tdata, err = os.ReadFile(gomodActual)\n+\tvar (\n+\t\tworkFileGoVersion string\n+\t\tworkFileReplaces  []*modfile.Replace\n+\t)\n+\tif inWorkspaceMode() {\n+\t\tvar err error\n+\t\tworkFileGoVersion, modRoots, workFileReplaces, err = loadWorkFile(workFilePath)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"reading go.work: %v\", err)\n+\t\t}\n+\t\tfor _, modRoot := range modRoots {\n+\t\t\tsumFile := strings.TrimSuffix(modFilePath(modRoot), \".mod\") + \".sum\"\n+\t\t\tmodfetch.WorkspaceGoSumFiles = append(modfetch.WorkspaceGoSumFiles, sumFile)\n+\t\t}\n+\t\tmodfetch.GoSumFile = workFilePath + \".sum\"\n+\t} else if modRoots == nil {\n+\t\t// We're in module mode, but not inside a module.\n+\t\t//\n+\t\t// Commands like 'go build', 'go run', 'go list' have no go.mod file to\n+\t\t// read or write. They would need to find and download the latest versions\n+\t\t// of a potentially large number of modules with no way to save version\n+\t\t// information. We can succeed slowly (but not reproducibly), but that's\n+\t\t// not usually a good experience.\n+\t\t//\n+\t\t// Instead, we forbid resolving import paths to modules other than std and\n+\t\t// cmd. Users may still build packages specified with .go files on the\n+\t\t// command line, but they'll see an error if those files import anything\n+\t\t// outside std.\n+\t\t//\n+\t\t// This can be overridden by calling AllowMissingModuleImports.\n+\t\t// For example, 'go get' does this, since it is expected to resolve paths.\n+\t\t//\n+\t\t// See golang.org/issue/32027.\n \t} else {\n-\t\tdata, err = lockedfile.Read(gomodActual)\n-\t}\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n+\t\tmodfetch.GoSumFile = strings.TrimSuffix(modFilePath(modRoots[0]), \".mod\") + \".sum\"\n+\t}\n+\tif len(modRoots) == 0 {\n+\t\t// TODO(#49228): Instead of creating a fake module with an empty modroot,\n+\t\t// make MainModules.Len() == 0 mean that we're in module mode but not inside\n+\t\t// any module.\n+\t\tmainModule := module.Version{Path: \"command-line-arguments\"}\n+\t\tMainModules = makeMainModules([]module.Version{mainModule}, []string{\"\"}, []*modfile.File{nil}, []*modFileIndex{nil}, \"\", nil)\n+\t\tgoVersion := LatestGoVersion()\n+\t\trawGoVersion.Store(mainModule, goVersion)\n+\t\tpruning := pruningForGoVersion(goVersion)\n+\t\tif inWorkspaceMode() {\n+\t\t\tpruning = workspace\n+\t\t}\n+\t\trequirements = newRequirements(pruning, nil, nil)\n+\t\treturn requirements\n \t}\n \n-\tvar fixed bool\n-\tf, err := modfile.Parse(gomod, data, fixVersion(ctx, &fixed))\n-\tif err != nil {\n-\t\t// Errors returned by modfile.Parse begin with file:line.\n-\t\tbase.Fatalf(\"go: errors parsing go.mod:\\n%s\\n\", err)\n-\t}\n-\tif f.Module == nil {\n-\t\t// No module declaration. Must add module path.\n-\t\tbase.Fatalf(\"go: no module declaration in go.mod. To specify the module path:\\n\\tgo mod edit -module=example.com/mod\")\n-\t}\n+\tvar modFiles []*modfile.File\n+\tvar mainModules []module.Version\n+\tvar indices []*modFileIndex\n+\tfor _, modroot := range modRoots {\n+\t\tgomod := modFilePath(modroot)\n+\t\tvar fixed bool\n+\t\tdata, f, err := ReadModFile(gomod, fixVersion(ctx, &fixed))\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t}\n \n-\tmodFile = f\n-\tinitTarget(f.Module.Mod)\n-\tindex = indexModFile(data, f, fixed)\n+\t\tmodFiles = append(modFiles, f)\n+\t\tmainModule := f.Module.Mod\n+\t\tmainModules = append(mainModules, mainModule)\n+\t\tindices = append(indices, indexModFile(data, f, mainModule, fixed))\n \n-\tif err := module.CheckImportPath(f.Module.Mod.Path); err != nil {\n-\t\tif pathErr, ok := err.(*module.InvalidPathError); ok {\n-\t\t\tpathErr.Kind = \"module\"\n+\t\tif err := module.CheckImportPath(f.Module.Mod.Path); err != nil {\n+\t\t\tif pathErr, ok := err.(*module.InvalidPathError); ok {\n+\t\t\t\tpathErr.Kind = \"module\"\n+\t\t\t}\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n-\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n+\tMainModules = makeMainModules(mainModules, modRoots, modFiles, indices, workFileGoVersion, workFileReplaces)\n \tsetDefaultBuildMod() // possibly enable automatic vendoring\n-\trs = requirementsFromModFile()\n+\trs := requirementsFromModFiles(ctx, modFiles)\n+\n+\tif inWorkspaceMode() {\n+\t\t// We don't need to do anything for vendor or update the mod file so\n+\t\t// return early.\n+\t\trequirements = rs\n+\t\treturn rs\n+\t}\n+\n+\tmainModule := MainModules.mustGetSingleMainModule()\n+\n \tif cfg.BuildMod == \"vendor\" {\n-\t\treadVendorList()\n-\t\tcheckVendorConsistency()\n+\t\treadVendorList(mainModule)\n+\t\tindex := MainModules.Index(mainModule)\n+\t\tmodFile := MainModules.ModFile(mainModule)\n+\t\tcheckVendorConsistency(index, modFile)\n \t\trs.initVendor(vendorList)\n \t}\n+\n \tif rs.hasRedundantRoot() {\n \t\t// If any module path appears more than once in the roots, we know that the\n \t\t// go.mod file needs to be updated even though we have not yet loaded any\n \t\t// transitive dependencies.\n+\t\tvar err error\n \t\trs, err = updateRoots(ctx, rs.direct, rs, nil, nil, false)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t}\n \n-\tif index.goVersionV == \"\" {\n+\tif MainModules.Index(mainModule).goVersionV == \"\" && rs.pruning != workspace {\n \t\t// TODO(#45551): Do something more principled instead of checking\n \t\t// cfg.CmdName directly here.\n \t\tif cfg.BuildMod == \"mod\" && cfg.CmdName != \"mod graph\" && cfg.CmdName != \"mod why\" {\n-\t\t\taddGoStmt(LatestGoVersion())\n-\t\t\tif go117EnableLazyLoading {\n-\t\t\t\t// We need to add a 'go' version to the go.mod file, but we must assume\n-\t\t\t\t// that its existing contents match something between Go 1.11 and 1.16.\n-\t\t\t\t// Go 1.11 through 1.16 have eager requirements, but the latest Go\n-\t\t\t\t// version uses lazy requirements instead \u2014 so we need to cnvert the\n-\t\t\t\t// requirements to be lazy.\n-\t\t\t\trs, err = convertDepth(ctx, rs, lazy)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tbase.Fatalf(\"go: %v\", err)\n-\t\t\t\t}\n+\t\t\taddGoStmt(MainModules.ModFile(mainModule), mainModule, LatestGoVersion())\n+\n+\t\t\t// We need to add a 'go' version to the go.mod file, but we must assume\n+\t\t\t// that its existing contents match something between Go 1.11 and 1.16.\n+\t\t\t// Go 1.11 through 1.16 do not support graph pruning, but the latest Go\n+\t\t\t// version uses a pruned module graph \u2014 so we need to convert the\n+\t\t\t// requirements to support pruning.\n+\t\t\tvar err error\n+\t\t\trs, err = convertPruning(ctx, rs, pruned)\n+\t\t\tif err != nil {\n+\t\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t\t}\n \t\t} else {\n-\t\t\trawGoVersion.Store(Target, modFileGoVersion())\n+\t\t\trawGoVersion.Store(mainModule, modFileGoVersion(MainModules.ModFile(mainModule)))\n \t\t}\n \t}\n \n \trequirements = rs\n-\treturn requirements, true\n+\treturn requirements\n }\n \n // CreateModFile initializes a new module by creating a go.mod file.\n@@ -500,9 +794,10 @@ func loadModFile(ctx context.Context) (rs *Requirements, needCommit bool) {\n // exactly the same as in the legacy configuration (for example, we can't get\n // packages at multiple versions from the same module).\n func CreateModFile(ctx context.Context, modPath string) {\n-\tmodRoot = base.Cwd()\n+\tmodRoot := base.Cwd()\n+\tmodRoots = []string{modRoot}\n \tInit()\n-\tmodFilePath := ModFilePath()\n+\tmodFilePath := modFilePath(modRoot)\n \tif _, err := fsys.Stat(modFilePath); err == nil {\n \t\tbase.Fatalf(\"go: %s already exists\", modFilePath)\n \t}\n@@ -523,28 +818,38 @@ func CreateModFile(ctx context.Context, modPath string) {\n \t\t\t}\n \t\t}\n \t\tbase.Fatalf(\"go: %v\", err)\n+\t} else if _, _, ok := module.SplitPathVersion(modPath); !ok {\n+\t\tif strings.HasPrefix(modPath, \"gopkg.in/\") {\n+\t\t\tinvalidMajorVersionMsg := fmt.Errorf(\"module paths beginning with gopkg.in/ must always have a major version suffix in the form of .vN:\\n\\tgo mod init %s\", suggestGopkgIn(modPath))\n+\t\t\tbase.Fatalf(`go: invalid module path \"%v\": %v`, modPath, invalidMajorVersionMsg)\n+\t\t}\n+\t\tinvalidMajorVersionMsg := fmt.Errorf(\"major version suffixes must be in the form of /vN and are only allowed for v2 or later:\\n\\tgo mod init %s\", suggestModulePath(modPath))\n+\t\tbase.Fatalf(`go: invalid module path \"%v\": %v`, modPath, invalidMajorVersionMsg)\n \t}\n \n \tfmt.Fprintf(os.Stderr, \"go: creating new go.mod: module %s\\n\", modPath)\n-\tmodFile = new(modfile.File)\n+\tmodFile := new(modfile.File)\n \tmodFile.AddModuleStmt(modPath)\n-\tinitTarget(modFile.Module.Mod)\n-\taddGoStmt(LatestGoVersion()) // Add the go directive before converted module requirements.\n+\tMainModules = makeMainModules([]module.Version{modFile.Module.Mod}, []string{modRoot}, []*modfile.File{modFile}, []*modFileIndex{nil}, \"\", nil)\n+\taddGoStmt(modFile, modFile.Module.Mod, LatestGoVersion()) // Add the go directive before converted module requirements.\n \n-\tconvertedFrom, err := convertLegacyConfig(modPath)\n+\tconvertedFrom, err := convertLegacyConfig(modFile, modRoot)\n \tif convertedFrom != \"\" {\n \t\tfmt.Fprintf(os.Stderr, \"go: copying requirements from %s\\n\", base.ShortPath(convertedFrom))\n \t}\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\trs := requirementsFromModFile()\n+\trs := requirementsFromModFiles(ctx, []*modfile.File{modFile})\n \trs, err = updateRoots(ctx, rs.direct, rs, nil, nil, false)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n-\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\trequirements = rs\n+\tif err := commitRequirements(ctx); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n \n \t// Suggest running 'go mod tidy' unless the project is empty. Even if we\n \t// imported all the correct requirements above, we're probably missing\n@@ -570,6 +875,32 @@ func CreateModFile(ctx context.Context, modPath string) {\n \t}\n }\n \n+// CreateWorkFile initializes a new workspace by creating a go.work file.\n+func CreateWorkFile(ctx context.Context, workFile string, modDirs []string) {\n+\tif _, err := fsys.Stat(workFile); err == nil {\n+\t\tbase.Fatalf(\"go: %s already exists\", workFile)\n+\t}\n+\n+\tgoV := LatestGoVersion() // Use current Go version by default\n+\tworkF := new(modfile.WorkFile)\n+\tworkF.Syntax = new(modfile.FileSyntax)\n+\tworkF.AddGoStmt(goV)\n+\n+\tfor _, dir := range modDirs {\n+\t\t_, f, err := ReadModFile(filepath.Join(dir, \"go.mod\"), nil)\n+\t\tif err != nil {\n+\t\t\tif os.IsNotExist(err) {\n+\t\t\t\tbase.Fatalf(\"go: creating workspace file: no go.mod file exists in directory %v\", dir)\n+\t\t\t}\n+\t\t\tbase.Fatalf(\"go: error parsing go.mod in directory %s: %v\", dir, err)\n+\t\t}\n+\t\tworkF.AddUse(ToDirectoryPath(dir), f.Module.Mod.Path)\n+\t}\n+\n+\tUpdateWorkFile(workF)\n+\tWriteWorkFile(workFile, workF)\n+}\n+\n // fixVersion returns a modfile.VersionFixer implemented using the Query function.\n //\n // It resolves commit hashes and branch names to versions,\n@@ -632,68 +963,161 @@ func AllowMissingModuleImports() {\n \tallowMissingModuleImports = true\n }\n \n-// initTarget sets Target and associated variables according to modFile,\n-func initTarget(m module.Version) {\n-\tTarget = m\n-\ttargetPrefix = m.Path\n-\n-\tif rel := search.InDir(base.Cwd(), cfg.GOROOTsrc); rel != \"\" {\n-\t\ttargetInGorootSrc = true\n-\t\tif m.Path == \"std\" {\n-\t\t\t// The \"std\" module in GOROOT/src is the Go standard library. Unlike other\n-\t\t\t// modules, the packages in the \"std\" module have no import-path prefix.\n-\t\t\t//\n-\t\t\t// Modules named \"std\" outside of GOROOT/src do not receive this special\n-\t\t\t// treatment, so it is possible to run 'go test .' in other GOROOTs to\n-\t\t\t// test individual packages using a combination of the modified package\n-\t\t\t// and the ordinary standard library.\n-\t\t\t// (See https://golang.org/issue/30756.)\n-\t\t\ttargetPrefix = \"\"\n+// makeMainModules creates a MainModuleSet and associated variables according to\n+// the given main modules.\n+func makeMainModules(ms []module.Version, rootDirs []string, modFiles []*modfile.File, indices []*modFileIndex, workFileGoVersion string, workFileReplaces []*modfile.Replace) *MainModuleSet {\n+\tfor _, m := range ms {\n+\t\tif m.Version != \"\" {\n+\t\t\tpanic(\"mainModulesCalled with module.Version with non empty Version field: \" + fmt.Sprintf(\"%#v\", m))\n \t\t}\n \t}\n+\tmodRootContainingCWD := findModuleRoot(base.Cwd())\n+\tmainModules := &MainModuleSet{\n+\t\tversions:           ms[:len(ms):len(ms)],\n+\t\tinGorootSrc:        map[module.Version]bool{},\n+\t\tpathPrefix:         map[module.Version]string{},\n+\t\tmodRoot:            map[module.Version]string{},\n+\t\tmodFiles:           map[module.Version]*modfile.File{},\n+\t\tindices:            map[module.Version]*modFileIndex{},\n+\t\tworkFileGoVersion:  workFileGoVersion,\n+\t\tworkFileReplaceMap: toReplaceMap(workFileReplaces),\n+\t\thighestReplaced:    map[string]string{},\n+\t}\n+\tmainModulePaths := make(map[string]bool)\n+\tfor _, m := range ms {\n+\t\tmainModulePaths[m.Path] = true\n+\t}\n+\treplacedByWorkFile := make(map[string]bool)\n+\treplacements := make(map[module.Version]module.Version)\n+\tfor _, r := range workFileReplaces {\n+\t\tif mainModulePaths[r.Old.Path] && r.Old.Version == \"\" {\n+\t\t\tbase.Errorf(\"go: workspace module %v is replaced at all versions in the go.work file. To fix, remove the replacement from the go.work file or specify the version at which to replace the module.\", r.Old.Path)\n+\t\t}\n+\t\treplacedByWorkFile[r.Old.Path] = true\n+\t\tv, ok := mainModules.highestReplaced[r.Old.Path]\n+\t\tif !ok || semver.Compare(r.Old.Version, v) > 0 {\n+\t\t\tmainModules.highestReplaced[r.Old.Path] = r.Old.Version\n+\t\t}\n+\t\treplacements[r.Old] = r.New\n+\t}\n+\tfor i, m := range ms {\n+\t\tmainModules.pathPrefix[m] = m.Path\n+\t\tmainModules.modRoot[m] = rootDirs[i]\n+\t\tmainModules.modFiles[m] = modFiles[i]\n+\t\tmainModules.indices[m] = indices[i]\n+\n+\t\tif mainModules.modRoot[m] == modRootContainingCWD {\n+\t\t\tmainModules.modContainingCWD = m\n+\t\t}\n+\n+\t\tif rel := search.InDir(rootDirs[i], cfg.GOROOTsrc); rel != \"\" {\n+\t\t\tmainModules.inGorootSrc[m] = true\n+\t\t\tif m.Path == \"std\" {\n+\t\t\t\t// The \"std\" module in GOROOT/src is the Go standard library. Unlike other\n+\t\t\t\t// modules, the packages in the \"std\" module have no import-path prefix.\n+\t\t\t\t//\n+\t\t\t\t// Modules named \"std\" outside of GOROOT/src do not receive this special\n+\t\t\t\t// treatment, so it is possible to run 'go test .' in other GOROOTs to\n+\t\t\t\t// test individual packages using a combination of the modified package\n+\t\t\t\t// and the ordinary standard library.\n+\t\t\t\t// (See https://golang.org/issue/30756.)\n+\t\t\t\tmainModules.pathPrefix[m] = \"\"\n+\t\t\t}\n+\t\t}\n+\n+\t\tif modFiles[i] != nil {\n+\t\t\tcurModuleReplaces := make(map[module.Version]bool)\n+\t\t\tfor _, r := range modFiles[i].Replace {\n+\t\t\t\tif replacedByWorkFile[r.Old.Path] {\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else if prev, ok := replacements[r.Old]; ok && !curModuleReplaces[r.Old] && prev != r.New {\n+\t\t\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\\nuse \\\"go work edit -replace %v=[override]\\\" to resolve\", r.Old, prev, r.New, r.Old)\n+\t\t\t\t}\n+\t\t\t\tcurModuleReplaces[r.Old] = true\n+\t\t\t\treplacements[r.Old] = r.New\n+\n+\t\t\t\tv, ok := mainModules.highestReplaced[r.Old.Path]\n+\t\t\t\tif !ok || semver.Compare(r.Old.Version, v) > 0 {\n+\t\t\t\t\tmainModules.highestReplaced[r.Old.Path] = r.Old.Version\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn mainModules\n }\n \n-// requirementsFromModFile returns the set of non-excluded requirements from\n+// requirementsFromModFiles returns the set of non-excluded requirements from\n // the global modFile.\n-func requirementsFromModFile() *Requirements {\n-\troots := make([]module.Version, 0, len(modFile.Require))\n+func requirementsFromModFiles(ctx context.Context, modFiles []*modfile.File) *Requirements {\n+\tvar roots []module.Version\n \tdirect := map[string]bool{}\n-\tfor _, r := range modFile.Require {\n-\t\tif index != nil && index.exclude[r.Mod] {\n-\t\t\tif cfg.BuildMod == \"mod\" {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: dropping requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n-\t\t\t} else {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"go: ignoring requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n-\t\t\t}\n-\t\t\tcontinue\n+\tvar pruning modPruning\n+\tif inWorkspaceMode() {\n+\t\tpruning = workspace\n+\t\troots = make([]module.Version, len(MainModules.Versions()))\n+\t\tcopy(roots, MainModules.Versions())\n+\t} else {\n+\t\tpruning = pruningForGoVersion(MainModules.GoVersion())\n+\t\tif len(modFiles) != 1 {\n+\t\t\tpanic(fmt.Errorf(\"requirementsFromModFiles called with %v modfiles outside workspace mode\", len(modFiles)))\n \t\t}\n+\t\tmodFile := modFiles[0]\n+\t\troots = make([]module.Version, 0, len(modFile.Require))\n+\t\tmm := MainModules.mustGetSingleMainModule()\n+\t\tfor _, r := range modFile.Require {\n+\t\t\tif index := MainModules.Index(mm); index != nil && index.exclude[r.Mod] {\n+\t\t\t\tif cfg.BuildMod == \"mod\" {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"go: dropping requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n+\t\t\t\t} else {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"go: ignoring requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\troots = append(roots, r.Mod)\n-\t\tif !r.Indirect {\n-\t\t\tdirect[r.Mod.Path] = true\n+\t\t\troots = append(roots, r.Mod)\n+\t\t\tif !r.Indirect {\n+\t\t\t\tdirect[r.Mod.Path] = true\n+\t\t\t}\n \t\t}\n \t}\n \tmodule.Sort(roots)\n-\trs := newRequirements(modDepthFromGoVersion(modFileGoVersion()), roots, direct)\n+\trs := newRequirements(pruning, roots, direct)\n \treturn rs\n }\n \n // setDefaultBuildMod sets a default value for cfg.BuildMod if the -mod flag\n // wasn't provided. setDefaultBuildMod may be called multiple times.\n func setDefaultBuildMod() {\n \tif cfg.BuildModExplicit {\n+\t\tif inWorkspaceMode() && cfg.BuildMod != \"readonly\" {\n+\t\t\tbase.Fatalf(\"go: -mod may only be set to readonly when in workspace mode, but it is set to %q\"+\n+\t\t\t\t\"\\n\\tRemove the -mod flag to use the default readonly value,\"+\n+\t\t\t\t\"\\n\\tor set -workfile=off to disable workspace mode.\", cfg.BuildMod)\n+\t\t}\n \t\t// Don't override an explicit '-mod=' argument.\n \t\treturn\n \t}\n \n-\tif cfg.CmdName == \"get\" || strings.HasPrefix(cfg.CmdName, \"mod \") {\n-\t\t// 'get' and 'go mod' commands may update go.mod automatically.\n-\t\t// TODO(jayconrod): should this narrower? Should 'go mod download' or\n-\t\t// 'go mod graph' update go.mod by default?\n+\t// TODO(#40775): commands should pass in the module mode as an option\n+\t// to modload functions instead of relying on an implicit setting\n+\t// based on command name.\n+\tswitch cfg.CmdName {\n+\tcase \"get\", \"mod download\", \"mod init\", \"mod tidy\", \"work sync\":\n+\t\t// These commands are intended to update go.mod and go.sum.\n+\t\tcfg.BuildMod = \"mod\"\n+\t\treturn\n+\tcase \"mod graph\", \"mod verify\", \"mod why\":\n+\t\t// These commands should not update go.mod or go.sum, but they should be\n+\t\t// able to fetch modules not in go.sum and should not report errors if\n+\t\t// go.mod is inconsistent. They're useful for debugging, and they need\n+\t\t// to work in buggy situations.\n \t\tcfg.BuildMod = \"mod\"\n \t\treturn\n+\tcase \"mod vendor\":\n+\t\tcfg.BuildMod = \"readonly\"\n+\t\treturn\n \t}\n-\tif modRoot == \"\" {\n+\tif modRoots == nil {\n \t\tif allowMissingModuleImports {\n \t\t\tcfg.BuildMod = \"mod\"\n \t\t} else {\n@@ -702,31 +1126,38 @@ func setDefaultBuildMod() {\n \t\treturn\n \t}\n \n-\tif fi, err := fsys.Stat(filepath.Join(modRoot, \"vendor\")); err == nil && fi.IsDir() {\n-\t\tmodGo := \"unspecified\"\n-\t\tif index != nil && index.goVersionV != \"\" {\n-\t\t\tif semver.Compare(index.goVersionV, \"v1.14\") >= 0 {\n-\t\t\t\t// The Go version is at least 1.14, and a vendor directory exists.\n-\t\t\t\t// Set -mod=vendor by default.\n-\t\t\t\tcfg.BuildMod = \"vendor\"\n-\t\t\t\tcfg.BuildModReason = \"Go version in go.mod is at least 1.14 and vendor directory exists.\"\n-\t\t\t\treturn\n-\t\t\t} else {\n-\t\t\t\tmodGo = index.goVersionV[1:]\n+\tif len(modRoots) == 1 {\n+\t\tindex := MainModules.GetSingleIndexOrNil()\n+\t\tif fi, err := fsys.Stat(filepath.Join(modRoots[0], \"vendor\")); err == nil && fi.IsDir() {\n+\t\t\tmodGo := \"unspecified\"\n+\t\t\tif index != nil && index.goVersionV != \"\" {\n+\t\t\t\tif semver.Compare(index.goVersionV, \"v1.14\") >= 0 {\n+\t\t\t\t\t// The Go version is at least 1.14, and a vendor directory exists.\n+\t\t\t\t\t// Set -mod=vendor by default.\n+\t\t\t\t\tcfg.BuildMod = \"vendor\"\n+\t\t\t\t\tcfg.BuildModReason = \"Go version in go.mod is at least 1.14 and vendor directory exists.\"\n+\t\t\t\t\treturn\n+\t\t\t\t} else {\n+\t\t\t\t\tmodGo = index.goVersionV[1:]\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t// Since a vendor directory exists, we should record why we didn't use it.\n-\t\t// This message won't normally be shown, but it may appear with import errors.\n-\t\tcfg.BuildModReason = fmt.Sprintf(\"Go version in go.mod is %s, so vendor directory was not used.\", modGo)\n+\t\t\t// Since a vendor directory exists, we should record why we didn't use it.\n+\t\t\t// This message won't normally be shown, but it may appear with import errors.\n+\t\t\tcfg.BuildModReason = fmt.Sprintf(\"Go version in go.mod is %s, so vendor directory was not used.\", modGo)\n+\t\t}\n \t}\n \n \tcfg.BuildMod = \"readonly\"\n }\n \n+func mustHaveCompleteRequirements() bool {\n+\treturn cfg.BuildMod != \"mod\" && !inWorkspaceMode()\n+}\n+\n // convertLegacyConfig imports module requirements from a legacy vendoring\n // configuration file, if one is present.\n-func convertLegacyConfig(modPath string) (from string, err error) {\n+func convertLegacyConfig(modFile *modfile.File, modRoot string) (from string, err error) {\n \tnoneSelected := func(path string) (version string) { return \"none\" }\n \tqueryPackage := func(path, rev string) (module.Version, error) {\n \t\tpkgMods, modOnly, err := QueryPattern(context.Background(), path, rev, noneSelected, nil)\n@@ -757,14 +1188,14 @@ func convertLegacyConfig(modPath string) (from string, err error) {\n // addGoStmt adds a go directive to the go.mod file if it does not already\n // include one. The 'go' version added, if any, is the latest version supported\n // by this toolchain.\n-func addGoStmt(v string) {\n+func addGoStmt(modFile *modfile.File, mod module.Version, v string) {\n \tif modFile.Go != nil && modFile.Go.Version != \"\" {\n \t\treturn\n \t}\n \tif err := modFile.AddGoStmt(v); err != nil {\n \t\tbase.Fatalf(\"go: internal error: %v\", err)\n \t}\n-\trawGoVersion.Store(Target, v)\n+\trawGoVersion.Store(mod, v)\n }\n \n // LatestGoVersion returns the latest version of the Go language supported by\n@@ -815,7 +1246,7 @@ var altConfigs = []string{\n \t\".git/config\",\n }\n \n-func findModuleRoot(dir string) (root string) {\n+func findModuleRoot(dir string) (roots string) {\n \tif dir == \"\" {\n \t\tpanic(\"dir not set\")\n \t}\n@@ -835,6 +1266,33 @@ func findModuleRoot(dir string) (root string) {\n \treturn \"\"\n }\n \n+func findWorkspaceFile(dir string) (root string) {\n+\tif dir == \"\" {\n+\t\tpanic(\"dir not set\")\n+\t}\n+\tdir = filepath.Clean(dir)\n+\n+\t// Look for enclosing go.mod.\n+\tfor {\n+\t\tf := filepath.Join(dir, \"go.work\")\n+\t\tif fi, err := fsys.Stat(f); err == nil && !fi.IsDir() {\n+\t\t\treturn f\n+\t\t}\n+\t\td := filepath.Dir(dir)\n+\t\tif d == dir {\n+\t\t\tbreak\n+\t\t}\n+\t\tif d == cfg.GOROOT {\n+\t\t\t// As a special case, don't cross GOROOT to find a go.work file.\n+\t\t\t// The standard library and commands built in go always use the vendored\n+\t\t\t// dependencies, so avoid using a most likely irrelevant go.work file.\n+\t\t\treturn \"\"\n+\t\t}\n+\t\tdir = d\n+\t}\n+\treturn \"\"\n+}\n+\n func findAltConfig(dir string) (root, name string) {\n \tif dir == \"\" {\n \t\tpanic(\"dir not set\")\n@@ -960,66 +1418,62 @@ func findImportComment(file string) string {\n \treturn path\n }\n \n-var allowWriteGoMod = true\n-\n-// DisallowWriteGoMod causes future calls to WriteGoMod to do nothing at all.\n-func DisallowWriteGoMod() {\n-\tallowWriteGoMod = false\n-}\n-\n-// AllowWriteGoMod undoes the effect of DisallowWriteGoMod:\n-// future calls to WriteGoMod will update go.mod if needed.\n-// Note that any past calls have been discarded, so typically\n-// a call to AlowWriteGoMod should be followed by a call to WriteGoMod.\n-func AllowWriteGoMod() {\n-\tallowWriteGoMod = true\n-}\n-\n // WriteGoMod writes the current build list back to go.mod.\n-func WriteGoMod(ctx context.Context) {\n-\tif !allowWriteGoMod {\n-\t\tpanic(\"WriteGoMod called while disallowed\")\n-\t}\n-\tcommitRequirements(ctx, modFileGoVersion(), LoadModFile(ctx))\n+func WriteGoMod(ctx context.Context) error {\n+\trequirements = LoadModFile(ctx)\n+\treturn commitRequirements(ctx)\n }\n \n-// commitRequirements writes sets the global requirements variable to rs and\n-// writes its contents back to the go.mod file on disk.\n-func commitRequirements(ctx context.Context, goVersion string, rs *Requirements) {\n-\trequirements = rs\n-\n-\tif !allowWriteGoMod {\n-\t\t// Some package outside of modload promised to update the go.mod file later.\n-\t\treturn\n-\t}\n-\n-\tif modRoot == \"\" {\n+// commitRequirements ensures go.mod and go.sum are up to date with the current\n+// requirements.\n+//\n+// In \"mod\" mode, commitRequirements writes changes to go.mod and go.sum.\n+//\n+// In \"readonly\" and \"vendor\" modes, commitRequirements returns an error if\n+// go.mod or go.sum are out of date in a semantically significant way.\n+//\n+// In workspace mode, commitRequirements only writes changes to go.work.sum.\n+func commitRequirements(ctx context.Context) (err error) {\n+\tif inWorkspaceMode() {\n+\t\t// go.mod files aren't updated in workspace mode, but we still want to\n+\t\t// update the go.work.sum file.\n+\t\treturn modfetch.WriteGoSum(keepSums(ctx, loaded, requirements, addBuildListZipSums), mustHaveCompleteRequirements())\n+\t}\n+\tif MainModules.Len() != 1 || MainModules.ModRoot(MainModules.Versions()[0]) == \"\" {\n \t\t// We aren't in a module, so we don't have anywhere to write a go.mod file.\n-\t\treturn\n+\t\treturn nil\n+\t}\n+\tmainModule := MainModules.mustGetSingleMainModule()\n+\tmodFile := MainModules.ModFile(mainModule)\n+\tif modFile == nil {\n+\t\t// command-line-arguments has no .mod file to write.\n+\t\treturn nil\n \t}\n+\tmodFilePath := modFilePath(MainModules.ModRoot(mainModule))\n \n \tvar list []*modfile.Require\n-\tfor _, m := range rs.rootModules {\n+\tfor _, m := range requirements.rootModules {\n \t\tlist = append(list, &modfile.Require{\n \t\t\tMod:      m,\n-\t\t\tIndirect: !rs.direct[m.Path],\n+\t\t\tIndirect: !requirements.direct[m.Path],\n \t\t})\n \t}\n-\tif goVersion != \"\" {\n-\t\tmodFile.AddGoStmt(goVersion)\n+\tif modFile.Go == nil || modFile.Go.Version == \"\" {\n+\t\tmodFile.AddGoStmt(modFileGoVersion(modFile))\n \t}\n-\tif semver.Compare(\"v\"+modFileGoVersion(), separateIndirectVersionV) < 0 {\n+\tif semver.Compare(\"v\"+modFileGoVersion(modFile), separateIndirectVersionV) < 0 {\n \t\tmodFile.SetRequire(list)\n \t} else {\n \t\tmodFile.SetRequireSeparateIndirect(list)\n \t}\n \tmodFile.Cleanup()\n \n+\tindex := MainModules.GetSingleIndexOrNil()\n \tdirty := index.modFileIsDirty(modFile)\n \tif dirty && cfg.BuildMod != \"mod\" {\n \t\t// If we're about to fail due to -mod=readonly,\n \t\t// prefer to report a dirty go.mod over a dirty go.sum\n-\t\tbase.Fatalf(\"go: %v\", errGoModDirty)\n+\t\treturn errGoModDirty\n \t}\n \n \tif !dirty && cfg.CmdName != \"mod tidy\" {\n@@ -1028,30 +1482,33 @@ func commitRequirements(ctx context.Context, goVersion string, rs *Requirements)\n \t\t// Don't write go.mod, but write go.sum in case we added or trimmed sums.\n \t\t// 'go mod init' shouldn't write go.sum, since it will be incomplete.\n \t\tif cfg.CmdName != \"mod init\" {\n-\t\t\tmodfetch.WriteGoSum(keepSums(ctx, loaded, rs, addBuildListZipSums))\n+\t\t\tif err := modfetch.WriteGoSum(keepSums(ctx, loaded, requirements, addBuildListZipSums), mustHaveCompleteRequirements()); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n-\t\treturn\n+\t\treturn nil\n \t}\n-\tgomod := ModFilePath()\n-\tif _, ok := fsys.OverlayPath(gomod); ok {\n+\tif _, ok := fsys.OverlayPath(modFilePath); ok {\n \t\tif dirty {\n-\t\t\tbase.Fatalf(\"go: updates to go.mod needed, but go.mod is part of the overlay specified with -overlay\")\n+\t\t\treturn errors.New(\"updates to go.mod needed, but go.mod is part of the overlay specified with -overlay\")\n \t\t}\n-\t\treturn\n+\t\treturn nil\n \t}\n \n \tnew, err := modFile.Format()\n \tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n+\t\treturn err\n \t}\n \tdefer func() {\n \t\t// At this point we have determined to make the go.mod file on disk equal to new.\n-\t\tindex = indexModFile(new, modFile, false)\n+\t\tMainModules.SetIndex(mainModule, indexModFile(new, modFile, mainModule, false))\n \n \t\t// Update go.sum after releasing the side lock and refreshing the index.\n \t\t// 'go mod init' shouldn't write go.sum, since it will be incomplete.\n \t\tif cfg.CmdName != \"mod init\" {\n-\t\t\tmodfetch.WriteGoSum(keepSums(ctx, loaded, rs, addBuildListZipSums))\n+\t\t\tif err == nil {\n+\t\t\t\terr = modfetch.WriteGoSum(keepSums(ctx, loaded, requirements, addBuildListZipSums), mustHaveCompleteRequirements())\n+\t\t\t}\n \t\t}\n \t}()\n \n@@ -1063,7 +1520,7 @@ func commitRequirements(ctx context.Context, goVersion string, rs *Requirements)\n \n \terrNoChange := errors.New(\"no update needed\")\n \n-\terr = lockedfile.Transform(ModFilePath(), func(old []byte) ([]byte, error) {\n+\terr = lockedfile.Transform(modFilePath, func(old []byte) ([]byte, error) {\n \t\tif bytes.Equal(old, new) {\n \t\t\t// The go.mod file is already equal to new, possibly as the result of some\n \t\t\t// other process.\n@@ -1084,8 +1541,9 @@ func commitRequirements(ctx context.Context, goVersion string, rs *Requirements)\n \t})\n \n \tif err != nil && err != errNoChange {\n-\t\tbase.Fatalf(\"go: updating go.mod: %v\", err)\n+\t\treturn fmt.Errorf(\"updating go.mod: %w\", err)\n \t}\n+\treturn nil\n }\n \n // keepSums returns the set of modules (and go.mod file entries) for which\n@@ -1113,16 +1571,18 @@ func keepSums(ctx context.Context, ld *loader, rs *Requirements, which whichSums\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\tif rs.depth == lazy && pkg.mod.Path != \"\" {\n+\t\t\tif rs.pruning == pruned && pkg.mod.Path != \"\" {\n \t\t\t\tif v, ok := rs.rootSelected(pkg.mod.Path); ok && v == pkg.mod.Version {\n-\t\t\t\t\t// pkg was loaded from a root module, and because the main module is\n-\t\t\t\t\t// lazy we do not check non-root modules for conflicts for packages\n-\t\t\t\t\t// that can be found in roots. So we only need the checksums for the\n-\t\t\t\t\t// root modules that may contain pkg, not all possible modules.\n+\t\t\t\t\t// pkg was loaded from a root module, and because the main module has\n+\t\t\t\t\t// a pruned module graph we do not check non-root modules for\n+\t\t\t\t\t// conflicts for packages that can be found in roots. So we only need\n+\t\t\t\t\t// the checksums for the root modules that may contain pkg, not all\n+\t\t\t\t\t// possible modules.\n \t\t\t\t\tfor prefix := pkg.path; prefix != \".\"; prefix = path.Dir(prefix) {\n \t\t\t\t\t\tif v, ok := rs.rootSelected(prefix); ok && v != \"none\" {\n \t\t\t\t\t\t\tm := module.Version{Path: prefix, Version: v}\n-\t\t\t\t\t\t\tkeep[resolveReplacement(m)] = true\n+\t\t\t\t\t\t\tr := resolveReplacement(m)\n+\t\t\t\t\t\t\tkeep[r] = true\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tcontinue\n@@ -1133,15 +1593,15 @@ func keepSums(ctx context.Context, ld *loader, rs *Requirements, which whichSums\n \t\t\tfor prefix := pkg.path; prefix != \".\"; prefix = path.Dir(prefix) {\n \t\t\t\tif v := mg.Selected(prefix); v != \"none\" {\n \t\t\t\t\tm := module.Version{Path: prefix, Version: v}\n-\t\t\t\t\tkeep[resolveReplacement(m)] = true\n+\t\t\t\t\tr := resolveReplacement(m)\n+\t\t\t\t\tkeep[r] = true\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \tif rs.graph.Load() == nil {\n-\t\t// The module graph was not loaded, possibly because the main module is lazy\n-\t\t// or possibly because we haven't needed to load the graph yet.\n+\t\t// We haven't needed to load the module graph so far.\n \t\t// Save sums for the root modules (or their replacements), but don't\n \t\t// incur the cost of loading the graph just to find and retain the sums.\n \t\tfor _, m := range rs.rootModules {\n@@ -1158,13 +1618,15 @@ func keepSums(ctx context.Context, ld *loader, rs *Requirements, which whichSums\n \t\t\t\t// The requirements from m's go.mod file are present in the module graph,\n \t\t\t\t// so they are relevant to the MVS result regardless of whether m was\n \t\t\t\t// actually selected.\n-\t\t\t\tkeep[modkey(resolveReplacement(m))] = true\n+\t\t\t\tr := resolveReplacement(m)\n+\t\t\t\tkeep[modkey(r)] = true\n \t\t\t}\n \t\t})\n \n \t\tif which == addBuildListZipSums {\n \t\t\tfor _, m := range mg.BuildList() {\n-\t\t\t\tkeep[resolveReplacement(m)] = true\n+\t\t\t\tr := resolveReplacement(m)\n+\t\t\t\tkeep[r] = true\n \t\t\t}\n \t\t}\n \t}\n@@ -1184,3 +1646,56 @@ const (\n func modkey(m module.Version) module.Version {\n \treturn module.Version{Path: m.Path, Version: m.Version + \"/go.mod\"}\n }\n+\n+func suggestModulePath(path string) string {\n+\tvar m string\n+\n+\ti := len(path)\n+\tfor i > 0 && ('0' <= path[i-1] && path[i-1] <= '9' || path[i-1] == '.') {\n+\t\ti--\n+\t}\n+\turl := path[:i]\n+\turl = strings.TrimSuffix(url, \"/v\")\n+\turl = strings.TrimSuffix(url, \"/\")\n+\n+\tf := func(c rune) bool {\n+\t\treturn c > '9' || c < '0'\n+\t}\n+\ts := strings.FieldsFunc(path[i:], f)\n+\tif len(s) > 0 {\n+\t\tm = s[0]\n+\t}\n+\tm = strings.TrimLeft(m, \"0\")\n+\tif m == \"\" || m == \"1\" {\n+\t\treturn url + \"/v2\"\n+\t}\n+\n+\treturn url + \"/v\" + m\n+}\n+\n+func suggestGopkgIn(path string) string {\n+\tvar m string\n+\ti := len(path)\n+\tfor i > 0 && (('0' <= path[i-1] && path[i-1] <= '9') || (path[i-1] == '.')) {\n+\t\ti--\n+\t}\n+\turl := path[:i]\n+\turl = strings.TrimSuffix(url, \".v\")\n+\turl = strings.TrimSuffix(url, \"/v\")\n+\turl = strings.TrimSuffix(url, \"/\")\n+\n+\tf := func(c rune) bool {\n+\t\treturn c > '9' || c < '0'\n+\t}\n+\ts := strings.FieldsFunc(path, f)\n+\tif len(s) > 0 {\n+\t\tm = s[0]\n+\t}\n+\n+\tm = strings.TrimLeft(m, \"0\")\n+\n+\tif m == \"\" {\n+\t\treturn url + \".v1\"\n+\t}\n+\treturn url + \".v\" + m\n+}"}, {"sha": "f782cd93db3d25d2258303fc22239c09156ff1c8", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -72,14 +72,21 @@ func ListModules(ctx context.Context, args []string, mode ListMode) ([]*modinfo.\n \t}\n \n \tif err == nil {\n-\t\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\t\trequirements = rs\n+\t\tif !ExplicitWriteGoMod {\n+\t\t\terr = commitRequirements(ctx)\n+\t\t}\n \t}\n \treturn mods, err\n }\n \n func listModules(ctx context.Context, rs *Requirements, args []string, mode ListMode) (_ *Requirements, mods []*modinfo.ModulePublic, mgErr error) {\n \tif len(args) == 0 {\n-\t\treturn rs, []*modinfo.ModulePublic{moduleInfo(ctx, rs, Target, mode)}, nil\n+\t\tvar ms []*modinfo.ModulePublic\n+\t\tfor _, m := range MainModules.Versions() {\n+\t\t\tms = append(ms, moduleInfo(ctx, rs, m, mode))\n+\t\t}\n+\t\treturn rs, ms, nil\n \t}\n \n \tneedFullGraph := false\n@@ -101,7 +108,7 @@ func listModules(ctx context.Context, rs *Requirements, args []string, mode List\n \t\t\tpath := arg[:i]\n \t\t\tvers := arg[i+1:]\n \t\t\tif vers == \"upgrade\" || vers == \"patch\" {\n-\t\t\t\tif _, ok := rs.rootSelected(path); !ok || rs.depth == eager {\n+\t\t\t\tif _, ok := rs.rootSelected(path); !ok || rs.pruning == unpruned {\n \t\t\t\t\tneedFullGraph = true\n \t\t\t\t\tif !HasModRoot() {\n \t\t\t\t\t\tbase.Fatalf(\"go: cannot match %q: %v\", arg, ErrNoModRoot)\n@@ -110,7 +117,7 @@ func listModules(ctx context.Context, rs *Requirements, args []string, mode List\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n-\t\tif _, ok := rs.rootSelected(arg); !ok || rs.depth == eager {\n+\t\tif _, ok := rs.rootSelected(arg); !ok || rs.pruning == unpruned {\n \t\t\tneedFullGraph = true\n \t\t\tif mode&ListVersions == 0 && !HasModRoot() {\n \t\t\t\tbase.Fatalf(\"go: cannot match %q without -versions or an explicit version: %v\", arg, ErrNoModRoot)"}, {"sha": "617b634d263e335946ef51ee84a26eb0cb0dc4d8", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 229, "deletions": 114, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -40,9 +40,10 @@ package modload\n // \t- the main module specifies a go version \u2264 1.15, and the package is imported\n // \t  by a *test of* another package in \"all\".\n //\n-// When we implement lazy loading, we will record the modules providing packages\n-// in \"all\" even when we are only loading individual packages, so we set the\n-// pkgInAll flag regardless of the whether the \"all\" pattern is a root.\n+// When graph pruning is in effect, we want to spot-check the graph-pruning\n+// invariants \u2014 which depend on which packages are known to be in \"all\" \u2014 even\n+// when we are only loading individual packages, so we set the pkgInAll flag\n+// regardless of the whether the \"all\" pattern is a root.\n // (This is necessary to maintain the \u201cimport invariant\u201d described in\n // https://golang.org/design/36460-lazy-module-loading.)\n //\n@@ -230,6 +231,9 @@ type PackageOpts struct {\n \t// SilenceUnmatchedWarnings suppresses the warnings normally emitted for\n \t// patterns that did not match any packages.\n \tSilenceUnmatchedWarnings bool\n+\n+\t// Resolve the query against this module.\n+\tMainModule module.Version\n }\n \n // LoadPackages identifies the set of packages matching the given patterns and\n@@ -255,7 +259,11 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t\tcase m.IsLocal():\n \t\t\t\t// Evaluate list of file system directories on first iteration.\n \t\t\t\tif m.Dirs == nil {\n-\t\t\t\t\tmatchLocalDirs(ctx, m, rs)\n+\t\t\t\t\tmatchModRoots := modRoots\n+\t\t\t\t\tif opts.MainModule != (module.Version{}) {\n+\t\t\t\t\t\tmatchModRoots = []string{MainModules.ModRoot(opts.MainModule)}\n+\t\t\t\t\t}\n+\t\t\t\t\tmatchLocalDirs(ctx, matchModRoots, m, rs)\n \t\t\t\t}\n \n \t\t\t\t// Make a copy of the directory list and translate to import paths.\n@@ -274,7 +282,9 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \n \t\t\t\t\t\t// If we're outside of a module, ensure that the failure mode\n \t\t\t\t\t\t// indicates that.\n-\t\t\t\t\t\tModRoot()\n+\t\t\t\t\t\tif !HasModRoot() {\n+\t\t\t\t\t\t\tdie()\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t\tif ld != nil {\n \t\t\t\t\t\t\tm.AddError(err)\n@@ -306,7 +316,11 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t\t\t\t// The initial roots are the packages in the main module.\n \t\t\t\t\t// loadFromRoots will expand that to \"all\".\n \t\t\t\t\tm.Errs = m.Errs[:0]\n-\t\t\t\t\tmatchPackages(ctx, m, opts.Tags, omitStd, []module.Version{Target})\n+\t\t\t\t\tmatchModules := MainModules.Versions()\n+\t\t\t\t\tif opts.MainModule != (module.Version{}) {\n+\t\t\t\t\t\tmatchModules = []module.Version{opts.MainModule}\n+\t\t\t\t\t}\n+\t\t\t\t\tmatchPackages(ctx, m, opts.Tags, omitStd, matchModules)\n \t\t\t\t} else {\n \t\t\t\t\t// Starting with the packages in the main module,\n \t\t\t\t\t// enumerate the full list of \"all\".\n@@ -324,7 +338,7 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t}\n \t}\n \n-\tinitialRS, _ := loadModFile(ctx) // Ignore needCommit \u2014 we're going to commit at the end regardless.\n+\tinitialRS := LoadModFile(ctx)\n \n \tld := loadFromRoots(ctx, loaderParams{\n \t\tPackageOpts:  opts,\n@@ -365,7 +379,7 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \n \t\t\tfor _, m := range initialRS.rootModules {\n \t\t\t\tvar unused bool\n-\t\t\t\tif ld.requirements.depth == eager {\n+\t\t\t\tif ld.requirements.pruning == unpruned {\n \t\t\t\t\t// m is unused if it was dropped from the module graph entirely. If it\n \t\t\t\t\t// was only demoted from direct to indirect, it may still be in use via\n \t\t\t\t\t// a transitive import.\n@@ -384,7 +398,7 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t}\n \n \t\tkeep := keepSums(ctx, ld, ld.requirements, loadedZipSumsOnly)\n-\t\tif compatDepth := modDepthFromGoVersion(ld.TidyCompatibleVersion); compatDepth != ld.requirements.depth {\n+\t\tif compatDepth := pruningForGoVersion(ld.TidyCompatibleVersion); compatDepth != ld.requirements.pruning {\n \t\t\tcompatRS := newRequirements(compatDepth, ld.requirements.rootModules, ld.requirements.direct)\n \t\t\tld.checkTidyCompatibility(ctx, compatRS)\n \n@@ -393,34 +407,52 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t\t}\n \t\t}\n \n-\t\tif allowWriteGoMod {\n+\t\tif !ExplicitWriteGoMod {\n \t\t\tmodfetch.TrimGoSum(keep)\n \n \t\t\t// commitRequirements below will also call WriteGoSum, but the \"keep\" map\n \t\t\t// we have here could be strictly larger: commitRequirements only commits\n \t\t\t// loaded.requirements, but here we may have also loaded (and want to\n \t\t\t// preserve checksums for) additional entities from compatRS, which are\n \t\t\t// only needed for compatibility with ld.TidyCompatibleVersion.\n-\t\t\tmodfetch.WriteGoSum(keep)\n+\t\t\tif err := modfetch.WriteGoSum(keep, mustHaveCompleteRequirements()); err != nil {\n+\t\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Update the go.mod file's Go version if necessary.\n+\t\tmodFile := MainModules.ModFile(MainModules.mustGetSingleMainModule())\n+\t\tif ld.GoVersion != \"\" {\n+\t\t\tmodFile.AddGoStmt(ld.GoVersion)\n \t\t}\n \t}\n \n \t// Success! Update go.mod and go.sum (if needed) and return the results.\n+\t// We'll skip updating if ExplicitWriteGoMod is true (the caller has opted\n+\t// to call WriteGoMod itself) or if ResolveMissingImports is false (the\n+\t// command wants to examine the package graph as-is).\n \tloaded = ld\n-\tcommitRequirements(ctx, loaded.GoVersion, loaded.requirements)\n+\trequirements = loaded.requirements\n \n \tfor _, pkg := range ld.pkgs {\n \t\tif !pkg.isTest() {\n \t\t\tloadedPackages = append(loadedPackages, pkg.path)\n \t\t}\n \t}\n \tsort.Strings(loadedPackages)\n+\n+\tif !ExplicitWriteGoMod && opts.ResolveMissingImports {\n+\t\tif err := commitRequirements(ctx); err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t}\n+\t}\n+\n \treturn matches, loadedPackages\n }\n \n // matchLocalDirs is like m.MatchDirs, but tries to avoid scanning directories\n // outside of the standard library and active modules.\n-func matchLocalDirs(ctx context.Context, m *search.Match, rs *Requirements) {\n+func matchLocalDirs(ctx context.Context, modRoots []string, m *search.Match, rs *Requirements) {\n \tif !m.IsLocal() {\n \t\tpanic(fmt.Sprintf(\"internal error: resolveLocalDirs on non-local pattern %s\", m.Pattern()))\n \t}\n@@ -436,14 +468,23 @@ func matchLocalDirs(ctx context.Context, m *search.Match, rs *Requirements) {\n \t\tif !filepath.IsAbs(dir) {\n \t\t\tabsDir = filepath.Join(base.Cwd(), dir)\n \t\t}\n-\t\tif search.InDir(absDir, cfg.GOROOTsrc) == \"\" && search.InDir(absDir, ModRoot()) == \"\" && pathInModuleCache(ctx, absDir, rs) == \"\" {\n+\n+\t\tmodRoot := findModuleRoot(absDir)\n+\t\tfound := false\n+\t\tfor _, mainModuleRoot := range modRoots {\n+\t\t\tif mainModuleRoot == modRoot {\n+\t\t\t\tfound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !found && search.InDir(absDir, cfg.GOROOTsrc) == \"\" && pathInModuleCache(ctx, absDir, rs) == \"\" {\n \t\t\tm.Dirs = []string{}\n \t\t\tm.AddError(fmt.Errorf(\"directory prefix %s outside available modules\", base.ShortPath(absDir)))\n \t\t\treturn\n \t\t}\n \t}\n \n-\tm.MatchDirs()\n+\tm.MatchDirs(modRoots)\n }\n \n // resolveLocalPackage resolves a filesystem path to a package path.\n@@ -485,49 +526,69 @@ func resolveLocalPackage(ctx context.Context, dir string, rs *Requirements) (str\n \t\t}\n \t}\n \n-\tif modRoot != \"\" && absDir == modRoot {\n-\t\tif absDir == cfg.GOROOTsrc {\n-\t\t\treturn \"\", errPkgIsGorootSrc\n+\tfor _, mod := range MainModules.Versions() {\n+\t\tmodRoot := MainModules.ModRoot(mod)\n+\t\tif modRoot != \"\" && absDir == modRoot {\n+\t\t\tif absDir == cfg.GOROOTsrc {\n+\t\t\t\treturn \"\", errPkgIsGorootSrc\n+\t\t\t}\n+\t\t\treturn MainModules.PathPrefix(mod), nil\n \t\t}\n-\t\treturn targetPrefix, nil\n \t}\n \n \t// Note: The checks for @ here are just to avoid misinterpreting\n \t// the module cache directories (formerly GOPATH/src/mod/foo@v1.5.2/bar).\n \t// It's not strictly necessary but helpful to keep the checks.\n-\tif modRoot != \"\" && strings.HasPrefix(absDir, modRoot+string(filepath.Separator)) && !strings.Contains(absDir[len(modRoot):], \"@\") {\n-\t\tsuffix := filepath.ToSlash(absDir[len(modRoot):])\n-\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n-\t\t\tif cfg.BuildMod != \"vendor\" {\n-\t\t\t\treturn \"\", fmt.Errorf(\"without -mod=vendor, directory %s has no package path\", absDir)\n+\tvar pkgNotFoundErr error\n+\tpkgNotFoundLongestPrefix := \"\"\n+\tfor _, mainModule := range MainModules.Versions() {\n+\t\tmodRoot := MainModules.ModRoot(mainModule)\n+\t\tif modRoot != \"\" && strings.HasPrefix(absDir, modRoot+string(filepath.Separator)) && !strings.Contains(absDir[len(modRoot):], \"@\") {\n+\t\t\tsuffix := filepath.ToSlash(absDir[len(modRoot):])\n+\t\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n+\t\t\t\tif cfg.BuildMod != \"vendor\" {\n+\t\t\t\t\treturn \"\", fmt.Errorf(\"without -mod=vendor, directory %s has no package path\", absDir)\n+\t\t\t\t}\n+\n+\t\t\t\treadVendorList(mainModule)\n+\t\t\t\tpkg := strings.TrimPrefix(suffix, \"/vendor/\")\n+\t\t\t\tif _, ok := vendorPkgModule[pkg]; !ok {\n+\t\t\t\t\treturn \"\", fmt.Errorf(\"directory %s is not a package listed in vendor/modules.txt\", absDir)\n+\t\t\t\t}\n+\t\t\t\treturn pkg, nil\n \t\t\t}\n \n-\t\t\treadVendorList()\n-\t\t\tpkg := strings.TrimPrefix(suffix, \"/vendor/\")\n-\t\t\tif _, ok := vendorPkgModule[pkg]; !ok {\n-\t\t\t\treturn \"\", fmt.Errorf(\"directory %s is not a package listed in vendor/modules.txt\", absDir)\n+\t\t\tmainModulePrefix := MainModules.PathPrefix(mainModule)\n+\t\t\tif mainModulePrefix == \"\" {\n+\t\t\t\tpkg := strings.TrimPrefix(suffix, \"/\")\n+\t\t\t\tif pkg == \"builtin\" {\n+\t\t\t\t\t// \"builtin\" is a pseudo-package with a real source file.\n+\t\t\t\t\t// It's not included in \"std\", so it shouldn't resolve from \".\"\n+\t\t\t\t\t// within module \"std\" either.\n+\t\t\t\t\treturn \"\", errPkgIsBuiltin\n+\t\t\t\t}\n+\t\t\t\treturn pkg, nil\n \t\t\t}\n-\t\t\treturn pkg, nil\n-\t\t}\n \n-\t\tif targetPrefix == \"\" {\n-\t\t\tpkg := strings.TrimPrefix(suffix, \"/\")\n-\t\t\tif pkg == \"builtin\" {\n-\t\t\t\t// \"builtin\" is a pseudo-package with a real source file.\n-\t\t\t\t// It's not included in \"std\", so it shouldn't resolve from \".\"\n-\t\t\t\t// within module \"std\" either.\n-\t\t\t\treturn \"\", errPkgIsBuiltin\n+\t\t\tpkg := mainModulePrefix + suffix\n+\t\t\tif _, ok, err := dirInModule(pkg, mainModulePrefix, modRoot, true); err != nil {\n+\t\t\t\treturn \"\", err\n+\t\t\t} else if !ok {\n+\t\t\t\t// This main module could contain the directory but doesn't. Other main\n+\t\t\t\t// modules might contain the directory, so wait till we finish the loop\n+\t\t\t\t// to see if another main module contains directory. But if not,\n+\t\t\t\t// return an error.\n+\t\t\t\tif len(mainModulePrefix) > len(pkgNotFoundLongestPrefix) {\n+\t\t\t\t\tpkgNotFoundLongestPrefix = mainModulePrefix\n+\t\t\t\t\tpkgNotFoundErr = &PackageNotInModuleError{MainModules: []module.Version{mainModule}, Pattern: pkg}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t\treturn pkg, nil\n \t\t}\n-\n-\t\tpkg := targetPrefix + suffix\n-\t\tif _, ok, err := dirInModule(pkg, targetPrefix, modRoot, true); err != nil {\n-\t\t\treturn \"\", err\n-\t\t} else if !ok {\n-\t\t\treturn \"\", &PackageNotInModuleError{Mod: Target, Pattern: pkg}\n-\t\t}\n-\t\treturn pkg, nil\n+\t}\n+\tif pkgNotFoundErr != nil {\n+\t\treturn \"\", pkgNotFoundErr\n \t}\n \n \tif sub := search.InDir(absDir, cfg.GOROOTsrc); sub != \"\" && sub != \".\" && !strings.Contains(sub, \"@\") {\n@@ -560,7 +621,7 @@ func pathInModuleCache(ctx context.Context, dir string, rs *Requirements) string\n \t\tif repl := Replacement(m); repl.Path != \"\" && repl.Version == \"\" {\n \t\t\troot = repl.Path\n \t\t\tif !filepath.IsAbs(root) {\n-\t\t\t\troot = filepath.Join(ModRoot(), root)\n+\t\t\t\troot = filepath.Join(replaceRelativeTo(), root)\n \t\t\t}\n \t\t} else if repl.Path != \"\" {\n \t\t\troot, err = modfetch.DownloadDir(repl)\n@@ -583,7 +644,7 @@ func pathInModuleCache(ctx context.Context, dir string, rs *Requirements) string\n \t\treturn path.Join(m.Path, filepath.ToSlash(sub)), true\n \t}\n \n-\tif rs.depth == lazy {\n+\tif rs.pruning == pruned {\n \t\tfor _, m := range rs.rootModules {\n \t\t\tif v, _ := rs.rootSelected(m.Path); v != m.Version {\n \t\t\t\tcontinue // m is a root, but we have a higher root for the same path.\n@@ -596,9 +657,9 @@ func pathInModuleCache(ctx context.Context, dir string, rs *Requirements) string\n \t\t}\n \t}\n \n-\t// None of the roots contained dir, or we're in eager mode and want to load\n-\t// the full module graph more aggressively. Either way, check the full graph\n-\t// to see if the directory is a non-root dependency.\n+\t// None of the roots contained dir, or the graph is unpruned (so we don't want\n+\t// to distinguish between roots and transitive dependencies). Either way,\n+\t// check the full graph to see if the directory is a non-root dependency.\n \t//\n \t// If the roots are not consistent with the full module graph, the selected\n \t// versions of root modules may differ from what we already checked above.\n@@ -645,14 +706,14 @@ func ImportFromFiles(ctx context.Context, gofiles []string) {\n \t\t\treturn roots\n \t\t},\n \t})\n-\tcommitRequirements(ctx, loaded.GoVersion, loaded.requirements)\n+\trequirements = loaded.requirements\n }\n \n // DirImportPath returns the effective import path for dir,\n-// provided it is within the main module, or else returns \".\".\n-func DirImportPath(ctx context.Context, dir string) string {\n+// provided it is within a main module, or else returns \".\".\n+func (mms *MainModuleSet) DirImportPath(ctx context.Context, dir string) (path string, m module.Version) {\n \tif !HasModRoot() {\n-\t\treturn \".\"\n+\t\treturn \".\", module.Version{}\n \t}\n \tLoadModFile(ctx) // Sets targetPrefix.\n \n@@ -662,17 +723,32 @@ func DirImportPath(ctx context.Context, dir string) string {\n \t\tdir = filepath.Clean(dir)\n \t}\n \n-\tif dir == modRoot {\n-\t\treturn targetPrefix\n-\t}\n-\tif strings.HasPrefix(dir, modRoot+string(filepath.Separator)) {\n-\t\tsuffix := filepath.ToSlash(dir[len(modRoot):])\n-\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n-\t\t\treturn strings.TrimPrefix(suffix, \"/vendor/\")\n+\tvar longestPrefix string\n+\tvar longestPrefixPath string\n+\tvar longestPrefixVersion module.Version\n+\tfor _, v := range mms.Versions() {\n+\t\tmodRoot := mms.ModRoot(v)\n+\t\tif dir == modRoot {\n+\t\t\treturn mms.PathPrefix(v), v\n+\t\t}\n+\t\tif strings.HasPrefix(dir, modRoot+string(filepath.Separator)) {\n+\t\t\tpathPrefix := MainModules.PathPrefix(v)\n+\t\t\tif pathPrefix > longestPrefix {\n+\t\t\t\tlongestPrefix = pathPrefix\n+\t\t\t\tlongestPrefixVersion = v\n+\t\t\t\tsuffix := filepath.ToSlash(dir[len(modRoot):])\n+\t\t\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n+\t\t\t\t\tlongestPrefixPath = strings.TrimPrefix(suffix, \"/vendor/\")\n+\t\t\t\t}\n+\t\t\t\tlongestPrefixPath = mms.PathPrefix(v) + suffix\n+\t\t\t}\n \t\t}\n-\t\treturn targetPrefix + suffix\n \t}\n-\treturn \".\"\n+\tif len(longestPrefix) > 0 {\n+\t\treturn longestPrefixPath, longestPrefixVersion\n+\t}\n+\n+\treturn \".\", module.Version{}\n }\n \n // ImportMap returns the actual package import path\n@@ -783,7 +859,7 @@ func (ld *loader) reset() {\n \n // errorf reports an error via either os.Stderr or base.Errorf,\n // according to whether ld.AllowErrors is set.\n-func (ld *loader) errorf(format string, args ...interface{}) {\n+func (ld *loader) errorf(format string, args ...any) {\n \tif ld.AllowErrors {\n \t\tfmt.Fprintf(os.Stderr, format, args...)\n \t} else {\n@@ -807,6 +883,7 @@ type loadPkg struct {\n \timports     []*loadPkg     // packages imported by this one\n \ttestImports []string       // test-only imports, saved for use by pkg.test.\n \tinStd       bool\n+\taltMods     []module.Version // modules that could have contained the package but did not\n \n \t// Populated by (*loader).pkgTest:\n \ttestOnce sync.Once\n@@ -894,10 +971,7 @@ func (pkg *loadPkg) fromExternalModule() bool {\n \tif pkg.mod.Path == \"\" {\n \t\treturn false // loaded from the standard library, not a module\n \t}\n-\tif pkg.mod.Path == Target.Path {\n-\t\treturn false // loaded from the main module.\n-\t}\n-\treturn true\n+\treturn !MainModules.Contains(pkg.mod.Path)\n }\n \n var errMissing = errors.New(\"cannot find package\")\n@@ -915,10 +989,10 @@ func loadFromRoots(ctx context.Context, params loaderParams) *loader {\n \t}\n \n \tif ld.GoVersion == \"\" {\n-\t\tld.GoVersion = modFileGoVersion()\n+\t\tld.GoVersion = MainModules.GoVersion()\n \n \t\tif ld.Tidy && semver.Compare(\"v\"+ld.GoVersion, \"v\"+LatestGoVersion()) > 0 {\n-\t\t\tld.errorf(\"go mod tidy: go.mod file indicates go %s, but maximum supported version is %s\\n\", ld.GoVersion, LatestGoVersion())\n+\t\t\tld.errorf(\"go: go.mod file indicates go %s, but maximum version supported by tidy is %s\\n\", ld.GoVersion, LatestGoVersion())\n \t\t\tbase.ExitIfErrors()\n \t\t}\n \t}\n@@ -935,18 +1009,30 @@ func loadFromRoots(ctx context.Context, params loaderParams) *loader {\n \t}\n \n \tif semver.Compare(\"v\"+ld.GoVersion, narrowAllVersionV) < 0 && !ld.UseVendorAll {\n-\t\t// The module's go version explicitly predates the change in \"all\" for lazy\n-\t\t// loading, so continue to use the older interpretation.\n+\t\t// The module's go version explicitly predates the change in \"all\" for graph\n+\t\t// pruning, so continue to use the older interpretation.\n \t\tld.allClosesOverTests = true\n \t}\n \n \tvar err error\n-\tld.requirements, err = convertDepth(ctx, ld.requirements, modDepthFromGoVersion(ld.GoVersion))\n+\tdesiredPruning := pruningForGoVersion(ld.GoVersion)\n+\tif ld.requirements.pruning == workspace {\n+\t\tdesiredPruning = workspace\n+\t}\n+\tld.requirements, err = convertPruning(ctx, ld.requirements, desiredPruning)\n \tif err != nil {\n \t\tld.errorf(\"go: %v\\n\", err)\n \t}\n \n-\tif ld.requirements.depth == eager {\n+\tif ld.requirements.pruning == unpruned {\n+\t\t// If the module graph does not support pruning, we assume that we will need\n+\t\t// the full module graph in order to load package dependencies.\n+\t\t//\n+\t\t// This might not be strictly necessary, but it matches the historical\n+\t\t// behavior of the 'go' command and keeps the go.mod file more consistent in\n+\t\t// case of erroneous hand-edits \u2014 which are less likely to be detected by\n+\t\t// spot-checks in modules that do not maintain the expanded go.mod\n+\t\t// requirements needed for graph pruning.\n \t\tvar err error\n \t\tld.requirements, _, err = expandGraph(ctx, ld.requirements)\n \t\tif err != nil {\n@@ -963,7 +1049,7 @@ func loadFromRoots(ctx context.Context, params loaderParams) *loader {\n \t\t// build list we're using.\n \t\trootPkgs := ld.listRoots(ld.requirements)\n \n-\t\tif ld.requirements.depth == lazy && cfg.BuildMod == \"mod\" {\n+\t\tif ld.requirements.pruning == pruned && cfg.BuildMod == \"mod\" {\n \t\t\t// Before we start loading transitive imports of packages, locate all of\n \t\t\t// the root packages and promote their containing modules to root modules\n \t\t\t// dependencies. If their go.mod files are tidy (the common case) and the\n@@ -1005,7 +1091,7 @@ func loadFromRoots(ctx context.Context, params loaderParams) *loader {\n \t\t\tbreak\n \t\t}\n \t\tif changed {\n-\t\t\t// Don't resolve missing imports until the module graph have stabilized.\n+\t\t\t// Don't resolve missing imports until the module graph has stabilized.\n \t\t\t// If the roots are still changing, they may turn out to specify a\n \t\t\t// requirement on the missing package(s), and we would rather use a\n \t\t\t// version specified by a new root than add a new dependency on an\n@@ -1074,15 +1160,15 @@ func loadFromRoots(ctx context.Context, params loaderParams) *loader {\n \t\t\tld.errorf(\"go: %v\\n\", err)\n \t\t}\n \n-\t\tif ld.requirements.depth == lazy {\n+\t\tif ld.requirements.pruning == pruned {\n \t\t\t// We continuously add tidy roots to ld.requirements during loading, so at\n \t\t\t// this point the tidy roots should be a subset of the roots of\n \t\t\t// ld.requirements, ensuring that no new dependencies are brought inside\n-\t\t\t// the lazy-loading horizon.\n+\t\t\t// the graph-pruning horizon.\n \t\t\t// If that is not the case, there is a bug in the loading loop above.\n \t\t\tfor _, m := range rs.rootModules {\n \t\t\t\tif v, ok := ld.requirements.rootSelected(m.Path); !ok || v != m.Version {\n-\t\t\t\t\tld.errorf(\"go mod tidy: internal error: a requirement on %v is needed but was not added during package loading\\n\", m)\n+\t\t\t\t\tld.errorf(\"go: internal error: a requirement on %v is needed but was not added during package loading\\n\", m)\n \t\t\t\t\tbase.ExitIfErrors()\n \t\t\t\t}\n \t\t\t}\n@@ -1124,8 +1210,7 @@ func loadFromRoots(ctx context.Context, params loaderParams) *loader {\n }\n \n // updateRequirements ensures that ld.requirements is consistent with the\n-// information gained from ld.pkgs and includes the modules in add as roots at\n-// at least the given versions.\n+// information gained from ld.pkgs.\n //\n // In particular:\n //\n@@ -1168,14 +1253,32 @@ func (ld *loader) updateRequirements(ctx context.Context) (changed bool, err err\n \t}\n \n \tfor _, pkg := range ld.pkgs {\n-\t\tif pkg.mod != Target {\n+\t\tif pkg.mod.Version != \"\" || !MainModules.Contains(pkg.mod.Path) {\n \t\t\tcontinue\n \t\t}\n \t\tfor _, dep := range pkg.imports {\n \t\t\tif !dep.fromExternalModule() {\n \t\t\t\tcontinue\n \t\t\t}\n \n+\t\t\tif inWorkspaceMode() {\n+\t\t\t\t// In workspace mode / workspace pruning mode, the roots are the main modules\n+\t\t\t\t// rather than the main module's direct dependencies. The check below on the selected\n+\t\t\t\t// roots does not apply.\n+\t\t\t\tif mg, err := rs.Graph(ctx); err != nil {\n+\t\t\t\t\treturn false, err\n+\t\t\t\t} else if _, ok := mg.RequiredBy(dep.mod); !ok {\n+\t\t\t\t\t// dep.mod is not an explicit dependency, but needs to be.\n+\t\t\t\t\t// See comment on error returned below.\n+\t\t\t\t\tpkg.err = &DirectImportFromImplicitDependencyError{\n+\t\t\t\t\t\tImporterPath: pkg.path,\n+\t\t\t\t\t\tImportedPath: dep.path,\n+\t\t\t\t\t\tModule:       dep.mod,\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n \t\t\tif pkg.err == nil && cfg.BuildMod != \"mod\" {\n \t\t\t\tif v, ok := rs.rootSelected(dep.mod.Path); !ok || v != dep.mod.Version {\n \t\t\t\t\t// dep.mod is not an explicit dependency, but needs to be.\n@@ -1206,14 +1309,14 @@ func (ld *loader) updateRequirements(ctx context.Context) (changed bool, err err\n \n \tvar addRoots []module.Version\n \tif ld.Tidy {\n-\t\t// When we are tidying a lazy module, we may need to add roots to preserve\n-\t\t// the versions of indirect, test-only dependencies that are upgraded\n-\t\t// above or otherwise missing from the go.mod files of direct\n-\t\t// dependencies. (For example, the direct dependency might be a very\n+\t\t// When we are tidying a module with a pruned dependency graph, we may need\n+\t\t// to add roots to preserve the versions of indirect, test-only dependencies\n+\t\t// that are upgraded above or otherwise missing from the go.mod files of\n+\t\t// direct dependencies. (For example, the direct dependency might be a very\n \t\t// stable codebase that predates modules and thus lacks a go.mod file, or\n-\t\t// the author of the direct dependency may have forgotten to commit a\n-\t\t// change to the go.mod file, or may have made an erroneous hand-edit that\n-\t\t// causes it to be untidy.)\n+\t\t// the author of the direct dependency may have forgotten to commit a change\n+\t\t// to the go.mod file, or may have made an erroneous hand-edit that causes\n+\t\t// it to be untidy.)\n \t\t//\n \t\t// Promoting an indirect dependency to a root adds the next layer of its\n \t\t// dependencies to the module graph, which may increase the selected\n@@ -1283,7 +1386,7 @@ func (ld *loader) updateRequirements(ctx context.Context) (changed bool, err err\n \t\t\t\t//\n \t\t\t\t// In some sense, we can think of this as \u2018upgraded the module providing\n \t\t\t\t// pkg.path from \"none\" to a version higher than \"none\"\u2019.\n-\t\t\t\tif _, _, err = importFromModules(ctx, pkg.path, rs, nil); err == nil {\n+\t\t\t\tif _, _, _, err = importFromModules(ctx, pkg.path, rs, nil); err == nil {\n \t\t\t\t\tchanged = true\n \t\t\t\t\tbreak\n \t\t\t\t}\n@@ -1327,6 +1430,15 @@ func (ld *loader) resolveMissingImports(ctx context.Context) (modAddedBy map[mod\n \t\t\tvar err error\n \t\t\tmod, err = queryImport(ctx, pkg.path, ld.requirements)\n \t\t\tif err != nil {\n+\t\t\t\tvar ime *ImportMissingError\n+\t\t\t\tif errors.As(err, &ime) {\n+\t\t\t\t\tfor curstack := pkg.stack; curstack != nil; curstack = curstack.stack {\n+\t\t\t\t\t\tif MainModules.Contains(curstack.mod.Path) {\n+\t\t\t\t\t\t\time.ImportingMainModule = curstack.mod\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\t// pkg.err was already non-nil, so we can reasonably attribute the error\n \t\t\t\t// for pkg to either the original error or the one returned by\n \t\t\t\t// queryImport. The existing error indicates only that we couldn't find\n@@ -1380,7 +1492,7 @@ func (ld *loader) pkg(ctx context.Context, path string, flags loadPkgFlags) *loa\n \t\tpanic(\"internal error: (*loader).pkg called with pkgImportsLoaded flag set\")\n \t}\n \n-\tpkg := ld.pkgCache.Do(path, func() interface{} {\n+\tpkg := ld.pkgCache.Do(path, func() any {\n \t\tpkg := &loadPkg{\n \t\t\tpath: path,\n \t\t}\n@@ -1425,7 +1537,7 @@ func (ld *loader) applyPkgFlags(ctx context.Context, pkg *loadPkg, flags loadPkg\n \t\t// so it's ok if we call it more than is strictly necessary.\n \t\twantTest := false\n \t\tswitch {\n-\t\tcase ld.allPatternIsRoot && pkg.mod == Target:\n+\t\tcase ld.allPatternIsRoot && MainModules.Contains(pkg.mod.Path):\n \t\t\t// We are loading the \"all\" pattern, which includes packages imported by\n \t\t\t// tests in the main module. This package is in the main module, so we\n \t\t\t// need to identify the imports of its test even if LoadTests is not set.\n@@ -1446,7 +1558,7 @@ func (ld *loader) applyPkgFlags(ctx context.Context, pkg *loadPkg, flags loadPkg\n \n \t\tif wantTest {\n \t\t\tvar testFlags loadPkgFlags\n-\t\t\tif pkg.mod == Target || (ld.allClosesOverTests && new.has(pkgInAll)) {\n+\t\t\tif MainModules.Contains(pkg.mod.Path) || (ld.allClosesOverTests && new.has(pkgInAll)) {\n \t\t\t\t// Tests of packages in the main module are in \"all\", in the sense that\n \t\t\t\t// they cause the packages they import to also be in \"all\". So are tests\n \t\t\t\t// of packages in \"all\" if \"all\" closes over test dependencies.\n@@ -1485,7 +1597,7 @@ func (ld *loader) preloadRootModules(ctx context.Context, rootPkgs []string) (ch\n \t\t\t// If the main module is tidy and the package is in \"all\" \u2014 or if we're\n \t\t\t// lucky \u2014 we can identify all of its imports without actually loading the\n \t\t\t// full module graph.\n-\t\t\tm, _, err := importFromModules(ctx, path, ld.requirements, nil)\n+\t\t\tm, _, _, err := importFromModules(ctx, path, ld.requirements, nil)\n \t\t\tif err != nil {\n \t\t\t\tvar missing *ImportMissingError\n \t\t\t\tif errors.As(err, &missing) && ld.ResolveMissingImports {\n@@ -1511,7 +1623,8 @@ func (ld *loader) preloadRootModules(ctx context.Context, rootPkgs []string) (ch\n \t\t\t\t// module to a root to ensure that any other packages this package\n \t\t\t\t// imports are resolved from correct dependency versions.\n \t\t\t\t//\n-\t\t\t\t// (This is the \u201cargument invariant\u201d from the lazy loading design.)\n+\t\t\t\t// (This is the \u201cargument invariant\u201d from\n+\t\t\t\t// https://golang.org/design/36460-lazy-module-loading.)\n \t\t\t\tneed := <-needc\n \t\t\t\tneed[m] = true\n \t\t\t\tneedc <- need\n@@ -1573,7 +1686,7 @@ func (ld *loader) load(ctx context.Context, pkg *loadPkg) {\n \t}\n \n \tvar mg *ModuleGraph\n-\tif ld.requirements.depth == eager {\n+\tif ld.requirements.pruning == unpruned {\n \t\tvar err error\n \t\tmg, err = ld.requirements.Graph(ctx)\n \t\tif err != nil {\n@@ -1589,11 +1702,11 @@ func (ld *loader) load(ctx context.Context, pkg *loadPkg) {\n \t\t}\n \t}\n \n-\tpkg.mod, pkg.dir, pkg.err = importFromModules(ctx, pkg.path, ld.requirements, mg)\n+\tpkg.mod, pkg.dir, pkg.altMods, pkg.err = importFromModules(ctx, pkg.path, ld.requirements, mg)\n \tif pkg.dir == \"\" {\n \t\treturn\n \t}\n-\tif pkg.mod == Target {\n+\tif MainModules.Contains(pkg.mod.Path) {\n \t\t// Go ahead and mark pkg as in \"all\". This provides the invariant that a\n \t\t// package that is *only* imported by other packages in \"all\" is always\n \t\t// marked as such before loading its imports.\n@@ -1698,13 +1811,14 @@ func (ld *loader) stdVendor(parentPath, path string) string {\n \t}\n \n \tif str.HasPathPrefix(parentPath, \"cmd\") {\n-\t\tif !ld.VendorModulesInGOROOTSrc || Target.Path != \"cmd\" {\n+\t\tif !ld.VendorModulesInGOROOTSrc || !MainModules.Contains(\"cmd\") {\n \t\t\tvendorPath := pathpkg.Join(\"cmd\", \"vendor\", path)\n+\n \t\t\tif _, err := os.Stat(filepath.Join(cfg.GOROOTsrc, filepath.FromSlash(vendorPath))); err == nil {\n \t\t\t\treturn vendorPath\n \t\t\t}\n \t\t}\n-\t} else if !ld.VendorModulesInGOROOTSrc || Target.Path != \"std\" || str.HasPathPrefix(parentPath, \"vendor\") {\n+\t} else if !ld.VendorModulesInGOROOTSrc || !MainModules.Contains(\"std\") || str.HasPathPrefix(parentPath, \"vendor\") {\n \t\t// If we are outside of the 'std' module, resolve imports from within 'std'\n \t\t// to the vendor directory.\n \t\t//\n@@ -1781,7 +1895,7 @@ func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements)\n \t\tfmt.Fprintln(os.Stderr)\n \n \t\tgoFlag := \"\"\n-\t\tif ld.GoVersion != modFileGoVersion() {\n+\t\tif ld.GoVersion != MainModules.GoVersion() {\n \t\t\tgoFlag = \" -go=\" + ld.GoVersion\n \t\t}\n \n@@ -1813,7 +1927,7 @@ func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements)\n \n \tmg, err := rs.Graph(ctx)\n \tif err != nil {\n-\t\tld.errorf(\"go mod tidy: error loading go %s module graph: %v\\n\", ld.TidyCompatibleVersion, err)\n+\t\tld.errorf(\"go: error loading go %s module graph: %v\\n\", ld.TidyCompatibleVersion, err)\n \t\tsuggestFixes()\n \t\treturn\n \t}\n@@ -1847,7 +1961,7 @@ func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements)\n \n \t\tpkg := pkg\n \t\tld.work.Add(func() {\n-\t\t\tmod, _, err := importFromModules(ctx, pkg.path, rs, mg)\n+\t\t\tmod, _, _, err := importFromModules(ctx, pkg.path, rs, mg)\n \t\t\tif mod != pkg.mod {\n \t\t\t\tmismatches := <-mismatchMu\n \t\t\t\tmismatches[pkg] = mismatch{mod: mod, err: err}\n@@ -1900,9 +2014,10 @@ func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements)\n \t\tcase mismatch.err != nil:\n \t\t\t// pkg resolved successfully, but errors out using the requirements in rs.\n \t\t\t//\n-\t\t\t// This could occur because the import is provided by a single lazy root\n-\t\t\t// (and is thus unambiguous in lazy mode) and also one or more\n-\t\t\t// transitive dependencies (and is ambiguous in eager mode).\n+\t\t\t// This could occur because the import is provided by a single root (and\n+\t\t\t// is thus unambiguous in a main module with a pruned module graph) and\n+\t\t\t// also one or more transitive dependencies (and is ambiguous with an\n+\t\t\t// unpruned graph).\n \t\t\t//\n \t\t\t// It could also occur because some transitive dependency upgrades the\n \t\t\t// module that previously provided the package to a version that no\n@@ -1940,18 +2055,18 @@ func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements)\n \t\t\t}\n \n \t\tcase pkg.err != nil:\n-\t\t\t// pkg had an error in lazy mode (presumably suppressed with the -e flag),\n-\t\t\t// but not in eager mode.\n+\t\t\t// pkg had an error in with a pruned module graph (presumably suppressed\n+\t\t\t// with the -e flag), but the error went away using an unpruned graph.\n \t\t\t//\n-\t\t\t// This is possible, if, say, the import is unresolved in lazy mode\n+\t\t\t// This is possible, if, say, the import is unresolved in the pruned graph\n \t\t\t// (because the \"latest\" version of each candidate module either is\n-\t\t\t// unavailable or does not contain the package), but is resolved in\n-\t\t\t// eager mode due to a newer-than-latest dependency that is normally\n-\t\t\t// runed out of the module graph.\n+\t\t\t// unavailable or does not contain the package), but is resolved in the\n+\t\t\t// unpruned graph due to a newer-than-latest dependency that is normally\n+\t\t\t// pruned out.\n \t\t\t//\n \t\t\t// This could also occur if the source code for the module providing the\n-\t\t\t// package in lazy mode has a checksum error, but eager mode upgrades\n-\t\t\t// that module to a version with a correct checksum.\n+\t\t\t// package in the pruned graph has a checksum error, but the unpruned\n+\t\t\t// graph upgrades that module to a version with a correct checksum.\n \t\t\t//\n \t\t\t// pkg.err should have already been logged elsewhere \u2014 along with a\n \t\t\t// stack trace \u2014 so log only the import path and non-error info here."}, {"sha": "627cf1dbc0642ee6056bdfac85a18940093a54c3", "filename": "libgo/go/cmd/go/internal/modload/modfile.go", "status": "modified", "additions": 191, "deletions": 100, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -33,34 +33,51 @@ const (\n \t// tests outside of the main module.\n \tnarrowAllVersionV = \"v1.16\"\n \n-\t// lazyLoadingVersionV is the Go version (plus leading \"v\") at which a\n+\t// ExplicitIndirectVersionV is the Go version (plus leading \"v\") at which a\n \t// module's go.mod file is expected to list explicit requirements on every\n \t// module that provides any package transitively imported by that module.\n-\tlazyLoadingVersionV = \"v1.17\"\n+\t//\n+\t// Other indirect dependencies of such a module can be safely pruned out of\n+\t// the module graph; see https://golang.org/ref/mod#graph-pruning.\n+\tExplicitIndirectVersionV = \"v1.17\"\n \n \t// separateIndirectVersionV is the Go version (plus leading \"v\") at which\n \t// \"// indirect\" dependencies are added in a block separate from the direct\n \t// ones. See https://golang.org/issue/45965.\n \tseparateIndirectVersionV = \"v1.17\"\n )\n \n-const (\n-\t// go117EnableLazyLoading toggles whether lazy-loading code paths should be\n-\t// active. It will be removed once the lazy loading implementation is stable\n-\t// and well-tested.\n-\tgo117EnableLazyLoading = true\n-\n-\t// go1117LazyTODO is a constant that exists only until lazy loading is\n-\t// implemented. Its use indicates a condition that will need to change if the\n-\t// main module is lazy.\n-\tgo117LazyTODO = false\n-)\n+// ReadModFile reads and parses the mod file at gomod. ReadModFile properly applies the\n+// overlay, locks the file while reading, and applies fix, if applicable.\n+func ReadModFile(gomod string, fix modfile.VersionFixer) (data []byte, f *modfile.File, err error) {\n+\tif gomodActual, ok := fsys.OverlayPath(gomod); ok {\n+\t\t// Don't lock go.mod if it's part of the overlay.\n+\t\t// On Plan 9, locking requires chmod, and we don't want to modify any file\n+\t\t// in the overlay. See #44700.\n+\t\tdata, err = os.ReadFile(gomodActual)\n+\t} else {\n+\t\tdata, err = lockedfile.Read(gomodActual)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n \n-var modFile *modfile.File\n+\tf, err = modfile.Parse(gomod, data, fix)\n+\tif err != nil {\n+\t\t// Errors returned by modfile.Parse begin with file:line.\n+\t\treturn nil, nil, fmt.Errorf(\"errors parsing go.mod:\\n%s\\n\", err)\n+\t}\n+\tif f.Module == nil {\n+\t\t// No module declaration. Must add module path.\n+\t\treturn nil, nil, errors.New(\"no module declaration in go.mod. To specify the module path:\\n\\tgo mod edit -module=example.com/mod\")\n+\t}\n+\n+\treturn data, f, err\n+}\n \n // modFileGoVersion returns the (non-empty) Go version at which the requirements\n-// in modFile are intepreted, or the latest Go version if modFile is nil.\n-func modFileGoVersion() string {\n+// in modFile are interpreted, or the latest Go version if modFile is nil.\n+func modFileGoVersion(modFile *modfile.File) string {\n \tif modFile == nil {\n \t\treturn LatestGoVersion()\n \t}\n@@ -71,9 +88,9 @@ func modFileGoVersion() string {\n \t\t// has been erroneously hand-edited.\n \t\t//\n \t\t// The semantics of the go.mod file are more-or-less the same from Go 1.11\n-\t\t// through Go 1.16, changing at 1.17 for lazy loading. So even though a\n-\t\t// go.mod file without a 'go' directive is theoretically a Go 1.11 file,\n-\t\t// scripts may assume that it ends up as a Go 1.16 module.\n+\t\t// through Go 1.16, changing at 1.17 to support module graph pruning.\n+\t\t// So even though a go.mod file without a 'go' directive is theoretically a\n+\t\t// Go 1.11 file, scripts may assume that it ends up as a Go 1.16 module.\n \t\treturn \"1.16\"\n \t}\n \treturn modFile.Go.Version\n@@ -82,39 +99,37 @@ func modFileGoVersion() string {\n // A modFileIndex is an index of data corresponding to a modFile\n // at a specific point in time.\n type modFileIndex struct {\n-\tdata            []byte\n-\tdataNeedsFix    bool // true if fixVersion applied a change while parsing data\n-\tmodule          module.Version\n-\tgoVersionV      string // GoVersion with \"v\" prefix\n-\trequire         map[module.Version]requireMeta\n-\treplace         map[module.Version]module.Version\n-\thighestReplaced map[string]string // highest replaced version of each module path; empty string for wildcard-only replacements\n-\texclude         map[module.Version]bool\n+\tdata         []byte\n+\tdataNeedsFix bool // true if fixVersion applied a change while parsing data\n+\tmodule       module.Version\n+\tgoVersionV   string // GoVersion with \"v\" prefix\n+\trequire      map[module.Version]requireMeta\n+\treplace      map[module.Version]module.Version\n+\texclude      map[module.Version]bool\n }\n \n-// index is the index of the go.mod file as of when it was last read or written.\n-var index *modFileIndex\n-\n type requireMeta struct {\n \tindirect bool\n }\n \n-// A modDepth indicates which dependencies should be loaded for a go.mod file.\n-type modDepth uint8\n+// A modPruning indicates whether transitive dependencies of Go 1.17 dependencies\n+// are pruned out of the module subgraph rooted at a given module.\n+// (See https://golang.org/ref/mod#graph-pruning.)\n+type modPruning uint8\n \n const (\n-\tlazy  modDepth = iota // load dependencies only as needed\n-\teager                 // load all transitive dependencies eagerly\n+\tpruned    modPruning = iota // transitive dependencies of modules at go 1.17 and higher are pruned out\n+\tunpruned                    // no transitive dependencies are pruned out\n+\tworkspace                   // pruned to the union of modules in the workspace\n )\n \n-func modDepthFromGoVersion(goVersion string) modDepth {\n-\tif !go117EnableLazyLoading {\n-\t\treturn eager\n-\t}\n-\tif semver.Compare(\"v\"+goVersion, lazyLoadingVersionV) < 0 {\n-\t\treturn eager\n+func pruningForGoVersion(goVersion string) modPruning {\n+\tif semver.Compare(\"v\"+goVersion, ExplicitIndirectVersionV) < 0 {\n+\t\t// The go.mod file does not duplicate relevant information about transitive\n+\t\t// dependencies, so they cannot be pruned out.\n+\t\treturn unpruned\n \t}\n-\treturn lazy\n+\treturn pruned\n }\n \n // CheckAllowed returns an error equivalent to ErrDisallowed if m is excluded by\n@@ -137,8 +152,10 @@ var ErrDisallowed = errors.New(\"disallowed module version\")\n // CheckExclusions returns an error equivalent to ErrDisallowed if module m is\n // excluded by the main module's go.mod file.\n func CheckExclusions(ctx context.Context, m module.Version) error {\n-\tif index != nil && index.exclude[m] {\n-\t\treturn module.VersionError(m, errExcluded)\n+\tfor _, mainModule := range MainModules.Versions() {\n+\t\tif index := MainModules.Index(mainModule); index != nil && index.exclude[m] {\n+\t\t\treturn module.VersionError(m, errExcluded)\n+\t\t}\n \t}\n \treturn nil\n }\n@@ -306,34 +323,99 @@ func CheckDeprecation(ctx context.Context, m module.Version) (deprecation string\n \treturn summary.deprecated, nil\n }\n \n-// Replacement returns the replacement for mod, if any, from go.mod.\n-// If there is no replacement for mod, Replacement returns\n-// a module.Version with Path == \"\".\n+func replacement(mod module.Version, replace map[module.Version]module.Version) (fromVersion string, to module.Version, ok bool) {\n+\tif r, ok := replace[mod]; ok {\n+\t\treturn mod.Version, r, true\n+\t}\n+\tif r, ok := replace[module.Version{Path: mod.Path}]; ok {\n+\t\treturn \"\", r, true\n+\t}\n+\treturn \"\", module.Version{}, false\n+}\n+\n+// Replacement returns the replacement for mod, if any. If the path in the\n+// module.Version is relative it's relative to the single main module outside\n+// workspace mode, or the workspace's directory in workspace mode.\n func Replacement(mod module.Version) module.Version {\n-\tif index != nil {\n-\t\tif r, ok := index.replace[mod]; ok {\n-\t\t\treturn r\n-\t\t}\n-\t\tif r, ok := index.replace[module.Version{Path: mod.Path}]; ok {\n-\t\t\treturn r\n+\tfoundFrom, found, foundModRoot := \"\", module.Version{}, \"\"\n+\tif MainModules == nil {\n+\t\treturn module.Version{}\n+\t} else if MainModules.Contains(mod.Path) && mod.Version == \"\" {\n+\t\t// Don't replace the workspace version of the main module.\n+\t\treturn module.Version{}\n+\t}\n+\tif _, r, ok := replacement(mod, MainModules.WorkFileReplaceMap()); ok {\n+\t\treturn r\n+\t}\n+\tfor _, v := range MainModules.Versions() {\n+\t\tif index := MainModules.Index(v); index != nil {\n+\t\t\tif from, r, ok := replacement(mod, index.replace); ok {\n+\t\t\t\tmodRoot := MainModules.ModRoot(v)\n+\t\t\t\tif foundModRoot != \"\" && foundFrom != from && found != r {\n+\t\t\t\t\tbase.Errorf(\"conflicting replacements found for %v in workspace modules defined by %v and %v\",\n+\t\t\t\t\t\tmod, modFilePath(foundModRoot), modFilePath(modRoot))\n+\t\t\t\t\treturn canonicalizeReplacePath(found, foundModRoot)\n+\t\t\t\t}\n+\t\t\t\tfound, foundModRoot = r, modRoot\n+\t\t\t}\n \t\t}\n \t}\n-\treturn module.Version{}\n+\treturn canonicalizeReplacePath(found, foundModRoot)\n+}\n+\n+func replaceRelativeTo() string {\n+\tif workFilePath := WorkFilePath(); workFilePath != \"\" {\n+\t\treturn filepath.Dir(workFilePath)\n+\t}\n+\treturn MainModules.ModRoot(MainModules.mustGetSingleMainModule())\n+}\n+\n+// canonicalizeReplacePath ensures that relative, on-disk, replaced module paths\n+// are relative to the workspace directory (in workspace mode) or to the module's\n+// directory (in module mode, as they already are).\n+func canonicalizeReplacePath(r module.Version, modRoot string) module.Version {\n+\tif filepath.IsAbs(r.Path) || r.Version != \"\" {\n+\t\treturn r\n+\t}\n+\tworkFilePath := WorkFilePath()\n+\tif workFilePath == \"\" {\n+\t\treturn r\n+\t}\n+\tabs := filepath.Join(modRoot, r.Path)\n+\tif rel, err := filepath.Rel(filepath.Dir(workFilePath), abs); err == nil {\n+\t\treturn module.Version{Path: rel, Version: r.Version}\n+\t}\n+\t// We couldn't make the version's path relative to the workspace's path,\n+\t// so just return the absolute path. It's the best we can do.\n+\treturn module.Version{Path: abs, Version: r.Version}\n }\n \n // resolveReplacement returns the module actually used to load the source code\n // for m: either m itself, or the replacement for m (iff m is replaced).\n+// It also returns the modroot of the module providing the replacement if\n+// one was found.\n func resolveReplacement(m module.Version) module.Version {\n \tif r := Replacement(m); r.Path != \"\" {\n \t\treturn r\n \t}\n \treturn m\n }\n \n+func toReplaceMap(replacements []*modfile.Replace) map[module.Version]module.Version {\n+\treplaceMap := make(map[module.Version]module.Version, len(replacements))\n+\tfor _, r := range replacements {\n+\t\tif prev, dup := replaceMap[r.Old]; dup && prev != r.New {\n+\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\", r.Old, prev, r.New)\n+\t\t}\n+\t\treplaceMap[r.Old] = r.New\n+\t}\n+\treturn replaceMap\n+}\n+\n // indexModFile rebuilds the index of modFile.\n // If modFile has been changed since it was first read,\n // modFile.Cleanup must be called before indexModFile.\n-func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileIndex {\n+func indexModFile(data []byte, modFile *modfile.File, mod module.Version, needsFix bool) *modFileIndex {\n \ti := new(modFileIndex)\n \ti.data = data\n \ti.dataNeedsFix = needsFix\n@@ -345,34 +427,20 @@ func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileInd\n \n \ti.goVersionV = \"\"\n \tif modFile.Go == nil {\n-\t\trawGoVersion.Store(Target, \"\")\n+\t\trawGoVersion.Store(mod, \"\")\n \t} else {\n \t\t// We're going to use the semver package to compare Go versions, so go ahead\n \t\t// and add the \"v\" prefix it expects once instead of every time.\n \t\ti.goVersionV = \"v\" + modFile.Go.Version\n-\t\trawGoVersion.Store(Target, modFile.Go.Version)\n+\t\trawGoVersion.Store(mod, modFile.Go.Version)\n \t}\n \n \ti.require = make(map[module.Version]requireMeta, len(modFile.Require))\n \tfor _, r := range modFile.Require {\n \t\ti.require[r.Mod] = requireMeta{indirect: r.Indirect}\n \t}\n \n-\ti.replace = make(map[module.Version]module.Version, len(modFile.Replace))\n-\tfor _, r := range modFile.Replace {\n-\t\tif prev, dup := i.replace[r.Old]; dup && prev != r.New {\n-\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\", r.Old, prev, r.New)\n-\t\t}\n-\t\ti.replace[r.Old] = r.New\n-\t}\n-\n-\ti.highestReplaced = make(map[string]string)\n-\tfor _, r := range modFile.Replace {\n-\t\tv, ok := i.highestReplaced[r.Old.Path]\n-\t\tif !ok || semver.Compare(r.Old.Version, v) > 0 {\n-\t\t\ti.highestReplaced[r.Old.Path] = r.Old.Version\n-\t\t}\n-\t}\n+\ti.replace = toReplaceMap(modFile.Replace)\n \n \ti.exclude = make(map[module.Version]bool, len(modFile.Exclude))\n \tfor _, x := range modFile.Exclude {\n@@ -465,7 +533,7 @@ var rawGoVersion sync.Map // map[module.Version]string\n type modFileSummary struct {\n \tmodule     module.Version\n \tgoVersion  string\n-\tdepth      modDepth\n+\tpruning    modPruning\n \trequire    []module.Version\n \tretract    []retraction\n \tdeprecated string\n@@ -490,8 +558,8 @@ type retraction struct {\n //\n // The caller must not modify the returned summary.\n func goModSummary(m module.Version) (*modFileSummary, error) {\n-\tif m == Target {\n-\t\tpanic(\"internal error: goModSummary called on the Target module\")\n+\tif m.Version == \"\" && !inWorkspaceMode() && MainModules.Contains(m.Path) {\n+\t\tpanic(\"internal error: goModSummary called on a main module\")\n \t}\n \n \tif cfg.BuildMod == \"vendor\" {\n@@ -506,7 +574,7 @@ func goModSummary(m module.Version) (*modFileSummary, error) {\n \n \t\t// For every module other than the target,\n \t\t// return the full list of modules from modules.txt.\n-\t\treadVendorList()\n+\t\treadVendorList(MainModules.mustGetSingleMainModule())\n \n \t\t// We don't know what versions the vendored module actually relies on,\n \t\t// so assume that it requires everything.\n@@ -515,7 +583,7 @@ func goModSummary(m module.Version) (*modFileSummary, error) {\n \t}\n \n \tactual := resolveReplacement(m)\n-\tif HasModRoot() && cfg.BuildMod == \"readonly\" && actual.Version != \"\" {\n+\tif HasModRoot() && cfg.BuildMod == \"readonly\" && !inWorkspaceMode() && actual.Version != \"\" {\n \t\tkey := module.Version{Path: actual.Path, Version: actual.Version + \"/go.mod\"}\n \t\tif !modfetch.HaveSum(key) {\n \t\t\tsuggestion := fmt.Sprintf(\"; to add it:\\n\\tgo mod download %s\", m.Path)\n@@ -553,27 +621,29 @@ func goModSummary(m module.Version) (*modFileSummary, error) {\n \t\t}\n \t}\n \n-\tif index != nil && len(index.exclude) > 0 {\n-\t\t// Drop any requirements on excluded versions.\n-\t\t// Don't modify the cached summary though, since we might need the raw\n-\t\t// summary separately.\n-\t\thaveExcludedReqs := false\n-\t\tfor _, r := range summary.require {\n-\t\t\tif index.exclude[r] {\n-\t\t\t\thaveExcludedReqs = true\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif haveExcludedReqs {\n-\t\t\ts := new(modFileSummary)\n-\t\t\t*s = *summary\n-\t\t\ts.require = make([]module.Version, 0, len(summary.require))\n+\tfor _, mainModule := range MainModules.Versions() {\n+\t\tif index := MainModules.Index(mainModule); index != nil && len(index.exclude) > 0 {\n+\t\t\t// Drop any requirements on excluded versions.\n+\t\t\t// Don't modify the cached summary though, since we might need the raw\n+\t\t\t// summary separately.\n+\t\t\thaveExcludedReqs := false\n \t\t\tfor _, r := range summary.require {\n-\t\t\t\tif !index.exclude[r] {\n-\t\t\t\t\ts.require = append(s.require, r)\n+\t\t\t\tif index.exclude[r] {\n+\t\t\t\t\thaveExcludedReqs = true\n+\t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n-\t\t\tsummary = s\n+\t\t\tif haveExcludedReqs {\n+\t\t\t\ts := new(modFileSummary)\n+\t\t\t\t*s = *summary\n+\t\t\t\ts.require = make([]module.Version, 0, len(summary.require))\n+\t\t\t\tfor _, r := range summary.require {\n+\t\t\t\t\tif !index.exclude[r] {\n+\t\t\t\t\t\ts.require = append(s.require, r)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tsummary = s\n+\t\t\t}\n \t\t}\n \t}\n \treturn summary, nil\n@@ -584,16 +654,20 @@ func goModSummary(m module.Version) (*modFileSummary, error) {\n // its dependencies.\n //\n // rawGoModSummary cannot be used on the Target module.\n+\n func rawGoModSummary(m module.Version) (*modFileSummary, error) {\n-\tif m == Target {\n+\tif m.Path == \"\" && MainModules.Contains(m.Path) {\n \t\tpanic(\"internal error: rawGoModSummary called on the Target module\")\n \t}\n \n+\ttype key struct {\n+\t\tm module.Version\n+\t}\n \ttype cached struct {\n \t\tsummary *modFileSummary\n \t\terr     error\n \t}\n-\tc := rawGoModSummaryCache.Do(m, func() interface{} {\n+\tc := rawGoModSummaryCache.Do(key{m}, func() any {\n \t\tsummary := new(modFileSummary)\n \t\tname, data, err := rawGoModData(m)\n \t\tif err != nil {\n@@ -610,9 +684,9 @@ func rawGoModSummary(m module.Version) (*modFileSummary, error) {\n \t\tif f.Go != nil && f.Go.Version != \"\" {\n \t\t\trawGoVersion.LoadOrStore(m, f.Go.Version)\n \t\t\tsummary.goVersion = f.Go.Version\n-\t\t\tsummary.depth = modDepthFromGoVersion(f.Go.Version)\n+\t\t\tsummary.pruning = pruningForGoVersion(f.Go.Version)\n \t\t} else {\n-\t\t\tsummary.depth = eager\n+\t\t\tsummary.pruning = unpruned\n \t\t}\n \t\tif len(f.Require) > 0 {\n \t\t\tsummary.require = make([]module.Version, 0, len(f.Require))\n@@ -648,9 +722,14 @@ var rawGoModSummaryCache par.Cache // module.Version \u2192 rawGoModSummary result\n func rawGoModData(m module.Version) (name string, data []byte, err error) {\n \tif m.Version == \"\" {\n \t\t// m is a replacement module with only a file path.\n+\n \t\tdir := m.Path\n \t\tif !filepath.IsAbs(dir) {\n-\t\t\tdir = filepath.Join(ModRoot(), dir)\n+\t\t\tif inWorkspaceMode() && MainModules.Contains(m.Path) {\n+\t\t\t\tdir = MainModules.ModRoot(m)\n+\t\t\t} else {\n+\t\t\t\tdir = filepath.Join(replaceRelativeTo(), dir)\n+\t\t\t}\n \t\t}\n \t\tname = filepath.Join(dir, \"go.mod\")\n \t\tif gomodActual, ok := fsys.OverlayPath(name); ok {\n@@ -690,7 +769,7 @@ func queryLatestVersionIgnoringRetractions(ctx context.Context, path string) (la\n \t\tlatest module.Version\n \t\terr    error\n \t}\n-\te := latestVersionIgnoringRetractionsCache.Do(path, func() interface{} {\n+\te := latestVersionIgnoringRetractionsCache.Do(path, func() any {\n \t\tctx, span := trace.StartSpan(ctx, \"queryLatestVersionIgnoringRetractions \"+path)\n \t\tdefer span.Done()\n \n@@ -718,3 +797,15 @@ func queryLatestVersionIgnoringRetractions(ctx context.Context, path string) (la\n }\n \n var latestVersionIgnoringRetractionsCache par.Cache // path \u2192 queryLatestVersionIgnoringRetractions result\n+\n+// ToDirectoryPath adds a prefix if necessary so that path in unambiguously\n+// an absolute path or a relative path starting with a '.' or '..'\n+// path component.\n+func ToDirectoryPath(path string) string {\n+\tif modfile.IsDirectoryPath(path) {\n+\t\treturn path\n+\t}\n+\t// The path is not a relative path or an absolute path, so make it relative\n+\t// to the current directory.\n+\treturn \"./\" + filepath.ToSlash(filepath.Clean(path))\n+}"}, {"sha": "588bcf4bdc26453b41e53d2562ecbe66088ee0f3", "filename": "libgo/go/cmd/go/internal/modload/mvs.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -42,7 +42,7 @@ type mvsReqs struct {\n }\n \n func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n-\tif mod == Target {\n+\tif mod.Version == \"\" && MainModules.Contains(mod.Path) {\n \t\t// Use the build list as it existed when r was constructed, not the current\n \t\t// global build list.\n \t\treturn r.roots, nil\n@@ -108,12 +108,12 @@ func versions(ctx context.Context, path string, allowed AllowedFunc) ([]string,\n // previousVersion returns the tagged version of m.Path immediately prior to\n // m.Version, or version \"none\" if no prior version is tagged.\n //\n-// Since the version of Target is not found in the version list,\n+// Since the version of a main module is not found in the version list,\n // it has no previous version.\n func previousVersion(m module.Version) (module.Version, error) {\n \t// TODO(golang.org/issue/38714): thread tracing context through MVS.\n \n-\tif m == Target {\n+\tif m.Version == \"\" && MainModules.Contains(m.Path) {\n \t\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n \t}\n "}, {"sha": "33808ea1097a7f3dc0f1b06a197fde3a09900eb6", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 129, "deletions": 77, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -110,11 +110,12 @@ func queryProxy(ctx context.Context, proxy, path, query, current string, allowed\n \t\tallowed = func(context.Context, module.Version) error { return nil }\n \t}\n \n-\tif path == Target.Path && (query == \"upgrade\" || query == \"patch\") {\n-\t\tif err := allowed(ctx, Target); err != nil {\n+\tif MainModules.Contains(path) && (query == \"upgrade\" || query == \"patch\") {\n+\t\tm := module.Version{Path: path}\n+\t\tif err := allowed(ctx, m); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"internal error: main module version is not allowed: %w\", err)\n \t\t}\n-\t\treturn &modfetch.RevInfo{Version: Target.Version}, nil\n+\t\treturn &modfetch.RevInfo{Version: m.Version}, nil\n \t}\n \n \tif path == \"std\" || path == \"cmd\" {\n@@ -512,9 +513,10 @@ func QueryPackages(ctx context.Context, pattern, query string, current func(stri\n \tpkgMods, modOnly, err := QueryPattern(ctx, pattern, query, current, allowed)\n \n \tif len(pkgMods) == 0 && err == nil {\n+\t\treplacement := Replacement(modOnly.Mod)\n \t\treturn nil, &PackageNotInModuleError{\n \t\t\tMod:         modOnly.Mod,\n-\t\t\tReplacement: Replacement(modOnly.Mod),\n+\t\t\tReplacement: replacement,\n \t\t\tQuery:       query,\n \t\t\tPattern:     pattern,\n \t\t}\n@@ -551,38 +553,40 @@ func QueryPattern(ctx context.Context, pattern, query string, current func(strin\n \t\treturn m.Errs[0]\n \t}\n \n-\tvar match func(mod module.Version, root string, isLocal bool) *search.Match\n+\tvar match func(mod module.Version, roots []string, isLocal bool) *search.Match\n \tmatchPattern := search.MatchPattern(pattern)\n \n \tif i := strings.Index(pattern, \"...\"); i >= 0 {\n \t\tbase = pathpkg.Dir(pattern[:i+3])\n \t\tif base == \".\" {\n \t\t\treturn nil, nil, &WildcardInFirstElementError{Pattern: pattern, Query: query}\n \t\t}\n-\t\tmatch = func(mod module.Version, root string, isLocal bool) *search.Match {\n+\t\tmatch = func(mod module.Version, roots []string, isLocal bool) *search.Match {\n \t\t\tm := search.NewMatch(pattern)\n \t\t\tmatchPackages(ctx, m, imports.AnyTags(), omitStd, []module.Version{mod})\n \t\t\treturn m\n \t\t}\n \t} else {\n-\t\tmatch = func(mod module.Version, root string, isLocal bool) *search.Match {\n+\t\tmatch = func(mod module.Version, roots []string, isLocal bool) *search.Match {\n \t\t\tm := search.NewMatch(pattern)\n \t\t\tprefix := mod.Path\n-\t\t\tif mod == Target {\n-\t\t\t\tprefix = targetPrefix\n+\t\t\tif MainModules.Contains(mod.Path) {\n+\t\t\t\tprefix = MainModules.PathPrefix(module.Version{Path: mod.Path})\n \t\t\t}\n-\t\t\tif _, ok, err := dirInModule(pattern, prefix, root, isLocal); err != nil {\n-\t\t\t\tm.AddError(err)\n-\t\t\t} else if ok {\n-\t\t\t\tm.Pkgs = []string{pattern}\n+\t\t\tfor _, root := range roots {\n+\t\t\t\tif _, ok, err := dirInModule(pattern, prefix, root, isLocal); err != nil {\n+\t\t\t\t\tm.AddError(err)\n+\t\t\t\t} else if ok {\n+\t\t\t\t\tm.Pkgs = []string{pattern}\n+\t\t\t\t}\n \t\t\t}\n \t\t\treturn m\n \t\t}\n \t}\n \n-\tvar queryMatchesMainModule bool\n-\tif HasModRoot() {\n-\t\tm := match(Target, modRoot, true)\n+\tvar mainModuleMatches []module.Version\n+\tfor _, mainModule := range MainModules.Versions() {\n+\t\tm := match(mainModule, modRoots, true)\n \t\tif len(m.Pkgs) > 0 {\n \t\t\tif query != \"upgrade\" && query != \"patch\" {\n \t\t\t\treturn nil, nil, &QueryMatchesPackagesInMainModuleError{\n@@ -591,28 +595,30 @@ func QueryPattern(ctx context.Context, pattern, query string, current func(strin\n \t\t\t\t\tPackages: m.Pkgs,\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif err := allowed(ctx, Target); err != nil {\n-\t\t\t\treturn nil, nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed: %w\", pattern, Target.Path, err)\n+\t\t\tif err := allowed(ctx, mainModule); err != nil {\n+\t\t\t\treturn nil, nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed: %w\", pattern, mainModule.Path, err)\n \t\t\t}\n \t\t\treturn []QueryResult{{\n-\t\t\t\tMod:      Target,\n-\t\t\t\tRev:      &modfetch.RevInfo{Version: Target.Version},\n+\t\t\t\tMod:      mainModule,\n+\t\t\t\tRev:      &modfetch.RevInfo{Version: mainModule.Version},\n \t\t\t\tPackages: m.Pkgs,\n \t\t\t}}, nil, nil\n \t\t}\n \t\tif err := firstError(m); err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n \n-\t\tif matchPattern(Target.Path) {\n-\t\t\tqueryMatchesMainModule = true\n+\t\tvar matchesMainModule bool\n+\t\tif matchPattern(mainModule.Path) {\n+\t\t\tmainModuleMatches = append(mainModuleMatches, mainModule)\n+\t\t\tmatchesMainModule = true\n \t\t}\n \n-\t\tif (query == \"upgrade\" || query == \"patch\") && queryMatchesMainModule {\n-\t\t\tif err := allowed(ctx, Target); err == nil {\n+\t\tif (query == \"upgrade\" || query == \"patch\") && matchesMainModule {\n+\t\t\tif err := allowed(ctx, mainModule); err == nil {\n \t\t\t\tmodOnly = &QueryResult{\n-\t\t\t\t\tMod: Target,\n-\t\t\t\t\tRev: &modfetch.RevInfo{Version: Target.Version},\n+\t\t\t\t\tMod: mainModule,\n+\t\t\t\t\tRev: &modfetch.RevInfo{Version: mainModule.Version},\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -625,16 +631,17 @@ func QueryPattern(ctx context.Context, pattern, query string, current func(strin\n \tif len(candidateModules) == 0 {\n \t\tif modOnly != nil {\n \t\t\treturn nil, modOnly, nil\n-\t\t} else if queryMatchesMainModule {\n-\t\t\treturn nil, nil, &QueryMatchesMainModuleError{\n-\t\t\t\tPattern: pattern,\n-\t\t\t\tQuery:   query,\n+\t\t} else if len(mainModuleMatches) != 0 {\n+\t\t\treturn nil, nil, &QueryMatchesMainModulesError{\n+\t\t\t\tMainModules: mainModuleMatches,\n+\t\t\t\tPattern:     pattern,\n+\t\t\t\tQuery:       query,\n \t\t\t}\n \t\t} else {\n \t\t\treturn nil, nil, &PackageNotInModuleError{\n-\t\t\t\tMod:     Target,\n-\t\t\t\tQuery:   query,\n-\t\t\t\tPattern: pattern,\n+\t\t\t\tMainModules: mainModuleMatches,\n+\t\t\t\tQuery:       query,\n+\t\t\t\tPattern:     pattern,\n \t\t\t}\n \t\t}\n \t}\n@@ -656,15 +663,16 @@ func QueryPattern(ctx context.Context, pattern, query string, current func(strin\n \t\t\tif err != nil {\n \t\t\t\treturn r, err\n \t\t\t}\n-\t\t\tm := match(r.Mod, root, isLocal)\n+\t\t\tm := match(r.Mod, []string{root}, isLocal)\n \t\t\tr.Packages = m.Pkgs\n \t\t\tif len(r.Packages) == 0 && !matchPattern(path) {\n \t\t\t\tif err := firstError(m); err != nil {\n \t\t\t\t\treturn r, err\n \t\t\t\t}\n+\t\t\t\treplacement := Replacement(r.Mod)\n \t\t\t\treturn r, &PackageNotInModuleError{\n \t\t\t\t\tMod:         r.Mod,\n-\t\t\t\t\tReplacement: Replacement(r.Mod),\n+\t\t\t\t\tReplacement: replacement,\n \t\t\t\t\tQuery:       query,\n \t\t\t\t\tPattern:     pattern,\n \t\t\t\t}\n@@ -684,8 +692,8 @@ func QueryPattern(ctx context.Context, pattern, query string, current func(strin\n \t\treturn err\n \t})\n \n-\tif queryMatchesMainModule && len(results) == 0 && modOnly == nil && errors.Is(err, fs.ErrNotExist) {\n-\t\treturn nil, nil, &QueryMatchesMainModuleError{\n+\tif len(mainModuleMatches) > 0 && len(results) == 0 && modOnly == nil && errors.Is(err, fs.ErrNotExist) {\n+\t\treturn nil, nil, &QueryMatchesMainModulesError{\n \t\t\tPattern: pattern,\n \t\t\tQuery:   query,\n \t\t}\n@@ -701,8 +709,13 @@ func QueryPattern(ctx context.Context, pattern, query string, current func(strin\n func modulePrefixesExcludingTarget(path string) []string {\n \tprefixes := make([]string, 0, strings.Count(path, \"/\")+1)\n \n+\tmainModulePrefixes := make(map[string]bool)\n+\tfor _, m := range MainModules.Versions() {\n+\t\tmainModulePrefixes[m.Path] = true\n+\t}\n+\n \tfor {\n-\t\tif path != targetPrefix {\n+\t\tif !mainModulePrefixes[path] {\n \t\t\tif _, _, ok := module.SplitPathVersion(path); ok {\n \t\t\t\tprefixes = append(prefixes, path)\n \t\t\t}\n@@ -759,7 +772,7 @@ func queryPrefixModules(ctx context.Context, candidateModules []string, queryMod\n \t\tcase *PackageNotInModuleError:\n \t\t\t// Given the option, prefer to attribute \u201cpackage not in module\u201d\n \t\t\t// to modules other than the main one.\n-\t\t\tif noPackage == nil || noPackage.Mod == Target {\n+\t\t\tif noPackage == nil || MainModules.Contains(noPackage.Mod.Path) {\n \t\t\t\tnoPackage = rErr\n \t\t\t}\n \t\tcase *NoMatchingVersionError:\n@@ -878,18 +891,23 @@ func (e *WildcardInFirstElementError) Error() string {\n // code for the versions it knows about, and thus did not have the opportunity\n // to return a non-400 status code to suppress fallback.\n type PackageNotInModuleError struct {\n+\tMainModules []module.Version\n \tMod         module.Version\n \tReplacement module.Version\n \tQuery       string\n \tPattern     string\n }\n \n func (e *PackageNotInModuleError) Error() string {\n-\tif e.Mod == Target {\n+\tif len(e.MainModules) > 0 {\n+\t\tprefix := \"workspace modules do\"\n+\t\tif len(e.MainModules) == 1 {\n+\t\t\tprefix = fmt.Sprintf(\"main module (%s) does\", e.MainModules[0])\n+\t\t}\n \t\tif strings.Contains(e.Pattern, \"...\") {\n-\t\t\treturn fmt.Sprintf(\"main module (%s) does not contain packages matching %s\", Target.Path, e.Pattern)\n+\t\t\treturn fmt.Sprintf(\"%s not contain packages matching %s\", prefix, e.Pattern)\n \t\t}\n-\t\treturn fmt.Sprintf(\"main module (%s) does not contain package %s\", Target.Path, e.Pattern)\n+\t\treturn fmt.Sprintf(\"%s not contain package %s\", prefix, e.Pattern)\n \t}\n \n \tfound := \"\"\n@@ -978,14 +996,13 @@ func lookupRepo(proxy, path string) (repo versionRepo, err error) {\n \t\trepo = emptyRepo{path: path, err: err}\n \t}\n \n-\tif index == nil {\n-\t\treturn repo, err\n-\t}\n-\tif _, ok := index.highestReplaced[path]; !ok {\n+\tif MainModules == nil {\n \t\treturn repo, err\n+\t} else if _, ok := MainModules.HighestReplaced()[path]; ok {\n+\t\treturn &replacementRepo{repo: repo}, nil\n \t}\n \n-\treturn &replacementRepo{repo: repo}, nil\n+\treturn repo, err\n }\n \n // An emptyRepo is a versionRepo that contains no versions.\n@@ -1024,11 +1041,13 @@ func (rr *replacementRepo) Versions(prefix string) ([]string, error) {\n \t}\n \n \tversions := repoVersions\n-\tif index != nil && len(index.replace) > 0 {\n-\t\tpath := rr.ModulePath()\n-\t\tfor m, _ := range index.replace {\n-\t\t\tif m.Path == path && strings.HasPrefix(m.Version, prefix) && m.Version != \"\" && !module.IsPseudoVersion(m.Version) {\n-\t\t\t\tversions = append(versions, m.Version)\n+\tfor _, mm := range MainModules.Versions() {\n+\t\tif index := MainModules.Index(mm); index != nil && len(index.replace) > 0 {\n+\t\t\tpath := rr.ModulePath()\n+\t\t\tfor m, _ := range index.replace {\n+\t\t\t\tif m.Path == path && strings.HasPrefix(m.Version, prefix) && m.Version != \"\" && !module.IsPseudoVersion(m.Version) {\n+\t\t\t\t\tversions = append(versions, m.Version)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -1046,7 +1065,16 @@ func (rr *replacementRepo) Versions(prefix string) ([]string, error) {\n \n func (rr *replacementRepo) Stat(rev string) (*modfetch.RevInfo, error) {\n \tinfo, err := rr.repo.Stat(rev)\n-\tif err == nil || index == nil || len(index.replace) == 0 {\n+\tif err == nil {\n+\t\treturn info, err\n+\t}\n+\tvar hasReplacements bool\n+\tfor _, v := range MainModules.Versions() {\n+\t\tif index := MainModules.Index(v); index != nil && len(index.replace) > 0 {\n+\t\t\thasReplacements = true\n+\t\t}\n+\t}\n+\tif !hasReplacements {\n \t\treturn info, err\n \t}\n \n@@ -1073,26 +1101,24 @@ func (rr *replacementRepo) Stat(rev string) (*modfetch.RevInfo, error) {\n \n func (rr *replacementRepo) Latest() (*modfetch.RevInfo, error) {\n \tinfo, err := rr.repo.Latest()\n+\tpath := rr.ModulePath()\n \n-\tif index != nil {\n-\t\tpath := rr.ModulePath()\n-\t\tif v, ok := index.highestReplaced[path]; ok {\n-\t\t\tif v == \"\" {\n-\t\t\t\t// The only replacement is a wildcard that doesn't specify a version, so\n-\t\t\t\t// synthesize a pseudo-version with an appropriate major version and a\n-\t\t\t\t// timestamp below any real timestamp. That way, if the main module is\n-\t\t\t\t// used from within some other module, the user will be able to upgrade\n-\t\t\t\t// the requirement to any real version they choose.\n-\t\t\t\tif _, pathMajor, ok := module.SplitPathVersion(path); ok && len(pathMajor) > 0 {\n-\t\t\t\t\tv = module.PseudoVersion(pathMajor[1:], \"\", time.Time{}, \"000000000000\")\n-\t\t\t\t} else {\n-\t\t\t\t\tv = module.PseudoVersion(\"v0\", \"\", time.Time{}, \"000000000000\")\n-\t\t\t\t}\n+\tif v, ok := MainModules.HighestReplaced()[path]; ok {\n+\t\tif v == \"\" {\n+\t\t\t// The only replacement is a wildcard that doesn't specify a version, so\n+\t\t\t// synthesize a pseudo-version with an appropriate major version and a\n+\t\t\t// timestamp below any real timestamp. That way, if the main module is\n+\t\t\t// used from within some other module, the user will be able to upgrade\n+\t\t\t// the requirement to any real version they choose.\n+\t\t\tif _, pathMajor, ok := module.SplitPathVersion(path); ok && len(pathMajor) > 0 {\n+\t\t\t\tv = module.PseudoVersion(pathMajor[1:], \"\", time.Time{}, \"000000000000\")\n+\t\t\t} else {\n+\t\t\t\tv = module.PseudoVersion(\"v0\", \"\", time.Time{}, \"000000000000\")\n \t\t\t}\n+\t\t}\n \n-\t\t\tif err != nil || semver.Compare(v, info.Version) > 0 {\n-\t\t\t\treturn rr.replacementStat(v)\n-\t\t\t}\n+\t\tif err != nil || semver.Compare(v, info.Version) > 0 {\n+\t\t\treturn rr.replacementStat(v)\n \t\t}\n \t}\n \n@@ -1108,20 +1134,46 @@ func (rr *replacementRepo) replacementStat(v string) (*modfetch.RevInfo, error)\n \treturn rev, nil\n }\n \n-// A QueryMatchesMainModuleError indicates that a query requests\n+// A QueryMatchesMainModulesError indicates that a query requests\n // a version of the main module that cannot be satisfied.\n // (The main module's version cannot be changed.)\n-type QueryMatchesMainModuleError struct {\n-\tPattern string\n-\tQuery   string\n+type QueryMatchesMainModulesError struct {\n+\tMainModules []module.Version\n+\tPattern     string\n+\tQuery       string\n }\n \n-func (e *QueryMatchesMainModuleError) Error() string {\n-\tif e.Pattern == Target.Path {\n+func (e *QueryMatchesMainModulesError) Error() string {\n+\tif MainModules.Contains(e.Pattern) {\n \t\treturn fmt.Sprintf(\"can't request version %q of the main module (%s)\", e.Query, e.Pattern)\n \t}\n \n-\treturn fmt.Sprintf(\"can't request version %q of pattern %q that includes the main module (%s)\", e.Query, e.Pattern, Target.Path)\n+\tplural := \"\"\n+\tmainModulePaths := make([]string, len(e.MainModules))\n+\tfor i := range e.MainModules {\n+\t\tmainModulePaths[i] = e.MainModules[i].Path\n+\t}\n+\tif len(e.MainModules) > 1 {\n+\t\tplural = \"s\"\n+\t}\n+\treturn fmt.Sprintf(\"can't request version %q of pattern %q that includes the main module%s (%s)\", e.Query, e.Pattern, plural, strings.Join(mainModulePaths, \", \"))\n+}\n+\n+// A QueryUpgradesAllError indicates that a query requests\n+// an upgrade on the all pattern.\n+// (The main module's version cannot be changed.)\n+type QueryUpgradesAllError struct {\n+\tMainModules []module.Version\n+\tQuery       string\n+}\n+\n+func (e *QueryUpgradesAllError) Error() string {\n+\tvar plural string = \"\"\n+\tif len(e.MainModules) != 1 {\n+\t\tplural = \"s\"\n+\t}\n+\n+\treturn fmt.Sprintf(\"can't request version %q of pattern \\\"all\\\" that includes the main module%s\", e.Query, plural)\n }\n \n // A QueryMatchesPackagesInMainModuleError indicates that a query cannot be"}, {"sha": "87c5c55471dcd65d8ef64da1f4e9b7475935a460", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -132,9 +132,10 @@ func matchPackages(ctx context.Context, m *search.Match, tags map[string]bool, f\n \t}\n \n \tif cfg.BuildMod == \"vendor\" {\n-\t\tif HasModRoot() {\n-\t\t\twalkPkgs(ModRoot(), targetPrefix, pruneGoMod|pruneVendor)\n-\t\t\twalkPkgs(filepath.Join(ModRoot(), \"vendor\"), \"\", pruneVendor)\n+\t\tmod := MainModules.mustGetSingleMainModule()\n+\t\tif modRoot := MainModules.ModRoot(mod); modRoot != \"\" {\n+\t\t\twalkPkgs(modRoot, MainModules.PathPrefix(mod), pruneGoMod|pruneVendor)\n+\t\t\twalkPkgs(filepath.Join(modRoot, \"vendor\"), \"\", pruneVendor)\n \t\t}\n \t\treturn\n \t}\n@@ -148,12 +149,12 @@ func matchPackages(ctx context.Context, m *search.Match, tags map[string]bool, f\n \t\t\troot, modPrefix string\n \t\t\tisLocal         bool\n \t\t)\n-\t\tif mod == Target {\n-\t\t\tif !HasModRoot() {\n+\t\tif MainModules.Contains(mod.Path) {\n+\t\t\tif MainModules.ModRoot(mod) == \"\" {\n \t\t\t\tcontinue // If there is no main module, we can't search in it.\n \t\t\t}\n-\t\t\troot = ModRoot()\n-\t\t\tmodPrefix = targetPrefix\n+\t\t\troot = MainModules.ModRoot(mod)\n+\t\t\tmodPrefix = MainModules.PathPrefix(mod)\n \t\t\tisLocal = true\n \t\t} else {\n \t\t\tvar err error"}, {"sha": "ff7c124af58a28c6da3ddfe48d144f935a1afdfb", "filename": "libgo/go/cmd/go/internal/modload/stat_openfile.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build (js && wasm) || plan9\n-// +build js,wasm plan9\n \n // On plan9, per http://9p.io/magic/man2html/2/access: \u201cSince file permissions\n // are checked by the server and group information is not known to the client,"}, {"sha": "38f5cc4ffb624bb3e6c8046175f960eb54240062", "filename": "libgo/go/cmd/go/internal/modload/stat_unix.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build aix || darwin || dragonfly || freebsd || hurd || linux || netbsd || openbsd || solaris\n-// +build aix darwin dragonfly freebsd hurd linux netbsd openbsd solaris\n \n package modload\n "}, {"sha": "f29a99165e53001faec5e8553e670a82803522dc", "filename": "libgo/go/cmd/go/internal/modload/stat_windows.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build windows\n-// +build windows\n \n package modload\n "}, {"sha": "5ea82a862083fdd76ed81f0b63ccac63abb88ef9", "filename": "libgo/go/cmd/go/internal/modload/vendor.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -15,6 +15,7 @@ import (\n \n \t\"cmd/go/internal/base\"\n \n+\t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n@@ -35,13 +36,13 @@ type vendorMetadata struct {\n }\n \n // readVendorList reads the list of vendored modules from vendor/modules.txt.\n-func readVendorList() {\n+func readVendorList(mainModule module.Version) {\n \tvendorOnce.Do(func() {\n \t\tvendorList = nil\n \t\tvendorPkgModule = make(map[string]module.Version)\n \t\tvendorVersion = make(map[string]string)\n \t\tvendorMeta = make(map[module.Version]vendorMetadata)\n-\t\tdata, err := os.ReadFile(filepath.Join(ModRoot(), \"vendor/modules.txt\"))\n+\t\tdata, err := os.ReadFile(filepath.Join(MainModules.ModRoot(mainModule), \"vendor/modules.txt\"))\n \t\tif err != nil {\n \t\t\tif !errors.Is(err, fs.ErrNotExist) {\n \t\t\t\tbase.Fatalf(\"go: %s\", err)\n@@ -134,8 +135,8 @@ func readVendorList() {\n // checkVendorConsistency verifies that the vendor/modules.txt file matches (if\n // go 1.14) or at least does not contradict (go 1.13 or earlier) the\n // requirements and replacements listed in the main module's go.mod file.\n-func checkVendorConsistency() {\n-\treadVendorList()\n+func checkVendorConsistency(index *modFileIndex, modFile *modfile.File) {\n+\treadVendorList(MainModules.mustGetSingleMainModule())\n \n \tpre114 := false\n \tif semver.Compare(index.goVersionV, \"v1.14\") < 0 {\n@@ -146,7 +147,7 @@ func checkVendorConsistency() {\n \t}\n \n \tvendErrors := new(strings.Builder)\n-\tvendErrorf := func(mod module.Version, format string, args ...interface{}) {\n+\tvendErrorf := func(mod module.Version, format string, args ...any) {\n \t\tdetail := fmt.Sprintf(format, args...)\n \t\tif mod.Version == \"\" {\n \t\t\tfmt.Fprintf(vendErrors, \"\\n\\t%s: %s\", mod.Path, detail)\n@@ -219,6 +220,7 @@ func checkVendorConsistency() {\n \t}\n \n \tif vendErrors.Len() > 0 {\n+\t\tmodRoot := MainModules.ModRoot(MainModules.mustGetSingleMainModule())\n \t\tbase.Fatalf(\"go: inconsistent vendoring in %s:%s\\n\\n\\tTo ignore the vendor directory, use -mod=readonly or -mod=mod.\\n\\tTo sync the vendor directory, run:\\n\\t\\tgo mod vendor\", modRoot, vendErrors)\n \t}\n }"}, {"sha": "d25d447b0ee397fb603280be92e8b245a402f0d0", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -8,6 +8,7 @@ package mvs\n \n import (\n \t\"fmt\"\n+\t\"reflect\"\n \t\"sort\"\n \t\"sync\"\n \n@@ -85,11 +86,11 @@ type DowngradeReqs interface {\n // of the list are sorted by path.\n //\n // See https://research.swtch.com/vgo-mvs for details.\n-func BuildList(target module.Version, reqs Reqs) ([]module.Version, error) {\n-\treturn buildList(target, reqs, nil)\n+func BuildList(targets []module.Version, reqs Reqs) ([]module.Version, error) {\n+\treturn buildList(targets, reqs, nil)\n }\n \n-func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (module.Version, error)) ([]module.Version, error) {\n+func buildList(targets []module.Version, reqs Reqs, upgrade func(module.Version) (module.Version, error)) ([]module.Version, error) {\n \tcmp := func(v1, v2 string) int {\n \t\tif reqs.Max(v1, v2) != v1 {\n \t\t\treturn -1\n@@ -102,16 +103,18 @@ func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (m\n \n \tvar (\n \t\tmu       sync.Mutex\n-\t\tg        = NewGraph(cmp, []module.Version{target})\n+\t\tg        = NewGraph(cmp, targets)\n \t\tupgrades = map[module.Version]module.Version{}\n \t\terrs     = map[module.Version]error{} // (non-nil errors only)\n \t)\n \n \t// Explore work graph in parallel in case reqs.Required\n \t// does high-latency network operations.\n \tvar work par.Work\n-\twork.Add(target)\n-\twork.Do(10, func(item interface{}) {\n+\tfor _, target := range targets {\n+\t\twork.Add(target)\n+\t}\n+\twork.Do(10, func(item any) {\n \t\tm := item.(module.Version)\n \n \t\tvar required []module.Version\n@@ -168,21 +171,21 @@ func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (m\n \n \t// The final list is the minimum version of each module found in the graph.\n \tlist := g.BuildList()\n-\tif v := list[0]; v != target {\n+\tif vs := list[:len(targets)]; !reflect.DeepEqual(vs, targets) {\n \t\t// target.Version will be \"\" for modload, the main client of MVS.\n \t\t// \"\" denotes the main module, which has no version. However, MVS treats\n \t\t// version strings as opaque, so \"\" is not a special value here.\n \t\t// See golang.org/issue/31491, golang.org/issue/29773.\n-\t\tpanic(fmt.Sprintf(\"mistake: chose version %q instead of target %+v\", v, target))\n+\t\tpanic(fmt.Sprintf(\"mistake: chose versions %+v instead of targets %+v\", vs, targets))\n \t}\n \treturn list, nil\n }\n \n // Req returns the minimal requirement list for the target module,\n // with the constraint that all module paths listed in base must\n // appear in the returned list.\n-func Req(target module.Version, base []string, reqs Reqs) ([]module.Version, error) {\n-\tlist, err := BuildList(target, reqs)\n+func Req(mainModule module.Version, base []string, reqs Reqs) ([]module.Version, error) {\n+\tlist, err := BuildList([]module.Version{mainModule}, reqs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -194,7 +197,8 @@ func Req(target module.Version, base []string, reqs Reqs) ([]module.Version, err\n \t// Compute postorder, cache requirements.\n \tvar postorder []module.Version\n \treqCache := map[module.Version][]module.Version{}\n-\treqCache[target] = nil\n+\treqCache[mainModule] = nil\n+\n \tvar walk func(module.Version) error\n \twalk = func(m module.Version) error {\n \t\t_, ok := reqCache[m]\n@@ -273,7 +277,7 @@ func Req(target module.Version, base []string, reqs Reqs) ([]module.Version, err\n // UpgradeAll returns a build list for the target module\n // in which every module is upgraded to its latest version.\n func UpgradeAll(target module.Version, reqs UpgradeReqs) ([]module.Version, error) {\n-\treturn buildList(target, reqs, func(m module.Version) (module.Version, error) {\n+\treturn buildList([]module.Version{target}, reqs, func(m module.Version) (module.Version, error) {\n \t\tif m.Path == target.Path {\n \t\t\treturn target, nil\n \t\t}\n@@ -308,7 +312,7 @@ func Upgrade(target module.Version, reqs UpgradeReqs, upgrade ...module.Version)\n \t\t}\n \t}\n \n-\treturn buildList(target, &override{target, list, reqs}, func(m module.Version) (module.Version, error) {\n+\treturn buildList([]module.Version{target}, &override{target, list, reqs}, func(m module.Version) (module.Version, error) {\n \t\tif v, ok := upgradeTo[m.Path]; ok {\n \t\t\treturn module.Version{Path: m.Path, Version: v}, nil\n \t\t}\n@@ -331,7 +335,7 @@ func Downgrade(target module.Version, reqs DowngradeReqs, downgrade ...module.Ve\n \t//\n \t// In order to generate those new requirements, we need to identify versions\n \t// for every module in the build list \u2014 not just reqs.Required(target).\n-\tlist, err := BuildList(target, reqs)\n+\tlist, err := BuildList([]module.Version{target}, reqs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -446,7 +450,7 @@ List:\n \t// list with the actual versions of the downgraded modules as selected by MVS,\n \t// instead of our initial downgrades.\n \t// (See the downhiddenartifact and downhiddencross test cases).\n-\tactual, err := BuildList(target, &override{\n+\tactual, err := BuildList([]module.Version{target}, &override{\n \t\ttarget: target,\n \t\tlist:   downgraded,\n \t\tReqs:   reqs,\n@@ -466,7 +470,7 @@ List:\n \t\t}\n \t}\n \n-\treturn BuildList(target, &override{\n+\treturn BuildList([]module.Version{target}, &override{\n \t\ttarget: target,\n \t\tlist:   downgraded,\n \t\tReqs:   reqs,"}, {"sha": "26d004fee2856ebb2a19cf27033d753b01e11c8d", "filename": "libgo/go/cmd/go/internal/mvs/mvs_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -507,7 +507,7 @@ func Test(t *testing.T) {\n \t\t\t\tt.Fatalf(\"build takes one argument: %q\", line)\n \t\t\t}\n \t\t\tfns = append(fns, func(t *testing.T) {\n-\t\t\t\tlist, err := BuildList(m(kf[1]), reqs)\n+\t\t\t\tlist, err := BuildList([]module.Version{m(kf[1])}, reqs)\n \t\t\t\tcheckList(t, key, list, err, val)\n \t\t\t})\n \t\t\tcontinue"}, {"sha": "496c41b1509281bcea9b1ba5abfda1effe605e4f", "filename": "libgo/go/cmd/go/internal/par/work.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -14,24 +14,24 @@ import (\n // Work manages a set of work items to be executed in parallel, at most once each.\n // The items in the set must all be valid map keys.\n type Work struct {\n-\tf       func(interface{}) // function to run for each item\n-\trunning int               // total number of runners\n+\tf       func(any) // function to run for each item\n+\trunning int       // total number of runners\n \n \tmu      sync.Mutex\n-\tadded   map[interface{}]bool // items added to set\n-\ttodo    []interface{}        // items yet to be run\n-\twait    sync.Cond            // wait when todo is empty\n-\twaiting int                  // number of runners waiting for todo\n+\tadded   map[any]bool // items added to set\n+\ttodo    []any        // items yet to be run\n+\twait    sync.Cond    // wait when todo is empty\n+\twaiting int          // number of runners waiting for todo\n }\n \n func (w *Work) init() {\n \tif w.added == nil {\n-\t\tw.added = make(map[interface{}]bool)\n+\t\tw.added = make(map[any]bool)\n \t}\n }\n \n // Add adds item to the work set, if it hasn't already been added.\n-func (w *Work) Add(item interface{}) {\n+func (w *Work) Add(item any) {\n \tw.mu.Lock()\n \tw.init()\n \tif !w.added[item] {\n@@ -51,7 +51,7 @@ func (w *Work) Add(item interface{}) {\n // before calling Do (or else Do returns immediately),\n // but it is allowed for f(item) to add new items to the set.\n // Do should only be used once on a given Work.\n-func (w *Work) Do(n int, f func(item interface{})) {\n+func (w *Work) Do(n int, f func(item any)) {\n \tif n < 1 {\n \t\tpanic(\"par.Work.Do: n < 1\")\n \t}\n@@ -110,13 +110,13 @@ type Cache struct {\n type cacheEntry struct {\n \tdone   uint32\n \tmu     sync.Mutex\n-\tresult interface{}\n+\tresult any\n }\n \n // Do calls the function f if and only if Do is being called for the first time with this key.\n // No call to Do with a given key returns until the one call to f returns.\n // Do returns the value returned by the one call to f.\n-func (c *Cache) Do(key interface{}, f func() interface{}) interface{} {\n+func (c *Cache) Do(key any, f func() any) any {\n \tentryIface, ok := c.m.Load(key)\n \tif !ok {\n \t\tentryIface, _ = c.m.LoadOrStore(key, new(cacheEntry))\n@@ -136,7 +136,7 @@ func (c *Cache) Do(key interface{}, f func() interface{}) interface{} {\n // Get returns the cached result associated with key.\n // It returns nil if there is no such result.\n // If the result for key is being computed, Get does not wait for the computation to finish.\n-func (c *Cache) Get(key interface{}) interface{} {\n+func (c *Cache) Get(key any) any {\n \tentryIface, ok := c.m.Load(key)\n \tif !ok {\n \t\treturn nil\n@@ -156,7 +156,7 @@ func (c *Cache) Get(key interface{}) interface{} {\n // TODO(jayconrod): Delete this after the package cache clearing functions\n // in internal/load have been removed.\n func (c *Cache) Clear() {\n-\tc.m.Range(func(key, value interface{}) bool {\n+\tc.m.Range(func(key, value any) bool {\n \t\tc.m.Delete(key)\n \t\treturn true\n \t})\n@@ -169,7 +169,7 @@ func (c *Cache) Clear() {\n //\n // TODO(jayconrod): Delete this after the package cache clearing functions\n // in internal/load have been removed.\n-func (c *Cache) Delete(key interface{}) {\n+func (c *Cache) Delete(key any) {\n \tc.m.Delete(key)\n }\n \n@@ -180,8 +180,8 @@ func (c *Cache) Delete(key interface{}) {\n //\n // TODO(jayconrod): Delete this after the package cache clearing functions\n // in internal/load have been removed.\n-func (c *Cache) DeleteIf(pred func(key interface{}) bool) {\n-\tc.m.Range(func(key, _ interface{}) bool {\n+func (c *Cache) DeleteIf(pred func(key any) bool) {\n+\tc.m.Range(func(key, _ any) bool {\n \t\tif pred(key) {\n \t\t\tc.Delete(key)\n \t\t}"}, {"sha": "add0e640d8c093423e16c1a3fae1cd2b208bd137", "filename": "libgo/go/cmd/go/internal/par/work_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -16,7 +16,7 @@ func TestWork(t *testing.T) {\n \tconst N = 10000\n \tn := int32(0)\n \tw.Add(N)\n-\tw.Do(100, func(x interface{}) {\n+\tw.Do(100, func(x any) {\n \t\tatomic.AddInt32(&n, 1)\n \t\ti := x.(int)\n \t\tif i >= 2 {\n@@ -40,7 +40,7 @@ func TestWorkParallel(t *testing.T) {\n \t\t}\n \t\tstart := time.Now()\n \t\tvar n int32\n-\t\tw.Do(N, func(x interface{}) {\n+\t\tw.Do(N, func(x any) {\n \t\t\ttime.Sleep(1 * time.Millisecond)\n \t\t\tatomic.AddInt32(&n, +1)\n \t\t})\n@@ -58,19 +58,19 @@ func TestCache(t *testing.T) {\n \tvar cache Cache\n \n \tn := 1\n-\tv := cache.Do(1, func() interface{} { n++; return n })\n+\tv := cache.Do(1, func() any { n++; return n })\n \tif v != 2 {\n \t\tt.Fatalf(\"cache.Do(1) did not run f\")\n \t}\n-\tv = cache.Do(1, func() interface{} { n++; return n })\n+\tv = cache.Do(1, func() any { n++; return n })\n \tif v != 2 {\n \t\tt.Fatalf(\"cache.Do(1) ran f again!\")\n \t}\n-\tv = cache.Do(2, func() interface{} { n++; return n })\n+\tv = cache.Do(2, func() any { n++; return n })\n \tif v != 3 {\n \t\tt.Fatalf(\"cache.Do(2) did not run f\")\n \t}\n-\tv = cache.Do(1, func() interface{} { n++; return n })\n+\tv = cache.Do(1, func() any { n++; return n })\n \tif v != 2 {\n \t\tt.Fatalf(\"cache.Do(1) did not returned saved value from original cache.Do(1)\")\n \t}"}, {"sha": "c56e36ca62412aae46a98f41f5a2d9ad5191fe8e", "filename": "libgo/go/cmd/go/internal/robustio/robustio_flaky.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build windows || darwin\n-// +build windows darwin\n \n package robustio\n "}, {"sha": "da9a46e4face362eb5d95872bccc2ecd4a7a5424", "filename": "libgo/go/cmd/go/internal/robustio/robustio_other.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !windows && !darwin\n-// +build !windows,!darwin\n \n package robustio\n "}, {"sha": "c4b70b64fe651b6bed5a3b8b5bcc8a6d0d33c0a1", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -65,14 +65,17 @@ func init() {\n \tCmdRun.Run = runRun // break init loop\n \n \twork.AddBuildFlags(CmdRun, work.DefaultBuildFlags)\n+\tbase.AddWorkfileFlag(&CmdRun.Flag)\n \tCmdRun.Flag.Var((*base.StringsFlag)(&work.ExecCmd), \"exec\", \"\")\n }\n \n-func printStderr(args ...interface{}) (int, error) {\n+func printStderr(args ...any) (int, error) {\n \treturn fmt.Fprint(os.Stderr, args...)\n }\n \n func runRun(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n \tif shouldUseOutsideModuleMode(args) {\n \t\t// Set global module flags for 'go run cmd@version'.\n \t\t// This must be done before modload.Init, but we need to call work.BuildInit\n@@ -100,7 +103,7 @@ func runRun(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tif strings.HasSuffix(file, \"_test.go\") {\n \t\t\t\t// GoFilesPackage is going to assign this to TestGoFiles.\n \t\t\t\t// Reject since it won't be part of the build.\n-\t\t\t\tbase.Fatalf(\"go run: cannot run *_test.go files (%s)\", file)\n+\t\t\t\tbase.Fatalf(\"go: cannot run *_test.go files (%s)\", file)\n \t\t\t}\n \t\t}\n \t\tp = load.GoFilesPackage(ctx, pkgOpts, files)\n@@ -111,26 +114,26 @@ func runRun(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tvar err error\n \t\t\tpkgs, err = load.PackagesAndErrorsOutsideModule(ctx, pkgOpts, args[:1])\n \t\t\tif err != nil {\n-\t\t\t\tbase.Fatalf(\"go run: %v\", err)\n+\t\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t\t}\n \t\t} else {\n \t\t\tpkgs = load.PackagesAndErrors(ctx, pkgOpts, args[:1])\n \t\t}\n \n \t\tif len(pkgs) == 0 {\n-\t\t\tbase.Fatalf(\"go run: no packages loaded from %s\", arg)\n+\t\t\tbase.Fatalf(\"go: no packages loaded from %s\", arg)\n \t\t}\n \t\tif len(pkgs) > 1 {\n \t\t\tvar names []string\n \t\t\tfor _, p := range pkgs {\n \t\t\t\tnames = append(names, p.ImportPath)\n \t\t\t}\n-\t\t\tbase.Fatalf(\"go run: pattern %s matches multiple packages:\\n\\t%s\", arg, strings.Join(names, \"\\n\\t\"))\n+\t\t\tbase.Fatalf(\"go: pattern %s matches multiple packages:\\n\\t%s\", arg, strings.Join(names, \"\\n\\t\"))\n \t\t}\n \t\tp = pkgs[0]\n \t\ti++\n \t} else {\n-\t\tbase.Fatalf(\"go run: no go files listed\")\n+\t\tbase.Fatalf(\"go: no go files listed\")\n \t}\n \tcmdArgs := args[i:]\n \tload.CheckPackageErrors([]*load.Package{p})\n@@ -151,7 +154,7 @@ func runRun(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tif !cfg.BuildContext.CgoEnabled {\n \t\t\t\thint = \" (cgo is disabled)\"\n \t\t\t}\n-\t\t\tbase.Fatalf(\"go run: no suitable source files%s\", hint)\n+\t\t\tbase.Fatalf(\"go: no suitable source files%s\", hint)\n \t\t}\n \t\tp.Internal.ExeName = src[:len(src)-len(\".go\")]\n \t} else {"}, {"sha": "ebd4990a68413b2b03476f0305fff05924db2093", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -202,20 +202,14 @@ func (m *Match) MatchPackages() {\n \t}\n }\n \n-var modRoot string\n-\n-func SetModRoot(dir string) {\n-\tmodRoot = dir\n-}\n-\n // MatchDirs sets m.Dirs to a non-nil slice containing all directories that\n // potentially match a local pattern. The pattern must begin with an absolute\n // path, or \"./\", or \"../\". On Windows, the pattern may use slash or backslash\n // separators or a mix of both.\n //\n // If any errors may have caused the set of directories to be incomplete,\n // MatchDirs appends those errors to m.Errs.\n-func (m *Match) MatchDirs() {\n+func (m *Match) MatchDirs(modRoots []string) {\n \tm.Dirs = []string{}\n \tif !m.IsLocal() {\n \t\tm.AddError(fmt.Errorf(\"internal error: MatchDirs: %s is not a valid filesystem pattern\", m.pattern))\n@@ -253,15 +247,24 @@ func (m *Match) MatchDirs() {\n \t// We need to preserve the ./ for pattern matching\n \t// and in the returned import paths.\n \n-\tif modRoot != \"\" {\n+\tif len(modRoots) > 1 {\n \t\tabs, err := filepath.Abs(dir)\n \t\tif err != nil {\n \t\t\tm.AddError(err)\n \t\t\treturn\n \t\t}\n-\t\tif !hasFilepathPrefix(abs, modRoot) {\n-\t\t\tm.AddError(fmt.Errorf(\"directory %s is outside module root (%s)\", abs, modRoot))\n-\t\t\treturn\n+\t\tvar found bool\n+\t\tfor _, modRoot := range modRoots {\n+\t\t\tif modRoot != \"\" && hasFilepathPrefix(abs, modRoot) {\n+\t\t\t\tfound = true\n+\t\t\t}\n+\t\t}\n+\t\tif !found {\n+\t\t\tplural := \"\"\n+\t\t\tif len(modRoots) > 1 {\n+\t\t\t\tplural = \"s\"\n+\t\t\t}\n+\t\t\tm.AddError(fmt.Errorf(\"directory %s is outside module root%s (%s)\", abs, plural, strings.Join(modRoots, \", \")))\n \t\t}\n \t}\n \n@@ -424,19 +427,19 @@ func WarnUnmatched(matches []*Match) {\n \n // ImportPaths returns the matching paths to use for the given command line.\n // It calls ImportPathsQuiet and then WarnUnmatched.\n-func ImportPaths(patterns []string) []*Match {\n-\tmatches := ImportPathsQuiet(patterns)\n+func ImportPaths(patterns, modRoots []string) []*Match {\n+\tmatches := ImportPathsQuiet(patterns, modRoots)\n \tWarnUnmatched(matches)\n \treturn matches\n }\n \n // ImportPathsQuiet is like ImportPaths but does not warn about patterns with no matches.\n-func ImportPathsQuiet(patterns []string) []*Match {\n+func ImportPathsQuiet(patterns, modRoots []string) []*Match {\n \tvar out []*Match\n \tfor _, a := range CleanPatterns(patterns) {\n \t\tm := NewMatch(a)\n \t\tif m.IsLocal() {\n-\t\t\tm.MatchDirs()\n+\t\t\tm.MatchDirs(modRoots)\n \n \t\t\t// Change the file import path to a regular import path if the package\n \t\t\t// is in GOPATH or GOROOT. We don't report errors here; LoadImport"}, {"sha": "0c8aaeaca1fba0f5f2cbc0d27c2262d8d43932f5", "filename": "libgo/go/cmd/go/internal/str/path.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -49,3 +49,17 @@ func HasFilePathPrefix(s, prefix string) bool {\n \t\treturn s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix\n \t}\n }\n+\n+// TrimFilePathPrefix returns s without the leading path elements in prefix.\n+// If s does not start with prefix (HasFilePathPrefix with the same arguments\n+// returns false), TrimFilePathPrefix returns s. If s equals prefix,\n+// TrimFilePathPrefix returns \"\".\n+func TrimFilePathPrefix(s, prefix string) string {\n+\tif !HasFilePathPrefix(s, prefix) {\n+\t\treturn s\n+\t}\n+\tif len(s) == len(prefix) {\n+\t\treturn \"\"\n+\t}\n+\treturn s[len(prefix)+1:]\n+}"}, {"sha": "021bfbff779162b14a7882cbc1e7b63da9fd929b", "filename": "libgo/go/cmd/go/internal/str/str.go", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -14,7 +14,7 @@ import (\n \n // StringList flattens its arguments into a single []string.\n // Each argument in args must have type string or []string.\n-func StringList(args ...interface{}) []string {\n+func StringList(args ...any) []string {\n \tvar x []string\n \tfor _, arg := range args {\n \t\tswitch arg := arg.(type) {\n@@ -109,47 +109,3 @@ func Uniq(ss *[]string) {\n \t}\n \t*ss = uniq\n }\n-\n-func isSpaceByte(c byte) bool {\n-\treturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'\n-}\n-\n-// SplitQuotedFields splits s into a list of fields,\n-// allowing single or double quotes around elements.\n-// There is no unescaping or other processing within\n-// quoted fields.\n-func SplitQuotedFields(s string) ([]string, error) {\n-\t// Split fields allowing '' or \"\" around elements.\n-\t// Quotes further inside the string do not count.\n-\tvar f []string\n-\tfor len(s) > 0 {\n-\t\tfor len(s) > 0 && isSpaceByte(s[0]) {\n-\t\t\ts = s[1:]\n-\t\t}\n-\t\tif len(s) == 0 {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Accepted quoted string. No unescaping inside.\n-\t\tif s[0] == '\"' || s[0] == '\\'' {\n-\t\t\tquote := s[0]\n-\t\t\ts = s[1:]\n-\t\t\ti := 0\n-\t\t\tfor i < len(s) && s[i] != quote {\n-\t\t\t\ti++\n-\t\t\t}\n-\t\t\tif i >= len(s) {\n-\t\t\t\treturn nil, fmt.Errorf(\"unterminated %c string\", quote)\n-\t\t\t}\n-\t\t\tf = append(f, s[:i])\n-\t\t\ts = s[i+1:]\n-\t\t\tcontinue\n-\t\t}\n-\t\ti := 0\n-\t\tfor i < len(s) && !isSpaceByte(s[i]) {\n-\t\t\ti++\n-\t\t}\n-\t\tf = append(f, s[:i])\n-\t\ts = s[i:]\n-\t}\n-\treturn f, nil\n-}"}, {"sha": "8ea758e0a8b64bf0c8e4314660f9b79050fb4383", "filename": "libgo/go/cmd/go/internal/str/str_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -4,7 +4,9 @@\n \n package str\n \n-import \"testing\"\n+import (\n+\t\"testing\"\n+)\n \n var foldDupTests = []struct {\n \tlist   []string"}, {"sha": "1b79314eff365889fa9b4b1cb9b221e91abfbd49", "filename": "libgo/go/cmd/go/internal/test/flagdefs.go", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -19,6 +19,9 @@ var passFlagToTest = map[string]bool{\n \t\"cpu\":                  true,\n \t\"cpuprofile\":           true,\n \t\"failfast\":             true,\n+\t\"fuzz\":                 true,\n+\t\"fuzzminimizetime\":     true,\n+\t\"fuzztime\":             true,\n \t\"list\":                 true,\n \t\"memprofile\":           true,\n \t\"memprofilerate\":       true,\n@@ -33,3 +36,37 @@ var passFlagToTest = map[string]bool{\n \t\"trace\":                true,\n \t\"v\":                    true,\n }\n+\n+var passAnalyzersToVet = map[string]bool{\n+\t\"asmdecl\":          true,\n+\t\"assign\":           true,\n+\t\"atomic\":           true,\n+\t\"bool\":             true,\n+\t\"bools\":            true,\n+\t\"buildtag\":         true,\n+\t\"buildtags\":        true,\n+\t\"cgocall\":          true,\n+\t\"composites\":       true,\n+\t\"copylocks\":        true,\n+\t\"errorsas\":         true,\n+\t\"framepointer\":     true,\n+\t\"httpresponse\":     true,\n+\t\"ifaceassert\":      true,\n+\t\"loopclosure\":      true,\n+\t\"lostcancel\":       true,\n+\t\"methods\":          true,\n+\t\"nilfunc\":          true,\n+\t\"printf\":           true,\n+\t\"rangeloops\":       true,\n+\t\"shift\":            true,\n+\t\"sigchanyzer\":      true,\n+\t\"stdmethods\":       true,\n+\t\"stringintconv\":    true,\n+\t\"structtag\":        true,\n+\t\"testinggoroutine\": true,\n+\t\"tests\":            true,\n+\t\"unmarshal\":        true,\n+\t\"unreachable\":      true,\n+\t\"unsafeptr\":        true,\n+\t\"unusedresult\":     true,\n+}"}, {"sha": "a2f09e5a9609cac258f11151ef52ed2ce430dc8d", "filename": "libgo/go/cmd/go/internal/test/flagdefs_test.go", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,7 +5,10 @@\n package test\n \n import (\n+\t\"cmd/go/internal/test/internal/genflags\"\n \t\"flag\"\n+\t\"internal/testenv\"\n+\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -17,7 +20,7 @@ func TestPassFlagToTestIncludesAllTestFlags(t *testing.T) {\n \t\t}\n \t\tname := strings.TrimPrefix(f.Name, \"test.\")\n \t\tswitch name {\n-\t\tcase \"testlogfile\", \"paniconexit0\":\n+\t\tcase \"testlogfile\", \"paniconexit0\", \"fuzzcachedir\", \"fuzzworker\":\n \t\t\t// These are internal flags.\n \t\tdefault:\n \t\t\tif !passFlagToTest[name] {\n@@ -37,3 +40,22 @@ func TestPassFlagToTestIncludesAllTestFlags(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestVetAnalyzersSetIsCorrect(t *testing.T) {\n+\ttestenv.MustHaveGoBuild(t)\n+\n+\tvetAns, err := genflags.VetAnalyzers()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\twant := make(map[string]bool)\n+\tfor _, a := range vetAns {\n+\t\twant[a] = true\n+\t}\n+\n+\tif !reflect.DeepEqual(want, passAnalyzersToVet) {\n+\t\tt.Errorf(\"stale vet analyzers: want %v; got %v\", want, passAnalyzersToVet)\n+\t\tt.Logf(\"(Run 'go generate cmd/go/internal/test' to refresh the set of analyzers.)\")\n+\t}\n+}"}, {"sha": "10f290090c7cf8e92420c8f61dae4ca559d926d0", "filename": "libgo/go/cmd/go/internal/test/genflags.go", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build ignore\n-// +build ignore\n \n package main\n \n@@ -16,6 +15,8 @@ import (\n \t\"strings\"\n \t\"testing\"\n \t\"text/template\"\n+\n+\t\"cmd/go/internal/test/internal/genflags\"\n )\n \n func main() {\n@@ -25,9 +26,18 @@ func main() {\n }\n \n func regenerate() error {\n+\tvetAnalyzers, err := genflags.VetAnalyzers()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \tt := template.Must(template.New(\"fileTemplate\").Parse(fileTemplate))\n+\ttData := map[string][]string{\n+\t\t\"testFlags\":    testFlags(),\n+\t\t\"vetAnalyzers\": vetAnalyzers,\n+\t}\n \tbuf := bytes.NewBuffer(nil)\n-\tif err := t.Execute(buf, testFlags()); err != nil {\n+\tif err := t.Execute(buf, tData); err != nil {\n \t\treturn err\n \t}\n \n@@ -64,7 +74,7 @@ func testFlags() []string {\n \t\tname := strings.TrimPrefix(f.Name, \"test.\")\n \n \t\tswitch name {\n-\t\tcase \"testlogfile\", \"paniconexit0\":\n+\t\tcase \"testlogfile\", \"paniconexit0\", \"fuzzcachedir\", \"fuzzworker\":\n \t\t\t// These flags are only for use by cmd/go.\n \t\tdefault:\n \t\t\tnames = append(names, name)\n@@ -85,7 +95,13 @@ package test\n // passFlagToTest contains the flags that should be forwarded to\n // the test binary with the prefix \"test.\".\n var passFlagToTest = map[string]bool {\n-{{- range .}}\n+{{- range .testFlags}}\n+\t\"{{.}}\": true,\n+{{- end }}\n+}\n+\n+var passAnalyzersToVet = map[string]bool {\n+{{- range .vetAnalyzers}}\n \t\"{{.}}\": true,\n {{- end }}\n }"}, {"sha": "2195cc34479f31bc611860fa9cdfecbbcc5744f3", "filename": "libgo/go/cmd/go/internal/test/internal/genflags/vetflag.go", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Finternal%2Fgenflags%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Finternal%2Fgenflags%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Finternal%2Fgenflags%2Fvetflag.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package genflags\n+\n+import (\n+\t\"bytes\"\n+\t\"cmd/go/internal/base\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\texec \"internal/execabs\"\n+\t\"regexp\"\n+\t\"sort\"\n+)\n+\n+// VetAnalyzers computes analyzers and their aliases supported by vet.\n+func VetAnalyzers() ([]string, error) {\n+\t// get supported vet flag information\n+\ttool := base.Tool(\"vet\")\n+\tvetcmd := exec.Command(tool, \"-flags\")\n+\tout := new(bytes.Buffer)\n+\tvetcmd.Stdout = out\n+\tif err := vetcmd.Run(); err != nil {\n+\t\treturn nil, fmt.Errorf(\"go vet: can't execute %s -flags: %v\\n\", tool, err)\n+\t}\n+\tvar analysisFlags []struct {\n+\t\tName  string\n+\t\tBool  bool\n+\t\tUsage string\n+\t}\n+\tif err := json.Unmarshal(out.Bytes(), &analysisFlags); err != nil {\n+\t\treturn nil, fmt.Errorf(\"go vet: can't unmarshal JSON from %s -flags: %v\", tool, err)\n+\t}\n+\n+\t// parse the flags to figure out which ones stand for analyses\n+\tanalyzerSet := make(map[string]bool)\n+\trEnable := regexp.MustCompile(\"^enable .+ analysis$\")\n+\tfor _, flag := range analysisFlags {\n+\t\tif rEnable.MatchString(flag.Usage) {\n+\t\t\tanalyzerSet[flag.Name] = true\n+\t\t}\n+\t}\n+\n+\trDeprecated := regexp.MustCompile(\"^deprecated alias for -(?P<analyzer>(.+))$\")\n+\t// Returns the original value matched by rDeprecated on input value.\n+\t// If there is no match, \"\" is returned.\n+\toriginalValue := func(value string) string {\n+\t\tmatch := rDeprecated.FindStringSubmatch(value)\n+\t\tif len(match) < 2 {\n+\t\t\treturn \"\"\n+\t\t}\n+\t\treturn match[1]\n+\t}\n+\t// extract deprecated aliases for existing analyses\n+\tfor _, flag := range analysisFlags {\n+\t\tif o := originalValue(flag.Usage); analyzerSet[o] {\n+\t\t\tanalyzerSet[flag.Name] = true\n+\t\t}\n+\t}\n+\n+\tvar analyzers []string\n+\tfor a := range analyzerSet {\n+\t\tanalyzers = append(analyzers, a)\n+\t}\n+\tsort.Strings(analyzers)\n+\treturn analyzers, nil\n+}"}, {"sha": "50e6d5201b0d6e04cc59a3289d30fa8b4e1cb2b0", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 227, "deletions": 45, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -29,11 +29,15 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/lockedfile\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/trace\"\n \t\"cmd/go/internal/work\"\n+\t\"cmd/internal/sys\"\n \t\"cmd/internal/test2json\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n // Break init loop.\n@@ -60,8 +64,8 @@ followed by detailed output for each failed package.\n \n 'Go test' recompiles each package along with any files with names matching\n the file pattern \"*_test.go\".\n-These additional files can contain test functions, benchmark functions, and\n-example functions. See 'go help testfunc' for more.\n+These additional files can contain test functions, benchmark functions, fuzz\n+tests and example functions. See 'go help testfunc' for more.\n Each listed package causes the execution of a separate test binary.\n Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n \n@@ -78,7 +82,8 @@ binary. Only a high-confidence subset of the default go vet checks are\n used. That subset is: 'atomic', 'bool', 'buildtags', 'errorsas',\n 'ifaceassert', 'nilfunc', 'printf', and 'stringintconv'. You can see\n the documentation for these and other vet tests via \"go doc cmd/vet\".\n-To disable the running of go vet, use the -vet=off flag.\n+To disable the running of go vet, use the -vet=off flag. To run all\n+checks, use the -vet=all flag.\n \n All test output and summary lines are printed to the go command's\n standard output, even if the test printed them to its own standard\n@@ -119,16 +124,16 @@ elapsed time in the summary line.\n The rule for a match in the cache is that the run involves the same\n test binary and the flags on the command line come entirely from a\n restricted set of 'cacheable' test flags, defined as -benchtime, -cpu,\n--list, -parallel, -run, -short, and -v. If a run of go test has any test\n-or non-test flags outside this set, the result is not cached. To\n-disable test caching, use any test flag or argument other than the\n-cacheable flags. The idiomatic way to disable test caching explicitly\n-is to use -count=1. Tests that open files within the package's source\n-root (usually $GOPATH) or that consult environment variables only\n-match future runs in which the files and environment variables are unchanged.\n-A cached test result is treated as executing in no time at all,\n-so a successful package test result will be cached and reused\n-regardless of -timeout setting.\n+-list, -parallel, -run, -short, -timeout, -failfast, and -v.\n+If a run of go test has any test or non-test flags outside this set,\n+the result is not cached. To disable test caching, use any test flag\n+or argument other than the cacheable flags. The idiomatic way to disable\n+test caching explicitly is to use -count=1. Tests that open files within\n+the package's source root (usually $GOPATH) or that consult environment\n+variables only match future runs in which the files and environment\n+variables are unchanged. A cached test result is treated as executing\n+in no time at all,so a successful package test result will be cached and\n+reused regardless of -timeout setting.\n \n In addition to the build flags, the flags handled by 'go test' itself are:\n \n@@ -206,9 +211,10 @@ control the execution of any test:\n \t    (for example, -benchtime 100x).\n \n \t-count n\n-\t    Run each test and benchmark n times (default 1).\n+\t    Run each test, benchmark, and fuzz seed n times (default 1).\n \t    If -cpu is set, run n times for each GOMAXPROCS value.\n-\t    Examples are always run once.\n+\t    Examples are always run once. -count does not apply to\n+\t    fuzz tests matched by -fuzz.\n \n \t-cover\n \t    Enable coverage analysis.\n@@ -235,32 +241,67 @@ control the execution of any test:\n \t    Sets -cover.\n \n \t-cpu 1,2,4\n-\t    Specify a list of GOMAXPROCS values for which the tests or\n-\t    benchmarks should be executed. The default is the current value\n-\t    of GOMAXPROCS.\n+\t    Specify a list of GOMAXPROCS values for which the tests, benchmarks or\n+\t    fuzz tests should be executed. The default is the current value\n+\t    of GOMAXPROCS. -cpu does not apply to fuzz tests matched by -fuzz.\n \n \t-failfast\n \t    Do not start new tests after the first test failure.\n \n+\t-fuzz regexp\n+\t    Run the fuzz test matching the regular expression. When specified,\n+\t    the command line argument must match exactly one package within the\n+\t    main module, and regexp must match exactly one fuzz test within\n+\t    that package. Fuzzing will occur after tests, benchmarks, seed corpora\n+\t    of other fuzz tests, and examples have completed. See the Fuzzing\n+\t    section of the testing package documentation for details.\n+\n+\t-fuzztime t\n+\t    Run enough iterations of the fuzz target during fuzzing to take t,\n+\t    specified as a time.Duration (for example, -fuzztime 1h30s).\n+\t\tThe default is to run forever.\n+\t    The special syntax Nx means to run the fuzz target N times\n+\t    (for example, -fuzztime 1000x).\n+\n+\t-fuzzminimizetime t\n+\t    Run enough iterations of the fuzz target during each minimization\n+\t    attempt to take t, as specified as a time.Duration (for example,\n+\t    -fuzzminimizetime 30s).\n+\t\tThe default is 60s.\n+\t    The special syntax Nx means to run the fuzz target N times\n+\t    (for example, -fuzzminimizetime 100x).\n+\n+\t-json\n+\t    Log verbose output and test results in JSON. This presents the\n+\t    same information as the -v flag in a machine-readable format.\n+\n \t-list regexp\n-\t    List tests, benchmarks, or examples matching the regular expression.\n-\t    No tests, benchmarks or examples will be run. This will only\n-\t    list top-level tests. No subtest or subbenchmarks will be shown.\n+\t    List tests, benchmarks, fuzz tests, or examples matching the regular\n+\t    expression. No tests, benchmarks, fuzz tests, or examples will be run.\n+\t    This will only list top-level tests. No subtest or subbenchmarks will be\n+\t    shown.\n \n \t-parallel n\n-\t    Allow parallel execution of test functions that call t.Parallel.\n+\t    Allow parallel execution of test functions that call t.Parallel, and\n+\t    fuzz targets that call t.Parallel when running the seed corpus.\n \t    The value of this flag is the maximum number of tests to run\n-\t    simultaneously; by default, it is set to the value of GOMAXPROCS.\n+\t    simultaneously.\n+\t    While fuzzing, the value of this flag is the maximum number of\n+\t    subprocesses that may call the fuzz function simultaneously, regardless of\n+\t    whether T.Parallel is called.\n+\t    By default, -parallel is set to the value of GOMAXPROCS.\n+\t    Setting -parallel to values higher than GOMAXPROCS may cause degraded\n+\t    performance due to CPU contention, especially when fuzzing.\n \t    Note that -parallel only applies within a single test binary.\n \t    The 'go test' command may run tests for different packages\n \t    in parallel as well, according to the setting of the -p flag\n \t    (see 'go help build').\n \n \t-run regexp\n-\t    Run only those tests and examples matching the regular expression.\n-\t    For tests, the regular expression is split by unbracketed slash (/)\n-\t    characters into a sequence of regular expressions, and each part\n-\t    of a test's identifier must match the corresponding element in\n+\t    Run only those tests, examples, and fuzz tests matching the regular\n+\t    expression. For tests, the regular expression is split by unbracketed\n+\t    slash (/) characters into a sequence of regular expressions, and each\n+\t    part of a test's identifier must match the corresponding element in\n \t    the sequence, if any. Note that possible parents of matches are\n \t    run too, so that -run=X/Y matches and runs and reports the result\n \t    of all tests matching X, even those without sub-tests matching Y,\n@@ -273,11 +314,11 @@ control the execution of any test:\n \t    exhaustive tests.\n \n \t-shuffle off,on,N\n-\t\tRandomize the execution order of tests and benchmarks.\n-\t\tIt is off by default. If -shuffle is set to on, then it will seed\n-\t\tthe randomizer using the system clock. If -shuffle is set to an\n-\t\tinteger N, then N will be used as the seed value. In both cases,\n-\t\tthe seed will be reported for reproducibility.\n+\t    Randomize the execution order of tests and benchmarks.\n+\t    It is off by default. If -shuffle is set to on, then it will seed\n+\t    the randomizer using the system clock. If -shuffle is set to an\n+\t    integer N, then N will be used as the seed value. In both cases,\n+\t    the seed will be reported for reproducibility.\n \n \t-timeout d\n \t    If a test binary runs longer than duration d, panic.\n@@ -373,7 +414,11 @@ leave the test binary in pkg.test for use when analyzing the profiles.\n When 'go test' runs a test binary, it does so from within the\n corresponding package's source code directory. Depending on the test,\n it may be necessary to do the same when invoking a generated test\n-binary directly.\n+binary directly. Because that directory may be located within the\n+module cache, which may be read-only and is verified by checksums, the\n+test must not write to it or any other directory within the module\n+unless explicitly requested by the user (such as with the -fuzz flag,\n+which writes failures to testdata/fuzz).\n \n The command-line package list, if present, must appear before any\n flag not known to the go test command. Continuing the example above,\n@@ -430,6 +475,10 @@ A benchmark function is one named BenchmarkXxx and should have the signature,\n \n \tfunc BenchmarkXxx(b *testing.B) { ... }\n \n+A fuzz test is one named FuzzXxx and should have the signature,\n+\n+\tfunc FuzzXxx(f *testing.F) { ... }\n+\n An example function is similar to a test function but, instead of using\n *testing.T to report success or failure, prints output to os.Stdout.\n If the last comment in the function starts with \"Output:\" then the output\n@@ -469,7 +518,7 @@ Here is another example where the ordering of the output is ignored:\n \n The entire test file is presented as the example when it contains a single\n example function, at least one other function, type, variable, or constant\n-declaration, and no test or benchmark functions.\n+declaration, and no tests, benchmarks, or fuzz tests.\n \n See the documentation of the testing package for more information.\n `,\n@@ -483,6 +532,7 @@ var (\n \ttestCoverPaths   []string                          // -coverpkg flag\n \ttestCoverPkgs    []*load.Package                   // -coverpkg flag\n \ttestCoverProfile string                            // -coverprofile flag\n+\ttestFuzz         string                            // -fuzz flag\n \ttestJSON         bool                              // -json flag\n \ttestList         string                            // -list flag\n \ttestO            string                            // -o flag\n@@ -578,6 +628,7 @@ var defaultVetFlags = []string{\n \n func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \tpkgArgs, testArgs = testFlags(args)\n+\tmodload.InitWorkfile() // The test command does custom flag processing; initialize workspaces after that.\n \n \tif cfg.DebugTrace != \"\" {\n \t\tvar close func() error\n@@ -615,6 +666,52 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \tif testO != \"\" && len(pkgs) != 1 {\n \t\tbase.Fatalf(\"cannot use -o flag with multiple packages\")\n \t}\n+\tif testFuzz != \"\" {\n+\t\tif !sys.FuzzSupported(cfg.Goos, cfg.Goarch) {\n+\t\t\tbase.Fatalf(\"-fuzz flag is not supported on %s/%s\", cfg.Goos, cfg.Goarch)\n+\t\t}\n+\t\tif len(pkgs) != 1 {\n+\t\t\tbase.Fatalf(\"cannot use -fuzz flag with multiple packages\")\n+\t\t}\n+\t\tif testCoverProfile != \"\" {\n+\t\t\tbase.Fatalf(\"cannot use -coverprofile flag with -fuzz flag\")\n+\t\t}\n+\t\tif profileFlag := testProfile(); profileFlag != \"\" {\n+\t\t\tbase.Fatalf(\"cannot use %s flag with -fuzz flag\", profileFlag)\n+\t\t}\n+\n+\t\t// Reject the '-fuzz' flag if the package is outside the main module.\n+\t\t// Otherwise, if fuzzing identifies a failure it could corrupt checksums in\n+\t\t// the module cache (or permanently alter the behavior of std tests for all\n+\t\t// users) by writing the failing input to the package's testdata directory.\n+\t\t// (See https://golang.org/issue/48495 and test_fuzz_modcache.txt.)\n+\t\tmainMods := modload.MainModules\n+\t\tif m := pkgs[0].Module; m != nil && m.Path != \"\" {\n+\t\t\tif !mainMods.Contains(m.Path) {\n+\t\t\t\tbase.Fatalf(\"cannot use -fuzz flag on package outside the main module\")\n+\t\t\t}\n+\t\t} else if pkgs[0].Standard && modload.Enabled() {\n+\t\t\t// Because packages in 'std' and 'cmd' are part of the standard library,\n+\t\t\t// they are only treated as part of a module in 'go mod' subcommands and\n+\t\t\t// 'go get'. However, we still don't want to accidentally corrupt their\n+\t\t\t// testdata during fuzzing, nor do we want to fail with surprising errors\n+\t\t\t// if GOROOT isn't writable (as is often the case for Go toolchains\n+\t\t\t// installed through package managers).\n+\t\t\t//\n+\t\t\t// If the user is requesting to fuzz a standard-library package, ensure\n+\t\t\t// that they are in the same module as that package (just like when\n+\t\t\t// fuzzing any other package).\n+\t\t\tif strings.HasPrefix(pkgs[0].ImportPath, \"cmd/\") {\n+\t\t\t\tif !mainMods.Contains(\"cmd\") || !mainMods.InGorootSrc(module.Version{Path: \"cmd\"}) {\n+\t\t\t\t\tbase.Fatalf(\"cannot use -fuzz flag on package outside the main module\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif !mainMods.Contains(\"std\") || !mainMods.InGorootSrc(module.Version{Path: \"std\"}) {\n+\t\t\t\t\tbase.Fatalf(\"cannot use -fuzz flag on package outside the main module\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n \tif testProfile() != \"\" && len(pkgs) != 1 {\n \t\tbase.Fatalf(\"cannot use %s flag with multiple packages\", testProfile())\n \t}\n@@ -625,7 +722,9 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \t// to that timeout plus one minute. This is a backup alarm in case\n \t// the test wedges with a goroutine spinning and its background\n \t// timer does not get a chance to fire.\n-\tif testTimeout > 0 {\n+\t// Don't set this if fuzzing, since it should be able to run\n+\t// indefinitely.\n+\tif testTimeout > 0 && testFuzz == \"\" {\n \t\ttestKillTimeout = testTimeout + 1*time.Minute\n \t}\n \n@@ -649,7 +748,7 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \tb.Init()\n \n \tif cfg.BuildI {\n-\t\tfmt.Fprint(os.Stderr, \"go test: -i flag is deprecated\\n\")\n+\t\tfmt.Fprint(os.Stderr, \"go: -i flag is deprecated\\n\")\n \t\tcfg.BuildV = testV\n \n \t\tdeps := make(map[string]bool)\n@@ -775,14 +874,49 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n+\t// Inform the compiler that it should instrument the binary at\n+\t// build-time when fuzzing is enabled.\n+\tif testFuzz != \"\" {\n+\t\t// Don't instrument packages which may affect coverage guidance but are\n+\t\t// unlikely to be useful. Most of these are used by the testing or\n+\t\t// internal/fuzz packages concurrently with fuzzing.\n+\t\tvar skipInstrumentation = map[string]bool{\n+\t\t\t\"context\":       true,\n+\t\t\t\"internal/fuzz\": true,\n+\t\t\t\"reflect\":       true,\n+\t\t\t\"runtime\":       true,\n+\t\t\t\"sync\":          true,\n+\t\t\t\"sync/atomic\":   true,\n+\t\t\t\"syscall\":       true,\n+\t\t\t\"testing\":       true,\n+\t\t\t\"time\":          true,\n+\t\t}\n+\t\tfor _, p := range load.TestPackageList(ctx, pkgOpts, pkgs) {\n+\t\t\tif !skipInstrumentation[p.ImportPath] {\n+\t\t\t\tp.Internal.FuzzInstrument = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Collect all the packages imported by the packages being tested.\n+\tallImports := make(map[*load.Package]bool)\n+\tfor _, p := range pkgs {\n+\t\tif p.Error != nil && p.Error.IsImportCycle {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, p1 := range p.Internal.Imports {\n+\t\t\tallImports[p1] = true\n+\t\t}\n+\t}\n+\n \t// Prepare build + run + print actions for all packages being tested.\n \tfor _, p := range pkgs {\n \t\t// sync/atomic import is inserted by the cover tool. See #18486\n \t\tif testCover && testCoverMode == \"atomic\" {\n \t\t\tensureImport(p, \"sync/atomic\")\n \t\t}\n \n-\t\tbuildTest, runTest, printTest, err := builderTest(&b, ctx, pkgOpts, p)\n+\t\tbuildTest, runTest, printTest, err := builderTest(&b, ctx, pkgOpts, p, allImports[p])\n \t\tif err != nil {\n \t\t\tstr := err.Error()\n \t\t\tstr = strings.TrimPrefix(str, \"\\n\")\n@@ -849,7 +983,7 @@ var windowsBadWords = []string{\n \t\"update\",\n }\n \n-func builderTest(b *work.Builder, ctx context.Context, pkgOpts load.PackageOpts, p *load.Package) (buildAction, runAction, printAction *work.Action, err error) {\n+func builderTest(b *work.Builder, ctx context.Context, pkgOpts load.PackageOpts, p *load.Package, imported bool) (buildAction, runAction, printAction *work.Action, err error) {\n \tif len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {\n \t\tbuild := b.CompileAction(work.ModeBuild, work.ModeBuild, p)\n \t\trun := &work.Action{Mode: \"test run\", Package: p, Deps: []*work.Action{build}}\n@@ -877,6 +1011,16 @@ func builderTest(b *work.Builder, ctx context.Context, pkgOpts load.PackageOpts,\n \t\treturn nil, nil, nil, err\n \t}\n \n+\t// If imported is true then this package is imported by some\n+\t// package being tested. Make building the test version of the\n+\t// package depend on building the non-test version, so that we\n+\t// only report build errors once. Issue #44624.\n+\tif imported && ptest != p {\n+\t\tbuildTest := b.CompileAction(work.ModeBuild, work.ModeBuild, ptest)\n+\t\tbuildP := b.CompileAction(work.ModeBuild, work.ModeBuild, p)\n+\t\tbuildTest.Deps = append(buildTest.Deps, buildP)\n+\t}\n+\n \t// Use last element of import path, not package name.\n \t// They differ when package name is \"main\".\n \t// But if the import path is \"command-line-arguments\",\n@@ -1080,6 +1224,8 @@ func declareCoverVars(p *load.Package, files ...string) map[string]*load.CoverVa\n }\n \n var noTestsToRun = []byte(\"\\ntesting: warning: no tests to run\\n\")\n+var noFuzzTestsToFuzz = []byte(\"\\ntesting: warning: no fuzz tests to fuzz\\n\")\n+var tooManyFuzzTestsToFuzz = []byte(\"\\ntesting: warning: -fuzz matches more than one fuzz test, won't fuzz\\n\")\n \n type runCache struct {\n \tdisableCache bool // cache should be disabled for this run\n@@ -1127,10 +1273,10 @@ func (c *runCache) builderRunTest(b *work.Builder, ctx context.Context, a *work.\n \t}\n \n \tvar buf bytes.Buffer\n-\tif len(pkgArgs) == 0 || (testBench != \"\") {\n+\tif len(pkgArgs) == 0 || testBench != \"\" || testFuzz != \"\" {\n \t\t// Stream test output (no buffering) when no package has\n \t\t// been given on the command line (implicit current directory)\n-\t\t// or when benchmarking.\n+\t\t// or when benchmarking or fuzzing.\n \t\t// No change to stdout.\n \t} else {\n \t\t// If we're only running a single package under test or if parallelism is\n@@ -1183,7 +1329,12 @@ func (c *runCache) builderRunTest(b *work.Builder, ctx context.Context, a *work.\n \t\ttestlogArg = []string{\"-test.testlogfile=\" + a.Objdir + \"testlog.txt\"}\n \t}\n \tpanicArg := \"-test.paniconexit0\"\n-\targs := str.StringList(execCmd, a.Deps[0].BuiltTarget(), testlogArg, panicArg, testArgs)\n+\tfuzzArg := []string{}\n+\tif testFuzz != \"\" {\n+\t\tfuzzCacheDir := filepath.Join(cache.Default().FuzzDir(), a.Package.ImportPath)\n+\t\tfuzzArg = []string{\"-test.fuzzcachedir=\" + fuzzCacheDir}\n+\t}\n+\targs := str.StringList(execCmd, a.Deps[0].BuiltTarget(), testlogArg, panicArg, fuzzArg, testArgs)\n \n \tif testCoverProfile != \"\" {\n \t\t// Write coverage to temporary profile, for merging later.\n@@ -1276,15 +1427,31 @@ func (c *runCache) builderRunTest(b *work.Builder, ctx context.Context, a *work.\n \t\tif bytes.HasPrefix(out, noTestsToRun[1:]) || bytes.Contains(out, noTestsToRun) {\n \t\t\tnorun = \" [no tests to run]\"\n \t\t}\n+\t\tif bytes.HasPrefix(out, noFuzzTestsToFuzz[1:]) || bytes.Contains(out, noFuzzTestsToFuzz) {\n+\t\t\tnorun = \" [no fuzz tests to fuzz]\"\n+\t\t}\n+\t\tif bytes.HasPrefix(out, tooManyFuzzTestsToFuzz[1:]) || bytes.Contains(out, tooManyFuzzTestsToFuzz) {\n+\t\t\tnorun = \"[-fuzz matches more than one fuzz test, won't fuzz]\"\n+\t\t}\n+\t\tif len(out) > 0 && !bytes.HasSuffix(out, []byte(\"\\n\")) {\n+\t\t\t// Ensure that the output ends with a newline before the \"ok\"\n+\t\t\t// line we're about to print (https://golang.org/issue/49317).\n+\t\t\tcmd.Stdout.Write([]byte(\"\\n\"))\n+\t\t}\n \t\tfmt.Fprintf(cmd.Stdout, \"ok  \\t%s\\t%s%s%s\\n\", a.Package.ImportPath, t, coveragePercentage(out), norun)\n \t\tc.saveOutput(a)\n \t} else {\n \t\tbase.SetExitStatus(1)\n-\t\t// If there was test output, assume we don't need to print the exit status.\n-\t\t// Buf there's no test output, do print the exit status.\n \t\tif len(out) == 0 {\n+\t\t\t// If there was no test output, print the exit status so that the reason\n+\t\t\t// for failure is clear.\n \t\t\tfmt.Fprintf(cmd.Stdout, \"%s\\n\", err)\n+\t\t} else if !bytes.HasSuffix(out, []byte(\"\\n\")) {\n+\t\t\t// Otherwise, ensure that the output ends with a newline before the FAIL\n+\t\t\t// line we're about to print (https://golang.org/issue/49317).\n+\t\t\tcmd.Stdout.Write([]byte(\"\\n\"))\n \t\t}\n+\n \t\t// NOTE(golang.org/issue/37555): test2json reports that a test passes\n \t\t// unless \"FAIL\" is printed at the beginning of a line. The test may not\n \t\t// actually print that if it panics, exits, or terminates abnormally,\n@@ -1347,6 +1514,7 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \t\t\t\"-test.run\",\n \t\t\t\"-test.short\",\n \t\t\t\"-test.timeout\",\n+\t\t\t\"-test.failfast\",\n \t\t\t\"-test.v\":\n \t\t\t// These are cacheable.\n \t\t\t// Note that this list is documented above,\n@@ -1711,9 +1879,23 @@ func builderNoTest(b *work.Builder, ctx context.Context, a *work.Action) error {\n \treturn nil\n }\n \n-// printExitStatus is the action for printing the exit status\n+// printExitStatus is the action for printing the final exit status.\n+// If we are running multiple test targets, print a final \"FAIL\"\n+// in case a failure in an early package has already scrolled\n+// off of the user's terminal.\n+// (See https://golang.org/issue/30507#issuecomment-470593235.)\n+//\n+// In JSON mode, we need to maintain valid JSON output and\n+// we assume that the test output is being parsed by a tool\n+// anyway, so the failure will not be missed and would be\n+// awkward to try to wedge into the JSON stream.\n+//\n+// In fuzz mode, we only allow a single package for now\n+// (see CL 350156 and https://golang.org/issue/46312),\n+// so there is no possibility of scrolling off and no need\n+// to print the final status.\n func printExitStatus(b *work.Builder, ctx context.Context, a *work.Action) error {\n-\tif !testJSON && len(pkgArgs) != 0 {\n+\tif !testJSON && testFuzz == \"\" && len(pkgArgs) != 0 {\n \t\tif base.GetExitStatus() != 0 {\n \t\t\tfmt.Println(\"FAIL\")\n \t\t\treturn nil"}, {"sha": "b9d1ec91ff7552aba0e1667d96f16d55349931a5", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,6 +5,10 @@\n package test\n \n import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/cmdflag\"\n+\t\"cmd/go/internal/work\"\n \t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n@@ -13,11 +17,6 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n-\n-\t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/cmdflag\"\n-\t\"cmd/go/internal/work\"\n )\n \n //go:generate go run ./genflags.go\n@@ -29,6 +28,7 @@ import (\n \n func init() {\n \twork.AddBuildFlags(CmdTest, work.OmitVFlag)\n+\tbase.AddWorkfileFlag(&CmdTest.Flag)\n \n \tcf := CmdTest.Flag\n \tcf.BoolVar(&testC, \"c\", false, \"\")\n@@ -57,6 +57,7 @@ func init() {\n \tcf.String(\"cpu\", \"\", \"\")\n \tcf.StringVar(&testCPUProfile, \"cpuprofile\", \"\", \"\")\n \tcf.Bool(\"failfast\", false, \"\")\n+\tcf.StringVar(&testFuzz, \"fuzz\", \"\", \"\")\n \tcf.StringVar(&testList, \"list\", \"\", \"\")\n \tcf.StringVar(&testMemProfile, \"memprofile\", \"\", \"\")\n \tcf.String(\"memprofilerate\", \"\", \"\")\n@@ -67,6 +68,8 @@ func init() {\n \tcf.String(\"run\", \"\", \"\")\n \tcf.Bool(\"short\", false, \"\")\n \tcf.DurationVar(&testTimeout, \"timeout\", 10*time.Minute, \"\")\n+\tcf.String(\"fuzztime\", \"\", \"\")\n+\tcf.String(\"fuzzminimizetime\", \"\", \"\")\n \tcf.StringVar(&testTrace, \"trace\", \"\", \"\")\n \tcf.BoolVar(&testV, \"v\", false, \"\")\n \tcf.Var(&testShuffle, \"shuffle\", \"\")\n@@ -134,6 +137,7 @@ type outputdirFlag struct {\n func (f *outputdirFlag) String() string {\n \treturn f.abs\n }\n+\n func (f *outputdirFlag) Set(value string) (err error) {\n \tif value == \"\" {\n \t\tf.abs = \"\"\n@@ -142,6 +146,7 @@ func (f *outputdirFlag) Set(value string) (err error) {\n \t}\n \treturn err\n }\n+\n func (f *outputdirFlag) getAbs() string {\n \tif f.abs == \"\" {\n \t\treturn base.Cwd()\n@@ -150,16 +155,23 @@ func (f *outputdirFlag) getAbs() string {\n }\n \n // vetFlag implements the special parsing logic for the -vet flag:\n-// a comma-separated list, with a distinguished value \"off\" and\n-// a boolean tracking whether it was set explicitly.\n+// a comma-separated list, with distinguished values \"all\" and\n+// \"off\", plus a boolean tracking whether it was set explicitly.\n+//\n+// \"all\" is encoded as vetFlag{true, false, nil}, since it will\n+// pass no flags to the vet binary, and by default, it runs all\n+// analyzers.\n type vetFlag struct {\n \texplicit bool\n \toff      bool\n \tflags    []string // passed to vet when invoked automatically during 'go test'\n }\n \n func (f *vetFlag) String() string {\n-\tif f.off {\n+\tswitch {\n+\tcase !f.off && !f.explicit && len(f.flags) == 0:\n+\t\treturn \"all\"\n+\tcase f.off:\n \t\treturn \"off\"\n \t}\n \n@@ -174,31 +186,45 @@ func (f *vetFlag) String() string {\n }\n \n func (f *vetFlag) Set(value string) error {\n-\tif value == \"\" {\n+\tswitch {\n+\tcase value == \"\":\n \t\t*f = vetFlag{flags: defaultVetFlags}\n \t\treturn nil\n-\t}\n-\n-\tif value == \"off\" {\n-\t\t*f = vetFlag{\n-\t\t\texplicit: true,\n-\t\t\toff:      true,\n-\t\t}\n-\t\treturn nil\n-\t}\n-\n-\tif strings.Contains(value, \"=\") {\n+\tcase strings.Contains(value, \"=\"):\n \t\treturn fmt.Errorf(\"-vet argument cannot contain equal signs\")\n-\t}\n-\tif strings.Contains(value, \" \") {\n+\tcase strings.Contains(value, \" \"):\n \t\treturn fmt.Errorf(\"-vet argument is comma-separated list, cannot contain spaces\")\n \t}\n+\n \t*f = vetFlag{explicit: true}\n+\tvar single string\n \tfor _, arg := range strings.Split(value, \",\") {\n-\t\tif arg == \"\" {\n+\t\tswitch arg {\n+\t\tcase \"\":\n \t\t\treturn fmt.Errorf(\"-vet argument contains empty list element\")\n+\t\tcase \"all\":\n+\t\t\tsingle = arg\n+\t\t\t*f = vetFlag{explicit: true}\n+\t\t\tcontinue\n+\t\tcase \"off\":\n+\t\t\tsingle = arg\n+\t\t\t*f = vetFlag{\n+\t\t\t\texplicit: true,\n+\t\t\t\toff:      true,\n+\t\t\t}\n+\t\t\tcontinue\n+\t\tdefault:\n+\t\t\tif _, ok := passAnalyzersToVet[arg]; !ok {\n+\t\t\t\treturn fmt.Errorf(\"-vet argument must be a supported analyzer or a distinguished value; found %s\", arg)\n+\t\t\t}\n+\t\t\tf.flags = append(f.flags, \"-\"+arg)\n \t\t}\n-\t\tf.flags = append(f.flags, \"-\"+arg)\n+\t}\n+\tif len(f.flags) > 1 && single != \"\" {\n+\t\treturn fmt.Errorf(\"-vet does not accept %q in a list with other analyzers\", single)\n+\t}\n+\tif len(f.flags) > 1 && single != \"\" {\n+\t\treturn fmt.Errorf(\"-vet does not accept %q in a list with other analyzers\", single)\n \t}\n \treturn nil\n }\n@@ -369,7 +395,7 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\tif !testC {\n \t\t\tbuildFlag = \"-i\"\n \t\t}\n-\t\tfmt.Fprintf(os.Stderr, \"go test: unknown flag %s cannot be used with %s\\n\", firstUnknownFlag, buildFlag)\n+\t\tfmt.Fprintf(os.Stderr, \"go: unknown flag %s cannot be used with %s\\n\", firstUnknownFlag, buildFlag)\n \t\texitWithUsage()\n \t}\n "}, {"sha": "4fe4c2baeda1ff7dbe1a1360f9a1d6d8dd9cb5f4", "filename": "libgo/go/cmd/go/internal/tool/tool.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -61,7 +61,7 @@ func runTool(ctx context.Context, cmd *base.Command, args []string) {\n \t\tswitch {\n \t\tcase 'a' <= c && c <= 'z', '0' <= c && c <= '9', c == '_':\n \t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"go tool: bad tool name %q\\n\", toolName)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: bad tool name %q\\n\", toolName)\n \t\t\tbase.SetExitStatus(2)\n \t\t\treturn\n \t\t}\n@@ -117,14 +117,14 @@ func runTool(ctx context.Context, cmd *base.Command, args []string) {\n func listTools() {\n \tf, err := os.Open(base.ToolDir)\n \tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"go tool: no tool directory: %s\\n\", err)\n+\t\tfmt.Fprintf(os.Stderr, \"go: no tool directory: %s\\n\", err)\n \t\tbase.SetExitStatus(2)\n \t\treturn\n \t}\n \tdefer f.Close()\n \tnames, err := f.Readdirnames(-1)\n \tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"go tool: can't read directory: %s\\n\", err)\n+\t\tfmt.Fprintf(os.Stderr, \"go: can't read tool directory: %s\\n\", err)\n \t\tbase.SetExitStatus(2)\n \t\treturn\n \t}"}, {"sha": "3f734f6762531ec9e4444daa742572b45e1a0721", "filename": "libgo/go/cmd/go/internal/txtar/archive_test.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive_test.go?ref=9a56779dbc4e2d9c15be8d31e36f2f59be7331a8", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package txtar\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"reflect\"\n-\t\"testing\"\n-)\n-\n-var tests = []struct {\n-\tname   string\n-\ttext   string\n-\tparsed *Archive\n-}{\n-\t{\n-\t\tname: \"basic\",\n-\t\ttext: `comment1\n-comment2\n--- file1 --\n-File 1 text.\n--- foo ---\n-More file 1 text.\n--- file 2 --\n-File 2 text.\n--- empty --\n--- noNL --\n-hello world`,\n-\t\tparsed: &Archive{\n-\t\t\tComment: []byte(\"comment1\\ncomment2\\n\"),\n-\t\t\tFiles: []File{\n-\t\t\t\t{\"file1\", []byte(\"File 1 text.\\n-- foo ---\\nMore file 1 text.\\n\")},\n-\t\t\t\t{\"file 2\", []byte(\"File 2 text.\\n\")},\n-\t\t\t\t{\"empty\", []byte{}},\n-\t\t\t\t{\"noNL\", []byte(\"hello world\\n\")},\n-\t\t\t},\n-\t\t},\n-\t},\n-}\n-\n-func Test(t *testing.T) {\n-\tfor _, tt := range tests {\n-\t\tt.Run(tt.name, func(t *testing.T) {\n-\t\t\ta := Parse([]byte(tt.text))\n-\t\t\tif !reflect.DeepEqual(a, tt.parsed) {\n-\t\t\t\tt.Fatalf(\"Parse: wrong output:\\nhave:\\n%s\\nwant:\\n%s\", shortArchive(a), shortArchive(tt.parsed))\n-\t\t\t}\n-\t\t\ttext := Format(a)\n-\t\t\ta = Parse(text)\n-\t\t\tif !reflect.DeepEqual(a, tt.parsed) {\n-\t\t\t\tt.Fatalf(\"Parse after Format: wrong output:\\nhave:\\n%s\\nwant:\\n%s\", shortArchive(a), shortArchive(tt.parsed))\n-\t\t\t}\n-\t\t})\n-\t}\n-}\n-\n-func shortArchive(a *Archive) string {\n-\tvar buf bytes.Buffer\n-\tfmt.Fprintf(&buf, \"comment: %q\\n\", a.Comment)\n-\tfor _, f := range a.Files {\n-\t\tfmt.Fprintf(&buf, \"file %q: %q\\n\", f.Name, f.Data)\n-\t}\n-\treturn buf.String()\n-}"}, {"sha": "fd521b2eb1558f4fd7991b9de529d3f621db6702", "filename": "libgo/go/cmd/go/internal/vcs/vcs.go", "status": "modified", "additions": 298, "deletions": 96, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,7 +5,7 @@\n package vcs\n \n import (\n-\t\"encoding/json\"\n+\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \texec \"internal/execabs\"\n@@ -17,8 +17,10 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n+\t\"time\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -29,11 +31,12 @@ import (\n \t\"golang.org/x/mod/module\"\n )\n \n-// A vcsCmd describes how to use a version control system\n+// A Cmd describes how to use a version control system\n // like Mercurial, Git, or Subversion.\n type Cmd struct {\n-\tName string\n-\tCmd  string // name of binary to invoke command\n+\tName      string\n+\tCmd       string   // name of binary to invoke command\n+\tRootNames []string // filename indicating the root of a checkout directory\n \n \tCreateCmd   []string // commands to download a fresh copy of a repository\n \tDownloadCmd []string // commands to download updates into an existing repository\n@@ -48,6 +51,14 @@ type Cmd struct {\n \n \tRemoteRepo  func(v *Cmd, rootDir string) (remoteRepo string, err error)\n \tResolveRepo func(v *Cmd, rootDir, remoteRepo string) (realRepo string, err error)\n+\tStatus      func(v *Cmd, rootDir string) (Status, error)\n+}\n+\n+// Status is the current state of a local repository.\n+type Status struct {\n+\tRevision    string    // Optional.\n+\tCommitTime  time.Time // Optional.\n+\tUncommitted bool      // Required.\n }\n \n var defaultSecureScheme = map[string]bool{\n@@ -118,8 +129,9 @@ func vcsByCmd(cmd string) *Cmd {\n \n // vcsHg describes how to use Mercurial.\n var vcsHg = &Cmd{\n-\tName: \"Mercurial\",\n-\tCmd:  \"hg\",\n+\tName:      \"Mercurial\",\n+\tCmd:       \"hg\",\n+\tRootNames: []string{\".hg\"},\n \n \tCreateCmd:   []string{\"clone -U -- {repo} {dir}\"},\n \tDownloadCmd: []string{\"pull\"},\n@@ -139,6 +151,7 @@ var vcsHg = &Cmd{\n \tScheme:     []string{\"https\", \"http\", \"ssh\"},\n \tPingCmd:    \"identify -- {scheme}://{repo}\",\n \tRemoteRepo: hgRemoteRepo,\n+\tStatus:     hgStatus,\n }\n \n func hgRemoteRepo(vcsHg *Cmd, rootDir string) (remoteRepo string, err error) {\n@@ -149,10 +162,64 @@ func hgRemoteRepo(vcsHg *Cmd, rootDir string) (remoteRepo string, err error) {\n \treturn strings.TrimSpace(string(out)), nil\n }\n \n+func hgStatus(vcsHg *Cmd, rootDir string) (Status, error) {\n+\t// Output changeset ID and seconds since epoch.\n+\tout, err := vcsHg.runOutputVerboseOnly(rootDir, `log -l1 -T {node}:{date|hgdate}`)\n+\tif err != nil {\n+\t\treturn Status{}, err\n+\t}\n+\n+\t// Successful execution without output indicates an empty repo (no commits).\n+\tvar rev string\n+\tvar commitTime time.Time\n+\tif len(out) > 0 {\n+\t\t// Strip trailing timezone offset.\n+\t\tif i := bytes.IndexByte(out, ' '); i > 0 {\n+\t\t\tout = out[:i]\n+\t\t}\n+\t\trev, commitTime, err = parseRevTime(out)\n+\t\tif err != nil {\n+\t\t\treturn Status{}, err\n+\t\t}\n+\t}\n+\n+\t// Also look for untracked files.\n+\tout, err = vcsHg.runOutputVerboseOnly(rootDir, \"status\")\n+\tif err != nil {\n+\t\treturn Status{}, err\n+\t}\n+\tuncommitted := len(out) > 0\n+\n+\treturn Status{\n+\t\tRevision:    rev,\n+\t\tCommitTime:  commitTime,\n+\t\tUncommitted: uncommitted,\n+\t}, nil\n+}\n+\n+// parseRevTime parses commit details in \"revision:seconds\" format.\n+func parseRevTime(out []byte) (string, time.Time, error) {\n+\tbuf := string(bytes.TrimSpace(out))\n+\n+\ti := strings.IndexByte(buf, ':')\n+\tif i < 1 {\n+\t\treturn \"\", time.Time{}, errors.New(\"unrecognized VCS tool output\")\n+\t}\n+\trev := buf[:i]\n+\n+\tsecs, err := strconv.ParseInt(string(buf[i+1:]), 10, 64)\n+\tif err != nil {\n+\t\treturn \"\", time.Time{}, fmt.Errorf(\"unrecognized VCS tool output: %v\", err)\n+\t}\n+\n+\treturn rev, time.Unix(secs, 0), nil\n+}\n+\n // vcsGit describes how to use Git.\n var vcsGit = &Cmd{\n-\tName: \"Git\",\n-\tCmd:  \"git\",\n+\tName:      \"Git\",\n+\tCmd:       \"git\",\n+\tRootNames: []string{\".git\"},\n \n \tCreateCmd:   []string{\"clone -- {repo} {dir}\", \"-go-internal-cd {dir} submodule update --init --recursive\"},\n \tDownloadCmd: []string{\"pull --ff-only\", \"submodule update --init --recursive\"},\n@@ -182,6 +249,7 @@ var vcsGit = &Cmd{\n \tPingCmd: \"ls-remote {scheme}://{repo}\",\n \n \tRemoteRepo: gitRemoteRepo,\n+\tStatus:     gitStatus,\n }\n \n // scpSyntaxRe matches the SCP-like addresses used by Git to access\n@@ -232,10 +300,40 @@ func gitRemoteRepo(vcsGit *Cmd, rootDir string) (remoteRepo string, err error) {\n \treturn \"\", errParse\n }\n \n+func gitStatus(vcsGit *Cmd, rootDir string) (Status, error) {\n+\tout, err := vcsGit.runOutputVerboseOnly(rootDir, \"status --porcelain\")\n+\tif err != nil {\n+\t\treturn Status{}, err\n+\t}\n+\tuncommitted := len(out) > 0\n+\n+\t// \"git status\" works for empty repositories, but \"git show\" does not.\n+\t// Assume there are no commits in the repo when \"git show\" fails with\n+\t// uncommitted files and skip tagging revision / committime.\n+\tvar rev string\n+\tvar commitTime time.Time\n+\tout, err = vcsGit.runOutputVerboseOnly(rootDir, \"show -s --no-show-signature --format=%H:%ct\")\n+\tif err != nil && !uncommitted {\n+\t\treturn Status{}, err\n+\t} else if err == nil {\n+\t\trev, commitTime, err = parseRevTime(out)\n+\t\tif err != nil {\n+\t\t\treturn Status{}, err\n+\t\t}\n+\t}\n+\n+\treturn Status{\n+\t\tRevision:    rev,\n+\t\tCommitTime:  commitTime,\n+\t\tUncommitted: uncommitted,\n+\t}, nil\n+}\n+\n // vcsBzr describes how to use Bazaar.\n var vcsBzr = &Cmd{\n-\tName: \"Bazaar\",\n-\tCmd:  \"bzr\",\n+\tName:      \"Bazaar\",\n+\tCmd:       \"bzr\",\n+\tRootNames: []string{\".bzr\"},\n \n \tCreateCmd: []string{\"branch -- {repo} {dir}\"},\n \n@@ -251,6 +349,7 @@ var vcsBzr = &Cmd{\n \tPingCmd:     \"info -- {scheme}://{repo}\",\n \tRemoteRepo:  bzrRemoteRepo,\n \tResolveRepo: bzrResolveRepo,\n+\tStatus:      bzrStatus,\n }\n \n func bzrRemoteRepo(vcsBzr *Cmd, rootDir string) (remoteRepo string, err error) {\n@@ -294,10 +393,68 @@ func bzrResolveRepo(vcsBzr *Cmd, rootDir, remoteRepo string) (realRepo string, e\n \treturn strings.TrimSpace(out), nil\n }\n \n+func bzrStatus(vcsBzr *Cmd, rootDir string) (Status, error) {\n+\toutb, err := vcsBzr.runOutputVerboseOnly(rootDir, \"version-info\")\n+\tif err != nil {\n+\t\treturn Status{}, err\n+\t}\n+\tout := string(outb)\n+\n+\t// Expect (non-empty repositories only):\n+\t//\n+\t// revision-id: gopher@gopher.net-20211021072330-qshok76wfypw9lpm\n+\t// date: 2021-09-21 12:00:00 +1000\n+\t// ...\n+\tvar rev string\n+\tvar commitTime time.Time\n+\n+\tfor _, line := range strings.Split(out, \"\\n\") {\n+\t\ti := strings.IndexByte(line, ':')\n+\t\tif i < 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tkey := line[:i]\n+\t\tvalue := strings.TrimSpace(line[i+1:])\n+\n+\t\tswitch key {\n+\t\tcase \"revision-id\":\n+\t\t\trev = value\n+\t\tcase \"date\":\n+\t\t\tvar err error\n+\t\t\tcommitTime, err = time.Parse(\"2006-01-02 15:04:05 -0700\", value)\n+\t\t\tif err != nil {\n+\t\t\t\treturn Status{}, errors.New(\"unable to parse output of bzr version-info\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\toutb, err = vcsBzr.runOutputVerboseOnly(rootDir, \"status\")\n+\tif err != nil {\n+\t\treturn Status{}, err\n+\t}\n+\n+\t// Skip warning when working directory is set to an older revision.\n+\tif bytes.HasPrefix(outb, []byte(\"working tree is out of date\")) {\n+\t\ti := bytes.IndexByte(outb, '\\n')\n+\t\tif i < 0 {\n+\t\t\ti = len(outb)\n+\t\t}\n+\t\toutb = outb[:i]\n+\t}\n+\tuncommitted := len(outb) > 0\n+\n+\treturn Status{\n+\t\tRevision:    rev,\n+\t\tCommitTime:  commitTime,\n+\t\tUncommitted: uncommitted,\n+\t}, nil\n+}\n+\n // vcsSvn describes how to use Subversion.\n var vcsSvn = &Cmd{\n-\tName: \"Subversion\",\n-\tCmd:  \"svn\",\n+\tName:      \"Subversion\",\n+\tCmd:       \"svn\",\n+\tRootNames: []string{\".svn\"},\n \n \tCreateCmd:   []string{\"checkout -- {repo} {dir}\"},\n \tDownloadCmd: []string{\"update\"},\n@@ -346,8 +503,9 @@ const fossilRepoName = \".fossil\"\n \n // vcsFossil describes how to use Fossil (fossil-scm.org)\n var vcsFossil = &Cmd{\n-\tName: \"Fossil\",\n-\tCmd:  \"fossil\",\n+\tName:      \"Fossil\",\n+\tCmd:       \"fossil\",\n+\tRootNames: []string{\".fslckout\", \"_FOSSIL_\"},\n \n \tCreateCmd:   []string{\"-go-internal-mkdir {dir} clone -- {repo} \" + filepath.Join(\"{dir}\", fossilRepoName), \"-go-internal-cd {dir} open .fossil\"},\n \tDownloadCmd: []string{\"up\"},\n@@ -358,6 +516,7 @@ var vcsFossil = &Cmd{\n \n \tScheme:     []string{\"https\", \"http\"},\n \tRemoteRepo: fossilRemoteRepo,\n+\tStatus:     fossilStatus,\n }\n \n func fossilRemoteRepo(vcsFossil *Cmd, rootDir string) (remoteRepo string, err error) {\n@@ -368,6 +527,60 @@ func fossilRemoteRepo(vcsFossil *Cmd, rootDir string) (remoteRepo string, err er\n \treturn strings.TrimSpace(string(out)), nil\n }\n \n+var errFossilInfo = errors.New(\"unable to parse output of fossil info\")\n+\n+func fossilStatus(vcsFossil *Cmd, rootDir string) (Status, error) {\n+\toutb, err := vcsFossil.runOutputVerboseOnly(rootDir, \"info\")\n+\tif err != nil {\n+\t\treturn Status{}, err\n+\t}\n+\tout := string(outb)\n+\n+\t// Expect:\n+\t// ...\n+\t// checkout:     91ed71f22c77be0c3e250920f47bfd4e1f9024d2 2021-09-21 12:00:00 UTC\n+\t// ...\n+\n+\t// Extract revision and commit time.\n+\t// Ensure line ends with UTC (known timezone offset).\n+\tconst prefix = \"\\ncheckout:\"\n+\tconst suffix = \" UTC\"\n+\ti := strings.Index(out, prefix)\n+\tif i < 0 {\n+\t\treturn Status{}, errFossilInfo\n+\t}\n+\tcheckout := out[i+len(prefix):]\n+\ti = strings.Index(checkout, suffix)\n+\tif i < 0 {\n+\t\treturn Status{}, errFossilInfo\n+\t}\n+\tcheckout = strings.TrimSpace(checkout[:i])\n+\n+\ti = strings.IndexByte(checkout, ' ')\n+\tif i < 0 {\n+\t\treturn Status{}, errFossilInfo\n+\t}\n+\trev := checkout[:i]\n+\n+\tcommitTime, err := time.ParseInLocation(\"2006-01-02 15:04:05\", checkout[i+1:], time.UTC)\n+\tif err != nil {\n+\t\treturn Status{}, fmt.Errorf(\"%v: %v\", errFossilInfo, err)\n+\t}\n+\n+\t// Also look for untracked changes.\n+\toutb, err = vcsFossil.runOutputVerboseOnly(rootDir, \"changes --differ\")\n+\tif err != nil {\n+\t\treturn Status{}, err\n+\t}\n+\tuncommitted := len(outb) > 0\n+\n+\treturn Status{\n+\t\tRevision:    rev,\n+\t\tCommitTime:  commitTime,\n+\t\tUncommitted: uncommitted,\n+\t}, nil\n+}\n+\n func (v *Cmd) String() string {\n \treturn v.Name\n }\n@@ -395,6 +608,12 @@ func (v *Cmd) runOutput(dir string, cmd string, keyval ...string) ([]byte, error\n \treturn v.run1(dir, cmd, keyval, true)\n }\n \n+// runOutputVerboseOnly is like runOutput but only generates error output to\n+// standard error in verbose mode.\n+func (v *Cmd) runOutputVerboseOnly(dir string, cmd string, keyval ...string) ([]byte, error) {\n+\treturn v.run1(dir, cmd, keyval, false)\n+}\n+\n // run1 is the generalized implementation of run and runOutput.\n func (v *Cmd) run1(dir string, cmdline string, keyval []string, verbose bool) ([]byte, error) {\n \tm := make(map[string]string)\n@@ -550,58 +769,86 @@ type vcsPath struct {\n \n // FromDir inspects dir and its parents to determine the\n // version control system and code repository to use.\n-// On return, root is the import path\n-// corresponding to the root of the repository.\n-func FromDir(dir, srcRoot string) (vcs *Cmd, root string, err error) {\n+// If no repository is found, FromDir returns an error\n+// equivalent to os.ErrNotExist.\n+func FromDir(dir, srcRoot string, allowNesting bool) (repoDir string, vcsCmd *Cmd, err error) {\n \t// Clean and double-check that dir is in (a subdirectory of) srcRoot.\n \tdir = filepath.Clean(dir)\n-\tsrcRoot = filepath.Clean(srcRoot)\n-\tif len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {\n-\t\treturn nil, \"\", fmt.Errorf(\"directory %q is outside source root %q\", dir, srcRoot)\n+\tif srcRoot != \"\" {\n+\t\tsrcRoot = filepath.Clean(srcRoot)\n+\t\tif len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {\n+\t\t\treturn \"\", nil, fmt.Errorf(\"directory %q is outside source root %q\", dir, srcRoot)\n+\t\t}\n \t}\n \n-\tvar vcsRet *Cmd\n-\tvar rootRet string\n-\n \torigDir := dir\n \tfor len(dir) > len(srcRoot) {\n \t\tfor _, vcs := range vcsList {\n-\t\t\tif _, err := os.Stat(filepath.Join(dir, \".\"+vcs.Cmd)); err == nil {\n-\t\t\t\troot := filepath.ToSlash(dir[len(srcRoot)+1:])\n-\t\t\t\t// Record first VCS we find, but keep looking,\n-\t\t\t\t// to detect mistakes like one kind of VCS inside another.\n-\t\t\t\tif vcsRet == nil {\n-\t\t\t\t\tvcsRet = vcs\n-\t\t\t\t\trootRet = root\n+\t\t\tif _, err := statAny(dir, vcs.RootNames); err == nil {\n+\t\t\t\t// Record first VCS we find.\n+\t\t\t\t// If allowNesting is false (as it is in GOPATH), keep looking for\n+\t\t\t\t// repositories in parent directories and report an error if one is\n+\t\t\t\t// found to mitigate VCS injection attacks.\n+\t\t\t\tif vcsCmd == nil {\n+\t\t\t\t\tvcsCmd = vcs\n+\t\t\t\t\trepoDir = dir\n+\t\t\t\t\tif allowNesting {\n+\t\t\t\t\t\treturn repoDir, vcsCmd, nil\n+\t\t\t\t\t}\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\t// Allow .git inside .git, which can arise due to submodules.\n-\t\t\t\tif vcsRet == vcs && vcs.Cmd == \"git\" {\n+\t\t\t\tif vcsCmd == vcs && vcs.Cmd == \"git\" {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\t// Otherwise, we have one VCS inside a different VCS.\n-\t\t\t\treturn nil, \"\", fmt.Errorf(\"directory %q uses %s, but parent %q uses %s\",\n-\t\t\t\t\tfilepath.Join(srcRoot, rootRet), vcsRet.Cmd, filepath.Join(srcRoot, root), vcs.Cmd)\n+\t\t\t\treturn \"\", nil, fmt.Errorf(\"directory %q uses %s, but parent %q uses %s\",\n+\t\t\t\t\trepoDir, vcsCmd.Cmd, dir, vcs.Cmd)\n \t\t\t}\n \t\t}\n \n \t\t// Move to parent.\n \t\tndir := filepath.Dir(dir)\n \t\tif len(ndir) >= len(dir) {\n-\t\t\t// Shouldn't happen, but just in case, stop.\n \t\t\tbreak\n \t\t}\n \t\tdir = ndir\n \t}\n+\tif vcsCmd == nil {\n+\t\treturn \"\", nil, &vcsNotFoundError{dir: origDir}\n+\t}\n+\treturn repoDir, vcsCmd, nil\n+}\n \n-\tif vcsRet != nil {\n-\t\tif err := checkGOVCS(vcsRet, rootRet); err != nil {\n-\t\t\treturn nil, \"\", err\n+// statAny provides FileInfo for the first filename found in the directory.\n+// Otherwise, it returns the last error seen.\n+func statAny(dir string, filenames []string) (os.FileInfo, error) {\n+\tif len(filenames) == 0 {\n+\t\treturn nil, errors.New(\"invalid argument: no filenames provided\")\n+\t}\n+\n+\tvar err error\n+\tvar fi os.FileInfo\n+\tfor _, name := range filenames {\n+\t\tfi, err = os.Stat(filepath.Join(dir, name))\n+\t\tif err == nil {\n+\t\t\treturn fi, nil\n \t\t}\n-\t\treturn vcsRet, rootRet, nil\n \t}\n \n-\treturn nil, \"\", fmt.Errorf(\"directory %q is not using a known version control system\", origDir)\n+\treturn nil, err\n+}\n+\n+type vcsNotFoundError struct {\n+\tdir string\n+}\n+\n+func (e *vcsNotFoundError) Error() string {\n+\treturn fmt.Sprintf(\"directory %q is not using a known version control system\", e.dir)\n+}\n+\n+func (e *vcsNotFoundError) Is(err error) bool {\n+\treturn err == os.ErrNotExist\n }\n \n // A govcsRule is a single GOVCS rule like private:hg|svn.\n@@ -707,7 +954,11 @@ var defaultGOVCS = govcsConfig{\n \t{\"public\", []string{\"git\", \"hg\"}},\n }\n \n-func checkGOVCS(vcs *Cmd, root string) error {\n+// CheckGOVCS checks whether the policy defined by the environment variable\n+// GOVCS allows the given vcs command to be used with the given repository\n+// root path. Note that root may not be a real package or module path; it's\n+// the same as the root path in the go-import meta tag.\n+func CheckGOVCS(vcs *Cmd, root string) error {\n \tif vcs == vcsMod {\n \t\t// Direct module (proxy protocol) fetches don't\n \t\t// involve an external version control system\n@@ -745,7 +996,7 @@ func CheckNested(vcs *Cmd, dir, srcRoot string) error {\n \totherDir := dir\n \tfor len(otherDir) > len(srcRoot) {\n \t\tfor _, otherVCS := range vcsList {\n-\t\t\tif _, err := os.Stat(filepath.Join(otherDir, \".\"+otherVCS.Cmd)); err == nil {\n+\t\t\tif _, err := statAny(otherDir, otherVCS.RootNames); err == nil {\n \t\t\t\t// Allow expected vcs in original dir.\n \t\t\t\tif otherDir == dir && otherVCS == vcs {\n \t\t\t\t\tcontinue\n@@ -885,7 +1136,7 @@ func repoRootFromVCSPaths(importPath string, security web.SecurityMode, vcsPaths\n \t\tif vcs == nil {\n \t\t\treturn nil, fmt.Errorf(\"unknown version control system %q\", match[\"vcs\"])\n \t\t}\n-\t\tif err := checkGOVCS(vcs, match[\"root\"]); err != nil {\n+\t\tif err := CheckGOVCS(vcs, match[\"root\"]); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\tvar repoURL string\n@@ -1012,7 +1263,7 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se\n \t\t}\n \t}\n \n-\tif err := checkGOVCS(vcs, mmi.Prefix); err != nil {\n+\tif err := CheckGOVCS(vcs, mmi.Prefix); err != nil {\n \t\treturn nil, err\n \t}\n \n@@ -1063,7 +1314,7 @@ func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.Secu\n \t\treturn res, nil\n \t}\n \n-\tresi, _, _ := fetchGroup.Do(importPrefix, func() (resi interface{}, err error) {\n+\tresi, _, _ := fetchGroup.Do(importPrefix, func() (resi any, err error) {\n \t\tfetchCacheMu.Lock()\n \t\tif res, ok := fetchCache[importPrefix]; ok {\n \t\t\tfetchCacheMu.Unlock()\n@@ -1189,8 +1440,9 @@ var vcsPaths = []*vcsPath{\n \t{\n \t\tpathPrefix: \"bitbucket.org\",\n \t\tregexp:     lazyregexp.New(`^(?P<root>bitbucket\\.org/(?P<bitname>[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`),\n+\t\tvcs:        \"git\",\n \t\trepo:       \"https://{root}\",\n-\t\tcheck:      bitbucketVCS,\n+\t\tcheck:      noVCSSuffix,\n \t},\n \n \t// IBM DevOps Services (JazzHub)\n@@ -1262,56 +1514,6 @@ func noVCSSuffix(match map[string]string) error {\n \treturn nil\n }\n \n-// bitbucketVCS determines the version control system for a\n-// Bitbucket repository, by using the Bitbucket API.\n-func bitbucketVCS(match map[string]string) error {\n-\tif err := noVCSSuffix(match); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tvar resp struct {\n-\t\tSCM string `json:\"scm\"`\n-\t}\n-\turl := &urlpkg.URL{\n-\t\tScheme:   \"https\",\n-\t\tHost:     \"api.bitbucket.org\",\n-\t\tPath:     expand(match, \"/2.0/repositories/{bitname}\"),\n-\t\tRawQuery: \"fields=scm\",\n-\t}\n-\tdata, err := web.GetBytes(url)\n-\tif err != nil {\n-\t\tif httpErr, ok := err.(*web.HTTPError); ok && httpErr.StatusCode == 403 {\n-\t\t\t// this may be a private repository. If so, attempt to determine which\n-\t\t\t// VCS it uses. See issue 5375.\n-\t\t\troot := match[\"root\"]\n-\t\t\tfor _, vcs := range []string{\"git\", \"hg\"} {\n-\t\t\t\tif vcsByCmd(vcs).Ping(\"https\", root) == nil {\n-\t\t\t\t\tresp.SCM = vcs\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif resp.SCM == \"\" {\n-\t\t\treturn err\n-\t\t}\n-\t} else {\n-\t\tif err := json.Unmarshal(data, &resp); err != nil {\n-\t\t\treturn fmt.Errorf(\"decoding %s: %v\", url, err)\n-\t\t}\n-\t}\n-\n-\tif vcsByCmd(resp.SCM) != nil {\n-\t\tmatch[\"vcs\"] = resp.SCM\n-\t\tif resp.SCM == \"git\" {\n-\t\t\tmatch[\"repo\"] += \".git\"\n-\t\t}\n-\t\treturn nil\n-\t}\n-\n-\treturn fmt.Errorf(\"unable to detect version control system for bitbucket.org/ path\")\n-}\n-\n // launchpadVCS solves the ambiguity for \"lp.net/project/foo\". In this case,\n // \"foo\" could be a series name registered in Launchpad with its own branch,\n // and it could also be the name of a directory within the main project\n@@ -1340,7 +1542,7 @@ type importError struct {\n \terr        error\n }\n \n-func importErrorf(path, format string, args ...interface{}) error {\n+func importErrorf(path, format string, args ...any) error {\n \terr := &importError{importPath: path, err: fmt.Errorf(format, args...)}\n \tif errStr := err.Error(); !strings.Contains(errStr, path) {\n \t\tpanic(fmt.Sprintf(\"path %q not in error %q\", path, errStr))"}, {"sha": "943d520d547461118ab78ef26364c141bd2be005", "filename": "libgo/go/cmd/go/internal/vcs/vcs_test.go", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -6,9 +6,9 @@ package vcs\n \n import (\n \t\"errors\"\n+\t\"fmt\"\n \t\"internal/testenv\"\n \t\"os\"\n-\t\"path\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n@@ -183,6 +183,13 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t\t\"chiselapp.com/user/kyle/fossilgg\",\n \t\t\tnil,\n \t\t},\n+\t\t{\n+\t\t\t\"bitbucket.org/workspace/pkgname\",\n+\t\t\t&RepoRoot{\n+\t\t\t\tVCS:  vcsGit,\n+\t\t\t\tRepo: \"https://bitbucket.org/workspace/pkgname\",\n+\t\t\t},\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n@@ -205,7 +212,8 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t}\n }\n \n-// Test that vcsFromDir correctly inspects a given directory and returns the right VCS and root.\n+// Test that vcs.FromDir correctly inspects a given directory and returns the\n+// right VCS and repo directory.\n func TestFromDir(t *testing.T) {\n \ttempDir, err := os.MkdirTemp(\"\", \"vcstest\")\n \tif err != nil {\n@@ -214,36 +222,35 @@ func TestFromDir(t *testing.T) {\n \tdefer os.RemoveAll(tempDir)\n \n \tfor j, vcs := range vcsList {\n-\t\tdir := filepath.Join(tempDir, \"example.com\", vcs.Name, \".\"+vcs.Cmd)\n-\t\tif j&1 == 0 {\n-\t\t\terr := os.MkdirAll(dir, 0755)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n+\t\tfor r, rootName := range vcs.RootNames {\n+\t\t\tvcsName := fmt.Sprint(vcs.Name, r)\n+\t\t\tdir := filepath.Join(tempDir, \"example.com\", vcsName, rootName)\n+\t\t\tif j&1 == 0 {\n+\t\t\t\terr := os.MkdirAll(dir, 0755)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\terr := os.MkdirAll(filepath.Dir(dir), 0755)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\tf, err := os.Create(dir)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\tf.Close()\n \t\t\t}\n-\t\t} else {\n-\t\t\terr := os.MkdirAll(filepath.Dir(dir), 0755)\n+\n+\t\t\twantRepoDir := filepath.Dir(dir)\n+\t\t\tgotRepoDir, gotVCS, err := FromDir(dir, tempDir, false)\n \t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n+\t\t\t\tt.Errorf(\"FromDir(%q, %q): %v\", dir, tempDir, err)\n+\t\t\t\tcontinue\n \t\t\t}\n-\t\t\tf, err := os.Create(dir)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n+\t\t\tif gotRepoDir != wantRepoDir || gotVCS.Name != vcs.Name {\n+\t\t\t\tt.Errorf(\"FromDir(%q, %q) = RepoDir(%s), VCS(%s); want RepoDir(%s), VCS(%s)\", dir, tempDir, gotRepoDir, gotVCS.Name, wantRepoDir, vcs.Name)\n \t\t\t}\n-\t\t\tf.Close()\n-\t\t}\n-\n-\t\twant := RepoRoot{\n-\t\t\tVCS:  vcs,\n-\t\t\tRoot: path.Join(\"example.com\", vcs.Name),\n-\t\t}\n-\t\tvar got RepoRoot\n-\t\tgot.VCS, got.Root, err = FromDir(dir, tempDir)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"FromDir(%q, %q): %v\", dir, tempDir, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif got.VCS.Name != want.VCS.Name || got.Root != want.Root {\n-\t\t\tt.Errorf(\"FromDir(%q, %q) = VCS(%s) Root(%s), want VCS(%s) Root(%s)\", dir, tempDir, got.VCS, got.Root, want.VCS, want.Root)\n \t\t}\n \t}\n }"}, {"sha": "0e7deef1491a9c4d022ff0ff6b86341d4a7b0cb4", "filename": "libgo/go/cmd/go/internal/version/exe.go", "status": "removed", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go?ref=9a56779dbc4e2d9c15be8d31e36f2f59be7331a8", "patch": "@@ -1,263 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package version\n-\n-import (\n-\t\"bytes\"\n-\t\"debug/elf\"\n-\t\"debug/macho\"\n-\t\"debug/pe\"\n-\t\"fmt\"\n-\t\"internal/xcoff\"\n-\t\"io\"\n-\t\"os\"\n-)\n-\n-// An exe is a generic interface to an OS executable (ELF, Mach-O, PE, XCOFF).\n-type exe interface {\n-\t// Close closes the underlying file.\n-\tClose() error\n-\n-\t// ReadData reads and returns up to size byte starting at virtual address addr.\n-\tReadData(addr, size uint64) ([]byte, error)\n-\n-\t// DataStart returns the writable data segment start address.\n-\tDataStart() uint64\n-}\n-\n-// openExe opens file and returns it as an exe.\n-func openExe(file string) (exe, error) {\n-\tf, err := os.Open(file)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdata := make([]byte, 16)\n-\tif _, err := io.ReadFull(f, data); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tf.Seek(0, 0)\n-\tif bytes.HasPrefix(data, []byte(\"\\x7FELF\")) {\n-\t\te, err := elf.NewFile(f)\n-\t\tif err != nil {\n-\t\t\tf.Close()\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn &elfExe{f, e}, nil\n-\t}\n-\tif bytes.HasPrefix(data, []byte(\"MZ\")) {\n-\t\te, err := pe.NewFile(f)\n-\t\tif err != nil {\n-\t\t\tf.Close()\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn &peExe{f, e}, nil\n-\t}\n-\tif bytes.HasPrefix(data, []byte(\"\\xFE\\xED\\xFA\")) || bytes.HasPrefix(data[1:], []byte(\"\\xFA\\xED\\xFE\")) {\n-\t\te, err := macho.NewFile(f)\n-\t\tif err != nil {\n-\t\t\tf.Close()\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn &machoExe{f, e}, nil\n-\t}\n-\tif bytes.HasPrefix(data, []byte{0x01, 0xDF}) || bytes.HasPrefix(data, []byte{0x01, 0xF7}) {\n-\t\te, err := xcoff.NewFile(f)\n-\t\tif err != nil {\n-\t\t\tf.Close()\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn &xcoffExe{f, e}, nil\n-\n-\t}\n-\treturn nil, fmt.Errorf(\"unrecognized executable format\")\n-}\n-\n-// elfExe is the ELF implementation of the exe interface.\n-type elfExe struct {\n-\tos *os.File\n-\tf  *elf.File\n-}\n-\n-func (x *elfExe) Close() error {\n-\treturn x.os.Close()\n-}\n-\n-func (x *elfExe) ReadData(addr, size uint64) ([]byte, error) {\n-\tfor _, prog := range x.f.Progs {\n-\t\tif prog.Vaddr <= addr && addr <= prog.Vaddr+prog.Filesz-1 {\n-\t\t\tn := prog.Vaddr + prog.Filesz - addr\n-\t\t\tif n > size {\n-\t\t\t\tn = size\n-\t\t\t}\n-\t\t\tdata := make([]byte, n)\n-\t\t\t_, err := prog.ReadAt(data, int64(addr-prog.Vaddr))\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\treturn data, nil\n-\t\t}\n-\t}\n-\treturn nil, fmt.Errorf(\"address not mapped\")\n-}\n-\n-func (x *elfExe) DataStart() uint64 {\n-\tfor _, s := range x.f.Sections {\n-\t\tif s.Name == \".go.buildinfo\" {\n-\t\t\treturn s.Addr\n-\t\t}\n-\t}\n-\tfor _, p := range x.f.Progs {\n-\t\tif p.Type == elf.PT_LOAD && p.Flags&(elf.PF_X|elf.PF_W) == elf.PF_W {\n-\t\t\treturn p.Vaddr\n-\t\t}\n-\t}\n-\treturn 0\n-}\n-\n-// peExe is the PE (Windows Portable Executable) implementation of the exe interface.\n-type peExe struct {\n-\tos *os.File\n-\tf  *pe.File\n-}\n-\n-func (x *peExe) Close() error {\n-\treturn x.os.Close()\n-}\n-\n-func (x *peExe) imageBase() uint64 {\n-\tswitch oh := x.f.OptionalHeader.(type) {\n-\tcase *pe.OptionalHeader32:\n-\t\treturn uint64(oh.ImageBase)\n-\tcase *pe.OptionalHeader64:\n-\t\treturn oh.ImageBase\n-\t}\n-\treturn 0\n-}\n-\n-func (x *peExe) ReadData(addr, size uint64) ([]byte, error) {\n-\taddr -= x.imageBase()\n-\tfor _, sect := range x.f.Sections {\n-\t\tif uint64(sect.VirtualAddress) <= addr && addr <= uint64(sect.VirtualAddress+sect.Size-1) {\n-\t\t\tn := uint64(sect.VirtualAddress+sect.Size) - addr\n-\t\t\tif n > size {\n-\t\t\t\tn = size\n-\t\t\t}\n-\t\t\tdata := make([]byte, n)\n-\t\t\t_, err := sect.ReadAt(data, int64(addr-uint64(sect.VirtualAddress)))\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\treturn data, nil\n-\t\t}\n-\t}\n-\treturn nil, fmt.Errorf(\"address not mapped\")\n-}\n-\n-func (x *peExe) DataStart() uint64 {\n-\t// Assume data is first writable section.\n-\tconst (\n-\t\tIMAGE_SCN_CNT_CODE               = 0x00000020\n-\t\tIMAGE_SCN_CNT_INITIALIZED_DATA   = 0x00000040\n-\t\tIMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080\n-\t\tIMAGE_SCN_MEM_EXECUTE            = 0x20000000\n-\t\tIMAGE_SCN_MEM_READ               = 0x40000000\n-\t\tIMAGE_SCN_MEM_WRITE              = 0x80000000\n-\t\tIMAGE_SCN_MEM_DISCARDABLE        = 0x2000000\n-\t\tIMAGE_SCN_LNK_NRELOC_OVFL        = 0x1000000\n-\t\tIMAGE_SCN_ALIGN_32BYTES          = 0x600000\n-\t)\n-\tfor _, sect := range x.f.Sections {\n-\t\tif sect.VirtualAddress != 0 && sect.Size != 0 &&\n-\t\t\tsect.Characteristics&^IMAGE_SCN_ALIGN_32BYTES == IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_MEM_READ|IMAGE_SCN_MEM_WRITE {\n-\t\t\treturn uint64(sect.VirtualAddress) + x.imageBase()\n-\t\t}\n-\t}\n-\treturn 0\n-}\n-\n-// machoExe is the Mach-O (Apple macOS/iOS) implementation of the exe interface.\n-type machoExe struct {\n-\tos *os.File\n-\tf  *macho.File\n-}\n-\n-func (x *machoExe) Close() error {\n-\treturn x.os.Close()\n-}\n-\n-func (x *machoExe) ReadData(addr, size uint64) ([]byte, error) {\n-\tfor _, load := range x.f.Loads {\n-\t\tseg, ok := load.(*macho.Segment)\n-\t\tif !ok {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif seg.Addr <= addr && addr <= seg.Addr+seg.Filesz-1 {\n-\t\t\tif seg.Name == \"__PAGEZERO\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tn := seg.Addr + seg.Filesz - addr\n-\t\t\tif n > size {\n-\t\t\t\tn = size\n-\t\t\t}\n-\t\t\tdata := make([]byte, n)\n-\t\t\t_, err := seg.ReadAt(data, int64(addr-seg.Addr))\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\treturn data, nil\n-\t\t}\n-\t}\n-\treturn nil, fmt.Errorf(\"address not mapped\")\n-}\n-\n-func (x *machoExe) DataStart() uint64 {\n-\t// Look for section named \"__go_buildinfo\".\n-\tfor _, sec := range x.f.Sections {\n-\t\tif sec.Name == \"__go_buildinfo\" {\n-\t\t\treturn sec.Addr\n-\t\t}\n-\t}\n-\t// Try the first non-empty writable segment.\n-\tconst RW = 3\n-\tfor _, load := range x.f.Loads {\n-\t\tseg, ok := load.(*macho.Segment)\n-\t\tif ok && seg.Addr != 0 && seg.Filesz != 0 && seg.Prot == RW && seg.Maxprot == RW {\n-\t\t\treturn seg.Addr\n-\t\t}\n-\t}\n-\treturn 0\n-}\n-\n-// xcoffExe is the XCOFF (AIX eXtended COFF) implementation of the exe interface.\n-type xcoffExe struct {\n-\tos *os.File\n-\tf  *xcoff.File\n-}\n-\n-func (x *xcoffExe) Close() error {\n-\treturn x.os.Close()\n-}\n-\n-func (x *xcoffExe) ReadData(addr, size uint64) ([]byte, error) {\n-\tfor _, sect := range x.f.Sections {\n-\t\tif uint64(sect.VirtualAddress) <= addr && addr <= uint64(sect.VirtualAddress+sect.Size-1) {\n-\t\t\tn := uint64(sect.VirtualAddress+sect.Size) - addr\n-\t\t\tif n > size {\n-\t\t\t\tn = size\n-\t\t\t}\n-\t\t\tdata := make([]byte, n)\n-\t\t\t_, err := sect.ReadAt(data, int64(addr-uint64(sect.VirtualAddress)))\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\treturn data, nil\n-\t\t}\n-\t}\n-\treturn nil, fmt.Errorf(\"address not mapped\")\n-}\n-\n-func (x *xcoffExe) DataStart() uint64 {\n-\treturn x.f.SectionByType(xcoff.STYP_DATA).VirtualAddress\n-}"}, {"sha": "52502e95c6d673eed8ec1b1a203ba9b9b55bd268", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "modified", "additions": 22, "deletions": 79, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -8,7 +8,8 @@ package version\n import (\n \t\"bytes\"\n \t\"context\"\n-\t\"encoding/binary\"\n+\t\"debug/buildinfo\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io/fs\"\n \t\"os\"\n@@ -62,8 +63,14 @@ func runVersion(ctx context.Context, cmd *base.Command, args []string) {\n \t\t// a reasonable use case. For example, imagine GOFLAGS=-v to\n \t\t// turn \"verbose mode\" on for all Go commands, which should not\n \t\t// break \"go version\".\n-\t\tif (!base.InGOFLAGS(\"-m\") && *versionM) || (!base.InGOFLAGS(\"-v\") && *versionV) {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go version: flags can only be used with arguments\\n\")\n+\t\tvar argOnlyFlag string\n+\t\tif !base.InGOFLAGS(\"-m\") && *versionM {\n+\t\t\targOnlyFlag = \"-m\"\n+\t\t} else if !base.InGOFLAGS(\"-v\") && *versionV {\n+\t\t\targOnlyFlag = \"-v\"\n+\t\t}\n+\t\tif argOnlyFlag != \"\" {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: 'go version' only accepts %s flag with arguments\\n\", argOnlyFlag)\n \t\t\tbase.SetExitStatus(2)\n \t\t\treturn\n \t\t}\n@@ -135,90 +142,26 @@ func scanFile(file string, info fs.FileInfo, mustPrint bool) {\n \t\treturn\n \t}\n \n-\tx, err := openExe(file)\n+\tbi, err := buildinfo.ReadFile(file)\n \tif err != nil {\n \t\tif mustPrint {\n-\t\t\tfmt.Fprintf(os.Stderr, \"%s: %v\\n\", file, err)\n-\t\t}\n-\t\treturn\n-\t}\n-\tdefer x.Close()\n-\n-\tvers, mod := findVers(x)\n-\tif vers == \"\" {\n-\t\tif mustPrint {\n-\t\t\tfmt.Fprintf(os.Stderr, \"%s: go version not found\\n\", file)\n+\t\t\tif pathErr := (*os.PathError)(nil); errors.As(err, &pathErr) && filepath.Clean(pathErr.Path) == filepath.Clean(file) {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", file)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: %v\\n\", file, err)\n+\t\t\t}\n \t\t}\n \t\treturn\n \t}\n \n-\tfmt.Printf(\"%s: %s\\n\", file, vers)\n-\tif *versionM && mod != \"\" {\n-\t\tfmt.Printf(\"\\t%s\\n\", strings.ReplaceAll(mod[:len(mod)-1], \"\\n\", \"\\n\\t\"))\n-\t}\n-}\n-\n-// The build info blob left by the linker is identified by\n-// a 16-byte header, consisting of buildInfoMagic (14 bytes),\n-// the binary's pointer size (1 byte),\n-// and whether the binary is big endian (1 byte).\n-var buildInfoMagic = []byte(\"\\xff Go buildinf:\")\n-\n-// findVers finds and returns the Go version and module version information\n-// in the executable x.\n-func findVers(x exe) (vers, mod string) {\n-\t// Read the first 64kB of text to find the build info blob.\n-\ttext := x.DataStart()\n-\tdata, err := x.ReadData(text, 64*1024)\n+\tfmt.Printf(\"%s: %s\\n\", file, bi.GoVersion)\n+\tbi.GoVersion = \"\" // suppress printing go version again\n+\tmod, err := bi.MarshalText()\n \tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"%s: formatting build info: %v\\n\", file, err)\n \t\treturn\n \t}\n-\tfor ; !bytes.HasPrefix(data, buildInfoMagic); data = data[32:] {\n-\t\tif len(data) < 32 {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\t// Decode the blob.\n-\tptrSize := int(data[14])\n-\tbigEndian := data[15] != 0\n-\tvar bo binary.ByteOrder\n-\tif bigEndian {\n-\t\tbo = binary.BigEndian\n-\t} else {\n-\t\tbo = binary.LittleEndian\n-\t}\n-\tvar readPtr func([]byte) uint64\n-\tif ptrSize == 4 {\n-\t\treadPtr = func(b []byte) uint64 { return uint64(bo.Uint32(b)) }\n-\t} else {\n-\t\treadPtr = bo.Uint64\n-\t}\n-\tvers = readString(x, ptrSize, readPtr, readPtr(data[16:]))\n-\tif vers == \"\" {\n-\t\treturn\n-\t}\n-\tmod = readString(x, ptrSize, readPtr, readPtr(data[16+ptrSize:]))\n-\tif len(mod) >= 33 && mod[len(mod)-17] == '\\n' {\n-\t\t// Strip module framing.\n-\t\tmod = mod[16 : len(mod)-16]\n-\t} else {\n-\t\tmod = \"\"\n-\t}\n-\treturn\n-}\n-\n-// readString returns the string at address addr in the executable x.\n-func readString(x exe, ptrSize int, readPtr func([]byte) uint64, addr uint64) string {\n-\thdr, err := x.ReadData(addr, uint64(2*ptrSize))\n-\tif err != nil || len(hdr) < 2*ptrSize {\n-\t\treturn \"\"\n-\t}\n-\tdataAddr := readPtr(hdr)\n-\tdataLen := readPtr(hdr[ptrSize:])\n-\tdata, err := x.ReadData(dataAddr, dataLen)\n-\tif err != nil || uint64(len(data)) < dataLen {\n-\t\treturn \"\"\n+\tif *versionM && len(mod) > 0 {\n+\t\tfmt.Printf(\"\\t%s\\n\", bytes.ReplaceAll(mod[:len(mod)-1], []byte(\"\\n\"), []byte(\"\\n\\t\")))\n \t}\n-\treturn string(data)\n }"}, {"sha": "88b3c570a03b5c52328eaf745dc795d86174c830", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -103,7 +103,7 @@ func runVet(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tcontinue\n \t\t}\n \t\tif len(ptest.GoFiles) == 0 && len(ptest.CgoFiles) == 0 && pxtest == nil {\n-\t\t\tbase.Errorf(\"go vet %s: no Go files in %s\", p.ImportPath, p.Dir)\n+\t\t\tbase.Errorf(\"go: can't vet %s: no Go files in %s\", p.ImportPath, p.Dir)\n \t\t\tcontinue\n \t\t}\n \t\tif len(ptest.GoFiles) > 0 || len(ptest.CgoFiles) > 0 {"}, {"sha": "3551a5997c5f887d5c3f9f8dd00ac462a902f46b", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -82,7 +82,7 @@ func vetFlags(args []string) (passToVet, packageNames []string) {\n \tvetcmd := exec.Command(tool, \"-flags\")\n \tvetcmd.Stdout = out\n \tif err := vetcmd.Run(); err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"go vet: can't execute %s -flags: %v\\n\", tool, err)\n+\t\tfmt.Fprintf(os.Stderr, \"go: can't execute %s -flags: %v\\n\", tool, err)\n \t\tbase.SetExitStatus(2)\n \t\tbase.Exit()\n \t}\n@@ -92,7 +92,7 @@ func vetFlags(args []string) (passToVet, packageNames []string) {\n \t\tUsage string\n \t}\n \tif err := json.Unmarshal(out.Bytes(), &analysisFlags); err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"go vet: can't unmarshal JSON from %s -flags: %v\", tool, err)\n+\t\tfmt.Fprintf(os.Stderr, \"go: can't unmarshal JSON from %s -flags: %v\", tool, err)\n \t\tbase.SetExitStatus(2)\n \t\tbase.Exit()\n \t}"}, {"sha": "ab88e9e4781f4666c9102104d4e1eccf7948c90b", "filename": "libgo/go/cmd/go/internal/web/bootstrap.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build cmd_go_bootstrap\n-// +build cmd_go_bootstrap\n \n // This code is compiled only into the bootstrap 'go' binary.\n // These stubs avoid importing packages with large dependency"}, {"sha": "a92326db01e629093235ad88d809329bcadb1ab9", "filename": "libgo/go/cmd/go/internal/web/http.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !cmd_go_bootstrap\n-// +build !cmd_go_bootstrap\n \n // This code is compiled into the real 'go' binary, but it is not\n // compiled into the binary that is built during all.bash, so as\n@@ -17,6 +16,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"mime\"\n+\t\"net\"\n \t\"net/http\"\n \turlpkg \"net/url\"\n \t\"os\"\n@@ -84,8 +84,15 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \tif url.Host == \"localhost.localdev\" {\n \t\treturn nil, fmt.Errorf(\"no such host localhost.localdev\")\n \t}\n-\tif os.Getenv(\"TESTGONETWORK\") == \"panic\" && !strings.HasPrefix(url.Host, \"127.0.0.1\") && !strings.HasPrefix(url.Host, \"0.0.0.0\") {\n-\t\tpanic(\"use of network: \" + url.String())\n+\tif os.Getenv(\"TESTGONETWORK\") == \"panic\" {\n+\t\thost := url.Host\n+\t\tif h, _, err := net.SplitHostPort(url.Host); err == nil && h != \"\" {\n+\t\t\thost = h\n+\t\t}\n+\t\taddr := net.ParseIP(host)\n+\t\tif addr == nil || (!addr.IsLoopback() && !addr.IsUnspecified()) {\n+\t\t\tpanic(\"use of network: \" + url.String())\n+\t\t}\n \t}\n \n \tfetch := func(url *urlpkg.URL) (*urlpkg.URL, *http.Response, error) {"}, {"sha": "84bbd72820fcab516624f09755265dcd97f0f81d", "filename": "libgo/go/cmd/go/internal/web/url_other.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !windows\n-// +build !windows\n \n package web\n "}, {"sha": "5c197de800dc1f31e73ca132da21218f7c8df148", "filename": "libgo/go/cmd/go/internal/web/url_other_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !windows\n-// +build !windows\n \n package web\n "}, {"sha": "ba82e8ff225a4a764ba03cfef56861f209c7950d", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -38,7 +38,7 @@ type Builder struct {\n \tactionCache map[cacheKey]*Action // a cache of already-constructed actions\n \tmkdirCache  map[string]bool      // a cache of created directories\n \tflagCache   map[[2]string]bool   // a cache of supported compiler flags\n-\tPrint       func(args ...interface{}) (int, error)\n+\tPrint       func(args ...any) (int, error)\n \n \tIsCmdList           bool // running as part of go list; set p.Stale and additional fields below\n \tNeedError           bool // list needs p.Error\n@@ -121,8 +121,8 @@ type actionQueue []*Action\n func (q *actionQueue) Len() int           { return len(*q) }\n func (q *actionQueue) Swap(i, j int)      { (*q)[i], (*q)[j] = (*q)[j], (*q)[i] }\n func (q *actionQueue) Less(i, j int) bool { return (*q)[i].priority < (*q)[j].priority }\n-func (q *actionQueue) Push(x interface{}) { *q = append(*q, x.(*Action)) }\n-func (q *actionQueue) Pop() interface{} {\n+func (q *actionQueue) Push(x any)         { *q = append(*q, x.(*Action)) }\n+func (q *actionQueue) Pop() any {\n \tn := len(*q) - 1\n \tx := (*q)[n]\n \t*q = (*q)[:n]\n@@ -242,7 +242,7 @@ const (\n )\n \n func (b *Builder) Init() {\n-\tb.Print = func(a ...interface{}) (int, error) {\n+\tb.Print = func(a ...any) (int, error) {\n \t\treturn fmt.Fprint(os.Stderr, a...)\n \t}\n \tb.actionCache = make(map[cacheKey]*Action)\n@@ -295,14 +295,14 @@ func (b *Builder) Init() {\n \t}\n \n \tif err := CheckGOOSARCHPair(cfg.Goos, cfg.Goarch); err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"cmd/go: %v\\n\", err)\n+\t\tfmt.Fprintf(os.Stderr, \"go: %v\\n\", err)\n \t\tbase.SetExitStatus(2)\n \t\tbase.Exit()\n \t}\n \n \tfor _, tag := range cfg.BuildContext.BuildTags {\n \t\tif strings.Contains(tag, \",\") {\n-\t\t\tfmt.Fprintf(os.Stderr, \"cmd/go: -tags space-separated list contains comma\\n\")\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: -tags space-separated list contains comma\\n\")\n \t\t\tbase.SetExitStatus(2)\n \t\t\tbase.Exit()\n \t\t}"}, {"sha": "1c278d3d992838549ea170ada4b53ef581244171", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -68,13 +68,16 @@ and test commands:\n \t\tThe default is GOMAXPROCS, normally the number of CPUs available.\n \t-race\n \t\tenable data race detection.\n-\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,\n+\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, darwin/arm64, windows/amd64,\n \t\tlinux/ppc64le and linux/arm64 (only for 48-bit VMA).\n \t-msan\n \t\tenable interoperation with memory sanitizer.\n \t\tSupported only on linux/amd64, linux/arm64\n \t\tand only with Clang/LLVM as the host C compiler.\n \t\tOn linux/arm64, pie build mode will be used.\n+\t-asan\n+\t\tenable interoperation with address sanitizer.\n+\t\tSupported only on linux/arm64, linux/amd64.\n \t-v\n \t\tprint the names of packages as they are compiled.\n \t-work\n@@ -87,6 +90,12 @@ and test commands:\n \t\targuments to pass on each go tool asm invocation.\n \t-buildmode mode\n \t\tbuild mode to use. See 'go help buildmode' for more.\n+\t-buildvcs\n+\t\tWhether to stamp binaries with version control information. By default,\n+\t\tversion control information is stamped into a binary if the main package\n+\t\tand the main module containing it are in the repository containing the\n+\t\tcurrent directory (if there is a repository). Use -buildvcs=false to\n+\t\tomit version control information.\n \t-compiler name\n \t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n \t-gccgoflags '[pattern=]arg list'\n@@ -98,8 +107,8 @@ and test commands:\n \t\tin order to keep output separate from default builds.\n \t\tIf using the -race flag, the install suffix is automatically set to race\n \t\tor, if set explicitly, has _race appended to it. Likewise for the -msan\n-\t\tflag. Using a -buildmode option that requires non-default compile flags\n-\t\thas a similar effect.\n+\t\tand -asan flags. Using a -buildmode option that requires non-default compile\n+\t\tflags has a similar effect.\n \t-ldflags '[pattern=]arg list'\n \t\targuments to pass on each go tool link invocation.\n \t-linkshared\n@@ -121,6 +130,14 @@ and test commands:\n \t\tdirectory, but it is not accessed. When -modfile is specified, an\n \t\talternate go.sum file is also used: its path is derived from the\n \t\t-modfile flag by trimming the \".mod\" extension and appending \".sum\".\n+\t-workfile file\n+\t\tin module aware mode, use the given go.work file as a workspace file.\n+\t\tBy default or when -workfile is \"auto\", the go command searches for a\n+\t\tfile named go.work in the current directory and then containing directories\n+\t\tuntil one is found. If a valid go.work file is found, the modules\n+\t\tspecified will collectively be used as the main modules. If -workfile\n+\t\tis \"off\", or a go.work file is not found in \"auto\" mode, workspace\n+\t\tmode is disabled.\n \t-overlay file\n \t\tread a JSON config file that provides an overlay for build operations.\n \t\tThe file is a JSON struct with a single field, named 'Replace', that\n@@ -145,9 +162,8 @@ and test commands:\n \t-trimpath\n \t\tremove all file system paths from the resulting executable.\n \t\tInstead of absolute file system paths, the recorded file names\n-\t\twill begin with either \"go\" (for the standard library),\n-\t\tor a module path@version (when using modules),\n-\t\tor a plain import path (when using GOPATH).\n+\t\twill begin either a module path@version (when using modules),\n+\t\tor a plain import path (when using the standard library, or GOPATH).\n \t-toolexec 'cmd args'\n \t\ta program to use to invoke toolchain programs like vet and asm.\n \t\tFor example, instead of running asm, the go command will run\n@@ -201,6 +217,7 @@ func init() {\n \n \tAddBuildFlags(CmdBuild, DefaultBuildFlags)\n \tAddBuildFlags(CmdInstall, DefaultBuildFlags)\n+\tbase.AddWorkfileFlag(&CmdBuild.Flag)\n }\n \n // Note that flags consulted by other parts of the code\n@@ -289,10 +306,12 @@ func AddBuildFlags(cmd *base.Command, mask BuildFlagMask) {\n \tcmd.Flag.StringVar(&cfg.BuildPkgdir, \"pkgdir\", \"\", \"\")\n \tcmd.Flag.BoolVar(&cfg.BuildRace, \"race\", false, \"\")\n \tcmd.Flag.BoolVar(&cfg.BuildMSan, \"msan\", false, \"\")\n+\tcmd.Flag.BoolVar(&cfg.BuildASan, \"asan\", false, \"\")\n \tcmd.Flag.Var((*tagsFlag)(&cfg.BuildContext.BuildTags), \"tags\", \"\")\n \tcmd.Flag.Var((*base.StringsFlag)(&cfg.BuildToolexec), \"toolexec\", \"\")\n \tcmd.Flag.BoolVar(&cfg.BuildTrimpath, \"trimpath\", false, \"\")\n \tcmd.Flag.BoolVar(&cfg.BuildWork, \"work\", false, \"\")\n+\tcmd.Flag.BoolVar(&cfg.BuildBuildvcs, \"buildvcs\", true, \"\")\n \n \t// Undocumented, unstable debugging flags.\n \tcmd.Flag.StringVar(&cfg.DebugActiongraph, \"debug-actiongraph\", \"\", \"\")\n@@ -364,6 +383,7 @@ var pkgsFilter = func(pkgs []*load.Package) []*load.Package { return pkgs }\n var runtimeVersion = runtime.Version()\n \n func runBuild(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n \tBuildInit()\n \tvar b Builder\n \tb.Init()\n@@ -396,7 +416,7 @@ func runBuild(ctx context.Context, cmd *base.Command, args []string) {\n \tdepMode := ModeBuild\n \tif cfg.BuildI {\n \t\tdepMode = ModeInstall\n-\t\tfmt.Fprint(os.Stderr, \"go build: -i flag is deprecated\\n\")\n+\t\tfmt.Fprint(os.Stderr, \"go: -i flag is deprecated\\n\")\n \t}\n \n \tpkgs = omitTestOnly(pkgsFilter(pkgs))\n@@ -415,7 +435,7 @@ func runBuild(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tstrings.HasSuffix(cfg.BuildO, \"/\") ||\n \t\t\tstrings.HasSuffix(cfg.BuildO, string(os.PathSeparator)) {\n \t\t\tif !explicitO {\n-\t\t\t\tbase.Fatalf(\"go build: build output %q already exists and is a directory\", cfg.BuildO)\n+\t\t\t\tbase.Fatalf(\"go: build output %q already exists and is a directory\", cfg.BuildO)\n \t\t\t}\n \t\t\ta := &Action{Mode: \"go build\"}\n \t\t\tfor _, p := range pkgs {\n@@ -430,13 +450,13 @@ func runBuild(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t\ta.Deps = append(a.Deps, b.AutoAction(ModeInstall, depMode, p))\n \t\t\t}\n \t\t\tif len(a.Deps) == 0 {\n-\t\t\t\tbase.Fatalf(\"go build: no main packages to build\")\n+\t\t\t\tbase.Fatalf(\"go: no main packages to build\")\n \t\t\t}\n \t\t\tb.Do(ctx, a)\n \t\t\treturn\n \t\t}\n \t\tif len(pkgs) > 1 {\n-\t\t\tbase.Fatalf(\"go build: cannot write multiple packages to non-directory %s\", cfg.BuildO)\n+\t\t\tbase.Fatalf(\"go: cannot write multiple packages to non-directory %s\", cfg.BuildO)\n \t\t} else if len(pkgs) == 0 {\n \t\t\tbase.Fatalf(\"no packages to build\")\n \t\t}\n@@ -486,14 +506,17 @@ allowed, even if they refer to the same version.\n \n - All arguments must refer to packages in the same module at the same version.\n \n+- Package path arguments must refer to main packages. Pattern arguments\n+will only match main packages.\n+\n - No module is considered the \"main\" module. If the module containing\n packages named on the command line has a go.mod file, it must not contain\n directives (replace and exclude) that would cause it to be interpreted\n differently than if it were the main module. The module must not require\n a higher version of itself.\n \n-- Package path arguments must refer to main packages. Pattern arguments\n-will only match main packages.\n+- Vendor directories are not used in any module. (Vendor directories are not\n+included in the module zip files downloaded by 'go install'.)\n \n If the arguments don't have version suffixes, \"go install\" may run in\n module-aware mode or GOPATH mode, depending on the GO111MODULE environment\n@@ -580,13 +603,14 @@ func runInstall(ctx context.Context, cmd *base.Command, args []string) {\n \tfor _, arg := range args {\n \t\tif strings.Contains(arg, \"@\") && !build.IsLocalImport(arg) && !filepath.IsAbs(arg) {\n \t\t\tif cfg.BuildI {\n-\t\t\t\tfmt.Fprint(os.Stderr, \"go install: -i flag is deprecated\\n\")\n+\t\t\t\tfmt.Fprint(os.Stderr, \"go: -i flag is deprecated\\n\")\n \t\t\t}\n \t\t\tinstallOutsideModule(ctx, args)\n \t\t\treturn\n \t\t}\n \t}\n \n+\tmodload.InitWorkfile()\n \tBuildInit()\n \tpkgs := load.PackagesAndErrors(ctx, load.PackageOpts{}, args)\n \tif cfg.ModulesEnabled && !modload.HasModRoot() {\n@@ -608,7 +632,7 @@ func runInstall(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t\tlatestArgs[i] = args[i] + \"@latest\"\n \t\t\t}\n \t\t\thint := strings.Join(latestArgs, \" \")\n-\t\t\tbase.Fatalf(\"go install: version is required when current directory is not in a module\\n\\tTry 'go install %s' to install the latest version\", hint)\n+\t\t\tbase.Fatalf(\"go: 'go install' requires a version when current directory is not in a module\\n\\tTry 'go install %s' to install the latest version\", hint)\n \t\t}\n \t}\n \tload.CheckPackageErrors(pkgs)\n@@ -621,7 +645,7 @@ func runInstall(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}\n \t\tif !allGoroot {\n-\t\t\tfmt.Fprint(os.Stderr, \"go install: -i flag is deprecated\\n\")\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: -i flag is deprecated\\n\")\n \t\t}\n \t}\n \n@@ -667,14 +691,14 @@ func InstallPackages(ctx context.Context, patterns []string, pkgs []*load.Packag\n \t\t\tcase p.Name != \"main\" && p.Module != nil:\n \t\t\t\t// Non-executables have no target (except the cache) when building with modules.\n \t\t\tcase p.Internal.GobinSubdir:\n-\t\t\t\tbase.Errorf(\"go %s: cannot install cross-compiled binaries when GOBIN is set\", cfg.CmdName)\n+\t\t\t\tbase.Errorf(\"go: cannot install cross-compiled binaries when GOBIN is set\")\n \t\t\tcase p.Internal.CmdlineFiles:\n-\t\t\t\tbase.Errorf(\"go %s: no install location for .go files listed on command line (GOBIN not set)\", cfg.CmdName)\n+\t\t\t\tbase.Errorf(\"go: no install location for .go files listed on command line (GOBIN not set)\")\n \t\t\tcase p.ConflictDir != \"\":\n-\t\t\t\tbase.Errorf(\"go %s: no install location for %s: hidden by %s\", cfg.CmdName, p.Dir, p.ConflictDir)\n+\t\t\t\tbase.Errorf(\"go: no install location for %s: hidden by %s\", p.Dir, p.ConflictDir)\n \t\t\tdefault:\n-\t\t\t\tbase.Errorf(\"go %s: no install location for directory %s outside GOPATH\\n\"+\n-\t\t\t\t\t\"\\tFor more details see: 'go help gopath'\", cfg.CmdName, p.Dir)\n+\t\t\t\tbase.Errorf(\"go: no install location for directory %s outside GOPATH\\n\"+\n+\t\t\t\t\t\"\\tFor more details see: 'go help gopath'\", p.Dir)\n \t\t\t}\n \t\t}\n \t}\n@@ -769,7 +793,7 @@ func installOutsideModule(ctx context.Context, args []string) {\n \tpkgOpts := load.PackageOpts{MainOnly: true}\n \tpkgs, err := load.PackagesAndErrorsOutsideModule(ctx, pkgOpts, args)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go install: %v\", err)\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \tload.CheckPackageErrors(pkgs)\n \tpatterns := make([]string, len(args))"}, {"sha": "0b6b83a706cd400faba2bb45ef531adce2166180", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -234,7 +234,7 @@ func TestRespectSetgidDir(t *testing.T) {\n \t// of `(*Builder).ShowCmd` afterwards as a sanity check.\n \tcfg.BuildX = true\n \tvar cmdBuf bytes.Buffer\n-\tb.Print = func(a ...interface{}) (int, error) {\n+\tb.Print = func(a ...any) (int, error) {\n \t\treturn cmdBuf.WriteString(fmt.Sprint(a...))\n \t}\n "}, {"sha": "76335e9bb170b145d71ff15de5d5383090b2db17", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -570,6 +570,8 @@ func showStdout(b *Builder, c *cache.Cache, actionID cache.ActionID, key string)\n \t\t\tb.Showcmd(\"\", \"%s  # internal\", joinUnambiguously(str.StringList(\"cat\", c.OutputFile(stdoutEntry.OutputID))))\n \t\t}\n \t\tif !cfg.BuildN {\n+\t\t\tb.output.Lock()\n+\t\t\tdefer b.output.Unlock()\n \t\t\tb.Print(string(stdout))\n \t\t}\n \t}\n@@ -578,6 +580,8 @@ func showStdout(b *Builder, c *cache.Cache, actionID cache.ActionID, key string)\n \n // flushOutput flushes the output being queued in a.\n func (b *Builder) flushOutput(a *Action) {\n+\tb.output.Lock()\n+\tdefer b.output.Unlock()\n \tb.Print(string(a.output))\n \ta.output = nil\n }"}, {"sha": "d3f0ecac0495d99c7e0f9ee623847c252c3aafe1", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -36,6 +36,8 @@ import (\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/trace\"\n+\t\"cmd/internal/quoted\"\n+\t\"cmd/internal/sys\"\n )\n \n // actionList returns the list of actions in the dag rooted at root\n@@ -222,18 +224,34 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \t// same compiler settings and can reuse each other's results.\n \t// If not, the reason is already recorded in buildGcflags.\n \tfmt.Fprintf(h, \"compile\\n\")\n-\t// Only include the package directory if it may affect the output.\n-\t// We trim workspace paths for all packages when -trimpath is set.\n-\t// The compiler hides the exact value of $GOROOT\n-\t// when building things in GOROOT.\n-\t// Assume b.WorkDir is being trimmed properly.\n-\t// When -trimpath is used with a package built from the module cache,\n-\t// use the module path and version instead of the directory.\n-\tif !p.Goroot && !cfg.BuildTrimpath && !strings.HasPrefix(p.Dir, b.WorkDir) {\n+\n+\t// Include information about the origin of the package that\n+\t// may be embedded in the debug info for the object file.\n+\tif cfg.BuildTrimpath {\n+\t\t// When -trimpath is used with a package built from the module cache,\n+\t\t// its debug information refers to the module path and version\n+\t\t// instead of the directory.\n+\t\tif p.Module != nil {\n+\t\t\tfmt.Fprintf(h, \"module %s@%s\\n\", p.Module.Path, p.Module.Version)\n+\t\t}\n+\t} else if p.Goroot {\n+\t\t// The Go compiler always hides the exact value of $GOROOT\n+\t\t// when building things in GOROOT.\n+\t\t//\n+\t\t// The C compiler does not, but for packages in GOROOT we rewrite the path\n+\t\t// as though -trimpath were set, so that we don't invalidate the build cache\n+\t\t// (and especially any precompiled C archive files) when changing\n+\t\t// GOROOT_FINAL. (See https://go.dev/issue/50183.)\n+\t\t//\n+\t\t// b.WorkDir is always either trimmed or rewritten to\n+\t\t// the literal string \"/tmp/go-build\".\n+\t} else if !strings.HasPrefix(p.Dir, b.WorkDir) {\n+\t\t// -trimpath is not set and no other rewrite rules apply,\n+\t\t// so the object file may refer to the absolute directory\n+\t\t// containing the package.\n \t\tfmt.Fprintf(h, \"dir %s\\n\", p.Dir)\n-\t} else if cfg.BuildTrimpath && p.Module != nil {\n-\t\tfmt.Fprintf(h, \"module %s@%s\\n\", p.Module.Path, p.Module.Version)\n \t}\n+\n \tif p.Module != nil {\n \t\tfmt.Fprintf(h, \"go %s\\n\", p.Module.GoVersion)\n \t}\n@@ -281,6 +299,11 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \tif p.Internal.CoverMode != \"\" {\n \t\tfmt.Fprintf(h, \"cover %q %q\\n\", p.Internal.CoverMode, b.toolID(\"cover\"))\n \t}\n+\tif p.Internal.FuzzInstrument {\n+\t\tif fuzzFlags := fuzzInstrumentFlags(); fuzzFlags != nil {\n+\t\t\tfmt.Fprintf(h, \"fuzz %q\\n\", fuzzFlags)\n+\t\t}\n+\t}\n \tfmt.Fprintf(h, \"modinfo %q\\n\", p.Internal.BuildInfo)\n \n \t// Configuration specific to compiler toolchain.\n@@ -775,10 +798,13 @@ OverlayLoop:\n \t}\n \n \tif p.Internal.BuildInfo != \"\" && cfg.ModulesEnabled {\n-\t\tif err := b.writeFile(objdir+\"_gomod_.go\", modload.ModInfoProg(p.Internal.BuildInfo, cfg.BuildToolchainName == \"gccgo\")); err != nil {\n-\t\t\treturn err\n+\t\tprog := modload.ModInfoProg(p.Internal.BuildInfo, cfg.BuildToolchainName == \"gccgo\")\n+\t\tif len(prog) > 0 {\n+\t\t\tif err := b.writeFile(objdir+\"_gomod_.go\", prog); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tgofiles = append(gofiles, objdir+\"_gomod_.go\")\n \t\t}\n-\t\tgofiles = append(gofiles, objdir+\"_gomod_.go\")\n \t}\n \n \t// Compile Go.\n@@ -1375,6 +1401,7 @@ func (b *Builder) writeLinkImportcfg(a *Action, file string) error {\n \t\t\tfmt.Fprintf(&icfg, \"packageshlib %s=%s\\n\", p1.ImportPath, p1.Shlib)\n \t\t}\n \t}\n+\tfmt.Fprintf(&icfg, \"modinfo %q\\n\", modload.ModInfoData(a.Package.Internal.BuildInfo))\n \treturn b.writeFile(file, icfg.Bytes())\n }\n \n@@ -1489,6 +1516,8 @@ func (b *Builder) getPkgConfigFlags(p *load.Package) (cflags, ldflags []string,\n \t\t\treturn nil, nil, errPrintedOutput\n \t\t}\n \t\tif len(out) > 0 {\n+\t\t\t// NOTE: we don't attempt to parse quotes and unescapes here. pkg-config\n+\t\t\t// is typically used within shell backticks, which treats quotes literally.\n \t\t\tldflags = strings.Fields(string(out))\n \t\t\tif err := checkLinkerFlags(\"LDFLAGS\", \"pkg-config --libs\", ldflags); err != nil {\n \t\t\t\treturn nil, nil, err\n@@ -1923,7 +1952,7 @@ func mayberemovefile(s string) {\n //\tfmtcmd replaces the name of the current directory with dot (.)\n //\tbut only when it is at the beginning of a space-separated token.\n //\n-func (b *Builder) fmtcmd(dir string, format string, args ...interface{}) string {\n+func (b *Builder) fmtcmd(dir string, format string, args ...any) string {\n \tcmd := fmt.Sprintf(format, args...)\n \tif dir != \"\" && dir != \"/\" {\n \t\tdot := \" .\"\n@@ -1949,7 +1978,7 @@ func (b *Builder) fmtcmd(dir string, format string, args ...interface{}) string\n \n // showcmd prints the given command to standard output\n // for the implementation of -n or -x.\n-func (b *Builder) Showcmd(dir string, format string, args ...interface{}) {\n+func (b *Builder) Showcmd(dir string, format string, args ...any) {\n \tb.output.Lock()\n \tdefer b.output.Unlock()\n \tb.Print(b.fmtcmd(dir, format, args...) + \"\\n\")\n@@ -2013,7 +2042,7 @@ var cgoTypeSigRe = lazyregexp.New(`\\b_C2?(type|func|var|macro)_\\B`)\n // run runs the command given by cmdline in the directory dir.\n // If the command fails, run prints information about the failure\n // and returns a non-nil error.\n-func (b *Builder) run(a *Action, dir string, desc string, env []string, cmdargs ...interface{}) error {\n+func (b *Builder) run(a *Action, dir string, desc string, env []string, cmdargs ...any) error {\n \tout, err := b.runOut(a, dir, env, cmdargs...)\n \tif len(out) > 0 {\n \t\tif desc == \"\" {\n@@ -2047,7 +2076,7 @@ func (b *Builder) processOutput(out []byte) string {\n // runOut runs the command given by cmdline in the directory dir.\n // It returns the command output and any errors that occurred.\n // It accumulates execution time in a.\n-func (b *Builder) runOut(a *Action, dir string, env []string, cmdargs ...interface{}) ([]byte, error) {\n+func (b *Builder) runOut(a *Action, dir string, env []string, cmdargs ...any) ([]byte, error) {\n \tcmdline := str.StringList(cmdargs...)\n \n \tfor _, arg := range cmdline {\n@@ -2312,7 +2341,7 @@ func (b *Builder) ccompile(a *Action, p *load.Package, outfile string, flags []s\n \t// directives pointing to the source directory. It should not generate those\n \t// when -trimpath is enabled.\n \tif b.gccSupportsFlag(compiler, \"-fdebug-prefix-map=a=b\") {\n-\t\tif cfg.BuildTrimpath {\n+\t\tif cfg.BuildTrimpath || p.Goroot {\n \t\t\t// Keep in sync with Action.trimpath.\n \t\t\t// The trimmed paths are a little different, but we need to trim in the\n \t\t\t// same situations.\n@@ -2334,8 +2363,6 @@ func (b *Builder) ccompile(a *Action, p *load.Package, outfile string, flags []s\n \t\t\t\tto = filepath.Join(\"/_\", toPath)\n \t\t\t}\n \t\t\tflags = append(flags[:len(flags):len(flags)], \"-fdebug-prefix-map=\"+from+\"=\"+to)\n-\t\t} else if p.Goroot && cfg.GOROOT_FINAL != cfg.GOROOT {\n-\t\t\tflags = append(flags[:len(flags):len(flags)], \"-fdebug-prefix-map=\"+cfg.GOROOT+\"=\"+cfg.GOROOT_FINAL)\n \t\t}\n \t}\n \n@@ -2384,7 +2411,7 @@ func (b *Builder) gccld(a *Action, p *load.Package, objdir, outfile string, flag\n \t\tcmd = b.GccCmd(p.Dir, objdir)\n \t}\n \n-\tcmdargs := []interface{}{cmd, \"-o\", outfile, objs, flags}\n+\tcmdargs := []any{cmd, \"-o\", outfile, objs, flags}\n \tdir := p.Dir\n \tout, err := b.runOut(a, base.Cwd(), b.cCompilerEnv(), cmdargs...)\n \n@@ -2431,12 +2458,6 @@ func (b *Builder) gccld(a *Action, p *load.Package, objdir, outfile string, flag\n \treturn err\n }\n \n-// Grab these before main helpfully overwrites them.\n-var (\n-\torigCC  = cfg.Getenv(\"CC\")\n-\torigCXX = cfg.Getenv(\"CXX\")\n-)\n-\n // gccCmd returns a gcc command line prefix\n // defaultCC is defined in zdefaultcc.go, written by cmd/dist.\n func (b *Builder) GccCmd(incdir, workdir string) []string {\n@@ -2456,40 +2477,23 @@ func (b *Builder) gfortranCmd(incdir, workdir string) []string {\n \n // ccExe returns the CC compiler setting without all the extra flags we add implicitly.\n func (b *Builder) ccExe() []string {\n-\treturn b.compilerExe(origCC, cfg.DefaultCC(cfg.Goos, cfg.Goarch))\n+\treturn envList(\"CC\", cfg.DefaultCC(cfg.Goos, cfg.Goarch))\n }\n \n // cxxExe returns the CXX compiler setting without all the extra flags we add implicitly.\n func (b *Builder) cxxExe() []string {\n-\treturn b.compilerExe(origCXX, cfg.DefaultCXX(cfg.Goos, cfg.Goarch))\n+\treturn envList(\"CXX\", cfg.DefaultCXX(cfg.Goos, cfg.Goarch))\n }\n \n // fcExe returns the FC compiler setting without all the extra flags we add implicitly.\n func (b *Builder) fcExe() []string {\n-\treturn b.compilerExe(cfg.Getenv(\"FC\"), \"gfortran\")\n-}\n-\n-// compilerExe returns the compiler to use given an\n-// environment variable setting (the value not the name)\n-// and a default. The resulting slice is usually just the name\n-// of the compiler but can have additional arguments if they\n-// were present in the environment value.\n-// For example if CC=\"gcc -DGOPHER\" then the result is [\"gcc\", \"-DGOPHER\"].\n-func (b *Builder) compilerExe(envValue string, def string) []string {\n-\tcompiler := strings.Fields(envValue)\n-\tif len(compiler) == 0 {\n-\t\tcompiler = strings.Fields(def)\n-\t}\n-\treturn compiler\n+\treturn envList(\"FC\", \"gfortran\")\n }\n \n // compilerCmd returns a command line prefix for the given environment\n // variable and using the default command when the variable is empty.\n func (b *Builder) compilerCmd(compiler []string, incdir, workdir string) []string {\n-\t// NOTE: env.go's mkEnv knows that the first three\n-\t// strings returned are \"gcc\", \"-I\", incdir (and cuts them off).\n-\ta := []string{compiler[0], \"-I\", incdir}\n-\ta = append(a, compiler[1:]...)\n+\ta := append(compiler, \"-I\", incdir)\n \n \t// Definitely want -fPIC but on Windows gcc complains\n \t// \"-fPIC ignored for target (all code is position independent)\"\n@@ -2670,12 +2674,20 @@ func (b *Builder) gccArchArgs() []string {\n \n // envList returns the value of the given environment variable broken\n // into fields, using the default value when the variable is empty.\n+//\n+// The environment variable must be quoted correctly for\n+// str.SplitQuotedFields. This should be done before building\n+// anything, for example, in BuildInit.\n func envList(key, def string) []string {\n \tv := cfg.Getenv(key)\n \tif v == \"\" {\n \t\tv = def\n \t}\n-\treturn strings.Fields(v)\n+\targs, err := quoted.Split(v)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(\"could not parse environment variable %s with value %q: %v\", key, v, err))\n+\t}\n+\treturn args\n }\n \n // CFlags returns the flags to use when invoking the C, C++ or Fortran compilers, or cgo.\n@@ -2741,6 +2753,10 @@ func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgo\n \t\tcgoCFLAGS = append([]string{\"-fsanitize=memory\"}, cgoCFLAGS...)\n \t\tcgoLDFLAGS = append([]string{\"-fsanitize=memory\"}, cgoLDFLAGS...)\n \t}\n+\tif cfg.BuildASan {\n+\t\tcgoCFLAGS = append([]string{\"-fsanitize=address\"}, cgoCFLAGS...)\n+\t\tcgoLDFLAGS = append([]string{\"-fsanitize=address\"}, cgoLDFLAGS...)\n+\t}\n \n \t// Allows including _cgo_export.h, as well as the user's .h files,\n \t// from .[ch] files in the package.\n@@ -2762,7 +2778,7 @@ func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgo\n \tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n \t\tcgoflags = append(cgoflags, \"-import_runtime_cgo=false\")\n \t}\n-\tif p.Standard && (p.ImportPath == \"runtime/race\" || p.ImportPath == \"runtime/msan\" || p.ImportPath == \"runtime/cgo\") {\n+\tif p.Standard && (p.ImportPath == \"runtime/race\" || p.ImportPath == \"runtime/msan\" || p.ImportPath == \"runtime/cgo\" || p.ImportPath == \"runtime/asan\") {\n \t\tcgoflags = append(cgoflags, \"-import_syscall=false\")\n \t}\n \n@@ -2988,18 +3004,24 @@ func (b *Builder) dynimport(a *Action, p *load.Package, objdir, importGo, cgoExe\n \tlinkobj := str.StringList(ofile, outObj, mkAbsFiles(p.Dir, p.SysoFiles))\n \tdynobj := objdir + \"_cgo_.o\"\n \n-\t// we need to use -pie for Linux/ARM to get accurate imported sym\n \tldflags := cgoLDFLAGS\n \tif (cfg.Goarch == \"arm\" && cfg.Goos == \"linux\") || cfg.Goos == \"android\" {\n-\t\t// -static -pie doesn't make sense, and causes link errors.\n-\t\t// Issue 26197.\n-\t\tn := make([]string, 0, len(ldflags))\n-\t\tfor _, flag := range ldflags {\n-\t\t\tif flag != \"-static\" {\n-\t\t\t\tn = append(n, flag)\n+\t\tif !str.Contains(ldflags, \"-no-pie\") {\n+\t\t\t// we need to use -pie for Linux/ARM to get accurate imported sym (added in https://golang.org/cl/5989058)\n+\t\t\t// this seems to be outdated, but we don't want to break existing builds depending on this (Issue 45940)\n+\t\t\tldflags = append(ldflags, \"-pie\")\n+\t\t}\n+\t\tif str.Contains(ldflags, \"-pie\") && str.Contains(ldflags, \"-static\") {\n+\t\t\t// -static -pie doesn't make sense, and causes link errors.\n+\t\t\t// Issue 26197.\n+\t\t\tn := make([]string, 0, len(ldflags)-1)\n+\t\t\tfor _, flag := range ldflags {\n+\t\t\t\tif flag != \"-static\" {\n+\t\t\t\t\tn = append(n, flag)\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tldflags = n\n \t\t}\n-\t\tldflags = append(n, \"-pie\")\n \t}\n \tif err := b.gccld(a, p, objdir, dynobj, ldflags, linkobj); err != nil {\n \t\treturn err\n@@ -3321,12 +3343,6 @@ func passLongArgsInResponseFiles(cmd *exec.Cmd) (cleanup func()) {\n \treturn cleanup\n }\n \n-// Windows has a limit of 32 KB arguments. To be conservative and not worry\n-// about whether that includes spaces or not, just use 30 KB. Darwin's limit is\n-// less clear. The OS claims 256KB, but we've seen failures with arglen as\n-// small as 50KB.\n-const ArgLengthForResponseFile = (30 << 10)\n-\n func useResponseFile(path string, argLen int) bool {\n \t// Unless the program uses objabi.Flagparse, which understands\n \t// response files, don't use response files.\n@@ -3338,7 +3354,7 @@ func useResponseFile(path string, argLen int) bool {\n \t\treturn false\n \t}\n \n-\tif argLen > ArgLengthForResponseFile {\n+\tif argLen > sys.ExecArgLengthLimit {\n \t\treturn true\n \t}\n "}, {"sha": "8bbf25bb337e8b44e49cf56ae3dd8dfba4aafcf7", "filename": "libgo/go/cmd/go/internal/work/exec_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -7,6 +7,7 @@ package work\n import (\n \t\"bytes\"\n \t\"cmd/internal/objabi\"\n+\t\"cmd/internal/sys\"\n \t\"fmt\"\n \t\"math/rand\"\n \t\"testing\"\n@@ -56,7 +57,7 @@ func TestEncodeDecodeFuzz(t *testing.T) {\n \t}\n \tt.Parallel()\n \n-\tnRunes := ArgLengthForResponseFile + 100\n+\tnRunes := sys.ExecArgLengthLimit + 100\n \trBuffer := make([]rune, nRunes)\n \tbuf := bytes.NewBuffer([]byte(string(rBuffer)))\n \n@@ -67,7 +68,7 @@ func TestEncodeDecodeFuzz(t *testing.T) {\n \tfor i := 0; i < 50; i++ {\n \t\t// Generate a random string of runes.\n \t\tbuf.Reset()\n-\t\tfor buf.Len() < ArgLengthForResponseFile+1 {\n+\t\tfor buf.Len() < sys.ExecArgLengthLimit+1 {\n \t\t\tvar r rune\n \t\t\tfor {\n \t\t\t\tr = rune(rng.Intn(utf8.MaxRune + 1))"}, {"sha": "40175324d2654dc029ae5f038ebe4ceb1270c2f5", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -22,13 +22,26 @@ import (\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/internal/objabi\"\n+\t\"cmd/internal/quoted\"\n \t\"cmd/internal/sys\"\n \t\"crypto/sha1\"\n )\n \n // The 'path' used for GOROOT_FINAL when -trimpath is specified\n const trimPathGoRootFinal = \"go\"\n \n+var runtimePackages = map[string]struct{}{\n+\t\"internal/abi\":            struct{}{},\n+\t\"internal/bytealg\":        struct{}{},\n+\t\"internal/cpu\":            struct{}{},\n+\t\"internal/goarch\":         struct{}{},\n+\t\"internal/goos\":           struct{}{},\n+\t\"runtime\":                 struct{}{},\n+\t\"runtime/internal/atomic\": struct{}{},\n+\t\"runtime/internal/math\":   struct{}{},\n+\t\"runtime/internal/sys\":    struct{}{},\n+}\n+\n // The Go toolchain.\n \n type gcToolchain struct{}\n@@ -63,7 +76,7 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \t}\n \n \tpkgpath := pkgPath(a)\n-\tgcargs := []string{\"-p\", pkgpath}\n+\tdefaultGcFlags := []string{\"-p\", pkgpath}\n \tif p.Module != nil {\n \t\tv := p.Module.GoVersion\n \t\tif v == \"\" {\n@@ -82,22 +95,19 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \t\t\tv = \"1.16\"\n \t\t}\n \t\tif allowedVersion(v) {\n-\t\t\tgcargs = append(gcargs, \"-lang=go\"+v)\n+\t\t\tdefaultGcFlags = append(defaultGcFlags, \"-lang=go\"+v)\n \t\t}\n \t}\n \tif p.Standard {\n-\t\tgcargs = append(gcargs, \"-std\")\n-\t}\n-\tcompilingRuntime := p.Standard && (p.ImportPath == \"runtime\" || strings.HasPrefix(p.ImportPath, \"runtime/internal\"))\n-\t// The runtime package imports a couple of general internal packages.\n-\tif p.Standard && (p.ImportPath == \"internal/cpu\" || p.ImportPath == \"internal/bytealg\" || p.ImportPath == \"internal/abi\") {\n-\t\tcompilingRuntime = true\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-std\")\n \t}\n+\t_, compilingRuntime := runtimePackages[p.ImportPath]\n+\tcompilingRuntime = compilingRuntime && p.Standard\n \tif compilingRuntime {\n \t\t// runtime compiles with a special gc flag to check for\n \t\t// memory allocations that are invalid in the runtime package,\n \t\t// and to implement some special compiler pragmas.\n-\t\tgcargs = append(gcargs, \"-+\")\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-+\")\n \t}\n \n \t// If we're giving the compiler the entire package (no C etc files), tell it that,\n@@ -116,25 +126,28 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \t\t}\n \t}\n \tif extFiles == 0 {\n-\t\tgcargs = append(gcargs, \"-complete\")\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-complete\")\n \t}\n \tif cfg.BuildContext.InstallSuffix != \"\" {\n-\t\tgcargs = append(gcargs, \"-installsuffix\", cfg.BuildContext.InstallSuffix)\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-installsuffix\", cfg.BuildContext.InstallSuffix)\n \t}\n \tif a.buildID != \"\" {\n-\t\tgcargs = append(gcargs, \"-buildid\", a.buildID)\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-buildid\", a.buildID)\n \t}\n \tif p.Internal.OmitDebug || cfg.Goos == \"plan9\" || cfg.Goarch == \"wasm\" {\n-\t\tgcargs = append(gcargs, \"-dwarf=false\")\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-dwarf=false\")\n \t}\n \tif strings.HasPrefix(runtimeVersion, \"go1\") && !strings.Contains(os.Args[0], \"go_bootstrap\") {\n-\t\tgcargs = append(gcargs, \"-goversion\", runtimeVersion)\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-goversion\", runtimeVersion)\n \t}\n \tif symabis != \"\" {\n-\t\tgcargs = append(gcargs, \"-symabis\", symabis)\n+\t\tdefaultGcFlags = append(defaultGcFlags, \"-symabis\", symabis)\n \t}\n \n \tgcflags := str.StringList(forcedGcflags, p.Internal.Gcflags)\n+\tif p.Internal.FuzzInstrument {\n+\t\tgcflags = append(gcflags, fuzzInstrumentFlags()...)\n+\t}\n \tif compilingRuntime {\n \t\t// Remove -N, if present.\n \t\t// It is not possible to build the runtime with no optimizations,\n@@ -147,10 +160,15 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \t\t\t}\n \t\t}\n \t}\n+\t// Add -c=N to use concurrent backend compilation, if possible.\n+\tif c := gcBackendConcurrency(gcflags); c > 1 {\n+\t\tgcflags = append(gcflags, fmt.Sprintf(\"-c=%d\", c))\n+\t}\n \n-\targs := []interface{}{cfg.BuildToolexec, base.Tool(\"compile\"), \"-o\", ofile, \"-trimpath\", a.trimpath(), gcflags, gcargs}\n-\tif p.Internal.LocalPrefix != \"\" {\n-\t\t// Workaround #43883.\n+\targs := []any{cfg.BuildToolexec, base.Tool(\"compile\"), \"-o\", ofile, \"-trimpath\", a.trimpath(), defaultGcFlags, gcflags}\n+\tif p.Internal.LocalPrefix == \"\" {\n+\t\targs = append(args, \"-nolocalimports\")\n+\t} else {\n \t\targs = append(args, \"-D\", p.Internal.LocalPrefix)\n \t}\n \tif importcfg != nil {\n@@ -172,11 +190,6 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \t\targs = append(args, \"-asmhdr\", objdir+\"go_asm.h\")\n \t}\n \n-\t// Add -c=N to use concurrent backend compilation, if possible.\n-\tif c := gcBackendConcurrency(gcflags); c > 1 {\n-\t\targs = append(args, fmt.Sprintf(\"-c=%d\", c))\n-\t}\n-\n \tfor _, f := range gofiles {\n \t\tf := mkAbs(p.Dir, f)\n \n@@ -223,7 +236,7 @@ CheckFlags:\n \t\t// except for known commonly used flags.\n \t\t// If the user knows better, they can manually add their own -c to the gcflags.\n \t\tswitch flag {\n-\t\tcase \"-N\", \"-l\", \"-S\", \"-B\", \"-C\", \"-I\":\n+\t\tcase \"-N\", \"-l\", \"-S\", \"-B\", \"-C\", \"-I\", \"-shared\":\n \t\t\t// OK\n \t\tdefault:\n \t\t\tcanDashC = false\n@@ -349,11 +362,11 @@ func (a *Action) trimpath() string {\n \treturn rewrite\n }\n \n-func asmArgs(a *Action, p *load.Package) []interface{} {\n+func asmArgs(a *Action, p *load.Package) []any {\n \t// Add -I pkg/GOOS_GOARCH so #include \"textflag.h\" works in .s files.\n \tinc := filepath.Join(cfg.GOROOT, \"pkg\", \"include\")\n \tpkgpath := pkgPath(a)\n-\targs := []interface{}{cfg.BuildToolexec, base.Tool(\"asm\"), \"-p\", pkgpath, \"-trimpath\", a.trimpath(), \"-I\", a.Objdir, \"-I\", inc, \"-D\", \"GOOS_\" + cfg.Goos, \"-D\", \"GOARCH_\" + cfg.Goarch, forcedAsmflags, p.Internal.Asmflags}\n+\targs := []any{cfg.BuildToolexec, base.Tool(\"asm\"), \"-p\", pkgpath, \"-trimpath\", a.trimpath(), \"-I\", a.Objdir, \"-I\", inc, \"-D\", \"GOOS_\" + cfg.Goos, \"-D\", \"GOARCH_\" + cfg.Goarch, forcedAsmflags, p.Internal.Asmflags}\n \tif p.ImportPath == \"runtime\" && cfg.Goarch == \"386\" {\n \t\tfor _, arg := range forcedAsmflags {\n \t\t\tif arg == \"-dynlink\" {\n@@ -365,6 +378,16 @@ func asmArgs(a *Action, p *load.Package) []interface{} {\n \t\targs = append(args, \"-compiling-runtime\")\n \t}\n \n+\tif cfg.Goarch == \"386\" {\n+\t\t// Define GO386_value from cfg.GO386.\n+\t\targs = append(args, \"-D\", \"GO386_\"+cfg.GO386)\n+\t}\n+\n+\tif cfg.Goarch == \"amd64\" {\n+\t\t// Define GOAMD64_value from cfg.GOAMD64.\n+\t\targs = append(args, \"-D\", \"GOAMD64_\"+cfg.GOAMD64)\n+\t}\n+\n \tif cfg.Goarch == \"mips\" || cfg.Goarch == \"mipsle\" {\n \t\t// Define GOMIPS_value from cfg.GOMIPS.\n \t\targs = append(args, \"-D\", \"GOMIPS_\"+cfg.GOMIPS)\n@@ -432,8 +455,8 @@ func (gcToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, erro\n // toolVerify checks that the command line args writes the same output file\n // if run using newTool instead.\n // Unused now but kept around for future use.\n-func toolVerify(a *Action, b *Builder, p *load.Package, newTool string, ofile string, args []interface{}) error {\n-\tnewArgs := make([]interface{}, len(args))\n+func toolVerify(a *Action, b *Builder, p *load.Package, newTool string, ofile string, args []any) error {\n+\tnewArgs := make([]any, len(args))\n \tcopy(newArgs, args)\n \tnewArgs[1] = base.Tool(newTool)\n \tnewArgs[3] = ofile + \".new\" // x.6 becomes x.6.new\n@@ -536,33 +559,18 @@ func packInternal(afile string, ofiles []string) error {\n }\n \n // setextld sets the appropriate linker flags for the specified compiler.\n-func setextld(ldflags []string, compiler []string) []string {\n+func setextld(ldflags []string, compiler []string) ([]string, error) {\n \tfor _, f := range ldflags {\n \t\tif f == \"-extld\" || strings.HasPrefix(f, \"-extld=\") {\n \t\t\t// don't override -extld if supplied\n-\t\t\treturn ldflags\n+\t\t\treturn ldflags, nil\n \t\t}\n \t}\n-\tldflags = append(ldflags, \"-extld=\"+compiler[0])\n-\tif len(compiler) > 1 {\n-\t\textldflags := false\n-\t\tadd := strings.Join(compiler[1:], \" \")\n-\t\tfor i, f := range ldflags {\n-\t\t\tif f == \"-extldflags\" && i+1 < len(ldflags) {\n-\t\t\t\tldflags[i+1] = add + \" \" + ldflags[i+1]\n-\t\t\t\textldflags = true\n-\t\t\t\tbreak\n-\t\t\t} else if strings.HasPrefix(f, \"-extldflags=\") {\n-\t\t\t\tldflags[i] = \"-extldflags=\" + add + \" \" + ldflags[i][len(\"-extldflags=\"):]\n-\t\t\t\textldflags = true\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif !extldflags {\n-\t\t\tldflags = append(ldflags, \"-extldflags=\"+add)\n-\t\t}\n+\tjoined, err := quoted.Join(compiler)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\treturn ldflags\n+\treturn append(ldflags, \"-extld=\"+joined), nil\n }\n \n // pluginPath computes the package path for a plugin main package.\n@@ -649,7 +657,10 @@ func (gcToolchain) ld(b *Builder, root *Action, out, importcfg, mainpkg string)\n \t}\n \tldflags = append(ldflags, forcedLdflags...)\n \tldflags = append(ldflags, root.Package.Internal.Ldflags...)\n-\tldflags = setextld(ldflags, compiler)\n+\tldflags, err := setextld(ldflags, compiler)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n \t// On OS X when using external linking to build a shared library,\n \t// the argument passed here to -o ends up recorded in the final\n@@ -693,7 +704,10 @@ func (gcToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action,\n \t} else {\n \t\tcompiler = envList(\"CC\", cfg.DefaultCC(cfg.Goos, cfg.Goarch))\n \t}\n-\tldflags = setextld(ldflags, compiler)\n+\tldflags, err := setextld(ldflags, compiler)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tfor _, d := range toplevelactions {\n \t\tif !strings.HasSuffix(d.Target, \".a\") { // omit unsafe etc and actions for other shared libraries\n \t\t\tcontinue"}, {"sha": "26192ecaed11cad5ebcbbd6c21ba7b9d0462777c", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -11,8 +11,8 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/modload\"\n+\t\"cmd/internal/quoted\"\n \t\"cmd/internal/sys\"\n-\t\"flag\"\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -32,27 +32,63 @@ func BuildInit() {\n \tif cfg.BuildPkgdir != \"\" && !filepath.IsAbs(cfg.BuildPkgdir) {\n \t\tp, err := filepath.Abs(cfg.BuildPkgdir)\n \t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go %s: evaluating -pkgdir: %v\\n\", flag.Args()[0], err)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: evaluating -pkgdir: %v\\n\", err)\n \t\t\tbase.SetExitStatus(2)\n \t\t\tbase.Exit()\n \t\t}\n \t\tcfg.BuildPkgdir = p\n \t}\n \n-\t// Make sure CC and CXX are absolute paths\n-\tfor _, key := range []string{\"CC\", \"CXX\"} {\n-\t\tif path := cfg.Getenv(key); !filepath.IsAbs(path) && path != \"\" && path != filepath.Base(path) {\n-\t\t\tbase.Fatalf(\"go %s: %s environment variable is relative; must be absolute path: %s\\n\", flag.Args()[0], key, path)\n+\tif cfg.BuildP <= 0 {\n+\t\tbase.Fatalf(\"go: -p must be a positive integer: %v\\n\", cfg.BuildP)\n+\t}\n+\n+\t// Make sure CC, CXX, and FC are absolute paths.\n+\tfor _, key := range []string{\"CC\", \"CXX\", \"FC\"} {\n+\t\tvalue := cfg.Getenv(key)\n+\t\targs, err := quoted.Split(value)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %s environment variable could not be parsed: %v\", key, err)\n \t\t}\n+\t\tif len(args) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tpath := args[0]\n+\t\tif !filepath.IsAbs(path) && path != filepath.Base(path) {\n+\t\t\tbase.Fatalf(\"go: %s environment variable is relative; must be absolute path: %s\\n\", key, path)\n+\t\t}\n+\t}\n+}\n+\n+// fuzzInstrumentFlags returns compiler flags that enable fuzzing instrumation\n+// on supported platforms.\n+//\n+// On unsupported platforms, fuzzInstrumentFlags returns nil, meaning no\n+// instrumentation is added. 'go test -fuzz' still works without coverage,\n+// but it generates random inputs without guidance, so it's much less effective.\n+func fuzzInstrumentFlags() []string {\n+\tif !sys.FuzzInstrumented(cfg.Goos, cfg.Goarch) {\n+\t\treturn nil\n \t}\n+\treturn []string{\"-d=libfuzzer\"}\n }\n \n func instrumentInit() {\n-\tif !cfg.BuildRace && !cfg.BuildMSan {\n+\tif !cfg.BuildRace && !cfg.BuildMSan && !cfg.BuildASan {\n \t\treturn\n \t}\n \tif cfg.BuildRace && cfg.BuildMSan {\n-\t\tfmt.Fprintf(os.Stderr, \"go %s: may not use -race and -msan simultaneously\\n\", flag.Args()[0])\n+\t\tfmt.Fprintf(os.Stderr, \"go: may not use -race and -msan simultaneously\\n\")\n+\t\tbase.SetExitStatus(2)\n+\t\tbase.Exit()\n+\t}\n+\tif cfg.BuildRace && cfg.BuildASan {\n+\t\tfmt.Fprintf(os.Stderr, \"go: may not use -race and -asan simultaneously\\n\")\n+\t\tbase.SetExitStatus(2)\n+\t\tbase.Exit()\n+\t}\n+\tif cfg.BuildMSan && cfg.BuildASan {\n+\t\tfmt.Fprintf(os.Stderr, \"go: may not use -msan and -asan simultaneously\\n\")\n \t\tbase.SetExitStatus(2)\n \t\tbase.Exit()\n \t}\n@@ -61,12 +97,15 @@ func instrumentInit() {\n \t\tbase.SetExitStatus(2)\n \t\tbase.Exit()\n \t}\n-\tif cfg.BuildRace {\n-\t\tif !sys.RaceDetectorSupported(cfg.Goos, cfg.Goarch) {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go %s: -race is only supported on linux/amd64, linux/ppc64le, linux/arm64, freebsd/amd64, netbsd/amd64, darwin/amd64, darwin/arm64, and windows/amd64\\n\", flag.Args()[0])\n-\t\t\tbase.SetExitStatus(2)\n-\t\t\tbase.Exit()\n-\t\t}\n+\tif cfg.BuildRace && !sys.RaceDetectorSupported(cfg.Goos, cfg.Goarch) {\n+\t\tfmt.Fprintf(os.Stderr, \"-race is not supported on %s/%s\\n\", cfg.Goos, cfg.Goarch)\n+\t\tbase.SetExitStatus(2)\n+\t\tbase.Exit()\n+\t}\n+\tif cfg.BuildASan && !sys.ASanSupported(cfg.Goos, cfg.Goarch) {\n+\t\tfmt.Fprintf(os.Stderr, \"-asan is not supported on %s/%s\\n\", cfg.Goos, cfg.Goarch)\n+\t\tbase.SetExitStatus(2)\n+\t\tbase.Exit()\n \t}\n \tmode := \"race\"\n \tif cfg.BuildMSan {\n@@ -77,13 +116,16 @@ func instrumentInit() {\n \t\t\tcfg.BuildBuildmode = \"pie\"\n \t\t}\n \t}\n+\tif cfg.BuildASan {\n+\t\tmode = \"asan\"\n+\t}\n \tmodeFlag := \"-\" + mode\n \n \tif !cfg.BuildContext.CgoEnabled {\n \t\tif runtime.GOOS != cfg.Goos || runtime.GOARCH != cfg.Goarch {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go %s: %s requires cgo\\n\", flag.Args()[0], modeFlag)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: %s requires cgo\\n\", modeFlag)\n \t\t} else {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go %s: %s requires cgo; enable cgo by setting CGO_ENABLED=1\\n\", flag.Args()[0], modeFlag)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: %s requires cgo; enable cgo by setting CGO_ENABLED=1\\n\", modeFlag)\n \t\t}\n \n \t\tbase.SetExitStatus(2)\n@@ -96,7 +138,7 @@ func instrumentInit() {\n \t\tcfg.BuildContext.InstallSuffix += \"_\"\n \t}\n \tcfg.BuildContext.InstallSuffix += mode\n-\tcfg.BuildContext.BuildTags = append(cfg.BuildContext.BuildTags, mode)\n+\tcfg.BuildContext.ToolTags = append(cfg.BuildContext.ToolTags, mode)\n }\n \n func buildModeInit() {"}, {"sha": "a09b65a23c35cd3bc928200faec75f5fa8de334c", "filename": "libgo/go/cmd/go/internal/work/testgo.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,7 +5,6 @@\n // This file contains extra hooks for testing the go command.\n \n //go:build testgo\n-// +build testgo\n \n package work\n "}, {"sha": "c42000710e0f5c56d037288f164156d3d7b7e585", "filename": "libgo/go/cmd/go/internal/workcmd/edit.go", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go work edit\n+\n+package workcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\n+\t\"golang.org/x/mod/module\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+)\n+\n+var cmdEdit = &base.Command{\n+\tUsageLine: \"go work edit [editing flags] [go.work]\",\n+\tShort:     \"edit go.work from tools or scripts\",\n+\tLong: `Edit provides a command-line interface for editing go.work,\n+for use primarily by tools or scripts. It only reads go.work;\n+it does not look up information about the modules involved.\n+If no file is specified, Edit looks for a go.work file in the current\n+directory and its parent directories\n+\n+The editing flags specify a sequence of editing operations.\n+\n+The -fmt flag reformats the go.work file without making other changes.\n+This reformatting is also implied by any other modifications that use or\n+rewrite the go.mod file. The only time this flag is needed is if no other\n+flags are specified, as in 'go work edit -fmt'.\n+\n+The -use=path and -dropuse=path flags\n+add and drop a use directive from the go.work file's set of module directories.\n+\n+The -replace=old[@v]=new[@v] flag adds a replacement of the given\n+module path and version pair. If the @v in old@v is omitted, a\n+replacement without a version on the left side is added, which applies\n+to all versions of the old module path. If the @v in new@v is omitted,\n+the new path should be a local module root directory, not a module\n+path. Note that -replace overrides any redundant replacements for old[@v],\n+so omitting @v will drop existing replacements for specific versions.\n+\n+The -dropreplace=old[@v] flag drops a replacement of the given\n+module path and version pair. If the @v is omitted, a replacement without\n+a version on the left side is dropped.\n+\n+The -use, -dropuse, -replace, and -dropreplace,\n+editing flags may be repeated, and the changes are applied in the order given.\n+\n+The -go=version flag sets the expected Go language version.\n+\n+The -print flag prints the final go.work in its text format instead of\n+writing it back to go.mod.\n+\n+The -json flag prints the final go.work file in JSON format instead of\n+writing it back to go.mod. The JSON output corresponds to these Go types:\n+\n+\ttype Module struct {\n+\t\tPath    string\n+\t\tVersion string\n+\t}\n+\n+\ttype GoWork struct {\n+\t\tGo        string\n+\t\tDirectory []Directory\n+\t\tReplace   []Replace\n+\t}\n+\n+\ttype Use struct {\n+\t\tPath       string\n+\t\tModulePath string\n+\t}\n+\n+\ttype Replace struct {\n+\t\tOld Module\n+\t\tNew Module\n+\t}\n+\n+See the workspaces design proposal at\n+https://go.googlesource.com/proposal/+/master/design/45713-workspace.md for\n+more information.\n+`,\n+}\n+\n+var (\n+\teditFmt   = cmdEdit.Flag.Bool(\"fmt\", false, \"\")\n+\teditGo    = cmdEdit.Flag.String(\"go\", \"\", \"\")\n+\teditJSON  = cmdEdit.Flag.Bool(\"json\", false, \"\")\n+\teditPrint = cmdEdit.Flag.Bool(\"print\", false, \"\")\n+\tworkedits []func(file *modfile.WorkFile) // edits specified in flags\n+)\n+\n+type flagFunc func(string)\n+\n+func (f flagFunc) String() string     { return \"\" }\n+func (f flagFunc) Set(s string) error { f(s); return nil }\n+\n+func init() {\n+\tcmdEdit.Run = runEditwork // break init cycle\n+\n+\tcmdEdit.Flag.Var(flagFunc(flagEditworkUse), \"use\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagEditworkDropUse), \"dropuse\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagEditworkReplace), \"replace\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagEditworkDropReplace), \"dropreplace\", \"\")\n+\n+\tbase.AddWorkfileFlag(&cmdEdit.Flag)\n+}\n+\n+func runEditwork(ctx context.Context, cmd *base.Command, args []string) {\n+\tanyFlags :=\n+\t\t*editGo != \"\" ||\n+\t\t\t*editJSON ||\n+\t\t\t*editPrint ||\n+\t\t\t*editFmt ||\n+\t\t\tlen(workedits) > 0\n+\n+\tif !anyFlags {\n+\t\tbase.Fatalf(\"go: no flags specified (see 'go help work edit').\")\n+\t}\n+\n+\tif *editJSON && *editPrint {\n+\t\tbase.Fatalf(\"go: cannot use both -json and -print\")\n+\t}\n+\n+\tif len(args) > 1 {\n+\t\tbase.Fatalf(\"go: 'go help work edit' accepts at most one argument\")\n+\t}\n+\tvar gowork string\n+\tif len(args) == 1 {\n+\t\tgowork = args[0]\n+\t} else {\n+\t\tmodload.InitWorkfile()\n+\t\tgowork = modload.WorkFilePath()\n+\t}\n+\n+\tif *editGo != \"\" {\n+\t\tif !modfile.GoVersionRE.MatchString(*editGo) {\n+\t\t\tbase.Fatalf(`go mod: invalid -go option; expecting something like \"-go %s\"`, modload.LatestGoVersion())\n+\t\t}\n+\t}\n+\n+\tworkFile, err := modload.ReadWorkFile(gowork)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: errors parsing %s:\\n%s\", base.ShortPath(gowork), err)\n+\t}\n+\n+\tif *editGo != \"\" {\n+\t\tif err := workFile.AddGoStmt(*editGo); err != nil {\n+\t\t\tbase.Fatalf(\"go: internal error: %v\", err)\n+\t\t}\n+\t}\n+\n+\tif len(workedits) > 0 {\n+\t\tfor _, edit := range workedits {\n+\t\t\tedit(workFile)\n+\t\t}\n+\t}\n+\n+\tmodload.UpdateWorkFile(workFile)\n+\n+\tworkFile.SortBlocks()\n+\tworkFile.Cleanup() // clean file after edits\n+\n+\tif *editJSON {\n+\t\teditPrintJSON(workFile)\n+\t\treturn\n+\t}\n+\n+\tif *editPrint {\n+\t\tos.Stdout.Write(modfile.Format(workFile.Syntax))\n+\t\treturn\n+\t}\n+\n+\tmodload.WriteWorkFile(gowork, workFile)\n+}\n+\n+// flagEditworkUse implements the -use flag.\n+func flagEditworkUse(arg string) {\n+\tworkedits = append(workedits, func(f *modfile.WorkFile) {\n+\t\t_, mf, err := modload.ReadModFile(filepath.Join(arg, \"go.mod\"), nil)\n+\t\tmodulePath := \"\"\n+\t\tif err == nil {\n+\t\t\tmodulePath = mf.Module.Mod.Path\n+\t\t}\n+\t\tf.AddUse(modload.ToDirectoryPath(arg), modulePath)\n+\t\tif err := f.AddUse(modload.ToDirectoryPath(arg), \"\"); err != nil {\n+\t\t\tbase.Fatalf(\"go: -use=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagEditworkDropUse implements the -dropuse flag.\n+func flagEditworkDropUse(arg string) {\n+\tworkedits = append(workedits, func(f *modfile.WorkFile) {\n+\t\tif err := f.DropUse(modload.ToDirectoryPath(arg)); err != nil {\n+\t\t\tbase.Fatalf(\"go: -dropdirectory=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// allowedVersionArg returns whether a token may be used as a version in go.mod.\n+// We don't call modfile.CheckPathVersion, because that insists on versions\n+// being in semver form, but here we want to allow versions like \"master\" or\n+// \"1234abcdef\", which the go command will resolve the next time it runs (or\n+// during -fix).  Even so, we need to make sure the version is a valid token.\n+func allowedVersionArg(arg string) bool {\n+\treturn !modfile.MustQuote(arg)\n+}\n+\n+// parsePathVersionOptional parses path[@version], using adj to\n+// describe any errors.\n+func parsePathVersionOptional(adj, arg string, allowDirPath bool) (path, version string, err error) {\n+\tif i := strings.Index(arg, \"@\"); i < 0 {\n+\t\tpath = arg\n+\t} else {\n+\t\tpath, version = strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n+\t}\n+\tif err := module.CheckImportPath(path); err != nil {\n+\t\tif !allowDirPath || !modfile.IsDirectoryPath(path) {\n+\t\t\treturn path, version, fmt.Errorf(\"invalid %s path: %v\", adj, err)\n+\t\t}\n+\t}\n+\tif path != arg && !allowedVersionArg(version) {\n+\t\treturn path, version, fmt.Errorf(\"invalid %s version: %q\", adj, version)\n+\t}\n+\treturn path, version, nil\n+}\n+\n+// flagReplace implements the -replace flag.\n+func flagEditworkReplace(arg string) {\n+\tvar i int\n+\tif i = strings.Index(arg, \"=\"); i < 0 {\n+\t\tbase.Fatalf(\"go: -replace=%s: need old[@v]=new[@w] (missing =)\", arg)\n+\t}\n+\told, new := strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n+\tif strings.HasPrefix(new, \">\") {\n+\t\tbase.Fatalf(\"go: -replace=%s: separator between old and new is =, not =>\", arg)\n+\t}\n+\toldPath, oldVersion, err := parsePathVersionOptional(\"old\", old, false)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: -replace=%s: %v\", arg, err)\n+\t}\n+\tnewPath, newVersion, err := parsePathVersionOptional(\"new\", new, true)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: -replace=%s: %v\", arg, err)\n+\t}\n+\tif newPath == new && !modfile.IsDirectoryPath(new) {\n+\t\tbase.Fatalf(\"go: -replace=%s: unversioned new path must be local directory\", arg)\n+\t}\n+\n+\tworkedits = append(workedits, func(f *modfile.WorkFile) {\n+\t\tif err := f.AddReplace(oldPath, oldVersion, newPath, newVersion); err != nil {\n+\t\t\tbase.Fatalf(\"go: -replace=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagDropReplace implements the -dropreplace flag.\n+func flagEditworkDropReplace(arg string) {\n+\tpath, version, err := parsePathVersionOptional(\"old\", arg, true)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: -dropreplace=%s: %v\", arg, err)\n+\t}\n+\tworkedits = append(workedits, func(f *modfile.WorkFile) {\n+\t\tif err := f.DropReplace(path, version); err != nil {\n+\t\t\tbase.Fatalf(\"go: -dropreplace=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+type replaceJSON struct {\n+\tOld module.Version\n+\tNew module.Version\n+}\n+\n+// editPrintJSON prints the -json output.\n+func editPrintJSON(workFile *modfile.WorkFile) {\n+\tvar f workfileJSON\n+\tif workFile.Go != nil {\n+\t\tf.Go = workFile.Go.Version\n+\t}\n+\tfor _, d := range workFile.Use {\n+\t\tf.Use = append(f.Use, useJSON{DiskPath: d.Path, ModPath: d.ModulePath})\n+\t}\n+\n+\tfor _, r := range workFile.Replace {\n+\t\tf.Replace = append(f.Replace, replaceJSON{r.Old, r.New})\n+\t}\n+\tdata, err := json.MarshalIndent(&f, \"\", \"\\t\")\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: internal error: %v\", err)\n+\t}\n+\tdata = append(data, '\\n')\n+\tos.Stdout.Write(data)\n+}\n+\n+// workfileJSON is the -json output data structure.\n+type workfileJSON struct {\n+\tGo      string `json:\",omitempty\"`\n+\tUse     []useJSON\n+\tReplace []replaceJSON\n+}\n+\n+type useJSON struct {\n+\tDiskPath string\n+\tModPath  string `json:\",omitempty\"`\n+}"}, {"sha": "cefecee8329dea1ec8f8ec56c8eb66942107bbb2", "filename": "libgo/go/cmd/go/internal/workcmd/init.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go work init\n+\n+package workcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n+\t\"context\"\n+\t\"path/filepath\"\n+)\n+\n+var cmdInit = &base.Command{\n+\tUsageLine: \"go work init [moddirs]\",\n+\tShort:     \"initialize workspace file\",\n+\tLong: `Init initializes and writes a new go.work file in the\n+current directory, in effect creating a new workspace at the current\n+directory.\n+\n+go work init optionally accepts paths to the workspace modules as\n+arguments. If the argument is omitted, an empty workspace with no\n+modules will be created.\n+\n+Each argument path is added to a use directive in the go.work file. The\n+current go version will also be listed in the go.work file.\n+\n+`,\n+\tRun: runInit,\n+}\n+\n+func init() {\n+\tbase.AddModCommonFlags(&cmdInit.Flag)\n+\tbase.AddWorkfileFlag(&cmdInit.Flag)\n+}\n+\n+func runInit(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n+\tmodload.ForceUseModules = true\n+\n+\t// TODO(matloob): support using the -workfile path\n+\t// To do that properly, we'll have to make the module directories\n+\t// make dirs relative to workFile path before adding the paths to\n+\t// the directory entries\n+\n+\tworkFile := filepath.Join(base.Cwd(), \"go.work\")\n+\n+\tmodload.CreateWorkFile(ctx, workFile, args)\n+}"}, {"sha": "1cca817517c2852ee7f37651a3abcefc94795035", "filename": "libgo/go/cmd/go/internal/workcmd/sync.go", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go work sync\n+\n+package workcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/imports\"\n+\t\"cmd/go/internal/modload\"\n+\t\"context\"\n+\n+\t\"golang.org/x/mod/module\"\n+)\n+\n+var cmdSync = &base.Command{\n+\tUsageLine: \"go work sync\",\n+\tShort:     \"sync workspace build list to modules\",\n+\tLong: `Sync syncs the workspace's build list back to the\n+workspace's modules\n+\n+The workspace's build list is the set of versions of all the\n+(transitive) dependency modules used to do builds in the workspace. go\n+work sync generates that build list using the Minimal Version Selection\n+algorithm, and then syncs those versions back to each of modules\n+specified in the workspace (with use directives).\n+\n+The syncing is done by sequentially upgrading each of the dependency\n+modules specified in a workspace module to the version in the build list\n+if the dependency module's version is not already the same as the build\n+list's version. Note that Minimal Version Selection guarantees that the\n+build list's version of each module is always the same or higher than\n+that in each workspace module.\n+`,\n+\tRun: runSync,\n+}\n+\n+func init() {\n+\tbase.AddModCommonFlags(&cmdSync.Flag)\n+\tbase.AddWorkfileFlag(&cmdSync.Flag)\n+}\n+\n+func runSync(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n+\tmodload.ForceUseModules = true\n+\n+\tworkGraph := modload.LoadModGraph(ctx, \"\")\n+\t_ = workGraph\n+\tmustSelectFor := map[module.Version][]module.Version{}\n+\n+\tmms := modload.MainModules\n+\n+\topts := modload.PackageOpts{\n+\t\tTags:                     imports.AnyTags(),\n+\t\tVendorModulesInGOROOTSrc: true,\n+\t\tResolveMissingImports:    false,\n+\t\tLoadTests:                true,\n+\t\tAllowErrors:              true,\n+\t\tSilencePackageErrors:     true,\n+\t\tSilenceUnmatchedWarnings: true,\n+\t}\n+\tfor _, m := range mms.Versions() {\n+\t\topts.MainModule = m\n+\t\t_, pkgs := modload.LoadPackages(ctx, opts, \"all\")\n+\t\topts.MainModule = module.Version{} // reset\n+\n+\t\tvar (\n+\t\t\tmustSelect   []module.Version\n+\t\t\tinMustSelect = map[module.Version]bool{}\n+\t\t)\n+\t\tfor _, pkg := range pkgs {\n+\t\t\tif r := modload.PackageModule(pkg); r.Version != \"\" && !inMustSelect[r] {\n+\t\t\t\t// r has a known version, so force that version.\n+\t\t\t\tmustSelect = append(mustSelect, r)\n+\t\t\t\tinMustSelect[r] = true\n+\t\t\t}\n+\t\t}\n+\t\tmodule.Sort(mustSelect) // ensure determinism\n+\t\tmustSelectFor[m] = mustSelect\n+\t}\n+\n+\tworkFilePath := modload.WorkFilePath() // save go.work path because EnterModule clobbers it.\n+\n+\tfor _, m := range mms.Versions() {\n+\t\tif mms.ModRoot(m) == \"\" && m.Path == \"command-line-arguments\" {\n+\t\t\t// This is not a real module.\n+\t\t\t// TODO(#49228): Remove this special case once the special\n+\t\t\t// command-line-arguments module is gone.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Use EnterModule to reset the global state in modload to be in\n+\t\t// single-module mode using the modroot of m.\n+\t\tmodload.EnterModule(ctx, mms.ModRoot(m))\n+\n+\t\t// Edit the build list in the same way that 'go get' would if we\n+\t\t// requested the relevant module versions explicitly.\n+\t\tchanged, err := modload.EditBuildList(ctx, nil, mustSelectFor[m])\n+\t\tif err != nil {\n+\t\t\tbase.Errorf(\"go: %v\", err)\n+\t\t}\n+\t\tif !changed {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tmodload.LoadPackages(ctx, modload.PackageOpts{\n+\t\t\tTags:                     imports.AnyTags(),\n+\t\t\tTidy:                     true,\n+\t\t\tVendorModulesInGOROOTSrc: true,\n+\t\t\tResolveMissingImports:    false,\n+\t\t\tLoadTests:                true,\n+\t\t\tAllowErrors:              true,\n+\t\t\tSilenceMissingStdImports: true,\n+\t\t\tSilencePackageErrors:     true,\n+\t\t}, \"all\")\n+\t\tmodload.WriteGoMod(ctx)\n+\t}\n+\n+\twf, err := modload.ReadWorkFile(workFilePath)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\tmodload.UpdateWorkFile(wf)\n+\tif err := modload.WriteWorkFile(workFilePath, wf); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+}"}, {"sha": "852e5b910c26074204ddf42249003583c54849c8", "filename": "libgo/go/cmd/go/internal/workcmd/use.go", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go work use\n+\n+package workcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/fsys\"\n+\t\"cmd/go/internal/modload\"\n+\t\"context\"\n+\t\"io/fs\"\n+\t\"os\"\n+\t\"path/filepath\"\n+)\n+\n+var cmdUse = &base.Command{\n+\tUsageLine: \"go work use [-r] [moddirs]\",\n+\tShort:     \"add modules to workspace file\",\n+\tLong: `Use provides a command-line interface for adding\n+directories, optionally recursively, to a go.work file.\n+\n+A use directive will be added to the go.work file for each argument\n+directory listed on the command line go.work file, if it exists on disk,\n+or removed from the go.work file if it does not exist on disk.\n+\n+The -r flag searches recursively for modules in the argument\n+directories, and the use command operates as if each of the directories\n+were specified as arguments: namely, use directives will be added for\n+directories that exist, and removed for directories that do not exist.\n+`,\n+}\n+\n+var useR = cmdUse.Flag.Bool(\"r\", false, \"\")\n+\n+func init() {\n+\tcmdUse.Run = runUse // break init cycle\n+\n+\tbase.AddModCommonFlags(&cmdUse.Flag)\n+\tbase.AddWorkfileFlag(&cmdUse.Flag)\n+}\n+\n+func runUse(ctx context.Context, cmd *base.Command, args []string) {\n+\tmodload.InitWorkfile()\n+\n+\tmodload.ForceUseModules = true\n+\n+\tvar gowork string\n+\tmodload.InitWorkfile()\n+\tgowork = modload.WorkFilePath()\n+\n+\tworkFile, err := modload.ReadWorkFile(gowork)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n+\thaveDirs := make(map[string]bool)\n+\tfor _, dir := range workFile.Use {\n+\t\thaveDirs[filepath.Join(filepath.Dir(gowork), filepath.FromSlash(dir.Path))] = true\n+\t}\n+\n+\taddDirs := make(map[string]bool)\n+\tremoveDirs := make(map[string]bool)\n+\tlookDir := func(dir string) {\n+\t\tabsDir := filepath.Join(base.Cwd(), dir)\n+\t\t// If the path is absolute, keep it absolute. If it's relative,\n+\t\t// make it relative to the go.work file rather than the working directory.\n+\t\tif !filepath.IsAbs(dir) {\n+\t\t\trel, err := filepath.Rel(filepath.Dir(gowork), absDir)\n+\t\t\tif err == nil {\n+\t\t\t\tdir = rel\n+\t\t\t}\n+\t\t}\n+\t\tfi, err := os.Stat(filepath.Join(dir, \"go.mod\"))\n+\t\tif err != nil {\n+\t\t\tif os.IsNotExist(err) {\n+\n+\t\t\t\tif haveDirs[absDir] {\n+\t\t\t\t\tremoveDirs[dir] = true\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tbase.Errorf(\"go: %v\", err)\n+\t\t}\n+\n+\t\tif !fi.Mode().IsRegular() {\n+\t\t\tbase.Errorf(\"go: %v is not regular\", filepath.Join(dir, \"go.mod\"))\n+\t\t}\n+\n+\t\tif !haveDirs[absDir] {\n+\t\t\taddDirs[dir] = true\n+\t\t}\n+\t}\n+\n+\tfor _, useDir := range args {\n+\t\tif *useR {\n+\t\t\tfsys.Walk(useDir, func(path string, info fs.FileInfo, err error) error {\n+\t\t\t\tif !info.IsDir() {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\tlookDir(path)\n+\t\t\t\treturn nil\n+\t\t\t})\n+\t\t\tcontinue\n+\t\t}\n+\t\tlookDir(useDir)\n+\t}\n+\n+\tfor dir := range removeDirs {\n+\t\tworkFile.DropUse(filepath.ToSlash(dir))\n+\t}\n+\tfor dir := range addDirs {\n+\t\tworkFile.AddUse(filepath.ToSlash(dir), \"\")\n+\t}\n+\tmodload.UpdateWorkFile(workFile)\n+\tmodload.WriteWorkFile(gowork, workFile)\n+}"}, {"sha": "5bb0a2e8badb5c593f086cdb6d6ace46a493fd44", "filename": "libgo/go/cmd/go/internal/workcmd/work.go", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package workcmd implements the ``go work'' command.\n+package workcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+)\n+\n+var CmdWork = &base.Command{\n+\tUsageLine: \"go work\",\n+\tShort:     \"workspace maintenance\",\n+\tLong: `Go workspace provides access to operations on workspaces.\n+\n+Note that support for workspaces is built into many other commands, not\n+just 'go work'.\n+\n+See 'go help modules' for information about Go's module system of which\n+workspaces are a part.\n+\n+A workspace is specified by a go.work file that specifies a set of\n+module directories with the \"use\" directive. These modules are used as\n+root modules by the go command for builds and related operations.  A\n+workspace that does not specify modules to be used cannot be used to do\n+builds from local modules.\n+\n+go.work files are line-oriented. Each line holds a single directive,\n+made up of a keyword followed by aruments. For example:\n+\n+\tgo 1.18\n+\n+\tuse ../foo/bar\n+\tuse ./baz\n+\n+\treplace example.com/foo v1.2.3 => example.com/bar v1.4.5\n+\n+The leading keyword can be factored out of adjacent lines to create a block,\n+like in Go imports.\n+\n+\tuse (\n+\t  ../foo/bar\n+\t  ./baz\n+\t)\n+\n+The use directive specifies a module to be included in the workspace's\n+set of main modules. The argument to the use directive is the directory\n+containing the module's go.mod file.\n+\n+The go directive specifies the version of Go the file was written at. It\n+is possible there may be future changes in the semantics of workspaces\n+that could be controlled by this version, but for now the version\n+specified has no effect.\n+\n+The replace directive has the same syntax as the replace directive in a\n+go.mod file and takes precedence over replaces in go.mod files.  It is\n+primarily intended to override conflicting replaces in different workspace\n+modules.\n+\n+To determine whether the go command is operating in workspace mode, use\n+the \"go env GOWORK\" command. This will specify the workspace file being\n+used.\n+`,\n+\n+\tCommands: []*base.Command{\n+\t\tcmdEdit,\n+\t\tcmdInit,\n+\t\tcmdSync,\n+\t\tcmdUse,\n+\t},\n+}"}, {"sha": "d7034084dc840412caa892b9d01b299405d7b0de", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -7,6 +7,7 @@\n package main\n \n import (\n+\t\"cmd/go/internal/workcmd\"\n \t\"context\"\n \t\"flag\"\n \t\"fmt\"\n@@ -56,6 +57,7 @@ func init() {\n \t\twork.CmdInstall,\n \t\tlist.CmdList,\n \t\tmodcmd.CmdMod,\n+\t\tworkcmd.CmdWork,\n \t\trun.CmdRun,\n \t\ttest.CmdTest,\n \t\ttool.CmdTool,"}, {"sha": "517a88554282de5f133b8fc1196e112abf5a0d87", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -25,12 +25,12 @@ import (\n \n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/txtar\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n \t\"golang.org/x/mod/sumdb\"\n \t\"golang.org/x/mod/sumdb/dirhash\"\n+\t\"golang.org/x/tools/txtar\"\n )\n \n var (\n@@ -357,7 +357,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\tzip []byte\n \t\t\terr error\n \t\t}\n-\t\tc := zipCache.Do(a, func() interface{} {\n+\t\tc := zipCache.Do(a, func() any {\n \t\t\tvar buf bytes.Buffer\n \t\t\tz := zip.NewWriter(&buf)\n \t\t\tfor _, f := range a.Files {\n@@ -431,7 +431,7 @@ func readArchive(path, vers string) (*txtar.Archive, error) {\n \n \tprefix := strings.ReplaceAll(enc, \"/\", \"_\")\n \tname := filepath.Join(cmdGoDir, \"testdata/mod\", prefix+\"_\"+encVers+\".txt\")\n-\ta := archiveCache.Do(name, func() interface{} {\n+\ta := archiveCache.Do(name, func() any {\n \t\ta, err := txtar.ParseFile(name)\n \t\tif err != nil {\n \t\t\tif testing.Verbose() || !os.IsNotExist(err) {"}, {"sha": "0fc4b0f7abd0fc104a7ff26b5f4b85a16a7268b3", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 209, "deletions": 23, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"errors\"\n+\t\"flag\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"internal/testenv\"\n@@ -30,11 +31,14 @@ import (\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/robustio\"\n-\t\"cmd/go/internal/txtar\"\n \t\"cmd/go/internal/work\"\n \t\"cmd/internal/sys\"\n+\n+\t\"golang.org/x/tools/txtar\"\n )\n \n+var testSum = flag.String(\"testsum\", \"\", `may be tidy, listm, or listall. If set, TestScript generates a go.sum file at the beginning of each test and updates test files if they pass.`)\n+\n // TestScript runs the tests in testdata/script/*.txt.\n func TestScript(t *testing.T) {\n \ttestenv.MustHaveGoBuild(t)\n@@ -181,6 +185,7 @@ func (ts *testScript) setup() {\n \t\t\"devnull=\" + os.DevNull,\n \t\t\"goversion=\" + goVersion(ts),\n \t\t\":=\" + string(os.PathListSeparator),\n+\t\t\"/=\" + string(os.PathSeparator),\n \t}\n \tif !testenv.HasExternalNetwork() {\n \t\tts.env = append(ts.env, \"TESTGONETWORK=panic\", \"TESTGOVCS=panic\")\n@@ -269,6 +274,22 @@ func (ts *testScript) run() {\n \t\tts.mark = ts.log.Len()\n \t}\n \n+\t// With -testsum, if a go.mod file is present in the test's initial\n+\t// working directory, run 'go mod tidy'.\n+\tif *testSum != \"\" {\n+\t\tif ts.updateSum(a) {\n+\t\t\tdefer func() {\n+\t\t\t\tif ts.t.Failed() {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tdata := txtar.Format(a)\n+\t\t\t\tif err := os.WriteFile(ts.file, data, 0666); err != nil {\n+\t\t\t\t\tts.t.Errorf(\"rewriting test file: %v\", err)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t}\n+\t}\n+\n \t// Run script.\n \t// See testdata/script/README for documentation of script form.\n \tscript := string(a.Comment)\n@@ -332,8 +353,14 @@ Script:\n \t\t\t\tok = canCgo\n \t\t\tcase \"msan\":\n \t\t\t\tok = canMSan\n+\t\t\tcase \"asan\":\n+\t\t\t\tok = canASan\n \t\t\tcase \"race\":\n \t\t\t\tok = canRace\n+\t\t\tcase \"fuzz\":\n+\t\t\t\tok = canFuzz\n+\t\t\tcase \"fuzz-instrumented\":\n+\t\t\t\tok = fuzzInstrumented\n \t\t\tcase \"net\":\n \t\t\t\tok = testenv.HasExternalNetwork()\n \t\t\tcase \"link\":\n@@ -347,7 +374,7 @@ Script:\n \t\t\tdefault:\n \t\t\t\tif strings.HasPrefix(cond.tag, \"exec:\") {\n \t\t\t\t\tprog := cond.tag[len(\"exec:\"):]\n-\t\t\t\t\tok = execCache.Do(prog, func() interface{} {\n+\t\t\t\t\tok = execCache.Do(prog, func() any {\n \t\t\t\t\t\tif runtime.GOOS == \"plan9\" && prog == \"git\" {\n \t\t\t\t\t\t\t// The Git command is usually not the real Git on Plan 9.\n \t\t\t\t\t\t\t// See https://golang.org/issues/29640.\n@@ -464,6 +491,7 @@ var scriptCmds = map[string]func(*testScript, simpleStatus, []string){\n \t\"go\":      (*testScript).cmdGo,\n \t\"grep\":    (*testScript).cmdGrep,\n \t\"mkdir\":   (*testScript).cmdMkdir,\n+\t\"mv\":      (*testScript).cmdMv,\n \t\"rm\":      (*testScript).cmdRm,\n \t\"skip\":    (*testScript).cmdSkip,\n \t\"stale\":   (*testScript).cmdStale,\n@@ -558,10 +586,6 @@ func (ts *testScript) cmdChmod(want simpleStatus, args []string) {\n \n // cmp compares two files.\n func (ts *testScript) cmdCmp(want simpleStatus, args []string) {\n-\tif want != success {\n-\t\t// It would be strange to say \"this file can have any content except this precise byte sequence\".\n-\t\tts.fatalf(\"unsupported: %v cmp\", want)\n-\t}\n \tquiet := false\n \tif len(args) > 0 && args[0] == \"-q\" {\n \t\tquiet = true\n@@ -570,14 +594,11 @@ func (ts *testScript) cmdCmp(want simpleStatus, args []string) {\n \tif len(args) != 2 {\n \t\tts.fatalf(\"usage: cmp file1 file2\")\n \t}\n-\tts.doCmdCmp(args, false, quiet)\n+\tts.doCmdCmp(want, args, false, quiet)\n }\n \n // cmpenv compares two files with environment variable substitution.\n func (ts *testScript) cmdCmpenv(want simpleStatus, args []string) {\n-\tif want != success {\n-\t\tts.fatalf(\"unsupported: %v cmpenv\", want)\n-\t}\n \tquiet := false\n \tif len(args) > 0 && args[0] == \"-q\" {\n \t\tquiet = true\n@@ -586,17 +607,18 @@ func (ts *testScript) cmdCmpenv(want simpleStatus, args []string) {\n \tif len(args) != 2 {\n \t\tts.fatalf(\"usage: cmpenv file1 file2\")\n \t}\n-\tts.doCmdCmp(args, true, quiet)\n+\tts.doCmdCmp(want, args, true, quiet)\n }\n \n-func (ts *testScript) doCmdCmp(args []string, env, quiet bool) {\n+func (ts *testScript) doCmdCmp(want simpleStatus, args []string, env, quiet bool) {\n \tname1, name2 := args[0], args[1]\n \tvar text1, text2 string\n-\tif name1 == \"stdout\" {\n+\tswitch name1 {\n+\tcase \"stdout\":\n \t\ttext1 = ts.stdout\n-\t} else if name1 == \"stderr\" {\n+\tcase \"stderr\":\n \t\ttext1 = ts.stderr\n-\t} else {\n+\tdefault:\n \t\tdata, err := os.ReadFile(ts.mkabs(name1))\n \t\tts.check(err)\n \t\ttext1 = string(data)\n@@ -611,14 +633,28 @@ func (ts *testScript) doCmdCmp(args []string, env, quiet bool) {\n \t\ttext2 = ts.expand(text2, false)\n \t}\n \n-\tif text1 == text2 {\n-\t\treturn\n-\t}\n-\n-\tif !quiet {\n+\teq := text1 == text2\n+\tif !eq && !quiet && want != failure {\n \t\tfmt.Fprintf(&ts.log, \"[diff -%s +%s]\\n%s\\n\", name1, name2, diff(text1, text2))\n \t}\n-\tts.fatalf(\"%s and %s differ\", name1, name2)\n+\tswitch want {\n+\tcase failure:\n+\t\tif eq {\n+\t\t\tts.fatalf(\"%s and %s do not differ\", name1, name2)\n+\t\t}\n+\tcase success:\n+\t\tif !eq {\n+\t\t\tts.fatalf(\"%s and %s differ\", name1, name2)\n+\t\t}\n+\tcase successOrFailure:\n+\t\tif eq {\n+\t\t\tfmt.Fprintf(&ts.log, \"%s and %s do not differ\", name1, name2)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(&ts.log, \"%s and %s differ\", name1, name2)\n+\t\t}\n+\tdefault:\n+\t\tts.fatalf(\"unsupported: %v cmp\", want)\n+\t}\n }\n \n // cp copies files, maybe eventually directories.\n@@ -813,6 +849,16 @@ func (ts *testScript) cmdMkdir(want simpleStatus, args []string) {\n \t}\n }\n \n+func (ts *testScript) cmdMv(want simpleStatus, args []string) {\n+\tif want != success {\n+\t\tts.fatalf(\"unsupported: %v mv\", want)\n+\t}\n+\tif len(args) != 2 {\n+\t\tts.fatalf(\"usage: mv old new\")\n+\t}\n+\tts.check(os.Rename(ts.mkabs(args[0]), ts.mkabs(args[1])))\n+}\n+\n // rm removes files or directories.\n func (ts *testScript) cmdRm(want simpleStatus, args []string) {\n \tif want != success {\n@@ -1109,6 +1155,17 @@ func (ts *testScript) startBackground(want simpleStatus, command string, args ..\n \t\tdone: done,\n \t}\n \n+\t// Use the script's PATH to look up the command if it contains a separator\n+\t// instead of the test process's PATH (see lookPath).\n+\t// Don't use filepath.Clean, since that changes \"./foo\" to \"foo\".\n+\tcommand = filepath.FromSlash(command)\n+\tif !strings.Contains(command, string(filepath.Separator)) {\n+\t\tvar err error\n+\t\tcommand, err = ts.lookPath(command)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n \tcmd := exec.Command(command, args...)\n \tcmd.Dir = ts.cd\n \tcmd.Env = append(ts.env, \"PWD=\"+ts.cd)\n@@ -1125,6 +1182,73 @@ func (ts *testScript) startBackground(want simpleStatus, command string, args ..\n \treturn bg, nil\n }\n \n+// lookPath is (roughly) like exec.LookPath, but it uses the test script's PATH\n+// instead of the test process's PATH to find the executable. We don't change\n+// the test process's PATH since it may run scripts in parallel.\n+func (ts *testScript) lookPath(command string) (string, error) {\n+\tvar strEqual func(string, string) bool\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"darwin\" {\n+\t\t// Using GOOS as a proxy for case-insensitive file system.\n+\t\tstrEqual = strings.EqualFold\n+\t} else {\n+\t\tstrEqual = func(a, b string) bool { return a == b }\n+\t}\n+\n+\tvar pathExt []string\n+\tvar searchExt bool\n+\tvar isExecutable func(os.FileInfo) bool\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Use the test process's PathExt instead of the script's.\n+\t\t// If PathExt is set in the command's environment, cmd.Start fails with\n+\t\t// \"parameter is invalid\". Not sure why.\n+\t\t// If the command already has an extension in PathExt (like \"cmd.exe\")\n+\t\t// don't search for other extensions (not \"cmd.bat.exe\").\n+\t\tpathExt = strings.Split(os.Getenv(\"PathExt\"), string(filepath.ListSeparator))\n+\t\tsearchExt = true\n+\t\tcmdExt := filepath.Ext(command)\n+\t\tfor _, ext := range pathExt {\n+\t\t\tif strEqual(cmdExt, ext) {\n+\t\t\t\tsearchExt = false\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tisExecutable = func(fi os.FileInfo) bool {\n+\t\t\treturn fi.Mode().IsRegular()\n+\t\t}\n+\t} else {\n+\t\tisExecutable = func(fi os.FileInfo) bool {\n+\t\t\treturn fi.Mode().IsRegular() && fi.Mode().Perm()&0111 != 0\n+\t\t}\n+\t}\n+\n+\tpathName := \"PATH\"\n+\tif runtime.GOOS == \"plan9\" {\n+\t\tpathName = \"path\"\n+\t}\n+\n+\tfor _, dir := range strings.Split(ts.envMap[pathName], string(filepath.ListSeparator)) {\n+\t\tif searchExt {\n+\t\t\tents, err := os.ReadDir(dir)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor _, ent := range ents {\n+\t\t\t\tfor _, ext := range pathExt {\n+\t\t\t\t\tif !ent.IsDir() && strEqual(ent.Name(), command+ext) {\n+\t\t\t\t\t\treturn dir + string(filepath.Separator) + ent.Name(), nil\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tpath := dir + string(filepath.Separator) + command\n+\t\t\tif fi, err := os.Stat(path); err == nil && isExecutable(fi) {\n+\t\t\t\treturn path, nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn \"\", &exec.Error{Name: command, Err: exec.ErrNotFound}\n+}\n+\n // waitOrStop waits for the already-started command cmd by calling its Wait method.\n //\n // If cmd does not return before ctx is done, waitOrStop sends it the given interrupt signal.\n@@ -1151,7 +1275,7 @@ func waitOrStop(ctx context.Context, cmd *exec.Cmd, interrupt os.Signal, killDel\n \t\terr := cmd.Process.Signal(interrupt)\n \t\tif err == nil {\n \t\t\terr = ctx.Err() // Report ctx.Err() as the reason we interrupted.\n-\t\t} else if err.Error() == \"os: process already finished\" {\n+\t\t} else if err == os.ErrProcessDone {\n \t\t\terrc <- nil\n \t\t\treturn\n \t\t}\n@@ -1204,7 +1328,7 @@ func (ts *testScript) expand(s string, inRegexp bool) string {\n }\n \n // fatalf aborts the test with the given failure message.\n-func (ts *testScript) fatalf(format string, args ...interface{}) {\n+func (ts *testScript) fatalf(format string, args ...any) {\n \tfmt.Fprintf(&ts.log, \"FAIL: %s:%d: %s\\n\", ts.file, ts.lineno, fmt.Sprintf(format, args...))\n \tts.t.FailNow()\n }\n@@ -1341,6 +1465,68 @@ func (ts *testScript) parse(line string) command {\n \treturn cmd\n }\n \n+// updateSum runs 'go mod tidy', 'go list -mod=mod -m all', or\n+// 'go list -mod=mod all' in the test's current directory if a file named\n+// \"go.mod\" is present after the archive has been extracted. updateSum modifies\n+// archive and returns true if go.mod or go.sum were changed.\n+func (ts *testScript) updateSum(archive *txtar.Archive) (rewrite bool) {\n+\tgomodIdx, gosumIdx := -1, -1\n+\tfor i := range archive.Files {\n+\t\tswitch archive.Files[i].Name {\n+\t\tcase \"go.mod\":\n+\t\t\tgomodIdx = i\n+\t\tcase \"go.sum\":\n+\t\t\tgosumIdx = i\n+\t\t}\n+\t}\n+\tif gomodIdx < 0 {\n+\t\treturn false\n+\t}\n+\n+\tswitch *testSum {\n+\tcase \"tidy\":\n+\t\tts.cmdGo(success, []string{\"mod\", \"tidy\"})\n+\tcase \"listm\":\n+\t\tts.cmdGo(success, []string{\"list\", \"-m\", \"-mod=mod\", \"all\"})\n+\tcase \"listall\":\n+\t\tts.cmdGo(success, []string{\"list\", \"-mod=mod\", \"all\"})\n+\tdefault:\n+\t\tts.t.Fatalf(`unknown value for -testsum %q; may be \"tidy\", \"listm\", or \"listall\"`, *testSum)\n+\t}\n+\n+\tnewGomodData, err := os.ReadFile(filepath.Join(ts.cd, \"go.mod\"))\n+\tif err != nil {\n+\t\tts.t.Fatalf(\"reading go.mod after -testsum: %v\", err)\n+\t}\n+\tif !bytes.Equal(newGomodData, archive.Files[gomodIdx].Data) {\n+\t\tarchive.Files[gomodIdx].Data = newGomodData\n+\t\trewrite = true\n+\t}\n+\n+\tnewGosumData, err := os.ReadFile(filepath.Join(ts.cd, \"go.sum\"))\n+\tif err != nil && !os.IsNotExist(err) {\n+\t\tts.t.Fatalf(\"reading go.sum after -testsum: %v\", err)\n+\t}\n+\tswitch {\n+\tcase os.IsNotExist(err) && gosumIdx >= 0:\n+\t\t// go.sum was deleted.\n+\t\trewrite = true\n+\t\tarchive.Files = append(archive.Files[:gosumIdx], archive.Files[gosumIdx+1:]...)\n+\tcase err == nil && gosumIdx < 0:\n+\t\t// go.sum was created.\n+\t\trewrite = true\n+\t\tgosumIdx = gomodIdx + 1\n+\t\tarchive.Files = append(archive.Files, txtar.File{})\n+\t\tcopy(archive.Files[gosumIdx+1:], archive.Files[gosumIdx:])\n+\t\tarchive.Files[gosumIdx] = txtar.File{Name: \"go.sum\", Data: newGosumData}\n+\tcase err == nil && gosumIdx >= 0 && !bytes.Equal(newGosumData, archive.Files[gosumIdx].Data):\n+\t\t// go.sum was changed.\n+\t\trewrite = true\n+\t\tarchive.Files[gosumIdx].Data = newGosumData\n+\t}\n+\treturn rewrite\n+}\n+\n // diff returns a formatted diff of the two texts,\n // showing the entire text and the minimum line-level\n // additions and removals to turn text1 into text2."}, {"sha": "35c12858c1d5e1d36772a0285313c410b7643058", "filename": "libgo/go/cmd/go/stop_other_test.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_other_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_other_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_other_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,15 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build !(aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris)\n-// +build !aix\n-// +build !darwin\n-// +build !dragonfly\n-// +build !freebsd\n-// +build !js !wasm\n-// +build !linux\n-// +build !netbsd\n-// +build !openbsd\n-// +build !solaris\n \n package main_test\n "}, {"sha": "5939f0d40d996777493cc6f64263ed340d71029e", "filename": "libgo/go/cmd/go/stop_unix_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_unix_test.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,7 +3,6 @@\n // license that can be found in the LICENSE file.\n \n //go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris\n-// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris\n \n package main_test\n "}, {"sha": "eac2a7ad449a2fea361545cd27a712bfe0821a92", "filename": "libgo/go/cmd/go/testdata/addmod.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build ignore\n // +build ignore\n \n // Addmod adds a module as a txtar archive to the testdata/mod directory.\n@@ -29,7 +30,7 @@ import (\n \t\"path/filepath\"\n \t\"strings\"\n \n-\t\"cmd/go/internal/txtar\"\n+\t\"golang.org/x/tools/txtar\"\n )\n \n func usage() {\n@@ -39,7 +40,7 @@ func usage() {\n \n var tmpdir string\n \n-func fatalf(format string, args ...interface{}) {\n+func fatalf(format string, args ...any) {\n \tos.RemoveAll(tmpdir)\n \tlog.Fatalf(format, args...)\n }"}, {"sha": "00076d74fc2f8868a1e78de129bcbe6a6fbf1d51", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split-incompatible_v2.0.0+incompatible.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.0.0%2Bincompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.0.0%2Bincompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.0.0%2Bincompatible.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,6 +1,6 @@\n Written by hand.\n Test case for getting a package that has been moved to a nested module,\n-with a +incompatible verison (and thus no go.mod file) at the root module.\n+with a +incompatible version (and thus no go.mod file) at the root module.\n \n -- .mod --\n module example.com/split-incompatible"}, {"sha": "bb1c1fecc9d2713360069cf593b6df89e6e1c303", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split-incompatible_v2.1.0-pre+incompatible.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.1.0-pre%2Bincompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.1.0-pre%2Bincompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.1.0-pre%2Bincompatible.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,6 +1,6 @@\n Written by hand.\n Test case for getting a package that has been moved to a nested module,\n-with a +incompatible verison (and thus no go.mod file) at the root module.\n+with a +incompatible version (and thus no go.mod file) at the root module.\n \n -- .mod --\n module example.com/split-incompatible"}, {"sha": "53c78cfb00bbac391b9b1f818a566a0d8d786555", "filename": "libgo/go/cmd/go/testdata/savedir.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build ignore\n // +build ignore\n \n // Savedir archives a directory tree as a txtar archive printed to standard output.\n@@ -24,7 +25,7 @@ import (\n \t\"strings\"\n \t\"unicode/utf8\"\n \n-\t\"../internal/txtar\"\n+\t\"golang.org/x/tools/txtar\"\n )\n \n func usage() {"}, {"sha": "b2a7fd19156d096131a3b91a22a069b958d51a2c", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -79,7 +79,9 @@ should only run when the condition is satisfied. The available conditions are:\n  - Compiler names, like [gccgo], [gc].\n  - Test environment details:\n    - [short] for testing.Short()\n-   - [cgo], [msan], [race] for whether cgo, msan, and the race detector can be used\n+   - [cgo], [msan], [asan], [race] for whether cgo, msan, asan, and the race detector can be used\n+   - [fuzz] for whether 'go test -fuzz' can be used at all\n+   - [fuzz-instrumented] for whether 'go test -fuzz' uses coverage-instrumented binaries\n    - [net] for whether the external network can be used\n    - [link] for testenv.HasLink()\n    - [root] for os.Geteuid() == 0\n@@ -108,14 +110,15 @@ The commands are:\n   Change the permissions of the files or directories named by the path arguments\n   to be equal to perm. Only numerical permissions are supported.\n \n-- cmp file1 file2\n-  Check that the named files have the same content.\n+- [! | ?] cmp file1 file2\n+  Check that the named files have (or do not have) the same content.\n   By convention, file1 is the actual data and file2 the expected data.\n   File1 can be \"stdout\" or \"stderr\" to use the standard output or standard error\n   from the most recent exec or go command.\n-  (If the files have differing content, the failure prints a diff.)\n+  (If the file contents differ and the command is not negated,\n+  the failure prints a diff.)\n \n-- cmpenv file1 file2\n+- [! | ?] cmpenv file1 file2\n   Like cmp, but environment variables are substituted in the file contents\n   before the comparison. For example, $GOOS is replaced by the target GOOS.\n \n@@ -161,6 +164,10 @@ The commands are:\n - mkdir path...\n   Create the listed directories, if they do not already exists.\n \n+- mv path1 path2\n+  Rename path1 to path2. OS-specific restrictions may apply when path1 and path2\n+  are in different directories.\n+\n - rm file...\n   Remove the listed files or directories.\n "}, {"sha": "a4cc33c357b1fe95c8b45c615d2fd31897ce2998", "filename": "libgo/go/cmd/go/testdata/script/build_cache_disabled.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_disabled.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_disabled.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_disabled.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -9,7 +9,7 @@\n # * go fix\n # * go fmt\n # * go generate\n-# * go get -d\n+# * go get\n # * go list (without -export or -compiled)\n \n env GOCACHE=off"}, {"sha": "7ee3c3b41d489a7cd3059efe567737f25b040559", "filename": "libgo/go/cmd/go/testdata/script/build_cache_trimpath.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -16,10 +16,10 @@ stderr 'link( |\\.exe)'\n # Two distinct versions of the same module with identical content should\n # still be cached separately.\n # Verifies golang.org/issue/35412.\n-go get -d example.com/stack@v1.0.0\n+go get example.com/stack@v1.0.0\n go run -trimpath printstack.go\n stdout '^example.com/stack@v1.0.0/stack.go$'\n-go get -d example.com/stack@v1.0.1\n+go get example.com/stack@v1.0.1\n go run -trimpath printstack.go\n stdout '^example.com/stack@v1.0.1/stack.go$'\n "}, {"sha": "3587e22038e1c4aac422a3426c08dbd13600f29c", "filename": "libgo/go/cmd/go/testdata/script/build_concurrent_backend.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_concurrent_backend.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_concurrent_backend.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_concurrent_backend.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,12 @@\n+# Tests golang.org/issue/48490\n+# cmd/go should enable concurrent compilation by default\n+\n+[gccgo] skip\n+\n+# Reset all experiments, since one of them can disable\n+# concurrent compilation, e.g: fieldtrack.\n+env GOEXPERIMENT=none\n+\n+env GOMAXPROCS=4\n+go build -n -x -a fmt\n+stderr ' -c=4 '"}, {"sha": "bab02786ec97be1e11d471235d55a8e0c6992387", "filename": "libgo/go/cmd/go/testdata/script/build_gcflags_order.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags_order.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags_order.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags_order.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,20 @@\n+# Tests golang.org/issue/47682\n+# Flags specified with -gcflags should appear after other flags generated by cmd/go.\n+\n+cd m\n+go build -n -gcflags=-lang=go1.17\n+[!gccgo] stderr ' -lang=go1.16.* -lang=go1.17'\n+\n+-- m/go.mod --\n+module example.com\n+\n+go 1.16\n+\n+-- m/main.go --\n+package main\n+\n+func main() {\n+    var s = []int{1, 2, 3}\n+    var pa = (*[2]int)(s[1:])\n+    println(pa[1])\n+}"}, {"sha": "5c1799566999e44a76c4555af4e06cfd67b592fd", "filename": "libgo/go/cmd/go/testdata/script/build_i_deprecate.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i_deprecate.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i_deprecate.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i_deprecate.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,13 +2,13 @@\n # TODO(golang.org/issue/41696): remove the -i flag after Go 1.16, and this test.\n \n go build -n -i\n-stderr '^go build: -i flag is deprecated$'\n+stderr '^go: -i flag is deprecated$'\n \n go install -n -i\n-stderr '^go install: -i flag is deprecated$'\n+stderr '^go: -i flag is deprecated$'\n \n go test -n -i\n-stderr '^go test: -i flag is deprecated$'\n+stderr '^go: -i flag is deprecated$'\n \n \n # 'go clean -i' should not print a deprecation warning."}, {"sha": "3979247f2fd962b065f5c36b2225208fe5c35cc2", "filename": "libgo/go/cmd/go/testdata/script/build_issue48319.txt", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_issue48319.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_issue48319.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_issue48319.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,47 @@\n+# Regression test for https://go.dev/issue/48319:\n+# cgo builds should not include debug information from a stale GOROOT_FINAL.\n+\n+[short] skip\n+[!cgo] skip\n+[windows] skip  # The Go Windows builders have an extremely out-of-date gcc that does not support reproducible builds; see https://go.dev/issue/50824.\n+\n+# This test is sensitive to cache invalidation,\n+# so use a separate build cache that we can control.\n+env GOCACHE=$WORK/gocache\n+mkdir $GOCACHE\n+\n+# Build a binary using a specific value of GOROOT_FINAL.\n+env GOROOT_FINAL=$WORK${/}goroot1\n+go build -o main.exe\n+mv main.exe main1.exe\n+\n+# Now clean the cache and build using a different GOROOT_FINAL.\n+# The resulting binaries should differ in their debug metadata.\n+go clean -cache\n+env GOROOT_FINAL=$WORK${/}goroot2\n+go build -o main.exe\n+mv main.exe main2.exe\n+! cmp main2.exe main1.exe\n+\n+# Set GOROOT_FINAL back to the first value.\n+# If the build is properly reproducible, the two binaries should match.\n+env GOROOT_FINAL=$WORK${/}goroot1\n+go build -o main.exe\n+cmp -q main.exe main1.exe\n+\n+-- go.mod --\n+module main\n+\n+go 1.18\n+-- main.go --\n+package main\n+\n+import \"C\"\n+\n+import \"runtime\"\n+\n+var _ C.int\n+\n+func main() {\n+\tprintln(runtime.GOROOT())\n+}"}, {"sha": "9123907dc87a40e41803c145433602aada4db3dd", "filename": "libgo/go/cmd/go/testdata/script/build_negative_p.txt", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_negative_p.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_negative_p.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_negative_p.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,5 @@\n+! go build -p=-1 example.go\n+stderr 'go: -p must be a positive integer: -1'\n+\n+-- example.go --\n+package example\n\\ No newline at end of file"}, {"sha": "56e812f44b29e7eb943f4302a17a4aeb825582bb", "filename": "libgo/go/cmd/go/testdata/script/build_overlay.txt", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_overlay.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_overlay.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_overlay.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -31,17 +31,17 @@ exec ./print_trimpath_two_files$GOEXE\n stdout $WORK[/\\\\]gopath[/\\\\]src[/\\\\]m[/\\\\]printpath[/\\\\]main.go\n stdout $WORK[/\\\\]gopath[/\\\\]src[/\\\\]m[/\\\\]printpath[/\\\\]other.go\n \n-go build -overlay overlay.json -o main_cgo_replace$GOEXE ./cgo_hello_replace\n-exec ./main_cgo_replace$GOEXE\n-stdout '^hello cgo\\r?\\n'\n+[cgo] go build -overlay overlay.json -o main_cgo_replace$GOEXE ./cgo_hello_replace\n+[cgo] exec ./main_cgo_replace$GOEXE\n+[cgo] stdout '^hello cgo\\r?\\n'\n \n-go build -overlay overlay.json -o main_cgo_quote$GOEXE ./cgo_hello_quote\n-exec ./main_cgo_quote$GOEXE\n-stdout '^hello cgo\\r?\\n'\n+[cgo] go build -overlay overlay.json -o main_cgo_quote$GOEXE ./cgo_hello_quote\n+[cgo] exec ./main_cgo_quote$GOEXE\n+[cgo] stdout '^hello cgo\\r?\\n'\n \n-go build -overlay overlay.json -o main_cgo_angle$GOEXE ./cgo_hello_angle\n-exec ./main_cgo_angle$GOEXE\n-stdout '^hello cgo\\r?\\n'\n+[cgo] go build -overlay overlay.json -o main_cgo_angle$GOEXE ./cgo_hello_angle\n+[cgo] exec ./main_cgo_angle$GOEXE\n+[cgo] stdout '^hello cgo\\r?\\n'\n \n go build -overlay overlay.json -o main_call_asm$GOEXE ./call_asm\n exec ./main_call_asm$GOEXE\n@@ -55,11 +55,11 @@ cp overlay/test_cache_different.go overlay/test_cache.go\n go list -overlay overlay.json -f '{{.Stale}}' ./test_cache\n stdout '^true$'\n \n-go list -compiled -overlay overlay.json -f '{{range .CompiledGoFiles}}{{. | printf \"%s\\n\"}}{{end}}' ./cgo_hello_replace\n-cp stdout compiled_cgo_sources.txt\n-go run ../print_line_comments.go compiled_cgo_sources.txt\n-stdout $GOPATH[/\\\\]src[/\\\\]m[/\\\\]cgo_hello_replace[/\\\\]cgo_hello_replace.go\n-! stdout $GOPATH[/\\\\]src[/\\\\]m[/\\\\]overlay[/\\\\]hello.c\n+[cgo] go list -compiled -overlay overlay.json -f '{{range .CompiledGoFiles}}{{. | printf \"%s\\n\"}}{{end}}' ./cgo_hello_replace\n+[cgo] cp stdout compiled_cgo_sources.txt\n+[cgo] go run ../print_line_comments.go compiled_cgo_sources.txt\n+[cgo] stdout $GOPATH[/\\\\]src[/\\\\]m[/\\\\]cgo_hello_replace[/\\\\]cgo_hello_replace.go\n+[cgo] ! stdout $GOPATH[/\\\\]src[/\\\\]m[/\\\\]overlay[/\\\\]hello.c\n \n # Run same tests but with gccgo.\n env GO111MODULE=off"}, {"sha": "c87e480911933a6211fd31991cbf17ec2e75da44", "filename": "libgo/go/cmd/go/testdata/script/build_runtime_gcflags.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_runtime_gcflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_runtime_gcflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_runtime_gcflags.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -8,4 +8,4 @@ mkdir $GOCACHE\n # Verify the standard library (specifically runtime/internal/atomic) can be\n # built with -gcflags when -n is given. See golang.org/issue/29346.\n go build -n -gcflags=all='-l' std\n-stderr 'compile.* -l .* runtime/internal/atomic'\n+stderr 'compile.* runtime/internal/atomic .* -l'"}, {"sha": "241cdb954ba7664ce796ea16c761d23a59dfe45c", "filename": "libgo/go/cmd/go/testdata/script/build_single_error.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_single_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_single_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_single_error.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,18 @@\n+# go test ./... with a bad package should report the error once (#44624).\n+! go test ./...\n+stderr -count=1 undefined\n+\n+-- go.mod --\n+module example.com\n+\n+go 1.18\n+-- a/a.go --\n+package a\n+\n+import \"example.com/b\"\n+-- b/b.go --\n+package b\n+\n+var X = Y\n+-- b/b_test.go --\n+package b"}, {"sha": "f36b1237dc09413f8cf95fea76a278ed48b187f6", "filename": "libgo/go/cmd/go/testdata/script/build_trimpath.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -32,7 +32,8 @@ stdout 'binary contains GOROOT: false'\n \n # A binary from an external module built with -trimpath should not contain\n # the current workspace or GOROOT.\n-go get -trimpath rsc.io/fortune\n+go get rsc.io/fortune\n+go install -trimpath rsc.io/fortune\n exec $WORK/paths-a.exe $GOPATH/bin/fortune$GOEXE\n stdout 'binary contains module root: false'\n stdout 'binary contains GOROOT: false'"}, {"sha": "955610130088d512759b29d86d0dba92a0875ef2", "filename": "libgo/go/cmd/go/testdata/script/cgo_path_space_quote.txt", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path_space_quote.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path_space_quote.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path_space_quote.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,58 @@\n+# This test checks that the CC environment variable may contain quotes and\n+# spaces. Arguments are normally split on spaces, tabs, newlines. If an\n+# argument contains these characters, the entire argument may be quoted\n+# with single or double quotes. This is the same as -gcflags and similar\n+# options.\n+\n+[short] skip\n+[!exec:clang] [!exec:gcc] skip\n+[!cgo] skip\n+\n+env GOENV=$WORK/go.env\n+mkdir 'program files'\n+go build -o 'program files' './which cc/which cc.go'\n+[exec:clang] env CC='\"'$PWD${/}program' 'files${/}which' 'cc\"' 'clang\n+[!exec:clang] env CC='\"'$PWD${/}program' 'files${/}which' 'cc\"' 'gcc\n+go env CC\n+stdout 'program files[/\\\\]which cc\" (clang|gcc)$'\n+go env -w CC=$CC\n+env CC=\n+go env CC\n+stdout 'program files[/\\\\]which cc\" (clang|gcc)$'\n+\n+go run .\n+stdout 1\n+\n+-- go.mod --\n+module test\n+\n+go 1.17\n+-- which cc/which cc.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+)\n+\n+func main() {\n+\targs := append([]string{\"-DWRAPPER_WAS_USED=1\"}, os.Args[2:]...)\n+\tcmd := exec.Command(os.Args[1], args...)\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\tif err := cmd.Run(); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+}\n+-- hello.go --\n+package main\n+\n+// int x = WRAPPER_WAS_USED;\n+import \"C\"\n+import \"fmt\"\n+\n+func main() {\n+\tfmt.Println(C.x)\n+}"}, {"sha": "80ed751afcd19490db1b3d2d1031bc0a8aced5d0", "filename": "libgo/go/cmd/go/testdata/script/cgo_stale_precompiled.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_stale_precompiled.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_stale_precompiled.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_stale_precompiled.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,28 @@\n+# Regression test for https://go.dev/issue/47215 and https://go.dev/issue/50183:\n+# A mismatched $GOROOT_FINAL or missing $CC caused the C dependencies of the net\n+# package to appear stale, and it could not be rebuilt due to a missing $CC.\n+\n+[!cgo] skip\n+\n+# This test may start with the runtime/cgo package already stale.\n+# Explicitly rebuild it to ensure that it is cached.\n+# (See https://go.dev/issue/50892.)\n+#\n+# If running in non-short mode, explicitly vary CGO_CFLAGS\n+# as a control case (to ensure that our regexps do catch rebuilds).\n+\n+[!short] env GOCACHE=$WORK/cache\n+[!short] env CGO_CFLAGS=-DTestScript_cgo_stale_precompiled=true\n+go build -x runtime/cgo\n+[!short] stderr '[/\\\\]cgo'$GOEXE'[\"]? .* -importpath runtime/cgo'\n+\n+# https://go.dev/issue/47215: a missing $(go env CC) caused the precompiled net to be stale.\n+[!plan9] env PATH=''  # Guaranteed not to include $(go env CC)!\n+[plan9] env path=''\n+go build -x runtime/cgo\n+! stderr '[/\\\\]cgo'$GOEXE'[\"]? .* -importpath runtime/cgo'\n+\n+# https://go.dev/issue/50183: a mismatched GOROOT_FINAL caused net to be stale.\n+env GOROOT_FINAL=$WORK${/}goroot\n+go build -x runtime/cgo\n+! stderr '[/\\\\]cgo'$GOEXE'[\"]? .* -importpath runtime/cgo'"}, {"sha": "5f7f6edd77e7f9a4d8fee9c8b26ee278a4d04e8a", "filename": "libgo/go/cmd/go/testdata/script/embed.txt", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -60,6 +60,18 @@ rm t/x.txt\n ! go build m/use\n stderr '^x.go:5:12: pattern [*]t: cannot embed directory t: contains no embeddable files$'\n \n+# all still ignores .git and symlinks\n+cp x.go3 x.go\n+! go build -x\n+stderr '^x.go:5:12: pattern all:t: cannot embed directory t: contains no embeddable files$'\n+\n+# all finds dot files and underscore files\n+cp x.txt t/.x.txt\n+go build -x\n+rm t/.x.txt\n+cp x.txt t/_x.txt\n+go build -x\n+\n -- x.go --\n package p\n \n@@ -92,6 +104,14 @@ import \"embed\"\n //go:embed *t\n var X embed.FS\n \n+-- x.go3 --\n+package p\n+\n+import \"embed\"\n+\n+//go:embed all:t\n+var X embed.FS\n+\n -- x.txt --\n hello\n "}, {"sha": "107b605a3137c508c3ad30d8eb6f9b391df6940f", "filename": "libgo/go/cmd/go/testdata/script/env_unset.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_unset.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_unset.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_unset.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -14,13 +14,13 @@ stderr '^go(\\.exe)?: unknown GOEXPERIMENT badexp$'\n go env -u GOEXPERIMENT\n \n ! go env\n-stderr '^cmd/go: unsupported GOOS/GOARCH pair bados/badarch$'\n+stderr '^go: unsupported GOOS/GOARCH pair bados/badarch$'\n \n ! go env -u GOOS\n-stderr '^go env -u: unsupported GOOS/GOARCH pair \\w+/badarch$'\n+stderr '^go: unsupported GOOS/GOARCH pair \\w+/badarch$'\n \n ! go env -u GOARCH\n-stderr '^go env -u: unsupported GOOS/GOARCH pair bados/\\w+$'\n+stderr '^go: unsupported GOOS/GOARCH pair bados/\\w+$'\n \n go env -u GOOS GOARCH\n "}, {"sha": "6f8a366d6189f302326da851cc436f0807480f5b", "filename": "libgo/go/cmd/go/testdata/script/env_write.txt", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -30,9 +30,9 @@ go env\n \n # checking errors\n ! go env -w\n-stderr 'go env -w: no KEY=VALUE arguments given'\n+stderr 'go: no KEY=VALUE arguments given'\n ! go env -u\n-stderr 'go env -u: no arguments given'\n+stderr 'go: ''go env -u'' requires an argument'\n \n # go env -w changes default setting\n env root=\n@@ -111,7 +111,7 @@ stderr 'GOPATH entry is relative; must be absolute path'\n \n # go env -w rejects invalid GOTMPDIR values\n ! go env -w GOTMPDIR=x\n-stderr 'go env -w: GOTMPDIR must be an absolute path'\n+stderr 'go: GOTMPDIR must be an absolute path'\n \n # go env -w should accept absolute GOTMPDIR value\n # and should not create it\n@@ -134,24 +134,24 @@ stdout ^$\n go env -w CC=clang\n [!windows] ! go env -w CC=./clang\n [!windows] ! go env -w CC=bin/clang\n-[!windows] stderr 'go env -w: CC entry is relative; must be absolute path'\n+[!windows] stderr 'go: CC entry is relative; must be absolute path'\n \n [windows] go env -w CC=$WORK\\bin\\clang\n [windows] ! go env -w CC=.\\clang\n [windows] ! go env -w CC=bin\\clang\n-[windows] stderr 'go env -w: CC entry is relative; must be absolute path'\n+[windows] stderr 'go: CC entry is relative; must be absolute path'\n \n # go env -w rejects relative CXX values\n [!windows] go env -w CC=/usr/bin/cpp\n go env -w CXX=cpp\n [!windows] ! go env -w CXX=./cpp\n [!windows] ! go env -w CXX=bin/cpp\n-[!windows] stderr 'go env -w: CXX entry is relative; must be absolute path'\n+[!windows] stderr 'go: CXX entry is relative; must be absolute path'\n \n [windows] go env -w CXX=$WORK\\bin\\cpp\n [windows] ! go env -w CXX=.\\cpp\n [windows] ! go env -w CXX=bin\\cpp\n-[windows] stderr 'go env -w: CXX entry is relative; must be absolute path'\n+[windows] stderr 'go: CXX entry is relative; must be absolute path'\n \n # go env -w/-u checks validity of GOOS/ARCH combinations\n [gccgo] skip\n@@ -177,9 +177,9 @@ stderr 'unsupported GOOS/GOARCH.*windows/mips$'\n \n # go env -w should reject relative paths in GOMODCACHE environment.\n ! go env -w GOMODCACHE=~/test\n-stderr 'go env -w: GOMODCACHE entry is relative; must be absolute path: \"~/test\"'\n+stderr 'go: GOMODCACHE entry is relative; must be absolute path: \"~/test\"'\n ! go env -w GOMODCACHE=./test\n-stderr 'go env -w: GOMODCACHE entry is relative; must be absolute path: \"./test\"'\n+stderr 'go: GOMODCACHE entry is relative; must be absolute path: \"./test\"'\n \n # go env -w checks validity of GOEXPERIMENT\n env GOEXPERIMENT="}, {"sha": "24ec5aa11b01deaa9d6b6075a3f700623e995c9e", "filename": "libgo/go/cmd/go/testdata/script/gcflags_patterns.txt", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -7,28 +7,28 @@ env GOCACHE=$WORK/gocache  # Looking for compile commands, so need a clean cache\n \n # -gcflags=-e applies to named packages, not dependencies\n go build -n -v -gcflags=-e z1 z2\n-stderr 'compile.* -e.* -p z1'\n-stderr 'compile.* -e.* -p z2'\n+stderr 'compile.* -p z1.* -e '\n+stderr 'compile.* -p z2.* -e '\n stderr 'compile.* -p y'\n-! stderr 'compile.* -e.* -p [^z]'\n+! stderr 'compile.* -p [^z].* -e '\n \n # -gcflags can specify package=flags, and can be repeated; last match wins\n go build -n -v -gcflags=-e -gcflags=z1=-N z1 z2\n-stderr 'compile.* -N.* -p z1'\n-! stderr 'compile.* -e.* -p z1'\n-! stderr 'compile.* -N.* -p z2'\n-stderr 'compile.* -e.* -p z2'\n+stderr 'compile.* -p z1.* -N '\n+! stderr 'compile.* -p z1.* -e '\n+! stderr 'compile.* -p z2.* -N '\n+stderr 'compile.* -p z2.* -e '\n stderr 'compile.* -p y'\n-! stderr 'compile.* -e.* -p [^z]'\n-! stderr 'compile.* -N.* -p [^z]'\n+! stderr 'compile.* -p [^z].* -e '\n+! stderr 'compile.* -p [^z].* -N '\n \n # -gcflags can have arbitrary spaces around the flags\n go build -n -v -gcflags='  z1 =  \t-e \t' z1\n-stderr 'compile.* -e.* -p z1'\n+stderr 'compile.* -p z1.* -e '\n \n # -gcflags='all=-e' should apply to all packages, even with go test\n go test -c -n -gcflags='all=-e' z1\n-stderr 'compile.* -e.* -p z3 '\n+stderr 'compile.* -p z3.* -e '\n \n # this particular -gcflags argument made the compiler crash\n ! go build -gcflags=-d=ssa/ z1\n@@ -58,8 +58,7 @@ go build -n -ldflags=-X=math.pi=3\n stderr 'link.* -X=math.pi=3'\n \n # -ldflags applies to current directory even if GOPATH is funny\n-[windows] cd $WORK/GoPath/src/my/cmd/prog\n-[darwin] cd $WORK/GoPath/src/my/cmd/prog\n+[!case-sensitive] cd $WORK/GoPath/src/my/cmd/prog\n go build -n -ldflags=-X=math.pi=3\n stderr 'link.* -X=math.pi=3'\n "}, {"sha": "29fc5421e12fb9824c62dcec8d4f0bc526d16cf4", "filename": "libgo/go/cmd/go/testdata/script/get_404_meta.txt", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -9,4 +9,10 @@ go get -d bazil.org/fuse/fs/fstestutil\n \n env GO111MODULE=on\n env GOPROXY=direct\n-go get -d bazil.org/fuse/fs/fstestutil\n+go get bazil.org/fuse/fs/fstestutil\n+\n+\n+-- go.mod --\n+module m\n+\n+go 1.18"}, {"sha": "f6d0de4d06fe540d92c580fbec4c4f9a9743dfb7", "filename": "libgo/go/cmd/go/testdata/script/get_go_file.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_go_file.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_go_file.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_go_file.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -9,15 +9,15 @@ go get -d test\n \n # argument has .go suffix, is a file and exists\n ! go get -d test.go\n-stderr 'go get test.go: arguments must be package or module paths'\n+stderr 'go: test.go: arguments must be package or module paths'\n \n # argument has .go suffix, doesn't exist and has no slashes\n ! go get -d test_missing.go\n-stderr 'go get test_missing.go: arguments must be package or module paths'\n+stderr 'go: test_missing.go: arguments must be package or module paths'\n \n # argument has .go suffix, is a file and exists in sub-directory\n ! go get -d test/test.go\n-stderr 'go get: test/test.go exists as a file, but ''go get'' requires package arguments'\n+stderr 'go: test/test.go exists as a file, but ''go get'' requires package arguments'\n \n # argument has .go suffix, doesn't exist and has slashes\n ! go get -d test/test_missing.go\n@@ -27,19 +27,19 @@ stderr 'go get: test/test.go exists as a file, but ''go get'' requires package a\n # argument has .go suffix, is a symlink and exists\n [symlink] symlink test_sym.go -> test.go\n [symlink] ! go get -d test_sym.go\n-[symlink] stderr 'go get test_sym.go: arguments must be package or module paths'\n+[symlink] stderr 'go: test_sym.go: arguments must be package or module paths'\n [symlink] rm test_sym.go\n \n # argument has .go suffix, is a symlink and exists in sub-directory\n [symlink] symlink test/test_sym.go -> test.go\n [symlink] ! go get -d test/test_sym.go\n-[symlink] stderr 'go get: test/test_sym.go exists as a file, but ''go get'' requires package arguments'\n+[symlink] stderr 'go: test/test_sym.go exists as a file, but ''go get'' requires package arguments'\n [symlink] rm test_sym.go\n \n # argument has .go suffix, is a directory and exists\n mkdir test_dir.go\n ! go get -d test_dir.go\n-stderr 'go get test_dir.go: arguments must be package or module paths'\n+stderr 'go: test_dir.go: arguments must be package or module paths'\n rm test_dir.go\n \n # argument has .go suffix, is a directory and exists in sub-directory"}, {"sha": "00bf32fc78effbb635570ffa919e96af69e561ee", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_no_longer_supported.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_no_longer_supported.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_no_longer_supported.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_no_longer_supported.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,11 +3,11 @@ env GO111MODULE=off\n \n # GOPATH: Fetch with insecure, should error\n ! go get -insecure test\n-stderr 'go get: -insecure flag is no longer supported; use GOINSECURE instead'\n+stderr 'go: -insecure flag is no longer supported; use GOINSECURE instead'\n \n # Modules: Set up\n env GO111MODULE=on\n \n # Modules: Fetch with insecure, should error\n ! go get -insecure test\n-stderr 'go get: -insecure flag is no longer supported; use GOINSECURE instead'\n+stderr 'go: -insecure flag is no longer supported; use GOINSECURE instead'"}, {"sha": "1a787e1b18c1dd9265e6f2ed29f0871ce98f26d8", "filename": "libgo/go/cmd/go/testdata/script/go_version.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgo_version.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgo_version.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgo_version.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,9 @@\n+# test that go version doesn't panic on non-go binaries\r\n+# See Issue #49181\r\n+\r\n+[exec:/bin/true] cp /bin/true true\r\n+[exec:C:\\windows\\system32\\help.exe] cp C:\\windows\\system32\\help.exe help.exe\r\n+\r\n+go version -m .\r\n+! stdout .\r\n+! stderr .\r"}, {"sha": "f4872ffd356b5b3874e1205c0959c20c79a38ca0", "filename": "libgo/go/cmd/go/testdata/script/goflags.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -9,7 +9,7 @@ stdout '[\\\\/]runtime$'\n \n env GOFLAGS=-race OLDGOARCH=$GOARCH OLDGOOS=$GOOS GOARCH=386 GOOS=linux\n ! go list runtime\n-stderr 'race is only supported on'\n+stderr 'race is not supported on linux/386'\n \n env GOARCH=$OLDGOARCH GOOS=$OLDGOOS\n "}, {"sha": "6c572eae619f067eac3ec44681314e1706a851f9", "filename": "libgo/go/cmd/go/testdata/script/gopath_install.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_install.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_install.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_install.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -26,7 +26,7 @@ cd ..\n env GOPATH= # reset to default ($HOME/go, which does not exist)\n env GOBIN=\n ! go install go-cmd-test/helloworld.go\n-stderr '^go install: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n+stderr '^go: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n \n # With $GOBIN set, should install there.\n env GOBIN=$WORK/bin1"}, {"sha": "54beaca5e8a9c211db89a82d3d729a673880c1dc", "filename": "libgo/go/cmd/go/testdata/script/gopath_local.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_local.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_local.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_local.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -22,7 +22,7 @@ stdout '^sub\\.Hello'\n # Explicit source files listed on the command line should not install without\n # GOBIN set, since individual source files aren't part of the containing GOPATH.\n ! go install testdata/local/easy.go\n-stderr '^go install: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n+stderr '^go: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n \n [windows] stop  # Windows does not allow the ridiculous directory name we're about to use.\n \n@@ -58,7 +58,7 @@ stdout '^sub\\.Hello'\n # Explicit source files listed on the command line should not install without\n # GOBIN set, since individual source files aren't part of the containing GOPATH.\n ! go install testdata/$BAD_DIR_NAME/easy.go\n-stderr '^go install: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n+stderr '^go: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n \n -- testdata/local/easy.go --\n package main"}, {"sha": "46f1bd0da2ada67d7cb80664699f6ac3d7e3881c", "filename": "libgo/go/cmd/go/testdata/script/govcs.txt", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgovcs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgovcs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgovcs.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,64 +5,64 @@ env GOPROXY=direct\n # GOVCS stops go get\n env GOVCS='*:none'\n ! go get github.com/google/go-cmp\n-stderr '^go get: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n+stderr '^go: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n env GOPRIVATE='github.com/google'\n ! go get github.com/google/go-cmp\n-stderr '^go get: GOVCS disallows using git for private github.com/google/go-cmp; see ''go help vcs''$'\n+stderr '^go: GOVCS disallows using git for private github.com/google/go-cmp; see ''go help vcs''$'\n \n # public pattern works\n env GOPRIVATE='github.com/google'\n env GOVCS='public:all,private:none'\n ! go get github.com/google/go-cmp\n-stderr '^go get: GOVCS disallows using git for private github.com/google/go-cmp; see ''go help vcs''$'\n+stderr '^go: GOVCS disallows using git for private github.com/google/go-cmp; see ''go help vcs''$'\n \n # private pattern works\n env GOPRIVATE='hubgit.com/google'\n env GOVCS='private:all,public:none'\n ! go get github.com/google/go-cmp\n-stderr '^go get: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n+stderr '^go: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n \n # other patterns work (for more patterns, see TestGOVCS)\n env GOPRIVATE=\n env GOVCS='github.com:svn|hg'\n ! go get github.com/google/go-cmp\n-stderr '^go get: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n+stderr '^go: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n env GOVCS='github.com/google/go-cmp/inner:git,github.com:svn|hg'\n ! go get github.com/google/go-cmp\n-stderr '^go get: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n+stderr '^go: GOVCS disallows using git for public github.com/google/go-cmp; see ''go help vcs''$'\n \n # bad patterns are reported (for more bad patterns, see TestGOVCSErrors)\n env GOVCS='git'\n ! go get github.com/google/go-cmp\n-stderr '^go get github.com/google/go-cmp: malformed entry in GOVCS \\(missing colon\\): \"git\"$'\n+stderr '^go: github.com/google/go-cmp: malformed entry in GOVCS \\(missing colon\\): \"git\"$'\n \n env GOVCS=github.com:hg,github.com:git\n ! go get github.com/google/go-cmp\n-stderr '^go get github.com/google/go-cmp: unreachable pattern in GOVCS: \"github.com:git\" after \"github.com:hg\"$'\n+stderr '^go: github.com/google/go-cmp: unreachable pattern in GOVCS: \"github.com:git\" after \"github.com:hg\"$'\n \n # bad GOVCS patterns do not stop commands that do not need to check VCS\n go list\n env GOPROXY=$proxy\n-go get -d rsc.io/quote # ok because used proxy\n+go get rsc.io/quote # ok because used proxy\n env GOPROXY=direct\n \n # svn is disallowed by default\n env GOPRIVATE=\n env GOVCS=\n ! go get rsc.io/nonexist.svn/hello\n-stderr '^go get rsc.io/nonexist.svn/hello: GOVCS disallows using svn for public rsc.io/nonexist.svn; see ''go help vcs''$'\n+stderr '^go: rsc.io/nonexist.svn/hello: GOVCS disallows using svn for public rsc.io/nonexist.svn; see ''go help vcs''$'\n \n # fossil is disallowed by default\n env GOPRIVATE=\n env GOVCS=\n ! go get rsc.io/nonexist.fossil/hello\n-stderr '^go get rsc.io/nonexist.fossil/hello: GOVCS disallows using fossil for public rsc.io/nonexist.fossil; see ''go help vcs''$'\n+stderr '^go: rsc.io/nonexist.fossil/hello: GOVCS disallows using fossil for public rsc.io/nonexist.fossil; see ''go help vcs''$'\n \n # bzr is disallowed by default\n env GOPRIVATE=\n env GOVCS=\n ! go get rsc.io/nonexist.bzr/hello\n-stderr '^go get rsc.io/nonexist.bzr/hello: GOVCS disallows using bzr for public rsc.io/nonexist.bzr; see ''go help vcs''$'\n+stderr '^go: rsc.io/nonexist.bzr/hello: GOVCS disallows using bzr for public rsc.io/nonexist.bzr; see ''go help vcs''$'\n \n # git is OK by default\n env GOVCS=\n@@ -77,12 +77,12 @@ env GONOSUMDB='*'\n # git can be disallowed\n env GOVCS=public:hg\n ! go get rsc.io/nonexist.git/hello\n-stderr '^go get rsc.io/nonexist.git/hello: GOVCS disallows using git for public rsc.io/nonexist.git; see ''go help vcs''$'\n+stderr '^go: rsc.io/nonexist.git/hello: GOVCS disallows using git for public rsc.io/nonexist.git; see ''go help vcs''$'\n \n # hg can be disallowed\n env GOVCS=public:git\n ! go get rsc.io/nonexist.hg/hello\n-stderr '^go get rsc.io/nonexist.hg/hello: GOVCS disallows using hg for public rsc.io/nonexist.hg; see ''go help vcs''$'\n+stderr '^go: rsc.io/nonexist.hg/hello: GOVCS disallows using hg for public rsc.io/nonexist.hg; see ''go help vcs''$'\n \n # Repeat in GOPATH mode. Error texts slightly different.\n "}, {"sha": "5e88f7b8dbdc7288c3bdc6d8f7c4774b7e7fa1a0", "filename": "libgo/go/cmd/go/testdata/script/install_msan_and_race_require_cgo.txt", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_msan_and_race_require_cgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_msan_and_race_require_cgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_msan_and_race_require_cgo.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,7 +1,5 @@\n # Tests Issue #21895\n \n-[!msan] [!race] skip 'skipping because both msan and the race detector are not supported'\n-\n env CGO_ENABLED=0\n \n [race] ! go install -race triv.go\n@@ -12,6 +10,10 @@ env CGO_ENABLED=0\n [msan] stderr '-msan requires cgo'\n [msan] ! stderr '-race'\n \n+[asan] ! go install -asan triv.go\n+[asan] stderr '-asan requires cgo'\n+[asan] ! stderr '-msan'\n+\n -- triv.go --\n package main\n "}, {"sha": "5d2d87644d9d00ded203b80f91191876e4ef020d", "filename": "libgo/go/cmd/go/testdata/script/link_external_undef.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_external_undef.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_external_undef.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_external_undef.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,49 @@\n+\n+# Test case for issue 47993, in which the linker crashes\n+# on a bad input instead of issuing an error and exiting.\n+\n+# This test requires external linking, so use cgo as a proxy \n+[!cgo] skip\n+\n+! go build -ldflags='-linkmode=external' .\n+! stderr 'panic'\n+[!gccgo] stderr '^.*unreachable sym in relocation.*'\n+[gccgo] stderr '^.*undefined reference to.*'\n+\n+-- go.mod --\n+\n+module issue47993\n+\n+go 1.16\n+\n+-- main.go --\n+\n+package main\n+\n+type M struct {\n+\tb bool\n+}\n+\n+// Note the body-less func def here. This is what causes the problems.\n+func (m *M) run(fp func())\n+\n+func doit(m *M) {\n+        InAsm()\n+\tm.run(func() {\n+\t})\n+}\n+\n+func main() {\n+     m := &M{true}\n+     doit(m)\n+}\n+\n+func InAsm() \n+\n+-- main.s --\n+\n+// Add an assembly function so as to leave open the possibility\n+// that body-less functions in Go might be defined in assembly.\n+\n+// Currently we just need an empty file here.\n+"}, {"sha": "e0a47398bbd92f25d3561239eedd330e8067b299", "filename": "libgo/go/cmd/go/testdata/script/list_all_gobuild.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_all_gobuild.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_all_gobuild.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_all_gobuild.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,41 @@\n+# go list all should work with GOOS=linux because all packages build on Linux\n+env GOOS=linux\n+go list all\n+\n+# go list all should work with GOOS=darwin, but it used to fail because\n+# in the absence of //go:build support, p looked like it needed q\n+# (p_test.go was not properly excluded), and q was Linux-only.\n+#\n+# Also testing with r and s that +build lines keep working.\n+env GOOS=darwin\n+go list all\n+\n+-- go.mod --\n+go 1.17\n+module m\n+\n+-- p/p.go --\n+package p\n+\n+-- p/p_test.go --\n+//go:build linux\n+\n+package p\n+\n+import \"m/q\"\n+\n+-- q/q_linux.go --\n+package q\n+\n+-- r/r.go --\n+package r\n+\n+-- r/r_test.go --\n+// +build linux\n+\n+package r\n+\n+import \"m/s\"\n+\n+-- s/s_linux.go --\n+package s"}, {"sha": "30effb104b49e9d12d2f2384ee2b6fa9d5c2b46f", "filename": "libgo/go/cmd/go/testdata/script/list_cgo_compiled_importmap.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_cgo_compiled_importmap.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_cgo_compiled_importmap.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_cgo_compiled_importmap.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -12,7 +12,7 @@ env CGO_ENABLED=1\n env GOFLAGS=-tags=netcgo  # Force net to use cgo even on Windows.\n \n \n-# \"runtime/cgo [runtime.test]\" appears in the the test dependencies of \"runtime\",\n+# \"runtime/cgo [runtime.test]\" appears in the test dependencies of \"runtime\",\n # because \"runtime/cgo\" itself depends on \"runtime\"\n \n go list -deps -test -compiled -f '{{if eq .ImportPath \"net [runtime.test]\"}}{{printf \"%q\" .Imports}}{{end}}' runtime"}, {"sha": "b9c5361492be9cfce28f3d94c204cc11be2cdcb9", "filename": "libgo/go/cmd/go/testdata/script/list_reserved.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_reserved.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_reserved.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_reserved.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,7 @@\n+# https://golang.org/issue/37641: the paths \"example\" and \"test\" are reserved\n+# for end users, and must never exist in the standard library.\n+\n+go list example/... test/...\n+stderr 'go: warning: \"example/...\" matched no packages$'\n+stderr 'go: warning: \"test/...\" matched no packages$'\n+! stdout ."}, {"sha": "c66dae8b8f6b10a37abc1b534fdc269dc5f75fc3", "filename": "libgo/go/cmd/go/testdata/script/list_shadow.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_shadow.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_shadow.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_shadow.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -17,7 +17,7 @@ stdout '^\\(.*gopath(\\\\|/)src(\\\\|/)shadow(\\\\|/)root2(\\\\|/)src(\\\\|/)foo\\) \\('$WORK\n \n # The error for go install should mention the conflicting directory.\n ! go install -n ./shadow/root2/src/foo\n-stderr 'go install: no install location for '$WORK'(\\\\|/)?gopath(\\\\|/)src(\\\\|/)shadow(\\\\|/)root2(\\\\|/)src(\\\\|/)foo: hidden by '$WORK'(\\\\|/)?gopath(\\\\|/)src(\\\\|/)shadow(\\\\|/)root1(\\\\|/)src(\\\\|/)foo'\n+stderr 'go: no install location for '$WORK'(\\\\|/)?gopath(\\\\|/)src(\\\\|/)shadow(\\\\|/)root2(\\\\|/)src(\\\\|/)foo: hidden by '$WORK'(\\\\|/)?gopath(\\\\|/)src(\\\\|/)shadow(\\\\|/)root1(\\\\|/)src(\\\\|/)foo'\n \n -- shadow/root1/src/foo/foo.go --\n package foo"}, {"sha": "d4227a80e8e8834d3af5608c3ee94f7e731a490c", "filename": "libgo/go/cmd/go/testdata/script/list_swigcxx.txt", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_swigcxx.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_swigcxx.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_swigcxx.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,17 +2,19 @@\n \n [!exec:swig] skip\n [!exec:g++] skip\n+[!cgo] skip\n \n # CompiledGoFiles should contain 4 files:\n #  a.go\n #  a.swigcxx.go\n #  _cgo_gotypes.go\n #  a.cgo1.go\n+#\n+# These names we see here, other than a.go, will be from the build cache,\n+# so we just count them.\n \n go list -f '{{.CompiledGoFiles}}' -compiled=true example/swig\n \n-# These names we see here, other than a.go, will be from the build cache,\n-# so we just count them.\n stdout a\\.go\n stdout -count=3 $GOCACHE\n "}, {"sha": "25dbb969b01c06a04d1869879168f4a52422923e", "filename": "libgo/go/cmd/go/testdata/script/list_test_err.txt", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -44,6 +44,10 @@ stdout 'testdep_b <nil>'\n stdout 'nameerr\\.test \"[^\"]*wrong signature for TestBad'\n ! stderr 'wrong signature for TestBad'\n \n+# go list prints a useful error for generic test functions\n+! go list -test -deps genericerr\n+stderr 'wrong signature for TestGeneric, test functions cannot have type parameters'\n+\n # go list prints partial information with error if test has cyclic import\n ! go list -test -deps cycleerr\n stdout cycleerr\n@@ -106,6 +110,16 @@ import (\n \n func TestBad(t *testing.B) {}\n \n+-- genericerr/genericerr.go --\n+package genericerr\n+\n+-- genericerr/genericerr_test.go --\n+package genericerr\n+\n+import \"testing\"\n+\n+func TestGeneric[T any](t *testing.T) {}\n+\n -- cycleerr/cycleerr_test.go --\n package cycleerr\n "}, {"sha": "b71a920870a9bb7ffd2ad3668e10af24eb98991c", "filename": "libgo/go/cmd/go/testdata/script/mod_all.txt", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_all.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_all.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_all.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -202,9 +202,9 @@ go mod edit -go=1.17 u/go.mod\n go mod edit -go=1.17 w/go.mod\n go mod edit -go=1.17 x/go.mod\n go mod edit -go=1.17\n-cp go.mod go.mod.orig\n+cmp go.mod go.mod.beforetidy\n go mod tidy\n-cmp go.mod go.mod.orig\n+cmp go.mod go.mod.aftertidy\n \n # With lazy loading, 'go list all' with neither -mod=vendor nor -test should\n # match -mod=vendor without -test in 1.15.\n@@ -315,7 +315,7 @@ go 1.15\n \n require (\n \texample.com/a v0.1.0\n-\texample.com/b v0.1.0\n+\texample.com/b v0.1.0 // indirect\n \texample.com/q v0.1.0\n \texample.com/r v0.1.0 // indirect\n \texample.com/t v0.1.0\n@@ -466,3 +466,66 @@ module example.com/x\n go 1.15\n -- x/x.go --\n package x\n+-- go.mod.beforetidy --\n+module example.com/main\n+\n+// Note: this go.mod file initially specifies go 1.15,\n+// but includes some redundant roots so that it\n+// also already obeys the 1.17 lazy loading invariants.\n+go 1.17\n+\n+require (\n+\texample.com/a v0.1.0\n+\texample.com/b v0.1.0 // indirect\n+\texample.com/q v0.1.0\n+\texample.com/r v0.1.0 // indirect\n+\texample.com/t v0.1.0\n+\texample.com/u v0.1.0 // indirect\n+)\n+\n+replace (\n+\texample.com/a v0.1.0 => ./a\n+\texample.com/b v0.1.0 => ./b\n+\texample.com/c v0.1.0 => ./c\n+\texample.com/d v0.1.0 => ./d\n+\texample.com/q v0.1.0 => ./q\n+\texample.com/r v0.1.0 => ./r\n+\texample.com/s v0.1.0 => ./s\n+\texample.com/t v0.1.0 => ./t\n+\texample.com/u v0.1.0 => ./u\n+\texample.com/w v0.1.0 => ./w\n+\texample.com/x v0.1.0 => ./x\n+)\n+-- go.mod.aftertidy --\n+module example.com/main\n+\n+// Note: this go.mod file initially specifies go 1.15,\n+// but includes some redundant roots so that it\n+// also already obeys the 1.17 lazy loading invariants.\n+go 1.17\n+\n+require (\n+\texample.com/a v0.1.0\n+\texample.com/q v0.1.0\n+\texample.com/t v0.1.0\n+)\n+\n+require (\n+\texample.com/b v0.1.0 // indirect\n+\texample.com/r v0.1.0 // indirect\n+\texample.com/u v0.1.0 // indirect\n+)\n+\n+replace (\n+\texample.com/a v0.1.0 => ./a\n+\texample.com/b v0.1.0 => ./b\n+\texample.com/c v0.1.0 => ./c\n+\texample.com/d v0.1.0 => ./d\n+\texample.com/q v0.1.0 => ./q\n+\texample.com/r v0.1.0 => ./r\n+\texample.com/s v0.1.0 => ./s\n+\texample.com/t v0.1.0 => ./t\n+\texample.com/u v0.1.0 => ./u\n+\texample.com/w v0.1.0 => ./w\n+\texample.com/x v0.1.0 => ./x\n+)"}, {"sha": "afd6e5186c152ac7f9ad6ba6547c7d9bafa10064", "filename": "libgo/go/cmd/go/testdata/script/mod_bad_domain.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,7 +2,7 @@ env GO111MODULE=on\n \n # explicit get should report errors about bad names\n ! go get appengine\n-stderr '^go get: malformed module path \"appengine\": missing dot in first path element$'\n+stderr '^go: malformed module path \"appengine\": missing dot in first path element$'\n ! go get x/y.z\n stderr 'malformed module path \"x/y.z\": missing dot in first path element'\n \n@@ -24,10 +24,10 @@ stderr '^usenonexistent[/\\\\]x.go:2:8: no required module provides package nonexi\n \n # 'get -d' should be similarly definitive\n \n-go get -d ./useappengine  # TODO(#41315): This should fail.\n+go get ./useappengine  # TODO(#41315): This should fail.\n  # stderr '^useappengine[/\\\\]x.go:2:8: cannot find package$'\n \n-! go get -d  ./usenonexistent\n+! go get  ./usenonexistent\n stderr '^x/usenonexistent imports\\n\\tnonexistent.rsc.io: cannot find module providing package nonexistent.rsc.io$'\n \n "}, {"sha": "5c3c309b0dc86e40394e88625e9fc3520ba7f263", "filename": "libgo/go/cmd/go/testdata/script/mod_build_info_err.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -11,7 +11,7 @@ stderr '^bad[/\\\\]bad.go:3:8: malformed import path \"\ud83d\udc27.example.com/string\": in\n \n # TODO(#41688): This should include a file and line, and report the reason for the error..\n # (Today it includes only an import stack.)\n-! go get -d ./main\n+! go get ./main\n stderr '^m/main imports\\n\\tm/bad imports\\n\\t\ud83d\udc27.example.com/string: malformed import path \"\ud83d\udc27.example.com/string\": invalid char ''\ud83d\udc27''$'\n \n "}, {"sha": "859eafcf84dff71d478735102d6777d09ec54f85", "filename": "libgo/go/cmd/go/testdata/script/mod_build_trimpath_issue48557.txt", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_trimpath_issue48557.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_trimpath_issue48557.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_trimpath_issue48557.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -0,0 +1,52 @@\n+# Regression test for issue #48557.\n+# Since builds in module mode do not support relative imports at all, the build\n+# ID for (and other contents of) a binary built with -trimpath in module mode\n+# should not depend on its working directory, even if the binary is specified as\n+# a list of relative source files.\n+\n+[short] skip  # links and runs binaries\n+\n+env GOFLAGS=-trimpath\n+env GOCACHE=$WORK/gocache\n+\n+\n+# When we build a binary in module mode with -trimpath, the -D flag (for the\n+# \"local import prefix\") should not be passed to it.\n+\n+cd $WORK/tmp/foo\n+go build -x -o a.exe main.go\n+stderr ${/}compile$GOEXE.*' -nolocalimports'\n+! stderr ${/}compile$GOEXE.*' -D[ =]'\n+\n+go tool buildid a.exe\n+cp stdout ../foo-buildid.txt\n+go version a.exe\n+cp stdout ../foo-version.txt\n+cd ..\n+\n+\n+# On the second build \u2014 in a different directory but with -trimpath \u2014 the\n+# compiler should not be invoked, since the cache key should be identical.\n+# Only the linker and buildid tool should be needed.\n+\n+mkdir bar\n+cp foo/main.go bar/main.go\n+cd bar\n+go build -x -o a.exe main.go\n+! stderr ${/}compile$GOEXE\n+\n+go tool buildid a.exe\n+cp stdout ../bar-buildid.txt\n+go version a.exe\n+cp stdout ../bar-version.txt\n+cd ..\n+\n+cmp bar-buildid.txt foo-buildid.txt\n+cmp bar-version.txt foo-version.txt\n+cmp bar/a.exe foo/a.exe\n+\n+\n+-- $WORK/tmp/foo/main.go --\n+package main\n+\n+func main() {}"}, {"sha": "f55041834aefe874bb195b4ce77999545846a668", "filename": "libgo/go/cmd/go/testdata/script/mod_build_versioned.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_versioned.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_versioned.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_versioned.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,7 +1,7 @@\n env GO111MODULE=on\n [short] skip\n \n-go get -d rsc.io/fortune/v2\n+go get rsc.io/fortune/v2\n \n # The default executable name shouldn't be v2$GOEXE\n go build rsc.io/fortune/v2"}, {"sha": "4045928a9781b7e5cbb826508be511f551f395b3", "filename": "libgo/go/cmd/go/testdata/script/mod_cache_dir.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_dir.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,9 +3,9 @@ env GO111MODULE=on\n # Go should reject relative paths in GOMODCACHE environment.\n \n env GOMODCACHE=\"~/test\"\n-! go get example.com/tools/cmd/hello\n+! go install example.com/tools/cmd/hello@latest\n stderr 'must be absolute path'\n \n env GOMODCACHE=\"./test\"\n-! go get example.com/tools/cmd/hello\n+! go install example.com/tools/cmd/hello@latest\n stderr 'must be absolute path'"}, {"sha": "07755415d608a46748b658ae808f67e575ec5d9b", "filename": "libgo/go/cmd/go/testdata/script/mod_cache_rw.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_rw.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_rw.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_rw.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,7 +5,7 @@ env GO111MODULE=on\n # golang.org/issue/31481: an explicit flag should make directories in the module\n # cache writable in order to work around the historical inability of 'rm -rf' to\n # forcibly remove files in unwritable directories.\n-go get -modcacherw -d rsc.io/quote@v1.5.2\n+go get -modcacherw rsc.io/quote@v1.5.2\n cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go\n \n # After adding an extraneous file, 'go mod verify' should fail.\n@@ -28,7 +28,7 @@ cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go\n # Windows does not respect FILE_ATTRIBUTE_READONLY on directories, according\n # to MSDN, so there we disable testing whether the directory itself is\n # unwritable.\n-go get -d rsc.io/quote@latest\n+go get rsc.io/quote@latest\n [!root] ! cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/go.mod\n [!windows] [!root] ! cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go\n ! exists $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go"}, {"sha": "d3fb11dfa332168acb0ffa4188800d4bbb4a7d60", "filename": "libgo/go/cmd/go/testdata/script/mod_case.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,6 +1,6 @@\n env GO111MODULE=on\n \n-go get -d\n+go get\n go list -m all\n stdout '^rsc.io/quote v1.5.2'\n stdout '^rsc.io/QUOTE v1.5.2'\n@@ -9,7 +9,7 @@ go list -f 'DIR {{.Dir}} DEPS {{.Deps}}' rsc.io/QUOTE/QUOTE\n stdout 'DEPS.*rsc.io/quote'\n stdout 'DIR.*!q!u!o!t!e'\n \n-go get -d rsc.io/QUOTE@v1.5.3-PRE\n+go get rsc.io/QUOTE@v1.5.3-PRE\n go list -m all\n stdout '^rsc.io/QUOTE v1.5.3-PRE'\n "}, {"sha": "7c768a096395d93ec984a73eaf712c0ba389ba78", "filename": "libgo/go/cmd/go/testdata/script/mod_case_cgo.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case_cgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case_cgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_case_cgo.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,7 +2,7 @@\n \n env GO111MODULE=on\n \n-go get -d rsc.io/CGO\n+go get rsc.io/CGO\n [short] stop\n \n go build rsc.io/CGO"}, {"sha": "e2224d659b23a53dc28092a3eb153a5b0648a655", "filename": "libgo/go/cmd/go/testdata/script/mod_concurrent.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,7 +1,7 @@\n env GO111MODULE=on\n \n # Concurrent builds should succeed, even if they need to download modules.\n-go get -d ./x ./y\n+go get ./x ./y\n go build ./x &\n go build ./y\n wait"}, {"sha": "8e2771dc1f2250b542c4c737ec0cfeeb196a1278", "filename": "libgo/go/cmd/go/testdata/script/mod_deprecate_message.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_deprecate_message.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_deprecate_message.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_deprecate_message.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,25 +1,25 @@\n # When there is a short single-line message, 'go get' should print it all.\n-go get -d short\n+go get short\n stderr '^go: module short is deprecated: short$'\n go list -m -u -f '{{.Deprecated}}' short\n stdout '^short$'\n \n # When there is a multi-line message, 'go get' should print the first line.\n-go get -d multiline\n+go get multiline\n stderr '^go: module multiline is deprecated: first line$'\n ! stderr 'second line'\n go list -m -u -f '{{.Deprecated}}' multiline\n stdout '^first line\\nsecond line.$'\n \n # When there is a long message, 'go get' should print a placeholder.\n-go get -d long\n+go get long\n stderr '^go: module long is deprecated: \\(message omitted: too long\\)$'\n go list -m -u -f '{{.Deprecated}}' long\n stdout '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa$'\n \n # When a message contains unprintable chracters, 'go get' should say that\n # without printing the message.\n-go get -d unprintable\n+go get unprintable\n stderr '^go: module unprintable is deprecated: \\(message omitted: contains non-printable characters\\)$'\n go list -m -u -f '{{.Deprecated}}' unprintable\n stdout '^message contains ASCII BEL\\x07$'"}, {"sha": "c13029d534163e0f58b7e2de27d989cc7fadcf96", "filename": "libgo/go/cmd/go/testdata/script/mod_domain_root.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_domain_root.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_domain_root.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_domain_root.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,7 +2,7 @@\n # (example.com not example.com/something)\n \n env GO111MODULE=on\n-go get -d\n+go get\n \n -- go.mod --\n module x"}, {"sha": "925a724c5286af63ea528992327a2e5cc177ca63", "filename": "libgo/go/cmd/go/testdata/script/mod_dot.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,11 +5,11 @@ env GO111MODULE=on\n # to resolve an external module.\n cd dir\n ! go get\n-stderr '^go get: no package in current directory$'\n+stderr '^go: no package to get in current directory$'\n ! go get .\n-stderr '^go get \\.: no package in current directory$'\n+stderr '^go: .: no package to get in current directory$'\n ! go get ./subdir\n-stderr '^go get: \\.[/\\\\]subdir \\('$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]subdir\\) is not a package in module rooted at '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir$'\n+stderr '^go: \\.[/\\\\]subdir \\('$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]subdir\\) is not a package in module rooted at '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir$'\n ! go list\n ! stderr 'cannot find module providing package'\n stderr '^no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir$'"}, {"sha": "154e68338b6b3e2f2bdfd63e3d789c7f664dd1e9", "filename": "libgo/go/cmd/go/testdata/script/mod_download.txt", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -93,19 +93,19 @@ exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.1.zip\n \n # download reports errors encountered when locating modules\n ! go mod download bad/path\n-stderr '^go mod download: module bad/path: not a known dependency$'\n+stderr '^go: module bad/path: not a known dependency$'\n ! go mod download bad/path@latest\n-stderr '^go mod download: bad/path@latest: malformed module path \"bad/path\": missing dot in first path element$'\n+stderr '^go: bad/path@latest: malformed module path \"bad/path\": missing dot in first path element$'\n ! go mod download rsc.io/quote@v1.999.999\n-stderr '^go mod download: rsc.io/quote@v1.999.999: reading .*/v1.999.999.info: 404 Not Found$'\n+stderr '^go: rsc.io/quote@v1.999.999: reading .*/v1.999.999.info: 404 Not Found$'\n ! go mod download -json bad/path\n stdout '^\\t\"Error\": \"module bad/path: not a known dependency\"'\n \n # download main module produces a warning or error\n go mod download m\n-stderr '^go mod download: skipping argument m that resolves to the main module\\n'\n+stderr '^go: skipping download of m that resolves to the main module\\n'\n ! go mod download m@latest\n-stderr '^go mod download: m@latest: malformed module path \"m\": missing dot in first path element$'\n+stderr '^go: m@latest: malformed module path \"m\": missing dot in first path element$'\n \n # download without arguments updates go.mod and go.sum after loading the\n # build list, but does not save sums for downloaded zips.\n@@ -128,6 +128,50 @@ rm go.sum\n go mod download all\n cmp go.mod.update go.mod\n grep '^rsc.io/sampler v1.3.0 ' go.sum\n+\n+# https://golang.org/issue/44435: At go 1.17 or higher, 'go mod download'\n+# (without arguments) should only download the modules explicitly required in\n+# the go.mod file, not (presumed-irrelevant) transitive dependencies.\n+#\n+# (If the go.mod file is inconsistent, the version downloaded should be the\n+# selected version from the broader graph, but the go.mod file will also be\n+# updated to list the correct versions. If at some point we change 'go mod\n+# download' to stop updating for consistency, then it should fail if the\n+# requirements are inconsistent.)\n+\n+rm go.sum\n+cp go.mod.orig go.mod\n+go mod edit -go=1.17\n+cp go.mod.update go.mod.go117\n+go mod edit -go=1.17 go.mod.go117\n+\n+go clean -modcache\n+go mod download\n+cmp go.mod go.mod.go117\n+\n+go list -e -m all\n+stdout '^rsc.io/quote v1.5.2$'\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.zip\n+stdout '^rsc.io/sampler v1.3.0$'\n+! exists $GOPATH/pkg/mod/cache/download/rsc.io/sampler/@v/v1.2.1.zip\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/sampler/@v/v1.3.0.zip\n+stdout '^golang\\.org/x/text v0.0.0-20170915032832-14c0d48ead0c$'\n+! exists $GOPATH/pkg/mod/cache/download/golang.org/x/text/@v/v0.0.0-20170915032832-14c0d48ead0c.zip\n+cmp go.mod go.mod.go117\n+\n+# However, 'go mod download all' continues to download the selected version\n+# of every module reported by 'go list -m all'.\n+\n+cp go.mod.orig go.mod\n+go mod edit -go=1.17\n+go clean -modcache\n+go mod download all\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.zip\n+! exists $GOPATH/pkg/mod/cache/download/rsc.io/sampler/@v/v1.2.1.zip\n+exists $GOPATH/pkg/mod/cache/download/rsc.io/sampler/@v/v1.3.0.zip\n+exists $GOPATH/pkg/mod/cache/download/golang.org/x/text/@v/v0.0.0-20170915032832-14c0d48ead0c.zip\n+cmp go.mod go.mod.go117\n+\n cd ..\n \n # allow go mod download without go.mod"}, {"sha": "46eb666686502cafdea600ab9b0ec044bb454212", "filename": "libgo/go/cmd/go/testdata/script/mod_download_insecure_redirect.txt", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_insecure_redirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_insecure_redirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_insecure_redirect.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -7,26 +7,26 @@ env GO111MODULE=on\n env GOPROXY=direct\n env GOSUMDB=off\n \n-! go get -d vcs-test.golang.org/insecure/go/insecure\n+! go mod download vcs-test.golang.org/insecure/go/insecure@latest\n stderr 'redirected .* to insecure URL'\n \n # insecure host\n env GOINSECURE=vcs-test.golang.org\n go clean -modcache\n-go get -d vcs-test.golang.org/insecure/go/insecure\n+go mod download vcs-test.golang.org/insecure/go/insecure@latest\n \n # insecure glob host\n env GOINSECURE=*.golang.org\n go clean -modcache\n-go get -d vcs-test.golang.org/insecure/go/insecure\n+go mod download vcs-test.golang.org/insecure/go/insecure@latest\n \n # insecure multiple host\n env GOINSECURE=somewhere-else.com,*.golang.org\n go clean -modcache\n-go get -d vcs-test.golang.org/insecure/go/insecure\n+go mod download vcs-test.golang.org/insecure/go/insecure@latest\n \n # different insecure host does not fetch\n env GOINSECURE=somewhere-else.com\n go clean -modcache\n-! go get -d vcs-test.golang.org/insecure/go/insecure\n+! go mod download vcs-test.golang.org/insecure/go/insecure@latest\n stderr 'redirected .* to insecure URL'", "previous_filename": "libgo/go/cmd/go/testdata/script/mod_get_insecure_redirect.txt"}, {"sha": "3a02fcd7474b5b795f3159d1ac718e3b541f3764", "filename": "libgo/go/cmd/go/testdata/script/mod_download_partial.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_partial.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_partial.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_partial.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,5 +1,5 @@\n # Download modules and populate go.sum.\n-go get -d -modcacherw\n+go get -modcacherw\n exists $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/go.mod\n \n # 'go mod verify' should fail if we delete a file."}, {"sha": "e126793907241b65c6de002dc3cb200f37dd2fea", "filename": "libgo/go/cmd/go/testdata/script/mod_download_private_vcs.txt", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_private_vcs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_private_vcs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_private_vcs.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,18 +5,18 @@ env GO111MODULE=on\n [!exec:git] skip\n env GOPROXY=direct\n \n-! go get github.com/golang/nonexist\n+! go mod download github.com/golang/nonexist@latest\n stderr 'Confirm the import path was entered correctly.'\n stderr 'If this is a private repository, see https://golang.org/doc/faq#git_https for additional information.'\n ! stdout .\n \n # Fetching a nonexistent commit should return an \"unknown revision\"\n # error message.\n-! go get github.com/golang/term@86186f3aba07ed0212cfb944f3398997d2d07c6b\n-stderr '^go get: github.com/golang/term@86186f3aba07ed0212cfb944f3398997d2d07c6b: invalid version: unknown revision 86186f3aba07ed0212cfb944f3398997d2d07c6b$'\n+! go mod download github.com/golang/term@86186f3aba07ed0212cfb944f3398997d2d07c6b\n+stderr '^go: github.com/golang/term@86186f3aba07ed0212cfb944f3398997d2d07c6b: invalid version: unknown revision 86186f3aba07ed0212cfb944f3398997d2d07c6b$'\n ! stdout .\n \n-! go get github.com/golang/nonexist@master\n+! go mod download github.com/golang/nonexist@master\n stderr '^Confirm the import path was entered correctly.$'\n stderr '^If this is a private repository, see https://golang.org/doc/faq#git_https for additional information.$'\n ! stderr 'unknown revision'", "previous_filename": "libgo/go/cmd/go/testdata/script/mod_get_private_vcs.txt"}, {"sha": "79e00dc9706c9fd80ba7f7a37eec2e076678817b", "filename": "libgo/go/cmd/go/testdata/script/mod_download_svn.txt", "status": "renamed", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_svn.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_svn.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_svn.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,7 +1,7 @@\n [!net] skip\n [!exec:svn] skip\n \n-# 'go get' will fall back to svn+ssh once svn fails over protocols like https.\n+# 'go mod download' will fall back to svn+ssh once svn fails over protocols like https.\n # If vcs-test.golang.org isn't in the user's known_hosts file, this will result\n # in an ssh prompt, which will stop 'go test' entirely\n #\n@@ -19,18 +19,11 @@ env GOPROXY=direct\n env GOSUMDB=off\n \n # Attempting to get a module zip using svn should succeed.\n-go get vcs-test.golang.org/svn/hello.svn@000000000001\n+go mod download vcs-test.golang.org/svn/hello.svn@000000000001\n exists $GOPATH/pkg/mod/cache/download/vcs-test.golang.org/svn/hello.svn/@v/v0.0.0-20170922011245-000000000001.zip\n-exists $GOPATH/bin/hello.svn$GOEXE\n \n # Attempting to get a nonexistent module using svn should fail with a\n # reasonable message instead of a panic.\n-! go get -d vcs-test.golang.org/svn/nonexistent.svn\n+! go mod download vcs-test.golang.org/svn/nonexistent.svn@latest\n ! stderr panic\n-stderr 'go get vcs-test.golang.org/svn/nonexistent.svn: no matching versions for query \"upgrade\"'\n-\n--- go.mod --\n-module golang/go/issues/28943/main\n--- go.sum --\n-vcs-test.golang.org/svn/hello.svn v0.0.0-20170922011245-000000000001 h1:rZjvboXMfQICKXdhx/QHqJ2Y/AQsJVrXnwGqwcTxQiw=\n-vcs-test.golang.org/svn/hello.svn v0.0.0-20170922011245-000000000001/go.mod h1:0memnh/BRLuxiK2zF4rvUgz6ts/fhhB28l3ULFWPusc=\n+stderr 'go: module vcs-test.golang.org/svn/nonexistent.svn: no matching versions for query \"latest\"$'", "previous_filename": "libgo/go/cmd/go/testdata/script/mod_get_svn.txt"}, {"sha": "a6b5a59054872926ed3fceb269e8899bc89c38d2", "filename": "libgo/go/cmd/go/testdata/script/mod_download_too_many_redirects.txt", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_too_many_redirects.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_too_many_redirects.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_too_many_redirects.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,8 +3,8 @@ env GOPROXYBASE=$GOPROXY\n env GOPROXY=$GOPROXYBASE/redirect/11\n env GOSUMDB=off\n \n-! go get -d rsc.io/quote@v1.2.0\n+! go mod download rsc.io/quote@v1.2.0\n stderr 'stopped after 10 redirects'\n \n env GOPROXY=$GOPROXYBASE/redirect/9\n-go get -d rsc.io/quote@v1.2.0\n+go mod download rsc.io/quote@v1.2.0", "previous_filename": "libgo/go/cmd/go/testdata/script/mod_get_too_many_redirects.txt"}, {"sha": "3cffaf6ef1c1cf1bdc6bda4bc1ac6ae79966be00", "filename": "libgo/go/cmd/go/testdata/script/mod_e.txt", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_e.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_e.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_e.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -24,11 +24,11 @@ cmp go.mod.orig go.mod\n \n ! go mod vendor\n \n-stderr '^example.com/untidy imports\\n\\texample.net/directnotfound: cannot find module providing package example.net/directnotfound: module example.net/directnotfound: reading http://.*: 404 Not Found$'\n+stderr '^example.com/untidy imports\\n\\texample.net/directnotfound: no required module provides package example.net/directnotfound; to add it:\\n\\tgo get example.net/directnotfound$'\n \n-stderr '^example.com/untidy imports\\n\\texample.net/m imports\\n\\texample.net/indirectnotfound: cannot find module providing package example.net/indirectnotfound: module example.net/indirectnotfound: reading http://.*: 404 Not Found$'\n+stderr '^example.com/untidy imports\\n\\texample.net/m: module example.net/m provides package example.net/m and is replaced but not required; to add it:\\n\\tgo get example.net/m@v0.1.0$'\n \n-stderr '^example.com/untidy tested by\\n\\texample.com/untidy.test imports\\n\\texample.net/directtestnotfound: cannot find module providing package example.net/directtestnotfound: module example.net/directtestnotfound: reading http://.*: 404 Not Found$'\n+stderr '^example.com/untidy tested by\\n\\texample.com/untidy.test imports\\n\\texample.net/directtestnotfound: no required module provides package example.net/directtestnotfound; to add it:\\n\\tgo get example.net/directtestnotfound$'\n \n ! stderr 'indirecttestnotfound'  # Vendor prunes test dependencies.\n \n@@ -43,15 +43,22 @@ stderr -count=4 'cannot find module providing package'\n cmp go.mod.final go.mod\n \n \n-# 'go mod vendor -e' still logs the errors, but succeeds and updates go.mod.\n-\n+# 'go mod vendor -e' still logs the errors, but creates a vendor directory\n+# and exits with status 0.\n+# 'go mod vendor -e' does not update go.mod and will not vendor packages that\n+# would require changing go.mod, for example, by adding a requirement.\n cp go.mod.orig go.mod\n go mod vendor -e\n-stderr -count=3 'cannot find module providing package'\n-cmp go.mod.final go.mod\n+stderr -count=2 'no required module provides package'\n+stderr '^example.com/untidy imports\\n\\texample.net/m: module example.net/m provides package example.net/m and is replaced but not required; to add it:\\n\\tgo get example.net/m@v0.1.0$'\n exists vendor/modules.txt\n-exists vendor/example.net/m/m.go\n+! exists vendor/example.net\n \n+go mod edit -require example.net/m@v0.1.0\n+go mod vendor -e\n+stderr -count=3 'no required module provides package'\n+exists vendor/modules.txt\n+exists vendor/example.net/m/m.go\n \n -- go.mod --\n module example.com/untidy"}, {"sha": "ebc032a73cf7819171cb48b1137f16d497632d38", "filename": "libgo/go/cmd/go/testdata/script/mod_edit.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -23,18 +23,18 @@ cmpenv go.mod $WORK/go.mod.edit2\n \n # -exclude and -retract reject invalid versions.\n ! go mod edit -exclude=example.com/m@bad\n-stderr '^go mod: -exclude=example.com/m@bad: version \"bad\" invalid: must be of the form v1.2.3$'\n+stderr '^go: -exclude=example.com/m@bad: version \"bad\" invalid: must be of the form v1.2.3$'\n ! go mod edit -retract=bad\n-stderr '^go mod: -retract=bad: version \"bad\" invalid: must be of the form v1.2.3$'\n+stderr '^go: -retract=bad: version \"bad\" invalid: must be of the form v1.2.3$'\n \n ! go mod edit -exclude=example.com/m@v2.0.0\n-stderr '^go mod: -exclude=example.com/m@v2\\.0\\.0: version \"v2\\.0\\.0\" invalid: should be v2\\.0\\.0\\+incompatible \\(or module example\\.com/m/v2\\)$'\n+stderr '^go: -exclude=example.com/m@v2\\.0\\.0: version \"v2\\.0\\.0\" invalid: should be v2\\.0\\.0\\+incompatible \\(or module example\\.com/m/v2\\)$'\n \n ! go mod edit -exclude=example.com/m/v2@v1.0.0\n-stderr '^go mod: -exclude=example.com/m/v2@v1\\.0\\.0: version \"v1\\.0\\.0\" invalid: should be v2, not v1$'\n+stderr '^go: -exclude=example.com/m/v2@v1\\.0\\.0: version \"v1\\.0\\.0\" invalid: should be v2, not v1$'\n \n ! go mod edit -exclude=gopkg.in/example.v1@v2.0.0\n-stderr '^go mod: -exclude=gopkg\\.in/example\\.v1@v2\\.0\\.0: version \"v2\\.0\\.0\" invalid: should be v1, not v2$'\n+stderr '^go: -exclude=gopkg\\.in/example\\.v1@v2\\.0\\.0: version \"v2\\.0\\.0\" invalid: should be v1, not v2$'\n \n cmpenv go.mod $WORK/go.mod.edit2\n "}, {"sha": "58520fab353703d29da5655c000c37530a85ac50", "filename": "libgo/go/cmd/go/testdata/script/mod_edit_go.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -4,7 +4,7 @@\n \n env GO111MODULE=on\n ! go build\n-stderr 'type aliases only supported as of'\n+stderr ' type aliases requires'\n go mod edit -go=1.9\n grep 'go 1.9' go.mod\n go build\n@@ -13,7 +13,7 @@ go build\n # the cached 1.9 build. (https://golang.org/issue/37804)\n go mod edit -go=1.8\n ! go build\n-stderr 'type aliases only supported as of'\n+stderr 'type aliases requires'\n \n \n -- go.mod --"}, {"sha": "92149933686a6fc5e7bdbd9733ac8e414c49c808", "filename": "libgo/go/cmd/go/testdata/script/mod_get_ambiguous_arg.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_arg.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_arg.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_arg.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -4,14 +4,14 @@ cp go.mod go.mod.orig\n # If there is no sensible *package* meaning for 'm/p', it should refer\n # to *module* m/p.\n \n-go get -d m/p  # @latest\n+go get m/p  # @latest\n go list -m all\n stdout '^m/p v0.3.0 '\n ! stdout '^m '\n \n cp go.mod.orig go.mod\n \n-go get -d m/p@v0.1.0\n+go get m/p@v0.1.0\n go list -m all\n stdout '^m/p v0.1.0 '\n ! stdout '^m '\n@@ -22,15 +22,15 @@ stdout '^m/p v0.1.0 '\n # (It only refers to *module* m/p if there is no such package at the\n # requested version.)\n \n-go get -d m/p@v0.2.0\n+go get m/p@v0.2.0\n go list -m all\n stdout '^m v0.2.0 '\n stdout '^m/p v0.1.0 '  # unchanged from the previous case\n \n # Repeating the above with module m/p already in the module graph does not\n # change its meaning.\n \n-go get -d m/p@v0.2.0\n+go get m/p@v0.2.0\n go list -m all\n stdout '^m v0.2.0 '\n stdout '^m/p v0.1.0 '"}, {"sha": "0af78bd4f252d737e2880c783055dd4414fea408", "filename": "libgo/go/cmd/go/testdata/script/mod_get_ambiguous_import.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_import.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -8,14 +8,14 @@ cp go.mod go.mod.orig\n #\n # TODO(#27899): Should we automatically upgrade example.net/m to v0.2.0\n # to resolve the conflict?\n-! go get -d example.net/m/p@v1.0.0\n+! go get example.net/m/p@v1.0.0\n stderr '^example.net/m/p: ambiguous import: found package example.net/m/p in multiple modules:\\n\\texample.net/m v0.1.0 \\(.*[/\\\\]m1[/\\\\]p\\)\\n\\texample.net/m/p v1.0.0 \\(.*[/\\\\]p0\\)\\n\\z'\n cmp go.mod go.mod.orig\n \n # Upgrading both modules simultaneously resolves the ambiguous upgrade.\n # Note that this command line mixes a module path (example.net/m)\n # and a package path (example.net/m/p) in the same command.\n-go get -d example.net/m@v0.2.0 example.net/m/p@v1.0.0\n+go get example.net/m@v0.2.0 example.net/m/p@v1.0.0\n \n go list -m all\n stdout '^example.net/m v0.2.0 '"}, {"sha": "1641196007b8e166a685f00d292207a72b69d25c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_ambiguous_pkg.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_pkg.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_pkg.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_ambiguous_pkg.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -8,7 +8,7 @@ cp go.mod go.mod.orig\n # From a clean slate, 'go get' currently does the same thing as 'go mod tidy':\n # it resolves the package from the module with the longest matching prefix.\n \n-go get -d example.net/ambiguous/nested/pkg@v0.1.0\n+go get example.net/ambiguous/nested/pkg@v0.1.0\n go list -m all\n stdout '^example.net/ambiguous/nested v0.1.0$'\n ! stdout '^example.net/ambiguous '\n@@ -21,7 +21,7 @@ stdout '^example.net/ambiguous/nested v0.1.0$'\n cp go.mod.orig go.mod\n go mod edit -require=example.net/ambiguous@v0.1.0\n \n-go get -d example.net/ambiguous/nested/pkg@v0.1.0\n+go get example.net/ambiguous/nested/pkg@v0.1.0\n go list -m all\n stdout '^example.net/ambiguous v0.1.0$'\n ! stdout '^example.net/ambiguous/nested '\n@@ -30,7 +30,7 @@ stdout '^example.net/ambiguous v0.1.0$'\n # The user should be able to make the command unambiguous by explicitly\n # upgrading the conflicting module...\n \n-go get -d example.net/ambiguous@v0.2.0 example.net/ambiguous/nested/pkg@v0.1.0\n+go get example.net/ambiguous@v0.2.0 example.net/ambiguous/nested/pkg@v0.1.0\n go list -m all\n stdout '^example.net/ambiguous/nested v0.1.0$'\n stdout '^example.net/ambiguous v0.2.0$'\n@@ -41,7 +41,7 @@ stdout '^example.net/ambiguous v0.2.0$'\n cp go.mod.orig go.mod\n go mod edit -require=example.net/ambiguous@v0.1.0\n \n-go get -d example.net/ambiguous/nested/pkg@v0.1.0 example.net/ambiguous/nested@none\n+go get example.net/ambiguous/nested/pkg@v0.1.0 example.net/ambiguous/nested@none\n go list -m all\n ! stdout '^example.net/ambiguous/nested '\n stdout '^example.net/ambiguous v0.1.0$'\n@@ -53,7 +53,7 @@ stdout '^example.net/ambiguous v0.1.0$'\n cp go.mod.orig go.mod\n go mod edit -require=example.net/ambiguous@v0.1.0\n \n-go get -d example.net/ambiguous@none example.net/ambiguous/nested/pkg@v0.1.0\n+go get example.net/ambiguous@none example.net/ambiguous/nested/pkg@v0.1.0\n go list -m all\n stdout '^example.net/ambiguous/nested v0.1.0$'\n ! stdout '^example.net/ambiguous '\n@@ -66,7 +66,7 @@ stdout '^example.net/ambiguous/nested v0.1.0$'\n \n cp go.mod.orig go.mod\n \n-go get -d example.net/ambiguous/nested/pkg/...@v0.1.0\n+go get example.net/ambiguous/nested/pkg/...@v0.1.0\n go list -m all\n stdout '^example.net/ambiguous/nested v0.1.0$'\n ! stdout '^example.net/ambiguous '\n@@ -75,7 +75,7 @@ stdout '^example.net/ambiguous/nested v0.1.0$'\n cp go.mod.orig go.mod\n go mod edit -require=example.net/ambiguous@v0.1.0\n \n-go get -d example.net/ambiguous/nested/pkg/...@v0.1.0\n+go get example.net/ambiguous/nested/pkg/...@v0.1.0\n go list -m all\n ! stdout '^example.net/ambiguous/nested '\n stdout '^example.net/ambiguous v0.1.0$'"}, {"sha": "12a112b4d87af75c8302dad7e5c1eedfbfec8a09", "filename": "libgo/go/cmd/go/testdata/script/mod_get_changes.txt", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_changes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_changes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_changes.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,9 +3,9 @@\n # for changed indirect dependencies.\n go list -m all\n ! stdout golang.org/x/text\n-go get -d rsc.io/quote@v1.5.2\n-stderr '^go get: added rsc.io/quote v1.5.2$'\n-stderr '^go get: upgraded rsc.io/sampler v1.0.0 => v1.3.0$'\n+go get rsc.io/quote@v1.5.2\n+stderr '^go: added rsc.io/quote v1.5.2$'\n+stderr '^go: upgraded rsc.io/sampler v1.0.0 => v1.3.0$'\n ! stderr '^go get.*golang.org/x/text'\n go list -m all\n stdout golang.org/x/text\n@@ -14,18 +14,18 @@ cmp go.mod go.mod.upgrade\n # When removing a requirement, 'go get' prints a message for the requiremnent\n # and for changed explicit dependencies. 'go get' does not print messages\n # for changed indirect dependencies.\n-go get -d rsc.io/sampler@none\n-stderr '^go get: downgraded rsc.io/quote v1.5.2 => v1.3.0$'\n-stderr '^go get: removed rsc.io/sampler v1.3.0$'\n+go get rsc.io/sampler@none\n+stderr '^go: downgraded rsc.io/quote v1.5.2 => v1.3.0$'\n+stderr '^go: removed rsc.io/sampler v1.3.0$'\n ! stderr '^go get.*golang.org/x/text'\n cmp go.mod go.mod.downgrade\n \n # When removing or downgrading a requirement, 'go get' also prints a message\n # for explicit dependencies removed as a consequence.\n cp go.mod.usequote go.mod\n-go get -d rsc.io/quote@v1.5.1\n-stderr '^go get: downgraded rsc.io/quote v1.5.2 => v1.5.1$'\n-stderr '^go get: removed usequote v0.0.0$'\n+go get rsc.io/quote@v1.5.1\n+stderr '^go: downgraded rsc.io/quote v1.5.2 => v1.5.1$'\n+stderr '^go: removed usequote v0.0.0$'\n \n -- go.mod --\n module m"}, {"sha": "d31cee1444a6adf5dcc8b4706f06584dbf31ae3c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_cmd.txt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_cmd.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56779dbc4e2d9c15be8d31e36f2f59be7331a8/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_cmd.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_cmd.txt?ref=9a56779dbc4e2d9c15be8d31e36f2f59be7331a8", "patch": "@@ -1,20 +0,0 @@\n-env GO111MODULE=on\n-[short] skip\n-\n-# Test that when 'go get' is run from $GOBIN, it does not delete binaries\n-# after it installs them. Verifies golang.org/issue/32766.\n-\n-go get example.com/tools/cmd/hello\n-\n-# 'go get' should not delete the command when run from $GOPATH/bin\n-cd $GOPATH/bin\n-exists hello$GOEXE\n-go get example.com/tools/cmd/hello\n-exists hello$GOEXE\n-\n-# 'go get' should not delete the command when run from a different $GOBIN\n-mkdir $WORK/bin\n-cd $WORK/bin\n-env GOBIN=$WORK/bin\n-go get example.com/tools/cmd/hello\n-exists hello$GOEXE"}, {"sha": "f60eaab3a77e09d4aee4c57839ce7098f1443f89", "filename": "libgo/go/cmd/go/testdata/script/mod_get_commit.txt", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_commit.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,46 +5,47 @@ env GO111MODULE=on\n \n # golang.org/x/text/language@commit should resolve.\n # Because of -d, the compiler should not run.\n-go get -d -x golang.org/x/text/language@14c0d48\n+go get -x golang.org/x/text/language@14c0d48\n ! stderr 'compile|cp|gccgo .*language\\.a$'\n \n # go get should skip build with no Go files in root\n-go get -d golang.org/x/text@14c0d48\n+go get golang.org/x/text@14c0d48\n \n # dropping -d, we should see a build.\n [short] skip\n \n env GOCACHE=$WORK/gocache  # Looking for compile commands, so need a clean cache.\n \n-go get -x golang.org/x/text/language@14c0d48\n+go build -x golang.org/x/text/language\n stderr 'compile|cp|gccgo .*language\\.a$'\n \n # BUG: after the build, the package should not be stale, as 'go install' would\n # not do anything further.\n go list -f '{{.Stale}}' golang.org/x/text/language\n stdout ^true\n \n-# install after get should not run the compiler again.\n+# install after build should not run the compiler again.\n go install -x golang.org/x/text/language\n ! stderr 'compile|cp|gccgo .*language\\.a$'\n \n-# even with -d, we should see an error for unknown packages.\n-! go get -d -x golang.org/x/text/foo@14c0d48\n+# we should see an error for unknown packages.\n+! go get -x golang.org/x/text/foo@14c0d48\n+stderr '^go: module golang.org/x/text@14c0d48 found \\(v0.3.0\\), but does not contain package golang.org/x/text/foo$'\n \n # get pseudo-version should record that version\n-go get -d rsc.io/quote@v0.0.0-20180214005840-23179ee8a569\n+go get rsc.io/quote@v0.0.0-20180214005840-23179ee8a569\n grep 'rsc.io/quote v0.0.0-20180214005840-23179ee8a569' go.mod\n \n # but as commit should record as v1.5.1\n-go get -d rsc.io/quote@23179ee8\n+go get rsc.io/quote@23179ee8\n grep 'rsc.io/quote v1.5.1' go.mod\n \n # go mod edit -require does not interpret commits\n go mod edit -require rsc.io/quote@23179ee\n grep 'rsc.io/quote 23179ee' go.mod\n \n # but other commands fix them\n-go mod graph\n+go list -m -mod=mod all\n grep 'rsc.io/quote v1.5.1' go.mod\n \n -- go.mod --"}, {"sha": "03258f52966fc745f3a1e01ac0b182e285c18b13", "filename": "libgo/go/cmd/go/testdata/script/mod_get_deprecate_install.txt", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_deprecate_install.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_deprecate_install.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_deprecate_install.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -2,24 +2,27 @@\n \n env GO111MODULE=on\n \n-# 'go get' outside a module with an executable prints a deprecation message.\n-go get example.com/cmd/a\n-stderr '^go get: installing executables with ''go get'' in module mode is deprecated.$'\n-stderr 'Use ''go install pkg@version'' instead.'\n+# 'go get' outside a module prints an error.\n+! go get example.com/cmd/a\n+stderr '^go: go.mod file not found in current directory or any parent directory.$'\n+stderr '^\\t''go get'' is no longer supported outside a module.$'\n \n cp go.mod.orig go.mod\n \n # 'go get' inside a module with a non-main package does not print a message.\n # This will stop building in the future, but it's the command we want to use.\n go get rsc.io/quote\n ! stderr deprecated\n+! stderr 'no longer installs'\n cp go.mod.orig go.mod\n \n-# 'go get' inside a module with an executable prints a different\n-# deprecation message.\n+# 'go get' inside a module with an executable does not print a message.\n+# In 1.16 and 1.17, 'go get' did print a message in this case suggesting the\n+# use of -d. In 1.18, -d is a no-op, and we'd like to begin discouraging\n+# its use.\n go get example.com/cmd/a\n-stderr '^go get: installing executables with ''go get'' in module mode is deprecated.$'\n-stderr 'To adjust and download dependencies of the current module, use ''go get -d'''\n+! stderr deprecated\n+! stderr 'no longer installs'\n cp go.mod.orig go.mod\n \n # 'go get' should not print a warning for a main package inside the main module."}, {"sha": "ec7bcfdb997e2e57218f11108430f09f46ab1862", "filename": "libgo/go/cmd/go/testdata/script/mod_get_deprecated.txt", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_deprecated.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_deprecated.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_deprecated.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,31 +1,31 @@\n # 'go get pkg' should not show a deprecation message for an unrelated module.\n-go get -d ./use/nothing\n+go get ./use/nothing\n ! stderr 'module.*is deprecated'\n \n # 'go get pkg' should show a deprecation message for the module providing pkg.\n-go get -d example.com/deprecated/a\n+go get example.com/deprecated/a\n stderr '^go: module example.com/deprecated/a is deprecated: in example.com/deprecated/a@v1.9.0$'\n-go get -d example.com/deprecated/a@v1.0.0\n+go get example.com/deprecated/a@v1.0.0\n stderr '^go: module example.com/deprecated/a is deprecated: in example.com/deprecated/a@v1.9.0$'\n \n # 'go get pkg' should show a deprecation message for a module providing\n # packages directly imported by pkg.\n-go get -d ./use/a\n+go get ./use/a\n stderr '^go: module example.com/deprecated/a is deprecated: in example.com/deprecated/a@v1.9.0$'\n \n # 'go get pkg' may show a deprecation message for an indirectly required module\n # if it provides a package named on the command line.\n-go get -d ./use/b\n+go get ./use/b\n ! stderr 'module.*is deprecated'\n-go get -d local/use\n+go get local/use\n ! stderr 'module.*is deprecated'\n-go get -d example.com/deprecated/b\n+go get example.com/deprecated/b\n stderr '^go: module example.com/deprecated/b is deprecated: in example.com/deprecated/b@v1.9.0$'\n \n # 'go get pkg' does not show a deprecation message for a module providing a\n # directly imported package if the module is no longer deprecated in its\n # latest version, even if the module is deprecated in its current version.\n-go get -d ./use/undeprecated\n+go get ./use/undeprecated\n ! stderr 'module.*is deprecated'\n \n -- go.mod --"}, {"sha": "856e05bc329328d2fe33771d12e8ac7d7cfb11a2", "filename": "libgo/go/cmd/go/testdata/script/mod_get_direct.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_direct.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_direct.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_direct.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -10,7 +10,7 @@ env GO111MODULE=on\n env GOPROXY=direct\n env GOSUMDB=off\n \n-go list -m cloud.google.com/go@master\n+go list -m cloud.google.com/go@main\n ! stdout 'v0.0.0-'\n \n -- go.mod --"}, {"sha": "0f5ba992da204ed28a6854cb29b0e6807f348e34", "filename": "libgo/go/cmd/go/testdata/script/mod_get_downadd_indirect.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downadd_indirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downadd_indirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downadd_indirect.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -18,7 +18,7 @@ cp go.mod go.mod.orig\n go mod tidy\n cmp go.mod.orig go.mod\n \n-go get -d example.com/d@v0.1.0\n+go get example.com/d@v0.1.0\n go list -m all\n stdout '^example.com/b v0.1.0 '\n stdout '^example.com/c v0.1.0 '"}, {"sha": "2eed56d9b71b899dac731e794e6bc18a50815653", "filename": "libgo/go/cmd/go/testdata/script/mod_get_downgrade.txt", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -3,33 +3,33 @@ env GO111MODULE=on\n \n # downgrade sampler should downgrade quote\n cp go.mod.orig go.mod\n-go get -d rsc.io/sampler@v1.0.0\n+go get rsc.io/sampler@v1.0.0\n go list -m all\n stdout 'rsc.io/quote v1.4.0'\n stdout 'rsc.io/sampler v1.0.0'\n \n # downgrade sampler away should downgrade quote further\n-go get -d rsc.io/sampler@none\n+go get rsc.io/sampler@none\n go list -m all\n stdout 'rsc.io/quote v1.3.0'\n \n # downgrade should report inconsistencies and not change go.mod\n-go get -d rsc.io/quote@v1.5.1\n+go get rsc.io/quote@v1.5.1\n go list -m all\n stdout 'rsc.io/quote v1.5.1'\n stdout 'rsc.io/sampler v1.3.0'\n \n-! go get -d rsc.io/sampler@v1.0.0 rsc.io/quote@v1.5.2 golang.org/x/text@none\n-stderr -count=1 '^go get:'\n-stderr '^go get: rsc.io/quote@v1.5.2 requires rsc.io/sampler@v1.3.0, not rsc.io/sampler@v1.0.0$'\n+! go get rsc.io/sampler@v1.0.0 rsc.io/quote@v1.5.2 golang.org/x/text@none\n+! stderr add|remove|upgrad|downgrad\n+stderr '^go: rsc.io/quote@v1.5.2 requires rsc.io/sampler@v1.3.0, not rsc.io/sampler@v1.0.0$'\n \n go list -m all\n stdout 'rsc.io/quote v1.5.1'\n stdout 'rsc.io/sampler v1.3.0'\n \n # go get -u args should limit upgrades\n cp go.mod.empty go.mod\n-go get -d -u rsc.io/quote@v1.4.0 rsc.io/sampler@v1.0.0\n+go get -u rsc.io/quote@v1.4.0 rsc.io/sampler@v1.0.0\n go list -m all\n stdout 'rsc.io/quote v1.4.0'\n stdout 'rsc.io/sampler v1.0.0'\n@@ -40,7 +40,7 @@ stdout 'rsc.io/sampler v1.0.0'\n cp go.mod.orig go.mod\n go list -m -versions example.com/latemigrate/v2\n stdout v2.0.0 # proxy may serve incompatible versions\n-go get -d rsc.io/quote@none\n+go get rsc.io/quote@none\n go list -m all\n ! stdout 'example.com/latemigrate/v2'\n "}, {"sha": "582593b96cdfb6241e403216c214fd2668642549", "filename": "libgo/go/cmd/go/testdata/script/mod_get_downgrade_missing.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade_missing.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade_missing.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downgrade_missing.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -4,15 +4,15 @@ cp go.mod go.mod.orig\n # not yet present in that module should report the version mismatch\n # rather than a \"matched no packages\" warning.\n \n-! go get -d example.net/pkgadded@v1.1.0 example.net/pkgadded/subpkg/...\n-stderr '^go get: example.net/pkgadded@v1.1.0 conflicts with example.net/pkgadded/subpkg/...@upgrade \\(v1.2.0\\)$'\n+! go get example.net/pkgadded@v1.1.0 example.net/pkgadded/subpkg/...\n+stderr '^go: example.net/pkgadded@v1.1.0 conflicts with example.net/pkgadded/subpkg/...@upgrade \\(v1.2.0\\)$'\n ! stderr 'matched no packages'\n cmp go.mod.orig go.mod\n \n \n # A wildcard pattern should match the pattern with that path.\n \n-go get -d example.net/pkgadded/...@v1.0.0\n+go get example.net/pkgadded/...@v1.0.0\n go list -m all\n stdout '^example.net/pkgadded v1.0.0'\n cp go.mod.orig go.mod\n@@ -22,12 +22,12 @@ cp go.mod.orig go.mod\n # and another argument constrains away the version that provides that\n # package, then 'go get' should fail with a useful error message.\n \n-! go get -d example.net/pkgadded@v1.0.0 .\n+! go get example.net/pkgadded@v1.0.0 .\n stderr '^example.com/m imports\\n\\texample.net/pkgadded/subpkg: cannot find module providing package example.net/pkgadded/subpkg$'\n ! stderr 'example.net/pkgadded v1\\.2\\.0'\n cmp go.mod.orig go.mod\n \n-go get -d example.net/pkgadded@v1.0.0\n+go get example.net/pkgadded@v1.0.0\n ! go list -deps -mod=readonly .\n stderr '^m.go:3:8: cannot find module providing package example\\.net/pkgadded/subpkg: '\n "}, {"sha": "111a54f8f7370cacb24af0852354e88246185921", "filename": "libgo/go/cmd/go/testdata/script/mod_get_downup_artifact.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_artifact.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_artifact.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_artifact.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -55,7 +55,7 @@ stdout '^example.com/d v0.1.0 '\n # upgrades of module d and addition of module e, which are not relevant to\n # b@v0.1.0 and should not be added to the main module's dependencies.\n \n-go get -u -d example.com/a@latest example.com/c@v0.1.0\n+go get -u example.com/a@latest example.com/c@v0.1.0\n \n go list -m all\n stdout '^example.com/a v0.1.0 '"}, {"sha": "3a46a774ce7c4516ae97074111f3db5d6196fec4", "filename": "libgo/go/cmd/go/testdata/script/mod_get_downup_indirect.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_indirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_indirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_indirect.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -25,7 +25,7 @@ cp go.mod go.mod.orig\n go mod tidy\n cmp go.mod.orig go.mod\n \n-go get -d example.com/d@v0.1.0\n+go get example.com/d@v0.1.0\n go list -m all\n ! stdout '^example.com/b '\n ! stdout '^example.com/c '"}, {"sha": "b678a177b521e32619b4afd6058e839813026327", "filename": "libgo/go/cmd/go/testdata/script/mod_get_downup_pseudo_artifact.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_pseudo_artifact.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_pseudo_artifact.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_downup_pseudo_artifact.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -28,7 +28,7 @@ cmp go.mod.orig go.mod\n \n # When we downgrade d.2 to d.1, no dependency on e should be added\n # because nothing else in the module or import graph requires it.\n-go get -d example.net/d@v0.1.0\n+go get example.net/d@v0.1.0\n \n go list -m all\n stdout '^example.net/b v0.2.1-0.20210219000000-000000000000 '"}, {"sha": "7cb03ce2f1e6b5b4f5b5efd63110653c0a172740", "filename": "libgo/go/cmd/go/testdata/script/mod_get_errors.txt", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_errors.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_errors.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_errors.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -1,35 +1,23 @@\n cp go.mod go.mod.orig\n \n \n-# Both 'go get' and 'go get -d' should fail, without updating go.mod,\n-# if the transitive dependencies of the requested package (by default,\n-# the package in the current directory) cannot be resolved.\n+# 'go get' should fail, without updating go.mod, if the transitive dependencies\n+# of the requested package (by default, the package in the current directory)\n+# cannot be resolved.\n \n ! go get\n stderr '^example.com/m imports\\n\\texample.com/badimport imports\\n\\texample.net/oops: cannot find module providing package example.net/oops$'\n cmp go.mod.orig go.mod\n \n-! go get -d\n-stderr '^example.com/m imports\\n\\texample.com/badimport imports\\n\\texample.net/oops: cannot find module providing package example.net/oops$'\n-cmp go.mod.orig go.mod\n-\n cd importsyntax\n \n \n-# If 'go get' fails due to a compile error (such as a syntax error),\n-# it should not update the go.mod file.\n-\n-! go get\n-stderr '^..[/\\\\]badimport[/\\\\]syntaxerror[/\\\\]syntaxerror.go:1:1: expected ''package'', found pack$'  # TODO: An import stack would be nice.\n-cmp ../go.mod.orig ../go.mod\n-\n-\n # A syntax error in a dependency prevents the compiler from needing that\n-# dependency's imports, so 'go get -d' should not report an error when those\n+# dependency's imports, so 'go get' should not report an error when those\n # imports cannot be resolved: it has all of the dependencies that the compiler\n # needs, and the user did not request to run the compiler.\n \n-go get -d\n+go get\n cmp ../go.mod.syntax-d ../go.mod\n \n "}, {"sha": "083e03678e48f1ebc0ffa5b1baece7841e8d258a", "filename": "libgo/go/cmd/go/testdata/script/mod_get_extra.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_extra.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_extra.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_extra.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -4,7 +4,7 @@ cp go.mod go.mod.orig\n # determined by explicit queries to any version other than the explicit one.\n # Otherwise, 'go get -u' could introduce spurious dependencies.\n \n-go get -d -u example.net/a@v0.1.0 example.net/b@v0.1.0\n+go get -u example.net/a@v0.1.0 example.net/b@v0.1.0\n go list -m all\n stdout '^example.net/a v0.1.0 '\n stdout '^example.net/b v0.1.0 '\n@@ -16,7 +16,7 @@ stdout '^example.net/b v0.1.0 '\n \n cp go.mod.orig go.mod\n \n-go get -d -u example.net/a@v0.1.0 example.net/b/...@v0.1.0\n+go get -u example.net/a@v0.1.0 example.net/b/...@v0.1.0\n go list -m all\n stdout '^example.net/a v0.1.0 '\n stdout '^example.net/b v0.1.0 '"}, {"sha": "35722333d6a0e86b195f80ff13f1fa73c56fa3d1", "filename": "libgo/go/cmd/go/testdata/script/mod_get_fallback.txt", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -5,6 +5,11 @@ env GO111MODULE=on\n env GOPROXY=https://proxy.golang.org,direct\n env GOSUMDB=off\n \n-go get -x -v -d golang.org/x/tools/cmd/goimports\n+go get -x -v golang.org/x/tools/cmd/goimports\n stderr '# get https://proxy.golang.org/golang.org/x/tools/@v/list'\n ! stderr '# get https://golang.org'\n+\n+-- go.mod --\n+module m\n+\n+go 1.18"}, {"sha": "c2d42f0f596f4a01b0077a54aa515b9fba1f4f68", "filename": "libgo/go/cmd/go/testdata/script/mod_get_fossil.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fossil.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fossil.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fossil.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494", "patch": "@@ -18,11 +18,10 @@ env GOSUMDB=off\n env USER=fossiluser\n env FOSSIL_HOME=$WORK/home\n \n-# Attempting to get the latest version of a fossil repo.\n+# Attempt to get the latest version of a fossil repo.\n go get vcs-test.golang.org/fossil/hello.fossil\n ! stderr 'unexpected response from fossil info'\n grep 'vcs-test.golang.org/fossil/hello.fossil' go.mod\n-exists $GOPATH/bin/hello.fossil$GOEXE\n \n -- go.mod --\n module x"}, {"sha": "c81e491b947ecbe93955979ad978dfba8be7497d", "filename": "libgo/go/cmd/go/testdata/script/mod_get_go_file.txt", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_go_file.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_go_file.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_go_file.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "5a7d70637180af3eb4c7c5483c102c47819523c8", "filename": "libgo/go/cmd/go/testdata/script/mod_get_incompatible.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_incompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_incompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_incompatible.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "fa7edf22d7b997d0abd8648023d86488229e9b51", "filename": "libgo/go/cmd/go/testdata/script/mod_get_indirect.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_indirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_indirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_indirect.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "9392e73a174bd69e8efdfe49753f28f2f7d0d6fd", "filename": "libgo/go/cmd/go/testdata/script/mod_get_issue37438.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue37438.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue37438.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue37438.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "848ee3aa09a9ad3d696b0ed30c37ed3332666145", "filename": "libgo/go/cmd/go/testdata/script/mod_get_issue47979.txt", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue47979.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue47979.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue47979.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "0ba486d35bd6cecc2d8a6f4236c42613e445f7be", "filename": "libgo/go/cmd/go/testdata/script/mod_get_issue48511.txt", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue48511.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue48511.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_issue48511.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "00da0c316469f9bd3d5e54f8bd67eb931b53047c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_latest_pseudo.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_latest_pseudo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_latest_pseudo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_latest_pseudo.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "3dae383de1e57bd5c9d664c290da73470c0fedab", "filename": "libgo/go/cmd/go/testdata/script/mod_get_lazy_upgrade_lazy.txt", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_lazy_upgrade_lazy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_lazy_upgrade_lazy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_lazy_upgrade_lazy.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "4c81d16a1fe072058a6cd4aeb5abcc6fc1ab519d", "filename": "libgo/go/cmd/go/testdata/script/mod_get_local.txt", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_local.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_local.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_local.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "cddd5f70826eb406a18e9efb55ed018f241f4ab0", "filename": "libgo/go/cmd/go/testdata/script/mod_get_main.txt", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "2db13180bd79786283919bba2e6e5d61ebe2c5c3", "filename": "libgo/go/cmd/go/testdata/script/mod_get_major.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_major.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_major.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_major.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "5934251e4b8b74688a40d060c261147b77a3e6d1", "filename": "libgo/go/cmd/go/testdata/script/mod_get_missing_ziphash.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_missing_ziphash.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_missing_ziphash.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_missing_ziphash.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "ba79c8263c06dab4ab02ee466cf08275b99ea02c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_moved.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_moved.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_moved.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_moved.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "18dc6503617a566937844904736f80c50ab2a341", "filename": "libgo/go/cmd/go/testdata/script/mod_get_newcycle.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "5aec209f59fe6fa54ffa3f67ce9d31d73fb665de", "filename": "libgo/go/cmd/go/testdata/script/mod_get_none.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_none.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_none.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_none.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "14176a7dc8786d0538c10ea5ec61b1fe1adefdba", "filename": "libgo/go/cmd/go/testdata/script/mod_get_nopkgs.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_nopkgs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_nopkgs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_nopkgs.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "35cc276c5c36839788d2e7dd60be4f122d9d648b", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patch.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patch.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patch.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patch.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "e4d3c491f45611f45919ef3aca1c3a0d26efe6dd", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patchbound.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchbound.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchbound.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchbound.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "6600109d2dad9be00b39c17478dec0ec17f1a8f4", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patchcycle.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchcycle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchcycle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchcycle.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "28277310aa15e5041c137d69dcc2bbdf9cefb242", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patchmod.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchmod.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchmod.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patchmod.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "891353fd4b9a0b6ef59098a609bbe97ddc2112ae", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patterns.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "7ad3c3c7c44a4caf8c40c05f8d764580815f587b", "filename": "libgo/go/cmd/go/testdata/script/mod_get_pkgtags.txt", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pkgtags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pkgtags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pkgtags.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "06e2fc686029184d8b15cfa2f0b4e39edb8aad7f", "filename": "libgo/go/cmd/go/testdata/script/mod_get_prefer_incompatible.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_prefer_incompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_prefer_incompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_prefer_incompatible.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "03f6810e354a0a3e56a112a424b499ffdb7d1fcb", "filename": "libgo/go/cmd/go/testdata/script/mod_get_promote_implicit.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_promote_implicit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_promote_implicit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_promote_implicit.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "b964ae448453b9860fa1d854109110e975649b7c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_pseudo.txt", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "d085f4fa3c8e6b2319bce5ed94c9b569f58d3ded", "filename": "libgo/go/cmd/go/testdata/script/mod_get_pseudo_other_branch.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo_other_branch.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo_other_branch.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo_other_branch.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "8e6cd907f183495842855232179f2ed9f16e3bb1", "filename": "libgo/go/cmd/go/testdata/script/mod_get_pseudo_prefix.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo_prefix.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo_prefix.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_pseudo_prefix.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "b1fc8b80563307cb948b50361507275bd8b578ff", "filename": "libgo/go/cmd/go/testdata/script/mod_get_replaced.txt", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_replaced.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_replaced.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_replaced.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "9757989666728eb3050c3c63a8cd37fce848f6cb", "filename": "libgo/go/cmd/go/testdata/script/mod_get_retract.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_retract.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_retract.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_retract.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "4b4f5da03cdba618d7abed6d297c71af5572f8e9", "filename": "libgo/go/cmd/go/testdata/script/mod_get_retract_ambiguous.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_retract_ambiguous.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_retract_ambiguous.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_retract_ambiguous.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "0fb22c85d3943efb3d01890772c599962ebd0817", "filename": "libgo/go/cmd/go/testdata/script/mod_get_split.txt", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_split.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_split.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_split.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "0d9a840e779cc4334544df743213f67ea58b5cc7", "filename": "libgo/go/cmd/go/testdata/script/mod_get_sum_noroot.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_sum_noroot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_sum_noroot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_sum_noroot.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "e4fb6c4326b46f52a14b4d8316896a9e18e0d5ce", "filename": "libgo/go/cmd/go/testdata/script/mod_get_tags.txt", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_tags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_tags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_tags.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "0fa7cd98b98fb2fd0f38d08d35ce27b0503a6484", "filename": "libgo/go/cmd/go/testdata/script/mod_get_test.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "7b469008baffd414014094578da7b0ee36618b3b", "filename": "libgo/go/cmd/go/testdata/script/mod_get_trailing_slash.txt", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "a5651e934181a70dc5e302193792fb939bbe4bd9", "filename": "libgo/go/cmd/go/testdata/script/mod_get_update_unrelated_sum.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_update_unrelated_sum.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_update_unrelated_sum.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_update_unrelated_sum.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "51d5990ee179c73a90bcd42661a29f764313a813", "filename": "libgo/go/cmd/go/testdata/script/mod_get_upgrade.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "deff9358f060f462a74c0ab349a97139d553202e", "filename": "libgo/go/cmd/go/testdata/script/mod_get_upgrade_pseudo.txt", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade_pseudo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade_pseudo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade_pseudo.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "06f9973e431932f35923d937e0e3378247b9ad7a", "filename": "libgo/go/cmd/go/testdata/script/mod_get_wild.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_wild.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_wild.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_wild.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "aaf526b2ab54beb3245ea4737a313bc54456055f", "filename": "libgo/go/cmd/go/testdata/script/mod_getmode_vendor.txt", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getmode_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getmode_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getmode_vendor.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "b3d06c17c85afa0111bdcc10999d5425a2d8deca", "filename": "libgo/go/cmd/go/testdata/script/mod_getx.txt", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getx.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getx.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getx.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "2159a1e4c0ee5ec0f60fc1ca5d3ebca6fd4e2fd5", "filename": "libgo/go/cmd/go/testdata/script/mod_go_version_missing.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version_missing.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version_missing.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version_missing.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "bafa5876241ece08b9e06340673761bf912ce7bf", "filename": "libgo/go/cmd/go/testdata/script/mod_gomodcache.txt", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gomodcache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gomodcache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gomodcache.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "d42d668f679eeaf57a76adcdda70d0f6ee313dca", "filename": "libgo/go/cmd/go/testdata/script/mod_gonoproxy.txt", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gonoproxy.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "beba3e7b02cd6b3e12d62428e5df0ee61a544661", "filename": "libgo/go/cmd/go/testdata/script/mod_gopkg_unstable.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gopkg_unstable.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gopkg_unstable.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gopkg_unstable.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}, {"sha": "07714e92c720d1d498e4fb4000f6bf00a669399d", "filename": "libgo/go/cmd/go/testdata/script/mod_import.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2499aa62f768c6395c9754b8cabc1ce25c494/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_import.txt?ref=8dc2499aa62f768c6395c9754b8cabc1ce25c494"}]}