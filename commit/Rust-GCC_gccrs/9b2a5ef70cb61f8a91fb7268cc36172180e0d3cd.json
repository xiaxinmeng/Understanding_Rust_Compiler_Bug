{"sha": "9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIyYTVlZjcwY2I2MWY4YTkxZmI3MjY4Y2MzNjE3MjE4MGUwZDNjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-07-30T00:34:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-07-30T00:34:47Z"}, "message": "cgraph.c (cgraph_set_call_stmt_including_clones): Tidy.\n\n        * cgraph.c (cgraph_set_call_stmt_including_clones): Tidy.\n        (cgraph_create_edge_including_clones): Likewise.\n        * tree-inline.c (copy_bb): Operate on the correct edges\n        when updating the callgraph.\n\nFrom-SVN: r150234", "tree": {"sha": "23026fcdcd9433b2a8685cc8e5e252e7bee82279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23026fcdcd9433b2a8685cc8e5e252e7bee82279"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd/comments", "author": null, "committer": null, "parents": [{"sha": "2f5164ee55b442cf588b0f8eba915e153eaf769b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5164ee55b442cf588b0f8eba915e153eaf769b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f5164ee55b442cf588b0f8eba915e153eaf769b"}], "stats": {"total": 154, "additions": 86, "deletions": 68}, "files": [{"sha": "d61bf2d52b86a9f75dadb79c1a2e600fb70a20e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd", "patch": "@@ -1,3 +1,10 @@\n+2009-07-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* cgraph.c (cgraph_set_call_stmt_including_clones): Tidy.\n+\t(cgraph_create_edge_including_clones): Likewise.\n+\t* tree-inline.c (copy_bb): Operate on the correct edges\n+\twhen updating the callgraph.\n+\n 2009-07-29  Douglas B Rupp  <rupp@gnat.com>\n \n \t* config/alpha/vms-cc.c: Deleted."}, {"sha": "ded99f9cb81837579865c09847072e7e3afa1c28", "filename": "gcc/cgraph.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd", "patch": "@@ -654,8 +654,8 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n     }\n }\n \n-/* Like cgraph_set_call_stmt but walk the clone tree and update all clones sharing\n-   same function body.  */\n+/* Like cgraph_set_call_stmt but walk the clone tree and update all\n+   clones sharing the same function body.  */\n \n void\n cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n@@ -666,8 +666,10 @@ cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n \n   if (edge)\n     cgraph_set_call_stmt (edge, new_stmt);\n-  if (orig->clones)\n-    for (node = orig->clones; node != orig;)\n+\n+  node = orig->clones;\n+  if (node)\n+    while (node != orig)\n       {\n \tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n \tif (edge)\n@@ -690,29 +692,36 @@ cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n    same function body.  \n    \n    TODO: COUNT and LOOP_DEPTH should be properly distributed based on relative\n-   frequencies of the clones.\n-   */\n+   frequencies of the clones.  */\n \n void\n-cgraph_create_edge_including_clones (struct cgraph_node *orig, struct cgraph_node *callee,\n-\t\t\t\t     gimple stmt, gcov_type count, int freq,\n-\t\t\t\t     int loop_depth,\n+cgraph_create_edge_including_clones (struct cgraph_node *orig,\n+\t\t\t\t     struct cgraph_node *callee,\n+\t\t\t\t     gimple stmt, gcov_type count,\n+\t\t\t\t     int freq, int loop_depth,\n \t\t\t\t     cgraph_inline_failed_t reason)\n {\n   struct cgraph_node *node;\n+  struct cgraph_edge *edge;\n \n   if (!cgraph_edge (orig, stmt))\n-     cgraph_create_edge (orig, callee, stmt,\n-     \t\t\t count, freq, loop_depth)->inline_failed = reason;\n+    {\n+      edge = cgraph_create_edge (orig, callee, stmt, count, freq, loop_depth);\n+      edge->inline_failed = reason;\n+    }\n \n-  if (orig->clones)\n-    for (node = orig->clones; node != orig;)\n+  node = orig->clones;\n+  if (node)\n+    while (node != orig)\n       {\n         /* It is possible that we already constant propagated into the clone\n \t   and turned indirect call into dirrect call.  */\n         if (!cgraph_edge (node, stmt))\n-\t  cgraph_create_edge (node, callee, stmt, count, freq,\n-\t\t\t      loop_depth)->inline_failed = reason;\n+\t  {\n+\t    edge = cgraph_create_edge (node, callee, stmt, count,\n+\t\t\t\t       freq, loop_depth);\n+\t    edge->inline_failed = reason;\n+\t  }\n \n \tif (node->clones)\n \t  node = node->clones;"}, {"sha": "e62c5c1e7925f748d74ff4c4370f8cc98383f922", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 55, "deletions": 53, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=9b2a5ef70cb61f8a91fb7268cc36172180e0d3cd", "patch": "@@ -1496,67 +1496,69 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t     callgraph edges and update or duplicate them.  */\n \t  if (is_gimple_call (stmt))\n \t    {\n-\t      struct cgraph_edge *edge = cgraph_edge (id->src_node, orig_stmt);\n+\t      struct cgraph_edge *edge;\n \t      int flags;\n \n \t      switch (id->transform_call_graph_edges)\n \t\t{\n-\t      case CB_CGE_DUPLICATE:\n-\t        if (edge)\n-\t\t  cgraph_clone_edge (edge, id->dst_node, stmt,\n-\t\t\t\t\t   REG_BR_PROB_BASE, 1,\n-\t\t\t\t\t   edge->frequency, true);\n-\t\tbreak;\n-\n-\t      case CB_CGE_MOVE_CLONES:\n-\t\tcgraph_set_call_stmt_including_clones (id->dst_node, orig_stmt, stmt);\n-\t\tbreak;\n-\n-\t      case CB_CGE_MOVE:\n-\t        if (edge)\n-\t\t  cgraph_set_call_stmt (edge, stmt);\n-\t\tbreak;\n-\n-\t      default:\n-\t\tgcc_unreachable ();\n+\t\tcase CB_CGE_DUPLICATE:\n+\t\t  edge = cgraph_edge (id->src_node, orig_stmt);\n+\t\t  if (edge)\n+\t\t    edge = cgraph_clone_edge (edge, id->dst_node, stmt,\n+\t\t\t\t\t      REG_BR_PROB_BASE, 1,\n+\t\t\t\t\t      edge->frequency, true);\n+\t\t  break;\n+\n+\t\tcase CB_CGE_MOVE_CLONES:\n+\t\t  cgraph_set_call_stmt_including_clones (id->dst_node,\n+\t\t\t\t\t\t\t orig_stmt, stmt);\n+\t\t  edge = cgraph_edge (id->dst_node, stmt);\n+\t\t  break;\n+\n+\t\tcase CB_CGE_MOVE:\n+\t\t  edge = cgraph_edge (id->dst_node, orig_stmt);\n+\t\t  if (edge)\n+\t\t    cgraph_set_call_stmt (edge, stmt);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n \t\t}\n \n-\t    edge = cgraph_edge (id->src_node, orig_stmt);\n-\t    /* Constant propagation on argument done during inlining\n-\t       may create new direct call.  Produce an edge for it.  */\n-\t    if ((!edge \n-\t\t || (edge->indirect_call\n-\t\t     && id->transform_call_graph_edges == CB_CGE_MOVE_CLONES))\n-\t\t&& is_gimple_call (stmt)\n-\t\t&& (fn = gimple_call_fndecl (stmt)) != NULL)\n-\t      {\n-\t\tstruct cgraph_node *dest = cgraph_node (fn);\n-\n-\t\t/* We have missing edge in the callgraph.  This can happen in one case\n-\t\t   where previous inlining turned indirect call into direct call by\n-\t\t   constant propagating arguments.  In all other cases we hit a bug\n-\t\t   (incorrect node sharing is most common reason for missing edges.  */\n-\t\tgcc_assert (dest->needed || !dest->analyzed);\n-\t\tif (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n-\t\t  cgraph_create_edge_including_clones (id->dst_node, dest, stmt,\n-\t\t\t\t\t\t       bb->count,\n-\t\t\t\t\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl, bb),\n-\t\t\t\t\t\t       bb->loop_depth,\n-\t\t\t\t\t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n-\t\telse\n-\t\t  cgraph_create_edge (id->dst_node, dest, stmt,\n-\t\t\t\t      bb->count, CGRAPH_FREQ_BASE,\n-\t\t\t\t      bb->loop_depth)->inline_failed\n-\t\t    = CIF_ORIGINALLY_INDIRECT_CALL;\n-\t\tif (dump_file)\n-\t\t  {\n-\t\t     fprintf (dump_file, \"Created new direct edge to %s\",\n-\t\t\t      cgraph_node_name (dest));\n-\t\t  }\n-\t      }\n+\t      /* Constant propagation on argument done during inlining\n+\t\t may create new direct call.  Produce an edge for it.  */\n+\t      if ((!edge \n+\t\t   || (edge->indirect_call\n+\t\t       && id->transform_call_graph_edges == CB_CGE_MOVE_CLONES))\n+\t\t  && is_gimple_call (stmt)\n+\t\t  && (fn = gimple_call_fndecl (stmt)) != NULL)\n+\t\t{\n+\t\t  struct cgraph_node *dest = cgraph_node (fn);\n+\n+\t\t  /* We have missing edge in the callgraph.  This can happen\n+\t\t     when previous inlining turned an indirect call into a\n+\t\t     direct call by constant propagating arguments.  In all\n+\t\t     other cases we hit a bug (incorrect node sharing is the\n+\t\t     most common reason for missing edges).  */\n+\t\t  gcc_assert (dest->needed || !dest->analyzed);\n+\t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n+\t\t    cgraph_create_edge_including_clones\n+\t\t      (id->dst_node, dest, stmt, bb->count,\n+\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl, bb),\n+\t\t       bb->loop_depth, CIF_ORIGINALLY_INDIRECT_CALL);\n+\t\t  else\n+\t\t    cgraph_create_edge (id->dst_node, dest, stmt,\n+\t\t\t\t\tbb->count, CGRAPH_FREQ_BASE,\n+\t\t\t\t\tbb->loop_depth)->inline_failed\n+\t\t      = CIF_ORIGINALLY_INDIRECT_CALL;\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Created new direct edge to %s\",\n+\t\t\t       cgraph_node_name (dest));\n+\t\t    }\n+\t\t}\n \n \t      flags = gimple_call_flags (stmt);\n-\n \t      if (flags & ECF_MAY_BE_ALLOCA)\n \t\tcfun->calls_alloca = true;\n \t      if (flags & ECF_RETURNS_TWICE)"}]}