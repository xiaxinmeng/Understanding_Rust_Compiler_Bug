{"sha": "14f732114eaf16771c0f3865b678e491838fdc87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRmNzMyMTE0ZWFmMTY3NzFjMGYzODY1YjY3OGU0OTE4MzhmZGM4Nw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2015-10-20T10:23:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T10:23:46Z"}, "message": "sem_ch13.adb (Analyze_One_Aspect): Avoid analyzing the expression in a 'Disable_Controlled attribute when...\n\n2015-10-20  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch13.adb (Analyze_One_Aspect): Avoid\n\tanalyzing the expression in a 'Disable_Controlled attribute when\n\tExpander_Active is False, because otherwise, we get errors about\n\tnonstatic expressions in pragma-Preelaborate generic packages.\n\t* restrict.ads: minor whitespace cleanup in comment\n\n2015-10-20  Bob Duff  <duff@adacore.com>\n\n\t* a-conhel.adb: Remove \"use SAC;\", because otherwise the compiler\n\tcomplains about use clauses in run-time units. Use \"use type\"\n\tinstead.\n\t* a-btgbso.adb, a-btgbso.ads, a-cbdlli.adb, a-cbdlli.ads,\n\t* a-cbhama.adb, a-cbhama.ads, a-cbhase.adb, a-cbhase.ads,\n\t* a-cbmutr.adb, a-cbmutr.ads, a-cborma.adb, a-cborma.ads,\n\t* a-cborse.adb, a-cborse.ads, a-cdlili.adb, a-cdlili.ads,\n\t* a-chtgbk.adb, a-chtgbk.ads, a-chtgbo.adb, a-chtgbo.ads,\n\t* a-chtgke.adb, a-chtgke.ads, a-chtgop.adb, a-chtgop.ads,\n\t* a-cidlli.adb, a-cidlli.ads, a-cihama.adb, a-cihama.ads,\n\t* a-cihase.adb, a-cihase.ads, a-cimutr.adb, a-cimutr.ads,\n\t* a-ciorma.adb, a-ciorma.ads, a-ciormu.adb, a-ciormu.ads,\n\t* a-ciorse.adb, a-ciorse.ads, a-cobove.adb, a-cobove.ads,\n\t* a-cohama.adb, a-cohama.ads, a-cohase.adb, a-cohase.ads,\n\t* a-cohata.ads, a-coinve.adb, a-comutr.adb, a-comutr.ads,\n\t* a-convec.adb, a-coorma.adb, a-coorma.ads, a-coormu.adb,\n\t* a-coormu.ads, a-coorse.adb, a-coorse.ads, a-crbltr.ads,\n\t* a-crbtgk.adb, a-crbtgk.ads, a-crbtgo.adb, a-crbtgo.ads,\n\t* a-rbtgbk.adb, a-rbtgbk.ads, a-rbtgbo.adb, a-rbtgbo.ads,\n\t* a-rbtgso.adb, a-rbtgso.ads: Change all the predefined containers\n\tto share the tampering machinery in Ada.Containers.Helpers. This\n\treduces the amount of duplicated code, and takes advantage of\n\tefficiency improvements in Helpers.\n\tProtect all run-time checks and supporting machinery with \"if\n\tChecks\" or \"if T_Check\", so this code can be suppressed with\n\tpragma Suppress or -gnatp.\n\tAdd Pseudo_Reference and Get_Element_Access to remaining\n\tcontainers, so that the compiler can optimize \"for ... of\" loops.\n\nFrom-SVN: r229041", "tree": {"sha": "5d28f19aa90d6e4079a4f3107278c6be82f787be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d28f19aa90d6e4079a4f3107278c6be82f787be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14f732114eaf16771c0f3865b678e491838fdc87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f732114eaf16771c0f3865b678e491838fdc87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f732114eaf16771c0f3865b678e491838fdc87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f732114eaf16771c0f3865b678e491838fdc87/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7737d1d375636232744501175edef1ae3ff5e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7737d1d375636232744501175edef1ae3ff5e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7737d1d375636232744501175edef1ae3ff5e7d"}], "stats": {"total": 11480, "additions": 3839, "deletions": 7641}, "files": [{"sha": "76f4dd6e47f6e2d1aff427ef3e01cdcab36456e3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -1,3 +1,42 @@\n+2015-10-20  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_One_Aspect): Avoid\n+\tanalyzing the expression in a 'Disable_Controlled attribute when\n+\tExpander_Active is False, because otherwise, we get errors about\n+\tnonstatic expressions in pragma-Preelaborate generic packages.\n+\t* restrict.ads: minor whitespace cleanup in comment\n+\n+2015-10-20  Bob Duff  <duff@adacore.com>\n+\n+\t* a-conhel.adb: Remove \"use SAC;\", because otherwise the compiler\n+\tcomplains about use clauses in run-time units. Use \"use type\"\n+\tinstead.\n+\t* a-btgbso.adb, a-btgbso.ads, a-cbdlli.adb, a-cbdlli.ads,\n+\t* a-cbhama.adb, a-cbhama.ads, a-cbhase.adb, a-cbhase.ads,\n+\t* a-cbmutr.adb, a-cbmutr.ads, a-cborma.adb, a-cborma.ads,\n+\t* a-cborse.adb, a-cborse.ads, a-cdlili.adb, a-cdlili.ads,\n+\t* a-chtgbk.adb, a-chtgbk.ads, a-chtgbo.adb, a-chtgbo.ads,\n+\t* a-chtgke.adb, a-chtgke.ads, a-chtgop.adb, a-chtgop.ads,\n+\t* a-cidlli.adb, a-cidlli.ads, a-cihama.adb, a-cihama.ads,\n+\t* a-cihase.adb, a-cihase.ads, a-cimutr.adb, a-cimutr.ads,\n+\t* a-ciorma.adb, a-ciorma.ads, a-ciormu.adb, a-ciormu.ads,\n+\t* a-ciorse.adb, a-ciorse.ads, a-cobove.adb, a-cobove.ads,\n+\t* a-cohama.adb, a-cohama.ads, a-cohase.adb, a-cohase.ads,\n+\t* a-cohata.ads, a-coinve.adb, a-comutr.adb, a-comutr.ads,\n+\t* a-convec.adb, a-coorma.adb, a-coorma.ads, a-coormu.adb,\n+\t* a-coormu.ads, a-coorse.adb, a-coorse.ads, a-crbltr.ads,\n+\t* a-crbtgk.adb, a-crbtgk.ads, a-crbtgo.adb, a-crbtgo.ads,\n+\t* a-rbtgbk.adb, a-rbtgbk.ads, a-rbtgbo.adb, a-rbtgbo.ads,\n+\t* a-rbtgso.adb, a-rbtgso.ads: Change all the predefined containers\n+\tto share the tampering machinery in Ada.Containers.Helpers. This\n+\treduces the amount of duplicated code, and takes advantage of\n+\tefficiency improvements in Helpers.\n+\tProtect all run-time checks and supporting machinery with \"if\n+\tChecks\" or \"if T_Check\", so this code can be suppressed with\n+\tpragma Suppress or -gnatp.\n+\tAdd Pseudo_Reference and Get_Element_Access to remaining\n+\tcontainers, so that the compiler can optimize \"for ... of\" loops.\n+\n 2015-10-20  Bob Duff  <duff@adacore.com>\n \n \t* a-contai.adb, a-coinve.ads, a-contai.ads, a-conhel.adb, a-conhel.ads,"}, {"sha": "363b77e349a4d1eff91174a54019a8696c0c230d", "filename": "gcc/ada/a-btgbso.adb", "status": "modified", "additions": 35, "deletions": 288, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-btgbso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-btgbso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-btgbso.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,10 @@ with System; use type System.Address;\n \n package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -53,12 +57,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n    ----------------\n \n    procedure Set_Difference (Target : in out Set_Type; Source : Set_Type) is\n-      BT : Natural renames Target.Busy;\n-      LT : Natural renames Target.Lock;\n-\n-      BS : Natural renames Source'Unrestricted_Access.Busy;\n-      LS : Natural renames Source'Unrestricted_Access.Lock;\n-\n       Tgt, Src : Count_Type;\n \n       TN : Nodes_Type renames Target.Nodes;\n@@ -68,10 +66,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n \n    begin\n       if Target'Address = Source'Address then\n-         if Target.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (container is busy)\";\n-         end if;\n+         TC_Check (Target.TC);\n \n          Tree_Operations.Clear_Tree (Target);\n          return;\n@@ -81,10 +76,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n \n       Tgt := Target.First;\n       Src := Source.First;\n@@ -100,35 +92,17 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n+         declare\n+            Lock_Target : With_Lock (Target.TC'Unrestricted_Access);\n+            Lock_Source : With_Lock (Source.TC'Unrestricted_Access);\n          begin\n-            BT := BT + 1;\n-            LT := LT + 1;\n-\n-            BS := BS + 1;\n-            LS := LS + 1;\n-\n             if Is_Less (TN (Tgt), SN (Src)) then\n                Compare := -1;\n             elsif Is_Less (SN (Src), TN (Tgt)) then\n                Compare := 1;\n             else\n                Compare := 0;\n             end if;\n-\n-            BT := BT - 1;\n-            LT := LT - 1;\n-\n-            BS := BS - 1;\n-            LS := LS - 1;\n-         exception\n-            when others =>\n-               BT := BT - 1;\n-               LT := LT - 1;\n-\n-               BS := BS - 1;\n-               LS := LS - 1;\n-\n-               raise;\n          end;\n \n          if Compare < 0 then\n@@ -171,11 +145,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            BL : Natural renames Left'Unrestricted_Access.Busy;\n-            LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-            BR : Natural renames Right'Unrestricted_Access.Busy;\n-            LR : Natural renames Right'Unrestricted_Access.Lock;\n+            Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+            Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n             L_Node : Count_Type;\n             R_Node : Count_Type;\n@@ -184,12 +155,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n             pragma Warnings (Off, Dst_Node);\n \n          begin\n-            BL := BL + 1;\n-            LL := LL + 1;\n-\n-            BR := BR + 1;\n-            LR := LR + 1;\n-\n             L_Node := Left.First;\n             R_Node := Right.First;\n             loop\n@@ -228,21 +193,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n                   R_Node := Tree_Operations.Next (Right, R_Node);\n                end if;\n             end loop;\n-\n-            BL := BL - 1;\n-            LL := LL - 1;\n-\n-            BR := BR - 1;\n-            LR := LR - 1;\n-         exception\n-            when others =>\n-               BL := BL - 1;\n-               LL := LL - 1;\n-\n-               BR := BR - 1;\n-               LR := LR - 1;\n-\n-               raise;\n          end;\n       end return;\n    end Set_Difference;\n@@ -255,12 +205,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n      (Target : in out Set_Type;\n       Source : Set_Type)\n    is\n-      BT : Natural renames Target.Busy;\n-      LT : Natural renames Target.Lock;\n-\n-      BS : Natural renames Source'Unrestricted_Access.Busy;\n-      LS : Natural renames Source'Unrestricted_Access.Lock;\n-\n       Tgt : Count_Type;\n       Src : Count_Type;\n \n@@ -271,10 +215,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n \n       if Source.Length = 0 then\n          Tree_Operations.Clear_Tree (Target);\n@@ -289,35 +230,17 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n+         declare\n+            Lock_Target : With_Lock (Target.TC'Unrestricted_Access);\n+            Lock_Source : With_Lock (Source.TC'Unrestricted_Access);\n          begin\n-            BT := BT + 1;\n-            LT := LT + 1;\n-\n-            BS := BS + 1;\n-            LS := LS + 1;\n-\n             if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n                Compare := -1;\n             elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n                Compare := 1;\n             else\n                Compare := 0;\n             end if;\n-\n-            BT := BT - 1;\n-            LT := LT - 1;\n-\n-            BS := BS - 1;\n-            LS := LS - 1;\n-         exception\n-            when others =>\n-               BT := BT - 1;\n-               LT := LT - 1;\n-\n-               BS := BS - 1;\n-               LS := LS - 1;\n-\n-               raise;\n          end;\n \n          if Compare < 0 then\n@@ -363,11 +286,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            BL : Natural renames Left'Unrestricted_Access.Busy;\n-            LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-            BR : Natural renames Right'Unrestricted_Access.Busy;\n-            LR : Natural renames Right'Unrestricted_Access.Lock;\n+            Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+            Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n             L_Node : Count_Type;\n             R_Node : Count_Type;\n@@ -376,12 +296,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n             pragma Warnings (Off, Dst_Node);\n \n          begin\n-            BL := BL + 1;\n-            LL := LL + 1;\n-\n-            BR := BR + 1;\n-            LR := LR + 1;\n-\n             L_Node := Left.First;\n             R_Node := Right.First;\n             loop\n@@ -410,21 +324,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n                   R_Node := Tree_Operations.Next (Right, R_Node);\n                end if;\n             end loop;\n-\n-            BL := BL - 1;\n-            LL := LL - 1;\n-\n-            BR := BR - 1;\n-            LR := LR - 1;\n-         exception\n-            when others =>\n-               BL := BL - 1;\n-               LL := LL - 1;\n-\n-               BR := BR - 1;\n-               LR := LR - 1;\n-\n-               raise;\n          end;\n       end return;\n    end Set_Intersection;\n@@ -450,42 +349,27 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         BL : Natural renames Subset'Unrestricted_Access.Busy;\n-         LL : Natural renames Subset'Unrestricted_Access.Lock;\n-\n-         BR : Natural renames Of_Set'Unrestricted_Access.Busy;\n-         LR : Natural renames Of_Set'Unrestricted_Access.Lock;\n+         Lock_Subset : With_Lock (Subset.TC'Unrestricted_Access);\n+         Lock_Of_Set : With_Lock (Of_Set.TC'Unrestricted_Access);\n \n          Subset_Node : Count_Type;\n          Set_Node    : Count_Type;\n-\n-         Result : Boolean;\n-\n       begin\n-         BL := BL + 1;\n-         LL := LL + 1;\n-\n-         BR := BR + 1;\n-         LR := LR + 1;\n-\n          Subset_Node := Subset.First;\n          Set_Node    := Of_Set.First;\n          loop\n             if Set_Node = 0 then\n-               Result := Subset_Node = 0;\n-               exit;\n+               return Subset_Node = 0;\n             end if;\n \n             if Subset_Node = 0 then\n-               Result := True;\n-               exit;\n+               return True;\n             end if;\n \n             if Is_Less (Subset.Nodes (Subset_Node),\n                         Of_Set.Nodes (Set_Node))\n             then\n-               Result := False;\n-               exit;\n+               return False;\n             end if;\n \n             if Is_Less (Of_Set.Nodes (Set_Node),\n@@ -497,23 +381,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n                Subset_Node := Tree_Operations.Next (Subset, Subset_Node);\n             end if;\n          end loop;\n-\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         return Result;\n-      exception\n-         when others =>\n-            BL := BL - 1;\n-            LL := LL - 1;\n-\n-            BR := BR - 1;\n-            LR := LR - 1;\n-\n-            raise;\n       end;\n    end Set_Subset;\n \n@@ -531,62 +398,29 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         BL : Natural renames Left'Unrestricted_Access.Busy;\n-         LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-         BR : Natural renames Right'Unrestricted_Access.Busy;\n-         LR : Natural renames Right'Unrestricted_Access.Lock;\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n          L_Node : Count_Type;\n          R_Node : Count_Type;\n-\n-         Result : Boolean;\n-\n       begin\n-         BL := BL + 1;\n-         LL := LL + 1;\n-\n-         BR := BR + 1;\n-         LR := LR + 1;\n-\n          L_Node := Left.First;\n          R_Node := Right.First;\n          loop\n             if L_Node = 0\n               or else R_Node = 0\n             then\n-               Result := False;\n-               exit;\n+               return False;\n             end if;\n \n             if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n                L_Node := Tree_Operations.Next (Left, L_Node);\n-\n             elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n                R_Node := Tree_Operations.Next (Right, R_Node);\n-\n             else\n-               Result := True;\n-               exit;\n+               return True;\n             end if;\n          end loop;\n-\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         return Result;\n-      exception\n-         when others =>\n-            BL := BL - 1;\n-            LL := LL - 1;\n-\n-            BR := BR - 1;\n-            LR := LR - 1;\n-\n-            raise;\n       end;\n    end Set_Overlap;\n \n@@ -598,12 +432,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n      (Target : in out Set_Type;\n       Source : Set_Type)\n    is\n-      BT : Natural renames Target.Busy;\n-      LT : Natural renames Target.Lock;\n-\n-      BS : Natural renames Source'Unrestricted_Access.Busy;\n-      LS : Natural renames Source'Unrestricted_Access.Lock;\n-\n       Tgt : Count_Type;\n       Src : Count_Type;\n \n@@ -642,35 +470,17 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n+         declare\n+            Lock_Target : With_Lock (Target.TC'Unrestricted_Access);\n+            Lock_Source : With_Lock (Source.TC'Unrestricted_Access);\n          begin\n-            BT := BT + 1;\n-            LT := LT + 1;\n-\n-            BS := BS + 1;\n-            LS := LS + 1;\n-\n             if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n                Compare := -1;\n             elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n                Compare := 1;\n             else\n                Compare := 0;\n             end if;\n-\n-            BT := BT - 1;\n-            LT := LT - 1;\n-\n-            BS := BS - 1;\n-            LS := LS - 1;\n-         exception\n-            when others =>\n-               BT := BT - 1;\n-               LT := LT - 1;\n-\n-               BS := BS - 1;\n-               LS := LS - 1;\n-\n-               raise;\n          end;\n \n          if Compare < 0 then\n@@ -722,11 +532,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            BL : Natural renames Left'Unrestricted_Access.Busy;\n-            LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-            BR : Natural renames Right'Unrestricted_Access.Busy;\n-            LR : Natural renames Right'Unrestricted_Access.Lock;\n+            Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+            Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n             L_Node : Count_Type;\n             R_Node : Count_Type;\n@@ -735,12 +542,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n             pragma Warnings (Off, Dst_Node);\n \n          begin\n-            BL := BL + 1;\n-            LL := LL + 1;\n-\n-            BR := BR + 1;\n-            LR := LR + 1;\n-\n             L_Node := Left.First;\n             R_Node := Right.First;\n             loop\n@@ -795,21 +596,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n                   R_Node := Tree_Operations.Next (Right, R_Node);\n                end if;\n             end loop;\n-\n-            BL := BL - 1;\n-            LL := LL - 1;\n-\n-            BR := BR - 1;\n-            LR := LR - 1;\n-         exception\n-            when others =>\n-               BL := BL - 1;\n-               LL := LL - 1;\n-\n-               BR := BR - 1;\n-               LR := LR - 1;\n-\n-               raise;\n          end;\n       end return;\n    end Set_Symmetric_Difference;\n@@ -850,29 +636,15 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         BS : Natural renames Source'Unrestricted_Access.Busy;\n-         LS : Natural renames Source'Unrestricted_Access.Lock;\n-\n+         Lock_Source : With_Lock (Source.TC'Unrestricted_Access);\n       begin\n-         BS := BS + 1;\n-         LS := LS + 1;\n-\n          --  Note that there's no way to decide a priori whether the target has\n          --  enough capacity for the union with source. We cannot simply\n          --  compare the sum of the existing lengths to the capacity of the\n          --  target, because equivalent items from source are not included in\n          --  the union.\n \n          Iterate (Source);\n-\n-         BS := BS - 1;\n-         LS := LS - 1;\n-      exception\n-         when others =>\n-            BS := BS - 1;\n-            LS := LS - 1;\n-\n-            raise;\n       end;\n    end Set_Union;\n \n@@ -892,19 +664,9 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n \n       return Result : Set_Type (Left.Length + Right.Length) do\n          declare\n-            BL : Natural renames Left'Unrestricted_Access.Busy;\n-            LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-            BR : Natural renames Right'Unrestricted_Access.Busy;\n-            LR : Natural renames Right'Unrestricted_Access.Lock;\n-\n+            Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+            Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n          begin\n-            BL := BL + 1;\n-            LL := LL + 1;\n-\n-            BR := BR + 1;\n-            LR := LR + 1;\n-\n             Assign (Target => Result, Source => Left);\n \n             Insert_Right : declare\n@@ -934,21 +696,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n             begin\n                Iterate (Right);\n             end Insert_Right;\n-\n-            BL := BL - 1;\n-            LL := LL - 1;\n-\n-            BR := BR - 1;\n-            LR := LR - 1;\n-         exception\n-            when others =>\n-               BL := BL - 1;\n-               LL := LL - 1;\n-\n-               BR := BR - 1;\n-               LR := LR - 1;\n-\n-               raise;\n          end;\n       end return;\n    end Set_Union;"}, {"sha": "0527a90c442490c256926c329987e53f471effea", "filename": "gcc/ada/a-btgbso.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-btgbso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-btgbso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-btgbso.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,7 +37,7 @@ generic\n \n    type Set_Type is new Tree_Operations.Tree_Types.Tree_Type with private;\n \n-   use Tree_Operations.Tree_Types;\n+   use Tree_Operations.Tree_Types, Tree_Operations.Tree_Types.Implementation;\n \n    with procedure Assign (Target : in out Set_Type; Source : Set_Type);\n "}, {"sha": "2d8cbdaaeeded18f0cf1df9ce68310670980bbe1", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 206, "deletions": 452, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,10 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -80,68 +84,34 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      BL : Natural renames Left'Unrestricted_Access.Busy;\n-      LL : Natural renames Left'Unrestricted_Access.Lock;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-      BR : Natural renames Right'Unrestricted_Access.Busy;\n-      LR : Natural renames Right'Unrestricted_Access.Lock;\n+      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n       LN : Node_Array renames Left.Nodes;\n       RN : Node_Array renames Right.Nodes;\n \n       LI : Count_Type;\n       RI : Count_Type;\n-\n-      Result : Boolean;\n-\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       if Left.Length /= Right.Length then\n          return False;\n       end if;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n       LI := Left.First;\n       RI := Right.First;\n-      Result := True;\n       for J in 1 .. Left.Length loop\n          if LN (LI).Element /= RN (RI).Element then\n-            Result := False;\n-            exit;\n+            return False;\n          end if;\n \n          LI := LN (LI).Next;\n          RI := RN (RI).Next;\n       end loop;\n \n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n+      return True;\n    end \"=\";\n \n    --------------\n@@ -229,24 +199,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Insert (Container, No_Element, New_Item, Count);\n    end Append;\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : List renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -260,7 +212,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error  -- ???\n            with \"Target capacity is less than Source length\";\n       end if;\n@@ -286,8 +238,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       if Container.Length = 0 then\n          pragma Assert (Container.First = 0);\n          pragma Assert (Container.Last = 0);\n-         pragma Assert (Container.Busy = 0);\n-         pragma Assert (Container.Lock = 0);\n+         pragma Assert (Container.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n \n@@ -296,10 +247,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       pragma Assert (N (Container.First).Prev = 0);\n       pragma Assert (N (Container.Last).Next = 0);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       while Container.Length > 1 loop\n          X := Container.First;\n@@ -332,30 +280,30 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n \n-         declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n-            B : Natural renames Position.Container.Busy;\n-            L : Natural renames Position.Container.Lock;\n-         begin\n-            return R : constant Constant_Reference_Type :=\n-              (Element => N.Element'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n-            do\n-               B := B + 1;\n-               L := L + 1;\n-            end return;\n-         end;\n-      end if;\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         return R : constant Constant_Reference_Type :=\n+           (Element => N.Element'Access,\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Constant_Reference;\n \n    --------------\n@@ -382,7 +330,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          C := Source.Length;\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n-      else\n+      elsif Checks then\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n \n@@ -404,12 +352,13 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       X : Count_Type;\n \n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -431,10 +380,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       for Index in 1 .. Count loop\n          pragma Assert (Container.Length >= 2);\n@@ -484,10 +430,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       for J in 1 .. Count loop\n          X := Container.First;\n@@ -523,10 +466,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       for J in 1 .. Count loop\n          X := Container.Last;\n@@ -547,15 +487,14 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Element\");\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n \n-         return Position.Container.Nodes (Position.Node).Element;\n-      end if;\n+      return Position.Container.Nodes (Position.Node).Element;\n    end Element;\n \n    --------------\n@@ -565,27 +504,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : List renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.TC);\n       end if;\n    end Finalize;\n \n@@ -606,7 +525,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          Node := Container.First;\n \n       else\n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n          end if;\n@@ -618,39 +538,17 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Count_Type;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := 0;\n          while Node /= 0 loop\n             if Nodes (Node).Element = Item then\n-               Result := Node;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Node);\n             end if;\n \n             Node := Nodes (Node).Next;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = 0 then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return No_Element;\n       end;\n    end Find;\n \n@@ -695,11 +593,11 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    function First_Element (Container : List) return Element_Type is\n    begin\n-      if Container.First = 0 then\n+      if Checks and then Container.First = 0 then\n          raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (Container.First).Element;\n       end if;\n+\n+      return Container.Nodes (Container.First).Element;\n    end First_Element;\n \n    ----------\n@@ -826,42 +724,24 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       ---------------\n \n       function Is_Sorted (Container : List) return Boolean is\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Nodes : Node_Array renames Container.Nodes;\n-         Node  : Count_Type;\n-\n-         Result : Boolean;\n-\n-      begin\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n-         B := B + 1;\n-         L := L + 1;\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n \n+         Nodes : Node_Array renames Container.Nodes;\n+         Node  : Count_Type;\n+      begin\n          Node := Container.First;\n-         Result := True;\n          for J in 2 .. Container.Length loop\n             if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n-               Result := False;\n-               exit;\n+               return False;\n             end if;\n \n             Node := Nodes (Node).Next;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         return Result;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return True;\n       end Is_Sorted;\n \n       -----------\n@@ -885,51 +765,37 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             return;\n          end if;\n \n-         if Target'Address = Source'Address then\n+         if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n          end if;\n \n-         if Target.Length > Count_Type'Last - Source.Length then\n+         if Checks and then Target.Length > Count_Type'Last - Source.Length\n+         then\n             raise Constraint_Error with \"new length exceeds maximum\";\n          end if;\n \n-         if Target.Length + Source.Length > Target.Capacity then\n+         if Checks and then Target.Length + Source.Length > Target.Capacity\n+         then\n             raise Capacity_Error with \"new length exceeds target capacity\";\n          end if;\n \n-         if Target.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Target (list is busy)\";\n-         end if;\n-\n-         if Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Source (list is busy)\";\n-         end if;\n+         TC_Check (Target.TC);\n+         TC_Check (Source.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            TB : Natural renames Target.Busy;\n-            TL : Natural renames Target.Lock;\n-\n-            SB : Natural renames Source.Busy;\n-            SL : Natural renames Source.Lock;\n+            Lock_Target : With_Lock (Target.TC'Unchecked_Access);\n+            Lock_Source : With_Lock (Source.TC'Unchecked_Access);\n \n             LN : Node_Array renames Target.Nodes;\n             RN : Node_Array renames Source.Nodes;\n \n             LI, LJ, RI, RJ : Count_Type;\n \n          begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n-\n-            SB := SB + 1;\n-            SL := SL + 1;\n-\n             LI := Target.First;\n             RI := Source.First;\n             while RI /= 0 loop\n@@ -955,22 +821,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n                   LI := LN (LI).Next;\n                end if;\n             end loop;\n-\n-            TB := TB - 1;\n-            TL := TL - 1;\n-\n-            SB := SB - 1;\n-            SL := SL - 1;\n-\n-         exception\n-            when others =>\n-               TB := TB - 1;\n-               TL := TL - 1;\n-\n-               SB := SB - 1;\n-               SL := SL - 1;\n-\n-               raise;\n          end;\n       end Merge;\n \n@@ -1056,32 +906,15 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          pragma Assert (N (Container.First).Prev = 0);\n          pragma Assert (N (Container.Last).Next = 0);\n \n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (list is busy)\";\n-         end if;\n+         TC_Check (Container.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n+            Lock : With_Lock (Container.TC'Unchecked_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Sort (Front => 0, Back => 0);\n-\n-            B := B - 1;\n-            L := L - 1;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-               raise;\n          end;\n \n          pragma Assert (N (Container.First).Prev = 0);\n@@ -1090,6 +923,16 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    end Generic_Sorting;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Nodes (Position.Node).Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1116,7 +959,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Before cursor designates wrong list\";\n          end if;\n@@ -1129,14 +973,11 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Length > Container.Capacity - Count then\n+      if Checks and then Container.Length > Container.Capacity - Count then\n          raise Capacity_Error with \"capacity exceeded\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       Allocate (Container, New_Item, New_Node);\n       First_Node := New_Node;\n@@ -1258,32 +1099,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B    : Natural renames Container'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n       Node : Count_Type := Container.First;\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         while Node /= 0 loop\n-            Process (Cursor'(Container'Unrestricted_Access, Node));\n-            Node := Container.Nodes (Node).Next;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      while Node /= 0 loop\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+         Node := Container.Nodes (Node).Next;\n+      end loop;\n    end Iterate;\n \n    function Iterate\n      (Container : List)\n       return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -1300,7 +1129,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n                                 Container => Container'Unrestricted_Access,\n                                 Node      => 0)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1309,8 +1138,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Start     : Cursor)\n       return List_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1323,12 +1150,12 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start = No_Element then\n+      if Checks and then Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n       end if;\n \n-      if Start.Container /= Container'Unrestricted_Access then\n+      if Checks and then Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong list\";\n       end if;\n@@ -1349,7 +1176,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n                     Container => Container'Unrestricted_Access,\n                     Node      => Start.Node)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1394,11 +1221,11 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    function Last_Element (Container : List) return Element_Type is\n    begin\n-      if Container.Last = 0 then\n+      if Checks and then Container.Last = 0 then\n          raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (Container.Last).Element;\n       end if;\n+\n+      return Container.Nodes (Container.Last).Element;\n    end Last_Element;\n \n    ------------\n@@ -1426,14 +1253,11 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error with \"Source length exceeds Target capacity\";\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       --  Clear target, note that this checks busy bits of Target\n \n@@ -1533,12 +1357,14 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong list\";\n-      else\n-         return Next (Position);\n       end if;\n+\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1590,14 +1416,30 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong list\";\n-      else\n-         return Previous (Position);\n       end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased List'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1607,35 +1449,19 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n       declare\n+         Lock : With_Lock (Position.Container.TC'Unrestricted_Access);\n          C : List renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-\n+         N : Node_Type renames C.Nodes (Position.Node);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            N : Node_Type renames C.Nodes (Position.Node);\n-         begin\n-            Process (N.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (N.Element);\n       end;\n    end Query_Element;\n \n@@ -1654,21 +1480,22 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Clear (Item);\n       Count_Type'Base'Read (Stream, N);\n \n-      if N < 0 then\n+      if Checks and then N < 0 then\n          raise Program_Error with \"bad list length (corrupt stream)\";\n+      end if;\n \n-      elsif N = 0 then\n+      if N = 0 then\n          return;\n+      end if;\n \n-      elsif N > Item.Capacity then\n+      if Checks and then N > Item.Capacity then\n          raise Constraint_Error with \"length exceeds capacity\";\n-\n-      else\n-         for Idx in 1 .. N loop\n-            Allocate (Item, Stream, New_Node => X);\n-            Insert_Internal (Item, Before => 0, New_Node => X);\n-         end loop;\n       end if;\n+\n+      for Idx in 1 .. N loop\n+         Allocate (Item, Stream, New_Node => X);\n+         Insert_Internal (Item, Before => 0, New_Node => X);\n+      end loop;\n    end Read;\n \n    procedure Read\n@@ -1704,30 +1531,30 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n \n-         declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n-            B : Natural   renames Container.Busy;\n-            L : Natural   renames Container.Lock;\n-         begin\n-            return R : constant Reference_Type :=\n-               (Element => N.Element'Access,\n-                Control => (Controlled with Container'Unrestricted_Access))\n-            do\n-               B := B + 1;\n-               L := L + 1;\n-            end return;\n-         end;\n-      end if;\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         return R : constant Reference_Type :=\n+           (Element => N.Element'Access,\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Reference;\n \n    ---------------------\n@@ -1740,22 +1567,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unchecked_Access then\n+      if Checks and then Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      elsif Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is locked)\";\n+      TE_Check (Container.TC);\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-         Container.Nodes (Position.Node).Element := New_Item;\n-      end if;\n+      Container.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -1817,10 +1642,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       pragma Assert (N (Container.First).Prev = 0);\n       pragma Assert (N (Container.Last).Next = 0);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       Container.First := J;\n       Container.Last := I;\n@@ -1862,7 +1684,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          Node := Container.Last;\n \n       else\n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n          end if;\n@@ -1874,39 +1697,17 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Count_Type;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := 0;\n          while Node /= 0 loop\n             if Container.Nodes (Node).Element = Item then\n-               Result := Node;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Node);\n             end if;\n \n             Node := Container.Nodes (Node).Prev;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = 0 then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return No_Element;\n       end;\n    end Reverse_Find;\n \n@@ -1918,26 +1719,14 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      C : List renames Container'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n       Node : Count_Type := Container.Last;\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         while Node /= 0 loop\n-            Process (Cursor'(Container'Unrestricted_Access, Node));\n-            Node := Container.Nodes (Node).Prev;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      while Node /= 0 loop\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+         Node := Container.Nodes (Node).Prev;\n+      end loop;\n    end Reverse_Iterate;\n \n    ------------\n@@ -1951,7 +1740,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    is\n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n          end if;\n@@ -1961,24 +1750,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n       if Target'Address = Source'Address or else Source.Length = 0 then\n          return;\n+      end if;\n \n-      elsif Target.Length > Count_Type'Last - Source.Length then\n+      if Checks and then Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n+      end if;\n \n-      elsif Target.Length + Source.Length > Target.Capacity then\n+      if Checks and then Target.Length + Source.Length > Target.Capacity then\n          raise Capacity_Error with \"new length exceeds target capacity\";\n+      end if;\n \n-      elsif Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-\n-      elsif Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n-      else\n-         Splice_Internal (Target, Before.Node, Source);\n-      end if;\n+      Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n    procedure Splice\n@@ -1990,19 +1775,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Container'Unchecked_Access then\n+         if Checks and then Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -2017,10 +1803,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n       pragma Assert (Container.Length >= 2);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Before.Node = 0 then\n          pragma Assert (Position.Node /= Container.Last);\n@@ -2100,38 +1883,31 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       end if;\n \n       if Before.Container /= null then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Source'Unrestricted_Access then\n+      if Checks and then Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-      if Target.Length >= Target.Capacity then\n+      if Checks and then Target.Length >= Target.Capacity then\n          raise Capacity_Error with \"Target is full\";\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       Splice_Internal\n         (Target  => Target,\n@@ -2275,30 +2051,27 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = 0 then\n+      if Checks and then I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if J.Node = 0 then\n+      if Checks and then J.Node = 0 then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unchecked_Access then\n+      if Checks and then I.Container /= Container'Unchecked_Access then\n          raise Program_Error with \"I cursor designates wrong container\";\n       end if;\n \n-      if J.Container /= Container'Unchecked_Access then\n+      if Checks and then J.Container /= Container'Unchecked_Access then\n          raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap\");\n@@ -2324,30 +2097,27 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = 0 then\n+      if Checks and then I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if J.Node = 0 then\n+      if Checks and then J.Node = 0 then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n+      if Checks and then I.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"I cursor designates wrong container\";\n       end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n+      if Checks and then J.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n@@ -2388,38 +2158,22 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unchecked_Access then\n+      if Checks and then Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n \n       declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n+         Lock : With_Lock (Container.TC'Unchecked_Access);\n+         N : Node_Type renames Container.Nodes (Position.Node);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n-         begin\n-            Process (N.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (N.Element);\n       end;\n    end Update_Element;\n "}, {"sha": "ba063c1139e337d59fccaaa4a72326913070c7fd", "filename": "gcc/ada/a-cbdlli.ads", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -33,6 +33,7 @@\n \n with Ada.Iterator_Interfaces;\n \n+private with Ada.Containers.Helpers;\n private with Ada.Streams;\n private with Ada.Finalization;\n \n@@ -248,6 +249,10 @@ private\n    pragma Inline (Next);\n    pragma Inline (Previous);\n \n+   use Ada.Containers.Helpers;\n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    use Ada.Streams;\n    use Ada.Finalization;\n \n@@ -265,8 +270,7 @@ private\n       First  : Count_Type := 0;\n       Last   : Count_Type := 0;\n       Length : Count_Type := 0;\n-      Busy   : Natural := 0;\n-      Lock   : Natural := 0;\n+      TC     : aliased Tamper_Counts;\n    end record;\n \n    procedure Read\n@@ -301,15 +305,8 @@ private\n \n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is new Controlled with record\n-      Container : List_Access;\n-   end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -353,6 +350,25 @@ private\n \n    for Reference_Type'Read use Read;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased List'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_List : constant List := (Capacity => 0, others => <>);\n \n    No_Element : constant Cursor := Cursor'(null, 0);\n@@ -362,7 +378,8 @@ private\n    record\n       Container : List_Access;\n       Node      : Count_Type;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "6d4bc55f3702b9ecc2bf030e0361d6c0bc956320", "filename": "gcc/ada/a-cbhama.adb", "status": "modified", "additions": 96, "deletions": 168, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,8 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Prime_Numbers;  use Ada.Containers.Prime_Numbers;\n \n with System;  use type System.Address;\n@@ -41,6 +43,10 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -119,24 +125,6 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       return Is_Equal (Left, Right);\n    end \"=\";\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Map renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -168,7 +156,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error\n            with \"Target capacity is less than Source length\";\n       end if;\n@@ -204,12 +192,13 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n@@ -219,15 +208,14 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Position.Container.Busy;\n-         L : Natural renames Position.Container.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n-            (Element => N.Element'Access,\n-             Control => (Controlled with Container'Unrestricted_Access))\n+           (Element => N.Element'Access,\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -240,25 +228,20 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n                Key_Ops.Find (Container'Unrestricted_Access.all, Key);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n-         Cur  : Cursor := Find (Container, Key);\n-         pragma Unmodified (Cur);\n-\n          N : Node_Type renames Container.Nodes (Node);\n-         B : Natural   renames Cur.Container.Busy;\n-         L : Natural   renames Cur.Container.Lock;\n-\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => N.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -291,7 +274,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n \n@@ -325,7 +308,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    begin\n       Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n \n-      if X = 0 then\n+      if Checks and then X = 0 then\n          raise Constraint_Error with \"attempt to delete key not in map\";\n       end if;\n \n@@ -334,20 +317,18 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"Delete attempted to tamper with cursors (map is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n@@ -366,7 +347,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n                Key_Ops.Find (Container'Unrestricted_Access.all, Key);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with\n            \"no element available because key not in map\";\n       end if;\n@@ -376,7 +357,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of function Element equals No_Element\";\n       end if;\n@@ -404,12 +385,12 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    function Equivalent_Keys (Left, Right : Cursor)\n      return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n@@ -428,7 +409,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n@@ -445,7 +426,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n@@ -478,27 +459,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Map renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.TC);\n       end if;\n    end Finalize;\n \n@@ -536,6 +497,16 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       return Object.Container.First;\n    end First;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Nodes (Position.Node).Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -571,10 +542,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"Include attempted to tamper with elements (map is locked)\";\n-         end if;\n+         TE_Check (Container.TC);\n \n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n@@ -648,7 +616,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       --  order to prevent divide-by-zero errors later, when we compute the\n       --  buckets array index value for a key, given its hash value.\n \n-      if Container.Buckets'Length = 0 then\n+      if Checks and then Container.Buckets'Length = 0 then\n          raise Capacity_Error with \"No capacity for insertion\";\n       end if;\n \n@@ -705,7 +673,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       --  order to prevent divide-by-zero errors later, when we compute the\n       --  buckets array index value for a key, given its hash value.\n \n-      if Container.Buckets'Length = 0 then\n+      if Checks and then Container.Buckets'Length = 0 then\n          raise Capacity_Error with \"No capacity for insertion\";\n       end if;\n \n@@ -726,7 +694,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    begin\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert key already in map\";\n       end if;\n@@ -763,35 +731,23 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (Container);\n    end Iterate;\n \n    function Iterate\n      (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       return It : constant Iterator :=\n         (Limited_Controlled with\n            Container => Container'Unrestricted_Access)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -801,7 +757,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of function Key equals No_Element\";\n       end if;\n@@ -833,10 +789,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Target.Assign (Source);\n       Source.Clear;\n@@ -885,14 +838,29 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong map\";\n       end if;\n \n       return Next (Position);\n    end Next;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -903,7 +871,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n                    procedure (Key : Key_Type; Element : Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n@@ -913,26 +881,9 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       declare\n          M : Map renames Position.Container.all;\n          N : Node_Type renames M.Nodes (Position.Node);\n-         B : Natural renames M.Busy;\n-         L : Natural renames M.Lock;\n-\n+         Lock : With_Lock (M.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-\n-         begin\n-            Process (N.Key, N.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (N.Key, N.Element);\n       end;\n    end Query_Element;\n \n@@ -1017,12 +968,13 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n@@ -1032,16 +984,14 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => N.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1053,22 +1003,20 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n          N : Node_Type renames Container.Nodes (Node);\n-         B : Natural   renames Container.Busy;\n-         L : Natural   renames Container.Lock;\n-\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => N.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1085,19 +1033,15 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace attempted to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          N : Node_Type renames Container.Nodes (Node);\n-\n       begin\n          N.Key := Key;\n          N.Element := New_Item;\n@@ -1114,20 +1058,18 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      if Position.Container.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace_Element attempted to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Position.Container.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n@@ -1143,7 +1085,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       Capacity  : Count_Type)\n    is\n    begin\n-      if Capacity > Container.Capacity then\n+      if Checks and then Capacity > Container.Capacity then\n          raise Capacity_Error with \"requested capacity is too large\";\n       end if;\n    end Reserve_Capacity;\n@@ -1168,12 +1110,13 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Update_Element designates wrong map\";\n       end if;\n@@ -1182,24 +1125,9 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (N.Key, N.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (N.Key, N.Element);\n       end;\n    end Update_Element;\n "}, {"sha": "1514fb84aed174ec013a0bc463eb244d0737a59d", "filename": "gcc/ada/a-cbhama.ads", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -338,7 +338,7 @@ private\n    type Map (Capacity : Count_Type; Modulus : Hash_Type) is\n       new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n    use Ada.Streams;\n    use Ada.Finalization;\n \n@@ -380,15 +380,8 @@ private\n \n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is new Controlled with record\n-      Container : Map_Access;\n-   end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -432,6 +425,25 @@ private\n \n    for Reference_Type'Read use Read;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Map : constant Map :=\n                  (Hash_Table_Type with Capacity => 0, Modulus => 0);\n \n@@ -441,7 +453,8 @@ private\n      Map_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Map_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "d75ac48bb21449f02cf01d4364fc69d137b405a5", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 104, "deletions": 211, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,8 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n \n with System; use type System.Address;\n@@ -41,6 +43,10 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -140,24 +146,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       return Is_Equal (Left, Right);\n    end \"=\";\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Set renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -188,7 +176,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error\n            with \"Target capacity is less than Source length\";\n       end if;\n@@ -224,11 +212,12 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -237,16 +226,14 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Position.Container.Busy;\n-         L : Natural renames Position.Container.Lock;\n-\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n-            (Element => N.Element'Access,\n-             Control => (Controlled with Container'Unrestricted_Access))\n+           (Element => N.Element'Access,\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -277,7 +264,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          C := Source.Length;\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n-      else\n+      elsif Checks then\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n \n@@ -314,7 +301,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    begin\n       Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n \n-      if X = 0 then\n+      if Checks and then X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n@@ -326,18 +313,16 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n@@ -372,10 +357,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n \n       if Source.Length < Target.Length then\n          Src_Node := HT_Ops.First (Source);\n@@ -460,7 +442,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n@@ -530,12 +512,12 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n      return Boolean is\n \n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n@@ -570,7 +552,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Right : Element_Type) return Boolean\n    is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n@@ -589,7 +571,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Right : Cursor) return Boolean\n    is\n    begin\n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n@@ -638,27 +620,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Set renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.TC);\n       end if;\n    end Finalize;\n \n@@ -693,6 +655,16 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       return Object.Container.First;\n    end First;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Nodes (Position.Node).Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -727,10 +699,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Container.TC);\n \n          Container.Nodes (Position.Node).Element := New_Item;\n       end if;\n@@ -763,7 +732,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    begin\n       Insert (Container, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert element already in set\";\n       end if;\n@@ -816,7 +785,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       --  order to prevent divide-by-zero errors later, when we compute the\n       --  buckets array index value for an element, given its hash value.\n \n-      if Container.Buckets'Length = 0 then\n+      if Checks and then Container.Buckets'Length = 0 then\n          raise Capacity_Error with \"No capacity for insertion\";\n       end if;\n \n@@ -844,10 +813,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n \n       Tgt_Node := HT_Ops.First (Target);\n       while Tgt_Node /= 0 loop\n@@ -982,30 +948,19 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Iterate (Container);\n    end Iterate;\n \n    function Iterate (Container : Set)\n      return Set_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n    begin\n-      B := B + 1;\n+      Busy (Container.TC'Unrestricted_Access.all);\n       return It : constant Iterator :=\n         Iterator'(Limited_Controlled with\n                     Container => Container'Unrestricted_Access);\n@@ -1030,10 +985,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Target.Assign (Source);\n       Source.Clear;\n@@ -1083,7 +1035,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong set\";\n       end if;\n@@ -1118,6 +1070,21 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       return False;\n    end Overlap;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1127,7 +1094,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n@@ -1136,24 +1103,9 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n       declare\n          S : Set renames Position.Container.all;\n-         B : Natural renames S.Busy;\n-         L : Natural renames S.Lock;\n-\n+         Lock : With_Lock (S.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (S.Nodes (Position.Node).Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (S.Nodes (Position.Node).Element);\n       end;\n    end Query_Element;\n \n@@ -1231,15 +1183,12 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       Container.Nodes (Node).Element := New_Item;\n    end Replace;\n@@ -1250,12 +1199,13 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong set\";\n       end if;\n@@ -1274,7 +1224,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Capacity  : Count_Type)\n    is\n    begin\n-      if Capacity > Container.Capacity then\n+      if Checks and then Capacity > Container.Capacity then\n          raise Capacity_Error with \"requested capacity is too large\";\n       end if;\n    end Reserve_Capacity;\n@@ -1342,10 +1292,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n \n       Iterate (Source);\n    end Symmetric_Difference;\n@@ -1471,10 +1418,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n \n       --  ??? why is this code commented out ???\n       --  declare\n@@ -1623,23 +1567,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       -- Local Subprograms --\n       -----------------------\n \n-      ------------\n-      -- Adjust --\n-      ------------\n-\n-      procedure Adjust (Control : in out Reference_Control_Type) is\n-      begin\n-         if Control.Container /= null then\n-            declare\n-               B : Natural renames Control.Container.Busy;\n-               L : Natural renames Control.Container.Lock;\n-            begin\n-               B := B + 1;\n-               L := L + 1;\n-            end;\n-         end if;\n-      end Adjust;\n-\n       function Equivalent_Key_Node\n         (Key  : Key_Type;\n          Node : Node_Type) return Boolean;\n@@ -1670,25 +1597,20 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                   Key_Keys.Find (Container'Unrestricted_Access.all, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n          declare\n-            Cur  : Cursor := Find (Container, Key);\n-            pragma Unmodified (Cur);\n-\n             N : Node_Type renames Container.Nodes (Node);\n-            B : Natural renames Cur.Container.Busy;\n-            L : Natural renames Cur.Container.Lock;\n-\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n          begin\n             return R : constant Constant_Reference_Type :=\n               (Element => N.Element'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n+               Control => (Controlled with TC))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (TC.all);\n             end return;\n          end;\n       end Constant_Reference;\n@@ -1718,7 +1640,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       begin\n          Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n \n-         if X = 0 then\n+         if Checks and then X = 0 then\n             raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n@@ -1737,7 +1659,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                   Key_Keys.Find (Container'Unrestricted_Access.all, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n@@ -1777,15 +1699,10 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       procedure Finalize (Control : in out Reference_Control_Type) is\n       begin\n          if Control.Container /= null then\n-            declare\n-               B : Natural renames Control.Container.Busy;\n-               L : Natural renames Control.Container.Lock;\n-            begin\n-               B := B - 1;\n-               L := L - 1;\n-            end;\n+            Impl.Reference_Control_Type (Control).Finalize;\n \n-            if Hash (Key (Element (Control.Old_Pos))) /= Control.Old_Hash\n+            if Checks and then\n+              Hash (Key (Element (Control.Old_Pos))) /= Control.Old_Hash\n             then\n                HT_Ops.Delete_Node_At_Index\n                  (Control.Container.all, Control.Index, Control.Old_Pos.Node);\n@@ -1817,7 +1734,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n-         if Position.Node = 0 then\n+         if Checks and then Position.Node = 0 then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n@@ -1847,11 +1764,12 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          Position  : Cursor) return Reference_Type\n       is\n       begin\n-         if Position.Container = null then\n+         if Checks and then Position.Container = null then\n             raise Constraint_Error with \"Position cursor has no element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n          end if;\n@@ -1862,21 +1780,18 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n          begin\n             return R : constant Reference_Type :=\n               (Element  => N.Element'Unrestricted_Access,\n                 Control =>\n                   (Controlled with\n+                     Container.TC'Unrestricted_Access,\n                      Container'Unrestricted_Access,\n                      Index    => Key_Keys.Index (Container, Key (Position)),\n                      Old_Pos  => Position,\n                      Old_Hash => Hash (Key (Position))))\n-         do\n-               B := B + 1;\n-               L := L + 1;\n+            do\n+               Lock (Container.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -1888,27 +1803,24 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n          declare\n             P : constant Cursor := Find (Container, Key);\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n          begin\n             return R : constant Reference_Type :=\n               (Element => Container.Nodes (Node).Element'Unrestricted_Access,\n                Control =>\n                  (Controlled with\n+                    Container.TC'Unrestricted_Access,\n                     Container'Unrestricted_Access,\n                     Index  => Key_Keys.Index (Container, Key),\n                     Old_Pos => P,\n                     Old_Hash => Hash (Key)))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (Container.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -1925,7 +1837,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with\n               \"attempt to replace key not in set\";\n          end if;\n@@ -1947,12 +1859,13 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          N    : Nodes_Type renames Container.Nodes;\n \n       begin\n-         if Position.Node = 0 then\n+         if Checks and then Position.Node = 0 then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong set\";\n          end if;\n@@ -1977,34 +1890,14 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          declare\n             E : Element_Type renames N (Position.Node).Element;\n             K : constant Key_Type := Key (E);\n-\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n-            Eq : Boolean;\n-\n+            Lock : With_Lock (Container.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               --  Record bucket now, in case key is changed\n-               Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n-\n-               Process (E);\n-\n-               Eq := Equivalent_Keys (K, Key (E));\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n+            --  Record bucket now, in case key is changed\n+            Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n \n-            L := L - 1;\n-            B := B - 1;\n+            Process (E);\n \n-            if Eq then\n+            if Equivalent_Keys (K, Key (E)) then\n                return;\n             end if;\n          end;\n@@ -2022,7 +1915,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                while N (Prev).Next /= Position.Node loop\n                   Prev := N (Prev).Next;\n \n-                  if Prev = 0 then\n+                  if Checks and then Prev = 0 then\n                      raise Program_Error with\n                        \"Position cursor is bad (node not found)\";\n                   end if;"}, {"sha": "7f55d8d26e1306e910d98c3890394c7a756dcdd5", "filename": "gcc/ada/a-cbhase.ads", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -34,6 +34,7 @@\n with Ada.Iterator_Interfaces;\n \n private with Ada.Containers.Hash_Tables;\n+private with Ada.Containers.Helpers;\n private with Ada.Streams;\n private with Ada.Finalization; use Ada.Finalization;\n \n@@ -447,18 +448,17 @@ package Ada.Containers.Bounded_Hashed_Sets is\n       type Set_Access is access all Set;\n       for Set_Access'Storage_Size use 0;\n \n+      package Impl is new Helpers.Generic_Implementation;\n+\n       type Reference_Control_Type is\n-         new Ada.Finalization.Controlled with\n+         new Impl.Reference_Control_Type with\n       record\n          Container : Set_Access;\n          Index     : Hash_Type;\n          Old_Pos   : Cursor;\n          Old_Hash  : Hash_Type;\n       end record;\n \n-      overriding procedure Adjust (Control : in out Reference_Control_Type);\n-      pragma Inline (Adjust);\n-\n       overriding procedure Finalize (Control : in out Reference_Control_Type);\n       pragma Inline (Finalize);\n \n@@ -496,7 +496,7 @@ private\n    type Set (Capacity : Count_Type; Modulus : Hash_Type) is\n      new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n    use Ada.Streams;\n \n    procedure Write\n@@ -537,15 +537,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is new Controlled with record\n-      Container : Set_Access;\n-   end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -569,6 +562,25 @@ private\n \n    for Constant_Reference_Type'Write use Write;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Set : constant Set :=\n                  (Hash_Table_Type with Capacity => 0, Modulus => 0);\n \n@@ -578,7 +590,8 @@ private\n      Set_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Set_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "24db4d453a7d9c608e7b5f851ed44a549ec58a77", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 218, "deletions": 330, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2011-2014, Free Software Foundation, Inc.      --\n+--             Copyright (C) 2011-2015, Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,12 +27,19 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Finalization;\n with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Multiway_Trees is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n+   use Finalization;\n+\n    --------------------\n    --  Root_Iterator --\n    --------------------\n@@ -217,10 +224,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n    function \"=\" (Left, Right : Tree) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       if Left.Count /= Right.Count then\n          return False;\n       end if;\n@@ -236,24 +239,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n                 Right_Subtree => Root_Node (Right));\n    end \"=\";\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Tree renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    -------------------\n    -- Allocate_Node --\n    -------------------\n@@ -343,7 +328,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       R, N : Count_Type;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n@@ -352,7 +337,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  search. For now we omit this check, pending a ruling from the ARG.\n       --  ???\n       --\n-      --  if Is_Root (Position) then\n+      --  if Checks and then Is_Root (Position) then\n       --     raise Program_Error with \"Position cursor designates root\";\n       --  end if;\n \n@@ -383,27 +368,24 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       First, Last : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Count = 0 then\n          return;\n       end if;\n \n-      if Container.Count > Container.Capacity - Count then\n+      if Checks and then Container.Count > Container.Capacity - Count then\n          raise Capacity_Error\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Container.Count = 0 then\n          Initialize_Root (Container);\n@@ -443,7 +425,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Count then\n+      if Checks and then Target.Capacity < Source.Count then\n          raise Capacity_Error  -- ???\n            with \"Target capacity is less than Source count\";\n       end if;\n@@ -521,15 +503,15 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       N      : Count_Type'Base;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Child = No_Element then\n+      if Checks and then Child = No_Element then\n          raise Constraint_Error with \"Child cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Child.Container then\n+      if Checks and then Parent.Container /= Child.Container then\n          raise Program_Error with \"Parent and Child in different containers\";\n       end if;\n \n@@ -545,7 +527,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          Result := Result + 1;\n          N := Parent.Container.Nodes (N).Parent;\n \n-         if N < 0 then\n+         if Checks and then N < 0 then\n             raise Program_Error with \"Parent is not ancestor of Child\";\n          end if;\n       end loop;\n@@ -562,10 +544,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Count           : Count_Type;\n \n    begin\n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Container_Count = 0 then\n          return;\n@@ -596,17 +575,18 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      if Position.Node = Root_Node (Container) then\n+      if Checks and then Position.Node = Root_Node (Container) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -615,17 +595,14 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --                 \"Position cursor in Constant_Reference is bad\");\n \n       declare\n-         C : Tree renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Container.Elements (Position.Node)'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -657,7 +634,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          C := Source.Count;\n       elsif Capacity >= Source.Count then\n          C := Capacity;\n-      else\n+      elsif Checks then\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n \n@@ -762,20 +739,22 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Target_Count   : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Target'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Target'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with \"Before cursor not in container\";\n          end if;\n \n-         if Before.Container.Nodes (Before.Node).Parent /= Parent.Node then\n+         if Checks and then\n+           Before.Container.Nodes (Before.Node).Parent /= Parent.Node\n+         then\n             raise Constraint_Error with \"Before cursor not child of Parent\";\n          end if;\n       end if;\n@@ -784,7 +763,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Is_Root (Source) then\n+      if Checks and then Is_Root (Source) then\n          raise Constraint_Error with \"Source cursor designates root\";\n       end if;\n \n@@ -1011,18 +990,15 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Container.Count = 0 then\n          pragma Assert (Is_Root (Parent));\n@@ -1053,26 +1029,24 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       X : Count_Type;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if not Is_Leaf (Position) then\n+      if Checks and then not Is_Leaf (Position) then\n          raise Constraint_Error with \"Position cursor does not designate leaf\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       X := Position.Node;\n       Position := No_Element;\n@@ -1095,22 +1069,20 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       X := Position.Node;\n       Position := No_Element;\n@@ -1163,11 +1135,12 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Node = Root_Node (Position.Container.all) then\n+      if Checks and then Position.Node = Root_Node (Position.Container.all)\n+      then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -1222,11 +1195,11 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Right_Position : Cursor) return Boolean\n    is\n    begin\n-      if Left_Position = No_Element then\n+      if Checks and then Left_Position = No_Element then\n          raise Constraint_Error with \"Left cursor has no element\";\n       end if;\n \n-      if Right_Position = No_Element then\n+      if Checks and then Right_Position = No_Element then\n          raise Constraint_Error with \"Right cursor has no element\";\n       end if;\n \n@@ -1290,25 +1263,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    --------------\n \n    procedure Finalize (Object : in out Root_Iterator) is\n-      B : Natural renames Object.Container.Busy;\n-   begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n    begin\n-      if Control.Container /= null then\n-         declare\n-            C : Tree renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n-      end if;\n+      Unbusy (Object.Container.TC);\n    end Finalize;\n \n    ----------\n@@ -1361,7 +1317,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Node : Count_Type'Base;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n@@ -1426,13 +1382,15 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Result : Count_Type;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       --  Commented-out pending ruling by ARG.  ???\n \n-      --  if Position.Container /= Container'Unrestricted_Access then\n+      --  if Checks and then\n+      --    Position.Container /= Container'Unrestricted_Access\n+      --  then\n       --     raise Program_Error with \"Position cursor not in container\";\n       --  end if;\n \n@@ -1474,6 +1432,16 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       return Find_In_Children (Container, Subtree, Item);\n    end Find_In_Subtree;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Elements (Position.Node)'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1543,20 +1511,23 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Last  : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with \"Before cursor not in container\";\n          end if;\n \n-         if Before.Container.Nodes (Before.Node).Parent /= Parent.Node then\n+         if Checks and then\n+           Before.Container.Nodes (Before.Node).Parent /= Parent.Node\n+         then\n             raise Constraint_Error with \"Parent cursor not parent of Before\";\n          end if;\n       end if;\n@@ -1566,15 +1537,12 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Container.Count > Container.Capacity - Count then\n+      if Checks and then Container.Count > Container.Capacity - Count then\n          raise Capacity_Error\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Container.Count = 0 then\n          Initialize_Root (Container);\n@@ -1620,20 +1588,23 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  OK to reference, see below\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with \"Before cursor not in container\";\n          end if;\n \n-         if Before.Container.Nodes (Before.Node).Parent /= Parent.Node then\n+         if Checks and then\n+           Before.Container.Nodes (Before.Node).Parent /= Parent.Node\n+         then\n             raise Constraint_Error with \"Parent cursor not parent of Before\";\n          end if;\n       end if;\n@@ -1643,15 +1614,12 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Container.Count > Container.Capacity - Count then\n+      if Checks and then Container.Count > Container.Capacity - Count then\n          raise Capacity_Error\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Container.Count = 0 then\n          Initialize_Root (Container);\n@@ -1832,26 +1800,16 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n      (Container : Tree;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n       if Container.Count = 0 then\n          return;\n       end if;\n \n-      B := B + 1;\n-\n       Iterate_Children\n         (Container => Container,\n          Subtree   => Root_Node (Container),\n          Process   => Process);\n-\n-      B := B - 1;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         raise;\n    end Iterate;\n \n    function Iterate (Container : Tree)\n@@ -1870,7 +1828,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Process : not null access procedure (Position : Cursor))\n    is\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n@@ -1880,25 +1838,16 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       end if;\n \n       declare\n-         B  : Natural renames Parent.Container.Busy;\n          C  : Count_Type;\n          NN : Tree_Node_Array renames Parent.Container.Nodes;\n+         Busy : With_Busy (Parent.Container.TC'Unrestricted_Access);\n \n       begin\n-         B := B + 1;\n-\n          C := NN (Parent.Node).Children.First;\n          while C > 0 loop\n             Process (Cursor'(Parent.Container, Node => C));\n             C := NN (C).Next;\n          end loop;\n-\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n       end;\n    end Iterate_Children;\n \n@@ -1931,14 +1880,12 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       C : constant Tree_Access := Container'Unrestricted_Access;\n-      B : Natural renames C.Busy;\n-\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= C then\n+      if Checks and then Parent.Container /= C then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n@@ -1947,7 +1894,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n                           Container => C,\n                           Subtree   => Parent.Node)\n       do\n-         B := B + 1;\n+         Busy (C.TC);\n       end return;\n    end Iterate_Children;\n \n@@ -1959,33 +1906,30 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n      (Position : Cursor)\n       return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n+      C : constant Tree_Access := Position.Container;\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       --  Implement Vet for multiway trees???\n       --  pragma Assert (Vet (Position), \"bad subtree cursor\");\n \n-      declare\n-         B : Natural renames Position.Container.Busy;\n-      begin\n-         return It : constant Subtree_Iterator :=\n-           (Limited_Controlled with\n-              Container => Position.Container,\n-              Subtree   => Position.Node)\n-         do\n-            B := B + 1;\n-         end return;\n-      end;\n+      return It : constant Subtree_Iterator :=\n+        (Limited_Controlled with\n+           Container => C,\n+           Subtree   => Position.Node)\n+      do\n+         Busy (C.TC);\n+      end return;\n    end Iterate_Subtree;\n \n    procedure Iterate_Subtree\n      (Position  : Cursor;\n       Process   : not null access procedure (Position : Cursor))\n    is\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n@@ -1996,23 +1940,13 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n       declare\n          T : Tree renames Position.Container.all;\n-         B : Natural renames T.Busy;\n-\n+         Busy : With_Busy (T.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-\n          if Is_Root (Position) then\n             Iterate_Children (T, Position.Node, Process);\n          else\n             Iterate_Subtree (T, Position.Node, Process);\n          end if;\n-\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n       end;\n    end Iterate_Subtree;\n \n@@ -2047,7 +1981,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Node : Count_Type'Base;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n@@ -2084,10 +2018,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors of Source (tree is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Target.Assign (Source);\n       Source.Clear;\n@@ -2106,7 +2037,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong tree\";\n       end if;\n@@ -2146,7 +2077,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong tree\";\n       end if;\n@@ -2254,27 +2185,24 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       First, Last : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Count = 0 then\n          return;\n       end if;\n \n-      if Container.Count > Container.Capacity - Count then\n+      if Checks and then Container.Count > Container.Capacity - Count then\n          raise Capacity_Error\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Container.Count = 0 then\n          Initialize_Root (Container);\n@@ -2315,7 +2243,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong tree\";\n       end if;\n@@ -2357,6 +2285,20 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Position := Previous_Sibling (Position);\n    end Previous_Sibling;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Tree'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -2366,33 +2308,19 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n       declare\n          T : Tree renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n+         Lock : With_Lock (T.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n          Process (Element => T.Elements (Position.Node));\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n       end;\n    end Query_Element;\n \n@@ -2430,7 +2358,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       begin\n          Count_Type'Read (Stream, Count);\n \n-         if Count < 0 then\n+         if Checks and then Count < 0 then\n             raise Program_Error with \"attempt to read from corrupt stream\";\n          end if;\n \n@@ -2480,15 +2408,15 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n       Count_Type'Read (Stream, Total_Count);\n \n-      if Total_Count < 0 then\n+      if Checks and then Total_Count < 0 then\n          raise Program_Error with \"attempt to read from corrupt stream\";\n       end if;\n \n       if Total_Count = 0 then\n          return;\n       end if;\n \n-      if Total_Count > Container.Capacity then\n+      if Checks and then Total_Count > Container.Capacity then\n          raise Capacity_Error  -- ???\n            with \"node count in stream exceeds container capacity\";\n       end if;\n@@ -2499,7 +2427,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n       Read_Children (Root_Node (Container));\n \n-      if Read_Count /= Total_Count then\n+      if Checks and then Read_Count /= Total_Count then\n          raise Program_Error with \"attempt to read from corrupt stream\";\n       end if;\n \n@@ -2539,17 +2467,18 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      if Position.Node = Root_Node (Container) then\n+      if Checks and then Position.Node = Root_Node (Container) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -2558,19 +2487,16 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --                 \"Position cursor in Constant_Reference is bad\");\n \n       declare\n-         C : Tree renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Container.Elements (Position.Node)'Access,\n-            Control => (Controlled with Position.Container))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n-\n    end Reference;\n \n    --------------------\n@@ -2623,22 +2549,20 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with elements (tree is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       Container.Elements (Position.Node) := New_Item;\n    end Replace_Element;\n@@ -2652,7 +2576,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Process : not null access procedure (Position : Cursor))\n    is\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n@@ -2663,24 +2587,15 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n       declare\n          NN : Tree_Node_Array renames Parent.Container.Nodes;\n-         B  : Natural renames Parent.Container.Busy;\n+         Busy : With_Busy (Parent.Container.TC'Unrestricted_Access);\n          C  : Count_Type;\n \n       begin\n-         B := B + 1;\n-\n          C := NN (Parent.Node).Children.Last;\n          while C > 0 loop\n             Process (Cursor'(Parent.Container, Node => C));\n             C := NN (C).Prev;\n          end loop;\n-\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n       end;\n    end Reverse_Iterate_Children;\n \n@@ -2716,32 +2631,36 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Source_Parent : Cursor)\n    is\n    begin\n-      if Target_Parent = No_Element then\n+      if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n \n-      if Target_Parent.Container /= Target'Unrestricted_Access then\n+      if Checks and then Target_Parent.Container /= Target'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Target_Parent cursor not in Target container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error\n               with \"Before cursor not in Target container\";\n          end if;\n \n-         if Target.Nodes (Before.Node).Parent /= Target_Parent.Node then\n+         if Checks and then\n+           Target.Nodes (Before.Node).Parent /= Target_Parent.Node\n+         then\n             raise Constraint_Error\n               with \"Before cursor not child of Target_Parent\";\n          end if;\n       end if;\n \n-      if Source_Parent = No_Element then\n+      if Checks and then Source_Parent = No_Element then\n          raise Constraint_Error with \"Source_Parent cursor has no element\";\n       end if;\n \n-      if Source_Parent.Container /= Source'Unrestricted_Access then\n+      if Checks and then Source_Parent.Container /= Source'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Source_Parent cursor not in Source container\";\n       end if;\n@@ -2756,12 +2675,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n             return;\n          end if;\n \n-         if Target.Busy > 0 then\n-            raise Program_Error\n-              with \"attempt to tamper with cursors (Target tree is busy)\";\n-         end if;\n+         TC_Check (Target.TC);\n \n-         if Is_Reachable (Container => Target,\n+         if Checks and then Is_Reachable (Container => Target,\n                           From      => Target_Parent.Node,\n                           To        => Source_Parent.Node)\n          then\n@@ -2778,15 +2694,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Target tree is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Source tree is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       if Target.Count = 0 then\n          Initialize_Root (Target);\n@@ -2807,32 +2716,39 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Source_Parent   : Cursor)\n    is\n    begin\n-      if Target_Parent = No_Element then\n+      if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n \n-      if Target_Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then\n+        Target_Parent.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Target_Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error\n               with \"Before cursor not in container\";\n          end if;\n \n-         if Container.Nodes (Before.Node).Parent /= Target_Parent.Node then\n+         if Checks and then\n+           Container.Nodes (Before.Node).Parent /= Target_Parent.Node\n+         then\n             raise Constraint_Error\n               with \"Before cursor not child of Target_Parent\";\n          end if;\n       end if;\n \n-      if Source_Parent = No_Element then\n+      if Checks and then Source_Parent = No_Element then\n          raise Constraint_Error with \"Source_Parent cursor has no element\";\n       end if;\n \n-      if Source_Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then\n+        Source_Parent.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Source_Parent cursor not in container\";\n       end if;\n@@ -2843,12 +2759,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n       pragma Assert (Container.Count > 0);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n-      if Is_Reachable (Container => Container,\n+      if Checks and then Is_Reachable (Container => Container,\n                        From      => Target_Parent.Node,\n                        To        => Source_Parent.Node)\n       then\n@@ -2944,7 +2857,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Target.Count > Target.Capacity - Source_Count then\n+      if Checks and then Target.Count > Target.Capacity - Source_Count then\n          raise Capacity_Error  -- ???\n            with \"Source count exceeds available storage on Target\";\n       end if;\n@@ -3002,33 +2915,34 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Position : in out Cursor)\n    is\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Target'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Target'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in Target container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with \"Before cursor not in Target container\";\n          end if;\n \n-         if Target.Nodes (Before.Node).Parent /= Parent.Node then\n+         if Checks and then Target.Nodes (Before.Node).Parent /= Parent.Node\n+         then\n             raise Constraint_Error with \"Before cursor not child of Parent\";\n          end if;\n       end if;\n \n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Source'Unrestricted_Access then\n+      if Checks and then Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error with \"Position cursor not in Source container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -3047,12 +2961,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n             end if;\n          end if;\n \n-         if Target.Busy > 0 then\n-            raise Program_Error\n-              with \"attempt to tamper with cursors (Target tree is busy)\";\n-         end if;\n+         TC_Check (Target.TC);\n \n-         if Is_Reachable (Container => Target,\n+         if Checks and then Is_Reachable (Container => Target,\n                           From      => Parent.Node,\n                           To        => Position.Node)\n          then\n@@ -3067,15 +2978,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Target tree is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Source tree is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       if Target.Count = 0 then\n          Initialize_Root (Target);\n@@ -3098,33 +3002,36 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Position  : Cursor)\n    is\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with \"Before cursor not in container\";\n          end if;\n \n-         if Container.Nodes (Before.Node).Parent /= Parent.Node then\n+         if Checks and then Container.Nodes (Before.Node).Parent /= Parent.Node\n+         then\n             raise Constraint_Error with \"Before cursor not child of Parent\";\n          end if;\n       end if;\n \n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n \n          --  Should this be PE instead?  Need ARG confirmation.  ???\n \n@@ -3145,12 +3052,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          end if;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n-      if Is_Reachable (Container => Container,\n+      if Checks and then Is_Reachable (Container => Container,\n                        From      => Parent.Node,\n                        To        => Position.Node)\n       then\n@@ -3181,7 +3085,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  is a bit of a misnomer here in the case of a bounded tree, because\n       --  the elements must be copied from the source to the target.\n \n-      if Target.Count > Target.Capacity - Source_Count then\n+      if Checks and then Target.Count > Target.Capacity - Source_Count then\n          raise Capacity_Error  -- ???\n            with \"Source count exceeds available storage on Target\";\n       end if;\n@@ -3276,38 +3180,35 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       I, J      : Cursor)\n    is\n    begin\n-      if I = No_Element then\n+      if Checks and then I = No_Element then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n+      if Checks and then I.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"I cursor not in container\";\n       end if;\n \n-      if Is_Root (I) then\n+      if Checks and then Is_Root (I) then\n          raise Program_Error with \"I cursor designates root\";\n       end if;\n \n       if I = J then -- make this test sooner???\n          return;\n       end if;\n \n-      if J = No_Element then\n+      if Checks and then J = No_Element then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n+      if Checks and then J.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"J cursor not in container\";\n       end if;\n \n-      if Is_Root (J) then\n+      if Checks and then Is_Root (J) then\n          raise Program_Error with \"J cursor designates root\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with elements (tree is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          EE : Element_Array renames Container.Elements;\n@@ -3329,37 +3230,24 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n       declare\n          T : Tree renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n+         Lock : With_Lock (T.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n          Process (Element => T.Elements (Position.Node));\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n       end;\n    end Update_Element;\n "}, {"sha": "93b5e27d89e44aef34f420344d49914401bd5a57", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -32,8 +32,9 @@\n ------------------------------------------------------------------------------\n \n with Ada.Iterator_Interfaces;\n+\n+private with Ada.Containers.Helpers;\n private with Ada.Streams;\n-private with Ada.Finalization;\n \n generic\n    type Element_Type is private;\n@@ -270,8 +271,12 @@ package Ada.Containers.Bounded_Multiway_Trees is\n       Process : not null access procedure (Position : Cursor));\n \n private\n+\n+   use Ada.Containers.Helpers;\n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    use Ada.Streams;\n-   use Ada.Finalization;\n \n    No_Node : constant Count_Type'Base := -1;\n    --  Need to document all global declarations such as this ???\n@@ -297,8 +302,7 @@ private\n       Nodes    : Tree_Node_Array (0 .. Capacity) := (others => <>);\n       Elements : Element_Array (1 .. Capacity) := (others => <>);\n       Free     : Count_Type'Base := No_Node;\n-      Busy     : Integer := 0;\n-      Lock     : Integer := 0;\n+      TC       : aliased Tamper_Counts;\n       Count    : Count_Type := 0;\n    end record;\n \n@@ -332,16 +336,8 @@ private\n       Position : Cursor);\n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Tree_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -383,6 +379,25 @@ private\n       Item   : out Reference_Type);\n    for Reference_Type'Read use Read;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Tree'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Tree : constant Tree := (Capacity => 0, others => <>);\n \n    No_Element : constant Cursor := Cursor'(others => <>);"}, {"sha": "c9f113040a2c4eb901a0a116fba39f95dcbd80fe", "filename": "gcc/ada/a-cborma.adb", "status": "modified", "additions": 117, "deletions": 196, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,6 +27,8 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n pragma Elaborate_All\n   (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n@@ -41,6 +43,10 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -108,11 +114,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n@@ -133,7 +139,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n@@ -150,7 +156,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n@@ -206,11 +212,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n@@ -231,7 +237,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n@@ -247,7 +253,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n@@ -262,24 +268,6 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       end;\n    end \">\";\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Map renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -358,7 +346,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error\n            with \"Target capacity is less than Source length\";\n       end if;\n@@ -409,12 +397,13 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n@@ -424,16 +413,14 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Position.Container.Busy;\n-         L : Natural renames Position.Container.Lock;\n-\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n-            (Element => N.Element'Access,\n-             Control => (Controlled with Container'Unrestricted_Access))\n+           (Element => N.Element'Access,\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -445,25 +432,20 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n-         Cur  : Cursor := Find (Container, Key);\n-         pragma Unmodified (Cur);\n-\n          N : Node_Type renames Container.Nodes (Node);\n-         B : Natural renames Cur.Container.Busy;\n-         L : Natural renames Cur.Container.Lock;\n-\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n-            (Element => N.Element'Access,\n-             Control => (Controlled with Container'Unrestricted_Access))\n+           (Element => N.Element'Access,\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -491,7 +473,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n \n@@ -506,12 +488,13 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n@@ -529,7 +512,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       X : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-      if X = 0 then\n+      if Checks and then X = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n@@ -571,7 +554,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of function Element equals No_Element\";\n       end if;\n@@ -585,11 +568,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with \"key not in map\";\n-      else\n-         return Container.Nodes (Node).Element;\n       end if;\n+\n+      return Container.Nodes (Node).Element;\n    end Element;\n \n    ---------------------\n@@ -628,27 +611,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Map renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.TC);\n       end if;\n    end Finalize;\n \n@@ -707,11 +670,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function First_Element (Container : Map) return Element_Type is\n    begin\n-      if Container.First = 0 then\n+      if Checks and then Container.First = 0 then\n          raise Constraint_Error with \"map is empty\";\n-      else\n-         return Container.Nodes (Container.First).Element;\n       end if;\n+\n+      return Container.Nodes (Container.First).Element;\n    end First_Element;\n \n    ---------------\n@@ -720,11 +683,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function First_Key (Container : Map) return Key_Type is\n    begin\n-      if Container.First = 0 then\n+      if Checks and then Container.First = 0 then\n          raise Constraint_Error with \"map is empty\";\n-      else\n-         return Container.Nodes (Container.First).Key;\n       end if;\n+\n+      return Container.Nodes (Container.First).Key;\n    end First_Key;\n \n    -----------\n@@ -741,6 +704,16 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       end if;\n    end Floor;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Nodes (Position.Node).Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -766,10 +739,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (map is locked)\";\n-         end if;\n+         TE_Check (Container.TC);\n \n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n@@ -852,7 +822,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n    begin\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with \"key already in map\";\n       end if;\n    end Insert;\n@@ -979,29 +949,17 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (Container);\n    end Iterate;\n \n    function Iterate\n      (Container : Map) return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -1018,7 +976,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n            Container => Container'Unrestricted_Access,\n            Node      => 0)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1027,8 +985,6 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Start     : Cursor)\n       return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  Iterator was defined to behave the same as for a complete iterator,\n       --  and iterate over the entire sequence of items. However, those\n@@ -1040,12 +996,12 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start = No_Element then\n+      if Checks and then Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n       end if;\n \n-      if Start.Container /= Container'Unrestricted_Access then\n+      if Checks and then Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong map\";\n       end if;\n@@ -1067,7 +1023,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n            Container => Container'Unrestricted_Access,\n            Node      => Start.Node)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1077,7 +1033,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of function Key equals No_Element\";\n       end if;\n@@ -1129,11 +1085,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function Last_Element (Container : Map) return Element_Type is\n    begin\n-      if Container.Last = 0 then\n+      if Checks and then Container.Last = 0 then\n          raise Constraint_Error with \"map is empty\";\n-      else\n-         return Container.Nodes (Container.Last).Element;\n       end if;\n+\n+      return Container.Nodes (Container.Last).Element;\n    end Last_Element;\n \n    --------------\n@@ -1142,11 +1098,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n    function Last_Key (Container : Map) return Key_Type is\n    begin\n-      if Container.Last = 0 then\n+      if Checks and then Container.Last = 0 then\n          raise Constraint_Error with \"map is empty\";\n-      else\n-         return Container.Nodes (Container.Last).Key;\n       end if;\n+\n+      return Container.Nodes (Container.Last).Key;\n    end Last_Key;\n \n    ----------\n@@ -1177,10 +1133,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Target.Assign (Source);\n       Source.Clear;\n@@ -1228,7 +1181,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong map\";\n       end if;\n@@ -1287,14 +1240,29 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong map\";\n       end if;\n \n       return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1305,7 +1273,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n                                             Element : Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n@@ -1316,25 +1284,9 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       declare\n          M : Map renames Position.Container.all;\n          N : Node_Type renames M.Nodes (Position.Node);\n-\n-         B : Natural renames M.Busy;\n-         L : Natural renames M.Lock;\n-\n+         Lock : With_Lock (M.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (N.Key, N.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (N.Key, N.Element);\n       end;\n    end Query_Element;\n \n@@ -1404,12 +1356,13 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n@@ -1419,15 +1372,14 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural   renames Container.Busy;\n-         L : Natural   renames Container.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => N.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1439,21 +1391,20 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n          N : Node_Type renames Container.Nodes (Node);\n-         B : Natural   renames Container.Busy;\n-         L : Natural   renames Container.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => N.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1470,14 +1421,11 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          N : Node_Type renames Container.Nodes (Node);\n@@ -1498,20 +1446,18 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n@@ -1542,22 +1488,12 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n \n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (Container);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Reverse_Iterate (Container);\n    end Reverse_Iterate;\n \n    -----------\n@@ -1619,12 +1555,13 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Update_Element designates wrong map\";\n       end if;\n@@ -1634,25 +1571,9 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (N.Key, N.Element);\n-\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (N.Key, N.Element);\n       end;\n    end Update_Element;\n "}, {"sha": "2b68bbffb47d4b9616245008faa0b41bc574cea2", "filename": "gcc/ada/a-cborma.ads", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -248,7 +248,7 @@ private\n      new Tree_Types.Tree_Type (Capacity) with null record;\n \n    use Red_Black_Trees;\n-   use Tree_Types;\n+   use Tree_Types, Tree_Types.Implementation;\n    use Ada.Streams;\n \n    procedure Write\n@@ -283,15 +283,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is new Controlled with record\n-      Container : Map_Access;\n-   end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -335,6 +328,25 @@ private\n \n    for Reference_Type'Write use Write;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions.  See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Map : constant Map := Map'(Tree_Type with Capacity => 0);\n \n    No_Element : constant Cursor := Cursor'(null, 0);\n@@ -344,7 +356,8 @@ private\n    record\n       Container : Map_Access;\n       Node      : Count_Type;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "84c71492e097a02151363218fccb5a5e7642077f", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 115, "deletions": 255, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,6 +27,8 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n pragma Elaborate_All\n   (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n@@ -44,6 +46,10 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    ------------------------------\n    -- Access to Fields of Node --\n    ------------------------------\n@@ -141,11 +147,11 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n@@ -165,7 +171,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n@@ -177,7 +183,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n@@ -219,11 +225,11 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n@@ -245,7 +251,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = 0 then\n+      if Checks and then Right.Node = 0 then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n@@ -257,7 +263,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n-      if Left.Node = 0 then\n+      if Checks and then Left.Node = 0 then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n@@ -267,24 +273,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       return Right < Left.Container.Nodes (Left.Node).Element;\n    end \">\";\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Set renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -361,7 +349,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error\n            with \"Target capacity is less than Source length\";\n       end if;\n@@ -409,11 +397,12 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -424,15 +413,14 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       declare\n          N : Node_Type renames Container.Nodes (Position.Node);\n-         B : Natural renames Position.Container.Busy;\n-         L : Natural renames Position.Container.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n-            (Element => N.Element'Access,\n-             Control => (Controlled with Container'Unrestricted_Access))\n+           (Element => N.Element'Access,\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -461,7 +449,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          C := Source.Length;\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n-      else\n+      elsif Checks then\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n \n@@ -476,18 +464,16 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Delete\");\n@@ -504,7 +490,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    begin\n       Tree_Operations.Delete_Node_Sans_Free (Container, X);\n \n-      if X = 0 then\n+      if Checks and then X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n@@ -553,7 +539,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n@@ -620,27 +606,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Set renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.TC);\n       end if;\n    end Finalize;\n \n@@ -693,7 +659,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function First_Element (Container : Set) return Element_Type is\n    begin\n-      if Container.First = 0 then\n+      if Checks and then Container.First = 0 then\n          raise Constraint_Error with \"set is empty\";\n       end if;\n \n@@ -742,23 +708,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n            Is_Less_Key_Node    => Is_Less_Key_Node,\n            Is_Greater_Key_Node => Is_Greater_Key_Node);\n \n-      ------------\n-      -- Adjust --\n-      ------------\n-\n-      procedure Adjust (Control : in out Reference_Control_Type) is\n-      begin\n-         if Control.Container /= null then\n-            declare\n-               B : Natural renames Control.Container.Busy;\n-               L : Natural renames Control.Container.Lock;\n-            begin\n-               B := B + 1;\n-               L := L + 1;\n-            end;\n-         end if;\n-      end Adjust;\n-\n       -------------\n       -- Ceiling --\n       -------------\n@@ -782,25 +731,20 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n          declare\n-            Cur : Cursor := Find (Container, Key);\n-            pragma Unmodified (Cur);\n-\n             N : Node_Type renames Container.Nodes (Node);\n-            B : Natural renames Cur.Container.Busy;\n-            L : Natural renames Cur.Container.Lock;\n-\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n          begin\n             return R : constant Constant_Reference_Type :=\n               (Element => N.Element'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n+               Control => (Controlled with TC))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (TC.all);\n             end return;\n          end;\n       end Constant_Reference;\n@@ -822,7 +766,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          X : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if X = 0 then\n+         if Checks and then X = 0 then\n             raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n@@ -838,7 +782,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n@@ -874,15 +818,10 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       procedure Finalize (Control : in out Reference_Control_Type) is\n       begin\n          if Control.Container /= null then\n-            declare\n-               B : Natural renames Control.Container.Busy;\n-               L : Natural renames Control.Container.Lock;\n-            begin\n-               B := B - 1;\n-               L := L - 1;\n-            end;\n-\n-            if not (Key (Control.Pos) = Control.Old_Key.all) then\n+            Impl.Reference_Control_Type (Control).Finalize;\n+\n+            if Checks and then not (Key (Control.Pos) = Control.Old_Key.all)\n+            then\n                Delete (Control.Container.all, Key (Control.Pos));\n                raise Program_Error;\n             end if;\n@@ -943,7 +882,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n-         if Position.Node = 0 then\n+         if Checks and then Position.Node = 0 then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n@@ -975,11 +914,12 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          Position  : Cursor) return Reference_Type\n       is\n       begin\n-         if Position.Container = null then\n+         if Checks and then Position.Container = null then\n             raise Constraint_Error with \"Position cursor has no element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n          end if;\n@@ -990,19 +930,17 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n          begin\n             return R : constant Reference_Type :=\n                          (Element => N.Element'Access,\n                           Control =>\n                             (Controlled with\n+                              Container.TC'Unrestricted_Access,\n                               Container => Container'Access,\n                               Pos       => Position,\n                               Old_Key   => new Key_Type'(Key (Position))))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (Container.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -1014,25 +952,23 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n          declare\n             N : Node_Type renames Container.Nodes (Node);\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n          begin\n             return R : constant Reference_Type :=\n                          (Element => N.Element'Access,\n                           Control =>\n                             (Controlled with\n+                              Container.TC'Unrestricted_Access,\n                               Container => Container'Access,\n                                Pos      => Find (Container, Key),\n                                Old_Key  => new Key_Type'(Key)))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (Container.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -1049,7 +985,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if Node = 0 then\n+         if Checks and then Node = 0 then\n             raise Constraint_Error with\n               \"attempt to replace key not in set\";\n          end if;\n@@ -1067,12 +1003,13 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          Process   : not null access procedure (Element : in out Element_Type))\n       is\n       begin\n-         if Position.Node = 0 then\n+         if Checks and then Position.Node = 0 then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong set\";\n          end if;\n@@ -1087,30 +1024,10 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n             N : Node_Type renames Container.Nodes (Position.Node);\n             E : Element_Type renames N.Element;\n             K : constant Key_Type := Key (E);\n-\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n-            Eq : Boolean;\n-\n+            Lock : With_Lock (Container.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Process (E);\n-               Eq := Equivalent_Keys (K, Key (E));\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n-\n-            L := L - 1;\n-            B := B - 1;\n-\n-            if Eq then\n+            Process (E);\n+            if Equivalent_Keys (K, Key (E)) then\n                return;\n             end if;\n          end;\n@@ -1134,6 +1051,16 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       end Write;\n    end Generic_Keys;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Nodes (Position.Node).Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1155,10 +1082,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Container.TC);\n \n          Container.Nodes (Position.Node).Element := New_Item;\n       end if;\n@@ -1196,7 +1120,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    begin\n       Insert (Container, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert element already in set\";\n       end if;\n@@ -1250,10 +1174,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    --  Start of processing for Insert_Sans_Hint\n \n    begin\n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attemot to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       Conditional_Insert_Sans_Hint\n         (Container,\n@@ -1411,29 +1332,17 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       end Process_Node;\n \n       S : Set renames Container'Unrestricted_Access.all;\n-      B : Natural renames S.Busy;\n+      Busy : With_Busy (S.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (S);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (S);\n    end Iterate;\n \n    function Iterate (Container : Set)\n      return Set_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -1450,15 +1359,13 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n                     Container => Container'Unrestricted_Access,\n                     Node      => 0)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n    function Iterate (Container : Set; Start : Cursor)\n      return Set_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1471,12 +1378,12 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start = No_Element then\n+      if Checks and then Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n       end if;\n \n-      if Start.Container /= Container'Unrestricted_Access then\n+      if Checks and then Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong set\";\n       end if;\n@@ -1498,7 +1405,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n                     Container => Container'Unrestricted_Access,\n                     Node      => Start.Node)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1540,7 +1447,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Last_Element (Container : Set) return Element_Type is\n    begin\n-      if Container.Last = 0 then\n+      if Checks and then Container.Last = 0 then\n          raise Constraint_Error with \"set is empty\";\n       end if;\n \n@@ -1575,10 +1482,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Target.Assign (Source);\n       Source.Clear;\n@@ -1621,7 +1525,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong set\";\n       end if;\n@@ -1678,14 +1582,29 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong set\";\n       end if;\n \n       return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1695,7 +1614,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n@@ -1704,24 +1623,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       declare\n          S : Set renames Position.Container.all;\n-         B : Natural renames S.Busy;\n-         L : Natural renames S.Lock;\n-\n+         Lock : With_Lock (S.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (S.Nodes (Position.Node).Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (S.Nodes (Position.Node).Element);\n       end;\n    end Query_Element;\n \n@@ -1781,15 +1685,12 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n \n    begin\n-      if Node = 0 then\n+      if Checks and then Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       Container.Nodes (Node).Element := New_Item;\n    end Replace;\n@@ -1841,12 +1742,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Inserted  : Boolean;\n       Compare   : Boolean;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      B : Natural renames Container.Busy;\n-      L : Natural renames Container.Lock;\n-\n    --  Start of processing for Replace_Element\n \n    begin\n@@ -1864,33 +1759,20 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       --  Determine whether Item is equivalent to element on the specified\n       --  node.\n \n+      declare\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n          Compare := (if Item < Node.Element then False\n                      elsif Node.Element < Item then False\n                      else True);\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n       end;\n \n       if Compare then\n \n          --  Item is equivalent to the node's element, so we will not have to\n          --  move the node.\n \n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Container.TC);\n \n          Node.Element := Item;\n          return;\n@@ -1908,25 +1790,15 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Hint := Element_Keys.Ceiling (Container, Item);\n \n       if Hint /= 0 then  -- Item <= Nodes (Hint).Element\n+         declare\n+            Lock : With_Lock (Container.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Compare := Item < Nodes (Hint).Element;\n-\n-            L := L - 1;\n-            B := B - 1;\n-\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n          end;\n \n          --  Item is equivalent to Nodes (Hint).Element\n \n-         if not Compare then\n+         if Checks and then not Compare then\n \n             --  Ceiling returns an element that is equivalent or greater than\n             --  Item. If Item is \"not less than\" the element, then by\n@@ -1958,10 +1830,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          --  because it would only be placed in the exact same position.\n \n          if Hint = Index then\n-            if Container.Lock > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with elements (set is locked)\";\n-            end if;\n+            TE_Check (Container.TC);\n \n             Node.Element := Item;\n             return;\n@@ -1993,12 +1862,13 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = 0 then\n+      if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong set\";\n       end if;\n@@ -2033,22 +1903,12 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       end Process_Node;\n \n       S : Set renames Container'Unrestricted_Access.all;\n-      B : Natural renames S.Busy;\n+      Busy : With_Busy (S.TC'Unrestricted_Access);\n \n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (S);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Reverse_Iterate (S);\n    end Reverse_Iterate;\n \n    -----------"}, {"sha": "a12a7988a93a20a08b4e24fda353f897bea2faac", "filename": "gcc/ada/a-cborse.ads", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cborse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -33,6 +33,7 @@\n \n with Ada.Iterator_Interfaces;\n \n+private with Ada.Containers.Helpers;\n private with Ada.Containers.Red_Black_Trees;\n private with Ada.Streams;\n private with Ada.Finalization;\n@@ -284,17 +285,16 @@ package Ada.Containers.Bounded_Ordered_Sets is\n \n       use Ada.Streams;\n \n+      package Impl is new Helpers.Generic_Implementation;\n+\n       type Reference_Control_Type is\n-        new Ada.Finalization.Controlled with\n+        new Impl.Reference_Control_Type with\n       record\n          Container : Set_Access;\n          Pos       : Cursor;\n          Old_Key   : Key_Access;\n       end record;\n \n-      overriding procedure Adjust (Control : in out Reference_Control_Type);\n-      pragma Inline (Adjust);\n-\n       overriding procedure Finalize (Control : in out Reference_Control_Type);\n       pragma Inline (Finalize);\n \n@@ -335,7 +335,7 @@ private\n    type Set (Capacity : Count_Type) is\n      new Tree_Types.Tree_Type (Capacity) with null record;\n \n-   use Tree_Types;\n+   use Tree_Types, Tree_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -377,15 +377,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is new Controlled with record\n-      Container : Set_Access;\n-   end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -409,6 +402,25 @@ private\n \n    for Constant_Reference_Type'Write use Write;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Set : constant Set := Set'(Tree_Type with Capacity => 0);\n \n    No_Element : constant Cursor := Cursor'(null, 0);\n@@ -418,7 +430,8 @@ private\n    record\n       Container : Set_Access;\n       Node      : Count_Type;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "6cd1ae7e400ac841b451d77cd322b6228ac74ba7", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 233, "deletions": 513, "changes": 746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -35,6 +35,10 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -69,64 +73,32 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      BL : Natural renames Left'Unrestricted_Access.Busy;\n-      LL : Natural renames Left'Unrestricted_Access.Lock;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-      BR : Natural renames Right'Unrestricted_Access.Busy;\n-      LR : Natural renames Right'Unrestricted_Access.Lock;\n+      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n       L      : Node_Access;\n       R      : Node_Access;\n-      Result : Boolean;\n \n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       if Left.Length /= Right.Length then\n          return False;\n       end if;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n       L := Left.First;\n       R := Right.First;\n-      Result := True;\n       for J in 1 .. Left.Length loop\n          if L.Element /= R.Element then\n-            Result := False;\n-            exit;\n+            return False;\n          end if;\n \n          L := L.Next;\n          R := R.Next;\n       end loop;\n \n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n+      return True;\n    end \"=\";\n \n    ------------\n@@ -140,8 +112,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       if Src = null then\n          pragma Assert (Container.Last = null);\n          pragma Assert (Container.Length = 0);\n-         pragma Assert (Container.Busy = 0);\n-         pragma Assert (Container.Lock = 0);\n+         pragma Assert (Container.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n \n@@ -152,8 +123,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Container.First := null;\n       Container.Last := null;\n       Container.Length := 0;\n-      Container.Busy := 0;\n-      Container.Lock := 0;\n+      Zero_Counts (Container.TC);\n \n       Container.First := new Node_Type'(Src.Element, null, null);\n       Container.Last := Container.First;\n@@ -171,20 +141,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end loop;\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : List renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Append --\n    ------------\n@@ -230,18 +186,14 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       if Container.Length = 0 then\n          pragma Assert (Container.First = null);\n          pragma Assert (Container.Last = null);\n-         pragma Assert (Container.Busy = 0);\n-         pragma Assert (Container.Lock = 0);\n+         pragma Assert (Container.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n \n       pragma Assert (Container.First.Prev = null);\n       pragma Assert (Container.Last.Next = null);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       while Container.Length > 1 loop\n          X := Container.First;\n@@ -276,28 +228,27 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n \n       declare\n-         C : List renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -337,12 +288,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -360,10 +312,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       for Index in 1 .. Count loop\n          X := Position.Node;\n@@ -412,10 +361,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       for J in 1 .. Count loop\n          X := Container.First;\n@@ -450,10 +396,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       for J in 1 .. Count loop\n          X := Container.Last;\n@@ -474,14 +417,14 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Element\");\n-\n-         return Position.Node.Element;\n       end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+\n+      return Position.Node.Element;\n    end Element;\n \n    --------------\n@@ -491,27 +434,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : List renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.TC);\n       end if;\n    end Finalize;\n \n@@ -531,57 +454,30 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          Node := Container.First;\n \n       else\n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n-         else\n-            pragma Assert (Vet (Position), \"bad cursor in Find\");\n          end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Node_Access;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         pragma Warnings (Off);\n-         --  Deal with junk infinite loop warning from below loop\n-\n-         Result := null;\n          while Node /= null loop\n             if Node.Element = Item then\n-               Result := Node;\n-               exit;\n-            else\n-               Node := Node.Next;\n+               return Cursor'(Container'Unrestricted_Access, Node);\n             end if;\n-         end loop;\n \n-         pragma Warnings (On);\n-         --  End of section dealing with junk infinite loop warning\n-\n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = null then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n+            Node := Node.Next;\n+         end loop;\n \n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return No_Element;\n       end;\n    end Find;\n \n@@ -626,11 +522,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function First_Element (Container : List) return Element_Type is\n    begin\n-      if Container.First = null then\n+      if Checks and then Container.First = null then\n          raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.First.Element;\n       end if;\n+\n+      return Container.First.Element;\n    end First_Element;\n \n    ----------\n@@ -673,40 +569,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       ---------------\n \n       function Is_Sorted (Container : List) return Boolean is\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Node   : Node_Access;\n-         Result : Boolean;\n-\n-      begin\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n-         B := B + 1;\n-         L := L + 1;\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n \n+         Node   : Node_Access;\n+      begin\n          Node := Container.First;\n-         Result := True;\n          for Idx in 2 .. Container.Length loop\n             if Node.Next.Element < Node.Element then\n-               Result := False;\n-               exit;\n+               return False;\n             end if;\n \n             Node := Node.Next;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         return Result;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return True;\n       end Is_Sorted;\n \n       -----------\n@@ -730,44 +609,29 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             return;\n          end if;\n \n-         if Target'Address = Source'Address then\n+         if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n          end if;\n \n-         if Target.Length > Count_Type'Last - Source.Length then\n+         if Checks and then Target.Length > Count_Type'Last - Source.Length\n+         then\n             raise Constraint_Error with \"new length exceeds maximum\";\n          end if;\n \n-         if Target.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Target (list is busy)\";\n-         end if;\n-\n-         if Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Source (list is busy)\";\n-         end if;\n+         TC_Check (Target.TC);\n+         TC_Check (Source.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            TB : Natural renames Target.Busy;\n-            TL : Natural renames Target.Lock;\n-\n-            SB : Natural renames Source.Busy;\n-            SL : Natural renames Source.Lock;\n+            Lock_Target : With_Lock (Target.TC'Unchecked_Access);\n+            Lock_Source : With_Lock (Source.TC'Unchecked_Access);\n \n             LI, RI, RJ : Node_Access;\n \n          begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n-\n-            SB := SB + 1;\n-            SL := SL + 1;\n-\n             LI := Target.First;\n             RI := Source.First;\n             while RI /= null loop\n@@ -791,22 +655,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n                   LI := LI.Next;\n                end if;\n             end loop;\n-\n-            TB := TB - 1;\n-            TL := TL - 1;\n-\n-            SB := SB - 1;\n-            SL := SL - 1;\n-\n-         exception\n-            when others =>\n-               TB := TB - 1;\n-               TL := TL - 1;\n-\n-               SB := SB - 1;\n-               SL := SL - 1;\n-\n-               raise;\n          end;\n       end Merge;\n \n@@ -889,32 +737,15 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          pragma Assert (Container.First.Prev = null);\n          pragma Assert (Container.Last.Next = null);\n \n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (list is busy)\";\n-         end if;\n+         TC_Check (Container.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n+            Lock : With_Lock (Container.TC'Unchecked_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Sort (Front => null, Back => null);\n-\n-            B := B - 1;\n-            L := L - 1;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-               raise;\n          end;\n \n          pragma Assert (Container.First.Prev = null);\n@@ -959,37 +790,36 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Before cursor designates wrong list\";\n-         else\n-            pragma Assert (Vet (Before), \"bad cursor in Insert\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n          Position := Before;\n          return;\n+      end if;\n \n-      elsif Container.Length > Count_Type'Last - Count then\n+      if Checks and then Container.Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"new length exceeds maximum\";\n+      end if;\n \n-      elsif Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n+      TC_Check (Container.TC);\n \n-      else\n-         New_Node   := new Node_Type'(New_Item, null, null);\n-         First_Node := New_Node;\n-         Insert_Internal (Container, Before.Node, New_Node);\n+      New_Node   := new Node_Type'(New_Item, null, null);\n+      First_Node := New_Node;\n+      Insert_Internal (Container, Before.Node, New_Node);\n \n-         for J in 2 .. Count loop\n-            New_Node := new Node_Type'(New_Item, null, null);\n-            Insert_Internal (Container, Before.Node, New_Node);\n-         end loop;\n+      for J in 2 .. Count loop\n+         New_Node := new Node_Type'(New_Item, null, null);\n+         Insert_Internal (Container, Before.Node, New_Node);\n+      end loop;\n \n-         Position := Cursor'(Container'Unchecked_Access, First_Node);\n-      end if;\n+      Position := Cursor'(Container'Unchecked_Access, First_Node);\n    end Insert;\n \n    procedure Insert\n@@ -1015,38 +845,36 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Before cursor designates wrong list\";\n-         else\n-            pragma Assert (Vet (Before), \"bad cursor in Insert\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n          Position := Before;\n          return;\n       end if;\n \n-      if Container.Length > Count_Type'Last - Count then\n+      if Checks and then Container.Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"new length exceeds maximum\";\n+      end if;\n \n-      elsif Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n+      TC_Check (Container.TC);\n \n-      else\n-         New_Node   := new Node_Type;\n-         First_Node := New_Node;\n-         Insert_Internal (Container, Before.Node, New_Node);\n+      New_Node   := new Node_Type;\n+      First_Node := New_Node;\n+      Insert_Internal (Container, Before.Node, New_Node);\n \n-         for J in 2 .. Count loop\n-            New_Node := new Node_Type;\n-            Insert_Internal (Container, Before.Node, New_Node);\n-         end loop;\n+      for J in 2 .. Count loop\n+         New_Node := new Node_Type;\n+         Insert_Internal (Container, Before.Node, New_Node);\n+      end loop;\n \n-         Position := Cursor'(Container'Unchecked_Access, First_Node);\n-      end if;\n+      Position := Cursor'(Container'Unchecked_Access, First_Node);\n    end Insert;\n \n    ---------------------\n@@ -1114,31 +942,19 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B    : Natural renames Container'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n       Node : Node_Access := Container.First;\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         while Node /= null loop\n-            Process (Cursor'(Container'Unrestricted_Access, Node));\n-            Node := Node.Next;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+         Node := Node.Next;\n+      end loop;\n    end Iterate;\n \n    function Iterate (Container : List)\n      return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -1155,15 +971,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n                                 Container => Container'Unrestricted_Access,\n                                 Node      => null)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n    function Iterate (Container : List; Start : Cursor)\n      return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1176,34 +990,34 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start = No_Element then\n+      if Checks and then Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n+      end if;\n \n-      elsif Start.Container /= Container'Unrestricted_Access then\n+      if Checks and then Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong list\";\n-\n-      else\n-         pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n-\n-         --  The value of the Node component influences the behavior of the\n-         --  First and Last selector functions of the iterator object. When\n-         --  the Node component is non-null (as is the case here), it means\n-         --  that this is a partial iteration, over a subset of the complete\n-         --  sequence of items. The iterator object was constructed with\n-         --  a start expression, indicating the position from which the\n-         --  iteration begins. Note that the start position has the same value\n-         --  irrespective of whether this is a forward or reverse iteration.\n-\n-         return It : constant Iterator :=\n-                       Iterator'(Limited_Controlled with\n-                                   Container => Container'Unrestricted_Access,\n-                                 Node      => Start.Node)\n-         do\n-            B := B + 1;\n-         end return;\n       end if;\n+\n+      pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this is a\n+      --  partial iteration, over a subset of the complete sequence of items.\n+      --  The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n+      return It : constant Iterator :=\n+                    Iterator'(Limited_Controlled with\n+                                Container => Container'Unrestricted_Access,\n+                              Node      => Start.Node)\n+      do\n+         Busy (Container.TC'Unrestricted_Access.all);\n+      end return;\n    end Iterate;\n \n    ----------\n@@ -1247,11 +1061,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Last_Element (Container : List) return Element_Type is\n    begin\n-      if Container.Last = null then\n+      if Checks and then Container.Last = null then\n          raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Last.Element;\n       end if;\n+\n+      return Container.Last.Element;\n    end Last_Element;\n \n    ------------\n@@ -1274,23 +1088,20 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Target'Address = Source'Address then\n          return;\n+      end if;\n \n-      elsif Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n+      TC_Check (Source.TC);\n \n-      else\n-         Clear (Target);\n+      Clear (Target);\n \n-         Target.First := Source.First;\n-         Source.First := null;\n+      Target.First := Source.First;\n+      Source.First := null;\n \n-         Target.Last := Source.Last;\n-         Source.Last := null;\n+      Target.Last := Source.Last;\n+      Source.Last := null;\n \n-         Target.Length := Source.Length;\n-         Source.Length := 0;\n-      end if;\n+      Target.Length := Source.Length;\n+      Source.Length := 0;\n    end Move;\n \n    ----------\n@@ -1329,12 +1140,14 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong list\";\n-      else\n-         return Next (Position);\n       end if;\n+\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1386,12 +1199,14 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong list\";\n-      else\n-         return Previous (Position);\n       end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    ----------------------\n@@ -1401,15 +1216,10 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    function Pseudo_Reference\n      (Container : aliased List'Class) return Reference_Control_Type\n    is\n-      C : constant List_Access := Container'Unrestricted_Access;\n-      B : Natural renames C.Busy;\n-      L : Natural renames C.Lock;\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n    begin\n-      return R : constant Reference_Control_Type :=\n-        (Controlled with C)\n-      do\n-         B := B + 1;\n-         L := L + 1;\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n       end return;\n    end Pseudo_Reference;\n \n@@ -1422,33 +1232,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n       declare\n-         C : List renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-\n+         Lock : With_Lock (Position.Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Position.Node.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (Position.Node.Element);\n       end;\n    end Query_Element;\n \n@@ -1537,30 +1331,28 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unchecked_Access then\n+      if Checks and then Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n \n-         declare\n-            C : List renames Position.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            return R : constant Reference_Type :=\n-                         (Element => Position.Node.Element'Access,\n-                          Control => (Controlled with Position.Container))\n-            do\n-               B := B + 1;\n-               L := L + 1;\n-            end return;\n-         end;\n-      end if;\n+      declare\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         return R : constant Reference_Type :=\n+           (Element => Position.Node.Element'Access,\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Reference;\n \n    ---------------------\n@@ -1573,22 +1365,20 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unchecked_Access then\n+      if Checks and then Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      elsif Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is locked)\";\n+      TE_Check (Container.TC);\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-         Position.Node.Element := New_Item;\n-      end if;\n+      Position.Node.Element := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -1649,10 +1439,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       pragma Assert (Container.First.Prev = null);\n       pragma Assert (Container.Last.Next = null);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       Container.First := J;\n       Container.Last := I;\n@@ -1694,51 +1481,30 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          Node := Container.Last;\n \n       else\n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n-         else\n-            pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n          end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Node_Access;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := null;\n          while Node /= null loop\n             if Node.Element = Item then\n-               Result := Node;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Node);\n             end if;\n \n             Node := Node.Prev;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = null then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-            raise;\n+         return No_Element;\n       end;\n    end Reverse_Find;\n \n@@ -1750,26 +1516,14 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      C : List renames Container'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n       Node : Node_Access := Container.Last;\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         while Node /= null loop\n-            Process (Cursor'(Container'Unrestricted_Access, Node));\n-            Node := Node.Prev;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+         Node := Node.Prev;\n+      end loop;\n    end Reverse_Iterate;\n \n    ------------\n@@ -1783,31 +1537,26 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    is\n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n-         else\n-            pragma Assert (Vet (Before), \"bad cursor in Splice\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Splice\");\n       end if;\n \n       if Target'Address = Source'Address or else Source.Length = 0 then\n          return;\n+      end if;\n \n-      elsif Target.Length > Count_Type'Last - Source.Length then\n+      if Checks and then Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n+      end if;\n \n-      elsif Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-\n-      elsif Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n-      else\n-         Splice_Internal (Target, Before.Node, Source);\n-      end if;\n+      Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n    procedure Splice\n@@ -1817,19 +1566,20 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    is\n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Container'Unchecked_Access then\n+         if Checks and then Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n-         else\n-            pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -1844,10 +1594,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       pragma Assert (Container.Length >= 2);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Before.Node = null then\n          pragma Assert (Position.Node /= Container.Last);\n@@ -1925,40 +1672,34 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       if Before.Container /= null then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n-         else\n-            pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Source'Unrestricted_Access then\n+      if Checks and then Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n-\n-         if Target.Length = Count_Type'Last then\n-            raise Constraint_Error with \"Target is full\";\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-         elsif Target.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Target (list is busy)\";\n+      if Checks and then Target.Length = Count_Type'Last then\n+         raise Constraint_Error with \"Target is full\";\n+      end if;\n \n-         elsif Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Source (list is busy)\";\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n-         else\n-            Splice_Internal (Target, Before.Node, Source, Position.Node);\n-            Position.Container := Target'Unchecked_Access;\n-         end if;\n-      end if;\n+      Splice_Internal (Target, Before.Node, Source, Position.Node);\n+      Position.Container := Target'Unchecked_Access;\n    end Splice;\n \n    ---------------------\n@@ -2114,30 +1855,27 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null then\n+      if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if J.Node = null then\n+      if Checks and then J.Node = null then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unchecked_Access then\n+      if Checks and then I.Container /= Container'Unchecked_Access then\n          raise Program_Error with \"I cursor designates wrong container\";\n       end if;\n \n-      if J.Container /= Container'Unchecked_Access then\n+      if Checks and then J.Container /= Container'Unchecked_Access then\n          raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap\");\n@@ -2163,30 +1901,27 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null then\n+      if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if J.Node = null then\n+      if Checks and then J.Node = null then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n+      if Checks and then I.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"I cursor designates wrong container\";\n       end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n+      if Checks and then J.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n@@ -2227,37 +1962,22 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unchecked_Access then\n+      if Checks and then Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n-\n-         declare\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Process (Position.Node.Element);\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n \n-            L := L - 1;\n-            B := B - 1;\n-         end;\n-      end if;\n+      declare\n+         Lock : With_Lock (Container.TC'Unchecked_Access);\n+      begin\n+         Process (Position.Node.Element);\n+      end;\n    end Update_Element;\n \n    ---------"}, {"sha": "45abeb1559f3f44a69f1076512b0f517191bde5e", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -33,6 +33,7 @@\n \n with Ada.Iterator_Interfaces;\n \n+private with Ada.Containers.Helpers;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n@@ -248,6 +249,10 @@ private\n    pragma Inline (Next);\n    pragma Inline (Previous);\n \n+   use Ada.Containers.Helpers;\n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n@@ -263,11 +268,10 @@ private\n \n    type List is\n      new Controlled with record\n-        First  : Node_Access;\n-        Last   : Node_Access;\n+        First  : Node_Access := null;\n+        Last   : Node_Access := null;\n         Length : Count_Type := 0;\n-        Busy   : Natural := 0;\n-        Lock   : Natural := 0;\n+        TC     : aliased Tamper_Counts;\n      end record;\n \n    overriding procedure Adjust (Container : in out List);\n@@ -307,16 +311,8 @@ private\n \n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : List_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -374,13 +370,14 @@ private\n    --  container, and increments the Lock. Finalization of this object will\n    --  decrement the Lock.\n \n-   type Element_Access is access all Element_Type;\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n \n    function Get_Element_Access\n      (Position : Cursor) return not null Element_Access;\n    --  Returns a pointer to the element designated by Position.\n \n-   Empty_List : constant List := (Controlled with null, null, 0, 0, 0);\n+   Empty_List : constant List := (Controlled with others => <>);\n \n    No_Element : constant Cursor := Cursor'(null, null);\n \n@@ -389,7 +386,8 @@ private\n    record\n       Container : List_Access;\n       Node      : Node_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "43d0c1aece21a357d22a28cd4def38ba264f7e2b", "filename": "gcc/ada/a-chtgbk.adb", "status": "modified", "additions": 20, "deletions": 90, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbk.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,10 @@\n \n package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------------\n    -- Checked_Equivalent_Keys --\n    -----------------------------\n@@ -38,28 +42,9 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       Key  : Key_Type;\n       Node : Count_Type) return Boolean\n    is\n-      Result : Boolean;\n-\n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n-\n+      Lock : With_Lock (HT.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := Equivalent_Keys (Key, HT.Nodes (Node));\n-\n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return Equivalent_Keys (Key, HT.Nodes (Node));\n    end Checked_Equivalent_Keys;\n \n    -------------------\n@@ -70,28 +55,9 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n      (HT  : aliased in out Hash_Table_Type'Class;\n       Key : Key_Type) return Hash_Type\n    is\n-      Result : Hash_Type;\n-\n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n-\n+      Lock : With_Lock (HT.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n-\n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n    end Checked_Index;\n \n    --------------------------\n@@ -115,10 +81,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       Indx := Checked_Index (HT, Key);\n       X := HT.Buckets (Indx);\n@@ -128,10 +91,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       end if;\n \n       if Checked_Equivalent_Keys (HT, Key, X) then\n-         if HT.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (container is busy)\";\n-         end if;\n+         TC_Check (HT.TC);\n          HT.Buckets (Indx) := Next (HT.Nodes (X));\n          HT.Length := HT.Length - 1;\n          return;\n@@ -146,10 +106,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          end if;\n \n          if Checked_Equivalent_Keys (HT, Key, X) then\n-            if HT.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (container is busy)\";\n-            end if;\n+            TC_Check (HT.TC);\n             Set_Next (HT.Nodes (Prev), Next => Next (HT.Nodes (X)));\n             HT.Length := HT.Length - 1;\n             return;\n@@ -204,16 +161,13 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       Indx := Checked_Index (HT, Key);\n       Node := HT.Buckets (Indx);\n \n       if Node = 0 then\n-         if HT.Length = HT.Capacity then\n+         if Checks and then HT.Length = HT.Capacity then\n             raise Capacity_Error with \"no more capacity for insertion\";\n          end if;\n \n@@ -239,7 +193,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          exit when Node = 0;\n       end loop;\n \n-      if HT.Length = HT.Capacity then\n+      if Checks and then HT.Length = HT.Capacity then\n          raise Capacity_Error with \"no more capacity for insertion\";\n       end if;\n \n@@ -285,24 +239,9 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       --  the computation of New_Index until after the tampering check. ???\n \n       declare\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n          Old_Indx := HT.Buckets'First + Hash (NN (Node)) mod HT.Buckets'Length;\n-\n-         B := B - 1;\n-         L := L - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n       end;\n \n       --  Replace_Element is allowed to change a node's key to Key\n@@ -311,10 +250,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       --  hash table as this one, a key is mapped to exactly one node.)\n \n       if Checked_Equivalent_Keys (HT, Key, Node) then\n-         if HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (container is locked)\";\n-         end if;\n+         TE_Check (HT.TC);\n \n          --  The new Key value is mapped to this same Node, so Node\n          --  stays in the same bucket.\n@@ -330,7 +266,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n \n       N := New_Bucket;\n       while N /= 0 loop\n-         if Checked_Equivalent_Keys (HT, Key, N) then\n+         if Checks and then Checked_Equivalent_Keys (HT, Key, N) then\n             pragma Assert (N /= Node);\n             raise Program_Error with\n               \"attempt to replace existing element\";\n@@ -350,21 +286,15 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          --  The node is already in the bucket implied by Key. In this case\n          --  we merely change its value without moving it.\n \n-         if HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (container is locked)\";\n-         end if;\n+         TE_Check (HT.TC);\n \n          Assign (NN (Node), Key);\n          return;\n       end if;\n \n       --  The node is a bucket different from the bucket implied by Key\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       --  Do the assignment first, before moving the node, so that if Assign\n       --  propagates an exception, then the hash table will not have been"}, {"sha": "037a87ec499f744fad92d9c828e6186bb616092a", "filename": "gcc/ada/a-chtgbk.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbk.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,7 +34,7 @@ generic\n    with package HT_Types is\n      new Generic_Bounded_Hash_Table_Types (<>);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n \n    with function Next (Node : Node_Type) return Count_Type;\n "}, {"sha": "f4f7c1c237ed44aef3f61c00ba907b2a5b5a4fbe", "filename": "gcc/ada/a-chtgbo.adb", "status": "modified", "additions": 23, "deletions": 72, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,10 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -------------------\n    -- Checked_Index --\n    -------------------\n@@ -39,28 +43,9 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n      (Hash_Table : aliased in out Hash_Table_Type'Class;\n       Node       : Count_Type) return Hash_Type\n    is\n-      Result : Hash_Type;\n-\n-      B : Natural renames Hash_Table.Busy;\n-      L : Natural renames Hash_Table.Lock;\n-\n+      Lock : With_Lock (Hash_Table.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := Index (Hash_Table, Hash_Table.Nodes (Node));\n-\n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return Index (Hash_Table, Hash_Table.Nodes (Node));\n    end Checked_Index;\n \n    -----------\n@@ -69,10 +54,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n \n    procedure Clear (HT : in out Hash_Table_Type'Class) is\n    begin\n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       HT.Length := 0;\n       --  HT.Busy := 0;\n@@ -96,7 +78,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n    begin\n       Prev := HT.Buckets (Indx);\n \n-      if Prev = 0 then\n+      if Checks and then Prev = 0 then\n          raise Program_Error with\n            \"attempt to delete node from empty hash bucket\";\n       end if;\n@@ -107,15 +89,15 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n          return;\n       end if;\n \n-      if HT.Length = 1 then\n+      if Checks and then HT.Length = 1 then\n          raise Program_Error with\n            \"attempt to delete node not in its proper hash bucket\";\n       end if;\n \n       loop\n          Curr := Next (HT.Nodes (Prev));\n \n-         if Curr = 0 then\n+         if Checks and then Curr = 0 then\n             raise Program_Error with\n               \"attempt to delete node not in its proper hash bucket\";\n          end if;\n@@ -139,15 +121,15 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n       Curr : Count_Type;\n \n    begin\n-      if HT.Length = 0 then\n+      if Checks and then HT.Length = 0 then\n          raise Program_Error with\n            \"attempt to delete node from empty hashed container\";\n       end if;\n \n       Indx := Checked_Index (HT, X);\n       Prev := HT.Buckets (Indx);\n \n-      if Prev = 0 then\n+      if Checks and then Prev = 0 then\n          raise Program_Error with\n            \"attempt to delete node from empty hash bucket\";\n       end if;\n@@ -158,15 +140,15 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n          return;\n       end if;\n \n-      if HT.Length = 1 then\n+      if Checks and then HT.Length = 1 then\n          raise Program_Error with\n            \"attempt to delete node not in its proper hash bucket\";\n       end if;\n \n       loop\n          Curr := Next (HT.Nodes (Prev));\n \n-         if Curr = 0 then\n+         if Checks and then Curr = 0 then\n             raise Program_Error with\n               \"attempt to delete node not in its proper hash bucket\";\n          end if;\n@@ -363,13 +345,11 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n    function Generic_Equal\n      (L, R : Hash_Table_Type'Class) return Boolean\n    is\n-      BL : Natural renames L'Unrestricted_Access.Busy;\n-      LL : Natural renames L'Unrestricted_Access.Lock;\n-\n-      BR : Natural renames R'Unrestricted_Access.Busy;\n-      LR : Natural renames R'Unrestricted_Access.Lock;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-      Result : Boolean;\n+      Lock_L : With_Lock (L.TC'Unrestricted_Access);\n+      Lock_R : With_Lock (R.TC'Unrestricted_Access);\n \n       L_Index : Hash_Type;\n       L_Node  : Count_Type;\n@@ -398,23 +378,13 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n          L_Index := L_Index + 1;\n       end loop;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n       --  For each node of hash table L, search for an equivalent node in hash\n       --  table R.\n \n       N := L.Length;\n       loop\n          if not Find (HT => R, Key => L.Nodes (L_Node)) then\n-            Result := False;\n-            exit;\n+            return False;\n          end if;\n \n          N := N - 1;\n@@ -426,8 +396,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n             --  We have exhausted the nodes in this bucket\n \n             if N = 0 then\n-               Result := True;\n-               exit;\n+               return True;\n             end if;\n \n             --  Find the next bucket\n@@ -439,24 +408,6 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n             end loop;\n          end if;\n       end loop;\n-\n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n    end Generic_Equal;\n \n    -----------------------\n@@ -495,15 +446,15 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n \n       Count_Type'Base'Read (Stream, N);\n \n-      if N < 0 then\n+      if Checks and then N < 0 then\n          raise Program_Error with \"stream appears to be corrupt\";\n       end if;\n \n       if N = 0 then\n          return;\n       end if;\n \n-      if N > HT.Capacity then\n+      if Checks and then N > HT.Capacity then\n          raise Capacity_Error with \"too many elements in stream\";\n       end if;\n "}, {"sha": "892bdaaf1dffc163ed98ba56bb18ed2cb2c65e92", "filename": "gcc/ada/a-chtgbo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,7 @@ generic\n    with package HT_Types is\n      new Generic_Bounded_Hash_Table_Types (<>);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n \n    with function Hash_Node (Node : Node_Type) return Hash_Type;\n "}, {"sha": "cab0c09bc355b982369b6b22723784d5d2625bd4", "filename": "gcc/ada/a-chtgke.adb", "status": "modified", "additions": 20, "deletions": 90, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgke.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgke.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,10 @@\n \n package body Ada.Containers.Hash_Tables.Generic_Keys is\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------------\n    -- Checked_Equivalent_Keys --\n    -----------------------------\n@@ -38,28 +42,9 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       Key  : Key_Type;\n       Node : Node_Access) return Boolean\n    is\n-      Result : Boolean;\n-\n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n-\n+      Lock : With_Lock (HT.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := Equivalent_Keys (Key, Node);\n-\n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return Equivalent_Keys (Key, Node);\n    end Checked_Equivalent_Keys;\n \n    -------------------\n@@ -70,28 +55,9 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n      (HT  : aliased in out Hash_Table_Type;\n       Key : Key_Type) return Hash_Type\n    is\n-      Result : Hash_Type;\n-\n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n-\n+      Lock : With_Lock (HT.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := Hash (Key) mod HT.Buckets'Length;\n-\n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return Hash (Key) mod HT.Buckets'Length;\n    end Checked_Index;\n \n    --------------------------\n@@ -115,10 +81,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       Indx := Checked_Index (HT, Key);\n       X := HT.Buckets (Indx);\n@@ -128,10 +91,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       end if;\n \n       if Checked_Equivalent_Keys (HT, Key, X) then\n-         if HT.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (container is busy)\";\n-         end if;\n+         TC_Check (HT.TC);\n          HT.Buckets (Indx) := Next (X);\n          HT.Length := HT.Length - 1;\n          return;\n@@ -146,10 +106,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          end if;\n \n          if Checked_Equivalent_Keys (HT, Key, X) then\n-            if HT.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (container is busy)\";\n-            end if;\n+            TC_Check (HT.TC);\n             Set_Next (Node => Prev, Next => Next (X));\n             HT.Length := HT.Length - 1;\n             return;\n@@ -202,16 +159,13 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       Indx := Checked_Index (HT, Key);\n       Node := HT.Buckets (Indx);\n \n       if Node = null then\n-         if HT.Length = Count_Type'Last then\n+         if Checks and then HT.Length = Count_Type'Last then\n             raise Constraint_Error;\n          end if;\n \n@@ -235,7 +189,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          exit when Node = null;\n       end loop;\n \n-      if HT.Length = Count_Type'Last then\n+      if Checks and then HT.Length = Count_Type'Last then\n          raise Constraint_Error;\n       end if;\n \n@@ -269,31 +223,13 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n          Old_Indx := Hash (Node) mod HT.Buckets'Length;\n-\n-         B := B - 1;\n-         L := L - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n       end;\n \n       if Checked_Equivalent_Keys (HT, Key, Node) then\n-         if HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (container is locked)\";\n-         end if;\n+         TE_Check (HT.TC);\n \n          --  We can change a node's key to Key (that's what Assign is for), but\n          --  only if Key is not already in the hash table. (In a unique-key\n@@ -312,7 +248,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n \n       N := New_Bucket;\n       while N /= null loop\n-         if Checked_Equivalent_Keys (HT, Key, N) then\n+         if Checks and then Checked_Equivalent_Keys (HT, Key, N) then\n             pragma Assert (N /= Node);\n             raise Program_Error with\n               \"attempt to replace existing element\";\n@@ -332,21 +268,15 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          --  The node is already in the bucket implied by Key. In this case\n          --  we merely change its value without moving it.\n \n-         if HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (container is locked)\";\n-         end if;\n+         TE_Check (HT.TC);\n \n          Assign (Node, Key);\n          return;\n       end if;\n \n       --  The node is a bucket different from the bucket implied by Key\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       --  Do the assignment first, before moving the node, so that if Assign\n       --  propagates an exception, then the hash table will not have been"}, {"sha": "00b313845874925fd2766ffa2508da3d9c757628", "filename": "gcc/ada/a-chtgke.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgke.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgke.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,7 +34,7 @@ generic\n    with package HT_Types is\n      new Generic_Hash_Table_Types (<>);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n \n    with function Next (Node : Node_Access) return Node_Access;\n "}, {"sha": "87a2e1eca83bb827b730360cfe180f5845c6c61b", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 23, "deletions": 78, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,10 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    type Buckets_Allocation is access all Buckets_Type;\n    --  Used for allocation and deallocation (see New_Buckets and Free_Buckets).\n    --  This is necessary because Buckets_Access has an empty storage pool.\n@@ -130,28 +134,9 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Buckets    : Buckets_Type;\n       Node       : Node_Access) return Hash_Type\n    is\n-      Result : Hash_Type;\n-\n-      B : Natural renames Hash_Table.Busy;\n-      L : Natural renames Hash_Table.Lock;\n-\n+      Lock : With_Lock (Hash_Table.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := Index (Buckets, Node);\n-\n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return Index (Buckets, Node);\n    end Checked_Index;\n \n    function Checked_Index\n@@ -171,10 +156,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Node  : Node_Access;\n \n    begin\n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       while HT.Length > 0 loop\n          while HT.Buckets (Index) = null loop\n@@ -217,15 +199,15 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          return;\n       end if;\n \n-      if HT.Length = 1 then\n+      if Checks and then HT.Length = 1 then\n          raise Program_Error with\n            \"attempt to delete node not in its proper hash bucket\";\n       end if;\n \n       loop\n          Curr := Next (Prev);\n \n-         if Curr = null then\n+         if Checks and then Curr = null then\n             raise Program_Error with\n               \"attempt to delete node not in its proper hash bucket\";\n          end if;\n@@ -256,15 +238,15 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Curr : Node_Access;\n \n    begin\n-      if HT.Length = 0 then\n+      if Checks and then HT.Length = 0 then\n          raise Program_Error with\n            \"attempt to delete node from empty hashed container\";\n       end if;\n \n       Indx := Checked_Index (HT, X);\n       Prev := HT.Buckets (Indx);\n \n-      if Prev = null then\n+      if Checks and then Prev = null then\n          raise Program_Error with\n            \"attempt to delete node from empty hash bucket\";\n       end if;\n@@ -275,15 +257,15 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          return;\n       end if;\n \n-      if HT.Length = 1 then\n+      if Checks and then HT.Length = 1 then\n          raise Program_Error with\n            \"attempt to delete node not in its proper hash bucket\";\n       end if;\n \n       loop\n          Curr := Next (Prev);\n \n-         if Curr = null then\n+         if Checks and then Curr = null then\n             raise Program_Error with\n               \"attempt to delete node not in its proper hash bucket\";\n          end if;\n@@ -375,13 +357,11 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    function Generic_Equal\n      (L, R : Hash_Table_Type) return Boolean\n    is\n-      BL : Natural renames L'Unrestricted_Access.Busy;\n-      LL : Natural renames L'Unrestricted_Access.Lock;\n-\n-      BR : Natural renames R'Unrestricted_Access.Busy;\n-      LR : Natural renames R'Unrestricted_Access.Lock;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-      Result : Boolean;\n+      Lock_L : With_Lock (L.TC'Unrestricted_Access);\n+      Lock_R : With_Lock (R.TC'Unrestricted_Access);\n \n       L_Index : Hash_Type;\n       L_Node  : Node_Access;\n@@ -410,23 +390,13 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          L_Index := L_Index + 1;\n       end loop;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n       --  For each node of hash table L, search for an equivalent node in hash\n       --  table R.\n \n       N := L.Length;\n       loop\n          if not Find (HT => R, Key => L_Node) then\n-            Result := False;\n-            exit;\n+            return False;\n          end if;\n \n          N := N - 1;\n@@ -437,8 +407,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n             --  We have exhausted the nodes in this bucket\n \n             if N = 0 then\n-               Result := True;\n-               exit;\n+               return True;\n             end if;\n \n             --  Find the next bucket\n@@ -450,24 +419,6 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n             end loop;\n          end if;\n       end loop;\n-\n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n    end Generic_Equal;\n \n    -----------------------\n@@ -507,7 +458,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n       Count_Type'Base'Read (Stream, N);\n \n-      if N < 0 then\n+      if Checks and then N < 0 then\n          raise Program_Error with \"stream appears to be corrupt\";\n       end if;\n \n@@ -600,10 +551,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Clear (Target);\n \n@@ -745,10 +693,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          end if;\n       end if;\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       Rehash : declare\n          Dst_Buckets : Buckets_Access := New_Buckets (Length => NN);"}, {"sha": "4a7fbd6c7438f241840cbd40b407503bbd18fcfe", "filename": "gcc/ada/a-chtgop.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-chtgop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,7 +37,7 @@ generic\n    with package HT_Types is\n      new Generic_Hash_Table_Types (<>);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n \n    with function Hash_Node (Node : Node_Access) return Hash_Type;\n "}, {"sha": "d7995e3e98a01f0145598b856d7769464d8fefe1", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 296, "deletions": 528, "changes": 824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,10 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n@@ -72,64 +76,32 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      BL : Natural renames Left'Unrestricted_Access.Busy;\n-      LL : Natural renames Left'Unrestricted_Access.Lock;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-      BR : Natural renames Right'Unrestricted_Access.Busy;\n-      LR : Natural renames Right'Unrestricted_Access.Lock;\n+      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n       L      : Node_Access;\n       R      : Node_Access;\n-      Result : Boolean;\n \n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       if Left.Length /= Right.Length then\n          return False;\n       end if;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n       L := Left.First;\n       R := Right.First;\n-      Result := True;\n       for J in 1 .. Left.Length loop\n          if L.Element.all /= R.Element.all then\n-            Result := False;\n-            exit;\n+            return False;\n          end if;\n \n          L := L.Next;\n          R := R.Next;\n       end loop;\n \n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n+      return True;\n    end \"=\";\n \n    ------------\n@@ -144,8 +116,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Src = null then\n          pragma Assert (Container.Last = null);\n          pragma Assert (Container.Length = 0);\n-         pragma Assert (Container.Busy = 0);\n-         pragma Assert (Container.Lock = 0);\n+         pragma Assert (Container.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n \n@@ -156,8 +127,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Container.First := null;\n       Container.Last := null;\n       Container.Length := 0;\n-      Container.Busy := 0;\n-      Container.Lock := 0;\n+      Zero_Counts (Container.TC);\n \n       declare\n          Element : Element_Access := new Element_Type'(Src.Element.all);\n@@ -193,20 +163,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end loop;\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : List renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Append --\n    ------------\n@@ -254,18 +210,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Container.Length = 0 then\n          pragma Assert (Container.First = null);\n          pragma Assert (Container.Last = null);\n-         pragma Assert (Container.Busy = 0);\n-         pragma Assert (Container.Lock = 0);\n+         pragma Assert (Container.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n \n       pragma Assert (Container.First.Prev = null);\n       pragma Assert (Container.Last.Next = null);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       while Container.Length > 1 loop\n          X := Container.First;\n@@ -298,32 +250,33 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      elsif Position.Node.Element = null then\n+      end if;\n+\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n \n-         declare\n-            C : List renames Position.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            return R : constant Constant_Reference_Type :=\n-                         (Element => Position.Node.Element.all'Access,\n-                          Control => (Controlled with Position.Container))\n-            do\n-               B := B + 1;\n-               L := L + 1;\n-            end return;\n-         end;\n-      end if;\n+      declare\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         return R : constant Constant_Reference_Type :=\n+           (Element => Position.Node.Element,\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Constant_Reference;\n \n    --------------\n@@ -361,17 +314,18 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -389,10 +343,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       for Index in 1 .. Count loop\n          X := Position.Node;\n@@ -435,27 +386,25 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Count >= Container.Length then\n          Clear (Container);\n          return;\n+      end if;\n \n-      elsif Count = 0 then\n+      if Count = 0 then\n          return;\n+      end if;\n \n-      elsif Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n+      TC_Check (Container.TC);\n \n-      else\n-         for J in 1 .. Count loop\n-            X := Container.First;\n-            pragma Assert (X.Next.Prev = Container.First);\n+      for J in 1 .. Count loop\n+         X := Container.First;\n+         pragma Assert (X.Next.Prev = Container.First);\n \n-            Container.First := X.Next;\n-            Container.First.Prev := null;\n+         Container.First := X.Next;\n+         Container.First.Prev := null;\n \n-            Container.Length := Container.Length - 1;\n+         Container.Length := Container.Length - 1;\n \n-            Free (X);\n-         end loop;\n-      end if;\n+         Free (X);\n+      end loop;\n    end Delete_First;\n \n    -----------------\n@@ -472,27 +421,25 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Count >= Container.Length then\n          Clear (Container);\n          return;\n+      end if;\n \n-      elsif Count = 0 then\n+      if Count = 0 then\n          return;\n+      end if;\n \n-      elsif Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n+      TC_Check (Container.TC);\n \n-      else\n-         for J in 1 .. Count loop\n-            X := Container.Last;\n-            pragma Assert (X.Prev.Next = Container.Last);\n+      for J in 1 .. Count loop\n+         X := Container.Last;\n+         pragma Assert (X.Prev.Next = Container.Last);\n \n-            Container.Last := X.Prev;\n-            Container.Last.Next := null;\n+         Container.Last := X.Prev;\n+         Container.Last.Next := null;\n \n-            Container.Length := Container.Length - 1;\n+         Container.Length := Container.Length - 1;\n \n-            Free (X);\n-         end loop;\n-      end if;\n+         Free (X);\n+      end loop;\n    end Delete_Last;\n \n    -------------\n@@ -501,19 +448,19 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Element\");\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n \n-         return Position.Node.Element.all;\n-      end if;\n+      return Position.Node.Element.all;\n    end Element;\n \n    --------------\n@@ -523,27 +470,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : List renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.TC);\n       end if;\n    end Finalize;\n \n@@ -563,56 +490,34 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          Node := Container.First;\n \n       else\n-         if Node.Element = null then\n+         if Checks and then Node.Element = null then\n             raise Program_Error;\n+         end if;\n \n-         elsif Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n-\n-         else\n-            pragma Assert (Vet (Position), \"bad cursor in Find\");\n          end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Node_Access;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := null;\n          while Node /= null loop\n             if Node.Element.all = Item then\n-               Result := Node;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Node);\n             end if;\n \n             Node := Node.Next;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = null then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n+         return No_Element;\n       end;\n    end Find;\n \n@@ -657,11 +562,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function First_Element (Container : List) return Element_Type is\n    begin\n-      if Container.First = null then\n+      if Checks and then Container.First = null then\n          raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.First.Element.all;\n       end if;\n+\n+      return Container.First.Element.all;\n    end First_Element;\n \n    ----------\n@@ -716,41 +621,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       ---------------\n \n       function Is_Sorted (Container : List) return Boolean is\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Node   : Node_Access;\n-         Result : Boolean;\n-\n-      begin\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n-         B := B + 1;\n-         L := L + 1;\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n \n+         Node   : Node_Access;\n+      begin\n          Node := Container.First;\n-         Result := True;\n          for J in 2 .. Container.Length loop\n             if Node.Next.Element.all < Node.Element.all then\n-               Result := False;\n-               exit;\n+               return False;\n             end if;\n \n             Node := Node.Next;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         return Result;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n+         return True;\n       end Is_Sorted;\n \n       -----------\n@@ -772,39 +659,28 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n          if Source.Is_Empty then\n             return;\n+         end if;\n \n-         elsif Target'Address = Source'Address then\n+         if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n+         end if;\n \n-         elsif Target.Length > Count_Type'Last - Source.Length then\n+         if Checks and then Target.Length > Count_Type'Last - Source.Length\n+         then\n             raise Constraint_Error with \"new length exceeds maximum\";\n-\n-         elsif Target.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Target (list is busy)\";\n-\n-         elsif Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Source (list is busy)\";\n          end if;\n \n-         declare\n-            TB : Natural renames Target.Busy;\n-            TL : Natural renames Target.Lock;\n+         TC_Check (Target.TC);\n+         TC_Check (Source.TC);\n \n-            SB : Natural renames Source.Busy;\n-            SL : Natural renames Source.Lock;\n+         declare\n+            Lock_Target : With_Lock (Target.TC'Unchecked_Access);\n+            Lock_Source : With_Lock (Source.TC'Unchecked_Access);\n \n             LI, RI, RJ : Node_Access;\n \n          begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n-\n-            SB := SB + 1;\n-            SL := SL + 1;\n-\n             LI := Target.First;\n             RI := Source.First;\n             while RI /= null loop\n@@ -830,22 +706,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n                   LI := LI.Next;\n                end if;\n             end loop;\n-\n-            TB := TB - 1;\n-            TL := TL - 1;\n-\n-            SB := SB - 1;\n-            SL := SL - 1;\n-\n-         exception\n-            when others =>\n-               TB := TB - 1;\n-               TL := TL - 1;\n-\n-               SB := SB - 1;\n-               SL := SL - 1;\n-\n-               raise;\n          end;\n       end Merge;\n \n@@ -929,33 +789,15 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          pragma Assert (Container.First.Prev = null);\n          pragma Assert (Container.Last.Next = null);\n \n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (list is busy)\";\n-         end if;\n+         TC_Check (Container.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n+            Lock : With_Lock (Container.TC'Unchecked_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Sort (Front => null, Back => null);\n-\n-            B := B - 1;\n-            L := L - 1;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-\n-               raise;\n          end;\n \n          pragma Assert (Container.First.Prev = null);\n@@ -964,6 +806,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    end Generic_Sorting;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -990,32 +842,32 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n-              \"attempt to tamper with cursors (list is busy)\";\n+              \"Before cursor designates wrong list\";\n+         end if;\n \n-         elsif Before.Node = null or else Before.Node.Element = null then\n+         if Checks and then\n+           (Before.Node = null or else Before.Node.Element = null)\n+         then\n             raise Program_Error with\n               \"Before cursor has no element\";\n-\n-         else\n-            pragma Assert (Vet (Before), \"bad cursor in Insert\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n          Position := Before;\n          return;\n       end if;\n \n-      if Container.Length > Count_Type'Last - Count then\n+      if Checks and then Container.Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       declare\n          --  The element allocator may need an accessibility check in the case\n@@ -1134,32 +986,20 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B    : Natural renames Container'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n       Node : Node_Access := Container.First;\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         while Node /= null loop\n-            Process (Cursor'(Container'Unrestricted_Access, Node));\n-            Node := Node.Next;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+         Node := Node.Next;\n+      end loop;\n    end Iterate;\n \n    function Iterate\n      (Container : List)\n       return List_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -1176,7 +1016,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n                                 Container => Container'Unrestricted_Access,\n                                 Node      => null)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1185,8 +1025,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Start     : Cursor)\n       return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1199,34 +1037,34 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start = No_Element then\n+      if Checks and then Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n+      end if;\n \n-      elsif Start.Container /= Container'Unrestricted_Access then\n+      if Checks and then Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong list\";\n-\n-      else\n-         pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n-\n-         --  The value of the Node component influences the behavior of the\n-         --  First and Last selector functions of the iterator object. When\n-         --  the Node component is non-null (as is the case here), it means\n-         --  that this is a partial iteration, over a subset of the complete\n-         --  sequence of items. The iterator object was constructed with\n-         --  a start expression, indicating the position from which the\n-         --  iteration begins. Note that the start position has the same value\n-         --  irrespective of whether this is a forward or reverse iteration.\n-\n-         return It : constant Iterator :=\n-                       Iterator'(Limited_Controlled with\n-                                   Container => Container'Unrestricted_Access,\n-                                 Node      => Start.Node)\n-         do\n-            B := B + 1;\n-         end return;\n       end if;\n+\n+      pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the\n+      --  First and Last selector functions of the iterator object. When\n+      --  the Node component is non-null (as is the case here), it means\n+      --  that this is a partial iteration, over a subset of the complete\n+      --  sequence of items. The iterator object was constructed with\n+      --  a start expression, indicating the position from which the\n+      --  iteration begins. Note that the start position has the same value\n+      --  irrespective of whether this is a forward or reverse iteration.\n+\n+      return It : constant Iterator :=\n+                    Iterator'(Limited_Controlled with\n+                                Container => Container'Unrestricted_Access,\n+                              Node      => Start.Node)\n+      do\n+         Busy (Container.TC'Unrestricted_Access.all);\n+      end return;\n    end Iterate;\n \n    ----------\n@@ -1270,11 +1108,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Last_Element (Container : List) return Element_Type is\n    begin\n-      if Container.Last = null then\n+      if Checks and then Container.Last = null then\n          raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Last.Element.all;\n       end if;\n+\n+      return Container.Last.Element.all;\n    end Last_Element;\n \n    ------------\n@@ -1294,23 +1132,20 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Target'Address = Source'Address then\n          return;\n+      end if;\n \n-      elsif Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n+      TC_Check (Source.TC);\n \n-      else\n-         Clear (Target);\n+      Clear (Target);\n \n-         Target.First := Source.First;\n-         Source.First := null;\n+      Target.First := Source.First;\n+      Source.First := null;\n \n-         Target.Last := Source.Last;\n-         Source.Last := null;\n+      Target.Last := Source.Last;\n+      Source.Last := null;\n \n-         Target.Length := Source.Length;\n-         Source.Length := 0;\n-      end if;\n+      Target.Length := Source.Length;\n+      Source.Length := 0;\n    end Move;\n \n    ----------\n@@ -1346,12 +1181,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong list\";\n-      else\n-         return Next (Position);\n       end if;\n+\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1400,14 +1237,30 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong list\";\n-      else\n-         return Previous (Position);\n       end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased List'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1417,39 +1270,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n-\n-         declare\n-            C : List renames Position.Container.all'Unrestricted_Access.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Process (Position.Node.Element.all);\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n-            L := L - 1;\n-            B := B - 1;\n-         end;\n-      end if;\n+      declare\n+         Lock : With_Lock (Position.Container.TC'Unrestricted_Access);\n+      begin\n+         Process (Position.Node.Element.all);\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1538,33 +1375,33 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      elsif Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n \n-         declare\n-            C : List renames Position.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            return R : constant Reference_Type :=\n-                         (Element => Position.Node.Element.all'Access,\n-                          Control => (Controlled with Position.Container))\n-            do\n-               B := B + 1;\n-               L := L + 1;\n-            end return;\n-         end;\n-      end if;\n+      declare\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         return R : constant Reference_Type :=\n+           (Element => Position.Node.Element,\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Reference;\n \n    ---------------------\n@@ -1577,38 +1414,37 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unchecked_Access then\n+      if Checks and then Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n+      end if;\n \n-      elsif Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is locked)\";\n+      TE_Check (Container.TC);\n \n-      elsif Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n+      end if;\n \n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-         declare\n-            --  The element allocator may need an accessibility check in the\n-            --  case the actual type is class-wide or has access discriminants\n-            --  (see RM 4.8(10.1) and AI12-0035).\n+      declare\n+         --  The element allocator may need an accessibility check in the\n+         --  case the actual type is class-wide or has access discriminants\n+         --  (see RM 4.8(10.1) and AI12-0035).\n \n-            pragma Unsuppress (Accessibility_Check);\n+         pragma Unsuppress (Accessibility_Check);\n \n-            X : Element_Access := Position.Node.Element;\n+         X : Element_Access := Position.Node.Element;\n \n-         begin\n-            Position.Node.Element := new Element_Type'(New_Item);\n-            Free (X);\n-         end;\n-      end if;\n+      begin\n+         Position.Node.Element := new Element_Type'(New_Item);\n+         Free (X);\n+      end;\n    end Replace_Element;\n \n    ----------------------\n@@ -1669,10 +1505,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       pragma Assert (Container.First.Prev = null);\n       pragma Assert (Container.Last.Next = null);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       Container.First := J;\n       Container.Last := I;\n@@ -1714,56 +1547,34 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          Node := Container.Last;\n \n       else\n-         if Node.Element = null then\n+         if Checks and then Node.Element = null then\n             raise Program_Error with \"Position cursor has no element\";\n+         end if;\n \n-         elsif Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n-\n-         else\n-            pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n          end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Node_Access;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := null;\n          while Node /= null loop\n             if Node.Element.all = Item then\n-               Result := Node;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Node);\n             end if;\n \n             Node := Node.Prev;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = null then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n+         return No_Element;\n       end;\n    end Reverse_Find;\n \n@@ -1775,26 +1586,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      C : List renames Container'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n       Node : Node_Access := Container.Last;\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         while Node /= null loop\n-            Process (Cursor'(Container'Unrestricted_Access, Node));\n-            Node := Node.Prev;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      while Node /= null loop\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+         Node := Node.Prev;\n+      end loop;\n    end Reverse_Iterate;\n \n    ------------\n@@ -1808,36 +1607,33 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    is\n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n+         end if;\n \n-         elsif Before.Node = null or else Before.Node.Element = null then\n+         if Checks and then\n+           (Before.Node = null or else Before.Node.Element = null)\n+         then\n             raise Program_Error with\n               \"Before cursor has no element\";\n-\n-         else\n-            pragma Assert (Vet (Before), \"bad cursor in Splice\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Splice\");\n       end if;\n \n       if Target'Address = Source'Address or else Source.Length = 0 then\n          return;\n+      end if;\n \n-      elsif Target.Length > Count_Type'Last - Source.Length then\n+      if Checks and then Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n+      end if;\n \n-      elsif Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-\n-      elsif Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n-      else\n-         Splice_Internal (Target, Before.Node, Source);\n-      end if;\n+      Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n    procedure Splice\n@@ -1847,28 +1643,31 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    is\n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Container'Unchecked_Access then\n+         if Checks and then Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n+         end if;\n \n-         elsif Before.Node = null or else Before.Node.Element = null then\n+         if Checks and then\n+           (Before.Node = null or else Before.Node.Element = null)\n+         then\n             raise Program_Error with\n               \"Before cursor has no element\";\n-\n-         else\n-            pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n          end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -1883,10 +1682,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       pragma Assert (Container.Length >= 2);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       if Before.Node = null then\n          pragma Assert (Position.Node /= Container.Last);\n@@ -1964,13 +1760,13 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       if Before.Container /= null then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n          end if;\n \n-         if Before.Node = null\n-           or else Before.Node.Element = null\n+         if Checks and then\n+           (Before.Node = null or else Before.Node.Element = null)\n          then\n             raise Program_Error with\n               \"Before cursor has no element\";\n@@ -1979,35 +1775,28 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Source'Unrestricted_Access then\n+      if Checks and then Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-      if Target.Length = Count_Type'Last then\n+      if Checks and then Target.Length = Count_Type'Last then\n          raise Constraint_Error with \"Target is full\";\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       Splice_Internal (Target, Before.Node, Source, Position.Node);\n       Position.Container := Target'Unchecked_Access;\n@@ -2165,30 +1954,27 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null then\n+      if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if J.Node = null then\n+      if Checks and then J.Node = null then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unchecked_Access then\n+      if Checks and then I.Container /= Container'Unchecked_Access then\n          raise Program_Error with \"I cursor designates wrong container\";\n       end if;\n \n-      if J.Container /= Container'Unchecked_Access then\n+      if Checks and then J.Container /= Container'Unchecked_Access then\n          raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (list is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap\");\n@@ -2211,30 +1997,27 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null then\n+      if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if J.Node = null then\n+      if Checks and then J.Node = null then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n+      if Checks and then I.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"I cursor designates wrong container\";\n       end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n+      if Checks and then J.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n@@ -2278,41 +2061,26 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unchecked_Access then\n+      if Checks and then Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n \n       declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n-\n+         Lock : With_Lock (Container.TC'Unchecked_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Position.Node.Element.all);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (Position.Node.Element.all);\n       end;\n    end Update_Element;\n "}, {"sha": "46354afa19e141758b681810dc0fe1a510f3fe41", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -33,6 +33,7 @@\n \n with Ada.Iterator_Interfaces;\n \n+private with Ada.Containers.Helpers;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n@@ -240,10 +241,14 @@ private\n    pragma Inline (Next);\n    pragma Inline (Previous);\n \n+   use Ada.Containers.Helpers;\n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   type Element_Access is access Element_Type;\n+   type Element_Access is access all Element_Type;\n \n    type Node_Type is\n       limited record\n@@ -257,11 +262,10 @@ private\n \n    type List is\n      new Controlled with record\n-        First  : Node_Access;\n-        Last   : Node_Access;\n+        First  : Node_Access := null;\n+        Last   : Node_Access := null;\n         Length : Count_Type := 0;\n-        Busy   : Natural := 0;\n-        Lock   : Natural := 0;\n+        TC     : aliased Tamper_Counts;\n      end record;\n \n    overriding procedure Adjust (Container : in out List);\n@@ -301,16 +305,8 @@ private\n \n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : List_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -356,7 +352,23 @@ private\n \n    for Reference_Type'Read use Read;\n \n-   Empty_List : constant List := List'(Controlled with null, null, 0, 0, 0);\n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased List'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n+   Empty_List : constant List := List'(Controlled with others => <>);\n \n    No_Element : constant Cursor := Cursor'(null, null);\n \n@@ -365,7 +377,8 @@ private\n    record\n       Container : List_Access;\n       Node      : Node_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "2cea31895111955a6a6841c40e5e4adc93d7a242", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 112, "deletions": 178, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,8 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Unchecked_Deallocation;\n \n with System; use type System.Address;\n@@ -41,6 +43,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    procedure Free_Key is\n       new Ada.Unchecked_Deallocation (Key_Type, Key_Access);\n \n@@ -124,21 +130,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       HT_Ops.Adjust (Container.HT);\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            M : Map renames Control.Container.all;\n-            HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -201,17 +192,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n       end if;\n@@ -223,15 +215,14 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       declare\n          M : Map renames Position.Container.all;\n          HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -244,24 +235,23 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      if Node.Element = null then\n+      if Checks and then Node.Element = null then\n          raise Program_Error with \"key has no element\";\n       end if;\n \n       declare\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -292,7 +282,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error\n            with \"Requested capacity is less than Source length\";\n       end if;\n@@ -330,7 +320,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    begin\n       Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n-      if X = null then\n+      if Checks and then X = null then\n          raise Constraint_Error with \"attempt to delete key not in map\";\n       end if;\n \n@@ -339,20 +329,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n \n-      if Container.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"Delete attempted to tamper with cursors (map is busy)\";\n-      end if;\n+      TC_Check (Container.HT.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n@@ -371,7 +359,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with\n            \"no element available because key not in map\";\n       end if;\n@@ -381,12 +369,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of function Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor of function Element is bad\";\n       end if;\n@@ -414,22 +402,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Equivalent_Keys (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null then\n+      if Checks and then Left.Node.Key = null then\n          raise Program_Error with\n            \"Left cursor of Equivalent_Keys is bad\";\n       end if;\n \n-      if Right.Node.Key = null then\n+      if Checks and then Right.Node.Key = null then\n          raise Program_Error with\n            \"Right cursor of Equivalent_Keys is bad\";\n       end if;\n@@ -445,12 +433,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Key_Type) return Boolean\n    is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null then\n+      if Checks and then Left.Node.Key = null then\n          raise Program_Error with\n            \"Left cursor of Equivalent_Keys is bad\";\n       end if;\n@@ -465,12 +453,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Cursor) return Boolean\n    is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n-      if Right.Node.Key = null then\n+      if Checks and then Right.Node.Key = null then\n          raise Program_Error with\n            \"Right cursor of Equivalent_Keys is bad\";\n       end if;\n@@ -503,28 +491,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.HT.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            M : Map renames Control.Container.all;\n-            HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.HT.TC);\n       end if;\n    end Finalize;\n \n@@ -631,6 +598,16 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Deallocate (X);\n    end Free;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -669,10 +646,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.HT.Lock > 0 then\n-            raise Program_Error with\n-              \"Include attempted to tamper with elements (map is locked)\";\n-         end if;\n+         TE_Check (Container.HT.TC);\n \n          K := Position.Node.Key;\n          E := Position.Node.Element;\n@@ -774,7 +748,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    begin\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert key already in map\";\n       end if;\n@@ -812,33 +786,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n+      Busy : With_Busy (Container.HT.TC'Unrestricted_Access);\n \n    --  Start of processing Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container.HT);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (Container.HT);\n    end Iterate;\n \n    function Iterate\n      (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n    begin\n       return It : constant Iterator :=\n         (Limited_Controlled with Container => Container'Unrestricted_Access)\n       do\n-         B := B + 1;\n+         Busy (Container.HT.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -848,12 +811,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of function Key equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null then\n+      if Checks and then Position.Node.Key = null then\n          raise Program_Error with\n            \"Position cursor of function Key is bad\";\n       end if;\n@@ -904,8 +867,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with \"Position cursor of Next is bad\";\n       end if;\n@@ -930,14 +893,29 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong map\";\n       end if;\n \n       return Next (Position);\n    end Next;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.HT.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -948,13 +926,13 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n                                             Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with\n            \"Position cursor of Query_Element is bad\";\n@@ -965,31 +943,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       declare\n          M  : Map renames Position.Container.all;\n          HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n-\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n+         K : Key_Type renames Position.Node.Key.all;\n+         E : Element_Type renames Position.Node.Element.all;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            K : Key_Type renames Position.Node.Key.all;\n-            E : Element_Type renames Position.Node.Element.all;\n-\n-         begin\n-            Process (K, E);\n-\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (K, E);\n       end;\n    end Query_Element;\n \n@@ -1070,17 +1028,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n       end if;\n@@ -1092,15 +1051,14 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       declare\n          M : Map renames Position.Container.all;\n          HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Position.Container))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1113,24 +1071,23 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      if Node.Element = null then\n+      if Checks and then Node.Element = null then\n          raise Program_Error with \"key has no element\";\n       end if;\n \n       declare\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1150,15 +1107,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       E : Element_Access;\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n       end if;\n \n-      if Container.HT.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace attempted to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Container.HT.TC);\n \n       K := Node.Key;\n       E := Node.Element;\n@@ -1195,27 +1149,25 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with\n            \"Position cursor of Replace_Element is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      if Position.Container.HT.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace_Element attempted to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Position.Container.HT.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n@@ -1266,19 +1218,20 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with\n            \"Position cursor of Update_Element is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Update_Element designates wrong map\";\n       end if;\n@@ -1287,30 +1240,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n       declare\n          HT : Hash_Table_Type renames Container.HT;\n-\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n+         K : Key_Type renames Position.Node.Key.all;\n+         E : Element_Type renames Position.Node.Element.all;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            K : Key_Type renames Position.Node.Key.all;\n-            E : Element_Type renames Position.Node.Element.all;\n-\n-         begin\n-            Process (K, E);\n-\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (K, E);\n       end;\n    end Update_Element;\n "}, {"sha": "e0584a86a4379c9880bb97830fcc0db6333857e3", "filename": "gcc/ada/a-cihama.ads", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -312,7 +312,7 @@ private\n    type Node_Access is access Node_Type;\n \n    type Key_Access is access Key_Type;\n-   type Element_Access is access Element_Type;\n+   type Element_Access is access all Element_Type;\n \n    type Node_Type is limited record\n       Key     : Key_Access;\n@@ -331,7 +331,7 @@ private\n \n    overriding procedure Finalize (Container : in out Map);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -367,16 +367,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Map_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -422,15 +414,32 @@ private\n \n    for Reference_Type'Read use Read;\n \n-   Empty_Map : constant Map := (Controlled with HT => (null, 0, 0, 0));\n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n+   Empty_Map : constant Map := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (Container => null, Node => null);\n \n    type Iterator is new Limited_Controlled and\n      Map_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Map_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "655304fa862d2ad3a49a3d2d9f064bec30edaf1b", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 140, "deletions": 309, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,8 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Prime_Numbers;\n \n with System; use type System.Address;\n@@ -43,6 +45,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -155,20 +161,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       HT_Ops.Adjust (Container.HT);\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            HT : Hash_Table_Type renames Control.Container.all.HT;\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -224,32 +216,32 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n \n       declare\n          HT : Hash_Table_Type renames Position.Container.all.HT;\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -280,7 +272,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error\n            with \"Requested capacity is less than Source length\";\n       end if;\n@@ -318,7 +310,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    begin\n       Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n \n-      if X = null then\n+      if Checks and then X = null then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n@@ -330,22 +322,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      if Container.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Container.HT.TC);\n \n       pragma Assert (Vet (Position), \"Position cursor is bad\");\n \n@@ -376,10 +366,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.HT.TC);\n \n       if Src_HT.Length < Target.HT.Length then\n          declare\n@@ -495,7 +482,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             raise;\n       end Iterate_Left;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Difference;\n \n    -------------\n@@ -504,11 +491,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor of equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then  --  handle dangling reference\n+      if Checks and then Position.Node.Element = null then\n+         --  handle dangling reference\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n@@ -532,22 +520,22 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Equivalent_Elements (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null then\n+      if Checks and then Left.Node.Element = null then\n          raise Program_Error with\n            \"Left cursor of Equivalent_Elements is bad\";\n       end if;\n \n-      if Right.Node.Element = null then\n+      if Checks and then Right.Node.Element = null then\n          raise Program_Error with\n            \"Right cursor of Equivalent_Elements is bad\";\n       end if;\n@@ -579,12 +567,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Right : Element_Type) return Boolean\n    is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null then\n+      if Checks and then Left.Node.Element = null then\n          raise Program_Error with\n            \"Left cursor of Equivalent_Elements is bad\";\n       end if;\n@@ -599,12 +587,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Right : Cursor) return Boolean\n    is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Right.Node.Element = null then\n+      if Checks and then Right.Node.Element = null then\n          raise Program_Error with\n            \"Right cursor of Equivalent_Elements is bad\";\n       end if;\n@@ -652,27 +640,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.HT.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            HT : Hash_Table_Type renames Control.Container.all.HT;\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.HT.TC);\n       end if;\n    end Finalize;\n \n@@ -789,6 +757,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Deallocate (X);\n    end Free;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -825,10 +803,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Container.HT.TC);\n \n          X := Position.Node.Element;\n \n@@ -874,7 +849,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    begin\n       Insert (Container, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert element already in set\";\n       end if;\n@@ -950,10 +925,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.HT.TC);\n \n       Tgt_Node := HT_Ops.First (Target.HT);\n       while Tgt_Node /= null loop\n@@ -1048,7 +1020,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             raise;\n       end Iterate_Left;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Intersection;\n \n    --------------\n@@ -1128,34 +1100,23 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n+      Busy : With_Busy (Container.HT.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Iterate (Container.HT);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Iterate (Container.HT);\n    end Iterate;\n \n    function Iterate (Container : Set)\n      return Set_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n    begin\n       return It : constant Iterator :=\n         Iterator'(Limited_Controlled with\n                     Container => Container'Unrestricted_Access)\n       do\n-         B := B + 1;\n+         Busy (Container.HT.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1192,7 +1153,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"bad cursor in Next\";\n       end if;\n \n@@ -1221,7 +1182,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong set\";\n       end if;\n@@ -1259,6 +1220,21 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       return False;\n    end Overlap;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.HT.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1268,12 +1244,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"bad cursor in Query_Element\";\n       end if;\n \n@@ -1282,25 +1258,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       declare\n          HT : Hash_Table_Type renames\n                 Position.Container'Unrestricted_Access.all.HT;\n-\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Position.Node.Element.all);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (Position.Node.Element.all);\n       end;\n    end Query_Element;\n \n@@ -1363,15 +1323,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       pragma Warnings (Off, X);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.HT.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is locked)\";\n-      end if;\n+      TE_Check (Container.HT.TC);\n \n       X := Node.Element;\n \n@@ -1399,15 +1356,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"bad cursor in Replace_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong set\";\n       end if;\n@@ -1448,26 +1406,13 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    is\n       Tgt_HT : Hash_Table_Type renames Target.HT;\n       Src_HT : Hash_Table_Type renames Source.HT'Unrestricted_Access.all;\n-\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      TB : Natural renames Tgt_HT.Busy;\n-      TL : Natural renames Tgt_HT.Lock;\n-\n-      SB : Natural renames Src_HT.Busy;\n-      SL : Natural renames Src_HT.Lock;\n-\n    begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      if TB > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Tgt_HT.TC);\n \n       declare\n          N : constant Count_Type := Target.Length + Source.Length;\n@@ -1507,32 +1452,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                N := N + 1;\n             end Process;\n \n-         --  Start of processing for Iterate_Source_When_Empty_Target\n+            --  Per AI05-0022, the container implementation is required to\n+            --  detect element tampering by a generic actual subprogram.\n \n-         begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n+            Lock_Tgt : With_Lock (Tgt_HT.TC'Unrestricted_Access);\n+            Lock_Src : With_Lock (Src_HT.TC'Unrestricted_Access);\n \n-            SB := SB + 1;\n-            SL := SL + 1;\n+         --  Start of processing for Iterate_Source_When_Empty_Target\n \n+         begin\n             Iterate (Src_HT);\n-\n-            SL := SL - 1;\n-            SB := SB - 1;\n-\n-            TL := TL - 1;\n-            TB := TB - 1;\n-\n-         exception\n-            when others =>\n-               SL := SL - 1;\n-               SB := SB - 1;\n-\n-               TL := TL - 1;\n-               TB := TB - 1;\n-\n-               raise;\n          end Iterate_Source_When_Empty_Target;\n \n       else\n@@ -1608,32 +1537,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                end if;\n             end Process;\n \n-         --  Start of processing for Iterate_Source\n+            --  Per AI05-0022, the container implementation is required to\n+            --  detect element tampering by a generic actual subprogram.\n \n-         begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n+            Lock_Tgt : With_Lock (Tgt_HT.TC'Unrestricted_Access);\n+            Lock_Src : With_Lock (Src_HT.TC'Unrestricted_Access);\n \n-            SB := SB + 1;\n-            SL := SL + 1;\n+         --  Start of processing for Iterate_Source\n \n+         begin\n             Iterate (Src_HT);\n-\n-            SL := SL - 1;\n-            SB := SB - 1;\n-\n-            TL := TL - 1;\n-            TB := TB - 1;\n-\n-         exception\n-            when others =>\n-               SL := SL - 1;\n-               SB := SB - 1;\n-\n-               TL := TL - 1;\n-               TB := TB - 1;\n-\n-               raise;\n          end Iterate_Source;\n       end if;\n    end Symmetric_Difference;\n@@ -1767,7 +1680,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             raise;\n       end Iterate_Right;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Symmetric_Difference;\n \n    ------------\n@@ -1841,10 +1754,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.HT.TC);\n \n       declare\n          N : constant Count_Type := Target.Length + Source.Length;\n@@ -1911,25 +1821,14 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          --  Checked_Index instead of a simple invocation of generic formal\n          --  Hash.\n \n-         B : Integer renames Left_HT.Busy;\n-         L : Integer renames Left_HT.Lock;\n+         Lock_Left : With_Lock (Left_HT.TC'Unrestricted_Access);\n \n       --  Start of processing for Iterate_Left\n \n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Iterate (Left.HT);\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n+         Iterate (Left_HT);\n       exception\n          when others =>\n-            L := L - 1;\n-            B := B - 1;\n-\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Left;\n@@ -1978,42 +1877,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          --  Checked_Index instead of a simple invocation of generic formal\n          --  Hash.\n \n-         LB : Integer renames Left_HT.Busy;\n-         LL : Integer renames Left_HT.Lock;\n-\n-         RB : Integer renames Right_HT.Busy;\n-         RL : Integer renames Right_HT.Lock;\n+         Lock_Left : With_Lock (Left_HT.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right_HT.TC'Unrestricted_Access);\n \n       --  Start of processing for Iterate_Right\n \n       begin\n-         LB := LB + 1;\n-         LL := LL + 1;\n-\n-         RB := RB + 1;\n-         RL := RL + 1;\n-\n          Iterate (Right.HT);\n-\n-         RL := RL - 1;\n-         RB := RB - 1;\n-\n-         LL := LL - 1;\n-         LB := LB - 1;\n-\n       exception\n          when others =>\n-            RL := RL - 1;\n-            RB := RB - 1;\n-\n-            LL := LL - 1;\n-            LB := LB - 1;\n-\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Right;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Union;\n \n    ---------\n@@ -2141,24 +2018,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            Hash      => Hash,\n            Equivalent_Keys => Equivalent_Key_Node);\n \n-      ------------\n-      -- Adjust --\n-      ------------\n-\n-      procedure Adjust (Control : in out Reference_Control_Type) is\n-      begin\n-         if Control.Container /= null then\n-            declare\n-               HT : Hash_Table_Type renames Control.Container.HT;\n-               B  : Natural renames HT.Busy;\n-               L  : Natural renames HT.Lock;\n-            begin\n-               B := B + 1;\n-               L := L + 1;\n-            end;\n-         end if;\n-      end Adjust;\n-\n       ------------------------\n       -- Constant_Reference --\n       ------------------------\n@@ -2171,24 +2030,23 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"Key not in set\";\n          end if;\n \n-         if Node.Element = null then\n+         if Checks and then Node.Element = null then\n             raise Program_Error with \"Node has no element\";\n          end if;\n \n          declare\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n+            TC : constant Tamper_Counts_Access :=\n+              HT.TC'Unrestricted_Access;\n          begin\n             return R : constant Constant_Reference_Type :=\n               (Element => Node.Element.all'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n+               Control => (Controlled with TC))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (TC.all);\n             end return;\n          end;\n       end Constant_Reference;\n@@ -2218,7 +2076,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       begin\n          Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n-         if X = null then\n+         if Checks and then X = null then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n@@ -2237,7 +2095,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n@@ -2276,16 +2134,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       procedure Finalize (Control : in out Reference_Control_Type) is\n       begin\n          if Control.Container /= null then\n-            declare\n-               HT : Hash_Table_Type renames Control.Container.HT;\n-               B  : Natural renames HT.Busy;\n-               L  : Natural renames HT.Lock;\n-            begin\n-               B := B - 1;\n-               L := L - 1;\n-            end;\n+            Impl.Reference_Control_Type (Control).Finalize;\n \n-            if Hash (Key (Control.Old_Pos)) /= Control.Old_Hash then\n+            if Checks and then Hash (Key (Control.Old_Pos)) /= Control.Old_Hash\n+            then\n                HT_Ops.Delete_Node_At_Index\n                  (Control.Container.HT, Control.Index, Control.Old_Pos.Node);\n                raise Program_Error;\n@@ -2316,12 +2168,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n-         if Position.Node = null then\n+         if Checks and then Position.Node = null then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Node.Element = null then\n+         if Checks and then Position.Node.Element = null then\n             raise Program_Error with \"Position cursor is bad\";\n          end if;\n \n@@ -2351,16 +2203,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Position  : Cursor) return Reference_Type\n       is\n       begin\n-         if Position.Container = null then\n+         if Checks and then Position.Container = null then\n             raise Constraint_Error with \"Position cursor has no element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n          end if;\n \n-         if Position.Node.Element = null then\n+         if Checks and then Position.Node.Element = null then\n             raise Program_Error with \"Node has no element\";\n          end if;\n \n@@ -2370,20 +2223,18 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          declare\n             HT : Hash_Table_Type renames Container.HT;\n-            B  : Natural renames HT.Busy;\n-            L  : Natural renames HT.Lock;\n          begin\n             return R : constant Reference_Type :=\n                          (Element => Position.Node.Element.all'Access,\n                           Control =>\n                             (Controlled with\n+                              HT.TC'Unrestricted_Access,\n                               Container => Container'Access,\n                               Index     => HT_Ops.Index (HT, Position.Node),\n                               Old_Pos   => Position,\n                               Old_Hash  => Hash (Key (Position))))\n-         do\n-               B := B + 1;\n-               L := L + 1;\n+            do\n+               Lock (HT.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -2395,31 +2246,29 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"Key not in set\";\n          end if;\n \n-         if Node.Element = null then\n+         if Checks and then Node.Element = null then\n             raise Program_Error with \"Node has no element\";\n          end if;\n \n          declare\n             HT : Hash_Table_Type renames Container.HT;\n-            B  : Natural renames HT.Busy;\n-            L  : Natural renames HT.Lock;\n             P  : constant Cursor := Find (Container, Key);\n          begin\n             return R : constant Reference_Type :=\n                          (Element => Node.Element.all'Access,\n                           Control =>\n                             (Controlled with\n+                              HT.TC'Unrestricted_Access,\n                               Container => Container'Access,\n                               Index     => HT_Ops.Index (HT, P.Node),\n                               Old_Pos   => P,\n                               Old_Hash  => Hash (Key)))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (HT.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -2436,7 +2285,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with\n               \"attempt to replace key not in set\";\n          end if;\n@@ -2458,25 +2307,28 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Indx : Hash_Type;\n \n       begin\n-         if Position.Node = null then\n+         if Checks and then Position.Node = null then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Node.Element = null\n-           or else Position.Node.Next = Position.Node\n+         if Checks and then\n+           (Position.Node.Element = null\n+              or else Position.Node.Next = Position.Node)\n          then\n             raise Program_Error with \"Position cursor is bad\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong set\";\n          end if;\n \n-         if HT.Buckets = null\n-           or else HT.Buckets'Length = 0\n-           or else HT.Length = 0\n+         if Checks and then\n+           (HT.Buckets = null\n+              or else HT.Buckets'Length = 0\n+              or else HT.Length = 0)\n          then\n             raise Program_Error with \"Position cursor is bad (set is empty)\";\n          end if;\n@@ -2491,33 +2343,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          declare\n             E : Element_Type renames Position.Node.Element.all;\n             K : constant Key_Type := Key (E);\n-\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-\n-            Eq : Boolean;\n-\n+            Lock : With_Lock (HT.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Indx := HT_Ops.Index (HT, Position.Node);\n-               Process (E);\n-               Eq := Equivalent_Keys (K, Key (E));\n-\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-\n-                  raise;\n-            end;\n-\n-            L := L - 1;\n-            B := B - 1;\n+            Indx := HT_Ops.Index (HT, Position.Node);\n+            Process (E);\n \n-            if Eq then\n+            if Equivalent_Keys (K, Key (E)) then\n                return;\n             end if;\n          end;\n@@ -2533,7 +2364,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                while Prev.Next /= Position.Node loop\n                   Prev := Prev.Next;\n \n-                  if Prev = null then\n+                  if Checks and then Prev = null then\n                      raise Program_Error with\n                        \"Position cursor is bad (node not found)\";\n                   end if;"}, {"sha": "db4d8bda9dc7831bcc1a3604b1271db109b7443c", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -34,6 +34,7 @@\n with Ada.Iterator_Interfaces;\n \n private with Ada.Containers.Hash_Tables;\n+private with Ada.Containers.Helpers;\n private with Ada.Streams;\n private with Ada.Finalization;\n \n@@ -433,18 +434,17 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n       type Set_Access is access all Set;\n       for Set_Access'Storage_Size use 0;\n \n+      package Impl is new Helpers.Generic_Implementation;\n+\n       type Reference_Control_Type is\n-        new Ada.Finalization.Controlled with\n+        new Impl.Reference_Control_Type with\n       record\n          Container : Set_Access;\n          Index     : Hash_Type;\n          Old_Pos   : Cursor;\n          Old_Hash  : Hash_Type;\n       end record;\n \n-      overriding procedure Adjust (Control : in out Reference_Control_Type);\n-      pragma Inline (Adjust);\n-\n       overriding procedure Finalize (Control : in out Reference_Control_Type);\n       pragma Inline (Finalize);\n \n@@ -477,7 +477,7 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   type Element_Access is access Element_Type;\n+   type Element_Access is access all Element_Type;\n \n    type Node_Type is limited record\n       Element : Element_Access;\n@@ -495,7 +495,7 @@ private\n \n    overriding procedure Finalize (Container : in out Set);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -531,16 +531,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Set_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -564,15 +556,32 @@ private\n \n    for Constant_Reference_Type'Write use Write;\n \n-   Empty_Set : constant Set := (Controlled with HT => (null, 0, 0, 0));\n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n+   Empty_Set : constant Set := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (Container => null, Node => null);\n \n    type Iterator is new Limited_Controlled and\n      Set_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Set_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "326c1172c8f978fe4f3fe75c2cc01163ecd4f0ed", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 219, "deletions": 351, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,10 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    --------------------\n    --  Root_Iterator --\n    --------------------\n@@ -164,10 +168,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n    function \"=\" (Left, Right : Tree) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       return Equal_Children (Root_Node (Left), Root_Node (Right));\n    end \"=\";\n \n@@ -186,8 +186,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       --  are preserved in the event that the allocation fails.\n \n       Container.Root.Children := Children_Type'(others => null);\n-      Container.Busy := 0;\n-      Container.Lock := 0;\n+      Zero_Counts (Container.TC);\n       Container.Count := 0;\n \n       --  Copy_Children returns a count of the number of nodes that it\n@@ -206,20 +205,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Container.Count := Source_Count;\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Tree renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    -------------------\n    -- Ancestor_Find --\n    -------------------\n@@ -231,21 +216,23 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       R, N : Tree_Node_Access;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       --  Commented-out pending ARG ruling.  ???\n \n-      --  if Position.Container /= Container'Unrestricted_Access then\n+      --  if Checks and then\n+      --     Position.Container /= Container'Unrestricted_Access\n+      --  then\n       --     raise Program_Error with \"Position cursor not in container\";\n       --  end if;\n \n       --  AI-0136 says to raise PE if Position equals the root node. This does\n       --  not seem correct, as this value is just the limiting condition of the\n       --  search. For now we omit this check pending a ruling from the ARG.???\n \n-      --  if Is_Root (Position) then\n+      --  if Checks and then Is_Root (Position) then\n       --     raise Program_Error with \"Position cursor designates root\";\n       --  end if;\n \n@@ -276,22 +263,19 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Element     : Element_Access;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Count = 0 then\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       declare\n          --  The element allocator may need an accessibility check in the case\n@@ -406,15 +390,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       N      : Tree_Node_Access;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Child = No_Element then\n+      if Checks and then Child = No_Element then\n          raise Constraint_Error with \"Child cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Child.Container then\n+      if Checks and then Parent.Container /= Child.Container then\n          raise Program_Error with \"Parent and Child in different containers\";\n       end if;\n \n@@ -424,7 +408,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          Result := Result + 1;\n          N := N.Parent;\n \n-         if N = null then\n+         if Checks and then N = null then\n             raise Program_Error with \"Parent is not ancestor of Child\";\n          end if;\n       end loop;\n@@ -441,10 +425,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Children_Count  : Count_Type;\n \n    begin\n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  We first set the container count to 0, in order to preserve\n       --  invariants in case the deallocation fails. (This works because\n@@ -478,21 +459,22 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      if Position.Node = Root_Node (Container) then\n+      if Checks and then Position.Node = Root_Node (Container) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n@@ -501,16 +483,14 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       --                 \"Position cursor in Constant_Reference is bad\");\n \n       declare\n-         C : Tree renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -615,20 +595,20 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Target_Count   : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Target'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Target'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with \"Before cursor not in container\";\n          end if;\n \n-         if Before.Node.Parent /= Parent.Node then\n+         if Checks and then Before.Node.Parent /= Parent.Node then\n             raise Constraint_Error with \"Before cursor not child of Parent\";\n          end if;\n       end if;\n@@ -637,7 +617,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      if Is_Root (Source) then\n+      if Checks and then Is_Root (Source) then\n          raise Constraint_Error with \"Source cursor designates root\";\n       end if;\n \n@@ -760,18 +740,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  Deallocate_Children returns a count of the number of nodes\n       --  that it deallocates, but it works by incrementing the\n@@ -797,26 +774,24 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       X : Tree_Node_Access;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if not Is_Leaf (Position) then\n+      if Checks and then not Is_Leaf (Position) then\n          raise Constraint_Error with \"Position cursor does not designate leaf\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       X := Position.Node;\n       Position := No_Element;\n@@ -846,22 +821,20 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       X := Position.Node;\n       Position := No_Element;\n@@ -924,11 +897,12 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Node = Root_Node (Position.Container.all) then\n+      if Checks and then Position.Node = Root_Node (Position.Container.all)\n+      then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -976,11 +950,11 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Right_Position : Cursor) return Boolean\n    is\n    begin\n-      if Left_Position = No_Element then\n+      if Checks and then Left_Position = No_Element then\n          raise Constraint_Error with \"Left cursor has no element\";\n       end if;\n \n-      if Right_Position = No_Element then\n+      if Checks and then Right_Position = No_Element then\n          raise Constraint_Error with \"Right cursor has no element\";\n       end if;\n \n@@ -1020,25 +994,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    --------------\n \n    procedure Finalize (Object : in out Root_Iterator) is\n-      B : Natural renames Object.Container.Busy;\n-   begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n    begin\n-      if Control.Container /= null then\n-         declare\n-            C : Tree renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n-      end if;\n+      Unbusy (Object.Container.TC);\n    end Finalize;\n \n    ----------\n@@ -1086,7 +1043,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Node : Tree_Node_Access;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n@@ -1144,13 +1101,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Result : Tree_Node_Access;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       --  Commented-out pending ruling from ARG.  ???\n \n-      --  if Position.Container /= Container'Unrestricted_Access then\n+      --  if Checks and then\n+      --    Position.Container /= Container'Unrestricted_Access\n+      --  then\n       --     raise Program_Error with \"Position cursor not in container\";\n       --  end if;\n \n@@ -1180,6 +1139,16 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       return Find_In_Children (Subtree, Item);\n    end Find_In_Subtree;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1224,20 +1193,21 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Element : Element_Access;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with \"Before cursor not in container\";\n          end if;\n \n-         if Before.Node.Parent /= Parent.Node then\n+         if Checks and then Before.Node.Parent /= Parent.Node then\n             raise Constraint_Error with \"Parent cursor not parent of Before\";\n          end if;\n       end if;\n@@ -1247,10 +1217,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       declare\n          --  The element allocator may need an accessibility check in the case\n@@ -1437,22 +1404,12 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n      (Container : Tree;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-\n       Iterate_Children\n         (Container => Container'Unrestricted_Access,\n          Subtree   => Root_Node (Container),\n          Process   => Process);\n-\n-      B := B - 1;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         raise;\n    end Iterate;\n \n    function Iterate (Container : Tree)\n@@ -1470,31 +1427,18 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n      (Parent  : Cursor;\n       Process : not null access procedure (Position : Cursor))\n    is\n+      C : Tree_Node_Access;\n+      Busy : With_Busy (Parent.Container.TC'Unrestricted_Access);\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      declare\n-         B : Natural renames Parent.Container.Busy;\n-         C : Tree_Node_Access;\n-\n-      begin\n-         B := B + 1;\n-\n-         C := Parent.Node.Children.First;\n-         while C /= null loop\n-            Process (Position => Cursor'(Parent.Container, Node => C));\n-            C := C.Next;\n-         end loop;\n-\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n+      C := Parent.Node.Children.First;\n+      while C /= null loop\n+         Process (Position => Cursor'(Parent.Container, Node => C));\n+         C := C.Next;\n+      end loop;\n    end Iterate_Children;\n \n    procedure Iterate_Children\n@@ -1524,14 +1468,12 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n      return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       C : constant Tree_Access := Container'Unrestricted_Access;\n-      B : Natural renames C.Busy;\n-\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= C then\n+      if Checks and then Parent.Container /= C then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n@@ -1540,7 +1482,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n                           Container => C,\n                           Subtree   => Parent.Node)\n       do\n-         B := B + 1;\n+         Busy (C.TC);\n       end return;\n    end Iterate_Children;\n \n@@ -1552,55 +1494,39 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n      (Position : Cursor)\n       return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n+      C : constant Tree_Access := Position.Container;\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       --  Implement Vet for multiway trees???\n       --  pragma Assert (Vet (Position), \"bad subtree cursor\");\n \n-      declare\n-         B : Natural renames Position.Container.Busy;\n-      begin\n-         return It : constant Subtree_Iterator :=\n-           (Limited_Controlled with\n-              Container => Position.Container,\n-              Subtree   => Position.Node)\n-         do\n-            B := B + 1;\n-         end return;\n-      end;\n+      return It : constant Subtree_Iterator :=\n+        (Limited_Controlled with\n+           Container => Position.Container,\n+           Subtree   => Position.Node)\n+      do\n+         Busy (C.TC);\n+      end return;\n    end Iterate_Subtree;\n \n    procedure Iterate_Subtree\n      (Position  : Cursor;\n       Process   : not null access procedure (Position : Cursor))\n    is\n+      Busy : With_Busy (Position.Container.TC'Unrestricted_Access);\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      declare\n-         B : Natural renames Position.Container.Busy;\n-\n-      begin\n-         B := B + 1;\n-\n-         if Is_Root (Position) then\n-            Iterate_Children (Position.Container, Position.Node, Process);\n-         else\n-            Iterate_Subtree (Position.Container, Position.Node, Process);\n-         end if;\n-\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n+      if Is_Root (Position) then\n+         Iterate_Children (Position.Container, Position.Node, Process);\n+      else\n+         Iterate_Subtree (Position.Container, Position.Node, Process);\n+      end if;\n    end Iterate_Subtree;\n \n    procedure Iterate_Subtree\n@@ -1634,7 +1560,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Node : Tree_Node_Access;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n@@ -1668,10 +1594,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      if Source.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors of Source (tree is busy)\";\n-      end if;\n+      TC_Check (Source.TC);\n \n       Target.Clear;  -- checks busy bit\n \n@@ -1703,7 +1626,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong tree\";\n       end if;\n@@ -1734,7 +1657,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong tree\";\n       end if;\n@@ -1814,22 +1737,19 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Element     : Element_Access;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Count = 0 then\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       declare\n          --  The element allocator may need an accessibility check in the case\n@@ -1889,7 +1809,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong tree\";\n       end if;\n@@ -1919,6 +1839,20 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Position := Previous_Sibling (Position);\n    end Previous_Sibling;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Tree'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1927,35 +1861,18 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n+      T : Tree renames Position.Container.all'Unrestricted_Access.all;\n+      Lock : With_Lock (T.TC'Unrestricted_Access);\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      declare\n-         T : Tree renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Process (Position.Node.Element.all);\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+      Process (Position.Node.Element.all);\n    end Query_Element;\n \n    ----------\n@@ -1994,7 +1911,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       begin\n          Count_Type'Read (Stream, Count);\n \n-         if Count < 0 then\n+         if Checks and then Count < 0 then\n             raise Program_Error with \"attempt to read from corrupt stream\";\n          end if;\n \n@@ -2046,7 +1963,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n       Count_Type'Read (Stream, Total_Count);\n \n-      if Total_Count < 0 then\n+      if Checks and then Total_Count < 0 then\n          raise Program_Error with \"attempt to read from corrupt stream\";\n       end if;\n \n@@ -2058,7 +1975,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n       Read_Children (Root_Node (Container));\n \n-      if Read_Count /= Total_Count then\n+      if Checks and then Read_Count /= Total_Count then\n          raise Program_Error with \"attempt to read from corrupt stream\";\n       end if;\n \n@@ -2098,21 +2015,22 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      if Position.Node = Root_Node (Container) then\n+      if Checks and then Position.Node = Root_Node (Container) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n@@ -2121,16 +2039,14 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       --                 \"Position cursor in Constant_Reference is bad\");\n \n       declare\n-         C : Tree renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Position.Container))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -2182,22 +2098,20 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       E, X : Element_Access;\n \n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with elements (tree is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          --  The element allocator may need an accessibility check in the case\n@@ -2224,31 +2138,18 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n      (Parent  : Cursor;\n       Process : not null access procedure (Position : Cursor))\n    is\n+      C : Tree_Node_Access;\n+      Busy : With_Busy (Parent.Container.TC'Unrestricted_Access);\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      declare\n-         B : Natural renames Parent.Container.Busy;\n-         C : Tree_Node_Access;\n-\n-      begin\n-         B := B + 1;\n-\n-         C := Parent.Node.Children.Last;\n-         while C /= null loop\n-            Process (Position => Cursor'(Parent.Container, Node => C));\n-            C := C.Prev;\n-         end loop;\n-\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n+      C := Parent.Node.Children.Last;\n+      while C /= null loop\n+         Process (Position => Cursor'(Parent.Container, Node => C));\n+         C := C.Prev;\n+      end loop;\n    end Reverse_Iterate_Children;\n \n    ----------\n@@ -2283,32 +2184,34 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n-      if Target_Parent = No_Element then\n+      if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n \n-      if Target_Parent.Container /= Target'Unrestricted_Access then\n+      if Checks and then Target_Parent.Container /= Target'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Target_Parent cursor not in Target container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error\n               with \"Before cursor not in Target container\";\n          end if;\n \n-         if Before.Node.Parent /= Target_Parent.Node then\n+         if Checks and then Before.Node.Parent /= Target_Parent.Node then\n             raise Constraint_Error\n               with \"Before cursor not child of Target_Parent\";\n          end if;\n       end if;\n \n-      if Source_Parent = No_Element then\n+      if Checks and then Source_Parent = No_Element then\n          raise Constraint_Error with \"Source_Parent cursor has no element\";\n       end if;\n \n-      if Source_Parent.Container /= Source'Unrestricted_Access then\n+      if Checks and then Source_Parent.Container /= Source'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Source_Parent cursor not in Source container\";\n       end if;\n@@ -2318,12 +2221,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n             return;\n          end if;\n \n-         if Target.Busy > 0 then\n-            raise Program_Error\n-              with \"attempt to tamper with cursors (Target tree is busy)\";\n-         end if;\n+         TC_Check (Target.TC);\n \n-         if Is_Reachable (From => Target_Parent.Node,\n+         if Checks and then Is_Reachable (From => Target_Parent.Node,\n                           To   => Source_Parent.Node)\n          then\n             raise Constraint_Error\n@@ -2338,15 +2238,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Target tree is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Source tree is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       --  We cache the count of the nodes we have allocated, so that operation\n       --  Node_Count can execute in O(1) time. But that means we must count the\n@@ -2374,32 +2267,37 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Source_Parent   : Cursor)\n    is\n    begin\n-      if Target_Parent = No_Element then\n+      if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n \n-      if Target_Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then\n+        Target_Parent.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Target_Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error\n               with \"Before cursor not in container\";\n          end if;\n \n-         if Before.Node.Parent /= Target_Parent.Node then\n+         if Checks and then Before.Node.Parent /= Target_Parent.Node then\n             raise Constraint_Error\n               with \"Before cursor not child of Target_Parent\";\n          end if;\n       end if;\n \n-      if Source_Parent = No_Element then\n+      if Checks and then Source_Parent = No_Element then\n          raise Constraint_Error with \"Source_Parent cursor has no element\";\n       end if;\n \n-      if Source_Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then\n+        Source_Parent.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error\n            with \"Source_Parent cursor not in container\";\n       end if;\n@@ -2408,12 +2306,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n-      if Is_Reachable (From => Target_Parent.Node,\n+      if Checks and then Is_Reachable (From => Target_Parent.Node,\n                        To   => Source_Parent.Node)\n       then\n          raise Constraint_Error\n@@ -2470,33 +2365,33 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Subtree_Count : Count_Type;\n \n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Target'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Target'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in Target container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Target'Unrestricted_Access then\n+         if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with \"Before cursor not in Target container\";\n          end if;\n \n-         if Before.Node.Parent /= Parent.Node then\n+         if Checks and then Before.Node.Parent /= Parent.Node then\n             raise Constraint_Error with \"Before cursor not child of Parent\";\n          end if;\n       end if;\n \n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Source'Unrestricted_Access then\n+      if Checks and then Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error with \"Position cursor not in Source container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n@@ -2511,12 +2406,11 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n             end if;\n          end if;\n \n-         if Target.Busy > 0 then\n-            raise Program_Error\n-              with \"attempt to tamper with cursors (Target tree is busy)\";\n-         end if;\n+         TC_Check (Target.TC);\n \n-         if Is_Reachable (From => Parent.Node, To => Position.Node) then\n+         if Checks and then\n+           Is_Reachable (From => Parent.Node, To => Position.Node)\n+         then\n             raise Constraint_Error with \"Position is ancestor of Parent\";\n          end if;\n \n@@ -2528,15 +2422,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Target tree is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (Source tree is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       --  This is an unfortunate feature of this API: we must count the nodes\n       --  in the subtree that we remove from the source tree, which is an O(n)\n@@ -2570,33 +2457,35 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Position  : Cursor)\n    is\n    begin\n-      if Parent = No_Element then\n+      if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n \n-      if Parent.Container /= Container'Unrestricted_Access then\n+      if Checks and then Parent.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n       if Before /= No_Element then\n-         if Before.Container /= Container'Unrestricted_Access then\n+         if Checks and then Before.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with \"Before cursor not in container\";\n          end if;\n \n-         if Before.Node.Parent /= Parent.Node then\n+         if Checks and then Before.Node.Parent /= Parent.Node then\n             raise Constraint_Error with \"Before cursor not child of Parent\";\n          end if;\n       end if;\n \n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n \n          --  Should this be PE instead?  Need ARG confirmation.  ???\n \n@@ -2613,12 +2502,11 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          end if;\n       end if;\n \n-      if Container.Busy > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with cursors (tree is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n-      if Is_Reachable (From => Parent.Node, To => Position.Node) then\n+      if Checks and then\n+        Is_Reachable (From => Parent.Node, To => Position.Node)\n+      then\n          raise Constraint_Error with \"Position is ancestor of Parent\";\n       end if;\n \n@@ -2667,38 +2555,35 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       I, J      : Cursor)\n    is\n    begin\n-      if I = No_Element then\n+      if Checks and then I = No_Element then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n+      if Checks and then I.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"I cursor not in container\";\n       end if;\n \n-      if Is_Root (I) then\n+      if Checks and then Is_Root (I) then\n          raise Program_Error with \"I cursor designates root\";\n       end if;\n \n       if I = J then -- make this test sooner???\n          return;\n       end if;\n \n-      if J = No_Element then\n+      if Checks and then J = No_Element then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n+      if Checks and then J.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"J cursor not in container\";\n       end if;\n \n-      if Is_Root (J) then\n+      if Checks and then Is_Root (J) then\n          raise Program_Error with \"J cursor designates root\";\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error\n-           with \"attempt to tamper with elements (tree is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          EI : constant Element_Access := I.Node.Element;\n@@ -2718,40 +2603,23 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n+      T : Tree renames Position.Container.all'Unrestricted_Access.all;\n+      Lock : With_Lock (T.TC'Unrestricted_Access);\n    begin\n-      if Position = No_Element then\n+      if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor not in container\";\n       end if;\n \n-      if Is_Root (Position) then\n+      if Checks and then Is_Root (Position) then\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      declare\n-         T : Tree renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n-      begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Process (Position.Node.Element.all);\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-\n-            raise;\n-      end;\n+      Process (Position.Node.Element.all);\n    end Update_Element;\n \n    -----------"}, {"sha": "dd636511ea4717a3112478166b5e80e7949e528e", "filename": "gcc/ada/a-cimutr.ads", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cimutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cimutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -32,6 +32,8 @@\n ------------------------------------------------------------------------------\n \n with Ada.Iterator_Interfaces;\n+\n+private with Ada.Containers.Helpers;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n@@ -303,6 +305,10 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n \n private\n \n+   use Ada.Containers.Helpers;\n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    type Tree_Node_Type;\n    type Tree_Node_Access is access all Tree_Node_Type;\n \n@@ -311,7 +317,7 @@ private\n       Last  : Tree_Node_Access;\n    end record;\n \n-   type Element_Access is access Element_Type;\n+   type Element_Access is access all Element_Type;\n \n    type Tree_Node_Type is record\n       Parent   : Tree_Node_Access;\n@@ -337,8 +343,7 @@ private\n \n    type Tree is new Controlled with record\n       Root  : aliased Tree_Node_Type;\n-      Busy  : Natural := 0;\n-      Lock  : Natural := 0;\n+      TC    : aliased Tamper_Counts;\n       Count : Count_Type := 0;\n    end record;\n \n@@ -380,16 +385,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Tree_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -435,6 +432,22 @@ private\n \n    for Reference_Type'Write use Write;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Tree'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Tree : constant Tree := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (others => <>);"}, {"sha": "3d4a92f7f2e34d7130e36afc4cbedbb25388689d", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 132, "deletions": 206, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,8 @@\n \n with Ada.Unchecked_Deallocation;\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Red_Black_Trees.Generic_Operations;\n pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Operations);\n \n@@ -41,6 +43,10 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    pragma Annotate (CodePeer, Skip_Analysis);\n    pragma Suppress (All_Checks);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -132,19 +138,19 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null then\n+      if Checks and then Left.Node.Key = null then\n          raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n       end if;\n \n-      if Right.Node.Key = null then\n+      if Checks and then Right.Node.Key = null then\n          raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n@@ -159,11 +165,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null then\n+      if Checks and then Left.Node.Key = null then\n          raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n       end if;\n \n@@ -175,11 +181,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n-      if Right.Node.Key = null then\n+      if Checks and then Right.Node.Key = null then\n          raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n@@ -204,19 +210,19 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null then\n+      if Checks and then Left.Node.Key = null then\n          raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n       end if;\n \n-      if Right.Node.Key = null then\n+      if Checks and then Right.Node.Key = null then\n          raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n@@ -231,11 +237,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null then\n+      if Checks and then Left.Node.Key = null then\n          raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n       end if;\n \n@@ -247,11 +253,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n-      if Right.Node.Key = null then\n+      if Checks and then Right.Node.Key = null then\n          raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n@@ -272,20 +278,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Adjust (Container.Tree);\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            T : Tree_Type renames Control.Container.all.Tree;\n-            B : Natural renames T.Busy;\n-            L : Natural renames T.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -357,34 +349,33 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n                      \"Position cursor in Constant_Reference is bad\");\n \n       declare\n-         T : Tree_Type renames Container'Unrestricted_Access.all.Tree;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.Tree.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -396,25 +387,23 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      if Node.Element = null then\n+      if Checks and then Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n       declare\n-         T : Tree_Type renames Container'Unrestricted_Access.all.Tree;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.Tree.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -473,18 +462,19 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position  : in out Cursor)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with \"Position cursor of Delete is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n@@ -502,7 +492,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       X : Node_Access := Key_Ops.Find (Container.Tree, Key);\n \n    begin\n-      if X = null then\n+      if Checks and then X = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n@@ -542,12 +532,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of function Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor of function Element is bad\";\n       end if;\n@@ -562,7 +552,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n@@ -598,27 +588,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Tree.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            T : Tree_Type renames Control.Container.all.Tree;\n-            B : Natural renames T.Busy;\n-            L : Natural renames T.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.Tree.TC);\n       end if;\n    end Finalize;\n \n@@ -673,11 +643,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    function First_Element (Container : Map) return Element_Type is\n       T : Tree_Type renames Container.Tree;\n    begin\n-      if T.First = null then\n+      if Checks and then T.First = null then\n          raise Constraint_Error with \"map is empty\";\n-      else\n-         return T.First.Element.all;\n       end if;\n+\n+      return T.First.Element.all;\n    end First_Element;\n \n    ---------------\n@@ -687,11 +657,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    function First_Key (Container : Map) return Key_Type is\n       T : Tree_Type renames Container.Tree;\n    begin\n-      if T.First = null then\n+      if Checks and then T.First = null then\n          raise Constraint_Error with \"map is empty\";\n-      else\n-         return T.First.Key.all;\n       end if;\n+\n+      return T.First.Key.all;\n    end First_Key;\n \n    -----------\n@@ -754,6 +724,16 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Deallocate (X);\n    end Free;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -782,10 +762,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Tree.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (map is locked)\";\n-         end if;\n+         TE_Check (Container.Tree.TC);\n \n          K := Position.Node.Key;\n          E := Position.Node.Element;\n@@ -886,7 +863,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    begin\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with \"key already in map\";\n       end if;\n    end Insert;\n@@ -959,30 +936,17 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.Tree.Busy;\n+      Busy : With_Busy (Container.Tree.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container.Tree);\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (Container.Tree);\n    end Iterate;\n \n    function Iterate\n      (Container : Map) return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Tree.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -999,7 +963,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n            Container => Container'Unrestricted_Access,\n            Node      => null)\n       do\n-         B := B + 1;\n+         Busy (Container.Tree.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1008,8 +972,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Start     : Cursor)\n       return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Tree.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1022,12 +984,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start = No_Element then\n+      if Checks and then Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n       end if;\n \n-      if Start.Container /= Container'Unrestricted_Access then\n+      if Checks and then Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong map\";\n       end if;\n@@ -1049,7 +1011,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n            Container => Container'Unrestricted_Access,\n            Node      => Start.Node)\n       do\n-         B := B + 1;\n+         Busy (Container.Tree.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1059,12 +1021,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of function Key equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null then\n+      if Checks and then Position.Node.Key = null then\n          raise Program_Error with\n            \"Position cursor of function Key is bad\";\n       end if;\n@@ -1116,7 +1078,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       T : Tree_Type renames Container.Tree;\n \n    begin\n-      if T.Last = null then\n+      if Checks and then T.Last = null then\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n@@ -1131,7 +1093,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       T : Tree_Type renames Container.Tree;\n \n    begin\n-      if T.Last = null then\n+      if Checks and then T.Last = null then\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n@@ -1206,7 +1168,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong map\";\n       end if;\n@@ -1262,14 +1224,29 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong map\";\n       end if;\n \n       return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.Tree.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1280,13 +1257,13 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n                                             Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with\n            \"Position cursor of Query_Element is bad\";\n@@ -1297,28 +1274,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       declare\n          T : Tree_Type renames Position.Container.Tree;\n-\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n+         Lock : With_Lock (T.TC'Unrestricted_Access);\n+         K : Key_Type renames Position.Node.Key.all;\n+         E : Element_Type renames Position.Node.Element.all;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            K : Key_Type renames Position.Node.Key.all;\n-            E : Element_Type renames Position.Node.Element.all;\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (K, E);\n       end;\n    end Query_Element;\n \n@@ -1394,34 +1354,33 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n                      \"Position cursor in function Reference is bad\");\n \n       declare\n-         T : Tree_Type renames Container'Unrestricted_Access.all.Tree;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.Tree.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Position.Container))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1433,25 +1392,23 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      if Node.Element = null then\n+      if Checks and then Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n       declare\n-         T : Tree_Type renames Container'Unrestricted_Access.all.Tree;\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Container.Tree.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1471,14 +1428,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       E : Element_Access;\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      if Container.Tree.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Container.Tree.TC);\n \n       K := Node.Key;\n       E := Node.Element;\n@@ -1515,27 +1469,25 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with\n            \"Position cursor of Replace_Element is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      if Container.Tree.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Container.Tree.TC);\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n@@ -1578,22 +1530,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container.Tree'Unrestricted_Access.all.Busy;\n+      Busy : With_Busy (Container.Tree.TC'Unrestricted_Access);\n \n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (Container.Tree);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Reverse_Iterate (Container.Tree);\n    end Reverse_Iterate;\n \n    -----------\n@@ -1652,19 +1594,20 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n-      if Position.Node.Key = null\n-        or else Position.Node.Element = null\n+      if Checks and then\n+        (Position.Node.Key = null or else Position.Node.Element = null)\n       then\n          raise Program_Error with\n            \"Position cursor of Update_Element is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Update_Element designates wrong map\";\n       end if;\n@@ -1674,28 +1617,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       declare\n          T : Tree_Type renames Position.Container.Tree;\n-\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n+         Lock : With_Lock (T.TC'Unrestricted_Access);\n+         K : Key_Type renames Position.Node.Key.all;\n+         E : Element_Type renames Position.Node.Element.all;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            K : Key_Type renames Position.Node.Key.all;\n-            E : Element_Type renames Position.Node.Element.all;\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (K, E);\n       end;\n    end Update_Element;\n "}, {"sha": "62bd6878aa1768886f2bc00059b730e252162f1e", "filename": "gcc/ada/a-ciorma.ads", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -236,7 +236,7 @@ private\n    type Node_Access is access Node_Type;\n \n    type Key_Access is access Key_Type;\n-   type Element_Access is access Element_Type;\n+   type Element_Access is access all Element_Type;\n \n    type Node_Type is limited record\n       Parent  : Node_Access;\n@@ -260,7 +260,7 @@ private\n    overriding procedure Finalize (Container : in out Map) renames Clear;\n \n    use Red_Black_Trees;\n-   use Tree_Types;\n+   use Tree_Types, Tree_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -296,16 +296,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Map_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -351,13 +343,23 @@ private\n \n    for Reference_Type'Write use Write;\n \n-   Empty_Map : constant Map :=\n-                 (Controlled with Tree => (First  => null,\n-                                           Last   => null,\n-                                           Root   => null,\n-                                           Length => 0,\n-                                           Busy   => 0,\n-                                           Lock   => 0));\n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions.  See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n+   Empty_Map : constant Map := (Controlled with others => <>);\n \n    No_Element : constant Cursor := Cursor'(null, null);\n \n@@ -366,7 +368,8 @@ private\n    record\n       Container : Map_Access;\n       Node      : Node_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "8888e274bc30cb3eec3e9a8c287f9fcd0c3e7ef4", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 24, "deletions": 121, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -44,6 +44,10 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -636,10 +640,8 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    --------------\n \n    procedure Finalize (Object : in out Iterator) is\n-      B : Natural renames Object.Container.Tree.Busy;\n-      pragma Assert (B > 0);\n    begin\n-      B := B - 1;\n+      Unbusy (Object.Container.Tree.TC);\n    end Finalize;\n \n    -----------\n@@ -943,22 +945,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          end Process_Node;\n \n          T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-         B : Natural renames T.Busy;\n+         Busy : With_Busy (T.TC'Unrestricted_Access);\n \n       --  Start of processing for Iterate\n \n       begin\n-         B := B + 1;\n-\n-         begin\n-            Local_Iterate (T, Key);\n-         exception\n-            when others =>\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         B := B - 1;\n+         Local_Iterate (T, Key);\n       end Iterate;\n \n       ---------\n@@ -1012,22 +1004,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          end Process_Node;\n \n          T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-         B : Natural renames T.Busy;\n+         Busy : With_Busy (T.TC'Unrestricted_Access);\n \n       --  Start of processing for Reverse_Iterate\n \n       begin\n-         B := B + 1;\n-\n-         begin\n-            Local_Reverse_Iterate (T, Key);\n-         exception\n-            when others =>\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         B := B - 1;\n+         Local_Reverse_Iterate (T, Key);\n       end Reverse_Iterate;\n \n       --------------------\n@@ -1061,25 +1043,9 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          declare\n             E : Element_Type renames Node.Element.all;\n             K : constant Key_Type := Key (E);\n-\n-            B : Natural renames Tree.Busy;\n-            L : Natural renames Tree.Lock;\n-\n+            Lock : With_Lock (Tree.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Process (E);\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n-\n-            L := L - 1;\n-            B := B - 1;\n+            Process (E);\n \n             if Equivalent_Keys (Left => K, Right => Key (E)) then\n                return;\n@@ -1367,22 +1333,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       end Process_Node;\n \n       T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-      B : Natural renames T.Busy;\n+      Busy : With_Busy (T.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (T, Item);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (T, Item);\n    end Iterate;\n \n    procedure Iterate\n@@ -1405,30 +1361,18 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       end Process_Node;\n \n       T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-      B : Natural renames T.Busy;\n+      Busy : With_Busy (T.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (T);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (T);\n    end Iterate;\n \n    function Iterate (Container : Set)\n      return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       S : constant Set_Access := Container'Unrestricted_Access;\n-      B : Natural renames S.Tree.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -1441,16 +1385,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       --  for a reverse iterator, Container.Last is the beginning.\n \n       return It : constant Iterator := (Limited_Controlled with S, null) do\n-         B := B + 1;\n+         Busy (S.Tree.TC);\n       end return;\n    end Iterate;\n \n    function Iterate (Container : Set; Start : Cursor)\n      return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       S : constant Set_Access := Container'Unrestricted_Access;\n-      B : Natural renames S.Tree.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1488,7 +1430,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       return It : constant Iterator :=\n                     (Limited_Controlled with S, Start.Node)\n       do\n-         B := B + 1;\n+         Busy (S.Tree.TC);\n       end return;\n    end Iterate;\n \n@@ -1701,25 +1643,9 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       declare\n          T : Tree_Type renames Position.Container.Tree;\n-\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n+         Lock : With_Lock (T.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Position.Node.Element.all);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (Position.Node.Element.all);\n       end;\n    end Query_Element;\n \n@@ -1792,10 +1718,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       then\n          null;\n       else\n-         if Tree.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Tree.TC);\n \n          declare\n             X : Element_Access := Node.Element;\n@@ -1914,22 +1837,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       end Process_Node;\n \n       T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-      B : Natural renames T.Busy;\n+      Busy : With_Busy (T.TC'Unrestricted_Access);\n \n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (T, Item);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Reverse_Iterate (T, Item);\n    end Reverse_Iterate;\n \n    procedure Reverse_Iterate\n@@ -1952,22 +1865,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       end Process_Node;\n \n       T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-      B : Natural renames T.Busy;\n+      Busy : With_Busy (T.TC'Unrestricted_Access);\n \n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (T);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Reverse_Iterate (T);\n    end Reverse_Iterate;\n \n    -----------"}, {"sha": "0663b67fec03b8be38d2c6e68302161e7d591cfd", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -472,7 +472,7 @@ private\n    overriding procedure Finalize (Container : in out Set) renames Clear;\n \n    use Red_Black_Trees;\n-   use Tree_Types;\n+   use Tree_Types, Tree_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -539,20 +539,15 @@ private\n \n    for Constant_Reference_Type'Write use Write;\n \n-   Empty_Set : constant Set :=\n-                 (Controlled with Tree => (First  => null,\n-                                           Last   => null,\n-                                           Root   => null,\n-                                           Length => 0,\n-                                           Busy   => 0,\n-                                           Lock   => 0));\n+   Empty_Set : constant Set := (Controlled with others => <>);\n \n    type Iterator is new Limited_Controlled and\n      Set_Iterator_Interfaces.Reversible_Iterator with\n    record\n       Container : Set_Access;\n       Node      : Node_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "62b7c432d4888f7f05e94605048aac59c3ade92c", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 138, "deletions": 266, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,6 +27,8 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Red_Black_Trees.Generic_Operations;\n pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Operations);\n \n@@ -44,6 +46,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -147,19 +153,19 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null then\n+      if Checks and then Left.Node.Element = null then\n          raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n-      if Right.Node.Element = null then\n+      if Checks and then Right.Node.Element = null then\n          raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n@@ -174,11 +180,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null then\n+      if Checks and then Left.Node.Element = null then\n          raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n@@ -190,11 +196,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n-      if Right.Node.Element = null then\n+      if Checks and then Right.Node.Element = null then\n          raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n@@ -237,19 +243,19 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null then\n+      if Checks and then Left.Node.Element = null then\n          raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n-      if Right.Node.Element = null then\n+      if Checks and then Right.Node.Element = null then\n          raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n@@ -266,11 +272,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null then\n+      if Checks and then Left.Node.Element = null then\n          raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n@@ -282,11 +288,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n-      if Right.Node.Element = null then\n+      if Checks and then Right.Node.Element = null then\n          raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n@@ -307,20 +313,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Adjust (Container.Tree);\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            Tree : Tree_Type renames Control.Container.all.Tree;\n-            B : Natural renames Tree.Busy;\n-            L : Natural renames Tree.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -377,16 +369,17 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n       end if;\n \n@@ -396,15 +389,14 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       declare\n          Tree : Tree_Type renames Position.Container.all.Tree;\n-         B : Natural renames Tree.Busy;\n-         L : Natural renames Tree.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           Tree.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -455,15 +447,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n@@ -478,12 +471,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    procedure Delete (Container : in out Set; Item : Element_Type) is\n       X : Node_Access := Element_Keys.Find (Container.Tree, Item);\n    begin\n-      if X = null then\n+      if Checks and then X = null then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n-      else\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n-         Free (X);\n       end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n+      Free (X);\n    end Delete;\n \n    ------------------\n@@ -535,11 +528,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n@@ -615,27 +608,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Tree.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            Tree : Tree_Type renames Control.Container.all.Tree;\n-            B : Natural renames Tree.Busy;\n-            L : Natural renames Tree.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.Tree.TC);\n       end if;\n    end Finalize;\n \n@@ -692,11 +665,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function First_Element (Container : Set) return Element_Type is\n    begin\n-      if Container.Tree.First = null then\n+      if Checks and then Container.Tree.First = null then\n          raise Constraint_Error with \"set is empty\";\n-      else\n-         return Container.Tree.First.Element.all;\n       end if;\n+\n+      return Container.Tree.First.Element.all;\n    end First_Element;\n \n    -----------\n@@ -770,24 +743,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n            Is_Less_Key_Node    => Is_Less_Key_Node,\n            Is_Greater_Key_Node => Is_Greater_Key_Node);\n \n-      ------------\n-      -- Adjust --\n-      ------------\n-\n-      procedure Adjust (Control : in out Reference_Control_Type) is\n-      begin\n-         if Control.Container /= null then\n-            declare\n-               Tree : Tree_Type renames Control.Container.Tree;\n-               B    : Natural renames Tree.Busy;\n-               L    : Natural renames Tree.Lock;\n-            begin\n-               B := B + 1;\n-               L := L + 1;\n-            end;\n-         end if;\n-      end Adjust;\n-\n       -------------\n       -- Ceiling --\n       -------------\n@@ -810,25 +765,24 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"Key not in set\";\n          end if;\n \n-         if Node.Element = null then\n+         if Checks and then Node.Element = null then\n             raise Program_Error with \"Node has no element\";\n          end if;\n \n          declare\n             Tree : Tree_Type renames Container'Unrestricted_Access.all.Tree;\n-            B : Natural renames Tree.Busy;\n-            L : Natural renames Tree.Lock;\n+            TC : constant Tamper_Counts_Access :=\n+              Tree.TC'Unrestricted_Access;\n          begin\n             return R : constant Constant_Reference_Type :=\n               (Element => Node.Element.all'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n+               Control => (Controlled with TC))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (TC.all);\n             end return;\n          end;\n       end Constant_Reference;\n@@ -850,7 +804,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          X : Node_Access := Key_Keys.Find (Container.Tree, Key);\n \n       begin\n-         if X = null then\n+         if Checks and then X = null then\n             raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n@@ -865,11 +819,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       function Element (Container : Set; Key : Key_Type) return Element_Type is\n          Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"key not in set\";\n-         else\n-            return Node.Element.all;\n          end if;\n+\n+         return Node.Element.all;\n       end Element;\n \n       ---------------------\n@@ -905,16 +859,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       procedure Finalize (Control : in out Reference_Control_Type) is\n       begin\n          if Control.Container /= null then\n-            declare\n-               Tree : Tree_Type renames Control.Container.Tree;\n-               B    : Natural renames Tree.Busy;\n-               L    : Natural renames Tree.Lock;\n-            begin\n-               B := B - 1;\n-               L := L - 1;\n-            end;\n+            Impl.Reference_Control_Type (Control).Finalize;\n \n-            if not (Key (Control.Pos) = Control.Old_Key.all) then\n+            if Checks and then not (Key (Control.Pos) = Control.Old_Key.all)\n+            then\n                Delete (Control.Container.all, Key (Control.Pos));\n                raise Program_Error;\n             end if;\n@@ -976,12 +924,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n-         if Position.Node = null then\n+         if Checks and then Position.Node = null then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Node.Element = null then\n+         if Checks and then Position.Node.Element = null then\n             raise Program_Error with\n               \"Position cursor is bad\";\n          end if;\n@@ -1004,7 +952,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with\n               \"attempt to replace key not in set\";\n          end if;\n@@ -1033,16 +981,17 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Position  : Cursor) return Reference_Type\n       is\n       begin\n-         if Position.Container = null then\n+         if Checks and then Position.Container = null then\n             raise Constraint_Error with \"Position cursor has no element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n          end if;\n \n-         if Position.Node.Element = null then\n+         if Checks and then Position.Node.Element = null then\n             raise Program_Error with \"Node has no element\";\n          end if;\n \n@@ -1052,19 +1001,17 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n          declare\n             Tree : Tree_Type renames Container.Tree;\n-            B    : Natural renames Tree.Busy;\n-            L    : Natural renames Tree.Lock;\n          begin\n             return R : constant Reference_Type :=\n               (Element   => Position.Node.Element.all'Unchecked_Access,\n                Control =>\n                  (Controlled with\n+                    Tree.TC'Unrestricted_Access,\n                     Container => Container'Access,\n                     Pos       => Position,\n                     Old_Key   => new Key_Type'(Key (Position))))\n          do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (Tree.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -1076,29 +1023,27 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"Key not in set\";\n          end if;\n \n-         if Node.Element = null then\n+         if Checks and then Node.Element = null then\n             raise Program_Error with \"Node has no element\";\n          end if;\n \n          declare\n             Tree : Tree_Type renames Container.Tree;\n-            B    : Natural renames Tree.Busy;\n-            L    : Natural renames Tree.Lock;\n          begin\n             return R : constant Reference_Type :=\n               (Element  => Node.Element.all'Unchecked_Access,\n                Control =>\n                  (Controlled with\n+                    Tree.TC'Unrestricted_Access,\n                     Container => Container'Access,\n                     Pos       => Find (Container, Key),\n                     Old_Key   => new Key_Type'(Key)))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (Tree.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -1116,15 +1061,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Tree : Tree_Type renames Container.Tree;\n \n       begin\n-         if Position.Node = null then\n+         if Checks and then Position.Node = null then\n             raise Constraint_Error with \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Node.Element = null then\n+         if Checks and then Position.Node.Element = null then\n             raise Program_Error with \"Position cursor is bad\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with \"Position cursor designates wrong set\";\n          end if;\n \n@@ -1134,30 +1080,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          declare\n             E : Element_Type renames Position.Node.Element.all;\n             K : constant Key_Type := Key (E);\n-\n-            B : Natural renames Tree.Busy;\n-            L : Natural renames Tree.Lock;\n-\n-            Eq : Boolean;\n-\n+            Lock : With_Lock (Tree.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Process (E);\n-               Eq := Equivalent_Keys (K, Key (E));\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n-\n-            L := L - 1;\n-            B := B - 1;\n-\n-            if Eq then\n+            Process (E);\n+            if Equivalent_Keys (K, Key (E)) then\n                return;\n             end if;\n          end;\n@@ -1186,6 +1112,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    end Generic_Keys;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1199,7 +1135,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    -- Include --\n    -------------\n \n-   procedure Include (Container : in out Set; New_Item  : Element_Type) is\n+   procedure Include (Container : in out Set; New_Item : Element_Type) is\n       Position : Cursor;\n       Inserted : Boolean;\n \n@@ -1209,10 +1145,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Tree.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Container.Tree.TC);\n \n          declare\n             --  The element allocator may need an accessibility check in the\n@@ -1258,7 +1191,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    begin\n       Insert (Container, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert element already in set\";\n       end if;\n@@ -1470,30 +1403,18 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       end Process_Node;\n \n       T : Tree_Type renames Container'Unrestricted_Access.all.Tree;\n-      B : Natural renames T.Busy;\n+      Busy : With_Busy (T.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (T);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (T);\n    end Iterate;\n \n    function Iterate\n      (Container : Set)\n       return Set_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Tree.Busy;\n-\n    begin\n       --  The value of the Node component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Node\n@@ -1510,7 +1431,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n                     Container => Container'Unrestricted_Access,\n                     Node      => null)\n       do\n-         B := B + 1;\n+         Busy (Container.Tree.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1519,8 +1440,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Start     : Cursor)\n       return Set_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Tree.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1533,12 +1452,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start = No_Element then\n+      if Checks and then Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n       end if;\n \n-      if Start.Container /= Container'Unrestricted_Access then\n+      if Checks and then Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong set\";\n       end if;\n@@ -1560,7 +1479,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n            Container => Container'Unrestricted_Access,\n            Node      => Start.Node)\n       do\n-         B := B + 1;\n+         Busy (Container.Tree.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1603,11 +1522,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Last_Element (Container : Set) return Element_Type is\n    begin\n-      if Container.Tree.Last = null then\n+      if Checks and then Container.Tree.Last = null then\n          raise Constraint_Error with \"set is empty\";\n-      else\n-         return Container.Tree.Last.Element.all;\n       end if;\n+\n+      return Container.Tree.Last.Element.all;\n    end Last_Element;\n \n    ----------\n@@ -1654,7 +1573,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n@@ -1678,7 +1597,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong set\";\n       end if;\n@@ -1719,7 +1638,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n@@ -1744,14 +1663,29 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong set\";\n       end if;\n \n       return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access :=\n+        Container.Tree.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1761,11 +1695,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Process   : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n@@ -1774,25 +1708,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       declare\n          T : Tree_Type renames Position.Container.Tree;\n-\n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n-\n+         Lock : With_Lock (T.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Position.Node.Element.all);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (Position.Node.Element.all);\n       end;\n    end Query_Element;\n \n@@ -1864,14 +1782,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       pragma Warnings (Off, X);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.Tree.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is locked)\";\n-      end if;\n+      TE_Check (Container.Tree.TC);\n \n       declare\n          --  The element allocator may need an accessibility check in the case\n@@ -1941,12 +1856,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       X : Element_Access := Node.Element;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      B : Natural renames Tree.Busy;\n-      L : Natural renames Tree.Lock;\n-\n    --  Start of processing for Replace_Element\n \n    begin\n@@ -1964,33 +1873,19 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       --  Determine whether Item is equivalent to element on the specified\n       --  node.\n \n+      declare\n+         Lock : With_Lock (Tree.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n          Compare := (if Item < Node.Element.all then False\n                      elsif Node.Element.all < Item then False\n                      else True);\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-\n-            raise;\n       end;\n \n       if Compare then\n          --  Item is equivalent to the node's element, so we will not have to\n          --  move the node.\n \n-         if Tree.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Tree.TC);\n \n          declare\n             --  The element allocator may need an accessibility check in the\n@@ -2019,26 +1914,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Hint := Element_Keys.Ceiling (Tree, Item);\n \n       if Hint /= null then\n+         declare\n+            Lock : With_Lock (Tree.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Compare := Item < Hint.Element.all;\n-\n-            L := L - 1;\n-            B := B - 1;\n-\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-\n-               raise;\n          end;\n \n          --  Item >= Hint.Element\n \n-         if not Compare then\n+         if Checks and then not Compare then\n \n             --  Ceiling returns an element that is equivalent or greater\n             --  than Item. If Item is \"not less than\" the element, then\n@@ -2069,10 +1953,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          --  because it would only be placed in the exact same position.\n \n          if Hint = Node then\n-            if Tree.Lock > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with elements (set is locked)\";\n-            end if;\n+            TE_Check (Tree.TC);\n \n             declare\n                --  The element allocator may need an accessibility check in the\n@@ -2118,15 +1999,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n      New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Node.Element = null then\n+      if Checks and then Position.Node.Element = null then\n          raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n@@ -2160,22 +2042,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       end Process_Node;\n \n       T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-      B : Natural renames T.Busy;\n+      Busy : With_Busy (T.TC'Unrestricted_Access);\n \n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Reverse_Iterate (T);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Reverse_Iterate (T);\n    end Reverse_Iterate;\n \n    -----------"}, {"sha": "e0e95ede1b363009bc28a029144c69e7667b9d19", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -33,6 +33,7 @@\n \n with Ada.Iterator_Interfaces;\n \n+private with Ada.Containers.Helpers;\n private with Ada.Containers.Red_Black_Trees;\n private with Ada.Finalization;\n private with Ada.Streams;\n@@ -298,17 +299,16 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n       type Key_Access is access all Key_Type;\n \n+      package Impl is new Helpers.Generic_Implementation;\n+\n       type Reference_Control_Type is\n-        new Ada.Finalization.Controlled with\n+        new Impl.Reference_Control_Type with\n       record\n          Container : Set_Access;\n          Pos       : Cursor;\n          Old_Key   : Key_Access;\n       end record;\n \n-      overriding procedure Adjust (Control : in out Reference_Control_Type);\n-      pragma Inline (Adjust);\n-\n       overriding procedure Finalize (Control : in out Reference_Control_Type);\n       pragma Inline (Finalize);\n \n@@ -338,7 +338,7 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   type Element_Access is access Element_Type;\n+   type Element_Access is access all Element_Type;\n \n    type Node_Type is limited record\n       Parent  : Node_Access;\n@@ -361,7 +361,7 @@ private\n    overriding procedure Finalize (Container : in out Set) renames Clear;\n \n    use Red_Black_Trees;\n-   use Tree_Types;\n+   use Tree_Types, Tree_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -397,16 +397,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Set_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -430,13 +422,23 @@ private\n \n    for Constant_Reference_Type'Write use Write;\n \n-   Empty_Set : constant Set :=\n-                 (Controlled with Tree => (First  => null,\n-                                           Last   => null,\n-                                           Root   => null,\n-                                           Length => 0,\n-                                           Busy   => 0,\n-                                           Lock   => 0));\n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n+   Empty_Set : constant Set := (Controlled with others => <>);\n \n    No_Element : constant Cursor := Cursor'(null, null);\n \n@@ -445,7 +447,8 @@ private\n    record\n       Container : Set_Access;\n       Node      : Node_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "4db39237e6c17b779c8f7b793dc7aa5529a99421", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 237, "deletions": 492, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,10 @@ package body Ada.Containers.Bounded_Vectors is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -89,7 +93,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  we must check the sum of the combined lengths. Note that we cannot\n       --  simply add the lengths, because of the possibility of overflow.\n \n-      if LN > Count_Type'Last - RN then\n+      if Checks and then LN > Count_Type'Last - RN then\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n@@ -115,7 +119,9 @@ package body Ada.Containers.Bounded_Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (N) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (N) < No_Index\n+         then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n@@ -127,7 +133,7 @@ package body Ada.Containers.Bounded_Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n@@ -139,7 +145,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n          J := Count_Type'Base (No_Index) + N;  -- Last\n \n-         if J > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then J > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n@@ -156,7 +162,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n          J := Count_Type'Base (Index_Type'Last) - N;  -- No_Index\n \n-         if J < Count_Type'Base (No_Index) then\n+         if Checks and then J < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n@@ -193,11 +199,11 @@ package body Ada.Containers.Bounded_Vectors is\n       --  constraints: the new length cannot exceed Count_Type'Last, and the\n       --  new Last index cannot exceed Index_Type'Last.\n \n-      if LN = Count_Type'Last then\n+      if Checks and then LN = Count_Type'Last then\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n-      if Left.Last >= Index_Type'Last then\n+      if Checks and then Left.Last >= Index_Type'Last then\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n@@ -221,11 +227,11 @@ package body Ada.Containers.Bounded_Vectors is\n       --  the new length cannot exceed Count_Type'Last, and the new Last index\n       --  cannot exceed Index_Type'Last.\n \n-      if RN = Count_Type'Last then\n+      if Checks and then RN = Count_Type'Last then\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n-      if Right.Last >= Index_Type'Last then\n+      if Checks and then Right.Last >= Index_Type'Last then\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n@@ -248,7 +254,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  know that that condition is satisfied), and the new Last index cannot\n       --  exceed Index_Type'Last.\n \n-      if Index_Type'First >= Index_Type'Last then\n+      if Checks and then Index_Type'First >= Index_Type'Last then\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n@@ -263,77 +269,25 @@ package body Ada.Containers.Bounded_Vectors is\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n-      BL : Natural renames Left'Unrestricted_Access.Busy;\n-      LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-      BR : Natural renames Right'Unrestricted_Access.Busy;\n-      LR : Natural renames Right'Unrestricted_Access.Lock;\n-\n-      Result : Boolean;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n+      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       if Left.Last /= Right.Last then\n          return False;\n       end if;\n \n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n-      Result := True;\n       for J in Count_Type range 1 .. Left.Length loop\n          if Left.Elements (J) /= Right.Elements (J) then\n-            Result := False;\n-            exit;\n+            return False;\n          end if;\n       end loop;\n \n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n+      return True;\n    end \"=\";\n \n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Vector renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -344,7 +298,7 @@ package body Ada.Containers.Bounded_Vectors is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error  -- ???\n            with \"Target capacity is less than Source length\";\n       end if;\n@@ -367,7 +321,7 @@ package body Ada.Containers.Bounded_Vectors is\n          return;\n       end if;\n \n-      if Container.Last >= Index_Type'Last then\n+      if Checks and then Container.Last >= Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n@@ -384,7 +338,7 @@ package body Ada.Containers.Bounded_Vectors is\n          return;\n       end if;\n \n-      if Container.Last >= Index_Type'Last then\n+      if Checks and then Container.Last >= Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n@@ -406,10 +360,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n    procedure Clear (Container : in out Vector) is\n    begin\n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       Container.Last := No_Index;\n    end Clear;\n@@ -423,30 +374,30 @@ package body Ada.Containers.Bounded_Vectors is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n-      if Position.Index > Position.Container.Last then\n+      if Checks and then Position.Index > Position.Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n       declare\n          A : Elements_Array renames Container.Elements;\n-         I : constant Count_Type := To_Array_Index (Position.Index);\n-         B : Natural renames Position.Container.Busy;\n-         L : Natural renames Position.Container.Lock;\n+         J : constant Count_Type := To_Array_Index (Position.Index);\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n-           (Element => A (I)'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+           (Element => A (J)'Access,\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -456,20 +407,21 @@ package body Ada.Containers.Bounded_Vectors is\n       Index     : Index_Type) return Constant_Reference_Type\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       declare\n          A : Elements_Array renames Container.Elements;\n-         I : constant Count_Type := To_Array_Index (Index);\n+         J : constant Count_Type := To_Array_Index (Index);\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n-           (Element => A (I)'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+           (Element => A (J)'Access,\n+            Control => (Controlled with TC))\n          do\n-            R.Control.Container.Busy := R.Control.Container.Busy + 1;\n-            R.Control.Container.Lock := R.Control.Container.Lock + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -503,7 +455,7 @@ package body Ada.Containers.Bounded_Vectors is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error\n            with \"Requested capacity is less than Source length\";\n       end if;\n@@ -549,7 +501,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  in the base range that immediately precede and immediately follow the\n       --  values in the Index_Type.)\n \n-      if Index < Index_Type'First then\n+      if Checks and then Index < Index_Type'First then\n          raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n \n@@ -561,7 +513,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  algorithm, so that case is treated as a proper error.)\n \n       if Index > Old_Last then\n-         if Index > Old_Last + 1 then\n+         if Checks and then Index > Old_Last + 1 then\n             raise Constraint_Error with \"Index is out of range (too large)\";\n          end if;\n \n@@ -581,10 +533,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  the count on exit. Delete checks the count to determine whether it is\n       --  being called while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  We first calculate what's available for deletion starting at\n       --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n@@ -641,15 +590,16 @@ package body Ada.Containers.Bounded_Vectors is\n       pragma Warnings (Off, Position);\n \n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n-      if Position.Index > Container.Last then\n+      if Checks and then Position.Index > Container.Last then\n          raise Program_Error with \"Position index is out of range\";\n       end if;\n \n@@ -703,10 +653,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  it is being called while the associated callback procedure is\n       --  executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  There is no restriction on how large Count can be when deleting\n       --  items. If it is equal or greater than the current length, then this\n@@ -739,7 +686,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Index     : Index_Type) return Element_Type\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       else\n          return Container.Elements (To_Array_Index (Index));\n@@ -748,7 +695,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       else\n          return Position.Container.Element (Position.Index);\n@@ -760,25 +707,8 @@ package body Ada.Containers.Bounded_Vectors is\n    --------------\n \n    procedure Finalize (Object : in out Iterator) is\n-      B : Natural renames Object.Container.Busy;\n    begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Vector renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n-      end if;\n+      Unbusy (Object.Container.TC);\n    end Finalize;\n \n    ----------\n@@ -792,11 +722,12 @@ package body Ada.Containers.Bounded_Vectors is\n    is\n    begin\n       if Position.Container /= null then\n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with \"Position cursor denotes wrong container\";\n          end if;\n \n-         if Position.Index > Container.Last then\n+         if Checks and then Position.Index > Container.Last then\n             raise Program_Error with \"Position index is out of range\";\n          end if;\n       end if;\n@@ -805,38 +736,15 @@ package body Ada.Containers.Bounded_Vectors is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Index_Type'Base;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := No_Index;\n          for J in Position.Index .. Container.Last loop\n             if Container.Elements (To_Array_Index (J)) = Item then\n-               Result := J;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, J);\n             end if;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = No_Index then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n+         return No_Element;\n       end;\n    end Find;\n \n@@ -849,37 +757,18 @@ package body Ada.Containers.Bounded_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-      L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-      Result : Index_Type'Base;\n-\n-   begin\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := No_Index;\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n+   begin\n       for Indx in Index .. Container.Last loop\n          if Container.Elements (To_Array_Index (Indx)) = Item then\n-            Result := Indx;\n-            exit;\n+            return Indx;\n          end if;\n       end loop;\n \n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return No_Index;\n    end Find_Index;\n \n    -----------\n@@ -924,11 +813,11 @@ package body Ada.Containers.Bounded_Vectors is\n \n    function First_Element (Container : Vector) return Element_Type is\n    begin\n-      if Container.Last = No_Index then\n+      if Checks and then Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n-      else\n-         return Container.Elements (To_Array_Index (Index_Type'First));\n       end if;\n+\n+      return Container.Elements (To_Array_Index (Index_Type'First));\n    end First_Element;\n \n    -----------------\n@@ -961,36 +850,16 @@ package body Ada.Containers.Bounded_Vectors is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n+            Lock : With_Lock (Container.TC'Unrestricted_Access);\n             EA : Elements_Array renames Container.Elements;\n-\n-            B : Natural renames Container'Unrestricted_Access.Busy;\n-            L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-            Result : Boolean;\n-\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            Result := True;\n             for J in 1 .. Container.Length - 1 loop\n                if EA (J + 1) < EA (J) then\n-                  Result := False;\n-                  exit;\n+                  return False;\n                end if;\n             end loop;\n \n-            B := B - 1;\n-            L := L - 1;\n-\n-            return Result;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-\n-               raise;\n+            return True;\n          end;\n       end Is_Sorted;\n \n@@ -1014,7 +883,7 @@ package body Ada.Containers.Bounded_Vectors is\n             return;\n          end if;\n \n-         if Target'Address = Source'Address then\n+         if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n          end if;\n@@ -1024,10 +893,7 @@ package body Ada.Containers.Bounded_Vectors is\n             return;\n          end if;\n \n-         if Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is busy)\";\n-         end if;\n+         TC_Check (Source.TC);\n \n          I := Target.Length;\n          Target.Set_Length (I + Source.Length);\n@@ -1039,19 +905,9 @@ package body Ada.Containers.Bounded_Vectors is\n             TA : Elements_Array renames Target.Elements;\n             SA : Elements_Array renames Source.Elements;\n \n-            TB : Natural renames Target.Busy;\n-            TL : Natural renames Target.Lock;\n-\n-            SB : Natural renames Source.Busy;\n-            SL : Natural renames Source.Lock;\n-\n+            Lock_Target : With_Lock (Target.TC'Unchecked_Access);\n+            Lock_Source : With_Lock (Source.TC'Unchecked_Access);\n          begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n-\n-            SB := SB + 1;\n-            SL := SL + 1;\n-\n             J := Target.Length;\n             while not Source.Is_Empty loop\n                pragma Assert (Source.Length <= 1\n@@ -1077,22 +933,6 @@ package body Ada.Containers.Bounded_Vectors is\n \n                J := J - 1;\n             end loop;\n-\n-            TB := TB - 1;\n-            TL := TL - 1;\n-\n-            SB := SB - 1;\n-            SL := SL - 1;\n-\n-         exception\n-            when others =>\n-               TB := TB - 1;\n-               TL := TL - 1;\n-\n-               SB := SB - 1;\n-               SL := SL - 1;\n-\n-               raise;\n          end;\n       end Merge;\n \n@@ -1124,38 +964,31 @@ package body Ada.Containers.Bounded_Vectors is\n          --  an artifact of our array-based implementation. Logically Sort\n          --  requires a check for cursor tampering.\n \n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is busy)\";\n-         end if;\n+         TC_Check (Container.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n+            Lock : With_Lock (Container.TC'Unchecked_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Sort (Container.Elements (1 .. Container.Length));\n-\n-            B := B - 1;\n-            L := L - 1;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-\n-               raise;\n          end;\n       end Sort;\n \n    end Generic_Sorting;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Elements\n+        (To_Array_Index (Position.Index))'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1199,7 +1032,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  in the base range that immediately precede and immediately follow the\n       --  values in the Index_Type.)\n \n-      if Before < Index_Type'First then\n+      if Checks and then Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n       end if;\n@@ -1211,7 +1044,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  deeper flaw in the caller's algorithm, so that case is treated as a\n       --  proper error.)\n \n-      if Before > Container.Last\n+      if Checks and then Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n          raise Constraint_Error with\n@@ -1231,7 +1064,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  count. Note that we cannot simply add these values, because of the\n       --  possibility of overflow.\n \n-      if Old_Length > Count_Type'Last - Count then\n+      if Checks and then Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -1340,7 +1173,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  an internal array with a last index value greater than\n       --  Index_Type'Last, with no way to index those elements).\n \n-      if New_Length > Max_Length then\n+      if Checks and then New_Length > Max_Length then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -1350,12 +1183,9 @@ package body Ada.Containers.Bounded_Vectors is\n       --  exit. Insert checks the count to determine whether it is being called\n       --  while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n-      if New_Length > Container.Capacity then\n+      if Checks and then New_Length > Container.Capacity then\n          raise Capacity_Error with \"New length is larger than capacity\";\n       end if;\n \n@@ -1462,7 +1292,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unchecked_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1475,7 +1305,7 @@ package body Ada.Containers.Bounded_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -1498,7 +1328,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unchecked_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1519,7 +1349,7 @@ package body Ada.Containers.Bounded_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -1544,7 +1374,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unchecked_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1557,7 +1387,7 @@ package body Ada.Containers.Bounded_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -1581,7 +1411,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unchecked_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1602,7 +1432,7 @@ package body Ada.Containers.Bounded_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -1672,7 +1502,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  in the base range that immediately precede and immediately follow the\n       --  values in the Index_Type.)\n \n-      if Before < Index_Type'First then\n+      if Checks and then Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n       end if;\n@@ -1684,7 +1514,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  deeper flaw in the caller's algorithm, so that case is treated as a\n       --  proper error.)\n \n-      if Before > Container.Last\n+      if Checks and then Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n          raise Constraint_Error with\n@@ -1704,7 +1534,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  Note that we cannot simply add these values, because of the\n       --  possibility of overflow.\n \n-      if Old_Length > Count_Type'Last - Count then\n+      if Checks and then Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -1813,7 +1643,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  an internal array with a last index value greater than\n       --  Index_Type'Last, with no way to index those elements).\n \n-      if New_Length > Max_Length then\n+      if Checks and then New_Length > Max_Length then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -1823,15 +1653,12 @@ package body Ada.Containers.Bounded_Vectors is\n       --  exit. Insert checks the count to determine whether it is being called\n       --  while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  An internal array has already been allocated, so we need to check\n       --  whether there is enough unused storage for the new items.\n \n-      if New_Length > Container.Capacity then\n+      if Checks and then New_Length > Container.Capacity then\n          raise Capacity_Error with \"New length is larger than capacity\";\n       end if;\n \n@@ -1870,7 +1697,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unchecked_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1891,7 +1718,7 @@ package body Ada.Containers.Bounded_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -1924,31 +1751,18 @@ package body Ada.Containers.Bounded_Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in Index_Type'First .. Container.Last loop\n-            Process (Cursor'(Container'Unrestricted_Access, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      for Indx in Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unrestricted_Access, Indx));\n+      end loop;\n    end Iterate;\n \n    function Iterate\n      (Container : Vector)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       V : constant Vector_Access := Container'Unrestricted_Access;\n-      B : Natural renames V.Busy;\n-\n    begin\n       --  The value of its Index component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Index\n@@ -1965,7 +1779,7 @@ package body Ada.Containers.Bounded_Vectors is\n            Container => V,\n            Index     => No_Index)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -1975,8 +1789,6 @@ package body Ada.Containers.Bounded_Vectors is\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       V : constant Vector_Access := Container'Unrestricted_Access;\n-      B : Natural renames V.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -1989,17 +1801,17 @@ package body Ada.Containers.Bounded_Vectors is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start.Container = null then\n+      if Checks and then Start.Container = null then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n       end if;\n \n-      if Start.Container /= V then\n+      if Checks and then Start.Container /= V then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong vector\";\n       end if;\n \n-      if Start.Index > V.Last then\n+      if Checks and then Start.Index > V.Last then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n       end if;\n@@ -2018,7 +1830,7 @@ package body Ada.Containers.Bounded_Vectors is\n            Container => V,\n            Index     => Start.Index)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -2063,11 +1875,11 @@ package body Ada.Containers.Bounded_Vectors is\n \n    function Last_Element (Container : Vector) return Element_Type is\n    begin\n-      if Container.Last = No_Index then\n+      if Checks and then Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n-      else\n-         return Container.Elements (Container.Length);\n       end if;\n+\n+      return Container.Elements (Container.Length);\n    end Last_Element;\n \n    ----------------\n@@ -2126,20 +1938,13 @@ package body Ada.Containers.Bounded_Vectors is\n          return;\n       end if;\n \n-      if Target.Capacity < Source.Length then\n+      if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error  -- ???\n            with \"Target capacity is less than Source length\";\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (Target is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (Source is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       --  Clear Target now, in case element assignment fails\n \n@@ -2171,12 +1976,14 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong vector\";\n-      else\n-         return Next (Position);\n       end if;\n+\n+      return Next (Position);\n    end Next;\n \n    procedure Next (Position : in out Cursor) is\n@@ -2241,14 +2048,30 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      end if;\n+\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong vector\";\n-      else\n-         return Previous (Position);\n       end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Vector'Class) return Reference_Control_Type\n+   is\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -2258,41 +2081,26 @@ package body Ada.Containers.Bounded_Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : Element_Type))\n    is\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n       V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-      L : Natural renames V.Lock;\n-\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      begin\n-         Process (V.Elements (To_Array_Index (Index)));\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n+      Process (V.Elements (To_Array_Index (Index)));\n    end Query_Element;\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      else\n-         Query_Element (Position.Container.all, Position.Index, Process);\n       end if;\n+\n+      Query_Element (Position.Container.all, Position.Index, Process);\n    end Query_Element;\n \n    ----------\n@@ -2353,28 +2161,31 @@ package body Ada.Containers.Bounded_Vectors is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n-      if Position.Index > Position.Container.Last then\n+      if Checks and then Position.Index > Position.Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n       declare\n          A : Elements_Array renames Container.Elements;\n-         B : Natural        renames Container.Busy;\n-         L : Natural        renames Container.Lock;\n          J : constant Count_Type := To_Array_Index (Position.Index);\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-         return (Element => A (J)'Access,\n-                 Control => (Controlled with Container'Unrestricted_Access));\n+         return R : constant Reference_Type :=\n+           (Element => A (J)'Access,\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n       end;\n    end Reference;\n \n@@ -2383,20 +2194,22 @@ package body Ada.Containers.Bounded_Vectors is\n       Index     : Index_Type) return Reference_Type\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       declare\n          A : Elements_Array renames Container.Elements;\n-         B : Natural        renames Container.Busy;\n-         L : Natural        renames Container.Lock;\n          J : constant Count_Type := To_Array_Index (Index);\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-         return (Element => A (J)'Access,\n-                 Control => (Controlled with Container'Unrestricted_Access));\n+         return R : constant Reference_Type :=\n+           (Element => A (J)'Access,\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n       end;\n    end Reference;\n \n@@ -2410,14 +2223,13 @@ package body Ada.Containers.Bounded_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n-      elsif Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      else\n-         Container.Elements (To_Array_Index (Index)) := New_Item;\n       end if;\n+\n+      TE_Check (Container.TC);\n+\n+      Container.Elements (To_Array_Index (Index)) := New_Item;\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -2426,22 +2238,22 @@ package body Ada.Containers.Bounded_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      elsif Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n \n-      elsif Position.Index > Container.Last then\n+      if Checks and then Position.Index > Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n \n-      elsif Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n+      TE_Check (Container.TC);\n \n-      else\n-         Container.Elements (To_Array_Index (Position.Index)) := New_Item;\n-      end if;\n+      Container.Elements (To_Array_Index (Position.Index)) := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -2453,7 +2265,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Capacity  : Count_Type)\n    is\n    begin\n-      if Capacity > Container.Capacity then\n+      if Checks and then Capacity > Container.Capacity then\n          raise Capacity_Error with \"Capacity is out of range\";\n       end if;\n    end Reserve_Capacity;\n@@ -2483,10 +2295,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  implementation. Logically Reverse_Elements requires a check for\n       --  cursor tampering.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       Idx := 1;\n       Jdx := Container.Length;\n@@ -2516,7 +2325,7 @@ package body Ada.Containers.Bounded_Vectors is\n       Last : Index_Type'Base;\n \n    begin\n-      if Position.Container /= null\n+      if Checks and then Position.Container /= null\n         and then Position.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n@@ -2531,38 +2340,15 @@ package body Ada.Containers.Bounded_Vectors is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Index_Type'Base;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := No_Index;\n          for Indx in reverse Index_Type'First .. Last loop\n             if Container.Elements (To_Array_Index (Indx)) = Item then\n-               Result := Indx;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Indx);\n             end if;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = No_Index then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n+         return No_Element;\n       end;\n    end Reverse_Find;\n \n@@ -2575,40 +2361,22 @@ package body Ada.Containers.Bounded_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-      L : Natural renames Container'Unrestricted_Access.Lock;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n \n       Last : constant Index_Type'Base :=\n         Index_Type'Min (Container.Last, Index);\n \n-      Result : Index_Type'Base;\n-\n    begin\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := No_Index;\n       for Indx in reverse Index_Type'First .. Last loop\n          if Container.Elements (To_Array_Index (Indx)) = Item then\n-            Result := Indx;\n-            exit;\n+            return Indx;\n          end if;\n       end loop;\n \n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return No_Index;\n    end Reverse_Find_Index;\n \n    ---------------------\n@@ -2619,23 +2387,11 @@ package body Ada.Containers.Bounded_Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in reverse Index_Type'First .. Container.Last loop\n-            Process (Cursor'(Container'Unrestricted_Access, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      for Indx in reverse Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unrestricted_Access, Indx));\n+      end loop;\n    end Reverse_Iterate;\n \n    ----------------\n@@ -2655,11 +2411,13 @@ package body Ada.Containers.Bounded_Vectors is\n \n       if Count >= 0 then\n          Container.Delete_Last (Count);\n-      elsif Container.Last >= Index_Type'Last then\n+      end if;\n+\n+      if Checks and then Container.Last >= Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n-      else\n-         Container.Insert_Space (Container.Last + 1, -Count);\n       end if;\n+\n+      Container.Insert_Space (Container.Last + 1, -Count);\n    end Set_Length;\n \n    ----------\n@@ -2670,22 +2428,19 @@ package body Ada.Containers.Bounded_Vectors is\n       E : Elements_Array renames Container.Elements;\n \n    begin\n-      if I > Container.Last then\n+      if Checks and then I > Container.Last then\n          raise Constraint_Error with \"I index is out of range\";\n       end if;\n \n-      if J > Container.Last then\n+      if Checks and then J > Container.Last then\n          raise Constraint_Error with \"J index is out of range\";\n       end if;\n \n       if I = J then\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          EI_Copy : constant Element_Type := E (To_Array_Index (I));\n@@ -2697,19 +2452,19 @@ package body Ada.Containers.Bounded_Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Cursor) is\n    begin\n-      if I.Container = null then\n+      if Checks and then I.Container = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if J.Container = null then\n+      if Checks and then J.Container = null then\n          raise Constraint_Error with \"J cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n+      if Checks and then I.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"I cursor denotes wrong container\";\n       end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n+      if Checks and then J.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"J cursor denotes wrong container\";\n       end if;\n \n@@ -2814,7 +2569,9 @@ package body Ada.Containers.Bounded_Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index\n+         then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2826,7 +2583,7 @@ package body Ada.Containers.Bounded_Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2838,7 +2595,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n          Index := Count_Type'Base (No_Index) + Length;  -- Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2855,7 +2612,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2903,7 +2660,9 @@ package body Ada.Containers.Bounded_Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index\n+         then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2915,7 +2674,7 @@ package body Ada.Containers.Bounded_Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2927,7 +2686,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n          Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2944,7 +2703,7 @@ package body Ada.Containers.Bounded_Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -2970,28 +2729,13 @@ package body Ada.Containers.Bounded_Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      B : Natural renames Container.Busy;\n-      L : Natural renames Container.Lock;\n-\n+      Lock : With_Lock (Container.TC'Unchecked_Access);\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      begin\n-         Process (Container.Elements (To_Array_Index (Index)));\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n+      Process (Container.Elements (To_Array_Index (Index)));\n    end Update_Element;\n \n    procedure Update_Element\n@@ -3000,11 +2744,12 @@ package body Ada.Containers.Bounded_Vectors is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n "}, {"sha": "1fb346c79723fd8b47b67df5bea943b39b1eaf94", "filename": "gcc/ada/a-cobove.ads", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cobove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cobove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -33,6 +33,7 @@\n \n with Ada.Iterator_Interfaces;\n \n+private with Ada.Containers.Helpers;\n private with Ada.Streams;\n private with Ada.Finalization;\n \n@@ -364,6 +365,10 @@ private\n    pragma Inline (Next);\n    pragma Inline (Previous);\n \n+   use Ada.Containers.Helpers;\n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    use Ada.Streams;\n    use Ada.Finalization;\n \n@@ -373,8 +378,7 @@ private\n    type Vector (Capacity : Count_Type) is tagged record\n       Elements : Elements_Array (1 .. Capacity) := (others => <>);\n       Last     : Extended_Index := No_Index;\n-      Busy     : Natural := 0;\n-      Lock     : Natural := 0;\n+      TC       : aliased Tamper_Counts;\n    end record;\n \n    procedure Write\n@@ -409,15 +413,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is new Controlled with record\n-      Container : Vector_Access;\n-   end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -461,6 +458,25 @@ private\n \n    for Reference_Type'Write use Write;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Vector'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Vector : constant Vector := (Capacity => 0, others => <>);\n \n    No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n@@ -470,7 +486,8 @@ private\n    record\n       Container : Vector_Access;\n       Index     : Index_Type'Base;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "969bf9be122baa0bbce55d7d34582561fa8a37a6", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 72, "deletions": 159, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -35,12 +35,18 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Hashed_Maps is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -123,20 +129,6 @@ package body Ada.Containers.Hashed_Maps is\n       HT_Ops.Adjust (Container.HT);\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            HT : Hash_Table_Type renames Control.Container.all.HT;\n-            B  : Natural renames HT.Busy;\n-            L  : Natural renames HT.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -199,12 +191,13 @@ package body Ada.Containers.Hashed_Maps is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n@@ -215,15 +208,14 @@ package body Ada.Containers.Hashed_Maps is\n \n       declare\n          HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n-         B  : Natural renames HT.Busy;\n-         L  : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element'Access,\n-            Control => (Controlled with Position.Container))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -236,20 +228,19 @@ package body Ada.Containers.Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n-         B  : Natural renames HT.Busy;\n-         L  : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Node.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -280,7 +271,7 @@ package body Ada.Containers.Hashed_Maps is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error\n            with \"Requested capacity is less than Source length\";\n       end if;\n@@ -316,7 +307,7 @@ package body Ada.Containers.Hashed_Maps is\n    begin\n       Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n-      if X = null then\n+      if Checks and then X = null then\n          raise Constraint_Error with \"attempt to delete key not in map\";\n       end if;\n \n@@ -325,20 +316,18 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n \n-      if Container.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"Delete attempted to tamper with cursors (map is busy)\";\n-      end if;\n+      TC_Check (Container.HT.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n@@ -357,7 +346,7 @@ package body Ada.Containers.Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with\n            \"no element available because key not in map\";\n       end if;\n@@ -367,7 +356,7 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of function Element equals No_Element\";\n       end if;\n@@ -395,12 +384,12 @@ package body Ada.Containers.Hashed_Maps is\n    function Equivalent_Keys (Left, Right : Cursor)\n      return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n@@ -413,7 +402,7 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n@@ -425,7 +414,7 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n@@ -458,27 +447,7 @@ package body Ada.Containers.Hashed_Maps is\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.HT.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            HT : Hash_Table_Type renames Control.Container.all.HT;\n-            B  : Natural renames HT.Busy;\n-            L  : Natural renames HT.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n+         Unbusy (Object.Container.HT.TC);\n       end if;\n    end Finalize;\n \n@@ -600,10 +569,7 @@ package body Ada.Containers.Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.HT.Lock > 0 then\n-            raise Program_Error with\n-              \"Include attempted to tamper with elements (map is locked)\";\n-         end if;\n+         TE_Check (Container.HT.TC);\n \n          Position.Node.Key := Key;\n          Position.Node.Element := New_Item;\n@@ -712,7 +678,7 @@ package body Ada.Containers.Hashed_Maps is\n    begin\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert key already in map\";\n       end if;\n@@ -749,33 +715,22 @@ package body Ada.Containers.Hashed_Maps is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n+      Busy : With_Busy (Container.HT.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Local_Iterate (Container.HT);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Local_Iterate (Container.HT);\n    end Iterate;\n \n    function Iterate\n      (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n    begin\n       return It : constant Iterator :=\n         (Limited_Controlled with Container => Container'Unrestricted_Access)\n       do\n-         B := B + 1;\n+         Busy (Container.HT.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -785,7 +740,7 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of function Key equals No_Element\";\n       end if;\n@@ -860,7 +815,7 @@ package body Ada.Containers.Hashed_Maps is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong map\";\n       end if;\n@@ -875,15 +830,11 @@ package body Ada.Containers.Hashed_Maps is\n    function Pseudo_Reference\n      (Container : aliased Map'Class) return Reference_Control_Type\n    is\n-      C : constant Map_Access := Container'Unrestricted_Access;\n-      B : Natural renames C.HT.Busy;\n-      L : Natural renames C.HT.Lock;\n+      TC : constant Tamper_Counts_Access :=\n+        Container.HT.TC'Unrestricted_Access;\n    begin\n-      return R : constant Reference_Control_Type :=\n-        (Controlled with C)\n-      do\n-         B := B + 1;\n-         L := L + 1;\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n       end return;\n    end Pseudo_Reference;\n \n@@ -897,7 +848,7 @@ package body Ada.Containers.Hashed_Maps is\n                    procedure (Key : Key_Type; Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n@@ -907,28 +858,11 @@ package body Ada.Containers.Hashed_Maps is\n       declare\n          M  : Map renames Position.Container.all;\n          HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n-\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n+         K : Key_Type renames Position.Node.Key;\n+         E : Element_Type renames Position.Node.Element;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            K : Key_Type renames Position.Node.Key;\n-            E : Element_Type renames Position.Node.Element;\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (K, E);\n       end;\n    end Query_Element;\n \n@@ -977,12 +911,13 @@ package body Ada.Containers.Hashed_Maps is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong map\";\n       end if;\n@@ -993,15 +928,14 @@ package body Ada.Containers.Hashed_Maps is\n \n       declare\n          HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n-         B  : Natural renames HT.Busy;\n-         L  : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Position.Node.Element'Access,\n-            Control => (Controlled with Position.Container))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1014,20 +948,19 @@ package body Ada.Containers.Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n-         B  : Natural renames HT.Busy;\n-         L  : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Reference_Type :=\n            (Element => Node.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Reference;\n@@ -1064,15 +997,12 @@ package body Ada.Containers.Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n       end if;\n \n-      if Container.HT.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace attempted to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Container.HT.TC);\n \n       Node.Key := Key;\n       Node.Element := New_Item;\n@@ -1088,20 +1018,18 @@ package body Ada.Containers.Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      if Position.Container.HT.Lock > 0 then\n-         raise Program_Error with\n-           \"Replace_Element attempted to tamper with elements (map is locked)\";\n-      end if;\n+      TE_Check (Position.Container.HT.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n@@ -1140,12 +1068,13 @@ package body Ada.Containers.Hashed_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor of Update_Element designates wrong map\";\n       end if;\n@@ -1154,27 +1083,11 @@ package body Ada.Containers.Hashed_Maps is\n \n       declare\n          HT : Hash_Table_Type renames Container.HT;\n-         B  : Natural renames HT.Busy;\n-         L  : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n+         K : Key_Type renames Position.Node.Key;\n+         E : Element_Type renames Position.Node.Element;\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         declare\n-            K : Key_Type renames Position.Node.Key;\n-            E : Element_Type renames Position.Node.Element;\n-         begin\n-            Process (K, E);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (K, E);\n       end;\n    end Update_Element;\n "}, {"sha": "c398812db768c811af9ee46d812fe615531e1eb7", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -337,7 +337,7 @@ private\n \n    overriding procedure Finalize (Container : in out Map);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -373,16 +373,8 @@ private\n \n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Map_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -440,21 +432,23 @@ private\n    --  container, and increments the Lock. Finalization of this object will\n    --  decrement the Lock.\n \n-   type Element_Access is access all Element_Type;\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n \n    function Get_Element_Access\n      (Position : Cursor) return not null Element_Access;\n    --  Returns a pointer to the element designated by Position.\n \n-   Empty_Map : constant Map := (Controlled with HT => (null, 0, 0, 0));\n+   Empty_Map : constant Map := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (Container => null, Node => null);\n \n    type Iterator is new Limited_Controlled and\n      Map_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Map_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding procedure Finalize (Object : in out Iterator);\n "}, {"sha": "125f6b0f483a3bc720904d6ab1b4f775c97b4b8e", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 102, "deletions": 304, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -35,6 +35,8 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n+with Ada.Containers.Helpers; use Ada.Containers.Helpers;\n+\n with Ada.Containers.Prime_Numbers;\n \n with System; use type System.Address;\n@@ -43,6 +45,10 @@ package body Ada.Containers.Hashed_Sets is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers.Helpers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -152,20 +158,6 @@ package body Ada.Containers.Hashed_Sets is\n       HT_Ops.Adjust (Container.HT);\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            HT : Hash_Table_Type renames Control.Container.all.HT;\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Assign --\n    ------------\n@@ -212,11 +204,12 @@ package body Ada.Containers.Hashed_Sets is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n       end if;\n@@ -225,15 +218,14 @@ package body Ada.Containers.Hashed_Sets is\n \n       declare\n          HT : Hash_Table_Type renames Position.Container.all.HT;\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         TC : constant Tamper_Counts_Access :=\n+           HT.TC'Unrestricted_Access;\n       begin\n          return R : constant Constant_Reference_Type :=\n            (Element => Position.Node.Element'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n+            Control => (Controlled with TC))\n          do\n-            B := B + 1;\n-            L := L + 1;\n+            Lock (TC.all);\n          end return;\n       end;\n    end Constant_Reference;\n@@ -264,7 +256,7 @@ package body Ada.Containers.Hashed_Sets is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error\n            with \"Requested capacity is less than Source length\";\n       end if;\n@@ -297,7 +289,7 @@ package body Ada.Containers.Hashed_Sets is\n    begin\n       Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n \n-      if X = null then\n+      if Checks and then X = null then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n@@ -309,18 +301,16 @@ package body Ada.Containers.Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      if Container.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Container.HT.TC);\n \n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n@@ -351,10 +341,7 @@ package body Ada.Containers.Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.HT.TC);\n \n       if Src_HT.Length < Target.HT.Length then\n          declare\n@@ -462,7 +449,7 @@ package body Ada.Containers.Hashed_Sets is\n             raise;\n       end Iterate_Left;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Difference;\n \n    -------------\n@@ -471,7 +458,7 @@ package body Ada.Containers.Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n@@ -496,12 +483,12 @@ package body Ada.Containers.Hashed_Sets is\n    function Equivalent_Elements (Left, Right : Cursor)\n      return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n@@ -529,7 +516,7 @@ package body Ada.Containers.Hashed_Sets is\n    function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n      return Boolean is\n    begin\n-      if Left.Node = null then\n+      if Checks and then Left.Node = null then\n          raise Constraint_Error with\n            \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n@@ -542,7 +529,7 @@ package body Ada.Containers.Hashed_Sets is\n    function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n      return Boolean is\n    begin\n-      if Right.Node = null then\n+      if Checks and then Right.Node = null then\n          raise Constraint_Error with\n            \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n@@ -587,30 +574,10 @@ package body Ada.Containers.Hashed_Sets is\n       HT_Ops.Finalize (Container.HT);\n    end Finalize;\n \n-   procedure Finalize (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            HT : Hash_Table_Type renames Control.Container.all.HT;\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n-      end if;\n-   end Finalize;\n-\n    procedure Finalize (Object : in out Iterator) is\n    begin\n       if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.HT.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n+         Unbusy (Object.Container.HT.TC);\n       end if;\n    end Finalize;\n \n@@ -766,10 +733,7 @@ package body Ada.Containers.Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (set is locked)\";\n-         end if;\n+         TE_Check (Container.HT.TC);\n \n          Position.Node.Element := New_Item;\n       end if;\n@@ -802,7 +766,7 @@ package body Ada.Containers.Hashed_Sets is\n    begin\n       Insert (Container, New_Item, Position, Inserted);\n \n-      if not Inserted then\n+      if Checks and then not Inserted then\n          raise Constraint_Error with\n            \"attempt to insert element already in set\";\n       end if;\n@@ -836,10 +800,7 @@ package body Ada.Containers.Hashed_Sets is\n          HT_Ops.Reserve_Capacity (HT, 1);\n       end if;\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (HT.TC);\n \n       Local_Insert (HT, New_Item, Node, Inserted);\n \n@@ -871,10 +832,7 @@ package body Ada.Containers.Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.HT.TC);\n \n       Tgt_Node := HT_Ops.First (Target.HT);\n       while Tgt_Node /= null loop\n@@ -960,7 +918,7 @@ package body Ada.Containers.Hashed_Sets is\n             raise;\n       end Iterate_Left;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Intersection;\n \n    --------------\n@@ -1036,30 +994,19 @@ package body Ada.Containers.Hashed_Sets is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+      Busy : With_Busy (Container.HT.TC'Unrestricted_Access);\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Iterate (Container.HT);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      Iterate (Container.HT);\n    end Iterate;\n \n    function Iterate\n      (Container : Set) return Set_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n    begin\n-      B := B + 1;\n+      Busy (Container.HT.TC'Unrestricted_Access.all);\n       return It : constant Iterator :=\n          Iterator'(Limited_Controlled with\n               Container => Container'Unrestricted_Access);\n@@ -1127,7 +1074,7 @@ package body Ada.Containers.Hashed_Sets is\n          return No_Element;\n       end if;\n \n-      if Position.Container /= Object.Container then\n+      if Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong set\";\n       end if;\n@@ -1171,15 +1118,11 @@ package body Ada.Containers.Hashed_Sets is\n    function Pseudo_Reference\n      (Container : aliased Set'Class) return Reference_Control_Type\n    is\n-      C : constant Set_Access := Container'Unrestricted_Access;\n-      B : Natural renames C.HT.Busy;\n-      L : Natural renames C.HT.Lock;\n-   begin\n-      return R : constant Reference_Control_Type :=\n-        (Controlled with C)\n-      do\n-         B := B + 1;\n-         L := L + 1;\n+      TC : constant Tamper_Counts_Access :=\n+        Container.HT.TC'Unrestricted_Access;\n+   begin\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n       end return;\n    end Pseudo_Reference;\n \n@@ -1192,7 +1135,7 @@ package body Ada.Containers.Hashed_Sets is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element equals No_Element\";\n       end if;\n@@ -1201,25 +1144,9 @@ package body Ada.Containers.Hashed_Sets is\n \n       declare\n          HT : Hash_Table_Type renames Position.Container.HT;\n-\n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n-\n+         Lock : With_Lock (HT.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         begin\n-            Process (Position.Node.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n-\n-         L := L - 1;\n-         B := B - 1;\n+         Process (Position.Node.Element);\n       end;\n    end Query_Element;\n \n@@ -1280,15 +1207,12 @@ package body Ada.Containers.Hashed_Sets is\n         Element_Keys.Find (Container.HT, New_Item);\n \n    begin\n-      if Node = null then\n+      if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.HT.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is locked)\";\n-      end if;\n+      TE_Check (Container.HT.TC);\n \n       Node.Element := New_Item;\n    end Replace;\n@@ -1299,12 +1223,13 @@ package body Ada.Containers.Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Node = null then\n+      if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor equals No_Element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      if Checks and then Position.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error with\n            \"Position cursor designates wrong set\";\n       end if;\n@@ -1345,26 +1270,13 @@ package body Ada.Containers.Hashed_Sets is\n    is\n       Tgt_HT : Hash_Table_Type renames Target.HT;\n       Src_HT : Hash_Table_Type renames Source.HT'Unrestricted_Access.all;\n-\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      TB : Natural renames Tgt_HT.Busy;\n-      TL : Natural renames Tgt_HT.Lock;\n-\n-      SB : Natural renames Src_HT.Busy;\n-      SL : Natural renames Src_HT.Lock;\n-\n    begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      if TB > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Tgt_HT.TC);\n \n       declare\n          N : constant Count_Type := Target.Length + Source.Length;\n@@ -1378,8 +1290,7 @@ package body Ada.Containers.Hashed_Sets is\n          Iterate_Source_When_Empty_Target : declare\n             procedure Process (Src_Node : Node_Access);\n \n-            procedure Iterate is\n-               new HT_Ops.Generic_Iteration (Process);\n+            procedure Iterate is new HT_Ops.Generic_Iteration (Process);\n \n             -------------\n             -- Process --\n@@ -1396,32 +1307,16 @@ package body Ada.Containers.Hashed_Sets is\n                N := N + 1;\n             end Process;\n \n-         --  Start of processing for Iterate_Source_When_Empty_Target\n+            --  Per AI05-0022, the container implementation is required to\n+            --  detect element tampering by a generic actual subprogram.\n \n-         begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n+            Lock_Tgt : With_Lock (Tgt_HT.TC'Unrestricted_Access);\n+            Lock_Src : With_Lock (Src_HT.TC'Unrestricted_Access);\n \n-            SB := SB + 1;\n-            SL := SL + 1;\n+         --  Start of processing for Iterate_Source_When_Empty_Target\n \n+         begin\n             Iterate (Src_HT);\n-\n-            SL := SL - 1;\n-            SB := SB - 1;\n-\n-            TL := TL - 1;\n-            TB := TB - 1;\n-\n-         exception\n-            when others =>\n-               SL := SL - 1;\n-               SB := SB - 1;\n-\n-               TL := TL - 1;\n-               TB := TB - 1;\n-\n-               raise;\n          end Iterate_Source_When_Empty_Target;\n \n       else\n@@ -1479,32 +1374,16 @@ package body Ada.Containers.Hashed_Sets is\n                end if;\n             end Process;\n \n-         --  Start of processing for Iterate_Source\n+            --  Per AI05-0022, the container implementation is required to\n+            --  detect element tampering by a generic actual subprogram.\n \n-         begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n+            Lock_Tgt : With_Lock (Tgt_HT.TC'Unrestricted_Access);\n+            Lock_Src : With_Lock (Src_HT.TC'Unrestricted_Access);\n \n-            SB := SB + 1;\n-            SL := SL + 1;\n+         --  Start of processing for Iterate_Source\n \n+         begin\n             Iterate (Src_HT);\n-\n-            SL := SL - 1;\n-            SB := SB - 1;\n-\n-            TL := TL - 1;\n-            TB := TB - 1;\n-\n-         exception\n-            when others =>\n-               SL := SL - 1;\n-               SB := SB - 1;\n-\n-               TL := TL - 1;\n-               TB := TB - 1;\n-\n-               raise;\n          end Iterate_Source;\n       end if;\n    end Symmetric_Difference;\n@@ -1621,7 +1500,7 @@ package body Ada.Containers.Hashed_Sets is\n             raise;\n       end Iterate_Right;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Symmetric_Difference;\n \n    ------------\n@@ -1692,10 +1571,7 @@ package body Ada.Containers.Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (set is busy)\";\n-      end if;\n+      TC_Check (Target.HT.TC);\n \n       declare\n          N : constant Count_Type := Target.Length + Source.Length;\n@@ -1757,25 +1633,14 @@ package body Ada.Containers.Hashed_Sets is\n          --  Checked_Index instead of a simple invocation of generic formal\n          --  Hash.\n \n-         B : Integer renames Left_HT.Busy;\n-         L : Integer renames Left_HT.Lock;\n+         Lock_Left : With_Lock (Left_HT.TC'Unrestricted_Access);\n \n       --  Start of processing for Iterate_Left\n \n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n          Iterate (Left_HT);\n-\n-         L := L - 1;\n-         B := B - 1;\n-\n       exception\n          when others =>\n-            L := L - 1;\n-            B := B - 1;\n-\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Left;\n@@ -1816,42 +1681,20 @@ package body Ada.Containers.Hashed_Sets is\n          --  Checked_Index instead of a simple invocation of generic formal\n          --  Hash.\n \n-         LB : Integer renames Left_HT.Busy;\n-         LL : Integer renames Left_HT.Lock;\n-\n-         RB : Integer renames Right_HT.Busy;\n-         RL : Integer renames Right_HT.Lock;\n+         Lock_Left : With_Lock (Left_HT.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right_HT.TC'Unrestricted_Access);\n \n       --  Start of processing for Iterate_Right\n \n       begin\n-         LB := LB + 1;\n-         LL := LL + 1;\n-\n-         RB := RB + 1;\n-         RL := RL + 1;\n-\n          Iterate (Right_HT);\n-\n-         RL := RL - 1;\n-         RB := RB - 1;\n-\n-         LL := LL - 1;\n-         LB := LB - 1;\n-\n       exception\n          when others =>\n-            RL := RL - 1;\n-            RB := RB - 1;\n-\n-            LL := LL - 1;\n-            LB := LB - 1;\n-\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Right;\n \n-      return (Controlled with HT => (Buckets, Length, 0, 0));\n+      return (Controlled with HT => (Buckets, Length, (Busy => 0, Lock => 0)));\n    end Union;\n \n    ---------\n@@ -1957,24 +1800,6 @@ package body Ada.Containers.Hashed_Sets is\n       -- Local Subprograms --\n       -----------------------\n \n-      ------------\n-      -- Adjust --\n-      ------------\n-\n-      procedure Adjust (Control : in out Reference_Control_Type) is\n-      begin\n-         if Control.Container /= null then\n-            declare\n-               HT : Hash_Table_Type renames Control.Container.all.HT;\n-               B : Natural renames HT.Busy;\n-               L : Natural renames HT.Lock;\n-            begin\n-               B := B + 1;\n-               L := L + 1;\n-            end;\n-         end if;\n-      end Adjust;\n-\n       function Equivalent_Key_Node\n         (Key  : Key_Type;\n          Node : Node_Access) return Boolean;\n@@ -2005,20 +1830,19 @@ package body Ada.Containers.Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"Key not in set\";\n          end if;\n \n          declare\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n+            TC : constant Tamper_Counts_Access :=\n+              HT.TC'Unrestricted_Access;\n          begin\n             return R : constant Constant_Reference_Type :=\n               (Element => Node.Element'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n+               Control => (Controlled with TC))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (TC.all);\n             end return;\n          end;\n       end Constant_Reference;\n@@ -2048,7 +1872,7 @@ package body Ada.Containers.Hashed_Sets is\n       begin\n          Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n-         if X = null then\n+         if Checks and then X = null then\n             raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n@@ -2067,7 +1891,7 @@ package body Ada.Containers.Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n@@ -2107,16 +1931,10 @@ package body Ada.Containers.Hashed_Sets is\n       procedure Finalize (Control : in out Reference_Control_Type) is\n       begin\n          if Control.Container /= null then\n-            declare\n-               HT : Hash_Table_Type renames Control.Container.all.HT;\n-               B  : Natural renames HT.Busy;\n-               L  : Natural renames HT.Lock;\n-            begin\n-               B := B - 1;\n-               L := L - 1;\n-            end;\n+            Impl.Reference_Control_Type (Control).Finalize;\n \n-            if Hash (Key (Element (Control.Old_Pos))) /= Control.Old_Hash\n+            if Checks and then\n+              Hash (Key (Element (Control.Old_Pos))) /= Control.Old_Hash\n             then\n                HT_Ops.Delete_Node_At_Index\n                  (Control.Container.HT, Control.Index, Control.Old_Pos.Node);\n@@ -2151,7 +1969,7 @@ package body Ada.Containers.Hashed_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n-         if Position.Node = null then\n+         if Checks and then Position.Node = null then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n@@ -2182,11 +2000,12 @@ package body Ada.Containers.Hashed_Sets is\n          Position  : Cursor) return Reference_Type\n       is\n       begin\n-         if Position.Container = null then\n+         if Checks and then Position.Container = null then\n             raise Constraint_Error with \"Position cursor has no element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n          end if;\n@@ -2197,20 +2016,18 @@ package body Ada.Containers.Hashed_Sets is\n \n          declare\n             HT : Hash_Table_Type renames Position.Container.all.HT;\n-            B  : Natural renames HT.Busy;\n-            L  : Natural renames HT.Lock;\n          begin\n             return R : constant Reference_Type :=\n                          (Element => Position.Node.Element'Access,\n                           Control =>\n                             (Controlled with\n+                              HT.TC'Unrestricted_Access,\n                               Container'Unrestricted_Access,\n                               Index    => HT_Ops.Index (HT, Position.Node),\n                               Old_Pos  => Position,\n                               Old_Hash => Hash (Key (Position))))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (HT.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -2222,27 +2039,25 @@ package body Ada.Containers.Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n          declare\n             HT : Hash_Table_Type renames Container.HT;\n-            B  : Natural renames HT.Busy;\n-            L  : Natural renames HT.Lock;\n             P  : constant Cursor := Find (Container, Key);\n          begin\n             return R : constant Reference_Type :=\n                          (Element => Node.Element'Access,\n                           Control =>\n                             (Controlled with\n+                              HT.TC'Unrestricted_Access,\n                               Container'Unrestricted_Access,\n                               Index    => HT_Ops.Index (HT, P.Node),\n                               Old_Pos  => P,\n                               Old_Hash => Hash (Key)))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (HT.TC);\n             end return;\n          end;\n       end Reference_Preserving_Key;\n@@ -2259,7 +2074,7 @@ package body Ada.Containers.Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n \n       begin\n-         if Node = null then\n+         if Checks and then Node = null then\n             raise Constraint_Error with\n               \"attempt to replace key not in set\";\n          end if;\n@@ -2281,20 +2096,22 @@ package body Ada.Containers.Hashed_Sets is\n          Indx : Hash_Type;\n \n       begin\n-         if Position.Node = null then\n+         if Checks and then Position.Node = null then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         if Checks and then Position.Container /= Container'Unrestricted_Access\n+         then\n             raise Program_Error with\n               \"Position cursor designates wrong set\";\n          end if;\n \n-         if HT.Buckets = null\n-           or else HT.Buckets'Length = 0\n-           or else HT.Length = 0\n-           or else Position.Node.Next = Position.Node\n+         if Checks and then\n+           (HT.Buckets = null\n+              or else HT.Buckets'Length = 0\n+              or else HT.Length = 0\n+              or else Position.Node.Next = Position.Node)\n          then\n             raise Program_Error with \"Position cursor is bad (set is empty)\";\n          end if;\n@@ -2309,31 +2126,12 @@ package body Ada.Containers.Hashed_Sets is\n          declare\n             E : Element_Type renames Position.Node.Element;\n             K : constant Key_Type := Key (E);\n-\n-            B : Natural renames HT.Busy;\n-            L : Natural renames HT.Lock;\n-\n-            Eq : Boolean;\n-\n+            Lock : With_Lock (HT.TC'Unrestricted_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            begin\n-               Indx := HT_Ops.Index (HT, Position.Node);\n-               Process (E);\n-               Eq := Equivalent_Keys (K, Key (E));\n-            exception\n-               when others =>\n-                  L := L - 1;\n-                  B := B - 1;\n-                  raise;\n-            end;\n-\n-            L := L - 1;\n-            B := B - 1;\n+            Indx := HT_Ops.Index (HT, Position.Node);\n+            Process (E);\n \n-            if Eq then\n+            if Equivalent_Keys (K, Key (E)) then\n                return;\n             end if;\n          end;\n@@ -2349,7 +2147,7 @@ package body Ada.Containers.Hashed_Sets is\n                while Prev.Next /= Position.Node loop\n                   Prev := Prev.Next;\n \n-                  if Prev = null then\n+                  if Checks and then Prev = null then\n                      raise Program_Error with\n                        \"Position cursor is bad (node not found)\";\n                   end if;"}, {"sha": "91f134539435713d196ebce69fe7da771c3a78d5", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -34,6 +34,7 @@\n with Ada.Iterator_Interfaces;\n \n private with Ada.Containers.Hash_Tables;\n+private with Ada.Containers.Helpers;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n@@ -451,18 +452,17 @@ package Ada.Containers.Hashed_Sets is\n       --  in that case the check that buckets have not changed is performed\n       --  at the time of the update, not when the reference is finalized.\n \n+      package Impl is new Helpers.Generic_Implementation;\n+\n       type Reference_Control_Type is\n-         new Ada.Finalization.Controlled with\n+         new Impl.Reference_Control_Type with\n       record\n          Container : Set_Access;\n          Index     : Hash_Type;\n          Old_Pos   : Cursor;\n          Old_Hash  : Hash_Type;\n       end record;\n \n-      overriding procedure Adjust (Control : in out Reference_Control_Type);\n-      pragma Inline (Adjust);\n-\n       overriding procedure Finalize (Control : in out Reference_Control_Type);\n       pragma Inline (Finalize);\n \n@@ -505,7 +505,7 @@ private\n \n    overriding procedure Finalize (Container : in out Set);\n \n-   use HT_Types;\n+   use HT_Types, HT_Types.Implementation;\n    use Ada.Finalization;\n    use Ada.Streams;\n \n@@ -529,10 +529,6 @@ private\n       Node      : Node_Access;\n    end record;\n \n-   type Reference_Control_Type is new Ada.Finalization.Controlled with record\n-      Container : Set_Access;\n-   end record;\n-\n    procedure Write\n      (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor);\n@@ -545,11 +541,8 @@ private\n \n    for Cursor'Read use Read;\n \n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -585,21 +578,23 @@ private\n    --  container, and increments the Lock. Finalization of this object will\n    --  decrement the Lock.\n \n-   type Element_Access is access all Element_Type;\n+   type Element_Access is access all Element_Type with\n+     Storage_Size => 0;\n \n    function Get_Element_Access\n      (Position : Cursor) return not null Element_Access;\n    --  Returns a pointer to the element designated by Position.\n \n-   Empty_Set : constant Set := (Controlled with HT => (null, 0, 0, 0));\n+   Empty_Set : constant Set := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (Container => null, Node => null);\n \n-   type Iterator is new Limited_Controlled\n-     and Set_Iterator_Interfaces.Forward_Iterator with\n+   type Iterator is new Limited_Controlled and\n+     Set_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Set_Access;\n-   end record;\n+   end record\n+     with Disable_Controlled => not T_Check;\n \n    overriding function First (Object : Iterator) return Cursor;\n "}, {"sha": "c83e8c0081c4dca1864f17f0d60ef51997c07554", "filename": "gcc/ada/a-cohata.ads", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohata.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-cohata.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohata.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,8 @@\n --  This package declares the hash-table type used to implement hashed\n --  containers.\n \n+with Ada.Containers.Helpers;\n+\n package Ada.Containers.Hash_Tables is\n    pragma Pure;\n    --  Declare Pure so this can be imported by Remote_Types packages\n@@ -40,23 +42,26 @@ package Ada.Containers.Hash_Tables is\n       type Node_Access is access Node_Type;\n \n    package Generic_Hash_Table_Types is\n+\n       type Buckets_Type is array (Hash_Type range <>) of Node_Access;\n \n       type Buckets_Access is access all Buckets_Type;\n       for Buckets_Access'Storage_Size use 0;\n       --  Storage_Size of zero so this package can be Pure\n \n       type Hash_Table_Type is tagged record\n-         Buckets : Buckets_Access;\n+         Buckets : Buckets_Access := null;\n          Length  : Count_Type := 0;\n-         Busy    : Natural    := 0;\n-         Lock    : Natural    := 0;\n+         TC      : aliased Helpers.Tamper_Counts;\n       end record;\n+\n+      package Implementation is new Helpers.Generic_Implementation;\n    end Generic_Hash_Table_Types;\n \n    generic\n       type Node_Type is private;\n    package Generic_Bounded_Hash_Table_Types is\n+\n       type Nodes_Type is array (Count_Type range <>) of Node_Type;\n       type Buckets_Type is array (Hash_Type range <>) of Count_Type;\n \n@@ -65,12 +70,13 @@ package Ada.Containers.Hash_Tables is\n          Modulus  : Hash_Type) is\n       tagged record\n          Length  : Count_Type                  := 0;\n-         Busy    : Natural                     := 0;\n-         Lock    : Natural                     := 0;\n+         TC      : aliased Helpers.Tamper_Counts;\n          Free    : Count_Type'Base             := -1;\n          Nodes   : Nodes_Type (1 .. Capacity)  := (others => <>);\n          Buckets : Buckets_Type (1 .. Modulus) := (others => 0);\n       end record;\n+\n+      package Implementation is new Helpers.Generic_Implementation;\n    end Generic_Bounded_Hash_Table_Types;\n \n end Ada.Containers.Hash_Tables;"}, {"sha": "106178a02bf27ce11b1931deb3d97189ac55f9a9", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 45, "deletions": 69, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87", "patch": "@@ -38,7 +38,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n    pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n-   --  See comment in Ada.Containers\n+   --  See comment in Ada.Containers.Helpers\n \n    procedure Free is\n      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n@@ -304,25 +304,19 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n       end if;\n \n-      if T_Check then\n-         declare\n-            TC : constant Tamper_Counts_Access :=\n-              Container.TC'Unrestricted_Access;\n-         begin\n-            --  The following will raise Constraint_Error if Element is null\n-\n-            return R : constant Constant_Reference_Type :=\n-              (Element => Container.Elements.EA (Position.Index),\n-               Control => (Controlled with TC))\n-            do\n-               Lock (TC.all);\n-            end return;\n-         end;\n-      else\n+      declare\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         --  The following will raise Constraint_Error if Element is null\n+\n          return R : constant Constant_Reference_Type :=\n            (Element => Container.Elements.EA (Position.Index),\n-            Control => (Controlled with null));\n-      end if;\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Constant_Reference;\n \n    function Constant_Reference\n@@ -334,25 +328,19 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if T_Check then\n-         declare\n-            TC : constant Tamper_Counts_Access :=\n-              Container.TC'Unrestricted_Access;\n-         begin\n-            --  The following will raise Constraint_Error if Element is null\n-\n-            return R : constant Constant_Reference_Type :=\n-              (Element => Container.Elements.EA (Index),\n-               Control => (Controlled with TC))\n-            do\n-               Lock (TC.all);\n-            end return;\n-         end;\n-      else\n+      declare\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         --  The following will raise Constraint_Error if Element is null\n+\n          return R : constant Constant_Reference_Type :=\n            (Element => Container.Elements.EA (Index),\n-            Control => (Controlled with null));\n-      end if;\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Constant_Reference;\n \n    --------------\n@@ -2700,25 +2688,19 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n       end if;\n \n-      if T_Check then\n-         declare\n-            TC : constant Tamper_Counts_Access :=\n-              Container.TC'Unrestricted_Access;\n-         begin\n-            --  The following will raise Constraint_Error if Element is null\n-\n-            return R : constant Reference_Type :=\n-              (Element => Container.Elements.EA (Position.Index),\n-               Control => (Controlled with TC))\n-            do\n-               Lock (TC.all);\n-            end return;\n-         end;\n-      else\n+      declare\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         --  The following will raise Constraint_Error if Element is null\n+\n          return R : constant Reference_Type :=\n            (Element => Container.Elements.EA (Position.Index),\n-            Control => (Controlled with null));\n-      end if;\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Reference;\n \n    function Reference\n@@ -2730,25 +2712,19 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if T_Check then\n-         declare\n-            TC : constant Tamper_Counts_Access :=\n-              Container.TC'Unrestricted_Access;\n-         begin\n-            --  The following will raise Constraint_Error if Element is null\n-\n-            return R : constant Reference_Type :=\n-              (Element => Container.Elements.EA (Index),\n-               Control => (Controlled with TC))\n-            do\n-               Lock (TC.all);\n-            end return;\n-         end;\n-      else\n+      declare\n+         TC : constant Tamper_Counts_Access :=\n+           Container.TC'Unrestricted_Access;\n+      begin\n+         --  The following will raise Constraint_Error if Element is null\n+\n          return R : constant Reference_Type :=\n            (Element => Container.Elements.EA (Index),\n-            Control => (Controlled with null));\n-      end if;\n+            Control => (Controlled with TC))\n+         do\n+            Lock (TC.all);\n+         end return;\n+      end;\n    end Reference;\n \n    ---------------------"}, {"sha": "08aa4c9f5b4ef4933621697a94e2291d4df1b813", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "918edfdd8aa52ee6c6905b75a21442a9d4f7b41a", "filename": "gcc/ada/a-comutr.ads", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "f433250000abecbc2f55ba5c9bf374cfe1c599cb", "filename": "gcc/ada/a-conhel.adb", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-conhel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-conhel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-conhel.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "cae5fa0180a4f2833e1a8fde471f86d9d2c4707d", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 37, "deletions": 61, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "3ad48e6a074f03faf954d9e064f9595030446121", "filename": "gcc/ada/a-coorma.adb", "status": "modified", "additions": 92, "deletions": 193, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "5687780318713541d1b08b0203142d44942c1e48", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "1b9852f0975a834d2178668f24aaf1a453eebefa", "filename": "gcc/ada/a-coormu.adb", "status": "modified", "additions": 24, "deletions": 121, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "db47c19f676cf22c4227abe3afcbaa31ccf49fa4", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "a92ed7f704a2892d1a6c627edd301f28bfb1227a", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 91, "deletions": 250, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "d2e882a7f8241e39b3e732c993b2fc57be52d903", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "73ed9ae6741f63acb23ca28381ac9fa5baa310b0", "filename": "gcc/ada/a-crbltr.ads", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbltr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbltr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbltr.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "10a9e92ba0deae781a1fc0824efb0c85b6ed9ac8", "filename": "gcc/ada/a-crbtgk.adb", "status": "modified", "additions": 36, "deletions": 174, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "c93dfe7ba6a35e1650f0fe0f4f014eb2a0204a92", "filename": "gcc/ada/a-crbtgk.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "e656295f68365e48e9471fe846c673cc7455be4c", "filename": "gcc/ada/a-crbtgo.adb", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "4c197417ae65b326df3adcaf81af550173aff483", "filename": "gcc/ada/a-crbtgo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-crbtgo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "abf7773522a75556ac216ff05d1722189313876c", "filename": "gcc/ada/a-rbtgbk.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbk.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "1cf1cbc9cc48e6102da0bcbf4e50e729d653586b", "filename": "gcc/ada/a-rbtgbk.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbk.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "b75974065d25adcae2e2bc443eb1839a2cbcda7d", "filename": "gcc/ada/a-rbtgbo.adb", "status": "modified", "additions": 15, "deletions": 53, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbo.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "2f8b7835582470797643f6085158da3873ea7e02", "filename": "gcc/ada/a-rbtgbo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbo.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "f6daa90ff1d09050bd9d99b33888c604ab7477e4", "filename": "gcc/ada/a-rbtgso.adb", "status": "modified", "additions": 37, "deletions": 281, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgso.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "9ad296fe090b2e8d2a4448fa62eb689155f5c8d1", "filename": "gcc/ada/a-rbtgso.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fa-rbtgso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgso.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "ac0a09e0bbc7ee8df202d4fbfc1f32f4b6450675", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=14f732114eaf16771c0f3865b678e491838fdc87"}, {"sha": "95624e69401081d7509050301f9ada3be5ae4e11", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f732114eaf16771c0f3865b678e491838fdc87/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=14f732114eaf16771c0f3865b678e491838fdc87"}]}