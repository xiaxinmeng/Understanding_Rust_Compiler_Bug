{"sha": "448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ4NTQ1Y2I1MWJkZjNkNzRjM2Q3NWYzYjg4ZGJmOGM3YThkZTk4NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-03-17T23:31:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-03-17T23:31:18Z"}, "message": "decl.c (grokfndecl): Set DECL_CONTEXT on parms.\n\n        cp/:\n        * decl.c (grokfndecl): Set DECL_CONTEXT on parms.\n        (duplicate_decls): Adjust DECL_CONTEXT of newdecl's parms.\n        * pt.c (check_explicit_specialization): Likewise.\n        (tsubst_copy) [PARM_DECL]: Return a dummy parm if we don't have a\n        local specialization.\n        * tree.c (cp_tree_equal) [PARM_DECL]: Check type and index, not name.\n        * decl2.c (parm_index): New fn.\n        * semantics.c (finish_decltype_type): Don't use describable_type.\n        * mangle.c (write_expression): Likewise.  Mangle ALIGNOF_EXPR.\n        Give a sorry for unsupported codes rather than crash.  Mangle\n        conversions with other than 1 operand.  New mangling for PARM_DECL.\n        * operators.def (ALIGNOF_EXPR): Mangle as az.\n  \n        * include/demangle.h (enum demangle_component_type): Add\n        DEMANGLE_COMPONENT_FUNCTION_PARAM.\n        * libiberty/cp-demangle.c (d_make_function_param): new fn.\n        (cplus_demangle_mangled_name): Work around abi v2 bug.\n        (d_expr_primary): Likewise.\n        (cplus_demangle_operators): Add alignof ops.\n        (d_expression): Handle function parameters and conversions\n        with other than 1 operand.\n        (d_print_comp): Handle function parameters.  Fix bug with\n        function used in type of function.\n\nFrom-SVN: r144924", "tree": {"sha": "a0bf6190acd7e4997d3304c4bfe60c3c1b461532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0bf6190acd7e4997d3304c4bfe60c3c1b461532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0075846f90cb2f586f7600d1dd1d522de9dbc00f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0075846f90cb2f586f7600d1dd1d522de9dbc00f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0075846f90cb2f586f7600d1dd1d522de9dbc00f"}], "stats": {"total": 319, "additions": 231, "deletions": 88}, "files": [{"sha": "1f5dd9d75f50b5581062af890e8f7a2bb34da987", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -1,3 +1,18 @@\n+2009-03-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* decl.c (grokfndecl): Set DECL_CONTEXT on parms.\n+\t(duplicate_decls): Adjust DECL_CONTEXT of newdecl's parms.\n+\t* pt.c (check_explicit_specialization): Likewise.\n+\t(tsubst_copy) [PARM_DECL]: Return a dummy parm if we don't have a\n+\tlocal specialization.\n+\t* tree.c (cp_tree_equal) [PARM_DECL]: Check type and index, not name.\n+\t* decl2.c (parm_index): New fn.\n+\t* semantics.c (finish_decltype_type): Don't use describable_type.\n+\t* mangle.c (write_expression): Likewise.  Mangle ALIGNOF_EXPR.\n+\tGive a sorry for unsupported codes rather than crash.  Mangle\n+\tconversions with other than 1 operand.  New mangling for PARM_DECL.\n+\t* operators.def (ALIGNOF_EXPR): Mangle as \"az\".\n+\n 2009-03-17  Jing Yu  <jingyu@google.com>\n \n \tPR middle-end/39378"}, {"sha": "1745ede53c38cc16e3d83b020b2fc357f9b912c0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -4436,6 +4436,7 @@ extern bool decl_needed_p\t\t\t(tree);\n extern void note_vague_linkage_fn\t\t(tree);\n extern tree build_artificial_parm\t\t(tree, tree);\n extern bool possibly_inlined_p\t\t\t(tree);\n+extern int parm_index                           (tree);\n \n /* in error.c */\n extern void init_error\t\t\t\t(void);"}, {"sha": "9a6ab02e36eeb1478607d85dbfca18f7bb7b1b46", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -1684,8 +1684,14 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    = DECL_SOURCE_LOCATION (newdecl);\n \t  DECL_INITIAL (old_result) = DECL_INITIAL (new_result);\n \t  if (DECL_FUNCTION_TEMPLATE_P (newdecl))\n-\t    DECL_ARGUMENTS (old_result)\n-\t      = DECL_ARGUMENTS (new_result);\n+\t    {\n+\t      tree parm;\n+\t      DECL_ARGUMENTS (old_result)\n+\t\t= DECL_ARGUMENTS (new_result);\n+\t      for (parm = DECL_ARGUMENTS (old_result); parm;\n+\t\t   parm = TREE_CHAIN (parm))\n+\t\tDECL_CONTEXT (parm) = old_result;\n+\t    }\n \t}\n \n       return olddecl;\n@@ -1918,6 +1924,8 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n+      tree parm;\n+\n       if (DECL_TEMPLATE_INSTANTIATION (olddecl)\n \t  && !DECL_TEMPLATE_INSTANTIATION (newdecl))\n \t{\n@@ -1974,6 +1982,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       /* Preserve abstractness on cloned [cd]tors.  */\n       DECL_ABSTRACT (newdecl) = DECL_ABSTRACT (olddecl);\n \n+      /* Update newdecl's parms to point at olddecl.  */\n+      for (parm = DECL_ARGUMENTS (newdecl); parm;\n+\t   parm = TREE_CHAIN (parm))\n+\tDECL_CONTEXT (parm) = olddecl;\n+\n       if (! types_match)\n \t{\n \t  SET_DECL_LANGUAGE (olddecl, DECL_LANGUAGE (newdecl));\n@@ -2006,7 +2019,8 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    }\n \n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n-\t  /* Don't clear out the arguments if we're redefining a function.  */\n+\t  /* Don't clear out the arguments if we're just redeclaring a\n+\t     function.  */\n \t  if (DECL_ARGUMENTS (olddecl))\n \t    DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n \t}\n@@ -6555,6 +6569,8 @@ grokfndecl (tree ctype,\n       parms = parm;\n     }\n   DECL_ARGUMENTS (decl) = parms;\n+  for (t = parms; t; t = TREE_CHAIN (t))\n+    DECL_CONTEXT (t) = decl;\n   /* Propagate volatile out from type to decl.  */\n   if (TYPE_VOLATILE (type))\n     TREE_THIS_VOLATILE (decl) = 1;"}, {"sha": "deba8b4e01c2ae4048f8b2afa260cfeb97774e47", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -3907,4 +3907,27 @@ mark_used (tree decl)\n   processing_template_decl = saved_processing_template_decl;\n }\n \n+/* Given function PARM_DECL PARM, return its index in the function's list\n+   of parameters, beginning with 1.  */\n+\n+int\n+parm_index (tree parm)\n+{\n+  int index;\n+  tree arg;\n+\n+  for (index = 1, arg = DECL_ARGUMENTS (DECL_CONTEXT (parm));\n+       arg;\n+       ++index, arg = TREE_CHAIN (arg))\n+    {\n+      if (DECL_NAME (parm) == DECL_NAME (arg))\n+\tbreak;\n+      if (DECL_ARTIFICIAL (arg))\n+\t--index;\n+    }\n+\n+  gcc_assert (arg);\n+  return index;\n+}\n+\n #include \"gt-cp-decl2.h\""}, {"sha": "eabab7fb5103cf7e648a3d70f2c2f375188ad76e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -2143,27 +2143,6 @@ write_expression (tree expr)\n {\n   enum tree_code code = TREE_CODE (expr);\n \n-  /* Inside decltype we can simplify some expressions, since we're only\n-     interested in the type.  */\n-  if (skip_evaluation)\n-    {\n-      tree type = describable_type (expr);\n-      if (type == NULL_TREE)\n-\t;\n-      else if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t{\n-\t  write_string (\"sT\");\n-\t  write_type (TREE_TYPE (type));\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  write_string (\"sR\");\n-\t  write_type (type);\n-\t  return;\n-\t}\n-    }\n-\n   /* Skip NOP_EXPRs.  They can occur when (say) a pointer argument\n      is converted (via qualification conversions) to another\n      type.  */\n@@ -2210,10 +2189,12 @@ write_expression (tree expr)\n     write_template_arg_literal (expr);\n   else if (code == PARM_DECL)\n     {\n-      /* A function parameter used under decltype in a late-specified\n-\t return type.  Represented with a type placeholder.  */\n-      write_string (\"sT\");\n-      write_type (non_reference (TREE_TYPE (expr)));\n+      /* A function parameter used in a late-specified return type.  */\n+      int index = parm_index (expr);\n+      write_string (\"fp\");\n+      if (index > 1)\n+\twrite_unsigned_number (index - 2);\n+      write_char ('_');\n     }\n   else if (DECL_P (expr))\n     {\n@@ -2231,6 +2212,12 @@ write_expression (tree expr)\n       write_string (\"st\");\n       write_type (TREE_OPERAND (expr, 0));\n     }\n+  else if (TREE_CODE (expr) == ALIGNOF_EXPR\n+\t   && TYPE_P (TREE_OPERAND (expr, 0)))\n+    {\n+      write_string (\"at\");\n+      write_type (TREE_OPERAND (expr, 0));\n+    }\n   else if (abi_version_at_least (2) && TREE_CODE (expr) == SCOPE_REF)\n     {\n       tree scope = TREE_OPERAND (expr, 0);\n@@ -2298,9 +2285,16 @@ write_expression (tree expr)\n \t    write_template_args (template_args);\n \t}\n     }\n+  else if (TREE_CODE (expr) == INDIRECT_REF\n+\t   && TREE_TYPE (TREE_OPERAND (expr, 0))\n+\t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == REFERENCE_TYPE)\n+    {\n+      write_expression (TREE_OPERAND (expr, 0));\n+    }\n   else\n     {\n       int i;\n+      const char *name;\n \n       /* When we bind a variable or function to a non-type template\n \t argument with reference type, we create an ADDR_EXPR to show\n@@ -2338,7 +2332,14 @@ write_expression (tree expr)\n \t}\n \n       /* If it wasn't any of those, recursively expand the expression.  */\n-      write_string (operator_name_info[(int) code].mangled_name);\n+      name = operator_name_info[(int) code].mangled_name;\n+      if (name == NULL)\n+\t{\n+\t  sorry (\"mangling %C\", code);\n+\t  return;\n+\t}\n+      else\n+\twrite_string (name);\t\n \n       switch (code)\n \t{\n@@ -2351,23 +2352,29 @@ write_expression (tree expr)\n \n \tcase CAST_EXPR:\n \t  write_type (TREE_TYPE (expr));\n-\t  /* There is no way to mangle a zero-operand cast like\n-\t     \"T()\".  */\n-\t  if (!TREE_OPERAND (expr, 0))\n-\t    sorry (\"zero-operand casts cannot be mangled due to a defect \"\n-\t\t   \"in the C++ ABI\");\n-\t  else if (list_length (TREE_OPERAND (expr, 0)) > 1)\n-\t    sorry (\"mangling function-style cast with more than one argument\");\n-\t  else\n+\t  if (list_length (TREE_OPERAND (expr, 0)) == 1)\t  \n \t    write_expression (TREE_VALUE (TREE_OPERAND (expr, 0)));\n+\t  else\n+\t    {\n+\t      tree args = TREE_OPERAND (expr, 0);\n+\t      write_char ('_');\n+\t      for (; args; args = TREE_CHAIN (args))\n+\t\twrite_expression (TREE_VALUE (args));\n+\t      write_char ('E');\n+\t    }\n \t  break;\n \n+\t  /* FIXME these should have a distinct mangling.  */\n \tcase STATIC_CAST_EXPR:\n \tcase CONST_CAST_EXPR:\n \t  write_type (TREE_TYPE (expr));\n \t  write_expression (TREE_OPERAND (expr, 0));\n \t  break;\n \n+\tcase NEW_EXPR:\n+\t  sorry (\"mangling new-expression\");\n+\t  break;\n+\n \t/* Handle pointers-to-members specially.  */\n \tcase SCOPE_REF:\n \t  write_type (TREE_OPERAND (expr, 0));"}, {"sha": "20d811b812ba378e70dd851a10e45e519588c7da", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -94,7 +94,7 @@ DEF_SIMPLE_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", 1)\n DEF_SIMPLE_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", 1)\n DEF_SIMPLE_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", 1)\n /* These are extensions.  */\n-DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"v17alignof\", 1)\n+DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"az\", 1)\n DEF_SIMPLE_OPERATOR (\"__imag__\", IMAGPART_EXPR, \"v18__imag__\", 1)\n DEF_SIMPLE_OPERATOR (\"__real__\", REALPART_EXPR, \"v18__real__\", 1)\n "}, {"sha": "62a7b882015bb872056e8f555e658796dbd90ceb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -2217,17 +2217,21 @@ check_explicit_specialization (tree declarator,\n \t     the specialization of it.  */\n \t  if (tsk == tsk_template)\n \t    {\n+\t      tree result = DECL_TEMPLATE_RESULT (tmpl);\n \t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n-\t      DECL_INITIAL (DECL_TEMPLATE_RESULT (tmpl)) = NULL_TREE;\n+\t      DECL_INITIAL (result) = NULL_TREE;\n \t      if (have_def)\n \t\t{\n+\t\t  tree parm;\n \t\t  DECL_SOURCE_LOCATION (tmpl) = DECL_SOURCE_LOCATION (decl);\n-\t\t  DECL_SOURCE_LOCATION (DECL_TEMPLATE_RESULT (tmpl))\n+\t\t  DECL_SOURCE_LOCATION (result)\n \t\t    = DECL_SOURCE_LOCATION (decl);\n \t\t  /* We want to use the argument list specified in the\n \t\t     definition, not in the original declaration.  */\n-\t\t  DECL_ARGUMENTS (DECL_TEMPLATE_RESULT (tmpl))\n-\t\t    = DECL_ARGUMENTS (decl);\n+\t\t  DECL_ARGUMENTS (result) = DECL_ARGUMENTS (decl);\n+\t\t  for (parm = DECL_ARGUMENTS (result); parm;\n+\t\t       parm = TREE_CHAIN (parm))\n+\t\t    DECL_CONTEXT (parm) = result;\n \t\t}\n \t      return tmpl;\n \t    }\n@@ -9898,16 +9902,14 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (r == NULL)\n \t{\n \t  /* This can happen for a parameter name used later in a function\n-\t     declaration (such as in a late-specified return type).\n-\t     Replace it with an arbitrary expression with the same type\n-\t     (*(T*)0).  This should only occur in an unevaluated context\n-\t     (i.e. decltype).  */\n-\t  gcc_assert (skip_evaluation);\n-\t  r = non_reference (TREE_TYPE (t));\n-\t  r = tsubst (r, args, complain, in_decl);\n-\t  r = build_pointer_type (r);\n-\t  r = build_c_cast (r, null_node);\n-\t  return cp_build_indirect_ref (r, NULL, tf_warning_or_error);\n+\t     declaration (such as in a late-specified return type).  Just\n+\t     make a dummy decl, since it's only used for its type.  */\n+\t  gcc_assert (skip_evaluation);\t  \n+\t  r = tsubst_decl (t, args, complain);\n+\t  /* Give it the template pattern as its context; its true context\n+\t     hasn't been instantiated yet and this is good enough for\n+\t     mangling.  */\n+\t  DECL_CONTEXT (r) = DECL_CONTEXT (t);\n \t}\n       \n       if (TREE_CODE (r) == ARGUMENT_PACK_SELECT)"}, {"sha": "c72897007284a5b65a7e319a2cb8d0097895e2e3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -4585,8 +4585,6 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n \t      break;\n \t    }\n \t}\n-      else\n-\ttype = describable_type (expr);\n \n       if (type && !type_uses_auto (type))\n \treturn type;"}, {"sha": "2287f11f04b87c7253b931ec2a50061a5e0c39b8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -1881,9 +1881,8 @@ cp_tree_equal (tree t1, tree t2)\n     case PARM_DECL:\n       /* For comparing uses of parameters in late-specified return types\n \t with an out-of-class definition of the function.  */\n-      if ((!DECL_CONTEXT (t1) || !DECL_CONTEXT (t2))\n-\t  && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t  && DECL_NAME (t1) == DECL_NAME (t2))\n+      if (same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  && parm_index (t1) == parm_index (t2))\n \treturn true;\n       else\n \treturn false;"}, {"sha": "b59350c54447946dc04eb37159b43b64915ae1e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -1,3 +1,7 @@\n+2009-03-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/auto6.C, auto12.C: Update mangling.\n+\n 2009-03-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/39475"}, {"sha": "45ceedfdc8819a5ef2b9d7e3372c824169027e81", "filename": "gcc/testsuite/g++.dg/cpp0x/auto12.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto12.C?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -37,16 +37,16 @@ auto A<T>::f(U u) -> decltype (u + i)\n \n int main()\n {\n-  // { dg-final { scan-assembler  \"_ZN1AIiE1fIiEEDTplsTT_sTiES2_\" } }\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1fIiEEDTplfp_L_ZNS0_1iEEET_\" } }\n   A<int>().f(1);\n-  // { dg-final { scan-assembler  \"_ZN1AIiE2frIiEEDTplsTT_sTiES2_\" } }\n+  // { dg-final { scan-assembler  \"_ZN1AIiE2frIiEEDTplfp_L_ZNS0_2irEEET_\" } }\n   A<int>().fr(1);\n-  // { dg-final { scan-assembler  \"_ZN1AIiE3frrIiEEDTplsTT_sTiES2_\" } }\n+  // { dg-final { scan-assembler  \"_ZN1AIiE3frrIiEEDTplfp_L_ZNS0_3irrEEET_\" } }\n   A<int>().frr(1);\n-  // { dg-final { scan-assembler  \"_ZN1AIiE1gIiEEDTplsTT_sR.ES2_\" } }\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1gIiEEDTplfp_szL_ZNS0_1iEEET_\" } }\n   A<int>().g(1);\n-  // { dg-final { scan-assembler  \"_ZN1AIiE1hIiEEDTplsTT_sr1BIS2_E1iES2_\" } }\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1hIiEEDTplfp_sr1BIT_E1iES3_\" } }\n   A<int>().h(1);\n-  // { dg-final { scan-assembler  \"_ZN1AIiE1jIiEEDTplsTT_sRiES2_\" } }\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1jIiEEDTplfp_clL_Z1xvEEET_\" } }\n   A<int>().j(1);\n }"}, {"sha": "dfd6a2026981b584c7c7be4a16b28a6d71b772f1", "filename": "gcc/testsuite/g++.dg/cpp0x/auto6.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -95,21 +95,21 @@ A<int> a, *p;\n \n int main()\n {\n-  // { dg-final { scan-assembler  \"_Z3addIidEDTplsTT_sTT0_ES0_S1_\" } }\n+  // { dg-final { scan-assembler  \"_Z3addIidEDTplfp_fp0_ET_T0_\" } }\n   auto i = add(1, 2.0);\n-  // { dg-final { scan-assembler \"_Z4add4IidEDTplsTT_sTT0_ES0_S1_\" } }\n+  // { dg-final { scan-assembler \"_Z4add4IidEDTpldecvPT_Li0EdecvPT0_Li0EES0_S2_\" } }\n   auto i4 = add4(1, 2.0);\n-  // { dg-final { scan-assembler \"_Z4add2IidEDTplsRT_sRT0_ES0_S1_\" } }\n+  // { dg-final { scan-assembler \"_Z4add2IidEDTplcvT__EcvT0__EES0_S1_\" } }\n   auto i2 = add2(1, 2.0);\n-  // { dg-final { scan-assembler \"_Z4add3IidEDTclL_Z2agEsTT_sTT0_EES0_S1_\" } }\n+  // { dg-final { scan-assembler \"_Z4add3IidEDTclL_Z2agEfp_fp0_EET_T0_\" } }\n   auto i3 = add3(1, 2.0);\n-  // { dg-final { scan-assembler \"_Z1fI1AIiEEDTclptsTPT_1fEES3_\" } }\n+  // { dg-final { scan-assembler \"_Z1fI1AIiEEDTclptfp_1fEEPT_\" } }\n   f(p);\n-  // { dg-final { scan-assembler \"_Z1gI1AIiEEDTcldtsTT_1fEES2_\" } }\n+  // { dg-final { scan-assembler \"_Z1gI1AIiEEDTcldtfp_1fEET_\" } }\n   g(a);\n-  // { dg-final { scan-assembler \"_Z1hI1AIiEdEDTcldtsTT_1gIT0_EEES2_S3_\" } }\n+  // { dg-final { scan-assembler \"_Z1hI1AIiEdEDTcldtfp_1gIT0_EEET_S2_\" } }\n   h(a,1.0);\n-  // { dg-final { scan-assembler \"_Z1kI1C1AIiE1DEDtdtsTT_srNT0_1BIT1_EE3MEMES4_S5_S7_\" } }\n+  // { dg-final { scan-assembler \"_Z1kI1C1AIiE1DEDtdtfp_srNT0_1BIT1_EE3MEMET_S4_S6_\" } }\n   k( C(), A<int>(), D() );\n   // { dg-final { scan-assembler \"_Z1lIiET_S0_\" } }\n   l(1);"}, {"sha": "64dd0d962af19e5b0afe036ada57045c13a9941e", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -1,3 +1,8 @@\n+2009-03-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* demangle.h (enum demangle_component_type): Add\n+\tDEMANGLE_COMPONENT_FUNCTION_PARAM.\n+\n 2008-12-10  Jason Merrill  <jason@redhat.com>\n \n \t* demangle.h (enum demangle_component_type): Add "}, {"sha": "eb39c7c13c4df9686825a56f86846960283a87dd", "filename": "include/demangle.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -221,6 +221,8 @@ enum demangle_component_type\n   /* A template parameter.  This holds a number, which is the template\n      parameter index.  */\n   DEMANGLE_COMPONENT_TEMPLATE_PARAM,\n+  /* A function parameter.  This holds a number, which is the index.  */\n+  DEMANGLE_COMPONENT_FUNCTION_PARAM,\n   /* A constructor.  This holds a name and the kind of\n      constructor.  */\n   DEMANGLE_COMPONENT_CTOR,\n@@ -466,10 +468,10 @@ struct demangle_component\n       int len;\n     } s_string;\n \n-    /* For DEMANGLE_COMPONENT_TEMPLATE_PARAM.  */\n+    /* For DEMANGLE_COMPONENT_*_PARAM.  */\n     struct\n     {\n-      /* Template parameter index.  */\n+      /* Parameter index.  */\n       long number;\n     } s_number;\n "}, {"sha": "00aa57a84e4d1327551aa044305571160032a065", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -1,3 +1,15 @@\n+2009-03-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_make_function_param): new fn.\n+\t(cplus_demangle_mangled_name): Work around abi v2 bug.\n+\t(d_expr_primary): Likewise.\n+\t(cplus_demangle_operators): Add alignof ops.\n+\t(d_expression): Handle function parameters and conversions\n+\twith other than 1 operand.\n+\t(d_print_comp): Handle function parameters.  Fix bug with\n+\tfunction used in type of function.\n+\t* testsuite/demangle-expected: Upate tests.\n+\n 2009-02-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* make-temp-file.c (<windows.h>): Include on Windows."}, {"sha": "e6d3d5ea902d9a1a719ec4f7c9746b64cb15693a", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -964,6 +964,22 @@ d_make_template_param (struct d_info *di, long i)\n   return p;\n }\n \n+/* Add a new function parameter.  */\n+\n+static struct demangle_component *\n+d_make_function_param (struct d_info *di, long i)\n+{\n+  struct demangle_component *p;\n+\n+  p = d_make_empty (di);\n+  if (p != NULL)\n+    {\n+      p->type = DEMANGLE_COMPONENT_FUNCTION_PARAM;\n+      p->u.s_number.number = i;\n+    }\n+  return p;\n+}\n+\n /* Add a new standard substitution component.  */\n \n static struct demangle_component *\n@@ -989,7 +1005,11 @@ CP_STATIC_IF_GLIBCPP_V3\n struct demangle_component *\n cplus_demangle_mangled_name (struct d_info *di, int top_level)\n {\n-  if (! d_check_char (di, '_'))\n+  if (! d_check_char (di, '_')\n+      /* Allow missing _ if not at toplevel to work around a\n+\t bug in G++ abi-version=2 mangling; see the comment in\n+\t write_template_arg.  */\n+      && top_level)\n     return NULL;\n   if (! d_check_char (di, 'Z'))\n     return NULL;\n@@ -1481,6 +1501,8 @@ const struct demangle_operator_info cplus_demangle_operators[] =\n   { \"rs\", NL (\">>\"),        2 },\n   { \"st\", NL (\"sizeof \"),   1 },\n   { \"sz\", NL (\"sizeof \"),   1 },\n+  { \"at\", NL (\"alignof \"),   1 },\n+  { \"az\", NL (\"alignof \"),   1 },\n   { NULL, NULL, 0,          0 }\n };\n \n@@ -2564,12 +2586,25 @@ d_expression (struct d_info *di)\n \t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n \t\t\t\t\t d_template_args (di)));\n     }\n-  else if (peek == 's'\n-\t   && (d_peek_next_char (di) == 'T' || d_peek_next_char (di) == 'R'))\n+  else if (peek == 'f' && d_peek_next_char (di) == 'p')\n     {\n-      /* Just demangle a parameter placeholder as its type.  */\n+      /* Function parameter used in a late-specified return type.  */\n+      int index;\n       d_advance (di, 2);\n-      return cplus_demangle_type (di);\n+      if (d_peek_char (di) == '_')\n+\tindex = 1;\n+      else\n+\t{\n+\t  index = d_number (di);\n+\t  if (index < 0)\n+\t    return NULL;\n+\t  index += 2;\n+\t}\n+\n+      if (! d_check_char (di, '_'))\n+\treturn NULL;\n+\n+      return d_make_function_param (di, index);\n     }\n   else if (IS_DIGIT (peek))\n     {\n@@ -2619,8 +2654,16 @@ d_expression (struct d_info *di)\n       switch (args)\n \t{\n \tcase 1:\n-\t  return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n-\t\t\t      d_expression (di));\n+\t  {\n+\t    struct demangle_component *operand;\n+\t    if (op->type == DEMANGLE_COMPONENT_CAST\n+\t\t&& d_check_char (di, '_'))\n+\t      operand = d_exprlist (di);\n+\t    else\n+\t      operand = d_expression (di);\n+\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n+\t\t\t\toperand);\n+\t  }\n \tcase 2:\n \t  {\n \t    struct demangle_component *left;\n@@ -2671,7 +2714,9 @@ d_expr_primary (struct d_info *di)\n \n   if (! d_check_char (di, 'L'))\n     return NULL;\n-  if (d_peek_char (di) == '_')\n+  if (d_peek_char (di) == '_'\n+      /* Workaround for G++ bug; see comment in write_template_arg.  */\n+      || d_peek_char (di) == 'Z')\n     ret = cplus_demangle_mangled_name (di, 0);\n   else\n     {\n@@ -3293,6 +3338,7 @@ d_print_comp (struct d_print_info *dpi,\n \t   the right place for the type.  We also have to pass down\n \t   any CV-qualifiers, which apply to the this parameter.  */\n \thold_modifiers = dpi->modifiers;\n+\tdpi->modifiers = 0;\n \ti = 0;\n \ttyped_name = d_left (dc);\n \twhile (typed_name != NULL)\n@@ -3981,6 +4027,15 @@ d_print_comp (struct d_print_info *dpi,\n       }\n       return;\n \n+    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n+      {\n+\tchar buf[25];\n+\td_append_string (dpi, \"parm#\");\n+\tsprintf(buf,\"%ld\", dc->u.s_number.number);\n+\td_append_string (dpi, buf);\n+\treturn;\n+      }\n+\n     default:\n       d_print_error (dpi);\n       return;"}, {"sha": "cded6b5d71acf481fbb4ce34b066be86c4056a8b", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448545cb51bdf3d74c3d75f3b88dbf8c7a8de984/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=448545cb51bdf3d74c3d75f3b88dbf8c7a8de984", "patch": "@@ -3723,7 +3723,7 @@ foo<int (*) [3]>\n # This used to crash the demangler--PR 16240\n --format=gnu-v3 --no-params\n _ZN13PatternDriver23StringScalarDeleteValueC1ERKNS_25ConflateStringScalarValueERKNS_25AbstractStringScalarValueERKNS_12TemplateEnumINS_12pdcomplementELZNS_16complement_namesEELZNS_14COMPLEMENTENUMEEEE\n-_ZN13PatternDriver23StringScalarDeleteValueC1ERKNS_25ConflateStringScalarValueERKNS_25AbstractStringScalarValueERKNS_12TemplateEnumINS_12pdcomplementELZNS_16complement_namesEELZNS_14COMPLEMENTENUMEEEE\n+PatternDriver::StringScalarDeleteValue::StringScalarDeleteValue(PatternDriver::ConflateStringScalarValue const&, PatternDriver::AbstractStringScalarValue const&, PatternDriver::TemplateEnum<PatternDriver::pdcomplement, PatternDriver::complement_names, PatternDriver::COMPLEMENTENUM> const&)\n PatternDriver::StringScalarDeleteValue::StringScalarDeleteValue\n #\n # This used to cause the demangler to walk into undefined memory--PR 22268\n@@ -3884,12 +3884,12 @@ _ZGr32_java$Sutil$Siso4217$_properties\n java resource java/util/iso4217.properties\n # decltype/param placeholder test\n --format=gnu-v3\n-_Z3addIidEDTplsTT_sTT0_ES0_S1_\n-decltype ((int)+(double)) add<int, double>(int, double)\n+_Z3addIidEDTplfp_fp0_ET_T0_\n+decltype ((parm#1)+(parm#2)) add<int, double>(int, double)\n # decltype/fn call test\n --format=gnu-v3\n-_Z4add3IidEDTclL_Z1gEsTT_sTT0_EES0_S1_\n-decltype (g(int, double)) add3<int, double>(int, double)\n+_Z4add3IidEDTclL_Z1gEfp_fp0_EET_T0_\n+decltype (g(parm#1, parm#2)) add3<int, double>(int, double)\n # new (2008) built in types test\n --format=gnu-v3\n _Z1fDfDdDeDhDsDi\n@@ -3900,5 +3900,9 @@ _Z1fIIPiPfPdEEvDpT_\n void f<int*, float*, double*>(int*, float*, double*)\n # '.' test\n --format=gnu-v3\n-_Z1hI1AIiEdEDTcldtsTT_1gIT0_EEES2_S3_\n-decltype (((A<int>).(g<double>))()) h<A<int>, double>(A<int>, double)\n+_Z1hI1AIiEdEDTcldtfp_1gIT0_EEET_S2_\n+decltype (((parm#1).(g<double>))()) h<A<int>, double>(A<int>, double)\n+# test for typed function in decltype\n+--format=gnu-v3\n+_ZN1AIiE1jIiEEDTplfp_clL_Z1xvEEET_\n+decltype ((parm#1)+((x())())) A<int>::j<int>(int)"}]}