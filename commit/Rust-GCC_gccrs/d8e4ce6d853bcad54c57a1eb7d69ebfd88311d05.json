{"sha": "d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlNGNlNmQ4NTNiY2FkNTRjNTdhMWViN2Q2OWViZmQ4ODMxMWQwNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-04-15T10:18:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-04-15T10:18:28Z"}, "message": "alias.c (ncr_compar): New function.\n\n2014-04-15  Richard Biener  <rguenther@suse.de>\n\n\t* alias.c (ncr_compar): New function.\n\t(nonoverlapping_component_refs_p): Re-implement in O (n log n).\n\nFrom-SVN: r209413", "tree": {"sha": "1aa9d502c4c8a21b8c5b2d8c22ba67ec58c3ff19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aa9d502c4c8a21b8c5b2d8c22ba67ec58c3ff19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1999fd7dde1116754b88e9749334ae74c41d884e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1999fd7dde1116754b88e9749334ae74c41d884e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1999fd7dde1116754b88e9749334ae74c41d884e"}], "stats": {"total": 137, "additions": 100, "deletions": 37}, "files": [{"sha": "bfba5a5fdf405757ae4c877fb7158bb3c909aa0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05", "patch": "@@ -1,3 +1,8 @@\n+2014-04-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* alias.c (ncr_compar): New function.\n+\t(nonoverlapping_component_refs_p): Re-implement in O (n log n).\n+\n 2014-04-15  Richard Biener  <rguenther@suse.de>\n \n \t* alias.c (record_component_aliases): Do not walk BINFOs."}, {"sha": "4b32fcb027b1b3b47b9811b72563a36b842ab941", "filename": "gcc/alias.c", "status": "modified", "additions": 95, "deletions": 37, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d8e4ce6d853bcad54c57a1eb7d69ebfd88311d05", "patch": "@@ -2248,64 +2248,122 @@ read_dependence (const_rtx mem, const_rtx x)\n   return false;\n }\n \n+/* qsort compare function to sort FIELD_DECLs after their\n+   DECL_FIELD_CONTEXT TYPE_UID.  */\n+\n+static inline int\n+ncr_compar (const void *field1_, const void *field2_)\n+{\n+  const_tree field1 = *(const_tree *) const_cast <void *>(field1_);\n+  const_tree field2 = *(const_tree *) const_cast <void *>(field2_);\n+  unsigned int uid1\n+    = TYPE_UID (TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field1)));\n+  unsigned int uid2\n+    = TYPE_UID (TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field2)));\n+  if (uid1 < uid2)\n+    return -1;\n+  else if (uid1 > uid2)\n+    return 1;\n+  return 0;\n+}\n+\n /* Return true if we can determine that the fields referenced cannot\n    overlap for any pair of objects.  */\n \n static bool\n nonoverlapping_component_refs_p (const_rtx rtlx, const_rtx rtly)\n {\n   const_tree x = MEM_EXPR (rtlx), y = MEM_EXPR (rtly);\n-  const_tree fieldx, fieldy, typex, typey, orig_y;\n \n   if (!flag_strict_aliasing\n       || !x || !y\n       || TREE_CODE (x) != COMPONENT_REF\n       || TREE_CODE (y) != COMPONENT_REF)\n     return false;\n \n-  do\n+  auto_vec<const_tree, 16> fieldsx;\n+  while (TREE_CODE (x) == COMPONENT_REF)\n     {\n-      /* The comparison has to be done at a common type, since we don't\n-\t know how the inheritance hierarchy works.  */\n-      orig_y = y;\n-      do\n-\t{\n-\t  fieldx = TREE_OPERAND (x, 1);\n-\t  typex = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldx));\n-\n-\t  y = orig_y;\n-\t  do\n-\t    {\n-\t      fieldy = TREE_OPERAND (y, 1);\n-\t      typey = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldy));\n-\n-\t      if (typex == typey)\n-\t\tgoto found;\n+      tree field = TREE_OPERAND (x, 1);\n+      tree type = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field));\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\tfieldsx.safe_push (field);\n+      x = TREE_OPERAND (x, 0);\n+    }\n+  if (fieldsx.length () == 0)\n+    return false;\n+  auto_vec<const_tree, 16> fieldsy;\n+  while (TREE_CODE (y) == COMPONENT_REF)\n+    {\n+      tree field = TREE_OPERAND (y, 1);\n+      tree type = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field));\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\tfieldsy.safe_push (TREE_OPERAND (y, 1));\n+      y = TREE_OPERAND (y, 0);\n+    }\n+  if (fieldsy.length () == 0)\n+    return false;\n \n-\t      y = TREE_OPERAND (y, 0);\n-\t    }\n-\t  while (y && TREE_CODE (y) == COMPONENT_REF);\n+  /* Most common case first.  */\n+  if (fieldsx.length () == 1\n+      && fieldsy.length () == 1)\n+    return ((TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldsx[0]))\n+\t     == TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldsy[0])))\n+\t    && fieldsx[0] != fieldsy[0]\n+\t    && !(DECL_BIT_FIELD (fieldsx[0]) && DECL_BIT_FIELD (fieldsy[0])));\n \n-\t  x = TREE_OPERAND (x, 0);\n+  if (fieldsx.length () == 2)\n+    {\n+      if (ncr_compar (&fieldsx[0], &fieldsx[1]) == 1)\n+\t{\n+\t  const_tree tem = fieldsx[0];\n+\t  fieldsx[0] = fieldsx[1];\n+\t  fieldsx[1] = tem;\n \t}\n-      while (x && TREE_CODE (x) == COMPONENT_REF);\n-      /* Never found a common type.  */\n-      return false;\n+    }\n+  else\n+    fieldsx.qsort (ncr_compar);\n \n-    found:\n-      /* If we're left with accessing different fields of a structure, then no\n-\t possible overlap, unless they are both bitfields.  */\n-      if (TREE_CODE (typex) == RECORD_TYPE && fieldx != fieldy)\n-\treturn !(DECL_BIT_FIELD (fieldx) && DECL_BIT_FIELD (fieldy));\n+  if (fieldsy.length () == 2)\n+    {\n+      if (ncr_compar (&fieldsy[0], &fieldsy[1]) == 1)\n+\t{\n+\t  const_tree tem = fieldsy[0];\n+\t  fieldsy[0] = fieldsy[1];\n+\t  fieldsy[1] = tem;\n+\t}\n+    }\n+  else\n+    fieldsy.qsort (ncr_compar);\n \n-      /* The comparison on the current field failed.  If we're accessing\n-\t a very nested structure, look at the next outer level.  */\n-      x = TREE_OPERAND (x, 0);\n-      y = TREE_OPERAND (y, 0);\n+  unsigned i = 0, j = 0;\n+  do\n+    {\n+      const_tree fieldx = fieldsx[i];\n+      const_tree fieldy = fieldsy[j];\n+      tree typex = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldx));\n+      tree typey = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldy));\n+      if (typex == typey)\n+\t{\n+\t  /* We're left with accessing different fields of a structure,\n+\t     no possible overlap, unless they are both bitfields.  */\n+\t  if (fieldx != fieldy)\n+\t    return !(DECL_BIT_FIELD (fieldx) && DECL_BIT_FIELD (fieldy));\n+\t}\n+      if (TYPE_UID (typex) < TYPE_UID (typey))\n+\t{\n+\t  i++;\n+\t  if (i == fieldsx.length ())\n+\t    break;\n+\t}\n+      else\n+\t{\n+\t  j++;\n+\t  if (j == fieldsy.length ())\n+\t    break;\n+\t}\n     }\n-  while (x && y\n-\t && TREE_CODE (x) == COMPONENT_REF\n-\t && TREE_CODE (y) == COMPONENT_REF);\n+  while (1);\n \n   return false;\n }"}]}