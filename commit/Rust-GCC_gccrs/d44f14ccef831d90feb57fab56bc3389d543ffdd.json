{"sha": "d44f14ccef831d90feb57fab56bc3389d543ffdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ0ZjE0Y2NlZjgzMWQ5MGZlYjU3ZmFiNTZiYzMzODlkNTQzZmZkZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-05T14:34:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-05T14:34:51Z"}, "message": "csa, postreload: Improve csa after recent cselib changes [PR94516]\n\nThis patch addresses a missed optimization caused by the cselib changes.\nAlready in the past postreload could replace sp = sp + const_int with\nsp = regxy if regxy already has the right value, but with the cselib\nchanges it happens several times more often.  It can result in smaller\ncode, so it seems undesirable to prevent such optimizations, but\nunfortunately it can get into the way of stack adjustment coalescing,\nwhere e.g. if we used to have sp = sp + 32; sp = sp - 8;, previously\nwe'd turn that into sp = sp + 24;, but now postreload optimizes\ninto sp = r12; sp = sp - 8; and csa gives up.\n\nThe patch just adds a REG_EQUAL note when changing sp = sp + const into\nsp = reg, where we remember it was actually a stack adjustment by certain\nconstant, and the combine-stack-adj changes than make use of those REG_EQUAL\nnotes, together with LR tracking (csa did enable the note problem, just\ndidn't simulate each insn) so that we can add the needed clobbers etc.\n(taken from the other stack adjustment insn).\n\n2020-05-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/94516\n\t* postreload.c (reload_cse_simplify): When replacing sp = sp + const\n\twith sp = reg, add REG_EQUAL note with sp + const.\n\t* combine-stack-adj.c (try_apply_stack_adjustment): Change return\n\ttype from int to bool.  Add LIVE and OTHER_INSN arguments.  Undo\n\tpostreload sp = sp + const to sp = reg optimization if needed and\n\tpossible.\n\t(combine_stack_adjustments_for_block): Add LIVE argument.  Handle\n\treg = sp insn with sp + const REG_EQUAL note.  Adjust\n\ttry_apply_stack_adjustment caller, call\n\tdf_simulate_initialize_forwards and df_simulate_one_insn_forwards.\n\t(combine_stack_adjustments): Allocate and free LIVE bitmap,\n\tadjust combine_stack_adjustments_for_block caller.", "tree": {"sha": "270006a083fca18745d6cf12d0fcdf01114cbb49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/270006a083fca18745d6cf12d0fcdf01114cbb49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d44f14ccef831d90feb57fab56bc3389d543ffdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44f14ccef831d90feb57fab56bc3389d543ffdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d44f14ccef831d90feb57fab56bc3389d543ffdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44f14ccef831d90feb57fab56bc3389d543ffdd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3479afc5ab415f00a53fc6f6a990df7f6a0747"}], "stats": {"total": 171, "additions": 154, "deletions": 17}, "files": [{"sha": "b1c0759ca28c8140d73c2b5d7962945ff504c78e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44f14ccef831d90feb57fab56bc3389d543ffdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44f14ccef831d90feb57fab56bc3389d543ffdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d44f14ccef831d90feb57fab56bc3389d543ffdd", "patch": "@@ -1,3 +1,19 @@\n+2020-05-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/94516\n+\t* postreload.c (reload_cse_simplify): When replacing sp = sp + const\n+\twith sp = reg, add REG_EQUAL note with sp + const.\n+\t* combine-stack-adj.c (try_apply_stack_adjustment): Change return\n+\ttype from int to bool.  Add LIVE and OTHER_INSN arguments.  Undo\n+\tpostreload sp = sp + const to sp = reg optimization if needed and\n+\tpossible.\n+\t(combine_stack_adjustments_for_block): Add LIVE argument.  Handle\n+\treg = sp insn with sp + const REG_EQUAL note.  Adjust\n+\ttry_apply_stack_adjustment caller, call\n+\tdf_simulate_initialize_forwards and df_simulate_one_insn_forwards.\n+\t(combine_stack_adjustments): Allocate and free LIVE bitmap,\n+\tadjust combine_stack_adjustments_for_block caller.\n+\n 2020-05-05  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/93623"}, {"sha": "281166bf6955aa69056b0c3a9126e233b5a5555b", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 119, "deletions": 17, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44f14ccef831d90feb57fab56bc3389d543ffdd/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44f14ccef831d90feb57fab56bc3389d543ffdd/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=d44f14ccef831d90feb57fab56bc3389d543ffdd", "patch": "@@ -70,9 +70,10 @@ static rtx single_set_for_csa (rtx_insn *);\n static void free_csa_reflist (struct csa_reflist *);\n static struct csa_reflist *record_one_stack_ref (rtx_insn *, rtx *,\n \t\t\t\t\t\t struct csa_reflist *);\n-static int try_apply_stack_adjustment (rtx_insn *, struct csa_reflist *,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT);\n-static void combine_stack_adjustments_for_block (basic_block);\n+static bool try_apply_stack_adjustment (rtx_insn *, struct csa_reflist *,\n+\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tbitmap, rtx_insn *);\n+static void combine_stack_adjustments_for_block (basic_block, bitmap);\n \n \n /* Main entry point for stack adjustment combination.  */\n@@ -81,9 +82,12 @@ static void\n combine_stack_adjustments (void)\n {\n   basic_block bb;\n+  bitmap live = BITMAP_ALLOC (&reg_obstack);\n \n   FOR_EACH_BB_FN (bb, cfun)\n-    combine_stack_adjustments_for_block (bb);\n+    combine_stack_adjustments_for_block (bb, live);\n+\n+  BITMAP_FREE (live);\n }\n \n /* Recognize a MEM of the form (sp) or (plus sp const).  */\n@@ -219,18 +223,60 @@ no_unhandled_cfa (rtx_insn *insn)\n    as each of the memories and stack references in REFLIST.  Return true\n    on success.  */\n \n-static int\n+static bool\n try_apply_stack_adjustment (rtx_insn *insn, struct csa_reflist *reflist,\n-\t\t\t    HOST_WIDE_INT new_adjust, HOST_WIDE_INT delta)\n+\t\t\t    HOST_WIDE_INT new_adjust, HOST_WIDE_INT delta,\n+\t\t\t    bitmap live, rtx_insn *other_insn)\n {\n   struct csa_reflist *ml;\n   rtx set;\n+  bool remove_equal = false;\n \n   set = single_set_for_csa (insn);\n   if (MEM_P (SET_DEST (set)))\n     validate_change (insn, &SET_DEST (set),\n \t\t     replace_equiv_address (SET_DEST (set), stack_pointer_rtx),\n \t\t     1);\n+  else if (REG_P (SET_SRC (set)))\n+    {\n+      if (other_insn == NULL_RTX || live == NULL)\n+\treturn false;\n+      rtx other_set = single_set_for_csa (other_insn);\n+      if (SET_DEST (other_set) != stack_pointer_rtx\n+\t  || GET_CODE (SET_SRC (other_set)) != PLUS\n+\t  || XEXP (SET_SRC (other_set), 0) != stack_pointer_rtx\n+\t  || !CONST_INT_P (XEXP (SET_SRC (other_set), 1)))\n+\treturn false;\n+      if (PATTERN (other_insn) != other_set)\n+\t{\n+\t  if (GET_CODE (PATTERN (other_insn)) != PARALLEL)\n+\t    return false;\n+\t  int i;\n+\t  rtx p = PATTERN (other_insn);\n+\t  for (i = 0; i < XVECLEN (p, 0); ++i)\n+\t    {\n+\t      rtx this_rtx = XVECEXP (p, 0, i);\n+\t      if (this_rtx == other_set)\n+\t\tcontinue;\n+\t      if (GET_CODE (this_rtx) != CLOBBER)\n+\t\treturn false;\n+\t      if (!REG_P (XEXP (this_rtx, 0))\n+\t\t  || !HARD_REGISTER_P (XEXP (this_rtx, 0)))\n+\t\treturn false;\n+\t      unsigned int end_regno = END_REGNO (XEXP (this_rtx, 0));\n+\t      for (unsigned int regno = REGNO (XEXP (this_rtx, 0));\n+\t\t   regno < end_regno; ++regno)\n+\t\tif (bitmap_bit_p (live, regno))\n+\t\t  return false;\n+\t    }\n+\t}\n+      validate_change (insn, &PATTERN (insn), copy_rtx (PATTERN (other_insn)),\n+\t\t       1);\n+      set = single_set_for_csa (insn);\n+      validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (new_adjust),\n+\t\t       1);\n+      remove_equal = true;\n+    }\n   else\n     validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (new_adjust), 1);\n \n@@ -256,10 +302,12 @@ try_apply_stack_adjustment (rtx_insn *insn, struct csa_reflist *reflist,\n       for (ml = reflist; ml ; ml = ml->next)\n \tml->sp_offset -= delta;\n \n-      return 1;\n+      if (remove_equal)\n+\tremove_reg_equal_equiv_notes (insn);\n+      return true;\n     }\n   else\n-    return 0;\n+    return false;\n }\n \n /* For non-debug insns, record all stack memory references in INSN\n@@ -489,16 +537,21 @@ force_move_args_size_note (basic_block bb, rtx_insn *prev, rtx_insn *insn)\n /* Subroutine of combine_stack_adjustments, called for each basic block.  */\n \n static void\n-combine_stack_adjustments_for_block (basic_block bb)\n+combine_stack_adjustments_for_block (basic_block bb, bitmap live)\n {\n   HOST_WIDE_INT last_sp_adjust = 0;\n   rtx_insn *last_sp_set = NULL;\n   rtx_insn *last2_sp_set = NULL;\n+  bitmap last_sp_live = NULL;\n   struct csa_reflist *reflist = NULL;\n+  bitmap copy = NULL;\n   rtx_insn *insn, *next;\n   rtx set;\n   bool end_of_block = false;\n \n+  bitmap_copy (live, DF_LR_IN (bb));\n+  df_simulate_initialize_forwards (bb, live);\n+\n   for (insn = BB_HEAD (bb); !end_of_block ; insn = next)\n     {\n       end_of_block = insn == BB_END (bb);\n@@ -514,21 +567,43 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t{\n \t  rtx dest = SET_DEST (set);\n \t  rtx src = SET_SRC (set);\n+\t  HOST_WIDE_INT this_adjust = 0;\n \n \t  /* Find constant additions to the stack pointer.  */\n \t  if (dest == stack_pointer_rtx\n \t      && GET_CODE (src) == PLUS\n \t      && XEXP (src, 0) == stack_pointer_rtx\n \t      && CONST_INT_P (XEXP (src, 1)))\n+\t    this_adjust = INTVAL (XEXP (src, 1));\n+\t  /* Or such additions turned by postreload into a store of\n+\t     equivalent register.  */\n+\t  else if (dest == stack_pointer_rtx\n+\t\t   && REG_P (src)\n+\t\t   && REGNO (src) != STACK_POINTER_REGNUM)\n+\t    if (rtx equal = find_reg_note (insn, REG_EQUAL, NULL_RTX))\n+\t      if (GET_CODE (XEXP (equal, 0)) == PLUS\n+\t\t  && XEXP (XEXP (equal, 0), 0) == stack_pointer_rtx\n+\t\t  && CONST_INT_P (XEXP (XEXP (equal, 0), 1)))\n+\t\tthis_adjust = INTVAL (XEXP (XEXP (equal, 0), 1));\n+\n+\t  if (this_adjust)\n \t    {\n-\t      HOST_WIDE_INT this_adjust = INTVAL (XEXP (src, 1));\n-\n \t      /* If we've not seen an adjustment previously, record\n \t\t it now and continue.  */\n \t      if (! last_sp_set)\n \t\t{\n \t\t  last_sp_set = insn;\n \t\t  last_sp_adjust = this_adjust;\n+\t\t  if (REG_P (src))\n+\t\t    {\n+\t\t      if (copy == NULL)\n+\t\t\tcopy = BITMAP_ALLOC (&reg_obstack);\n+\t\t      last_sp_live = copy;\n+\t\t      bitmap_copy (last_sp_live, live);\n+\t\t    }\n+\t\t  else\n+\t\t    last_sp_live = NULL;\n+\t\t  df_simulate_one_insn_forwards (bb, insn, live);\n \t\t  continue;\n \t\t}\n \n@@ -560,13 +635,16 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t      && try_apply_stack_adjustment (last_sp_set, reflist,\n \t\t\t\t\t\t     last_sp_adjust\n \t\t\t\t\t\t     + this_adjust,\n-\t\t\t\t\t\t     this_adjust))\n+\t\t\t\t\t\t     this_adjust,\n+\t\t\t\t\t\t     last_sp_live,\n+\t\t\t\t\t\t     insn))\n \t\t    {\n \t\t      /* It worked!  */\n \t\t      maybe_move_args_size_note (last_sp_set, insn, false);\n \t\t      maybe_merge_cfa_adjust (last_sp_set, insn, false);\n \t\t      delete_insn (insn);\n \t\t      last_sp_adjust += this_adjust;\n+\t\t      last_sp_live = NULL;\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -577,19 +655,23 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t       ? last_sp_adjust >= 0 : last_sp_adjust <= 0)\n \t\t{\n \t\t  if (no_unhandled_cfa (last_sp_set)\n+\t\t      && !REG_P (src)\n \t\t      && try_apply_stack_adjustment (insn, reflist,\n \t\t\t\t\t\t     last_sp_adjust\n \t\t\t\t\t\t     + this_adjust,\n-\t\t\t\t\t\t     -last_sp_adjust))\n+\t\t\t\t\t\t     -last_sp_adjust,\n+\t\t\t\t\t\t     NULL, NULL))\n \t\t    {\n \t\t      /* It worked!  */\n \t\t      maybe_move_args_size_note (insn, last_sp_set, true);\n \t\t      maybe_merge_cfa_adjust (insn, last_sp_set, true);\n \t\t      delete_insn (last_sp_set);\n \t\t      last_sp_set = insn;\n \t\t      last_sp_adjust += this_adjust;\n+\t\t      last_sp_live = NULL;\n \t\t      free_csa_reflist (reflist);\n \t\t      reflist = NULL;\n+\t\t      df_simulate_one_insn_forwards (bb, insn, live);\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -612,6 +694,16 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      reflist = NULL;\n \t      last_sp_set = insn;\n \t      last_sp_adjust = this_adjust;\n+\t      if (REG_P (src))\n+\t\t{\n+\t\t  if (copy == NULL)\n+\t\t    copy = BITMAP_ALLOC (&reg_obstack);\n+\t\t  last_sp_live = copy;\n+\t\t  bitmap_copy (last_sp_live, live);\n+\t\t}\n+\t      else\n+\t\tlast_sp_live = NULL;\n+\t      df_simulate_one_insn_forwards (bb, insn, live);\n \t      continue;\n \t    }\n \n@@ -641,7 +733,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      && !reg_mentioned_p (stack_pointer_rtx, src)\n \t      && memory_address_p (GET_MODE (dest), stack_pointer_rtx)\n \t      && try_apply_stack_adjustment (insn, reflist, 0,\n-\t\t\t\t\t     -last_sp_adjust))\n+\t\t\t\t\t     -last_sp_adjust,\n+\t\t\t\t\t     NULL, NULL))\n \t    {\n \t      if (last2_sp_set)\n \t\tmaybe_move_args_size_note (last2_sp_set, last_sp_set, false);\n@@ -652,13 +745,17 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      reflist = NULL;\n \t      last_sp_set = NULL;\n \t      last_sp_adjust = 0;\n+\t      last_sp_live = NULL;\n+\t      df_simulate_one_insn_forwards (bb, insn, live);\n \t      continue;\n \t    }\n \t}\n \n-      if (!CALL_P (insn) && last_sp_set\n-\t  && record_stack_refs (insn, &reflist))\n-\tcontinue;\n+      if (!CALL_P (insn) && last_sp_set && record_stack_refs (insn, &reflist))\n+\t{\n+\t  df_simulate_one_insn_forwards (bb, insn, live);\n+\t  continue;\n+\t}\n \n       /* Otherwise, we were not able to process the instruction.\n \t Do not continue collecting data across such a one.  */\n@@ -676,7 +773,10 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t  last2_sp_set = NULL;\n \t  last_sp_set = NULL;\n \t  last_sp_adjust = 0;\n+\t  last_sp_live = NULL;\n \t}\n+\n+      df_simulate_one_insn_forwards (bb, insn, live);\n     }\n \n   if (last_sp_set && last_sp_adjust == 0)\n@@ -687,6 +787,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n \n   if (reflist)\n     free_csa_reflist (reflist);\n+  if (copy)\n+    BITMAP_FREE (copy);\n }\n \f\n static unsigned int"}, {"sha": "677b8244e3efd6b284c007bc5149b14666533310", "filename": "gcc/postreload.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44f14ccef831d90feb57fab56bc3389d543ffdd/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44f14ccef831d90feb57fab56bc3389d543ffdd/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=d44f14ccef831d90feb57fab56bc3389d543ffdd", "patch": "@@ -97,6 +97,16 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n   if (NO_FUNCTION_CSE && CALL_P (insn))\n     return false;\n \n+  /* Remember if this insn has been sp += const_int.  */\n+  rtx sp_set = set_for_reg_notes (insn);\n+  rtx sp_addend = NULL_RTX;\n+  if (sp_set\n+      && SET_DEST (sp_set) == stack_pointer_rtx\n+      && GET_CODE (SET_SRC (sp_set)) == PLUS\n+      && XEXP (SET_SRC (sp_set), 0) == stack_pointer_rtx\n+      && CONST_INT_P (XEXP (SET_SRC (sp_set), 1)))\n+    sp_addend = XEXP (SET_SRC (sp_set), 1);\n+\n   if (GET_CODE (body) == SET)\n     {\n       int count = 0;\n@@ -180,6 +190,15 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n \treload_cse_simplify_operands (insn, testreg);\n     }\n \n+  /* If sp += const_int insn is changed into sp = reg;, add REG_EQUAL\n+     note so that the stack_adjustments pass can undo it if beneficial.  */\n+  if (sp_addend\n+      && SET_DEST (sp_set) == stack_pointer_rtx\n+      && REG_P (SET_SRC (sp_set)))\n+    set_dst_reg_note (insn, REG_EQUAL,\n+\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t    sp_addend), stack_pointer_rtx);\n+\n done:\n   return (EDGE_COUNT (insn_bb->succs) != insn_bb_succs);\n }"}]}