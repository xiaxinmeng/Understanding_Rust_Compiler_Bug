{"sha": "87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlM2RiYzkyYTFiYjExNGJkZGUwMGZlOGQ1NDFmN2ZjMTIxZTlkNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-07T16:07:42Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-07T16:07:42Z"}, "message": "Makefile.in (tree.o): Depend on ggc.h.\n\n\t* Makefile.in (tree.o): Depend on ggc.h.\n\t* class.c (make_method_vec): Remove.\n\t(free_method_vec): Likewise.\n\t(free_method_vecs): Remove.\n\t(add_method): Don't use them.\n\t* cp-tree.def (PTRMEM_CST): Make it longer.\n\t(TEMPLATE_PARM_INDEX): Make it shorter.\n\t* cp-tree.h (BINDING_HAS_LEVEL_P): New macro.\n\t(template_parm_index): Remove RTL field.\n\t(ptrmem_cst): Add RTL field.\n\t(finish_function): Removed parameter.\n\t(process_next_inline): Change prototype.\n\t(init_cplus_unsave): Rename to init_tree.\n\t(binding_init): Remove.\n\t* decl.c (free_binding_nodes): Remove.\n\t(push_binding): Don't use them.  Set BINDING_HAS_LEVEL_P.\n\t(pop_binding): Don't use free_binding_nodes.\n\t(free_binding_vecs): Remove.\n\t(store_bindings): Don't use them.\n\t(pop_from_top_level): Likewise.\n\t(lookup_namespace_name): Simplify.\n\t(build_typename_type): Don't use obstack_free.\n\t(unqualified_namespace_lookup): Simplify.\n\t(lookup_name_real): Simplify.\n\t(start_function): Remove comment about leaks.\n\t(finish_function): Removed nested parameter.  Call\n\texpand_end_bindings even when building_stmt_tree.\n\tCall ggc_push_context and ggc_pop_context around\n\trest_of_compilation, if necessary.\n\t(mark_cp_function_context): Handle a NULL language-context.\n\t(lang_mark_false_label_stack): Fix typo.\n\t(lang_mark_tree): Handle CPLUS_BINDING, OVERLOAD,\n\tTEMPLATE_PARM_INDEX.  Handle the funny TYPE_LANG_SPECIFIC on\n\tpointer to method types.\n\t(lang_cleanup_tree): Use free to free TYPE_LANG_SPECIFIC.\n\t* decl2.c (finish_objects): Adjust call to finish_function.\n\t(finish_static_store_duration_function): Likewise.\n\t(do_nonmember_using_decl): Remove call to binding_init.\n\t* except.c (end_anon_func): Adjust call to finish_function.\n\t* lex.c (mark_impl_file_chain): New function.\n\t(init_parse): Call init_tree, not init_cplus_unsave.\n\tAdd GC roots.\n\t(cp_pramga_interface): Use xmalloc, not permalloc.\n\t(cp_pragma_implementation): Likewise.\n\t(begin_definition_of_inclass_inline): Simplify.\n\t(process_next_inline): Adjust prototype.\n\t(do_scoped_id): Don't call binding_init.\n\t(make_lang_type): Allocate TYPE_LANG_SPECIFIC with xmalloc.\n\t(emit_thunk): Adjust call to finish_function.\n\t(synthesize_method): Likewise.\n\t* parse.y (%union): Add a new `pi' variant.\n\t(PRE_PARSED_FUNCTION_DECL): Use it.\n\t(fn.defpen): Likewise.\n\t(fndef): Adjust call to finish_function.\n\t(instantiate_decl): Likewise.\n\t(rtti.c): Likewise.\n\t(semantics.c): Likewise.\n\t* tree.c: Include ggc.h.\n\t(mark_list_hash): New function.\n\t(binding_init): Remove.\n\t(init_cplus_unsave): Rename to ...\n\t(init_tree): This.  Add GC roots.\n\nFrom-SVN: r29172", "tree": {"sha": "5caea69b4472a05021147247c1b01dfdbe9059bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5caea69b4472a05021147247c1b01dfdbe9059bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/comments", "author": null, "committer": null, "parents": [{"sha": "bcc5cac9a73b8d8903cd5b7ac7e789dfb26e1a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc5cac9a73b8d8903cd5b7ac7e789dfb26e1a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc5cac9a73b8d8903cd5b7ac7e789dfb26e1a7c"}], "stats": {"total": 3118, "additions": 1568, "deletions": 1550}, "files": [{"sha": "996ee3e4c9fa7d410a6c4e911fcd1e4f519af329", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -1,3 +1,68 @@\n+1999-09-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (tree.o): Depend on ggc.h.\n+\t* class.c (make_method_vec): Remove.\n+\t(free_method_vec): Likewise.\n+\t(free_method_vecs): Remove.\n+\t(add_method): Don't use them.\n+\t* cp-tree.def (PTRMEM_CST): Make it longer.\n+\t(TEMPLATE_PARM_INDEX): Make it shorter.\n+\t* cp-tree.h (BINDING_HAS_LEVEL_P): New macro.\n+\t(template_parm_index): Remove RTL field.\n+\t(ptrmem_cst): Add RTL field.\n+\t(finish_function): Removed parameter.\n+\t(process_next_inline): Change prototype.\n+\t(init_cplus_unsave): Rename to init_tree.\n+\t(binding_init): Remove.\n+\t* decl.c (free_binding_nodes): Remove.\n+\t(push_binding): Don't use them.  Set BINDING_HAS_LEVEL_P.\n+\t(pop_binding): Don't use free_binding_nodes.\n+\t(free_binding_vecs): Remove.\n+\t(store_bindings): Don't use them.\n+\t(pop_from_top_level): Likewise.\n+\t(lookup_namespace_name): Simplify.\n+\t(build_typename_type): Don't use obstack_free.\n+\t(unqualified_namespace_lookup): Simplify.\n+\t(lookup_name_real): Simplify.\n+\t(start_function): Remove comment about leaks.\n+\t(finish_function): Removed nested parameter.  Call\n+\texpand_end_bindings even when building_stmt_tree.\n+\tCall ggc_push_context and ggc_pop_context around\n+\trest_of_compilation, if necessary.\n+\t(mark_cp_function_context): Handle a NULL language-context.\n+\t(lang_mark_false_label_stack): Fix typo.\n+\t(lang_mark_tree): Handle CPLUS_BINDING, OVERLOAD,\n+\tTEMPLATE_PARM_INDEX.  Handle the funny TYPE_LANG_SPECIFIC on\n+\tpointer to method types.\n+\t(lang_cleanup_tree): Use free to free TYPE_LANG_SPECIFIC.\n+\t* decl2.c (finish_objects): Adjust call to finish_function.\n+\t(finish_static_store_duration_function): Likewise.\n+\t(do_nonmember_using_decl): Remove call to binding_init.\n+\t* except.c (end_anon_func): Adjust call to finish_function.\n+\t* lex.c (mark_impl_file_chain): New function.\n+\t(init_parse): Call init_tree, not init_cplus_unsave.\n+\tAdd GC roots.\n+\t(cp_pramga_interface): Use xmalloc, not permalloc.\n+\t(cp_pragma_implementation): Likewise.\n+\t(begin_definition_of_inclass_inline): Simplify.\n+\t(process_next_inline): Adjust prototype.\n+\t(do_scoped_id): Don't call binding_init.\n+\t(make_lang_type): Allocate TYPE_LANG_SPECIFIC with xmalloc.\n+\t(emit_thunk): Adjust call to finish_function.\n+\t(synthesize_method): Likewise.\n+\t* parse.y (%union): Add a new `pi' variant.\n+\t(PRE_PARSED_FUNCTION_DECL): Use it.\n+\t(fn.defpen): Likewise.\n+\t(fndef): Adjust call to finish_function.\n+\t(instantiate_decl): Likewise.\n+\t(rtti.c): Likewise.\n+\t(semantics.c): Likewise.\n+\t* tree.c: Include ggc.h.\n+\t(mark_list_hash): New function.\n+\t(binding_init): Remove.\n+\t(init_cplus_unsave): Rename to ...\n+\t(init_tree): This.  Add GC roots.\n+\t\n 1999-09-05  Mark Mitchell  <mark@codesourcery.com>\n \n \tGet ready for garbage collection."}, {"sha": "621567b59d008ca611bd94ac4c800b3eda4852f5", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -271,7 +271,7 @@ cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h decl.h \\\n search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h \\\n   $(srcdir)/../flags.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h\n rtti.o : rtti.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h"}, {"sha": "ab417f505ea0db50113e3b56808a4c130daa74a9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -115,8 +115,6 @@ static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n static int field_decl_cmp PROTO ((const tree *, const tree *));\n static int method_name_cmp PROTO ((const tree *, const tree *));\n-static tree make_method_vec PROTO((int));\n-static void free_method_vec PROTO((tree));\n static tree add_implicitly_declared_members PROTO((tree, int, int, int));\n static tree fixed_type_or_null PROTO((tree, int *));\n static tree resolve_address_of_overloaded_function PROTO((tree, tree, int,\n@@ -1066,46 +1064,6 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n struct obstack class_obstack;\n extern struct obstack *current_obstack;\n \n-/* These are method vectors that were too small for the number of\n-   methods in some class, and so were abandoned.  */\n-static tree free_method_vecs;\n-\n-/* Returns a method vector with enough room for N methods.  N should\n-   be a power of two.  */\n-\n-static tree\n-make_method_vec (n)\n-     int n;\n-{\n-  tree new_vec;\n-  tree* t;\n-  \n-  for (t = &free_method_vecs; *t; t = &(TREE_CHAIN (*t)))\n-    /* Note that we don't use >= n here because we don't want to\n-       allocate a very large vector where it isn't needed.  */\n-    if (TREE_VEC_LENGTH (*t) == n)\n-      {\n-\tnew_vec = *t;\n-\t*t = TREE_CHAIN (new_vec);\n-\tTREE_CHAIN (new_vec) = NULL_TREE;\n-\tbzero ((PTR) &TREE_VEC_ELT (new_vec, 0), n * sizeof (tree));\n-\treturn new_vec;\n-      }\n-\n-  new_vec = make_tree_vec (n);\n-  return new_vec;\n-}\n-\n-/* Free the method vector VEC.  */\n-\n-static void\n-free_method_vec (vec)\n-     tree vec;\n-{\n-  TREE_CHAIN (vec) = free_method_vecs;\n-  free_method_vecs = vec;\n-}\n-\n /* Add method METHOD to class TYPE.\n \n    If non-NULL, FIELDS is the entry in the METHOD_VEC vector entry of\n@@ -1141,9 +1099,8 @@ add_method (type, fields, method)\n \t   memory making the links in the list than we would by\n \t   over-allocating the size of the vector here.  Furthermore,\n \t   we would complicate all the code that expects this to be a\n-\t   vector.  We keep a free list of vectors that we outgrew so\n-\t   that we don't really waste any memory.  */\n-\tCLASSTYPE_METHOD_VEC (type) = make_method_vec (8);\n+\t   vector.  */\n+\tCLASSTYPE_METHOD_VEC (type) = make_tree_vec (8);\n \n       method_vec = CLASSTYPE_METHOD_VEC (type);\n       len = TREE_VEC_LENGTH (method_vec);\n@@ -1165,11 +1122,10 @@ add_method (type, fields, method)\n \t  if (slot == len)\n \t    {\n \t      /* We need a bigger method vector.  */\n-\t      tree new_vec = make_method_vec (2 * len);\n+\t      tree new_vec = make_tree_vec (2 * len);\n \t      bcopy ((PTR) &TREE_VEC_ELT (method_vec, 0),\n \t\t     (PTR) &TREE_VEC_ELT (new_vec, 0),\n \t\t     len * sizeof (tree));\n-\t      free_method_vec (method_vec);\n \t      len = 2 * len;\n \t      method_vec = CLASSTYPE_METHOD_VEC (type) = new_vec;\n \t    }"}, {"sha": "3322786ce2c53722befc29de87bb7419bc31de37", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -32,7 +32,7 @@ DEFTREECODE (OFFSET_REF, \"offset_ref\", 'r', 2)\n /* A pointer-to-member constant.  For a pointer-to-member constant\n    `X::Y' The PTRMEM_CST_CLASS is the RECORD_TYPE for `X' and the\n    PTRMEM_CST_MEMBER is the _DECL for `Y'.  */\n-DEFTREECODE (PTRMEM_CST, \"ptrmem_cst\", 'c', 1)\n+DEFTREECODE (PTRMEM_CST, \"ptrmem_cst\", 'c', 2)\n \n /* For NEW_EXPR, operand 0 is the placement list.\n    Operand 1 is the new-declarator.\n@@ -130,7 +130,7 @@ DEFTREECODE (TEMPLATE_PARM_INDEX, \"template_parm_index\", 'x',\n \t\texpression is to ensure against the case where\n \t\tsizeof(char*) does not evenly divide\n \t\tsizeof(HOST_WIDE_INT).  */\n-\t     2 + ((3 * sizeof (HOST_WIDE_INT) + sizeof(char*) - 1)\n+\t     1 + ((3 * sizeof (HOST_WIDE_INT) + sizeof(char*) - 1)\n \t\t  / sizeof (char*)))\n \n /* Index into a template parameter list.  This parameter must be a type."}, {"sha": "d7ca7a7ea80feb577e90473ed9ac6f3a1cbf8f59", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -54,6 +54,7 @@ Boston, MA 02111-1307, USA.  */\n       BINFO_FIELDS_MARKED.\n       TYPE_VIRTUAL_P.\n       ICS_THIS_FLAG (in _CONV)\n+      BINDING_HAS_LEVEL_P (In CPLUS_BINDING)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n       BINFO_VTABLE_PATH_MARKED.\n       BINFO_PUSHDECLS_MARKED.\n@@ -139,8 +140,6 @@ typedef struct\n typedef struct \n {\n   char common[sizeof (struct tree_common)];\n-  struct rtx_def *rtl;\t/* Unused, but required to match up with what\n-\t\t\t   the middle-end expects.  */\n   HOST_WIDE_INT index;\n   HOST_WIDE_INT level;\n   HOST_WIDE_INT orig_level;\n@@ -150,6 +149,9 @@ typedef struct\n typedef struct ptrmem_cst\n {\n   char common[sizeof (struct tree_common)];\n+  /* This isn't used, but the middle-end expects all constants to have \n+     this field.  */\n+  struct rtx_def *rtl;\n   tree member;\n }* ptrmem_cst_t;\n \n@@ -168,6 +170,9 @@ typedef struct ptrmem_cst\n    BINDING_LEVEL is used instead.  */\n #define BINDING_SCOPE(NODE) (((struct tree_binding*)NODE)->scope.scope)\n \n+/* Nonzero if NODE has BINDING_LEVEL, rather than BINDING_SCOPE.  */\n+#define BINDING_HAS_LEVEL_P(NODE) TREE_LANG_FLAG_2 ((NODE))\n+\n /* This is the declaration bound to the name. Possible values:\n    variable, overloaded function, namespace, template, enumerator.  */\n #define BINDING_VALUE(NODE)    (((struct tree_binding*)NODE)->value)\n@@ -3174,7 +3179,7 @@ extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n extern void expand_start_early_try_stmts\tPROTO((void));\n extern void store_parm_decls\t\t\tPROTO((void));\n extern void store_return_init\t\t\tPROTO((tree));\n-extern void finish_function\t\t\tPROTO((int, int, int));\n+extern void finish_function\t\t\tPROTO((int, int));\n extern tree start_method\t\t\tPROTO((tree, tree, tree));\n extern tree finish_method\t\t\tPROTO((tree));\n extern void hack_incomplete_structures\t\tPROTO((tree));\n@@ -3376,7 +3381,7 @@ extern void reinit_parse_for_function\t\tPROTO((void));\n extern void print_parse_statistics\t\tPROTO((void));\n extern void extract_interface_info\t\tPROTO((void));\n extern void do_pending_inlines\t\t\tPROTO((void));\n-extern void process_next_inline\t\t\tPROTO((tree));\n+extern void process_next_inline\t\t\tPROTO((struct pending_inline *));\n extern struct pending_input *save_pending_input PROTO((void));\n extern void restore_pending_input\t\tPROTO((struct pending_input *));\n extern void yyungetc\t\t\t\tPROTO((int, int));\n@@ -3640,7 +3645,7 @@ extern int yylex\t\t\t\tPROTO((void));\n extern tree arbitrate_lookup\t\t\tPROTO((tree, tree, tree));\n \n /* in tree.c */\n-extern void init_cplus_unsave\t\t\tPROTO((void));\n+extern void init_tree\t\t\t        PROTO((void));\n extern void cplus_unsave_expr_now               PROTO((tree));\n extern int pod_type_p\t\t\t\tPROTO((tree));\n extern void unshare_base_binfos\t\t\tPROTO((tree));\n@@ -3670,7 +3675,6 @@ extern tree reverse_path\t\t\tPROTO((tree));\n extern int count_functions\t\t\tPROTO((tree));\n extern int is_overloaded_fn\t\t\tPROTO((tree));\n extern tree get_first_fn\t\t\tPROTO((tree));\n-extern tree binding_init                        PROTO((struct tree_binding*));\n extern int bound_pmf_p\t\t\t\tPROTO((tree));\n extern tree ovl_cons                            PROTO((tree, tree));\n extern tree scratch_ovl_cons                    PROTO((tree, tree));"}, {"sha": "b5c5806444c8be66d019dfaaa6bda8d8e57836e0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 64, "deletions": 82, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -946,11 +946,6 @@ pushlevel_temporary (tag_transparent)\n #define BINDING_LEVEL(NODE) \\\n    (((struct tree_binding*)NODE)->scope.level)\n \n-/* These are currently unused, but permanent, CPLUS_BINDING nodes.\n-   They are kept here because they are allocated from the permanent\n-   obstack and cannot be easily freed.  */\n-static tree free_binding_nodes;\n-\n /* Make DECL the innermost binding for ID.  The LEVEL is the binding\n    level at which this declaration is being bound.  */\n \n@@ -962,28 +957,15 @@ push_binding (id, decl, level)\n {\n   tree binding;\n \n-  if (!free_binding_nodes)\n-    {\n-      /* There are no free nodes, so we must build one here.  */\n-      push_permanent_obstack ();\n-      binding = make_node (CPLUS_BINDING);\n-      pop_obstacks ();\n-    }\n-  else\n-    {\n-      /* There are nodes on the free list.  Grab the first one.  */\n-      binding = free_binding_nodes;\n-      \n-      /* And update the free list.  */\n-      free_binding_nodes = TREE_CHAIN (free_binding_nodes);\n-    }\n+  binding = make_node (CPLUS_BINDING);\n \n   /* Now, fill in the binding information.  */\n   BINDING_VALUE (binding) = decl;\n   BINDING_TYPE (binding) = NULL_TREE;\n   BINDING_LEVEL (binding) = level;\n   INHERITED_VALUE_BINDING_P (binding) = 0;\n   LOCAL_BINDING_P (binding) = (level != class_binding_level);\n+  BINDING_HAS_LEVEL_P (binding) = 1;\n \n   /* And put it on the front of the list of bindings for ID.  */\n   TREE_CHAIN (binding) = IDENTIFIER_BINDING (id);\n@@ -1210,15 +1192,9 @@ pop_binding (id, decl)\n     my_friendly_abort (0);\n \n   if (!BINDING_VALUE (binding) && !BINDING_TYPE (binding))\n-    {\n-      /* We're completely done with the innermost binding for this\n-\t identifier.  Unhook it from the list of bindings.  */\n-      IDENTIFIER_BINDING (id) = TREE_CHAIN (binding);\n-\n-      /* And place it on the free list.  */\n-      TREE_CHAIN (binding) = free_binding_nodes;\n-      free_binding_nodes = binding;\n-    }\n+    /* We're completely done with the innermost binding for this\n+       identifier.  Unhook it from the list of bindings.  */\n+    IDENTIFIER_BINDING (id) = TREE_CHAIN (binding);\n }\n \n /* When a label goes out of scope, check to see if that label was used\n@@ -2424,11 +2400,6 @@ mark_saved_scope (arg)\n     }\n }\n \n-/* A chain of the binding vecs created by store_bindings.  We create a\n-   whole bunch of these during compilation, on permanent_obstack, so we\n-   can't just throw them away.  */\n-static tree free_binding_vecs;\n-\n static tree\n store_bindings (names, old_bindings)\n      tree names, old_bindings;\n@@ -2454,13 +2425,7 @@ store_bindings (names, old_bindings)\n \tif (TREE_VEC_ELT (t1, 0) == id)\n \t  goto skip_it;\n \n-      if (free_binding_vecs)\n-\t{\n-\t  binding = free_binding_vecs;\n-\t  free_binding_vecs = TREE_CHAIN (free_binding_vecs);\n-\t}\n-      else\n-\tbinding = make_tree_vec (4);\n+      binding = make_tree_vec (4);\n \n       if (id)\n \t{\n@@ -2567,19 +2532,15 @@ pop_from_top_level ()\n   VARRAY_FREE (current_lang_base);\n \n   scope_chain = s->prev;\n-  for (t = s->old_bindings; t; )\n+  for (t = s->old_bindings; t; t = TREE_CHAIN (t))\n     {\n-      tree save = t;\n       tree id = TREE_VEC_ELT (t, 0);\n       if (id)\n \t{\n \t  SET_IDENTIFIER_TYPE_VALUE (id, TREE_VEC_ELT (t, 1));\n \t  IDENTIFIER_BINDING (id) = TREE_VEC_ELT (t, 2);\n \t  IDENTIFIER_CLASS_VALUE (id) = TREE_VEC_ELT (t, 3);\n  \t}\n-      t = TREE_CHAIN (t);\n-      TREE_CHAIN (save) = free_binding_vecs;\n-      free_binding_vecs = save;\n     }\n \n   if (current_lang_name == lang_name_cplusplus)\n@@ -5262,7 +5223,6 @@ tree\n lookup_namespace_name (namespace, name)\n      tree namespace, name;\n {\n-  struct tree_binding _b;\n   tree val;\n   tree template_id = NULL_TREE;\n \n@@ -5293,7 +5253,7 @@ lookup_namespace_name (namespace, name)\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n   \n-  val = binding_init (&_b);\n+  val = make_node (CPLUS_BINDING);\n   if (!qualified_lookup_using_namespace (name, namespace, val, 0))\n     return error_mark_node;\n \n@@ -5425,12 +5385,7 @@ build_typename_type (context, name, fullname, base_type)\n   /* See if we already have this type.  */\n   e = hash_lookup (&ht, t, /*create=*/false, /*copy=*/0);\n   if (e)\n-    {\n-      /* This will free not only TREE_TYPE, but the lang-specific data\n-\t and the TYPE_DECL as well.  */\n-      obstack_free (&permanent_obstack, t);\n-      t = (tree) e->key;\n-    }\n+    t = (tree) e->key;\n   else\n     /* Insert the type into the table.  */\n     hash_lookup (&ht, t, /*create=*/true, /*copy=*/0);\n@@ -5571,8 +5526,7 @@ unqualified_namespace_lookup (name, flags, spacesp)\n      int flags;\n      tree *spacesp;\n {\n-  struct tree_binding _binding;\n-  tree b = binding_init (&_binding);\n+  tree b = make_node (CPLUS_BINDING);\n   tree initial = current_decl_namespace();\n   tree scope = initial;\n   tree siter;\n@@ -5750,8 +5704,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t    type = global_namespace;\n \t  if (TREE_CODE (type) == NAMESPACE_DECL)\n \t    {\n-\t      struct tree_binding b;\n-\t      val = binding_init (&b);\n+\t      val = make_node (CPLUS_BINDING);\n \t      flags |= LOOKUP_COMPLAIN;\n \t      if (!qualified_lookup_using_namespace (name, type, val, flags))\n \t\treturn NULL_TREE;\n@@ -12930,11 +12883,7 @@ static int function_depth;\n    For C++, we must first check whether that datum makes any sense.\n    For example, \"class A local_a(1,2);\" means that variable local_a\n    is an aggregate of type A, which should have a constructor\n-   applied to it with the argument list [1, 2].\n-\n-   @@ There is currently no way to retrieve the storage\n-   @@ allocated to FUNCTION (or all of its parms) if we return\n-   @@ something we had previously.  */\n+   applied to it with the argument list [1, 2].  */\n \n int\n start_function (declspecs, declarator, attrs, pre_parsed_p)\n@@ -13550,16 +13499,12 @@ store_return_init (decl)\n      2 - INCLASS_INLINE\n        We just finished processing the body of an in-class inline\n        function definition.  (This processing will have taken place\n-       after the class definition is complete.)\n-\n-   NESTED is nonzero if we were in the middle of compiling another function\n-   when we started on this one.  */\n+       after the class definition is complete.)  */\n \n void\n-finish_function (lineno, flags, nested)\n+finish_function (lineno, flags)\n      int lineno;\n      int flags;\n-     int nested;\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n@@ -13570,15 +13515,14 @@ finish_function (lineno, flags, nested)\n   int call_poplevel = (flags & 1) != 0;\n   int inclass_inline = (flags & 2) != 0;\n   int expand_p;\n+  int nested;\n \n   /* When we get some parse errors, we can end up without a\n      current_function_decl, so cope.  */\n   if (fndecl == NULL_TREE)\n     return;\n \n-  if (function_depth > 1)\n-    nested = 1;\n-\n+  nested = function_depth > 1;\n   fntype = TREE_TYPE (fndecl);\n \n /*  TREE_READONLY (fndecl) = 1;\n@@ -13600,6 +13544,15 @@ finish_function (lineno, flags, nested)\n \t  expand_end_bindings (decls, decls != NULL_TREE, 0);\n \t  poplevel (decls != NULL_TREE, 0, 0);\n \t}\n+\n+      /* Because we do not call expand_function_end, we won't call\n+\t expand_end_bindings to match the call to\n+\t expand_start_bindings we did in store_parm_decls.  Therefore,\n+\t we explicitly call expand_end_bindings here.  However, we\n+\t really shouldn't be calling expand_start_bindings at all when\n+\t building_stmt_tree; it's conceptually an RTL-generation\n+\t function, rather than a front-end function.  */\n+      expand_end_bindings (0, 0, 0);\n     }\n   else\n     {\n@@ -14041,9 +13994,16 @@ finish_function (lineno, flags, nested)\n \t   function is gone.  See save_tree_status.  */\n \tflag_keep_inline_functions = 1;\n \n+      /* If this is a nested function (like a template instantiation\n+\t that we're compiling in the midst of compiling something\n+\t else), push a new GC context.  That will keep local variables\n+\t on the stack from being collected while we're doing the\n+\t compilation of this function.  */\n+      if (function_depth > 1)\n+\tggc_push_context ();\n+\n       /* Run the optimizers and output the assembler code for this\n          function.  */\n-\n       if (DECL_ARTIFICIAL (fndecl))\n \t{\n \t  /* Do we really *want* to inline this synthesized method?  */\n@@ -14061,6 +14021,10 @@ finish_function (lineno, flags, nested)\n       else\n \trest_of_compilation (fndecl);\n \n+      /* Undo the call to ggc_push_context above.  */\n+      if (function_depth > 1)\n+\tggc_pop_context ();\n+\n       flag_keep_inline_functions = saved_flag_keep_inline_functions;\n \n       if (DECL_SAVED_INSNS (fndecl) && ! TREE_ASM_WRITTEN (fndecl))\n@@ -14557,6 +14521,9 @@ mark_cp_function_context (f)\n {\n   struct language_function *p = f->language;\n \n+  if (!p)\n+    return;\n+\n   ggc_mark_tree (p->x_named_labels);\n   ggc_mark_tree (p->x_ctor_label);\n   ggc_mark_tree (p->x_dtor_label);\n@@ -14588,7 +14555,7 @@ lang_mark_false_label_stack (l)\n      struct label_node *l;\n {\n   /* C++ doesn't use false_label_stack.  It better be NULL.  */\n-  my_friendly_assert (l != NULL, 19990904);\n+  my_friendly_assert (l == NULL, 19990904);\n }\n \n void\n@@ -14611,6 +14578,18 @@ lang_mark_tree (t)\n \t  ggc_mark_tree (li2->error_locus);\n \t}\n     }\n+  else if (code == CPLUS_BINDING)\n+    {\n+      if (BINDING_HAS_LEVEL_P (t))\n+\tmark_binding_level (&BINDING_LEVEL (t));\n+      else\n+\tggc_mark_tree (BINDING_SCOPE (t));\n+      ggc_mark_tree (BINDING_VALUE (t));\n+    }\n+  else if (code == OVERLOAD)\n+    ggc_mark_tree (OVL_FUNCTION (t));\n+  else if (code == TEMPLATE_PARM_INDEX)\n+    ggc_mark_tree (TEMPLATE_PARM_DECL (t));\n   else if (TREE_CODE_CLASS (code) == 'd')\n     {\n       struct lang_decl *ld = DECL_LANG_SPECIFIC (t);\n@@ -14635,7 +14614,8 @@ lang_mark_tree (t)\n     {\n       struct lang_type *lt = TYPE_LANG_SPECIFIC (t);\n \n-      if (lt)\n+      if (lt && !(TREE_CODE (t) == POINTER_TYPE \n+\t\t  && TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE))\n \t{\n \t  ggc_mark_tree (lt->vfields);\n \t  ggc_mark_tree (lt->vbases);\n@@ -14647,7 +14627,12 @@ lang_mark_tree (t)\n \t  ggc_mark_tree (lt->rtti);\n \t  ggc_mark_tree (lt->methods);\n \t  ggc_mark_tree (lt->template_info);\n+\t  ggc_mark_tree (lt->befriending_classes);\n \t}\n+      else if (lt)\n+\t/* In the case of pointer-to-member function types, the\n+\t   TYPE_LANG_SPECIFIC is really just a tree.  */\n+\tggc_mark_tree ((tree) lt);\n     }\n }\n \n@@ -14656,11 +14641,8 @@ lang_cleanup_tree (t)\n      tree t;\n {\n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't'\n-      && TYPE_LANG_SPECIFIC (t) != NULL)\n-    {\n-#if 0\n-      /* This is currently allocated with an obstack.  This will change.  */\n-      free (TYPE_LANG_SPECIFIC (t));\n-#endif\n-    }\n+      && TYPE_LANG_SPECIFIC (t) != NULL\n+      && !(TREE_CODE (t) == POINTER_TYPE \n+\t\t  && TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE))\n+    free (TYPE_LANG_SPECIFIC (t));\n }"}, {"sha": "6ca93f9c0248f8bff6c9170679a09ce3a1329e44", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -2860,7 +2860,7 @@ finish_objects (method_type, initp)\n   expand_end_bindings (getdecls (), 1, 0);\n   poplevel (1, 0, 0);\n   pop_momentary ();\n-  finish_function (lineno, 0, 0);\n+  finish_function (lineno, 0);\n \n   if (initp == DEFAULT_INIT_PRIORITY)\n     {\n@@ -3111,7 +3111,7 @@ finish_static_storage_duration_function ()\n   expand_end_bindings (getdecls (), 1, 0);\n   poplevel (1, 0, 0);\n   pop_momentary ();\n-  finish_function (lineno, 0, 0);\n+  finish_function (lineno, 0);\n }\n \n /* Return the information about the indicated PRIORITY level.  If no\n@@ -4950,10 +4950,9 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n      tree *newval, *newtype;\n {\n   tree decls;\n-  struct tree_binding _decls;\n \n   *newval = *newtype = NULL_TREE;\n-  decls = binding_init (&_decls);\n+  decls = make_node (CPLUS_BINDING);\n   if (!qualified_lookup_using_namespace (name, scope, decls, 0))\n     /* Lookup error */\n     return;"}, {"sha": "87c6e470d0b058fd5e236c04dd63d2ee8dcf54b5", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -838,7 +838,7 @@ end_anon_func ()\n   poplevel (1, 0, 0);\n   pop_momentary ();\n \n-  finish_function (lineno, 0, 0);\n+  finish_function (lineno, 0);\n \n   pop_from_top_level ();\n   pop_function_context_from (NULL_TREE);"}, {"sha": "51f0c0028f44580661f714aa00f95bc578d4aab8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 50, "deletions": 43, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -94,6 +94,7 @@ static void pragma_ungetc PROTO((int));\n static int read_line_number PROTO((int *));\n static int token_getch PROTO ((void));\n static void token_put_back PROTO ((int));\n+static void mark_impl_file_chain PROTO ((void *));\n \n /* Given a file name X, return the nondirectory portion.\n    Keep in mind that X can be computed more than once.  */\n@@ -185,6 +186,33 @@ extern int *token_count;\n static tree defarg_fns;\n static tree defarg_parm;\n \n+/* Functions and data structures for #pragma interface.\n+\n+   `#pragma implementation' means that the main file being compiled\n+   is considered to implement (provide) the classes that appear in\n+   its main body.  I.e., if this is file \"foo.cc\", and class `bar'\n+   is defined in \"foo.cc\", then we say that \"foo.cc implements bar\".\n+\n+   All main input files \"implement\" themselves automagically.\n+\n+   `#pragma interface' means that unless this file (of the form \"foo.h\"\n+   is not presently being included by file \"foo.cc\", the\n+   CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none\n+   of the vtables nor any of the inline functions defined in foo.h\n+   will ever be output.\n+\n+   There are cases when we want to link files such as \"defs.h\" and\n+   \"main.cc\".  In this case, we give \"defs.h\" a `#pragma interface',\n+   and \"main.cc\" has `#pragma implementation \"defs.h\"'.  */\n+\n+struct impl_files\n+{\n+  char *filename;\n+  struct impl_files *next;\n+};\n+\n+static struct impl_files *impl_file_chain;\n+\n \f\n /* Return something to represent absolute declarators containing a *.\n    TARGET is the absolute declarator that the * contains.\n@@ -544,7 +572,7 @@ init_parse (filename)\n   set_identifier_size (sizeof (struct lang_identifier));\n   decl_printable_name = lang_printable_name;\n \n-  init_cplus_unsave ();\n+  init_tree ();\n   init_cplus_expand ();\n \n   memcpy (tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE,\n@@ -894,7 +922,8 @@ init_parse (filename)\n   ggc_add_tree_root (&defarg_parm, 1);\n   ggc_add_tree_root (&this_filename_time, 1);\n   ggc_add_tree_root (&filename_times, 1);\n-\n+  ggc_add_root (&impl_file_chain, 1, sizeof (impl_file_chain),\n+\t\tmark_impl_file_chain);\n   return filename;\n }\n \n@@ -1091,32 +1120,18 @@ set_yydebug (value)\n }\n \n \f\n-/* Functions and data structures for #pragma interface.\n-\n-   `#pragma implementation' means that the main file being compiled\n-   is considered to implement (provide) the classes that appear in\n-   its main body.  I.e., if this is file \"foo.cc\", and class `bar'\n-   is defined in \"foo.cc\", then we say that \"foo.cc implements bar\".\n-\n-   All main input files \"implement\" themselves automagically.\n-\n-   `#pragma interface' means that unless this file (of the form \"foo.h\"\n-   is not presently being included by file \"foo.cc\", the\n-   CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none\n-   of the vtables nor any of the inline functions defined in foo.h\n-   will ever be output.\n+/* Mark ARG (which is really a struct impl_files **) for GC.  */\n \n-   There are cases when we want to link files such as \"defs.h\" and\n-   \"main.cc\".  In this case, we give \"defs.h\" a `#pragma interface',\n-   and \"main.cc\" has `#pragma implementation \"defs.h\"'.  */\n-\n-struct impl_files\n+static void\n+mark_impl_file_chain (arg)\n+     void *arg;\n {\n-  char *filename;\n-  struct impl_files *next;\n-};\n+  struct impl_files *ifs;\n \n-static struct impl_files *impl_file_chain;\n+  ifs = *(struct impl_files **) arg;\n+  if (ifs)\n+    ggc_mark_string (ifs->filename);\n+}\n \n /* Helper function to load global variables with interface\n    information.  */\n@@ -1202,7 +1217,8 @@ cp_pragma_interface (main_filename)\n       TREE_INT_CST_LOW (fi) = 0;\n       TREE_INT_CST_HIGH (fi) = 1;\n       /* Get default.  */\n-      impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n+      impl_file_chain \n+\t= (struct impl_files *) xmalloc (sizeof (struct impl_files));\n       impl_file_chain->filename = filename;\n       impl_file_chain->next = 0;\n #endif\n@@ -1237,7 +1253,7 @@ cp_pragma_implementation (main_filename)\n \t}\n       if (ifiles == 0)\n \t{\n-\t  ifiles = (struct impl_files*) permalloc (sizeof (struct impl_files));\n+\t  ifiles = (struct impl_files*) xmalloc (sizeof (struct impl_files));\n \t  ifiles->filename = main_filename;\n \t  ifiles->next = impl_file_chain;\n \t  impl_file_chain = ifiles;\n@@ -1247,7 +1263,7 @@ cp_pragma_implementation (main_filename)\n \t    && ! strcmp (main_input_filename, input_filename))\n \t   || ! strcmp (main_filename, input_filename))\n     {\n-      impl_file_chain = (struct impl_files*) permalloc (sizeof (struct impl_files));\n+      impl_file_chain = (struct impl_files*) xmalloc (sizeof (struct impl_files));\n       impl_file_chain->filename = main_filename;\n       impl_file_chain->next = 0;\n     }\n@@ -1289,7 +1305,7 @@ begin_definition_of_inclass_inline (pi)\n \n   feed_input (pi->buf, pi->len, pi->filename, pi->lineno);\n   yychar = PRE_PARSED_FUNCTION_DECL;\n-  yylval.ttype = build_tree_list ((tree) pi, pi->fndecl);\n+  yylval.pi = pi;\n   /* Pass back a handle to the rest of the inline functions, so that they\n      can be processed later.  */\n   DECL_PENDING_INLINE_INFO (pi->fndecl) = 0;\n@@ -1340,11 +1356,10 @@ do_pending_inlines ()\n    do_pending_inlines).  */\n \n void\n-process_next_inline (t)\n-     tree t;\n+process_next_inline (i)\n+     struct pending_inline *i;\n {\n   tree context;\n-  struct pending_inline *i = (struct pending_inline *) TREE_PURPOSE (t);\n   context = hack_decl_function_context (i->fndecl);  \n   if (context)\n     pop_function_context_from (context);\n@@ -2539,7 +2554,7 @@ check_newline ()\n       body_time = this_time;\n     }\n \n-  if (!TREE_PERMANENT (yylval.ttype))\n+  if (! ggc_p && !TREE_PERMANENT (yylval.ttype))\n     {\n       input_filename\n \t= (char *) permalloc (TREE_STRING_LENGTH (yylval.ttype) + 1);\n@@ -3254,8 +3269,7 @@ do_scoped_id (token, parsing)\n   /* during parsing, this is ::name. Otherwise, it is black magic. */\n   if (parsing)\n     {\n-      struct tree_binding _b;\n-      id = binding_init (&_b);\n+      id = make_node (CPLUS_BINDING);\n       if (!qualified_lookup_using_namespace (token, global_namespace, id, 0))\n \tid = NULL_TREE;\n       else\n@@ -4836,23 +4850,16 @@ tree\n make_lang_type (code)\n      enum tree_code code;\n {\n-  extern struct obstack *current_obstack, *saveable_obstack;\n   register tree t = make_node (code);\n \n   /* Set up some flags that give proper default behavior.  */\n   if (IS_AGGR_TYPE_CODE (code))\n     {\n-      struct obstack *obstack = current_obstack;\n       struct lang_type *pi;\n \n       SET_IS_AGGR_TYPE (t, 1);\n \n-      if (! TREE_PERMANENT (t))\n-\tobstack = saveable_obstack;\n-      else\n-\tmy_friendly_assert (obstack == &permanent_obstack, 236);\n-\n-      pi = (struct lang_type *) obstack_alloc (obstack, sizeof (struct lang_type));\n+      pi = (struct lang_type *) xmalloc (sizeof (struct lang_type));\n       bzero ((char *) pi, (int) sizeof (struct lang_type));\n \n       TYPE_LANG_SPECIFIC (t) = pi;"}, {"sha": "80e6bf453d02b51632fd7bd998dfa19debcc5f08", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 1316, "deletions": 1318, "changes": 2634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6"}, {"sha": "67d0f575df165cefea84fe1d3bce8461d568a6be", "filename": "gcc/cp/parse.h", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.h?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -1,4 +1,11 @@\n-typedef union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; } YYSTYPE;\n+typedef union {\n+  long itype; \n+  tree ttype; \n+  char *strtype; \n+  enum tree_code code; \n+  flagged_type_tree ftype; \n+  struct pending_inline *pi;\n+} YYSTYPE;\n #define\tIDENTIFIER\t257\n #define\tTYPENAME\t258\n #define\tSELFNAME\t259\n@@ -73,12 +80,12 @@ typedef union {long itype; tree ttype; char *strtype; enum tree_code code; flagg\n #define\tPOINTSAT\t328\n #define\tTRY\t329\n #define\tCATCH\t330\n-#define\tPRE_PARSED_FUNCTION_DECL\t331\n-#define\tEXTERN_LANG_STRING\t332\n-#define\tALL\t333\n-#define\tPRE_PARSED_CLASS_DECL\t334\n-#define\tDEFARG\t335\n-#define\tDEFARG_MARKER\t336\n+#define\tEXTERN_LANG_STRING\t331\n+#define\tALL\t332\n+#define\tPRE_PARSED_CLASS_DECL\t333\n+#define\tDEFARG\t334\n+#define\tDEFARG_MARKER\t335\n+#define\tPRE_PARSED_FUNCTION_DECL\t336\n #define\tTYPENAME_DEFN\t337\n #define\tIDENTIFIER_DEFN\t338\n #define\tPTYPENAME_DEFN\t339"}, {"sha": "cf69bc1dd881d361eaf5e61f7b2606c078f695a8", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -90,7 +90,14 @@ empty_parms ()\n \n %start program\n \n-%union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; }\n+%union {\n+  long itype; \n+  tree ttype; \n+  char *strtype; \n+  enum tree_code code; \n+  flagged_type_tree ftype; \n+  struct pending_inline *pi;\n+}\n \n /* All identifiers that are not reserved words\n    and are not declared typedefs in the current block */\n@@ -236,10 +243,12 @@ empty_parms ()\n \n /* C++ extensions */\n %token <ttype> PTYPENAME\n-%token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n+%token <ttype> EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER\n+%token <pi> PRE_PARSED_FUNCTION_DECL \n %type <ttype> component_constructor_declarator\n-%type <ttype> fn.def2 return_id fn.defpen constructor_declarator\n+%type <ttype> fn.def2 return_id constructor_declarator\n+%type <pi> fn.defpen \n %type <itype> ctor_initializer_opt function_try_block\n %type <ttype> named_class_head_sans_basetype\n %type <ftype> class_head named_class_head \n@@ -311,7 +320,7 @@ extern void yyprint\t\t\tPROTO((FILE *, int, YYSTYPE));\n extern tree combine_strings\t\tPROTO((tree));\n \n static int\n-parse_decl(declarator, specs_attrs, attributes, initialized, decl)\n+parse_decl (declarator, specs_attrs, attributes, initialized, decl)\n   tree declarator;\n   tree specs_attrs;\n   tree attributes;\n@@ -651,13 +660,9 @@ eat_saved_input:\n \n fndef:\n \t  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error\n-\t\t{ finish_function (lineno, (int)$3, 0); }\n+\t\t{ finish_function (lineno, (int)$3); }\n \t| fn.def1 maybe_return_init function_try_block\n-\t\t{ \n-\t\t  int nested = (hack_decl_function_context\n-\t\t\t\t(current_function_decl) != NULL_TREE);\n-\t\t  finish_function (lineno, (int)$3, nested); \n-\t\t}\n+\t\t{ finish_function (lineno, (int)$3); }\n \t| fn.def1 maybe_return_init error\n \t\t{ }\n \t;\n@@ -2059,23 +2064,18 @@ initlist:\n \n fn.defpen:\n \tPRE_PARSED_FUNCTION_DECL\n-\t\t{ start_function (NULL_TREE, TREE_VALUE ($1),\n-\t\t\t\t  NULL_TREE, 2);\n+\t\t{ start_function (NULL_TREE, $1->fndecl, NULL_TREE, 2);\n \t\t  reinit_parse_for_function (); }\n \n pending_inline:\n \t  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error\n \t\t{\n-\t\t  int nested = (hack_decl_function_context\n-\t\t\t\t(current_function_decl) != NULL_TREE);\n-\t\t  finish_function (lineno, (int)$3 | 2, nested);\n+\t\t  finish_function (lineno, (int)$3 | 2);\n \t\t  process_next_inline ($1);\n \t\t}\n \t| fn.defpen maybe_return_init function_try_block\n \t\t{ \n-\t\t  int nested = (hack_decl_function_context\n-\t\t\t\t(current_function_decl) != NULL_TREE);\n-\t\t  finish_function (lineno, (int)$3 | 2, nested); \n+\t\t  finish_function (lineno, (int)$3 | 2); \n                   process_next_inline ($1);\n \t\t}\n \t| fn.defpen maybe_return_init error"}, {"sha": "d3878ef7dc21c457166faa9b68854cc9e3f15574", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=87e3dbc92a1bb114bdde00fe8d541f7fc121e9d6", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n static tree bot_manip PROTO((tree));\n static tree perm_manip PROTO((tree));\n@@ -39,6 +40,7 @@ static int avoid_overlap PROTO((tree, tree));\n static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n static tree no_linkage_helper PROTO((tree));\n static tree build_srcloc PROTO((char *, int));\n+static void mark_list_hash PROTO ((void *));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n@@ -1299,25 +1301,6 @@ debug_binfo (elem)\n     }\n }\n \n-/* Initialize an CPLUS_BINDING node that does not live on an obstack. */\n-\n-tree\n-binding_init (node)\n-     struct tree_binding* node;\n-{\n-  static struct tree_binding* source;\n-  if (!source)\n-    {\n-      extern struct obstack permanent_obstack;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-      source = (struct tree_binding*)make_node (CPLUS_BINDING);\n-      pop_obstacks ();\n-    }\n-  *node = *source;\n-  TREE_PERMANENT ((tree)node) = 0;\n-  return (tree)node;\n-}\n-\n int\n count_functions (t)\n      tree t;\n@@ -2870,11 +2853,28 @@ make_ptrmem_cst (type, member)\n   return ptrmem_cst;\n }\n \n-/* Initialize unsave for C++. */\n+/* Mark ARG (which is really a list_hash_table **) for GC.  */\n+\n+static void\n+mark_list_hash (arg)\n+     void *arg;\n+{\n+  struct list_hash *lh;\n+\n+  for (lh = * ((struct list_hash **) arg); lh; lh = lh->next)\n+    ggc_mark_tree (lh->list);\n+}\n+\n+/* Initialize tree.c.  */\n+\n void\n-init_cplus_unsave ()\n+init_tree ()\n {\n   lang_unsave_expr_now = cplus_unsave_expr_now;\n+  ggc_add_root (list_hash_table, \n+\t\tsizeof (list_hash_table) / sizeof (struct list_hash *),\n+\t\tsizeof (struct list_hash *),\n+\t\tmark_list_hash);\n }\n \n /* The C++ version of unsave_expr_now."}]}