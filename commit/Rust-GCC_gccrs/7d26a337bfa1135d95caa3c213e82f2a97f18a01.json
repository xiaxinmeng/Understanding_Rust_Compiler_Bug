{"sha": "7d26a337bfa1135d95caa3c213e82f2a97f18a01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QyNmEzMzdiZmExMTM1ZDk1Y2FhM2MyMTNlODJmMmE5N2YxOGEwMQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-10T00:38:22Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-10T00:41:05Z"}, "message": "Fix logical_combine OR operation. Again.\n\nThe original fix was incorrect and results in loss of opportunities.\nRevert the original fix. When processing logical chains, do not\nfollow chains outside of the current basic block.  Use the import\nvalue instead.\n\n\tgcc/\n\tPR tree-optimization/97567\n\t* gimple-range-gori.cc: (gori_compute::logical_combine): False\n\tOR operations should intersect the 2 results.\n\t(gori_compute::compute_logical_operands_in_chain): If def chains\n\tare outside the current basic block, don't follow them.\n\tgcc/testsuite/\n\t* gcc.dg/pr97567-2.c: New.", "tree": {"sha": "bf1633d16785790c688b97118e4aedf716550ba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf1633d16785790c688b97118e4aedf716550ba6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d26a337bfa1135d95caa3c213e82f2a97f18a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d26a337bfa1135d95caa3c213e82f2a97f18a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d26a337bfa1135d95caa3c213e82f2a97f18a01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d26a337bfa1135d95caa3c213e82f2a97f18a01/comments", "author": null, "committer": null, "parents": [{"sha": "2bee28dd41ff2b2bc73223aaa18d02e5329b219f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bee28dd41ff2b2bc73223aaa18d02e5329b219f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bee28dd41ff2b2bc73223aaa18d02e5329b219f"}], "stats": {"total": 49, "additions": 37, "deletions": 12}, "files": [{"sha": "af3609e414e89ba383cf05804700f31da869beba", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d26a337bfa1135d95caa3c213e82f2a97f18a01/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d26a337bfa1135d95caa3c213e82f2a97f18a01/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=7d26a337bfa1135d95caa3c213e82f2a97f18a01", "patch": "@@ -730,10 +730,10 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n         if (lhs.zero_p ())\n \t  {\n \t    // An OR operation will only take the FALSE path if both\n-\t    // operands are false, so either [20, 255] or [0, 5] is the\n-\t    // union: [0,5][20,255].\n+\t    // operands are false simlulateously, which means they should\n+\t    // be intersected.  !(x || y) == !x && !y\n \t    r = op1.false_range;\n-\t    r.union_ (op2.false_range);\n+\t    r.intersect (op2.false_range);\n \t  }\n \telse\n \t  {\n@@ -804,24 +804,25 @@ gori_compute::compute_logical_operands_in_chain (tf_range &range,\n \t\t\t\t\t\t tree name,\n \t\t\t\t\t\t tree op, bool op_in_chain)\n {\n-  if (!op_in_chain)\n+  gimple *src_stmt = gimple_range_ssa_p (op) ? SSA_NAME_DEF_STMT (op) : NULL;\n+  basic_block bb = gimple_bb (stmt);\n+  if (!op_in_chain || (src_stmt != NULL && bb != gimple_bb (src_stmt)))\n     {\n-      // If op is not in chain, use its known value.\n+      // If op is not in the def chain, or defined in this block,\n+      // use its known value on entry to the block.\n       expr_range_in_bb (range.true_range, name, gimple_bb (stmt));\n       range.false_range = range.true_range;\n       return;\n     }\n   if (optimize_logical_operands (range, stmt, lhs, name, op))\n     return;\n \n-  // Calulate ranges for true and false on both sides, since the false\n+  // Calculate ranges for true and false on both sides, since the false\n   // path is not always a simple inversion of the true side.\n-  if (!compute_operand_range (range.true_range, SSA_NAME_DEF_STMT (op),\n-\t\t\t      m_bool_one, name))\n-    expr_range_in_bb (range.true_range, name, gimple_bb (stmt));\n-  if (!compute_operand_range (range.false_range, SSA_NAME_DEF_STMT (op),\n-\t\t\t      m_bool_zero, name))\n-    expr_range_in_bb (range.false_range, name, gimple_bb (stmt));\n+  if (!compute_operand_range (range.true_range, src_stmt, m_bool_one, name))\n+    expr_range_in_bb (range.true_range, name, bb);\n+  if (!compute_operand_range (range.false_range, src_stmt, m_bool_zero, name))\n+    expr_range_in_bb (range.false_range, name, bb);\n }\n \n // Given a logical STMT, calculate true and false for each potential"}, {"sha": "dee31c6dc013fb53ccbeb09fb563bf8bcc53589f", "filename": "gcc/testsuite/gcc.dg/pr97567-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d26a337bfa1135d95caa3c213e82f2a97f18a01/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97567-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d26a337bfa1135d95caa3c213e82f2a97f18a01/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97567-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97567-2.c?ref=7d26a337bfa1135d95caa3c213e82f2a97f18a01", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile} */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+char a[2];\n+\n+extern int x;\n+\n+void foo(void);\n+\n+signed char g (signed char min, signed char max)\n+{\n+   signed char i = x;\n+   return i < min || max < i ? min : i;\n+}\n+\n+void gg (void)\n+{\n+   signed char t = g (0, 9);\n+   /* Ranger should be able to remove the call to foo ().  */\n+   if (t > 9 || t < 0)\n+     foo ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"foo\" \"evrp\" } }  */"}]}