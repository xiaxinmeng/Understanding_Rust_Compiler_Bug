{"sha": "148cbb153dafd6b21d83c00787acd430aec68a3d", "node_id": "C_kwDOANBUbNoAKDE0OGNiYjE1M2RhZmQ2YjIxZDgzYzAwNzg3YWNkNDMwYWVjNjhhM2Q", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-02-09T20:51:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-03-09T15:25:45Z"}, "message": "c++: add __is_deducible trait [PR105841]\n\nC++20 class template argument deduction for an alias template involves\nadding a constraint that the template arguments for the alias template can\nbe deduced from the return type of the deduction guide for the underlying\nclass template.  In the standard, this is modeled as defining a class\ntemplate with a partial specialization, but it's much more efficient to\nimplement with a trait that directly tries to perform the deduction.\n\nThe first argument to the trait is a template rather than a type, so various\nplaces needed to be adjusted to accommodate that.\n\n\tPR c++/105841\n\ngcc/ChangeLog:\n\n\t* doc/extend.texi (Type Traits):: Document __is_deducible.\n\ngcc/cp/ChangeLog:\n\n\t* cp-trait.def (IS_DEDUCIBLE): New.\n\t* cxx-pretty-print.cc (pp_cxx_trait): Handle non-type.\n\t* parser.cc (cp_parser_trait): Likewise.\n\t* tree.cc (cp_tree_equal): Likewise.\n\t* pt.cc (tsubst_copy_and_build): Likewise.\n\t(type_targs_deducible_from): New.\n\t(alias_ctad_tweaks): Use it.\n\t* semantics.cc (trait_expr_value): Handle CPTK_IS_DEDUCIBLE.\n\t(finish_trait_expr): Likewise.\n\t* constraint.cc (diagnose_trait_expr): Likewise.\n\t* cp-tree.h (type_targs_deducible_from): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/is_deducible1.C: New test.", "tree": {"sha": "0844e8d60e6ef3de63399d0227dbb191279a28d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0844e8d60e6ef3de63399d0227dbb191279a28d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/148cbb153dafd6b21d83c00787acd430aec68a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148cbb153dafd6b21d83c00787acd430aec68a3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/148cbb153dafd6b21d83c00787acd430aec68a3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148cbb153dafd6b21d83c00787acd430aec68a3d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d11e088210a551235d3937f867ee1c8b19d02290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11e088210a551235d3937f867ee1c8b19d02290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11e088210a551235d3937f867ee1c8b19d02290"}], "stats": {"total": 147, "additions": 131, "deletions": 16}, "files": [{"sha": "a28c85178fe6fa77a45ba080ad0c89bc4eef2c0b", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -3797,6 +3797,9 @@ diagnose_trait_expr (tree expr, tree args)\n       inform (loc, \"  %qT is not a reference that binds to a temporary \"\n \t      \"object of type %qT (copy-initialization)\", t1, t2);\n       break;\n+    case CPTK_IS_DEDUCIBLE:\n+      inform (loc, \"  %qD is not deducible from %qT\", t1, t2);\n+      break;\n #define DEFTRAIT_TYPE(CODE, NAME, ARITY) \\\n     case CPTK_##CODE:\n #include \"cp-trait.def\""}, {"sha": "e43fb464f42b32a5b9d7315cc6a004aabfd1f43c", "filename": "gcc/cp/cp-trait.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fcp-trait.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fcp-trait.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-trait.def?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -84,6 +84,7 @@ DEFTRAIT_EXPR (IS_TRIVIALLY_COPYABLE, \"__is_trivially_copyable\", 1)\n DEFTRAIT_EXPR (IS_UNION, \"__is_union\", 1)\n DEFTRAIT_EXPR (REF_CONSTRUCTS_FROM_TEMPORARY, \"__reference_constructs_from_temporary\", 2)\n DEFTRAIT_EXPR (REF_CONVERTS_FROM_TEMPORARY, \"__reference_converts_from_temporary\", 2)\n+DEFTRAIT_EXPR (IS_DEDUCIBLE, \"__is_deducible\", 2)\n \n DEFTRAIT_TYPE (REMOVE_CV, \"__remove_cv\", 1)\n DEFTRAIT_TYPE (REMOVE_REFERENCE, \"__remove_reference\", 1)"}, {"sha": "dfc1c8457684f01417590324ee1e48eb7e47e703", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -7361,6 +7361,7 @@ extern tree fn_type_unification\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t bool, bool);\n extern void mark_decl_instantiated\t\t(tree, int);\n extern int more_specialized_fn\t\t\t(tree, tree, int);\n+extern bool type_targs_deducible_from\t\t(tree, tree);\n extern void do_decl_instantiation\t\t(tree, tree);\n extern void do_type_instantiation\t\t(tree, tree, tsubst_flags_t);\n extern bool always_instantiate_p\t\t(tree);"}, {"sha": "7f4556d0da2b2ac827d3777d08bdee94dc7632bd", "filename": "gcc/cp/cxx-pretty-print.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fcxx-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fcxx-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.cc?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -2626,7 +2626,10 @@ pp_cxx_trait (cxx_pretty_printer *pp, tree t)\n     }\n \n   pp_cxx_left_paren (pp);\n-  pp->type_id (type1);\n+  if (TYPE_P (type1))\n+    pp->type_id (type1);\n+  else\n+    pp->expression (type1);\n   if (type2)\n     {\n       if (TREE_CODE (type2) != TREE_LIST)"}, {"sha": "533041946c0967edddba75d4c97ae9c32069f5e8", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -10960,10 +10960,22 @@ cp_parser_trait (cp_parser* parser, enum rid keyword)\n   matching_parens parens;\n   parens.require_open (parser);\n \n-  {\n-    type_id_in_expr_sentinel s (parser);\n-    type1 = cp_parser_type_id (parser);\n-  }\n+  if (kind == CPTK_IS_DEDUCIBLE)\n+    {\n+      const cp_token* token = cp_lexer_peek_token (parser->lexer);\n+      type1 = cp_parser_id_expression (parser,\n+\t\t\t\t       /*template_keyword_p=*/false,\n+\t\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t\t       nullptr,\n+\t\t\t\t       /*declarator_p=*/false,\n+\t\t\t\t       /*optional_p=*/false);\n+      type1 = cp_parser_lookup_name_simple (parser, type1, token->location);\n+    }\n+  else\n+    {\n+      type_id_in_expr_sentinel s (parser);\n+      type1 = cp_parser_type_id (parser);\n+    }\n \n   if (type1 == error_mark_node)\n     return error_mark_node;"}, {"sha": "e87cda245b29f93a4b41c10d9020977525acd0ab", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -21587,8 +21587,8 @@ tsubst_copy_and_build (tree t,\n \n     case TRAIT_EXPR:\n       {\n-\ttree type1 = tsubst (TRAIT_EXPR_TYPE1 (t), args,\n-\t\t\t     complain, in_decl);\n+\ttree type1 = tsubst_copy (TRAIT_EXPR_TYPE1 (t), args,\n+\t\t\t\t  complain, in_decl);\n \ttree type2 = tsubst (TRAIT_EXPR_TYPE2 (t), args,\n \t\t\t     complain, in_decl);\n \tRETURN (finish_trait_expr (TRAIT_EXPR_LOCATION (t),\n@@ -29989,7 +29989,7 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n   /* This implementation differs from the above in two significant ways:\n \n      1) We include all template parameters of A, not just some.\n-     2) The added constraint is same_type instead of deducible.\n+     2) [fixed] The added constraint is same_type instead of deducible.\n \n      I believe that while it's probably possible to construct a testcase that\n      behaves differently with this simplification, it should have the same\n@@ -30089,7 +30089,7 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n \t      /* FIXME this should mean they don't compare as equivalent.  */\n \t      || dependent_alias_template_spec_p (atype, nt_opaque))\n \t    {\n-\t      tree same = finish_trait_expr (loc, CPTK_IS_SAME, atype, ret);\n+\t      tree same = finish_trait_expr (loc, CPTK_IS_DEDUCIBLE, tmpl, ret);\n \t      ci = append_constraint (ci, same);\n \t    }\n \n@@ -30103,12 +30103,7 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n \t{\n \t  /* For a non-template deduction guide, if the arguments of A aren't\n \t     deducible from the return type, don't add the candidate.  */\n-\t  tree targs = make_tree_vec (natparms);\n-\t  int err = unify (atparms, targs, utype, ret, UNIFY_ALLOW_NONE, false);\n-\t  for (unsigned i = 0; !err && i < natparms; ++i)\n-\t    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n-\t      err = true;\n-\t  if (err)\n+\t  if (!type_targs_deducible_from (tmpl, ret))\n \t    continue;\n \t}\n \n@@ -30118,6 +30113,60 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n   return aguides;\n }\n \n+/* True iff template arguments for TMPL can be deduced from TYPE.\n+   Used to implement CPTK_IS_DEDUCIBLE for alias CTAD according to\n+   [over.match.class.deduct].\n+\n+   This check is specified in terms of partial specialization, so the behavior\n+   should be parallel to that of get_partial_spec_bindings.  */\n+\n+bool\n+type_targs_deducible_from (tree tmpl, tree type)\n+{\n+  tree tparms = DECL_INNERMOST_TEMPLATE_PARMS (tmpl);\n+  int len = TREE_VEC_LENGTH (tparms);\n+  tree targs = make_tree_vec (len);\n+  bool tried_array_deduction = (cxx_dialect < cxx17);\n+\n+  /* If tmpl is a class template, this is trivial: it's deducible if TYPE is a\n+     specialization of TMPL.  */\n+  if (DECL_CLASS_TEMPLATE_P (tmpl))\n+    return (CLASS_TYPE_P (type)\n+\t    && CLASSTYPE_TEMPLATE_INFO (type)\n+\t    && CLASSTYPE_TI_TEMPLATE (type) == tmpl);\n+\n+  /* Otherwise it's an alias template.  */\n+ again:\n+  if (unify (tparms, targs, TREE_TYPE (tmpl), type,\n+\t     UNIFY_ALLOW_NONE, false))\n+    return false;\n+\n+  /* We don't fail on an undeduced targ the second time through (like\n+     get_partial_spec_bindings) because we're going to try defaults.  */\n+  if (!tried_array_deduction)\n+    for (int i =  0; i < len; ++i)\n+      if (! TREE_VEC_ELT (targs, i))\n+\t{\n+\t  try_array_deduction (tparms, targs, TREE_TYPE (tmpl));\n+\t  tried_array_deduction = true;\n+\t  if (TREE_VEC_ELT (targs, i))\n+\t    goto again;\n+\t}\n+\n+  /* Maybe add in default template args.  This seems like a flaw in the\n+     specification in terms of partial specialization, since it says the\n+     partial specialization has the the template parameter list of A, but a\n+     partial specialization can't have default targs.  */\n+  targs = coerce_template_parms (tparms, targs, tmpl, tf_none);\n+  if (targs == error_mark_node)\n+    return false;\n+\n+  /* I believe we don't need the template_template_parm_bindings_ok_p call\n+     because coerce_template_parms did coerce_template_template_parms.  */\n+\n+  return constraints_satisfied_p (tmpl, targs);\n+}\n+\n /* Return artificial deduction guides built from the constructors of class\n    template TMPL.  */\n "}, {"sha": "d67a9b26719f28c625b28e0663b8de5d05b76a87", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -12049,6 +12049,9 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_REF_CONVERTS_FROM_TEMPORARY:\n       return ref_xes_from_temporary (type1, type2, /*direct_init=*/false);\n \n+    case CPTK_IS_DEDUCIBLE:\n+      return type_targs_deducible_from (type1, type2);\n+\n #define DEFTRAIT_TYPE(CODE, NAME, ARITY) \\\n     case CPTK_##CODE:\n #include \"cp-trait.def\"\n@@ -12206,6 +12209,14 @@ finish_trait_expr (location_t loc, cp_trait_kind kind, tree type1, tree type2)\n \treturn error_mark_node;\n       break;\n \n+    case CPTK_IS_DEDUCIBLE:\n+      if (!DECL_TYPE_TEMPLATE_P (type1))\n+\t{\n+\t  error (\"%qD is not a class or alias template\", type1);\n+\t  return error_mark_node;\n+\t}\n+      break;\n+\n #define DEFTRAIT_TYPE(CODE, NAME, ARITY) \\\n     case CPTK_##CODE:\n #include \"cp-trait.def\""}, {"sha": "de83d41e6b4f4bd5de18b956a33c28d0f45786ef", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -4235,7 +4235,7 @@ cp_tree_equal (tree t1, tree t2)\n     case TRAIT_EXPR:\n       if (TRAIT_EXPR_KIND (t1) != TRAIT_EXPR_KIND (t2))\n \treturn false;\n-      return same_type_p (TRAIT_EXPR_TYPE1 (t1), TRAIT_EXPR_TYPE1 (t2))\n+      return cp_tree_equal (TRAIT_EXPR_TYPE1 (t1), TRAIT_EXPR_TYPE1 (t2))\n \t&& cp_tree_equal (TRAIT_EXPR_TYPE2 (t1), TRAIT_EXPR_TYPE2 (t2));\n \n     case NON_LVALUE_EXPR:"}, {"sha": "b64a85722dbc80cf66d5624ec52c5cb0e8dc7071", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -25213,6 +25213,10 @@ type.  A diagnostic is produced if this requirement is not met.\n If @code{type} is a cv-qualified class type, and not a union type\n ([basic.compound]) the trait is @code{true}, else it is @code{false}.\n \n+@item __is_deducible (template, type)\n+If template arguments for @code{template} can be deduced from\n+@code{type} or obtained from default template arguments.\n+\n @item __is_empty (type)\n If @code{__is_class (type)} is @code{false} then the trait is @code{false}.\n Otherwise @code{type} is considered empty if and only if: @code{type}"}, {"sha": "30cbe089f507948f37ead75f85d23a82f7a01543", "filename": "gcc/testsuite/g++.dg/ext/is_deducible1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_deducible1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148cbb153dafd6b21d83c00787acd430aec68a3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_deducible1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_deducible1.C?ref=148cbb153dafd6b21d83c00787acd430aec68a3d", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile { target c++20 } }\n+\n+template <class T> struct A { };\n+template <class T> struct B { };\n+\n+// Simple forms.\n+static_assert (__is_deducible (::A, A<int>));\n+static_assert (__is_deducible (B, B<int>));\n+static_assert (!__is_deducible (A, B<int>));\n+static_assert (!__is_deducible (::B, A<int>));\n+\n+// This is the interesting use case for alias CTAD.\n+template <class T> using AP = A<T*>;\n+static_assert (__is_deducible (AP, A<int*>));\n+static_assert (!__is_deducible (AP, A<int>));\n+\n+// Can't deduce a parameter not used on the RHS.\n+template <class T> using C = void;\n+static_assert (!__is_deducible (C, C<int>));\n+\n+// But a default template argument counts.\n+template <class T = void> using D = void;\n+static_assert (__is_deducible (D, D<int>));\n+\n+// P0127 array bound type deduction should work here.\n+template <class T, T N> using E = int[N];\n+static_assert (__is_deducible (E, int[42]));\n+\n+// We don't try to support this.\n+template <class T> void f(T);\n+bool b = __is_deducible (f, void (int)); // { dg-error \"class or alias\" }"}]}