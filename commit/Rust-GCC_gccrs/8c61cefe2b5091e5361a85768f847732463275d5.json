{"sha": "8c61cefe2b5091e5361a85768f847732463275d5", "node_id": "C_kwDOANBUbNoAKDhjNjFjZWZlMmI1MDkxZTUzNjFhODU3NjhmODQ3NzMyNDYzMjc1ZDU", "commit": {"author": {"name": "Murray Steele", "email": "murray.steele@arm.com", "date": "2021-12-22T14:50:00Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-12-22T14:57:29Z"}, "message": "arm: Move arm_simd_info array declaration into header\n\nMove the arm_simd_type and arm_type_qualifiers enums, and\narm_simd_info struct from arm-builtins.c into arm-builtins.h header.\n\nThis is a first step towards internalising the type definitions for\nMVE predicate, vector, and tuple types.  By moving arm_simd_types into\na header, we allow future patches to use these type trees externally\nto arm-builtins.c, which is a crucial step towards developing an MVE\nintrinsics framework similar to the current SVE implementation.\n\ngcc/ChangeLog:\n\n\t* config/arm/arm-builtins.c (enum arm_type_qualifiers): Move to\n\tarm_builtins.h.\n\t(enum arm_simd_type): Move to arm-builtins.h.\n\t(struct arm_simd_type_info): Move to arm-builtins.h.\n\t* config/arm/arm-builtins.h (enum arm_simd_type): Move from\n\tarm-builtins.c.\n\t(enum arm_type_qualifiers): Move from arm-builtins.c.\n\t(struct arm_simd_type_info): Move from arm-builtins.c.", "tree": {"sha": "95582f337e3822d2a13ac183c73c4197b45c510e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95582f337e3822d2a13ac183c73c4197b45c510e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c61cefe2b5091e5361a85768f847732463275d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c61cefe2b5091e5361a85768f847732463275d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c61cefe2b5091e5361a85768f847732463275d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c61cefe2b5091e5361a85768f847732463275d5/comments", "author": {"login": "arm-murray", "id": 137165131, "node_id": "U_kgDOCCz5Sw", "avatar_url": "https://avatars.githubusercontent.com/u/137165131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arm-murray", "html_url": "https://github.com/arm-murray", "followers_url": "https://api.github.com/users/arm-murray/followers", "following_url": "https://api.github.com/users/arm-murray/following{/other_user}", "gists_url": "https://api.github.com/users/arm-murray/gists{/gist_id}", "starred_url": "https://api.github.com/users/arm-murray/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arm-murray/subscriptions", "organizations_url": "https://api.github.com/users/arm-murray/orgs", "repos_url": "https://api.github.com/users/arm-murray/repos", "events_url": "https://api.github.com/users/arm-murray/events{/privacy}", "received_events_url": "https://api.github.com/users/arm-murray/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "228173565eafbe34e44c1600c32e32a323eb5aab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/228173565eafbe34e44c1600c32e32a323eb5aab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/228173565eafbe34e44c1600c32e32a323eb5aab"}], "stats": {"total": 174, "additions": 88, "deletions": 86}, "files": [{"sha": "b6bf31349d8f0e996a6c169b061ebe05a2cf9acb", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c61cefe2b5091e5361a85768f847732463275d5/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c61cefe2b5091e5361a85768f847732463275d5/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=8c61cefe2b5091e5361a85768f847732463275d5", "patch": "@@ -48,53 +48,6 @@\n \n #define SIMD_MAX_BUILTIN_ARGS 7\n \n-enum arm_type_qualifiers\n-{\n-  /* T foo.  */\n-  qualifier_none = 0x0,\n-  /* unsigned T foo.  */\n-  qualifier_unsigned = 0x1, /* 1 << 0  */\n-  /* const T foo.  */\n-  qualifier_const = 0x2, /* 1 << 1  */\n-  /* T *foo.  */\n-  qualifier_pointer = 0x4, /* 1 << 2  */\n-  /* const T * foo.  */\n-  qualifier_const_pointer = 0x6,\n-  /* Used when expanding arguments if an operand could\n-     be an immediate.  */\n-  qualifier_immediate = 0x8, /* 1 << 3  */\n-  qualifier_unsigned_immediate = 0x9,\n-  qualifier_maybe_immediate = 0x10, /* 1 << 4  */\n-  /* void foo (...).  */\n-  qualifier_void = 0x20, /* 1 << 5  */\n-  /* Some patterns may have internal operands, this qualifier is an\n-     instruction to the initialisation code to skip this operand.  */\n-  qualifier_internal = 0x40, /* 1 << 6  */\n-  /* Some builtins should use the T_*mode* encoded in a simd_builtin_datum\n-     rather than using the type of the operand.  */\n-  qualifier_map_mode = 0x80, /* 1 << 7  */\n-  /* qualifier_pointer | qualifier_map_mode  */\n-  qualifier_pointer_map_mode = 0x84,\n-  /* qualifier_const_pointer | qualifier_map_mode  */\n-  qualifier_const_pointer_map_mode = 0x86,\n-  /* Polynomial types.  */\n-  qualifier_poly = 0x100,\n-  /* Lane indices - must be within range of previous argument = a vector.  */\n-  qualifier_lane_index = 0x200,\n-  /* Lane indices for single lane structure loads and stores.  */\n-  qualifier_struct_load_store_lane_index = 0x400,\n-  /* A void pointer.  */\n-  qualifier_void_pointer = 0x800,\n-  /* A const void pointer.  */\n-  qualifier_const_void_pointer = 0x802,\n-  /* Lane indices selected in pairs - must be within range of previous\n-     argument = a vector.  */\n-  qualifier_lane_pair_index = 0x1000,\n-  /* Lane indices selected in quadtuplets - must be within range of previous\n-     argument = a vector.  */\n-  qualifier_lane_quadtup_index = 0x2000\n-};\n-\n /*  The qualifier_internal allows generation of a unary builtin from\n     a pattern with a third pseudo-operand such as a match_scratch.\n     T (T).  */\n@@ -1377,50 +1330,12 @@ const char *arm_scalar_builtin_types[] = {\n   NULL\n };\n \n-#define ENTRY(E, M, Q, S, T, G) E,\n-enum arm_simd_type\n-{\n-#include \"arm-simd-builtin-types.def\"\n-  __TYPE_FINAL\n-};\n-#undef ENTRY\n-\n-struct arm_simd_type_info\n-{\n-  enum arm_simd_type type;\n-\n-  /* Internal type name.  */\n-  const char *name;\n-\n-  /* Internal type name(mangled).  The mangled names conform to the\n-     AAPCS (see \"Procedure Call Standard for the ARM Architecture\",\n-     Appendix A).  To qualify for emission with the mangled names defined in\n-     that document, a vector type must not only be of the correct mode but also\n-     be of the correct internal Neon vector type (e.g. __simd64_int8_t);\n-     these types are registered by arm_init_simd_builtin_types ().  In other\n-     words, vector types defined in other ways e.g. via vector_size attribute\n-     will get default mangled names.  */\n-  const char *mangle;\n-\n-  /* Internal type.  */\n-  tree itype;\n-\n-  /* Element type.  */\n-  tree eltype;\n-\n-  /* Machine mode the internal type maps to.  */\n-  machine_mode mode;\n-\n-  /* Qualifiers.  */\n-  enum arm_type_qualifiers q;\n-};\n-\n #define ENTRY(E, M, Q, S, T, G)\t\t\\\n   {E,\t\t\t\t\t\\\n    \"__simd\" #S \"_\" #T \"_t\",\t\t\\\n    #G \"__simd\" #S \"_\" #T \"_t\",\t\t\\\n    NULL_TREE, NULL_TREE, M##mode, qualifier_##Q},\n-static struct arm_simd_type_info arm_simd_types [] = {\n+struct arm_simd_type_info arm_simd_types [] = {\n #include \"arm-simd-builtin-types.def\"\n };\n #undef ENTRY"}, {"sha": "a40fa8950707314d3cc1372fb5c47a8891a18516", "filename": "gcc/config/arm/arm-builtins.h", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c61cefe2b5091e5361a85768f847732463275d5/gcc%2Fconfig%2Farm%2Farm-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c61cefe2b5091e5361a85768f847732463275d5/gcc%2Fconfig%2Farm%2Farm-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.h?ref=8c61cefe2b5091e5361a85768f847732463275d5", "patch": "@@ -32,4 +32,91 @@ enum resolver_ident {\n enum resolver_ident arm_describe_resolver (tree);\n unsigned arm_cde_end_args (tree);\n \n+#define ENTRY(E, M, Q, S, T, G) E,\n+enum arm_simd_type\n+{\n+#include \"arm-simd-builtin-types.def\"\n+  __TYPE_FINAL\n+};\n+#undef ENTRY\n+\n+enum arm_type_qualifiers\n+{\n+  /* T foo.  */\n+  qualifier_none = 0x0,\n+  /* unsigned T foo.  */\n+  qualifier_unsigned = 0x1, /* 1 << 0  */\n+  /* const T foo.  */\n+  qualifier_const = 0x2, /* 1 << 1  */\n+  /* T *foo.  */\n+  qualifier_pointer = 0x4, /* 1 << 2  */\n+  /* const T * foo.  */\n+  qualifier_const_pointer = 0x6,\n+  /* Used when expanding arguments if an operand could\n+     be an immediate.  */\n+  qualifier_immediate = 0x8, /* 1 << 3  */\n+  qualifier_unsigned_immediate = 0x9,\n+  qualifier_maybe_immediate = 0x10, /* 1 << 4  */\n+  /* void foo (...).  */\n+  qualifier_void = 0x20, /* 1 << 5  */\n+  /* Some patterns may have internal operands, this qualifier is an\n+     instruction to the initialisation code to skip this operand.  */\n+  qualifier_internal = 0x40, /* 1 << 6  */\n+  /* Some builtins should use the T_*mode* encoded in a simd_builtin_datum\n+     rather than using the type of the operand.  */\n+  qualifier_map_mode = 0x80, /* 1 << 7  */\n+  /* qualifier_pointer | qualifier_map_mode  */\n+  qualifier_pointer_map_mode = 0x84,\n+  /* qualifier_const_pointer | qualifier_map_mode  */\n+  qualifier_const_pointer_map_mode = 0x86,\n+  /* Polynomial types.  */\n+  qualifier_poly = 0x100,\n+  /* Lane indices - must be within range of previous argument = a vector.  */\n+  qualifier_lane_index = 0x200,\n+  /* Lane indices for single lane structure loads and stores.  */\n+  qualifier_struct_load_store_lane_index = 0x400,\n+  /* A void pointer.  */\n+  qualifier_void_pointer = 0x800,\n+  /* A const void pointer.  */\n+  qualifier_const_void_pointer = 0x802,\n+  /* Lane indices selected in pairs - must be within range of previous\n+     argument = a vector.  */\n+  qualifier_lane_pair_index = 0x1000,\n+  /* Lane indices selected in quadtuplets - must be within range of previous\n+     argument = a vector.  */\n+  qualifier_lane_quadtup_index = 0x2000\n+};\n+\n+struct arm_simd_type_info\n+{\n+  enum arm_simd_type type;\n+\n+  /* Internal type name.  */\n+  const char *name;\n+\n+  /* Internal type name(mangled).  The mangled names conform to the\n+     AAPCS (see \"Procedure Call Standard for the ARM Architecture\",\n+     Appendix A).  To qualify for emission with the mangled names defined in\n+     that document, a vector type must not only be of the correct mode but also\n+     be of the correct internal Neon vector type (e.g. __simd64_int8_t);\n+     these types are registered by arm_init_simd_builtin_types ().  In other\n+     words, vector types defined in other ways e.g. via vector_size attribute\n+     will get default mangled names.  */\n+  const char *mangle;\n+\n+  /* Internal type.  */\n+  tree itype;\n+\n+  /* Element type.  */\n+  tree eltype;\n+\n+  /* Machine mode the internal type maps to.  */\n+  machine_mode mode;\n+\n+  /* Qualifiers.  */\n+  enum arm_type_qualifiers q;\n+};\n+\n+extern struct arm_simd_type_info arm_simd_types[];\n+\n #endif /* GCC_ARM_BUILTINS_H */"}]}