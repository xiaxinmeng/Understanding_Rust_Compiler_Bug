{"sha": "4db183a2d5c98d60144b88dcf402f06fc2103200", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRiMTgzYTJkNWM5OGQ2MDE0NGI4OGRjZjQwMmYwNmZjMjEwMzIwMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-10-23T15:57:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-23T15:57:09Z"}, "message": "re PR tree-optimization/44683 (Optimization bug with copysign builtin)\n\n\t* fold-const.c (invert_tree_comparison): Always invert EQ_EXPR/NE_EXPR.\n\n\tPR tree-optimization/44683\n\t* tree-ssa-dom.c (record_edge_info): Record simple equivalences only if\n\twe can be sure that there are no signed zeros involved.\n\nFrom-SVN: r180340", "tree": {"sha": "e71fcaef7ab6dc1b0e93c1f57a474e7fe80156e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e71fcaef7ab6dc1b0e93c1f57a474e7fe80156e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4db183a2d5c98d60144b88dcf402f06fc2103200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db183a2d5c98d60144b88dcf402f06fc2103200", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4db183a2d5c98d60144b88dcf402f06fc2103200", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db183a2d5c98d60144b88dcf402f06fc2103200/comments", "author": null, "committer": null, "parents": [{"sha": "d621a5fb6d9bd91e30e96ba9ee60ac8ec1350ee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d621a5fb6d9bd91e30e96ba9ee60ac8ec1350ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d621a5fb6d9bd91e30e96ba9ee60ac8ec1350ee1"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "e9b48cbecf3f035c1884c690e49302ecbd2aab8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db183a2d5c98d60144b88dcf402f06fc2103200/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db183a2d5c98d60144b88dcf402f06fc2103200/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4db183a2d5c98d60144b88dcf402f06fc2103200", "patch": "@@ -1,3 +1,11 @@\n+2011-10-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fold-const.c (invert_tree_comparison): Always invert EQ_EXPR/NE_EXPR.\n+\n+\tPR tree-optimization/44683\n+\t* tree-ssa-dom.c (record_edge_info): Record simple equivalences only if\n+\twe can be sure that there are no signed zeros involved.\n+\n 2011-10-23  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline.c (estimate_badness): Scale up and handle overflows."}, {"sha": "e4c258903f7660acbfd9bcd52dd2cb6794c7523a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db183a2d5c98d60144b88dcf402f06fc2103200/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db183a2d5c98d60144b88dcf402f06fc2103200/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4db183a2d5c98d60144b88dcf402f06fc2103200", "patch": "@@ -2100,15 +2100,14 @@ pedantic_non_lvalue_loc (location_t loc, tree x)\n   return protected_set_expr_location_unshare (x, loc);\n }\n \f\n-/* Given a tree comparison code, return the code that is the logical inverse\n-   of the given code.  It is not safe to do this for floating-point\n-   comparisons, except for NE_EXPR and EQ_EXPR, so we receive a machine mode\n-   as well: if reversing the comparison is unsafe, return ERROR_MARK.  */\n+/* Given a tree comparison code, return the code that is the logical inverse.\n+   It is generally not safe to do this for floating-point comparisons, except\n+   for EQ_EXPR and NE_EXPR, so we return ERROR_MARK in this case.  */\n \n enum tree_code\n invert_tree_comparison (enum tree_code code, bool honor_nans)\n {\n-  if (honor_nans && flag_trapping_math)\n+  if (honor_nans && flag_trapping_math && code != EQ_EXPR && code != NE_EXPR)\n     return ERROR_MARK;\n \n   switch (code)"}, {"sha": "949acf1d16826fc10930ea0b88f97bc200e02896", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db183a2d5c98d60144b88dcf402f06fc2103200/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db183a2d5c98d60144b88dcf402f06fc2103200/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=4db183a2d5c98d60144b88dcf402f06fc2103200", "patch": "@@ -1610,12 +1610,15 @@ record_edge_info (basic_block bb)\n             {\n               tree cond = build2 (code, boolean_type_node, op0, op1);\n               tree inverted = invert_truthvalue_loc (loc, cond);\n+              bool can_infer_simple_equiv\n+                = !(HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op0)))\n+                    && real_zerop (op0));\n               struct edge_info *edge_info;\n \n               edge_info = allocate_edge_info (true_edge);\n               record_conditions (edge_info, cond, inverted);\n \n-              if (code == EQ_EXPR)\n+              if (can_infer_simple_equiv && code == EQ_EXPR)\n                 {\n                   edge_info->lhs = op1;\n                   edge_info->rhs = op0;\n@@ -1624,25 +1627,28 @@ record_edge_info (basic_block bb)\n               edge_info = allocate_edge_info (false_edge);\n               record_conditions (edge_info, inverted, cond);\n \n-              if (TREE_CODE (inverted) == EQ_EXPR)\n+              if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n                 {\n                   edge_info->lhs = op1;\n                   edge_info->rhs = op0;\n                 }\n             }\n \n           else if (TREE_CODE (op0) == SSA_NAME\n-                   && (is_gimple_min_invariant (op1)\n-                       || TREE_CODE (op1) == SSA_NAME))\n+                   && (TREE_CODE (op1) == SSA_NAME\n+                       || is_gimple_min_invariant (op1)))\n             {\n               tree cond = build2 (code, boolean_type_node, op0, op1);\n               tree inverted = invert_truthvalue_loc (loc, cond);\n+              bool can_infer_simple_equiv\n+                = !(HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op1)))\n+                    && (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));\n               struct edge_info *edge_info;\n \n               edge_info = allocate_edge_info (true_edge);\n               record_conditions (edge_info, cond, inverted);\n \n-              if (code == EQ_EXPR)\n+              if (can_infer_simple_equiv && code == EQ_EXPR)\n                 {\n                   edge_info->lhs = op0;\n                   edge_info->rhs = op1;\n@@ -1651,7 +1657,7 @@ record_edge_info (basic_block bb)\n               edge_info = allocate_edge_info (false_edge);\n               record_conditions (edge_info, inverted, cond);\n \n-              if (TREE_CODE (inverted) == EQ_EXPR)\n+              if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n                 {\n                   edge_info->lhs = op0;\n                   edge_info->rhs = op1;"}]}