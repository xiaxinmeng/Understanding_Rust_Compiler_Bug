{"sha": "124c354ad70f09c31610f67743b277a359527649", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI0YzM1NGFkNzBmMDljMzE2MTBmNjc3NDNiMjc3YTM1OTUyNzY0OQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-08-19T12:01:14Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-09-19T16:02:43Z"}, "message": "Jit, testsuite: Amend expect processing to tolerate more platforms.\n\nThe current 'fixed_host_execute' implementation fails on Darwin\nplatforms for a number of reasons:\n\n1/ If the sub-process spawn fails (e.g. because of missing or mal-\n   formed params); rather than reporting the fail output into the\n   match stream, as indicated by the expect manual, it terminates\n   the script.\n\n - We fix this by (a) checking that the executable is valid as well\n   as existing (b) we put the spawn into a catch block and report\n   a failure.\n\n2/ There is no recovery path at all for a buffer-full case (and we\n   do see buffer-full events with the default sizes).\n\n - Added by the patch here, however it is not as sophisticated as\n   the methods used by dejagnu internally.  Here we set the process\n   to be \"nowait\" and then close the connection - with the intent\n   that this will terminate the spawned process.\n\n3/  The expect logic assumes that 'Totals:' is a valid indicator\n    for the end of the spawned process output.  This is not true\n    even for the default dejagnu header (there are a number of\n    additional reporting lines after).  In addition to this, there\n    are some tests that intentionally produce more output after\n    the totals report (and there are tests that do not use that\n    mechanism at all).\n\n    The effect is the we might arrive at the \"wait\" for the spawned\n    process to finish - but that process might not have completed\n    all its output.  For Darwin, at least that causes a deadlock\n    between expect and the spawnee - the latter is doing a non-\n    cancellable write and the former is waiting for the latter to\n    terminate.  For some reason this does not seem to affect Linux\n    perhaps the pty implementation allows the write(s) are able to\n    proceed even though there is no reader.\n\n -  This is fixed by modifying the loop termination condition to be\n    either EOF (which will be the 'correct' condition) or a timeout\n    which would represent an error either in the runtime or in the\n    parsing of the output.  As added precautions, we only try to\n    wait if there is a correcly-spawned process, and we are also\n    specific about which process we are waiting for.\n\n4/  Darwin appears to have a bug in either the tcl or termios\n    'cooking' code that ocassionally inserts an additional CR char\n    into the stream - thus '\\n' => '\\r\\r\\n' instead of '\\r\\n'. The\n    original program output is correct (it only contains a single\n    \\n) - the additional character is being inserted somewhere in\n    the translations applied before the output reaches expect.\n\n    The logic of this expect implementation does not tolerate single\n    \\r or \\n characters (it will fail with a timeout or buffer-full\n    if that occurs).\n\n -  This is fixed by having a line-end match that is adjusted for\n    Darwin.\n\n5/  The default buffer size does seem to be too small in some cases\n    noting that GCC uses 10000 as the match buffer size and the\n    default is 2000.\n\n -  Fixed by increasing the size to 8192.\n\n6/  There is a somewhat arbitrary dumping of output where we match\n    ^$prefix\\tSOMETHING... and then process the something.  This\n    essentially allows the match to start at any place in the buffer\n    following any collection of non-line-end chars.\n\n -  Fixed by amending the match for 'general' lines to accommodate\n    these cases, and reporting such lines to the log.  At least this\n    should allow debugging of any cases where output that should be\n    recognized is being dropped.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/testsuite/ChangeLog:\n\n\t* jit.dg/jit.exp (fixed_local_execute): Amend the match and\n\texit conditions to cater for more platforms.", "tree": {"sha": "a8776f56bd71a34be936bca1c39b47c493f7f3bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8776f56bd71a34be936bca1c39b47c493f7f3bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/124c354ad70f09c31610f67743b277a359527649", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124c354ad70f09c31610f67743b277a359527649", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124c354ad70f09c31610f67743b277a359527649", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124c354ad70f09c31610f67743b277a359527649/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d42a27d8942e16e351d138955280a848d7b432a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d42a27d8942e16e351d138955280a848d7b432a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d42a27d8942e16e351d138955280a848d7b432a"}], "stats": {"total": 126, "additions": 85, "deletions": 41}, "files": [{"sha": "10b98bdc74b8506369ec6300248007cb8cfecf47", "filename": "gcc/testsuite/jit.dg/jit.exp", "status": "modified", "additions": 85, "deletions": 41, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124c354ad70f09c31610f67743b277a359527649/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124c354ad70f09c31610f67743b277a359527649/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp?ref=124c354ad70f09c31610f67743b277a359527649", "patch": "@@ -167,6 +167,9 @@ proc fixed_host_execute {args} {\n     if {![file exists ${executable}]} {\n \tperror \"The executable, \\\"$executable\\\" is missing\" 0\n \treturn \"No source file found\"\n+    } elseif {![file executable ${executable}]} {\n+\tperror \"The executable, \\\"$executable\\\" is not usable\" 0\n+\treturn \"Bad executable found\"\n     }\n \n     verbose \"params: $params\" 2\n@@ -194,84 +197,125 @@ proc fixed_host_execute {args} {\n     set args [concat $args ${params}]\n     verbose \"args: $args\" 2\n \n-    eval spawn -noecho $args\n-\n-    expect_after full_buffer {\terror \"got full_buffer\" }\n+    # We checked that the executable exists above, and can be executed, but\n+    #\u00a0that does not cover other reasons that the launch could fail (e.g.\n+    #\u00a0missing or malformed params); catch such cases here and report them.\n+    set err [catch \"spawn -noecho $args\" pid]\n+    set sub_proc_id $spawn_id\n+    if { $pid <= 0 || $err != 0 || $sub_proc_id < 0 } {\n+        warning \"failed to spawn : $args : err = $err\"\n+    }\n+\n+    # Increase the buffer size, if needed to avoid spurious buffer-full\n+    # events; GCC uses 10000; chose a power of two here.\n+    set current_max_match [match_max -i $sub_proc_id]\n+    if { $current_max_match < 8192 } {\n+        match_max -i $sub_proc_id 8192\n+        set used [match_max -i $sub_proc_id]\n+    }\n+\n+    # If we get a buffer-full error, that seems to be unrecoverable so try to\n+    #\u00a0exit in a reasonable manner to avoid wedged processes.\n+    expect_after full_buffer {\n+        verbose -log \"fixed_host_execute: $args FULL BUFFER\"\n+        # FIXME: this all assumes that closing the connection will cause the\n+        # sub-process to terminate (but that is not going to be the case if,\n+        # for example, there is something started with -nohup somewhere).\n+        # We should explicitly kill it here.\n+        #\u00a0Set the process to be a nowait exit.\n+        wait -nowait -i $sub_proc_id\n+        catch close\n+        perror \"${executable} got full_buffer\"\n+        return \"${executable} got full_buffer\"\n+    }\n \n     set prefix \"\\[^\\r\\n\\]*\"\n+    # Work around a Darwin tcl or termios bug that sometimes inserts extra\n+    # CR characters into the cooked tty stream\n+    set endline \"\\r\\n\"\n+    if { [istarget *-*-darwin*] } {\n+        set endline \"\\r(\\r)*\\n\"\n+    }\n+    \n+    # Note that the logic here assumes that we cannot (validly) get single\n+    # carriage return or line feed characters in the stream.  If those occur,\n+    #\u00a0it will stop any further matching.  We arange for the matching to be\n+    # at the start of the buffer - so that if there is any spurious output\n+    # to be discarded, it must be done explicitly - not by matching part-way\n+    # through the buffer.\n     expect {\n-\t-re \"^$prefix\\[0-9\\]\\[0-9\\]:..:..:${text}*\\r\\n\" {\n+\t-re \"^$prefix\\[0-9\\]\\[0-9\\]:..:..:${text}*$endline\" {\n \t    regsub \"\\[\\n\\r\\t\\]*NOTE: $text\\r\\n\" $expect_out(0,string) \"\" output\n \t    verbose \"$output\" 3\n \t    set timetol 0\n \t    exp_continue\n \t}\n-\t-re \"^$prefix\\tNOTE:\\[^\\r\\n\\]+\\r\\n\" {\n-\t    regsub \"\\[\\n\\r\\t\\]*NOTE: $text\\r\\n\" $expect_out(0,string) \"\" output\n-\t    set output [string range $output 6 end-2]\n-\t    verbose \"$output\" 2\n+\t-re \"^\\tNOTE: (\\[^\\r\\n\\]+)$endline\" {\n+\t    # discard notes.\n+\t    verbose \"Ignored note: $expect_out(1,string)\" 2\n \t    set timetol 0\n \t    exp_continue\n \t}\n-\t-re \"^$prefix\\tPASSED:\\[^\\r\\n\\]+\\r\\n\" {\n-\t    regsub \"\\[\\n\\r\\t\\]*PASSED: $text\\r\\n\" $expect_out(0,string) \"\" output\n-\t    set output [string range $output 8 end-2]\n-\t    pass \"$output\"\n+\t-re \"^\\tPASSED: (\\[^\\r\\n\\]+)$endline\" {\n+\t    pass \"$expect_out(1,string)\"\n \t    set timetol 0\n \t    exp_continue\n \t}\n-\t-re \"^$prefix\\tFAILED:\\[^\\r\\n\\]+\\r\\n\" {\n-\t    regsub \"\\[\\n\\r\\t\\]*FAILED: $text\\r\\n\" $expect_out(0,string) \"\" output\n-\t    set output [string range $output 8 end-2]\n-\t    fail \"$output\"\n+\t-re \"^\\tFAILED: (\\[^\\r\\n\\]+)$endline\" {\n+\t    fail \"$expect_out(1,string)\"\n \t    set timetol 0\n \t    exp_continue\n \t}\n-\t-re \"^$prefix\\tUNTESTED:\\[^\\r\\n\\]+\\r\\n\" {\n-\t    regsub \"\\[\\n\\r\\t\\]*TESTED: $text\\r\\n\" $expect_out(0,string) \"\" output\n-\t    set output [string range $output 8 end-2]\n-\t    untested \"$output\"\n+\t-re \"^\\tUNTESTED: (\\[^\\r\\n\\]+)$endline\" {\n+\t    untested \"$expect_out(1,string)\"\n \t    set timetol 0\n \t    exp_continue\n \t}\n-\t-re \"^$prefix\\tUNRESOLVED:\\[^\\r\\n\\]+\\r\\n\" {\n-\t    regsub \"\\[\\n\\r\\t\\]*UNRESOLVED: $text\\r\\n\" $expect_out(0,string) \"\" output\n-\t    set output [string range $output 8 end-2]\n-\t    unresolved \"$output\"\n+\t-re \"^\\tUNRESOLVED: (\\[^\\r\\n\\]+)$endline\" {\n+\t    unresolved \"$expect_out(1,string)\"\n \t    set timetol 0\n \t    exp_continue\n \t}\n-\t-re \"^Totals\" {\n-\t    verbose \"All done\" 2\n+\t-re \"^$prefix$endline\" {\n+            #\u00a0This matches and discards any other lines (including blank ones).\n+            if { [string length $expect_out(buffer)] <= 2 } {\n+                set output \"blank line\"\n+            } else {\n+\t        set output [string range $expect_out(buffer) 0 end-2]\n+\t    }\n+\t    verbose -log \"DISCARDED $expect_out(spawn_id) : $output\"\n+\t    exp_continue\n \t}\n \teof {\n-\t    #\t    unresolved \"${executable} died prematurely\"\n-\t    #\t    catch close\n-\t    #\t    return \"${executable} died prematurely\"\n+\t    # This seems to be the only way that we can reliably know that the\n+\t    # output is finished since there are cases where further output\n+\t    # follows the dejagnu test harness totals.\n+\t    verbose \"saw eof\" 2\n \t}\n \ttimeout {\n-\t    warning \"Timed out executing test case\"\n \t    if { $timetol <= 2 } {\n+\t        verbose -log \"Timed out with retry (timeout = $timeout)\"\n \t\tincr timetol\n \t\texp_continue\n \t    } else {\n+\t        warning \"Timed out executing testcase (timeout = $timeout)\"\n \t\tcatch close\n \t\treturn \"Timed out executing test case\"\n \t    }\n \t}\n-\t-re \"^$prefix\\r\\n\" {\n-\t    exp_continue\n-\t}\n     }\n \n-    # Use \"wait\" before \"close\": valgrind might not have finished\n-    # writing the log out before we parse it, so we need to wait for\n-    # the spawnee to finish.\n-\n-    catch wait wres\n-    verbose \"wres: $wres\" 2\n-    verify_exit_status $executable $wres\n-\n+    # Use \"wait\" to pick up the sub-process exit state.  If the sub-process is\n+    # writing to a file (perhaps under valgrind) then that also needs to be\n+    # complete; only attempt this on a valid spawn.\n+    if { $sub_proc_id > 0 } {\n+        verbose \"waiting for $sub_proc_id\" 1\n+        #\u00a0Be explicit about what we are waiting for.\n+        catch \"wait -i $sub_proc_id\" wres\n+        verbose \"wres: $wres\" 2\n+        verify_exit_status $executable $wres\n+    }\n+ \n     if $run_under_valgrind {\n \tupvar 2 name name\n \tparse_valgrind_logfile $name $valgrind_logfile"}]}