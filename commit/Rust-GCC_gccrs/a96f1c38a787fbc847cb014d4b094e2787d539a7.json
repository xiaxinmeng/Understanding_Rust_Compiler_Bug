{"sha": "a96f1c38a787fbc847cb014d4b094e2787d539a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk2ZjFjMzhhNzg3ZmJjODQ3Y2IwMTRkNGIwOTRlMjc4N2Q1MzlhNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-30T21:02:59Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-04-01T19:34:40Z"}, "message": "analyzer: handle compound assignments [PR94378]\n\nPR analyzer/94378 reports a false -Wanalyzer-malloc-leak\nwhen returning a struct containing a malloc-ed pointer.\n\nThe issue is that the assignment code was not handling\ncompound copies, only copying top-level values from region to region,\nand not copying child values.\n\nThis patch introduces a region_model::copy_region function, using\nit for assignments and when analyzing function return values.\nIt recursively copies nested values within structs, unions, and\narrays, fixing the bug.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/94378\n\t* checker-path.cc: Include \"bitmap.h\".\n\t* constraint-manager.cc: Likewise.\n\t* diagnostic-manager.cc: Likewise.\n\t* engine.cc: Likewise.\n\t(exploded_node::detect_leaks): Pass null region_id to pop_frame.\n\t* program-point.cc: Include \"bitmap.h\".\n\t* program-state.cc: Likewise.\n\t* region-model.cc (id_set<region_id>::id_set): Convert to...\n\t(region_id_set::region_id_set): ...this.\n\t(svalue_id_set::svalue_id_set): New ctor.\n\t(region_model::copy_region): New function.\n\t(region_model::copy_struct_region): New function.\n\t(region_model::copy_union_region): New function.\n\t(region_model::copy_array_region): New function.\n\t(stack_region::pop_frame): Drop return value.  Add\n\t\"result_dst_rid\" param; if it is non-null, use copy_region to copy\n\tthe result to it.  Rather than capture and pass a single \"known\n\tused\" return value to be used by purge_unused_values, instead\n\tgather and pass a set of known used return values.\n\t(root_region::pop_frame): Drop return value.  Add \"result_dst_rid\"\n\tparam.\n\t(region_model::on_assignment): Use copy_region.\n\t(region_model::on_return): Likewise for the result.\n\t(region_model::on_longjmp): Pass null for pop_frame's\n\tresult_dst_rid.\n\t(region_model::update_for_return_superedge): Pass the region for the\n\treturn value of the call, if any, to pop_frame, rather than setting\n\tthe lvalue for the lhs of the result.\n\t(region_model::pop_frame): Drop return value.  Add\n\t\"result_dst_rid\" param.\n\t(region_model::purge_unused_svalues): Convert third param from an\n\tsvalue_id * to an svalue_id_set *, updating the initial populating\n\tof the \"used\" bitmap accordingly.  Don't remap it when done.\n\t(struct selftest::coord_test): New selftest fixture, extracted from...\n\t(selftest::test_dump_2): ...here.\n\t(selftest::test_compound_assignment): New selftest.\n\t(selftest::test_stack_frames): Pass null to new param of pop_frame.\n\t(selftest::analyzer_region_model_cc_tests): Call the new selftest.\n\t* region-model.h (class id_set): Delete template.\n\t(class region_id_set): Reimplement, using old id_set implementation.\n\t(class svalue_id_set): Likewise.  Convert from auto_sbitmap to\n\tauto_bitmap.\n\t(region::get_active_view): New accessor.\n\t(stack_region::pop_frame): Drop return value.  Add\n\t\"result_dst_rid\" param.\n\t(root_region::pop_frame): Likewise.\n\t(region_model::pop_frame): Likewise.\n\t(region_model::copy_region): New decl.\n\t(region_model::purge_unused_svalues): Convert third param from an\n\tsvalue_id * to an svalue_id_set *.\n\t(region_model::copy_struct_region): New decl.\n\t(region_model::copy_union_region): New decl.\n\t(region_model::copy_array_region): New decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/94378\n\t* gcc.dg/analyzer/compound-assignment-1.c: New test.\n\t* gcc.dg/analyzer/compound-assignment-2.c: New test.\n\t* gcc.dg/analyzer/compound-assignment-3.c: New test.", "tree": {"sha": "344b4bab5c1d19a4e87aac09abbd98c82c9c74b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/344b4bab5c1d19a4e87aac09abbd98c82c9c74b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a96f1c38a787fbc847cb014d4b094e2787d539a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96f1c38a787fbc847cb014d4b094e2787d539a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96f1c38a787fbc847cb014d4b094e2787d539a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96f1c38a787fbc847cb014d4b094e2787d539a7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7546463b9f7a0b001cf61a94dcfc18f540721390", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7546463b9f7a0b001cf61a94dcfc18f540721390", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7546463b9f7a0b001cf61a94dcfc18f540721390"}], "stats": {"total": 606, "additions": 522, "deletions": 84}, "files": [{"sha": "3f136f45c20d50182b6b2217f5ff13267fa2b7b2", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -1,3 +1,60 @@\n+2020-04-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/94378\n+\t* checker-path.cc: Include \"bitmap.h\".\n+\t* constraint-manager.cc: Likewise.\n+\t* diagnostic-manager.cc: Likewise.\n+\t* engine.cc: Likewise.\n+\t(exploded_node::detect_leaks): Pass null region_id to pop_frame.\n+\t* program-point.cc: Include \"bitmap.h\".\n+\t* program-state.cc: Likewise.\n+\t* region-model.cc (id_set<region_id>::id_set): Convert to...\n+\t(region_id_set::region_id_set): ...this.\n+\t(svalue_id_set::svalue_id_set): New ctor.\n+\t(region_model::copy_region): New function.\n+\t(region_model::copy_struct_region): New function.\n+\t(region_model::copy_union_region): New function.\n+\t(region_model::copy_array_region): New function.\n+\t(stack_region::pop_frame): Drop return value.  Add\n+\t\"result_dst_rid\" param; if it is non-null, use copy_region to copy\n+\tthe result to it.  Rather than capture and pass a single \"known\n+\tused\" return value to be used by purge_unused_values, instead\n+\tgather and pass a set of known used return values.\n+\t(root_region::pop_frame): Drop return value.  Add \"result_dst_rid\"\n+\tparam.\n+\t(region_model::on_assignment): Use copy_region.\n+\t(region_model::on_return): Likewise for the result.\n+\t(region_model::on_longjmp): Pass null for pop_frame's\n+\tresult_dst_rid.\n+\t(region_model::update_for_return_superedge): Pass the region for the\n+\treturn value of the call, if any, to pop_frame, rather than setting\n+\tthe lvalue for the lhs of the result.\n+\t(region_model::pop_frame): Drop return value.  Add\n+\t\"result_dst_rid\" param.\n+\t(region_model::purge_unused_svalues): Convert third param from an\n+\tsvalue_id * to an svalue_id_set *, updating the initial populating\n+\tof the \"used\" bitmap accordingly.  Don't remap it when done.\n+\t(struct selftest::coord_test): New selftest fixture, extracted from...\n+\t(selftest::test_dump_2): ...here.\n+\t(selftest::test_compound_assignment): New selftest.\n+\t(selftest::test_stack_frames): Pass null to new param of pop_frame.\n+\t(selftest::analyzer_region_model_cc_tests): Call the new selftest.\n+\t* region-model.h (class id_set): Delete template.\n+\t(class region_id_set): Reimplement, using old id_set implementation.\n+\t(class svalue_id_set): Likewise.  Convert from auto_sbitmap to\n+\tauto_bitmap.\n+\t(region::get_active_view): New accessor.\n+\t(stack_region::pop_frame): Drop return value.  Add\n+\t\"result_dst_rid\" param.\n+\t(root_region::pop_frame): Likewise.\n+\t(region_model::pop_frame): Likewise.\n+\t(region_model::copy_region): New decl.\n+\t(region_model::purge_unused_svalues): Convert third param from an\n+\tsvalue_id * to an svalue_id_set *.\n+\t(region_model::copy_struct_region): New decl.\n+\t(region_model::copy_union_region): New decl.\n+\t(region_model::copy_array_region): New decl.\n+\n 2020-03-27  David Malcolm  <dmalcolm@redhat.com>\n \n \t* program-state.cc (selftest::test_program_state_dumping): Update"}, {"sha": "c07273460d55a3b89482a23b4749a7d6c2a23c8c", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"sbitmap.h\"\n+#include \"bitmap.h\"\n #include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\""}, {"sha": "786bd6ccf85974b57ff3a31b538954d491c97e98", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n #include \"sbitmap.h\"\n+#include \"bitmap.h\"\n #include \"tristate.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\""}, {"sha": "e132a5625de4b3e9938a1b72f37d08d53136cec2", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fibonacci_heap.h\"\n #include \"shortest-paths.h\"\n #include \"sbitmap.h\"\n+#include \"bitmap.h\"\n #include \"tristate.h\"\n #include \"selftest.h\"\n #include \"ordered-hash-map.h\""}, {"sha": "880e70fb2ba8a8602f2e97eb2e16b3be574a16d2", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"pretty-print.h\"\n #include \"sbitmap.h\"\n+#include \"bitmap.h\"\n #include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\"\n@@ -1361,7 +1362,8 @@ exploded_node::detect_leaks (exploded_graph &eg) const\n \t\t\t\t  &old_state, &new_state,\n \t\t\t\t  NULL,\n \t\t\t\t  get_stmt ());\n-  new_state.m_region_model->pop_frame (true, &stats, &ctxt);\n+  new_state.m_region_model->pop_frame (region_id::null (),\n+\t\t\t\t       true, &stats, &ctxt);\n }\n \n /* Dump the successors and predecessors of this enode to OUTF.  */"}, {"sha": "7bf2de4e3bfe08547e72f590f92630b7acfa73c5", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/program-point.h\"\n #include \"sbitmap.h\"\n+#include \"bitmap.h\"\n #include \"tristate.h\"\n #include \"selftest.h\"\n #include \"analyzer/region-model.h\""}, {"sha": "43396c658274d7744f0c2915191fee7728078105", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"sbitmap.h\"\n+#include \"bitmap.h\"\n #include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\""}, {"sha": "30fe72b90e995d412183006756925d9a5456826d", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 277, "deletions": 65, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -243,17 +243,22 @@ region_id::validate (const region_model &model) const\n   gcc_assert (null_p () || m_idx < (int)model.get_num_regions ());\n }\n \n-/* class id_set.  */\n+/* class region_id_set.  */\n \n-/* id_set<region_id>'s ctor.  */\n-\n-template<>\n-id_set<region_id>::id_set (const region_model *model)\n+region_id_set::region_id_set (const region_model *model)\n : m_bitmap (model->get_num_regions ())\n {\n   bitmap_clear (m_bitmap);\n }\n \n+/* class svalue_id_set.  */\n+\n+svalue_id_set::svalue_id_set ()\n+: m_bitmap (NULL)\n+{\n+  bitmap_clear (m_bitmap);\n+}\n+\n /* class svalue and its various subclasses.  */\n \n /* class svalue.  */\n@@ -1219,6 +1224,127 @@ region::get_inherited_child_sid (region *child,\n   return svalue_id::null ();\n }\n \n+/* Copy from SRC_RID to DST_RID, using CTXT for any issues that occur.\n+   Copy across any value for the region, and handle structs, unions\n+   and arrays recursively.  */\n+\n+void\n+region_model::copy_region (region_id dst_rid, region_id src_rid,\n+\t\t\t   region_model_context *ctxt)\n+{\n+  gcc_assert (!dst_rid.null_p ());\n+  gcc_assert (!src_rid.null_p ());\n+  if (dst_rid == src_rid)\n+    return;\n+  region *dst_reg = get_region (dst_rid);\n+  region *src_reg = get_region (src_rid);\n+\n+  /* Copy across any value for the src region itself.  */\n+  svalue_id sid = src_reg->get_value (*this, true, ctxt);\n+  set_value (dst_rid, sid, ctxt);\n+\n+  if (dst_reg->get_kind () != src_reg->get_kind ())\n+    return;\n+\n+  /* Copy across child regions for structs, unions, and arrays.  */\n+  switch (dst_reg->get_kind ())\n+    {\n+    case RK_PRIMITIVE:\n+      return;\n+    case RK_STRUCT:\n+      {\n+\tstruct_region *dst_sub = as_a <struct_region *> (dst_reg);\n+\tstruct_region *src_sub = as_a <struct_region *> (src_reg);\n+\tcopy_struct_region (dst_rid, dst_sub, src_sub, ctxt);\n+      }\n+      return;\n+    case RK_UNION:\n+      {\n+\tunion_region *src_sub = as_a <union_region *> (src_reg);\n+\tcopy_union_region (dst_rid, src_sub, ctxt);\n+      }\n+      return;\n+    case RK_FRAME:\n+    case RK_GLOBALS:\n+    case RK_CODE:\n+    case RK_FUNCTION:\n+      return;\n+    case RK_ARRAY:\n+      {\n+\tarray_region *dst_sub = as_a <array_region *> (dst_reg);\n+\tarray_region *src_sub = as_a <array_region *> (src_reg);\n+\tcopy_array_region (dst_rid, dst_sub, src_sub, ctxt);\n+      }\n+      return;\n+    case RK_STACK:\n+    case RK_HEAP:\n+    case RK_ROOT:\n+    case RK_SYMBOLIC:\n+      return;\n+    }\n+}\n+\n+/* Subroutine of region_model::copy_region for copying the child\n+   regions for a struct.  */\n+\n+void\n+region_model::copy_struct_region (region_id dst_rid,\n+\t\t\t\t  struct_region *dst_reg,\n+\t\t\t\t  struct_region *src_reg,\n+\t\t\t\t  region_model_context *ctxt)\n+{\n+  for (map_region::iterator_t iter = src_reg->begin ();\n+       iter != src_reg->end (); ++iter)\n+    {\n+      tree src_key = (*iter).first;\n+      region_id src_field_rid = (*iter).second;\n+      region *src_field_reg = get_region (src_field_rid);\n+      region_id dst_field_rid\n+\t= dst_reg->get_or_create (this, dst_rid, src_key,\n+\t\t\t\t  src_field_reg->get_type (), ctxt);\n+      copy_region (dst_field_rid, src_field_rid, ctxt);\n+    }\n+}\n+\n+/* Subroutine of region_model::copy_region for copying the active\n+   child region for a union.  */\n+\n+void\n+region_model::copy_union_region (region_id dst_rid,\n+\t\t\t\t union_region *src_reg,\n+\t\t\t\t region_model_context *ctxt)\n+{\n+  region_id src_active_view_rid = src_reg->get_active_view ();\n+  if (src_active_view_rid.null_p ())\n+    return;\n+  region *src_active_view = get_region (src_active_view_rid);\n+  tree type = src_active_view->get_type ();\n+  region_id dst_active_view_rid = get_or_create_view (dst_rid, type, ctxt);\n+  copy_region (dst_active_view_rid, src_active_view_rid, ctxt);\n+}\n+\n+/* Subroutine of region_model::copy_region for copying the child\n+   regions for an array.  */\n+\n+void\n+region_model::copy_array_region (region_id dst_rid,\n+\t\t\t\t array_region *dst_reg,\n+\t\t\t\t array_region *src_reg,\n+\t\t\t\t region_model_context *ctxt)\n+{\n+  for (array_region::iterator_t iter = src_reg->begin ();\n+       iter != src_reg->end (); ++iter)\n+    {\n+      array_region::key_t src_key = (*iter).first;\n+      region_id src_field_rid = (*iter).second;\n+      region *src_field_reg = get_region (src_field_rid);\n+      region_id dst_field_rid\n+\t= dst_reg->get_or_create (this, dst_rid, src_key,\n+\t\t\t\t  src_field_reg->get_type (), ctxt);\n+      copy_region (dst_field_rid, src_field_rid, ctxt);\n+    }\n+}\n+\n /* Generate a hash value for this region.  The work is done by the\n    add_to_hash vfunc.  */\n \n@@ -2630,21 +2756,21 @@ stack_region::get_current_frame_id () const\n \n /* Pop the topmost frame_region from this stack.\n \n+   If RESULT_DST_RID is non-null, copy any return value from the frame\n+   into RESULT_DST_RID's region.\n+\n    Purge the frame region and all its descendent regions.\n    Convert any pointers that point into such regions into\n    POISON_KIND_POPPED_STACK svalues.\n \n-   Return the ID of any return value from the frame.\n-\n    If PURGE, then purge all unused svalues, with the exception of any\n-   return value for the frame, which is temporarily\n-   preserved in case no regions reference it, so it can\n-   be written into a region in the caller.\n+   returned values.\n \n    Accumulate stats on purged entities into STATS.  */\n \n-svalue_id\n-stack_region::pop_frame (region_model *model, bool purge, purge_stats *stats,\n+void\n+stack_region::pop_frame (region_model *model, region_id result_dst_rid,\n+\t\t\t bool purge, purge_stats *stats,\n \t\t\t region_model_context *ctxt)\n {\n   gcc_assert (m_frame_rids.length () > 0);\n@@ -2653,11 +2779,35 @@ stack_region::pop_frame (region_model *model, bool purge, purge_stats *stats,\n   frame_region *frame = model->get_region<frame_region> (frame_rid);\n \n   /* Evaluate the result, within the callee frame.  */\n-  svalue_id result_sid;\n+  svalue_id_set returned_sids;\n   tree fndecl = frame->get_function ()->decl;\n   tree result = DECL_RESULT (fndecl);\n   if (result && TREE_TYPE (result) != void_type_node)\n-    result_sid = model->get_rvalue (result, ctxt);\n+    {\n+      if (!result_dst_rid.null_p ())\n+\t{\n+\t  /* Copy the result to RESULT_DST_RID.  */\n+\t  model->copy_region (result_dst_rid, model->get_lvalue (result, ctxt),\n+\t\t\t      ctxt);\n+\t}\n+      if (purge)\n+\t{\n+\t  /* Populate returned_sids, to avoid purging them.  */\n+\t  region_id return_rid = model->get_lvalue (result, NULL);\n+\t  region_id_set returned_rids (model);\n+\t  model->get_descendents (return_rid, &returned_rids,\n+\t\t\t\t  region_id::null ());\n+\t  for (unsigned i = 0; i < model->get_num_regions (); i++)\n+\t    {\n+\t      region_id rid = region_id::from_int (i);\n+\t      if (returned_rids.region_p (rid))\n+\t\t{\n+\t\t  svalue_id sid = model->get_region (rid)->get_value_direct ();\n+\t\t  returned_sids.add_svalue (sid);\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   /* Pop the frame RID.  */\n   m_frame_rids.pop ();\n@@ -2667,13 +2817,11 @@ stack_region::pop_frame (region_model *model, bool purge, purge_stats *stats,\n \t\t\t\t\tstats,\n \t\t\t\t\tctxt ? ctxt->get_logger () : NULL);\n \n-  /* Delete unused svalues, but don't delete the return value.  */\n+  /* Delete unused svalues, but don't delete the return value(s).  */\n   if (purge)\n-    model->purge_unused_svalues (stats, ctxt, &result_sid);\n+    model->purge_unused_svalues (stats, ctxt, &returned_sids);\n \n   model->validate ();\n-\n-  return result_sid;\n }\n \n /* Implementation of region::add_to_hash vfunc for stack_region.  */\n@@ -3039,12 +3187,13 @@ root_region::get_current_frame_id (const region_model &model) const\n /* Pop the topmost frame_region from this root_region's stack;\n    see the comment for stack_region::pop_frame.  */\n \n-svalue_id\n-root_region::pop_frame (region_model *model, bool purge, purge_stats *out,\n+void\n+root_region::pop_frame (region_model *model, region_id result_dst_rid,\n+\t\t\tbool purge, purge_stats *out,\n \t\t\tregion_model_context *ctxt)\n {\n   stack_region *stack = model->get_region <stack_region> (m_stack_rid);\n-  return stack->pop_frame (model, purge, out, ctxt);\n+  stack->pop_frame (model, result_dst_rid, purge, out, ctxt);\n }\n \n /* Return the region_id of the stack region, creating it if doesn't\n@@ -4139,8 +4288,8 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n     case PARM_DECL:\n       {\n \t/* LHS = VAR;  */\n-\tsvalue_id var_sid = get_rvalue (rhs1, ctxt);\n-\tset_value (lhs_rid, var_sid, ctxt);\n+\tregion_id rhs_rid = get_lvalue (rhs1, ctxt);\n+\tcopy_region (lhs_rid, rhs_rid, ctxt);\n       }\n       break;\n \n@@ -4601,7 +4750,7 @@ region_model::on_return (const greturn *return_stmt, region_model_context *ctxt)\n   tree rhs = gimple_return_retval (return_stmt);\n \n   if (lhs && rhs)\n-    set_value (get_lvalue (lhs, ctxt), get_rvalue (rhs, ctxt), ctxt);\n+    copy_region (get_lvalue (lhs, ctxt), get_lvalue (rhs, ctxt), ctxt);\n }\n \n /* Update this model for a call and return of setjmp/sigsetjmp at CALL within\n@@ -4656,7 +4805,7 @@ region_model::on_longjmp (const gcall *longjmp_call, const gcall *setjmp_call,\n   while (get_stack_depth () > setjmp_stack_depth)\n     {\n       /* Don't purge unused svalues yet, as we're using fake_retval_sid.  */\n-      pop_frame (false, NULL, ctxt);\n+      pop_frame (region_id::null (), false, NULL, ctxt);\n     }\n \n   gcc_assert (get_stack_depth () == setjmp_stack_depth);\n@@ -5997,31 +6146,39 @@ region_model::update_for_call_superedge (const call_superedge &call_edge,\n   push_frame (call_edge.get_callee_function (), &arg_sids, ctxt);\n }\n \n-/* Pop the top-most frame_region from the stack, and store the svalue\n-   for any returned value into the region for the lvalue of the LHS of\n+/* Pop the top-most frame_region from the stack, and copy the return\n+   region's values (if any) into the region for the lvalue of the LHS of\n    the call (if any).  */\n \n void\n region_model::update_for_return_superedge (const return_superedge &return_edge,\n \t\t\t\t\t   region_model_context *ctxt)\n {\n-  purge_stats stats;\n-  svalue_id result_sid = pop_frame (true, &stats, ctxt);\n-  // TODO: do something with the stats?\n-\n-  if (result_sid.null_p ())\n-    return;\n+  region_id stack_rid = get_stack_region_id ();\n+  stack_region *stack = get_region <stack_region> (stack_rid);\n \n-  /* Set the result of the call, within the caller frame.  */\n+  /* Get the region for the result of the call, within the caller frame.  */\n+  region_id result_dst_rid;\n   const gcall *call_stmt = return_edge.get_call_stmt ();\n   tree lhs = gimple_call_lhs (call_stmt);\n   if (lhs)\n-    set_value (get_lvalue (lhs, ctxt), result_sid, ctxt);\n-  else\n+    {\n+      /* Normally we access the top-level frame, which is:\n+\t   path_var (expr, stack->get_num_frames () - 1)\n+\t whereas here we need the caller frame, hence \"- 2\" here.  */\n+      gcc_assert (stack->get_num_frames () >= 2);\n+      result_dst_rid = get_lvalue (path_var (lhs, stack->get_num_frames () - 2),\n+\t\t\t\t   ctxt);\n+    }\n+\n+  purge_stats stats;\n+  stack->pop_frame (this, result_dst_rid, true, &stats, ctxt);\n+  // TODO: do something with the stats?\n+\n+  if (!lhs)\n     {\n       /* This could be a leak; try purging again, but this time,\n-\t don't special-case the result_sid.  */\n-      purge_stats stats;\n+\t don't special-case the result sids (as was done in pop_frame).  */\n       purge_unused_svalues (&stats, ctxt);\n     }\n }\n@@ -6189,11 +6346,12 @@ region_model::get_current_function () const\n /* Pop the topmost frame_region from this region_model's stack;\n    see the comment for stack_region::pop_frame.  */\n \n-svalue_id\n-region_model::pop_frame (bool purge, purge_stats *out,\n+void\n+region_model::pop_frame (region_id result_dst_rid,\n+\t\t\t bool purge, purge_stats *out,\n \t\t\t region_model_context *ctxt)\n {\n-  return get_root_region ()->pop_frame (this, purge, out, ctxt);\n+  get_root_region ()->pop_frame (this, result_dst_rid, purge, out, ctxt);\n }\n \n /* Get the number of frames in this region_model's stack.  */\n@@ -6374,17 +6532,19 @@ class restrict_to_used_svalues : public purge_criteria\n    number of redundant unknown values could grow without bounds, and each\n    such model would be treated as distinct.\n \n-   If KNOWN_USED is non-NULL, treat *KNOWN_USED as used (this is for\n+   If KNOWN_USED_SIDS is non-NULL, treat *KNOWN_USED_SIDS as used (this is for\n    handling values being returned from functions as their frame is popped,\n    since otherwise we'd have to simultaneously determine both the rvalue\n    of the return expr in the callee frame and the lvalue for the gcall's\n    assignment in the caller frame, and it seems cleaner to express all\n-   lvalue and rvalue lookups implicitly relative to a \"current\" frame).  */\n+   lvalue and rvalue lookups implicitly relative to a \"current\" frame).\n+   The svalue_ids in *KNOWN_USED_SIDS are not remapped and hence this\n+   call makes it invalid.  */\n \n void\n region_model::purge_unused_svalues (purge_stats *stats,\n \t\t\t\t    region_model_context *ctxt,\n-\t\t\t\t    svalue_id *known_used_sid)\n+\t\t\t\t    svalue_id_set *known_used_sids)\n {\n   // TODO: might want to avoid a vfunc call just to do logging here:\n   logger *logger = ctxt ? ctxt->get_logger () : NULL;\n@@ -6394,9 +6554,14 @@ region_model::purge_unused_svalues (purge_stats *stats,\n   auto_sbitmap used (m_svalues.length ());\n   bitmap_clear (used);\n \n-  if (known_used_sid)\n-    if (!known_used_sid->null_p ())\n-      bitmap_set_bit (used, known_used_sid->as_int ());\n+  if (known_used_sids)\n+    {\n+      /* We can't use an sbitmap for known_used_sids as the number of\n+\t svalues could have grown since it was created.  */\n+      for (unsigned i = 0; i < get_num_svalues (); i++)\n+\tif (known_used_sids->svalue_p (svalue_id::from_int (i)))\n+\t  bitmap_set_bit (used, i);\n+    }\n \n   /* Walk the regions, marking sids that are used.  */\n   unsigned i;\n@@ -6491,9 +6656,6 @@ region_model::purge_unused_svalues (purge_stats *stats,\n \tstats->m_num_svalues++;\n     }\n \n-  if (known_used_sid)\n-    map.update (known_used_sid);\n-\n   validate ();\n }\n \n@@ -7459,25 +7621,39 @@ make_test_compound_type (const char *name, bool is_struct,\n   return t;\n }\n \n+/* Selftest fixture for creating the type \"struct coord {int x; int y; };\".  */\n+\n+struct coord_test\n+{\n+  coord_test ()\n+  {\n+    auto_vec<tree> fields;\n+    m_x_field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t       get_identifier (\"x\"), integer_type_node);\n+    fields.safe_push (m_x_field);\n+    m_y_field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t       get_identifier (\"y\"), integer_type_node);\n+    fields.safe_push (m_y_field);\n+    m_coord_type = make_test_compound_type (\"coord\", true, &fields);\n+  }\n+\n+  tree m_x_field;\n+  tree m_y_field;\n+  tree m_coord_type;\n+};\n+\n /* Verify that dumps can show struct fields.  */\n \n static void\n test_dump_2 ()\n {\n-  auto_vec<tree> fields;\n-  tree x_field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n-\t\t\t     get_identifier (\"x\"), integer_type_node);\n-  fields.safe_push (x_field);\n-  tree y_field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n-\t\t\t     get_identifier (\"y\"), integer_type_node);\n-  fields.safe_push (y_field);\n-  tree coord_type = make_test_compound_type (\"coord\", true, &fields);\n-\n-  tree c = build_global_decl (\"c\", coord_type);\n-  tree c_x = build3 (COMPONENT_REF, TREE_TYPE (x_field),\n-\t\t     c, x_field, NULL_TREE);\n-  tree c_y = build3 (COMPONENT_REF, TREE_TYPE (y_field),\n-\t\t     c, y_field, NULL_TREE);\n+  coord_test ct;\n+\n+  tree c = build_global_decl (\"c\", ct.m_coord_type);\n+  tree c_x = build3 (COMPONENT_REF, TREE_TYPE (ct.m_x_field),\n+\t\t     c, ct.m_x_field, NULL_TREE);\n+  tree c_y = build3 (COMPONENT_REF, TREE_TYPE (ct.m_y_field),\n+\t\t     c, ct.m_y_field, NULL_TREE);\n \n   tree int_17 = build_int_cst (integer_type_node, 17);\n   tree int_m3 = build_int_cst (integer_type_node, -3);\n@@ -7881,6 +8057,41 @@ test_assignment ()\n   ASSERT_DUMP_EQ (model, true, \"y: 0, {x}: unknown, x == y\");\n }\n \n+/* Verify that compound assignments work as expected.  */\n+\n+static void\n+test_compound_assignment ()\n+{\n+  coord_test ct;\n+\n+  tree c = build_global_decl (\"c\", ct.m_coord_type);\n+  tree c_x = build3 (COMPONENT_REF, TREE_TYPE (ct.m_x_field),\n+\t\t     c, ct.m_x_field, NULL_TREE);\n+  tree c_y = build3 (COMPONENT_REF, TREE_TYPE (ct.m_y_field),\n+\t\t     c, ct.m_y_field, NULL_TREE);\n+  tree d = build_global_decl (\"d\", ct.m_coord_type);\n+  tree d_x = build3 (COMPONENT_REF, TREE_TYPE (ct.m_x_field),\n+\t\t     d, ct.m_x_field, NULL_TREE);\n+  tree d_y = build3 (COMPONENT_REF, TREE_TYPE (ct.m_y_field),\n+\t\t     d, ct.m_y_field, NULL_TREE);\n+\n+  tree int_17 = build_int_cst (integer_type_node, 17);\n+  tree int_m3 = build_int_cst (integer_type_node, -3);\n+\n+  region_model model;\n+  model.set_value (c_x, int_17, NULL);\n+  model.set_value (c_y, int_m3, NULL);\n+\n+  ASSERT_DUMP_EQ (model, true, \"c.x: 17, c.y: -3\");\n+\n+  /* Copy c to d.  */\n+  model.copy_region (model.get_lvalue (d, NULL), model.get_lvalue (c, NULL),\n+\t\t     NULL);\n+  /* Check that the fields have the same svalues.  */\n+  ASSERT_EQ (model.get_rvalue (c_x, NULL), model.get_rvalue (d_x, NULL));\n+  ASSERT_EQ (model.get_rvalue (c_y, NULL), model.get_rvalue (d_y, NULL));\n+}\n+\n /* Verify the details of pushing and popping stack frames.  */\n \n static void\n@@ -7986,7 +8197,7 @@ test_stack_frames ()\n \n   /* Pop the \"child_fn\" frame from the stack.  */\n   purge_stats purged;\n-  model.pop_frame (true, &purged, &ctxt);\n+  model.pop_frame (region_id::null (), true, &purged, &ctxt);\n \n   /* We should have purged the unknown values for x and y. */\n   ASSERT_EQ (purged.m_num_svalues, 2);\n@@ -8671,6 +8882,7 @@ analyzer_region_model_cc_tests ()\n   test_purging_by_criteria ();\n   test_purge_unused_svalues ();\n   test_assignment ();\n+  test_compound_assignment ();\n   test_stack_frames ();\n   test_get_representative_path_var ();\n   test_canonicalization_1 ();"}, {"sha": "2c9ee39a38dc105769aefeec86950979565ad9c7", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -370,25 +370,24 @@ one_way_id_map<T>::update (T *id) const\n   *id = get_dst_for_src (*id);\n }\n \n-/* A set of IDs within a region_model (either svalue_id or region_id).  */\n+/* A set of region_ids within a region_model.  */\n \n-template <typename T>\n-class id_set\n+class region_id_set\n {\n public:\n-  id_set (const region_model *model);\n+  region_id_set (const region_model *model);\n \n-  void add_region (T id)\n+  void add_region (region_id rid)\n   {\n-    if (!id.null_p ())\n-      bitmap_set_bit (m_bitmap, id.as_int ());\n+    if (!rid.null_p ())\n+      bitmap_set_bit (m_bitmap, rid.as_int ());\n   }\n \n-  bool region_p (T id) const\n+  bool region_p (region_id rid) const\n   {\n-    gcc_assert (!id.null_p ());\n+    gcc_assert (!rid.null_p ());\n     return bitmap_bit_p (const_cast <auto_sbitmap &> (m_bitmap),\n-\t\t\t id.as_int ());\n+\t\t\t rid.as_int ());\n   }\n \n   unsigned int num_regions ()\n@@ -400,7 +399,29 @@ class id_set\n   auto_sbitmap m_bitmap;\n };\n \n-typedef id_set<region_id> region_id_set;\n+/* A set of svalue_ids within a region_model.  */\n+\n+class svalue_id_set\n+{\n+public:\n+  svalue_id_set ();\n+\n+  void add_svalue (svalue_id sid)\n+  {\n+    if (!sid.null_p ())\n+      bitmap_set_bit (m_bitmap, sid.as_int ());\n+  }\n+\n+  bool svalue_p (svalue_id sid) const\n+  {\n+    gcc_assert (!sid.null_p ());\n+    return bitmap_bit_p (const_cast <auto_bitmap &> (m_bitmap),\n+\t\t\t sid.as_int ());\n+  }\n+\n+private:\n+  auto_bitmap m_bitmap;\n+};\n \n /* Various operations delete information from a region_model.\n \n@@ -890,6 +911,7 @@ class region\n \n   void add_view (region_id view_rid, region_model *model);\n   region_id get_view (tree type, region_model *model) const;\n+  region_id get_active_view () const { return m_active_view_rid; }\n   bool is_view_p () const { return m_is_view; }\n \n   virtual void validate (const region_model &model) const;\n@@ -1450,8 +1472,9 @@ class stack_region : public region\n \n   void push_frame (region_id frame_rid);\n   region_id get_current_frame_id () const;\n-  svalue_id pop_frame (region_model *model, bool purge, purge_stats *stats,\n-\t\t       region_model_context *ctxt);\n+  void pop_frame (region_model *model, region_id result_dst_rid,\n+\t\t  bool purge, purge_stats *stats,\n+\t\t  region_model_context *ctxt);\n \n   void remap_region_ids (const region_id_map &map) FINAL OVERRIDE;\n \n@@ -1555,8 +1578,9 @@ class root_region : public region\n \t\t\tvec<svalue_id> *arg_sids,\n \t\t\tregion_model_context *ctxt);\n   region_id get_current_frame_id (const region_model &model) const;\n-  svalue_id pop_frame (region_model *model, bool purge, purge_stats *stats,\n-\t\t       region_model_context *ctxt);\n+  void pop_frame (region_model *model, region_id result_dst_rid,\n+\t\t  bool purge, purge_stats *stats,\n+\t\t  region_model_context *ctxt);\n \n   region_id ensure_stack_region (region_model *model);\n   region_id get_stack_region_id () const { return m_stack_rid; }\n@@ -1724,8 +1748,9 @@ class region_model\n \t\t\tregion_model_context *ctxt);\n   region_id get_current_frame_id () const;\n   function * get_current_function () const;\n-  svalue_id pop_frame (bool purge, purge_stats *stats,\n-\t\t       region_model_context *ctxt);\n+  void pop_frame (region_id result_dst_rid,\n+\t\t  bool purge, purge_stats *stats,\n+\t\t  region_model_context *ctxt);\n   int get_stack_depth () const;\n   function *get_function_at_depth (unsigned depth) const;\n \n@@ -1781,6 +1806,9 @@ class region_model\n   svalue_id set_to_new_unknown_value (region_id dst_rid, tree type,\n \t\t\t\t      region_model_context *ctxt);\n \n+  void copy_region (region_id dst_rid, region_id src_rid,\n+\t\t    region_model_context *ctxt);\n+\n   tristate eval_condition (svalue_id lhs,\n \t\t\t   enum tree_code op,\n \t\t\t   svalue_id rhs) const;\n@@ -1804,7 +1832,7 @@ class region_model\n \n   void purge_unused_svalues (purge_stats *out,\n \t\t\t     region_model_context *ctxt,\n-\t\t\t     svalue_id *known_used_sid = NULL);\n+\t\t\t     svalue_id_set *known_used_sids = NULL);\n   void remap_svalue_ids (const svalue_id_map &map);\n   void remap_region_ids (const region_id_map &map);\n \n@@ -1858,6 +1886,13 @@ class region_model\n   region_id get_lvalue_1 (path_var pv, region_model_context *ctxt);\n   svalue_id get_rvalue_1 (path_var pv, region_model_context *ctxt);\n \n+  void copy_struct_region (region_id dst_rid, struct_region *dst_reg,\n+\t\t\t   struct_region *src_reg, region_model_context *ctxt);\n+  void copy_union_region (region_id dst_rid, union_region *src_reg,\n+\t\t\t  region_model_context *ctxt);\n+  void copy_array_region (region_id dst_rid, array_region *dst_reg,\n+\t\t\t  array_region *src_reg, region_model_context *ctxt);\n+\n   region_id make_region_for_unexpected_tree_code (region_model_context *ctxt,\n \t\t\t\t\t\t  tree t,\n \t\t\t\t\t\t  const dump_location_t &loc);"}, {"sha": "4d617c72c1bad00e1c8a44a5db781479ea0a6e39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -1,3 +1,10 @@\n+2020-04-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/94378\n+\t* gcc.dg/analyzer/compound-assignment-1.c: New test.\n+\t* gcc.dg/analyzer/compound-assignment-2.c: New test.\n+\t* gcc.dg/analyzer/compound-assignment-3.c: New test.\n+\n 2020-04-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/94436"}, {"sha": "bb03487f23e4ef2ac5e89229d44b7b738d633a6a", "filename": "gcc/testsuite/gcc.dg/analyzer/compound-assignment-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-1.c?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -0,0 +1,71 @@\n+#include <stdlib.h>\n+\n+struct ptr_wrapper\n+{\n+  int *ptr;\n+};\n+\n+struct ptr_wrapper\n+test_1 (void)\n+{\n+  struct ptr_wrapper r;\n+  r.ptr = malloc (sizeof (int));\n+  return r;\n+}\n+\n+struct ptr_wrapper\n+test_2 (void)\n+{\n+  struct ptr_wrapper r, s;\n+  r.ptr = malloc (sizeof (int));\n+  s = r;\n+  return s;\n+}\n+\n+struct nested\n+{\n+  struct ptr_wrapper w;\n+};\n+\n+struct nested\n+test_3 (void)\n+{\n+  struct nested n;\n+  n.w.ptr = malloc (sizeof (int));\n+  return n;\n+}\n+\n+void test_4 (void)\n+{\n+  struct ptr_wrapper r;\n+  r.ptr = malloc (sizeof (int)); /* { dg-message \"allocated here\" } */\n+} /* { dg-warning \"leak of 'r.ptr'\" } */\n+/* { dg-bogus \"leak of '<unknown>'\" \"unknown leak\" { xfail *-*-* } .-1 } */\n+\n+static struct ptr_wrapper __attribute__((noinline))\n+called_by_test_5a (void)\n+{\n+  struct ptr_wrapper r;\n+  r.ptr = malloc (sizeof (int));\n+  return r;\n+}\n+\n+void test_5a (void)\n+{\n+  struct ptr_wrapper q = called_by_test_5a ();  \n+} /* { dg-warning \"leak of 'q.ptr'\" } */\n+/* TODO: show the allocation point.  */\n+\n+static struct ptr_wrapper __attribute__((noinline))\n+called_by_test_5b (void)\n+{\n+  struct ptr_wrapper r;\n+  r.ptr = malloc (sizeof (int));\n+  return r; /* { dg-warning \"leak\" } */\n+  /* TODO: show the allocation point.  */\n+}\n+\n+void test_5b (void)\n+{\n+  called_by_test_5b ();\n+}"}, {"sha": "ecca9aca83b511abd8b6e3e2e08d0c6da1b010fc", "filename": "gcc/testsuite/gcc.dg/analyzer/compound-assignment-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-2.c?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -0,0 +1,24 @@\n+#include <stdlib.h>\n+\n+struct array_wrapper\n+{\n+  void *ptrs[2];\n+};\n+\n+struct array_wrapper\n+test_1 (void)\n+{\n+  struct array_wrapper aw1;\n+  aw1.ptrs[0] = malloc (1024);\n+  aw1.ptrs[1] = malloc (512);\n+  return aw1;\n+}\n+\n+struct array_wrapper\n+test_2 (void)\n+{\n+  struct array_wrapper aw2;\n+  aw2.ptrs[0] = malloc (1024);\n+  aw2.ptrs[1] = malloc (512);\n+} /* { dg-warning \"leak of 'aw2.ptrs.0.'\" \"leak of element 0\" } */\n+/* { dg-warning \"leak of 'aw2.ptrs.1.'\" \"leak of element 1\" { target *-*-* } .-1 } */"}, {"sha": "5083faa9ce2b847294e81f58faf90d8151603328", "filename": "gcc/testsuite/gcc.dg/analyzer/compound-assignment-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96f1c38a787fbc847cb014d4b094e2787d539a7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-3.c?ref=a96f1c38a787fbc847cb014d4b094e2787d539a7", "patch": "@@ -0,0 +1,25 @@\n+#include <stdlib.h>\n+\n+struct union_wrapper\n+{\n+  union\n+  {\n+    int i;\n+    void *ptr;\n+  } u;\n+};\n+\n+struct union_wrapper\n+test_1 (void)\n+{\n+  struct union_wrapper uw1;\n+  uw1.u.ptr = malloc (1024);\n+  return uw1;\n+}\n+\n+struct union_wrapper\n+test_2 (void)\n+{\n+  struct union_wrapper uw2;\n+  uw2.u.ptr = malloc (1024);\n+} /* { dg-warning \"leak of '\\\\(void \\\\*\\\\)uw2.u'\" } */"}]}