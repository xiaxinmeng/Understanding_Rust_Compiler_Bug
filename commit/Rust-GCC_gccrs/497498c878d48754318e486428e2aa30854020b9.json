{"sha": "497498c878d48754318e486428e2aa30854020b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3NDk4Yzg3OGQ0ODc1NDMxOGU0ODY0MjhlMmFhMzA4NTQwMjBiOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-03-09T19:42:57Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-03-21T08:53:30Z"}, "message": "lra: Tighten check for reloading paradoxical subregs [PR94052]\n\nsimplify_operand_subreg tries to detect whether the allocation for\na pseudo in a paradoxical subreg is also valid for the outer mode.\nThe condition it used to check for an invalid combination was:\n\n  else if (REG_P (reg)\n\t   && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n\t   && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n\t   && (hard_regno_nregs (hard_regno, innermode)\n\t       < hard_regno_nregs (hard_regno, mode))\n\t   && (regclass = lra_get_allocno_class (REGNO (reg)))\n\t   && (type != OP_IN\n\t       || !in_hard_reg_set_p (reg_class_contents[regclass],\n\t\t\t\t      mode, hard_regno)\n\t       || overlaps_hard_reg_set_p (lra_no_alloc_regs,\n\t\t\t\t\t   mode, hard_regno)))\n\nI think there are two problems with this:\n\n(1) It never actually checks whether the hard register is valid for the\n    outer mode (in the hard_regno_mode_ok sense).  If it isn't, any attempt\n    to reload in the outer mode is likely to cycle, because the implied\n    regno/mode combination will be just as invalid next time\n    curr_insn_transform sees the subreg.\n\n(2) The check is valid for little-endian only.  For big-endian we need\n    to move hard_regno backwards.\n\nUsing simplify_subreg_regno should avoid both problems.\n\nAs the existing comment says, IRA should always take subreg references\ninto account when allocating hard registers, so this fix-up should only\nreally be needed for pseudos allocated by LRA itself.\n\ngcc/\n2020-03-21  Richard Sandiford  <richard.sandiford@arm.com>\n\n\tPR rtl-optimization/94052\n\t* lra-constraints.c (simplify_operand_subreg): Reload the inner\n\tregister of a paradoxical subreg if simplify_subreg_regno fails\n\tto give a valid hard register for the outer mode.\n\ngcc/testsuite/\n2020-03-21  Tamar Christina  <tamar.christina@arm.com>\n\n\tPR target/94052\n\t* gcc.target/aarch64/pr94052.C: New test.", "tree": {"sha": "ab6586cb024f7e343a0116430fc67e05c2f68c66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab6586cb024f7e343a0116430fc67e05c2f68c66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/497498c878d48754318e486428e2aa30854020b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497498c878d48754318e486428e2aa30854020b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497498c878d48754318e486428e2aa30854020b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497498c878d48754318e486428e2aa30854020b9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15711e837b245ab1bbd2c9c49a010524d4e9d384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15711e837b245ab1bbd2c9c49a010524d4e9d384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15711e837b245ab1bbd2c9c49a010524d4e9d384"}], "stats": {"total": 210, "additions": 200, "deletions": 10}, "files": [{"sha": "e55a8e75ec958cadd1fb4d3bc4906e28e382adbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497498c878d48754318e486428e2aa30854020b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497498c878d48754318e486428e2aa30854020b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=497498c878d48754318e486428e2aa30854020b9", "patch": "@@ -1,3 +1,10 @@\n+2020-03-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/94052\n+\t* lra-constraints.c (simplify_operand_subreg): Reload the inner\n+\tregister of a paradoxical subreg if simplify_subreg_regno fails\n+\tto give a valid hard register for the outer mode.\n+\n 2020-03-20  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/93435"}, {"sha": "bf6d4a2fd4bf47caa017fc3bdf9c0ae8e53a79d5", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497498c878d48754318e486428e2aa30854020b9/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497498c878d48754318e486428e2aa30854020b9/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=497498c878d48754318e486428e2aa30854020b9", "patch": "@@ -1489,7 +1489,7 @@ static bool process_address (int, bool, rtx_insn **, rtx_insn **);\n static bool\n simplify_operand_subreg (int nop, machine_mode reg_mode)\n {\n-  int hard_regno;\n+  int hard_regno, inner_hard_regno;\n   rtx_insn *before, *after;\n   machine_mode mode, innermode;\n   rtx reg, new_reg;\n@@ -1735,15 +1735,19 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n      for the new uses.  */\n   else if (REG_P (reg)\n \t   && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n-\t   && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n-\t   && (hard_regno_nregs (hard_regno, innermode)\n-\t       < hard_regno_nregs (hard_regno, mode))\n-\t   && (regclass = lra_get_allocno_class (REGNO (reg)))\n-\t   && (type != OP_IN\n-\t       || !in_hard_reg_set_p (reg_class_contents[regclass],\n-\t\t\t\t      mode, hard_regno)\n-\t       || overlaps_hard_reg_set_p (lra_no_alloc_regs,\n-\t\t\t\t\t   mode, hard_regno)))\n+\t   && paradoxical_subreg_p (operand)\n+\t   && (inner_hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n+\t   && ((hard_regno\n+\t\t= simplify_subreg_regno (inner_hard_regno, innermode,\n+\t\t\t\t\t SUBREG_BYTE (operand), mode)) < 0\n+\t       || ((hard_regno_nregs (inner_hard_regno, innermode)\n+\t\t    < hard_regno_nregs (hard_regno, mode))\n+\t\t   && (regclass = lra_get_allocno_class (REGNO (reg)))\n+\t\t   && (type != OP_IN\n+\t\t       || !in_hard_reg_set_p (reg_class_contents[regclass],\n+\t\t\t\t\t      mode, hard_regno)\n+\t\t       || overlaps_hard_reg_set_p (lra_no_alloc_regs,\n+\t\t\t\t\t\t   mode, hard_regno)))))\n     {\n       /* The class will be defined later in curr_insn_transform.  */\n       enum reg_class rclass"}, {"sha": "bff5d8215e3ed6b5236741a9ee93d16abaa147ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497498c878d48754318e486428e2aa30854020b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497498c878d48754318e486428e2aa30854020b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=497498c878d48754318e486428e2aa30854020b9", "patch": "@@ -1,3 +1,8 @@\n+2020-03-21  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/94052\n+\t* gcc.target/aarch64/pr94052.C: New test.\n+\n 2020-03-20  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/93435"}, {"sha": "d36c9bdc1588533db35eb3cbd2502034edd25452", "filename": "gcc/testsuite/g++.target/aarch64/pr94052.C", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497498c878d48754318e486428e2aa30854020b9/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fpr94052.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497498c878d48754318e486428e2aa30854020b9/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fpr94052.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fpr94052.C?ref=497498c878d48754318e486428e2aa30854020b9", "patch": "@@ -0,0 +1,174 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -std=gnu++11 -w\" } */\n+\n+namespace c {\n+typedef int d;\n+template <typename e> struct f { typedef e g; };\n+template <bool, typename> struct h;\n+template <typename e> e aa(typename f<e>::g i) { return i; }\n+template <typename, typename> struct j {};\n+template <d, typename> struct k;\n+template <class l, class m> struct k<1, j<l, m>> { typedef m g; };\n+template <d n, class l, class m> typename k<n, j<l, m>>::g ab(j<l, m>);\n+} // namespace c\n+typedef long d;\n+typedef char o;\n+typedef int p;\n+typedef char q;\n+typedef int r;\n+namespace {\n+struct s;\n+constexpr d t = 6;\n+template <typename> class ad {\n+public:\n+  static constexpr d u = t;\n+  d v();\n+  d x();\n+  d y();\n+};\n+class z : ad<int> {};\n+struct ae {\n+  p af;\n+};\n+class ag {\n+public:\n+  ae ah();\n+};\n+} // namespace\n+typedef __Int32x4_t ai;\n+typedef struct {\n+  ai aj[2];\n+} ak;\n+typedef int al;\n+void am(p *a, ai b) { __builtin_aarch64_st1v4si(a, b); }\n+namespace an {\n+class ao {\n+public:\n+  bool operator==(ao);\n+  d v();\n+  d x();\n+};\n+class ap : public ad<r> {};\n+class aq {\n+public:\n+  c::j<int, int> ar();\n+  int as();\n+  int at();\n+};\n+class au {\n+public:\n+  virtual d av(d);\n+  virtual ap aw();\n+  virtual ag ax();\n+};\n+class ay {};\n+class az {\n+  virtual void ba(const ay &, const s &);\n+};\n+using bb = az;\n+class bc;\n+class bd : bb {\n+  void ba(const ay &, const s &);\n+  bc *be;\n+  bc *bf;\n+  bc *bg;\n+  aq bh;\n+  int bi;\n+  int bj;\n+  ao bk;\n+};\n+namespace bl {\n+namespace bm {\n+namespace bn {\n+class bo;\n+}\n+} // namespace bm\n+} // namespace bl\n+namespace bn {\n+template <typename ac = c::h<0, bl::bm ::bn::bo>>\n+ai bp(ac *, ac *, ac *, al, al, al, d, p);\n+template <typename ac = c::h<0, bl::bm ::bn::bo>>\n+ak bq(ac *br, ac *bs, ac *bt, al bu, al bv, al bw, d bx, int, int by) {\n+  ak{bp(br, bs, bt, bu, bv, bw, bx, by), bp(br, bs, bt, bu, bv, bw, bx, by)};\n+}\n+template <typename ac = c::h<0, bl::bm ::bn::bo>>\n+ak bz(ac *, ac *, ac *, al, al, al &, int, p);\n+template <int> void ca(p *, const ak &);\n+template <> void ca<1>(p *buffer, const ak &cb) {\n+  am(buffer, cb.aj[0]);\n+  am(buffer + 4, cb.aj[1]);\n+}\n+int cc(int, int);\n+} // namespace bn\n+class bc {\n+public:\n+  virtual au *cd();\n+};\n+class ce {\n+public:\n+  q *cf();\n+};\n+template <d> struct cg {\n+  template <typename ch> static void ci(ay, z cj, ch ck) { ck(cj); }\n+};\n+template <typename ch> void cl(ay w, ch ck) {\n+  z cj;\n+  cg<z::u>::ci(w, cj, c::aa<ch>(ck));\n+}\n+namespace {\n+template <typename T1, typename cm, int cn> class co {\n+public:\n+  static void convolve(ay, int cs, bc *cp, bc *cq, bc *cr, aq cw, int, ao ct) {\n+    int by = cp->cd()->ax().ah().af;\n+    int cu = cq->cd()->ax().ah().af;\n+    cp->cd()->aw().v();\n+    int cv = cp->cd()->aw().x();\n+    cp->cd()->aw().y();\n+    cp->cd()->aw();\n+    int da = cr->cd()->aw().x();\n+    int cx = cq->cd()->aw().x();\n+    cq->cd()->aw().y();\n+    int cy = cr->cd()->av(0);\n+    int cz = cr->cd()->av(1);\n+    bn::cc(cs, cn);\n+    int de = c::ab<1>(cw.ar());\n+    cw.as();\n+    cw.at();\n+    ay db;\n+    ce dc;\n+    ce dd;\n+    ce w;\n+    q *di = w.cf();\n+    cl(db, [&](z) {\n+      int df;\n+      dc;\n+      di;\n+      cx;\n+      auto dg(cu);\n+      auto dh(cu);\n+      auto dl(cu);\n+      for (; cz; df += de) {\n+        auto br = reinterpret_cast<T1 *>(cv);\n+        auto bs = reinterpret_cast<T1 *>(cv);\n+        auto bt = reinterpret_cast<T1 *>(df * ct.x());\n+        auto dj = reinterpret_cast<cm *>(dd.cf() + da);\n+        for (int dk; dk < cy; dk += cs, dj += cs)\n+          if (ct == ao()) {\n+            auto vres = bn::bz(br, bs, bt, dg, dh, dl, cn, by);\n+            bn::ca<cn>(dj, vres);\n+          } else\n+            bn::bq(br, bs, bt, dg, dh, dl, ct.v(), cn, by);\n+      }\n+    });\n+  }\n+};\n+template <typename T1, typename cm>\n+void bz(ay dm, int cs, bc *cp, bc *cq, bc *cr, aq cw, int dn, ao ct) {\n+  co<T1, cm, 1>::convolve(dm, cs, cp, cq, cr, cw, dn, ct);\n+  co<T1, cm, 2>::convolve(dm, cs, cp, cq, cr, cw, dn, ct);\n+}\n+} // namespace\n+void bd::ba(const ay &dm, const s &) {\n+  bz<o, p>(dm, bi, be, bg, bf, bh, bj, bk);\n+}\n+} // namespace an"}]}