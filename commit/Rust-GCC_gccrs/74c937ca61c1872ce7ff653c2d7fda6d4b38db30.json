{"sha": "74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRjOTM3Y2E2MWMxODcyY2U3ZmY2NTNjMmQ3ZmRhNmQ0YjM4ZGIzMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-11T02:11:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-11T02:11:21Z"}, "message": "ggc.h (ggc_push_context): Fix comment.\n\n\t* ggc.h (ggc_push_context): Fix comment.\n\t(ggc_pop_context): Likewise.\n\t(mark_string_if_gcable): Likewise.\n\t* ggc-common.c (ggc_mark_rtx_children): Use\n\tggc_mark_string_if_gcable.\n\t* ggc-page.c (ggc_lookup_page_table): New function.\n\t(ggc_allocated_p): Likewise.\n\t(mark_obj): Fix formatting.\n\t(ggc_mark_string_if_gcable): New function.\n\t* ggc-simple.c (ggc_allocated_strings): New variable.\n\t(ggc_strings_used): Likewise.\n\t(ggc_compare_addresses): New function.\n\t(ggc_pop_context): Pop the `any' memory too.\n\t(ggc_mark_string_if_gcable): New function.\n\t(ggc_collect): Initialize and tear down ggc_allocated_strings.\n\nFrom-SVN: r29897", "tree": {"sha": "5036f98758c484314588bc1a1893a4651f5f4190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5036f98758c484314588bc1a1893a4651f5f4190"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/comments", "author": null, "committer": null, "parents": [{"sha": "f9562f27ffae26afb22f320d27eca41f36de95a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9562f27ffae26afb22f320d27eca41f36de95a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9562f27ffae26afb22f320d27eca41f36de95a2"}], "stats": {"total": 153, "additions": 141, "deletions": 12}, "files": [{"sha": "0386a21f848c2d91521833c5d1e86a86a33d54f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "patch": "@@ -1,3 +1,21 @@\n+Sun Oct 10 18:27:27 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* ggc.h (ggc_push_context): Fix comment.\n+\t(ggc_pop_context): Likewise.\n+\t(mark_string_if_gcable): Likewise.\n+\t* ggc-common.c (ggc_mark_rtx_children): Use\n+\tggc_mark_string_if_gcable.\n+\t* ggc-page.c (ggc_lookup_page_table): New function.\n+\t(ggc_allocated_p): Likewise.\n+\t(mark_obj): Fix formatting.\n+\t(ggc_mark_string_if_gcable): New function.\n+\t* ggc-simple.c (ggc_allocated_strings): New variable.\n+\t(ggc_strings_used): Likewise.\n+\t(ggc_compare_addresses): New function.\n+\t(ggc_pop_context): Pop the `any' memory too.\n+\t(ggc_mark_string_if_gcable): New function.\n+\t(ggc_collect): Initialize and tear down ggc_allocated_strings.\n+\t\n Sun Oct 10 20:05:21 1999  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md (movstrsi_?reg): Use preferred rD/rS = r5 form."}, {"sha": "6df622e8e04df44efddee2b1332c7194308e33be", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "patch": "@@ -268,7 +268,7 @@ ggc_mark_rtx_children (r)\n \t  ggc_mark_rtvec (XVEC (r, i));\n \t  break;\n \tcase 'S': case 's':\n-\t  ggc_mark_string (XSTR (r, i));\n+\t  ggc_mark_string_if_gcable (XSTR (r, i));\n \t  break;\n \t}\n     }"}, {"sha": "1b643e6fa032ae48b85dafb258a440133d79b65b", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "patch": "@@ -258,6 +258,8 @@ static struct globals\n #define GGC_MIN_LAST_ALLOCATED (4 * 1024 * 1024)\n \n \f\n+static page_entry *** ggc_lookup_page_table PROTO ((void));\n+static int ggc_allocated_p PROTO ((const void *));\n static page_entry *lookup_page_table_entry PROTO ((void *));\n static void set_page_table_entry PROTO ((void *, page_entry *));\n static char *alloc_anon PROTO ((char *, size_t));\n@@ -276,15 +278,12 @@ static void poison_pages PROTO ((void));\n \n void debug_print_page_list PROTO ((int));\n \f\n-/* Traverse the page table and find the entry for a page. \n-   Die (probably) if the object wasn't allocated via GC.  */\n+/* Returns the lookup table appropriate for looking up P.  */\n \n-static inline page_entry *\n-lookup_page_table_entry(p)\n-     void *p;\n+static inline page_entry ***\n+ggc_lookup_page_table ()\n {\n   page_entry ***base;\n-  size_t L1, L2;\n \n #if HOST_BITS_PER_PTR <= 32\n   base = &G.lookup[0];\n@@ -296,6 +295,39 @@ lookup_page_table_entry(p)\n   base = &table->table[0];\n #endif\n \n+  return base;\n+}\n+\n+/* Returns non-zero if P was allocated in GC'able memory.  */\n+\n+static inline int\n+ggc_allocated_p (p)\n+     const void *p;\n+{\n+  page_entry ***base;\n+  size_t L1, L2;\n+\n+  base = ggc_lookup_page_table ();\n+\n+  /* Extract the level 1 and 2 indicies.  */\n+  L1 = LOOKUP_L1 (p);\n+  L2 = LOOKUP_L2 (p);\n+\n+  return base[L1] && base[L1][L2];\n+}\n+\n+/* Traverse the page table and find the entry for a page. \n+   Die (probably) if the object wasn't allocated via GC.  */\n+\n+static inline page_entry *\n+lookup_page_table_entry(p)\n+     void *p;\n+{\n+  page_entry ***base;\n+  size_t L1, L2;\n+\n+  base = ggc_lookup_page_table ();\n+\n   /* Extract the level 1 and 2 indicies.  */\n   L1 = LOOKUP_L1 (p);\n   L2 = LOOKUP_L2 (p);\n@@ -678,7 +710,7 @@ mark_obj (p)\n \n   /* Look up the page on which the object is alloced.  If the object\n      wasn't allocated by the collector, we'll probably die.  */\n-  entry = lookup_page_table_entry(p);\n+  entry = lookup_page_table_entry (p);\n #ifdef ENABLE_CHECKING\n   if (entry == NULL)\n     abort ();\n@@ -1076,6 +1108,14 @@ ggc_mark_string (s)\n     mark_obj (s);\n }\n \n+void\n+ggc_mark_string_if_gcable (s)\n+     char *s;\n+{\n+  if (s && ggc_allocated_p (s))\n+    mark_obj (s);\n+}\n+\n void \n ggc_mark (p)\n      void *p;"}, {"sha": "d8ed4a15a530e53392377c8a2cece8f5cc856077", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "patch": "@@ -114,6 +114,10 @@ struct ggc_status\n    front of the chain.  */\n static struct ggc_status *ggc_chain;\n \n+/* The table of all allocated strings.  Only valid during collection.  */\n+static varray_type ggc_allocated_strings;\n+static size_t ggc_strings_used;\n+\n /* Some statistics.  */\n \n static int n_rtxs_collected;\n@@ -134,6 +138,7 @@ static void ggc_free_rtvec PROTO ((struct ggc_rtvec *v));\n static void ggc_free_tree PROTO ((struct ggc_tree *t));\n static void ggc_free_string PROTO ((struct ggc_string *s));\n static void ggc_free_any PROTO ((struct ggc_any *a));\n+static int ggc_compare_addresses PROTO ((const void *, const void *));\n \n /* Called once to initialize the garbage collector.  */\n \n@@ -173,6 +178,7 @@ ggc_pop_context PROTO ((void))\n   struct ggc_rtvec *v;\n   struct ggc_tree *t;\n   struct ggc_string *s;\n+  struct ggc_any *a;\n   struct ggc_status *gs;\n \n   gs = ggc_chain;\n@@ -213,6 +219,15 @@ ggc_pop_context PROTO ((void))\n       gs->next->strings = gs->strings;\n     }\n \n+  a = gs->anys;\n+  if (a)\n+    {\n+     while (a->chain)\n+       a = a->chain;\n+      a->chain = gs->next->anys;\n+      gs->next->anys = gs->anys;\n+    }\n+\n   gs->next->bytes_alloced_since_gc += gs->bytes_alloced_since_gc;\n \n   ggc_chain = gs->next;\n@@ -455,6 +470,25 @@ ggc_set_mark_tree (t)\n   return marked;\n }\n \n+/* Compare the pointers pointed to by A1 and A2.  Used as a callback\n+   for qsort/bsearch.  */\n+\n+static int\n+ggc_compare_addresses (a1, a2)\n+     const void *a1;\n+     const void *a2;\n+{\n+  const char *c1 = *((const char **) a1);\n+  const char *c2 = *((const char **) a2);\n+\n+  if (c1 < c2)\n+    return -1;\n+  else if (c1 > c2)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n void\n ggc_mark_string (s)\n      char *s;\n@@ -471,6 +505,21 @@ ggc_mark_string (s)\n   gs->magic_mark = GGC_STRING_MAGIC_MARK;\n }\n \n+\n+void\n+ggc_mark_string_if_gcable (s)\n+     char *s;\n+{\n+  if (s && !bsearch (&s, \n+\t\t     &VARRAY_CHAR_PTR (ggc_allocated_strings, 0),\n+\t\t     ggc_strings_used, sizeof (char *),\n+\t\t     ggc_compare_addresses))\n+    return;\n+\n+  ggc_mark_string (s);\n+}\n+\n+\n /* Mark P, allocated with ggc_alloc.  */\n \n void\n@@ -513,6 +562,10 @@ ggc_collect ()\n \n   time = get_run_time ();\n \n+  /* Set up the table of allocated strings.  */\n+  VARRAY_CHAR_PTR_INIT (ggc_allocated_strings, 1024, \"allocated strings\");\n+  ggc_strings_used = 0;\n+\n   /* Clean out all of the GC marks.  */\n   for (gs = ggc_chain; gs; gs = gs->next)\n     {\n@@ -523,13 +576,28 @@ ggc_collect ()\n       for (t = gs->trees; t != NULL; t = t->chain)\n \tt->tree.common.gc_mark = 0;\n       for (s = gs->strings; s != NULL; s = s->chain)\n-\ts->magic_mark = GGC_STRING_MAGIC;\n+\t{\n+\t  s->magic_mark = GGC_STRING_MAGIC;\n+\t  if (ggc_strings_used == ggc_allocated_strings->num_elements)\n+\t    VARRAY_GROW (ggc_allocated_strings, 2 * ggc_strings_used);\n+\t  VARRAY_CHAR_PTR (ggc_allocated_strings, ggc_strings_used)\n+\t    = &s->string[0];\n+\t  ++ggc_strings_used;\n+\t}\n       for (a = gs->anys; a != NULL; a = a->chain)\n \ta->magic_mark = GGC_ANY_MAGIC;\n     }\n \n+  /* Sort the allocated string table.  */\n+  qsort (&VARRAY_CHAR_PTR (ggc_allocated_strings, 0),\n+\t ggc_strings_used, sizeof (char *),\n+\t ggc_compare_addresses);\n+\n   ggc_mark_roots ();\n \n+  /* Free the string table.  */\n+  VARRAY_FREE (ggc_allocated_strings);\n+\n   /* Sweep the resulting dead nodes.  */\n \n   /* The RTXs.  */"}, {"sha": "92b29f1f0e7b749b54f7775c05d3441b4d78310e", "filename": "gcc/ggc.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c937ca61c1872ce7ff653c2d7fda6d4b38db30/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=74c937ca61c1872ce7ff653c2d7fda6d4b38db30", "patch": "@@ -66,6 +66,10 @@ extern void ggc_mark_roots PROTO((void));\n extern void ggc_mark_rtx_children PROTO ((struct rtx_def *));\n extern void ggc_mark_tree_children PROTO ((union tree_node *));\n \n+/* Mark the string, but only if it was allocated in collectable\n+   memory.  */\n+extern void ggc_mark_string_if_gcable PROTO ((char *));\n+\n #define ggc_mark_rtx(RTX_EXPR)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n     rtx r__ = (RTX_EXPR);\t\t\t\t\\\n@@ -87,11 +91,11 @@ extern void init_ggc PROTO ((void));\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n-extern void ggc_pop_context PROTO ((void));\n+extern void ggc_push_context PROTO ((void));\n \n /* Finish a GC context.  Any uncollected memory in the new context\n    will be merged with the old context.  */\n-extern void ggc_push_context PROTO ((void));\n+extern void ggc_pop_context PROTO ((void));\n \n /* Allocation.  */\n struct rtx_def *ggc_alloc_rtx PROTO ((int nslots));\n@@ -113,7 +117,6 @@ int ggc_set_mark_rtx PROTO ((struct rtx_def *));\n int ggc_set_mark_rtvec PROTO ((struct rtvec_def *));\n int ggc_set_mark_tree PROTO ((union tree_node *));\n \n-\n /* Callbacks to the languages.  */\n \n /* This is the language's opportunity to mark nodes held through"}]}