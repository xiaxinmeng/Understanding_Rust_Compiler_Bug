{"sha": "50d76c246f1268b945c941c24d877b7acc5acae9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkNzZjMjQ2ZjEyNjhiOTQ1Yzk0MWMyNGQ4NzdiN2FjYzVhY2FlOQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2007-11-12T09:32:13Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2007-11-12T09:32:13Z"}, "message": "re PR tree-optimization/33953 (internal compiler error: vector VEC(tree,base) index domain error, in vectorizable_operation at tree-vect-transform.c:4017)\n\n\tPR tree-optimization/33953\n\t* tree-vect-transform.c (vectorizable_operation): In case of SLP,\n\tallocate vec_oprnds1 according to the number of created vector\n\tstatements. In case of shift with scalar argument, store scalar operand\n\tfor every vector statement to be created for the SLP node. Fix a\n\tcomment.\n\nFrom-SVN: r130096", "tree": {"sha": "575c10d594d2b57f54d759deee004cf543b23344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/575c10d594d2b57f54d759deee004cf543b23344"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50d76c246f1268b945c941c24d877b7acc5acae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d76c246f1268b945c941c24d877b7acc5acae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d76c246f1268b945c941c24d877b7acc5acae9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d76c246f1268b945c941c24d877b7acc5acae9/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7803a05defdb36b278dce08eb748fc72e41b3621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7803a05defdb36b278dce08eb748fc72e41b3621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7803a05defdb36b278dce08eb748fc72e41b3621"}], "stats": {"total": 98, "additions": 87, "deletions": 11}, "files": [{"sha": "1093ef3b261c3a3e35169810ece7ba8bdb6ec42d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50d76c246f1268b945c941c24d877b7acc5acae9", "patch": "@@ -1,3 +1,12 @@\n+2007-11-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/33953\n+\t* tree-vect-transform.c (vectorizable_operation): In case of SLP, \n+\tallocate vec_oprnds1 according to the number of created vector \n+\tstatements. In case of shift with scalar argument, store scalar operand  \n+\tfor every vector statement to be created for the SLP node. Fix a \n+\tcomment.\n+\n 2007-11-10  Steven Bosscher  <stevenb.gcc@gmail.com>\n \n \t* gcse.c (CUID_INSN): Remove."}, {"sha": "476b82b63bf69bb25f476b8176f2ceefdae0ce58", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50d76c246f1268b945c941c24d877b7acc5acae9", "patch": "@@ -1,3 +1,8 @@\n+2007-11-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/33953\n+\t* gcc.dg/vect/pr33953.c: New testcase.\n+\n 2007-11-11  Tom Tromey  <tromey@redhat.com>\n \n \tPR c++/17577:"}, {"sha": "ef1e248d7115788080058241bb1c4cbe6728a2ad", "filename": "gcc/testsuite/gcc.dg/vect/pr33953.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr33953.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr33953.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr33953.c?ref=50d76c246f1268b945c941c24d877b7acc5acae9", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+typedef unsigned int UINT32;\n+\n+void blockmove_NtoN_blend_noremap32 (const UINT32 *srcdata, int srcwidth,\n+                                     int srcheight, int srcmodulo,\n+                                     UINT32 *dstdata, int dstmodulo, \n+                                     int srcshift) \n+{\n+ UINT32 *end;\n+\n+ while (srcheight) \n+   {\n+     while (dstdata <= end - 8) \n+       {\n+         dstdata[0] |= srcdata[0] << srcshift;\n+         dstdata[1] |= srcdata[1] << srcshift;\n+         dstdata[2] |= srcdata[2] << srcshift;\n+         dstdata[3] |= srcdata[3] << srcshift;\n+         dstdata[4] |= srcdata[4] << srcshift;\n+         dstdata[5] |= srcdata[5] << srcshift;\n+         dstdata[6] |= srcdata[6] << srcshift;\n+         dstdata[7] |= srcdata[7] << srcshift;\n+         dstdata += 8;\n+         srcdata += 8;\n+       }\n+   }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "faf3b3ade221fc6f5539846aac105007c792ad61", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d76c246f1268b945c941c24d877b7acc5acae9/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=50d76c246f1268b945c941c24d877b7acc5acae9", "patch": "@@ -3785,6 +3785,8 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n   int j, i;\n   VEC(tree,heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n   tree vop0, vop1;\n+  unsigned int k;\n+  bool scalar_shift_arg = false;\n \n   /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n      this, so we can safely override NCOPIES with 1 here.  */\n@@ -3901,14 +3903,18 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n       /* Invariant argument is needed for a vector shift\n \t by a scalar shift operand.  */\n       optab_op2_mode = insn_data[icode].operand[2].mode;\n-      if (! (VECTOR_MODE_P (optab_op2_mode)\n-\t     || dt[1] == vect_constant_def\n-\t     || dt[1] == vect_invariant_def))\n+      if (!VECTOR_MODE_P (optab_op2_mode))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"operand mode requires invariant argument.\");\n-\t  return false;\n-\t}\n+\t  if (dt[1] != vect_constant_def && dt[1] != vect_invariant_def)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t        fprintf (vect_dump, \"operand mode requires invariant\"\n+                                    \" argument.\");\n+\t      return false;\n+\t    }\n+\n+          scalar_shift_arg = true;\n+        }\n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n@@ -3928,10 +3934,21 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n+  /* Allocate VECs for vector operands. In case of SLP, vector operands are \n+     created in the previous stages of the recursion, so no allocation is\n+     needed, except for the case of shift with scalar shift argument. In that\n+     case we store the scalar operand in VEC_OPRNDS1 for every vector stmt to\n+     be created to vectorize the SLP group, i.e., SLP_NODE->VEC_STMTS_SIZE.\n+     In case of loop-based vectorization we allocate VECs of size 1. We \n+     allocate VEC_OPRNDS1 only in case of binary operation.  */ \n   if (!slp_node)\n-    vec_oprnds0 = VEC_alloc (tree, heap, 1);\n-  if (op_type == binary_op)\n-    vec_oprnds1 = VEC_alloc (tree, heap, 1);\n+    {\n+      vec_oprnds0 = VEC_alloc (tree, heap, 1);\n+      if (op_type == binary_op)\n+        vec_oprnds1 = VEC_alloc (tree, heap, 1);\n+    }\n+  else if (scalar_shift_arg)\n+    vec_oprnds1 = VEC_alloc (tree, heap, slp_node->vec_stmts_size);  \n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -4006,10 +4023,20 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n \t\t    fprintf (vect_dump, \"operand 1 using scalar mode.\");\n \t\t  vec_oprnd1 = op1;\n \t\t  VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n+\t          if (slp_node)\n+\t            {\n+\t              /* Store vec_oprnd1 for every vector stmt to be created\n+\t                 for SLP_NODE. We check during the analysis that all the\n+                         shift arguments are the same.  \n+\t                 TODO: Allow different constants for different vector \n+\t                 stmts generated for an SLP instance.  */          \n+\t              for (k = 0; k < slp_node->vec_stmts_size - 1; k++)\n+\t                VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n+\t            }\n \t\t}\n \t    }\n \t \n-          /* vec_oprnd is available if operand 1 should be of a scalar-type \n+          /* vec_oprnd1 is available if operand 1 should be of a scalar-type \n              (a special case for certain kind of vector shifts); otherwise, \n              operand 1 should be of a vector type (the usual case).  */\n \t  if (op_type == binary_op && !vec_oprnd1)"}]}