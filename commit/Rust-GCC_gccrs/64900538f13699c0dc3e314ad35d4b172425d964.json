{"sha": "64900538f13699c0dc3e314ad35d4b172425d964", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ5MDA1MzhmMTM2OTljMGRjM2UzMTRhZDM1ZDRiMTcyNDI1ZDk2NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-11-09T12:59:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-11-09T12:59:17Z"}, "message": "re PR tree-optimization/56118 (Piecewise vector / complex initialization from constants not combined)\n\n2015-11-09  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/56118\n\t* tree-vectorizer.h (vect_find_last_scalar_stmt_in_slp): Declare.\n\t* tree-vect-slp.c (vect_find_last_scalar_stmt_in_slp): Export.\n\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): New\n\tfunction.\n\t(vect_slp_analyze_data_ref_dependences): Instead of computing\n\tall dependences of the region DRs just analyze the code motions\n\tSLP vectorization will perform.  Remove SLP instances that\n\tcannot have their store/load motions applied.\n\t(vect_analyze_data_refs): Allow DRs without a vectype\n\tin BB vectorization.\n\n\t* gcc.dg/vect/no-tree-sra-bb-slp-pr50730.c: Adjust.\n\nFrom-SVN: r230020", "tree": {"sha": "f09f60d6696253def20fa390d7a1c4736c462b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f09f60d6696253def20fa390d7a1c4736c462b37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64900538f13699c0dc3e314ad35d4b172425d964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64900538f13699c0dc3e314ad35d4b172425d964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64900538f13699c0dc3e314ad35d4b172425d964", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64900538f13699c0dc3e314ad35d4b172425d964/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc8ca59eb8522a9530e155f38ac616c15412254b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8ca59eb8522a9530e155f38ac616c15412254b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8ca59eb8522a9530e155f38ac616c15412254b"}], "stats": {"total": 118, "additions": 105, "deletions": 13}, "files": [{"sha": "56c609fc9ec1d1aea1386157611b8c3909be5573", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64900538f13699c0dc3e314ad35d4b172425d964", "patch": "@@ -1,3 +1,17 @@\n+2015-11-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/56118\n+\t* tree-vectorizer.h (vect_find_last_scalar_stmt_in_slp): Declare.\n+\t* tree-vect-slp.c (vect_find_last_scalar_stmt_in_slp): Export.\n+\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): New\n+\tfunction.\n+\t(vect_slp_analyze_data_ref_dependences): Instead of computing\n+\tall dependences of the region DRs just analyze the code motions\n+\tSLP vectorization will perform.  Remove SLP instances that\n+\tcannot have their store/load motions applied.\n+\t(vect_analyze_data_refs): Allow DRs without a vectype\n+\tin BB vectorization.\n+\n 2015-11-09  Julian Brown  <julian@codesourcery.com>\n \n \t* final.c (output_asm_insn): Pass VOIDmode to output_address."}, {"sha": "3809a723828ff65ca9b35e83b05d23fe711e4284", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64900538f13699c0dc3e314ad35d4b172425d964", "patch": "@@ -1,3 +1,8 @@\n+2015-11-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/56118\n+\t* gcc.dg/vect/no-tree-sra-bb-slp-pr50730.c: Adjust.\n+\n 2015-11-09  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* gcc.target/arm/thumb2-slow-flash-data.c: Add missing typespec for"}, {"sha": "8fe67f45faa4651b4d5a479c456222e58a955692", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-sra-bb-slp-pr50730.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-sra-bb-slp-pr50730.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-sra-bb-slp-pr50730.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-sra-bb-slp-pr50730.c?ref=64900538f13699c0dc3e314ad35d4b172425d964", "patch": "@@ -13,4 +13,4 @@ A sum(A a,A b)\n   return a;\n }\n \n-/* { dg-final { scan-tree-dump-times \"not vectorized: more than one data ref in stmt\" 0 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */"}, {"sha": "6e323911d932cae123ce24cdff2f6238fa2229c0", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 83, "deletions": 11, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=64900538f13699c0dc3e314ad35d4b172425d964", "patch": "@@ -559,6 +559,49 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n }\n \n \n+/* Analyze dependences involved in the transform of SLP NODE.  */\n+\n+static bool\n+vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node)\n+{\n+  /* This walks over all stmts involved in the SLP load/store done\n+     in NODE verifying we can sink them up to the last stmt in the\n+     group.  */\n+  gimple *last_access = vect_find_last_scalar_stmt_in_slp (node);\n+  for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n+    {\n+      gimple *access = SLP_TREE_SCALAR_STMTS (node)[k];\n+      if (access == last_access)\n+\tcontinue;\n+      stmt_vec_info access_stmt_info = vinfo_for_stmt (access);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (access);\n+      gsi_next (&gsi);\n+      for (; gsi_stmt (gsi) != last_access; gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  if (!STMT_VINFO_DATA_REF (stmt_info)\n+\t      || (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info))\n+\t\t  && DR_IS_READ (STMT_VINFO_DATA_REF (access_stmt_info))))\n+\t    continue;\n+\n+\t  ddr_p ddr = initialize_data_dependence_relation\n+\t      (STMT_VINFO_DATA_REF (access_stmt_info),\n+\t       STMT_VINFO_DATA_REF (stmt_info), vNULL);\n+\t  if (vect_slp_analyze_data_ref_dependence (ddr))\n+\t    {\n+\t      /* ???  If the dependence analysis failed we can resort to the\n+\t\t alias oracle which can handle more kinds of stmts.  */\n+\t      free_dependence_relation (ddr);\n+\t      return false;\n+\t    }\n+\t  free_dependence_relation (ddr);\n+\t}\n+    }\n+  return true;\n+}\n+\n+\n /* Function vect_analyze_data_ref_dependences.\n \n    Examine all the data references in the basic-block, and make sure there\n@@ -568,21 +611,45 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n bool\n vect_slp_analyze_data_ref_dependences (bb_vec_info bb_vinfo)\n {\n-  struct data_dependence_relation *ddr;\n-  unsigned int i;\n-\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_slp_analyze_data_ref_dependences ===\\n\");\n \n-  if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n-\t\t\t\t&BB_VINFO_DDRS (bb_vinfo),\n-\t\t\t\tvNULL, true))\n-    return false;\n+  slp_instance instance;\n+  slp_tree load;\n+  unsigned int i, j;\n+  for (i = 0; BB_VINFO_SLP_INSTANCES (bb_vinfo).iterate (i, &instance); )\n+    {\n+      bool remove = false;\n+      /* Verify we can sink loads to the vectorized stmt insert location.  */\n+      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, load)\n+\tif (! vect_slp_analyze_node_dependences (instance, load))\n+\t  {\n+\t    remove = true;\n+\t    break;\n+\t  }\n+      /* Verify we can sink stores to the vectorized stmt insert location.  */\n+      slp_tree store = SLP_INSTANCE_TREE (instance);\n+      if (!remove\n+\t  && STMT_VINFO_DATA_REF\n+\t\t(vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (store)[0]))\n+\t  && ! vect_slp_analyze_node_dependences (instance, store))\n+\tremove = true;\n+      if (remove)\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"removing SLP instance operations starting from: \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+\t\t\t    SLP_TREE_SCALAR_STMTS\n+\t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n+\t  vect_free_slp_instance (instance);\n+\t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n+\t}\n+      i++;\n+    }\n \n-  FOR_EACH_VEC_ELT (BB_VINFO_DDRS (bb_vinfo), i, ddr)\n-    if (vect_slp_analyze_data_ref_dependence (ddr))\n-      return false;\n+  if (!BB_VINFO_SLP_INSTANCES (bb_vinfo).length ())\n+    return false;\n \n   return true;\n }\n@@ -3674,7 +3741,12 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n             }\n \n           if (is_a <bb_vec_info> (vinfo))\n-\t    break;\n+\t    {\n+\t      /* No vector type is fine, the ref can still participate\n+\t         in dependence analysis, we just can't vectorize it.  */\n+\t      STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n+\t      continue;\n+\t    }\n \n \t  if (gatherscatter != SG_NONE || simd_lane_access)\n \t    {"}, {"sha": "954b85ef8bce45e4ad817ba7daee6f58b738eebb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=64900538f13699c0dc3e314ad35d4b172425d964", "patch": "@@ -1426,7 +1426,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \n /* Find the last store in SLP INSTANCE.  */\n \n-static gimple *\n+gimple *\n vect_find_last_scalar_stmt_in_slp (slp_tree node)\n {\n   gimple *last = NULL, *stmt;"}, {"sha": "fed80c81c3f3bf38923ed6cd6ed4961129dadc40", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64900538f13699c0dc3e314ad35d4b172425d964/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=64900538f13699c0dc3e314ad35d4b172425d964", "patch": "@@ -1075,6 +1075,7 @@ extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (vec<tree> , slp_tree,\n \t\t\t       vec<vec<tree> > *, int);\n extern bool vect_slp_bb (basic_block);\n+extern gimple *vect_find_last_scalar_stmt_in_slp (slp_tree);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}