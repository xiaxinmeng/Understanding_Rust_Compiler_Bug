{"sha": "3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NhMGRjNjAzMjEzYjJhZDVmZmJjZjFhNDQzYTEwMmJlZjk2MDUzYQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2017-11-15T01:53:45Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2017-11-15T01:53:45Z"}, "message": "Add __builtin_tgmath for better tgmath.h implementation (bug 81156).\n\nVarious implementations of C99/C11 <tgmath.h> have the property that\ntheir macro expansions contain many copies of the macro arguments, so\nresulting in exponential blowup of the size of macro expansions where\na call to such a macro contains other such calls in the macro\narguments.\n\nThis patch adds a (C-only) language feature __builtin_tgmath designed\nto avoid this problem by implementing the <tgmath.h> function\nselection rules directly in the compiler.  The effect is that\ntype-generic macros can be defined simply as\n\n#define pow(a, b) __builtin_tgmath (powf, pow, powl, \\\n                                    cpowf, cpow, cpowl, a, b)\n\nas in the example added to the manual, with each macro argument\nexpanded exactly once.  The details of __builtin_tgmath are as\ndescribed in the manual.  This is C-only since C++ uses function\noverloading and just defines <ctgmath> to include <ccomplex> and\n<cmath>.\n\n__builtin_tgmath handles C99/C11 type-generic macros, and _FloatN,\n_FloatNx and decimal floating-point types (following the proposed\nresolution to the floating-point TS DR#9 that makes the rules for\nfinding a common type from arguments to a type-generic macro follow\nthe usual arithmetic conversions after adjustment of integer arguments\nto _Decimal64 or double - or to _Complex double in the case of GNU\ncomplex integer arguments).\n\nType-generic macros for functions from TS 18661 that round their\nresults to a narrower type are handled, but there are still some\nunresolved questions regarding such macros so further changes in that\nregard may be needed in future.  The current implementation follows an\nolder version of the DR#13 resolution (allowing a function for a\nwide-enough argument type to be selected if no exactly-matching\nfunction is available), but with appropriate calls to __builtin_tgmath\nis still fully compatible with the latest version of the resolution\n(not yet in the DR log), and allowing such not-exactly-matching\nargument types to be chosen in that case avoids needing another\nspecial case to treat integers as _Float64 instead of double in\ncertain cases.\n\nRegarding other possible language/library features, not currently\nimplemented in GCC:\n\n* Imaginary types could be naturally supported by allowing cases where\n  the type-generic type is an imaginary type T and arguments or return\n  types may be T (as at present), or the corresponding real type to T\n  (as at present), or (new) the corresponding real type if T is real\n  or imaginary but T if T is complex.  (tgmath.h would need a series\n  of functions such as\n\n  static inline _Imaginary double\n  __sin_imag (_Imaginary double __x)\n  {\n    return _Imaginary_I * sinh (__imag__ __x);\n  }\n\n  to be used in __builtin_tgmath calls.)\n\n* __builtin_tgmath would use the constant rounding direction in the\n  presence of support for the FENV_ROUND / FENV_DEC_ROUND pragmas.\n  Support for those would also require a new __builtin_<something> to\n  cause a non-type-generic call to use the constant rounding\n  direction (it seems cleaner to add a new __builtin_<something> when\n  required than to make __builtin_tgmath handle a non-type-generic\n  case with only one function argument).\n\n* TS 18661-5 __STDC_TGMATH_OPERATOR_EVALUATION__ would require new\n  __builtin_<something> that evaluates with excess range and precision\n  like arithmetic operators do.\n\n* The proposed C bindings for IEEE 754-2018 augmented arithmetic\n  operations involve struct return types.  As currently implemented\n  __builtin_tgmath does not handle those, but support could be added.\n\nThere are many error cases that the implementation diagnoses.  I've\ntried to ensure reasonable error messages for erroneous uses of\n__builtin_tgmath, but the errors for erroneous uses of the resulting\ntype-generic macros (that is, when the non-function arguments have\ninappropriate types) are more important as they are more likely to be\nseen by users.\n\nGCC's own tgmath.h, as used for some targets, is updated in this\npatch.  I've tested those changes minimally, via adjusting\ngcc.dg/c99-tgmath-* locally to use that tgmath.h version.  I've also\nrun the glibc testsuite (which has much more thorough tests of\ncorrectness of tgmath.h function selection) with a glibc patch to use\n__builtin_tgmath in glibc's tgmath.h.\n\nBootstrapped with no regressions on x86_64-pc-linux-gnu.\n\n\tPR c/81156\n\ngcc:\n\t* doc/extend.texi (Other Builtins): Document __builtin_tgmath.\n\t* ginclude/tgmath.h (__tg_cplx, __tg_ldbl, __tg_dbl, __tg_choose)\n\t(__tg_choose_2, __tg_choose_3, __TGMATH_REAL_1_2)\n\t(__TGMATH_REAL_2_3): Remove macros.\n\t(__TGMATH_CPLX, __TGMATH_CPLX_2, __TGMATH_REAL, __TGMATH_REAL_2)\n\t(__TGMATH_REAL_3, __TGMATH_CPLX_ONLY): Define using\n\t__builtin_tgmath.\n\t(frexp, ldexp, nexttoward, scalbn, scalbln): Define using\n\t__TGMATH_REAL_2.\n\t(remquo): Define using __TGMATH_REAL_3.\n\ngcc/c:\n\t* c-parser.c (check_tgmath_function): New function.\n\t(enum tgmath_parm_kind): New enum.\n\t(c_parser_postfix_expression): Handle __builtin_tgmath.\n\ngcc/c-family:\n\t* c-common.c (c_common_reswords): Add __builtin_tgmath.\n\t* c-common.h (enum rid): Add RID_BUILTIN_TGMATH.\n\ngcc/testsuite:\n\t* gcc.dg/builtin-tgmath-1.c, gcc.dg/builtin-tgmath-2.c,\n\tgcc.dg/builtin-tgmath-err-1.c, gcc.dg/builtin-tgmath-err-2.c,\n\tgcc.dg/dfp/builtin-tgmath-dfp-err.c,\n\tgcc.dg/dfp/builtin-tgmath-dfp.c: New tests.\n\nFrom-SVN: r254749", "tree": {"sha": "3c0c2c2688d3a9286523a577c507e343650af5ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c0c2c2688d3a9286523a577c507e343650af5ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f60bea11ada835a0b007469816bd1130a2f9a77a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60bea11ada835a0b007469816bd1130a2f9a77a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60bea11ada835a0b007469816bd1130a2f9a77a"}], "stats": {"total": 1504, "additions": 1441, "deletions": 63}, "files": [{"sha": "22431e52f4504e5cf31b8f6453b549435d525d95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -1,3 +1,17 @@\n+2017-11-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/81156\n+\t* doc/extend.texi (Other Builtins): Document __builtin_tgmath.\n+\t* ginclude/tgmath.h (__tg_cplx, __tg_ldbl, __tg_dbl, __tg_choose)\n+\t(__tg_choose_2, __tg_choose_3, __TGMATH_REAL_1_2)\n+\t(__TGMATH_REAL_2_3): Remove macros.\n+\t(__TGMATH_CPLX, __TGMATH_CPLX_2, __TGMATH_REAL, __TGMATH_REAL_2)\n+\t(__TGMATH_REAL_3, __TGMATH_CPLX_ONLY): Define using\n+\t__builtin_tgmath.\n+\t(frexp, ldexp, nexttoward, scalbn, scalbln): Define using\n+\t__TGMATH_REAL_2.\n+\t(remquo): Define using __TGMATH_REAL_3.\n+\n 2017-11-14  Jeff Law  <law@redhat.com>\n \n \t* vr-values.c: New file with contents extracted from tree-vrp.c."}, {"sha": "3127635056ca7c83ba380dd178dd5e4b86341cd0", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -1,3 +1,9 @@\n+2017-11-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/81156\n+\t* c-common.c (c_common_reswords): Add __builtin_tgmath.\n+\t* c-common.h (enum rid): Add RID_BUILTIN_TGMATH.\n+\n 2017-11-10  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81117"}, {"sha": "65d37c60c48127dc8973cdbeda439b11a4ee7b99", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -376,6 +376,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__builtin_complex\", RID_BUILTIN_COMPLEX, D_CONLY },\n   { \"__builtin_launder\", RID_BUILTIN_LAUNDER, D_CXXONLY },\n   { \"__builtin_shuffle\", RID_BUILTIN_SHUFFLE, 0 },\n+  { \"__builtin_tgmath\", RID_BUILTIN_TGMATH, D_CONLY },\n   { \"__builtin_offsetof\", RID_OFFSETOF, 0 },\n   { \"__builtin_types_compatible_p\", RID_TYPES_COMPATIBLE_P, D_CONLY },\n   { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },"}, {"sha": "5bb86191d2b78cc6967e590ea6e93f7c264767e7", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -101,6 +101,7 @@ enum rid\n   RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\t     RID_BUILTIN_SHUFFLE,\n+  RID_BUILTIN_TGMATH,\n   RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n \n   /* TS 18661-3 keywords, in the same sequence as the TI_* values.  */"}, {"sha": "5622c8ae7875256a96dfbe94ec07fb8a84643454", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -1,3 +1,10 @@\n+2017-11-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/81156\n+\t* c-parser.c (check_tgmath_function): New function.\n+\t(enum tgmath_parm_kind): New enum.\n+\t(c_parser_postfix_expression): Handle __builtin_tgmath.\n+\n 2017-10-31  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-decl.c (implicit_decl_warning): Update for renaming of"}, {"sha": "3d90e28caad16aab94c8035a8fc94429eb8d098a", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -7829,6 +7829,61 @@ c_parser_generic_selection (c_parser *parser)\n   return matched_assoc.expression;\n }\n \n+/* Check the validity of a function pointer argument *EXPR (argument\n+   position POS) to __builtin_tgmath.  Return the number of function\n+   arguments if possibly valid; return 0 having reported an error if\n+   not valid.  */\n+\n+static unsigned int\n+check_tgmath_function (c_expr *expr, unsigned int pos)\n+{\n+  tree type = TREE_TYPE (expr->value);\n+  if (!FUNCTION_POINTER_TYPE_P (type))\n+    {\n+      error_at (expr->get_location (),\n+\t\t\"argument %u of %<__builtin_tgmath%> is not a function pointer\",\n+\t\tpos);\n+      return 0;\n+    }\n+  type = TREE_TYPE (type);\n+  if (!prototype_p (type))\n+    {\n+      error_at (expr->get_location (),\n+\t\t\"argument %u of %<__builtin_tgmath%> is unprototyped\", pos);\n+      return 0;\n+    }\n+  if (stdarg_p (type))\n+    {\n+      error_at (expr->get_location (),\n+\t\t\"argument %u of %<__builtin_tgmath%> has variable arguments\",\n+\t\tpos);\n+      return 0;\n+    }\n+  unsigned int nargs = 0;\n+  function_args_iterator iter;\n+  tree t;\n+  FOREACH_FUNCTION_ARGS (type, t, iter)\n+    {\n+      if (t == void_type_node)\n+\tbreak;\n+      nargs++;\n+    }\n+  if (nargs == 0)\n+    {\n+      error_at (expr->get_location (),\n+\t\t\"argument %u of %<__builtin_tgmath%> has no arguments\", pos);\n+      return 0;\n+    }\n+  return nargs;\n+}\n+\n+/* Ways in which a parameter or return value of a type-generic macro\n+   may vary between the different functions the macro may call.  */\n+enum tgmath_parm_kind\n+  {\n+    tgmath_fixed, tgmath_real, tgmath_complex\n+  };\n+\n /* Parse a postfix expression (C90 6.3.1-6.3.2, C99 6.5.1-6.5.2,\n    C11 6.5.1-6.5.2).  Compound literals aren't handled here; callers have to\n    call c_parser_postfix_expression_after_paren_type on encountering them.\n@@ -7869,6 +7924,7 @@ c_parser_generic_selection (c_parser *parser)\n \t\t\t     assignment-expression ,\n \t\t\t     assignment-expression )\n      __builtin_types_compatible_p ( type-name , type-name )\n+     __builtin_tgmath ( expr-list )\n      __builtin_complex ( assignment-expression , assignment-expression )\n      __builtin_shuffle ( assignment-expression , assignment-expression )\n      __builtin_shuffle ( assignment-expression ,\n@@ -8295,6 +8351,513 @@ c_parser_postfix_expression (c_parser *parser)\n \t    set_c_expr_source_range (&expr, loc, close_paren_loc);\n \t  }\n \t  break;\n+\tcase RID_BUILTIN_TGMATH:\n+\t  {\n+\t    vec<c_expr_t, va_gc> *cexpr_list;\n+\t    location_t close_paren_loc;\n+\n+\t    c_parser_consume_token (parser);\n+\t    if (!c_parser_get_builtin_args (parser,\n+\t\t\t\t\t    \"__builtin_tgmath\",\n+\t\t\t\t\t    &cexpr_list, false,\n+\t\t\t\t\t    &close_paren_loc))\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\n+\t    if (vec_safe_length (cexpr_list) < 3)\n+\t      {\n+\t\terror_at (loc, \"too few arguments to %<__builtin_tgmath%>\");\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\n+\t    unsigned int i;\n+\t    c_expr_t *p;\n+\t    FOR_EACH_VEC_ELT (*cexpr_list, i, p)\n+\t      *p = convert_lvalue_to_rvalue (loc, *p, true, true);\n+\t    unsigned int nargs = check_tgmath_function (&(*cexpr_list)[0], 1);\n+\t    if (nargs == 0)\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    if (vec_safe_length (cexpr_list) < nargs)\n+\t      {\n+\t\terror_at (loc, \"too few arguments to %<__builtin_tgmath%>\");\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    unsigned int num_functions = vec_safe_length (cexpr_list) - nargs;\n+\t    if (num_functions < 2)\n+\t      {\n+\t\terror_at (loc, \"too few arguments to %<__builtin_tgmath%>\");\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\n+\t    /* The first NUM_FUNCTIONS expressions are the function\n+\t       pointers.  The remaining NARGS expressions are the\n+\t       arguments that are to be passed to one of those\n+\t       functions, chosen following <tgmath.h> rules.  */\n+\t    for (unsigned int j = 1; j < num_functions; j++)\n+\t      {\n+\t\tunsigned int this_nargs\n+\t\t  = check_tgmath_function (&(*cexpr_list)[j], j + 1);\n+\t\tif (this_nargs == 0)\n+\t\t  {\n+\t\t    expr.set_error ();\n+\t\t    goto out;\n+\t\t  }\n+\t\tif (this_nargs != nargs)\n+\t\t  {\n+\t\t    error_at ((*cexpr_list)[j].get_location (),\n+\t\t\t      \"argument %u of %<__builtin_tgmath%> has \"\n+\t\t\t      \"wrong number of arguments\", j + 1);\n+\t\t    expr.set_error ();\n+\t\t    goto out;\n+\t\t  }\n+\t      }\n+\n+\t    /* The functions all have the same number of arguments.\n+\t       Determine whether arguments and return types vary in\n+\t       ways permitted for <tgmath.h> functions.  */\n+\t    /* The first entry in each of these vectors is for the\n+\t       return type, subsequent entries for parameter\n+\t       types.  */\n+\t    auto_vec<enum tgmath_parm_kind> parm_kind (nargs + 1);\n+\t    auto_vec<tree> parm_first (nargs + 1);\n+\t    auto_vec<bool> parm_complex (nargs + 1);\n+\t    auto_vec<bool> parm_varies (nargs + 1);\n+\t    tree first_type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[0].value));\n+\t    tree first_ret = TYPE_MAIN_VARIANT (TREE_TYPE (first_type));\n+\t    parm_first.quick_push (first_ret);\n+\t    parm_complex.quick_push (TREE_CODE (first_ret) == COMPLEX_TYPE);\n+\t    parm_varies.quick_push (false);\n+\t    function_args_iterator iter;\n+\t    tree t;\n+\t    unsigned int argpos;\n+\t    FOREACH_FUNCTION_ARGS (first_type, t, iter)\n+\t      {\n+\t\tif (t == void_type_node)\n+\t\t  break;\n+\t\tparm_first.quick_push (TYPE_MAIN_VARIANT (t));\n+\t\tparm_complex.quick_push (TREE_CODE (t) == COMPLEX_TYPE);\n+\t\tparm_varies.quick_push (false);\n+\t      }\n+\t    for (unsigned int j = 1; j < num_functions; j++)\n+\t      {\n+\t\ttree type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[j].value));\n+\t\ttree ret = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+\t\tif (ret != parm_first[0])\n+\t\t  {\n+\t\t    parm_varies[0] = true;\n+\t\t    if (!SCALAR_FLOAT_TYPE_P (parm_first[0])\n+\t\t\t&& !COMPLEX_FLOAT_TYPE_P (parm_first[0]))\n+\t\t      {\n+\t\t\terror_at ((*cexpr_list)[0].get_location (),\n+\t\t\t\t  \"invalid type-generic return type for \"\n+\t\t\t\t  \"argument %u of %<__builtin_tgmath%>\",\n+\t\t\t\t  1);\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t    if (!SCALAR_FLOAT_TYPE_P (ret)\n+\t\t\t&& !COMPLEX_FLOAT_TYPE_P (ret))\n+\t\t      {\n+\t\t\terror_at ((*cexpr_list)[j].get_location (),\n+\t\t\t\t  \"invalid type-generic return type for \"\n+\t\t\t\t  \"argument %u of %<__builtin_tgmath%>\",\n+\t\t\t\t  j + 1);\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t  }\n+\t\tif (TREE_CODE (ret) == COMPLEX_TYPE)\n+\t\t  parm_complex[0] = true;\n+\t\targpos = 1;\n+\t\tFOREACH_FUNCTION_ARGS (type, t, iter)\n+\t\t  {\n+\t\t    if (t == void_type_node)\n+\t\t      break;\n+\t\t    t = TYPE_MAIN_VARIANT (t);\n+\t\t    if (t != parm_first[argpos])\n+\t\t      {\n+\t\t\tparm_varies[argpos] = true;\n+\t\t\tif (!SCALAR_FLOAT_TYPE_P (parm_first[argpos])\n+\t\t\t    && !COMPLEX_FLOAT_TYPE_P (parm_first[argpos]))\n+\t\t\t  {\n+\t\t\t    error_at ((*cexpr_list)[0].get_location (),\n+\t\t\t\t      \"invalid type-generic type for \"\n+\t\t\t\t      \"argument %u of argument %u of \"\n+\t\t\t\t      \"%<__builtin_tgmath%>\", argpos, 1);\n+\t\t\t    expr.set_error ();\n+\t\t\t    goto out;\n+\t\t\t  }\n+\t\t\tif (!SCALAR_FLOAT_TYPE_P (t)\n+\t\t\t    && !COMPLEX_FLOAT_TYPE_P (t))\n+\t\t\t  {\n+\t\t\t    error_at ((*cexpr_list)[j].get_location (),\n+\t\t\t\t      \"invalid type-generic type for \"\n+\t\t\t\t      \"argument %u of argument %u of \"\n+\t\t\t\t      \"%<__builtin_tgmath%>\", argpos, j + 1);\n+\t\t\t    expr.set_error ();\n+\t\t\t    goto out;\n+\t\t\t  }\n+\t\t      }\n+\t\t    if (TREE_CODE (t) == COMPLEX_TYPE)\n+\t\t      parm_complex[argpos] = true;\n+\t\t    argpos++;\n+\t\t  }\n+\t      }\n+\t    enum tgmath_parm_kind max_variation = tgmath_fixed;\n+\t    for (unsigned int j = 0; j <= nargs; j++)\n+\t      {\n+\t\tenum tgmath_parm_kind this_kind;\n+\t\tif (parm_varies[j])\n+\t\t  {\n+\t\t    if (parm_complex[j])\n+\t\t      max_variation = this_kind = tgmath_complex;\n+\t\t    else\n+\t\t      {\n+\t\t\tthis_kind = tgmath_real;\n+\t\t\tif (max_variation != tgmath_complex)\n+\t\t\t  max_variation = tgmath_real;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  this_kind = tgmath_fixed;\n+\t\tparm_kind.quick_push (this_kind);\n+\t      }\n+\t    if (max_variation == tgmath_fixed)\n+\t      {\n+\t\terror_at (loc, \"function arguments of %<__builtin_tgmath%> \"\n+\t\t\t  \"all have the same type\");\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\n+\t    /* Identify a parameter (not the return type) that varies,\n+\t       including with complex types if any variation includes\n+\t       complex types; there must be at least one such\n+\t       parameter.  */\n+\t    unsigned int tgarg = 0;\n+\t    for (unsigned int j = 1; j <= nargs; j++)\n+\t      if (parm_kind[j] == max_variation)\n+\t\t{\n+\t\t  tgarg = j;\n+\t\t  break;\n+\t\t}\n+\t    if (tgarg == 0)\n+\t      {\n+\t\terror_at (loc, \"function arguments of %<__builtin_tgmath%> \"\n+\t\t\t  \"lack type-generic parameter\");\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\n+\t    /* Determine the type of the relevant parameter for each\n+\t       function.  */\n+\t    auto_vec<tree> tg_type (num_functions);\n+\t    for (unsigned int j = 0; j < num_functions; j++)\n+\t      {\n+\t\ttree type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[j].value));\n+\t\targpos = 1;\n+\t\tFOREACH_FUNCTION_ARGS (type, t, iter)\n+\t\t  {\n+\t\t    if (argpos == tgarg)\n+\t\t      {\n+\t\t\ttg_type.quick_push (TYPE_MAIN_VARIANT (t));\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    argpos++;\n+\t\t  }\n+\t      }\n+\n+\t    /* Verify that the corresponding types are different for\n+\t       all the listed functions.  Also determine whether all\n+\t       the types are complex, whether all the types are\n+\t       standard or binary, and whether all the types are\n+\t       decimal.  */\n+\t    bool all_complex = true;\n+\t    bool all_binary = true;\n+\t    bool all_decimal = true;\n+\t    hash_set<tree> tg_types;\n+\t    FOR_EACH_VEC_ELT (tg_type, i, t)\n+\t      {\n+\t\tif (TREE_CODE (t) == COMPLEX_TYPE)\n+\t\t  all_decimal = false;\n+\t\telse\n+\t\t  {\n+\t\t    all_complex = false;\n+\t\t    if (DECIMAL_FLOAT_TYPE_P (t))\n+\t\t      all_binary = false;\n+\t\t    else\n+\t\t      all_decimal = false;\n+\t\t  }\n+\t\tif (tg_types.add (t))\n+\t\t  {\n+\t\t    error_at ((*cexpr_list)[i].get_location (),\n+\t\t\t      \"duplicate type-generic parameter type for \"\n+\t\t\t      \"function argument %u of %<__builtin_tgmath%>\",\n+\t\t\t      i + 1);\n+\t\t    expr.set_error ();\n+\t\t    goto out;\n+\t\t  }\n+\t      }\n+\n+\t    /* Verify that other parameters and the return type whose\n+\t       types vary have their types varying in the correct\n+\t       way.  */\n+\t    for (unsigned int j = 0; j < num_functions; j++)\n+\t      {\n+\t\ttree exp_type = tg_type[j];\n+\t\ttree exp_real_type = exp_type;\n+\t\tif (TREE_CODE (exp_type) == COMPLEX_TYPE)\n+\t\t  exp_real_type = TREE_TYPE (exp_type);\n+\t\ttree type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[j].value));\n+\t\ttree ret = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+\t\tif ((parm_kind[0] == tgmath_complex && ret != exp_type)\n+\t\t    || (parm_kind[0] == tgmath_real && ret != exp_real_type))\n+\t\t  {\n+\t\t    error_at ((*cexpr_list)[j].get_location (),\n+\t\t\t      \"bad return type for function argument %u \"\n+\t\t\t      \"of %<__builtin_tgmath%>\", j + 1);\n+\t\t    expr.set_error ();\n+\t\t    goto out;\n+\t\t  }\n+\t\targpos = 1;\n+\t\tFOREACH_FUNCTION_ARGS (type, t, iter)\n+\t\t  {\n+\t\t    if (t == void_type_node)\n+\t\t      break;\n+\t\t    t = TYPE_MAIN_VARIANT (t);\n+\t\t    if ((parm_kind[argpos] == tgmath_complex\n+\t\t\t && t != exp_type)\n+\t\t\t|| (parm_kind[argpos] == tgmath_real\n+\t\t\t    && t != exp_real_type))\n+\t\t      {\n+\t\t\terror_at ((*cexpr_list)[j].get_location (),\n+\t\t\t\t  \"bad type for argument %u of \"\n+\t\t\t\t  \"function argument %u of \"\n+\t\t\t\t  \"%<__builtin_tgmath%>\", argpos, j + 1);\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t    argpos++;\n+\t\t  }\n+\t      }\n+\n+\t    /* The functions listed are a valid set of functions for a\n+\t       <tgmath.h> macro to select between.  Identify the\n+\t       matching function, if any.  First, the argument types\n+\t       must be combined following <tgmath.h> rules.  Integer\n+\t       types are treated as _Decimal64 if any type-generic\n+\t       argument is decimal, or if the only alternatives for\n+\t       type-generic arguments are of decimal types, and are\n+\t       otherwise treated as double (or _Complex double for\n+\t       complex integer types).  After that adjustment, types\n+\t       are combined following the usual arithmetic\n+\t       conversions.  If the function only accepts complex\n+\t       arguments, a complex type is produced.  */\n+\t    bool arg_complex = all_complex;\n+\t    bool arg_binary = all_binary;\n+\t    bool arg_int_decimal = all_decimal;\n+\t    for (unsigned int j = 1; j <= nargs; j++)\n+\t      {\n+\t\tif (parm_kind[j] == tgmath_fixed)\n+\t\t  continue;\n+\t\tc_expr_t *ce = &(*cexpr_list)[num_functions + j - 1];\n+\t\ttree type = TREE_TYPE (ce->value);\n+\t\tif (!INTEGRAL_TYPE_P (type)\n+\t\t    && !SCALAR_FLOAT_TYPE_P (type)\n+\t\t    && TREE_CODE (type) != COMPLEX_TYPE)\n+\t\t  {\n+\t\t    error_at (ce->get_location (),\n+\t\t\t      \"invalid type of argument %u of type-generic \"\n+\t\t\t      \"function\", j);\n+\t\t    expr.set_error ();\n+\t\t    goto out;\n+\t\t  }\n+\t\tif (DECIMAL_FLOAT_TYPE_P (type))\n+\t\t  {\n+\t\t    arg_int_decimal = true;\n+\t\t    if (all_complex)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"decimal floating-point argument %u to \"\n+\t\t\t\t  \"complex-only type-generic function\", j);\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t    else if (all_binary)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"decimal floating-point argument %u to \"\n+\t\t\t\t  \"binary-only type-generic function\", j);\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t    else if (arg_complex)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"both complex and decimal floating-point \"\n+\t\t\t\t  \"arguments to type-generic function\");\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t    else if (arg_binary)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"both binary and decimal floating-point \"\n+\t\t\t\t  \"arguments to type-generic function\");\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t  }\n+\t\telse if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t\t  {\n+\t\t    arg_complex = true;\n+\t\t    if (COMPLEX_FLOAT_TYPE_P (type))\n+\t\t      arg_binary = true;\n+\t\t    if (all_decimal)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"complex argument %u to \"\n+\t\t\t\t  \"decimal-only type-generic function\", j);\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t    else if (arg_int_decimal)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"both complex and decimal floating-point \"\n+\t\t\t\t  \"arguments to type-generic function\");\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t  }\n+\t\telse if (SCALAR_FLOAT_TYPE_P (type))\n+\t\t  {\n+\t\t    arg_binary = true;\n+\t\t    if (all_decimal)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"binary argument %u to \"\n+\t\t\t\t  \"decimal-only type-generic function\", j);\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t    else if (arg_int_decimal)\n+\t\t      {\n+\t\t\terror_at (ce->get_location (),\n+\t\t\t\t  \"both binary and decimal floating-point \"\n+\t\t\t\t  \"arguments to type-generic function\");\n+\t\t\texpr.set_error ();\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    tree arg_real = NULL_TREE;\n+\t    for (unsigned int j = 1; j <= nargs; j++)\n+\t      {\n+\t\tif (parm_kind[j] == tgmath_fixed)\n+\t\t  continue;\n+\t\tc_expr_t *ce = &(*cexpr_list)[num_functions + j - 1];\n+\t\ttree type = TYPE_MAIN_VARIANT (TREE_TYPE (ce->value));\n+\t\tif (TREE_CODE (type) == COMPLEX_TYPE)\n+\t\t  type = TREE_TYPE (type);\n+\t\tif (INTEGRAL_TYPE_P (type))\n+\t\t  type = (arg_int_decimal\n+\t\t\t  ? dfloat64_type_node\n+\t\t\t  : double_type_node);\n+\t\tif (arg_real == NULL_TREE)\n+\t\t  arg_real = type;\n+\t\telse\n+\t\t  arg_real = common_type (arg_real, type);\n+\t\tif (arg_real == error_mark_node)\n+\t\t  {\n+\t\t    expr.set_error ();\n+\t\t    goto out;\n+\t\t  }\n+\t      }\n+\t    tree arg_type = (arg_complex\n+\t\t\t     ? build_complex_type (arg_real)\n+\t\t\t     : arg_real);\n+\n+\t    /* Look for a function to call with type-generic parameter\n+\t       type ARG_TYPE.  */\n+\t    c_expr_t *fn = NULL;\n+\t    for (unsigned int j = 0; j < num_functions; j++)\n+\t      {\n+\t\tif (tg_type[j] == arg_type)\n+\t\t  {\n+\t\t    fn = &(*cexpr_list)[j];\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    if (fn == NULL\n+\t\t&& parm_kind[0] == tgmath_fixed\n+\t\t&& SCALAR_FLOAT_TYPE_P (parm_first[0]))\n+\t      {\n+\t\t/* Presume this is a macro that rounds its result to a\n+\t\t   narrower type, and look for the first function with\n+\t\t   at least the range and precision of the argument\n+\t\t   type.  */\n+\t\tfor (unsigned int j = 0; j < num_functions; j++)\n+\t\t  {\n+\t\t    if (arg_complex\n+\t\t\t!= (TREE_CODE (tg_type[j]) == COMPLEX_TYPE))\n+\t\t      continue;\n+\t\t    tree real_tg_type = (arg_complex\n+\t\t\t\t\t ? TREE_TYPE (tg_type[j])\n+\t\t\t\t\t : tg_type[j]);\n+\t\t    if (DECIMAL_FLOAT_TYPE_P (arg_real)\n+\t\t\t!= DECIMAL_FLOAT_TYPE_P (real_tg_type))\n+\t\t      continue;\n+\t\t    scalar_float_mode arg_mode\n+\t\t      = SCALAR_FLOAT_TYPE_MODE (arg_real);\n+\t\t    scalar_float_mode tg_mode\n+\t\t      = SCALAR_FLOAT_TYPE_MODE (real_tg_type);\n+\t\t    const real_format *arg_fmt = REAL_MODE_FORMAT (arg_mode);\n+\t\t    const real_format *tg_fmt = REAL_MODE_FORMAT (tg_mode);\n+\t\t    if (arg_fmt->b == tg_fmt->b\n+\t\t\t&& arg_fmt->p <= tg_fmt->p\n+\t\t\t&& arg_fmt->emax <= tg_fmt->emax\n+\t\t\t&& (arg_fmt->emin - arg_fmt->p\n+\t\t\t    >= tg_fmt->emin - tg_fmt->p))\n+\t\t      {\n+\t\t\tfn = &(*cexpr_list)[j];\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    if (fn == NULL)\n+\t      {\n+\t\terror_at (loc, \"no matching function for type-generic call\");\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\n+\t    /* Construct a call to FN.  */\n+\t    vec<tree, va_gc> *args;\n+\t    vec_alloc (args, nargs);\n+\t    vec<tree, va_gc> *origtypes;\n+\t    vec_alloc (origtypes, nargs);\n+\t    auto_vec<location_t> arg_loc (nargs);\n+\t    for (unsigned int j = 0; j < nargs; j++)\n+\t      {\n+\t\tc_expr_t *ce = &(*cexpr_list)[num_functions + j];\n+\t\targs->quick_push (ce->value);\n+\t\targ_loc.quick_push (ce->get_location ());\n+\t\torigtypes->quick_push (ce->original_type);\n+\t      }\n+\t    expr.value = c_build_function_call_vec (loc, arg_loc, fn->value,\n+\t\t\t\t\t\t    args, origtypes);\n+\t    set_c_expr_source_range (&expr, loc, close_paren_loc);\n+\t    break;\n+\t  }\n \tcase RID_BUILTIN_CALL_WITH_STATIC_CHAIN:\n \t  {\n \t    vec<c_expr_t, va_gc> *cexpr_list;\n@@ -8563,6 +9126,7 @@ c_parser_postfix_expression (c_parser *parser)\n       expr.set_error ();\n       break;\n     }\n+ out:\n   return c_parser_postfix_expression_after_primary\n     (parser, EXPR_LOC_OR_LOC (expr.value, loc), expr);\n }"}, {"sha": "711264c132a4b0df2b3d6261bfb282ce235a4219", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -11684,6 +11684,63 @@ future revisions.\n \n @end deftypefn\n \n+@deftypefn {Built-in Function} @var{type} __builtin_tgmath (@var{functions}, @var{arguments})\n+\n+The built-in function @code{__builtin_tgmath}, available only for C\n+and Objective-C, calls a function determined according to the rules of\n+@code{<tgmath.h>} macros.  It is intended to be used in\n+implementations of that header, so that expansions of macros from that\n+header only expand each of their arguments once, to avoid problems\n+when calls to such macros are nested inside the arguments of other\n+calls to such macros; in addition, it results in better diagnostics\n+for invalid calls to @code{<tgmath.h>} macros than implementations\n+using other GNU C language features.  For example, the @code{pow}\n+type-generic macro might be defined as:\n+\n+@smallexample\n+#define pow(a, b) __builtin_tgmath (powf, pow, powl, \\\n+                                    cpowf, cpow, cpowl, a, b)\n+@end smallexample\n+\n+The arguments to @code{__builtin_tgmath} are at least two pointers to\n+functions, followed by the arguments to the type-generic macro (which\n+will be passed as arguments to the selected function).  All the\n+pointers to functions must be pointers to prototyped functions, none\n+of which may have variable arguments, and all of which must have the\n+same number of parameters; the number of parameters of the first\n+function determines how many arguments to @code{__builtin_tgmath} are\n+interpreted as function pointers, and how many as the arguments to the\n+called function.\n+\n+The types of the specified functions must all be different, but\n+related to each other in the same way as a set of functions that may\n+be selected between by a macro in @code{<tgmath.h>}.  This means that\n+the functions are parameterized by a floating-point type @var{t},\n+different for each such function.  The function return types may all\n+be the same type, or they may be @var{t} for each function, or they\n+may be the real type corresponding to @var{t} for each function (if\n+some of the types @var{t} are complex).  Likewise, for each parameter\n+position, the type of the parameter in that position may always be the\n+same type, or may be @var{t} for each function (this case must apply\n+for at least one parameter position), or may be the real type\n+corresponding to @var{t} for each function.\n+\n+The standard rules for @code{<tgmath.h>} macros are used to find a\n+common type @var{u} from the types of the arguments for parameters\n+whose types vary between the functions; complex integer types (a GNU\n+extension) are treated like @code{_Complex double} for this purpose.\n+If the function return types vary, or are all the same integer type,\n+the function called is the one for which @var{t} is @var{u}, and it is\n+an error if there is no such function.  If the function return types\n+are all the same floating-point type, the type-generic macro is taken\n+to be one of those from TS 18661 that rounds the result to a narrower\n+type; if there is a function for which @var{t} is @var{u}, it is\n+called, and otherwise the first function, if any, for which @var{t}\n+has at least the range and precision of @var{u} is called, and it is\n+an error if there is no such function.\n+\n+@end deftypefn\n+\n @deftypefn {Built-in Function} @var{type} __builtin_complex (@var{real}, @var{imag})\n \n The built-in function @code{__builtin_complex} is provided for use in"}, {"sha": "97968ad2302b89bcebb51cfbaf5c486cf00d20b8", "filename": "gcc/ginclude/tgmath.h", "status": "modified", "additions": 19, "deletions": 63, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fginclude%2Ftgmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Fginclude%2Ftgmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Ftgmath.h?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -38,68 +38,24 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    __TGMATH_CPLX*, __TGMATH_REAL*, and __TGMATH_CPLX_ONLY.  _CPLX\n    means the generic argument(s) may be real or complex, _REAL means\n    real only, _CPLX means complex only.  If there is no suffix, we are\n-   defining a function of one generic argument.  If the suffix is _n\n-   it is a function of n generic arguments.  If the suffix is _m_n it\n-   is a function of n arguments, the first m of which are generic.  We\n-   only define these macros for values of n and/or m that are needed. */\n-\n-/* The general rules for generic macros are given in 7.22 paragraphs 1 and 2.\n-   If any generic parameter is complex, we use a complex version.  Otherwise\n-   we use a real version.  If the real part of any generic parameter is long\n-   double, we use the long double version.  Otherwise if the real part of any\n-   generic parameter is double or of integer type, we use the double version.\n-   Otherwise we use the float version. */\n-\n-#define __tg_cplx(expr) \\\n-  __builtin_classify_type(expr) == 9\n-\n-#define __tg_ldbl(expr) \\\n-  __builtin_types_compatible_p(__typeof__(expr), long double)\n-\n-#define __tg_dbl(expr)                                       \\\n-  (__builtin_types_compatible_p(__typeof__(expr), double)    \\\n-   || __builtin_classify_type(expr) == 1)\n-\n-#define __tg_choose(x,f,d,l)                                  \\\n-  __builtin_choose_expr(__tg_ldbl(x), l,                      \\\n-                        __builtin_choose_expr(__tg_dbl(x), d, \\\n-                                              f))\n-\n-#define __tg_choose_2(x,y,f,d,l)                                             \\\n-  __builtin_choose_expr(__tg_ldbl(x) || __tg_ldbl(y), l,                     \\\n-                        __builtin_choose_expr(__tg_dbl(x) || __tg_dbl(y), d, \\\n-                                              f))\n-\n-#define __tg_choose_3(x,y,z,f,d,l)                                        \\\n-   __builtin_choose_expr(__tg_ldbl(x) || __tg_ldbl(y) || __tg_ldbl(z), l, \\\n-                        __builtin_choose_expr(__tg_dbl(x) || __tg_dbl(y)  \\\n-                                              || __tg_dbl(z), d,          \\\n-                                              f))\n-\n-#define __TGMATH_CPLX(z,R,C)                                                  \\\n-  __builtin_choose_expr (__tg_cplx(z),                                        \\\n-                         __tg_choose (__real__(z), C##f(z), (C)(z), C##l(z)), \\\n-                         __tg_choose (z, R##f(z), (R)(z), R##l(z)))\n-\n-#define __TGMATH_CPLX_2(z1,z2,R,C)                                             \\\n-  __builtin_choose_expr (__tg_cplx(z1) || __tg_cplx(z2),                       \\\n-                         __tg_choose_2 (__real__(z1), __real__(z2),            \\\n-                                        C##f(z1,z2), (C)(z1,z2), C##l(z1,z2)), \\\n-                         __tg_choose_2 (z1, z2,                                \\\n-                                        R##f(z1,z2), (R)(z1,z2), R##l(z1,z2)))\n+   defining a function of one argument.  If the suffix is _n\n+   it is a function of n arguments.  We only define these macros for\n+   values of n that are needed. */\n+\n+#define __TGMATH_CPLX(z,R,C)\t\t\t\t\\\n+  __builtin_tgmath (R##f, R, R##l, C##f, C, C##l, (z))\n+\n+#define __TGMATH_CPLX_2(z1,z2,R,C)\t\t\t\t\\\n+  __builtin_tgmath (R##f, R, R##l, C##f, C, C##l, (z1), (z2))\n \n #define __TGMATH_REAL(x,R) \\\n-  __tg_choose (x, R##f(x), (R)(x), R##l(x))\n+  __builtin_tgmath (R##f, R, R##l, (x))\n #define __TGMATH_REAL_2(x,y,R) \\\n-  __tg_choose_2 (x, y, R##f(x,y), (R)(x,y), R##l(x,y))\n+  __builtin_tgmath (R##f, R, R##l, (x), (y))\n #define __TGMATH_REAL_3(x,y,z,R) \\\n-  __tg_choose_3 (x, y, z, R##f(x,y,z), (R)(x,y,z), R##l(x,y,z))\n-#define __TGMATH_REAL_1_2(x,y,R) \\\n-  __tg_choose (x, R##f(x,y), (R)(x,y), R##l(x,y))\n-#define __TGMATH_REAL_2_3(x,y,z,R) \\\n-  __tg_choose_2 (x, y, R##f(x,y,z), (R)(x,y,z), R##l(x,y,z))\n+  __builtin_tgmath (R##f, R, R##l, (x), (y), (z))\n #define __TGMATH_CPLX_ONLY(z,C) \\\n-  __tg_choose (__real__(z), C##f(z), (C)(z), C##l(z))\n+  __builtin_tgmath (C##f, C, C##l, (z))\n \n /* Functions defined in both <math.h> and <complex.h> (7.22p4) */\n #define acos(z)          __TGMATH_CPLX(z, acos, cacos)\n@@ -135,10 +91,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define fmax(x,y)        __TGMATH_REAL_2(x, y, fmax)\n #define fmin(x,y)        __TGMATH_REAL_2(x, y, fmin)\n #define fmod(x,y)        __TGMATH_REAL_2(x, y, fmod)\n-#define frexp(x,y)       __TGMATH_REAL_1_2(x, y, frexp)\n+#define frexp(x,y)       __TGMATH_REAL_2(x, y, frexp)\n #define hypot(x,y)       __TGMATH_REAL_2(x, y, hypot)\n #define ilogb(x)         __TGMATH_REAL(x, ilogb)\n-#define ldexp(x,y)       __TGMATH_REAL_1_2(x, y, ldexp)\n+#define ldexp(x,y)       __TGMATH_REAL_2(x, y, ldexp)\n #define lgamma(x)        __TGMATH_REAL(x, lgamma)\n #define llrint(x)        __TGMATH_REAL(x, llrint)\n #define llround(x)       __TGMATH_REAL(x, llround)\n@@ -150,13 +106,13 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define lround(x)        __TGMATH_REAL(x, lround)\n #define nearbyint(x)     __TGMATH_REAL(x, nearbyint)\n #define nextafter(x,y)   __TGMATH_REAL_2(x, y, nextafter)\n-#define nexttoward(x,y)  __TGMATH_REAL_1_2(x, y, nexttoward)\n+#define nexttoward(x,y)  __TGMATH_REAL_2(x, y, nexttoward)\n #define remainder(x,y)   __TGMATH_REAL_2(x, y, remainder)\n-#define remquo(x,y,z)    __TGMATH_REAL_2_3(x, y, z, remquo)\n+#define remquo(x,y,z)    __TGMATH_REAL_3(x, y, z, remquo)\n #define rint(x)          __TGMATH_REAL(x, rint)\n #define round(x)         __TGMATH_REAL(x, round)\n-#define scalbn(x,y)      __TGMATH_REAL_1_2(x, y, scalbn)\n-#define scalbln(x,y)     __TGMATH_REAL_1_2(x, y, scalbln)\n+#define scalbn(x,y)      __TGMATH_REAL_2(x, y, scalbn)\n+#define scalbln(x,y)     __TGMATH_REAL_2(x, y, scalbln)\n #define tgamma(x)        __TGMATH_REAL(x, tgamma)\n #define trunc(x)         __TGMATH_REAL(x, trunc)\n "}, {"sha": "1cd0070c82edd99e5cae25d1e3114166175b1734", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -1,3 +1,11 @@\n+2017-11-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/81156\n+\t* gcc.dg/builtin-tgmath-1.c, gcc.dg/builtin-tgmath-2.c,\n+\tgcc.dg/builtin-tgmath-err-1.c, gcc.dg/builtin-tgmath-err-2.c,\n+\tgcc.dg/dfp/builtin-tgmath-dfp-err.c,\n+\tgcc.dg/dfp/builtin-tgmath-dfp.c: New tests.\n+\n 2017-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/float128-hw4.c: New test."}, {"sha": "ff87ace42fd602b9ec070db9976664a0361b0e3a", "filename": "gcc/testsuite/gcc.dg/builtin-tgmath-1.c", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-1.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -0,0 +1,322 @@\n+/* Test __builtin_tgmath: valid uses, standard floating-point types.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+#define CHECK_CALL(C, E, V)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((C) != (E))\t\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      extern __typeof (C) V;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+extern float var_f;\n+extern double var_d;\n+extern long double var_ld;\n+extern _Complex float var_cf;\n+extern _Complex double var_cd;\n+extern _Complex long double var_cld;\n+extern int var_i;\n+\n+typedef float float_type;\n+typedef double double_type;\n+\n+/* Test simple case, real arguments and return type.  */\n+\n+float_type t1f (float x) { return x + 1; }\n+double t1d (double_type x) { return x + 2; }\n+long double t1l (volatile long double x) { return x + 3; }\n+\n+#define t1v(x) __builtin_tgmath (t1f, t1d, t1l, x)\n+#define t1vr(x) __builtin_tgmath (t1l, t1d, t1f, x)\n+\n+static void\n+test_1 (void)\n+{\n+  float_type f = 1;\n+  volatile float vf = 2;\n+  double d = 3;\n+  long double ld = 4;\n+  int i = 5;\n+  long long ll = 6;\n+  CHECK_CALL (t1v (f), 2, var_f);\n+  CHECK_CALL (t1v (vf), 3, var_f);\n+  CHECK_CALL (t1v (d), 5, var_d);\n+  CHECK_CALL (t1v (ld), 7, var_ld);\n+  CHECK_CALL (t1v (i), 7, var_d);\n+  CHECK_CALL (t1v (ll), 8, var_d);\n+  CHECK_CALL (t1vr (f), 2, var_f);\n+  CHECK_CALL (t1vr (vf), 3, var_f);\n+  CHECK_CALL (t1vr (d), 5, var_d);\n+  CHECK_CALL (t1vr (ld), 7, var_ld);\n+  CHECK_CALL (t1vr (i), 7, var_d);\n+  CHECK_CALL (t1vr (ll), 8, var_d);\n+}\n+\n+/* Test first argument not type-generic.  */\n+\n+float t2f (int a, float x) { return a * x + 1; }\n+double t2d (int a, double x) { return a * x + 2; }\n+long double t2l (int a, long double x) { return a * x + 3; }\n+\n+#define t2v(a, x) __builtin_tgmath (t2f, t2d, t2l, a, x)\n+\n+static void\n+test_2 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  int i = 4;\n+  unsigned long long ll = 5;\n+  CHECK_CALL (t2v (1, f), 2, var_f);\n+  CHECK_CALL (t2v (2, d), 6, var_d);\n+  CHECK_CALL (t2v (3, ld), 12, var_ld);\n+  CHECK_CALL (t2v (4, i), 18, var_d);\n+  CHECK_CALL (t2v (5, ll), 27, var_d);\n+}\n+\n+/* Test return type not type-generic.  */\n+\n+int t3f (float x) { return x + 1; }\n+int t3d (double x) { return x + 2; }\n+int t3l (long double x) { return x + 3; }\n+\n+#define t3v(x) __builtin_tgmath (t3f, t3d, t3l, x)\n+\n+static void\n+test_3 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  short s = 4;\n+  CHECK_CALL (t3v (f), 2, var_i);\n+  CHECK_CALL (t3v (d), 4, var_i);\n+  CHECK_CALL (t3v (ld), 6, var_i);\n+  CHECK_CALL (t3v (s), 6, var_i);\n+}\n+\n+/* Test multiple type-generic arguments.  */\n+\n+float t4f (float x, float y) { return 10 * x + y; }\n+double t4d (double x, double y) { return 100 * x + y; }\n+long double t4l (long double x, long double y) { return 1000 * x + y; }\n+\n+#define t4v(x, y) __builtin_tgmath (t4f, t4d, t4l, x, y)\n+\n+static void\n+test_4 (void)\n+{\n+  float f1 = 1;\n+  float f2 = 2;\n+  double d1 = 3;\n+  double d2 = 4;\n+  long double ld = 5;\n+  long int l = 6;\n+  CHECK_CALL (t4v (f1, f2), 12, var_f);\n+  CHECK_CALL (t4v (f2, f1), 21, var_f);\n+  CHECK_CALL (t4v (f1, d1), 103, var_d);\n+  CHECK_CALL (t4v (d2, f2), 402, var_d);\n+  CHECK_CALL (t4v (f1, l), 106, var_d);\n+  CHECK_CALL (t4v (ld, f1), 5001, var_ld);\n+  CHECK_CALL (t4v (l, l), 606, var_d);\n+  CHECK_CALL (t4v (l, ld), 6005, var_ld);\n+}\n+\n+/* Test complex argument, real return type.  */\n+\n+float t5f (_Complex float x) { return 1 + __real__ x + 3 * __imag__ x; }\n+double t5d (_Complex double x) { return 2 + __real__ x + 4 * __imag__ x; }\n+long double t5l (_Complex long double x) { return 3 + __real__ x + 5 * __imag__ x; }\n+\n+#define t5v(x) __builtin_tgmath (t5f, t5d, t5l, x)\n+\n+static void\n+test_5 (void)\n+{\n+  float f = 1;\n+  _Complex float cf = 2 + 3i;\n+  double d = 4;\n+  _Complex double cd = 5 + 6i;\n+  long double ld = 7;\n+  _Complex long double cld = 8 + 9i;\n+  int i = 10;\n+  _Complex int ci = 11 + 12i;\n+  CHECK_CALL (t5v (f), 2, var_f);\n+  CHECK_CALL (t5v (cf), 12, var_f);\n+  CHECK_CALL (t5v (d), 6, var_d);\n+  CHECK_CALL (t5v (cd), 31, var_d);\n+  CHECK_CALL (t5v (ld), 10, var_ld);\n+  CHECK_CALL (t5v (cld), 56, var_ld);\n+  CHECK_CALL (t5v (i), 12, var_d);\n+  CHECK_CALL (t5v (ci), 61, var_d);\n+}\n+\n+/* Test complex argument, complex return type.  */\n+\n+_Complex float t6f (_Complex float x) { return 1 + x; }\n+_Complex double t6d (_Complex double x) { return 2 + x; }\n+_Complex long double t6l (_Complex long double x) { return 3 + x; }\n+\n+#define t6v(x) __builtin_tgmath (t6f, t6d, t6l, x)\n+\n+static void\n+test_6 (void)\n+{\n+  float f = 1;\n+  _Complex float cf = 2 + 3i;\n+  double d = 4;\n+  _Complex double cd = 5 + 6i;\n+  long double ld = 7;\n+  _Complex long double cld = 8 + 9i;\n+  int i = 10;\n+  _Complex int ci = 11 + 12i;\n+  CHECK_CALL (t6v (f), 2, var_cf);\n+  CHECK_CALL (t6v (cf), 3 + 3i, var_cf);\n+  CHECK_CALL (t6v (d), 6, var_cd);\n+  CHECK_CALL (t6v (cd), 7 + 6i, var_cd);\n+  CHECK_CALL (t6v (ld), 10, var_cld);\n+  CHECK_CALL (t6v (cld), 11 + 9i, var_cld);\n+  CHECK_CALL (t6v (i), 12, var_cd);\n+  CHECK_CALL (t6v (ci), 13 + 12i, var_cd);\n+}\n+\n+/* Test real and complex argument, real return type.  */\n+\n+float t7f (float x) { return 1 + x; }\n+float t7cf (_Complex float x) { return 2 + __real__ x; }\n+double t7d (double x) { return 3 + x; }\n+double t7cd (_Complex double x) { return 4 + __real__ x; }\n+long double t7l (long double x) { return 5 + x; }\n+long double t7cl (_Complex long double x) { return 6 + __real__ x; }\n+\n+#define t7v(x) __builtin_tgmath (t7f, t7d, t7l, t7cf, t7cd, t7cl, x)\n+\n+static void\n+test_7 (void)\n+{\n+  float f = 1;\n+  _Complex float cf = 2 + 3i;\n+  double d = 4;\n+  _Complex double cd = 5 + 6i;\n+  long double ld = 7;\n+  _Complex long double cld = 8 + 9i;\n+  int i = 10;\n+  _Complex int ci = 11 + 12i;\n+  CHECK_CALL (t7v (f), 2, var_f);\n+  CHECK_CALL (t7v (cf), 4, var_f);\n+  CHECK_CALL (t7v (d), 7, var_d);\n+  CHECK_CALL (t7v (cd), 9, var_d);\n+  CHECK_CALL (t7v (ld), 12, var_ld);\n+  CHECK_CALL (t7v (cld), 14, var_ld);\n+  CHECK_CALL (t7v (i), 13, var_d);\n+  CHECK_CALL (t7v (ci), 15, var_d);\n+}\n+\n+/* Test real and complex argument, real and complex return type.  */\n+\n+float t8f (float x) { return 1 + x; }\n+_Complex float t8cf (_Complex float x) { return 2 + x; }\n+double t8d (double x) { return 3 + x; }\n+_Complex double t8cd (_Complex double x) { return 4 + x; }\n+long double t8l (long double x) { return 5 + x; }\n+_Complex long double t8cl (_Complex long double x) { return 6 + x; }\n+\n+#define t8v(x) __builtin_tgmath (t8f, t8d, t8l, t8cf, t8cd, t8cl, x)\n+\n+static void\n+test_8 (void)\n+{\n+  float f = 1;\n+  _Complex float cf = 2 + 3i;\n+  double d = 4;\n+  _Complex double cd = 5 + 6i;\n+  long double ld = 7;\n+  _Complex long double cld = 8 + 9i;\n+  int i = 10;\n+  _Complex int ci = 11 + 12i;\n+  CHECK_CALL (t8v (f), 2, var_f);\n+  CHECK_CALL (t8v (cf), 4 + 3i, var_cf);\n+  CHECK_CALL (t8v (d), 7, var_d);\n+  CHECK_CALL (t8v (cd), 9 + 6i, var_cd);\n+  CHECK_CALL (t8v (ld), 12, var_ld);\n+  CHECK_CALL (t8v (cld), 14 + 9i, var_cld);\n+  CHECK_CALL (t8v (i), 13, var_d);\n+  CHECK_CALL (t8v (ci), 15 + 12i, var_cd);\n+}\n+\n+/* Test multiple type-generic arguments, real and complex.  */\n+\n+float t9f (float x, float y) { return x + 10 * y; }\n+_Complex float t9cf (_Complex float x, _Complex float y) { return x + 100 * y; }\n+double t9d (double x, double y) { return x + 1000 * y; }\n+_Complex double t9cd (_Complex double x, _Complex double y) { return x + 10000 * y; }\n+long double t9l (long double x, long double y) { return x + 100000 * y; }\n+_Complex long double t9cl (_Complex long double x, _Complex long double y) { return x + 1000000 * y; }\n+\n+#define t9v(x, y) __builtin_tgmath (t9f, t9d, t9l, t9cf, t9cd, t9cl, x, y)\n+\n+static void\n+test_9 (void)\n+{\n+  float f = 1;\n+  _Complex float cf = 2 + 3i;\n+  double d = 4;\n+  _Complex double cd = 5 + 6i;\n+  long double ld = 7;\n+  _Complex long double cld = 8 + 9i;\n+  int i = 10;\n+  _Complex int ci = 11 + 12i;\n+  CHECK_CALL (t9v (f, f), 11, var_f);\n+  CHECK_CALL (t9v (f, cf), 201 + 300i, var_cf);\n+  CHECK_CALL (t9v (cf, f), 102 + 3i, var_cf);\n+  CHECK_CALL (t9v (f, i), 10001, var_d);\n+  CHECK_CALL (t9v (i, f), 1010, var_d);\n+  CHECK_CALL (t9v (d, d), 4004, var_d);\n+  CHECK_CALL (t9v (d, cd), 50004 + 60000i, var_cd);\n+  CHECK_CALL (t9v (ld, i), 1000007, var_ld);\n+  CHECK_CALL (t9v (cf, cld), 8000002 + 9000003i, var_cld);\n+  CHECK_CALL (t9v (i, i), 10010, var_d);\n+  CHECK_CALL (t9v (ci, i), 100011 + 12i, var_cd);\n+}\n+\n+/* Test functions rounding result to narrower type.  */\n+\n+float t10d (double x) { return 1 + x; }\n+float t10l (long double x) { return 2 + x; }\n+\n+#define t10v(x) __builtin_tgmath (t10d, t10l, x)\n+\n+static void\n+test_10 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  short s = 4;\n+  CHECK_CALL (t10v (f), 2, var_f);\n+  CHECK_CALL (t10v (d), 3, var_f);\n+  CHECK_CALL (t10v (ld), 5, var_f);\n+  CHECK_CALL (t10v (s), 5, var_f);\n+}\n+\n+int\n+main (void)\n+{\n+  test_1 ();\n+  test_2 ();\n+  test_3 ();\n+  test_4 ();\n+  test_5 ();\n+  test_6 ();\n+  test_7 ();\n+  test_8 ();\n+  test_9 ();\n+  test_10 ();\n+  exit (0);\n+}"}, {"sha": "c4140cc2bd5a2cefb9234dc87f407fbff723c6c6", "filename": "gcc/testsuite/gcc.dg/builtin-tgmath-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-2.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -0,0 +1,51 @@\n+/* Test __builtin_tgmath: valid uses, _FloatN types.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+#define CHECK_CALL(C, E, V)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((C) != (E))\t\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      extern __typeof (C) V;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+extern float var_f;\n+extern double var_d;\n+extern long double var_ld;\n+extern _Float32 var_f32;\n+\n+float t1f (float x) { return x + 1; }\n+double t1d (double x) { return x + 2; }\n+long double t1l (long double x) { return x + 3; }\n+_Float32 t1f32 (_Float32 x) { return x + 4; }\n+\n+#define t1v(x) __builtin_tgmath (t1f, t1d, t1l, t1f32, x)\n+\n+static void\n+test_1 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  _Float32 f32 = 4;\n+  int i = 5;\n+  CHECK_CALL (t1v (f), 2, var_f);\n+  CHECK_CALL (t1v (d), 4, var_d);\n+  CHECK_CALL (t1v (ld), 6, var_ld);\n+  CHECK_CALL (t1v (f32), 8, var_f32);\n+  CHECK_CALL (t1v (i), 7, var_d);\n+}\n+\n+int\n+main (void)\n+{\n+  test_1 ();\n+  exit (0);\n+}"}, {"sha": "9016ec742bed41b6ddebbc0fa2f1ac1dad714229", "filename": "gcc/testsuite/gcc.dg/builtin-tgmath-err-1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-err-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-err-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-err-1.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -0,0 +1,76 @@\n+/* Test __builtin_tgmath: errors that indicate a bad definition of a\n+   type-generic macro rather than bad arguments in a call to it.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+void *p;\n+double d;\n+double unprototyped_d ();\n+long double unprototyped_ld ();\n+double variadic_d (double, ...);\n+long double variadic_ld (long double, ...);\n+double no_arguments_d (void);\n+long double no_arguments_ld (void);\n+double f_d (double);\n+long double f_ld (long double);\n+double many_args (double, double, double, double);\n+int f_i_d (double);\n+_Complex int f_ci_d (double);\n+void * f_p_d (double);\n+double f_d_i (int);\n+double f_d_ci (_Complex int);\n+double f_d_p (void *);\n+long double f_ld_d (double);\n+_Complex double f_cd_d (double);\n+double f_d_f (float);\n+double f_d_dd (double, double);\n+long double f_ld_ldld (long double, long double);\n+float f_f_fd (float, double);\n+\n+void\n+test (void)\n+{\n+  /* Arguments individually invalid or no consistent number of\n+     arguments followed by those arguments.  */\n+  __builtin_tgmath (); /* { dg-error \"too few arguments\" } */\n+  __builtin_tgmath (f_d); /* { dg-error \"too few arguments\" } */\n+  __builtin_tgmath (f_d, f_ld); /* { dg-error \"too few arguments\" } */\n+  __builtin_tgmath (many_args, many_args, many_args); /* { dg-error \"too few arguments\" } */\n+  __builtin_tgmath (many_args, d, d, d, d); /* { dg-error \"too few arguments\" } */\n+  __builtin_tgmath (f_ld, many_args, d); /* { dg-error \"has wrong number of arguments\" } */\n+  __builtin_tgmath (unprototyped_d, unprototyped_ld, d); /* { dg-error \"is unprototyped\" } */\n+  __builtin_tgmath (f_d, unprototyped_ld, d); /* { dg-error \"is unprototyped\" } */\n+  __builtin_tgmath (variadic_d, variadic_ld, d); /* { dg-error \"variable arguments\" } */\n+  __builtin_tgmath (f_d, variadic_ld, d); /* { dg-error \"variable arguments\" } */\n+  __builtin_tgmath (p, p, p); /* { dg-error \"is not a function pointer\" } */\n+  __builtin_tgmath (f_d, p, p); /* { dg-error \"is not a function pointer\" } */\n+  __builtin_tgmath (no_arguments_d, no_arguments_d, no_arguments_ld); /* { dg-error \"has no arguments\" } */\n+  __builtin_tgmath (f_d, no_arguments_d, no_arguments_ld); /* { dg-error \"has no arguments\" } */\n+\n+  /* Invalid varying types of arguments.  */\n+  __builtin_tgmath (f_i_d, f_ld, 0); /* { dg-error \"invalid type-generic return type\" } */\n+  __builtin_tgmath (f_ci_d, f_ld, 0); /* { dg-error \"invalid type-generic return type\" } */\n+  __builtin_tgmath (f_p_d, f_ld, 0); /* { dg-error \"invalid type-generic return type\" } */\n+  __builtin_tgmath (f_ld, f_i_d, 0); /* { dg-error \"invalid type-generic return type\" } */\n+  __builtin_tgmath (f_ld, f_ci_d, 0); /* { dg-error \"invalid type-generic return type\" } */\n+  __builtin_tgmath (f_ld, f_p_d, 0); /* { dg-error \"invalid type-generic return type\" } */\n+  __builtin_tgmath (f_d_i, f_ld, 0); /* { dg-error \"invalid type-generic type for argument\" } */\n+  __builtin_tgmath (f_d_ci, f_ld, 0); /* { dg-error \"invalid type-generic type for argument\" } */\n+  __builtin_tgmath (f_d_p, f_ld, 0); /* { dg-error \"invalid type-generic type for argument\" } */\n+  __builtin_tgmath (f_ld, f_d_i, 0); /* { dg-error \"invalid type-generic type for argument\" } */\n+  __builtin_tgmath (f_ld, f_d_ci, 0); /* { dg-error \"invalid type-generic type for argument\" } */\n+  __builtin_tgmath (f_ld, f_d_p, 0); /* { dg-error \"invalid type-generic type for argument\" } */\n+\n+  /* Arguments same type.  */\n+  __builtin_tgmath (f_d, f_d, 0); /* { dg-error \"all have the same type\" } */\n+\n+  /* Missing or invalid type-generic parameter.  */\n+  __builtin_tgmath (f_d, f_ld_d, 0); /* { dg-error \"lack type-generic parameter\" } */\n+  __builtin_tgmath (f_d, f_ld, f_cd_d, 0); /* { dg-error \"lack type-generic parameter\" } */\n+  __builtin_tgmath (f_d, f_ld, f_d, 0); /* { dg-error \"duplicate type-generic parameter type\" } */\n+\n+  /* Variation not consistent with the identified type-generic\n+     parameter.  */\n+  __builtin_tgmath (f_d, f_ld, f_d_f, 0); /* { dg-error \"bad return type for function argument\" } */\n+  __builtin_tgmath (f_d_dd, f_ld_ldld, f_f_fd, 0, 0); /* { dg-error \"bad type for argument\" } */\n+}"}, {"sha": "df5655ef40256f5a997ae800ff2e89d8cab529c0", "filename": "gcc/testsuite/gcc.dg/builtin-tgmath-err-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-err-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-err-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-err-2.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -0,0 +1,19 @@\n+/* Test __builtin_tgmath: errors that indicate bad arguments in a call\n+   to a type-generic macro, non-DFP.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+float f_f (float);\n+double f_d (double);\n+long double f_ld (long double);\n+void *p;\n+long double ld;\n+_Complex float cf;\n+\n+void\n+test (void)\n+{\n+  __builtin_tgmath (f_f, f_d, f_ld, p); /* { dg-error \"invalid type of argument\" } */\n+  __builtin_tgmath (f_f, f_d, ld); /* { dg-error \"no matching function for type-generic call\" } */\n+  __builtin_tgmath (f_f, f_d, cf); /* { dg-error \"no matching function for type-generic call\" } */\n+}"}, {"sha": "b94c760c3ece1652019229ab2f8b5cb85030ca73", "filename": "gcc/testsuite/gcc.dg/dfp/builtin-tgmath-dfp-err.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fbuiltin-tgmath-dfp-err.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fbuiltin-tgmath-dfp-err.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fbuiltin-tgmath-dfp-err.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -0,0 +1,33 @@\n+/* Test __builtin_tgmath: errors that indicate bad arguments in a call\n+   to a type-generic macro, DFP involved.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+float f_f (float);\n+double f_d (double);\n+long double f_ld (long double);\n+_Complex float f_cf (_Complex float);\n+_Complex double f_cd (_Complex double);\n+_Complex long double f_cld (_Complex long double);\n+_Decimal32 f_d32 (_Decimal32);\n+_Decimal64 f_d64 (_Decimal64);\n+_Decimal128 f_d128 (_Decimal128);\n+float f_ff (float, float);\n+_Complex float f_cfcf (_Complex float, _Complex float);\n+_Decimal32 f_d32d32 (_Decimal32, _Decimal32);\n+_Complex float cf;\n+float f;\n+_Decimal32 d32;\n+\n+void\n+test (void)\n+{\n+  __builtin_tgmath (f_cf, f_cd, f_cld, d32); /* { dg-error \"decimal floating-point argument 1 to complex-only type-generic function\" } */\n+  __builtin_tgmath (f_f, f_d, f_ld, d32); /* { dg-error \"decimal floating-point argument 1 to binary-only type-generic function\" } */\n+  __builtin_tgmath (f_cfcf, f_d32d32, cf, d32); /* { dg-error \"both complex and decimal floating-point arguments to type-generic function\" } */\n+  __builtin_tgmath (f_ff, f_d32d32, f, d32); /* { dg-error \"both binary and decimal floating-point arguments to type-generic function\" } */\n+  __builtin_tgmath (f_d32, f_d64, f_d128, cf); /* { dg-error \"complex argument 1 to decimal-only type-generic function\" } */\n+  __builtin_tgmath (f_d32, f_d64, f_d128, f); /* { dg-error \"binary argument 1 to decimal-only type-generic function\" } */\n+  __builtin_tgmath (f_cfcf, f_d32d32, d32, cf); /* { dg-error \"both complex and decimal floating-point arguments to type-generic function\" } */\n+  __builtin_tgmath (f_ff, f_d32d32, d32, f); /* { dg-error \"both binary and decimal floating-point arguments to type-generic function\" } */\n+}"}, {"sha": "256a71e68be411eded0212263deaf8e80b4e55e0", "filename": "gcc/testsuite/gcc.dg/dfp/builtin-tgmath-dfp.c", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fbuiltin-tgmath-dfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca0dc603213b2ad5ffbcf1a443a102bef96053a/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fbuiltin-tgmath-dfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fbuiltin-tgmath-dfp.c?ref=3ca0dc603213b2ad5ffbcf1a443a102bef96053a", "patch": "@@ -0,0 +1,263 @@\n+/* Test __builtin_tgmath: valid uses, decimal floating-point types.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+#define CHECK_CALL(C, E, V)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((C) != (E))\t\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      extern __typeof (C) V;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+extern float var_f;\n+extern double var_d;\n+extern long double var_ld;\n+extern _Complex float var_cf;\n+extern _Complex double var_cd;\n+extern _Complex long double var_cld;\n+extern _Decimal32 var_d32;\n+extern _Decimal64 var_d64;\n+extern _Decimal128 var_d128;\n+extern int var_i;\n+\n+/* Test decimal-only function, single argument.  */\n+\n+_Decimal32 t1d32 (_Decimal32 x) { return x + 1; }\n+_Decimal64 t1d64 (_Decimal64 x) { return x + 2; }\n+_Decimal128 t1d128 (_Decimal128 x) { return x + 3; }\n+\n+#define t1v(x) __builtin_tgmath (t1d32, t1d64, t1d128, x)\n+\n+static void\n+test_1 (void)\n+{\n+  _Decimal32 d32 = 32;\n+  _Decimal64 d64 = 64;\n+  _Decimal128 d128 = 128;\n+  int i = 256;\n+  CHECK_CALL (t1v (d32), 33, var_d32);\n+  CHECK_CALL (t1v (d64), 66, var_d64);\n+  CHECK_CALL (t1v (d128), 131, var_d128);\n+  CHECK_CALL (t1v (i), 258, var_d64);\n+}\n+\n+/* Test decimal-only function, two arguments.  */\n+\n+_Decimal32 t2d32 (_Decimal32 x, _Decimal32 y) { return 10 * x + y; }\n+_Decimal64 t2d64 (_Decimal64 x, _Decimal64 y) { return 100 * x + y;; }\n+_Decimal128 t2d128 (_Decimal128 x, _Decimal128 y) { return 1000 * x + y; }\n+\n+#define t2v(x, y) __builtin_tgmath (t2d32, t2d64, t2d128, x, y)\n+\n+static void\n+test_2 (void)\n+{\n+  _Decimal32 d32 = 1;\n+  _Decimal64 d64 = 2;\n+  _Decimal128 d128 = 3;\n+  int i = 4;\n+  CHECK_CALL (t2v (d32, d32), 11, var_d32);\n+  CHECK_CALL (t2v (d64, d64), 202, var_d64);\n+  CHECK_CALL (t2v (d32, d64), 102, var_d64);\n+  CHECK_CALL (t2v (d128, d64), 3002, var_d128);\n+  CHECK_CALL (t2v (d128, i), 3004, var_d128);\n+  CHECK_CALL (t2v (i, i), 404, var_d64);\n+  CHECK_CALL (t2v (i, d32), 401, var_d64);\n+}\n+\n+/* Test real-only function, single argument.  */\n+\n+float t3f (float x) { return x + 1; }\n+double t3d (double x) { return x + 2; }\n+long double t3l (long double x) { return x + 3; }\n+_Decimal32 t3d32 (_Decimal32 x) { return x + 4; }\n+_Decimal64 t3d64 (_Decimal64 x) { return x + 5; }\n+_Decimal128 t3d128 (_Decimal128 x) { return x + 6; }\n+\n+#define t3v(x) __builtin_tgmath (t3f, t3d, t3l, t3d32, t3d64, t3d128, x)\n+\n+static void\n+test_3 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  int i = 4;\n+  _Decimal32 d32 = 5;\n+  _Decimal64 d64 = 6;\n+  _Decimal128 d128 = 7;\n+  CHECK_CALL (t3v (f), 2, var_f);\n+  CHECK_CALL (t3v (d), 4, var_d);\n+  CHECK_CALL (t3v (ld), 6, var_ld);\n+  CHECK_CALL (t3v (i), 6, var_d);\n+  CHECK_CALL (t3v (d32), 9, var_d32);\n+  CHECK_CALL (t3v (d64), 11, var_d64);\n+  CHECK_CALL (t3v (d128), 13, var_d128);\n+}\n+\n+/* Test real-and-complex function, single argument.  */\n+\n+float t4f (float x) { return x + 1; }\n+double t4d (double x) { return x + 2; }\n+long double t4l (long double x) { return x + 3; }\n+_Complex float t4cf (_Complex float x) { return x + 4; }\n+_Complex double t4cd (_Complex double x) { return x + 5; }\n+_Complex long double t4cl (_Complex long double x) { return x + 6; }\n+_Decimal32 t4d32 (_Decimal32 x) { return x + 7; }\n+_Decimal64 t4d64 (_Decimal64 x) { return x + 8; }\n+_Decimal128 t4d128 (_Decimal128 x) { return x + 9; }\n+\n+#define t4v(x) __builtin_tgmath (t4f, t4d, t4l, t4cf, t4cd, t4cl, t4d32, t4d64, t4d128, x)\n+\n+static void\n+test_4 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  int i = 4;\n+  _Complex float cf = 5;\n+  _Complex double cd = 6;\n+  _Complex long double cld = 7;\n+  _Complex int ci = 8;\n+  _Decimal32 d32 = 9;\n+  _Decimal64 d64 = 10;\n+  _Decimal128 d128 = 11;\n+  CHECK_CALL (t4v (f), 2, var_f);\n+  CHECK_CALL (t4v (d), 4, var_d);\n+  CHECK_CALL (t4v (ld), 6, var_ld);\n+  CHECK_CALL (t4v (i), 6, var_d);\n+  CHECK_CALL (t4v (cf), 9, var_cf);\n+  CHECK_CALL (t4v (cd), 11, var_cd);\n+  CHECK_CALL (t4v (cld), 13, var_cld);\n+  CHECK_CALL (t4v (ci), 13, var_cd);\n+  CHECK_CALL (t4v (d32), 16, var_d32);\n+  CHECK_CALL (t4v (d64), 18, var_d64);\n+  CHECK_CALL (t4v (d128), 20, var_d128);\n+}\n+\n+/* Test real-and-complex function, real return type, single argument.  */\n+\n+float t5f (float x) { return x + 1; }\n+double t5d (double x) { return x + 2; }\n+long double t5l (long double x) { return x + 3; }\n+float t5cf (_Complex float x) { return __real__ x + 4; }\n+double t5cd (_Complex double x) { return __real__ x + 5; }\n+long double t5cl (_Complex long double x) { return __real__ x + 6; }\n+_Decimal32 t5d32 (_Decimal32 x) { return x + 7; }\n+_Decimal64 t5d64 (_Decimal64 x) { return x + 8; }\n+_Decimal128 t5d128 (_Decimal128 x) { return x + 9; }\n+\n+#define t5v(x) __builtin_tgmath (t5f, t5d, t5l, t5cf, t5cd, t5cl, t5d32, t5d64, t5d128, x)\n+\n+static void\n+test_5 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  int i = 4;\n+  _Complex float cf = 5;\n+  _Complex double cd = 6;\n+  _Complex long double cld = 7;\n+  _Complex int ci = 8;\n+  _Decimal32 d32 = 9;\n+  _Decimal64 d64 = 10;\n+  _Decimal128 d128 = 11;\n+  CHECK_CALL (t5v (f), 2, var_f);\n+  CHECK_CALL (t5v (d), 4, var_d);\n+  CHECK_CALL (t5v (ld), 6, var_ld);\n+  CHECK_CALL (t5v (i), 6, var_d);\n+  CHECK_CALL (t5v (cf), 9, var_f);\n+  CHECK_CALL (t5v (cd), 11, var_d);\n+  CHECK_CALL (t5v (cld), 13, var_ld);\n+  CHECK_CALL (t5v (ci), 13, var_d);\n+  CHECK_CALL (t5v (d32), 16, var_d32);\n+  CHECK_CALL (t5v (d64), 18, var_d64);\n+  CHECK_CALL (t5v (d128), 20, var_d128);\n+}\n+\n+/* Test real-and-complex function, two arguments.  */\n+\n+float t6f (float x, float y) { return x * 10 + y; }\n+double t6d (double x, double y) { return x * 100 + y; }\n+long double t6l (long double x, long double y) { return x * 1000 + y; }\n+_Complex float t6cf (_Complex float x, _Complex float y) { return x * 10000 + y; }\n+_Complex double t6cd (_Complex double x, _Complex double y) { return x * 100000 + y; }\n+_Complex long double t6cl (_Complex long double x, _Complex long double y) { return x * 1000000 + y; }\n+_Decimal32 t6d32 (_Decimal32 x, _Decimal32 y) { return x * 50 + y; }\n+_Decimal64 t6d64 (_Decimal64 x, _Decimal64 y) { return x * 500 + y; }\n+_Decimal128 t6d128 (_Decimal128 x, _Decimal128 y) { return x * 5000 + y; }\n+\n+#define t6v(x, y) __builtin_tgmath (t6f, t6d, t6l, t6cf, t6cd, t6cl, t6d32, t6d64, t6d128, x, y)\n+\n+static void\n+test_6 (void)\n+{\n+  float f = 1;\n+  double d = 2;\n+  long double ld = 3;\n+  int i = 4;\n+  _Complex float cf = 5;\n+  _Complex double cd = 6;\n+  _Complex long double cld = 7;\n+  _Complex int ci = 8;\n+  _Decimal32 d32 = 9;\n+  _Decimal64 d64 = 10;\n+  _Decimal128 d128 = 11;\n+  CHECK_CALL (t6v (f, f), 11, var_f);\n+  CHECK_CALL (t6v (d, f), 201, var_d);\n+  CHECK_CALL (t6v (f, d), 102, var_d);\n+  CHECK_CALL (t6v (f, i), 104, var_d);\n+  CHECK_CALL (t6v (ld, f), 3001, var_ld);\n+  CHECK_CALL (t6v (i, ld), 4003, var_ld);\n+  CHECK_CALL (t6v (i, i), 404, var_d);\n+  CHECK_CALL (t6v (cf, f), 50001, var_cf);\n+  CHECK_CALL (t6v (cf, cf), 50005, var_cf);\n+  CHECK_CALL (t6v (cd, cf), 600005, var_cd);\n+  CHECK_CALL (t6v (d, cld), 2000007, var_cld);\n+  CHECK_CALL (t6v (ci, ci), 800008, var_cd);\n+  CHECK_CALL (t6v (ci, f), 800001, var_cd);\n+  CHECK_CALL (t6v (d32, d32), 459, var_d32);\n+  CHECK_CALL (t6v (d64, i), 5004, var_d64);\n+  CHECK_CALL (t6v (i, d32), 2009, var_d64);\n+  CHECK_CALL (t6v (d128, d32), 55009, var_d128);\n+}\n+\n+/* Test decimal-only function rounding result to narrower type.  */\n+\n+_Decimal32 t7d64 (_Decimal64 x) { return 1 + x; }\n+_Decimal32 t7d128 (_Decimal128 x) { return 2 + x; }\n+\n+#define t7v(x) __builtin_tgmath (t7d64, t7d128, x)\n+\n+static void\n+test_7 (void)\n+{\n+  _Decimal32 d32 = 1;\n+  _Decimal64 d64 = 2;\n+  _Decimal128 d128 = 3;\n+  short s = 4;\n+  CHECK_CALL (t7v (d32), 2, var_d32);\n+  CHECK_CALL (t7v (d64), 3, var_d32);\n+  CHECK_CALL (t7v (d128), 5, var_d32);\n+  CHECK_CALL (t7v (s), 5, var_d32);\n+}\n+\n+int\n+main (void)\n+{\n+  test_1 ();\n+  test_2 ();\n+  test_3 ();\n+  test_4 ();\n+  test_5 ();\n+  test_6 ();\n+  test_7 ();\n+  exit (0);\n+}"}]}