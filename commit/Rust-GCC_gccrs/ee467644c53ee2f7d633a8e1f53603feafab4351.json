{"sha": "ee467644c53ee2f7d633a8e1f53603feafab4351", "node_id": "C_kwDOANBUbNoAKGVlNDY3NjQ0YzUzZWUyZjdkNjMzYThlMWY1MzYwM2ZlYWZhYjQzNTE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-11T09:34:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-11T11:15:34Z"}, "message": "tree-optimization/107212 - SLP reduction of reduction paths\n\nThe following fixes an issue with how we handle epilogue generation\nfor SLP reductions of reduction paths where the actual live lanes\nare not \"canonical\".  We need to make sure to identify all live\nlanes as reductions and thus have to iterate over all participating\nSLP lanes when walking the reduction SSA use-def chain.  Also the\nprevious attempt likely to mitigate such issue in\nvectorizable_live_operation is misguided and has to be removed.\n\n\tPR tree-optimization/107212\n\t* tree-vect-loop.cc (vectorizable_reduction): Make sure to\n\tset STMT_VINFO_REDUC_DEF for all live lanes in a SLP\n\treduction.\n\t(vectorizable_live_operation): Do not pun to the SLP\n\tnode representative for reduction epilogue generation.\n\n\t* gcc.dg/vect/pr107212-1.c: New testcase.\n\t* gcc.dg/vect/pr107212-2.c: Likewise.", "tree": {"sha": "c74d7d3d017dd4e1e182e5dfd43e91bb490ef131", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c74d7d3d017dd4e1e182e5dfd43e91bb490ef131"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee467644c53ee2f7d633a8e1f53603feafab4351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee467644c53ee2f7d633a8e1f53603feafab4351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee467644c53ee2f7d633a8e1f53603feafab4351", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee467644c53ee2f7d633a8e1f53603feafab4351/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd9a05594d227cde79a67dc715bd9d82e9c464e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9a05594d227cde79a67dc715bd9d82e9c464e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd9a05594d227cde79a67dc715bd9d82e9c464e9"}], "stats": {"total": 70, "additions": 63, "deletions": 7}, "files": [{"sha": "5343f9b6b23e8f55f03364a595287dee41a09276", "filename": "gcc/testsuite/gcc.dg/vect/pr107212-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee467644c53ee2f7d633a8e1f53603feafab4351/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr107212-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee467644c53ee2f7d633a8e1f53603feafab4351/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr107212-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr107212-1.c?ref=ee467644c53ee2f7d633a8e1f53603feafab4351", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  unsigned int tab[6][2] = { {69, 73}, {36, 40}, {24, 16},\n+        {16, 11}, {4, 5}, {3, 1} };\n+\n+  int sum_0 = 0;\n+  int sum_1 = 0;\n+\n+  for(int t=0; t<6; t++) {\n+      sum_0 += tab[t][0];\n+      sum_1 += tab[t][1];\n+  }\n+\n+  int x1 = (sum_0 < 100);\n+  int x2 = (sum_0 > 200);\n+\n+  if (x1 || x2 || sum_1 != 146)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "109c2b991a6e63ba44b163ab6a65774e974e7c1b", "filename": "gcc/testsuite/gcc.dg/vect/pr107212-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee467644c53ee2f7d633a8e1f53603feafab4351/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr107212-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee467644c53ee2f7d633a8e1f53603feafab4351/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr107212-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr107212-2.c?ref=ee467644c53ee2f7d633a8e1f53603feafab4351", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+int sum_1 = 0;\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  unsigned int tab[6][2] = {{150, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}};\n+  \n+  int sum_0 = 0;\n+  \n+  for (int t = 0; t < 6; t++) {\n+    sum_0 += tab[t][0];\n+    sum_1 += tab[t][0];\n+  }\n+  \n+  if (sum_0 < 100 || sum_0 > 200)\n+    __builtin_abort();\n+  return 0;\n+}"}, {"sha": "1996ecfee7aa74bda0deebf72beddca8afeae1e3", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee467644c53ee2f7d633a8e1f53603feafab4351/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee467644c53ee2f7d633a8e1f53603feafab4351/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=ee467644c53ee2f7d633a8e1f53603feafab4351", "patch": "@@ -6822,10 +6822,20 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n \t}\n       if (!REDUC_GROUP_FIRST_ELEMENT (vdef))\n \tonly_slp_reduc_chain = false;\n-      /* ???  For epilogue generation live members of the chain need\n+      /* For epilogue generation live members of the chain need\n          to point back to the PHI via their original stmt for\n-\t info_for_reduction to work.  */\n-      if (STMT_VINFO_LIVE_P (vdef))\n+\t info_for_reduction to work.  For SLP we need to look at\n+\t all lanes here - even though we only will vectorize from\n+\t the SLP node with live lane zero the other live lanes also\n+\t need to be identified as part of a reduction to be able\n+\t to skip code generation for them.  */\n+      if (slp_for_stmt_info)\n+\t{\n+\t  for (auto s : SLP_TREE_SCALAR_STMTS (slp_for_stmt_info))\n+\t    if (STMT_VINFO_LIVE_P (s))\n+\t      STMT_VINFO_REDUC_DEF (vect_orig_stmt (s)) = phi_info;\n+\t}\n+      else if (STMT_VINFO_LIVE_P (vdef))\n \tSTMT_VINFO_REDUC_DEF (def) = phi_info;\n       gimple_match_op op;\n       if (!gimple_extract_op (vdef->stmt, &op))\n@@ -9601,10 +9611,6 @@ vectorizable_live_operation (vec_info *vinfo,\n \t     all involved stmts together.  */\n \t  else if (slp_index != 0)\n \t    return true;\n-\t  else\n-\t    /* For SLP reductions the meta-info is attached to\n-\t       the representative.  */\n-\t    stmt_info = SLP_TREE_REPRESENTATIVE (slp_node);\n \t}\n       stmt_vec_info reduc_info = info_for_reduction (loop_vinfo, stmt_info);\n       gcc_assert (reduc_info->is_reduc_info);"}]}