{"sha": "b92ba6ffd9d7f12d522ca13731946f12eeebca4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkyYmE2ZmZkOWQ3ZjEyZDUyMmNhMTM3MzE5NDZmMTJlZWViY2E0Yg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2005-07-28T11:55:56Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2005-07-28T11:55:56Z"}, "message": "re PR rtl-optimization/18992 (delete_trivially_dead_insns made ineffective for two-address targets)\n\n\tPR rtl-optimization/18992\n\tBack out this patch:\n\t  2003-10-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n\t  PR optimization/12142\n\t  * cse.c (count_reg_usage): In a SET with a REG SET_DEST, count the\n\t  uses of the register in the SET_SRC.  Remove unnecessary argument.\n\n\tReplace it with this:\n\t* cse.c (count_reg_usage): In INSN, JUMP_INSN and CALL_INSN cases,\n\tif flag_non_call_exceptions is set and the insn may trap, pass\n\tpc_rtx as dest for recursion.\n\tIn SET_SRC part of SET case, if dest is already set, pass it down\n\tunchanged.\n\nFrom-SVN: r102478", "tree": {"sha": "cf8e76465811b2ce0ddc559b964583c5cff6d9ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf8e76465811b2ce0ddc559b964583c5cff6d9ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b92ba6ffd9d7f12d522ca13731946f12eeebca4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b92ba6ffd9d7f12d522ca13731946f12eeebca4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b92ba6ffd9d7f12d522ca13731946f12eeebca4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b92ba6ffd9d7f12d522ca13731946f12eeebca4b/comments", "author": null, "committer": null, "parents": [{"sha": "7da3fe7701c9856578979b6dc587f925ab6a0c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da3fe7701c9856578979b6dc587f925ab6a0c53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da3fe7701c9856578979b6dc587f925ab6a0c53"}], "stats": {"total": 80, "additions": 56, "deletions": 24}, "files": [{"sha": "df7cb00b5006b84a76e8431c17f0996575b04622", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b92ba6ffd9d7f12d522ca13731946f12eeebca4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b92ba6ffd9d7f12d522ca13731946f12eeebca4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b92ba6ffd9d7f12d522ca13731946f12eeebca4b", "patch": "@@ -1,3 +1,19 @@\n+2005-07-28  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPR rtl-optimization/18992\n+\tBack out this patch:\n+\t  2003-10-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\t  PR optimization/12142\n+\t  * cse.c (count_reg_usage): In a SET with a REG SET_DEST, count the\n+\t  uses of the register in the SET_SRC.  Remove unnecessary argument.\n+\n+\tReplace it with this:\n+\t* cse.c (count_reg_usage): In INSN, JUMP_INSN and CALL_INSN cases,\n+\tif flag_non_call_exceptions is set and the insn may trap, pass\n+\tpc_rtx as dest for recursion.\n+\tIn SET_SRC part of SET case, if dest is already set, pass it down\n+\tunchanged.\n+\n 2005-07-28  Jan Hubicka  <jh@suse.cz>\n \n \t* cfg.c (update_bb_profile_for_threading): Use RDIV."}, {"sha": "9cade945e4e16fc0a3647bb4fb68017d091a6ef4", "filename": "gcc/cse.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b92ba6ffd9d7f12d522ca13731946f12eeebca4b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b92ba6ffd9d7f12d522ca13731946f12eeebca4b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=b92ba6ffd9d7f12d522ca13731946f12eeebca4b", "patch": "@@ -618,7 +618,7 @@ static rtx cse_process_notes (rtx, rtx);\n static void invalidate_skipped_set (rtx, rtx, void *);\n static void invalidate_skipped_block (rtx);\n static rtx cse_basic_block (rtx, rtx, struct branch_path *);\n-static void count_reg_usage (rtx, int *, int);\n+static void count_reg_usage (rtx, int *, rtx, int);\n static int check_for_label_ref (rtx *, void *);\n extern void dump_class (struct table_elt*);\n static void get_cse_reg_info_1 (unsigned int regno);\n@@ -7079,10 +7079,16 @@ check_for_label_ref (rtx *rtl, void *data)\n \f\n /* Count the number of times registers are used (not set) in X.\n    COUNTS is an array in which we accumulate the count, INCR is how much\n-   we count each register usage.  */\n+   we count each register usage.\n+\n+   Don't count a usage of DEST, which is the SET_DEST of a SET which\n+   contains X in its SET_SRC.  This is because such a SET does not\n+   modify the liveness of DEST.\n+   DEST is set to pc_rtx for a trapping insn, which means that we must count\n+   uses of a SET_DEST regardless because the insn can't be deleted here.  */\n \n static void\n-count_reg_usage (rtx x, int *counts, int incr)\n+count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n {\n   enum rtx_code code;\n   rtx note;\n@@ -7095,7 +7101,8 @@ count_reg_usage (rtx x, int *counts, int incr)\n   switch (code = GET_CODE (x))\n     {\n     case REG:\n-      counts[REGNO (x)] += incr;\n+      if (x != dest)\n+\tcounts[REGNO (x)] += incr;\n       return;\n \n     case PC:\n@@ -7112,23 +7119,28 @@ count_reg_usage (rtx x, int *counts, int incr)\n       /* If we are clobbering a MEM, mark any registers inside the address\n          as being used.  */\n       if (MEM_P (XEXP (x, 0)))\n-\tcount_reg_usage (XEXP (XEXP (x, 0), 0), counts, incr);\n+\tcount_reg_usage (XEXP (XEXP (x, 0), 0), counts, NULL_RTX, incr);\n       return;\n \n     case SET:\n       /* Unless we are setting a REG, count everything in SET_DEST.  */\n       if (!REG_P (SET_DEST (x)))\n-\tcount_reg_usage (SET_DEST (x), counts, incr);\n-      count_reg_usage (SET_SRC (x), counts, incr);\n+\tcount_reg_usage (SET_DEST (x), counts, NULL_RTX, incr);\n+      count_reg_usage (SET_SRC (x), counts,\n+\t\t       dest ? dest : SET_DEST (x),\n+\t\t       incr);\n       return;\n \n     case CALL_INSN:\n-      count_reg_usage (CALL_INSN_FUNCTION_USAGE (x), counts, incr);\n-      /* Fall through.  */\n-\n     case INSN:\n     case JUMP_INSN:\n-      count_reg_usage (PATTERN (x), counts, incr);\n+    /* We expect dest to be NULL_RTX here.  If the insn may trap, mark\n+       this fact by setting DEST to pc_rtx.  */\n+      if (flag_non_call_exceptions && may_trap_p (PATTERN (x)))\n+\tdest = pc_rtx;\n+      if (code == CALL_INSN)\n+\tcount_reg_usage (CALL_INSN_FUNCTION_USAGE (x), counts, dest, incr);\n+      count_reg_usage (PATTERN (x), counts, dest, incr);\n \n       /* Things used in a REG_EQUAL note aren't dead since loop may try to\n \t use them.  */\n@@ -7143,12 +7155,12 @@ count_reg_usage (rtx x, int *counts, int incr)\n \t     Process all the arguments.  */\n \t    do\n \t      {\n-\t\tcount_reg_usage (XEXP (eqv, 0), counts, incr);\n+\t\tcount_reg_usage (XEXP (eqv, 0), counts, dest, incr);\n \t\teqv = XEXP (eqv, 1);\n \t      }\n \t    while (eqv && GET_CODE (eqv) == EXPR_LIST);\n \t  else\n-\t    count_reg_usage (eqv, counts, incr);\n+\t    count_reg_usage (eqv, counts, dest, incr);\n \t}\n       return;\n \n@@ -7158,15 +7170,19 @@ count_reg_usage (rtx x, int *counts, int incr)\n \t  /* FUNCTION_USAGE expression lists may include (CLOBBER (mem /u)),\n \t     involving registers in the address.  */\n \t  || GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\tcount_reg_usage (XEXP (x, 0), counts, incr);\n+\tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n \n-      count_reg_usage (XEXP (x, 1), counts, incr);\n+      count_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n       return;\n \n     case ASM_OPERANDS:\n+      /* If the asm is volatile, then this insn cannot be deleted,\n+\t and so the inputs *must* be live.  */\n+      if (MEM_VOLATILE_P (x))\n+\tdest = NULL_RTX;\n       /* Iterate over just the inputs, not the constraints as well.  */\n       for (i = ASM_OPERANDS_INPUT_LENGTH (x) - 1; i >= 0; i--)\n-\tcount_reg_usage (ASM_OPERANDS_INPUT (x, i), counts, incr);\n+\tcount_reg_usage (ASM_OPERANDS_INPUT (x, i), counts, dest, incr);\n       return;\n \n     case INSN_LIST:\n@@ -7180,10 +7196,10 @@ count_reg_usage (rtx x, int *counts, int incr)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tcount_reg_usage (XEXP (x, i), counts, incr);\n+\tcount_reg_usage (XEXP (x, i), counts, dest, incr);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  count_reg_usage (XVECEXP (x, i, j), counts, incr);\n+\t  count_reg_usage (XVECEXP (x, i, j), counts, dest, incr);\n     }\n }\n \f\n@@ -7270,11 +7286,11 @@ dead_libcall_p (rtx insn, int *counts)\n     new = XEXP (note, 0);\n \n   /* While changing insn, we must update the counts accordingly.  */\n-  count_reg_usage (insn, counts, -1);\n+  count_reg_usage (insn, counts, NULL_RTX, -1);\n \n   if (validate_change (insn, &SET_SRC (set), new, 0))\n     {\n-      count_reg_usage (insn, counts, 1);\n+      count_reg_usage (insn, counts, NULL_RTX, 1);\n       remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n       remove_note (insn, note);\n       return true;\n@@ -7285,14 +7301,14 @@ dead_libcall_p (rtx insn, int *counts)\n       new = force_const_mem (GET_MODE (SET_DEST (set)), new);\n       if (new && validate_change (insn, &SET_SRC (set), new, 0))\n \t{\n-\t  count_reg_usage (insn, counts, 1);\n+\t  count_reg_usage (insn, counts, NULL_RTX, 1);\n \t  remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n \t  remove_note (insn, note);\n \t  return true;\n \t}\n     }\n \n-  count_reg_usage (insn, counts, 1);\n+  count_reg_usage (insn, counts, NULL_RTX, 1);\n   return false;\n }\n \n@@ -7317,7 +7333,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n   counts = xcalloc (nreg, sizeof (int));\n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n-      count_reg_usage (insn, counts, 1);\n+      count_reg_usage (insn, counts, NULL_RTX, 1);\n \n   /* Go from the last insn to the first and delete insns that only set unused\n      registers or copy a register to itself.  As we delete an insn, remove\n@@ -7355,7 +7371,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n \n       if (! live_insn)\n \t{\n-\t  count_reg_usage (insn, counts, -1);\n+\t  count_reg_usage (insn, counts, NULL_RTX, -1);\n \t  delete_insn_and_edges (insn);\n \t  ndead++;\n \t}"}]}