{"sha": "349ae713cb98e06d7be10c6e4913a28f67278528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ5YWU3MTNjYjk4ZTA2ZDdiZTEwYzZlNDkxM2EyOGY2NzI3ODUyOA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-04-24T20:41:04Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-04-24T20:41:04Z"}, "message": "attribs.c (c_common_attribute_table): Move table and handlers to c-common.c.\n\n\t* attribs.c (c_common_attribute_table): Move table and handlers\n\tto c-common.c.\n\t(format_attribute_table, lang_attribute_table,\n\tlang_attribute_common): Remove.\n\t(init_attributes): Replace NULL pointers with pointers to the\n\tempty table.\n\t(handle_packed_attribute, handle_nocommon_attribute,\n\thandle_common_attribute, handle_noreturn_attribute,\n\thandle_noinline_attribute, handle_always_inline_attribute,\n\thandle_used_attribute, handle_unused_attribute,\n\thandle_const_attribute, handle_transparent_union_attribute,\n\thandle_constructor_attribute, handle_destructor_attribute,\n\thandle_mode_attribute, handle_section_attribute,\n\thandle_aligned_attribute, handle_weak_attribute,\n\thandle_alias_attribute, handle_visibility_attribute,\n\thandle_no_instrument_function_attribute, handle_malloc_attribute,\n\thandle_no_limit_stack_attribute, handle_pure_attribute,\n\thandle_deprecated_attribute, handle_vector_size_attribute,\n\tvector_size_helper): Move to c-common.c.\n\t* c-common.c (c_common_attribute_table,\n\thandle_packed_attribute, handle_nocommon_attribute,\n\thandle_common_attribute, handle_noreturn_attribute,\n\thandle_noinline_attribute, handle_always_inline_attribute,\n\thandle_used_attribute, handle_unused_attribute,\n\thandle_const_attribute, handle_transparent_union_attribute,\n\thandle_constructor_attribute, handle_destructor_attribute,\n\thandle_mode_attribute, handle_section_attribute,\n\thandle_aligned_attribute, handle_weak_attribute,\n\thandle_alias_attribute, handle_visibility_attribute,\n\thandle_no_instrument_function_attribute, handle_malloc_attribute,\n\thandle_no_limit_stack_attribute, handle_pure_attribute,\n\thandle_deprecated_attribute, handle_vector_size_attribute,\n\tvector_size_helper): Move from attribs.c.\n\t* c-common.h (c_common_attribute_table,\n\tc_common_format_attribute_table): New.\n\t* c-lang.c (LANG_HOOKS_COMMON_ATTRIBUTE_TABLE,\n\tLANG_HOOKS_FORMAT_ATTRIBUTE_TABLE): Redefine.\n\t* langhooks-def.h (LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE,\n\tLANG_HOOKS_COMMON_ATTRIBUTE_TABLE, LANG_HOOKS_ATTRIBUTE_TABLE): New.\n\t(LANG_HOOKS_INITIALIZER): Update.\n\t* langhooks.h (struct lang_hooks): 3 new attribute hooks.\n\t* target-def.h (TARGET_ATTRIBUTE_TABLE): Default to NULL.\n\t* target.h: Update comment.\n\t* tree.c (default_target_attribute_table): Remove.\n\t* tree.h (default_target_attribute_table, format_attribute_table,\n\tlang_attribute_table, lang_attribute_common): Remove.\nada:\n\t* misc.c (gnat_init): Don't set lang_attribute_common.\ncp:\n\t* cp-lang.c (LANG_HOOKS_COMMON_ATTRIBUTE_TABLE,\n\tLANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, LANG_HOOKS_ATTRIBUTE_TABLE):\n\tRedefine.\n\t* cp-tree.h (cp_attribute_table): Rename.\n\t* decl.c (lang_attribute_table): Remove declaration.\n\t(cxx_init_decl_processing): Don't set it.\n\t* tree.c (cp_attribute_table): Rename.\nobjc:\n\t* objc-lang.c (LANG_HOOKS_COMMON_ATTRIBUTE_TABLE,\n\tLANG_HOOKS_FORMAT_ATTRIBUTE_TABLE): Redefine.\n\nFrom-SVN: r52730", "tree": {"sha": "a282065cb3961f75aca64ff2fdc96c61cce9c686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a282065cb3961f75aca64ff2fdc96c61cce9c686"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/349ae713cb98e06d7be10c6e4913a28f67278528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/349ae713cb98e06d7be10c6e4913a28f67278528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/349ae713cb98e06d7be10c6e4913a28f67278528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/349ae713cb98e06d7be10c6e4913a28f67278528/comments", "author": null, "committer": null, "parents": [{"sha": "3f2019c6efd7324664e5e2d184c7233da3f839a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2019c6efd7324664e5e2d184c7233da3f839a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f2019c6efd7324664e5e2d184c7233da3f839a2"}], "stats": {"total": 2473, "additions": 1272, "deletions": 1201}, "files": [{"sha": "e70a847091ae264ae1a93f5a975f3c8eee7b97a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -1,3 +1,55 @@\n+2002-04-24  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* attribs.c (c_common_attribute_table): Move table and handlers\n+\tto c-common.c.\n+\t(format_attribute_table, lang_attribute_table,\n+\tlang_attribute_common): Remove.\n+\t(init_attributes): Replace NULL pointers with pointers to the\n+\tempty table.\n+\t(handle_packed_attribute, handle_nocommon_attribute,\n+\thandle_common_attribute, handle_noreturn_attribute,\n+\thandle_noinline_attribute, handle_always_inline_attribute,\n+\thandle_used_attribute, handle_unused_attribute,\n+\thandle_const_attribute, handle_transparent_union_attribute,\n+\thandle_constructor_attribute, handle_destructor_attribute,\n+\thandle_mode_attribute, handle_section_attribute,\n+\thandle_aligned_attribute, handle_weak_attribute,\n+\thandle_alias_attribute, handle_visibility_attribute,\n+\thandle_no_instrument_function_attribute, handle_malloc_attribute,\n+\thandle_no_limit_stack_attribute, handle_pure_attribute,\n+\thandle_deprecated_attribute, handle_vector_size_attribute,\n+\tvector_size_helper): Move to c-common.c.\n+\t* c-common.c (c_common_attribute_table,\n+\thandle_packed_attribute, handle_nocommon_attribute,\n+\thandle_common_attribute, handle_noreturn_attribute,\n+\thandle_noinline_attribute, handle_always_inline_attribute,\n+\thandle_used_attribute, handle_unused_attribute,\n+\thandle_const_attribute, handle_transparent_union_attribute,\n+\thandle_constructor_attribute, handle_destructor_attribute,\n+\thandle_mode_attribute, handle_section_attribute,\n+\thandle_aligned_attribute, handle_weak_attribute,\n+\thandle_alias_attribute, handle_visibility_attribute,\n+\thandle_no_instrument_function_attribute, handle_malloc_attribute,\n+\thandle_no_limit_stack_attribute, handle_pure_attribute,\n+\thandle_deprecated_attribute, handle_vector_size_attribute,\n+\tvector_size_helper): Move from attribs.c.\n+\t* c-common.h (c_common_attribute_table,\n+\tc_common_format_attribute_table): New.\n+\t* c-lang.c (LANG_HOOKS_COMMON_ATTRIBUTE_TABLE,\n+\tLANG_HOOKS_FORMAT_ATTRIBUTE_TABLE): Redefine.\n+\t* langhooks-def.h (LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE,\n+\tLANG_HOOKS_COMMON_ATTRIBUTE_TABLE, LANG_HOOKS_ATTRIBUTE_TABLE): New.\n+\t(LANG_HOOKS_INITIALIZER): Update.\n+\t* langhooks.h (struct lang_hooks): 3 new attribute hooks.\n+\t* target-def.h (TARGET_ATTRIBUTE_TABLE): Default to NULL.\n+\t* target.h: Update comment.\n+\t* tree.c (default_target_attribute_table): Remove.\n+\t* tree.h (default_target_attribute_table, format_attribute_table,\n+\tlang_attribute_table, lang_attribute_common): Remove.\n+objc:\n+\t* objc-lang.c (LANG_HOOKS_COMMON_ATTRIBUTE_TABLE,\n+\tLANG_HOOKS_FORMAT_ATTRIBUTE_TABLE): Redefine.\n+\n 2002-04-24  Jason Merrill  <jason@redhat.com>\n \n \t* dwarf2.h (enum dwarf_attribute): Add DW_AT_GNU_vector."}, {"sha": "8ec214ce1a3dc3797ebb5be07b99ab1c296ad946", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -1,3 +1,7 @@\n+2002-04-24  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* misc.c (gnat_init): Don't set lang_attribute_common.\n+\n 2002-04-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gnat_rm.texi: Use @ifnottex instead of @ifinfo."}, {"sha": "20b2b014f91abe64f19d3efb02d2783eb3ca8fb7", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -388,9 +388,6 @@ gnat_init (filename)\n   /* Show that REFERENCE_TYPEs are internal and should be Pmode.  */\n   internal_reference_types ();\n \n-  /* Show we don't use the common language attributes.  */\n-  lang_attribute_common = 0;\n-\n   set_lang_adjust_rli (gnat_adjust_rli);\n   return filename;\n }"}, {"sha": "e48db854cfee9f51ee6b0f0285f815edc1d0d447", "filename": "gcc/attribs.c", "status": "modified", "additions": 9, "deletions": 1153, "changes": 1162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -36,157 +36,36 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static void init_attributes\t\tPARAMS ((void));\n \n-/* Table of the tables of attributes (common, format, language, machine)\n+/* Table of the tables of attributes (common, language, format, machine)\n    searched.  */\n static const struct attribute_spec *attribute_tables[4];\n \n static bool attributes_initialized = false;\n \n-static tree handle_packed_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_nocommon_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_common_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_noreturn_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_noinline_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_always_inline_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t    bool *));\n-static tree handle_used_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_unused_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_const_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_transparent_union_attribute PARAMS ((tree *, tree, tree,\n-\t\t\t\t\t\t\tint, bool *));\n-static tree handle_constructor_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t  bool *));\n-static tree handle_destructor_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_mode_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_section_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_aligned_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_weak_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_alias_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_visibility_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_no_instrument_function_attribute PARAMS ((tree *, tree,\n-\t\t\t\t\t\t\t     tree, int,\n-\t\t\t\t\t\t\t     bool *));\n-static tree handle_malloc_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t     bool *));\n-static tree handle_pure_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_deprecated_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_vector_size_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t  bool *));\n-static tree vector_size_helper PARAMS ((tree, tree));\n-\n-/* Table of machine-independent attributes common to all C-like languages.  */\n-static const struct attribute_spec c_common_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"packed\",                 0, 0, false, false, false,\n-      \t\t\t      handle_packed_attribute },\n-  { \"nocommon\",               0, 0, true,  false, false,\n-\t\t\t      handle_nocommon_attribute },\n-  { \"common\",                 0, 0, true,  false, false,\n-\t\t\t      handle_common_attribute },\n-  /* FIXME: logically, noreturn attributes should be listed as\n-     \"false, true, true\" and apply to function types.  But implementing this\n-     would require all the places in the compiler that use TREE_THIS_VOLATILE\n-     on a decl to identify non-returning functions to be located and fixed\n-     to check the function type instead.  */\n-  { \"noreturn\",               0, 0, true,  false, false,\n-\t\t\t      handle_noreturn_attribute },\n-  { \"volatile\",               0, 0, true,  false, false,\n-\t\t\t      handle_noreturn_attribute },\n-  { \"noinline\",               0, 0, true,  false, false,\n-\t\t\t      handle_noinline_attribute },\n-  { \"always_inline\",          0, 0, true,  false, false,\n-\t\t\t      handle_always_inline_attribute },\n-  { \"used\",                   0, 0, true,  false, false,\n-\t\t\t      handle_used_attribute },\n-  { \"unused\",                 0, 0, false, false, false,\n-\t\t\t      handle_unused_attribute },\n-  /* The same comments as for noreturn attributes apply to const ones.  */\n-  { \"const\",                  0, 0, true,  false, false,\n-\t\t\t      handle_const_attribute },\n-  { \"transparent_union\",      0, 0, false, false, false,\n-\t\t\t      handle_transparent_union_attribute },\n-  { \"constructor\",            0, 0, true,  false, false,\n-\t\t\t      handle_constructor_attribute },\n-  { \"destructor\",             0, 0, true,  false, false,\n-\t\t\t      handle_destructor_attribute },\n-  { \"mode\",                   1, 1, false,  true, false,\n-\t\t\t      handle_mode_attribute },\n-  { \"section\",                1, 1, true,  false, false,\n-\t\t\t      handle_section_attribute },\n-  { \"aligned\",                0, 1, false, false, false,\n-\t\t\t      handle_aligned_attribute },\n-  { \"weak\",                   0, 0, true,  false, false,\n-\t\t\t      handle_weak_attribute },\n-  { \"alias\",                  1, 1, true,  false, false,\n-\t\t\t      handle_alias_attribute },\n-  { \"no_instrument_function\", 0, 0, true,  false, false,\n-\t\t\t      handle_no_instrument_function_attribute },\n-  { \"malloc\",                 0, 0, true,  false, false,\n-\t\t\t      handle_malloc_attribute },\n-  { \"no_stack_limit\",         0, 0, true,  false, false,\n-\t\t\t      handle_no_limit_stack_attribute },\n-  { \"pure\",                   0, 0, true,  false, false,\n-\t\t\t      handle_pure_attribute },\n-  { \"deprecated\",             0, 0, false, false, false,\n-\t\t\t      handle_deprecated_attribute },\n-  { \"vector_size\",\t      1, 1, false, true, false,\n-\t\t\t      handle_vector_size_attribute },\n-  { \"visibility\",\t      1, 1, true,  false, false,\n-\t\t\t      handle_visibility_attribute },\n-  { NULL,                     0, 0, false, false, false, NULL }\n-};\n-\n /* Default empty table of attributes.  */\n static const struct attribute_spec empty_attribute_table[] =\n {\n   { NULL, 0, 0, false, false, false, NULL }\n };\n \n-/* Table of machine-independent attributes for checking formats, if used.  */\n-const struct attribute_spec *format_attribute_table = empty_attribute_table;\n-\n-/* Table of machine-independent attributes for a particular language.  */\n-const struct attribute_spec *lang_attribute_table = empty_attribute_table;\n-\n-/* Flag saying whether common language attributes are to be supported.  */\n-int lang_attribute_common = 1;\n-\n /* Initialize attribute tables, and make some sanity checks\n    if --enable-checking.  */\n \n static void\n init_attributes ()\n {\n-#ifdef ENABLE_CHECKING\n   size_t i;\n-#endif\n \n-  attribute_tables[0]\n-    = lang_attribute_common ? c_common_attribute_table : empty_attribute_table;\n-  attribute_tables[1] = lang_attribute_table;\n-  attribute_tables[2] = format_attribute_table;\n+  attribute_tables[0] = lang_hooks.common_attribute_table;\n+  attribute_tables[1] = lang_hooks.attribute_table;\n+  attribute_tables[2] = lang_hooks.format_attribute_table;\n   attribute_tables[3] = targetm.attribute_table;\n \n+  /* Translate NULL pointers to pointers to the empty table.  */\n+  for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n+    if (attribute_tables[i] == NULL)\n+      attribute_tables[i] = empty_attribute_table;\n+\n #ifdef ENABLE_CHECKING\n   /* Make some sanity checks on the attribute tables.  */\n   for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n@@ -426,1029 +305,6 @@ decl_attributes (node, attributes, flags)\n   return returned_attrs;\n }\n \n-/* Handle a \"packed\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_packed_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree *type = NULL;\n-  if (DECL_P (*node))\n-    {\n-      if (TREE_CODE (*node) == TYPE_DECL)\n-\ttype = &TREE_TYPE (*node);\n-    }\n-  else\n-    type = node;\n-\n-  if (type)\n-    {\n-      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*type = build_type_copy (*type);\n-      TYPE_PACKED (*type) = 1;\n-    }\n-  else if (TREE_CODE (*node) == FIELD_DECL)\n-    DECL_PACKED (*node) = 1;\n-  /* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n-     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"nocommon\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_nocommon_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == VAR_DECL)\n-    DECL_COMMON (*node) = 0;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"common\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_common_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == VAR_DECL)\n-    DECL_COMMON (*node) = 1;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"noreturn\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_noreturn_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree type = TREE_TYPE (*node);\n-\n-  /* See FIXME comment in c_common_attribute_table.  */\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_THIS_VOLATILE (*node) = 1;\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    TREE_TYPE (*node)\n-      = build_pointer_type\n-\t(build_type_variant (TREE_TYPE (type),\n-\t\t\t     TREE_READONLY (TREE_TYPE (type)), 1));\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"noinline\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_noinline_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_UNINLINABLE (*node) = 1;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"always_inline\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_always_inline_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    {\n-      /* Do nothing else, just set the attribute.  We'll get at\n-\t it later with lookup_attribute.  */\n-    }\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"used\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_used_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (*node))\n-      = TREE_USED (*node) = 1;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"unused\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_unused_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  if (DECL_P (*node))\n-    {\n-      tree decl = *node;\n-\n-      if (TREE_CODE (decl) == PARM_DECL\n-\t  || TREE_CODE (decl) == VAR_DECL\n-\t  || TREE_CODE (decl) == FUNCTION_DECL\n-\t  || TREE_CODE (decl) == LABEL_DECL\n-\t  || TREE_CODE (decl) == TYPE_DECL)\n-\tTREE_USED (decl) = 1;\n-      else\n-\t{\n-\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  *no_add_attrs = true;\n-\t}\n-    }\n-  else\n-    {\n-      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*node = build_type_copy (*node);\n-      TREE_USED (*node) = 1;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"const\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_const_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree type = TREE_TYPE (*node);\n-\n-  /* See FIXME comment on noreturn in c_common_attribute_table.  */\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_READONLY (*node) = 1;\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    TREE_TYPE (*node)\n-      = build_pointer_type\n-\t(build_type_variant (TREE_TYPE (type), 1,\n-\t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"transparent_union\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_transparent_union_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree decl = NULL_TREE;\n-  tree *type = NULL;\n-  int is_type = 0;\n-\n-  if (DECL_P (*node))\n-    {\n-      decl = *node;\n-      type = &TREE_TYPE (decl);\n-      is_type = TREE_CODE (*node) == TYPE_DECL;\n-    }\n-  else if (TYPE_P (*node))\n-    type = node, is_type = 1;\n-\n-  if (is_type\n-      && TREE_CODE (*type) == UNION_TYPE\n-      && (decl == 0\n-\t  || (TYPE_FIELDS (*type) != 0\n-\t      && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))))\n-    {\n-      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*type = build_type_copy (*type);\n-      TYPE_TRANSPARENT_UNION (*type) = 1;\n-    }\n-  else if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n-\t   && TREE_CODE (*type) == UNION_TYPE\n-\t   && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))\n-    DECL_TRANSPARENT_UNION (decl) = 1;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"constructor\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_constructor_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-  tree type = TREE_TYPE (decl);\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && TREE_CODE (type) == FUNCTION_TYPE\n-      && decl_function_context (decl) == 0)\n-    {\n-      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-      TREE_USED (decl) = 1;\n-    }\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"destructor\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_destructor_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-  tree type = TREE_TYPE (decl);\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && TREE_CODE (type) == FUNCTION_TYPE\n-      && decl_function_context (decl) == 0)\n-    {\n-      DECL_STATIC_DESTRUCTOR (decl) = 1;\n-      TREE_USED (decl) = 1;\n-    }\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"mode\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_mode_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree type = *node;\n-\n-  *no_add_attrs = true;\n-\n-  if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n-    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-  else\n-    {\n-      int j;\n-      const char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n-      int len = strlen (p);\n-      enum machine_mode mode = VOIDmode;\n-      tree typefm;\n-\n-      if (len > 4 && p[0] == '_' && p[1] == '_'\n-\t  && p[len - 1] == '_' && p[len - 2] == '_')\n-\t{\n-\t  char *newp = (char *) alloca (len - 1);\n-\n-\t  strcpy (newp, &p[2]);\n-\t  newp[len - 4] = '\\0';\n-\t  p = newp;\n-\t}\n-\n-      /* Change this type to have a type with the specified mode.\n-\t First check for the special modes.  */\n-      if (! strcmp (p, \"byte\"))\n-\tmode = byte_mode;\n-      else if (!strcmp (p, \"word\"))\n-\tmode = word_mode;\n-      else if (! strcmp (p, \"pointer\"))\n-\tmode = ptr_mode;\n-      else\n-\tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n-\t  if (!strcmp (p, GET_MODE_NAME (j)))\n-\t    mode = (enum machine_mode) j;\n-\n-      if (mode == VOIDmode)\n-\terror (\"unknown machine mode `%s'\", p);\n-      else if (0 == (typefm = (*lang_hooks.types.type_for_mode)\n-\t\t     (mode, TREE_UNSIGNED (type))))\n-\terror (\"no data type for mode `%s'\", p);\n-      else\n-\t*node = typefm;\n-        /* No need to layout the type here.  The caller should do this.  */\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"section\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_section_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (targetm.have_named_sections)\n-    {\n-      if ((TREE_CODE (decl) == FUNCTION_DECL\n-\t   || TREE_CODE (decl) == VAR_DECL)\n-\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n-\t{\n-\t  if (TREE_CODE (decl) == VAR_DECL\n-\t      && current_function_decl != NULL_TREE\n-\t      && ! TREE_STATIC (decl))\n-\t    {\n-\t      error_with_decl (decl,\n-\t\t\t       \"section attribute cannot be specified for local variables\");\n-\t      *no_add_attrs = true;\n-\t    }\n-\n-\t  /* The decl may have already been given a section attribute\n-\t     from a previous declaration.  Ensure they match.  */\n-\t  else if (DECL_SECTION_NAME (decl) != NULL_TREE\n-\t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n-\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n-\t    {\n-\t      error_with_decl (*node,\n-\t\t\t       \"section of `%s' conflicts with previous declaration\");\n-\t      *no_add_attrs = true;\n-\t    }\n-\t  else\n-\t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n-\t}\n-      else\n-\t{\n-\t  error_with_decl (*node,\n-\t\t\t   \"section attribute not allowed for `%s'\");\n-\t  *no_add_attrs = true;\n-\t}\n-    }\n-  else\n-    {\n-      error_with_decl (*node,\n-\t\t       \"section attributes are not supported for this target\");\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"aligned\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_aligned_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree decl = NULL_TREE;\n-  tree *type = NULL;\n-  int is_type = 0;\n-  tree align_expr = (args ? TREE_VALUE (args)\n-\t\t     : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-  int i;\n-\n-  if (DECL_P (*node))\n-    {\n-      decl = *node;\n-      type = &TREE_TYPE (decl);\n-      is_type = TREE_CODE (*node) == TYPE_DECL;\n-    }\n-  else if (TYPE_P (*node))\n-    type = node, is_type = 1;\n-\n-  /* Strip any NOPs of any kind.  */\n-  while (TREE_CODE (align_expr) == NOP_EXPR\n-\t || TREE_CODE (align_expr) == CONVERT_EXPR\n-\t || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n-    align_expr = TREE_OPERAND (align_expr, 0);\n-\n-  if (TREE_CODE (align_expr) != INTEGER_CST)\n-    {\n-      error (\"requested alignment is not a constant\");\n-      *no_add_attrs = true;\n-    }\n-  else if ((i = tree_log2 (align_expr)) == -1)\n-    {\n-      error (\"requested alignment is not a power of 2\");\n-      *no_add_attrs = true;\n-    }\n-  else if (i > HOST_BITS_PER_INT - 2)\n-    {\n-      error (\"requested alignment is too large\");\n-      *no_add_attrs = true;\n-    }\n-  else if (is_type)\n-    {\n-      /* If we have a TYPE_DECL, then copy the type, so that we\n-\t don't accidentally modify a builtin type.  See pushdecl.  */\n-      if (decl && TREE_TYPE (decl) != error_mark_node\n-\t  && DECL_ORIGINAL_TYPE (decl) == NULL_TREE)\n-\t{\n-\t  tree tt = TREE_TYPE (decl);\n-\t  *type = build_type_copy (*type);\n-\t  DECL_ORIGINAL_TYPE (decl) = tt;\n-\t  TYPE_NAME (*type) = decl;\n-\t  TREE_USED (*type) = TREE_USED (decl);\n-\t  TREE_TYPE (decl) = *type;\n-\t}\n-      else if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*type = build_type_copy (*type);\n-\n-      TYPE_ALIGN (*type) = (1 << i) * BITS_PER_UNIT;\n-      TYPE_USER_ALIGN (*type) = 1;\n-    }\n-  else if (TREE_CODE (decl) != VAR_DECL\n-\t   && TREE_CODE (decl) != FIELD_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"alignment may not be specified for `%s'\");\n-      *no_add_attrs = true;\n-    }\n-  else\n-    {\n-      DECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;\n-      DECL_USER_ALIGN (decl) = 1;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"weak\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_weak_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs ATTRIBUTE_UNUSED;\n-{\n-  declare_weak (*node);\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle an \"alias\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_alias_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n-      || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' defined both normally and as an alias\");\n-      *no_add_attrs = true;\n-    }\n-  else if (decl_function_context (decl) == 0)\n-    {\n-      tree id;\n-\n-      id = TREE_VALUE (args);\n-      if (TREE_CODE (id) != STRING_CST)\n-\t{\n-\t  error (\"alias arg not a string\");\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n-      id = get_identifier (TREE_STRING_POINTER (id));\n-      /* This counts as a use of the object pointed to.  */\n-      TREE_USED (id) = 1;\n-\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tDECL_INITIAL (decl) = error_mark_node;\n-      else\n-\tDECL_EXTERNAL (decl) = 0;\n-    }\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle an \"visibility\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_visibility_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    {\n-      tree id;\n-\n-      id = TREE_VALUE (args);\n-      if (TREE_CODE (id) != STRING_CST)\n-\t{\n-\t  error (\"visibility arg not a string\");\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n-      if (strcmp (TREE_STRING_POINTER (id), \"hidden\")\n-\t  && strcmp (TREE_STRING_POINTER (id), \"protected\")\n-\t  && strcmp (TREE_STRING_POINTER (id), \"internal\"))\n-\t{\n-\t  error (\"visibility arg must be one of \\\"hidden\\\", \\\"protected\\\" or \\\"internal\\\"\");\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"no_instrument_function\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' attribute applies only to functions\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else if (DECL_INITIAL (decl))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"can't set `%s' attribute after definition\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"malloc\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_malloc_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_IS_MALLOC (*node) = 1;\n-  /* ??? TODO: Support types.  */\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"no_limit_stack\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_no_limit_stack_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' attribute applies only to functions\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else if (DECL_INITIAL (decl))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"can't set `%s' attribute after definition\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    DECL_NO_LIMIT_STACK (decl) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"pure\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_pure_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_IS_PURE (*node) = 1;\n-  /* ??? TODO: Support types.  */\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"deprecated\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-   \n-static tree\n-handle_deprecated_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree type = NULL_TREE;\n-  int warn = 0;\n-  const char *what = NULL;\n-  \n-  if (DECL_P (*node))\n-    {\n-      tree decl = *node;\n-      type = TREE_TYPE (decl);\n-      \n-      if (TREE_CODE (decl) == TYPE_DECL\n-\t  || TREE_CODE (decl) == PARM_DECL\n-\t  || TREE_CODE (decl) == VAR_DECL\n-\t  || TREE_CODE (decl) == FUNCTION_DECL\n-\t  || TREE_CODE (decl) == FIELD_DECL)\n-\tTREE_DEPRECATED (decl) = 1;\n-      else\n-\twarn = 1;\n-    }\n-  else if (TYPE_P (*node))\n-    {\n-      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*node = build_type_copy (*node);\n-      TREE_DEPRECATED (*node) = 1;\n-      type = *node;\n-    }\n-  else\n-    warn = 1;\n-  \n-  if (warn)\n-    {\n-      *no_add_attrs = true;\n-      if (type && TYPE_NAME (type))\n-\t{\n-\t  if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\t    what = IDENTIFIER_POINTER (TYPE_NAME (*node));\n-\t  else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t\t   && DECL_NAME (TYPE_NAME (type)))\n-\t    what = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-\t}\n-      if (what)\n-\twarning (\"`%s' attribute ignored for `%s'\",\n-\t\t  IDENTIFIER_POINTER (name), what);\n-      else\n-\twarning (\"`%s' attribute ignored\", \n-\t\t      IDENTIFIER_POINTER (name));\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Keep a list of vector type nodes we created in handle_vector_size_attribute,\n-   to prevent us from duplicating type nodes unnecessarily.\n-   The normal mechanism to prevent duplicates is to use type_hash_canon, but\n-   since we want to distinguish types that are essentially identical (except\n-   for their debug representation), we use a local list here.  */\n-static tree vector_type_node_list = 0;\n-\n-/* Handle a \"vector_size\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  unsigned HOST_WIDE_INT vecsize, nunits;\n-  enum machine_mode mode, orig_mode, new_mode;\n-  tree type = *node, new_type = NULL_TREE;\n-  tree type_list_node;\n-\n-  *no_add_attrs = true;\n-\n-  if (! host_integerp (TREE_VALUE (args), 1))\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      return NULL_TREE;\n-    }\n-\n-  /* Get the vector size (in bytes).  */\n-  vecsize = tree_low_cst (TREE_VALUE (args), 1);\n-\n-  /* We need to provide for vector pointers, vector arrays, and\n-     functions returning vectors.  For example:\n-\n-       __attribute__((vector_size(16))) short *foo;\n-\n-     In this case, the mode is SI, but the type being modified is\n-     HI, so we need to look further.  */\n-\n-  while (POINTER_TYPE_P (type)\n-\t || TREE_CODE (type) == FUNCTION_TYPE\n-\t || TREE_CODE (type) == ARRAY_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  /* Get the mode of the type being modified.  */\n-  orig_mode = TYPE_MODE (type);\n-\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      || (GET_MODE_CLASS (orig_mode) != MODE_FLOAT\n-\t  && GET_MODE_CLASS (orig_mode) != MODE_INT)\n-      || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n-    {\n-      error (\"invalid vector type for attribute `%s'\",\n-\t     IDENTIFIER_POINTER (name));\n-      return NULL_TREE;\n-    }\n-\n-  /* Calculate how many units fit in the vector.  */\n-  nunits = vecsize / tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n-\n-  /* Find a suitably sized vector.  */\n-  new_mode = VOIDmode;\n-  for (mode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_mode) == MODE_INT\n-\t\t\t\t\t? MODE_VECTOR_INT\n-\t\t\t\t\t: MODE_VECTOR_FLOAT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    if (vecsize == GET_MODE_SIZE (mode)\n-\t&& nunits == (unsigned HOST_WIDE_INT) GET_MODE_NUNITS (mode))\n-      {\n-\tnew_mode = mode;\n-\tbreak;\n-      }\n-\n-    if (new_mode == VOIDmode)\n-    {\n-      error (\"no vector mode with the size and type specified could be found\");\n-      return NULL_TREE;\n-    }\n-\n-  for (type_list_node = vector_type_node_list; type_list_node;\n-       type_list_node = TREE_CHAIN (type_list_node))\n-    {\n-      tree other_type = TREE_VALUE (type_list_node);\n-      tree record = TYPE_DEBUG_REPRESENTATION_TYPE (other_type);\n-      tree fields = TYPE_FIELDS (record);\n-      tree field_type = TREE_TYPE (fields);\n-      tree array_type = TREE_TYPE (field_type);\n-      if (TREE_CODE (fields) != FIELD_DECL\n-\t  || TREE_CODE (field_type) != ARRAY_TYPE)\n-\tabort ();\n-\n-      if (TYPE_MODE (other_type) == mode && type == array_type)\n-\t{\n-\t  new_type = other_type;\n-\t  break;\n-\t}\n-    }\n-\n-  if (new_type == NULL_TREE)\n-    {\n-      tree index, array, rt, list_node;\n-\n-      new_type = (*lang_hooks.types.type_for_mode) (new_mode,\n-\t\t\t\t\t\t    TREE_UNSIGNED (type));\n-\n-      if (!new_type)\n-\t{\n-\t  error (\"no vector mode with the size and type specified could be found\");\n-\t  return NULL_TREE;\n-\t}\n-\n-      new_type = build_type_copy (new_type);\n-\n-      /* Set the debug information here, because this is the only\n-\t place where we know the underlying type for a vector made\n-\t with vector_size.  For debugging purposes we pretend a vector\n-\t is an array within a structure.  */\n-      index = build_int_2 (TYPE_VECTOR_SUBPARTS (new_type) - 1, 0);\n-      array = build_array_type (type, build_index_type (index));\n-      rt = make_node (RECORD_TYPE);\n-\n-      TYPE_FIELDS (rt) = build_decl (FIELD_DECL, get_identifier (\"f\"), array);\n-      DECL_CONTEXT (TYPE_FIELDS (rt)) = rt;\n-      layout_type (rt);\n-      TYPE_DEBUG_REPRESENTATION_TYPE (new_type) = rt;\n-\n-      list_node = build_tree_list (NULL, new_type);\n-      TREE_CHAIN (list_node) = vector_type_node_list;\n-      vector_type_node_list = list_node;\n-    }\n-\n-  /* Build back pointers if needed.  */\n-  *node = vector_size_helper (*node, new_type);\n-\n-  return NULL_TREE;\n-}\n-\n-/* HACK.  GROSS.  This is absolutely disgusting.  I wish there was a\n-   better way.\n-\n-   If we requested a pointer to a vector, build up the pointers that\n-   we stripped off while looking for the inner type.  Similarly for\n-   return values from functions.\n-\n-   The argument \"type\" is the top of the chain, and \"bottom\" is the\n-   new type which we will point to.  */\n-\n-static tree\n-vector_size_helper (type, bottom)\n-     tree type, bottom;\n-{\n-  tree inner, outer;\n-\n-  if (POINTER_TYPE_P (type))\n-    {\n-      inner = vector_size_helper (TREE_TYPE (type), bottom);\n-      outer = build_pointer_type (inner);\n-    }\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      inner = vector_size_helper (TREE_TYPE (type), bottom);\n-      outer = build_array_type (inner, TYPE_VALUES (type));\n-    }\n-  else if (TREE_CODE (type) == FUNCTION_TYPE)\n-    {\n-      inner = vector_size_helper (TREE_TYPE (type), bottom);\n-      outer = build_function_type (inner, TYPE_VALUES (type));\n-    }\n-  else\n-    return bottom;\n-  \n-  TREE_READONLY (outer) = TREE_READONLY (type);\n-  TREE_THIS_VOLATILE (outer) = TREE_THIS_VOLATILE (type);\n-\n-  return outer;\n-}\n-\n /* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two\n    lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).\n "}, {"sha": "03966a87c25259e1e58506408386c5e1e989c128", "filename": "gcc/c-common.c", "status": "modified", "additions": 1151, "deletions": 17, "changes": 1168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -271,6 +271,133 @@ static int if_stack_space = 0;\n /* Stack pointer.  */\n static int if_stack_pointer = 0;\n \n+static tree handle_packed_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_nocommon_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_common_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_noreturn_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_noinline_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_always_inline_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t    bool *));\n+static tree handle_used_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_unused_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_const_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_transparent_union_attribute PARAMS ((tree *, tree, tree,\n+\t\t\t\t\t\t\tint, bool *));\n+static tree handle_constructor_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t  bool *));\n+static tree handle_destructor_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_mode_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_section_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_aligned_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_weak_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_alias_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_visibility_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_no_instrument_function_attribute PARAMS ((tree *, tree,\n+\t\t\t\t\t\t\t     tree, int,\n+\t\t\t\t\t\t\t     bool *));\n+static tree handle_malloc_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t     bool *));\n+static tree handle_pure_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_deprecated_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_vector_size_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t  bool *));\n+static tree vector_size_helper PARAMS ((tree, tree));\n+\n+/* Table of machine-independent attributes common to all C-like languages.  */\n+const struct attribute_spec c_common_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"packed\",                 0, 0, false, false, false,\n+      \t\t\t      handle_packed_attribute },\n+  { \"nocommon\",               0, 0, true,  false, false,\n+\t\t\t      handle_nocommon_attribute },\n+  { \"common\",                 0, 0, true,  false, false,\n+\t\t\t      handle_common_attribute },\n+  /* FIXME: logically, noreturn attributes should be listed as\n+     \"false, true, true\" and apply to function types.  But implementing this\n+     would require all the places in the compiler that use TREE_THIS_VOLATILE\n+     on a decl to identify non-returning functions to be located and fixed\n+     to check the function type instead.  */\n+  { \"noreturn\",               0, 0, true,  false, false,\n+\t\t\t      handle_noreturn_attribute },\n+  { \"volatile\",               0, 0, true,  false, false,\n+\t\t\t      handle_noreturn_attribute },\n+  { \"noinline\",               0, 0, true,  false, false,\n+\t\t\t      handle_noinline_attribute },\n+  { \"always_inline\",          0, 0, true,  false, false,\n+\t\t\t      handle_always_inline_attribute },\n+  { \"used\",                   0, 0, true,  false, false,\n+\t\t\t      handle_used_attribute },\n+  { \"unused\",                 0, 0, false, false, false,\n+\t\t\t      handle_unused_attribute },\n+  /* The same comments as for noreturn attributes apply to const ones.  */\n+  { \"const\",                  0, 0, true,  false, false,\n+\t\t\t      handle_const_attribute },\n+  { \"transparent_union\",      0, 0, false, false, false,\n+\t\t\t      handle_transparent_union_attribute },\n+  { \"constructor\",            0, 0, true,  false, false,\n+\t\t\t      handle_constructor_attribute },\n+  { \"destructor\",             0, 0, true,  false, false,\n+\t\t\t      handle_destructor_attribute },\n+  { \"mode\",                   1, 1, false,  true, false,\n+\t\t\t      handle_mode_attribute },\n+  { \"section\",                1, 1, true,  false, false,\n+\t\t\t      handle_section_attribute },\n+  { \"aligned\",                0, 1, false, false, false,\n+\t\t\t      handle_aligned_attribute },\n+  { \"weak\",                   0, 0, true,  false, false,\n+\t\t\t      handle_weak_attribute },\n+  { \"alias\",                  1, 1, true,  false, false,\n+\t\t\t      handle_alias_attribute },\n+  { \"no_instrument_function\", 0, 0, true,  false, false,\n+\t\t\t      handle_no_instrument_function_attribute },\n+  { \"malloc\",                 0, 0, true,  false, false,\n+\t\t\t      handle_malloc_attribute },\n+  { \"no_stack_limit\",         0, 0, true,  false, false,\n+\t\t\t      handle_no_limit_stack_attribute },\n+  { \"pure\",                   0, 0, true,  false, false,\n+\t\t\t      handle_pure_attribute },\n+  { \"deprecated\",             0, 0, false, false, false,\n+\t\t\t      handle_deprecated_attribute },\n+  { \"vector_size\",\t      1, 1, false, true, false,\n+\t\t\t      handle_vector_size_attribute },\n+  { \"visibility\",\t      1, 1, true,  false, false,\n+\t\t\t      handle_visibility_attribute },\n+  { NULL,                     0, 0, false, false, false, NULL }\n+};\n+\n+/* Give the specifications for the format attributes, used by C and all\n+   descendents.  */\n+\n+const struct attribute_spec c_common_format_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"format\",                 3, 3, false, true,  true,\n+\t\t\t      handle_format_attribute },\n+  { \"format_arg\",             1, 1, false, true,  true,\n+\t\t\t      handle_format_arg_attribute },\n+  { NULL,                     0, 0, false, false, false, NULL }\n+};\n+\n /* Record the start of an if-then, and record the start of it\n    for ambiguous else detection.\n \n@@ -2495,19 +2622,6 @@ c_alignof_expr (expr)\n   return fold (build1 (NOP_EXPR, c_size_type_node, t));\n }\n \f\n-/* Give the specifications for the format attributes, used by C and all\n-   descendents.  */\n-\n-static const struct attribute_spec c_format_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"format\",                 3, 3, false, true,  true,\n-\t\t\t      handle_format_attribute },\n-  { \"format_arg\",             1, 1, false, true,  true,\n-\t\t\t      handle_format_arg_attribute },\n-  { NULL,                     0, 0, false, false, false, NULL }\n-};\n-\n /* Build tree nodes and builtin functions common to both C and C++ language\n    frontends.  */\n \n@@ -2548,10 +2662,6 @@ c_common_nodes_and_builtins ()\n   tree va_list_ref_type_node;\n   tree va_list_arg_type_node;\n \n-  /* We must initialize this before any builtin functions (which might have\n-     attributes) are declared.  (c_common_init is too late.)  */\n-  format_attribute_table = c_format_attribute_table;\n-\n   /* Define `int' and `char' first so that dbx will output them first.  */\n   record_builtin_type (RID_INT, NULL, integer_type_node);\n   record_builtin_type (RID_CHAR, \"char\", char_type_node);\n@@ -4275,3 +4385,1027 @@ shadow_warning (msgid, name, decl)\n \t\t\t      \"shadowed declaration is here\");\n }\n \n+/* Attribute handlers common to C front ends.  */\n+\n+/* Handle a \"packed\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_packed_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree *type = NULL;\n+  if (DECL_P (*node))\n+    {\n+      if (TREE_CODE (*node) == TYPE_DECL)\n+\ttype = &TREE_TYPE (*node);\n+    }\n+  else\n+    type = node;\n+\n+  if (type)\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+      TYPE_PACKED (*type) = 1;\n+    }\n+  else if (TREE_CODE (*node) == FIELD_DECL)\n+    DECL_PACKED (*node) = 1;\n+  /* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n+     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"nocommon\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_nocommon_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == VAR_DECL)\n+    DECL_COMMON (*node) = 0;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"common\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_common_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == VAR_DECL)\n+    DECL_COMMON (*node) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"noreturn\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noreturn_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_THIS_VOLATILE (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type\n+\t(build_type_variant (TREE_TYPE (type),\n+\t\t\t     TREE_READONLY (TREE_TYPE (type)), 1));\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"noinline\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noinline_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_UNINLINABLE (*node) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"always_inline\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_always_inline_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    {\n+      /* Do nothing else, just set the attribute.  We'll get at\n+\t it later with lookup_attribute.  */\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"used\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_used_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (*node))\n+      = TREE_USED (*node) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"unused\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_unused_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  if (DECL_P (*node))\n+    {\n+      tree decl = *node;\n+\n+      if (TREE_CODE (decl) == PARM_DECL\n+\t  || TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || TREE_CODE (decl) == LABEL_DECL\n+\t  || TREE_CODE (decl) == TYPE_DECL)\n+\tTREE_USED (decl) = 1;\n+      else\n+\t{\n+\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  else\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*node = build_type_copy (*node);\n+      TREE_USED (*node) = 1;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"const\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_const_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment on noreturn in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_READONLY (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type\n+\t(build_type_variant (TREE_TYPE (type), 1,\n+\t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"transparent_union\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_transparent_union_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree decl = NULL_TREE;\n+  tree *type = NULL;\n+  int is_type = 0;\n+\n+  if (DECL_P (*node))\n+    {\n+      decl = *node;\n+      type = &TREE_TYPE (decl);\n+      is_type = TREE_CODE (*node) == TYPE_DECL;\n+    }\n+  else if (TYPE_P (*node))\n+    type = node, is_type = 1;\n+\n+  if (is_type\n+      && TREE_CODE (*type) == UNION_TYPE\n+      && (decl == 0\n+\t  || (TYPE_FIELDS (*type) != 0\n+\t      && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))))\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+      TYPE_TRANSPARENT_UNION (*type) = 1;\n+    }\n+  else if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n+\t   && TREE_CODE (*type) == UNION_TYPE\n+\t   && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))\n+    DECL_TRANSPARENT_UNION (decl) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"constructor\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_constructor_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TREE_CODE (type) == FUNCTION_TYPE\n+      && decl_function_context (decl) == 0)\n+    {\n+      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+      TREE_USED (decl) = 1;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"destructor\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_destructor_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TREE_CODE (type) == FUNCTION_TYPE\n+      && decl_function_context (decl) == 0)\n+    {\n+      DECL_STATIC_DESTRUCTOR (decl) = 1;\n+      TREE_USED (decl) = 1;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"mode\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_mode_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = *node;\n+\n+  *no_add_attrs = true;\n+\n+  if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n+    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+  else\n+    {\n+      int j;\n+      const char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n+      int len = strlen (p);\n+      enum machine_mode mode = VOIDmode;\n+      tree typefm;\n+\n+      if (len > 4 && p[0] == '_' && p[1] == '_'\n+\t  && p[len - 1] == '_' && p[len - 2] == '_')\n+\t{\n+\t  char *newp = (char *) alloca (len - 1);\n+\n+\t  strcpy (newp, &p[2]);\n+\t  newp[len - 4] = '\\0';\n+\t  p = newp;\n+\t}\n+\n+      /* Change this type to have a type with the specified mode.\n+\t First check for the special modes.  */\n+      if (! strcmp (p, \"byte\"))\n+\tmode = byte_mode;\n+      else if (!strcmp (p, \"word\"))\n+\tmode = word_mode;\n+      else if (! strcmp (p, \"pointer\"))\n+\tmode = ptr_mode;\n+      else\n+\tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n+\t  if (!strcmp (p, GET_MODE_NAME (j)))\n+\t    mode = (enum machine_mode) j;\n+\n+      if (mode == VOIDmode)\n+\terror (\"unknown machine mode `%s'\", p);\n+      else if (0 == (typefm = (*lang_hooks.types.type_for_mode)\n+\t\t     (mode, TREE_UNSIGNED (type))))\n+\terror (\"no data type for mode `%s'\", p);\n+      else\n+\t*node = typefm;\n+        /* No need to layout the type here.  The caller should do this.  */\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"section\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_section_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (targetm.have_named_sections)\n+    {\n+      if ((TREE_CODE (decl) == FUNCTION_DECL\n+\t   || TREE_CODE (decl) == VAR_DECL)\n+\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+\t{\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && current_function_decl != NULL_TREE\n+\t      && ! TREE_STATIC (decl))\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"section attribute cannot be specified for local variables\");\n+\t      *no_add_attrs = true;\n+\t    }\n+\n+\t  /* The decl may have already been given a section attribute\n+\t     from a previous declaration.  Ensure they match.  */\n+\t  else if (DECL_SECTION_NAME (decl) != NULL_TREE\n+\t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n+\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n+\t    {\n+\t      error_with_decl (*node,\n+\t\t\t       \"section of `%s' conflicts with previous declaration\");\n+\t      *no_add_attrs = true;\n+\t    }\n+\t  else\n+\t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n+\t}\n+      else\n+\t{\n+\t  error_with_decl (*node,\n+\t\t\t   \"section attribute not allowed for `%s'\");\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  else\n+    {\n+      error_with_decl (*node,\n+\t\t       \"section attributes are not supported for this target\");\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"aligned\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_aligned_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree decl = NULL_TREE;\n+  tree *type = NULL;\n+  int is_type = 0;\n+  tree align_expr = (args ? TREE_VALUE (args)\n+\t\t     : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+  int i;\n+\n+  if (DECL_P (*node))\n+    {\n+      decl = *node;\n+      type = &TREE_TYPE (decl);\n+      is_type = TREE_CODE (*node) == TYPE_DECL;\n+    }\n+  else if (TYPE_P (*node))\n+    type = node, is_type = 1;\n+\n+  /* Strip any NOPs of any kind.  */\n+  while (TREE_CODE (align_expr) == NOP_EXPR\n+\t || TREE_CODE (align_expr) == CONVERT_EXPR\n+\t || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n+    align_expr = TREE_OPERAND (align_expr, 0);\n+\n+  if (TREE_CODE (align_expr) != INTEGER_CST)\n+    {\n+      error (\"requested alignment is not a constant\");\n+      *no_add_attrs = true;\n+    }\n+  else if ((i = tree_log2 (align_expr)) == -1)\n+    {\n+      error (\"requested alignment is not a power of 2\");\n+      *no_add_attrs = true;\n+    }\n+  else if (i > HOST_BITS_PER_INT - 2)\n+    {\n+      error (\"requested alignment is too large\");\n+      *no_add_attrs = true;\n+    }\n+  else if (is_type)\n+    {\n+      /* If we have a TYPE_DECL, then copy the type, so that we\n+\t don't accidentally modify a builtin type.  See pushdecl.  */\n+      if (decl && TREE_TYPE (decl) != error_mark_node\n+\t  && DECL_ORIGINAL_TYPE (decl) == NULL_TREE)\n+\t{\n+\t  tree tt = TREE_TYPE (decl);\n+\t  *type = build_type_copy (*type);\n+\t  DECL_ORIGINAL_TYPE (decl) = tt;\n+\t  TYPE_NAME (*type) = decl;\n+\t  TREE_USED (*type) = TREE_USED (decl);\n+\t  TREE_TYPE (decl) = *type;\n+\t}\n+      else if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+\n+      TYPE_ALIGN (*type) = (1 << i) * BITS_PER_UNIT;\n+      TYPE_USER_ALIGN (*type) = 1;\n+    }\n+  else if (TREE_CODE (decl) != VAR_DECL\n+\t   && TREE_CODE (decl) != FIELD_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"alignment may not be specified for `%s'\");\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      DECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;\n+      DECL_USER_ALIGN (decl) = 1;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"weak\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_weak_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs ATTRIBUTE_UNUSED;\n+{\n+  declare_weak (*node);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"alias\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_alias_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n+      || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' defined both normally and as an alias\");\n+      *no_add_attrs = true;\n+    }\n+  else if (decl_function_context (decl) == 0)\n+    {\n+      tree id;\n+\n+      id = TREE_VALUE (args);\n+      if (TREE_CODE (id) != STRING_CST)\n+\t{\n+\t  error (\"alias arg not a string\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+      id = get_identifier (TREE_STRING_POINTER (id));\n+      /* This counts as a use of the object pointed to.  */\n+      TREE_USED (id) = 1;\n+\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tDECL_INITIAL (decl) = error_mark_node;\n+      else\n+\tDECL_EXTERNAL (decl) = 0;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"visibility\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_visibility_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      tree id;\n+\n+      id = TREE_VALUE (args);\n+      if (TREE_CODE (id) != STRING_CST)\n+\t{\n+\t  error (\"visibility arg not a string\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+      if (strcmp (TREE_STRING_POINTER (id), \"hidden\")\n+\t  && strcmp (TREE_STRING_POINTER (id), \"protected\")\n+\t  && strcmp (TREE_STRING_POINTER (id), \"internal\"))\n+\t{\n+\t  error (\"visibility arg must be one of \\\"hidden\\\", \\\"protected\\\" or \\\"internal\\\"\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_instrument_function\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"malloc\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_malloc_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_IS_MALLOC (*node) = 1;\n+  /* ??? TODO: Support types.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_limit_stack\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_no_limit_stack_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    DECL_NO_LIMIT_STACK (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"pure\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_pure_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_IS_PURE (*node) = 1;\n+  /* ??? TODO: Support types.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"deprecated\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+   \n+static tree\n+handle_deprecated_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree type = NULL_TREE;\n+  int warn = 0;\n+  const char *what = NULL;\n+  \n+  if (DECL_P (*node))\n+    {\n+      tree decl = *node;\n+      type = TREE_TYPE (decl);\n+      \n+      if (TREE_CODE (decl) == TYPE_DECL\n+\t  || TREE_CODE (decl) == PARM_DECL\n+\t  || TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || TREE_CODE (decl) == FIELD_DECL)\n+\tTREE_DEPRECATED (decl) = 1;\n+      else\n+\twarn = 1;\n+    }\n+  else if (TYPE_P (*node))\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*node = build_type_copy (*node);\n+      TREE_DEPRECATED (*node) = 1;\n+      type = *node;\n+    }\n+  else\n+    warn = 1;\n+  \n+  if (warn)\n+    {\n+      *no_add_attrs = true;\n+      if (type && TYPE_NAME (type))\n+\t{\n+\t  if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n+\t    what = IDENTIFIER_POINTER (TYPE_NAME (*node));\n+\t  else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t\t   && DECL_NAME (TYPE_NAME (type)))\n+\t    what = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+\t}\n+      if (what)\n+\twarning (\"`%s' attribute ignored for `%s'\",\n+\t\t  IDENTIFIER_POINTER (name), what);\n+      else\n+\twarning (\"`%s' attribute ignored\", \n+\t\t      IDENTIFIER_POINTER (name));\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Keep a list of vector type nodes we created in handle_vector_size_attribute,\n+   to prevent us from duplicating type nodes unnecessarily.\n+   The normal mechanism to prevent duplicates is to use type_hash_canon, but\n+   since we want to distinguish types that are essentially identical (except\n+   for their debug representation), we use a local list here.  */\n+static tree vector_type_node_list = 0;\n+\n+/* Handle a \"vector_size\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  unsigned HOST_WIDE_INT vecsize, nunits;\n+  enum machine_mode mode, orig_mode, new_mode;\n+  tree type = *node, new_type = NULL_TREE;\n+  tree type_list_node;\n+\n+  *no_add_attrs = true;\n+\n+  if (! host_integerp (TREE_VALUE (args), 1))\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      return NULL_TREE;\n+    }\n+\n+  /* Get the vector size (in bytes).  */\n+  vecsize = tree_low_cst (TREE_VALUE (args), 1);\n+\n+  /* We need to provide for vector pointers, vector arrays, and\n+     functions returning vectors.  For example:\n+\n+       __attribute__((vector_size(16))) short *foo;\n+\n+     In this case, the mode is SI, but the type being modified is\n+     HI, so we need to look further.  */\n+\n+  while (POINTER_TYPE_P (type)\n+\t || TREE_CODE (type) == FUNCTION_TYPE\n+\t || TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  /* Get the mode of the type being modified.  */\n+  orig_mode = TYPE_MODE (type);\n+\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      || (GET_MODE_CLASS (orig_mode) != MODE_FLOAT\n+\t  && GET_MODE_CLASS (orig_mode) != MODE_INT)\n+      || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n+    {\n+      error (\"invalid vector type for attribute `%s'\",\n+\t     IDENTIFIER_POINTER (name));\n+      return NULL_TREE;\n+    }\n+\n+  /* Calculate how many units fit in the vector.  */\n+  nunits = vecsize / tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n+\n+  /* Find a suitably sized vector.  */\n+  new_mode = VOIDmode;\n+  for (mode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_mode) == MODE_INT\n+\t\t\t\t\t? MODE_VECTOR_INT\n+\t\t\t\t\t: MODE_VECTOR_FLOAT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (vecsize == GET_MODE_SIZE (mode)\n+\t&& nunits == (unsigned HOST_WIDE_INT) GET_MODE_NUNITS (mode))\n+      {\n+\tnew_mode = mode;\n+\tbreak;\n+      }\n+\n+    if (new_mode == VOIDmode)\n+    {\n+      error (\"no vector mode with the size and type specified could be found\");\n+      return NULL_TREE;\n+    }\n+\n+  for (type_list_node = vector_type_node_list; type_list_node;\n+       type_list_node = TREE_CHAIN (type_list_node))\n+    {\n+      tree other_type = TREE_VALUE (type_list_node);\n+      tree record = TYPE_DEBUG_REPRESENTATION_TYPE (other_type);\n+      tree fields = TYPE_FIELDS (record);\n+      tree field_type = TREE_TYPE (fields);\n+      tree array_type = TREE_TYPE (field_type);\n+      if (TREE_CODE (fields) != FIELD_DECL\n+\t  || TREE_CODE (field_type) != ARRAY_TYPE)\n+\tabort ();\n+\n+      if (TYPE_MODE (other_type) == mode && type == array_type)\n+\t{\n+\t  new_type = other_type;\n+\t  break;\n+\t}\n+    }\n+\n+  if (new_type == NULL_TREE)\n+    {\n+      tree index, array, rt, list_node;\n+\n+      new_type = (*lang_hooks.types.type_for_mode) (new_mode,\n+\t\t\t\t\t\t    TREE_UNSIGNED (type));\n+\n+      if (!new_type)\n+\t{\n+\t  error (\"no vector mode with the size and type specified could be found\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      new_type = build_type_copy (new_type);\n+\n+      /* Set the debug information here, because this is the only\n+\t place where we know the underlying type for a vector made\n+\t with vector_size.  For debugging purposes we pretend a vector\n+\t is an array within a structure.  */\n+      index = build_int_2 (TYPE_VECTOR_SUBPARTS (new_type) - 1, 0);\n+      array = build_array_type (type, build_index_type (index));\n+      rt = make_node (RECORD_TYPE);\n+\n+      TYPE_FIELDS (rt) = build_decl (FIELD_DECL, get_identifier (\"f\"), array);\n+      DECL_CONTEXT (TYPE_FIELDS (rt)) = rt;\n+      layout_type (rt);\n+      TYPE_DEBUG_REPRESENTATION_TYPE (new_type) = rt;\n+\n+      list_node = build_tree_list (NULL, new_type);\n+      TREE_CHAIN (list_node) = vector_type_node_list;\n+      vector_type_node_list = list_node;\n+    }\n+\n+  /* Build back pointers if needed.  */\n+  *node = vector_size_helper (*node, new_type);\n+\n+  return NULL_TREE;\n+}\n+\n+/* HACK.  GROSS.  This is absolutely disgusting.  I wish there was a\n+   better way.\n+\n+   If we requested a pointer to a vector, build up the pointers that\n+   we stripped off while looking for the inner type.  Similarly for\n+   return values from functions.\n+\n+   The argument \"type\" is the top of the chain, and \"bottom\" is the\n+   new type which we will point to.  */\n+\n+static tree\n+vector_size_helper (type, bottom)\n+     tree type, bottom;\n+{\n+  tree inner, outer;\n+\n+  if (POINTER_TYPE_P (type))\n+    {\n+      inner = vector_size_helper (TREE_TYPE (type), bottom);\n+      outer = build_pointer_type (inner);\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      inner = vector_size_helper (TREE_TYPE (type), bottom);\n+      outer = build_array_type (inner, TYPE_VALUES (type));\n+    }\n+  else if (TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      inner = vector_size_helper (TREE_TYPE (type), bottom);\n+      outer = build_function_type (inner, TYPE_VALUES (type));\n+    }\n+  else\n+    return bottom;\n+  \n+  TREE_READONLY (outer) = TREE_READONLY (type);\n+  TREE_THIS_VOLATILE (outer) = TREE_THIS_VOLATILE (type);\n+\n+  return outer;\n+}"}, {"sha": "bce32e349a8d0fa5f0237a8a183c924955cb9748", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -484,6 +484,10 @@ extern int warn_long_long;\n    what operator was specified for it.  */\n #define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n \n+/* Attribute table common to the C front ends.  */\n+extern const struct attribute_spec c_common_attribute_table[];\n+extern const struct attribute_spec c_common_format_attribute_table[];\n+\n /* Pointer to function to lazily generate the VAR_DECL for __FUNCTION__ etc.\n    ID is the identifier to use, NAME is the string.\n    TYPE_DEP indicates whether it depends on type of the function or not"}, {"sha": "f8f5b127c83695021895e7ad07763a0c335034d0", "filename": "gcc/c-lang.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -83,6 +83,12 @@ static void c_post_options PARAMS ((void));\n #undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL c_dup_lang_specific_decl\n \n+/* Attribute hooks.  */\n+#undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table\n+#undef LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE c_common_format_attribute_table\n+\n #undef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n #define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n   c_cannot_inline_tree_fn"}, {"sha": "39b60eb80e4fec2c0ad8e6753a78116cb4afa524", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -1,3 +1,13 @@\n+2002-04-24  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cp-lang.c (LANG_HOOKS_COMMON_ATTRIBUTE_TABLE,\n+\tLANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, LANG_HOOKS_ATTRIBUTE_TABLE):\n+\tRedefine.\n+\t* cp-tree.h (cp_attribute_table): Rename.\n+\t* decl.c (lang_attribute_table): Remove declaration.\n+\t(cxx_init_decl_processing): Don't set it.\n+\t* tree.c (cp_attribute_table): Rename.\n+\n 2002-04-24  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/6331"}, {"sha": "3a8417d8d2815d79a7e24fb6602d01d6986e0514", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -100,6 +100,14 @@ static bool cxx_warn_unused_global_decl PARAMS ((tree));\n #undef LANG_HOOKS_FUNCTION_MARK\n #define LANG_HOOKS_FUNCTION_MARK cxx_mark_function_context\n \n+/* Attribute hooks.  */\n+#undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table\n+#undef LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE c_common_format_attribute_table\n+#undef LANG_HOOKS_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_ATTRIBUTE_TABLE cxx_attribute_table\n+\n #undef LANG_HOOKS_TREE_INLINING_WALK_SUBTREES\n #define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES \\\n   cp_walk_subtrees"}, {"sha": "a692c98a2679f3c656c163150aebbcabd499a836", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -4287,7 +4287,7 @@ extern void debug_binfo\t\t\t\tPARAMS ((tree));\n extern tree build_dummy_object\t\t\tPARAMS ((tree));\n extern tree maybe_dummy_object\t\t\tPARAMS ((tree, tree *));\n extern int is_dummy_object\t\t\tPARAMS ((tree));\n-extern const struct attribute_spec cp_attribute_table[];\n+extern const struct attribute_spec cxx_attribute_table[];\n extern tree make_ptrmem_cst                     PARAMS ((tree, tree));\n extern tree cp_build_qualified_type_real        PARAMS ((tree, int, tsubst_flags_t));\n #define cp_build_qualified_type(TYPE, QUALS) \\"}, {"sha": "a260e11acc7b451f5193196e2a1428025fc9d96b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -49,8 +49,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-pragma.h\"\n #include \"diagnostic.h\"\n \n-extern const struct attribute_spec *lang_attribute_table;\n-\n #ifndef BOOL_TYPE_SIZE\n /* `bool' has size and alignment `1', on all platforms.  */\n #define BOOL_TYPE_SIZE CHAR_TYPE_SIZE\n@@ -6531,8 +6529,6 @@ cxx_init_decl_processing ()\n   std_node = current_namespace;\n   pop_namespace ();\n \n-  lang_attribute_table = cp_attribute_table;\n-\n   c_common_nodes_and_builtins ();\n \n   java_byte_type_node = record_builtin_java_type (\"__java_byte\", 8);"}, {"sha": "ff3e633302bc6ebb219a756c4e006259875c5dd4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -1895,7 +1895,7 @@ pod_type_p (t)\n }\n \n /* Table of valid C++ attributes.  */\n-const struct attribute_spec cp_attribute_table[] =\n+const struct attribute_spec cxx_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   { \"java_interface\", 0, 0, false, false, false, handle_java_interface_attribute },"}, {"sha": "341a69abcfa59b90ffde26195319fdbdf88cd354", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -116,6 +116,11 @@ tree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n #define LANG_HOOKS_FUNCTION_LEAVE_NESTED lhd_do_nothing_f\n #define LANG_HOOKS_FUNCTION_MARK\tlhd_do_nothing_f\n \n+/* Attribute hooks.  */\n+#define LANG_HOOKS_ATTRIBUTE_TABLE\t\tNULL\n+#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\tNULL\n+#define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\tNULL\n+\n /* Tree inlining hooks.  */\n #define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES lhd_tree_inlining_walk_subtrees\n #define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n@@ -246,6 +251,9 @@ int lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n   LANG_HOOKS_DECL_PRINTABLE_NAME, \\\n   LANG_HOOKS_PRINT_ERROR_FUNCTION, \\\n   LANG_HOOKS_SET_YYDEBUG, \\\n+  LANG_HOOKS_ATTRIBUTE_TABLE, \\\n+  LANG_HOOKS_COMMON_ATTRIBUTE_TABLE, \\\n+  LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_FUNCTION_INITIALIZER, \\\n   LANG_HOOKS_TREE_INLINING_INITIALIZER, \\\n   LANG_HOOKS_TREE_DUMP_INITIALIZER, \\"}, {"sha": "8c0b8ef96711b0f0905fe315f26a02c41ec20256", "filename": "gcc/langhooks.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -332,6 +332,15 @@ struct lang_hooks\n      warning that the front end does not use such a parser.  */\n   void (*set_yydebug) PARAMS ((int));\n \n+  /* Pointers to machine-independent attribute tables, for front ends\n+     using attribs.c.  If one is NULL, it is ignored.  Respectively, a\n+     table of attributes specific to the language, a table of\n+     attributes common to two or more languages (to allow easy\n+     sharing), and a table of attributes for checking formats.  */\n+  const struct attribute_spec *attribute_table;\n+  const struct attribute_spec *common_attribute_table;\n+  const struct attribute_spec *format_attribute_table;\n+\n   /* Function-related language hooks.  */\n   struct lang_hooks_for_functions function;\n "}, {"sha": "6719e52b365387890ed015247551cf9173a23988", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -80,6 +80,12 @@ static void objc_post_options                   PARAMS ((void));\n #undef LANG_HOOKS_FUNCTION_MARK\n #define LANG_HOOKS_FUNCTION_MARK c_mark_function_context\n \n+/* Attribute hooks.  */\n+#undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table\n+#undef LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE c_common_format_attribute_table\n+\n /* Inlining hooks same as the C front end.  */\n #undef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n #define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\"}, {"sha": "41ed37f2bc2ce71994a872e789f439242519fc24", "filename": "gcc/target-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -159,7 +159,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n /* All in tree.c.  */\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes\n #define TARGET_MERGE_TYPE_ATTRIBUTES merge_type_attributes\n-#define TARGET_ATTRIBUTE_TABLE default_target_attribute_table\n+#define TARGET_ATTRIBUTE_TABLE NULL\n #define TARGET_COMP_TYPE_ATTRIBUTES default_comp_type_attributes\n #define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES default_set_default_type_attributes\n #define TARGET_INSERT_ATTRIBUTES default_insert_attributes"}, {"sha": "201bb2cba305754a1936513fe123433ca30fe5bd", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -144,7 +144,8 @@ struct gcc_target\n   /* Given two types, merge their attributes and return the result.  */\n   tree (* merge_type_attributes) PARAMS ((tree, tree));\n \n-  /* Table of machine attributes and functions to handle them.  */\n+  /* Table of machine attributes and functions to handle them.\n+     Ignored if NULL.  */\n   const struct attribute_spec *attribute_table;\n \n   /* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,"}, {"sha": "450dd19cc044a84deba604e21b4ead0b40b0515b", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -2570,12 +2570,6 @@ default_insert_attributes (decl, attr_ptr)\n {\n }\n \n-/* Default value of targetm.attribute_table that is empty.  */\n-const struct attribute_spec default_target_attribute_table[] =\n-{\n-  { NULL, 0, 0, false, false, false, NULL }\n-};\n-\n /* Default value of targetm.function_attribute_inlinable_p that always\n    returns false.  */\n bool"}, {"sha": "3e51f7dbb3f8bbf71aef11d085d1deacab62ff63", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/349ae713cb98e06d7be10c6e4913a28f67278528/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=349ae713cb98e06d7be10c6e4913a28f67278528", "patch": "@@ -2221,8 +2221,6 @@ struct attribute_spec\n \t\t\t\t int flags, bool *no_add_attrs));\n };\n \n-extern const struct attribute_spec default_target_attribute_table[];\n-\n /* Flags that may be passed in the third argument of decl_attributes, and\n    to handler functions for attributes.  */\n enum attribute_flags\n@@ -2926,18 +2924,6 @@ extern int setjmp_call_p\t\tPARAMS ((tree));\n    a decl attribute to the declaration rather than to its type).  */\n extern tree decl_attributes\t\tPARAMS ((tree *, tree, int));\n \n-/* The following function must be provided by front ends\n-   using attribs.c.  */\n-\n-/* Table of machine-independent attributes for checking formats, if used.  */\n-extern const struct attribute_spec *format_attribute_table;\n-\n-/* Table of machine-independent attributes for a particular language.  */\n-extern const struct attribute_spec *lang_attribute_table;\n-\n-/* Flag saying whether common language attributes are to be supported.  */\n-extern int lang_attribute_common;\n-\n /* In integrate.c */\n extern void save_for_inline\t\tPARAMS ((tree));\n extern void set_decl_abstract_flags\tPARAMS ((tree, int));"}]}