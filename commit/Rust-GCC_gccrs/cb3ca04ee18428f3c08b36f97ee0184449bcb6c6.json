{"sha": "cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IzY2EwNGVlMTg0MjhmM2MwOGIzNmY5N2VlMDE4NDQ0OWJjYjZjNg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.columbia.edu", "date": "2000-01-05T19:26:23Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-01-05T19:26:23Z"}, "message": "c-decl.c (finish_enum): Simplify code to determine minimum and maximum values of the enum...\n\n2000-01-05 11:25 -0800  Zack Weinberg  <zack@rabi.columbia.edu>\n\n\t* c-decl.c (finish_enum): Simplify code to determine minimum and\n\tmaximum values of the enum, and calculate the type.  Remove check\n\tfor FUNCTION_DECLs in the values list, which cannot happen.  Replace\n\tthe DECL_INITIAL of each enumeration constant with a copy converted\n\tto the enumeration type.  When updating variant types, don't bother\n\tupdating the type itself.\n\n\t* c-typeck.c (build_binary_op): Simplify conditional expressions\n\twhen weeding out spurious signed-unsigned warnings.  Add new\n\tspurious warning category: if the unsigned quantity is an enum\n\tand its maximum value fits in signed_type(result_type).  Update\n\tcommentary.\n\t(build_conditional_expr): Warn here if one alternative is signed\n\tand the other is unsigned.\n\nFrom-SVN: r31244", "tree": {"sha": "2f5f1a4333cfc525d0e30c2fc974ac8bf2621783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f5f1a4333cfc525d0e30c2fc974ac8bf2621783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/comments", "author": null, "committer": null, "parents": [{"sha": "28b487d7fe96ff2475bd8de4f86d9bc3da040e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28b487d7fe96ff2475bd8de4f86d9bc3da040e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28b487d7fe96ff2475bd8de4f86d9bc3da040e85"}], "stats": {"total": 233, "additions": 151, "deletions": 82}, "files": [{"sha": "4f8b02fcd2009b6db3986299b42a369b39757de1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "patch": "@@ -1,3 +1,20 @@\n+2000-01-05 11:25 -0800  Zack Weinberg  <zack@rabi.columbia.edu>\n+\n+\t* c-decl.c (finish_enum): Simplify code to determine minimum and\n+\tmaximum values of the enum, and calculate the type.  Remove check\n+\tfor FUNCTION_DECLs in the values list, which cannot happen.  Replace\n+\tthe DECL_INITIAL of each enumeration constant with a copy converted\n+\tto the enumeration type.  When updating variant types, don't bother\n+\tupdating the type itself.\n+\n+\t* c-typeck.c (build_binary_op): Simplify conditional expressions\n+\twhen weeding out spurious signed-unsigned warnings.  Add new\n+\tspurious warning category: if the unsigned quantity is an enum\n+\tand its maximum value fits in signed_type(result_type).  Update\n+\tcommentary.\n+\t(build_conditional_expr): Warn here if one alternative is signed\n+\tand the other is unsigned.\n+\n 2000-01-05  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/fr30/fr30.h: Remove extraneous comments."}, {"sha": "850ac6d7ca48d598f4d358385b075ae2a5a89d55", "filename": "gcc/c-decl.c", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "patch": "@@ -5664,8 +5664,8 @@ finish_enum (enumtype, values, attributes)\n {\n   register tree pair, tem;\n   tree minnode = 0, maxnode = 0;\n-  int lowprec, highprec, precision;\n-  int toplevel = global_binding_level == current_binding_level;\n+  int precision, unsign;\n+  int toplevel = (global_binding_level == current_binding_level);\n \n   if (in_parm_level_p ())\n     warning (\"enum defined inside parms\");\n@@ -5677,74 +5677,71 @@ finish_enum (enumtype, values, attributes)\n   if (values == error_mark_node)\n     minnode = maxnode = integer_zero_node;\n   else\n-    for (pair = values; pair; pair = TREE_CHAIN (pair))\n-      {\n-\ttree value = TREE_VALUE (pair);\n-\tif (pair == values)\n-\t  minnode = maxnode = TREE_VALUE (pair);\n-\telse\n-\t  {\n-\t    if (tree_int_cst_lt (maxnode, value))\n-\t      maxnode = value;\n-\t    if (tree_int_cst_lt (value, minnode))\n-\t      minnode = value;\n-\t  }\n-      }\n-\n-  TYPE_MIN_VALUE (enumtype) = minnode;\n-  TYPE_MAX_VALUE (enumtype) = maxnode;\n-\n-  /* An enum can have some negative values; then it is signed.  */\n-  TREE_UNSIGNED (enumtype) = tree_int_cst_sgn (minnode) >= 0;\n-\n-  /* Determine the precision this type needs.  */\n-\n-  lowprec = min_precision (minnode, TREE_UNSIGNED (enumtype));\n-  highprec = min_precision (maxnode, TREE_UNSIGNED (enumtype));\n-  precision = MAX (lowprec, highprec);\n-\n-  if (TYPE_PACKED (enumtype) || precision > TYPE_PRECISION (integer_type_node))\n     {\n-      tree narrowest = type_for_size (precision, 1);\n-      if (narrowest == 0)\n+      minnode = maxnode = TREE_VALUE (values);\n+      for (pair = TREE_CHAIN (values); pair; pair = TREE_CHAIN (pair))\n \t{\n-\t  warning (\"enumeration values exceed range of largest integer\");\n-\t  narrowest = long_long_integer_type_node;\n+\t  tree value = TREE_VALUE (pair);\n+\t  if (tree_int_cst_lt (maxnode, value))\n+\t    maxnode = value;\n+\t  if (tree_int_cst_lt (value, minnode))\n+\t    minnode = value;\n \t}\n+    }\n \n-      TYPE_PRECISION (enumtype) = TYPE_PRECISION (narrowest);\n+  /* Construct the final type of this enumeration.  It is the same\n+     as one of the integral types - the narrowest one that fits, except\n+     that normally we only go as narrow as int - and signed iff any of\n+     the values are negative.  */\n+  unsign = (tree_int_cst_sgn (minnode) >= 0);\n+  precision = MAX (min_precision (minnode, unsign),\n+\t\t   min_precision (maxnode, unsign));\n+  if (!TYPE_PACKED (enumtype))\n+    precision = MAX (precision, TYPE_PRECISION (integer_type_node));\n+  if (type_for_size (precision, unsign) == 0)\n+    {\n+      warning (\"enumeration values exceed range of largest integer\");\n+      precision = TYPE_PRECISION (long_long_integer_type_node);\n     }\n-  else\n-    TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n \n+  TYPE_MIN_VALUE (enumtype) = minnode;\n+  TYPE_MAX_VALUE (enumtype) = maxnode;\n+  TYPE_PRECISION (enumtype) = precision;\n+  TREE_UNSIGNED (enumtype) = unsign;\n   TYPE_SIZE (enumtype) = 0;\n   layout_type (enumtype);\n \n   if (values != error_mark_node)\n     {\n-      /* Change the type of the enumerators to be the enum type.\n-\t Formerly this was done only for enums that fit in an int,\n-\t but the comment said it was done only for enums wider than int.\n-\t It seems necessary to do this for wide enums,\n-\t and best not to change what's done for ordinary narrower ones.  */\n+      /* Change the type of the enumerators to be the enum type.  We\n+\t need to do this irrespective of the size of the enum, for\n+\t proper type checking.  Replace the DECL_INITIALs of the\n+\t enumerators, and the value slots of the list, with copies\n+\t that have the enum type; they cannot be modified in place\n+\t because they may be shared (e.g.  integer_zero_node) Finally,\n+\t change the purpose slots to point to the names of the decls.  */\n       for (pair = values; pair; pair = TREE_CHAIN (pair))\n \t{\n-\t  TREE_TYPE (TREE_PURPOSE (pair)) = enumtype;\n-\t  DECL_SIZE (TREE_PURPOSE (pair)) = TYPE_SIZE (enumtype);\n-\t  if (TREE_CODE (TREE_PURPOSE (pair)) != FUNCTION_DECL)\n-\t    DECL_ALIGN (TREE_PURPOSE (pair)) = TYPE_ALIGN (enumtype);\n-\t}\n+\t  tree enu = TREE_PURPOSE (pair);\n \n-      /* Replace the decl nodes in VALUES with their names.  */\n-      for (pair = values; pair; pair = TREE_CHAIN (pair))\n-\tTREE_PURPOSE (pair) = DECL_NAME (TREE_PURPOSE (pair));\n+\t  TREE_TYPE (enu) = enumtype;\n+\t  DECL_SIZE (enu) = TYPE_SIZE (enumtype);\n+\t  DECL_ALIGN (enu) = TYPE_ALIGN (enumtype);\n+\t  DECL_MODE (enu) = TYPE_MODE (enumtype);\n+\t  DECL_INITIAL (enu) = convert (enumtype, DECL_INITIAL (enu));\n+\n+\t  TREE_PURPOSE (pair) = DECL_NAME (enu);\n+\t  TREE_VALUE (pair) = DECL_INITIAL (enu);\n+\t}\n \n       TYPE_VALUES (enumtype) = values;\n     }\n \n   /* Fix up all variant types of this enum type.  */\n   for (tem = TYPE_MAIN_VARIANT (enumtype); tem; tem = TYPE_NEXT_VARIANT (tem))\n     {\n+      if (tem == enumtype)\n+\tcontinue;\n       TYPE_VALUES (tem) = TYPE_VALUES (enumtype);\n       TYPE_MIN_VALUE (tem) = TYPE_MIN_VALUE (enumtype);\n       TYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);"}, {"sha": "0529d2a5b1845b60041a2dae0e497d450b1b0b3b", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 63, "deletions": 21, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "patch": "@@ -2390,8 +2390,6 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      tree primop0 = get_narrower (op0, &unsignedp0);\n \t      tree primop1 = get_narrower (op1, &unsignedp1);\n \n-\t      /* Avoid spurious warnings for comparison with enumerators.  */\n- \n \t      xop0 = orig_op0;\n \t      xop1 = orig_op1;\n \t      STRIP_TYPE_NOPS (xop0);\n@@ -2407,28 +2405,41 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\t all the values of the unsigned type.  */\n \t      if (! TREE_UNSIGNED (result_type))\n \t\t/* OK */;\n-              /* Do not warn if both operands are unsigned.  */\n+              /* Do not warn if both operands are the same signedness.  */\n               else if (op0_signed == op1_signed)\n                 /* OK */;\n-\t      /* Do not warn if the signed quantity is an unsuffixed\n-\t\t integer literal (or some static constant expression\n-\t\t involving such literals) and it is non-negative.  */\n-\t      else if ((op0_signed && TREE_CODE (xop0) == INTEGER_CST\n-\t\t\t&& tree_int_cst_sgn (xop0) >= 0)\n-\t\t       || (op1_signed && TREE_CODE (xop1) == INTEGER_CST\n-\t\t\t   && tree_int_cst_sgn (xop1) >= 0))\n-\t\t/* OK */;\n-\t      /* Do not warn if the comparison is an equality operation,\n-                 the unsigned quantity is an integral constant and it does\n-                 not use the most significant bit of result_type.  */\n-\t      else if ((resultcode == EQ_EXPR || resultcode == NE_EXPR)\n-\t\t       && ((op0_signed && TREE_CODE (xop1) == INTEGER_CST\n-\t\t\t    && int_fits_type_p (xop1, signed_type (result_type)))\n-\t\t\t   || (op1_signed && TREE_CODE (xop0) == INTEGER_CST\n-\t\t\t       && int_fits_type_p (xop0, signed_type (result_type)))))\n-\t\t/* OK */;\n \t      else\n-\t\twarning (\"comparison between signed and unsigned\");\n+\t\t{\n+\t\t  tree sop, uop;\n+\t\t  if (op0_signed)\n+\t\t    sop = xop0, uop = xop1;\n+\t\t  else\n+\t\t    sop = xop1, uop = xop0;\n+\n+\t\t  /* Do not warn if the signed quantity is an unsuffixed\n+\t\t     integer literal (or some static constant expression\n+\t\t     involving such literals) and it is non-negative.  */\n+\t\t  if (TREE_CODE (sop) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (sop) >= 0)\n+\t\t    /* OK */;\n+\t\t  /* Do not warn if the comparison is an equality operation,\n+\t\t     the unsigned quantity is an integral constant, and it\n+\t\t     would fit in the result if the result were signed.  */\n+\t\t  else if (TREE_CODE (uop) == INTEGER_CST\n+\t\t\t   && (resultcode == EQ_EXPR || resultcode == NE_EXPR)\n+\t\t\t   && int_fits_type_p (uop, signed_type (result_type)))\n+\t\t    /* OK */;\n+\t\t  /* Do not warn if the unsigned quantity is an enumeration\n+\t\t     constant and its maximum value would fit in the result\n+\t\t     if the result were signed.  */\n+\t\t  else if (TREE_CODE (uop) == INTEGER_CST\n+\t\t\t   && TREE_CODE (TREE_TYPE (uop)) == ENUMERAL_TYPE\n+\t\t\t   && int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE(uop)),\n+\t\t\t\t\t       signed_type (result_type)))\n+\t\t    /* OK */;\n+\t\t  else\n+\t\t    warning (\"comparison between signed and unsigned\");\n+\t\t}\n \n \t      /* Warn if two unsigned values are being compared in a size\n \t\t larger than their original size, and one (and only one) is the\n@@ -3362,6 +3373,37 @@ build_conditional_expr (ifexp, op1, op2)\n            && (code2 == INTEGER_TYPE || code2 == REAL_TYPE))\n     {\n       result_type = common_type (type1, type2);\n+\n+      /* If -Wsign-compare, warn here if type1 and type2 have\n+\t different signedness.  We'll promote the signed to unsigned\n+\t and later code won't know it used to be different.\n+\t Do this check on the original types, so that explicit casts\n+\t will be considered, but default promotions won't.  */\n+      if ((warn_sign_compare < 0 ? extra_warnings : warn_sign_compare)\n+\t  && !skip_evaluation)\n+\t{\n+\t  int unsigned_op1 = TREE_UNSIGNED (TREE_TYPE (orig_op1));\n+\t  int unsigned_op2 = TREE_UNSIGNED (TREE_TYPE (orig_op2));\n+\n+\t  if (unsigned_op1 ^ unsigned_op2)\n+\t    {\n+\t      /* Do not warn if the result type is signed, since the\n+\t\t signed type will only be chosen if it can represent\n+\t\t all the values of the unsigned type.  */\n+\t      if (! TREE_UNSIGNED (result_type))\n+\t\t/* OK */;\n+\t      /* Do not warn if the signed quantity is an unsuffixed\n+\t\t integer literal (or some static constant expression\n+\t\t involving such literals) and it is non-negative.  */\n+\t      else if ((unsigned_op2 && TREE_CODE (op1) == INTEGER_CST\n+\t\t\t&& tree_int_cst_sgn (op1) >= 0)\n+\t\t       || (unsigned_op1 && TREE_CODE (op2) == INTEGER_CST\n+\t\t\t   && tree_int_cst_sgn (op2) >= 0))\n+\t\t/* OK */;\n+\t      else\n+\t\twarning (\"signed and unsigned type in conditional expression\");\n+\t    }\n+\t}\n     }\n   else if (code1 == VOID_TYPE || code2 == VOID_TYPE)\n     {"}, {"sha": "44c4df840ae0645a630991b6039c8f3c97c70a13", "filename": "gcc/testsuite/gcc.dg/compare1.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare1.c?ref=cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "patch": "@@ -4,23 +4,36 @@\n /* { dg-do compile } */\n /* { dg-options \"-Wsign-compare\" } */\n \n-int target_flags = 1;\n+int tf = 1;\n \n-enum machine_mode \n+/* This enumeration has an explicit negative value and is therefore signed.  */\n+enum mm1 \n {\n-  VOIDmode , PQImode , QImode , PHImode , HImode ,\n-  PSImode , SImode , PDImode , DImode , TImode , OImode , QFmode ,\n-  HFmode , TQFmode , SFmode , DFmode , XFmode , TFmode , QCmode ,\n-  HCmode , SCmode , DCmode , XCmode , TCmode , CQImode , CHImode ,\n-  CSImode , CDImode , CTImode , COImode , BLKmode , CCmode , CCXmode,\n-  CC_NOOVmode, CCX_NOOVmode, CCFPmode, CCFPEmode , MAX_MACHINE_MODE \n+  VOID, SI, DI, MAX = -1\n };\n \n-#define Pmode ( target_flags ? DImode : SImode )\n+/* This enumeration fits entirely in a signed int, but is unsigned anyway.  */\n+enum mm2\n+{\n+  VOID2, SI2, DI2, MAX2\n+};\n+\n+int f(enum mm1 x)\n+{\n+  return x == (tf?DI:SI); /* { dg-bogus \"signed and unsigned\" \"case 1\" } */\n+}\n \n-int main()\n+int g(enum mm1 x)\n {\n-  enum machine_mode mode = DImode;\n+  return x == (tf?DI:-1); /* { dg-bogus \"signed and unsigned\" \"case 2\" } */\n+}\n \n-  return (mode == Pmode); /* { dg-bogus \"warning:\" \"comparison between signed and unsigned\" } */\n+int h(enum mm2 x)\n+{\n+  return x == (tf?DI2:SI2); /* { dg-bogus \"signed and unsigned\" \"case 3\" } */\n+}\n+\n+int i(enum mm2 x)\n+{\n+  return x == (tf?DI2:-1); /* { dg-warning \"signed and unsigned\" \"case 4\" } */\n }"}]}