{"sha": "67f3791f7d133214b112bd831ff2876822c665d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmMzc5MWY3ZDEzMzIxNGIxMTJiZDgzMWZmMjg3NjgyMmM2NjVkMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-23T19:44:23Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-23T19:44:23Z"}, "message": "Move thunks out of cgraph_node\n\nthis patch moves thunk_info out of cgraph_node into a symbol summary.\nI also moved it to separate hearder file since cgraph.h became really too\nfat.  I plan to contiue with similar breakup in order to cleanup interfaces\nand reduce WPA memory footprint (symbol table now consumes more memory than\ntrees)\n\ngcc/ChangeLog:\n\n2020-10-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* Makefile.in: Add symtab-thunks.o\n\t(GTFILES): Add symtab-thunks.h and symtab-thunks.cc; remove cgraphunit.c\n\t* cgraph.c: Include symtab-thunks.h.\n\t(cgraph_node::create_thunk): Update\n\t(symbol_table::create_edge): Update\n\t(cgraph_node::dump): Update\n\t(cgraph_node::call_for_symbol_thunks_and_aliases): Update\n\t(set_nothrow_flag_1): Update\n\t(set_malloc_flag_1): Update\n\t(set_const_flag_1): Update\n\t(collect_callers_of_node_1): Update\n\t(clone_of_p): Update\n\t(cgraph_node::verify_node): Update\n\t(cgraph_node::function_symbol): Update\n\t(cgraph_c_finalize): Call thunk_info::release.\n\t(cgraph_node::has_thunk_p): Update\n\t(cgraph_node::former_thunk_p): Move here from cgraph.h; reimplement.\n\t* cgraph.h (struct cgraph_thunk_info): Rename to symtab-thunks.h.\n\t(cgraph_node): Remove thunk field; add thunk bitfield.\n\t(cgraph_node::expand_thunk): Move to symtab-thunks.h\n\t(symtab_thunks_cc_finalize): Declare.\n\t(cgraph_node::has_gimple_body_p): Update.\n\t(cgraph_node::former_thunk_p): Update.\n\t* cgraphclones.c: Include symtab-thunks.h.\n\t(duplicate_thunk_for_node): Update.\n\t(cgraph_edge::redirect_callee_duplicating_thunks): Update.\n\t(cgraph_node::expand_all_artificial_thunks): Update.\n\t(cgraph_node::create_edge_including_clones): Update.\n\t* cgraphunit.c: Include symtab-thunks.h.\n\t(vtable_entry_type): Move to symtab-thunks.c.\n\t(cgraph_node::analyze): Update.\n\t(analyze_functions): Update.\n\t(mark_functions_to_output): Update.\n\t(thunk_adjust): Move to symtab-thunks.c\n\t(cgraph_node::expand_thunk): Move to symtab-thunks.c\n\t(cgraph_node::assemble_thunks_and_aliases): Update.\n\t(output_in_order): Update.\n\t(cgraphunit_c_finalize): Do not clear vtable_entry_type.\n\t(cgraph_node::create_wrapper): Update.\n\t* gengtype.c (open_base_files): Add symtab-thunks.h\n\t* ipa-comdats.c (propagate_comdat_group): UPdate.\n\t(ipa_comdats): Update.\n\t* ipa-cp.c (determine_versionability): UPdate.\n\t(gather_caller_stats): Update.\n\t(count_callers): Update\n\t(set_single_call_flag): Update\n\t(initialize_node_lattices): Update\n\t(call_passes_through_thunk_p): Update\n\t(call_passes_through_thunk): Update\n\t(propagate_constants_across_call): Update\n\t(find_more_scalar_values_for_callers_subset): Update\n\t(has_undead_caller_from_outside_scc_p): Update\n\t* ipa-fnsummary.c (evaluate_properties_for_edge): Update.\n\t(compute_fn_summary): Update.\n\t(inline_analyze_function): Update.\n\t* ipa-icf.c: Include symtab-thunks.h.\n\t(sem_function::equals_wpa): Update.\n\t(redirect_all_callers): Update.\n\t(sem_function::init): Update.\n\t(sem_function::parse): Update.\n\t* ipa-inline-transform.c: Include symtab-thunks.h.\n\t(inline_call): Update.\n\t(save_inline_function_body): Update.\n\t(preserve_function_body_p): Update.\n\t* ipa-inline.c (inline_small_functions): Update.\n\t* ipa-polymorphic-call.c: Include alloc-pool.h, symbol-summary.h,\n\tsymtab-thunks.h\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Update.\n\t* ipa-pure-const.c: Include symtab-thunks.h.\n\t(analyze_function): Update.\n\t* ipa-sra.c (check_for_caller_issues): Update.\n\t* ipa-utils.c (ipa_reverse_postorder): Update.\n\t(ipa_merge_profiles): Update.\n\t* ipa-visibility.c (non_local_p): Update.\n\t(cgraph_node::local_p): Update.\n\t(function_and_variable_visibility): Update.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Update.\n\t* lto-cgraph.c: Include alloc-pool.h, symbol-summary.h and\n\tsymtab-thunks.h\n\t(lto_output_edge): Update.\n\t(lto_output_node): Update.\n\t(compute_ltrans_boundary): Update.\n\t(output_symtab): Update.\n\t(verify_node_partition): Update.\n\t(input_overwrite_node): Update.\n\t(input_node): Update.\n\t* lto-streamer-in.c (fixup_call_stmt_edges): Update.\n\t* symtab-thunks.cc: New file.\n\t* symtab-thunks.h: New file.\n\t* toplev.c (toplev::finalize): Call symtab_thunks_cc_finalize.\n\t* trans-mem.c (ipa_tm_mayenterirr_function): Update.\n\t(ipa_tm_execute): Update.\n\t* tree-inline.c (expand_call_inline): Update.\n\t* tree-nested.c (create_nesting_tree): Update.\n\t(convert_all_function_calls): Update.\n\t(gimplify_all_functions): Update.\n\t* tree-profile.c (tree_profiling): Update.\n\t* tree-ssa-structalias.c (associate_varinfo_to_alias): Update.\n\t* tree.c (free_lang_data_in_decl): Update.\n\t* value-prof.c (init_node_map): Update.\n\ngcc/c-family/ChangeLog:\n\n2020-10-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* c-common.c (c_common_finalize_early_debug): Update for new thunk api.\n\ngcc/d/ChangeLog:\n\n2020-10-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* decl.cc (finish_thunk): Update for new thunk api.\n\ngcc/lto/ChangeLog:\n\n2020-10-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-partition.c (add_symbol_to_partition_1): Update for new thunk\n\tapi.", "tree": {"sha": "48c1ccff315d09fcce1ec1e9f2b998367140e45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48c1ccff315d09fcce1ec1e9f2b998367140e45a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67f3791f7d133214b112bd831ff2876822c665d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f3791f7d133214b112bd831ff2876822c665d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f3791f7d133214b112bd831ff2876822c665d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f3791f7d133214b112bd831ff2876822c665d0/comments", "author": null, "committer": null, "parents": [{"sha": "83f83ddfe0fe41c9b553850d4ababd5089df8332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f83ddfe0fe41c9b553850d4ababd5089df8332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f83ddfe0fe41c9b553850d4ababd5089df8332"}], "stats": {"total": 1806, "additions": 1045, "deletions": 761}, "files": [{"sha": "0894f488d06af5040915102d286f5476bd734160", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -1297,6 +1297,7 @@ OBJS = \\\n \tcfgloopmanip.o \\\n \tcfgrtl.o \\\n \tsymtab.o \\\n+\tsymtab-thunks.o \\\n \tcgraph.o \\\n \tcgraphbuild.o \\\n \tcgraphunit.o \\\n@@ -2591,6 +2592,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/function-abi.h \\\n   $(srcdir)/output.h $(srcdir)/cfgloop.h $(srcdir)/cfg.h $(srcdir)/profile-count.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n+  $(srcdir)/symtab-thunks.h $(srcdir)/symtab-thunks.cc \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-utils.h \\\n@@ -2629,7 +2631,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/omp-offload.c \\\n   $(srcdir)/omp-general.c \\\n   $(srcdir)/omp-low.c \\\n-  $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n+  $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c \\\n   $(srcdir)/cgraphclones.c \\\n   $(srcdir)/tree-phinodes.c \\\n   $(srcdir)/tree-ssa-alias.h \\"}, {"sha": "1787dfdb1d85ff487a5ede7607a9d55be6efc877", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -9134,7 +9134,7 @@ c_common_finalize_early_debug (void)\n      functions that are still reachable at this point.  */\n   struct cgraph_node *cnode;\n   FOR_EACH_FUNCTION (cnode)\n-    if (!cnode->alias && !cnode->thunk.thunk_p\n+    if (!cnode->alias && !cnode->thunk\n \t&& (cnode->has_gimple_body_p () || !DECL_IS_BUILTIN (cnode->decl)))\n       (*debug_hooks->early_global_decl) (cnode->decl);\n }"}, {"sha": "9f317733c91343ff9f5329a10b396d6c4eb46e6b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-into-ssa.h\"\n #include \"ipa-inline.h\"\n #include \"tree-nested.h\"\n+#include \"symtab-thunks.h\"\n \n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n@@ -629,15 +630,17 @@ cgraph_node::create_thunk (tree alias, tree, bool this_adjusting,\n \t\t       ? virtual_value == wi::to_wide (virtual_offset)\n \t\t       : virtual_value == 0);\n \n-  node->thunk.fixed_offset = fixed_offset;\n-  node->thunk.virtual_value = virtual_value;\n-  node->thunk.indirect_offset = indirect_offset;\n-  node->thunk.alias = real_alias;\n-  node->thunk.this_adjusting = this_adjusting;\n-  node->thunk.virtual_offset_p = virtual_offset != NULL;\n-  node->thunk.thunk_p = true;\n+  node->thunk = true;\n   node->definition = true;\n \n+  thunk_info *i = thunk_info::get_create (node);\n+  i->fixed_offset = fixed_offset;\n+  i->virtual_value = virtual_value;\n+  i->indirect_offset = indirect_offset;\n+  i->alias = real_alias;\n+  i->this_adjusting = this_adjusting;\n+  i->virtual_offset_p = virtual_offset != NULL;\n+\n   return node;\n }\n \n@@ -910,7 +913,7 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n       = decl_maybe_in_construction_p (NULL, NULL, call_stmt,\n \t\t\t\t      caller->decl);\n   else\n-    edge->in_polymorphic_cdtor = caller->thunk.thunk_p;\n+    edge->in_polymorphic_cdtor = caller->thunk;\n   if (callee)\n     caller->calls_declare_variant_alt |= callee->declare_variant_alt;\n \n@@ -2173,37 +2176,17 @@ cgraph_node::dump (FILE *f)\n \n   fprintf (f, \"\\n\");\n \n-  if (thunk.thunk_p)\n+  if (thunk)\n     {\n       fprintf (f, \"  Thunk\");\n-      if (thunk.alias)\n-\tfprintf (f, \"  of %s (asm:%s)\",\n-\t\t lang_hooks.decl_printable_name (thunk.alias, 2),\n-\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk.alias)));\n-      fprintf (f, \" fixed offset %i virtual value %i indirect_offset %i \"\n-\t\t  \"has virtual offset %i\\n\",\n-\t       (int)thunk.fixed_offset,\n-\t       (int)thunk.virtual_value,\n-\t       (int)thunk.indirect_offset,\n-\t       (int)thunk.virtual_offset_p);\n+      thunk_info::get (this)->dump (f);\n     }\n   else if (former_thunk_p ())\n-    fprintf (f, \"  Former thunk fixed offset %i virtual value %i \"\n-\t     \"indirect_offset %i has virtual offset %i\\n\",\n-\t     (int)thunk.fixed_offset,\n-\t     (int)thunk.virtual_value,\n-\t     (int)thunk.indirect_offset,\n-\t     (int)thunk.virtual_offset_p);\n-  if (alias && thunk.alias\n-      && DECL_P (thunk.alias))\n     {\n-      fprintf (f, \"  Alias of %s\",\n-\t       lang_hooks.decl_printable_name (thunk.alias, 2));\n-      if (DECL_ASSEMBLER_NAME_SET_P (thunk.alias))\n-\tfprintf (f, \" (asm:%s)\",\n-\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk.alias)));\n-      fprintf (f, \"\\n\");\n+      fprintf (f, \"  Former thunk \");\n+      thunk_info::get (this)->dump (f);\n     }\n+  else gcc_checking_assert (!thunk_info::get (this));\n   \n   fprintf (f, \"  Called by: \");\n \n@@ -2444,11 +2427,11 @@ cgraph_node::call_for_symbol_thunks_and_aliases (bool (*callback)\n   if (avail <= AVAIL_INTERPOSABLE)\n     return false;\n   for (e = callers; e; e = e->next_caller)\n-    if (e->caller->thunk.thunk_p\n+    if (e->caller->thunk\n \t&& (include_overwritable\n \t    || e->caller->get_availability () > AVAIL_INTERPOSABLE)\n \t&& !(exclude_virtual_thunks\n-\t     && e->caller->thunk.virtual_offset_p))\n+\t     && thunk_info::get (e->caller)->virtual_offset_p))\n       if (e->caller->call_for_symbol_thunks_and_aliases (callback, data,\n \t\t\t\t\t\t       include_overwritable,\n \t\t\t\t\t\t       exclude_virtual_thunks))\n@@ -2522,7 +2505,7 @@ set_nothrow_flag_1 (cgraph_node *node, bool nothrow, bool non_call,\n \tset_nothrow_flag_1 (alias, nothrow, non_call, changed);\n     }\n   for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n-    if (e->caller->thunk.thunk_p\n+    if (e->caller->thunk\n \t&& (!nothrow || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n       set_nothrow_flag_1 (e->caller, nothrow, non_call, changed);\n }\n@@ -2571,7 +2554,7 @@ set_malloc_flag_1 (cgraph_node *node, bool malloc_p, bool *changed)\n     }\n \n   for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n-    if (e->caller->thunk.thunk_p\n+    if (e->caller->thunk\n \t&& (!malloc_p || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n       set_malloc_flag_1 (e->caller, malloc_p, changed);\n }\n@@ -2690,13 +2673,13 @@ set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n \tset_const_flag_1 (alias, set_const, looping, changed);\n     }\n   for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n-    if (e->caller->thunk.thunk_p\n+    if (e->caller->thunk\n \t&& (!set_const || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n       {\n \t/* Virtual thunks access virtual offset in the vtable, so they can\n \t   only be pure, never const.  */\n         if (set_const\n-\t    && (e->caller->thunk.virtual_offset_p\n+\t    && (thunk_info::get (e->caller)->virtual_offset_p\n \t        || !node->binds_to_current_def_p (e->caller)))\n \t  *changed |= e->caller->set_pure_flag (true, looping);\n \telse\n@@ -3040,7 +3023,7 @@ collect_callers_of_node_1 (cgraph_node *node, void *data)\n   if (avail > AVAIL_INTERPOSABLE)\n     for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n       if (!cs->indirect_inlining_edge\n-\t  && !cs->caller->thunk.thunk_p)\n+\t  && !cs->caller->thunk)\n         redirect_callers->safe_push (cs);\n   return false;\n }\n@@ -3071,7 +3054,7 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)\n       || node2->former_clone_of == node->decl)\n     return true;\n \n-  if (!node->thunk.thunk_p && !node->former_thunk_p ())\n+  if (!node->thunk && !node->former_thunk_p ())\n     {\n       while (node2 && node->decl != node2->decl)\n \tnode2 = node2->clone_of;\n@@ -3081,9 +3064,9 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)\n   /* There are no virtual clones of thunks so check former_clone_of or if we\n      might have skipped thunks because this adjustments are no longer\n      necessary.  */\n-  while (node->thunk.thunk_p || node->former_thunk_p ())\n+  while (node->thunk || node->former_thunk_p ())\n     {\n-      if (!node->thunk.this_adjusting)\n+      if (!thunk_info::get (node)->this_adjusting)\n \treturn false;\n       /* In case of instrumented expanded thunks, which can have multiple calls\n \t in them, we do not know how to continue and just have to be\n@@ -3647,7 +3630,7 @@ cgraph_node::verify_node (void)\n \t}\n     }\n \n-  if (analyzed && thunk.thunk_p)\n+  if (analyzed && thunk)\n     {\n       if (!callees)\n \t{\n@@ -3831,7 +3814,7 @@ cgraph_node::function_symbol (enum availability *availability,\n {\n   cgraph_node *node = ultimate_alias_target (availability, ref);\n \n-  while (node->thunk.thunk_p)\n+  while (node->thunk)\n     {\n       enum availability a;\n \n@@ -3858,7 +3841,7 @@ cgraph_node::function_or_virtual_thunk_symbol\n {\n   cgraph_node *node = ultimate_alias_target (availability, ref);\n \n-  while (node->thunk.thunk_p && !node->thunk.virtual_offset_p)\n+  while (node->thunk && !thunk_info::get (node)->virtual_offset_p)\n     {\n       enum availability a;\n \n@@ -4007,6 +3990,7 @@ void\n cgraph_c_finalize (void)\n {\n   nested_function_info::release ();\n+  thunk_info::release ();\n   symtab = NULL;\n \n   x_cgraph_nodes_queue = NULL;\n@@ -4042,7 +4026,7 @@ bool\n cgraph_node::has_thunk_p (cgraph_node *node, void *)\n {\n   for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n-    if (e->caller->thunk.thunk_p)\n+    if (e->caller->thunk)\n       return true;\n   return false;\n }\n@@ -4178,6 +4162,21 @@ cgraph_c_tests ()\n \n } // namespace selftest\n \n+/* Return true if this node represents a former, i.e. an expanded, thunk.  */\n+\n+bool\n+cgraph_node::former_thunk_p (void)\n+{\n+  if (thunk)\n+    return false;\n+  thunk_info *i = thunk_info::get (this);\n+  if (!i)\n+    return false;\n+  gcc_checking_assert (i->fixed_offset || i->virtual_offset_p\n+\t\t       || i->indirect_offset);\n+  return true;\n+}\n+\n #endif /* CHECKING_P */\n \n #include \"gt-cgraph.h\""}, {"sha": "9eb48d5b62fbf9c392febeddd67f3b4ee61e8f3a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 19, "deletions": 70, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -681,52 +681,6 @@ extern const char * const cgraph_availability_names[];\n extern const char * const ld_plugin_symbol_resolution_names[];\n extern const char * const tls_model_names[];\n \n-/* Sub-structure of cgraph_node.  Holds information about thunk, used only for\n-   same body aliases.\n-\n-   Thunks are basically wrappers around methods which are introduced in case\n-   of multiple inheritance in order to adjust the value of the \"this\" pointer\n-   or of the returned value.\n-\n-   In the case of this-adjusting thunks, each back-end can override the\n-   can_output_mi_thunk/output_mi_thunk target hooks to generate a minimal thunk\n-   (with a tail call for instance) directly as assembly.  For the default hook\n-   or for the case where the can_output_mi_thunk hooks return false, the thunk\n-   is gimplified and lowered using the regular machinery.  */\n-\n-struct GTY(()) cgraph_thunk_info {\n-  /* Offset used to adjust \"this\".  */\n-  HOST_WIDE_INT fixed_offset;\n-\n-  /* Offset in the virtual table to get the offset to adjust \"this\".  Valid iff\n-     VIRTUAL_OFFSET_P is true.  */\n-  HOST_WIDE_INT virtual_value;\n-\n-  /* Offset from \"this\" to get the offset to adjust \"this\".  Zero means: this\n-     offset is to be ignored.  */\n-  HOST_WIDE_INT indirect_offset;\n-\n-  /* Thunk target, i.e. the method that this thunk wraps.  Depending on the\n-     TARGET_USE_LOCAL_THUNK_ALIAS_P macro, this may have to be a new alias.  */\n-  tree alias;\n-\n-  /* Nonzero for a \"this\" adjusting thunk and zero for a result adjusting\n-     thunk.  */\n-  bool this_adjusting;\n-\n-  /* If true, this thunk is what we call a virtual thunk.  In this case:\n-     * for this-adjusting thunks, after the FIXED_OFFSET based adjustment is\n-       done, add to the result the offset found in the vtable at:\n-\t vptr + VIRTUAL_VALUE\n-     * for result-adjusting thunks, the FIXED_OFFSET adjustment is done after\n-       the virtual one.  */\n-  bool virtual_offset_p;\n-\n-  /* Set to true when alias node (the cgraph_node to which this struct belong)\n-     is a thunk.  Access to any other fields is invalid if this is false.  */\n-  bool thunk_p;\n-};\n-\n /* Represent which DECL tree (or reference to such tree)\n    will be replaced by another tree while versioning.  */\n struct GTY(()) ipa_replace_map\n@@ -925,10 +879,11 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n       next_sibling_clone (NULL), prev_sibling_clone (NULL), clones (NULL),\n       clone_of (NULL), call_site_hash (NULL), former_clone_of (NULL),\n       simdclone (NULL), simd_clones (NULL), ipa_transforms_to_apply (vNULL),\n-      inlined_to (NULL), rtl (NULL), clone (), thunk (),\n+      inlined_to (NULL), rtl (NULL), clone (),\n       count (profile_count::uninitialized ()),\n       count_materialization_scale (REG_BR_PROB_BASE), profile_id (0),\n-      unit_id (0), tp_first_run (0), used_as_abstract_origin (false),\n+      unit_id (0), tp_first_run (0), thunk (false),\n+      used_as_abstract_origin (false),\n       lowered (false), process (false), frequency (NODE_FREQUENCY_NORMAL),\n       only_called_at_startup (false), only_called_at_exit (false),\n       tm_clone (false), dispatcher_function (false), calls_comdat_local (false),\n@@ -1078,7 +1033,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \n   /* Add thunk alias into callgraph.  The alias declaration is ALIAS and it\n      aliases DECL with an adjustments made into the first parameter.\n-     See comments in struct cgraph_thunk_info for detail on the parameters.  */\n+     See comments in struct symtab-thunks.h for detail on the parameters.  */\n   cgraph_node * create_thunk (tree alias, tree, bool this_adjusting,\n \t\t\t      HOST_WIDE_INT fixed_offset,\n \t\t\t      HOST_WIDE_INT virtual_value,\n@@ -1099,13 +1054,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   cgraph_node *ultimate_alias_target (availability *availability = NULL,\n \t\t\t\t      symtab_node *ref = NULL);\n \n-  /* Expand thunk NODE to gimple if possible.\n-     When FORCE_GIMPLE_THUNK is true, gimple thunk is created and\n-     no assembler is produced.\n-     When OUTPUT_ASM_THUNK is true, also produce assembler for\n-     thunks that are not lowered.  */\n-  bool expand_thunk (bool output_asm_thunks, bool force_gimple_thunk);\n-\n   /*  Call expand_thunk on all callers that are thunks and analyze those\n       nodes that were expanded.  */\n   void expand_all_artificial_thunks ();\n@@ -1324,7 +1272,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   inline bool has_gimple_body_p (void);\n \n   /* Return true if this node represents a former, i.e. an expanded, thunk.  */\n-  inline bool former_thunk_p (void);\n+  bool former_thunk_p (void);\n \n   /* Check if function calls comdat local.  This is used to recompute\n      calls_comdat_local flag after function transformations.  */\n@@ -1462,7 +1410,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \n   struct cgraph_rtl_info *rtl;\n   cgraph_clone_info clone;\n-  cgraph_thunk_info thunk;\n \n   /* Expected number of executions: calculated in profile.c.  */\n   profile_count count;\n@@ -1476,6 +1423,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* Time profiler: first run of function.  */\n   int tp_first_run;\n \n+  /* True when symbol is a thunk.  */\n+  unsigned thunk : 1;\n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n   unsigned used_as_abstract_origin : 1;\n@@ -2241,6 +2190,10 @@ struct asmname_hasher : ggc_ptr_hash <symtab_node>\n   static bool equal (symtab_node *n, const_tree t);\n };\n \n+struct thunk_info;\n+template <class T> class function_summary;\n+typedef function_summary <thunk_info *> thunk_summary;\n+\n class GTY((tag (\"SYMTAB\"))) symbol_table\n {\n public:\n@@ -2257,6 +2210,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   function_flags_ready (false), cpp_implicit_aliases_done (false),\n   section_hash (NULL), assembler_name_hash (NULL), init_priority_hash (NULL),\n   dump_file (NULL), ipa_clones_dump_file (NULL), cloned_nodes (),\n+  m_thunks (NULL),\n   m_first_edge_removal_hook (NULL), m_first_cgraph_removal_hook (NULL),\n   m_first_edge_duplicated_hook (NULL), m_first_cgraph_duplicated_hook (NULL),\n   m_first_cgraph_insertion_hook (NULL), m_first_varpool_insertion_hook (NULL),\n@@ -2538,6 +2492,9 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n \n   hash_set <const cgraph_node *> GTY ((skip)) cloned_nodes;\n \n+  /* Thunk annotations.  */\n+  thunk_summary *m_thunks;\n+\n private:\n   /* Allocate a cgraph_edge structure and fill it with data according to the\n      parameters of which only CALLEE can be NULL (when creating an indirect\n@@ -2612,6 +2569,9 @@ cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);\n void cgraphunit_c_finalize (void);\n int tp_first_run_node_cmp (const void *pa, const void *pb);\n \n+/* In symtab-thunks.cc  */\n+void symtab_thunks_cc_finalize (void);\n+\n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool, profile_count);\n@@ -3082,18 +3042,7 @@ symbol_table::next_function_with_gimple_body (cgraph_node *node)\n inline bool\n cgraph_node::has_gimple_body_p (void)\n {\n-  return definition && !thunk.thunk_p && !alias;\n-}\n-\n-/* Return true if this node represents a former, i.e. an expanded, thunk.  */\n-\n-inline bool\n-cgraph_node::former_thunk_p (void)\n-{\n-  return (!thunk.thunk_p\n-\t  && (thunk.fixed_offset\n-\t      || thunk.virtual_offset_p\n-\t      || thunk.indirect_offset));\n+  return definition && !thunk && !alias;\n }\n \n /* Walk all functions with body defined.  */"}, {"sha": "41c6efb10aca20d128bf573451bf1cfd23a7c3eb", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vrp.h\"\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n+#include \"symtab-thunks.h\"\n \n /* Create clone of edge in the node N represented by CALL_EXPR\n    the callgraph.  */\n@@ -183,28 +184,28 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   cgraph_node *new_thunk, *thunk_of;\n   thunk_of = thunk->callees->callee->ultimate_alias_target ();\n \n-  if (thunk_of->thunk.thunk_p)\n+  if (thunk_of->thunk)\n     node = duplicate_thunk_for_node (thunk_of, node);\n \n   if (!DECL_ARGUMENTS (thunk->decl))\n     thunk->get_untransformed_body ();\n \n+  thunk_info *i = thunk_info::get (thunk);\n   cgraph_edge *cs;\n   for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (cs->caller->thunk.thunk_p\n-\t&& cs->caller->thunk.fixed_offset == thunk->thunk.fixed_offset\n-\t&& cs->caller->thunk.virtual_value == thunk->thunk.virtual_value\n-\t&& cs->caller->thunk.indirect_offset == thunk->thunk.indirect_offset\n-\t&& cs->caller->thunk.this_adjusting == thunk->thunk.this_adjusting\n-\t&& cs->caller->thunk.virtual_offset_p == thunk->thunk.virtual_offset_p)\n-      return cs->caller;\n+    if (cs->caller->thunk)\n+      {\n+\tthunk_info *i2 = thunk_info::get (cs->caller);\n+\tif (*i2 == *i)\n+\t  return cs->caller;\n+      }\n \n   tree new_decl;\n   if (node->clone.param_adjustments)\n     {\n       /* We do not need to duplicate this_adjusting thunks if we have removed\n \t this.  */\n-      if (thunk->thunk.this_adjusting\n+      if (i->this_adjusting\n \t  && !node->clone.param_adjustments->first_param_intact_p ())\n \treturn node;\n \n@@ -256,7 +257,7 @@ void\n cgraph_edge::redirect_callee_duplicating_thunks (cgraph_node *n)\n {\n   cgraph_node *orig_to = callee->ultimate_alias_target ();\n-  if (orig_to->thunk.thunk_p)\n+  if (orig_to->thunk)\n     n = duplicate_thunk_for_node (orig_to, n);\n \n   redirect_callee (n);\n@@ -270,14 +271,14 @@ cgraph_node::expand_all_artificial_thunks ()\n {\n   cgraph_edge *e;\n   for (e = callers; e;)\n-    if (e->caller->thunk.thunk_p)\n+    if (e->caller->thunk)\n       {\n \tcgraph_node *thunk = e->caller;\n \n \te = e->next_caller;\n-\tif (thunk->expand_thunk (false, false))\n+\tif (expand_thunk (thunk, false, false))\n \t  {\n-\t    thunk->thunk.thunk_p = false;\n+\t    thunk->thunk = false;\n \t    thunk->analyze ();\n \t    ipa_analyze_node (thunk);\n \t    inline_analyze_function (thunk);\n@@ -812,7 +813,7 @@ cgraph_node::create_edge_including_clones (cgraph_node *callee,\n   if (node)\n     while (node != this)\n       /* Thunk clones do not get updated while copying inline function body.  */\n-      if (!node->thunk.thunk_p)\n+      if (!node->thunk)\n \t{\n \t  cgraph_edge *edge = node->get_edge (old_stmt);\n "}, {"sha": "d2d98c8dc8a09e448c678c7fcef74ea3f1c645e2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 21, "deletions": 502, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -207,6 +207,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"ipa-inline.h\"\n #include \"omp-offload.h\"\n+#include \"symtab-thunks.h\"\n \n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that\n@@ -217,9 +218,6 @@ static void expand_all_functions (void);\n static void mark_functions_to_output (void);\n static void handle_alias_pairs (void);\n \n-/* Used for vtable lookup in thunk adjusting.  */\n-static GTY (()) tree vtable_entry_type;\n-\n /* Return true if this symbol is a function from the C frontend specified\n    directly in RTL form (with \"__RTL\").  */\n \n@@ -619,9 +617,10 @@ cgraph_node::analyze (void)\n   location_t saved_loc = input_location;\n   input_location = DECL_SOURCE_LOCATION (decl);\n \n-  if (thunk.thunk_p)\n+  if (thunk)\n     {\n-      cgraph_node *t = cgraph_node::get (thunk.alias);\n+      thunk_info *info = thunk_info::get (this);\n+      cgraph_node *t = cgraph_node::get (info->alias);\n \n       create_edge (t, NULL, t->count);\n       callees->can_throw_external = !TREE_NOTHROW (t->decl);\n@@ -635,8 +634,8 @@ cgraph_node::analyze (void)\n \t  if (!t->analyzed && t->definition)\n \t    t->analyze ();\n \t}\n-      bool ret = expand_thunk (false, false);\n-      thunk.alias = NULL;\n+      bool ret = expand_thunk (this, false, false);\n+      thunk_info::get (this)->alias = NULL;\n       if (!ret)\n \treturn;\n     }\n@@ -1222,7 +1221,7 @@ analyze_functions (bool first_time)\n \t      See gcc.c-torture/compile/20011119-1.c  */\n \t      if (!DECL_STRUCT_FUNCTION (decl)\n \t\t  && !cnode->alias\n-\t\t  && !cnode->thunk.thunk_p\n+\t\t  && !cnode->thunk\n \t\t  && !cnode->dispatcher_function)\n \t\t{\n \t\t  cnode->reset ();\n@@ -1377,10 +1376,10 @@ analyze_functions (bool first_time)\n \n \t  if (cnode->definition && !gimple_has_body_p (decl)\n \t      && !cnode->alias\n-\t      && !cnode->thunk.thunk_p)\n+\t      && !cnode->thunk)\n \t    cnode->reset ();\n \n-\t  gcc_assert (!cnode->definition || cnode->thunk.thunk_p\n+\t  gcc_assert (!cnode->definition || cnode->thunk\n \t\t      || cnode->alias\n \t\t      || gimple_has_body_p (decl)\n \t\t      || cnode->native_rtl_p ());\n@@ -1611,7 +1610,7 @@ mark_functions_to_output (void)\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n       if (node->analyzed\n-\t  && !node->thunk.thunk_p\n+\t  && !node->thunk\n \t  && !node->alias\n \t  && !node->inlined_to\n \t  && !TREE_ASM_WRITTEN (decl)\n@@ -1624,7 +1623,7 @@ mark_functions_to_output (void)\n \t      for (next = dyn_cast<cgraph_node *> (node->same_comdat_group);\n \t\t   next != node;\n \t\t   next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n-\t\tif (!next->thunk.thunk_p && !next->alias\n+\t\tif (!next->thunk && !next->alias\n \t\t    && !next->comdat_local_p ())\n \t\t  next->process = 1;\n \t    }\n@@ -1733,487 +1732,6 @@ init_lowered_empty_function (tree decl, bool in_ssa, profile_count count)\n   return bb;\n }\n \n-/* Adjust PTR by the constant FIXED_OFFSET, by the vtable offset indicated by\n-   VIRTUAL_OFFSET, and by the indirect offset indicated by INDIRECT_OFFSET, if\n-   it is non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and zero\n-   for a result adjusting thunk.  */\n-\n-tree\n-thunk_adjust (gimple_stmt_iterator * bsi,\n-\t      tree ptr, bool this_adjusting,\n-\t      HOST_WIDE_INT fixed_offset, tree virtual_offset,\n-\t      HOST_WIDE_INT indirect_offset)\n-{\n-  gassign *stmt;\n-  tree ret;\n-\n-  if (this_adjusting\n-      && fixed_offset != 0)\n-    {\n-      stmt = gimple_build_assign\n-\t\t(ptr, fold_build_pointer_plus_hwi_loc (input_location,\n-\t\t\t\t\t\t       ptr,\n-\t\t\t\t\t\t       fixed_offset));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-    }\n-\n-  if (!vtable_entry_type && (virtual_offset || indirect_offset != 0))\n-    {\n-      tree vfunc_type = make_node (FUNCTION_TYPE);\n-      TREE_TYPE (vfunc_type) = integer_type_node;\n-      TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n-      layout_type (vfunc_type);\n-\n-      vtable_entry_type = build_pointer_type (vfunc_type);\n-    }\n-\n-  /* If there's a virtual offset, look up that value in the vtable and\n-     adjust the pointer again.  */\n-  if (virtual_offset)\n-    {\n-      tree vtabletmp;\n-      tree vtabletmp2;\n-      tree vtabletmp3;\n-\n-      vtabletmp =\n-\tcreate_tmp_reg (build_pointer_type\n-\t\t\t  (build_pointer_type (vtable_entry_type)), \"vptr\");\n-\n-      /* The vptr is always at offset zero in the object.  */\n-      stmt = gimple_build_assign (vtabletmp,\n-\t\t\t\t  build1 (NOP_EXPR, TREE_TYPE (vtabletmp),\n-\t\t\t\t\t  ptr));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-      /* Form the vtable address.  */\n-      vtabletmp2 = create_tmp_reg (TREE_TYPE (TREE_TYPE (vtabletmp)),\n-\t\t\t\t     \"vtableaddr\");\n-      stmt = gimple_build_assign (vtabletmp2,\n-\t\t\t\t  build_simple_mem_ref (vtabletmp));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-      /* Find the entry with the vcall offset.  */\n-      stmt = gimple_build_assign (vtabletmp2,\n-\t\t\t\t  fold_build_pointer_plus_loc (input_location,\n-\t\t\t\t\t\t\t       vtabletmp2,\n-\t\t\t\t\t\t\t       virtual_offset));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-      /* Get the offset itself.  */\n-      vtabletmp3 = create_tmp_reg (TREE_TYPE (TREE_TYPE (vtabletmp2)),\n-\t\t\t\t     \"vcalloffset\");\n-      stmt = gimple_build_assign (vtabletmp3,\n-\t\t\t\t  build_simple_mem_ref (vtabletmp2));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-      /* Adjust the `this' pointer.  */\n-      ptr = fold_build_pointer_plus_loc (input_location, ptr, vtabletmp3);\n-      ptr = force_gimple_operand_gsi (bsi, ptr, true, NULL_TREE, false,\n-\t\t\t\t      GSI_CONTINUE_LINKING);\n-    }\n-\n-  /* Likewise for an offset that is stored in the object that contains the\n-     vtable.  */\n-  if (indirect_offset != 0)\n-    {\n-      tree offset_ptr, offset_tree;\n-\n-      /* Get the address of the offset.  */\n-      offset_ptr\n-        = create_tmp_reg (build_pointer_type\n-\t\t\t  (build_pointer_type (vtable_entry_type)),\n-\t\t\t  \"offset_ptr\");\n-      stmt = gimple_build_assign (offset_ptr,\n-\t\t\t\t  build1 (NOP_EXPR, TREE_TYPE (offset_ptr),\n-\t\t\t\t\t  ptr));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-      stmt = gimple_build_assign\n-\t     (offset_ptr,\n-\t      fold_build_pointer_plus_hwi_loc (input_location, offset_ptr,\n-\t\t\t\t\t       indirect_offset));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-      /* Get the offset itself.  */\n-      offset_tree = create_tmp_reg (TREE_TYPE (TREE_TYPE (offset_ptr)),\n-\t\t\t\t    \"offset\");\n-      stmt = gimple_build_assign (offset_tree,\n-\t\t\t\t  build_simple_mem_ref (offset_ptr));\n-      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-      /* Adjust the `this' pointer.  */\n-      ptr = fold_build_pointer_plus_loc (input_location, ptr, offset_tree);\n-      ptr = force_gimple_operand_gsi (bsi, ptr, true, NULL_TREE, false,\n-\t\t\t\t      GSI_CONTINUE_LINKING);\n-    }\n-\n-  if (!this_adjusting\n-      && fixed_offset != 0)\n-    /* Adjust the pointer by the constant.  */\n-    {\n-      tree ptrtmp;\n-\n-      if (VAR_P (ptr))\n-        ptrtmp = ptr;\n-      else\n-        {\n-          ptrtmp = create_tmp_reg (TREE_TYPE (ptr), \"ptr\");\n-          stmt = gimple_build_assign (ptrtmp, ptr);\n-\t  gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\t}\n-      ptr = fold_build_pointer_plus_hwi_loc (input_location,\n-\t\t\t\t\t     ptrtmp, fixed_offset);\n-    }\n-\n-  /* Emit the statement and gimplify the adjustment expression.  */\n-  ret = create_tmp_reg (TREE_TYPE (ptr), \"adjusted_this\");\n-  stmt = gimple_build_assign (ret, ptr);\n-  gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n-\n-  return ret;\n-}\n-\n-/* Expand thunk NODE to gimple if possible.\n-   When FORCE_GIMPLE_THUNK is true, gimple thunk is created and\n-   no assembler is produced.\n-   When OUTPUT_ASM_THUNK is true, also produce assembler for\n-   thunks that are not lowered.  */\n-\n-bool\n-cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n-{\n-  bool this_adjusting = thunk.this_adjusting;\n-  HOST_WIDE_INT fixed_offset = thunk.fixed_offset;\n-  HOST_WIDE_INT virtual_value = thunk.virtual_value;\n-  HOST_WIDE_INT indirect_offset = thunk.indirect_offset;\n-  tree virtual_offset = NULL;\n-  tree alias = callees->callee->decl;\n-  tree thunk_fndecl = decl;\n-  tree a;\n-\n-  if (!force_gimple_thunk\n-      && this_adjusting\n-      && indirect_offset == 0\n-      && !DECL_EXTERNAL (alias)\n-      && !DECL_STATIC_CHAIN (alias)\n-      && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n-\t\t\t\t\t      virtual_value, alias))\n-    {\n-      tree fn_block;\n-      tree restype = TREE_TYPE (TREE_TYPE (thunk_fndecl));\n-\n-      if (!output_asm_thunks)\n-\t{\n-\t  analyzed = true;\n-\t  return false;\n-\t}\n-\n-      if (in_lto_p)\n-\tget_untransformed_body ();\n-      a = DECL_ARGUMENTS (thunk_fndecl);\n-      \n-      current_function_decl = thunk_fndecl;\n-\n-      /* Ensure thunks are emitted in their correct sections.  */\n-      resolve_unique_section (thunk_fndecl, 0,\n-\t\t\t      flag_function_sections);\n-\n-      DECL_RESULT (thunk_fndecl)\n-\t= build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n-\t\t      RESULT_DECL, 0, restype);\n-      DECL_CONTEXT (DECL_RESULT (thunk_fndecl)) = thunk_fndecl;\n-\n-      /* The back end expects DECL_INITIAL to contain a BLOCK, so we\n-\t create one.  */\n-      fn_block = make_node (BLOCK);\n-      BLOCK_VARS (fn_block) = a;\n-      DECL_INITIAL (thunk_fndecl) = fn_block;\n-      BLOCK_SUPERCONTEXT (fn_block) = thunk_fndecl;\n-      allocate_struct_function (thunk_fndecl, false);\n-      init_function_start (thunk_fndecl);\n-      cfun->is_thunk = 1;\n-      insn_locations_init ();\n-      set_curr_insn_location (DECL_SOURCE_LOCATION (thunk_fndecl));\n-      prologue_location = curr_insn_location ();\n-\n-      targetm.asm_out.output_mi_thunk (asm_out_file, thunk_fndecl,\n-\t\t\t\t       fixed_offset, virtual_value, alias);\n-\n-      insn_locations_finalize ();\n-      init_insn_lengths ();\n-      free_after_compilation (cfun);\n-      TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n-      thunk.thunk_p = false;\n-      analyzed = false;\n-    }\n-  else if (stdarg_p (TREE_TYPE (thunk_fndecl)))\n-    {\n-      error (\"generic thunk code fails for method %qD which uses %<...%>\",\n-\t     thunk_fndecl);\n-      TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n-      analyzed = true;\n-      return false;\n-    }\n-  else\n-    {\n-      tree restype;\n-      basic_block bb, then_bb, else_bb, return_bb;\n-      gimple_stmt_iterator bsi;\n-      int nargs = 0;\n-      tree arg;\n-      int i;\n-      tree resdecl;\n-      tree restmp = NULL;\n-\n-      gcall *call;\n-      greturn *ret;\n-      bool alias_is_noreturn = TREE_THIS_VOLATILE (alias);\n-\n-      /* We may be called from expand_thunk that releases body except for\n-\t DECL_ARGUMENTS.  In this case force_gimple_thunk is true.  */\n-      if (in_lto_p && !force_gimple_thunk)\n-\tget_untransformed_body ();\n-\n-      /* We need to force DECL_IGNORED_P when the thunk is created\n-\t after early debug was run.  */\n-      if (force_gimple_thunk)\n-\tDECL_IGNORED_P (thunk_fndecl) = 1;\n-\n-      a = DECL_ARGUMENTS (thunk_fndecl);\n-\n-      current_function_decl = thunk_fndecl;\n-\n-      /* Ensure thunks are emitted in their correct sections.  */\n-      resolve_unique_section (thunk_fndecl, 0,\n-\t\t\t      flag_function_sections);\n-\n-      bitmap_obstack_initialize (NULL);\n-\n-      if (thunk.virtual_offset_p)\n-        virtual_offset = size_int (virtual_value);\n-\n-      /* Build the return declaration for the function.  */\n-      restype = TREE_TYPE (TREE_TYPE (thunk_fndecl));\n-      if (DECL_RESULT (thunk_fndecl) == NULL_TREE)\n-\t{\n-\t  resdecl = build_decl (input_location, RESULT_DECL, 0, restype);\n-\t  DECL_ARTIFICIAL (resdecl) = 1;\n-\t  DECL_IGNORED_P (resdecl) = 1;\n-\t  DECL_CONTEXT (resdecl) = thunk_fndecl;\n-\t  DECL_RESULT (thunk_fndecl) = resdecl;\n-\t}\n-      else\n-\tresdecl = DECL_RESULT (thunk_fndecl);\n-\n-      profile_count cfg_count = count;\n-      if (!cfg_count.initialized_p ())\n-\tcfg_count = profile_count::from_gcov_type (BB_FREQ_MAX).guessed_local ();\n-\n-      bb = then_bb = else_bb = return_bb\n-\t= init_lowered_empty_function (thunk_fndecl, true, cfg_count);\n-\n-      bsi = gsi_start_bb (bb);\n-\n-      /* Build call to the function being thunked.  */\n-      if (!VOID_TYPE_P (restype)\n-\t  && (!alias_is_noreturn\n-\t      || TREE_ADDRESSABLE (restype)\n-\t      || TREE_CODE (TYPE_SIZE_UNIT (restype)) != INTEGER_CST))\n-\t{\n-\t  if (DECL_BY_REFERENCE (resdecl))\n-\t    {\n-\t      restmp = gimple_fold_indirect_ref (resdecl);\n-\t      if (!restmp)\n-\t\trestmp = build2 (MEM_REF,\n-\t\t\t\t TREE_TYPE (TREE_TYPE (resdecl)),\n-\t\t\t\t resdecl,\n-\t\t\t\t build_int_cst (TREE_TYPE (resdecl), 0));\n-\t    }\n-\t  else if (!is_gimple_reg_type (restype))\n-\t    {\n-\t      if (aggregate_value_p (resdecl, TREE_TYPE (thunk_fndecl)))\n-\t\t{\n-\t\t  restmp = resdecl;\n-\n-\t\t  if (VAR_P (restmp))\n-\t\t    {\n-\t\t      add_local_decl (cfun, restmp);\n-\t\t      BLOCK_VARS (DECL_INITIAL (current_function_decl))\n-\t\t\t= restmp;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\trestmp = create_tmp_var (restype, \"retval\");\n-\t    }\n-\t  else\n-\t    restmp = create_tmp_reg (restype, \"retval\");\n-\t}\n-\n-      for (arg = a; arg; arg = DECL_CHAIN (arg))\n-        nargs++;\n-      auto_vec<tree> vargs (nargs);\n-      i = 0;\n-      arg = a;\n-      if (this_adjusting)\n-\t{\n-\t  vargs.quick_push (thunk_adjust (&bsi, a, 1, fixed_offset,\n-\t\t\t\t\t  virtual_offset, indirect_offset));\n-\t  arg = DECL_CHAIN (a);\n-\t  i = 1;\n-\t}\n-\n-      if (nargs)\n-\tfor (; i < nargs; i++, arg = DECL_CHAIN (arg))\n-\t  {\n-\t    tree tmp = arg;\n-\t    DECL_NOT_GIMPLE_REG_P (arg) = 0;\n-\t    if (!is_gimple_val (arg))\n-\t      {\n-\t\ttmp = create_tmp_reg (TYPE_MAIN_VARIANT\n-\t\t\t\t      (TREE_TYPE (arg)), \"arg\");\n-\t\tgimple *stmt = gimple_build_assign (tmp, arg);\n-\t\tgsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n-\t      }\n-\t    vargs.quick_push (tmp);\n-\t  }\n-      call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n-      callees->call_stmt = call;\n-      gimple_call_set_from_thunk (call, true);\n-      if (DECL_STATIC_CHAIN (alias))\n-\t{\n-\t  tree p = DECL_STRUCT_FUNCTION (alias)->static_chain_decl;\n-\t  tree type = TREE_TYPE (p);\n-\t  tree decl = build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n-\t\t\t\t  PARM_DECL, create_tmp_var_name (\"CHAIN\"),\n-\t\t\t\t  type);\n-\t  DECL_ARTIFICIAL (decl) = 1;\n-\t  DECL_IGNORED_P (decl) = 1;\n-\t  TREE_USED (decl) = 1;\n-\t  DECL_CONTEXT (decl) = thunk_fndecl;\n-\t  DECL_ARG_TYPE (decl) = type;\n-\t  TREE_READONLY (decl) = 1;\n-\n-\t  struct function *sf = DECL_STRUCT_FUNCTION (thunk_fndecl);\n-\t  sf->static_chain_decl = decl;\n-\n-\t  gimple_call_set_chain (call, decl);\n-\t}\n-\n-      /* Return slot optimization is always possible and in fact required to\n-         return values with DECL_BY_REFERENCE.  */\n-      if (aggregate_value_p (resdecl, TREE_TYPE (thunk_fndecl))\n-\t  && (!is_gimple_reg_type (TREE_TYPE (resdecl))\n-\t      || DECL_BY_REFERENCE (resdecl)))\n-        gimple_call_set_return_slot_opt (call, true);\n-\n-      if (restmp)\n-\t{\n-          gimple_call_set_lhs (call, restmp);\n-\t  gcc_assert (useless_type_conversion_p (TREE_TYPE (restmp),\n-\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (alias))));\n-\t}\n-      gsi_insert_after (&bsi, call, GSI_NEW_STMT);\n-      if (!alias_is_noreturn)\n-\t{\n-\t  if (restmp && !this_adjusting\n-\t      && (fixed_offset || virtual_offset))\n-\t    {\n-\t      tree true_label = NULL_TREE;\n-\n-\t      if (TREE_CODE (TREE_TYPE (restmp)) == POINTER_TYPE)\n-\t\t{\n-\t\t  gimple *stmt;\n-\t\t  edge e;\n-\t\t  /* If the return type is a pointer, we need to\n-\t\t     protect against NULL.  We know there will be an\n-\t\t     adjustment, because that's why we're emitting a\n-\t\t     thunk.  */\n-\t\t  then_bb = create_basic_block (NULL, bb);\n-\t\t  then_bb->count = cfg_count - cfg_count.apply_scale (1, 16);\n-\t\t  return_bb = create_basic_block (NULL, then_bb);\n-\t\t  return_bb->count = cfg_count;\n-\t\t  else_bb = create_basic_block (NULL, else_bb);\n-\t\t  else_bb->count = cfg_count.apply_scale (1, 16);\n-\t\t  add_bb_to_loop (then_bb, bb->loop_father);\n-\t\t  add_bb_to_loop (return_bb, bb->loop_father);\n-\t\t  add_bb_to_loop (else_bb, bb->loop_father);\n-\t\t  remove_edge (single_succ_edge (bb));\n-\t\t  true_label = gimple_block_label (then_bb);\n-\t\t  stmt = gimple_build_cond (NE_EXPR, restmp,\n-\t\t\t\t\t    build_zero_cst (TREE_TYPE (restmp)),\n-\t\t\t\t\t    NULL_TREE, NULL_TREE);\n-\t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n-\t\t  e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n-\t\t  e->probability = profile_probability::guessed_always ()\n-\t\t\t\t\t.apply_scale (1, 16);\n-\t\t  e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n-\t\t  e->probability = profile_probability::guessed_always ()\n-\t\t\t\t\t.apply_scale (1, 16);\n-\t\t  make_single_succ_edge (return_bb,\n-\t\t\t\t\t EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-\t\t  make_single_succ_edge (then_bb, return_bb, EDGE_FALLTHRU);\n-\t\t  e = make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n-\t\t  e->probability = profile_probability::always ();\n-\t\t  bsi = gsi_last_bb (then_bb);\n-\t\t}\n-\n-\t      restmp = thunk_adjust (&bsi, restmp, /*this_adjusting=*/0,\n-\t\t\t\t     fixed_offset, virtual_offset,\n-\t\t\t\t     indirect_offset);\n-\t      if (true_label)\n-\t\t{\n-\t\t  gimple *stmt;\n-\t\t  bsi = gsi_last_bb (else_bb);\n-\t\t  stmt = gimple_build_assign (restmp,\n-\t\t\t\t\t      build_zero_cst (TREE_TYPE (restmp)));\n-\t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n-\t\t  bsi = gsi_last_bb (return_bb);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      gimple_call_set_tail (call, true);\n-\t      cfun->tail_call_marked = true;\n-\t    }\n-\n-\t  /* Build return value.  */\n-\t  if (!DECL_BY_REFERENCE (resdecl))\n-\t    ret = gimple_build_return (restmp);\n-\t  else\n-\t    ret = gimple_build_return (resdecl);\n-\n-\t  gsi_insert_after (&bsi, ret, GSI_NEW_STMT);\n-\t}\n-      else\n-\t{\n-\t  gimple_call_set_tail (call, true);\n-\t  cfun->tail_call_marked = true;\n-\t  remove_edge (single_succ_edge (bb));\n-\t}\n-\n-      cfun->gimple_df->in_ssa_p = true;\n-      update_max_bb_count ();\n-      profile_status_for_fn (cfun)\n-        = cfg_count.initialized_p () && cfg_count.ipa_p ()\n-\t  ? PROFILE_READ : PROFILE_GUESSED;\n-      /* FIXME: C++ FE should stop setting TREE_ASM_WRITTEN on thunks.  */\n-      TREE_ASM_WRITTEN (thunk_fndecl) = false;\n-      delete_unreachable_blocks ();\n-      update_ssa (TODO_update_ssa);\n-      checking_verify_flow_info ();\n-      free_dominance_info (CDI_DOMINATORS);\n-\n-      /* Since we want to emit the thunk, we explicitly mark its name as\n-\t referenced.  */\n-      thunk.thunk_p = false;\n-      lowered = true;\n-      bitmap_obstack_release (NULL);\n-    }\n-  current_function_decl = NULL;\n-  set_cfun (NULL);\n-  return true;\n-}\n-\n /* Assemble thunks and aliases associated to node.  */\n \n void\n@@ -2223,13 +1741,13 @@ cgraph_node::assemble_thunks_and_aliases (void)\n   ipa_ref *ref;\n \n   for (e = callers; e;)\n-    if (e->caller->thunk.thunk_p\n+    if (e->caller->thunk\n \t&& !e->caller->inlined_to)\n       {\n \tcgraph_node *thunk = e->caller;\n \n \te = e->next_caller;\n-\tthunk->expand_thunk (true, false);\n+\texpand_thunk (thunk, true, false);\n \tthunk->assemble_thunks_and_aliases ();\n       }\n     else\n@@ -2594,7 +2112,7 @@ output_in_order (void)\n   cgraph_order_sort *node;\n \n   FOR_EACH_DEFINED_FUNCTION (cnode)\n-    if (cnode->process && !cnode->thunk.thunk_p\n+    if (cnode->process && !cnode->thunk\n \t&& !cnode->alias && cnode->no_reorder)\n       nodes.safe_push (cgraph_order_sort (cnode));\n \n@@ -3034,7 +2552,6 @@ cgraphunit_c_finalize (void)\n   gcc_assert (cgraph_new_nodes.length () == 0);\n   cgraph_new_nodes.truncate (0);\n \n-  vtable_entry_type = NULL;\n   queued_nodes = &symtab_terminator;\n \n   first_analyzed = NULL;\n@@ -3064,8 +2581,11 @@ cgraph_node::create_wrapper (cgraph_node *target)\n   /* Turn alias into thunk and expand it into GIMPLE representation.  */\n   definition = true;\n \n-  memset (&thunk, 0, sizeof (cgraph_thunk_info));\n-  thunk.thunk_p = true;\n+  /* Create empty thunk, but be sure we did not keep former thunk around.\n+     In that case we would need to preserve the info.  */\n+  gcc_checking_assert (!thunk_info::get (this));\n+  thunk_info::get_create (this);\n+  thunk = true;\n   create_edge (target, NULL, count);\n   callees->can_throw_external = !TREE_NOTHROW (target->decl);\n \n@@ -3077,11 +2597,10 @@ cgraph_node::create_wrapper (cgraph_node *target)\n       arguments = TREE_CHAIN (arguments);\n     }\n \n-  expand_thunk (false, true);\n+  expand_thunk (this, false, true);\n+  thunk_info::remove (this);\n \n   /* Inline summary set-up.  */\n   analyze ();\n   inline_analyze_function (this);\n }\n-\n-#include \"gt-cgraphunit.h\""}, {"sha": "457894fbe228eae8e96526e31f8bff8ec2cdb56f", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -54,6 +54,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"tree-pretty-print.h\"\n #include \"tree-nested.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n \n #include \"d-tree.h\"\n \n@@ -1702,7 +1705,7 @@ finish_thunk (tree thunk, tree function)\n       if (!stdarg_p (TREE_TYPE (thunk)))\n \t{\n \t  thunk_node->create_edge (funcn, NULL, thunk_node->count);\n-\t  thunk_node->expand_thunk (false, true);\n+\t  expand_thunk (thunk_node, false, true);\n \t}\n \n       /* Tell the back-end to not bother inlining the function, this is"}, {"sha": "dd21ade57956ec6c09f8ba68e2469e6023255035", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -1726,7 +1726,8 @@ open_base_files (void)\n       \"except.h\", \"output.h\",  \"cfgloop.h\", \"target.h\", \"lto-streamer.h\",\n       \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"symbol-summary.h\",\n       \"ipa-prop.h\", \"ipa-fnsummary.h\", \"dwarf2out.h\", \"omp-general.h\",\n-      \"omp-offload.h\", \"ipa-modref-tree.h\", \"ipa-modref.h\", NULL\n+      \"omp-offload.h\", \"ipa-modref-tree.h\", \"ipa-modref.h\", \"symtab-thunks.h\",\n+      NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "350c474d8c61d29f1bde7ef117cd7fb080a98e84", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -128,7 +128,7 @@ propagate_comdat_group (struct symtab_node *symbol,\n \tif (cgraph_node * cn = dyn_cast <cgraph_node *> (symbol2))\n \t  {\n \t    /* Thunks cannot call across section boundary.  */\n-\t    if (cn->thunk.thunk_p)\n+\t    if (cn->thunk)\n \t      newgroup = propagate_comdat_group (symbol2, newgroup, map);\n \t    /* If we see inline clone, its comdat group actually\n \t       corresponds to the comdat group of the function it\n@@ -344,7 +344,7 @@ ipa_comdats (void)\n       if (!symbol->get_comdat_group ()\n \t  && !symbol->alias\n \t  && (!(fun = dyn_cast <cgraph_node *> (symbol))\n-\t      || !fun->thunk.thunk_p)\n+\t      || !fun->thunk)\n \t  && symbol->real_symbol_p ())\n \t{\n \t  tree *val = map.get (symbol);"}, {"sha": "f981366a345a20c7d3aaa2afca4e78301ed31807", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -595,7 +595,7 @@ determine_versionability (struct cgraph_node *node,\n   /* There are a number of generic reasons functions cannot be versioned.  We\n      also cannot remove parameters if there are type attributes such as fnspec\n      present.  */\n-  if (node->alias || node->thunk.thunk_p)\n+  if (node->alias || node->thunk)\n     reason = \"alias or thunk\";\n   else if (!node->versionable)\n     reason = \"not a tree_versionable_function\";\n@@ -646,7 +646,7 @@ determine_versionability (struct cgraph_node *node,\n \t    reason = \"external function which calls va_arg_pack_len\";\n         }\n \n-  if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n+  if (reason && dump_file && !node->alias && !node->thunk)\n     fprintf (dump_file, \"Function %s is not versionable, reason: %s.\\n\",\n \t     node->dump_name (), reason);\n \n@@ -691,7 +691,7 @@ gather_caller_stats (struct cgraph_node *node, void *data)\n   struct cgraph_edge *cs;\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (!cs->caller->thunk.thunk_p)\n+    if (!cs->caller->thunk)\n       {\n         if (cs->count.ipa ().initialized_p ())\n \t  stats->count_sum += cs->count.ipa ();\n@@ -1155,7 +1155,7 @@ count_callers (cgraph_node *node, void *data)\n   for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n     /* Local thunks can be handled transparently, but if the thunk cannot\n        be optimized out, count it as a real use.  */\n-    if (!cs->caller->thunk.thunk_p || !cs->caller->local)\n+    if (!cs->caller->thunk || !cs->caller->local)\n       ++*caller_count;\n   return false;\n }\n@@ -1168,7 +1168,7 @@ set_single_call_flag (cgraph_node *node, void *)\n {\n   cgraph_edge *cs = node->callers;\n   /* Local thunks can be handled transparently, skip them.  */\n-  while (cs && cs->caller->thunk.thunk_p && cs->caller->local)\n+  while (cs && cs->caller->thunk && cs->caller->local)\n     cs = cs->next_caller;\n   if (cs && IPA_NODE_REF (cs->caller))\n     {\n@@ -1215,7 +1215,7 @@ initialize_node_lattices (struct cgraph_node *node)\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS)\n-      && !node->alias && !node->thunk.thunk_p)\n+      && !node->alias && !node->thunk)\n     {\n       fprintf (dump_file, \"Initializing lattices of %s\\n\",\n \t       node->dump_name ());\n@@ -1240,7 +1240,7 @@ initialize_node_lattices (struct cgraph_node *node)\n       node->clone.param_adjustments->get_surviving_params (&surviving_params);\n \n       if (dump_file && (dump_flags & TDF_DETAILS)\n-\t  && !node->alias && !node->thunk.thunk_p)\n+\t  && !node->alias && !node->thunk)\n \t{\n \t  bool first = true;\n \t  for (int j = 0; j < ipa_get_param_count (info); j++)\n@@ -2806,12 +2806,12 @@ propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n    non-thunk) destination, the call passes through a thunk.  */\n \n static bool\n-call_passes_through_thunk_p (cgraph_edge *cs)\n+call_passes_through_thunk (cgraph_edge *cs)\n {\n   cgraph_node *alias_or_thunk = cs->callee;\n   while (alias_or_thunk->alias)\n     alias_or_thunk = alias_or_thunk->get_alias_target ();\n-  return alias_or_thunk->thunk.thunk_p;\n+  return alias_or_thunk->thunk;\n }\n \n /* Propagate constants from the caller to the callee of CS.  INFO describes the\n@@ -2853,7 +2853,7 @@ propagate_constants_across_call (struct cgraph_edge *cs)\n   /* If this call goes through a thunk we must not propagate to the first (0th)\n      parameter.  However, we might need to uncover a thunk from below a series\n      of aliases first.  */\n-  if (call_passes_through_thunk_p (cs))\n+  if (call_passes_through_thunk (cs))\n     {\n       ret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info,\n \t\t\t\t\t\t\t       0));\n@@ -4698,7 +4698,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t  if (!IPA_EDGE_REF (cs)\n \t      || i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n \t      || (i == 0\n-\t\t  && call_passes_through_thunk_p (cs)))\n+\t\t  && call_passes_through_thunk (cs)))\n \t    {\n \t      newval = NULL_TREE;\n \t      break;\n@@ -5661,7 +5661,7 @@ has_undead_caller_from_outside_scc_p (struct cgraph_node *node,\n   struct cgraph_edge *cs;\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (cs->caller->thunk.thunk_p\n+    if (cs->caller->thunk\n \t&& cs->caller->call_for_symbol_thunks_and_aliases\n \t  (has_undead_caller_from_outside_scc_p, NULL, true))\n       return true;"}, {"sha": "f27c5f07fa7ed2b42c3819e4355be605e4308695", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -699,7 +699,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t       }\n \t  }\n \telse\n-\t  gcc_assert (!count || callee->thunk.thunk_p);\n+\t  gcc_assert (!count || callee->thunk);\n     }\n   else if (e->call_stmt && !e->call_stmt_cannot_inline_p && info->conds)\n     {\n@@ -3051,12 +3051,12 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n   class ipa_size_summary *size_info = ipa_size_summaries->get_create (node);\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n-  self_stack_size = optimize && !node->thunk.thunk_p\n+  self_stack_size = optimize && !node->thunk\n \t\t    ? estimated_stack_frame_size (node) : 0;\n   size_info->estimated_self_stack_size = self_stack_size;\n   info->estimated_stack_size = self_stack_size;\n \n-  if (node->thunk.thunk_p)\n+  if (node->thunk)\n     {\n       ipa_call_summary *es = ipa_call_summaries->get_create (node->callees);\n       predicate t = true;\n@@ -4221,7 +4221,7 @@ inline_analyze_function (struct cgraph_node *node)\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nAnalyzing function: %s\\n\", node->dump_name ());\n-  if (opt_for_fn (node->decl, optimize) && !node->thunk.thunk_p)\n+  if (opt_for_fn (node->decl, optimize) && !node->thunk)\n     inline_indirect_intraprocedural_analysis (node);\n   compute_fn_summary (node, false);\n   if (!optimize)"}, {"sha": "8cae076b3cef806008c280d061dca483c003b6b3", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"dbgcnt.h\"\n #include \"tree-vector-builder.h\"\n+#include \"symtab-thunks.h\"\n \n using namespace ipa_icf_gimple;\n \n@@ -530,22 +531,14 @@ sem_function::equals_wpa (sem_item *item,\n \n   m_compared_func = static_cast<sem_function *> (item);\n \n-  if (cnode->thunk.thunk_p != cnode2->thunk.thunk_p)\n-    return return_false_with_msg (\"thunk_p mismatch\");\n+  if (cnode->thunk != cnode2->thunk)\n+    return return_false_with_msg (\"thunk mismatch\");\n+  if (cnode->former_thunk_p () != cnode2->former_thunk_p ())\n+    return return_false_with_msg (\"former_thunk_p mismatch\");\n \n-  if (cnode->thunk.thunk_p)\n-    {\n-      if (cnode->thunk.fixed_offset != cnode2->thunk.fixed_offset)\n-        return return_false_with_msg (\"thunk fixed_offset mismatch\");\n-      if (cnode->thunk.virtual_value != cnode2->thunk.virtual_value)\n-        return return_false_with_msg (\"thunk virtual_value mismatch\");\n-      if (cnode->thunk.indirect_offset != cnode2->thunk.indirect_offset)\n-        return return_false_with_msg (\"thunk indirect_offset mismatch\");\n-      if (cnode->thunk.this_adjusting != cnode2->thunk.this_adjusting)\n-        return return_false_with_msg (\"thunk this_adjusting mismatch\");\n-      if (cnode->thunk.virtual_offset_p != cnode2->thunk.virtual_offset_p)\n-        return return_false_with_msg (\"thunk virtual_offset_p mismatch\");\n-    }\n+  if ((cnode->thunk || cnode->former_thunk_p ())\n+      && thunk_info::get (cnode) != thunk_info::get (cnode2))\n+    return return_false_with_msg (\"thunk_info mismatch\");\n \n   /* Compare special function DECL attributes.  */\n   if (DECL_FUNCTION_PERSONALITY (decl)\n@@ -968,7 +961,7 @@ redirect_all_callers (cgraph_node *n, cgraph_node *to)\n       /* Redirecting thunks to interposable symbols or symbols in other sections\n \t may not be supported by target output code.  Play safe for now and\n \t punt on redirection.  */\n-      if (!e->caller->thunk.thunk_p)\n+      if (!e->caller->thunk)\n \t{\n \t  struct cgraph_edge *nexte = e->next_caller;\n           e->redirect_callee (to);\n@@ -1362,7 +1355,7 @@ sem_function::init (ipa_icf_gimple::func_checker *checker)\n \n   edge_count = n_edges_for_fn (func);\n   cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n-  if (!cnode->thunk.thunk_p)\n+  if (!cnode->thunk)\n     {\n       cfg_checksum = coverage_compute_cfg_checksum (func);\n \n@@ -1407,12 +1400,7 @@ sem_function::init (ipa_icf_gimple::func_checker *checker)\n   else\n     {\n       cfg_checksum = 0;\n-      inchash::hash hstate;\n-      hstate.add_hwi (cnode->thunk.fixed_offset);\n-      hstate.add_hwi (cnode->thunk.virtual_value);\n-      hstate.add_flag (cnode->thunk.this_adjusting);\n-      hstate.add_flag (cnode->thunk.virtual_offset_p);\n-      gcode_hash = hstate.end ();\n+      gcode_hash = thunk_info::get (cnode)->hash ();\n     }\n \n   m_checker = NULL;\n@@ -1494,7 +1482,7 @@ sem_function::parse (cgraph_node *node, bitmap_obstack *stack,\n   tree fndecl = node->decl;\n   function *func = DECL_STRUCT_FUNCTION (fndecl);\n \n-  if (!func || (!node->has_gimple_body_p () && !node->thunk.thunk_p))\n+  if (!func || (!node->has_gimple_body_p () && !node->thunk))\n     return NULL;\n \n   if (lookup_attribute_by_prefix (\"omp \", DECL_ATTRIBUTES (node->decl)) != NULL)"}, {"sha": "3782cce12e34aa40b4d1a5cb64dc95c8a00b095c", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"ipa-modref-tree.h\"\n #include \"ipa-modref.h\"\n+#include \"symtab-thunks.h\"\n \n int ncalls_inlined;\n int nfunctions_inlined;\n@@ -353,14 +354,18 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   to = e->caller;\n   if (to->inlined_to)\n     to = to->inlined_to;\n-  if (to->thunk.thunk_p)\n+  if (to->thunk)\n     {\n       struct cgraph_node *target = to->callees->callee;\n       thunk_expansion = true;\n+\n+      /* Remove all annotations, but keep thunk info.  */\n+      thunk_info info = *thunk_info::get (to);\n       symtab->call_cgraph_removal_hooks (to);\n+      *thunk_info::get_create (to) = info;\n       if (in_lto_p)\n \tto->get_untransformed_body ();\n-      to->expand_thunk (false, true);\n+      expand_thunk (to, false, true);\n       /* When thunk is instrumented we may have multiple callees.  */\n       for (e = to->callees; e && e->callee != target; e = e->next_callee)\n \t;\n@@ -564,9 +569,9 @@ save_inline_function_body (struct cgraph_node *node)\n   first_clone = node->clones;\n \n   /* Arrange first clone to not be thunk as those do not have bodies.  */\n-  if (first_clone->thunk.thunk_p)\n+  if (first_clone->thunk)\n     {\n-      while (first_clone->thunk.thunk_p)\n+      while (first_clone->thunk)\n         first_clone = first_clone->next_sibling_clone;\n       first_clone->prev_sibling_clone->next_sibling_clone\n \t= first_clone->next_sibling_clone;\n@@ -673,11 +678,11 @@ static bool\n preserve_function_body_p (struct cgraph_node *node)\n {\n   gcc_assert (symtab->global_info_ready);\n-  gcc_assert (!node->alias && !node->thunk.thunk_p);\n+  gcc_assert (!node->alias && !node->thunk);\n \n   /* Look if there is any non-thunk clone around.  */\n   for (node = node->clones; node; node = node->next_sibling_clone)\n-    if (!node->thunk.thunk_p)\n+    if (!node->thunk)\n       return true;\n   return false;\n }"}, {"sha": "8db23457daee947446836a32d670a8afa3ed087c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -1947,7 +1947,7 @@ inline_small_functions (void)\n     if (!node->inlined_to)\n       {\n \tif (!node->alias && node->analyzed\n-\t    && (node->has_gimple_body_p () || node->thunk.thunk_p)\n+\t    && (node->has_gimple_body_p () || node->thunk)\n \t    && opt_for_fn (node->decl, optimize))\n \t  {\n \t    class ipa_fn_summary *info = ipa_fn_summaries->get (node);"}, {"sha": "326aef7fd6a072b5613b855ab0cb7911f2bab1aa", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -38,6 +38,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-into-ssa.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n \n /* Return true when TYPE contains an polymorphic type and thus is interesting\n    for devirtualization machinery.  */\n@@ -1007,8 +1010,9 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t     Because we walked all the way to the beginning of thunk, we now\n \t     see pointer &bar-thunk.fixed_offset and need to compensate\n \t     for it.  */\n-\t  if (node->thunk.fixed_offset)\n-\t    offset -= node->thunk.fixed_offset * BITS_PER_UNIT;\n+\t  thunk_info *info = thunk_info::get (node);\n+\t  if (info && info->fixed_offset)\n+\t    offset -= info->fixed_offset * BITS_PER_UNIT;\n \n \t  /* Dynamic casting has possibly upcasted the type\n \t     in the hierarchy.  In this case outer type is less\n@@ -1021,7 +1025,7 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t      /* If we compile thunk with virtual offset, the THIS pointer\n \t\t is adjusted by unknown value.  We can't thus use outer info\n \t\t at all.  */\n-\t      || node->thunk.virtual_offset_p)\n+\t      || (info && info->virtual_offset_p))\n \t    {\n \t      outer_type = NULL;\n \t      if (instance)\n@@ -1047,10 +1051,10 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t    }\n \t  if (instance)\n \t    {\n+\t      thunk_info *info = thunk_info::get (node);\n \t      /* If method is expanded thunk, we need to apply thunk offset\n \t\t to instance pointer.  */\n-\t      if (node->thunk.virtual_offset_p\n-\t\t  || node->thunk.fixed_offset)\n+\t      if (info && (info->virtual_offset_p || info->fixed_offset))\n \t\t*instance = NULL;\n \t      else\n \t        *instance = base_pointer;"}, {"sha": "054f35981a5d21ffbbbec105307a8f6b432d6096", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"symbol-summary.h\"\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n+#include \"symtab-thunks.h\"\n \n /* Lattice values for const and pure functions.  Everything starts out\n    being const, then may drop to pure and then neither depending on\n@@ -1025,11 +1026,11 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t\t    flags_from_decl_or_type (fn->decl),\n \t\t    fn->cannot_return_p ());\n \n-  if (fn->thunk.thunk_p || fn->alias)\n+  if (fn->thunk || fn->alias)\n     {\n       /* Thunk gets propagated through, so nothing interesting happens.  */\n       gcc_assert (ipa);\n-      if (fn->thunk.thunk_p && fn->thunk.virtual_offset_p)\n+      if (fn->thunk && thunk_info::get (fn)->virtual_offset_p)\n \tl->pure_const_state = IPA_NEITHER;\n       return l;\n     }"}, {"sha": "8d4f580e00959e17050144ccfd1d52007ac57286", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -2935,7 +2935,7 @@ check_for_caller_issues (struct cgraph_node *node, void *data)\n \n   for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n     {\n-      if (cs->caller->thunk.thunk_p)\n+      if (cs->caller->thunk)\n \t{\n \t  issues->thunk = true;\n \t  /* TODO: We should be able to process at least some types of"}, {"sha": "2945380f20adafa99cd857b0745a8741001e0209", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -297,7 +297,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t  && (pass\n \t      || (!node->address_taken\n \t\t  && !node->inlined_to\n-\t\t  && !node->alias && !node->thunk.thunk_p\n+\t\t  && !node->alias && !node->thunk\n \t\t  && !node->only_called_directly_p ())))\n \t{\n \t  stack_size = 0;\n@@ -460,8 +460,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n     }\n \n   /* First handle functions with no gimple body.  */\n-  if (dst->thunk.thunk_p || dst->alias\n-      || src->thunk.thunk_p || src->alias)\n+  if (dst->thunk || dst->alias\n+      || src->thunk || src->alias)\n     {\n       scale_ipa_profile_for_fn (dst, orig_count);\n       return;"}, {"sha": "97d93889c86bafa7a654d3f38b3afca266afc081", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -95,7 +95,7 @@ non_local_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   return !(node->only_called_directly_or_aliased_p ()\n \t   /* i386 would need update to output thunk with local calling\n \t      conventions.  */\n-\t   && !node->thunk.thunk_p\n+\t   && !node->thunk\n \t   && node->definition\n \t   && !DECL_EXTERNAL (node->decl)\n \t   && !lookup_attribute (\"noipa\", DECL_ATTRIBUTES (node->decl))\n@@ -112,7 +112,7 @@ cgraph_node::local_p (void)\n {\n    cgraph_node *n = ultimate_alias_target ();\n \n-   if (n->thunk.thunk_p)\n+   if (n->thunk)\n      return n->callees->callee->local_p ();\n    return !n->call_for_symbol_thunks_and_aliases (non_local_p,\n \t\t\t\t\t\t  NULL, true);\n@@ -729,7 +729,7 @@ function_and_variable_visibility (bool whole_program)\n \t  && !DECL_EXTERNAL (node->decl))\n \tlocalize_node (whole_program, node);\n \n-      if (node->thunk.thunk_p\n+      if (node->thunk\n \t  && TREE_PUBLIC (node->decl))\n \t{\n \t  struct cgraph_node *decl_node = node;"}, {"sha": "cd0facf9956e4a28be58f17c657518e2b8fbaff0", "filename": "gcc/ipa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -475,7 +475,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t\t}\n \n \t    }\n-\t  else if (cnode->thunk.thunk_p)\n+\t  else if (cnode->thunk)\n \t    enqueue_node (cnode->callees->callee, &first, &reachable);\n \n \t  /* If any reachable function has simd clones, mark them as\n@@ -525,7 +525,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t  /* We keep definitions of thunks and aliases in the boundary so\n \t     we can walk to the ultimate alias targets and function symbols\n \t     reliably.  */\n-\t  if (node->alias || node->thunk.thunk_p)\n+\t  if (node->alias || node->thunk)\n \t    ;\n \t  else if (!body_needed_for_clonning.contains (node->decl))\n \t    {\n@@ -537,7 +537,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t    }\n \t  else if (!node->clone_of)\n \t    gcc_assert (in_lto_p || DECL_RESULT (node->decl));\n-\t  if (node->definition && !node->alias && !node->thunk.thunk_p)\n+\t  if (node->definition && !node->alias && !node->thunk)\n \t    {\n \t      if (file)\n \t\tfprintf (file, \" %s\", node->dump_name ());\n@@ -547,7 +547,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t      node->cpp_implicit_alias = false;\n \t      node->alias = false;\n \t      node->transparent_alias = false;\n-\t      node->thunk.thunk_p = false;\n+\t      node->thunk = false;\n \t      node->weakref = false;\n \t      /* After early inlining we drop always_inline attributes on\n \t\t bodies of functions that are still referenced (have their"}, {"sha": "19d4ca54e92d665a7e591b818d1b775f551f3755", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -39,6 +39,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-offload.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n \n /* True when asm nodes has been output.  */\n bool asm_nodes_output = false;\n@@ -261,7 +264,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n \t\t\t : gimple_uid (edge->call_stmt) + 1;\n   bp_pack_enum (&bp, cgraph_inline_failed_t,\n \t        CIF_N_REASONS, edge->inline_failed);\n-  gcc_checking_assert (uid || edge->caller->thunk.thunk_p);\n+  gcc_checking_assert (uid || edge->caller->thunk);\n   bp_pack_var_len_unsigned (&bp, uid);\n   bp_pack_value (&bp, edge->speculative_id, 16);\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n@@ -393,7 +396,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n \n   if (node->analyzed && (!boundary_p || node->alias\n-\t\t\t || (node->thunk.thunk_p && !node->inlined_to)))\n+\t\t\t || (node->thunk && !node->inlined_to)))\n     tag = LTO_symtab_analyzed_node;\n   else\n     tag = LTO_symtab_unavail_node;\n@@ -533,10 +536,19 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->nonfreeing_fn, 1);\n   bp_pack_value (&bp, node->merged_comdat, 1);\n   bp_pack_value (&bp, node->merged_extern_inline, 1);\n-  bp_pack_value (&bp, node->thunk.thunk_p, 1);\n+  bp_pack_value (&bp, node->thunk, 1);\n   bp_pack_value (&bp, node->parallelized_function, 1);\n   bp_pack_value (&bp, node->declare_variant_alt, 1);\n   bp_pack_value (&bp, node->calls_declare_variant_alt, 1);\n+\n+  /* Stream thunk info always because we use it in\n+     ipa_polymorphic_call_context::ipa_polymorphic_call_context\n+     to properly interpret THIS pointers for thunks that has been converted\n+     to Gimple.  */\n+  struct thunk_info *thunk = node->definition ? thunk_info::get (node) : NULL;\n+\n+  bp_pack_value (&bp, thunk != NULL, 1);\n+\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN,\n \t\t/* When doing incremental link, we will get new resolution\n@@ -546,26 +558,15 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   streamer_write_bitpack (&bp);\n   streamer_write_data_stream (ob->main_stream, section, strlen (section) + 1);\n \n-  /* Stream thunk info always because we use it in\n-     ipa_polymorphic_call_context::ipa_polymorphic_call_context\n-     to properly interpret THIS pointers for thunks that has been converted\n-     to Gimple.  */\n-  if (node->definition)\n-    {\n-      streamer_write_uhwi_stream\n-\t (ob->main_stream,\n-\t  1 + (node->thunk.this_adjusting != 0) * 2\n-\t  + (node->thunk.virtual_offset_p != 0) * 4);\n-      streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n-      streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n-      streamer_write_uhwi_stream (ob->main_stream, node->thunk.indirect_offset);\n-    }\n   streamer_write_hwi_stream (ob->main_stream, node->profile_id);\n   streamer_write_hwi_stream (ob->main_stream, node->unit_id);\n   if (DECL_STATIC_CONSTRUCTOR (node->decl))\n     streamer_write_hwi_stream (ob->main_stream, node->get_init_priority ());\n   if (DECL_STATIC_DESTRUCTOR (node->decl))\n     streamer_write_hwi_stream (ob->main_stream, node->get_fini_priority ());\n+\n+  if (thunk)\n+    thunk_info::get (node)->stream_out (ob);\n }\n \n /* Output the varpool NODE to OB. \n@@ -931,7 +932,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       if (node->alias && node->analyzed)\n \tcreate_references (encoder, node);\n       if (cnode\n-\t  && cnode->thunk.thunk_p && !cnode->inlined_to)\n+\t  && cnode->thunk && !cnode->inlined_to)\n \tadd_node_to (encoder, cnode->callees->callee, false);\n       while (node->transparent_alias && node->analyzed)\n \t{\n@@ -987,7 +988,7 @@ output_symtab (void)\n     {\n       node = dyn_cast <cgraph_node *> (lto_symtab_encoder_deref (encoder, i));\n       if (node\n-\t  && ((node->thunk.thunk_p && !node->inlined_to)\n+\t  && ((node->thunk && !node->inlined_to)\n \t      || lto_symtab_encoder_in_partition_p (encoder, node)))\n \t{\n \t  output_outgoing_cgraph_edges (node->callees, ob, encoder);\n@@ -1139,13 +1140,14 @@ verify_node_partition (symtab_node *node)\n    NODE or to replace the values in it, for instance because the first\n    time we saw it, the function body was not available but now it\n    is.  BP is a bitpack with all the bitflags for NODE read from the\n-   stream.  */\n+   stream.  Initialize HAS_THUNK_INFO to indicate if thunk info should\n+   be streamed in.  */\n \n static void\n input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t      struct cgraph_node *node,\n \t\t      enum LTO_symtab_tags tag,\n-\t\t      struct bitpack_d *bp)\n+\t\t      struct bitpack_d *bp, bool *has_thunk_info)\n {\n   node->aux = (void *) tag;\n   node->lto_file_data = file_data;\n@@ -1194,10 +1196,11 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->nonfreeing_fn = bp_unpack_value (bp, 1);\n   node->merged_comdat = bp_unpack_value (bp, 1);\n   node->merged_extern_inline = bp_unpack_value (bp, 1);\n-  node->thunk.thunk_p = bp_unpack_value (bp, 1);\n+  node->thunk = bp_unpack_value (bp, 1);\n   node->parallelized_function = bp_unpack_value (bp, 1);\n   node->declare_variant_alt = bp_unpack_value (bp, 1);\n   node->calls_declare_variant_alt = bp_unpack_value (bp, 1);\n+  *has_thunk_info = bp_unpack_value (bp, 1);\n   node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);\n   node->split_part = bp_unpack_value (bp, 1);\n@@ -1235,6 +1238,7 @@ input_node (struct lto_file_decl_data *file_data,\n   const char *section;\n   order = streamer_read_hwi (ib) + file_data->order_base;\n   clone_ref = streamer_read_hwi (ib);\n+  bool has_thunk_info;\n \n   fn_decl = lto_input_fn_decl_ref (ib, file_data);\n \n@@ -1294,7 +1298,7 @@ input_node (struct lto_file_decl_data *file_data,\n \n   bp = streamer_read_bitpack (ib);\n \n-  input_overwrite_node (file_data, node, tag, &bp);\n+  input_overwrite_node (file_data, node, tag, &bp, &has_thunk_info);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->inlined_to = (cgraph_node *) (intptr_t) ref;\n@@ -1311,19 +1315,6 @@ input_node (struct lto_file_decl_data *file_data,\n   if (section)\n     node->set_section_for_node (section);\n \n-  if (node->definition)\n-    {\n-      int type = streamer_read_uhwi (ib);\n-      HOST_WIDE_INT fixed_offset = streamer_read_uhwi (ib);\n-      HOST_WIDE_INT virtual_value = streamer_read_uhwi (ib);\n-      HOST_WIDE_INT indirect_offset = streamer_read_uhwi (ib);\n-\n-      node->thunk.fixed_offset = fixed_offset;\n-      node->thunk.virtual_value = virtual_value;\n-      node->thunk.indirect_offset = indirect_offset;\n-      node->thunk.this_adjusting = (type & 2);\n-      node->thunk.virtual_offset_p = (type & 4);\n-    }\n   if (node->alias && !node->analyzed && node->weakref)\n     node->alias_target = get_alias_symbol (node->decl);\n   node->profile_id = streamer_read_hwi (ib);\n@@ -1335,6 +1326,9 @@ input_node (struct lto_file_decl_data *file_data,\n   if (DECL_STATIC_DESTRUCTOR (node->decl))\n     node->set_fini_priority (streamer_read_hwi (ib));\n \n+  if (has_thunk_info)\n+    thunk_info::get_create (node)->stream_in (ib);\n+\n   return node;\n }\n "}, {"sha": "64037f74ad36f9387d72ce0a12129b83da8b976a", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -1232,12 +1232,12 @@ fixup_call_stmt_edges (struct cgraph_node *orig, gimple **stmts)\n     orig = orig->clone_of;\n   fn = DECL_STRUCT_FUNCTION (orig->decl);\n \n-  if (!orig->thunk.thunk_p)\n+  if (!orig->thunk)\n     fixup_call_stmt_edges_1 (orig, stmts, fn);\n   if (orig->clones)\n     for (node = orig->clones; node != orig;)\n       {\n-\tif (!node->thunk.thunk_p)\n+\tif (!node->thunk)\n \t  fixup_call_stmt_edges_1 (node, stmts, fn);\n \tif (node->clones)\n \t  node = node->clones;"}, {"sha": "7c15181f66f901f80741f760bf216cd7b7d7f698", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -181,7 +181,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n \n       /* Add all thunks associated with the function.  */\n       for (e = cnode->callers; e; e = e->next_caller)\n-\tif (e->caller->thunk.thunk_p && !e->caller->inlined_to)\n+\tif (e->caller->thunk && !e->caller->inlined_to)\n \t  add_symbol_to_partition_1 (part, e->caller);\n     }\n "}, {"sha": "1a4aaa2d80b6fa4c8a214a7a1b2870afa33e70c0", "filename": "gcc/symtab-thunks.cc", "status": "added", "additions": 639, "deletions": 0, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fsymtab-thunks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fsymtab-thunks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab-thunks.cc?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -0,0 +1,639 @@\n+/* Support for thunks in symbol table.\n+   Copyright (C) 2003-2020 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"predict.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"alloc-pool.h\"\n+#include \"cgraph.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n+#include \"lto-streamer.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-iterator.h\"\n+#include \"stor-layout.h\"\n+#include \"gimplify-me.h\"\n+#include \"varasm.h\"\n+#include \"output.h\"\n+#include \"cfg.h\"\n+#include \"cfghooks.h\"\n+#include \"gimple-ssa.h\"\n+#include \"gimple-fold.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"tree-cfg.h\"\n+#include \"cfgcleanup.h\"\n+#include \"tree-pass.h\"\n+#include \"data-streamer.h\"\n+#include \"langhooks.h\"\n+\n+/* Used for vtable lookup in thunk adjusting.  */\n+static GTY (()) tree vtable_entry_type;\n+\n+namespace {\n+\n+/* Function summary for thunk_infos.  */\n+class GTY((user)) thunk_infos_t: public function_summary <thunk_info *>\n+{\n+public:\n+  thunk_infos_t (symbol_table *table, bool ggc):\n+    function_summary<thunk_info *> (table, ggc) { }\n+\n+  /* Hook that is called by summary when a node is duplicated.  */\n+  virtual void duplicate (cgraph_node *node,\n+\t\t\t  cgraph_node *node2,\n+\t\t\t  thunk_info *data,\n+\t\t\t  thunk_info *data2);\n+};\n+\n+/* Duplication hook.  */\n+void\n+thunk_infos_t::duplicate (cgraph_node *, cgraph_node *,\n+\t\t\t  thunk_info *src, thunk_info *dst)\n+{\n+  *dst = *src;\n+}\n+\n+}  /* anon namespace  */\n+\n+/* Return thunk_info possibly creating new one.  */\n+thunk_info *\n+thunk_info::get_create (cgraph_node *node)\n+{\n+  if (!symtab->m_thunks)\n+    {\n+      symtab->m_thunks\n+\t = new (ggc_alloc_no_dtor <thunk_infos_t> ())\n+\t     thunk_infos_t (symtab, true);\n+      symtab->m_thunks->disable_insertion_hook ();\n+    }\n+  return symtab->m_thunks->get_create (node);\n+}\n+\n+/* Stream out THIS to OB.  */\n+void\n+thunk_info::stream_out (lto_simple_output_block *ob)\n+{\n+  streamer_write_uhwi_stream\n+     (ob->main_stream,\n+      1 + (this_adjusting != 0) * 2\n+      + (virtual_offset_p != 0) * 4);\n+  streamer_write_uhwi_stream (ob->main_stream, fixed_offset);\n+  streamer_write_uhwi_stream (ob->main_stream, virtual_value);\n+  streamer_write_uhwi_stream (ob->main_stream, indirect_offset);\n+}\n+\n+/* Stream in THIS from IB.  */\n+void\n+thunk_info::stream_in (class lto_input_block *ib)\n+{\n+  int type = streamer_read_uhwi (ib);\n+  fixed_offset = streamer_read_uhwi (ib);\n+  virtual_value = streamer_read_uhwi (ib);\n+  indirect_offset = streamer_read_uhwi (ib);\n+\n+  this_adjusting = (type & 2);\n+  virtual_offset_p = (type & 4);\n+}\n+\n+/* Dump THIS to F.  */\n+void\n+thunk_info::dump (FILE *f)\n+{\n+  if (alias)\n+    fprintf (f, \"  of %s (asm:%s)\",\n+\t     lang_hooks.decl_printable_name (alias, 2),\n+\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (alias)));\n+  fprintf (f, \" fixed offset %i virtual value %i indirect_offset %i \"\n+\t      \"has virtual offset %i\\n\",\n+\t   (int)fixed_offset,\n+\t   (int)virtual_value,\n+\t   (int)indirect_offset,\n+\t   (int)virtual_offset_p);\n+}\n+\n+/* Hash THIS.  */\n+hashval_t\n+thunk_info::hash ()\n+{\n+  inchash::hash hstate;\n+  hstate.add_hwi (fixed_offset);\n+  hstate.add_hwi (virtual_value);\n+  hstate.add_flag (this_adjusting);\n+  hstate.add_flag (virtual_offset_p);\n+  return hstate.end ();\n+}\n+\n+/* Adjust PTR by the constant FIXED_OFFSET, by the vtable offset indicated by\n+   VIRTUAL_OFFSET, and by the indirect offset indicated by INDIRECT_OFFSET, if\n+   it is non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and zero\n+   for a result adjusting thunk.  */\n+tree\n+thunk_adjust (gimple_stmt_iterator * bsi,\n+\t      tree ptr, bool this_adjusting,\n+\t      HOST_WIDE_INT fixed_offset, tree virtual_offset,\n+\t      HOST_WIDE_INT indirect_offset)\n+{\n+  gassign *stmt;\n+  tree ret;\n+\n+  if (this_adjusting\n+      && fixed_offset != 0)\n+    {\n+      stmt = gimple_build_assign\n+\t\t(ptr, fold_build_pointer_plus_hwi_loc (input_location,\n+\t\t\t\t\t\t       ptr,\n+\t\t\t\t\t\t       fixed_offset));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+    }\n+\n+  if (!vtable_entry_type && (virtual_offset || indirect_offset != 0))\n+    {\n+      tree vfunc_type = make_node (FUNCTION_TYPE);\n+      TREE_TYPE (vfunc_type) = integer_type_node;\n+      TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n+      layout_type (vfunc_type);\n+\n+      vtable_entry_type = build_pointer_type (vfunc_type);\n+    }\n+\n+  /* If there's a virtual offset, look up that value in the vtable and\n+     adjust the pointer again.  */\n+  if (virtual_offset)\n+    {\n+      tree vtabletmp;\n+      tree vtabletmp2;\n+      tree vtabletmp3;\n+\n+      vtabletmp = create_tmp_reg\n+\t\t    (build_pointer_type\n+\t\t\t  (build_pointer_type (vtable_entry_type)), \"vptr\");\n+\n+      /* The vptr is always at offset zero in the object.  */\n+      stmt = gimple_build_assign (vtabletmp,\n+\t\t\t\t  build1 (NOP_EXPR, TREE_TYPE (vtabletmp),\n+\t\t\t\t\t  ptr));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Form the vtable address.  */\n+      vtabletmp2 = create_tmp_reg (TREE_TYPE (TREE_TYPE (vtabletmp)),\n+\t\t\t\t     \"vtableaddr\");\n+      stmt = gimple_build_assign (vtabletmp2,\n+\t\t\t\t  build_simple_mem_ref (vtabletmp));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Find the entry with the vcall offset.  */\n+      stmt = gimple_build_assign (vtabletmp2,\n+\t\t\t\t  fold_build_pointer_plus_loc (input_location,\n+\t\t\t\t\t\t\t       vtabletmp2,\n+\t\t\t\t\t\t\t       virtual_offset));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Get the offset itself.  */\n+      vtabletmp3 = create_tmp_reg (TREE_TYPE (TREE_TYPE (vtabletmp2)),\n+\t\t\t\t     \"vcalloffset\");\n+      stmt = gimple_build_assign (vtabletmp3,\n+\t\t\t\t  build_simple_mem_ref (vtabletmp2));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Adjust the `this' pointer.  */\n+      ptr = fold_build_pointer_plus_loc (input_location, ptr, vtabletmp3);\n+      ptr = force_gimple_operand_gsi (bsi, ptr, true, NULL_TREE, false,\n+\t\t\t\t      GSI_CONTINUE_LINKING);\n+    }\n+\n+  /* Likewise for an offset that is stored in the object that contains the\n+     vtable.  */\n+  if (indirect_offset != 0)\n+    {\n+      tree offset_ptr, offset_tree;\n+\n+      /* Get the address of the offset.  */\n+      offset_ptr\n+\t= create_tmp_reg (build_pointer_type\n+\t\t\t  (build_pointer_type (vtable_entry_type)),\n+\t\t\t  \"offset_ptr\");\n+      stmt = gimple_build_assign (offset_ptr,\n+\t\t\t\t  build1 (NOP_EXPR, TREE_TYPE (offset_ptr),\n+\t\t\t\t\t  ptr));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      stmt = gimple_build_assign\n+\t     (offset_ptr,\n+\t      fold_build_pointer_plus_hwi_loc (input_location, offset_ptr,\n+\t\t\t\t\t       indirect_offset));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Get the offset itself.  */\n+      offset_tree = create_tmp_reg (TREE_TYPE (TREE_TYPE (offset_ptr)),\n+\t\t\t\t    \"offset\");\n+      stmt = gimple_build_assign (offset_tree,\n+\t\t\t\t  build_simple_mem_ref (offset_ptr));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Adjust the `this' pointer.  */\n+      ptr = fold_build_pointer_plus_loc (input_location, ptr, offset_tree);\n+      ptr = force_gimple_operand_gsi (bsi, ptr, true, NULL_TREE, false,\n+\t\t\t\t      GSI_CONTINUE_LINKING);\n+    }\n+\n+  if (!this_adjusting\n+      && fixed_offset != 0)\n+    /* Adjust the pointer by the constant.  */\n+    {\n+      tree ptrtmp;\n+\n+      if (VAR_P (ptr))\n+\tptrtmp = ptr;\n+      else\n+\t{\n+\t  ptrtmp = create_tmp_reg (TREE_TYPE (ptr), \"ptr\");\n+\t  stmt = gimple_build_assign (ptrtmp, ptr);\n+\t  gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\t}\n+      ptr = fold_build_pointer_plus_hwi_loc (input_location,\n+\t\t\t\t\t     ptrtmp, fixed_offset);\n+    }\n+\n+  /* Emit the statement and gimplify the adjustment expression.  */\n+  ret = create_tmp_reg (TREE_TYPE (ptr), \"adjusted_this\");\n+  stmt = gimple_build_assign (ret, ptr);\n+  gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+  return ret;\n+}\n+\n+/* Expand thunk NODE to gimple if possible.\n+   When FORCE_GIMPLE_THUNK is true, gimple thunk is created and\n+   no assembler is produced.\n+   When OUTPUT_ASM_THUNK is true, also produce assembler for\n+   thunks that are not lowered.  */\n+bool\n+expand_thunk (cgraph_node *node, bool output_asm_thunks,\n+\t      bool force_gimple_thunk)\n+{\n+  thunk_info *info = thunk_info::get (node);\n+  bool this_adjusting = info->this_adjusting;\n+  HOST_WIDE_INT fixed_offset = info->fixed_offset;\n+  HOST_WIDE_INT virtual_value = info->virtual_value;\n+  HOST_WIDE_INT indirect_offset = info->indirect_offset;\n+  tree virtual_offset = NULL;\n+  tree alias = node->callees->callee->decl;\n+  tree thunk_fndecl = node->decl;\n+  tree a;\n+\n+  if (!force_gimple_thunk\n+      && this_adjusting\n+      && indirect_offset == 0\n+      && !DECL_EXTERNAL (alias)\n+      && !DECL_STATIC_CHAIN (alias)\n+      && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n+\t\t\t\t\t      virtual_value, alias))\n+    {\n+      tree fn_block;\n+      tree restype = TREE_TYPE (TREE_TYPE (thunk_fndecl));\n+\n+      if (!output_asm_thunks)\n+\t{\n+\t  node->analyzed = true;\n+\t  return false;\n+\t}\n+\n+      if (in_lto_p)\n+\tnode->get_untransformed_body ();\n+      a = DECL_ARGUMENTS (thunk_fndecl);\n+\n+      current_function_decl = thunk_fndecl;\n+\n+      /* Ensure thunks are emitted in their correct sections.  */\n+      resolve_unique_section (thunk_fndecl, 0,\n+\t\t\t      flag_function_sections);\n+\n+      DECL_RESULT (thunk_fndecl)\n+\t= build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n+\t\t      RESULT_DECL, 0, restype);\n+      DECL_CONTEXT (DECL_RESULT (thunk_fndecl)) = thunk_fndecl;\n+\n+      /* The back end expects DECL_INITIAL to contain a BLOCK, so we\n+\t create one.  */\n+      fn_block = make_node (BLOCK);\n+      BLOCK_VARS (fn_block) = a;\n+      DECL_INITIAL (thunk_fndecl) = fn_block;\n+      BLOCK_SUPERCONTEXT (fn_block) = thunk_fndecl;\n+      allocate_struct_function (thunk_fndecl, false);\n+      init_function_start (thunk_fndecl);\n+      cfun->is_thunk = 1;\n+      insn_locations_init ();\n+      set_curr_insn_location (DECL_SOURCE_LOCATION (thunk_fndecl));\n+      prologue_location = curr_insn_location ();\n+\n+      targetm.asm_out.output_mi_thunk (asm_out_file, thunk_fndecl,\n+\t\t\t\t       fixed_offset, virtual_value, alias);\n+\n+      insn_locations_finalize ();\n+      init_insn_lengths ();\n+      free_after_compilation (cfun);\n+      TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n+      node->thunk = false;\n+      node->analyzed = false;\n+    }\n+  else if (stdarg_p (TREE_TYPE (thunk_fndecl)))\n+    {\n+      error (\"generic thunk code fails for method %qD which uses %<...%>\",\n+\t     thunk_fndecl);\n+      TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n+      node->analyzed = true;\n+      return false;\n+    }\n+  else\n+    {\n+      tree restype;\n+      basic_block bb, then_bb, else_bb, return_bb;\n+      gimple_stmt_iterator bsi;\n+      int nargs = 0;\n+      tree arg;\n+      int i;\n+      tree resdecl;\n+      tree restmp = NULL;\n+\n+      gcall *call;\n+      greturn *ret;\n+      bool alias_is_noreturn = TREE_THIS_VOLATILE (alias);\n+\n+      /* We may be called from expand_thunk that releases body except for\n+\t DECL_ARGUMENTS.  In this case force_gimple_thunk is true.  */\n+      if (in_lto_p && !force_gimple_thunk)\n+\tnode->get_untransformed_body ();\n+\n+      /* We need to force DECL_IGNORED_P when the thunk is created\n+\t after early debug was run.  */\n+      if (force_gimple_thunk)\n+\tDECL_IGNORED_P (thunk_fndecl) = 1;\n+\n+      a = DECL_ARGUMENTS (thunk_fndecl);\n+\n+      current_function_decl = thunk_fndecl;\n+\n+      /* Ensure thunks are emitted in their correct sections.  */\n+      resolve_unique_section (thunk_fndecl, 0,\n+\t\t\t      flag_function_sections);\n+\n+      bitmap_obstack_initialize (NULL);\n+\n+      if (info->virtual_offset_p)\n+\tvirtual_offset = size_int (virtual_value);\n+\n+      /* Build the return declaration for the function.  */\n+      restype = TREE_TYPE (TREE_TYPE (thunk_fndecl));\n+      if (DECL_RESULT (thunk_fndecl) == NULL_TREE)\n+\t{\n+\t  resdecl = build_decl (input_location, RESULT_DECL, 0, restype);\n+\t  DECL_ARTIFICIAL (resdecl) = 1;\n+\t  DECL_IGNORED_P (resdecl) = 1;\n+\t  DECL_CONTEXT (resdecl) = thunk_fndecl;\n+\t  DECL_RESULT (thunk_fndecl) = resdecl;\n+\t}\n+      else\n+\tresdecl = DECL_RESULT (thunk_fndecl);\n+\n+      profile_count cfg_count = node->count;\n+      if (!cfg_count.initialized_p ())\n+\tcfg_count = profile_count::from_gcov_type\n+\t\t\t (BB_FREQ_MAX).guessed_local ();\n+\n+      bb = then_bb = else_bb = return_bb\n+\t= init_lowered_empty_function (thunk_fndecl, true, cfg_count);\n+\n+      bsi = gsi_start_bb (bb);\n+\n+      /* Build call to the function being thunked.  */\n+      if (!VOID_TYPE_P (restype)\n+\t  && (!alias_is_noreturn\n+\t      || TREE_ADDRESSABLE (restype)\n+\t      || TREE_CODE (TYPE_SIZE_UNIT (restype)) != INTEGER_CST))\n+\t{\n+\t  if (DECL_BY_REFERENCE (resdecl))\n+\t    {\n+\t      restmp = gimple_fold_indirect_ref (resdecl);\n+\t      if (!restmp)\n+\t\trestmp = build2 (MEM_REF,\n+\t\t\t\t TREE_TYPE (TREE_TYPE (resdecl)),\n+\t\t\t\t resdecl,\n+\t\t\t\t build_int_cst (TREE_TYPE (resdecl), 0));\n+\t    }\n+\t  else if (!is_gimple_reg_type (restype))\n+\t    {\n+\t      if (aggregate_value_p (resdecl, TREE_TYPE (thunk_fndecl)))\n+\t\t{\n+\t\t  restmp = resdecl;\n+\n+\t\t  if (VAR_P (restmp))\n+\t\t    {\n+\t\t      add_local_decl (cfun, restmp);\n+\t\t      BLOCK_VARS (DECL_INITIAL (current_function_decl))\n+\t\t\t= restmp;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\trestmp = create_tmp_var (restype, \"retval\");\n+\t    }\n+\t  else\n+\t    restmp = create_tmp_reg (restype, \"retval\");\n+\t}\n+\n+      for (arg = a; arg; arg = DECL_CHAIN (arg))\n+\tnargs++;\n+      auto_vec<tree> vargs (nargs);\n+      i = 0;\n+      arg = a;\n+      if (this_adjusting)\n+\t{\n+\t  vargs.quick_push (thunk_adjust (&bsi, a, 1, fixed_offset,\n+\t\t\t\t\t  virtual_offset, indirect_offset));\n+\t  arg = DECL_CHAIN (a);\n+\t  i = 1;\n+\t}\n+\n+      if (nargs)\n+\tfor (; i < nargs; i++, arg = DECL_CHAIN (arg))\n+\t  {\n+\t    tree tmp = arg;\n+\t    DECL_NOT_GIMPLE_REG_P (arg) = 0;\n+\t    if (!is_gimple_val (arg))\n+\t      {\n+\t\ttmp = create_tmp_reg (TYPE_MAIN_VARIANT\n+\t\t\t\t      (TREE_TYPE (arg)), \"arg\");\n+\t\tgimple *stmt = gimple_build_assign (tmp, arg);\n+\t\tgsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t      }\n+\t    vargs.quick_push (tmp);\n+\t  }\n+      call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n+      node->callees->call_stmt = call;\n+      gimple_call_set_from_thunk (call, true);\n+      if (DECL_STATIC_CHAIN (alias))\n+\t{\n+\t  tree p = DECL_STRUCT_FUNCTION (alias)->static_chain_decl;\n+\t  tree type = TREE_TYPE (p);\n+\t  tree decl = build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n+\t\t\t\t  PARM_DECL, create_tmp_var_name (\"CHAIN\"),\n+\t\t\t\t  type);\n+\t  DECL_ARTIFICIAL (decl) = 1;\n+\t  DECL_IGNORED_P (decl) = 1;\n+\t  TREE_USED (decl) = 1;\n+\t  DECL_CONTEXT (decl) = thunk_fndecl;\n+\t  DECL_ARG_TYPE (decl) = type;\n+\t  TREE_READONLY (decl) = 1;\n+\n+\t  struct function *sf = DECL_STRUCT_FUNCTION (thunk_fndecl);\n+\t  sf->static_chain_decl = decl;\n+\n+\t  gimple_call_set_chain (call, decl);\n+\t}\n+\n+      /* Return slot optimization is always possible and in fact required to\n+\t return values with DECL_BY_REFERENCE.  */\n+      if (aggregate_value_p (resdecl, TREE_TYPE (thunk_fndecl))\n+\t  && (!is_gimple_reg_type (TREE_TYPE (resdecl))\n+\t      || DECL_BY_REFERENCE (resdecl)))\n+\tgimple_call_set_return_slot_opt (call, true);\n+\n+      if (restmp)\n+\t{\n+\t  gimple_call_set_lhs (call, restmp);\n+\t  gcc_assert (useless_type_conversion_p (TREE_TYPE (restmp),\n+\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (alias))));\n+\t}\n+      gsi_insert_after (&bsi, call, GSI_NEW_STMT);\n+      if (!alias_is_noreturn)\n+\t{\n+\t  if (restmp && !this_adjusting\n+\t      && (fixed_offset || virtual_offset))\n+\t    {\n+\t      tree true_label = NULL_TREE;\n+\n+\t      if (TREE_CODE (TREE_TYPE (restmp)) == POINTER_TYPE)\n+\t\t{\n+\t\t  gimple *stmt;\n+\t\t  edge e;\n+\t\t  /* If the return type is a pointer, we need to\n+\t\t     protect against NULL.  We know there will be an\n+\t\t     adjustment, because that's why we're emitting a\n+\t\t     thunk.  */\n+\t\t  then_bb = create_basic_block (NULL, bb);\n+\t\t  then_bb->count = cfg_count - cfg_count.apply_scale (1, 16);\n+\t\t  return_bb = create_basic_block (NULL, then_bb);\n+\t\t  return_bb->count = cfg_count;\n+\t\t  else_bb = create_basic_block (NULL, else_bb);\n+\t\t  else_bb->count = cfg_count.apply_scale (1, 16);\n+\t\t  add_bb_to_loop (then_bb, bb->loop_father);\n+\t\t  add_bb_to_loop (return_bb, bb->loop_father);\n+\t\t  add_bb_to_loop (else_bb, bb->loop_father);\n+\t\t  remove_edge (single_succ_edge (bb));\n+\t\t  true_label = gimple_block_label (then_bb);\n+\t\t  stmt = gimple_build_cond (NE_EXPR, restmp,\n+\t\t\t\t\t    build_zero_cst (TREE_TYPE (restmp)),\n+\t\t\t\t\t    NULL_TREE, NULL_TREE);\n+\t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t\t  e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n+\t\t  e->probability = profile_probability::guessed_always ()\n+\t\t\t\t\t.apply_scale (1, 16);\n+\t\t  e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n+\t\t  e->probability = profile_probability::guessed_always ()\n+\t\t\t\t\t.apply_scale (1, 16);\n+\t\t  make_single_succ_edge (return_bb,\n+\t\t\t\t\t EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+\t\t  make_single_succ_edge (then_bb, return_bb, EDGE_FALLTHRU);\n+\t\t  e = make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n+\t\t  e->probability = profile_probability::always ();\n+\t\t  bsi = gsi_last_bb (then_bb);\n+\t\t}\n+\n+\t      restmp = thunk_adjust (&bsi, restmp, /*this_adjusting=*/0,\n+\t\t\t\t     fixed_offset, virtual_offset,\n+\t\t\t\t     indirect_offset);\n+\t      if (true_label)\n+\t\t{\n+\t\t  gimple *stmt;\n+\t\t  bsi = gsi_last_bb (else_bb);\n+\t\t  stmt = gimple_build_assign (restmp,\n+\t\t\t\t\t      build_zero_cst\n+\t\t\t\t\t\t (TREE_TYPE (restmp)));\n+\t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t\t  bsi = gsi_last_bb (return_bb);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      gimple_call_set_tail (call, true);\n+\t      cfun->tail_call_marked = true;\n+\t    }\n+\n+\t  /* Build return value.  */\n+\t  if (!DECL_BY_REFERENCE (resdecl))\n+\t    ret = gimple_build_return (restmp);\n+\t  else\n+\t    ret = gimple_build_return (resdecl);\n+\n+\t  gsi_insert_after (&bsi, ret, GSI_NEW_STMT);\n+\t}\n+      else\n+\t{\n+\t  gimple_call_set_tail (call, true);\n+\t  cfun->tail_call_marked = true;\n+\t  remove_edge (single_succ_edge (bb));\n+\t}\n+\n+      cfun->gimple_df->in_ssa_p = true;\n+      update_max_bb_count ();\n+      profile_status_for_fn (cfun)\n+\t= cfg_count.initialized_p () && cfg_count.ipa_p ()\n+\t  ? PROFILE_READ : PROFILE_GUESSED;\n+      /* FIXME: C++ FE should stop setting TREE_ASM_WRITTEN on thunks.  */\n+      TREE_ASM_WRITTEN (thunk_fndecl) = false;\n+      delete_unreachable_blocks ();\n+      update_ssa (TODO_update_ssa);\n+      checking_verify_flow_info ();\n+      free_dominance_info (CDI_DOMINATORS);\n+\n+      /* Since we want to emit the thunk, we explicitly mark its name as\n+\t referenced.  */\n+      node->thunk = false;\n+      node->lowered = true;\n+      bitmap_obstack_release (NULL);\n+    }\n+  current_function_decl = NULL;\n+  set_cfun (NULL);\n+  return true;\n+}\n+\n+void\n+symtab_thunks_cc_finalize (void)\n+{\n+  vtable_entry_type = NULL;\n+}\n+\n+#include \"gt-symtab-thunks.h\""}, {"sha": "a23fc552950f9b9130caf90546915ec0b7f4f86b", "filename": "gcc/symtab-thunks.h", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fsymtab-thunks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fsymtab-thunks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab-thunks.h?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -0,0 +1,166 @@\n+/* Representation of thunks inside symbol table.\n+   Copyright (C) 2003-2020 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SYMTAB_THUNKS_H\n+#define GCC_SYMTAB_THUNKS_H\n+\n+/* This symbol annotation holds information about thunk.\n+\n+   Thunks are basically wrappers around methods which are introduced in case\n+   of multiple inheritance in order to adjust the value of the \"this\" pointer\n+   or of the returned value.\n+\n+   In the case of this-adjusting thunks, each back-end can override the\n+   can_output_mi_thunk/output_mi_thunk target hooks to generate a minimal thunk\n+   (with a tail call for instance) directly as assembly.  For the default hook\n+   or for the case where the can_output_mi_thunk hooks return false, the thunk\n+   is gimplified and lowered using the regular machinery.  */\n+\n+struct GTY(()) thunk_info {\n+  /* Constructor.  */\n+  thunk_info ()\n+    : fixed_offset (0),\n+      virtual_value (0),\n+      indirect_offset (0),\n+      alias (NULL),\n+      this_adjusting (false),\n+      virtual_offset_p (false)\n+  {\n+  }\n+  /* Copy constructor.  */\n+  thunk_info (const thunk_info &t)\n+    : fixed_offset (t.fixed_offset),\n+      virtual_value (t.virtual_value),\n+      indirect_offset (t.indirect_offset),\n+      alias (t.alias),\n+      this_adjusting (t.this_adjusting),\n+      virtual_offset_p (t.virtual_offset_p)\n+  {\n+  }\n+\n+  /* Compare for equiality.  */\n+  bool\n+  operator==(const thunk_info &other) const\n+  {\n+    return fixed_offset == other.fixed_offset\n+\t   && virtual_value == other.virtual_value\n+\t   && indirect_offset == other.indirect_offset\n+\t   && this_adjusting == other.this_adjusting\n+\t   && virtual_offset_p == other.virtual_offset_p;\n+  }\n+  bool\n+  operator!=(const thunk_info &other) const\n+  {\n+    return !(*this == other);\n+  }\n+  /* Copy operator.  */\n+  thunk_info &\n+  operator=(const thunk_info &other)\n+  {\n+    fixed_offset = other.fixed_offset;\n+    virtual_value = other.virtual_value;\n+    indirect_offset = other.indirect_offset;\n+    this_adjusting = other.this_adjusting;\n+    virtual_offset_p = other.virtual_offset_p;\n+    return *this;\n+  }\n+\n+  /* Offset used to adjust \"this\".  */\n+  HOST_WIDE_INT fixed_offset;\n+\n+  /* Offset in the virtual table to get the offset to adjust \"this\".  Valid iff\n+     VIRTUAL_OFFSET_P is true.  */\n+  HOST_WIDE_INT virtual_value;\n+\n+  /* Offset from \"this\" to get the offset to adjust \"this\".  Zero means: this\n+     offset is to be ignored.  */\n+  HOST_WIDE_INT indirect_offset;\n+\n+  /* Thunk target, i.e. the method that this thunk wraps.  Depending on the\n+     TARGET_USE_LOCAL_THUNK_ALIAS_P macro, this may have to be a new alias.  */\n+  tree alias;\n+\n+  /* Nonzero for a \"this\" adjusting thunk and zero for a result adjusting\n+     thunk.  */\n+  bool this_adjusting;\n+\n+  /* If true, this thunk is what we call a virtual thunk.  In this case:\n+     * for this-adjusting thunks, after the FIXED_OFFSET based adjustment is\n+       done, add to the result the offset found in the vtable at:\n+\t vptr + VIRTUAL_VALUE\n+     * for result-adjusting thunks, the FIXED_OFFSET adjustment is done after\n+       the virtual one.  */\n+  bool virtual_offset_p;\n+\n+\n+\n+  /* Dump thunk_info.  */\n+  void dump (FILE *);\n+\n+  /* Stream out thunk_info.  */\n+  void stream_out (class lto_simple_output_block *);\n+\n+  /* Stream in trunk_info.  */\n+  void stream_in (class lto_input_block *);\n+\n+  hashval_t hash ();\n+\n+\n+\n+  /* Return thunk_info, if available.  */\n+  static thunk_info *get (cgraph_node *node);\n+\n+  /* Return thunk_info possibly creating new one.  */\n+  static thunk_info *get_create (cgraph_node *node);\n+\n+  /* Remove thunk_info.  */\n+  static void remove (cgraph_node *node);\n+\n+  /* Release all thunk_infos.  */\n+  static void release (void);\n+};\n+\n+bool expand_thunk (cgraph_node *, bool, bool);\n+\n+/* Return thunk_info, if available.  */\n+inline thunk_info *\n+thunk_info::get (cgraph_node *node)\n+{\n+  if (!symtab->m_thunks)\n+    return NULL;\n+  return symtab->m_thunks->get (node);\n+}\n+\n+/* Remove thunk_info association for NODE.  */\n+inline void\n+thunk_info::remove (cgraph_node *node)\n+{\n+  symtab->m_thunks->remove (node);\n+}\n+\n+/* Free thunk info summaries.  */\n+inline void\n+thunk_info::release ()\n+{\n+  if (symtab->m_thunks)\n+    delete (symtab->m_thunks);\n+  symtab->m_thunks = NULL;\n+}\n+#endif  /* GCC_SYMTAB_THUNKS_H  */"}, {"sha": "20e231f4d2a47f142142832407541b9e70f13e81", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -2507,6 +2507,7 @@ toplev::finalize (void)\n \n   cgraph_c_finalize ();\n   cgraphunit_c_finalize ();\n+  symtab_thunks_cc_finalize ();\n   dwarf2out_c_finalize ();\n   gcse_c_finalize ();\n   ipa_cp_c_finalize ();"}, {"sha": "e4f264d6ae07a487396ca6e7d790aeb6a51b3851", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -51,6 +51,9 @@\n #include \"tree-ssa-address.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n \n #define A_RUNINSTRUMENTEDCODE\t0x0001\n #define A_RUNUNINSTRUMENTEDCODE\t0x0002\n@@ -4729,7 +4732,8 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n      result in one of the bits above being set so that we will not\n      have to recurse next time.  */\n   if (node->alias)\n-    return ipa_tm_mayenterirr_function (cgraph_node::get (node->thunk.alias));\n+    return ipa_tm_mayenterirr_function\n+\t\t (cgraph_node::get (thunk_info::get (node)->alias));\n \n   /* What remains is unmarked local functions without items that force\n      the function to go irrevocable.  */\n@@ -5475,7 +5479,7 @@ ipa_tm_execute (void)\n \t\t we need not scan the callees now, as the base will do.  */\n \t      if (node->alias)\n \t\t{\n-\t\t  node = cgraph_node::get (node->thunk.alias);\n+\t\t  node = cgraph_node::get (thunk_info::get (node)->alias);\n \t\t  d = get_cg_data (&node, true);\n \t\t  maybe_push_queue (node, &tm_callees, &d->in_callee_queue);\n \t\t  continue;"}, {"sha": "32fb3789f404ce826574cb8d05c5f74f9817bb1b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -61,6 +61,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sreal.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"tree-ssa-live.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -4792,13 +4795,14 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n \n   /* If callee is thunk, all we need is to adjust the THIS pointer\n      and redirect to function being thunked.  */\n-  if (id->src_node->thunk.thunk_p)\n+  if (id->src_node->thunk)\n     {\n       cgraph_edge *edge;\n       tree virtual_offset = NULL;\n       profile_count count = cg_edge->count;\n       tree op;\n       gimple_stmt_iterator iter = gsi_for_stmt (stmt);\n+      thunk_info *info = thunk_info::get (id->src_node);\n \n       cgraph_edge::remove (cg_edge);\n       edge = id->src_node->callees->clone (id->dst_node, call_stmt,\n@@ -4807,16 +4811,16 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n \t\t\t\t\t   profile_count::one (),\n \t\t\t\t           true);\n       edge->count = count;\n-      if (id->src_node->thunk.virtual_offset_p)\n-        virtual_offset = size_int (id->src_node->thunk.virtual_value);\n+      if (info->virtual_offset_p)\n+\tvirtual_offset = size_int (info->virtual_value);\n       op = create_tmp_reg_fn (cfun, TREE_TYPE (gimple_call_arg (stmt, 0)),\n \t\t\t      NULL);\n       gsi_insert_before (&iter, gimple_build_assign (op,\n \t\t\t\t\t\t    gimple_call_arg (stmt, 0)),\n \t\t\t GSI_NEW_STMT);\n-      gcc_assert (id->src_node->thunk.this_adjusting);\n-      op = thunk_adjust (&iter, op, 1, id->src_node->thunk.fixed_offset,\n-\t\t\t virtual_offset, id->src_node->thunk.indirect_offset);\n+      gcc_assert (info->this_adjusting);\n+      op = thunk_adjust (&iter, op, 1, info->fixed_offset,\n+\t\t\t virtual_offset, info->indirect_offset);\n \n       gimple_call_set_arg (stmt, 0, op);\n       gimple_call_set_fndecl (stmt, edge->callee->decl);"}, {"sha": "788883faa4c980edbbf6458f32c4f21362df6614", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -45,6 +45,7 @@\n #include \"alloc-pool.h\"\n #include \"tree-nested.h\"\n #include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n \n /* Summary of nested functions.  */\n static function_summary <nested_function_info *>\n@@ -937,7 +938,7 @@ create_nesting_tree (struct cgraph_node *cgn)\n   info->mem_refs = new hash_set<tree *>;\n   info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n   info->context = cgn->decl;\n-  info->thunk_p = cgn->thunk.thunk_p;\n+  info->thunk_p = cgn->thunk;\n \n   for (cgn = first_nested_function (cgn); cgn;\n        cgn = next_nested_function (cgn))\n@@ -3047,7 +3048,7 @@ convert_all_function_calls (struct nesting_info *root)\n     if (n->thunk_p)\n       {\n \ttree decl = n->context;\n-\ttree alias = cgraph_node::get (decl)->thunk.alias;\n+\ttree alias = thunk_info::get (cgraph_node::get (decl))->alias;\n \tDECL_STATIC_CHAIN (decl) = DECL_STATIC_CHAIN (alias);\n       }\n \n@@ -3083,7 +3084,7 @@ convert_all_function_calls (struct nesting_info *root)\n \tif (n->thunk_p)\n \t  {\n \t    tree decl = n->context;\n-\t    tree alias = cgraph_node::get (decl)->thunk.alias;\n+\t    tree alias = thunk_info::get (cgraph_node::get (decl))->alias;\n \t    DECL_STATIC_CHAIN (decl) = DECL_STATIC_CHAIN (alias);\n \t  }\n     }\n@@ -3638,7 +3639,7 @@ gimplify_all_functions (struct cgraph_node *root)\n     gimplify_function_tree (root->decl);\n   for (iter = first_nested_function (root); iter;\n        iter = next_nested_function (iter))\n-    if (!iter->thunk.thunk_p)\n+    if (!iter->thunk)\n       gimplify_all_functions (iter);\n }\n "}, {"sha": "07a6d995082d4edf4d549137d30c59a961364aa6", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -55,6 +55,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"stor-layout.h\"\n #include \"xregex.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-thunks.h\"\n \n static GTY(()) tree gcov_type_node;\n static GTY(()) tree tree_interval_profiler_fn;\n@@ -726,7 +729,7 @@ tree_profiling (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       bool thunk = false;\n-      if (!gimple_has_body_p (node->decl) && !node->thunk.thunk_p)\n+      if (!gimple_has_body_p (node->decl) && !node->thunk)\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n@@ -747,7 +750,7 @@ tree_profiling (void)\n       if (!include_source_file_for_profile (file))\n \tcontinue;\n \n-      if (node->thunk.thunk_p)\n+      if (node->thunk)\n \t{\n \t  /* We cannot expand variadic thunks to Gimple.  */\n \t  if (stdarg_p (TREE_TYPE (node->decl)))\n@@ -756,7 +759,7 @@ tree_profiling (void)\n \t  /* When generate profile, expand thunk to gimple so it can be\n \t     instrumented same way as other functions.  */\n \t  if (profile_arc_flag)\n-\t    node->expand_thunk (false, true);\n+\t    expand_thunk (node, false, true);\n \t  /* Read cgraph profile but keep function as thunk at profile-use\n \t     time.  */\n \t  else"}, {"sha": "9bac06f97af9dd26abbedbdcb682a3965a2b0434", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -7972,7 +7972,7 @@ static bool\n associate_varinfo_to_alias (struct cgraph_node *node, void *data)\n {\n   if ((node->alias\n-       || (node->thunk.thunk_p\n+       || (node->thunk\n \t   && ! node->inlined_to))\n       && node->analyzed\n       && !node->ifunc_resolver)"}, {"sha": "fa03d963eedea8d500c778bd6c041d00c78a6c63", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -5777,7 +5777,7 @@ free_lang_data_in_decl (tree decl, class free_lang_data_d *fld)\n \t      DECL_INITIAL (decl) = error_mark_node;\n \t    }\n \t}\n-      if (gimple_has_body_p (decl) || (node && node->thunk.thunk_p))\n+      if (gimple_has_body_p (decl) || (node && node->thunk))\n \t{\n \t  tree t;\n "}, {"sha": "db4fb8a2126666a63ea4d6f07ff80dd3ec596024", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3791f7d133214b112bd831ff2876822c665d0/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=67f3791f7d133214b112bd831ff2876822c665d0", "patch": "@@ -1222,7 +1222,7 @@ init_node_map (bool local)\n   cgraph_node_map = new hash_map<profile_id_hash, cgraph_node *>;\n \n   FOR_EACH_DEFINED_FUNCTION (n)\n-    if (n->has_gimple_body_p () || n->thunk.thunk_p)\n+    if (n->has_gimple_body_p () || n->thunk)\n       {\n \tcgraph_node **val;\n \tdump_user_location_t loc"}]}