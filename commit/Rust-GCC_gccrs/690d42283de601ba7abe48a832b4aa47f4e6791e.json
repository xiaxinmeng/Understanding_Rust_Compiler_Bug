{"sha": "690d42283de601ba7abe48a832b4aa47f4e6791e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwZDQyMjgzZGU2MDFiYTdhYmU0OGE4MzJiNGFhNDdmNGU2NzkxZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-07-16T20:58:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-07-16T20:58:13Z"}, "message": "pa.c (hppa_legitimize_address): Change references from SImode to either Pmode or word_mode as appropriate.\n\n        * pa.c (hppa_legitimize_address): Change references from SImode to\n        either Pmode or word_mode as appropriate.\n        (emit_move_sequence, store_reg, load_reg): Likewise.\n        (set_reg_plus_d, hppa_expand_prologue): Likewise.\n        (output_mul_insn): Likewise.\n        * pa.h (PROMOTE_MODE): Likewise.\n        (INITIALZE_TRAMPOLINE): Likewise.\n        (Pmode): Define to word_mode.\n\nFrom-SVN: r28128", "tree": {"sha": "7b42eea5b744bd93b66f50769215a22678a8f9e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b42eea5b744bd93b66f50769215a22678a8f9e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/690d42283de601ba7abe48a832b4aa47f4e6791e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690d42283de601ba7abe48a832b4aa47f4e6791e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/690d42283de601ba7abe48a832b4aa47f4e6791e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690d42283de601ba7abe48a832b4aa47f4e6791e/comments", "author": null, "committer": null, "parents": [{"sha": "d7735a074b4b8f8d1070388dbea6528187059319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7735a074b4b8f8d1070388dbea6528187059319", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7735a074b4b8f8d1070388dbea6528187059319"}], "stats": {"total": 121, "additions": 65, "deletions": 56}, "files": [{"sha": "f9bb028ce29262f36abfab09c209562a92d62949", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690d42283de601ba7abe48a832b4aa47f4e6791e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690d42283de601ba7abe48a832b4aa47f4e6791e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=690d42283de601ba7abe48a832b4aa47f4e6791e", "patch": "@@ -1,5 +1,14 @@\n Fri Jul 16 13:48:09 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* pa.c (hppa_legitimize_address): Change references from SImode to\n+\teither Pmode or word_mode as appropriate.\n+\t(emit_move_sequence, store_reg, load_reg): Likewise.\n+\t(set_reg_plus_d, hppa_expand_prologue): Likewise.\n+\t(output_mul_insn): Likewise.\n+\t* pa.h (PROMOTE_MODE): Likewise.\n+\t(INITIALZE_TRAMPOLINE): Likewise.\n+\t(Pmode): Define to word_mode.\n+\n \t* pa.c (compute_frame_size): Use UNITS_PER_WORD instead of hardwired\n \tvalue of 4.  Allocate 8 bytes for each FP register save.\n \t(hppa_expand_epilogue): Use UNITS_PER_WORD instead of harwarewired"}, {"sha": "ec76b524875bf285a84e324ff9a02331eb3bc095", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690d42283de601ba7abe48a832b4aa47f4e6791e/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690d42283de601ba7abe48a832b4aa47f4e6791e/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=690d42283de601ba7abe48a832b4aa47f4e6791e", "patch": "@@ -757,8 +757,8 @@ hppa_legitimize_address (x, oldx, mode)\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == SYMBOL_REF)\n     {\n-      rtx reg = force_reg (SImode, XEXP (x, 1));\n-      return force_reg (SImode, gen_rtx_PLUS (SImode, reg, XEXP (x, 0)));\n+      rtx reg = force_reg (Pmode, XEXP (x, 1));\n+      return force_reg (Pmode, gen_rtx_PLUS (Pmode, reg, XEXP (x, 0)));\n     }\n \n   /* Note we must reject symbols which represent function addresses\n@@ -1159,15 +1159,15 @@ emit_move_sequence (operands, mode, scratch_reg)\n       if (GET_CODE (operand1) == SUBREG)\n \toperand1 = XEXP (operand1, 0);\n \n-      scratch_reg = gen_rtx_REG (SImode, REGNO (scratch_reg));\n+      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n \n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n-      if (!memory_address_p (SImode, XEXP (operand1, 0)))\n+      if (!memory_address_p (Pmode, XEXP (operand1, 0)))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\n \t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),\n-\t\t\t\t\t\t       SImode,\n+\t\t\t\t\t\t       Pmode,\n \t\t\t\t\t\t       XEXP (XEXP (operand1, 0), 0),\n \t\t\t\t\t\t       scratch_reg));\n \t}\n@@ -1188,15 +1188,15 @@ emit_move_sequence (operands, mode, scratch_reg)\n       if (GET_CODE (operand0) == SUBREG)\n \toperand0 = XEXP (operand0, 0);\n \n-      scratch_reg = gen_rtx_REG (SImode, REGNO (scratch_reg));\n+      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n-      if (!memory_address_p (SImode, XEXP (operand0, 0)))\n+      if (!memory_address_p (Pmode, XEXP (operand0, 0)))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand0, 0), 1));\n \t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand0,\n \t\t\t\t\t\t\t\t        0)),\n-\t\t\t\t\t\t       SImode,\n+\t\t\t\t\t\t       Pmode,\n \t\t\t\t\t\t       XEXP (XEXP (operand0, 0),\n \t\t\t\t\t\t\t\t   0),\n \t\t\t\t\t\t       scratch_reg));\n@@ -1245,12 +1245,12 @@ emit_move_sequence (operands, mode, scratch_reg)\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n       if (GET_CODE (operand1) == MEM\n-\t  && !memory_address_p (SImode, XEXP (operand1, 0)))\n+\t  && !memory_address_p (Pmode, XEXP (operand1, 0)))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\t\n \t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1,\n \t\t\t\t\t\t\t\t        0)),\n-\t\t\t\t\t\t       SImode,\n+\t\t\t\t\t\t       Pmode,\n \t\t\t\t\t\t       XEXP (XEXP (operand1, 0),\n \t\t\t\t\t\t       0),\n \t\t\t\t\t\t       scratch_reg));\n@@ -2461,22 +2461,22 @@ store_reg (reg, disp, base)\n {\n   if (VAL_14_BITS_P (disp))\n     {\n-      emit_move_insn (gen_rtx_MEM (SImode,\n-\t\t\t\t   gen_rtx_PLUS (SImode,\n-\t\t\t\t\t\t gen_rtx_REG (SImode, base),\n+      emit_move_insn (gen_rtx_MEM (word_mode,\n+\t\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t gen_rtx_REG (Pmode, base),\n \t\t\t\t\t\t GEN_INT (disp))),\n-\t\t\t\t   gen_rtx_REG (SImode, reg));\n+\t\t\t\t   gen_rtx_REG (word_mode, reg));\n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx_REG (SImode, 1),\n-\t\t\t\t     gen_rtx_REG (SImode, base),\n+      emit_insn (gen_add_high_const (gen_rtx_REG (Pmode, 1),\n+\t\t\t\t     gen_rtx_REG (Pmode, base),\n \t\t\t\t     GEN_INT (disp)));\n-      emit_move_insn (gen_rtx_MEM (SImode,\n-\t\t\t\t   gen_rtx_LO_SUM (SImode,\n-\t\t\t\t\t\t   gen_rtx_REG (SImode, 1),\n+      emit_move_insn (gen_rtx_MEM (word_mode,\n+\t\t\t\t   gen_rtx_LO_SUM (Pmode,\n+\t\t\t\t\t\t   gen_rtx_REG (Pmode, 1),\n \t\t\t\t\t\t   GEN_INT (disp))),\n-\t\t      gen_rtx_REG (SImode, reg));\n+\t\t      gen_rtx_REG (word_mode, reg));\n     }\n }\n \n@@ -2491,21 +2491,21 @@ load_reg (reg, disp, base)\n {\n   if (VAL_14_BITS_P (disp))\n     {\n-      emit_move_insn (gen_rtx_REG (SImode, reg),\n-\t\t      gen_rtx_MEM (SImode,\n-\t\t\t\t   gen_rtx_PLUS (SImode,\n-\t\t\t\t\t\t gen_rtx_REG (SImode, base),\n+      emit_move_insn (gen_rtx_REG (word_mode, reg),\n+\t\t      gen_rtx_MEM (word_mode,\n+\t\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t gen_rtx_REG (Pmode, base),\n \t\t\t\t            GEN_INT (disp))));\n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx_REG (SImode, 1),\n-\t\t\t\t     gen_rtx_REG (SImode, base),\n+      emit_insn (gen_add_high_const (gen_rtx_REG (Pmode, 1),\n+\t\t\t\t     gen_rtx_REG (Pmode, base),\n \t\t\t\t     GEN_INT (disp)));\n-      emit_move_insn (gen_rtx_REG (SImode, reg),\n-\t\t      gen_rtx_MEM (SImode,\n-\t\t\t\t   gen_rtx_LO_SUM (SImode,\n-\t\t\t\t\t\t   gen_rtx_REG (SImode, 1),\n+      emit_move_insn (gen_rtx_REG (word_mode, reg),\n+\t\t      gen_rtx_MEM (word_mode,\n+\t\t\t\t   gen_rtx_LO_SUM (Pmode,\n+\t\t\t\t\t\t   gen_rtx_REG (Pmode, 1),\n \t\t\t\t\t\t   GEN_INT (disp))));\n     }\n }\n@@ -2521,19 +2521,19 @@ set_reg_plus_d(reg, base, disp)\n {\n   if (VAL_14_BITS_P (disp))\n     {\n-      emit_move_insn (gen_rtx_REG (SImode, reg),\n-\t\t      gen_rtx_PLUS (SImode,\n-\t\t\t\t    gen_rtx_REG (SImode, base),\n+      emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t      gen_rtx_PLUS (Pmode,\n+\t\t\t\t    gen_rtx_REG (Pmode, base),\n \t\t\t\t    GEN_INT (disp)));\n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx_REG (SImode, 1),\n-\t\t\t\t     gen_rtx_REG (SImode, base),\n+      emit_insn (gen_add_high_const (gen_rtx_REG (Pmode, 1),\n+\t\t\t\t     gen_rtx_REG (Pmode, base),\n \t\t\t\t     GEN_INT (disp)));\n-      emit_move_insn (gen_rtx_REG (SImode, reg),\n-\t\t      gen_rtx_LO_SUM (SImode,\n-\t\t\t\t      gen_rtx_REG (SImode, 1),\n+      emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t      gen_rtx_LO_SUM (Pmode,\n+\t\t\t\t      gen_rtx_REG (Pmode, 1),\n \t\t\t\t       GEN_INT (disp)));\n     }\n }\n@@ -2670,7 +2670,7 @@ hppa_expand_prologue()\n   actual_fsize = compute_frame_size (size, &save_fregs);\n \n   /* Compute a few things we will use often.  */\n-  tmpreg = gen_rtx_REG (SImode, 1);\n+  tmpreg = gen_rtx_REG (word_mode, 1);\n   size_rtx = GEN_INT (actual_fsize);\n \n   /* Save RP first.  The calling conventions manual states RP will\n@@ -2764,7 +2764,7 @@ hppa_expand_prologue()\n \t place to get the expected results.   sprintf here is just to\n \t put something in the name.  */\n       sprintf(hp_profile_label_name, \"LP$%04d\", -1);\n-      hp_profile_label_rtx = gen_rtx_SYMBOL_REF (SImode, hp_profile_label_name);\n+      hp_profile_label_rtx = gen_rtx_SYMBOL_REF (Pmode, hp_profile_label_name);\n       if (current_function_returns_struct)\n \tstore_reg (STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n       if (current_function_needs_context)\n@@ -2778,10 +2778,10 @@ hppa_expand_prologue()\n \t    pc_offset += VAL_14_BITS_P (arg_offset) ? 4 : 8;\n \t  }\n \n-      emit_move_insn (gen_rtx_REG (SImode, 26), gen_rtx_REG (SImode, 2));\n-      emit_move_insn (tmpreg, gen_rtx_HIGH (SImode, hp_profile_label_rtx));\n-      emit_move_insn (gen_rtx_REG (SImode, 24),\n-\t\t      gen_rtx_LO_SUM (SImode, tmpreg, hp_profile_label_rtx));\n+      emit_move_insn (gen_rtx_REG (word_mode, 26), gen_rtx_REG (word_mode, 2));\n+      emit_move_insn (tmpreg, gen_rtx_HIGH (Pmode, hp_profile_label_rtx));\n+      emit_move_insn (gen_rtx_REG (Pmode, 24),\n+\t\t      gen_rtx_LO_SUM (Pmode, tmpreg, hp_profile_label_rtx));\n       /* %r25 is set from within the output pattern.  */\n       emit_insn (gen_call_profiler (GEN_INT (- pc_offset - 20)));\n \n@@ -2825,7 +2825,7 @@ hppa_expand_prologue()\n \t      {\n \t\tmerge_sp_adjust_with_store = 0;\n \t        emit_insn (gen_post_stwm (stack_pointer_rtx,\n-\t\t\t\t\t  gen_rtx_REG (SImode, i),\n+\t\t\t\t\t  gen_rtx_REG (word_mode, i),\n \t\t\t\t\t  GEN_INT (-offset)));\n \t      }\n \t    else\n@@ -2886,8 +2886,8 @@ hppa_expand_prologue()\n      Avoid this if the callee saved register wasn't used (these are\n      leaf functions).  */\n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM_SAVED])\n-    emit_move_insn (gen_rtx_REG (SImode, PIC_OFFSET_TABLE_REGNUM_SAVED),\n-\t\t    gen_rtx_REG (SImode, PIC_OFFSET_TABLE_REGNUM));\n+    emit_move_insn (gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM_SAVED),\n+\t\t    gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM));\n }\n \n \n@@ -2936,7 +2936,7 @@ hppa_expand_epilogue ()\n   int merge_sp_adjust_with_load  = 0;\n \n   /* We will use this often.  */\n-  tmpreg = gen_rtx_REG (SImode, 1);\n+  tmpreg = gen_rtx_REG (word_mode, 1);\n \n   /* Try to restore RP early to avoid load/use interlocks when\n      RP gets used in the return (bv) instruction.  This appears to still\n@@ -3042,7 +3042,7 @@ hppa_expand_epilogue ()\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n   else if (! frame_pointer_needed  && merge_sp_adjust_with_load)\n-    emit_insn (gen_pre_ldwm (gen_rtx_REG (SImode, merge_sp_adjust_with_load),\n+    emit_insn (gen_pre_ldwm (gen_rtx_REG (word_mode, merge_sp_adjust_with_load),\n \t\t\t     stack_pointer_rtx,\n \t\t\t     GEN_INT (- actual_fsize)));\n   else if (actual_fsize != 0)\n@@ -3944,7 +3944,7 @@ output_mul_insn (unsignedp, insn)\n      rtx insn;\n {\n   import_milli (mulI);\n-  return output_millicode_call (insn, gen_rtx_SYMBOL_REF (SImode, \"$$mulI\"));\n+  return output_millicode_call (insn, gen_rtx_SYMBOL_REF (Pmode, \"$$mulI\"));\n }\n \n /* Emit the rtl for doing a division by a constant. */"}, {"sha": "717e3710450bcf9fdcec9b6da9eed2c3205a48ea", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690d42283de601ba7abe48a832b4aa47f4e6791e/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690d42283de601ba7abe48a832b4aa47f4e6791e/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=690d42283de601ba7abe48a832b4aa47f4e6791e", "patch": "@@ -320,7 +320,7 @@ int lhs_lshift_cint_operand ();\n #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\\\n       && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)  \t\\\n-    (MODE) = SImode;\n+    (MODE) = word_mode;\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n@@ -1206,12 +1206,12 @@ extern union tree_node *current_function_decl;\n   emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n   /* fdc and fic only use registers for the address to flush,\t\t\\\n      they do not accept integer displacements.  */ \t\t\t\\\n-  start_addr = force_reg (SImode, (TRAMP));\t\t\t\t\\\n-  end_addr = force_reg (SImode, plus_constant ((TRAMP), 32));\t\t\\\n+  start_addr = force_reg (Pmode, (TRAMP));\t\t\t\t\\\n+  end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\t\\\n   emit_insn (gen_dcacheflush (start_addr, end_addr));\t\t\t\\\n-  end_addr = force_reg (SImode, plus_constant (start_addr, 32));\t\\\n+  end_addr = force_reg (Pmode, plus_constant (start_addr, 32));\t\\\n   emit_insn (gen_icacheflush (start_addr, end_addr, start_addr,\t\t\\\n-\t\t\t      gen_reg_rtx (SImode), gen_reg_rtx (SImode)));\\\n+\t\t\t      gen_reg_rtx (Pmode), gen_reg_rtx (Pmode)));\\\n }\n \n /* Emit code for a call to builtin_saveregs.  We must emit USE insns which\n@@ -1631,7 +1631,7 @@ extern struct rtx_def *hppa_legitimize_address ();\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n+#define Pmode word_mode\n \n /* Add any extra modes needed to represent the condition code.\n "}]}