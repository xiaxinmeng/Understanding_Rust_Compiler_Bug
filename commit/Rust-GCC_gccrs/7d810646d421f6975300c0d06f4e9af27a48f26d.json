{"sha": "7d810646d421f6975300c0d06f4e9af27a48f26d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4MTA2NDZkNDIxZjY5NzUzMDBjMGQwNmY0ZTlhZjI3YTQ4ZjI2ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-05T13:51:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-06T09:56:47Z"}, "message": "Add FMADDSUB and FMSUBADD SLP vectorization patterns and optabs\n\nThis adds named expanders for vec_fmaddsub<mode>4 and\nvec_fmsubadd<mode>4 which map to x86 vfmaddsubXXXp{ds} and\nvfmsubaddXXXp{ds} instructions.  This complements the previous\naddition of ADDSUB support.\n\nx86 lacks SUBADD and the negate variants of FMA with mixed\nplus minus so I did not add optabs or patterns for those but\nit would not be difficult if there's a target that has them.\n\n2021-07-05  Richard Biener  <rguenther@suse.de>\n\n\t* doc/md.texi (vec_fmaddsub<mode>4): Document.\n\t(vec_fmsubadd<mode>4): Likewise.\n\t* optabs.def (vec_fmaddsub$a4): Add.\n\t(vec_fmsubadd$a4): Likewise.\n\t* internal-fn.def (IFN_VEC_FMADDSUB): Add.\n\t(IFN_VEC_FMSUBADD): Likewise.\n\t* tree-vect-slp-patterns.c (addsub_pattern::recognize):\n\tRefactor to handle IFN_VEC_FMADDSUB and IFN_VEC_FMSUBADD.\n\t(addsub_pattern::build): Likewise.\n\t* tree-vect-slp.c (vect_optimize_slp): CFN_VEC_FMADDSUB\n\tand CFN_VEC_FMSUBADD are not transparent for permutes.\n\t* config/i386/sse.md (vec_fmaddsub<mode>4): New expander.\n\t(vec_fmsubadd<mode>4): Likewise.\n\n\t* gcc.target/i386/vect-fmaddsubXXXpd.c: New testcase.\n\t* gcc.target/i386/vect-fmaddsubXXXps.c: Likewise.\n\t* gcc.target/i386/vect-fmsubaddXXXpd.c: Likewise.\n\t* gcc.target/i386/vect-fmsubaddXXXps.c: Likewise.", "tree": {"sha": "ab76365a066c48d72a332a290a099c3f3d53a335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab76365a066c48d72a332a290a099c3f3d53a335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d810646d421f6975300c0d06f4e9af27a48f26d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d810646d421f6975300c0d06f4e9af27a48f26d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d810646d421f6975300c0d06f4e9af27a48f26d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d810646d421f6975300c0d06f4e9af27a48f26d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f489a5731f12b8e6b49994e8f61acb5d26f508e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f489a5731f12b8e6b49994e8f61acb5d26f508e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f489a5731f12b8e6b49994e8f61acb5d26f508e"}], "stats": {"total": 368, "additions": 311, "deletions": 57}, "files": [{"sha": "17c9e571d5d7441b0201392b01dbcc62028d93d5", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -4644,6 +4644,25 @@\n ;;\n ;; But this doesn't seem useful in practice.\n \n+(define_expand \"vec_fmaddsub<mode>4\"\n+  [(set (match_operand:VF 0 \"register_operand\")\n+\t(unspec:VF\n+\t  [(match_operand:VF 1 \"nonimmediate_operand\")\n+\t   (match_operand:VF 2 \"nonimmediate_operand\")\n+\t   (match_operand:VF 3 \"nonimmediate_operand\")]\n+\t  UNSPEC_FMADDSUB))]\n+  \"TARGET_FMA || TARGET_FMA4 || (<MODE_SIZE> == 64 || TARGET_AVX512VL)\")\n+\n+(define_expand \"vec_fmsubadd<mode>4\"\n+  [(set (match_operand:VF 0 \"register_operand\")\n+\t(unspec:VF\n+\t  [(match_operand:VF 1 \"nonimmediate_operand\")\n+\t   (match_operand:VF 2 \"nonimmediate_operand\")\n+\t   (neg:VF\n+\t     (match_operand:VF 3 \"nonimmediate_operand\"))]\n+\t  UNSPEC_FMADDSUB))]\n+  \"TARGET_FMA || TARGET_FMA4 || (<MODE_SIZE> == 64 || TARGET_AVX512VL)\")\n+\n (define_expand \"fmaddsub_<mode>\"\n   [(set (match_operand:VF 0 \"register_operand\")\n \t(unspec:VF"}, {"sha": "cc92ebd26aa8864522f3537215dfed4a82b2c432", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -5688,6 +5688,20 @@ Alternating subtract, add with even lanes doing subtract and odd\n lanes doing addition.  Operands 1 and 2 and the outout operand are vectors\n with mode @var{m}.\n \n+@cindex @code{vec_fmaddsub@var{m}4} instruction pattern\n+@item @samp{vec_fmaddsub@var{m}4}\n+Alternating multiply subtract, add with even lanes doing subtract and odd\n+lanes doing addition of the third operand to the multiplication result\n+of the first two operands.  Operands 1, 2 and 3 and the outout operand are vectors\n+with mode @var{m}.\n+\n+@cindex @code{vec_fmsubadd@var{m}4} instruction pattern\n+@item @samp{vec_fmsubadd@var{m}4}\n+Alternating multiply add, subtract with even lanes doing addition and odd\n+lanes doing subtraction of the third operand to the multiplication result\n+of the first two operands.  Operands 1, 2 and 3 and the outout operand are vectors\n+with mode @var{m}.\n+\n These instructions are not allowed to @code{FAIL}.\n \n @cindex @code{mulhisi3} instruction pattern"}, {"sha": "a7003d5da8e0652f87766232cf92f9e91b395dd2", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -282,7 +282,8 @@ DEF_INTERNAL_OPTAB_FN (COMPLEX_ADD_ROT270, ECF_CONST, cadd270, binary)\n DEF_INTERNAL_OPTAB_FN (COMPLEX_MUL, ECF_CONST, cmul, binary)\n DEF_INTERNAL_OPTAB_FN (COMPLEX_MUL_CONJ, ECF_CONST, cmul_conj, binary)\n DEF_INTERNAL_OPTAB_FN (VEC_ADDSUB, ECF_CONST, vec_addsub, binary)\n-\n+DEF_INTERNAL_OPTAB_FN (VEC_FMADDSUB, ECF_CONST, vec_fmaddsub, ternary)\n+DEF_INTERNAL_OPTAB_FN (VEC_FMSUBADD, ECF_CONST, vec_fmsubadd, ternary)\n \n /* FP scales.  */\n DEF_INTERNAL_FLT_FN (LDEXP, ECF_CONST, ldexp, binary)"}, {"sha": "51acc1be8f55fa46ee8be6f1577bdfb5eda1440e", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -408,6 +408,8 @@ OPTAB_D (vec_widen_usubl_lo_optab, \"vec_widen_usubl_lo_$a\")\n OPTAB_D (vec_widen_uaddl_hi_optab, \"vec_widen_uaddl_hi_$a\")\n OPTAB_D (vec_widen_uaddl_lo_optab, \"vec_widen_uaddl_lo_$a\")\n OPTAB_D (vec_addsub_optab, \"vec_addsub$a3\")\n+OPTAB_D (vec_fmaddsub_optab, \"vec_fmaddsub$a4\")\n+OPTAB_D (vec_fmsubadd_optab, \"vec_fmsubadd$a4\")\n \n OPTAB_D (sync_add_optab, \"sync_add$I$a\")\n OPTAB_D (sync_and_optab, \"sync_and$I$a\")"}, {"sha": "b30d10731a7564dc6e32dc5502203fffcb8f6150", "filename": "gcc/testsuite/gcc.target/i386/vect-fmaddsubXXXpd.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmaddsubXXXpd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmaddsubXXXpd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmaddsubXXXpd.c?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma } */\n+/* { dg-options \"-O3 -mfma -save-temps\" } */\n+\n+#include \"fma-check.h\"\n+\n+void __attribute__((noipa))\n+check_fmaddsub (double * __restrict a, double *b, double *c, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      a[2*i + 0] = b[2*i + 0] * c[2*i + 0] - a[2*i + 0];\n+      a[2*i + 1] = b[2*i + 1] * c[2*i + 1] + a[2*i + 1];\n+    }\n+}\n+\n+static void\n+fma_test (void)\n+{\n+  double a[4], b[4], c[4];\n+  for (int i = 0; i < 4; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = 3*i;\n+      c[i] = 7*i;\n+    }\n+  check_fmaddsub (a, b, c, 2);\n+  const double d[4] = { 0., 22., 82., 192. };\n+  for (int i = 0; i < 4; ++i)\n+    if (a[i] != d[i])\n+      __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-assembler \"fmaddsub...pd\" } } */"}, {"sha": "cd2af8725a3344c974af9c5c7d6915d1d395c243", "filename": "gcc/testsuite/gcc.target/i386/vect-fmaddsubXXXps.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmaddsubXXXps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmaddsubXXXps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmaddsubXXXps.c?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma } */\n+/* { dg-options \"-O3 -mfma -save-temps\" } */\n+\n+#include \"fma-check.h\"\n+\n+void __attribute__((noipa))\n+check_fmaddsub (float * __restrict a, float *b, float *c, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      a[2*i + 0] = b[2*i + 0] * c[2*i + 0] - a[2*i + 0];\n+      a[2*i + 1] = b[2*i + 1] * c[2*i + 1] + a[2*i + 1];\n+    }\n+}\n+\n+static void\n+fma_test (void)\n+{\n+  float a[4], b[4], c[4];\n+  for (int i = 0; i < 4; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = 3*i;\n+      c[i] = 7*i;\n+    }\n+  check_fmaddsub (a, b, c, 2);\n+  const float d[4] = { 0., 22., 82., 192. };\n+  for (int i = 0; i < 4; ++i)\n+    if (a[i] != d[i])\n+      __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-assembler \"fmaddsub...ps\" } } */"}, {"sha": "7ca2a275cc15fd96eb7ced7c13bdcf24e11a0534", "filename": "gcc/testsuite/gcc.target/i386/vect-fmsubaddXXXpd.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmsubaddXXXpd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmsubaddXXXpd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmsubaddXXXpd.c?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma } */\n+/* { dg-options \"-O3 -mfma -save-temps\" } */\n+\n+#include \"fma-check.h\"\n+\n+void __attribute__((noipa))\n+check_fmsubadd (double * __restrict a, double *b, double *c, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      a[2*i + 0] = b[2*i + 0] * c[2*i + 0] + a[2*i + 0];\n+      a[2*i + 1] = b[2*i + 1] * c[2*i + 1] - a[2*i + 1];\n+    }\n+}\n+\n+static void\n+fma_test (void)\n+{\n+  double a[4], b[4], c[4];\n+  for (int i = 0; i < 4; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = 3*i;\n+      c[i] = 7*i;\n+    }\n+  check_fmsubadd (a, b, c, 2);\n+  const double d[4] = { 0., 20., 86., 186. };\n+  for (int i = 0; i < 4; ++i)\n+    if (a[i] != d[i])\n+      __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-assembler \"fmsubadd...pd\" } } */"}, {"sha": "9ddd0e423dbda10190ce9bf5d53b6323dcf8d6c8", "filename": "gcc/testsuite/gcc.target/i386/vect-fmsubaddXXXps.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmsubaddXXXps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmsubaddXXXps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-fmsubaddXXXps.c?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma } */\n+/* { dg-options \"-O3 -mfma -save-temps\" } */\n+\n+#include \"fma-check.h\"\n+\n+void __attribute__((noipa))\n+check_fmsubadd (float * __restrict a, float *b, float *c, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      a[2*i + 0] = b[2*i + 0] * c[2*i + 0] + a[2*i + 0];\n+      a[2*i + 1] = b[2*i + 1] * c[2*i + 1] - a[2*i + 1];\n+    }\n+}\n+\n+static void\n+fma_test (void)\n+{\n+  float a[4], b[4], c[4];\n+  for (int i = 0; i < 4; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = 3*i;\n+      c[i] = 7*i;\n+    }\n+  check_fmsubadd (a, b, c, 2);\n+  const float d[4] = { 0., 20., 86., 186. };\n+  for (int i = 0; i < 4; ++i)\n+    if (a[i] != d[i])\n+      __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-assembler \"fmsubadd...ps\" } } */"}, {"sha": "f774cac4a4d794e876dd081945da7572a9698e28", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 136, "deletions": 56, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -1496,8 +1496,8 @@ complex_operations_pattern::build (vec_info * /* vinfo */)\n class addsub_pattern : public vect_pattern\n {\n   public:\n-    addsub_pattern (slp_tree *node)\n-\t: vect_pattern (node, NULL, IFN_VEC_ADDSUB) {};\n+    addsub_pattern (slp_tree *node, internal_fn ifn)\n+\t: vect_pattern (node, NULL, ifn) {};\n \n     void build (vec_info *);\n \n@@ -1510,85 +1510,165 @@ addsub_pattern::recognize (slp_tree_to_load_perm_map_t *, slp_tree *node_)\n {\n   slp_tree node = *node_;\n   if (SLP_TREE_CODE (node) != VEC_PERM_EXPR\n-      || SLP_TREE_CHILDREN (node).length () != 2)\n+      || SLP_TREE_CHILDREN (node).length () != 2\n+      || SLP_TREE_LANE_PERMUTATION (node).length () % 2)\n     return NULL;\n \n   /* Match a blend of a plus and a minus op with the same number of plus and\n      minus lanes on the same operands.  */\n-  slp_tree sub = SLP_TREE_CHILDREN (node)[0];\n-  slp_tree add = SLP_TREE_CHILDREN (node)[1];\n-  bool swapped_p = false;\n-  if (vect_match_expression_p (sub, PLUS_EXPR))\n-    {\n-      std::swap (add, sub);\n-      swapped_p = true;\n-    }\n-  if (!(vect_match_expression_p (add, PLUS_EXPR)\n-\t&& vect_match_expression_p (sub, MINUS_EXPR)))\n+  unsigned l0 = SLP_TREE_LANE_PERMUTATION (node)[0].first;\n+  unsigned l1 = SLP_TREE_LANE_PERMUTATION (node)[1].first;\n+  if (l0 == l1)\n+    return NULL;\n+  bool l0add_p = vect_match_expression_p (SLP_TREE_CHILDREN (node)[l0],\n+\t\t\t\t\t  PLUS_EXPR);\n+  if (!l0add_p\n+      && !vect_match_expression_p (SLP_TREE_CHILDREN (node)[l0], MINUS_EXPR))\n+    return NULL;\n+  bool l1add_p = vect_match_expression_p (SLP_TREE_CHILDREN (node)[l1],\n+\t\t\t\t\t  PLUS_EXPR);\n+  if (!l1add_p\n+      && !vect_match_expression_p (SLP_TREE_CHILDREN (node)[l1], MINUS_EXPR))\n     return NULL;\n-  if (!((SLP_TREE_CHILDREN (sub)[0] == SLP_TREE_CHILDREN (add)[0]\n-\t && SLP_TREE_CHILDREN (sub)[1] == SLP_TREE_CHILDREN (add)[1])\n-\t|| (SLP_TREE_CHILDREN (sub)[0] == SLP_TREE_CHILDREN (add)[1]\n-\t    && SLP_TREE_CHILDREN (sub)[1] == SLP_TREE_CHILDREN (add)[0])))\n+\n+  slp_tree l0node = SLP_TREE_CHILDREN (node)[l0];\n+  slp_tree l1node = SLP_TREE_CHILDREN (node)[l1];\n+  if (!((SLP_TREE_CHILDREN (l0node)[0] == SLP_TREE_CHILDREN (l1node)[0]\n+\t && SLP_TREE_CHILDREN (l0node)[1] == SLP_TREE_CHILDREN (l1node)[1])\n+\t|| (SLP_TREE_CHILDREN (l0node)[0] == SLP_TREE_CHILDREN (l1node)[1]\n+\t    && SLP_TREE_CHILDREN (l0node)[1] == SLP_TREE_CHILDREN (l1node)[0])))\n     return NULL;\n \n   for (unsigned i = 0; i < SLP_TREE_LANE_PERMUTATION (node).length (); ++i)\n     {\n       std::pair<unsigned, unsigned> perm = SLP_TREE_LANE_PERMUTATION (node)[i];\n-      if (swapped_p)\n-\tperm.first = perm.first == 0 ? 1 : 0;\n-      /* It has to be alternating -, +, -, ...\n+      /* It has to be alternating -, +, -,\n \t While we could permute the .ADDSUB inputs and the .ADDSUB output\n \t that's only profitable over the add + sub + blend if at least\n \t one of the permute is optimized which we can't determine here.  */\n-      if (perm.first != (i & 1)\n+      if (perm.first != ((i & 1) ? l1 : l0)\n \t  || perm.second != i)\n \treturn NULL;\n     }\n \n-  if (!vect_pattern_validate_optab (IFN_VEC_ADDSUB, node))\n-    return NULL;\n+  /* Now we have either { -, +, -, + ... } (!l0add_p) or { +, -, +, - ... }\n+     (l0add_p), see whether we have FMA variants.  */\n+  if (!l0add_p\n+      && vect_match_expression_p (SLP_TREE_CHILDREN (l0node)[0], MULT_EXPR))\n+    {\n+      /* (c * d) -+ a */\n+      if (vect_pattern_validate_optab (IFN_VEC_FMADDSUB, node))\n+\treturn new addsub_pattern (node_, IFN_VEC_FMADDSUB);\n+    }\n+  else if (l0add_p\n+\t   && vect_match_expression_p (SLP_TREE_CHILDREN (l1node)[0], MULT_EXPR))\n+    {\n+      /* (c * d) +- a */\n+      if (vect_pattern_validate_optab (IFN_VEC_FMSUBADD, node))\n+\treturn new addsub_pattern (node_, IFN_VEC_FMSUBADD);\n+    }\n \n-  return new addsub_pattern (node_);\n+  if (!l0add_p && vect_pattern_validate_optab (IFN_VEC_ADDSUB, node))\n+    return new addsub_pattern (node_, IFN_VEC_ADDSUB);\n+\n+  return NULL;\n }\n \n void\n addsub_pattern::build (vec_info *vinfo)\n {\n   slp_tree node = *m_node;\n \n-  slp_tree sub = SLP_TREE_CHILDREN (node)[0];\n-  slp_tree add = SLP_TREE_CHILDREN (node)[1];\n-  if (vect_match_expression_p (sub, PLUS_EXPR))\n-    std::swap (add, sub);\n-\n-  /* Modify the blend node in-place.  */\n-  SLP_TREE_CHILDREN (node)[0] = SLP_TREE_CHILDREN (sub)[0];\n-  SLP_TREE_CHILDREN (node)[1] = SLP_TREE_CHILDREN (sub)[1];\n-  SLP_TREE_REF_COUNT (SLP_TREE_CHILDREN (node)[0])++;\n-  SLP_TREE_REF_COUNT (SLP_TREE_CHILDREN (node)[1])++;\n-\n-  /* Build IFN_VEC_ADDSUB from the sub representative operands.  */\n-  stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (sub);\n-  gcall *call = gimple_build_call_internal (IFN_VEC_ADDSUB, 2,\n-\t\t\t\t\t    gimple_assign_rhs1 (rep->stmt),\n-\t\t\t\t\t    gimple_assign_rhs2 (rep->stmt));\n-  gimple_call_set_lhs (call, make_ssa_name\n-\t\t\t       (TREE_TYPE (gimple_assign_lhs (rep->stmt))));\n-  gimple_call_set_nothrow (call, true);\n-  gimple_set_bb (call, gimple_bb (rep->stmt));\n-  stmt_vec_info new_rep = vinfo->add_pattern_stmt (call, rep);\n-  SLP_TREE_REPRESENTATIVE (node) = new_rep;\n-  STMT_VINFO_RELEVANT (new_rep) = vect_used_in_scope;\n-  STMT_SLP_TYPE (new_rep) = pure_slp;\n-  STMT_VINFO_VECTYPE (new_rep) = SLP_TREE_VECTYPE (node);\n-  STMT_VINFO_SLP_VECT_ONLY_PATTERN (new_rep) = true;\n-  STMT_VINFO_REDUC_DEF (new_rep) = STMT_VINFO_REDUC_DEF (vect_orig_stmt (rep));\n-  SLP_TREE_CODE (node) = ERROR_MARK;\n-  SLP_TREE_LANE_PERMUTATION (node).release ();\n-\n-  vect_free_slp_tree (sub);\n-  vect_free_slp_tree (add);\n+  unsigned l0 = SLP_TREE_LANE_PERMUTATION (node)[0].first;\n+  unsigned l1 = SLP_TREE_LANE_PERMUTATION (node)[1].first;\n+\n+  switch (m_ifn)\n+    {\n+    case IFN_VEC_ADDSUB:\n+      {\n+\tslp_tree sub = SLP_TREE_CHILDREN (node)[l0];\n+\tslp_tree add = SLP_TREE_CHILDREN (node)[l1];\n+\n+\t/* Modify the blend node in-place.  */\n+\tSLP_TREE_CHILDREN (node)[0] = SLP_TREE_CHILDREN (sub)[0];\n+\tSLP_TREE_CHILDREN (node)[1] = SLP_TREE_CHILDREN (sub)[1];\n+\tSLP_TREE_REF_COUNT (SLP_TREE_CHILDREN (node)[0])++;\n+\tSLP_TREE_REF_COUNT (SLP_TREE_CHILDREN (node)[1])++;\n+\n+\t/* Build IFN_VEC_ADDSUB from the sub representative operands.  */\n+\tstmt_vec_info rep = SLP_TREE_REPRESENTATIVE (sub);\n+\tgcall *call = gimple_build_call_internal (IFN_VEC_ADDSUB, 2,\n+\t\t\t\t\t\t  gimple_assign_rhs1 (rep->stmt),\n+\t\t\t\t\t\t  gimple_assign_rhs2 (rep->stmt));\n+\tgimple_call_set_lhs (call, make_ssa_name\n+\t\t\t     (TREE_TYPE (gimple_assign_lhs (rep->stmt))));\n+\tgimple_call_set_nothrow (call, true);\n+\tgimple_set_bb (call, gimple_bb (rep->stmt));\n+\tstmt_vec_info new_rep = vinfo->add_pattern_stmt (call, rep);\n+\tSLP_TREE_REPRESENTATIVE (node) = new_rep;\n+\tSTMT_VINFO_RELEVANT (new_rep) = vect_used_in_scope;\n+\tSTMT_SLP_TYPE (new_rep) = pure_slp;\n+\tSTMT_VINFO_VECTYPE (new_rep) = SLP_TREE_VECTYPE (node);\n+\tSTMT_VINFO_SLP_VECT_ONLY_PATTERN (new_rep) = true;\n+\tSTMT_VINFO_REDUC_DEF (new_rep) = STMT_VINFO_REDUC_DEF (vect_orig_stmt (rep));\n+\tSLP_TREE_CODE (node) = ERROR_MARK;\n+\tSLP_TREE_LANE_PERMUTATION (node).release ();\n+\n+\tvect_free_slp_tree (sub);\n+\tvect_free_slp_tree (add);\n+\tbreak;\n+      }\n+    case IFN_VEC_FMADDSUB:\n+    case IFN_VEC_FMSUBADD:\n+      {\n+\tslp_tree sub, add;\n+\tif (m_ifn == IFN_VEC_FMADDSUB)\n+\t  {\n+\t    sub = SLP_TREE_CHILDREN (node)[l0];\n+\t    add = SLP_TREE_CHILDREN (node)[l1];\n+\t  }\n+\telse /* m_ifn == IFN_VEC_FMSUBADD */\n+\t  {\n+\t    sub = SLP_TREE_CHILDREN (node)[l1];\n+\t    add = SLP_TREE_CHILDREN (node)[l0];\n+\t  }\n+\tslp_tree mul = SLP_TREE_CHILDREN (sub)[0];\n+\t/* Modify the blend node in-place.  */\n+\tSLP_TREE_CHILDREN (node).safe_grow (3, true);\n+\tSLP_TREE_CHILDREN (node)[0] = SLP_TREE_CHILDREN (mul)[0];\n+\tSLP_TREE_CHILDREN (node)[1] = SLP_TREE_CHILDREN (mul)[1];\n+\tSLP_TREE_CHILDREN (node)[2] = SLP_TREE_CHILDREN (sub)[1];\n+\tSLP_TREE_REF_COUNT (SLP_TREE_CHILDREN (node)[0])++;\n+\tSLP_TREE_REF_COUNT (SLP_TREE_CHILDREN (node)[1])++;\n+\tSLP_TREE_REF_COUNT (SLP_TREE_CHILDREN (node)[2])++;\n+\n+\t/* Build IFN_VEC_FMADDSUB from the mul/sub representative operands.  */\n+\tstmt_vec_info srep = SLP_TREE_REPRESENTATIVE (sub);\n+\tstmt_vec_info mrep = SLP_TREE_REPRESENTATIVE (mul);\n+\tgcall *call = gimple_build_call_internal (m_ifn, 3,\n+\t\t\t\t\t\t  gimple_assign_rhs1 (mrep->stmt),\n+\t\t\t\t\t\t  gimple_assign_rhs2 (mrep->stmt),\n+\t\t\t\t\t\t  gimple_assign_rhs2 (srep->stmt));\n+\tgimple_call_set_lhs (call, make_ssa_name\n+\t\t\t     (TREE_TYPE (gimple_assign_lhs (srep->stmt))));\n+\tgimple_call_set_nothrow (call, true);\n+\tgimple_set_bb (call, gimple_bb (srep->stmt));\n+\tstmt_vec_info new_rep = vinfo->add_pattern_stmt (call, srep);\n+\tSLP_TREE_REPRESENTATIVE (node) = new_rep;\n+\tSTMT_VINFO_RELEVANT (new_rep) = vect_used_in_scope;\n+\tSTMT_SLP_TYPE (new_rep) = pure_slp;\n+\tSTMT_VINFO_VECTYPE (new_rep) = SLP_TREE_VECTYPE (node);\n+\tSTMT_VINFO_SLP_VECT_ONLY_PATTERN (new_rep) = true;\n+\tSTMT_VINFO_REDUC_DEF (new_rep) = STMT_VINFO_REDUC_DEF (vect_orig_stmt (srep));\n+\tSLP_TREE_CODE (node) = ERROR_MARK;\n+\tSLP_TREE_LANE_PERMUTATION (node).release ();\n+\n+\tvect_free_slp_tree (sub);\n+\tvect_free_slp_tree (add);\n+\tbreak;\n+      }\n+    default:;\n+    }\n }\n \n /*******************************************************************************"}, {"sha": "5357cd0e7a4e4108bbd00bd3832de8c38b4792fb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d810646d421f6975300c0d06f4e9af27a48f26d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7d810646d421f6975300c0d06f4e9af27a48f26d", "patch": "@@ -3728,6 +3728,8 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t  case CFN_COMPLEX_MUL:\n \t\t  case CFN_COMPLEX_MUL_CONJ:\n \t\t  case CFN_VEC_ADDSUB:\n+\t\t  case CFN_VEC_FMADDSUB:\n+\t\t  case CFN_VEC_FMSUBADD:\n \t\t    vertices[idx].perm_in = 0;\n \t\t    vertices[idx].perm_out = 0;\n \t\t  default:;"}]}