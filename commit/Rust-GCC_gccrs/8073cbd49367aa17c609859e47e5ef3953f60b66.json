{"sha": "8073cbd49367aa17c609859e47e5ef3953f60b66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA3M2NiZDQ5MzY3YWExN2M2MDk4NTllNDdlNWVmMzk1M2Y2MGI2Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-12-19T21:58:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-12-19T21:58:02Z"}, "message": "re PR rtl-optimization/68910 (huge stack frame and poor code with instruction scheduling at -O2)\n\n\tPR rtl-optimization/68910\n\t* emit-rtl.c (set_unique_reg_note) <>REG_EQUAL>: Add bypass for USEs.\n\t* config/sparc/sparc.md (anddi3): Enable only in 64-bit mode.\n\t(iordi3): Likewise.\n\t(xordi3): Likewise.\n\t(one_cmpldi2): Likewise.\n\t(*anddi3_sp32): Delete.\n\t(*and_not_di_sp32): Likewise.\n\t(*iordi3_sp32): Likewise.\n\t(*or_not_di_sp32): Likewise.\n\t(*xordi3_sp32): Likewise.\n\t(*xor_not_di_sp32): Likewise.\n\t(32-bit DImode logical operations splitter): Likewise.\n\t(*one_cmpldi2_sp32): Likewise.\n\nFrom-SVN: r231851", "tree": {"sha": "679c22de52788aa1b63e543e49f16aedae25883d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/679c22de52788aa1b63e543e49f16aedae25883d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8073cbd49367aa17c609859e47e5ef3953f60b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8073cbd49367aa17c609859e47e5ef3953f60b66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8073cbd49367aa17c609859e47e5ef3953f60b66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8073cbd49367aa17c609859e47e5ef3953f60b66/comments", "author": null, "committer": null, "parents": [{"sha": "94d7642bda42e9105eed3038039417714acca729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d7642bda42e9105eed3038039417714acca729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d7642bda42e9105eed3038039417714acca729"}], "stats": {"total": 237, "additions": 66, "deletions": 171}, "files": [{"sha": "b1e6ab993029eefb2f365e2d7fd6f2ed1d46b637", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8073cbd49367aa17c609859e47e5ef3953f60b66", "patch": "@@ -1,3 +1,20 @@\n+2015-12-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/68910\n+\t* emit-rtl.c (set_unique_reg_note) <>REG_EQUAL>: Add bypass for USEs.\n+\t* config/sparc/sparc.md (anddi3): Enable only in 64-bit mode.\n+\t(iordi3): Likewise.\n+\t(xordi3): Likewise.\n+\t(one_cmpldi2): Likewise.\n+\t(*anddi3_sp32): Delete.\n+\t(*and_not_di_sp32): Likewise.\n+\t(*iordi3_sp32): Likewise.\n+\t(*or_not_di_sp32): Likewise.\n+\t(*xordi3_sp32): Likewise.\n+\t(*xor_not_di_sp32): Likewise.\n+\t(32-bit DImode logical operations splitter): Likewise.\n+\t(*one_cmpldi2_sp32): Likewise.\n+\n 2015-12-19  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* config/arc/arc.md (*storeqi_update): Use 'any_mem_operand' and"}, {"sha": "3654d1e688b5ad08b234130b2789470917842b6d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 4, "deletions": 170, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=8073cbd49367aa17c609859e47e5ef3953f60b66", "patch": "@@ -4740,24 +4740,7 @@\n \n ;; Boolean instructions.\n \n-;; We define DImode `and' so with DImode `not' we can get\n-;; DImode `andn'.  Other combinations are possible.\n-\n-(define_expand \"anddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*anddi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n-  \"! TARGET_ARCH64\"\n-  \"#\")\n-\n-(define_insn \"*anddi3_sp64\"\n+(define_insn \"anddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n \t\t(match_operand:DI 2 \"arith_operand\" \"rI\")))]\n@@ -4783,28 +4766,6 @@\n   operands[4] = GEN_INT (~INTVAL (operands[2]));\n })\n \n-(define_insn_and_split \"*and_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"%r\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_ARCH64\"\n-  \"#\"\n-  \"&& reload_completed\n-   && ((GET_CODE (operands[0]) == REG\n-        && SPARC_INT_REG_P (REGNO (operands[0])))\n-       || (GET_CODE (operands[0]) == SUBREG\n-           && GET_CODE (SUBREG_REG (operands[0])) == REG\n-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n-  [(set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))\n-   (set (match_dup 6) (and:SI (not:SI (match_dup 7)) (match_dup 8)))]\n-  \"operands[3] = gen_highpart (SImode, operands[0]);\n-   operands[4] = gen_highpart (SImode, operands[1]);\n-   operands[5] = gen_highpart (SImode, operands[2]);\n-   operands[6] = gen_lowpart (SImode, operands[0]);\n-   operands[7] = gen_lowpart (SImode, operands[1]);\n-   operands[8] = gen_lowpart (SImode, operands[2]);\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn \"*and_not_di_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"%r\"))\n@@ -4819,22 +4780,7 @@\n   \"\"\n   \"andn\\t%2, %1, %0\")\n \n-(define_expand \"iordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*iordi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n-  \"! TARGET_ARCH64\"\n-  \"#\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"*iordi3_sp64\"\n+(define_insn \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ior:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n \t\t(match_operand:DI 2 \"arith_operand\" \"rI\")))]\n@@ -4860,28 +4806,6 @@\n   operands[4] = gen_int_mode (~INTVAL (operands[2]), SImode);\n })\n \n-(define_insn_and_split \"*or_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_ARCH64\"\n-  \"#\"\n-  \"&& reload_completed\n-   && ((GET_CODE (operands[0]) == REG\n-        && SPARC_INT_REG_P (REGNO (operands[0])))\n-       || (GET_CODE (operands[0]) == SUBREG\n-           && GET_CODE (SUBREG_REG (operands[0])) == REG\n-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n-  [(set (match_dup 3) (ior:SI (not:SI (match_dup 4)) (match_dup 5)))\n-   (set (match_dup 6) (ior:SI (not:SI (match_dup 7)) (match_dup 8)))]\n-  \"operands[3] = gen_highpart (SImode, operands[0]);\n-   operands[4] = gen_highpart (SImode, operands[1]);\n-   operands[5] = gen_highpart (SImode, operands[2]);\n-   operands[6] = gen_lowpart (SImode, operands[0]);\n-   operands[7] = gen_lowpart (SImode, operands[1]);\n-   operands[8] = gen_lowpart (SImode, operands[2]);\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn \"*or_not_di_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n@@ -4896,22 +4820,7 @@\n   \"\"\n   \"orn\\t%2, %1, %0\")\n \n-(define_expand \"xordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*xordi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n-  \"! TARGET_ARCH64\"\n-  \"#\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"*xordi3_sp64\"\n+(define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(xor:DI (match_operand:DI 1 \"arith_operand\" \"%rJ\")\n \t\t(match_operand:DI 2 \"arith_operand\" \"rI\")))]\n@@ -4949,54 +4858,6 @@\n   operands[4] = gen_int_mode (~INTVAL (operands[2]), SImode);\n })\n \n-;; Split DImode logical operations requiring two instructions.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operator:DI 1 \"cc_arith_operator\"\t; AND, IOR, XOR\n-\t\t\t   [(match_operand:DI 2 \"register_operand\" \"\")\n-\t\t\t    (match_operand:DI 3 \"arith_double_operand\" \"\")]))]\n-  \"! TARGET_ARCH64\n-   && reload_completed\n-   && ((GET_CODE (operands[0]) == REG\n-        && SPARC_INT_REG_P (REGNO (operands[0])))\n-       || (GET_CODE (operands[0]) == SUBREG\n-           && GET_CODE (SUBREG_REG (operands[0])) == REG\n-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n-  [(set (match_dup 4) (match_op_dup:SI 1 [(match_dup 6) (match_dup 8)]))\n-   (set (match_dup 5) (match_op_dup:SI 1 [(match_dup 7) (match_dup 9)]))]\n-{\n-  operands[4] = gen_highpart (SImode, operands[0]);\n-  operands[5] = gen_lowpart (SImode, operands[0]);\n-  operands[6] = gen_highpart (SImode, operands[2]);\n-  operands[7] = gen_lowpart (SImode, operands[2]);\n-  operands[8] = gen_highpart_mode (SImode, DImode, operands[3]);\n-  operands[9] = gen_lowpart (SImode, operands[3]);\n-})\n-\n-;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b).\n-;; Combine now canonicalizes to the rightmost expression.\n-(define_insn_and_split \"*xor_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t(match_operand:DI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_ARCH64\"\n-  \"#\"\n-  \"&& reload_completed\n-   && ((GET_CODE (operands[0]) == REG\n-        && SPARC_INT_REG_P (REGNO (operands[0])))\n-       || (GET_CODE (operands[0]) == SUBREG\n-           && GET_CODE (SUBREG_REG (operands[0])) == REG\n-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n-  [(set (match_dup 3) (not:SI (xor:SI (match_dup 4) (match_dup 5))))\n-   (set (match_dup 6) (not:SI (xor:SI (match_dup 7) (match_dup 8))))]\n-  \"operands[3] = gen_highpart (SImode, operands[0]);\n-   operands[4] = gen_highpart (SImode, operands[1]);\n-   operands[5] = gen_highpart (SImode, operands[2]);\n-   operands[6] = gen_lowpart (SImode, operands[0]);\n-   operands[7] = gen_lowpart (SImode, operands[1]);\n-   operands[8] = gen_lowpart (SImode, operands[2]);\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn \"*xor_not_di_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (xor:DI (match_operand:DI 1 \"register_or_zero_operand\" \"rJ\")\n@@ -5245,34 +5106,7 @@\n   \"subcc\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n-;; We cannot use the \"not\" pseudo insn because the Sun assembler\n-;; does not know how to make it work for constants.\n-(define_expand \"one_cmpldi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(not:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn_and_split \"*one_cmpldi2_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n-  \"! TARGET_ARCH64\"\n-  \"#\"\n-  \"&& reload_completed\n-   && ((GET_CODE (operands[0]) == REG\n-        && SPARC_INT_REG_P (REGNO (operands[0])))\n-       || (GET_CODE (operands[0]) == SUBREG\n-           && GET_CODE (SUBREG_REG (operands[0])) == REG\n-           && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))\"\n-  [(set (match_dup 2) (not:SI (xor:SI (match_dup 3) (const_int 0))))\n-   (set (match_dup 4) (not:SI (xor:SI (match_dup 5) (const_int 0))))]\n-  \"operands[2] = gen_highpart (SImode, operands[0]);\n-   operands[3] = gen_highpart (SImode, operands[1]);\n-   operands[4] = gen_lowpart (SImode, operands[0]);\n-   operands[5] = gen_lowpart (SImode, operands[1]);\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"*one_cmpldi2_sp64\"\n+(define_insn \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_operand:DI 1 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\""}, {"sha": "dbc0af09a0807c4945a7dc1f0c955157ea3c003d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=8073cbd49367aa17c609859e47e5ef3953f60b66", "patch": "@@ -5239,7 +5239,8 @@ set_unique_reg_note (rtx insn, enum reg_note kind, rtx datum)\n     {\n     case REG_EQUAL:\n     case REG_EQUIV:\n-      if (!set_for_reg_notes (insn))\n+      /* We need to support the REG_EQUAL on USE trick of find_reloads.  */\n+      if (!set_for_reg_notes (insn) && GET_CODE (PATTERN (insn)) != USE)\n \treturn NULL_RTX;\n \n       /* Don't add ASM_OPERAND REG_EQUAL/REG_EQUIV notes."}, {"sha": "b1c48334d774d190e38c1e3a286bc4fa66dea297", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8073cbd49367aa17c609859e47e5ef3953f60b66", "patch": "@@ -1,3 +1,7 @@\n+2015-12-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/sparc/20151219-1.c: New test.\n+\n 2015-12-19  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gcc.target/arc/load-update.c: New file."}, {"sha": "efe720af6cd7c3d9c15dd8391268818660c81c94", "filename": "gcc/testsuite/gcc.target/sparc/20151219-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20151219-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8073cbd49367aa17c609859e47e5ef3953f60b66/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20151219-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20151219-1.c?ref=8073cbd49367aa17c609859e47e5ef3953f60b66", "patch": "@@ -0,0 +1,39 @@\n+/* PR rtl-optimization/68910 */\n+/* Reported by Sebastian Huber <sebastian.huber@embedded-brains.de> */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mtune=supersparc\" } */\n+\n+typedef unsigned int size_t;\n+typedef long long unsigned int uint64_t;\n+\n+extern void *memcpy (void *, const void *, size_t);\n+\n+void\n+SHA512_Transform(uint64_t * state, const unsigned char block[128])\n+{\n+  uint64_t W[80];\n+  uint64_t S[8];\n+  uint64_t t0, t1;\n+  int i;\n+\n+  memcpy ((void *)W, (const void *)block, (size_t)128);\n+\n+  for (i = 16; i < 80; i++)\n+    W[i] = (((W[i - 2] >> 19) | (W[i - 2] << (64 - 19))) ^ ((W[i - 2] >> 61) | (W[i - 2] << (64 - 61))) ^ (W[i - 2] >> 6)) + W[i - 7] + (((W[i - 15] >> 1) | (W[i - 15] << (64 - 1))) ^ ((W[i - 15] >> 8) | (W[i - 15] << (64 - 8))) ^ (W[i - 15] >> 7)) + W[i - 16];\n+\n+  memcpy (S, state, 64);\n+\n+  t0 = S[(87 - 0) % 8] + (((S[(84 - 0) % 8] >> 14) | (S[(84 - 0) % 8] << (64 - 14))) ^ ((S[(84 - 0) % 8] >> 18) | (S[(84 - 0) % 8] << (64 - 18))) ^ ((S[(84 - 0) % 8] >> 41) | (S[(84 - 0) % 8] << (64 - 41)))) + ((S[(84 - 0) % 8] & (S[(85 - 0) % 8] ^ S[(86 - 0) % 8])) ^ S[(86 - 0) % 8]) + W[0] + 0x428a2f98d728ae22ULL; t1 = (((S[(80 - 0) % 8] >> 28) | (S[(80 - 0) % 8] << (64 - 28))) ^ ((S[(80 - 0) % 8] >> 34) | (S[(80 - 0) % 8] << (64 - 34))) ^ ((S[(80 - 0) % 8] >> 39) | (S[(80 - 0) % 8] << (64 - 39)))) + ((S[(80 - 0) % 8] & (S[(81 - 0) % 8] | S[(82 - 0) % 8])) | (S[(81 - 0) % 8] & S[(82 - 0) % 8])); S[(83 - 0) % 8] += t0; S[(87 - 0) % 8] = t0 + t1;\n+\n+  t0 = S[(87 - 1) % 8] + (((S[(84 - 1) % 8] >> 14) | (S[(84 - 1) % 8] << (64 - 14))) ^ ((S[(84 - 1) % 8] >> 18) | (S[(84 - 1) % 8] << (64 - 18))) ^ ((S[(84 - 1) % 8] >> 41) | (S[(84 - 1) % 8] << (64 - 41)))) + ((S[(84 - 1) % 8] & (S[(85 - 1) % 8] ^ S[(86 - 1) % 8])) ^ S[(86 - 1) % 8]) + W[1] + 0x7137449123ef65cdULL; t1 = (((S[(80 - 1) % 8] >> 28) | (S[(80 - 1) % 8] << (64 - 28))) ^ ((S[(80 - 1) % 8] >> 34) | (S[(80 - 1) % 8] << (64 - 34))) ^ ((S[(80 - 1) % 8] >> 39) | (S[(80 - 1) % 8] << (64 - 39)))) + ((S[(80 - 1) % 8] & (S[(81 - 1) % 8] | S[(82 - 1) % 8])) | (S[(81 - 1) % 8] & S[(82 - 1) % 8])); S[(83 - 1) % 8] += t0; S[(87 - 1) % 8] = t0 + t1;\n+\n+  t0 = S[(87 - 2) % 8] + (((S[(84 - 2) % 8] >> 14) | (S[(84 - 2) % 8] << (64 - 14))) ^ ((S[(84 - 2) % 8] >> 18) | (S[(84 - 2) % 8] << (64 - 18))) ^ ((S[(84 - 2) % 8] >> 41) | (S[(84 - 2) % 8] << (64 - 41)))) + ((S[(84 - 2) % 8] & (S[(85 - 2) % 8] ^ S[(86 - 2) % 8])) ^ S[(86 - 2) % 8]) + W[2] + 0xb5c0fbcfec4d3b2fULL; t1 = (((S[(80 - 2) % 8] >> 28) | (S[(80 - 2) % 8] << (64 - 28))) ^ ((S[(80 - 2) % 8] >> 34) | (S[(80 - 2) % 8] << (64 - 34))) ^ ((S[(80 - 2) % 8] >> 39) | (S[(80 - 2) % 8] << (64 - 39)))) + ((S[(80 - 2) % 8] & (S[(81 - 2) % 8] | S[(82 - 2) % 8])) | (S[(81 - 2) % 8] & S[(82 - 2) % 8])); S[(83 - 2) % 8] += t0; S[(87 - 2) % 8] = t0 + t1;\n+\n+  t0 = S[(87 - 3) % 8] + (((S[(84 - 3) % 8] >> 14) | (S[(84 - 3) % 8] << (64 - 14))) ^ ((S[(84 - 3) % 8] >> 18) | (S[(84 - 3) % 8] << (64 - 18))) ^ ((S[(84 - 3) % 8] >> 41) | (S[(84 - 3) % 8] << (64 - 41)))) + ((S[(84 - 3) % 8] & (S[(85 - 3) % 8] ^ S[(86 - 3) % 8])) ^ S[(86 - 3) % 8]) + W[3] + 0xe9b5dba58189dbbcULL; t1 = (((S[(80 - 3) % 8] >> 28) | (S[(80 - 3) % 8] << (64 - 28))) ^ ((S[(80 - 3) % 8] >> 34) | (S[(80 - 3) % 8] << (64 - 34))) ^ ((S[(80 - 3) % 8] >> 39) | (S[(80 - 3) % 8] << (64 - 39)))) + ((S[(80 - 3) % 8] & (S[(81 - 3) % 8] | S[(82 - 3) % 8])) | (S[(81 - 3) % 8] & S[(82 - 3) % 8])); S[(83 - 3) % 8] += t0; S[(87 - 3) % 8] = t0 + t1;\n+\n+  for (i = 0; i < 8; i++)\n+    state[i] += S[i];\n+}\n+\n+/* { dg-final { scan-assembler-not \"stx\\t%\" } } */"}]}