{"sha": "8e007055dd1374ca4c44406a4ead172be0dfa3a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUwMDcwNTVkZDEzNzRjYTRjNDQ0MDZhNGVhZDE3MmJlMGRmYTNhOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-05T07:38:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-05T07:38:21Z"}, "message": "PR c++/91369 - Implement P0784R7: constexpr new\n\n\tPR c++/91369 - Implement P0784R7: constexpr new\nc-family/\n\t* c-cppbuiltin.c (c_cpp_builtins): Predefine\n\t__cpp_constexpr_dynamic_alloc=201907 for -std=c++2a.\ncp/\n\t* cp-tree.h (enum cp_tree_index): Add CPTI_HEAP_UNINIT_IDENTIFIER,\n\tCPTI_HEAP_IDENTIFIER and CPTI_HEAP_DELETED_IDENTIFIER.\n\t(heap_uninit_identifier, heap_identifier, heap_deleted_identifier):\n\tDefine.\n\t(type_has_constexpr_destructor, build_new_constexpr_heap_type,\n\tcxx_constant_dtor): Declare.\n\t* class.c (type_maybe_constexpr_default_constructor): Make static.\n\t(type_maybe_constexpr_destructor, type_has_constexpr_destructor): New\n\tfunctions.\n\t(finalize_literal_type_property): For c++2a, don't clear\n\tCLASSTYPE_LITERAL_P for types without trivial destructors unless they\n\thave non-constexpr destructors.\n\t(explain_non_literal_class): For c++2a, complain about non-constexpr\n\tdestructors rather than about non-trivial destructors.\n\t* constexpr.c: Include stor-layout.h.\n\t(struct constexpr_global_ctx): New type.\n\t(struct constexpr_ctx): Add global field, remove values and\n\tconstexpr_ops_count.\n\t(cxx_replaceable_global_alloc_fn): New inline function.\n\t(cxx_eval_call_expression): For c++2a allow calls to replaceable\n\tglobal allocation functions, for new return address of a heap uninit\n\tvar, for delete record its deletion.  Change ctx->values->{get,put} to\n\tctx->global->values.{get,put}.\n\t(non_const_var_error): Add auto_diagnostic_group sentinel.  Emit\n\tspecial diagnostics for heap variables.\n\t(cxx_eval_store_expression): Change ctx->values->{get,put} to\n\tctx->global->values.{get,put}.\n\t(cxx_eval_loop_expr): Initialize jump_target if NULL.  Change\n\tnew_ctx.values->remove to ctx->global->values.remove.\n\t(cxx_eval_constant_expression): Change *ctx->constexpr_ops_count\n\tto ctx->global->constexpr_ops_count.  Change ctx->values->{get,put} to\n\tctx->global->values.{get,put}.\n\t<case NOP_EXPR>: Formatting fix.  On cast of replaceable global\n\tallocation function to some pointer type, adjust the type of\n\tthe heap variable and change name from heap_uninit_identifier\n\tto heap_identifier.\n\t(find_heap_var_refs): New function.\n\t(cxx_eval_outermost_constant_expr): Add constexpr_dtor argument,\n\thandle evaluation of constexpr dtors and add tracking of heap\n\tvariables.  Use tf_no_cleanup for get_target_expr_with_sfinae.\n\t(cxx_constant_value): Adjust cxx_eval_outermost_constant_expr caller.\n\t(cxx_constant_dtor): New function.\n\t(maybe_constant_value, fold_non_dependent_expr_template,\n\tmaybe_constant_init_1): Adjust cxx_eval_outermost_constant_expr\n\tcallers.\n\t(potential_constant_expression_1): Ignore clobbers.  Allow\n\tCOND_EXPR_IS_VEC_DELETE for c++2a.\n\t* decl.c (initialize_predefined_identifiers): Add heap identifiers.\n\t(decl_maybe_constant_destruction): New function.\n\t(cp_finish_decl): Don't clear TREE_READONLY for constexpr variables\n\twith non-trivial, but constexpr destructors.\n\t(register_dtor_fn): For constexpr variables with constexpr non-trivial\n\tdestructors call cxx_maybe_build_cleanup instead of adding destructor\n\tcalls at runtime.\n\t(expand_static_init): For constexpr variables with constexpr\n\tnon-trivial destructors call cxx_maybe_build_cleanup.\n\t(grokdeclarator): Allow constexpr destructors for c++2a.  Formatting\n\tfix.\n\t(cxx_maybe_build_cleanup): For constexpr variables with constexpr\n\tnon-trivial destructors call cxx_constant_dtor instead of adding\n\tdestructor calls at runtime.\n\t* init.c: Include stor-layout.h.\n\t(build_new_constexpr_heap_type, maybe_wrap_new_for_constexpr): New\n\tfunctions.\n\t(build_new_1): For c++2a and new[], add cast around the alloc call\n\tto help constexpr evaluation figure out the type of the heap storage.\n\t(build_vec_delete_1): Set DECL_INITIAL of tbase and emit a DECL_EXPR\n\tfor it instead of initializing an uninitialized variable.\n\t* method.c: Include intl.h.\n\t(SFK_CTOR_P, SFK_DTOR_P, SFK_ASSIGN_P, SFK_COPY_P, SFK_MOVE_P): Move\n\tdefinitions earlier.\n\t(process_subob_fn): Add sfk argument, adjust non-constexpr call\n\tdiagnostics based on it.\n\t(walk_field_subobs): Formatting fixes.  Adjust process_subob_fn caller.\n\t(synthesized_method_base_walk): Likewise.\n\t(synthesized_method_walk): Set *constexpr_p to true for dtors in c++2a.\n\tFix up DR number in comment.\n\t(implicitly_declare_fn): Formatting fix.\n\t* typeck2.c (store_init_value): Don't call cp_fully_fold_init on\n\tinitializers of automatic non-constexpr variables in constexpr\n\tfunctions.\ntestsuite/\n\t* g++.dg/cpp0x/constexpr-delete2.C: Adjust expected diagnostics for\n\tc++2a.\n\t* g++.dg/cpp0x/locations1.C: Only expect constexpr ~S() diagnostics\n\tin c++17_down, adjust expected wording.\n\t* g++.dg/cpp1y/constexpr-new.C: Only expect diagnostics in c++17_down.\n\t* g++.dg/cpp2a/constexpr-dtor1.C: New test.\n\t* g++.dg/cpp2a/constexpr-dtor2.C: New test.\n\t* g++.dg/cpp2a/constexpr-dtor3.C: New test.\n\t* g++.dg/cpp2a/constexpr-new1.C: New test.\n\t* g++.dg/cpp2a/constexpr-new2.C: New test.\n\t* g++.dg/cpp2a/constexpr-new3.C: New test.\n\t* g++.dg/cpp2a/constexpr-new4.C: New test.\n\t* g++.dg/cpp2a/feat-cxx2a.C: Add __cpp_constinit and\n\t__cpp_constexpr_dynamic_alloc tests.  Tweak __cpp_* tests for c++2a\n\tfeatures to use style like older features, including #ifdef test.\n\t* g++.dg/ext/is_literal_type3.C: New test.\n\nFrom-SVN: r276622", "tree": {"sha": "6d2808d70c3cd75cdf81b49e2d1d7495f7ae4516", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d2808d70c3cd75cdf81b49e2d1d7495f7ae4516"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e007055dd1374ca4c44406a4ead172be0dfa3a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e007055dd1374ca4c44406a4ead172be0dfa3a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e007055dd1374ca4c44406a4ead172be0dfa3a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e007055dd1374ca4c44406a4ead172be0dfa3a8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0043b5280e6f571819d8764d76594a7a20467d00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0043b5280e6f571819d8764d76594a7a20467d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0043b5280e6f571819d8764d76594a7a20467d00"}], "stats": {"total": 1216, "additions": 1082, "deletions": 134}, "files": [{"sha": "7deaff065cf0f6d626afbd81522f032212be7253", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -1,3 +1,9 @@\n+2019-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/91369 - Implement P0784R7: constexpr new\n+\t* c-cppbuiltin.c (c_cpp_builtins): Predefine\n+\t__cpp_constexpr_dynamic_alloc=201907 for -std=c++2a.\n+\n 2019-10-04  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/82752"}, {"sha": "9e0ce428127e78dab9ebd7468525feece6341f58", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -989,6 +989,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_constinit=201907\");\n \t  cpp_define (pfile, \"__cpp_nontype_template_parameter_class=201806\");\n \t  cpp_define (pfile, \"__cpp_impl_destroying_delete=201806\");\n+\t  cpp_define (pfile, \"__cpp_constexpr_dynamic_alloc=201907\");\n \t}\n       if (flag_concepts)\n \tcpp_define (pfile, \"__cpp_concepts=201507\");"}, {"sha": "b40825ee8696c98e1d5803ab2cebdb9b4475971b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -1,3 +1,88 @@\n+2019-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/91369 - Implement P0784R7: constexpr new\n+\t* cp-tree.h (enum cp_tree_index): Add CPTI_HEAP_UNINIT_IDENTIFIER,\n+\tCPTI_HEAP_IDENTIFIER and CPTI_HEAP_DELETED_IDENTIFIER.\n+\t(heap_uninit_identifier, heap_identifier, heap_deleted_identifier):\n+\tDefine.\n+\t(type_has_constexpr_destructor, build_new_constexpr_heap_type,\n+\tcxx_constant_dtor): Declare.\n+\t* class.c (type_maybe_constexpr_default_constructor): Make static.\n+\t(type_maybe_constexpr_destructor, type_has_constexpr_destructor): New\n+\tfunctions.\n+\t(finalize_literal_type_property): For c++2a, don't clear\n+\tCLASSTYPE_LITERAL_P for types without trivial destructors unless they\n+\thave non-constexpr destructors.\n+\t(explain_non_literal_class): For c++2a, complain about non-constexpr\n+\tdestructors rather than about non-trivial destructors.\n+\t* constexpr.c: Include stor-layout.h.\n+\t(struct constexpr_global_ctx): New type.\n+\t(struct constexpr_ctx): Add global field, remove values and\n+\tconstexpr_ops_count.\n+\t(cxx_replaceable_global_alloc_fn): New inline function.\n+\t(cxx_eval_call_expression): For c++2a allow calls to replaceable\n+\tglobal allocation functions, for new return address of a heap uninit\n+\tvar, for delete record its deletion.  Change ctx->values->{get,put} to\n+\tctx->global->values.{get,put}.\n+\t(non_const_var_error): Add auto_diagnostic_group sentinel.  Emit\n+\tspecial diagnostics for heap variables.\n+\t(cxx_eval_store_expression): Change ctx->values->{get,put} to\n+\tctx->global->values.{get,put}.\n+\t(cxx_eval_loop_expr): Initialize jump_target if NULL.  Change\n+\tnew_ctx.values->remove to ctx->global->values.remove.\n+\t(cxx_eval_constant_expression): Change *ctx->constexpr_ops_count\n+\tto ctx->global->constexpr_ops_count.  Change ctx->values->{get,put} to\n+\tctx->global->values.{get,put}.\n+\t<case NOP_EXPR>: Formatting fix.  On cast of replaceable global\n+\tallocation function to some pointer type, adjust the type of\n+\tthe heap variable and change name from heap_uninit_identifier\n+\tto heap_identifier.\n+\t(find_heap_var_refs): New function.\n+\t(cxx_eval_outermost_constant_expr): Add constexpr_dtor argument,\n+\thandle evaluation of constexpr dtors and add tracking of heap\n+\tvariables.  Use tf_no_cleanup for get_target_expr_with_sfinae.\n+\t(cxx_constant_value): Adjust cxx_eval_outermost_constant_expr caller.\n+\t(cxx_constant_dtor): New function.\n+\t(maybe_constant_value, fold_non_dependent_expr_template,\n+\tmaybe_constant_init_1): Adjust cxx_eval_outermost_constant_expr\n+\tcallers.\n+\t(potential_constant_expression_1): Ignore clobbers.  Allow\n+\tCOND_EXPR_IS_VEC_DELETE for c++2a.\n+\t* decl.c (initialize_predefined_identifiers): Add heap identifiers.\n+\t(decl_maybe_constant_destruction): New function.\n+\t(cp_finish_decl): Don't clear TREE_READONLY for constexpr variables\n+\twith non-trivial, but constexpr destructors.\n+\t(register_dtor_fn): For constexpr variables with constexpr non-trivial\n+\tdestructors call cxx_maybe_build_cleanup instead of adding destructor\n+\tcalls at runtime.\n+\t(expand_static_init): For constexpr variables with constexpr\n+\tnon-trivial destructors call cxx_maybe_build_cleanup.\n+\t(grokdeclarator): Allow constexpr destructors for c++2a.  Formatting\n+\tfix.\n+\t(cxx_maybe_build_cleanup): For constexpr variables with constexpr\n+\tnon-trivial destructors call cxx_constant_dtor instead of adding\n+\tdestructor calls at runtime.\n+\t* init.c: Include stor-layout.h.\n+\t(build_new_constexpr_heap_type, maybe_wrap_new_for_constexpr): New\n+\tfunctions.\n+\t(build_new_1): For c++2a and new[], add cast around the alloc call\n+\tto help constexpr evaluation figure out the type of the heap storage.\n+\t(build_vec_delete_1): Set DECL_INITIAL of tbase and emit a DECL_EXPR\n+\tfor it instead of initializing an uninitialized variable.\n+\t* method.c: Include intl.h.\n+\t(SFK_CTOR_P, SFK_DTOR_P, SFK_ASSIGN_P, SFK_COPY_P, SFK_MOVE_P): Move\n+\tdefinitions earlier.\n+\t(process_subob_fn): Add sfk argument, adjust non-constexpr call\n+\tdiagnostics based on it.\n+\t(walk_field_subobs): Formatting fixes.  Adjust process_subob_fn caller.\n+\t(synthesized_method_base_walk): Likewise.\n+\t(synthesized_method_walk): Set *constexpr_p to true for dtors in c++2a.\n+\tFix up DR number in comment.\n+\t(implicitly_declare_fn): Formatting fix.\n+\t* typeck2.c (store_init_value): Don't call cp_fully_fold_init on\n+\tinitializers of automatic non-constexpr variables in constexpr\n+\tfunctions.\n+\n 2019-10-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/71504"}, {"sha": "4abcfaf4c1d2fa8dc92634ab4e4bb5d6dc4b1488", "filename": "gcc/cp/class.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -206,6 +206,7 @@ static int empty_base_at_nonzero_offset_p (tree, tree, splay_tree);\n static tree end_of_base (tree);\n static tree get_vcall_index (tree, tree);\n static bool type_maybe_constexpr_default_constructor (tree);\n+static bool type_maybe_constexpr_destructor (tree);\n static bool field_poverlapping_p (tree);\n \n /* Return a COND_EXPR that executes TRUE_STMT if this execution of the\n@@ -5242,7 +5243,7 @@ type_has_constexpr_default_constructor (tree t)\n    without forcing a lazy declaration (which might cause undesired\n    instantiations).  */\n \n-bool\n+static bool\n type_maybe_constexpr_default_constructor (tree t)\n {\n   if (CLASS_TYPE_P (t) && CLASSTYPE_LAZY_DEFAULT_CTOR (t)\n@@ -5252,6 +5253,34 @@ type_maybe_constexpr_default_constructor (tree t)\n   return type_has_constexpr_default_constructor (t);\n }\n \n+/* Returns true iff class T has a constexpr destructor.  */\n+\n+bool\n+type_has_constexpr_destructor (tree t)\n+{\n+  tree fns;\n+\n+  if (CLASSTYPE_LAZY_DESTRUCTOR (t))\n+    /* Non-trivial, we need to check subobject destructors.  */\n+    lazily_declare_fn (sfk_destructor, t);\n+  fns = CLASSTYPE_DESTRUCTOR (t);\n+  return (fns && DECL_DECLARED_CONSTEXPR_P (fns));\n+}\n+\n+/* Returns true iff class T has a constexpr destructor or has an\n+   implicitly declared destructor that we can't tell if it's constexpr\n+   without forcing a lazy declaration (which might cause undesired\n+   instantiations).  */\n+\n+static bool\n+type_maybe_constexpr_destructor (tree t)\n+{\n+  if (CLASS_TYPE_P (t) && CLASSTYPE_LAZY_DESTRUCTOR (t))\n+    /* Assume it's constexpr.  */\n+    return true;\n+  return type_has_constexpr_destructor (t);\n+}\n+\n /* Returns true iff class TYPE has a virtual destructor.  */\n \n bool\n@@ -5503,8 +5532,11 @@ finalize_literal_type_property (tree t)\n {\n   tree fn;\n \n-  if (cxx_dialect < cxx11\n-      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n+  if (cxx_dialect < cxx11)\n+    CLASSTYPE_LITERAL_P (t) = false;\n+  else if (CLASSTYPE_LITERAL_P (t)\n+\t   && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n+\t   && (cxx_dialect < cxx2a || !type_maybe_constexpr_destructor (t)))\n     CLASSTYPE_LITERAL_P (t) = false;\n   else if (CLASSTYPE_LITERAL_P (t) && LAMBDA_TYPE_P (t))\n     CLASSTYPE_LITERAL_P (t) = (cxx_dialect >= cxx17);\n@@ -5558,8 +5590,12 @@ explain_non_literal_class (tree t)\n     inform (UNKNOWN_LOCATION,\n \t    \"  %qT is a closure type, which is only literal in \"\n \t    \"C++17 and later\", t);\n-  else if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n+  else if (cxx_dialect < cxx2a && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n     inform (UNKNOWN_LOCATION, \"  %q+T has a non-trivial destructor\", t);\n+  else if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n+\t   && !type_maybe_constexpr_destructor (t))\n+    inform (UNKNOWN_LOCATION, \"  %q+T does not have %<constexpr%> destructor\",\n+\t    t);\n   else if (CLASSTYPE_NON_AGGREGATE (t)\n \t   && !TYPE_HAS_TRIVIAL_DFLT (t)\n \t   && !LAMBDA_TYPE_P (t)"}, {"sha": "f50cc04c2932b3a3256a9080b582d5dffbb00139", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 277, "deletions": 63, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-fold.h\"\n #include \"timevar.h\"\n #include \"fold-const-call.h\"\n+#include \"stor-layout.h\"\n \n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n@@ -1006,17 +1007,35 @@ enum constexpr_switch_state {\n   css_default_processing\n };\n \n+/* The constexpr expansion context part which needs one instance per\n+   cxx_eval_outermost_constant_expr invocation.  VALUES is a map of values of\n+   variables initialized within the expression.  */\n+\n+struct constexpr_global_ctx {\n+  /* Values for any temporaries or local variables within the\n+     constant-expression. */\n+  hash_map<tree,tree> values;\n+  /* Number of cxx_eval_constant_expression calls (except skipped ones,\n+     on simple constants or location wrappers) encountered during current\n+     cxx_eval_outermost_constant_expr call.  */\n+  HOST_WIDE_INT constexpr_ops_count;\n+  /* Heap VAR_DECLs created during the evaluation of the outermost constant\n+     expression.  */\n+  auto_vec<tree, 16> heap_vars;\n+  /* Constructor.  */\n+  constexpr_global_ctx () : constexpr_ops_count (0) {}\n+};\n+\n /* The constexpr expansion context.  CALL is the current function\n    expansion, CTOR is the current aggregate initializer, OBJECT is the\n-   object being initialized by CTOR, either a VAR_DECL or a _REF.  VALUES\n-   is a map of values of variables initialized within the expression.  */\n+   object being initialized by CTOR, either a VAR_DECL or a _REF.    */\n \n struct constexpr_ctx {\n+  /* The part of the context that needs to be unique to the whole\n+     cxx_eval_outermost_constant_expr invocation.  */\n+  constexpr_global_ctx *global;\n   /* The innermost call we're evaluating.  */\n   constexpr_call *call;\n-  /* Values for any temporaries or local variables within the\n-     constant-expression. */\n-  hash_map<tree,tree> *values;\n   /* SAVE_EXPRs that we've seen within the current LOOP_EXPR.  NULL if we\n      aren't inside a loop.  */\n   vec<tree> *save_exprs;\n@@ -1027,10 +1046,6 @@ struct constexpr_ctx {\n   tree object;\n   /* If inside SWITCH_EXPR.  */\n   constexpr_switch_state *css_state;\n-  /* Number of cxx_eval_constant_expression calls (except skipped ones,\n-     on simple constants or location wrappers) encountered during current\n-     cxx_eval_outermost_constant_expr call.  */\n-  HOST_WIDE_INT *constexpr_ops_count;\n \n   /* Whether we should error on a non-constant expression or fail quietly.  */\n   bool quiet;\n@@ -1578,6 +1593,17 @@ modifying_const_object_error (tree expr, tree obj)\n   inform (location_of (obj), \"originally declared %<const%> here\");\n }\n \n+/* Return true if FNDECL is a replaceable global allocation function that\n+   should be useable during constant expression evaluation.  */\n+\n+static inline bool\n+cxx_replaceable_global_alloc_fn (tree fndecl)\n+{\n+  return (cxx_dialect >= cxx2a\n+\t  && IDENTIFIER_NEWDEL_OP_P (DECL_NAME (fndecl))\n+\t  && CP_DECL_CONTEXT (fndecl) == global_namespace);\n+}\n+\n /* Subroutine of cxx_eval_constant_expression.\n    Evaluate the call expression tree T in the context of OLD_CALL expression\n    evaluation.  */\n@@ -1656,6 +1682,62 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t   lval, non_constant_p, overflow_p);\n   if (!DECL_DECLARED_CONSTEXPR_P (fun))\n     {\n+      if (cxx_replaceable_global_alloc_fn (fun))\n+\t{\n+\t  const int nargs = call_expr_nargs (t);\n+\t  tree arg0 = NULL_TREE;\n+\t  for (int i = 0; i < nargs; ++i)\n+\t    {\n+\t      tree arg = CALL_EXPR_ARG (t, i);\n+\t      arg = cxx_eval_constant_expression (ctx, arg, false,\n+\t\t\t\t\t\t  non_constant_p, overflow_p);\n+\t      VERIFY_CONSTANT (arg);\n+\t      if (i == 0)\n+\t\targ0 = arg;\n+\t    }\n+\t  gcc_assert (arg0);\n+\t  if (IDENTIFIER_NEW_OP_P (DECL_NAME (fun)))\n+\t    {\n+\t      tree type = build_array_type_nelts (char_type_node,\n+\t\t\t\t\t\t  tree_to_uhwi (arg0));\n+\t      tree var = build_decl (loc, VAR_DECL, heap_uninit_identifier,\n+\t\t\t\t     type);\n+\t      DECL_ARTIFICIAL (var) = 1;\n+\t      TREE_STATIC (var) = 1;\n+\t      ctx->global->heap_vars.safe_push (var);\n+\t      ctx->global->values.put (var, NULL_TREE);\n+\t      return fold_convert (ptr_type_node, build_address (var));\n+\t    }\n+\t  else\n+\t    {\n+\t      STRIP_NOPS (arg0);\n+\t      if (TREE_CODE (arg0) == ADDR_EXPR\n+\t\t  && VAR_P (TREE_OPERAND (arg0, 0)))\n+\t\t{\n+\t\t  tree var = TREE_OPERAND (arg0, 0);\n+\t\t  if (DECL_NAME (var) == heap_uninit_identifier\n+\t\t      || DECL_NAME (var) == heap_identifier)\n+\t\t    {\n+\t\t      DECL_NAME (var) = heap_deleted_identifier;\n+\t\t      ctx->global->values.remove (var);\n+\t\t      return void_node;\n+\t\t    }\n+\t\t  else if (DECL_NAME (var) == heap_deleted_identifier)\n+\t\t    {\n+\t\t      if (!ctx->quiet)\n+\t\t\terror_at (loc, \"deallocation of already deallocated \"\n+\t\t\t\t       \"storage\");\n+\t\t      *non_constant_p = true;\n+\t\t      return t;\n+\t\t    }\n+\t\t}\n+\t      if (!ctx->quiet)\n+\t\terror_at (loc, \"deallocation of storage that was \"\n+\t\t\t       \"not previously allocated\");\n+\t      *non_constant_p = true;\n+\t      return t;\n+\t    }\n+\t}\n       if (!ctx->quiet)\n \t{\n \t  if (!lambda_static_thunk_p (fun))\n@@ -1675,7 +1757,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       new_ctx.object = AGGR_INIT_EXPR_SLOT (t);\n       tree ctor = new_ctx.ctor = build_constructor (DECL_CONTEXT (fun), NULL);\n       CONSTRUCTOR_NO_CLEARING (ctor) = true;\n-      ctx->values->put (new_ctx.object, ctor);\n+      ctx->global->values.put (new_ctx.object, ctor);\n       ctx = &new_ctx;\n     }\n \n@@ -1877,7 +1959,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      arg = unshare_constructor (arg);\n \t      if (TREE_CODE (arg) == CONSTRUCTOR)\n \t\tvec_safe_push (ctors, arg);\n-\t      ctx->values->put (remapped, arg);\n+\t      ctx->global->values.put (remapped, arg);\n \t      remapped = DECL_CHAIN (remapped);\n \t    }\n \t  /* Add the RESULT_DECL to the values map, too.  */\n@@ -1887,11 +1969,11 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      slot = AGGR_INIT_EXPR_SLOT (t);\n \t      tree addr = build_address (slot);\n \t      addr = build_nop (TREE_TYPE (res), addr);\n-\t      ctx->values->put (res, addr);\n-\t      ctx->values->put (slot, NULL_TREE);\n+\t      ctx->global->values.put (res, addr);\n+\t      ctx->global->values.put (slot, NULL_TREE);\n \t    }\n \t  else\n-\t    ctx->values->put (res, NULL_TREE);\n+\t    ctx->global->values.put (res, NULL_TREE);\n \n \t  /* Track the callee's evaluated SAVE_EXPRs so that we can forget\n \t     their values after the call.  */\n@@ -1916,7 +1998,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t    result = void_node;\n \t  else\n \t    {\n-\t      result = *ctx->values->get (slot ? slot : res);\n+\t      result = *ctx->global->values.get (slot ? slot : res);\n \t      if (result == NULL_TREE && !*non_constant_p)\n \t\t{\n \t\t  if (!ctx->quiet)\n@@ -1934,8 +2016,8 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      && CLASS_TYPE_P (TREE_TYPE (new_obj))\n \t      && CP_TYPE_CONST_P (TREE_TYPE (new_obj)))\n \t    {\n-\t      /* Subobjects might not be stored in ctx->values but we can\n-\t\t get its CONSTRUCTOR by evaluating *this.  */\n+\t      /* Subobjects might not be stored in ctx->global->values but we\n+\t\t can get its CONSTRUCTOR by evaluating *this.  */\n \t      tree e = cxx_eval_constant_expression (ctx, new_obj,\n \t\t\t\t\t\t     /*lval*/false,\n \t\t\t\t\t\t     non_constant_p,\n@@ -1947,17 +2029,17 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  unsigned int i;\n \t  tree save_expr;\n \t  FOR_EACH_VEC_ELT (save_exprs, i, save_expr)\n-\t    ctx_with_save_exprs.values->remove (save_expr);\n+\t    ctx->global->values.remove (save_expr);\n \n \t  /* Remove the parms/result from the values map.  Is it worth\n \t     bothering to do this when the map itself is only live for\n \t     one constexpr evaluation?  If so, maybe also clear out\n \t     other vars from call, maybe in BIND_EXPR handling?  */\n-\t  ctx->values->remove (res);\n+\t  ctx->global->values.remove (res);\n \t  if (slot)\n-\t    ctx->values->remove (slot);\n+\t    ctx->global->values.remove (slot);\n \t  for (tree parm = parms; parm; parm = TREE_CHAIN (parm))\n-\t    ctx->values->remove (parm);\n+\t    ctx->global->values.remove (parm);\n \n \t  /* Free any parameter CONSTRUCTORs we aren't returning directly.  */\n \t  while (!ctors->is_empty ())\n@@ -3077,7 +3159,7 @@ verify_ctor_sanity (const constexpr_ctx *ctx, tree type)\n \t\t\t  (TREE_TYPE (type), TREE_TYPE (otype)))));\n     }\n   gcc_assert (!ctx->object || !DECL_P (ctx->object)\n-\t      || *(ctx->values->get (ctx->object)) == ctx->ctor);\n+\t      || *(ctx->global->values.get (ctx->object)) == ctx->ctor);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -3610,7 +3692,23 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n static void\n non_const_var_error (tree r)\n {\n+  auto_diagnostic_group d;\n   tree type = TREE_TYPE (r);\n+  if (DECL_NAME (r) == heap_uninit_identifier\n+      || DECL_NAME (r) == heap_identifier)\n+    {\n+      error (\"the content of uninitialized storage is not usable \"\n+\t     \"in a constant expression\");\n+      inform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n+      return;\n+    }\n+  if (DECL_NAME (r) == heap_deleted_identifier)\n+    {\n+      error (\"use of allocated storage after deallocation in a \"\n+\t     \"constant expression\");\n+      inform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n+      return;\n+    }\n   error (\"the value of %qD is not usable in a constant \"\n \t \"expression\", r);\n   /* Avoid error cascade.  */\n@@ -3854,7 +3952,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n        DECL_NAME to handle TARGET_EXPR temporaries, which are fair game.  */\n     valp = NULL;\n   else if (DECL_P (object))\n-    valp = ctx->values->get (object);\n+    valp = ctx->global->values.get (object);\n   else\n     valp = NULL;\n   if (!valp)\n@@ -4056,7 +4154,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t   non_constant_p, overflow_p);\n       if (ctors->is_empty())\n \t/* The hash table might have moved since the get earlier.  */\n-\tvalp = ctx->values->get (object);\n+\tvalp = ctx->global->values.get (object);\n     }\n \n   /* Don't share a CONSTRUCTOR that might be changed later.  */\n@@ -4332,6 +4430,12 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n \t\t    tree *jump_target)\n {\n   constexpr_ctx new_ctx = *ctx;\n+  tree local_target;\n+  if (!jump_target)\n+    {\n+      local_target = NULL_TREE;\n+      jump_target = &local_target;\n+    }\n \n   tree body, cond = NULL_TREE, expr = NULL_TREE;\n   int count = 0;\n@@ -4410,7 +4514,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n       unsigned int i;\n       tree save_expr;\n       FOR_EACH_VEC_ELT (save_exprs, i, save_expr)\n-\tnew_ctx.values->remove (save_expr);\n+\tctx->global->values.remove (save_expr);\n       save_exprs.truncate (0);\n \n       if (++count >= constexpr_loop_limit)\n@@ -4434,7 +4538,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n   unsigned int i;\n   tree save_expr;\n   FOR_EACH_VEC_ELT (save_exprs, i, save_expr)\n-    new_ctx.values->remove (save_expr);\n+    ctx->global->values.remove (save_expr);\n \n   return NULL_TREE;\n }\n@@ -4586,14 +4690,14 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     }\n \n   /* Avoid excessively long constexpr evaluations.  */\n-  if (++*ctx->constexpr_ops_count >= constexpr_ops_limit)\n+  if (++ctx->global->constexpr_ops_count >= constexpr_ops_limit)\n     {\n       if (!ctx->quiet)\n \terror_at (cp_expr_loc_or_input_loc (t),\n \t\t  \"%<constexpr%> evaluation operation count exceeds limit of \"\n \t\t  \"%wd (use %<-fconstexpr-ops-limit=%> to increase the limit)\",\n \t\t  constexpr_ops_limit);\n-      *ctx->constexpr_ops_count = INTTYPE_MINIMUM (HOST_WIDE_INT);\n+      ctx->global->constexpr_ops_count = INTTYPE_MINIMUM (HOST_WIDE_INT);\n       *non_constant_p = true;\n       return t;\n     }\n@@ -4610,7 +4714,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       /* We ask for an rvalue for the RESULT_DECL when indirecting\n \t through an invisible reference, or in named return value\n \t optimization.  */\n-      if (tree *p = ctx->values->get (t))\n+      if (tree *p = ctx->global->values.get (t))\n \treturn *p;\n       else\n \t{\n@@ -4666,7 +4770,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n \tr = TARGET_EXPR_INITIAL (r);\n       if (VAR_P (r))\n-\tif (tree *p = ctx->values->get (r))\n+\tif (tree *p = ctx->global->values.get (r))\n \t  if (*p != NULL_TREE)\n \t    r = *p;\n       if (DECL_P (r))\n@@ -4693,7 +4797,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case PARM_DECL:\n       if (lval && !TYPE_REF_P (TREE_TYPE (t)))\n \t/* glvalue use.  */;\n-      else if (tree *p = ctx->values->get (r))\n+      else if (tree *p = ctx->global->values.get (r))\n \tr = *p;\n       else if (lval)\n \t/* Defer in case this is only used for its type.  */;\n@@ -4735,7 +4839,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    new_ctx.object = r;\n \t    new_ctx.ctor = build_constructor (TREE_TYPE (r), NULL);\n \t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n-\t    new_ctx.values->put (r, new_ctx.ctor);\n+\t    ctx->global->values.put (r, new_ctx.ctor);\n \t    ctx = &new_ctx;\n \t  }\n \n@@ -4751,12 +4855,12 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    if (CLASS_TYPE_P (TREE_TYPE (r))\n \t\t&& CP_TYPE_CONST_P (TREE_TYPE (r)))\n \t      TREE_READONLY (init) = true;\n-\t    ctx->values->put (r, init);\n+\t    ctx->global->values.put (r, init);\n \t  }\n \telse if (ctx == &new_ctx)\n \t  /* We gave it a CONSTRUCTOR above.  */;\n \telse\n-\t  ctx->values->put (r, NULL_TREE);\n+\t  ctx->global->values.put (r, NULL_TREE);\n       }\n       break;\n \n@@ -4782,7 +4886,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  new_ctx.ctor = build_constructor (TREE_TYPE (t), NULL);\n \t  CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n \t  new_ctx.object = TARGET_EXPR_SLOT (t);\n-\t  ctx->values->put (new_ctx.object, new_ctx.ctor);\n+\t  ctx->global->values.put (new_ctx.object, new_ctx.ctor);\n \t  ctx = &new_ctx;\n \t}\n       /* Pass false for 'lval' because this indicates\n@@ -4797,7 +4901,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t{\n \t  tree slot = TARGET_EXPR_SLOT (t);\n \t  r = unshare_constructor (r);\n-\t  ctx->values->put (slot, r);\n+\t  ctx->global->values.put (slot, r);\n \t  return slot;\n \t}\n       break;\n@@ -4837,13 +4941,13 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n     case SAVE_EXPR:\n       /* Avoid evaluating a SAVE_EXPR more than once.  */\n-      if (tree *p = ctx->values->get (t))\n+      if (tree *p = ctx->global->values.get (t))\n \tr = *p;\n       else\n \t{\n \t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n \t\t\t\t\t    non_constant_p, overflow_p);\n-\t  ctx->values->put (t, r);\n+\t  ctx->global->values.put (t, r);\n \t  if (ctx->save_exprs)\n \t    ctx->save_exprs->safe_push (t);\n \t}\n@@ -5177,8 +5281,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tif (VOID_TYPE_P (type))\n \t  return void_node;\n \n-\tif (TREE_CODE (op) == PTRMEM_CST\n-\t    && !TYPE_PTRMEM_P (type))\n+\tif (TREE_CODE (op) == PTRMEM_CST && !TYPE_PTRMEM_P (type))\n \t  op = cplus_expand_constant (op);\n \n \tif (TREE_CODE (op) == PTRMEM_CST && tcode == NOP_EXPR)\n@@ -5232,6 +5335,34 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t      }\n \t  }\n \n+\tif (INDIRECT_TYPE_P (type)\n+\t    && TREE_CODE (op) == NOP_EXPR\n+\t    && TREE_TYPE (op) == ptr_type_node\n+\t    && TREE_CODE (TREE_OPERAND (op, 0)) == ADDR_EXPR\n+\t    && VAR_P (TREE_OPERAND (TREE_OPERAND (op, 0), 0))\n+\t    && DECL_NAME (TREE_OPERAND (TREE_OPERAND (op, 0),\n+\t\t\t\t\t0)) == heap_uninit_identifier)\n+\t  {\n+\t    tree var = TREE_OPERAND (TREE_OPERAND (op, 0), 0);\n+\t    tree var_size = TYPE_SIZE_UNIT (TREE_TYPE (var));\n+\t    tree elt_type = TREE_TYPE (type);\n+\t    tree cookie_size = NULL_TREE;\n+\t    if (TREE_CODE (elt_type) == RECORD_TYPE\n+\t\t&& TYPE_NAME (elt_type) == heap_identifier)\n+\t      {\n+\t\ttree fld1 = TYPE_FIELDS (elt_type);\n+\t\ttree fld2 = DECL_CHAIN (fld1);\n+\t\telt_type = TREE_TYPE (TREE_TYPE (fld2));\n+\t\tcookie_size = TYPE_SIZE_UNIT (TREE_TYPE (fld1));\n+\t      }\n+\t    DECL_NAME (var) = heap_identifier;\n+\t    TREE_TYPE (var)\n+\t      = build_new_constexpr_heap_type (elt_type, cookie_size,\n+\t\t\t\t\t       var_size);\n+\t    TREE_TYPE (TREE_OPERAND (op, 0))\n+\t      = build_pointer_type (TREE_TYPE (var));\n+\t  }\n+\n \tif (op == oldop && tcode != UNARY_PLUS_EXPR)\n \t  /* We didn't fold at the top so we could check for ptr-int\n \t     conversion.  */\n@@ -5473,6 +5604,7 @@ instantiate_cx_fn_r (tree *tp, int *walk_subtrees, void */*data*/)\n \n   return NULL_TREE;\n }\n+\n static void\n instantiate_constexpr_fns (tree t)\n {\n@@ -5481,34 +5613,58 @@ instantiate_constexpr_fns (tree t)\n   input_location = loc;\n }\n \n+/* Look for heap variables in the expression *TP.  */\n+\n+static tree\n+find_heap_var_refs (tree *tp, int *walk_subtrees, void */*data*/)\n+{\n+  if (VAR_P (*tp)\n+      && (DECL_NAME (*tp) == heap_uninit_identifier\n+\t  || DECL_NAME (*tp) == heap_identifier\n+\t  || DECL_NAME (*tp) == heap_deleted_identifier))\n+    return *tp;\n+\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n /* ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n    STRICT has the same sense as for constant_value_1: true if we only allow\n    conforming C++ constant expressions, or false if we want a constant value\n    even if it doesn't conform.\n    MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated as\n-   per P0595 even when ALLOW_NON_CONSTANT is true.  */\n+   per P0595 even when ALLOW_NON_CONSTANT is true.\n+   CONSTEXPR_DTOR is true when evaluating the dtor of a constexpr variable.\n+   OBJECT must be non-NULL in that case.  */\n \n static tree\n cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t\t\t\t  bool strict = true,\n \t\t\t\t  bool manifestly_const_eval = false,\n+\t\t\t\t  bool constexpr_dtor = false,\n \t\t\t\t  tree object = NULL_TREE)\n {\n   auto_timevar time (TV_CONSTEXPR);\n \n   bool non_constant_p = false;\n   bool overflow_p = false;\n-  hash_map<tree,tree> map;\n-  HOST_WIDE_INT constexpr_ctx_count = 0;\n \n-  constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL, NULL,\n-\t\t\t&constexpr_ctx_count, allow_non_constant, strict,\n+  constexpr_global_ctx global_ctx;\n+  constexpr_ctx ctx = { &global_ctx, NULL, NULL, NULL, NULL, NULL,\n+\t\t\tallow_non_constant, strict,\n \t\t\tmanifestly_const_eval || !allow_non_constant };\n \n   tree type = initialized_type (t);\n   tree r = t;\n   if (VOID_TYPE_P (type))\n-    return t;\n+    {\n+      if (constexpr_dtor)\n+\t/* Used for destructors of array elements.  */\n+\ttype = TREE_TYPE (object);\n+      else\n+\treturn t;\n+    }\n   if (AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n     {\n       /* In C++14 an NSDMI can participate in aggregate initialization,\n@@ -5518,8 +5674,22 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t update ctx.values for the VAR_DECL.  We use the same strategy\n \t for C++11 constexpr constructors that refer to the object being\n \t initialized.  */\n-      ctx.ctor = build_constructor (type, NULL);\n-      CONSTRUCTOR_NO_CLEARING (ctx.ctor) = true;\n+      if (constexpr_dtor)\n+\t{\n+\t  gcc_assert (object && VAR_P (object));\n+\t  gcc_assert (DECL_DECLARED_CONSTEXPR_P (object));\n+\t  gcc_assert (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (object));\n+\t  ctx.ctor = unshare_expr (DECL_INITIAL (object));\n+\t  TREE_READONLY (ctx.ctor) = false;\n+\t  /* Temporarily force decl_really_constant_value to return false\n+\t     for it, we want to use ctx.ctor for the current value instead.  */\n+\t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (object) = false;\n+\t}\n+      else\n+\t{\n+\t  ctx.ctor = build_constructor (type, NULL);\n+\t  CONSTRUCTOR_NO_CLEARING (ctx.ctor) = true;\n+\t}\n       if (!object)\n \t{\n \t  if (TREE_CODE (t) == TARGET_EXPR)\n@@ -5532,7 +5702,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n \t\t    (type, TREE_TYPE (object)));\n       if (object && DECL_P (object))\n-\tmap.put (object, ctx.ctor);\n+\tglobal_ctx.values.put (object, ctx.ctor);\n       if (TREE_CODE (r) == TARGET_EXPR)\n \t/* Avoid creating another CONSTRUCTOR when we expand the\n \t   TARGET_EXPR.  */\n@@ -5543,22 +5713,23 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   r = cxx_eval_constant_expression (&ctx, r,\n \t\t\t\t    false, &non_constant_p, &overflow_p);\n \n-  verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n+  if (!constexpr_dtor)\n+    verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n+  else\n+    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (object) = true;\n \n   /* Mutable logic is a bit tricky: we want to allow initialization of\n      constexpr variables with mutable members, but we can't copy those\n      members to another constexpr variable.  */\n-  if (TREE_CODE (r) == CONSTRUCTOR\n-      && CONSTRUCTOR_MUTABLE_POISON (r))\n+  if (TREE_CODE (r) == CONSTRUCTOR && CONSTRUCTOR_MUTABLE_POISON (r))\n     {\n       if (!allow_non_constant)\n \terror (\"%qE is not a constant expression because it refers to \"\n \t       \"mutable subobjects of %qT\", t, type);\n       non_constant_p = true;\n     }\n \n-  if (TREE_CODE (r) == CONSTRUCTOR\n-      && CONSTRUCTOR_NO_CLEARING (r))\n+  if (TREE_CODE (r) == CONSTRUCTOR && CONSTRUCTOR_NO_CLEARING (r))\n     {\n       if (!allow_non_constant)\n \terror (\"%qE is not a constant expression because it refers to \"\n@@ -5567,6 +5738,32 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n       non_constant_p = true;\n     }\n \n+  if (!global_ctx.heap_vars.is_empty ())\n+    {\n+      tree heap_var = cp_walk_tree_without_duplicates (&r, find_heap_var_refs,\n+\t\t\t\t\t\t       NULL);\n+      unsigned int i;\n+      if (heap_var)\n+\t{\n+\t  if (!allow_non_constant && !non_constant_p)\n+\t    error_at (DECL_SOURCE_LOCATION (heap_var),\n+\t\t      \"%qE is not a constant expression because it refers to \"\n+\t\t      \"a result of %<operator new%>\", t);\n+\t  r = t;\n+\t  non_constant_p = true;\n+\t}\n+      FOR_EACH_VEC_ELT (global_ctx.heap_vars, i, heap_var)\n+\tif (DECL_NAME (heap_var) != heap_deleted_identifier)\n+\t  {\n+\t    if (!allow_non_constant && !non_constant_p)\n+\t      error_at (DECL_SOURCE_LOCATION (heap_var),\n+\t\t\t\"%qE is not a constant expression because allocated \"\n+\t\t\t\"storage has not been deallocated\", t);\n+\t    r = t;\n+\t    non_constant_p = true;\n+\t  }\n+    }\n+\n   /* Technically we should check this for all subexpressions, but that\n      runs into problems with our internal representation of pointer\n      subtraction and the 5.19 rules are still in flux.  */\n@@ -5592,14 +5789,16 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \n   if (non_constant_p && !allow_non_constant)\n     return error_mark_node;\n+  else if (constexpr_dtor)\n+    return r;\n   else if (non_constant_p && TREE_CONSTANT (r))\n     {\n       /* If __builtin_is_constant_evaluated () was evaluated to true\n \t and the result is not a valid constant expression, we need to\n \t punt.  */\n       if (manifestly_const_eval)\n \treturn cxx_eval_outermost_constant_expr (t, true, strict,\n-\t\t\t\t\t\t false, object);\n+\t\t\t\t\t\t false, false, object);\n       /* This isn't actually constant, so unset TREE_CONSTANT.\n \t Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires\n \t it to be set if it is invariant address, even when it is not\n@@ -5627,7 +5826,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \treturn t;\n       else if (TREE_CODE (t) != CONSTRUCTOR)\n \t{\n-\t  r = get_target_expr (r);\n+\t  r = get_target_expr_sfinae (r, tf_warning_or_error | tf_no_cleanup);\n \t  TREE_CONSTANT (r) = true;\n \t}\n     }\n@@ -5642,7 +5841,16 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n tree\n cxx_constant_value (tree t, tree decl)\n {\n-  return cxx_eval_outermost_constant_expr (t, false, true, true, decl);\n+  return cxx_eval_outermost_constant_expr (t, false, true, true, false, decl);\n+}\n+\n+/* Like cxx_constant_value, but used for evaluation of constexpr destructors\n+   of constexpr variables.  The actual initializer of DECL is not modified.  */\n+\n+void\n+cxx_constant_dtor (tree t, tree decl)\n+{\n+  cxx_eval_outermost_constant_expr (t, false, true, true, true, decl);\n }\n \n /* Helper routine for fold_simple function.  Either return simplified\n@@ -5746,14 +5954,14 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n     return t;\n \n   if (manifestly_const_eval)\n-    return cxx_eval_outermost_constant_expr (t, true, true, true, decl);\n+    return cxx_eval_outermost_constant_expr (t, true, true, true, false, decl);\n \n   if (cv_cache == NULL)\n     cv_cache = hash_map<tree, tree>::create_ggc (101);\n   if (tree *cached = cv_cache->get (t))\n     return *cached;\n \n-  r = cxx_eval_outermost_constant_expr (t, true, true, false, decl);\n+  r = cxx_eval_outermost_constant_expr (t, true, true, false, false, decl);\n   gcc_checking_assert (r == t\n \t\t       || CONVERT_EXPR_P (t)\n \t\t       || TREE_CODE (t) == VIEW_CONVERT_EXPR\n@@ -5815,7 +6023,7 @@ fold_non_dependent_expr_template (tree t, tsubst_flags_t complain,\n \n       tree r = cxx_eval_outermost_constant_expr (t, true, true,\n \t\t\t\t\t\t manifestly_const_eval,\n-\t\t\t\t\t\t NULL_TREE);\n+\t\t\t\t\t\t false, NULL_TREE);\n       /* cp_tree_equal looks through NOPs, so allow them.  */\n       gcc_checking_assert (r == t\n \t\t\t   || CONVERT_EXPR_P (t)\n@@ -5919,7 +6127,7 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n   else\n     t = cxx_eval_outermost_constant_expr (t, allow_non_constant,\n \t\t\t\t\t  /*strict*/false,\n-\t\t\t\t\t  manifestly_const_eval, decl);\n+\t\t\t\t\t  manifestly_const_eval, false, decl);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n       tree init = TARGET_EXPR_INITIAL (t);\n@@ -6213,7 +6421,10 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\tif (!DECL_DECLARED_CONSTEXPR_P (fun)\n \t\t    /* Allow any built-in function; if the expansion\n \t\t       isn't constant, we'll deal with that then.  */\n-\t\t    && !fndecl_built_in_p (fun))\n+\t\t    && !fndecl_built_in_p (fun)\n+\t\t    /* In C++2a, replaceable global allocation functions\n+\t\t       are constant expressions.  */\n+\t\t    && !cxx_replaceable_global_alloc_fn (fun))\n \t\t  {\n \t\t    if (flags & tf_error)\n \t\t      {\n@@ -6442,6 +6653,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \tgoto fail;\n       if (!RECUR (TREE_OPERAND (t, 0), any))\n \treturn false;\n+      /* Just ignore clobbers.  */\n+      if (TREE_CLOBBER_P (TREE_OPERAND (t, 1)))\n+\treturn true;\n       if (!RECUR (TREE_OPERAND (t, 1), rval))\n \treturn false;\n       return true;\n@@ -6911,7 +7125,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n      return true;\n \n     case COND_EXPR:\n-      if (COND_EXPR_IS_VEC_DELETE (t))\n+      if (COND_EXPR_IS_VEC_DELETE (t) && cxx_dialect < cxx2a)\n \t{\n \t  if (flags & tf_error)\n \t    error_at (loc, \"%<delete[]%> is not a constant expression\");"}, {"sha": "b82b5808197f55a990ddc3a3a8197b0c3b9440eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -172,6 +172,9 @@ enum cp_tree_index\n     CPTI_VALUE_IDENTIFIER,\n     CPTI_FUN_IDENTIFIER,\n     CPTI_CLOSURE_IDENTIFIER,\n+    CPTI_HEAP_UNINIT_IDENTIFIER,\n+    CPTI_HEAP_IDENTIFIER,\n+    CPTI_HEAP_DELETED_IDENTIFIER,\n \n     CPTI_LANG_NAME_C,\n     CPTI_LANG_NAME_CPLUSPLUS,\n@@ -310,6 +313,9 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define value_identifier\t\tcp_global_trees[CPTI_VALUE_IDENTIFIER]\n #define fun_identifier\t\t\tcp_global_trees[CPTI_FUN_IDENTIFIER]\n #define closure_identifier\t\tcp_global_trees[CPTI_CLOSURE_IDENTIFIER]\n+#define heap_uninit_identifier\t\tcp_global_trees[CPTI_HEAP_UNINIT_IDENTIFIER]\n+#define heap_identifier\t\t\tcp_global_trees[CPTI_HEAP_IDENTIFIER]\n+#define heap_deleted_identifier\t\tcp_global_trees[CPTI_HEAP_DELETED_IDENTIFIER]\n #define lang_name_c\t\t\tcp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus\t\tcp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n \n@@ -6342,6 +6348,7 @@ extern bool vbase_has_user_provided_move_assign (tree);\n extern tree default_init_uninitialized_part (tree);\n extern bool trivial_default_constructor_is_constexpr (tree);\n extern bool type_has_constexpr_default_constructor (tree);\n+extern bool type_has_constexpr_destructor\t(tree);\n extern bool type_has_virtual_destructor\t\t(tree);\n extern bool classtype_has_move_assign_or_move_ctor_p (tree, bool user_declared);\n extern bool classtype_has_non_deleted_move_ctor (tree);\n@@ -6648,6 +6655,7 @@ extern tree build_offset_ref\t\t\t(tree, tree, bool,\n extern tree throw_bad_array_new_length\t\t(void);\n extern bool type_has_new_extended_alignment\t(tree);\n extern unsigned malloc_alignment\t\t(void);\n+extern tree build_new_constexpr_heap_type\t(tree, tree, tree);\n extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n \t\t\t\t\t\t vec<tree, va_gc> **, int,\n                                                  tsubst_flags_t);\n@@ -7747,6 +7755,7 @@ extern bool require_constant_expression (tree);\n extern bool require_rvalue_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n+extern void cxx_constant_dtor\t\t\t(tree, tree);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);"}, {"sha": "ea9a0011e24a635cfc290ef7bd22c35e1f876f05", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -4146,6 +4146,9 @@ initialize_predefined_identifiers (void)\n     {\"value\", &value_identifier, cik_normal},\n     {\"_FUN\", &fun_identifier, cik_normal},\n     {\"__closure\", &closure_identifier, cik_normal},\n+    {\"heap uninit\", &heap_uninit_identifier, cik_normal},\n+    {\"heap \", &heap_identifier, cik_normal},\n+    {\"heap deleted\", &heap_deleted_identifier, cik_normal},\n     {NULL, NULL, cik_normal}\n   };\n \n@@ -7006,6 +7009,19 @@ notice_forced_label_r (tree *tp, int *walk_subtrees, void *)\n   return NULL_TREE;\n }\n \n+/* Return true if DECL has either a trivial destructor, or for C++2A\n+   is constexpr and has a constexpr destructor.  */\n+\n+static bool\n+decl_maybe_constant_destruction (tree decl, tree type)\n+{\n+  return (TYPE_HAS_TRIVIAL_DESTRUCTOR (type)\n+\t  || (cxx_dialect >= cxx2a\n+\t      && VAR_P (decl)\n+\t      && DECL_DECLARED_CONSTEXPR_P (decl)\n+\t      && type_has_constexpr_destructor (strip_array_types (type))));\n+}\n+\n /* Finish processing of a declaration;\n    install its line number and initial value.\n    If the length of an array type is not known before,\n@@ -7430,7 +7446,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    TREE_READONLY (decl) = 1;\n \n \t  /* Likewise if it needs destruction.  */\n-\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+\t  if (!decl_maybe_constant_destruction (decl, type))\n \t    TREE_READONLY (decl) = 0;\n \t}\n \n@@ -8312,6 +8328,13 @@ register_dtor_fn (tree decl)\n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     return void_node;\n \n+  if (decl_maybe_constant_destruction (decl, type)\n+      && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n+    {\n+      cxx_maybe_build_cleanup (decl, tf_warning_or_error);\n+      return void_node;\n+    }\n+\n   /* If we're using \"__cxa_atexit\" (or \"__cxa_thread_atexit\" or\n      \"__aeabi_atexit\"), and DECL is a class object, we can just pass the\n      destructor to \"__cxa_atexit\"; we don't have to build a temporary\n@@ -8429,7 +8452,7 @@ expand_static_init (tree decl, tree init)\n   gcc_assert (TREE_STATIC (decl));\n \n   /* Some variables require no dynamic initialization.  */\n-  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+  if (decl_maybe_constant_destruction (decl, TREE_TYPE (decl)))\n     {\n       /* Make sure the destructor is callable.  */\n       cxx_maybe_build_cleanup (decl, tf_warning_or_error);\n@@ -12697,12 +12720,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t      \"a destructor cannot be %<concept%>\");\n                     return error_mark_node;\n                   }\n-                if (constexpr_p)\n-                  {\n-                    error_at (declspecs->locations[ds_constexpr],\n-\t\t\t      \"a destructor cannot be %<constexpr%>\");\n-                    return error_mark_node;\n-                  }\n+\t\tif (constexpr_p && cxx_dialect < cxx2a)\n+\t\t  {\n+\t\t    error_at (declspecs->locations[ds_constexpr],\n+\t\t\t      \"%<constexpr%> destructors only available\"\n+\t\t\t      \" with %<-std=c++2a%> or %<-std=gnu++2a%>\");\n+\t\t    return error_mark_node;\n+\t\t  }\n \t      }\n \t    else if (sfk == sfk_constructor && friendp && !ctype)\n \t      {\n@@ -12739,10 +12763,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n-\t    function_context = (ctype != NULL_TREE) ?\n-\t      decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE;\n-\t    publicp = (! friendp || ! staticp)\n-\t      && function_context == NULL_TREE;\n+\t    function_context\n+\t      = (ctype != NULL_TREE\n+\t\t ? decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE);\n+\t    publicp = ((! friendp || ! staticp)\n+\t\t       && function_context == NULL_TREE);\n \n \t    decl = grokfndecl (ctype, type,\n \t\t\t       TREE_CODE (unqualified_id) != TEMPLATE_ID_EXPR\n@@ -16742,6 +16767,9 @@ cxx_maybe_build_cleanup (tree decl, tsubst_flags_t complain)\n \tcleanup = error_mark_node;\n       else if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n \t/* Discard the call.  */;\n+      else if (decl_maybe_constant_destruction (decl, type)\n+\t       && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n+\tcxx_constant_dtor (call, decl);\n       else if (cleanup)\n \tcleanup = cp_build_compound_expr (cleanup, call, complain);\n       else"}, {"sha": "1c51e26febed98304cfd44e00f88ef871703e4c3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 86, "deletions": 11, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n+#include \"stor-layout.h\"\n \n static bool begin_init_stmts (tree *, tree *);\n static tree finish_init_stmts (bool, tree, tree);\n@@ -2860,6 +2861,82 @@ std_placement_new_fn_p (tree alloc_fn)\n   return false;\n }\n \n+/* For element type ELT_TYPE, return the appropriate type of the heap object\n+   containing such element(s).  COOKIE_SIZE is NULL or the size of cookie\n+   in bytes.  FULL_SIZE is NULL if it is unknown how big the heap allocation\n+   will be, otherwise size of the heap object.  If COOKIE_SIZE is NULL,\n+   return array type ELT_TYPE[FULL_SIZE / sizeof(ELT_TYPE)], otherwise return\n+   struct { size_t[COOKIE_SIZE/sizeof(size_t)]; ELT_TYPE[N]; }\n+   where N is nothing (flexible array member) if FULL_SIZE is NULL, otherwise\n+   it is computed such that the size of the struct fits into FULL_SIZE.  */\n+\n+tree\n+build_new_constexpr_heap_type (tree elt_type, tree cookie_size, tree full_size)\n+{\n+  gcc_assert (cookie_size == NULL_TREE || tree_fits_uhwi_p (cookie_size));\n+  gcc_assert (full_size == NULL_TREE || tree_fits_uhwi_p (full_size));\n+  unsigned HOST_WIDE_INT csz = cookie_size ? tree_to_uhwi (cookie_size) : 0;\n+  tree itype2 = NULL_TREE;\n+  if (full_size)\n+    {\n+      unsigned HOST_WIDE_INT fsz = tree_to_uhwi (full_size);\n+      gcc_assert (fsz >= csz);\n+      fsz -= csz;\n+      fsz /= int_size_in_bytes (elt_type);\n+      itype2 = build_index_type (size_int (fsz - 1));\n+      if (!cookie_size)\n+\treturn build_cplus_array_type (elt_type, itype2);\n+    }\n+  else\n+    gcc_assert (cookie_size);\n+  csz /= int_size_in_bytes (sizetype);\n+  tree itype1 = build_index_type (size_int (csz - 1));\n+  tree atype1 = build_cplus_array_type (sizetype, itype1);\n+  tree atype2 = build_cplus_array_type (elt_type, itype2);\n+  tree rtype = cxx_make_type (RECORD_TYPE);\n+  TYPE_NAME (rtype) = heap_identifier;\n+  tree fld1 = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE, atype1);\n+  tree fld2 = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE, atype2);\n+  DECL_FIELD_CONTEXT (fld1) = rtype;\n+  DECL_FIELD_CONTEXT (fld2) = rtype;\n+  DECL_ARTIFICIAL (fld1) = true;\n+  DECL_ARTIFICIAL (fld2) = true;\n+  TYPE_FIELDS (rtype) = fld1;\n+  DECL_CHAIN (fld1) = fld2;\n+  layout_type (rtype);\n+  return rtype;\n+}\n+\n+/* Help the constexpr code to find the right type for the heap variable\n+   by adding a NOP_EXPR around ALLOC_CALL if needed for cookie_size.\n+   Return ALLOC_CALL or ALLOC_CALL cast to a pointer to\n+   struct { size_t[cookie_size/sizeof(size_t)]; elt_type[]; }.  */\n+\n+static tree\n+maybe_wrap_new_for_constexpr (tree alloc_call, tree elt_type, tree cookie_size)\n+{\n+  if (cxx_dialect < cxx2a)\n+    return alloc_call;\n+\n+  if (current_function_decl != NULL_TREE\n+      && !DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n+    return alloc_call;\n+  \n+  tree call_expr = extract_call_expr (alloc_call);\n+  if (call_expr == error_mark_node)\n+    return alloc_call;\n+\n+  tree alloc_call_fndecl = cp_get_callee_fndecl_nofold (call_expr);\n+  if (alloc_call_fndecl == NULL_TREE\n+      || !IDENTIFIER_NEW_OP_P (DECL_NAME (alloc_call_fndecl))\n+      || CP_DECL_CONTEXT (alloc_call_fndecl) != global_namespace)\n+    return alloc_call;\n+\n+  tree rtype = build_new_constexpr_heap_type (elt_type, cookie_size,\n+\t\t\t\t\t      NULL_TREE);\n+  return build_nop (build_pointer_type (rtype), alloc_call);\n+}\n+\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -3327,6 +3404,10 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t}\n     }\n \n+  if (cookie_size)\n+    alloc_call = maybe_wrap_new_for_constexpr (alloc_call, elt_type,\n+\t\t\t\t\t       cookie_size);\n+\n   /* In the simple case, we can stop now.  */\n   pointer_type = build_pointer_type (type);\n   if (!cookie_size && !is_initialized)\n@@ -3902,17 +3983,11 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t     fold_convert (sizetype, maxindex));\n \n   tbase = create_temporary_var (ptype);\n-  tbase_init\n-    = cp_build_modify_expr (input_location, tbase, NOP_EXPR,\n-\t\t\t    fold_build_pointer_plus_loc (input_location,\n-\t\t\t\t\t\t\t fold_convert (ptype,\n-\t\t\t\t\t\t\t\t       base),\n-\t\t\t\t\t\t\t virtual_size),\n-\t\t\t    complain);\n-  if (tbase_init == error_mark_node)\n-    return error_mark_node;\n-  controller = build3 (BIND_EXPR, void_type_node, tbase,\n-\t\t       NULL_TREE, NULL_TREE);\n+  DECL_INITIAL (tbase)\n+    = fold_build_pointer_plus_loc (input_location, fold_convert (ptype, base),\n+\t\t\t\t   virtual_size);\n+  tbase_init = build_stmt (input_location, DECL_EXPR, tbase);\n+  controller = build3 (BIND_EXPR, void_type_node, tbase, NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (controller) = 1;\n \n   body = build1 (EXIT_EXPR, void_type_node,"}, {"sha": "01bf534aef276b308035a322b49bcf3697eee4f2", "filename": "gcc/cp/method.c", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"varasm.h\"\n #include \"toplev.h\"\n+#include \"intl.h\"\n #include \"common/common-target.h\"\n \n static void do_build_copy_assign (tree);\n@@ -1237,12 +1238,24 @@ is_xible (enum tree_code code, tree to, tree from)\n   return !!expr;\n }\n \n+/* Categorize various special_function_kinds.  */\n+#define SFK_CTOR_P(sfk) \\\n+  ((sfk) >= sfk_constructor && (sfk) <= sfk_move_constructor)\n+#define SFK_DTOR_P(sfk) \\\n+  ((sfk) == sfk_destructor || (sfk) == sfk_virtual_destructor)\n+#define SFK_ASSIGN_P(sfk) \\\n+  ((sfk) == sfk_copy_assignment || (sfk) == sfk_move_assignment)\n+#define SFK_COPY_P(sfk) \\\n+  ((sfk) == sfk_copy_constructor || (sfk) == sfk_copy_assignment)\n+#define SFK_MOVE_P(sfk) \\\n+  ((sfk) == sfk_move_constructor || (sfk) == sfk_move_assignment)\n+\n /* Subroutine of synthesized_method_walk.  Update SPEC_P, TRIVIAL_P and\n    DELETED_P or give an error message MSG with argument ARG.  */\n \n static void\n-process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,\n-\t\t  bool *deleted_p, bool *constexpr_p,\n+process_subob_fn (tree fn, special_function_kind sfk, tree *spec_p,\n+\t\t  bool *trivial_p, bool *deleted_p, bool *constexpr_p,\n \t\t  bool diag, tree arg, bool dtor_from_ctor = false)\n {\n   if (!fn || fn == error_mark_node)\n@@ -1283,24 +1296,15 @@ process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,\n       if (diag)\n \t{\n \t  inform (DECL_SOURCE_LOCATION (fn),\n-\t\t  \"defaulted constructor calls non-%<constexpr%> %qD\", fn);\n+\t\t  SFK_DTOR_P (sfk)\n+\t\t  ? G_(\"defaulted destructor calls non-%<constexpr%> %qD\")\n+\t\t  : G_(\"defaulted constructor calls non-%<constexpr%> %qD\"),\n+\t\t  fn);\n \t  explain_invalid_constexpr_fn (fn);\n \t}\n     }\n }\n \n-/* Categorize various special_function_kinds.  */\n-#define SFK_CTOR_P(sfk) \\\n-  ((sfk) >= sfk_constructor && (sfk) <= sfk_move_constructor)\n-#define SFK_DTOR_P(sfk) \\\n-  ((sfk) == sfk_destructor || (sfk) == sfk_virtual_destructor)\n-#define SFK_ASSIGN_P(sfk) \\\n-  ((sfk) == sfk_copy_assignment || (sfk) == sfk_move_assignment)\n-#define SFK_COPY_P(sfk) \\\n-  ((sfk) == sfk_copy_constructor || (sfk) == sfk_copy_assignment)\n-#define SFK_MOVE_P(sfk) \\\n-  ((sfk) == sfk_move_constructor || (sfk) == sfk_move_assignment)\n-\n /* Subroutine of synthesized_method_walk to allow recursion into anonymous\n    aggregates.  If DTOR_FROM_CTOR is true, we're walking subobject destructors\n    called from a synthesized constructor, in which case we don't consider\n@@ -1318,8 +1322,7 @@ walk_field_subobs (tree fields, special_function_kind sfk, tree fnname,\n     {\n       tree mem_type, argtype, rval;\n \n-      if (TREE_CODE (field) != FIELD_DECL\n-\t  || DECL_ARTIFICIAL (field))\n+      if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n \tcontinue;\n \n       /* Variant members only affect deletedness.  In particular, they don't\n@@ -1457,7 +1460,7 @@ walk_field_subobs (tree fields, special_function_kind sfk, tree fnname,\n \n       rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);\n \n-      process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n+      process_subob_fn (rval, sfk, spec_p, trivial_p, deleted_p,\n \t\t\tconstexpr_p, diag, field, dtor_from_ctor);\n     }\n }\n@@ -1510,23 +1513,23 @@ synthesized_method_base_walk (tree binfo, tree base_binfo,\n       && DECL_CONTEXT (*inheriting_ctor) == DECL_CONTEXT (rval))\n     *inheriting_ctor = DECL_CLONED_FUNCTION (rval);\n \n-  process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n+  process_subob_fn (rval, sfk, spec_p, trivial_p, deleted_p,\n \t\t    constexpr_p, diag, BINFO_TYPE (base_binfo));\n-  if (SFK_CTOR_P (sfk) &&\n-      (!BINFO_VIRTUAL_P (base_binfo)\n-       || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))))\n+  if (SFK_CTOR_P (sfk)\n+      && (!BINFO_VIRTUAL_P (base_binfo)\n+\t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))))\n     {\n       /* In a constructor we also need to check the subobject\n \t destructors for cleanup of partially constructed objects.  */\n       tree dtor = locate_fn_flags (base_binfo, complete_dtor_identifier,\n \t\t\t\t   NULL_TREE, flags,\n \t\t\t\t   diag ? tf_warning_or_error : tf_none);\n-\t  /* Note that we don't pass down trivial_p; the subobject\n-\t     destructors don't affect triviality of the constructor.  Nor\n-\t     do they affect constexpr-ness (a constant expression doesn't\n-\t     throw) or exception-specification (a throw from one of the\n-\t     dtors would be a double-fault).  */\n-      process_subob_fn (dtor, NULL, NULL, deleted_p, NULL, false,\n+      /* Note that we don't pass down trivial_p; the subobject\n+\t destructors don't affect triviality of the constructor.  Nor\n+\t do they affect constexpr-ness (a constant expression doesn't\n+\t throw) or exception-specification (a throw from one of the\n+\t dtors would be a double-fault).  */\n+      process_subob_fn (dtor, sfk, NULL, NULL, deleted_p, NULL, false,\n \t\t\tBINFO_TYPE (base_binfo), /*dtor_from_ctor*/true);\n     }\n \n@@ -1608,7 +1611,8 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \tmember is a constexpr function.  */\n   if (constexpr_p)\n     *constexpr_p = (SFK_CTOR_P (sfk)\n-\t\t    || (SFK_ASSIGN_P (sfk) && cxx_dialect >= cxx14));\n+\t\t    || (SFK_ASSIGN_P (sfk) && cxx_dialect >= cxx14)\n+\t\t    || (SFK_DTOR_P (sfk) && cxx_dialect >= cxx2a));\n \n   bool expected_trivial = type_has_trivial_fn (ctype, sfk);\n   if (trivial_p)\n@@ -1704,8 +1708,8 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   else if (vec_safe_is_empty (vbases))\n     /* No virtual bases to worry about.  */;\n   else if (ABSTRACT_CLASS_TYPE_P (ctype) && cxx_dialect >= cxx14\n-\t   /* DR 1658 specifis that vbases of abstract classes are\n-\t      ignored for both ctors and dtors.  Except DR 2338\n+\t   /* DR 1658 specifies that vbases of abstract classes are\n+\t      ignored for both ctors and dtors.  Except DR 2336\n \t      overrides that skipping when determing the eh-spec of a\n \t      virtual destructor.  */\n \t   && sfk != sfk_virtual_destructor)\n@@ -2046,7 +2050,8 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n     constexpr_p = false;\n   /* A trivial copy/move constructor is also a constexpr constructor,\n      unless the class has virtual bases (7.1.5p4).  */\n-  else if (trivial_p && cxx_dialect >= cxx11\n+  else if (trivial_p\n+\t   && cxx_dialect >= cxx11\n \t   && (kind == sfk_copy_constructor\n \t       || kind == sfk_move_constructor)\n \t   && !CLASSTYPE_VBASECLASSES (type))"}, {"sha": "54d6b848157bbe3e6d6a1e03d2d1571a2224b35d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -902,7 +902,13 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n \t    value = oldval;\n \t}\n     }\n-  value = cp_fully_fold_init (value);\n+  /* Don't fold initializers of automatic variables in constexpr functions,\n+     that might fold away something that needs to be diagnosed at constexpr\n+     evaluation time.  */\n+  if (!current_function_decl\n+      || !DECL_DECLARED_CONSTEXPR_P (current_function_decl)\n+      || TREE_STATIC (decl))\n+    value = cp_fully_fold_init (value);\n \n   /* Handle aggregate NSDMI in non-constant initializers, too.  */\n   value = replace_placeholders (value, decl);"}, {"sha": "8a0a03526e77c53eae3164b7e948f26e39364704", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -1,5 +1,23 @@\n 2019-10-05  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/91369 - Implement P0784R7: constexpr new\n+\t* g++.dg/cpp0x/constexpr-delete2.C: Adjust expected diagnostics for\n+\tc++2a.\n+\t* g++.dg/cpp0x/locations1.C: Only expect constexpr ~S() diagnostics\n+\tin c++17_down, adjust expected wording.\n+\t* g++.dg/cpp1y/constexpr-new.C: Only expect diagnostics in c++17_down.\n+\t* g++.dg/cpp2a/constexpr-dtor1.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dtor2.C: New test.\n+\t* g++.dg/cpp2a/constexpr-dtor3.C: New test.\n+\t* g++.dg/cpp2a/constexpr-new1.C: New test.\n+\t* g++.dg/cpp2a/constexpr-new2.C: New test.\n+\t* g++.dg/cpp2a/constexpr-new3.C: New test.\n+\t* g++.dg/cpp2a/constexpr-new4.C: New test.\n+\t* g++.dg/cpp2a/feat-cxx2a.C: Add __cpp_constinit and\n+\t__cpp_constexpr_dynamic_alloc tests.  Tweak __cpp_* tests for c++2a\n+\tfeatures to use style like older features, including #ifdef test.\n+\t* g++.dg/ext/is_literal_type3.C: New test.\n+\n \tPR tree-optimization/91734\n \t* gcc.dg/pr91734.c: New test.\n "}, {"sha": "999f9b7851ec9a8f46ff44209ee48091e146fa06", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-delete2.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-delete2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-delete2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-delete2.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -5,8 +5,9 @@ struct A { ~A(); };\n constexpr int f(int i) { return i; }\n constexpr int g(A* ap)\n {\n-  return f((delete[] ap, 42)); // { dg-message \"\" }\n+  return f((delete[] ap, 42)); // { dg-message \"\" \"\" { target c++17_down } }\n }\n \n A a;\n constexpr int i = g(&a);\t// { dg-error \"\" }\n+\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" \"\" { target c++2a } .-1 }"}, {"sha": "62a72ea280424403db079801a080eb48fc12913e", "filename": "gcc/testsuite/g++.dg/cpp0x/locations1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flocations1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flocations1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flocations1.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -11,7 +11,7 @@ struct S\n {\n   virtual S();  // { dg-error \"3:constructors cannot be declared .virtual.\" }\n   constexpr int s = 1;  // { dg-error \"3:non-static data member .s. declared .constexpr.\" }\n-  constexpr ~S();  // { dg-error \"3:a destructor cannot be .constexpr.\" }\n+  constexpr ~S();  // { dg-error \"3:'constexpr' destructors only available with\" \"\" { target c++17_down } }\n };\n \n typedef constexpr int my_int;  // { dg-error \"9:.constexpr. cannot appear in a typedef declaration\" }"}, {"sha": "90cb42595c499c06a6ff43386d74d7f647b36105", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-new.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-new.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-new.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-new.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -4,7 +4,7 @@ constexpr int *f4(bool b) {\n   if (b) {\n     return nullptr;\n   } else {\n-    return new int{42}; // { dg-error \"call to non-.constexpr.\" }\n+    return new int{42}; // { dg-error \"call to non-.constexpr.\" \"\" { target c++17_down } }\n   }\n }\n static_assert(f4(true) == nullptr, \"\");"}, {"sha": "a2ea6bfb33849abedfae2abee10eb0ffebf27dda", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dtor1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor1.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,9 @@\n+// P0784R7\n+// { dg-do compile { target c++11 } }\n+\n+struct S\n+{\n+  constexpr S () : s (0) {}\n+  constexpr ~S () {}\t// { dg-error \"'constexpr' destructors only available with\" \"\" { target c++17_down } }\n+  int s;\n+};"}, {"sha": "397cfb0f1a18496a9a7228c51271c2e34a38130d", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dtor2.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor2.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,66 @@\n+// P0784R7\n+// { dg-do compile { target c++2a } }\n+\n+struct S\n+{\n+  constexpr S () : r (4), s (3) { --r; s -= 2; }\n+  constexpr ~S () { if (s == 1) s = 0; else asm (\"\"); if (s == 0 && r == 3) r = 0; else asm (\"\"); }\n+  int r, s;\n+};\n+struct T : public S\n+{\n+  constexpr T () : t (2) {}\n+  int t;\n+  S u;\n+};\n+struct U : public S\n+{\n+  constexpr U (int x) : u (x) {}\n+  constexpr ~U () = default;\n+  int u;\n+  S v;\n+};\n+\n+constexpr S a;\n+constexpr T b;\n+constexpr U c = 3;\n+static_assert (a.s == 1 && a.r == 3);\n+static_assert (b.s == 1 && b.r == 3 && b.t == 2 && b.u.s == 1 && b.u.r == 3);\n+static_assert (c.s == 1 && c.r == 3 && c.u == 3 && c.v.s == 1 && c.v.r == 3);\n+\n+void\n+foo ()\n+{\n+  static constexpr S d;\n+  static constexpr T e;\n+  static constexpr U f = 4;\n+  static_assert (d.s == 1 && d.r == 3);\n+  static_assert (e.s == 1 && e.r == 3 && e.t == 2 && e.u.s == 1 && e.u.r == 3);\n+  static_assert (f.s == 1 && f.r == 3 && f.u == 4 && f.v.s == 1 && f.v.r == 3);\n+  if (1)\n+    {\n+      constexpr S g;\n+      constexpr T h;\n+      constexpr U i = 5;\n+      static_assert (g.s == 1 && g.r == 3);\n+      static_assert (h.s == 1 && h.r == 3 && h.t == 2 && h.u.s == 1 && h.u.r == 3);\n+      static_assert (i.s == 1 && i.r == 3 && i.u == 5 && i.v.s == 1 && i.v.r == 3);\n+    }\n+}\n+\n+constexpr bool\n+bar ()\n+{\n+  S j;\n+  T k;\n+  U l = 6;\n+  if (j.s != 1 || j.r != 3)\n+    return false;\n+  if (k.s != 1 || k.r != 3 || k.t != 2 || k.u.s != 1 || k.u.r != 3)\n+    return false;\n+  if (l.s != 1 || l.r != 3 || l.u != 6 || l.v.s != 1 || l.v.r != 3)\n+    return false;\n+  return true;\n+}\n+\n+static_assert (bar ());"}, {"sha": "dcfa4e6caf28776d894c10cf2b04b42e93f73df6", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-dtor3.C", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-dtor3.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,185 @@\n+// P0784R7\n+// { dg-do compile { target c++2a } }\n+\n+struct S\n+{\n+  constexpr S () : s (0) {}\n+  constexpr ~S () {}\n+  int s;\n+};\n+struct T\t// { dg-message \"'T' is not literal because\" }\n+{\t\t// { dg-message \"'T' does not have 'constexpr' destructor\" \"\" { target *-*-* } .-1 }\n+  constexpr T () : t (0) {}\n+  ~T () {}\t// { dg-message \"defaulted destructor calls non-'constexpr' 'T::~T\\\\(\\\\)'\" }\n+  int t;\n+};\n+struct U : public S\n+{\n+  constexpr U () : u (0) {}\n+  constexpr ~U () = default;\t// { dg-error \"explicitly defaulted function 'constexpr U::~U\\\\(\\\\)' cannot be declared 'constexpr' because the implicit declaration is not 'constexpr'\" }\n+  int u;\n+  T t;\n+};\n+struct V : virtual public S\n+{\n+  V () : v (0) {}\n+  constexpr ~V () = default;\t// { dg-error \"explicitly defaulted function 'constexpr V::~V\\\\(\\\\)' cannot be declared 'constexpr' because the implicit declaration is not 'constexpr'\" }\n+  int v;\n+};\n+struct W0\n+{\n+  constexpr W0 () : w (0) {}\n+  constexpr W0 (int x) : w (x) {}\n+  constexpr ~W0 () { if (w == 5) asm (\"\"); w = 3; }\n+  int w;\n+};\n+struct W1\n+{\n+  constexpr W1 () : w (0) {}\n+  constexpr W1 (int x) : w (x) {}\n+  constexpr ~W1 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct W2\n+{\n+  constexpr W2 () : w (0) {}\n+  constexpr W2 (int x) : w (x) {}\n+  constexpr ~W2 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct W3\n+{\n+  constexpr W3 () : w (0) {}\n+  constexpr W3 (int x) : w (x) {}\n+  constexpr ~W3 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct W4\n+{\n+  constexpr W4 () : w (0) {}\n+  constexpr W4 (int x) : w (x) {}\n+  constexpr ~W4 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct W5\n+{\n+  constexpr W5 () : w (0) {}\n+  constexpr W5 (int x) : w (x) {}\n+  constexpr ~W5 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct W6\n+{\n+  constexpr W6 () : w (0) {}\n+  constexpr W6 (int x) : w (x) {}\n+  constexpr ~W6 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct W7\n+{\n+  constexpr W7 () : w (0) {}\n+  constexpr W7 (int x) : w (x) {}\n+  constexpr ~W7 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct W8\n+{\n+  constexpr W8 () : w (0) {}\n+  constexpr W8 (int x) : w (x) {}\n+  constexpr ~W8 () { if (w == 5) asm (\"\"); w = 3; }\t// { dg-error \"inline assembly is not a constant expression\" }\n+\t\t\t\t\t\t\t// { dg-message \"only unevaluated inline assembly is allowed in a 'constexpr' function\" \"\" { target *-*-* } .-1 }\n+  int w;\n+};\n+struct X : public T\n+{\n+  constexpr X () : x (0) {}\n+  constexpr ~X () = default;\t// { dg-error \"explicitly defaulted function 'constexpr X::~X\\\\(\\\\)' cannot be declared 'constexpr' because the implicit declaration is not 'constexpr'\" }\n+  int x;\n+};\n+constexpr S s;\n+constexpr T t;\t// { dg-error \"the type 'const T' of 'constexpr' variable 't' is not literal\" }\n+constexpr W0 w1;\n+constexpr W0 w2 = 12;\n+constexpr W1 w3 = 5;\t// { dg-message \"in 'constexpr' expansion of\" }\n+constexpr W0 w4[3] = { 1, 2, 3 };\n+constexpr W2 w5[3] = { 4, 5, 6 };\t// { dg-message \"in 'constexpr' expansion of\" }\n+\n+void\n+f1 ()\n+{\n+  constexpr S s2;\n+  constexpr W0 w6;\n+  constexpr W0 w7 = 12;\n+  constexpr W3 w8 = 5;\t// { dg-message \"in 'constexpr' expansion of\" }\n+  constexpr W0 w9[3] = { 1, 2, 3 };\n+  constexpr W4 w10[3] = { 4, 5, 6 };\t// { dg-message \"in 'constexpr' expansion of\" }\n+}\n+\n+constexpr int\n+f2 ()\n+{\n+  constexpr S s3;\n+  constexpr W0 w11;\n+  constexpr W0 w12 = 12;\n+  constexpr W5 w13 = 5;\t// { dg-message \"in 'constexpr' expansion of\" }\n+  constexpr W0 w14[3] = { 1, 2, 3 };\n+  constexpr W6 w15[3] = { 4, 5, 6 };\t// { dg-message \"in 'constexpr' expansion of\" }\n+  return 0;\n+}\n+\n+constexpr int\n+f3 ()\n+{\n+  S s3;\n+  W0 w11;\n+  W0 w12 = 12;\n+  W0 w14[3] = { 1, 2, 3 };\n+  return 0;\n+}\n+\n+constexpr int x3 = f3 ();\n+\n+constexpr int\n+f4 ()\n+{\n+  W7 w13 = 5;\n+  return 0;\n+}\n+\n+constexpr int x4 = f4 ();\t// { dg-message \"in 'constexpr' expansion of\" }\n+\n+constexpr int\n+f5 ()\n+{\n+  W8 w15[3] = { 4, 5, 6 };\t// { dg-message \"in 'constexpr' expansion of\" }\n+  return 0;\n+}\n+\n+constexpr int x5 = f5 ();\t// { dg-message \"in 'constexpr' expansion of\" }\n+\n+void\n+f6 ()\n+{\n+  constexpr T t2;\t// { dg-error \"the type 'const T' of 'constexpr' variable 't2' is not literal\" }\n+}\n+\n+constexpr int\n+f7 ()\n+{\n+  constexpr T t3;\t// { dg-error \"the type 'const T' of 'constexpr' variable 't3' is not literal\" }\n+  return 0;\n+}\n+\n+constexpr int\n+f8 ()\n+{\n+  T t4;\t\t\t// { dg-error \"variable 't4' of non-literal type 'T' in 'constexpr' function\" }\n+  return 0;\n+}"}, {"sha": "873edd4d2313a83ae2db402e9020d850691a6835", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new1.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new1.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,39 @@\n+// P0784R7\n+// { dg-do compile { target c++2a } }\n+\n+struct S { constexpr S () : s (5) {} constexpr S (int x) : s (x) {} int s; };\n+\n+constexpr bool\n+foo ()\n+{\n+  int r = 0;\n+  S *p = new S ();\n+  p->s += 3;\n+  r += p->s;\n+  delete p;\n+  p = new S (12);\n+  p->s = p->s * 2;\n+  r += p->s;\n+  delete p;\n+  int *q = new int;\n+  *q = 25;\n+  r += *q;\n+  delete q;\n+  q = new int (1);\n+  r += *q;\n+  if (!q)\n+    return false;\n+  delete q;\n+  q = new int[5]{1,2,3,4,5};\n+  r += q[0] + q[4];\n+  delete[] q;\n+  q = new int[4];\n+  q[0] = 6;\n+  q[1] = 7;\n+  q[3] = 8;\n+  r += q[0] + q[1] + q[3];\n+  delete[] q;\n+  return r == 5 + 3 + 2 * 12 + 25 + 1 + 1 + 5 + 6 + 7 + 8;\n+}\n+constexpr bool a = foo ();\n+static_assert (a);"}, {"sha": "be5496293b6a74a18a30e2fc4225dc39b1a39990", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new2.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,21 @@\n+// P0784R7\n+// { dg-do compile { target c++2a } }\n+\n+template <int N>\n+constexpr bool\n+foo (const char (&x)[N])\n+{\n+  int **p = new int *[N];\n+  for (int i = 0; i < N; i++)\n+    p[i] = new int (x[i]);\n+  for (int i = 0; i < N; i++)\n+    if (*p[i] != x[i])\n+      return false;\n+  for (int i = 0; i < N; ++i)\n+    delete p[i];\n+  delete[] p;\n+  return true;\n+}\n+\n+constexpr bool a = foo (\"foobar\");\n+static_assert (a);"}, {"sha": "3380df74468f1ef5f0d054ee02e19b19807f792c", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new3.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new3.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,73 @@\n+// P0784R7\n+// { dg-do compile { target c++2a } }\n+\n+constexpr int *\n+f1 ()\n+{\n+  return new int (2);\t\t// { dg-error \"is not a constant expression because it refers to a result of\" }\n+}\n+\n+constexpr auto v1 = f1 ();\n+\n+constexpr bool\n+f2 ()\n+{\n+  int *p = new int (3);\t\t// { dg-error \"is not a constant expression because allocated storage has not been deallocated\" }\n+  return false;\n+}\n+\n+constexpr auto v2 = f2 ();\n+\n+constexpr bool\n+f3 ()\n+{\n+  int *p = new int (3);\n+  int *q = p;\n+  delete p;\n+  delete q;\t\t\t// { dg-error \"deallocation of already deallocated storage\" }\n+  return false;\n+}\n+\n+constexpr auto v3 = f3 ();\t// { dg-message \"in 'constexpr' expansion of\" }\n+\n+constexpr bool\n+f4 (int *p)\n+{\n+  delete p;\t\t\t// { dg-error \"deallocation of storage that was not previously allocated\" }\n+  return false;\n+}\n+\n+int q;\n+constexpr auto v4 = f4 (&q);\t// { dg-message \"in 'constexpr' expansion of\" }\n+\n+constexpr bool\n+f5 ()\n+{\n+  int *p = new int;\t\t// { dg-message \"allocated here\" }\n+  return *p == 1;\n+}\n+\n+constexpr auto v5 = f5 ();\t// { dg-error \"the content of uninitialized storage is not usable in a constant expression\" }\n+\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" \"\" { target *-*-* } .-1 }\n+\n+constexpr bool\n+f6 ()\n+{\n+  int *p = new int (2);\t\t// { dg-message \"allocated here\" }\n+  int *q = p;\n+  delete p;\n+  return *q == 2;\n+}\n+\n+constexpr auto v6 = f6 ();\t// { dg-error \"use of allocated storage after deallocation in a constant expression\" }\n+\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" \"\" { target *-*-* } .-1  }\n+\n+constexpr int *\n+f7 ()\n+{\n+  int *p = new int (2);\t\t// { dg-error \"is not a constant expression because it refers to a result of\" }\n+  delete p;\n+  return p;\n+}\n+\n+constexpr auto v7 = f7 ();"}, {"sha": "6cac9835463fd9eab5a2985894fea19992d01a38", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new4.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new4.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,29 @@\n+// P0784R7\n+// { dg-do compile { target c++2a } }\n+\n+struct S\n+{\n+  constexpr S () : s (0) { s++; }\n+  constexpr S (int x) : s (x) { s += 2; }\n+  constexpr ~S () { if (s != 35) asm (\"\"); s = 5; }\n+  int s;\n+};\n+\n+constexpr bool\n+foo ()\n+{\n+  S *p = new S (7);\n+  if (p->s != 9) return false;\n+  p->s = 35;\n+  delete p;\n+  p = new S[3] { 11, 13, 15 };\n+  if (p[0].s != 13 || p[1].s != 15 || p[2].s != 17) return false;\n+  p[0].s = 35;\n+  p[2].s = 35;\n+  p[1].s = 35;\n+  delete[] p;\n+  return true;\n+}\n+\n+constexpr bool a = foo ();\n+static_assert (a);"}, {"sha": "2b9cfd0effc5963be42ede69c0cd7e635f35e567", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -430,16 +430,34 @@\n \n // C++20 features\n \n-#if __cpp_conditional_explicit != 201806\n-# error \"__cpp_conditional_explicit != 201806\"\n+#ifndef __cpp_conditional_explicit\n+#  error \"__cpp_conditional_explicit\"\n+#elif __cpp_conditional_explicit != 201806\n+#  error \"__cpp_conditional_explicit != 201806\"\n #endif\n \n-#if __cpp_nontype_template_parameter_class != 201806\n-# error \"__cpp_nontype_template_parameter_class != 201806\"\n+#ifndef __cpp_nontype_template_parameter_class\n+#  error \"__cpp_nontype_template_parameter_class\"\n+#elif __cpp_nontype_template_parameter_class != 201806\n+#  error \"__cpp_nontype_template_parameter_class != 201806\"\n #endif\n \n-#if __cpp_impl_destroying_delete != 201806\n-# error \"__cpp_impl_destroying_delete != 201806\"\n+#ifndef __cpp_impl_destroying_delete\n+#  error \"__cpp_impl_destroying_delete\"\n+#elif __cpp_impl_destroying_delete != 201806\n+#  error \"__cpp_impl_destroying_delete != 201806\"\n+#endif\n+\n+#ifndef __cpp_constinit\n+#  error \"__cpp_constinit\"\n+#elif __cpp_constinit != 201907\n+#  error \"__cpp_constinit != 201907\"\n+#endif\n+\n+#ifndef __cpp_constexpr_dynamic_alloc\n+#  error \"__cpp_constexpr_dynamic_alloc\"\n+#elif __cpp_constexpr_dynamic_alloc != 201907\n+#  error \"__cpp_constexpr_dynamic_alloc != 201907\"\n #endif\n \n #ifdef __has_cpp_attribute\n@@ -484,8 +502,6 @@\n #  error \"__has_cpp_attribute\"\n #endif\n \n-// C++2A features:\n-\n #ifndef __cpp_char8_t\n #  error \"__cpp_char8_t\"\n #elif __cpp_char8_t != 201811"}, {"sha": "22d8494a2b47a913caca3d1efc1c61d8ea6c321a", "filename": "gcc/testsuite/g++.dg/ext/is_literal_type3.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_literal_type3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e007055dd1374ca4c44406a4ead172be0dfa3a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_literal_type3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_literal_type3.C?ref=8e007055dd1374ca4c44406a4ead172be0dfa3a8", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct S {\n+  constexpr S () : n{} { }\n+  ~S () { n = 1; }\n+  int n;\n+};\n+\n+static_assert(!__is_literal_type(S), \"\");\n+\n+#ifdef __cpp_constexpr_dynamic_alloc\n+struct T {\n+  constexpr T () : n{} { }\n+  constexpr ~T () { n = 1; }\n+  int n;\n+};\n+\n+static_assert(__is_literal_type(T), \"\");\n+\n+struct U : public T {\n+  constexpr U () : u{} { }\n+  int u;\n+};\n+\n+static_assert(__is_literal_type(U), \"\");\n+#endif"}]}