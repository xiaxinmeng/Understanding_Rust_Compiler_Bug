{"sha": "8a28dbccfd0a67fbde3b8364d4da3688508c5ca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEyOGRiY2NmZDBhNjdmYmRlM2I4MzY0ZDRkYTM2ODg1MDhjNWNhMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-04T11:23:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-04T11:23:21Z"}, "message": "expr.c (force_operand): Use expand_simple_* to handle more cases.\n\n\t* expr.c (force_operand): Use expand_simple_* to handle more\n\tcases.\n\nFrom-SVN: r53154", "tree": {"sha": "8e6feb5e7b280b49663becdac5be4fee44ee12b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e6feb5e7b280b49663becdac5be4fee44ee12b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3/comments", "author": null, "committer": null, "parents": [{"sha": "ae1a07e00c1f0bab2b14dc4987e9f428e6b7b990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1a07e00c1f0bab2b14dc4987e9f428e6b7b990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1a07e00c1f0bab2b14dc4987e9f428e6b7b990"}], "stats": {"total": 116, "additions": 73, "deletions": 43}, "files": [{"sha": "6d8a2e72e4884234a91f26e69fcb856a70247aef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a28dbccfd0a67fbde3b8364d4da3688508c5ca3", "patch": "@@ -1,3 +1,8 @@\n+Sat May  4 13:20:54 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* expr.c (force_operand): Use expand_simple_* to handle more\n+\tcases.\n+\n 2002-05-04  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-lex.c (lex_string): Let cpp_parse_escape handles truncation"}, {"sha": "dc4c335628603aaf317b7c6c639b37d67c2dad14", "filename": "gcc/expr.c", "status": "modified", "additions": 68, "deletions": 43, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a28dbccfd0a67fbde3b8364d4da3688508c5ca3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8a28dbccfd0a67fbde3b8364d4da3688508c5ca3", "patch": "@@ -5432,16 +5432,13 @@ rtx\n force_operand (value, target)\n      rtx value, target;\n {\n-  optab binoptab = 0;\n-  /* Use a temporary to force order of execution of calls to\n-     `force_operand'.  */\n-  rtx tmp;\n-  rtx op2;\n+  rtx op1, op2;\n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n   rtx subtarget = get_subtarget (target);\n+  enum rtx_code code = GET_CODE (value);\n \n   /* Check for a PIC address load.  */\n-  if ((GET_CODE (value) == PLUS || GET_CODE (value) == MINUS)\n+  if ((code == PLUS || code == MINUS)\n       && XEXP (value, 0) == pic_offset_table_rtx\n       && (GET_CODE (XEXP (value, 1)) == SYMBOL_REF\n \t  || GET_CODE (XEXP (value, 1)) == LABEL_REF\n@@ -5453,60 +5450,88 @@ force_operand (value, target)\n       return subtarget;\n     }\n \n-  if (GET_CODE (value) == PLUS)\n-    binoptab = add_optab;\n-  else if (GET_CODE (value) == MINUS)\n-    binoptab = sub_optab;\n-  else if (GET_CODE (value) == MULT)\n+  if (code == ZERO_EXTEND || code == SIGN_EXTEND)\n     {\n-      op2 = XEXP (value, 1);\n-      if (!CONSTANT_P (op2)\n-\t  && !(GET_CODE (op2) == REG && op2 != subtarget))\n-\tsubtarget = 0;\n-      tmp = force_operand (XEXP (value, 0), subtarget);\n-      return expand_mult (GET_MODE (value), tmp,\n-\t\t\t  force_operand (op2, NULL_RTX),\n-\t\t\t  target, 1);\n+      if (!target)\n+\ttarget = gen_reg_rtx (GET_MODE (value));\n+      convert_move (force_operand (XEXP (value, 0), NULL), target,\n+\t\t    code == ZERO_EXTEND);\n+      return target;\n     }\n \n-  if (binoptab)\n+  if (GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c')\n     {\n       op2 = XEXP (value, 1);\n-      if (!CONSTANT_P (op2)\n-\t  && !(GET_CODE (op2) == REG && op2 != subtarget))\n+      if (!CONSTANT_P (op2) && !(GET_CODE (op2) == REG && op2 != subtarget))\n \tsubtarget = 0;\n-      if (binoptab == sub_optab && GET_CODE (op2) == CONST_INT)\n+      if (code == MINUS && GET_CODE (op2) == CONST_INT)\n \t{\n-\t  binoptab = add_optab;\n+\t  code = PLUS;\n \t  op2 = negate_rtx (GET_MODE (value), op2);\n \t}\n \n       /* Check for an addition with OP2 a constant integer and our first\n-\t operand a PLUS of a virtual register and something else.  In that\n-\t case, we want to emit the sum of the virtual register and the\n-\t constant first and then add the other value.  This allows virtual\n-\t register instantiation to simply modify the constant rather than\n-\t creating another one around this addition.  */\n-      if (binoptab == add_optab && GET_CODE (op2) == CONST_INT\n+         operand a PLUS of a virtual register and something else.  In that\n+         case, we want to emit the sum of the virtual register and the\n+         constant first and then add the other value.  This allows virtual\n+         register instantiation to simply modify the constant rather than\n+         creating another one around this addition.  */\n+      if (code == PLUS && GET_CODE (op2) == CONST_INT\n \t  && GET_CODE (XEXP (value, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (value, 0), 0)) == REG\n \t  && REGNO (XEXP (XEXP (value, 0), 0)) >= FIRST_VIRTUAL_REGISTER\n \t  && REGNO (XEXP (XEXP (value, 0), 0)) <= LAST_VIRTUAL_REGISTER)\n \t{\n-\t  rtx temp = expand_binop (GET_MODE (value), binoptab,\n-\t\t\t\t   XEXP (XEXP (value, 0), 0), op2,\n-\t\t\t\t   subtarget, 0, OPTAB_LIB_WIDEN);\n-\t  return expand_binop (GET_MODE (value), binoptab, temp,\n-\t\t\t       force_operand (XEXP (XEXP (value, 0), 1), 0),\n-\t\t\t       target, 0, OPTAB_LIB_WIDEN);\n+\t  rtx temp = expand_simple_binop (GET_MODE (value), code,\n+\t\t\t\t\t  XEXP (XEXP (value, 0), 0), op2,\n+\t\t\t\t\t  subtarget, 0, OPTAB_LIB_WIDEN);\n+\t  return expand_simple_binop (GET_MODE (value), code, temp,\n+\t\t\t\t      force_operand (XEXP (XEXP (value,\n+\t\t\t\t\t\t\t\t 0), 1), 0),\n+\t\t\t\t      target, 0, OPTAB_LIB_WIDEN);\n+\t}\n+\n+      op1 = force_operand (XEXP (value, 0), subtarget);\n+      op2 = force_operand (op2, NULL_RTX);\n+      switch (code)\n+\t{\n+\tcase MULT:\n+\t  return expand_mult (GET_MODE (value), op1, op2, target, 1);\n+\tcase DIV:\n+\t  if (!INTEGRAL_MODE_P (GET_MODE (value)))\n+\t    return expand_simple_binop (GET_MODE (value), code, op1, op2,\n+\t\t\t\t\ttarget, 1, OPTAB_LIB_WIDEN);\n+\t  else\n+\t    return expand_divmod (0,\n+\t\t\t\t  FLOAT_MODE_P (GET_MODE (value))\n+\t\t\t\t  ? RDIV_EXPR : TRUNC_DIV_EXPR,\n+\t\t\t\t  GET_MODE (value), op1, op2, target, 0);\n+\t  break;\n+\tcase MOD:\n+\t  return expand_divmod (1, TRUNC_MOD_EXPR, GET_MODE (value), op1, op2,\n+\t\t\t\ttarget, 0);\n+\t  break;\n+\tcase UDIV:\n+\t  return expand_divmod (0, TRUNC_DIV_EXPR, GET_MODE (value), op1, op2,\n+\t\t\t\ttarget, 1);\n+\t  break;\n+\tcase UMOD:\n+\t  return expand_divmod (1, TRUNC_MOD_EXPR, GET_MODE (value), op1, op2,\n+\t\t\t\ttarget, 1);\n+\t  break;\n+\tcase ASHIFTRT:\n+\t  return expand_simple_binop (GET_MODE (value), code, op1, op2,\n+\t\t\t\t      target, 0, OPTAB_LIB_WIDEN);\n+\t  break;\n+\tdefault:\n+\t  return expand_simple_binop (GET_MODE (value), code, op1, op2,\n+\t\t\t\t      target, 1, OPTAB_LIB_WIDEN);\n \t}\n-\n-      tmp = force_operand (XEXP (value, 0), subtarget);\n-      return expand_binop (GET_MODE (value), binoptab, tmp,\n-\t\t\t   force_operand (op2, NULL_RTX),\n-\t\t\t   target, 0, OPTAB_LIB_WIDEN);\n-      /* We give UNSIGNEDP = 0 to expand_binop\n-\t because the only operations we are expanding here are signed ones.  */\n+    }\n+  if (GET_RTX_CLASS (code) == '1')\n+    {\n+      op1 = force_operand (XEXP (value, 0), NULL_RTX);\n+      return expand_simple_unop (GET_MODE (value), code, op1, target, 0);\n     }\n \n #ifdef INSN_SCHEDULING"}]}