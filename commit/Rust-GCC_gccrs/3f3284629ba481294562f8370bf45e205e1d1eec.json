{"sha": "3f3284629ba481294562f8370bf45e205e1d1eec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YzMjg0NjI5YmE0ODEyOTQ1NjJmODM3MGJmNDVlMjA1ZTFkMWVlYw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2018-11-09T02:46:03Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2018-11-09T02:46:03Z"}, "message": "re PR fortran/78351 (comma not terminating READ of formatted input field - ok in 4.1.7, not 4.4.7- maybe related to 25419?)\n\n2018-11-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/78351\n\t* io/transfer.c (read_sf_internal): Add support for early\n\tcomma termination of internal unit formatted reads.\n\n\t* gfortran.dg/read_legacy_comma.f90: New test.\n\nFrom-SVN: r265946", "tree": {"sha": "4d11a4fdaec7d19157cb0b95829bc770aa7b9aa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d11a4fdaec7d19157cb0b95829bc770aa7b9aa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f3284629ba481294562f8370bf45e205e1d1eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3284629ba481294562f8370bf45e205e1d1eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f3284629ba481294562f8370bf45e205e1d1eec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3284629ba481294562f8370bf45e205e1d1eec/comments", "author": null, "committer": null, "parents": [{"sha": "648cdca78ddaf6e5bafc8f735c3336eb5f1e5999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648cdca78ddaf6e5bafc8f735c3336eb5f1e5999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/648cdca78ddaf6e5bafc8f735c3336eb5f1e5999"}], "stats": {"total": 137, "additions": 114, "deletions": 23}, "files": [{"sha": "b300e5f0d9579615a2022b8b91893c4649950709", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3284629ba481294562f8370bf45e205e1d1eec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3284629ba481294562f8370bf45e205e1d1eec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3f3284629ba481294562f8370bf45e205e1d1eec", "patch": "@@ -1,3 +1,8 @@\n+2018-11-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/78351\n+\t* gfortran.dg/read_legacy_comma.f90: New test.\n+\n 2018-11-08  Peter Bergner  <bergner@linux.ibm.com>\n \n \tPR rtl-optimization/87600"}, {"sha": "7c3e18534124910c790f1a51277b4ea2ff3ee0eb", "filename": "gcc/testsuite/gfortran.dg/read_legacy_comma.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3284629ba481294562f8370bf45e205e1d1eec/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_legacy_comma.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3284629ba481294562f8370bf45e205e1d1eec/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_legacy_comma.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_legacy_comma.f90?ref=3f3284629ba481294562f8370bf45e205e1d1eec", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! { dg-options \"-std=legacy\" }\n+! PR78351\n+program read_csv\n+  implicit none\n+  integer, parameter :: dbl = selected_real_kind(p=14, r=99)\n+\n+  call checkit(\"101,1.,2.,3.,7,7\")\n+  call checkit (\"102,1.,,3.,,7\")\n+  call checkit (\",1.,,3.,,                                         \")\n+\n+contains\n+\n+subroutine checkit (text)\n+  character(*) :: text\n+  integer :: I1, I2, I3\n+  real(dbl) :: R1, R2, R3\n+  10 format (I8,3ES16.8,2I8)\n+  \n+  I1=-99;       I2=-99;       I3=-99\n+  R1=-99._DBL;  R2=-99._DBL;  R3=-99._DBL\n+  read(text,10) I1, R1, R2, R3, I2, I3\n+  if (I1 == -99) stop 1\n+  if (I2 == -99) stop 2\n+  if (I3 == -99) stop 3\n+  if (R1 == -99._DBL) stop 4\n+  if (R2 == -99._DBL) stop 5\n+  if (R3 == -99._DBL) stop 6\n+end subroutine\n+\n+end program"}, {"sha": "336c1c00de4f58b0644a083660301d8da67380cd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3284629ba481294562f8370bf45e205e1d1eec/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3284629ba481294562f8370bf45e205e1d1eec/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3f3284629ba481294562f8370bf45e205e1d1eec", "patch": "@@ -1,3 +1,9 @@\n+2018-11-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/78351\n+\t* io/transfer.c (read_sf_internal): Add support for early\n+\tcomma termination of internal unit formatted reads.\n+\n 2018-10-31  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR bootstrap/82856"}, {"sha": "21bfea486404aa5fb76ce396e94fb983a6811552", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 72, "deletions": 23, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3284629ba481294562f8370bf45e205e1d1eec/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3284629ba481294562f8370bf45e205e1d1eec/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=3f3284629ba481294562f8370bf45e205e1d1eec", "patch": "@@ -241,16 +241,6 @@ read_sf_internal (st_parameter_dt *dtp, size_t *length)\n       && dtp->u.p.current_unit->pad_status == PAD_NO)\n     hit_eof (dtp);\n \n-  /* If we have seen an eor previously, return a length of 0.  The\n-     caller is responsible for correctly padding the input field.  */\n-  if (dtp->u.p.sf_seen_eor)\n-    {\n-      *length = 0;\n-      /* Just return something that isn't a NULL pointer, otherwise the\n-         caller thinks an error occurred.  */\n-      return (char*) empty_string;\n-    }\n-\n   /* There are some cases with mixed DTIO where we have read a character\n      and saved it in the last character buffer, so we need to backup.  */\n   if (unlikely (dtp->u.p.current_unit->child_dtio > 0 &&\n@@ -260,22 +250,81 @@ read_sf_internal (st_parameter_dt *dtp, size_t *length)\n       sseek (dtp->u.p.current_unit->s, -1, SEEK_CUR);\n     }\n \n-  lorig = *length;\n-  if (is_char4_unit(dtp))\n+  /* To support legacy code we have to scan the input string one byte\n+     at a time because we don't know where an early comma may be and the\n+     requested length could go past the end of a comma shortened\n+     string.  We only do this if -std=legacy was given at compile\n+     time.  We also do not support this on kind=4 strings.  */\n+  printf(\"allow_std=%d\\n\", compile_options.warn_std);\n+  if (unlikely(compile_options.warn_std == 0)) // the slow legacy way.\n     {\n-      gfc_char4_t *p = (gfc_char4_t *) mem_alloc_r4 (dtp->u.p.current_unit->s,\n-\t\t\tlength);\n-      base = fbuf_alloc (dtp->u.p.current_unit, lorig);\n-      for (size_t i = 0; i < *length; i++, p++)\n-\tbase[i] = *p > 255 ? '?' : (unsigned char) *p;\n-    }\n-  else\n-    base = mem_alloc_r (dtp->u.p.current_unit->s, length);\n+      size_t n;\n+      size_t tmp = 1;\n+      char *q;\n+\n+      /* If we have seen an eor previously, return a length of 0.  The\n+\t caller is responsible for correctly padding the input field.  */\n+      if (dtp->u.p.sf_seen_eor)\n+\t{\n+\t  *length = 0;\n+\t  /* Just return something that isn't a NULL pointer, otherwise the\n+\t     caller thinks an error occurred.  */\n+\t  return (char*) empty_string;\n+\t}\n+\n+      /* Get the first character of the string to establish the base\n+\t address and check for comma or end-of-record condition.  */\n+      base = mem_alloc_r (dtp->u.p.current_unit->s, &tmp);\n+      if (tmp == 0)\n+\t{\n+\t  dtp->u.p.sf_seen_eor = 1;\n+\t  *length = 0;\n+\t  return (char*) empty_string;\n+\t}\n+      if (*base == ',')\n+\t{\n+\t  dtp->u.p.current_unit->bytes_left--;\n+\t  *length = 0;\n+\t  return (char*) empty_string;\n+\t}\n \n-  if (unlikely (lorig > *length))\n+      /* Now we scan the rest and deal with either an end-of-file\n+         condition or a comma, as needed.  */\n+      for (n = 1; n < *length; n++)\n+\t{\n+\t  q = mem_alloc_r (dtp->u.p.current_unit->s, &tmp);\n+\t  if (tmp == 0)\n+\t    {\n+\t      hit_eof (dtp);\n+\t      return NULL;\n+\t    }\n+\t  if (*q == ',')\n+\t    {\n+\t      dtp->u.p.current_unit->bytes_left -= n;\n+\t      *length = n;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else // the fast way\n     {\n-      hit_eof (dtp);\n-      return NULL;\n+      lorig = *length;\n+      if (is_char4_unit(dtp))\n+\t{\n+\t  gfc_char4_t *p = (gfc_char4_t *) mem_alloc_r4 (dtp->u.p.current_unit->s,\n+\t\t\t    length);\n+\t  base = fbuf_alloc (dtp->u.p.current_unit, lorig);\n+\t  for (size_t i = 0; i < *length; i++, p++)\n+\t    base[i] = *p > 255 ? '?' : (unsigned char) *p;\n+\t}\n+      else\n+\tbase = mem_alloc_r (dtp->u.p.current_unit->s, length);\n+\n+      if (unlikely (lorig > *length))\n+\t{\n+\t  hit_eof (dtp);\n+\t  return NULL;\n+\t}\n     }\n \n   dtp->u.p.current_unit->bytes_left -= *length;"}]}