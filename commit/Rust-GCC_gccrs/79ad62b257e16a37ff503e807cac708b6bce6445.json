{"sha": "79ad62b257e16a37ff503e807cac708b6bce6445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhZDYyYjI1N2UxNmEzN2ZmNTAzZTgwN2NhYzcwOGI2YmNlNjQ0NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-06-13T23:48:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-06-13T23:48:07Z"}, "message": "class.c (alter_access): Accept a BINFO explaining how to get from the entity whose accessed is being...\n\n\t* class.c (alter_access): Accept a BINFO explaining how to get\n\tfrom the entity whose accessed is being altered to the type doing\n\tthe altering.\n\t(handle_using_decl): New function containing code split out from ...\n\t(finish_struct_1): Here.\n\nFrom-SVN: r20500", "tree": {"sha": "7f52e502259781581c743bed14eb7dc907665944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f52e502259781581c743bed14eb7dc907665944"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79ad62b257e16a37ff503e807cac708b6bce6445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ad62b257e16a37ff503e807cac708b6bce6445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ad62b257e16a37ff503e807cac708b6bce6445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ad62b257e16a37ff503e807cac708b6bce6445/comments", "author": null, "committer": null, "parents": [{"sha": "8f259df3c054e887bf95c598842a4245195a1107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f259df3c054e887bf95c598842a4245195a1107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f259df3c054e887bf95c598842a4245195a1107"}], "stats": {"total": 212, "additions": 110, "deletions": 102}, "files": [{"sha": "897a1a1847a2d917af9866c1f43efd43653eb60a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ad62b257e16a37ff503e807cac708b6bce6445/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ad62b257e16a37ff503e807cac708b6bce6445/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=79ad62b257e16a37ff503e807cac708b6bce6445", "patch": "@@ -1,5 +1,11 @@\n 1998-06-13  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* class.c (alter_access): Accept a BINFO explaining how to get\n+\tfrom the entity whose accessed is being altered to the type doing\n+\tthe altering.\n+\t(handle_using_decl): New function containing code split out from ...\n+\t(finish_struct_1): Here.\n+\n \t* cp-tree.h (complete_type_or_else): Declare.\n \t* init.c (build_new_1, build_delete): Use it.\n \t* typeck.c (require_complete_type): Use complete_type, rather than"}, {"sha": "56c298434585ca6caa5a431f571eca034220547f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 102, "deletions": 100, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ad62b257e16a37ff503e807cac708b6bce6445/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ad62b257e16a37ff503e807cac708b6bce6445/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=79ad62b257e16a37ff503e807cac708b6bce6445", "patch": "@@ -107,7 +107,8 @@ static void add_virtual_function PROTO((tree *, tree *, int *, tree, tree));\n static tree delete_duplicate_fields_1 PROTO((tree, tree));\n static void delete_duplicate_fields PROTO((tree));\n static void finish_struct_bits PROTO((tree, int));\n-static int alter_access PROTO((tree, tree, tree));\n+static int alter_access PROTO((tree, tree, tree, tree));\n+static void handle_using_decl PROTO((tree, tree, tree, tree));\n static int overrides PROTO((tree, tree));\n static int strictly_overrides PROTO((tree, tree));\n static void merge_overrides PROTO((tree, tree, int, tree));\n@@ -1277,12 +1278,14 @@ delete_duplicate_fields (fields)\n     TREE_CHAIN (x) = delete_duplicate_fields_1 (x, TREE_CHAIN (x));\n }\n \n-/* Change the access of FDECL to ACCESS in T.\n-   Return 1 if change was legit, otherwise return 0.  */\n+/* Change the access of FDECL to ACCESS in T.  The access to FDECL is\n+   along the path given by BINFO.  Return 1 if change was legit,\n+   otherwise return 0.  */\n \n static int\n-alter_access (t, fdecl, access)\n+alter_access (t, binfo, fdecl, access)\n      tree t;\n+     tree binfo;\n      tree fdecl;\n      tree access;\n {\n@@ -1306,14 +1309,102 @@ alter_access (t, fdecl, access)\n     }\n   else\n     {\n-      enforce_access (TYPE_BINFO (t), fdecl);\n+      enforce_access (binfo, fdecl);\n \n       DECL_ACCESS (fdecl) = tree_cons (t, access, DECL_ACCESS (fdecl));\n       return 1;\n     }\n   return 0;\n }\n \n+/* Process the USING_DECL, which is a member of T.  The METHOD_VEC, if\n+   non-NULL, is the methods of T.  The FIELDS are the fields of T.\n+   Returns 1 if the USING_DECL was valid, 0 otherwise.  */\n+\n+void\n+handle_using_decl (using_decl, t, method_vec, fields)\n+     tree using_decl;\n+     tree t;\n+     tree method_vec;\n+     tree fields;\n+{\n+  tree ctype = DECL_INITIAL (using_decl);\n+  tree name = DECL_NAME (using_decl);\n+  tree access\n+    = TREE_PRIVATE (using_decl) ? access_private_node\n+    : TREE_PROTECTED (using_decl) ? access_protected_node\n+    : access_public_node;\n+  tree fdecl, binfo;\n+  tree flist = NULL_TREE;\n+  tree tmp;\n+  int i;\n+  int n_methods;\n+\n+  binfo = binfo_or_else (ctype, t);\n+  if (! binfo)\n+    return;\n+  \n+  if (name == constructor_name (ctype)\n+      || name == constructor_name_full (ctype))\n+    cp_error_at (\"using-declaration for constructor\", using_decl);\n+  \n+  fdecl = lookup_member (binfo, name, 0, 0);\n+  \n+  if (!fdecl)\n+    {\n+      cp_error_at (\"no members matching `%D' in `%#T'\", using_decl, ctype);\n+      return;\n+    }\n+\n+  /* Functions are represented as TREE_LIST, with the purpose\n+     being the type and the value the functions. Other members\n+     come as themselves. */\n+  if (TREE_CODE (fdecl) == TREE_LIST)\n+    /* Ignore base type this came from. */\n+    fdecl = TREE_VALUE (fdecl);\n+\n+  if (TREE_CODE (fdecl) == OVERLOAD)\n+    {\n+      /* We later iterate over all functions. */\n+      flist = fdecl;\n+      fdecl = OVL_FUNCTION (flist);\n+    }\n+  \n+  name = DECL_NAME (fdecl);\n+  n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n+  for (i = 2; i < n_methods; i++)\n+    if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n+\t== name)\n+      {\n+\tcp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n+\tcp_error_at (\"  because of local method `%#D' with same name\",\n+\t\t     OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n+\treturn;\n+      }\n+  \n+  for (tmp = fields; tmp; tmp = TREE_CHAIN (tmp))\n+    if (DECL_NAME (tmp) == name)\n+      {\n+\tcp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n+\tcp_error_at (\"  because of local field `%#D' with same name\", tmp);\n+\treturn;\n+      }\n+  \n+  /* Make type T see field decl FDECL with access ACCESS.*/\n+  if (flist)\n+    {\n+      while (flist)\n+\t{\n+\t  if (alter_access (t, binfo, OVL_FUNCTION (flist), \n+\t\t\t    access) == 0)\n+\t    return;\n+\t  flist = OVL_CHAIN (flist);\n+\t}\n+    }\n+  else\n+    alter_access (t, binfo, fdecl, access);\n+}\n+\n /* If FOR_TYPE needs to reinitialize virtual function table pointers\n    for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.\n    Returns BASE_INIT_LIST appropriately modified.  */\n@@ -3186,36 +3277,15 @@ finish_struct_1 (t, warn_anon)\n \t  empty = 0;\n \t}\n \n-      /* Handle access declarations.  */\n       if (TREE_CODE (x) == USING_DECL)\n \t{\n-\t  tree ctype = DECL_INITIAL (x);\n-\t  tree sname = DECL_NAME (x);\n-\t  tree access\n-\t    = TREE_PRIVATE (x) ? access_private_node\n-\t\t\t       : TREE_PROTECTED (x) ? access_protected_node\n-\t\t\t\t\t\t    : access_public_node;\n-\t  tree fdecl, binfo;\n-\n+\t  /* Save access declarations for later.  */\n \t  if (last_x)\n \t    TREE_CHAIN (last_x) = TREE_CHAIN (x);\n \t  else\n \t    fields = TREE_CHAIN (x);\n-\n-\t  binfo = binfo_or_else (ctype, t);\n-\t  if (! binfo)\n-\t    continue;\n-\n-\t  if (sname == constructor_name (ctype)\n-\t      || sname == constructor_name_full (ctype))\n-\t    cp_error_at (\"using-declaration for constructor\", x);\n-\n-\t  fdecl = lookup_member (binfo, sname, 0, 0);\n-\n-\t  if (fdecl)\n-\t    access_decls = scratch_tree_cons (access, fdecl, access_decls);\n-\t  else\n-\t    cp_error_at (\"no members matching `%D' in `%#T'\", x, ctype);\n+\t  \n+\t  access_decls = scratch_tree_cons (NULL_TREE, x, access_decls);\n \t  continue;\n \t}\n \n@@ -3658,77 +3728,9 @@ finish_struct_1 (t, warn_anon)\n       TYPE_HAS_DESTRUCTOR (t) = 0;\n     }\n \n-  {\n-    int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n-    \n-    for (access_decls = nreverse (access_decls); access_decls;\n-\t access_decls = TREE_CHAIN (access_decls))\n-      {\n-\ttree fdecl = TREE_VALUE (access_decls);\n-\ttree flist = NULL_TREE;\n-\ttree name;\n-\ttree access = TREE_PURPOSE (access_decls);\n-\tint i = 2;\n-\ttree tmp;\n-\n-\t/* Functions are represented as TREE_LIST, with the purpose\n-\t   being the type and the value the functions. Other members\n-\t   come as themselves. */\n-\tif (TREE_CODE (fdecl) == TREE_LIST)\n-\t  {\n-\t    /* Ignore base type this came from. */\n-\t    fdecl = TREE_VALUE (fdecl);\n-\t  }\n-\tif (TREE_CODE (fdecl) == OVERLOAD)\n-\t  {\n-\t    /* We later iterate over all functions. */\n-\t    flist = fdecl;\n-\t    fdecl = OVL_FUNCTION (flist);\n-\t  }\n-\n-\tname = DECL_NAME (fdecl);\n-\n-\tfor (; i < n_methods; i++)\n-\t  if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n-\t\t== name)\n-\t    {\n-\t      cp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n-\t      cp_error_at (\"  because of local method `%#D' with same name\",\n-\t\t\t   OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n-\t      fdecl = NULL_TREE;\n-\t      break;\n-\t    }\n-\n-\tif (! fdecl)\n-\t  continue;\n-\t\n-\tfor (tmp = fields; tmp; tmp = TREE_CHAIN (tmp))\n-\t  if (DECL_NAME (tmp) == name)\n-\t    {\n-\t      cp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n-\t      cp_error_at (\"  because of local field `%#D' with same name\", tmp);\n-\t      fdecl = NULL_TREE;\n-\t      break;\n-\t    }\n-\n-\tif (!fdecl)\n-\t  continue;\n-\t\n-\t/* Make type T see field decl FDECL with access ACCESS.*/\n-\tif (flist)\n-\t  {\n-\t    while (flist)\n-\t      {\n-\t\tif (alter_access (t, OVL_FUNCTION (flist), access) == 0)\n-\t\t  break;\n-\t\tflist = OVL_CHAIN (flist);\n-\t      }\n-\t  }\n-\telse\n-\t  alter_access (t, fdecl, access);\n-      }\n-    \n-  }\n+  for (access_decls = nreverse (access_decls); access_decls;\n+       access_decls = TREE_CHAIN (access_decls))\n+    handle_using_decl (TREE_VALUE (access_decls), t, method_vec, fields); \n \n   if (vfield == NULL_TREE && has_virtual)\n     {"}, {"sha": "d22d512f64b8c35f8b68fac19a99d11fd73331a1", "filename": "gcc/testsuite/g++.old-deja/g++.other/using1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ad62b257e16a37ff503e807cac708b6bce6445/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fusing1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ad62b257e16a37ff503e807cac708b6bce6445/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fusing1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fusing1.C?ref=79ad62b257e16a37ff503e807cac708b6bce6445", "patch": "@@ -2,7 +2,7 @@ class D2;\n \n class B {\n private:\n-  int a;\n+  int a; // ERROR - B::a is private\n protected:\n   int b;\n \n@@ -13,7 +13,7 @@ class D : public B {\n public:\n   using B::a;\n   using B::b;\n-};\n+}; // ERROR - within this context\n \n class D2 : public B {\n public:"}]}