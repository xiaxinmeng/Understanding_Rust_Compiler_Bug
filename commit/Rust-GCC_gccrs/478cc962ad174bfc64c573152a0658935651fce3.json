{"sha": "478cc962ad174bfc64c573152a0658935651fce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4Y2M5NjJhZDE3NGJmYzY0YzU3MzE1MmEwNjU4OTM1NjUxZmNlMw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-07-15T15:07:12Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-07-15T19:58:11Z"}, "message": "Add gimple_range_type for statements.\n\nThe existing mechanisms for picking up the type of a statement are\ninconsistent with the needs of ranger. Encapsulate all the bits\nrequired to pick up the return type of a statement in one place, and check\nwhether the type is supported.\n\n\t* gimple-range-fold.cc (adjust_pointer_diff_expr): Use\n\tgimple_range_type.\n\t(fold_using_range::fold_stmt): Ditto.\n\t(fold_using_range::range_of_range_op): Ditto.\n\t(fold_using_range::range_of_phi): Ditto.\n\t(fold_using_range::range_of_call): Ditto.\n\t(fold_using_range::range_of_builtin_ubsan_call): Ditto.\n\t(fold_using_range::range_of_builtin_call): Ditto.\n\t(fold_using_range::range_of_cond_expr): Ditto.\n\t* gimple-range-fold.h (gimple_range_type): New.", "tree": {"sha": "092b98b66e17b719def4a96973fcfb7851187538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/092b98b66e17b719def4a96973fcfb7851187538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478cc962ad174bfc64c573152a0658935651fce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478cc962ad174bfc64c573152a0658935651fce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478cc962ad174bfc64c573152a0658935651fce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478cc962ad174bfc64c573152a0658935651fce3/comments", "author": null, "committer": null, "parents": [{"sha": "f0500db3692276f60e0562c17c87a0cb03e34398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0500db3692276f60e0562c17c87a0cb03e34398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0500db3692276f60e0562c17c87a0cb03e34398"}], "stats": {"total": 74, "additions": 49, "deletions": 25}, "files": [{"sha": "f8578c013bcbb24a5745d6b50758e6e3491ad691", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478cc962ad174bfc64c573152a0658935651fce3/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478cc962ad174bfc64c573152a0658935651fce3/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=478cc962ad174bfc64c573152a0658935651fce3", "patch": "@@ -362,7 +362,7 @@ adjust_pointer_diff_expr (irange &res, const gimple *diff_stmt)\n     {\n       tree max = vrp_val_max (ptrdiff_type_node);\n       wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n-      tree expr_type = gimple_expr_type (diff_stmt);\n+      tree expr_type = gimple_range_type (diff_stmt);\n       tree range_min = build_zero_cst (expr_type);\n       tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n       int_range<2> r (range_min, range_max);\n@@ -522,16 +522,8 @@ fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n \n   if (!res)\n     {\n-      // If no name is specified, try the expression kind.\n-      if (!name)\n-\t{\n-\t  tree t = gimple_expr_type (s);\n-\t  if (!irange::supports_type_p (t))\n-\t    return false;\n-\t  r.set_varying (t);\n-\t  return true;\n-\t}\n-      if (!gimple_range_ssa_p (name))\n+      // If no name specified or range is unsupported, bail.\n+      if (!name || !gimple_range_ssa_p (name))\n \treturn false;\n       // We don't understand the stmt, so return the global range.\n       r = gimple_range_global (name);\n@@ -558,10 +550,11 @@ bool\n fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n {\n   int_range_max range1, range2;\n-  tree type = gimple_expr_type (s);\n+  tree type = gimple_range_type (s);\n+  if (!type)\n+    return false;\n   range_operator *handler = gimple_range_handler (s);\n   gcc_checking_assert (handler);\n-  gcc_checking_assert (irange::supports_type_p (type));\n \n   tree lhs = gimple_get_lhs (s);\n   tree op1 = gimple_range_operand1 (s);\n@@ -719,11 +712,11 @@ bool\n fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n {\n   tree phi_def = gimple_phi_result (phi);\n-  tree type = TREE_TYPE (phi_def);\n+  tree type = gimple_range_type (phi);\n   int_range_max arg_range;\n   unsigned x;\n \n-  if (!irange::supports_type_p (type))\n+  if (!type)\n     return false;\n \n   // Start with an empty range, unioning in each argument's range.\n@@ -780,13 +773,13 @@ fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n bool\n fold_using_range::range_of_call (irange &r, gcall *call, fur_source &src)\n {\n-  tree type = gimple_call_return_type (call);\n+  tree type = gimple_range_type (call);\n+  if (!type)\n+    return false;\n+\n   tree lhs = gimple_call_lhs (call);\n   bool strict_overflow_p;\n \n-  if (!irange::supports_type_p (type))\n-    return false;\n-\n   if (range_of_builtin_call (r, call, src))\n     ;\n   else if (gimple_stmt_nonnegative_warnv_p (call, &strict_overflow_p))\n@@ -817,7 +810,7 @@ fold_using_range::range_of_builtin_ubsan_call (irange &r, gcall *call,\n {\n   gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR\n \t\t       || code == MULT_EXPR);\n-  tree type = gimple_call_return_type (call);\n+  tree type = gimple_range_type (call);\n   range_operator *op = range_op_handler (code, type);\n   gcc_checking_assert (op);\n   int_range_max ir0, ir1;\n@@ -853,7 +846,7 @@ fold_using_range::range_of_builtin_call (irange &r, gcall *call,\n   if (func == CFN_LAST)\n     return false;\n \n-  tree type = gimple_call_return_type (call);\n+  tree type = gimple_range_type (call);\n   tree arg;\n   int mini, maxi, zerov = 0, prec;\n   scalar_int_mode mode;\n@@ -1094,12 +1087,12 @@ fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n   tree op1 = gimple_assign_rhs2 (s);\n   tree op2 = gimple_assign_rhs3 (s);\n \n-  gcc_checking_assert (gimple_assign_rhs_code (s) == COND_EXPR);\n-  gcc_checking_assert (useless_type_conversion_p  (TREE_TYPE (op1),\n-\t\t\t\t\t\t   TREE_TYPE (op2)));\n-  if (!irange::supports_type_p (TREE_TYPE (op1)))\n+  tree type = gimple_range_type (s);\n+  if (!type)\n     return false;\n \n+  gcc_checking_assert (gimple_assign_rhs_code (s) == COND_EXPR);\n+  gcc_checking_assert (range_compatible_p (TREE_TYPE (op1), TREE_TYPE (op2)));\n   src.get_operand (cond_range, cond);\n   src.get_operand (range1, op1);\n   src.get_operand (range2, op2);\n@@ -1118,6 +1111,7 @@ fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n       r = range1;\n       r.union_ (range2);\n     }\n+  gcc_checking_assert (range_compatible_p (r.type (), type));\n   return true;\n }\n "}, {"sha": "ceed7ba48e1cc5a49dc26edc78af638ea3f88f05", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478cc962ad174bfc64c573152a0658935651fce3/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478cc962ad174bfc64c573152a0658935651fce3/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=478cc962ad174bfc64c573152a0658935651fce3", "patch": "@@ -56,6 +56,36 @@ gimple_range_handler (const gimple *s)\n   return NULL;\n }\n \n+// Return the type of range which statement S calculates.  If the type is\n+// unsupported or no type can be determined, return NULL_TREE.\n+\n+static inline tree\n+gimple_range_type (const gimple *s)\n+{\n+  tree lhs = gimple_get_lhs (s);\n+  tree type = NULL_TREE;\n+  if (lhs)\n+    type = TREE_TYPE (lhs);\n+  else\n+    {\n+      enum gimple_code code = gimple_code (s);\n+      if (code == GIMPLE_COND)\n+\ttype = boolean_type_node;\n+      else if (code == GIMPLE_PHI)\n+\ttype = TREE_TYPE (gimple_phi_result (s));\n+      else if (code == GIMPLE_CALL)\n+\t{\n+\t  type = gimple_call_fntype (s);\n+\t  // If it has a type, get the return type.\n+\t  if (type)\n+\t    type = TREE_TYPE (type);\n+\t}\n+    }\n+  if (irange::supports_type_p (type))\n+    return type;\n+  return NULL_TREE;\n+}\n+\n // Return EXP if it is an SSA_NAME with a type supported by gimple ranges.\n \n static inline tree"}]}