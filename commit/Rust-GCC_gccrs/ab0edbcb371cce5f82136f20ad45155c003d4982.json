{"sha": "ab0edbcb371cce5f82136f20ad45155c003d4982", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwZWRiY2IzNzFjY2U1ZjgyMTM2ZjIwYWQ0NTE1NWMwMDNkNDk4Mg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-17T15:20:02Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-30T16:01:33Z"}, "message": "d: Refactor use of built-in memcmp/memcpy/memset into helper functions.\n\nGenerating calls to memset, memcpy, and memcmp is frequent enough that\nit becomes beneficial to put them into their own routine.  All parts of\nthe front-end have been updated to call the new helper functions instead\nof doing it themselves.\n\ngcc/d/ChangeLog:\n\n\t* d-codegen.cc (build_memcmp_call): New function.\n\t(build_memcpy_call): New function.\n\t(build_memset_call): New function.\n\t(build_float_identity): Call build_memcmp_call.\n\t(lower_struct_comparison): Likewise.\n\t(build_struct_comparison): Likewise.\n\t* d-tree.h (build_memcmp_call): Declare.\n\t(build_memcpy_call): Declare.\n\t(build_memset_call): Declare.\n\t* expr.cc (ExprVisitor::visit (EqualExp *)): Call build_memcmp_call.\n\t(ExprVisitor::visit (AssignExp *)): Call build_memset_call.\n\t(ExprVisitor::visit (ArrayLiteralExp *)): Call build_memcpy_call.\n\t(ExprVisitor::visit (StructLiteralExp *)): Call build_memset_call.", "tree": {"sha": "2601487ec66c374c0560c25a47ce266cbbd7bc2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2601487ec66c374c0560c25a47ce266cbbd7bc2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab0edbcb371cce5f82136f20ad45155c003d4982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0edbcb371cce5f82136f20ad45155c003d4982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab0edbcb371cce5f82136f20ad45155c003d4982", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0edbcb371cce5f82136f20ad45155c003d4982/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc60d67674dd809fd5d57390e1360436351ae7ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc60d67674dd809fd5d57390e1360436351ae7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc60d67674dd809fd5d57390e1360436351ae7ae"}], "stats": {"total": 109, "additions": 56, "deletions": 53}, "files": [{"sha": "a38aa6c55e036bc326cf8cd20dc370d391d8e19c", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0edbcb371cce5f82136f20ad45155c003d4982/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0edbcb371cce5f82136f20ad45155c003d4982/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=ab0edbcb371cce5f82136f20ad45155c003d4982", "patch": "@@ -794,6 +794,41 @@ d_mark_read (tree exp)\n   return exp;\n }\n \n+/* Build a call to memcmp(), compares the first NUM bytes of PTR1 with PTR2.  */\n+\n+tree\n+build_memcmp_call (tree ptr1, tree ptr2, tree num)\n+{\n+  return build_call_expr (builtin_decl_explicit (BUILT_IN_MEMCMP), 3,\n+\t\t\t  ptr1, ptr2, num);\n+}\n+\n+/* Build a call to memcpy(), copies the first NUM bytes of SRC into DST.  */\n+\n+tree\n+build_memcpy_call (tree dst, tree src, tree num)\n+{\n+  return build_call_expr (builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n+\t\t\t  dst, src, num);\n+}\n+\n+/* Build a call to memset(), fills the first NUM bytes of PTR with zeros.\n+   If NUM is NULL, then we expect PTR to be object that requires filling.  */\n+\n+tree\n+build_memset_call (tree ptr, tree num)\n+{\n+  if (num == NULL_TREE)\n+    {\n+      gcc_assert (TREE_CODE (ptr) != ADDR_EXPR);\n+      num = TYPE_SIZE_UNIT (TREE_TYPE (ptr));\n+      ptr = build_address (ptr);\n+    }\n+\n+  return build_call_expr (builtin_decl_explicit (BUILT_IN_MEMSET), 3,\n+\t\t\t  ptr, integer_zero_node, num);\n+}\n+\n /* Return TRUE if the struct SD is suitable for comparison using memcmp.\n    This is because we don't guarantee that padding is zero-initialized for\n    a stack variable, so we can't use memcmp to compare struct values.  */\n@@ -846,11 +881,9 @@ identity_compare_p (StructDeclaration *sd)\n tree\n build_float_identity (tree_code code, tree t1, tree t2)\n {\n-  tree tmemcmp = builtin_decl_explicit (BUILT_IN_MEMCMP);\n   tree size = size_int (TYPE_PRECISION (TREE_TYPE (t1)) / BITS_PER_UNIT);\n-\n-  tree result = build_call_expr (tmemcmp, 3, build_address (t1),\n-\t\t\t\t build_address (t2), size);\n+  tree result = build_memcmp_call (build_address (t1),\n+\t\t\t\t   build_address (t2), size);\n   return build_boolop (code, result, integer_zero_node);\n }\n \n@@ -879,10 +912,8 @@ lower_struct_comparison (tree_code code, StructDeclaration *sd,\n   /* Let back-end take care of union comparisons.  */\n   if (sd->isUnionDeclaration ())\n     {\n-      tmemcmp = build_call_expr (builtin_decl_explicit (BUILT_IN_MEMCMP), 3,\n-\t\t\t\t build_address (t1), build_address (t2),\n-\t\t\t\t size_int (sd->structsize));\n-\n+      tmemcmp = build_memcmp_call (build_address (t1), build_address (t2),\n+\t\t\t\t   size_int (sd->structsize));\n       return build_boolop (code, tmemcmp, integer_zero_node);\n     }\n \n@@ -943,11 +974,9 @@ lower_struct_comparison (tree_code code, StructDeclaration *sd,\n \t  else\n \t    {\n \t      /* Simple memcmp between types.  */\n-\t      tcmp = build_call_expr (builtin_decl_explicit (BUILT_IN_MEMCMP),\n-\t\t\t\t      3, build_address (t1ref),\n-\t\t\t\t      build_address (t2ref),\n-\t\t\t\t      TYPE_SIZE_UNIT (stype));\n-\n+\t      tcmp = build_memcmp_call (build_address (t1ref),\n+\t\t\t\t\tbuild_address (t2ref),\n+\t\t\t\t\tTYPE_SIZE_UNIT (stype));\n \t      tcmp = build_boolop (code, tcmp, integer_zero_node);\n \t    }\n \t}\n@@ -995,11 +1024,8 @@ build_struct_comparison (tree_code code, StructDeclaration *sd,\n   else\n     {\n       /* Do bit compare of structs.  */\n-      tree size = size_int (sd->structsize);\n-      tree tmemcmp = build_call_expr (builtin_decl_explicit (BUILT_IN_MEMCMP),\n-\t\t\t\t      3, build_address (t1),\n-\t\t\t\t      build_address (t2), size);\n-\n+      tree tmemcmp = build_memcmp_call (build_address (t1), build_address (t2),\n+\t\t\t\t\tsize_int (sd->structsize));\n       result = build_boolop (code, tmemcmp, integer_zero_node);\n     }\n "}, {"sha": "48c8ef09dd183c8fca427aa2ac9c77edd001bbb7", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0edbcb371cce5f82136f20ad45155c003d4982/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0edbcb371cce5f82136f20ad45155c003d4982/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=ab0edbcb371cce5f82136f20ad45155c003d4982", "patch": "@@ -530,6 +530,9 @@ extern tree build_address (tree);\n extern tree d_mark_addressable (tree);\n extern tree d_mark_used (tree);\n extern tree d_mark_read (tree);\n+extern tree build_memcmp_call (tree, tree, tree);\n+extern tree build_memcpy_call (tree, tree, tree);\n+extern tree build_memset_call (tree, tree = NULL_TREE);\n extern bool identity_compare_p (StructDeclaration *);\n extern tree build_float_identity (tree_code, tree, tree);\n extern tree build_struct_comparison (tree_code, StructDeclaration *,"}, {"sha": "58d4943ef2b74e9df479354a298ff3a2d948f5f9", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0edbcb371cce5f82136f20ad45155c003d4982/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0edbcb371cce5f82136f20ad45155c003d4982/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=ab0edbcb371cce5f82136f20ad45155c003d4982", "patch": "@@ -378,9 +378,8 @@ class ExprVisitor : public Visitor\n \t\t|| identity_compare_p (t1elem->isTypeStruct ()->sym))\n \t      {\n \t\ttree size = size_mult_expr (t1len, size_int (t1elem->size ()));\n-\t\ttree tmemcmp = builtin_decl_explicit (BUILT_IN_MEMCMP);\n \n-\t\tresult = build_call_expr (tmemcmp, 3, t1ptr, t2ptr, size);\n+\t\tresult = build_memcmp_call (t1ptr, t2ptr, size);\n \t\tresult = build_boolop (code, result, integer_zero_node);\n \t      }\n \t    else\n@@ -948,12 +947,9 @@ class ExprVisitor : public Visitor\n \n \t    if (integer_zerop (t2))\n \t      {\n-\t\ttree tmemset = builtin_decl_explicit (BUILT_IN_MEMSET);\n \t\ttree size = size_mult_expr (d_array_length (t1),\n \t\t\t\t\t    size_int (etype->size ()));\n-\n-\t\tresult = build_call_expr (tmemset, 3, d_array_ptr (t1),\n-\t\t\t\t\t  integer_zero_node, size);\n+\t\tresult = build_memset_call (d_array_ptr (t1), size);\n \t      }\n \t    else\n \t      result = build_array_set (d_array_ptr (t1),\n@@ -970,12 +966,10 @@ class ExprVisitor : public Visitor\n \t      {\n \t\ttree t1 = d_save_expr (d_array_convert (e->e1));\n \t\ttree t2 = d_array_convert (e->e2);\n-\t\ttree tmemcpy = builtin_decl_explicit (BUILT_IN_MEMCPY);\n \t\ttree size = size_mult_expr (d_array_length (t1),\n \t\t\t\t\t    size_int (etype->size ()));\n-\n-\t\ttree result = build_call_expr (tmemcpy, 3, d_array_ptr (t1),\n-\t\t\t\t\t       d_array_ptr (t2), size);\n+\t\ttree result = build_memcpy_call (d_array_ptr (t1),\n+\t\t\t\t\t\t d_array_ptr (t2), size);\n \t\tthis->result_ = compound_expr (result, t1);\n \t      }\n \t    else if ((postblit || destructor) && e->op != TOKblit)\n@@ -1042,9 +1036,7 @@ class ExprVisitor : public Visitor\n \t  {\n \t    /* Use memset to fill struct.  */\n \t    gcc_assert (e->op == TOKblit);\n-\t    tree tmemset = builtin_decl_explicit (BUILT_IN_MEMSET);\n-\t    tree result = build_call_expr (tmemset, 3, build_address (t1),\n-\t\t\t\t\t   t2, size_int (sd->structsize));\n+\t    tree result = build_memset_call (t1);\n \n \t    /* Maybe set-up hidden pointer to outer scope context.  */\n \t    if (sd->isNested ())\n@@ -1065,12 +1057,7 @@ class ExprVisitor : public Visitor\n \n \t    /* Fill any alignment holes in the struct using memset.  */\n \t    if (e->op == TOKconstruct && !identity_compare_p (sd))\n-\t      {\n-\t\ttree tmemset = builtin_decl_explicit (BUILT_IN_MEMSET);\n-\t\tinit = build_call_expr (tmemset, 3, build_address (t1),\n-\t\t\t\t\tinteger_zero_node,\n-\t\t\t\t\tsize_int (sd->structsize));\n-\t      }\n+\t      init = build_memset_call (t1);\n \n \t    tree result = build_assign (modifycode, t1, t2);\n \t    this->result_ = compound_expr (init, result);\n@@ -1087,15 +1074,7 @@ class ExprVisitor : public Visitor\n \t  {\n \t    /* Use memset to fill the array.  */\n \t    gcc_assert (e->op == TOKblit);\n-\n-\t    tree t1 = build_expr (e->e1);\n-\t    tree t2 = convert_for_assignment (build_expr (e->e2),\n-\t\t\t\t\t      e->e2->type, e->e1->type);\n-\t    tree size = size_int (e->e1->type->size ());\n-\n-\t    tree tmemset = builtin_decl_explicit (BUILT_IN_MEMSET);\n-\t    this->result_ = build_call_expr (tmemset, 3, build_address (t1),\n-\t\t\t\t\t     t2, size);\n+\t    this->result_ = build_memset_call (build_expr (e->e1));\n \t    return;\n \t  }\n \n@@ -2753,12 +2732,10 @@ class ExprVisitor : public Visitor\n \tmem = d_save_expr (mem);\n \n \t/* Now copy the constructor into memory.  */\n-\ttree tmemcpy = builtin_decl_explicit (BUILT_IN_MEMCPY);\n \ttree size = size_mult_expr (size_int (e->elements->length),\n \t\t\t\t    size_int (tb->nextOf ()->size ()));\n \n-\ttree result = build_call_expr (tmemcpy, 3, mem,\n-\t\t\t\t       build_address (ctor), size);\n+\ttree result = build_memcpy_call (mem, build_address (ctor), size);\n \n \t/* Return the array pointed to by MEM.  */\n \tresult = compound_expr (result, mem);\n@@ -2935,10 +2912,7 @@ class ExprVisitor : public Visitor\n       {\n \t/* For unions, use memset to fill holes in the object.  */\n \ttree var = build_local_temp (TREE_TYPE (ctor));\n-\ttree tmemset = builtin_decl_explicit (BUILT_IN_MEMSET);\n-\ttree init = build_call_expr (tmemset, 3, build_address (var),\n-\t\t\t\t     size_zero_node,\n-\t\t\t\t     size_int (e->sd->structsize));\n+\ttree init = build_memset_call (var);\n \n \tinit = compound_expr (init, saved_elems);\n \tinit = compound_expr (init, modify_expr (var, ctor));"}]}