{"sha": "3ccd3d704112889a79a0ccdcfc51bfcc55019827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjZDNkNzA0MTEyODg5YTc5YTBjY2RjZmM1MWJmY2M1NTAxOTgyNw==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2003-03-02T00:36:03Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-03-02T00:36:03Z"}, "message": "File.java (normalizePath): Remove trailing separator on Windows only if path is not of the form \"x:\\\".\n\n2003-03-01  Ranjit Mathew  <rmathew@hotmail.com>\n\n\t* java/io/File.java (normalizePath): Remove trailing separator\n\ton Windows only if path is not of the form \"x:\\\".\n\n\t* java/io/natFileWin32.cc (WIN32_EPOCH_MILLIS): New constant.\n\t(java::io::File::attr): Change formatting a bit and use\n\tWIN32_EPOCH_MILLIS instead of magic numbers.\n\t(java::io::File::isAbsolute): Path must have at least 3\n\tcharacters for a UNC network path.\n\t(java::io::File::init_native): Define.\n\t(java::io::File::performCreate): Likewise.\n\t(java::io::File::performSetReadOnly): Likewise.\n\t(java::io::File::performSetLastModified): Likewise.\n\t(java::io::File::performListRoots): Likewise.\n\nFrom-SVN: r63646", "tree": {"sha": "01d9125b79e1f1a6ddae6430cffd78841636a6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01d9125b79e1f1a6ddae6430cffd78841636a6e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ccd3d704112889a79a0ccdcfc51bfcc55019827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd3d704112889a79a0ccdcfc51bfcc55019827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccd3d704112889a79a0ccdcfc51bfcc55019827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd3d704112889a79a0ccdcfc51bfcc55019827/comments", "author": null, "committer": null, "parents": [{"sha": "d457094cc1695409b74aa40a7d095d39dfcf943e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d457094cc1695409b74aa40a7d095d39dfcf943e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d457094cc1695409b74aa40a7d095d39dfcf943e"}], "stats": {"total": 190, "additions": 170, "deletions": 20}, "files": [{"sha": "25ee6f47fbba59b7148a339ea2541841477f50ae", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccd3d704112889a79a0ccdcfc51bfcc55019827/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccd3d704112889a79a0ccdcfc51bfcc55019827/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3ccd3d704112889a79a0ccdcfc51bfcc55019827", "patch": "@@ -1,3 +1,19 @@\n+2003-03-01  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* java/io/File.java (normalizePath): Remove trailing separator\n+\ton Windows only if path is not of the form \"x:\\\".\n+\n+\t* java/io/natFileWin32.cc (WIN32_EPOCH_MILLIS): New constant.\n+\t(java::io::File::attr): Change formatting a bit and use\n+\tWIN32_EPOCH_MILLIS instead of magic numbers.\n+\t(java::io::File::isAbsolute): Path must have at least 3 \n+\tcharacters for a UNC network path.\n+\t(java::io::File::init_native): Define.\n+\t(java::io::File::performCreate): Likewise.\n+\t(java::io::File::performSetReadOnly): Likewise.\n+\t(java::io::File::performSetLastModified): Likewise.\n+\t(java::io::File::performListRoots): Likewise.\n+\n 2003-03-01  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/natObject.cc: Don't include assert.h."}, {"sha": "0f11bce669da8e2c17b30f1781a588c001ce0452", "filename": "libjava/java/io/File.java", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccd3d704112889a79a0ccdcfc51bfcc55019827/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccd3d704112889a79a0ccdcfc51bfcc55019827/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=3ccd3d704112889a79a0ccdcfc51bfcc55019827", "patch": "@@ -96,9 +96,13 @@ private String normalizePath(String p)\n \n     if (dupIndex == -1)\n       {\n-        // Ignore trailing separator.\n-        if (plen > 1 && p.charAt(plen - 1) == separatorChar)\n-\t  return p.substring(0, plen - 1);\n+        // Ignore trailing separator (though on Windows \"a:\\\", for\n+        // example, is a valid and minimal path).\n+        if (plen > 1 && p.charAt (plen - 1) == separatorChar)\n+\t  {\n+\t    if (! (separatorChar == '\\\\' && plen == 3 && p.charAt (1) == ':'))\n+\t      return p.substring (0, plen - 1);\n+\t  }\n \telse\n \t  return p;\n       }\n@@ -120,10 +124,16 @@ private String normalizePath(String p)\n \tdupIndex = p.indexOf(dupSeparator, last);\n       }\n     \n-    // Again, ignore possible trailing separator.\n+    // Again, ignore possible trailing separator (except special cases\n+    // like \"a:\\\" on Windows).\n     int end;\n-    if (plen > 1 && p.charAt(plen - 1) == separatorChar)\n-      end = plen - 1;\n+    if (plen > 1 && p.charAt (plen - 1) == separatorChar)\n+    {\n+      if (separatorChar == '\\\\' && plen == 3 && p.charAt (1) == ':')\n+        end = plen;\n+      else\n+        end = plen - 1;\n+    }\n     else\n       end = plen;\n     newpath.append(p.substring(last, end));"}, {"sha": "af12f5bb4e791232f7e5a455551c67ec54e2c2a0", "filename": "libjava/java/io/natFileWin32.cc", "status": "modified", "additions": 138, "deletions": 14, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccd3d704112889a79a0ccdcfc51bfcc55019827/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccd3d704112889a79a0ccdcfc51bfcc55019827/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileWin32.cc?ref=3ccd3d704112889a79a0ccdcfc51bfcc55019827", "patch": "@@ -26,6 +26,19 @@ details.  */\n #include <java/io/FileFilter.h>\n #include <java/lang/System.h>\n \n+// Java timestamps are milliseconds since the UNIX epoch (00:00:00 UTC on \n+// January 1, 1970) while Win32 file-times are 100-nanosecond intervals\n+// since the Win32 epoch (00:00:00 UTC on January 1, 1601). The following\n+// constant represents the number of milliseconds to be added to a\n+// Java timestamp to base it on the Win32 epoch.\n+// \n+// There were 369 years between 1601 and 1970, including 89 leap years\n+// (since 1700, 1800 and 1900 were not leap years):\n+//\n+// (89*366 + 280*365) days * 86400 seconds/day = 11644473600 seconds\n+//\n+#define WIN32_EPOCH_MILLIS 11644473600000LL\n+\n jboolean\n java::io::File::_access (jint query)\n {\n@@ -91,12 +104,16 @@ java::io::File::attr (jint query)\n   FindClose( sHandle);\n   \n   if (query == LENGTH)\n-    return ((long long)info.nFileSizeHigh) << 32 | (unsigned long long)info.nFileSizeLow;\n-  else {\n-    // FIXME? This is somewhat compiler dependant (the LL constant suffix)\n-    // The file time as return by windows is the number of 100-nanosecond intervals since January 1, 1601\n-    return (((((long long)info.ftLastWriteTime.dwHighDateTime) << 32) | ((unsigned long long)info.ftLastWriteTime.dwLowDateTime)) - 116444736000000000LL) / 10000LL;\n-  }\n+    return ((long long)info.nFileSizeHigh) << 32 \n+           | (unsigned long long)info.nFileSizeLow;\n+  else \n+    {\n+      // The file time as returned by Windows is in terms of the number\n+      // of 100-nanosecond intervals since 00:00:00 UTC, January 1, 1601.\n+      return (((((long long)info.ftLastWriteTime.dwHighDateTime) << 32) \n+               | ((unsigned long long)info.ftLastWriteTime.dwLowDateTime)) \n+              - WIN32_EPOCH_MILLIS*10000LL) / 10000LL;\n+    }\n }\n \n jstring\n@@ -120,7 +137,7 @@ jboolean\n java::io::File::isAbsolute (void)\n {\n   // See if the path represents a Windows UNC network path.\n-  if (path->length () > 1\n+  if (path->length () > 2\n       && (path->charAt (0) == '\\\\') && (path->charAt (1) == '\\\\'))\n     return true;\n \n@@ -138,8 +155,11 @@ java::io::File::isAbsolute (void)\n \t  && (path->charAt(2) == '/' || path->charAt(2) == '\\\\'));\n }\n \n-void java::io::File::init_native() { }\n-\n+void java::io::File::init_native () \n+{\n+  maxPathLen = MAX_PATH;\n+  caseSensitive = false;\n+}\n \n jobjectArray\n java::io::File::performList (java::io::FilenameFilter *filter, \n@@ -194,7 +214,6 @@ java::io::File::performList (java::io::FilenameFilter *filter,\n   return ret;\n }\n \n-\n jboolean\n java::io::File::performMkdir (void)\n {\n@@ -237,7 +256,112 @@ java::io::File::performDelete ()\n     return (DeleteFile (buf)) ? true : false;\n }\n \n-jboolean java::io::File::performCreate (void) { JvFail(\"unimplemented\\n\"); }\n-jboolean java::io::File::performSetReadOnly() { JvFail(\"unimplemented\"); }\n-jboolean java::io::File::performSetLastModified(jlong time) { JvFail(\"unimplemented\"); }\n-JArray<java::io::File*>* java::io::File::performListRoots() { JvFail(\"unimplemented\"); }\n+jboolean java::io::File::performCreate (void) \n+{\n+  jstring canon = getCanonicalPath ();\n+  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length (), buf);\n+  buf[total] = '\\0';\n+\n+  HANDLE h = CreateFile (buf, 0, 0, NULL, CREATE_NEW, \n+                         FILE_ATTRIBUTE_NORMAL, NULL);\n+  if (h != INVALID_HANDLE_VALUE)\n+    {\n+      CloseHandle (h);\n+      return true;\n+    }\n+  else\n+    {\n+      if (GetLastError () == ERROR_ALREADY_EXISTS)\n+        return false;\n+      else\n+        throw new IOException (JvNewStringLatin1 (\"CreateFile failed\"));\n+    }\n+}\n+\n+jboolean java::io::File::performSetReadOnly ()\n+{\n+  jstring canon = getCanonicalPath ();\n+  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length (), buf);\n+  buf[total] = '\\0';\n+\n+  DWORD attrs = GetFileAttributes (buf);\n+  if (attrs != INVALID_FILE_ATTRIBUTES)\n+    {\n+      if (SetFileAttributes (buf, attrs | FILE_ATTRIBUTE_READONLY) != 0)\n+        return true;\n+      else\n+        return false;\n+    }\n+  else\n+    return false;\n+}\n+\n+jboolean java::io::File::performSetLastModified (jlong time)\n+{\n+  jstring canon = getCanonicalPath ();\n+  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length (), buf);\n+  buf[total] = '\\0';\n+\n+  FILETIME modTime;\n+  long long mTime100ns = ((long long) time        /* Ha! */\n+                          + WIN32_EPOCH_MILLIS) * 10000LL;\n+  \n+  modTime.dwLowDateTime = (DWORD) mTime100ns;\n+  modTime.dwHighDateTime = (DWORD) (mTime100ns >> 32);\n+\n+  jboolean retVal = false;\n+  HANDLE h = CreateFile (buf, FILE_WRITE_ATTRIBUTES, \n+                         FILE_SHARE_READ | FILE_SHARE_WRITE, \n+                         NULL, OPEN_EXISTING, 0, NULL);\n+\n+  if (h != INVALID_HANDLE_VALUE)\n+    {\n+      if (SetFileTime (h, NULL, &modTime, &modTime) != 0)\n+        retVal = true;\n+\n+      CloseHandle (h);\n+    }\n+\n+  return retVal;\n+}\n+\n+JArray<java::io::File*>* java::io::File::performListRoots ()\n+{\n+  DWORD drivesBitmap = GetLogicalDrives ();\n+  DWORD mask;\n+\n+  // Possible drive letters are from ASCII 'A'-'Z'.\n+  int numDrives = 0;\n+  mask = 1;\n+  for (int i = 0; i < 26; i++)\n+    {\n+      if ((drivesBitmap & mask) != 0)\n+        numDrives++;\n+      mask <<= 1;\n+    }\n+\n+  JArray<java::io::File *> *roots\n+    = reinterpret_cast <JArray<java::io::File *>*> \n+        (JvNewObjectArray (numDrives, &java::io::File::class$, NULL));\n+\n+  ::java::io::File **rootsArray = elements (roots);\n+\n+  char aDriveRoot[] = {'A', ':', '\\\\', '\\0'};\n+  mask = 1;\n+  for (int i = 0, j = 0; i < 26; i++)\n+    {\n+      if ((drivesBitmap & mask) != 0)\n+        {\n+          rootsArray[j] \n+            = new ::java::io::File (JvNewStringLatin1 (aDriveRoot));\n+          j++;\n+        }\n+      mask <<= 1;\n+      aDriveRoot[0]++;\n+    }\n+\n+  return roots;\n+}"}]}