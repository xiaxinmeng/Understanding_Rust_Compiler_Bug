{"sha": "2c867f5a52a8fbe19640847244e0251754fd85b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4NjdmNWE1MmE4ZmJlMTk2NDA4NDcyNDRlMDI1MTc1NGZkODViMg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-09-05T08:03:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:03:48Z"}, "message": "sem_util.ads, [...] (Gather_Components): Omit interface tags from the list of required components.\n\n2005-09-01  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (Gather_Components): Omit interface tags\n\tfrom the list of required components.\n\t(Is_Controlling_Limited_Procedure): Determine whether an entity is a\n\tprimitive procedure of a limited interface with a controlling first\n\tparameter.\n\t(Is_Renamed_Entry): Determine whether an entry is a procedure renaming\n\tof an entry.\n\t(Safe_To_Capture_Value): A value (such as non_null) is not safe to\n\tcapture if it is generated in the second operand of a short-circuit\n\toperation.\n\tDo not capture values for variables with address clauses.\n\t(Is_Object_Reference): Treat a function call as an object reference only\n\tif its type is not Standard_Void_Type.\n\nFrom-SVN: r103888", "tree": {"sha": "2647249f9076f1c38e2b275cbb3e1817bf9c0d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2647249f9076f1c38e2b275cbb3e1817bf9c0d98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c867f5a52a8fbe19640847244e0251754fd85b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c867f5a52a8fbe19640847244e0251754fd85b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c867f5a52a8fbe19640847244e0251754fd85b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c867f5a52a8fbe19640847244e0251754fd85b2/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63e746db7a33e60716aa60fea4497d90402251fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e746db7a33e60716aa60fea4497d90402251fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e746db7a33e60716aa60fea4497d90402251fd"}], "stats": {"total": 173, "additions": 137, "deletions": 36}, "files": [{"sha": "f2835f674612334f5f45835dfbf5e75c109826ae", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 128, "deletions": 34, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c867f5a52a8fbe19640847244e0251754fd85b2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c867f5a52a8fbe19640847244e0251754fd85b2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2c867f5a52a8fbe19640847244e0251754fd85b2", "patch": "@@ -2206,16 +2206,21 @@ package body Sem_Util is\n \n       while Present (Comp_Item) loop\n \n-         --  Skip the tag of a tagged record, as well as all items\n-         --  that are not user components (anonymous types, rep clauses,\n-         --  Parent field, controller field).\n-\n-         if Nkind (Comp_Item) = N_Component_Declaration\n-           and then Chars (Defining_Identifier (Comp_Item)) /= Name_uTag\n-           and then Chars (Defining_Identifier (Comp_Item)) /= Name_uParent\n-           and then Chars (Defining_Identifier (Comp_Item)) /= Name_uController\n-         then\n-            Append_Elmt (Defining_Identifier (Comp_Item), Into);\n+         --  Skip the tag of a tagged record, the interface tags, as well\n+         --  as all items that are not user components (anonymous types,\n+         --  rep clauses, Parent field, controller field).\n+\n+         if Nkind (Comp_Item) = N_Component_Declaration then\n+            declare\n+               Comp : constant Entity_Id := Defining_Identifier (Comp_Item);\n+            begin\n+               if not Is_Tag (Comp)\n+                 and then Chars (Comp) /= Name_uParent\n+                 and then Chars (Comp) /= Name_uController\n+               then\n+                  Append_Elmt (Comp, Into);\n+               end if;\n+            end;\n          end if;\n \n          Next (Comp_Item);\n@@ -3438,6 +3443,41 @@ package body Sem_Util is\n       end if;\n    end Is_Atomic_Object;\n \n+   --------------------------------------\n+   -- Is_Controlling_Limited_Procedure --\n+   --------------------------------------\n+\n+   function Is_Controlling_Limited_Procedure\n+     (Proc_Nam : Entity_Id) return Boolean\n+   is\n+      Param_Typ : Entity_Id;\n+\n+   begin\n+      --  Proc_Nam was found to be a primitive operation of a limited interface\n+\n+      if Ekind (Proc_Nam) = E_Procedure then\n+         Param_Typ := Etype (Parameter_Type (First (Parameter_Specifications (\n+           Parent (Proc_Nam)))));\n+         return\n+           Is_Interface (Param_Typ)\n+             and then Is_Limited_Record (Param_Typ);\n+\n+      --  In this case where an Itype was created, the procedure call has been\n+      --  rewritten.\n+\n+      elsif Present (Associated_Node_For_Itype (Proc_Nam))\n+        and then Present (Original_Node (Associated_Node_For_Itype (Proc_Nam)))\n+      then\n+         Param_Typ := Etype (First (Parameter_Associations (\n+           Associated_Node_For_Itype (Proc_Nam))));\n+         return\n+           Is_Interface (Param_Typ)\n+             and then Is_Limited_Record (Param_Typ);\n+      end if;\n+\n+      return False;\n+   end Is_Controlling_Limited_Procedure;\n+\n    ----------------------------------------------\n    -- Is_Dependent_Component_Of_Mutable_Object --\n    ----------------------------------------------\n@@ -4078,10 +4118,11 @@ package body Sem_Util is\n                  Is_Object_Reference (Prefix (N))\n                    or else Is_Access_Type (Etype (Prefix (N)));\n \n-            --  In Ada95, a function call is a constant object\n+            --  In Ada95, a function call is a constant object; a procedure\n+            --  call is not.\n \n             when N_Function_Call =>\n-               return True;\n+               return Etype (N) /= Standard_Void_Type;\n \n             --  A reference to the stream attribute Input is a function call\n \n@@ -4538,6 +4579,58 @@ package body Sem_Util is\n       return False;\n    end Is_Remote_Call;\n \n+   ----------------------\n+   -- Is_Renamed_Entry --\n+   ----------------------\n+\n+   function Is_Renamed_Entry (Proc_Nam : Entity_Id) return Boolean is\n+      Orig_Node : Node_Id := Empty;\n+      Subp_Decl : Node_Id := Parent (Parent (Proc_Nam));\n+\n+      function Is_Entry (Nam : Node_Id) return Boolean;\n+      --  Determine whether Nam is an entry. Traverse selectors\n+      --  if there are nested selected components.\n+\n+      --------------\n+      -- Is_Entry --\n+      --------------\n+\n+      function Is_Entry (Nam : Node_Id) return Boolean is\n+      begin\n+         if Nkind (Nam) = N_Selected_Component then\n+            return Is_Entry (Selector_Name (Nam));\n+         end if;\n+\n+         return Ekind (Entity (Nam)) = E_Entry;\n+      end Is_Entry;\n+\n+   --  Start of processing for Is_Renamed_Entry\n+\n+   begin\n+      if Present (Alias (Proc_Nam)) then\n+         Subp_Decl := Parent (Parent (Alias (Proc_Nam)));\n+      end if;\n+\n+      --  Look for a rewritten subprogram renaming declaration\n+\n+      if Nkind (Subp_Decl) = N_Subprogram_Declaration\n+        and then Present (Original_Node (Subp_Decl))\n+      then\n+         Orig_Node := Original_Node (Subp_Decl);\n+      end if;\n+\n+      --  The rewritten subprogram is actually an entry\n+\n+      if Present (Orig_Node)\n+        and then Nkind (Orig_Node) = N_Subprogram_Renaming_Declaration\n+        and then Is_Entry (Name (Orig_Node))\n+      then\n+         return True;\n+      end if;\n+\n+      return False;\n+   end Is_Renamed_Entry;\n+\n    ----------------------\n    -- Is_Selector_Name --\n    ----------------------\n@@ -6096,8 +6189,14 @@ package body Sem_Util is\n \n       --  Skip volatile and aliased variables, since funny things might\n       --  be going on in these cases which we cannot necessarily track.\n+      --  Also skip any variable for which an address clause is given.\n+\n+      --  Should we have a flag Has_Address_Clause ???\n \n-      if Treat_As_Volatile (Ent) or else Is_Aliased (Ent) then\n+      if Treat_As_Volatile (Ent)\n+        or else Is_Aliased (Ent)\n+        or else Present (Address_Clause (Ent))\n+      then\n          return False;\n       end if;\n \n@@ -6130,28 +6229,27 @@ package body Sem_Util is\n       --  or an exception handler).\n \n       declare\n-         P : Node_Id;\n+         Desc : Node_Id;\n+         P    : Node_Id;\n \n       begin\n-         P := Parent (N);\n+         Desc := N;\n+         P    := Parent (N);\n          while Present (P) loop\n             if Nkind (P) = N_If_Statement\n-                 or else\n-               Nkind (P) = N_Case_Statement\n-                 or else\n-               Nkind (P) = N_Exception_Handler\n-                 or else\n-               Nkind (P) = N_Selective_Accept\n-                 or else\n-               Nkind (P) = N_Conditional_Entry_Call\n-                 or else\n-               Nkind (P) = N_Timed_Entry_Call\n-                 or else\n-               Nkind (P) = N_Asynchronous_Select\n+              or else  Nkind (P) = N_Case_Statement\n+              or else (Nkind (P) = N_And_Then and then Desc = Right_Opnd (P))\n+              or else (Nkind (P) = N_Or_Else and then Desc = Right_Opnd (P))\n+              or else  Nkind (P) = N_Exception_Handler\n+              or else  Nkind (P) = N_Selective_Accept\n+              or else  Nkind (P) = N_Conditional_Entry_Call\n+              or else  Nkind (P) = N_Timed_Entry_Call\n+              or else  Nkind (P) = N_Asynchronous_Select\n             then\n                return False;\n             else\n-               P := Parent (P);\n+               Desc := P;\n+               P    := Parent (P);\n             end if;\n          end loop;\n       end;\n@@ -6298,12 +6396,11 @@ package body Sem_Util is\n             return;\n          end if;\n \n-         Val_Actual := Val;\n-\n          --  A special situation arises for derived operations, where we want\n          --  to do the check against the parent (since the Sloc of the derived\n          --  operation points to the derived type declaration itself).\n \n+         Val_Actual := Val;\n          while not Comes_From_Source (Val_Actual)\n            and then Nkind (Val_Actual) in N_Entity\n            and then (Ekind (Val_Actual) = E_Enumeration_Literal\n@@ -6489,7 +6586,7 @@ package body Sem_Util is\n    -----------------------\n \n    procedure Transfer_Entities (From : Entity_Id; To : Entity_Id) is\n-      Ent      : Entity_Id := First_Entity (From);\n+      Ent : Entity_Id := First_Entity (From);\n \n    begin\n       if No (Ent) then\n@@ -6522,7 +6619,6 @@ package body Sem_Util is\n \n                begin\n                   Comp := First_Entity (Ent);\n-\n                   while Present (Comp) loop\n                      Set_Is_Public (Comp);\n                      Next_Entity (Comp);\n@@ -6635,9 +6731,7 @@ package body Sem_Util is\n \n       else\n          Get_First_Interp (Opnd, Index, It);\n-\n          while Present (It.Typ) loop\n-\n             if It.Typ = Universal_Integer\n               or else It.Typ = Universal_Real\n             then"}, {"sha": "27f2abd9708626e2a83eb25bb39b56eec631ab58", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c867f5a52a8fbe19640847244e0251754fd85b2/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c867f5a52a8fbe19640847244e0251754fd85b2/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2c867f5a52a8fbe19640847244e0251754fd85b2", "patch": "@@ -456,6 +456,11 @@ package Sem_Util is\n    --  Determines if the given node denotes an atomic object in the sense\n    --  of the legality checks described in RM C.6(12).\n \n+   function Is_Controlling_Limited_Procedure\n+     (Proc_Nam : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-345): Determine whether Proc_Nam is a primitive procedure\n+   --  of a limited interface with a controlling first parameter.\n+\n    function Is_Dependent_Component_Of_Mutable_Object\n      (Object : Node_Id) return Boolean;\n    --  Returns True if Object is the name of a subcomponent that\n@@ -560,6 +565,9 @@ package Sem_Util is\n    function Is_Remote_Call (N : Node_Id) return Boolean;\n    --  Return True if N denotes a potentially remote call\n \n+   function Is_Renamed_Entry (Proc_Nam : Entity_Id) return Boolean;\n+   --  Return True if Proc_Nam is a procedure renaming of an entry\n+\n    function Is_Selector_Name (N : Node_Id) return Boolean;\n    --  Given an N_Identifier node N, determines if it is a Selector_Name.\n    --  As described in Sinfo, Selector_Names are special because they\n@@ -735,8 +743,7 @@ package Sem_Util is\n \n    function Safe_To_Capture_Value\n      (N    : Node_Id;\n-      Ent  : Entity_Id)\n-      return Boolean;\n+      Ent  : Entity_Id) return Boolean;\n    --  The caller is interested in capturing a value (either the current\n    --  value, or an indication that the value is non-null) for the given\n    --  entity Ent. This value can only be captured if sequential execution"}]}