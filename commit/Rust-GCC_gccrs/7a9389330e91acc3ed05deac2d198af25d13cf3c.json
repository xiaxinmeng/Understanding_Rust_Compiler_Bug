{"sha": "7a9389330e91acc3ed05deac2d198af25d13cf3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E5Mzg5MzMwZTkxYWNjM2VkMDVkZWFjMmQxOThhZjI1ZDEzY2YzYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-03T04:34:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-03T04:34:57Z"}, "message": "Add Go frontend, libgo library, and Go testsuite.\n\ngcc/:\n\t* gcc.c (default_compilers): Add entry for \".go\".\n\t* common.opt: Add -static-libgo as a driver option.\n\t* doc/install.texi (Configuration): Mention libgo as an option for\n\t--enable-shared.  Mention go as an option for --enable-languages.\n\t* doc/invoke.texi (Overall Options): Mention .go as a file name\n\tsuffix.  Mention go as a -x option.\n\t* doc/frontends.texi (G++ and GCC): Mention Go as a supported\n\tlanguage.\n\t* doc/sourcebuild.texi (Top Level): Mention libgo.\n\t* doc/standards.texi (Standards): Add section on Go language.\n\tMove references for other languages into their own section.\n\t* doc/contrib.texi (Contributors): Mention that I contributed the\n\tGo frontend.\ngcc/testsuite/:\n\t* lib/go.exp: New file.\n\t* lib/go-dg.exp: New file.\n\t* lib/go-torture.exp: New file.\n\t* lib/target-supports.exp (check_compile): Match // Go.\n\nFrom-SVN: r167407", "tree": {"sha": "38fe54a4f38ede5d949c915d66191f24a6fe5153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38fe54a4f38ede5d949c915d66191f24a6fe5153"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a9389330e91acc3ed05deac2d198af25d13cf3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a9389330e91acc3ed05deac2d198af25d13cf3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a9389330e91acc3ed05deac2d198af25d13cf3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a9389330e91acc3ed05deac2d198af25d13cf3c/comments", "author": null, "committer": null, "parents": [{"sha": "1aa6700378e5188a853c018256113ce6e1fb5c05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa6700378e5188a853c018256113ce6e1fb5c05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa6700378e5188a853c018256113ce6e1fb5c05"}], "stats": {"total": 351577, "additions": 351565, "deletions": 12}, "files": [{"sha": "0c23273457cadee82c3de7ccccc4a0428e1da414", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -1,3 +1,19 @@\n+2010-12-02  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.c (default_compilers): Add entry for \".go\".\n+\t* common.opt: Add -static-libgo as a driver option.\n+\t* doc/install.texi (Configuration): Mention libgo as an option for\n+\t--enable-shared.  Mention go as an option for --enable-languages.\n+\t* doc/invoke.texi (Overall Options): Mention .go as a file name\n+\tsuffix.  Mention go as a -x option.\n+\t* doc/frontends.texi (G++ and GCC): Mention Go as a supported\n+\tlanguage.\n+\t* doc/sourcebuild.texi (Top Level): Mention libgo.\n+\t* doc/standards.texi (Standards): Add section on Go language.\n+\tMove references for other languages into their own section.\n+\t* doc/contrib.texi (Contributors): Mention that I contributed the\n+\tGo frontend.\n+\n 2010-12-03  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n \n \t* tree.h (struct call_expr_arg_iterator_d): Remove GTY tag."}, {"sha": "25e516eb3fb66d02490891351a163fbfa8e0e5b9", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -2272,6 +2272,10 @@ Driver\n static-libstdc++\n Driver\n \n+static-libgo\n+Driver\n+; Documented for Go, but always accepted by driver.\n+\n symbolic\n Driver\n "}, {"sha": "e52dcf9be74461e4624c39a201c59d4d1ecb0f0d", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -900,8 +900,8 @@ Jeff Sturm for Java porting help, bug fixes, and encouragement.\n Shigeya Suzuki for this fixes for the bsdi platforms.\n \n @item\n-Ian Lance Taylor for his mips16 work, general configury hacking,\n-fixincludes, etc.\n+Ian Lance Taylor for the Go frontend, the initial mips16 and mips64\n+support, general configury hacking, fixincludes, etc.\n \n @item\n Holger Teutsch provided the support for the Clipper CPU@."}, {"sha": "625e26d1b69630c19a896b55119472de2b6f9952", "filename": "gcc/doc/frontends.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Ffrontends.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Ffrontends.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ffrontends.texi?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -11,13 +11,14 @@\n @cindex GNU C Compiler\n @cindex Ada\n @cindex Fortran\n+@cindex Go\n @cindex Java\n @cindex Objective-C\n @cindex Objective-C++\n GCC stands for ``GNU Compiler Collection''.  GCC is an integrated\n distribution of compilers for several major programming languages.  These\n languages currently include C, C++, Objective-C, Objective-C++, Java,\n-Fortran, and Ada.\n+Fortran, Ada, and Go.\n \n The abbreviation @dfn{GCC} has multiple meanings in common use.  The\n current official meaning is ``GNU Compiler Collection'', which refers"}, {"sha": "fbb2d4c04cf0e437c0639aa557dfc9cac6ee1bb1", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -884,7 +884,7 @@ only for the listed packages.  For other packages, only static libraries\n will be built.  Package names currently recognized in the GCC tree are\n @samp{libgcc} (also known as @samp{gcc}), @samp{libstdc++} (not\n @samp{libstdc++-v3}), @samp{libffi}, @samp{zlib}, @samp{boehm-gc},\n-@samp{ada}, @samp{libada}, @samp{libjava} and @samp{libobjc}.\n+@samp{ada}, @samp{libada}, @samp{libjava}, @samp{libgo}, and @samp{libobjc}.\n Note @samp{libiberty} does not support shared libraries at all.\n \n Use @option{--disable-shared} to build only static libraries.  Note that\n@@ -1305,15 +1305,12 @@ their runtime libraries should be built.  For a list of valid values for\n grep language= */config-lang.in\n @end smallexample\n Currently, you can use any of the following:\n-@code{all}, @code{ada}, @code{c}, @code{c++}, @code{fortran}, @code{java},\n-@code{objc}, @code{obj-c++}.\n+@code{all}, @code{ada}, @code{c}, @code{c++}, @code{fortran},\n+@code{go}, @code{java}, @code{objc}, @code{obj-c++}.\n Building the Ada compiler has special requirements, see below.\n If you do not pass this flag, or specify the option @code{all}, then all\n default languages available in the @file{gcc} sub-tree will be configured.\n-Ada and Objective-C++ are not default languages; the rest are.\n-Re-defining @code{LANGUAGES} when calling @samp{make} @strong{does not}\n-work anymore, as those language sub-directories might not have been\n-configured!\n+Ada, Go and Objective-C++ are not default languages; the rest are.\n \n @item --enable-stage1-languages=@var{lang1},@var{lang2},@dots{}\n Specify that a particular subset of compilers and their runtime"}, {"sha": "7c8041591b791d24e22877f0dd85bee4e4850948", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -1070,6 +1070,9 @@ Free form Fortran source code which should not be preprocessed.\n Free form Fortran source code which must be preprocessed (with the\n traditional preprocessor).\n \n+@item @var{file}.go\n+Go source code.\n+\n @c FIXME: Descriptions of Java file types.\n @c @var{file}.java\n @c @var{file}.class\n@@ -1123,6 +1126,7 @@ objective-c++ objective-c++-header objective-c++-cpp-output\n assembler  assembler-with-cpp\n ada\n f77  f77-cpp-input f95  f95-cpp-input\n+go\n java\n @end smallexample\n "}, {"sha": "012e6804182bac840051353109203bc3ae9bc999", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -81,6 +81,10 @@ The GCC runtime library.\n @item libgfortran\n The Fortran runtime library.\n \n+@item libgo\n+The Go runtime library.  The bulk of this library is mirrored from the\n+@uref{http://code.google.com/@/p/@/go, master Go repository}.\n+\n @item libgomp\n The GNU OpenMP runtime library.\n "}, {"sha": "90ddd4769d69fc9c9daf8a303417fde5ef420275", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -271,6 +271,18 @@ The authoritative manual on Objective-C 2.0 is available from Apple:\n For more information concerning the history of Objective-C that is\n available online, see @uref{http://gcc.gnu.org/readings.html}\n \n+@section Go language\n+\n+The Go language continues to evolve as of this writing; see the\n+@uref{http://golang.org/@/doc/@/go_spec.html, current language\n+specifications}.  At present there are no specific versions of Go, and\n+there is no way to describe the language supported by GCC in terms of\n+a specific version.  In general GCC tracks the evolving specification\n+closely, and any given release will support the language as of the\n+date that the release was frozen.\n+\n+@section References for other languages\n+\n @xref{Top, GNAT Reference Manual, About This Guide, gnat_rm,\n GNAT Reference Manual}, for information on standard\n conformance and compatibility of the Ada compiler."}, {"sha": "a0343fa684b1e8eb452cdd7f7ceac73695ea4298", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -896,6 +896,7 @@ static const struct compiler default_compilers[] =\n   {\".p\", \"#Pascal\", 0, 0, 0}, {\".pas\", \"#Pascal\", 0, 0, 0},\n   {\".java\", \"#Java\", 0, 0, 0}, {\".class\", \"#Java\", 0, 0, 0},\n   {\".zip\", \"#Java\", 0, 0, 0}, {\".jar\", \"#Java\", 0, 0, 0},\n+  {\".go\", \"#Go\", 0, 1, 0},\n   /* Next come the entries for C.  */\n   {\".c\", \"@c\", 0, 0, 1},\n   {\"@c\","}, {"sha": "971490c48ddde0678a54d9b8cf5679e549f812a7", "filename": "gcc/go/Make-lang.in", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,267 @@\n+# Make-lang.in -- Top level -*- makefile -*- fragment for gcc Go frontend.\n+\n+# Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file provides the language dependent support in the main Makefile.\n+\n+# Installation name.\n+\n+GCCGO_INSTALL_NAME := $(shell echo gccgo|sed '$(program_transform_name)')\n+GCCGO_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccgo|sed '$(program_transform_name)')\n+\n+# The name for selecting go in LANGUAGES.\n+go: go1$(exeext)\n+\n+.PHONY: go\n+\n+gospec.o: $(srcdir)/go/gospec.c $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) \\\n+    $(CONFIG_H) opts.h\n+\t(SHLIB_LINK='$(SHLIB_LINK)'; \\\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(DRIVER_DEFINES) \\\n+\t\t$(INCLUDES) $(srcdir)/go/gospec.c)\n+\n+GCCGO_OBJS = $(GCC_OBJS) gospec.o intl.o prefix.o version.o\n+gccgo$(exeext): $(GCCGO_OBJS) $(EXTRA_GCC_OBJS) $(LIBDEPS)\n+\t$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t  $(GCCGO_OBJS) $(EXTRA_GCC_OBJS) $(LIBS)\n+\n+# Use strict warnings.\n+go-warn = $(STRICT_WARN)\n+\n+GO_OBJS = \\\n+\tgo/dataflow.o \\\n+\tgo/export.o \\\n+\tgo/expressions.o \\\n+\tgo/go-dump.o \\\n+\tgo/go-lang.o \\\n+\tgo/go.o \\\n+\tgo/gogo-tree.o \\\n+\tgo/gogo.o \\\n+\tgo/import.o \\\n+\tgo/import-archive.o \\\n+\tgo/lex.o \\\n+\tgo/parse.o \\\n+\tgo/statements.o \\\n+\tgo/types.o \\\n+\tgo/unsafe.o\n+\n+go1$(exeext): $(GO_OBJS) attribs.o $(BACKEND) $(LIBDEPS)\n+\t$(CXX) $(ALL_CXXFLAGS) $(LDFLAGS) -o $@ \\\n+\t      $(GO_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n+\n+# Documentation.\n+\n+GO_TEXI_FILES = \\\n+\tgo/gccgo.texi \\\n+\t$(gcc_docdir)/include/fdl.texi \\\n+\t$(gcc_docdir)/include/gpl_v3.texi \\\n+\t$(gcc_docdir)/include/gcc-common.texi \\\n+\tgcc-vers.texi\n+\n+doc/gccgo.info: $(GO_TEXI_FILES)\n+\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n+\t  rm -f doc/gccgo.info*; \\\n+\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \\\n+\t\t-I $(gcc_docdir)/include -o $@ $<; \\\n+\telse true; fi\n+\n+doc/gccgo.dvi: $(GO_TEXI_FILES)\n+\t$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+doc/gccgo.pdf: $(GO_TEXI_FILES)\n+\t$(TEXI2PDF) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+$(build_htmldir)/go/index.html: $(GO_TEXI_FILES)\n+\t$(mkinstalldirs) $(@D)\n+\trm -f $(@D)/*\n+\t$(TEXI2HTML) -I $(gcc_docdir) -I $(gcc_docdir)/include \\\n+\t\t-I $(srcdir)/go -o $(@D) $<\n+\n+.INTERMEDIATE: gccgo.pod\n+\n+gccgo.pod: go/gccgo.texi\n+\t-$(TEXI2POD) -D gccgo < $< > $@\n+\n+# Build hooks.\n+\n+go.all.cross: gccgo$(exeext)\n+go.start.encap: gccgo$(exeext)\n+go.rest.encap:\n+go.info: doc/gccgo.info\n+go.dvi: doc/gccgo.dvi\n+go.pdf: doc/gccgo.pdf\n+go.html: $(build_htmldir)/go/index.html\n+go.srcinfo: doc/gccgo.info\n+\t-cp -p $^ $(srcdir)/doc\n+go.srcextra:\n+go.tags: force\n+\tcd $(srcdir)/go; \\\n+\tetags -o TAGS.sub *.c *.h gofrontend/*.h gofrontend/*.cc; \\\n+\tetags --include TAGS.sub --include ../TAGS.sub\n+go.man: doc/gccgo.1\n+go.srcman: doc/gccgo.1\n+\t-cp -p $^ $(srcdir)/doc\n+\n+check-go:\n+lang_checks += check-go\n+\n+# Install hooks.\n+\n+go.install-common: installdirs\n+\t-rm -f $(DESTDIR)$(bindir)/$(GCCGO_INSTALL_NAME)$(exeext)\n+\t-rm -f $(DESTDIR)$(bindir)/$(GCCGO_TARGET_INSTALL_NAME)$(exeext)\n+\t$(INSTALL_PROGRAM) gccgo$(exeext) $(DESTDIR)$(bindir)/$(GCCGO_INSTALL_NAME)$(exeext)\n+\tif test -f $(DESTDIR)$(bindir)$(GCCGO_TARGET_INSTALL_NAME)$(exeext); then \\\n+\t  :; \\\n+\telse \\\n+\t  cd $(DESTDIR)$(bindir) && \\\n+\t   $(LN) $(GCCGO_INSTALL_NAME)$(exeext) $(GCCGO_TARGET_INSTALL_NAME)$(exeext); \\\n+\tfi\n+\n+go.install-plugin:\n+\n+go.install-info: $(DESTDIR)$(infodir)/gccgo.info\n+\n+go.install-pdf: doc/gccgo.pdf\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n+\t@for p in doc/gccgo.pdf; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(pdf__strip_dir) \\\n+\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n+\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n+\tdone\n+\n+go.install-html: $(build_htmldir)/go\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n+\t@for p in $(build_htmldir)/go; do \\\n+\t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(html__strip_dir) \\\n+\t  if test -d \"$$d$$p\"; then \\\n+\t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  else \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  fi; \\\n+\tdone\n+\n+go.install-man: $(DESTDIR)$(man1dir)/$(GCCGO_INSTALL_NAME)$(man1ext)\n+\n+$(DESTDIR)$(man1dir)/$(GCCGO_INSTALL_NAME)$(man1ext): doc/gccgo.1 installdirs\n+\t-rm -f $@\n+\t-$(INSTALL_DATA) $< $@\n+\t-chmod a-x $@\n+\n+go.uninstall:\n+\trm -rf $(DESTDIR)$(bindir)/$(GCCGO_INSTALL_NAME)$(exeext)\n+\trm -rf $(DESTDIR)$(man1dir)/$(GCCGO_INSTALL_NAME)$(man1ext)\n+\trm -rf $(DESTDIR)$(bindir)/$(GCCGO_TARGET_INSTALL_NAME)$(exeext)\n+\trm -rf $(DESTDIR)$(infodir)/gccgo.info*\n+\n+# Clean hooks.\n+\n+go.mostlyclean:\n+\t-rm -f go/*$(objext)\n+\t-rm -f go/*$(coverageexts)\n+go.clean:\n+go.distclean:\n+go.maintainer-clean:\n+\t-rm -f $(docobjdir)/gccgo.1\n+\n+# Stage hooks.\n+\n+go.stage1: stage1-start\n+\t-mv go/*$(objext) stage1/go\n+go.stage2: stage2-start\n+\t-mv go/*$(objext) stage2/go\n+go.stage3: stage3-start\n+\t-mv go/*$(objext) stage3/go\n+go.stage4: stage4-start\n+\t-mv go/*$(objext) stage4/go\n+go.stageprofile: stageprofile-start\n+\t-mv go/*$(objext) stageprofile/go\n+go.stagefeedback: stagefeedback-start\n+\t-mv go/*$(objext) stagefeedback/go\n+\n+GO_SYSTEM_H = go/go-system.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+\t$(DIAGNOSTIC_CORE_H) $(INPUT_H)\n+\n+GO_C_H = go/go-c.h $(MACHMODE_H)\n+GO_LEX_H = go/gofrontend/lex.h go/gofrontend/operator.h\n+GO_PARSE_H = go/gofrontend/parse.h\n+GO_GOGO_H = go/gofrontend/gogo.h\n+GO_TYPES_H = go/gofrontend/types.h\n+GO_STATEMENTS_H = go/gofrontend/statements.h go/gofrontend/operator.h\n+GO_EXPRESSIONS_H = go/gofrontend/expressions.h go/gofrontend/operator.h\n+GO_IMPORT_H = go/gofrontend/import.h go/gofrontend/export.h\n+\n+go/go-lang.o: go/go-lang.c $(GO_SYSTEM_H) coretypes.h opts.h $(TREE_H) \\\n+\t$(GIMPLE_H) $(GGC_H) $(TOPLEV_H) debug.h options.h $(FLAGS_H) \\\n+\tconvert.h langhooks.h $(LANGHOOKS_DEF_H) $(EXCEPT_H) $(TARGET_H) \\\n+\t$(DIAGNOSTIC_H) $(GO_C_H) gt-go-go-lang.h gtype-go.h\n+\n+GOINCLUDES = -I $(srcdir)/go -I $(srcdir)/go/gofrontend\n+\n+go/%.o: go/gofrontend/%.cc\n+\t$(CXX) -c $(GOINCLUDES) $(ALL_CPPFLAGS) $(ALL_CXXFLAGS) $< $(OUTPUT_OPTION)\n+\n+go/dataflow.o: go/gofrontend/dataflow.cc $(GO_SYSTEM_H) $(GO_GOGO_H) \\\n+\t$(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) go/gofrontend/dataflow.h\n+go/export.o: go/gofrontend/export.cc $(GO_SYSTEM_H) \\\n+\t$(srcdir)/../include/sha1.h $(MACHMODE_H) output.h $(TARGET_H) \\\n+\t$(GO_GOGO_H) $(GO_TYPES_H) $(GO_STATEMENTS_H) go/gofrontend/export.h\n+go/expressions.o: go/gofrontend/expressions.cc $(GO_SYSTEM_H) $(TOPLEV_H) \\\n+\tintl.h $(TREE_H) $(GIMPLE_H) tree-iterator.h convert.h $(REAL_H) \\\n+\trealmpfr.h $(TM_H) $(TM_P_H) $(GO_C_H) $(GO_GOGO_H) $(GO_TYPES_H) \\\n+\tgo/gofrontend/export.h $(GO_IMPORT_H) $(GO_STATEMENTS_H) $(GO_LEX_H) \\\n+\t$(GO_EXPRESSIONS_H)\n+go/go.o: go/gofrontend/go.cc $(GO_SYSTEM_H) $(GO_C_H) $(GO_LEX_H) \\\n+\t$(GO_PARSE_H) $(GO_GOGO_H)\n+go/go-dump.o: go/gofrontend/go-dump.cc $(GO_SYSTEM_H) $(GO_C_H) \\\n+\tgo/gofrontend/go-dump.h\n+go/gogo-tree.o: go/gofrontend/gogo-tree.cc $(GO_SYSTEM_H) $(TM_H) $(TOPLEV_H) \\\n+\t$(TREE_H) $(GIMPLE_H) tree-iterator.h $(CGRAPH_H) langhooks.h \\\n+\tconvert.h output.h $(DIAGNOSTIC_H) $(RTL_H) $(GO_TYPES_H) \\\n+\t$(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) $(GO_GOGO_H)\n+go/gogo.o: go/gofrontend/gogo.cc $(GO_SYSTEM_H) $(GO_C_H) \\\n+\tgo/gofrontend/go-dump.h $(GO_LEX_H) $(GO_TYPES_H) $(GO_STATEMENTS_H) \\\n+\t$(GO_EXPRESSIONS_H) go/gofrontend/dataflow.h $(GO_IMPORT_H) \\\n+\tgo/gofrontend/export.h $(GO_GOGO_H)\n+go/import.o: go/gofrontend/import.cc $(GO_SYSTEM_H) \\\n+\t$(srcdir)/../include/filenames.h $(srcdir)/../include/simple-object.h \\\n+\t$(GO_C_H) $(GO_GOGO_H) $(GO_TYPES_H) go/gofrontend/export.h \\\n+\t$(GO_IMPORT_H)\n+go/import-archive.o: go/gofrontend/import-archive.cc $(GO_SYSTEM_H) \\\n+\t$(GO_IMPORT_H)\n+go/lex.o: go/gofrontend/lex.cc $(GO_LEX_H) $(GO_SYSTEM_H)\n+go/parse.o: go/gofrontend/parse.cc $(GO_SYSTEM_H) $(GO_LEX_H) $(GO_GOGO_H) \\\n+\t$(GO_TYPES_H) $(GO_STATEMENTS_H) $(GO_EXPRESSIONS_H) $(GO_PARSE_H)\n+go/statements.o: go/gofrontend/statements.cc $(GO_SYSTEM_H) intl.h $(TREE_H) \\\n+\t$(GIMPLE_H) convert.h tree-iterator.h $(TREE_FLOW_H) $(REAL_H) \\\n+\t$(GO_C_H) $(GO_TYPES_H) $(GO_EXPRESSIONS_H) $(GO_GOGO_H) \\\n+\t$(GO_STATEMENTS_H)\n+go/types.o: go/gofrontend/types.cc $(GO_SYSTEM_H) $(TOPLEV_H) intl.h $(TREE_H) \\\n+\t$(GIMPLE_H) $(REAL_H) convert.h $(GO_C_H) $(GO_GOGO_H) \\\n+\tgo/gofrontend/operator.h $(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) \\\n+\tgo/gofrontend/export.h $(GO_IMPORT_H) $(GO_TYPES_H)\n+go/unsafe.o: go/gofrontend/unsafe.cc $(GO_SYSTEM_H) $(GO_TYPES_H) $(GO_GOGO_H)"}, {"sha": "3c764f7a99d00f81f6a1f51f93b9883c97901b68", "filename": "gcc/go/README.gcc", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2FREADME.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2FREADME.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FREADME.gcc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,3 @@\n+The files in the gofrontend subdirectory are mirrored from the\n+gofrontend project hosted at http://code.google.com/p/gofrontend.\n+These files are the ones in the go subdirectory of that project."}, {"sha": "47b2605f400246c533d6829874650bbca6e38375", "filename": "gcc/go/config-lang.in", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fconfig-lang.in?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,37 @@\n+# config-lang.in -- Top level configure fragment for gcc Go frontend.\n+\n+# Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# compilers\t- value to add to $(COMPILERS)\n+\n+language=\"go\"\n+\n+compilers=\"go1\\$(exeext)\"\n+\n+target_libs=\"target-libgo target-libffi\"\n+\n+# The Go frontend is written in C++, so we need to build the C++\n+# compiler during stage 1.\n+lang_requires_boot_languages=c++\n+\n+gtfiles=\"\\$(srcdir)/go/go-lang.c\""}, {"sha": "0e41261eec14f65d4ce449107dd6d9a453520e6c", "filename": "gcc/go/gccgo.texi", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgccgo.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgccgo.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgccgo.texi?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,348 @@\n+\\input texinfo @c -*-texinfo-*-\n+@setfilename gccgo.info\n+@settitle The GNU Go Compiler\n+\n+@c Merge the standard indexes into a single one.\n+@syncodeindex fn cp\n+@syncodeindex vr cp\n+@syncodeindex ky cp\n+@syncodeindex pg cp\n+@syncodeindex tp cp\n+\n+@include gcc-common.texi\n+\n+@c Copyright years for this manual.\n+@set copyrights-go 2010\n+\n+@copying\n+@c man begin COPYRIGHT\n+Copyright @copyright{} @value{copyrights-go} Free Software Foundation, Inc.\n+\n+Permission is granted to copy, distribute and/or modify this document\n+under the terms of the GNU Free Documentation License, Version 1.3 or\n+any later version published by the Free Software Foundation; with no\n+Invariant Sections, the Front-Cover Texts being (a) (see below), and\n+with the Back-Cover Texts being (b) (see below).\n+A copy of the license is included in the\n+@c man end\n+section entitled ``GNU Free Documentation License''.\n+@ignore\n+@c man begin COPYRIGHT\n+man page gfdl(7).\n+@c man end\n+@end ignore\n+\n+@c man begin COPYRIGHT\n+\n+(a) The FSF's Front-Cover Text is:\n+\n+     A GNU Manual\n+\n+(b) The FSF's Back-Cover Text is:\n+\n+     You have freedom to copy and modify this GNU Manual, like GNU\n+     software.  Copies published by the Free Software Foundation raise\n+     funds for GNU development.\n+@c man end\n+@end copying\n+\n+@ifinfo\n+@format\n+@dircategory Software development\n+@direntry\n+* Gccgo: (gccgo).           A GCC-based compiler for the Go language\n+@end direntry\n+@end format\n+\n+@insertcopying\n+@end ifinfo\n+\n+@titlepage\n+@title The GNU Go Compiler\n+@versionsubtitle\n+@author Ian Lance Taylor\n+\n+@page\n+@vskip 0pt plus 1filll\n+Published by the Free Software Foundation @*\n+51 Franklin Street, Fifth Floor@*\n+Boston, MA 02110-1301, USA@*\n+@sp 1\n+@insertcopying\n+@end titlepage\n+@contents\n+@page\n+\n+@node Top\n+@top Introduction\n+\n+This manual describes how to use @command{gccgo}, the GNU compiler for\n+the Go programming language.  This manual is specifically about\n+@command{gccgo}.  For more information about the Go programming\n+language in general, including language specifications and standard\n+package documentation, see @uref{http://golang.org/}.\n+\n+@menu\n+* Copying::                     The GNU General Public License.\n+* GNU Free Documentation License::\n+                                How you can share and copy this manual.\n+* Invoking gccgo::              How to run gccgo.\n+* Import and Export::           Importing and exporting package data.\n+* C Interoperability::          Calling C from Go and vice-vera.\n+* Index::                       Index.\n+@end menu\n+\n+\n+@include gpl_v3.texi\n+\n+@include fdl.texi\n+\n+\n+@node Invoking gccgo\n+@chapter Invoking gccgo\n+\n+@c man title gccgo A GCC-based compiler for the Go language\n+\n+@ignore\n+@c man begin SYNOPSIS gccgo\n+gccgo [@option{-c}|@option{-S}]\n+      [@option{-g}] [@option{-pg}] [@option{-O}@var{level}]\n+      [@option{-I}@var{dir}@dots{}] [@option{-L}@var{dir}@dots{}]\n+      [@option{-o} @var{outfile}] @var{infile}@dots{}\n+\n+Only the most useful options are listed here; see below for the\n+remainder.\n+@c man end\n+@c man begin SEEALSO\n+gpl(7), gfdl(7), fsf-funding(7), gcc(1)\n+and the Info entries for @file{gccgo} and @file{gcc}.\n+@c man end\n+@end ignore\n+\n+@c man begin DESCRIPTION gccgo\n+\n+The @command{gccgo} command is a frontend to @command{gcc} and\n+supports many of the same options.  @xref{Option Summary, , Option\n+Summary, gcc, Using the GNU Compiler Collection (GCC)}.  This manual\n+only documents the options specific to @command{gccgo}.\n+\n+The @command{gccgo} command may be used to compile Go source code into\n+an object file, link a collection of object files together, or do both\n+in sequence.\n+\n+Go source code is compiled as packages.  A package consists of one or\n+more Go source files.  All the files in a single package must be\n+compiled together, by passing all the files as arguments to\n+@command{gccgo}.  A single invocation of @command{gccgo} may only\n+compile a single package.\n+\n+One Go package may @code{import} a different Go package.  The imported\n+package must have already been compiled; @command{gccgo} will read\n+the import data directly from the compiled package.  When this package\n+is later linked, the compiled form of the package must be included in\n+the link command.\n+\n+@c man end\n+\n+@c man begin OPTIONS gccgo\n+\n+@table @gcctabopt\n+@item -I@var{dir}\n+@cindex @option{-I}\n+Specify a directory to use when searching for an import package at\n+compile time.\n+\n+@item -L@var{dir}\n+@cindex @option{-L}\n+When compiling, synonymous with @option{-I}.  When linking, specify a\n+library search directory, as with @command{gcc}.\n+\n+@item -fgo-prefix=@var{string}\n+@cindex @option{-fgo-prefix}\n+Go permits a single program to include more than one package with the\n+same name.  This option is required to make this work with\n+@command{gccgo}.  The argument to this option may be any string.  Each\n+package with the same name must use a distinct @option{-fgo-prefix}\n+option.  The argument is typically the full path under which the\n+package will be installed, as that must obviously be unique.\n+\n+@item -frequire-return-statement\n+@itemx -fno-require-return-statement\n+@cindex @option{-frequire-return-statement}\n+@cindex @option{-fno-require-return-statement}\n+By default @command{gccgo} will warn about functions which have one or\n+more return parameters but lack an explicit @code{return} statement.\n+This warning may be disabled using\n+@option{-fno-require-return-statement}.\n+@end table\n+\n+@c man end\n+\n+@node Import and Export\n+@chapter Import and Export\n+\n+When @command{gccgo} compiles a package which exports anything, the\n+export information will be stored directly in the object file.  When a\n+package is imported, @command{gccgo} must be able to find the file.\n+\n+@cindex @file{.gox}\n+When Go code imports the package @file{gopackage}, @command{gccgo}\n+will look for the import data using the following filenames, using the\n+first one that it finds.\n+\n+@table @file\n+@item @var{gopackage}.gox\n+@item lib@var{gopackage}.so\n+@item lib@var{gopackage}.a\n+@item @var{gopackage}.o\n+@end table\n+\n+The compiler will search for these files in the directories named by\n+any @option{-I} or @option{-L} options, in order in which the\n+directories appear on the command line.  The compiler will then search\n+several standard system directories.  Finally the compiler will search\n+the current directory (to search the current directory earlier, use\n+@samp{-I.}).\n+\n+The compiler will extract the export information directly from the\n+compiled object file.  The file @file{@var{gopackage}.gox} will\n+typically contain nothing but export data.  This can be generated from\n+@file{@var{gopackage}.o} via\n+\n+@smallexample\n+objcopy -j .go_export @var{gopackage}.o @var{gopackage}.gox\n+@end smallexample\n+\n+For example, it may be desirable to extract the export information\n+from several different packages into their independent\n+@file{@var{gopackage}.gox} files, and then to combine the different\n+package object files together into a single shared library or archive.\n+\n+At link time you must explicitly tell @command{gccgo} which files to\n+link together into the executable, as is usual with @command{gcc}.\n+This is different from the behaviour of other Go compilers.\n+\n+@node C Interoperability\n+@chapter C Interoperability\n+\n+When using @command{gccgo} there is limited interoperability with C,\n+or with C++ code compiled using @code{extern \"C\"}.\n+\n+@menu\n+* C Type Interoperability::     How C and Go types match up.\n+* Function Names::              How Go functions are named.\n+@end menu\n+\n+@node C Type Interoperability\n+@section C Type Interoperability\n+\n+Basic types map directly: an @code{int} in Go is an @code{int} in C,\n+etc.  Go @code{byte} is equivalent to C @code{unsigned char}.\n+Pointers in Go are pointers in C.  A Go @code{struct} is the same as C\n+@code{struct} with the same field names and types.\n+\n+@cindex @code{string} in C\n+The Go @code{string} type is currently defined as a two-element\n+structure:\n+\n+@smallexample\n+struct __go_string @{\n+  const unsigned char *__data;\n+  int __length;\n+@};\n+@end smallexample\n+\n+You can't pass arrays between C and Go.  However, a pointer to an\n+array in Go is equivalent to a C pointer to the equivalent of the\n+element type.  For example, Go @code{*[10]int} is equivalent to C\n+@code{int*}, assuming that the C pointer does point to 10 elements.\n+\n+@cindex @code{slice} in C\n+A slice in Go is a structure.  The current definition is:\n+\n+@smallexample\n+struct __go_slice @{\n+  void *__values;\n+  int __count;\n+  int __capacity;\n+@};\n+@end smallexample\n+\n+The type of a Go function with no receiver is equivalent to a C\n+function whose parameter types are equivalent.  When a Go function\n+returns more than one value, the C function returns a struct.  For\n+example, these functions have equivalent types:\n+\n+@smallexample\n+func GoFunction(int) (int, float)\n+struct @{ int i; float f; @} CFunction(int)\n+@end smallexample\n+\n+A pointer to a Go function is equivalent to a pointer to a C function\n+when the functions have equivalent types.\n+\n+Go @code{interface}, @code{channel}, and @code{map} types have no\n+corresponding C type (@code{interface} is a two-element struct and\n+@code{channel} and @code{map} are pointers to structs in C, but the\n+structs are deliberately undocumented).  C @code{enum} types\n+correspond to some integer type, but precisely which one is difficult\n+to predict in general; use a cast.  C @code{union} types have no\n+corresponding Go type.  C @code{struct} types containing bitfields\n+have no corresponding Go type.  C++ @code{class} types have no\n+corresponding Go type.\n+\n+Memory allocation is completely different between C and Go, as Go uses\n+garbage collection.  The exact guidelines in this area are\n+undetermined, but it is likely that it will be permitted to pass a\n+pointer to allocated memory from C to Go.  The responsibility of\n+eventually freeing the pointer will remain with C side, and of course\n+if the C side frees the pointer while the Go side still has a copy the\n+program will fail.  When passing a pointer from Go to C, the Go\n+function must retain a visible copy of it in some Go variable.\n+Otherwise the Go garbage collector may delete the pointer while the C\n+function is still using it.\n+\n+@node Function Names\n+@section Function Names\n+\n+@cindex @code{__asm__}\n+Go code can call C functions directly using a Go extension implemented\n+in @command{gccgo}: a function declaration may be followed by\n+@code{__asm__ (\"@var{name}\")}. For example, here is how the C function\n+@code{open} can be declared in Go:\n+\n+@smallexample\n+func c_open(name *byte, mode int, perm int) int __asm__ (\"open\");\n+@end smallexample\n+\n+The C function naturally expects a nul terminated string, which in Go\n+is equivalent to a pointer to an array (not a slice!) of @code{byte}\n+with a terminating zero byte.  So a sample call from Go would look\n+like (after importing the @code{os} package):\n+\n+@smallexample\n+var name = [4]byte@{'f', 'o', 'o', 0@};\n+i := c_open(&amp;name[0], os.O_RDONLY, 0);\n+@end smallexample\n+\n+Note that this serves as an example only.  To open a file in Go please\n+use Go's @code{os.Open} function instead.\n+\n+The name of Go functions accessed from C is subject to change.  At\n+present the name of a Go function that does not have a receiver is\n+@code{prefix.package.Functionname}.  The prefix is set by the\n+@option{-fgo-prefix} option used when the package is compiled; if the\n+option is not used, the default is simply @code{go}.  To call the\n+function from C you must set the name using the @command{gcc}\n+extension similar to the @command{gccgo} extension.\n+\n+@smallexample\n+extern int go_function(int) __asm__ (\"myprefix.mypackage.Function\");\n+@end smallexample\n+\n+@node Index\n+@unnumbered Index\n+\n+@printindex cp\n+\n+@bye"}, {"sha": "2075494ed11b07372292a940411b052361f4ad72", "filename": "gcc/go/go-c.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,66 @@\n+/* go-c.h -- Header file for go frontend gcc C interface.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GO_GO_C_H\n+#define GO_GO_C_H\n+\n+#ifdef ENABLE_BUILD_WITH_CXX\n+#define GO_EXTERN_C\n+#else\n+#define GO_EXTERN_C extern \"C\"\n+#endif\n+\n+#if defined(__cplusplus) && !defined(ENABLE_BUILD_WITH_CXX)\n+extern \"C\"\n+{\n+#endif\n+\n+#include \"machmode.h\"\n+\n+/* Functions defined in the Go frontend proper called by the GCC\n+   interface.  */\n+\n+extern int go_enable_dump (const char*);\n+extern void go_set_prefix (const char*);\n+\n+extern void go_add_search_path (const char*);\n+\n+extern void go_create_gogo (int int_type_size, int float_type_size,\n+\t\t\t    int pointer_size);\n+\n+extern void go_parse_input_files (const char**, unsigned int,\n+\t\t\t\t  bool only_check_syntax,\n+\t\t\t\t  bool require_return_statement);\n+extern void go_write_globals (void);\n+\n+extern tree go_type_for_size (unsigned int bits, int unsignedp);\n+extern tree go_type_for_mode (enum machine_mode, int unsignedp);\n+\n+/* Functions defined in the GCC interface called by the Go frontend\n+   proper.  */\n+\n+extern void go_preserve_from_gc (tree);\n+\n+extern const char *go_localize_identifier (const char*);\n+\n+#if defined(__cplusplus) && !defined(ENABLE_BUILD_WITH_CXX)\n+} /* End extern \"C\".  */\n+#endif\n+\n+#endif /* !defined(GO_GO_C_H) */"}, {"sha": "9c85ab7f7a2d842a3ba91961458fe2825380298f", "filename": "gcc/go/go-lang.c", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,404 @@\n+/* go-lang.c -- Go frontend gcc interface.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ggc.h\"\n+#include \"toplev.h\"\n+#include \"debug.h\"\n+#include \"options.h\"\n+#include \"flags.h\"\n+#include \"convert.h\"\n+#include \"diagnostic.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+#include \"except.h\"\n+#include \"target.h\"\n+\n+#include <mpfr.h>\n+\n+#include \"go-c.h\"\n+\n+/* Language-dependent contents of a type.  */\n+\n+struct GTY(()) lang_type\n+{\n+  char dummy;\n+};\n+\n+/* Language-dependent contents of a decl.  */\n+\n+struct GTY(()) lang_decl\n+{\n+  char dummy;\n+};\n+\n+/* Language-dependent contents of an identifier.  This must include a\n+   tree_identifier.  */\n+\n+struct GTY(()) lang_identifier\n+{\n+  struct tree_identifier common;\n+};\n+\n+/* The resulting tree type.  */\n+\n+union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+\t   chain_next (\"(union lang_tree_node *) TREE_CHAIN (&%h.generic)\")))\n+lang_tree_node\n+{\n+  union tree_node GTY((tag (\"0\"),\n+\t\t       desc (\"tree_node_structure (&%h)\"))) generic;\n+  struct lang_identifier GTY((tag (\"1\"))) identifier;\n+};\n+\n+/* We don't use language_function.  */\n+\n+struct GTY(()) language_function\n+{\n+  int dummy;\n+};\n+\n+/* Language hooks.  */\n+\n+static bool\n+go_langhook_init (void)\n+{\n+  build_common_tree_nodes (false);\n+\n+  /* The sizetype may be \"unsigned long\" or \"unsigned long long\".  */\n+  if (TYPE_MODE (long_unsigned_type_node) == ptr_mode)\n+    size_type_node = long_unsigned_type_node;\n+  else if (TYPE_MODE (long_long_unsigned_type_node) == ptr_mode)\n+    size_type_node = long_long_unsigned_type_node;\n+  else\n+    size_type_node = long_unsigned_type_node;\n+  set_sizetype (size_type_node);\n+\n+  build_common_tree_nodes_2 (0);\n+\n+  /* We must create the gogo IR after calling build_common_tree_nodes\n+     (because Gogo::define_builtin_function_trees refers indirectly\n+     to, e.g., unsigned_char_type_node) but before calling\n+     build_common_builtin_nodes (because it calls, indirectly,\n+     go_type_for_size).  */\n+  go_create_gogo (INT_TYPE_SIZE, FLOAT_TYPE_SIZE, POINTER_SIZE);\n+\n+  build_common_builtin_nodes ();\n+\n+  /* I don't know why this is not done by any of the above.  */\n+  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n+\n+  /* The default precision for floating point numbers.  This is used\n+     for floating point constants with abstract type.  This may\n+     eventually be controllable by a command line option.  */\n+  mpfr_set_default_prec (128);\n+\n+  /* Go uses exceptions.  */\n+  using_eh_for_cleanups ();\n+\n+  return true;\n+}\n+\n+/* The option mask.  */\n+\n+static unsigned int\n+go_langhook_option_lang_mask (void)\n+{\n+  return CL_Go;\n+}\n+\n+/* Initialize the options structure.  */\n+\n+static void\n+go_langhook_init_options_struct (struct gcc_options *opts)\n+{\n+  /* Go says that signed overflow is precisely defined.  */\n+  opts->x_flag_wrapv = 1;\n+\n+  /* We default to using strict aliasing, since Go pointers are safe.\n+     This is turned off for code that imports the \"unsafe\" package,\n+     because using unsafe.pointer violates C style aliasing\n+     requirements.  */\n+  opts->x_flag_strict_aliasing = 1;\n+\n+  /* Default to avoiding range issues for complex multiply and\n+     divide.  */\n+  opts->x_flag_complex_method = 2;\n+\n+  /* The builtin math functions should not set errno.  */\n+  opts->x_flag_errno_math = 0;\n+\n+  /* By default assume that floating point math does not trap.  */\n+  opts->x_flag_trapping_math = 0;\n+\n+  /* We turn on stack splitting if we can.  */\n+  if (targetm.supports_split_stack (false, opts))\n+    opts->x_flag_split_stack = 1;\n+\n+  /* Exceptions are used to handle recovering from panics.  */\n+  opts->x_flag_exceptions = 1;\n+  opts->x_flag_non_call_exceptions = 1;\n+}\n+\n+/* Handle Go specific options.  Return 0 if we didn't do anything.  */\n+\n+static bool\n+go_langhook_handle_option (\n+    size_t scode,\n+    const char *arg,\n+    int value ATTRIBUTE_UNUSED,\n+    int kind ATTRIBUTE_UNUSED,\n+    location_t loc ATTRIBUTE_UNUSED,\n+    const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+{\n+  enum opt_code code = (enum opt_code) scode;\n+  bool ret = true;\n+\n+  switch (code)\n+    {\n+    case OPT_I:\n+    case OPT_L:\n+      /* For the compiler, we currently handle -I and -L exactly the\n+\t same way: they give us a directory to search for import\n+\t statements.  */\n+      go_add_search_path (arg);\n+      break;\n+\n+    case OPT_fgo_dump_:\n+      ret = go_enable_dump (arg) ? true : false;\n+      break;\n+\n+    case OPT_fgo_prefix_:\n+      go_set_prefix (arg);\n+      break;\n+\n+    default:\n+      /* Just return 1 to indicate that the option is valid.  */\n+      break;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Run after parsing options.  */\n+\n+static bool\n+go_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (num_in_fnames > 0);\n+\n+  if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n+    flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n+\n+  /* Returning false means that the backend should be used.  */\n+  return false;\n+}\n+\n+static void\n+go_langhook_parse_file (void)\n+{\n+  go_parse_input_files (in_fnames, num_in_fnames, flag_syntax_only,\n+\t\t\tgo_require_return_statement);\n+}\n+\n+static tree\n+go_langhook_type_for_size (unsigned int bits, int unsignedp)\n+{\n+  return go_type_for_size (bits, unsignedp);\n+}\n+\n+static tree\n+go_langhook_type_for_mode (enum machine_mode mode, int unsignedp)\n+{\n+  return go_type_for_mode (mode, unsignedp);\n+}\n+\n+/* Record a builtin function.  We just ignore builtin functions.  */\n+\n+static tree\n+go_langhook_builtin_function (tree decl)\n+{\n+  return decl;\n+}\n+\n+static int\n+go_langhook_global_bindings_p (void)\n+{\n+  return current_function_decl == NULL ? 1 : 0;\n+}\n+\n+/* Push a declaration into the current binding level.  We can't\n+   usefully implement this since we don't want to convert from tree\n+   back to one of our internal data structures.  I think the only way\n+   this is used is to record a decl which is to be returned by\n+   getdecls, and we could implement it for that purpose if\n+   necessary.  */\n+\n+static tree\n+go_langhook_pushdecl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This hook is used to get the current list of declarations as trees.\n+   We don't support that; instead we use the write_globals hook.  This\n+   can't simply crash because it is called by -gstabs.  */\n+\n+static tree\n+go_langhook_getdecls (void)\n+{\n+  return NULL;\n+}\n+\n+/* Write out globals.  */\n+\n+static void\n+go_langhook_write_globals (void)\n+{\n+  go_write_globals ();\n+}\n+\n+/* Go specific gimplification.  We need to gimplify\n+   CALL_EXPR_STATIC_CHAIN, because the gimplifier doesn't handle\n+   it.  */\n+\n+static int\n+go_langhook_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n+{\n+  if (TREE_CODE (*expr_p) == CALL_EXPR\n+      && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n+    gimplify_expr (&CALL_EXPR_STATIC_CHAIN (*expr_p), pre_p, post_p,\n+\t\t   is_gimple_val, fb_rvalue);\n+  return GS_UNHANDLED;\n+}\n+\n+/* Return a decl for the exception personality function.  The function\n+   itself is implemented in libgo/runtime/go-unwind.c.  */\n+\n+static tree\n+go_langhook_eh_personality (void)\n+{\n+  static tree personality_decl;\n+  if (personality_decl == NULL_TREE)\n+    {\n+      personality_decl = build_personality_function (\"gccgo\");\n+      go_preserve_from_gc (personality_decl);\n+    }\n+  return personality_decl;\n+}\n+\n+/* Functions called directly by the generic backend.  */\n+\n+tree\n+convert (tree type, tree expr)\n+{\n+  if (type == error_mark_node\n+      || expr == error_mark_node\n+      || TREE_TYPE (expr) == error_mark_node)\n+    return error_mark_node;\n+\n+  if (type == TREE_TYPE (expr))\n+    return expr;\n+\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n+    return fold_convert (type, expr);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+      return fold_convert (type, expr);\n+    case INTEGER_TYPE:\n+      return fold (convert_to_integer (type, expr));\n+    case POINTER_TYPE:\n+      return fold (convert_to_pointer (type, expr));\n+    case REAL_TYPE:\n+      return fold (convert_to_real (type, expr));\n+    case COMPLEX_TYPE:\n+      return fold (convert_to_complex (type, expr));\n+    default:\n+      break;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* FIXME: This is a hack to preserve trees that we create from the\n+   garbage collector.  */\n+\n+static GTY(()) tree go_gc_root;\n+\n+void\n+go_preserve_from_gc (tree t)\n+{\n+  go_gc_root = tree_cons (NULL_TREE, t, go_gc_root);\n+}\n+\n+/* Convert an identifier for use in an error message.  */\n+\n+const char *\n+go_localize_identifier (const char *ident)\n+{\n+  return identifier_to_locale (ident);\n+}\n+\n+#undef LANG_HOOKS_NAME\n+#undef LANG_HOOKS_INIT\n+#undef LANG_HOOKS_OPTION_LANG_MASK\n+#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n+#undef LANG_HOOKS_HANDLE_OPTION\n+#undef LANG_HOOKS_POST_OPTIONS\n+#undef LANG_HOOKS_PARSE_FILE\n+#undef LANG_HOOKS_TYPE_FOR_MODE\n+#undef LANG_HOOKS_TYPE_FOR_SIZE\n+#undef LANG_HOOKS_BUILTIN_FUNCTION\n+#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n+#undef LANG_HOOKS_PUSHDECL\n+#undef LANG_HOOKS_GETDECLS\n+#undef LANG_HOOKS_WRITE_GLOBALS\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#undef LANG_HOOKS_EH_PERSONALITY\n+\n+#define LANG_HOOKS_NAME\t\t\t\"GNU Go\"\n+#define LANG_HOOKS_INIT\t\t\tgo_langhook_init\n+#define LANG_HOOKS_OPTION_LANG_MASK\tgo_langhook_option_lang_mask\n+#define LANG_HOOKS_INIT_OPTIONS_STRUCT\tgo_langhook_init_options_struct\n+#define LANG_HOOKS_HANDLE_OPTION\tgo_langhook_handle_option\n+#define LANG_HOOKS_POST_OPTIONS\t\tgo_langhook_post_options\n+#define LANG_HOOKS_PARSE_FILE\t\tgo_langhook_parse_file\n+#define LANG_HOOKS_TYPE_FOR_MODE\tgo_langhook_type_for_mode\n+#define LANG_HOOKS_TYPE_FOR_SIZE\tgo_langhook_type_for_size\n+#define LANG_HOOKS_BUILTIN_FUNCTION\tgo_langhook_builtin_function\n+#define LANG_HOOKS_GLOBAL_BINDINGS_P\tgo_langhook_global_bindings_p\n+#define LANG_HOOKS_PUSHDECL\t\tgo_langhook_pushdecl\n+#define LANG_HOOKS_GETDECLS\t\tgo_langhook_getdecls\n+#define LANG_HOOKS_WRITE_GLOBALS\tgo_langhook_write_globals\n+#define LANG_HOOKS_GIMPLIFY_EXPR\tgo_langhook_gimplify_expr\n+#define LANG_HOOKS_EH_PERSONALITY\tgo_langhook_eh_personality\n+\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+#include \"gt-go-go-lang.h\"\n+#include \"gtype-go.h\""}, {"sha": "e56952dfe4e492182d49c62423ec0372de14e842", "filename": "gcc/go/go-system.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgo-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgo-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-system.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,153 @@\n+// go-system.h -- Go frontend inclusion of gcc header files   -*- C++ -*-\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef GO_SYSTEM_H\n+#define GO_SYSTEM_H\n+\n+#include \"config.h\"\n+\n+// These must be included before the #poison declarations in system.h.\n+\n+#include <algorithm>\n+#include <string>\n+#include <list>\n+#include <map>\n+#include <set>\n+#include <vector>\n+\n+#if defined(HAVE_UNORDERED_MAP)\n+\n+# include <unordered_map>\n+# include <unordered_set>\n+\n+# define Unordered_map(KEYTYPE, VALTYPE) \\\n+\tstd::unordered_map<KEYTYPE, VALTYPE>\n+\n+# define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN) \\\n+\tstd::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n+\n+# define Unordered_set(KEYTYPE) \\\n+\tstd::unordered_set<KEYTYPE>\n+\n+# define Unordered_set_hash(KEYTYPE, HASHFN, EQFN) \\\n+\tstd::unordered_set<KEYTYPE, HASHFN, EQFN>\n+\n+#elif defined(HAVE_TR1_UNORDERED_MAP)\n+\n+# include <tr1/unordered_map>\n+# include <tr1/unordered_set>\n+\n+# define Unordered_map(KEYTYPE, VALTYPE) \\\n+\tstd::tr1::unordered_map<KEYTYPE, VALTYPE>\n+\n+# define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN) \\\n+\tstd::tr1::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n+\n+# define Unordered_set(KEYTYPE) \\\n+\tstd::tr1::unordered_set<KEYTYPE>\n+\n+# define Unordered_set_hash(KEYTYPE, HASHFN, EQFN) \\\n+\tstd::tr1::unordered_set<KEYTYPE, HASHFN, EQFN>\n+\n+#elif defined(HAVE_EXT_HASH_MAP)\n+\n+# include <ext/hash_map>\n+# include <ext/hash_set>\n+\n+# define Unordered_map(KEYTYPE, VALTYPE) \\\n+\t__gnu_cxx::hash_map<KEYTYPE, VALTYPE>\n+\n+# define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN) \\\n+\t__gnu_cxx::hash_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n+\n+# define Unordered_set(KEYTYPE) \\\n+\t__gnu_cxx::hash_set<KEYTYPE>\n+\n+# define Unordered_set_hash(KEYTYPE, HASHFN, EQFN) \\\n+\t__gnu_cxx::hash_set<KEYTYPE, HASHFN, EQFN>\n+\n+// Provide hash functions for strings and pointers.\n+\n+namespace __gnu_cxx\n+{\n+\n+template<>\n+struct hash<std::string>\n+{\n+  size_t\n+  operator()(std::string s) const\n+  { return __stl_hash_string(s.c_str()); }\n+};\n+\n+template<typename T>\n+struct hash<T*>\n+{\n+  size_t\n+  operator()(T* p) const\n+  { return reinterpret_cast<size_t>(p); }\n+};\n+\n+}\n+\n+#else\n+\n+# define Unordered_map(KEYTYPE, VALTYPE) \\\n+\tstd::map<KEYTYPE, VALTYPE>\n+\n+# define Unordered_set(KEYTYPE) \\\n+\tstd::set<KEYTYPE>\n+\n+// We could make this work by writing an adapter class which\n+// implemented operator< in terms of the hash function.\n+# error \"requires hash table type\"\n+\n+#endif\n+\n+// We don't really need iostream, but some versions of gmp.h include\n+// it when compiled with C++, which means that we need to include it\n+// before the macro magic of safe-ctype.h, which is included by\n+// system.h.\n+#include <iostream>\n+\n+// Some versions of gmp.h assume that #include <iostream> will define\n+// std::FILE.  This is not true with libstdc++ 4.3 and later.  This is\n+// fixed in GMP 4.3, but at this point we don't know which version of\n+// GMP is in use.  Since the top level configure script accepts GMP\n+// 4.2, at least for now we #include <cstdio> to ensure that GMP 4.2\n+// will work.  FIXME: This can be removed when we require GMP 4.3 or\n+// later.\n+#include <cstdio>\n+\n+#ifndef ENABLE_BUILD_WITH_CXX\n+extern \"C\"\n+{\n+#endif\n+\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"coretypes.h\"\n+\n+#include \"diagnostic-core.h\"\t/* For error_at and friends.  */\n+#include \"input.h\"\t\t/* For source_location.  */\n+\n+#ifndef ENABLE_BUILD_WITH_CXX\n+} // End extern \"C\"\n+#endif\n+\n+#endif // !defined(GO_SYSTEM_H)"}, {"sha": "d77335ff888dbb1cc5245ddfb7130315cd0d7e80", "filename": "gcc/go/gofrontend/LICENSE", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2FLICENSE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2FLICENSE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FLICENSE?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (c) 2009 The Go Authors. All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//    * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//    * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//    * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//\n+// Subject to the terms and conditions of this License, Google hereby\n+// grants to You a perpetual, worldwide, non-exclusive, no-charge,\n+// royalty-free, irrevocable (except as stated in this section) patent\n+// license to make, have made, use, offer to sell, sell, import, and\n+// otherwise transfer this implementation of Go, where such license\n+// applies only to those patent claims licensable by Google that are\n+// necessarily infringed by use of this implementation of Go. If You\n+// institute patent litigation against any entity (including a\n+// cross-claim or counterclaim in a lawsuit) alleging that this\n+// implementation of Go or a Contribution incorporated within this\n+// implementation of Go constitutes direct or contributory patent\n+// infringement, then any patent licenses granted to You under this\n+// License for this implementation of Go shall terminate as of the date\n+// such litigation is filed."}, {"sha": "dd13710079faeace0c9532410673ca803889b3e3", "filename": "gcc/go/gofrontend/README", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FREADME?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,57 @@\n+See ../README.\n+\n+The frontend is written in C++.\n+\n+The frontend lexes and parses the input into an IR specific to this\n+frontend known as gogo.  It then runs a series of passes over the\n+code.\n+\n+Finally it converts gogo to gcc's GENERIC.  A goal is to move the gcc\n+support code into a gcc-interface subdirectory.  The gcc code will be\n+put under the GPL.  The rest of the frontend will not include any gcc\n+header files.\n+\n+Issues to be faced in this transition:\n+\n+* Representation of source locations.\n+  + Currently the frontend uses gcc's source_location codes, using the\n+    interface in libcpp/line-map.h.\n+\n+* Handling of error messages.\n+  + Currently the frontend uses gcc's error_at and warning_at\n+    functions.\n+  + Currently the frontend uses gcc's diagnostic formatter, using\n+    features such as %<%> for appropriate quoting.\n+  + Localization may be an issue.\n+\n+* Use of gcc_assert and gcc_unreachable.\n+\n+This compiler works, but the code is a work in progress.  Notably, the\n+support for garbage collection is ineffective and needs a complete\n+rethinking.  The frontend pays little attention to its memory usage\n+and rarely frees any memory.  The code could use a general cleanup\n+which we have not had time to do.\n+\n+Contributing\n+=============\n+\n+To contribute patches to the files in this directory, please see\n+http://golang.org/doc/gccgo_contribute.html .\n+\n+Changes to these files require a copyright assignment to Google.  This\n+is required to permit the changes to be copied to the gcc repository,\n+as Google has a copyright assignment with the Free Software\n+Foundation.\n+\n+If you are the copyright holder, you will need to agree to the\n+individual contributor license agreement at\n+http://code.google.com/legal/individual-cla-v1.0.html.  This agreement\n+can be completed online.\n+\n+If your organization is the copyright holder, the organization will\n+need to agree to the corporate contributor license agreement at\n+http://code.google.com/legal/corporate-cla-v1.0.html.\n+\n+If the copyright holder for your code has already completed the\n+agreement in connection with another Google open source project, it\n+does not need to be completed again."}, {"sha": "8170d0ac18e5bb5d3bc80999a3e1944f3da82a0f", "filename": "gcc/go/gofrontend/dataflow.cc", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,278 @@\n+// dataflow.cc -- Go frontend dataflow.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"gogo.h\"\n+#include \"expressions.h\"\n+#include \"statements.h\"\n+#include \"dataflow.h\"\n+\n+// This class is used to traverse the tree to look for uses of\n+// variables.\n+\n+class Dataflow_traverse_expressions : public Traverse\n+{\n+ public:\n+  Dataflow_traverse_expressions(Dataflow* dataflow, Statement* statement)\n+    : Traverse(traverse_blocks | traverse_expressions),\n+      dataflow_(dataflow), statement_(statement)\n+  { }\n+\n+ protected:\n+  // Only look at top-level expressions: do not descend into blocks.\n+  // They will be examined via Dataflow_traverse_statements.\n+  int\n+  block(Block*)\n+  { return TRAVERSE_SKIP_COMPONENTS; }\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The dataflow information.\n+  Dataflow* dataflow_;\n+  // The Statement in which we are looking.\n+  Statement* statement_;\n+};\n+\n+// Given an expression, return the Named_object that it refers to, if\n+// it is a local variable.\n+\n+static Named_object*\n+get_var(Expression* expr)\n+{\n+  Var_expression* ve = expr->var_expression();\n+  if (ve == NULL)\n+    return NULL;\n+  Named_object* no = ve->named_object();\n+  gcc_assert(no->is_variable() || no->is_result_variable());\n+  if (no->is_variable() && no->var_value()->is_global())\n+    return NULL;\n+  return no;\n+}\n+\n+// Look for a reference to a variable in an expression.\n+\n+int\n+Dataflow_traverse_expressions::expression(Expression** expr)\n+{\n+  Named_object* no = get_var(*expr);\n+  if (no != NULL)\n+    this->dataflow_->add_ref(no, this->statement_);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// This class is used to handle an assignment statement.\n+\n+class Dataflow_traverse_assignment : public Traverse_assignments\n+{\n+ public:\n+  Dataflow_traverse_assignment(Dataflow* dataflow, Statement* statement)\n+    : dataflow_(dataflow), statement_(statement)\n+  { }\n+\n+ protected:\n+  void\n+  initialize_variable(Named_object*);\n+\n+  void\n+  assignment(Expression** lhs, Expression** rhs);\n+\n+  void\n+  value(Expression**, bool, bool);\n+\n+ private:\n+  // The dataflow information.\n+  Dataflow* dataflow_;\n+  // The Statement in which we are looking.\n+  Statement* statement_;\n+};\n+\n+// Handle a variable initialization.\n+\n+void\n+Dataflow_traverse_assignment::initialize_variable(Named_object* var)\n+{\n+  Expression* init = var->var_value()->init();\n+  this->dataflow_->add_def(var, init, this->statement_, true);\n+  if (init != NULL)\n+    {\n+      Expression* e = init;\n+      this->value(&e, true, true);\n+      gcc_assert(e == init);\n+    }\n+}\n+\n+// Handle an assignment in a statement.\n+\n+void\n+Dataflow_traverse_assignment::assignment(Expression** plhs, Expression** prhs)\n+{\n+  Named_object* no = get_var(*plhs);\n+  if (no != NULL)\n+    {\n+      Expression* rhs = prhs == NULL ? NULL : *prhs;\n+      this->dataflow_->add_def(no, rhs, this->statement_, false);\n+    }\n+  else\n+    {\n+      // If this is not a variable it may be some computed lvalue, and\n+      // we want to look for references to variables in that lvalue.\n+      this->value(plhs, false, false);\n+    }\n+  if (prhs != NULL)\n+    this->value(prhs, true, false);\n+}\n+\n+// Handle a value in a statement.\n+\n+void\n+Dataflow_traverse_assignment::value(Expression** pexpr, bool, bool)\n+{\n+  Named_object* no = get_var(*pexpr);\n+  if (no != NULL)\n+    this->dataflow_->add_ref(no, this->statement_);\n+  else\n+    {\n+      Dataflow_traverse_expressions dte(this->dataflow_, this->statement_);\n+      Expression::traverse(pexpr, &dte);\n+    }\n+}\n+\n+// This class is used to traverse the tree to look for statements.\n+\n+class Dataflow_traverse_statements : public Traverse\n+{\n+ public:\n+  Dataflow_traverse_statements(Dataflow* dataflow)\n+    : Traverse(traverse_statements),\n+      dataflow_(dataflow)\n+  { }\n+\n+ protected:\n+  int\n+  statement(Block*, size_t* pindex, Statement*);\n+\n+ private:\n+  // The dataflow information.\n+  Dataflow* dataflow_;\n+};\n+\n+// For each Statement, we look for expressions.\n+\n+int\n+Dataflow_traverse_statements::statement(Block* block, size_t* pindex,\n+\t\t\t\t\tStatement *statement)\n+{\n+  Dataflow_traverse_assignment dta(this->dataflow_, statement);\n+  if (!statement->traverse_assignments(&dta))\n+    {\n+      Dataflow_traverse_expressions dte(this->dataflow_, statement);\n+      statement->traverse(block, pindex, &dte);\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Compare variables.\n+\n+bool\n+Dataflow::Compare_vars::operator()(const Named_object* no1,\n+\t\t\t\t   const Named_object* no2) const\n+{\n+  if (no1->name() < no2->name())\n+    return true;\n+  if (no1->name() > no2->name())\n+    return false;\n+\n+  // We can have two different variables with the same name.\n+  source_location loc1 = no1->location();\n+  source_location loc2 = no2->location();\n+  if (loc1 < loc2)\n+    return false;\n+  if (loc1 > loc2)\n+    return true;\n+\n+  if (no1 == no2)\n+    return false;\n+\n+  // We can't have two variables with the same name in the same\n+  // location.\n+  gcc_unreachable();\n+}\n+\n+// Class Dataflow.\n+\n+Dataflow::Dataflow()\n+  : defs_(), refs_()\n+{\n+}\n+\n+// Build the dataflow information.\n+\n+void\n+Dataflow::initialize(Gogo* gogo)\n+{\n+  Dataflow_traverse_statements dts(this);\n+  gogo->traverse(&dts);\n+}\n+\n+// Add a definition of a variable.\n+\n+void\n+Dataflow::add_def(Named_object* var, Expression* val, Statement* statement,\n+\t\t  bool is_init)\n+{\n+  Defs* defnull = NULL;\n+  std::pair<Defmap::iterator, bool> ins =\n+    this->defs_.insert(std::make_pair(var, defnull));\n+  if (ins.second)\n+    ins.first->second = new Defs;\n+  Def def;\n+  def.statement = statement;\n+  def.val = val;\n+  def.is_init = is_init;\n+  ins.first->second->push_back(def);\n+}\n+\n+// Add a reference to a variable.\n+\n+void\n+Dataflow::add_ref(Named_object* var, Statement* statement)\n+{\n+  Refs* refnull = NULL;\n+  std::pair<Refmap::iterator, bool> ins =\n+    this->refs_.insert(std::make_pair(var, refnull));\n+  if (ins.second)\n+    ins.first->second = new Refs;\n+  Ref ref;\n+  ref.statement = statement;\n+  ins.first->second->push_back(ref);\n+}\n+\n+// Return the definitions of a variable.\n+\n+const Dataflow::Defs*\n+Dataflow::find_defs(Named_object* var) const\n+{\n+  Defmap::const_iterator p = this->defs_.find(var);\n+  if (p == this->defs_.end())\n+    return NULL;\n+  else\n+    return p->second;\n+}\n+\n+// Return the references of a variable.\n+\n+const Dataflow::Refs*\n+Dataflow::find_refs(Named_object* var) const\n+{\n+  Refmap::const_iterator p = this->refs_.find(var);\n+  if (p == this->refs_.end())\n+    return NULL;\n+  else\n+    return p->second;\n+}"}, {"sha": "a75c8e661f5a19ba772bcca0f05bec688d7e483c", "filename": "gcc/go/gofrontend/dataflow.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fdataflow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fdataflow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fdataflow.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,91 @@\n+// dataflow.h -- Go frontend dataflow.    -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_DATAFLOW_H\n+#define GO_DATAFLOW_H\n+\n+class Expression;\n+class Named_object;\n+class Statement;\n+\n+// Dataflow information about the Go program.\n+\n+class Dataflow\n+{\n+ public:\n+  // A variable definition.\n+  struct Def\n+  {\n+    // The statement where the variable is defined.\n+    Statement* statement;\n+    // The value to which the variable is set.  This may be NULL.\n+    Expression* val;\n+    // Whether this is an initialization of the variable.\n+    bool is_init;\n+  };\n+\n+  // A variable reference.\n+  struct Ref\n+  {\n+    // The statement where the variable is referenced.\n+    Statement* statement;\n+  };\n+\n+  // A list of defs.\n+  typedef std::vector<Def> Defs;\n+\n+  // A list of refs.\n+  typedef std::vector<Ref> Refs;\n+\n+  Dataflow();\n+\n+  // Initialize the dataflow information.\n+  void\n+  initialize(Gogo*);\n+\n+  // Add a definition of a variable.  STATEMENT assigns a value to\n+  // VAR.  VAL is the value if it is known, NULL otherwise.\n+  void\n+  add_def(Named_object* var, Expression* val, Statement* statement,\n+\t  bool is_init);\n+\n+  // Add a reference to a variable.  VAR is the variable, and\n+  // STATEMENT is the statement which refers to it.\n+  void\n+  add_ref(Named_object* var, Statement* statement);\n+\n+  // Return the definitions of VAR--the places where it is set.\n+  const Defs*\n+  find_defs(Named_object* var) const;\n+\n+  // Return the references to VAR--the places where it is used.\n+  const Refs*\n+  find_refs(Named_object* var) const;\n+\n+ private:\n+  // Order variables in the map.\n+  struct Compare_vars\n+  {\n+    bool\n+    operator()(const Named_object*, const Named_object*) const;\n+  };\n+\n+  // Map from variables to a list of defs of the variable.  We use a\n+  // map rather than a hash table because the order in which we\n+  // process variables may affect the resulting code.\n+  typedef std::map<Named_object*, Defs*, Compare_vars> Defmap;\n+\n+  // Map from variables to a list of refs to the vairable.\n+  typedef std::map<Named_object*, Refs*, Compare_vars> Refmap;\n+\n+  // Variable defs.\n+  Defmap defs_;\n+  // Variable refs;\n+  Refmap refs_;\n+};\n+\n+\n+#endif // !defined(GO_DATAFLOW_H)"}, {"sha": "6b42d0c493074b935a0fab8a161b85acb6bb6cf2", "filename": "gcc/go/gofrontend/export.cc", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,441 @@\n+// export.cc -- Export declarations in Go frontend.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+#include \"sha1.h\"\n+\n+#ifndef ENABLE_BUILD_WITH_CXX\n+extern \"C\"\n+{\n+#endif\n+\n+#include \"machmode.h\"\n+#include \"output.h\"\n+#include \"target.h\"\n+\n+#ifndef ENABLE_BUILD_WITH_CXX\n+}\n+#endif\n+\n+#include \"gogo.h\"\n+#include \"types.h\"\n+#include \"statements.h\"\n+#include \"export.h\"\n+\n+// This file handles exporting global declarations.\n+\n+// Class Export.\n+\n+// Version 1 magic number.\n+\n+const int Export::v1_magic_len;\n+\n+const char Export::v1_magic[Export::v1_magic_len] =\n+  {\n+    'v', '1', ';', '\\n'\n+  };\n+\n+const int Export::v1_checksum_len;\n+\n+// Constructor.\n+\n+Export::Export(Stream* stream)\n+  : stream_(stream), type_refs_(), type_index_(1)\n+{\n+}\n+\n+// A functor to sort Named_object pointers by name.\n+\n+struct Sort_bindings\n+{\n+  bool\n+  operator()(const Named_object* n1, const Named_object* n2) const\n+  { return n1->name() < n2->name(); }\n+};\n+\n+// Return true if we should export NO.\n+\n+static bool\n+should_export(Named_object* no)\n+{\n+  // We only export objects which are locally defined.\n+  if (no->package() != NULL)\n+    return false;\n+\n+  // We don't export packages.\n+  if (no->is_package())\n+    return false;\n+\n+  // We don't export hidden names.\n+  if (Gogo::is_hidden_name(no->name()))\n+    return false;\n+\n+  // We don't export nested functions.\n+  if (no->is_function() && no->func_value()->enclosing() != NULL)\n+    return false;\n+\n+  // We don't export thunks.\n+  if (no->is_function() && Gogo::is_thunk(no))\n+    return false;\n+\n+  // Methods are exported with the type, not here.\n+  if (no->is_function()\n+      && no->func_value()->type()->is_method())\n+    return false;\n+  if (no->is_function_declaration()\n+      && no->func_declaration_value()->type()->is_method())\n+    return false;\n+\n+  // Don't export dummy global variables created for initializers when\n+  // used with sinks.\n+  if (no->is_variable() && no->name()[0] == '_' && no->name()[1] == '.')\n+    return false;\n+\n+  return true;\n+}\n+\n+// Export those identifiers marked for exporting.\n+\n+void\n+Export::export_globals(const std::string& package_name,\n+\t\t       const std::string& unique_prefix,\n+\t\t       int package_priority,\n+\t\t       const std::string& import_init_fn,\n+\t\t       const std::set<Import_init>& imported_init_fns,\n+\t\t       const Bindings* bindings)\n+{\n+  // If there have been any errors so far, don't try to export\n+  // anything.  That way the export code doesn't have to worry about\n+  // mismatched types or other confusions.\n+  if (saw_errors())\n+    return;\n+\n+  // Export the symbols in sorted order.  That will reduce cases where\n+  // irrelevant changes to the source code affect the exported\n+  // interface.\n+  std::vector<Named_object*> exports;\n+  exports.reserve(bindings->size_definitions());\n+\n+  for (Bindings::const_definitions_iterator p = bindings->begin_definitions();\n+       p != bindings->end_definitions();\n+       ++p)\n+    if (should_export(*p))\n+      exports.push_back(*p);\n+\n+  for (Bindings::const_declarations_iterator p =\n+\t bindings->begin_declarations();\n+       p != bindings->end_declarations();\n+       ++p)\n+    {\n+      // We export a function declaration as it may be implemented in\n+      // supporting C code.  We do not export type declarations.\n+      if (p->second->is_function_declaration()\n+\t  && should_export(p->second))\n+\texports.push_back(p->second);\n+    }\n+\n+  std::sort(exports.begin(), exports.end(), Sort_bindings());\n+\n+  // Although the export data is readable, at least this version is,\n+  // it is conceptually a binary format.  Start with a four byte\n+  // verison number.\n+  this->write_bytes(Export::v1_magic, Export::v1_magic_len);\n+\n+  // The package name.\n+  this->write_c_string(\"package \");\n+  this->write_string(package_name);\n+  this->write_c_string(\";\\n\");\n+\n+  // The unique prefix.  This prefix is used for all global symbols.\n+  this->write_c_string(\"prefix \");\n+  this->write_string(unique_prefix);\n+  this->write_c_string(\";\\n\");\n+\n+  // The package priority.\n+  char buf[100];\n+  snprintf(buf, sizeof buf, \"priority %d;\\n\", package_priority);\n+  this->write_c_string(buf);\n+\n+  this->write_imported_init_fns(package_name, package_priority, import_init_fn,\n+\t\t\t\timported_init_fns);\n+\n+  // FIXME: It might be clever to add something about the processor\n+  // and ABI being used, although ideally any problems in that area\n+  // would be caught by the linker.\n+\n+  for (std::vector<Named_object*>::const_iterator p = exports.begin();\n+       p != exports.end();\n+       ++p)\n+    (*p)->export_named_object(this);\n+\n+  std::string checksum = this->stream_->checksum();\n+  std::string s = \"checksum \";\n+  for (std::string::const_iterator p = checksum.begin();\n+       p != checksum.end();\n+       ++p)\n+    {\n+      unsigned char c = *p;\n+      unsigned int dig = c >> 4;\n+      s += dig < 10 ? '0' + dig : 'A' + dig - 10;\n+      dig = c & 0xf;\n+      s += dig < 10 ? '0' + dig : 'A' + dig - 10;\n+    }\n+  s += \";\\n\";\n+  this->stream_->write_checksum(s);\n+}\n+\n+// Write out the import control variables for this package.\n+\n+void\n+Export::write_imported_init_fns(\n+    const std::string& package_name,\n+    int priority,\n+    const std::string& import_init_fn,\n+    const std::set<Import_init>& imported_init_fns)\n+{\n+  if (import_init_fn.empty() && imported_init_fns.empty())\n+    return;\n+\n+  this->write_c_string(\"import\");\n+\n+  if (!import_init_fn.empty())\n+    {\n+      this->write_c_string(\" \");\n+      this->write_string(package_name);\n+      this->write_c_string(\" \");\n+      this->write_string(import_init_fn);\n+      char buf[100];\n+      snprintf(buf, sizeof buf, \" %d\", priority);\n+      this->write_c_string(buf);\n+    }\n+\n+  if (!imported_init_fns.empty())\n+    {\n+      // Sort the list of functions for more consistent output.\n+      std::vector<Import_init> v;\n+      for (std::set<Import_init>::const_iterator p = imported_init_fns.begin();\n+\t   p != imported_init_fns.end();\n+\t   ++p)\n+\tv.push_back(*p);\n+      std::sort(v.begin(), v.end());\n+\n+      for (std::vector<Import_init>::const_iterator p = v.begin();\n+\t   p != v.end();\n+\t   ++p)\n+\t{\n+\t  this->write_c_string(\" \");\n+\t  this->write_string(p->package_name());\n+\t  this->write_c_string(\" \");\n+\t  this->write_string(p->init_name());\n+\t  char buf[100];\n+\t  snprintf(buf, sizeof buf, \" %d\", p->priority());\n+\t  this->write_c_string(buf);\n+\t}\n+    }\n+\n+  this->write_c_string(\";\\n\");\n+}\n+\n+// Export a type.  We have to ensure that on import we create a single\n+// Named_type node for each named type.  We do this by keeping a hash\n+// table mapping named types to reference numbers.  The first time we\n+// see a named type we assign it a reference number by making an entry\n+// in the hash table.  If we see it again, we just refer to the\n+// reference number.\n+\n+// Named types are, of course, associated with packages.  Note that we\n+// may see a named type when importing one package, and then later see\n+// the same named type when importing a different package.  The home\n+// package may or may not be imported during this compilation.  The\n+// reference number scheme has to get this all right.  Basic approach\n+// taken from \"On the Linearization of Graphs and Writing Symbol\n+// Files\" by Robert Griesemer.\n+\n+void\n+Export::write_type(const Type* type)\n+{\n+  // We don't want to assign a reference number to a forward\n+  // declaration to a type which was defined later.\n+  type = type->forwarded();\n+\n+  Type_refs::const_iterator p = this->type_refs_.find(type);\n+  if (p != this->type_refs_.end())\n+    {\n+      // This type was already in the table.\n+      int index = p->second;\n+      gcc_assert(index != 0);\n+      char buf[30];\n+      snprintf(buf, sizeof buf, \"<type %d>\", index);\n+      this->write_c_string(buf);\n+      return;\n+    }\n+\n+  const Named_type* named_type = type->named_type();\n+  const Forward_declaration_type* forward = type->forward_declaration_type();\n+\n+  int index = this->type_index_;\n+  ++this->type_index_;\n+\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \"<type %d \", index);\n+  this->write_c_string(buf);\n+\n+  if (named_type != NULL || forward != NULL)\n+    {\n+      const Named_object* named_object;\n+      if (named_type != NULL)\n+\t{\n+\t  // The builtin types should have been predefined.\n+\t  gcc_assert(named_type->location() != BUILTINS_LOCATION\n+\t\t     || (named_type->named_object()->package()->name()\n+\t\t\t == \"unsafe\"));\n+\t  named_object = named_type->named_object();\n+\t}\n+      else\n+\tnamed_object = forward->named_object();\n+\n+      const Package* package = named_object->package();\n+\n+      std::string s = \"\\\"\";\n+      if (package != NULL && !Gogo::is_hidden_name(named_object->name()))\n+\t{\n+\t  s += package->unique_prefix();\n+\t  s += '.';\n+\t  s += package->name();\n+\t  s += '.';\n+\t}\n+      s += named_object->name();\n+      s += \"\\\" \";\n+      this->write_string(s);\n+\n+      // We must add a named type to the table now, since the\n+      // definition of the type may refer to the named type via a\n+      // pointer.\n+      this->type_refs_[type] = index;\n+    }\n+\n+  type->export_type(this);\n+\n+  this->write_c_string(\">\");\n+\n+  if (named_type == NULL)\n+    this->type_refs_[type] = index;\n+}\n+\n+// Add the builtin types to the export table.\n+\n+void\n+Export::register_builtin_types(Gogo* gogo)\n+{\n+  this->register_builtin_type(gogo, \"int8\", BUILTIN_INT8);\n+  this->register_builtin_type(gogo, \"int16\", BUILTIN_INT16);\n+  this->register_builtin_type(gogo, \"int32\", BUILTIN_INT32);\n+  this->register_builtin_type(gogo, \"int64\", BUILTIN_INT64);\n+  this->register_builtin_type(gogo, \"uint8\", BUILTIN_UINT8);\n+  this->register_builtin_type(gogo, \"uint16\", BUILTIN_UINT16);\n+  this->register_builtin_type(gogo, \"uint32\", BUILTIN_UINT32);\n+  this->register_builtin_type(gogo, \"uint64\", BUILTIN_UINT64);\n+  this->register_builtin_type(gogo, \"float32\", BUILTIN_FLOAT32);\n+  this->register_builtin_type(gogo, \"float64\", BUILTIN_FLOAT64);\n+  this->register_builtin_type(gogo, \"complex64\", BUILTIN_COMPLEX64);\n+  this->register_builtin_type(gogo, \"complex128\", BUILTIN_COMPLEX128);\n+  this->register_builtin_type(gogo, \"int\", BUILTIN_INT);\n+  this->register_builtin_type(gogo, \"uint\", BUILTIN_UINT);\n+  this->register_builtin_type(gogo, \"uintptr\", BUILTIN_UINTPTR);\n+  this->register_builtin_type(gogo, \"float\", BUILTIN_FLOAT);\n+  this->register_builtin_type(gogo, \"complex\", BUILTIN_COMPLEX);\n+  this->register_builtin_type(gogo, \"bool\", BUILTIN_BOOL);\n+  this->register_builtin_type(gogo, \"string\", BUILTIN_STRING);\n+}\n+\n+// Register one builtin type in the export table.\n+\n+void\n+Export::register_builtin_type(Gogo* gogo, const char* name, Builtin_code code)\n+{\n+  Named_object* named_object = gogo->lookup_global(name);\n+  gcc_assert(named_object != NULL && named_object->is_type());\n+  std::pair<Type_refs::iterator, bool> ins =\n+    this->type_refs_.insert(std::make_pair(named_object->type_value(), code));\n+  gcc_assert(ins.second);\n+\n+  // We also insert the underlying type.  We can see the underlying\n+  // type at least for string and bool.\n+  Type* real_type = named_object->type_value()->real_type();\n+  ins = this->type_refs_.insert(std::make_pair(real_type, code));\n+  gcc_assert(ins.second);\n+}\n+\n+// Class Export::Stream.\n+\n+Export::Stream::Stream()\n+{\n+  this->checksum_ = new sha1_ctx;\n+  memset(this->checksum_, 0, sizeof(sha1_ctx));\n+  sha1_init_ctx(this->checksum_);\n+}\n+\n+Export::Stream::~Stream()\n+{\n+}\n+\n+// Write bytes to the stream.  This keeps a checksum of bytes as they\n+// go by.\n+\n+void\n+Export::Stream::write_and_sum_bytes(const char* bytes, size_t length)\n+{\n+  sha1_process_bytes(bytes, length, this->checksum_);\n+  this->do_write(bytes, length);\n+}\n+\n+// Get the checksum.\n+\n+std::string\n+Export::Stream::checksum()\n+{\n+  // Use a union to provide the required alignment.\n+  union\n+  {\n+    char checksum[Export::v1_checksum_len];\n+    long align;\n+  } u;\n+  sha1_finish_ctx(this->checksum_, u.checksum);\n+  return std::string(u.checksum, Export::v1_checksum_len);\n+}\n+\n+// Write the checksum string to the export data.\n+\n+void\n+Export::Stream::write_checksum(const std::string& s)\n+{\n+  this->do_write(s.data(), s.length());\n+}\n+\n+// Class Stream_to_section.\n+\n+Stream_to_section::Stream_to_section()\n+  : section_(NULL)\n+{\n+}\n+\n+// Write data to a section.\n+\n+void\n+Stream_to_section::do_write(const char* bytes, size_t length)\n+{\n+  section* sec = (section*) this->section_;\n+  if (sec == NULL)\n+    {\n+      gcc_assert(targetm.have_named_sections);\n+\n+      sec = get_section(\".go_export\", SECTION_DEBUG, NULL);\n+      this->section_ = (void*) sec;\n+    }\n+\n+  switch_to_section(sec);\n+  assemble_string(bytes, length);\n+}"}, {"sha": "90c2465a5e5e54923d26c320bd8bc521631ed1a7", "filename": "gcc/go/gofrontend/export.h", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,191 @@\n+// export.h -- Export declarations in Go frontend.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_EXPORT_H\n+#define GO_EXPORT_H\n+\n+struct sha1_ctx;\n+class Gogo;\n+class Import_init;\n+class Bindings;\n+class Type;\n+\n+// Codes used for the builtin types.  These are all negative to make\n+// them easily distinct from the codes assigned by Export::write_type.\n+// Note that these codes may not be changed!  Changing them would\n+// break existing export data.\n+\n+enum Builtin_code\n+{\n+  BUILTIN_INT8 = -1,\n+  BUILTIN_INT16 = -2,\n+  BUILTIN_INT32 = -3,\n+  BUILTIN_INT64 = -4,\n+  BUILTIN_UINT8 = -5,\n+  BUILTIN_UINT16 = -6,\n+  BUILTIN_UINT32 = -7,\n+  BUILTIN_UINT64 = -8,\n+  BUILTIN_FLOAT32 = -9,\n+  BUILTIN_FLOAT64 = -10,\n+  BUILTIN_INT = -11,\n+  BUILTIN_UINT = -12,\n+  BUILTIN_UINTPTR = -13,\n+  BUILTIN_FLOAT = -14,\n+  BUILTIN_BOOL = -15,\n+  BUILTIN_STRING = -16,\n+  BUILTIN_COMPLEX64 = -17,\n+  BUILTIN_COMPLEX128 = -18,\n+  BUILTIN_COMPLEX = -19,\n+\n+  SMALLEST_BUILTIN_CODE = -19\n+};\n+\n+// This class manages exporting Go declarations.  It handles the main\n+// loop of exporting.  A pointer to this class is also passed to the\n+// various specific export implementations.\n+\n+class Export\n+{\n+ public:\n+  // The Stream class is an interface used to output the exported\n+  // information.  The caller should instantiate a child of this\n+  // class.\n+  class Stream\n+  {\n+   public:\n+    Stream();\n+    virtual ~Stream();\n+\n+    // Write a string.\n+    void\n+    write_string(const std::string& s)\n+    { this->write_and_sum_bytes(s.data(), s.length()); }\n+\n+    // Write a nul terminated string.\n+    void\n+    write_c_string(const char* s)\n+    { this->write_and_sum_bytes(s, strlen(s)); }\n+\n+    // Write some bytes.\n+    void\n+    write_bytes(const char* bytes, size_t length)\n+    { this->write_and_sum_bytes(bytes, length); }\n+\n+    // Return the raw bytes of the checksum data.\n+    std::string\n+    checksum();\n+\n+    // Write a checksum string to the stream.  This will be called at\n+    // the end of the other output.\n+    void\n+    write_checksum(const std::string&);\n+\n+   protected:\n+    // This function is called with data to export.  This data must be\n+    // made available as a contiguous stream for the importer.\n+    virtual void\n+    do_write(const char* bytes, size_t length) = 0;\n+\n+  private:\n+    void\n+    write_and_sum_bytes(const char*, size_t);\n+\n+    // The checksum.\n+    sha1_ctx* checksum_;\n+  };\n+\n+  Export(Stream*);\n+\n+  // The magic code for version 1 export data.\n+  static const int v1_magic_len = 4;\n+  static const char v1_magic[v1_magic_len];\n+\n+  // The length of the v1 checksum string.\n+  static const int v1_checksum_len = 20;\n+\n+  // Register the builtin types.\n+  void\n+  register_builtin_types(Gogo*);\n+\n+  // Export the identifiers in BINDINGS which are marked for export.\n+  // The exporting is done via a series of calls to THIS->STREAM_.  If\n+  // is nothing to export, this->stream_->write will not be called.\n+  // UNIQUE_PREFIX is a prefix for all global symbols.\n+  // PACKAGE_PRIORITY is the priority to use for this package.\n+  // IMPORT_INIT_FN is the name of the import initialization function\n+  // for this package; it will be empty if none is needed.\n+  // IMPORTED_INIT_FNS is the list of initialization functions for\n+  // imported packages.\n+  void\n+  export_globals(const std::string& package_name,\n+\t\t const std::string& unique_prefix,\n+\t\t int package_priority,\n+\t\t const std::string& import_init_fn,\n+\t\t const std::set<Import_init>& imported_init_fns,\n+\t\t const Bindings* bindings);\n+\n+  // Write a string to the export stream.\n+  void\n+  write_string(const std::string& s)\n+  { this->stream_->write_string(s); }\n+\n+  // Write a nul terminated string to the export stream.\n+  void\n+  write_c_string(const char* s)\n+  { this->stream_->write_c_string(s); }\n+\n+  // Write some bytes to the export stream.\n+  void\n+  write_bytes(const char* bytes, size_t length)\n+  { this->stream_->write_bytes(bytes, length); }\n+\n+  // Write out a type.  This handles references back to previous\n+  // definitions.\n+  void\n+  write_type(const Type*);\n+\n+ private:\n+  Export(const Export&);\n+  Export& operator=(const Export&);\n+\n+  // Write out the imported initialization functions.\n+  void\n+  write_imported_init_fns(const std::string& package_name, int priority,\n+\t\t\t  const std::string&, const std::set<Import_init>&);\n+\n+  // Register one builtin type.\n+  void\n+  register_builtin_type(Gogo*, const char* name, Builtin_code);\n+\n+  // Mapping from Type objects to a constant index.\n+  typedef Unordered_map(const Type*, int) Type_refs;\n+\n+  // The stream to which we are writing data.\n+  Stream* stream_;\n+  // Type mappings.\n+  Type_refs type_refs_;\n+  // Index number of next type.\n+  int type_index_;\n+};\n+\n+// An export streamer which puts the export stream in a named section.\n+\n+class Stream_to_section : public Export::Stream\n+{\n+ public:\n+  Stream_to_section();\n+\n+ protected:\n+  void\n+  do_write(const char*, size_t);\n+\n+ private:\n+  // The section we are writing to; this is really union section\n+  // defined in output.h.\n+  void* section_;\n+};\n+\n+#endif // !defined(GO_EXPORT_H)"}, {"sha": "f35b3639aafec7c56e25ea8a6dafd164e60fa328", "filename": "gcc/go/gofrontend/expressions.cc", "status": "added", "additions": 12264, "deletions": 0, "changes": 12264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "4d539d43871322ee2b3e56c4d1f8ef6b00e9e16f", "filename": "gcc/go/gofrontend/expressions.h", "status": "added", "additions": 1920, "deletions": 0, "changes": 1920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,1920 @@\n+// expressions.h -- Go frontend expression handling.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_EXPRESSIONS_H\n+#define GO_EXPRESSIONS_H\n+\n+#include <gmp.h>\n+#include <mpfr.h>\n+\n+#include \"operator.h\"\n+\n+class Gogo;\n+class Translate_context;\n+class Traverse;\n+class Type;\n+struct Type_context;\n+class Function_type;\n+class Map_type;\n+class Struct_type;\n+class Struct_field;\n+class Expression_list;\n+class Var_expression;\n+class Temporary_reference_expression;\n+class String_expression;\n+class Binary_expression;\n+class Call_expression;\n+class Func_expression;\n+class Unknown_expression;\n+class Index_expression;\n+class Map_index_expression;\n+class Bound_method_expression;\n+class Field_reference_expression;\n+class Interface_field_reference_expression;\n+class Type_guard_expression;\n+class Receive_expression;\n+class Send_expression;\n+class Named_object;\n+class Export;\n+class Import;\n+class Temporary_statement;\n+class Label;\n+\n+// The base class for all expressions.\n+\n+class Expression\n+{\n+ public:\n+  // The types of expressions.\n+  enum Expression_classification\n+  {\n+    EXPRESSION_ERROR,\n+    EXPRESSION_TYPE,\n+    EXPRESSION_UNARY,\n+    EXPRESSION_BINARY,\n+    EXPRESSION_CONST_REFERENCE,\n+    EXPRESSION_VAR_REFERENCE,\n+    EXPRESSION_TEMPORARY_REFERENCE,\n+    EXPRESSION_SINK,\n+    EXPRESSION_FUNC_REFERENCE,\n+    EXPRESSION_UNKNOWN_REFERENCE,\n+    EXPRESSION_BOOLEAN,\n+    EXPRESSION_STRING,\n+    EXPRESSION_INTEGER,\n+    EXPRESSION_FLOAT,\n+    EXPRESSION_COMPLEX,\n+    EXPRESSION_NIL,\n+    EXPRESSION_IOTA,\n+    EXPRESSION_CALL,\n+    EXPRESSION_CALL_RESULT,\n+    EXPRESSION_BOUND_METHOD,\n+    EXPRESSION_INDEX,\n+    EXPRESSION_ARRAY_INDEX,\n+    EXPRESSION_STRING_INDEX,\n+    EXPRESSION_MAP_INDEX,\n+    EXPRESSION_SELECTOR,\n+    EXPRESSION_FIELD_REFERENCE,\n+    EXPRESSION_INTERFACE_FIELD_REFERENCE,\n+    EXPRESSION_ALLOCATION,\n+    EXPRESSION_MAKE,\n+    EXPRESSION_TYPE_GUARD,\n+    EXPRESSION_CONVERSION,\n+    EXPRESSION_STRUCT_CONSTRUCTION,\n+    EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n+    EXPRESSION_OPEN_ARRAY_CONSTRUCTION,\n+    EXPRESSION_MAP_CONSTRUCTION,\n+    EXPRESSION_COMPOSITE_LITERAL,\n+    EXPRESSION_HEAP_COMPOSITE,\n+    EXPRESSION_RECEIVE,\n+    EXPRESSION_SEND,\n+    EXPRESSION_TYPE_DESCRIPTOR,\n+    EXPRESSION_TYPE_INFO,\n+    EXPRESSION_STRUCT_FIELD_OFFSET,\n+    EXPRESSION_LABEL_ADDR\n+  };\n+\n+  Expression(Expression_classification, source_location);\n+\n+  virtual ~Expression();\n+\n+  // Make an error expression.  This is used when a parse error occurs\n+  // to prevent cascading errors.\n+  static Expression*\n+  make_error(source_location);\n+\n+  // Make an expression which is really a type.  This is used during\n+  // parsing.\n+  static Expression*\n+  make_type(Type*, source_location);\n+\n+  // Make a unary expression.\n+  static Expression*\n+  make_unary(Operator, Expression*, source_location);\n+\n+  // Make a binary expression.\n+  static Expression*\n+  make_binary(Operator, Expression*, Expression*, source_location);\n+\n+  // Make a reference to a constant in an expression.\n+  static Expression*\n+  make_const_reference(Named_object*, source_location);\n+\n+  // Make a reference to a variable in an expression.\n+  static Expression*\n+  make_var_reference(Named_object*, source_location);\n+\n+  // Make a reference to a temporary variable.  Temporary variables\n+  // are always created by a single statement, which is what we use to\n+  // refer to them.\n+  static Expression*\n+  make_temporary_reference(Temporary_statement*, source_location);\n+\n+  // Make a sink expression--a reference to the blank identifier _.\n+  static Expression*\n+  make_sink(source_location);\n+\n+  // Make a reference to a function in an expression.\n+  static Expression*\n+  make_func_reference(Named_object*, Expression* closure, source_location);\n+\n+  // Make a reference to an unknown name.  In a correct program this\n+  // will always be lowered to a real const/var/func reference.\n+  static Expression*\n+  make_unknown_reference(Named_object*, source_location);\n+\n+  // Make a constant bool expression.\n+  static Expression*\n+  make_boolean(bool val, source_location);\n+\n+  // Make a constant string expression.\n+  static Expression*\n+  make_string(const std::string&, source_location);\n+\n+  // Make a constant integer expression.  TYPE should be NULL for an\n+  // abstract type.\n+  static Expression*\n+  make_integer(const mpz_t*, Type*, source_location);\n+\n+  // Make a constant float expression.  TYPE should be NULL for an\n+  // abstract type.\n+  static Expression*\n+  make_float(const mpfr_t*, Type*, source_location);\n+\n+  // Make a constant complex expression.  TYPE should be NULL for an\n+  // abstract type.\n+  static Expression*\n+  make_complex(const mpfr_t* real, const mpfr_t* imag, Type*, source_location);\n+\n+  // Make a nil expression.\n+  static Expression*\n+  make_nil(source_location);\n+\n+  // Make an iota expression.  This is used for the predeclared\n+  // constant iota.\n+  static Expression*\n+  make_iota();\n+\n+  // Make a call expression.\n+  static Call_expression*\n+  make_call(Expression* func, Expression_list* args, bool is_varargs,\n+\t    source_location);\n+\n+  // Make a reference to a specific result of a call expression which\n+  // returns a tuple.\n+  static Expression*\n+  make_call_result(Call_expression*, unsigned int index);\n+\n+  // Make an expression which is a method bound to its first\n+  // parameter.\n+  static Bound_method_expression*\n+  make_bound_method(Expression* object, Expression* method, source_location);\n+\n+  // Make an index or slice expression.  This is a parser expression\n+  // which represents LEFT[START:END].  END may be NULL, meaning an\n+  // index rather than a slice.  At parse time we may not know the\n+  // type of LEFT.  After parsing this is lowered to an array index, a\n+  // string index, or a map index.\n+  static Expression*\n+  make_index(Expression* left, Expression* start, Expression* end,\n+\t     source_location);\n+\n+  // Make an array index expression.  END may be NULL, in which case\n+  // this is an lvalue.\n+  static Expression*\n+  make_array_index(Expression* array, Expression* start, Expression* end,\n+\t\t   source_location);\n+\n+  // Make a string index expression.  END may be NULL.  This is never\n+  // an lvalue.\n+  static Expression*\n+  make_string_index(Expression* string, Expression* start, Expression* end,\n+\t\t    source_location);\n+\n+  // Make a map index expression.  This is an lvalue.\n+  static Map_index_expression*\n+  make_map_index(Expression* map, Expression* val, source_location);\n+\n+  // Make a selector.  This is a parser expression which represents\n+  // LEFT.NAME.  At parse time we may not know the type of the left\n+  // hand side.\n+  static Expression*\n+  make_selector(Expression* left, const std::string& name, source_location);\n+\n+  // Make a reference to a field in a struct.\n+  static Field_reference_expression*\n+  make_field_reference(Expression*, unsigned int field_index, source_location);\n+\n+  // Make a reference to a field of an interface, with an associated\n+  // object.\n+  static Expression*\n+  make_interface_field_reference(Expression*, const std::string&,\n+\t\t\t\t source_location);\n+\n+  // Make an allocation expression.\n+  static Expression*\n+  make_allocation(Type*, source_location);\n+\n+  // Make a call to the builtin function make.\n+  static Expression*\n+  make_make(Type*, Expression_list*, source_location);\n+\n+  // Make a type guard expression.\n+  static Expression*\n+  make_type_guard(Expression*, Type*, source_location);\n+\n+  // Make a type cast expression.\n+  static Expression*\n+  make_cast(Type*, Expression*, source_location);\n+\n+  // Make a composite literal.  The DEPTH parameter is how far down we\n+  // are in a list of composite literals with omitted types.\n+  static Expression*\n+  make_composite_literal(Type*, int depth, bool has_keys, Expression_list*,\n+\t\t\t source_location);\n+\n+  // Make a struct composite literal.\n+  static Expression*\n+  make_struct_composite_literal(Type*, Expression_list*, source_location);\n+\n+  // Make a slice composite literal.\n+  static Expression*\n+  make_slice_composite_literal(Type*, Expression_list*, source_location);\n+\n+  // Take a composite literal and allocate it on the heap.\n+  static Expression*\n+  make_heap_composite(Expression*, source_location);\n+\n+  // Make a receive expression.  VAL is NULL for a unary receive.\n+  static Receive_expression*\n+  make_receive(Expression* channel, source_location);\n+\n+  // Make a send expression.\n+  static Send_expression*\n+  make_send(Expression* channel, Expression* val, source_location);\n+\n+  // Make an expression which evaluates to the type descriptor of a\n+  // type.\n+  static Expression*\n+  make_type_descriptor(Type* type, source_location);\n+\n+  // Make an expression which evaluates to some characteristic of a\n+  // type.  These are only used for type descriptors, so there is no\n+  // location parameter.\n+  enum Type_info\n+    {\n+      // The size of a value of the type.\n+      TYPE_INFO_SIZE,\n+      // The required alignment of a value of the type.\n+      TYPE_INFO_ALIGNMENT,\n+      // The required alignment of a value of the type when used as a\n+      // field in a struct.\n+      TYPE_INFO_FIELD_ALIGNMENT\n+    };\n+\n+  static Expression*\n+  make_type_info(Type* type, Type_info);\n+\n+  // Make an expression which evaluates to the offset of a field in a\n+  // struct.  This is only used for type descriptors, so there is no\n+  // location parameter.\n+  static Expression*\n+  make_struct_field_offset(Struct_type*, const Struct_field*);\n+\n+  // Make an expression which evaluates to the address of an unnamed\n+  // label.\n+  static Expression*\n+  make_label_addr(Label*, source_location);\n+\n+  // Return the expression classification.\n+  Expression_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Return the location of the expression.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return whether this is a constant expression.\n+  bool\n+  is_constant() const\n+  { return this->do_is_constant(); }\n+\n+  // If this is not a constant expression with integral type, return\n+  // false.  If it is one, return true, and set VAL to the value.  VAL\n+  // should already be initialized.  If this returns true, it sets\n+  // *PTYPE to the type of the value, or NULL for an abstract type.\n+  // If IOTA_IS_CONSTANT is true, then an iota expression is assumed\n+  // to have its final value.\n+  bool\n+  integer_constant_value(bool iota_is_constant, mpz_t val, Type** ptype) const;\n+\n+  // If this is not a constant expression with floating point type,\n+  // return false.  If it is one, return true, and set VAL to the\n+  // value.  VAL should already be initialized.  If this returns true,\n+  // it sets *PTYPE to the type of the value, or NULL for an abstract\n+  // type.\n+  bool\n+  float_constant_value(mpfr_t val, Type** ptype) const;\n+\n+  // If this is not a constant expression with complex type, return\n+  // false.  If it is one, return true, and set REAL and IMAG to the\n+  // value.  REAL and IMAG should already be initialized.  If this\n+  // return strue, it sets *PTYPE to the type of the value, or NULL\n+  // for an abstract type.\n+  bool\n+  complex_constant_value(mpfr_t real, mpfr_t imag, Type** ptype) const;\n+\n+  // If this is not a constant expression with string type, return\n+  // false.  If it is one, return true, and set VAL to the value.\n+  bool\n+  string_constant_value(std::string* val) const\n+  { return this->do_string_constant_value(val); }\n+\n+  // This is called by the parser if the value of this expression is\n+  // being discarded.  This issues warnings about computed values\n+  // being unused, and handles send expressions which act differently\n+  // depending upon whether the value is used.\n+  void\n+  discarding_value()\n+  { this->do_discarding_value(); }\n+\n+  // Return whether this is an error expression.\n+  bool\n+  is_error_expression() const\n+  { return this->classification_ == EXPRESSION_ERROR; }\n+\n+  // Return whether this expression really represents a type.\n+  bool\n+  is_type_expression() const\n+  { return this->classification_ == EXPRESSION_TYPE; }\n+\n+  // If this is a variable reference, return the Var_expression\n+  // structure.  Otherwise, return NULL.  This is a controlled dynamic\n+  // cast.\n+  Var_expression*\n+  var_expression()\n+  { return this->convert<Var_expression, EXPRESSION_VAR_REFERENCE>(); }\n+\n+  const Var_expression*\n+  var_expression() const\n+  { return this->convert<const Var_expression, EXPRESSION_VAR_REFERENCE>(); }\n+\n+  // If this is a reference to a temporary variable, return the\n+  // Temporary_reference_expression.  Otherwise, return NULL.\n+  Temporary_reference_expression*\n+  temporary_reference_expression()\n+  {\n+    return this->convert<Temporary_reference_expression,\n+\t\t\t EXPRESSION_TEMPORARY_REFERENCE>();\n+  }\n+\n+  // Return whether this is a sink expression.\n+  bool\n+  is_sink_expression() const\n+  { return this->classification_ == EXPRESSION_SINK; }\n+\n+  // If this is a string expression, return the String_expression\n+  // structure.  Otherwise, return NULL.\n+  String_expression*\n+  string_expression()\n+  { return this->convert<String_expression, EXPRESSION_STRING>(); }\n+\n+  // Return whether this is the expression nil.\n+  bool\n+  is_nil_expression() const\n+  { return this->classification_ == EXPRESSION_NIL; }\n+\n+  // If this is an indirection through a pointer, return the\n+  // expression being pointed through.  Otherwise return this.\n+  Expression*\n+  deref();\n+\n+  // If this is a binary expression, return the Binary_expression\n+  // structure.  Otherwise return NULL.\n+  Binary_expression*\n+  binary_expression()\n+  { return this->convert<Binary_expression, EXPRESSION_BINARY>(); }\n+\n+  // If this is a call expression, return the Call_expression\n+  // structure.  Otherwise, return NULL.  This is a controlled dynamic\n+  // cast.\n+  Call_expression*\n+  call_expression()\n+  { return this->convert<Call_expression, EXPRESSION_CALL>(); }\n+\n+  // If this is an expression which refers to a function, return the\n+  // Func_expression structure.  Otherwise, return NULL.\n+  Func_expression*\n+  func_expression()\n+  { return this->convert<Func_expression, EXPRESSION_FUNC_REFERENCE>(); }\n+\n+  const Func_expression*\n+  func_expression() const\n+  { return this->convert<const Func_expression, EXPRESSION_FUNC_REFERENCE>(); }\n+\n+  // If this is an expression which refers to an unknown name, return\n+  // the Unknown_expression structure.  Otherwise, return NULL.\n+  Unknown_expression*\n+  unknown_expression()\n+  { return this->convert<Unknown_expression, EXPRESSION_UNKNOWN_REFERENCE>(); }\n+\n+  const Unknown_expression*\n+  unknown_expression() const\n+  {\n+    return this->convert<const Unknown_expression,\n+\t\t\t EXPRESSION_UNKNOWN_REFERENCE>();\n+  }\n+\n+  // If this is an index expression, return the Index_expression\n+  // structure.  Otherwise, return NULL.\n+  Index_expression*\n+  index_expression()\n+  { return this->convert<Index_expression, EXPRESSION_INDEX>(); }\n+\n+  // If this is an expression which refers to indexing in a map,\n+  // return the Map_index_expression structure.  Otherwise, return\n+  // NULL.\n+  Map_index_expression*\n+  map_index_expression()\n+  { return this->convert<Map_index_expression, EXPRESSION_MAP_INDEX>(); }\n+\n+  // If this is a bound method expression, return the\n+  // Bound_method_expression structure.  Otherwise, return NULL.\n+  Bound_method_expression*\n+  bound_method_expression()\n+  { return this->convert<Bound_method_expression, EXPRESSION_BOUND_METHOD>(); }\n+\n+  // If this is a reference to a field in a struct, return the\n+  // Field_reference_expression structure.  Otherwise, return NULL.\n+  Field_reference_expression*\n+  field_reference_expression()\n+  {\n+    return this->convert<Field_reference_expression,\n+\t\t\t EXPRESSION_FIELD_REFERENCE>();\n+  }\n+\n+  // If this is a reference to a field in an interface, return the\n+  // Interface_field_reference_expression structure.  Otherwise,\n+  // return NULL.\n+  Interface_field_reference_expression*\n+  interface_field_reference_expression()\n+  {\n+    return this->convert<Interface_field_reference_expression,\n+\t\t\t EXPRESSION_INTERFACE_FIELD_REFERENCE>();\n+  }\n+\n+  // If this is a type guard expression, return the\n+  // Type_guard_expression structure.  Otherwise, return NULL.\n+  Type_guard_expression*\n+  type_guard_expression()\n+  { return this->convert<Type_guard_expression, EXPRESSION_TYPE_GUARD>(); }\n+\n+  // If this is a receive expression, return the Receive_expression\n+  // structure.  Otherwise, return NULL.\n+  Receive_expression*\n+  receive_expression()\n+  { return this->convert<Receive_expression, EXPRESSION_RECEIVE>(); }\n+\n+  // Return true if this is a composite literal.\n+  bool\n+  is_composite_literal() const;\n+\n+  // Return true if this is a composite literal which is not constant.\n+  bool\n+  is_nonconstant_composite_literal() const;\n+\n+  // Return true if this is a reference to a local variable.\n+  bool\n+  is_local_variable() const;\n+\n+  // Traverse an expression.\n+  static int\n+  traverse(Expression**, Traverse*);\n+\n+  // Traverse subexpressions of this expression.\n+  int\n+  traverse_subexpressions(Traverse*);\n+\n+  // Lower an expression.  This is called immediately after parsing.\n+  // IOTA_VALUE is the value that we should give to any iota\n+  // expressions.  This function must resolve expressions which could\n+  // not be fully parsed into their final form.  It returns the same\n+  // Expression or a new one.\n+  Expression*\n+  lower(Gogo* gogo, Named_object* function, int iota_value)\n+  { return this->do_lower(gogo, function, iota_value); }\n+\n+  // Determine the real type of an expression with abstract integer,\n+  // floating point, or complex type.  TYPE_CONTEXT describes the\n+  // expected type.\n+  void\n+  determine_type(const Type_context*);\n+\n+  // Check types in an expression.\n+  void\n+  check_types(Gogo* gogo)\n+  { this->do_check_types(gogo); }\n+\n+  // Determine the type when there is no context.\n+  void\n+  determine_type_no_context();\n+\n+  // Return the current type of the expression.  This may be changed\n+  // by determine_type.\n+  Type*\n+  type()\n+  { return this->do_type(); }\n+\n+  // Return a copy of an expression.\n+  Expression*\n+  copy()\n+  { return this->do_copy(); }\n+\n+  // Return whether the expression is addressable--something which may\n+  // be used as the operand of the unary & operator.\n+  bool\n+  is_addressable() const\n+  { return this->do_is_addressable(); }\n+\n+  // Note that we are taking the address of this expression.  ESCAPES\n+  // is true if this address escapes the current function.\n+  void\n+  address_taken(bool escapes)\n+  { this->do_address_taken(escapes); }\n+\n+  // Return whether this expression must be evaluated in order\n+  // according to the order of evaluation rules.  This is basically\n+  // true of all expressions with side-effects.\n+  bool\n+  must_eval_in_order() const\n+  { return this->do_must_eval_in_order(); }\n+\n+  // Return the tree for this expression.\n+  tree\n+  get_tree(Translate_context*);\n+\n+  // Return a tree handling any conversions which must be done during\n+  // assignment.\n+  static tree\n+  convert_for_assignment(Translate_context*, Type* lhs_type, Type* rhs_type,\n+\t\t\t tree rhs_tree, source_location location);\n+\n+  // Return a tree converting a value of one interface type to another\n+  // interface type.  If FOR_TYPE_GUARD is true this is for a type\n+  // assertion.\n+  static tree\n+  convert_interface_to_interface(Translate_context*, Type* lhs_type,\n+\t\t\t\t Type* rhs_type, tree rhs_tree,\n+\t\t\t\t bool for_type_guard, source_location);\n+\n+  // Return a tree implementing the comparison LHS_TREE OP RHS_TREE.\n+  // TYPE is the type of both sides.\n+  static tree\n+  comparison_tree(Translate_context*, Operator op, Type* left_type,\n+\t\t  tree left_tree, Type* right_type, tree right_tree,\n+\t\t  source_location);\n+\n+  // Return a tree for the multi-precision integer VAL in TYPE.\n+  static tree\n+  integer_constant_tree(mpz_t val, tree type);\n+\n+  // Return a tree for the floating point value VAL in TYPE.\n+  static tree\n+  float_constant_tree(mpfr_t val, tree type);\n+\n+  // Return a tree for the complex value REAL/IMAG in TYPE.\n+  static tree\n+  complex_constant_tree(mpfr_t real, mpfr_t imag, tree type);\n+\n+  // Export the expression.  This is only used for constants.  It will\n+  // be used for things like values of named constants and sizes of\n+  // arrays.\n+  void\n+  export_expression(Export* exp) const\n+  { this->do_export(exp); }\n+\n+  // Import an expression.\n+  static Expression*\n+  import_expression(Import*);\n+\n+  // Return a tree which checks that VAL, of arbitrary integer type,\n+  // is non-negative and is not more than the maximum value of\n+  // BOUND_TYPE.  If SOFAR is not NULL, it is or'red into the result.\n+  // The return value may be NULL if SOFAR is NULL.\n+  static tree\n+  check_bounds(tree val, tree bound_type, tree sofar, source_location);\n+\n+ protected:\n+  // May be implemented by child class: traverse the expressions.\n+  virtual int\n+  do_traverse(Traverse*);\n+\n+  // Return a lowered expression.\n+  virtual Expression*\n+  do_lower(Gogo*, Named_object*, int)\n+  { return this; }\n+\n+  // Return whether this is a constant expression.\n+  virtual bool\n+  do_is_constant() const\n+  { return false; }\n+\n+  // Return whether this is a constant expression of integral type,\n+  // and set VAL to the value.\n+  virtual bool\n+  do_integer_constant_value(bool, mpz_t, Type**) const\n+  { return false; }\n+\n+  // Return whether this is a constant expression of floating point\n+  // type, and set VAL to the value.\n+  virtual bool\n+  do_float_constant_value(mpfr_t, Type**) const\n+  { return false; }\n+\n+  // Return whether this is a constant expression of complex type, and\n+  // set REAL and IMAGE to the value.\n+  virtual bool\n+  do_complex_constant_value(mpfr_t, mpfr_t, Type**) const\n+  { return false; }\n+\n+  // Return whether this is a constant expression of string type, and\n+  // set VAL to the value.\n+  virtual bool\n+  do_string_constant_value(std::string*) const\n+  { return false; }\n+\n+  // Called by the parser if the value is being discarded.\n+  virtual void\n+  do_discarding_value();\n+\n+  // Child class holds type.\n+  virtual Type*\n+  do_type() = 0;\n+\n+  // Child class implements determining type information.\n+  virtual void\n+  do_determine_type(const Type_context*) = 0;\n+\n+  // Child class implements type checking if needed.\n+  virtual void\n+  do_check_types(Gogo*)\n+  { }\n+\n+  // Child class implements copying.\n+  virtual Expression*\n+  do_copy() = 0;\n+\n+  // Child class implements whether the expression is addressable.\n+  virtual bool\n+  do_is_addressable() const\n+  { return false; }\n+\n+  // Child class implements taking the address of an expression.\n+  virtual void\n+  do_address_taken(bool)\n+  { }\n+\n+  // Child class implements whether this expression must be evaluated\n+  // in order.\n+  virtual bool\n+  do_must_eval_in_order() const\n+  { return false; }\n+\n+  // Child class implements conversion to tree.\n+  virtual tree\n+  do_get_tree(Translate_context*) = 0;\n+\n+  // Child class implements export.\n+  virtual void\n+  do_export(Export*) const;\n+\n+  // For children to call to warn about an unused value.\n+  void\n+  warn_about_unused_value();\n+\n+  // For children to call when they detect that they are in error.\n+  void\n+  set_is_error();\n+\n+  // For children to call to report an error conveniently.\n+  void\n+  report_error(const char*);\n+\n+ private:\n+  // Convert to the desired statement classification, or return NULL.\n+  // This is a controlled dynamic cast.\n+  template<typename Expression_class,\n+\t   Expression_classification expr_classification>\n+  Expression_class*\n+  convert()\n+  {\n+    return (this->classification_ == expr_classification\n+\t    ? static_cast<Expression_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  template<typename Expression_class,\n+\t   Expression_classification expr_classification>\n+  const Expression_class*\n+  convert() const\n+  {\n+    return (this->classification_ == expr_classification\n+\t    ? static_cast<const Expression_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  static tree\n+  convert_type_to_interface(Translate_context*, Type*, Type*, tree,\n+\t\t\t    source_location);\n+\n+  static tree\n+  get_interface_type_descriptor(Translate_context*, Type*, tree,\n+\t\t\t\tsource_location);\n+\n+  static tree\n+  convert_interface_to_type(Translate_context*, Type*, Type*, tree,\n+\t\t\t    source_location);\n+\n+  // The expression classification.\n+  Expression_classification classification_;\n+  // The location in the input file.\n+  source_location location_;\n+};\n+\n+// A list of Expressions.\n+\n+class Expression_list\n+{\n+ public:\n+  Expression_list()\n+    : entries_()\n+  { }\n+\n+  // Return whether the list is empty.\n+  bool\n+  empty() const\n+  { return this->entries_.empty(); }\n+\n+  // Return the number of entries in the list.\n+  size_t\n+  size() const\n+  { return this->entries_.size(); }\n+\n+  // Add an entry to the end of the list.\n+  void\n+  push_back(Expression* expr)\n+  { this->entries_.push_back(expr); }\n+\n+  void\n+  append(Expression_list* add)\n+  { this->entries_.insert(this->entries_.end(), add->begin(), add->end()); }\n+\n+  // Reserve space in the list.\n+  void\n+  reserve(size_t size)\n+  { this->entries_.reserve(size); }\n+\n+  // Traverse the expressions in the list.\n+  int\n+  traverse(Traverse*);\n+\n+  // Copy the list.\n+  Expression_list*\n+  copy();\n+\n+  // Return true if the list contains an error expression.\n+  bool\n+  contains_error() const;\n+\n+  // Return the first and last elements.\n+  Expression*&\n+  front()\n+  { return this->entries_.front(); }\n+\n+  Expression*\n+  front() const\n+  { return this->entries_.front(); }\n+\n+  Expression*&\n+  back()\n+  { return this->entries_.back(); }\n+\n+  Expression*\n+  back() const\n+  { return this->entries_.back(); }\n+\n+  // Iterators.\n+\n+  typedef std::vector<Expression*>::iterator iterator;\n+  typedef std::vector<Expression*>::const_iterator const_iterator;\n+\n+  iterator\n+  begin()\n+  { return this->entries_.begin(); }\n+\n+  const_iterator\n+  begin() const\n+  { return this->entries_.begin(); }\n+\n+  iterator\n+  end()\n+  { return this->entries_.end(); }\n+\n+  const_iterator\n+  end() const\n+  { return this->entries_.end(); }\n+\n+  // Erase an entry.\n+  void\n+  erase(iterator p)\n+  { this->entries_.erase(p); }\n+\n+ private:\n+  std::vector<Expression*> entries_;\n+};\n+\n+// An abstract base class for an expression which is only used by the\n+// parser, and is lowered in the lowering pass.\n+\n+class Parser_expression : public Expression\n+{\n+ public:\n+  Parser_expression(Expression_classification classification,\n+\t\t    source_location location)\n+    : Expression(classification, location)\n+  { }\n+\n+ protected:\n+  virtual Expression*\n+  do_lower(Gogo*, Named_object*, int) = 0;\n+\n+  Type*\n+  do_type()\n+  { gcc_unreachable(); }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { gcc_unreachable(); }\n+\n+  void\n+  do_check_types(Gogo*)\n+  { gcc_unreachable(); }\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+};\n+\n+// An expression which is simply a variable.\n+\n+class Var_expression : public Expression\n+{\n+ public:\n+  Var_expression(Named_object* variable, source_location location)\n+    : Expression(EXPRESSION_VAR_REFERENCE, location),\n+      variable_(variable)\n+  { }\n+\n+  // Return the variable.\n+  Named_object*\n+  named_object() const\n+  { return this->variable_; }\n+\n+  // Return the name of the variable.\n+  const std::string&\n+  name() const;\n+\n+ protected:\n+  Expression*\n+  do_lower(Gogo*, Named_object*, int);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  { return this; }\n+\n+  bool\n+  do_is_addressable() const\n+  { return true; }\n+\n+  void\n+  do_address_taken(bool);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The variable we are referencing.\n+  Named_object* variable_;\n+};\n+\n+// A reference to a temporary variable.\n+\n+class Temporary_reference_expression : public Expression\n+{\n+ public:\n+  Temporary_reference_expression(Temporary_statement* statement,\n+\t\t\t\t source_location location)\n+    : Expression(EXPRESSION_TEMPORARY_REFERENCE, location),\n+      statement_(statement)\n+  { }\n+\n+ protected:\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  { return make_temporary_reference(this->statement_, this->location()); }\n+\n+  bool\n+  do_is_addressable() const\n+  { return true; }\n+\n+  void\n+  do_address_taken(bool);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The statement where the temporary variable is defined.\n+  Temporary_statement* statement_;\n+};\n+\n+// A string expression.\n+\n+class String_expression : public Expression\n+{\n+ public:\n+  String_expression(const std::string& val, source_location location)\n+    : Expression(EXPRESSION_STRING, location),\n+      val_(val), type_(NULL)\n+  { }\n+\n+  const std::string&\n+  val() const\n+  { return this->val_; }\n+\n+  static Expression*\n+  do_import(Import*);\n+\n+ protected:\n+  bool\n+  do_is_constant() const\n+  { return true; }\n+\n+  bool\n+  do_string_constant_value(std::string* val) const\n+  {\n+    *val = this->val_;\n+    return true;\n+  }\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  Expression*\n+  do_copy()\n+  { return this; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  // The string value.  This is immutable.\n+  const std::string val_;\n+  // The type as determined by context.\n+  Type* type_;\n+};\n+\n+// A binary expression.\n+\n+class Binary_expression : public Expression\n+{\n+ public:\n+  Binary_expression(Operator op, Expression* left, Expression* right,\n+\t\t    source_location location)\n+    : Expression(EXPRESSION_BINARY, location),\n+      op_(op), left_(left), right_(right)\n+  { }\n+\n+  // Return the operator.\n+  Operator\n+  op()\n+  { return this->op_; }\n+\n+  // Return the left hand expression.\n+  Expression*\n+  left()\n+  { return this->left_; }\n+\n+  // Return the right hand expression.\n+  Expression*\n+  right()\n+  { return this->right_; }\n+\n+  // Apply binary opcode OP to LEFT_VAL and RIGHT_VAL, setting VAL.\n+  // LEFT_TYPE is the type of LEFT_VAL, RIGHT_TYPE is the type of\n+  // RIGHT_VAL; LEFT_TYPE and/or RIGHT_TYPE may be NULL.  Return true\n+  // if this could be done, false if not.\n+  static bool\n+  eval_integer(Operator op, Type* left_type, mpz_t left_val,\n+\t       Type* right_type, mpz_t right_val, source_location,\n+\t       mpz_t val);\n+\n+  // Apply binary opcode OP to LEFT_VAL and RIGHT_VAL, setting VAL.\n+  // Return true if this could be done, false if not.\n+  static bool\n+  eval_float(Operator op, Type* left_type, mpfr_t left_val,\n+\t     Type* right_type, mpfr_t right_val, mpfr_t val,\n+\t     source_location);\n+\n+  // Apply binary opcode OP to LEFT_REAL/LEFT_IMAG and\n+  // RIGHT_REAL/RIGHT_IMAG, setting REAL/IMAG.  Return true if this\n+  // could be done, false if not.\n+  static bool\n+  eval_complex(Operator op, Type* left_type, mpfr_t left_real,\n+\t       mpfr_t left_imag, Type* right_type, mpfr_t right_real,\n+\t       mpfr_t right_imag, mpfr_t real, mpfr_t imag, source_location);\n+\n+  // Compare integer constants according to OP.\n+  static bool\n+  compare_integer(Operator op, mpz_t left_val, mpz_t right_val);\n+\n+  // Compare floating point constants according to OP.\n+  static bool\n+  compare_float(Operator op, Type* type, mpfr_t left_val, mpfr_t right_val);\n+\n+  // Compare complex constants according to OP.\n+  static bool\n+  compare_complex(Operator op, Type* type, mpfr_t left_real, mpfr_t left_imag,\n+\t\t  mpfr_t right_val, mpfr_t right_imag);\n+\n+  static Expression*\n+  do_import(Import*);\n+\n+  // Report an error if OP can not be applied to TYPE.  Return whether\n+  // it can.\n+  static bool\n+  check_operator_type(Operator op, Type* type, source_location);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, int);\n+\n+  bool\n+  do_is_constant() const\n+  { return this->left_->is_constant() && this->right_->is_constant(); }\n+\n+  bool\n+  do_integer_constant_value(bool, mpz_t val, Type**) const;\n+\n+  bool\n+  do_float_constant_value(mpfr_t val, Type**) const;\n+\n+  bool\n+  do_complex_constant_value(mpfr_t real, mpfr_t imag, Type**) const;\n+\n+  void\n+  do_discarding_value();\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_binary(this->op_, this->left_->copy(),\n+\t\t\t\t   this->right_->copy(), this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  // The binary operator to apply.\n+  Operator op_;\n+  // The left hand side operand.\n+  Expression* left_;\n+  // The right hand side operand.\n+  Expression* right_;\n+};\n+\n+// A call expression.  The go statement needs to dig inside this.\n+\n+class Call_expression : public Expression\n+{\n+ public:\n+  Call_expression(Expression* fn, Expression_list* args, bool is_varargs,\n+\t\t  source_location location)\n+    : Expression(EXPRESSION_CALL, location),\n+      fn_(fn), args_(args), type_(NULL), tree_(NULL), is_varargs_(is_varargs),\n+      is_value_discarded_(false), varargs_are_lowered_(false),\n+      is_deferred_(false)\n+  { }\n+\n+  // The function to call.\n+  Expression*\n+  fn() const\n+  { return this->fn_; }\n+\n+  // The arguments.\n+  Expression_list*\n+  args()\n+  { return this->args_; }\n+\n+  const Expression_list*\n+  args() const\n+  { return this->args_; }\n+\n+  // Get the function type.\n+  Function_type*\n+  get_function_type() const;\n+\n+  // Return the number of values this call will return.\n+  size_t\n+  result_count() const;\n+\n+  // Return whether this is a call to the predeclared function\n+  // recover.\n+  bool\n+  is_recover_call() const;\n+\n+  // Set the argument for a call to recover.\n+  void\n+  set_recover_arg(Expression*);\n+\n+  // Whether the last argument is a varargs argument (f(a...)).\n+  bool\n+  is_varargs() const\n+  { return this->is_varargs_; }\n+\n+  // Whether this call is being deferred.\n+  bool\n+  is_deferred() const\n+  { return this->is_deferred_; }\n+\n+  // Note that the call is being deferred.\n+  void\n+  set_is_deferred()\n+  { this->is_deferred_ = true; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  virtual Expression*\n+  do_lower(Gogo*, Named_object*, int);\n+\n+  void\n+  do_discarding_value()\n+  { this->is_value_discarded_ = true; }\n+\n+  virtual Type*\n+  do_type();\n+\n+  virtual void\n+  do_determine_type(const Type_context*);\n+\n+  virtual void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_call(this->fn_->copy(), this->args_->copy(),\n+\t\t\t\t this->is_varargs_, this->location());\n+  }\n+\n+  bool\n+  do_must_eval_in_order() const;\n+\n+  virtual tree\n+  do_get_tree(Translate_context*);\n+\n+  virtual bool\n+  do_is_recover_call() const;\n+\n+  virtual void\n+  do_set_recover_arg(Expression*);\n+\n+  // Let a builtin expression change the argument list.\n+  void\n+  set_args(Expression_list* args)\n+  { this->args_ = args; }\n+\n+  // Let a builtin expression lower varargs.\n+  Expression*\n+  lower_varargs(Gogo*, Named_object* function, Type* varargs_type,\n+\t\tsize_t param_count);\n+\n+ private:\n+  bool\n+  is_compatible_varargs_argument(Named_object*, Expression*, Type*, bool*);\n+\n+  bool\n+  check_argument_type(int, const Type*, const Type*, source_location, bool);\n+\n+  tree\n+  bound_method_function(Translate_context*, Bound_method_expression*, tree*);\n+\n+  tree\n+  interface_method_function(Translate_context*,\n+\t\t\t    Interface_field_reference_expression*,\n+\t\t\t    tree*);\n+\n+  // The function to call.\n+  Expression* fn_;\n+  // The arguments to pass.  This may be NULL if there are no\n+  // arguments.\n+  Expression_list* args_;\n+  // The type of the expression, to avoid recomputing it.\n+  Type* type_;\n+  // The tree for the call, used for a call which returns a tuple.\n+  tree tree_;\n+  // True if the last argument is a varargs argument (f(a...)).\n+  bool is_varargs_;\n+  // True if the value is being discarded.\n+  bool is_value_discarded_;\n+  // True if varargs have already been lowered.\n+  bool varargs_are_lowered_;\n+  // True if the call is an argument to a defer statement.\n+  bool is_deferred_;\n+};\n+\n+// An expression which represents a pointer to a function.\n+\n+class Func_expression : public Expression\n+{\n+ public:\n+  Func_expression(Named_object* function, Expression* closure,\n+\t\t  source_location location)\n+    : Expression(EXPRESSION_FUNC_REFERENCE, location),\n+      function_(function), closure_(closure)\n+  { }\n+\n+  // Return the object associated with the function.\n+  const Named_object*\n+  named_object() const\n+  { return this->function_; }\n+\n+  // Return the name of the function.\n+  const std::string&\n+  name() const;\n+\n+  // Return the closure for this function.  This will return NULL if\n+  // the function has no closure, which is the normal case.\n+  Expression*\n+  closure()\n+  { return this->closure_; }\n+\n+  // Return a tree for this function without evaluating the closure.\n+  tree\n+  get_tree_without_closure(Gogo*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  {\n+    if (this->closure_ != NULL)\n+      this->closure_->determine_type_no_context();\n+  }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_func_reference(this->function_,\n+\t\t\t\t\t   this->closure_->copy(),\n+\t\t\t\t\t   this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The function itself.\n+  Named_object* function_;\n+  // A closure.  This is normally NULL.  For a nested function, it may\n+  // be a heap-allocated struct holding pointers to all the variables\n+  // referenced by this function and defined in enclosing functions.\n+  Expression* closure_;\n+};\n+\n+// A reference to an unknown name.\n+\n+class Unknown_expression : public Parser_expression\n+{\n+ public:\n+  Unknown_expression(Named_object* named_object, source_location location)\n+    : Parser_expression(EXPRESSION_UNKNOWN_REFERENCE, location),\n+      named_object_(named_object), is_composite_literal_key_(false)\n+  { }\n+\n+  // The associated named object.\n+  Named_object*\n+  named_object() const\n+  { return this->named_object_; }\n+\n+  // The name of the identifier which was unknown.\n+  const std::string&\n+  name() const;\n+\n+  // Note that this expression is being used as the key in a composite\n+  // literal, so it may be OK if it is not resolved.\n+  void\n+  set_is_composite_literal_key()\n+  { this->is_composite_literal_key_ = true; }\n+\n+ protected:\n+  Expression*\n+  do_lower(Gogo*, Named_object*, int);\n+\n+  Expression*\n+  do_copy()\n+  { return new Unknown_expression(this->named_object_, this->location()); }\n+\n+ private:\n+  // The unknown name.\n+  Named_object* named_object_;\n+  // True if this is the key in a composite literal.\n+  bool is_composite_literal_key_;\n+};\n+\n+// An index expression.  This is lowered to an array index, a string\n+// index, or a map index.\n+\n+class Index_expression : public Parser_expression\n+{\n+ public:\n+  Index_expression(Expression* left, Expression* start, Expression* end,\n+\t\t   source_location location)\n+    : Parser_expression(EXPRESSION_INDEX, location),\n+      left_(left), start_(start), end_(end), is_lvalue_(false)\n+  { }\n+\n+  // Record that this expression is an lvalue.\n+  void\n+  set_is_lvalue()\n+  { this->is_lvalue_ = true; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, int);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Index_expression(this->left_->copy(), this->start_->copy(),\n+\t\t\t\t(this->end_ == NULL\n+\t\t\t\t ? NULL\n+\t\t\t\t : this->end_->copy()),\n+\t\t\t\tthis->location());\n+  }\n+\n+ private:\n+  // The expression being indexed.\n+  Expression* left_;\n+  // The first index.\n+  Expression* start_;\n+  // The second index.  This is NULL for an index, non-NULL for a\n+  // slice.\n+  Expression* end_;\n+  // Whether this is being used as an l-value.  We set this during the\n+  // parse because map index expressions need to know.\n+  bool is_lvalue_;\n+};\n+\n+// An index into a map.\n+\n+class Map_index_expression : public Expression\n+{\n+ public:\n+  Map_index_expression(Expression* map, Expression* index,\n+\t\t       source_location location)\n+    : Expression(EXPRESSION_MAP_INDEX, location),\n+      map_(map), index_(index), is_lvalue_(false),\n+      is_in_tuple_assignment_(false)\n+  { }\n+\n+  // Return the map.\n+  Expression*\n+  map()\n+  { return this->map_; }\n+\n+  const Expression*\n+  map() const\n+  { return this->map_; }\n+\n+  // Return the index.\n+  Expression*\n+  index()\n+  { return this->index_; }\n+\n+  const Expression*\n+  index() const\n+  { return this->index_; }\n+\n+  // Get the type of the map being indexed.\n+  Map_type*\n+  get_map_type() const;\n+\n+  // Record that this map expression is an lvalue.  The difference is\n+  // that an lvalue always inserts the key.\n+  void\n+  set_is_lvalue()\n+  { this->is_lvalue_ = true; }\n+\n+  // Return whether this map expression occurs in an assignment to a\n+  // pair of values.\n+  bool\n+  is_in_tuple_assignment() const\n+  { return this->is_in_tuple_assignment_; }\n+\n+  // Record that this map expression occurs in an assignment to a pair\n+  // of values.\n+  void\n+  set_is_in_tuple_assignment()\n+  { this->is_in_tuple_assignment_ = true; }\n+\n+  // Return a tree for the map index.  This returns a tree which\n+  // evaluates to a pointer to a value in the map.  If INSERT is true,\n+  // the key will be inserted if not present, and the value pointer\n+  // will be zero initialized.  If INSERT is false, and the key is not\n+  // present in the map, the pointer will be NULL.\n+  tree\n+  get_value_pointer(Translate_context*, bool insert);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_map_index(this->map_->copy(),\n+\t\t\t\t      this->index_->copy(),\n+\t\t\t\t      this->location());\n+  }\n+\n+  // A map index expression is an lvalue but it is not addressable.\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The map we are looking into.\n+  Expression* map_;\n+  // The index.\n+  Expression* index_;\n+  // Whether this is an lvalue.\n+  bool is_lvalue_;\n+  // Whether this is in a tuple assignment to a pair of values.\n+  bool is_in_tuple_assignment_;\n+};\n+\n+// An expression which represents a method bound to its first\n+// argument.\n+\n+class Bound_method_expression : public Expression\n+{\n+ public:\n+  Bound_method_expression(Expression* expr, Expression* method,\n+\t\t\t  source_location location)\n+    : Expression(EXPRESSION_BOUND_METHOD, location),\n+      expr_(expr), expr_type_(NULL), method_(method)\n+  { }\n+\n+  // Return the object which is the first argument.\n+  Expression*\n+  first_argument()\n+  { return this->expr_; }\n+\n+  // Return the implicit type of the first argument.  This will be\n+  // non-NULL when using a method from an anonymous field without\n+  // using an explicit stub.\n+  Type*\n+  first_argument_type() const\n+  { return this->expr_type_; }\n+\n+  // Return the reference to the method function.\n+  Expression*\n+  method()\n+  { return this->method_; }\n+\n+  // Set the implicit type of the expression.\n+  void\n+  set_first_argument_type(Type* type)\n+  { this->expr_type_ = type; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Bound_method_expression(this->expr_->copy(),\n+\t\t\t\t       this->method_->copy(),\n+\t\t\t\t       this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The object used to find the method.  This is passed to the method\n+  // as the first argument.\n+  Expression* expr_;\n+  // The implicit type of the object to pass to the method.  This is\n+  // NULL in the normal case, non-NULL when using a method from an\n+  // anonymous field which does not require a stub.\n+  Type* expr_type_;\n+  // The method itself.  This is a Func_expression.\n+  Expression* method_;\n+};\n+\n+// A reference to a field in a struct.\n+\n+class Field_reference_expression : public Expression\n+{\n+ public:\n+  Field_reference_expression(Expression* expr, unsigned int field_index,\n+\t\t\t     source_location location)\n+    : Expression(EXPRESSION_FIELD_REFERENCE, location),\n+      expr_(expr), field_index_(field_index)\n+  { }\n+\n+  // Return the struct expression.\n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n+  // Return the field index.\n+  unsigned int\n+  field_index() const\n+  { return this->field_index_; }\n+\n+  // Set the struct expression.  This is used when parsing.\n+  void\n+  set_struct_expression(Expression* expr)\n+  {\n+    gcc_assert(this->expr_ == NULL);\n+    this->expr_ = expr;\n+  }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return Expression::traverse(&this->expr_, traverse); }\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { this->expr_->determine_type_no_context(); }\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_field_reference(this->expr_->copy(),\n+\t\t\t\t\t    this->field_index_,\n+\t\t\t\t\t    this->location());\n+  }\n+\n+  bool\n+  do_is_addressable() const\n+  { return this->expr_->is_addressable(); }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The expression we are looking into.  This should have a type of\n+  // struct.\n+  Expression* expr_;\n+  // The zero-based index of the field we are retrieving.\n+  unsigned int field_index_;\n+};\n+\n+// A reference to a field of an interface.\n+\n+class Interface_field_reference_expression : public Expression\n+{\n+ public:\n+  Interface_field_reference_expression(Expression* expr,\n+\t\t\t\t       const std::string& name,\n+\t\t\t\t       source_location location)\n+    : Expression(EXPRESSION_INTERFACE_FIELD_REFERENCE, location),\n+      expr_(expr), name_(name)\n+  { }\n+\n+  // Return the expression for the interface object.\n+  Expression*\n+  expr()\n+  { return this->expr_; }\n+\n+  // Return the name of the method to call.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return a tree for the pointer to the function to call, given a\n+  // tree for the expression.\n+  tree\n+  get_function_tree(Translate_context*, tree);\n+\n+  // Return a tree for the first argument to pass to the interface\n+  // function, given a tree for the expression.  This is the real\n+  // object associated with the interface object.\n+  tree\n+  get_underlying_object_tree(Translate_context*, tree);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_interface_field_reference(this->expr_->copy(),\n+\t\t\t\t\t\t      this->name_,\n+\t\t\t\t\t\t      this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The expression for the interface object.  This should have a type\n+  // of interface or pointer to interface.\n+  Expression* expr_;\n+  // The field we are retrieving--the name of the method.\n+  std::string name_;\n+};\n+\n+// A type guard expression.\n+\n+class Type_guard_expression : public Expression\n+{\n+ public:\n+  Type_guard_expression(Expression* expr, Type* type, source_location location)\n+    : Expression(EXPRESSION_TYPE_GUARD, location),\n+      expr_(expr), type_(type)\n+  { }\n+\n+  // Return the expression to convert.\n+  Expression*\n+  expr()\n+  { return this->expr_; }\n+\n+  // Return the type to which to convert.\n+  Type*\n+  type()\n+  { return this->type_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { this->expr_->determine_type_no_context(); }\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Type_guard_expression(this->expr_->copy(), this->type_,\n+\t\t\t\t     this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The expression to convert.\n+  Expression* expr_;\n+  // The type to which to convert.\n+  Type* type_;\n+};\n+\n+// A receive expression.\n+\n+class Receive_expression : public Expression\n+{\n+ public:\n+  Receive_expression(Expression* channel, source_location location)\n+    : Expression(EXPRESSION_RECEIVE, location),\n+      channel_(channel), is_value_discarded_(false), for_select_(false)\n+  { }\n+\n+  // Return the channel.\n+  Expression*\n+  channel()\n+  { return this->channel_; }\n+\n+  // Note that this is for a select statement.\n+  void\n+  set_for_select()\n+  { this->for_select_ = true; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return Expression::traverse(&this->channel_, traverse); }\n+\n+  void\n+  do_discarding_value()\n+  { this->is_value_discarded_ = true; }\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { this->channel_->determine_type_no_context(); }\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_receive(this->channel_->copy(), this->location());\n+  }\n+\n+  bool\n+  do_must_eval_in_order() const\n+  { return true; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The channel from which we are receiving.\n+  Expression* channel_;\n+  // Whether the value is being discarded.\n+  bool is_value_discarded_;\n+  // Whether this is for a select statement.\n+  bool for_select_;\n+};\n+\n+// A send expression.\n+\n+class Send_expression : public Expression\n+{\n+ public:\n+  Send_expression(Expression* channel, Expression* val,\n+\t\t  source_location location)\n+    : Expression(EXPRESSION_SEND, location),\n+      channel_(channel), val_(val), is_value_discarded_(false),\n+      for_select_(false)\n+  { }\n+\n+  // Note that this is for a select statement.\n+  void\n+  set_for_select()\n+  { this->for_select_ = true; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  void\n+  do_discarding_value()\n+  { this->is_value_discarded_ = true; }\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_send(this->channel_->copy(), this->val_->copy(),\n+\t\t\t\t this->location());\n+  }\n+\n+  bool\n+  do_must_eval_in_order() const\n+  { return true; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The channel on which to send the value.\n+  Expression* channel_;\n+  // The value to send.\n+  Expression* val_;\n+  // Whether the value is being discarded.\n+  bool is_value_discarded_;\n+  // Whether this is for a select statement.\n+  bool for_select_;\n+};\n+\n+#endif // !defined(GO_EXPRESSIONS_H)"}, {"sha": "dd5a4c3f238da3c663c63a2d9106e763007018bd", "filename": "gcc/go/gofrontend/go-dump.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgo-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgo-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-dump.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,53 @@\n+// go-dump.cc -- Go frontend debug dumps.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"go-c.h\"\n+#include \"go-dump.h\"\n+\n+namespace {\n+\n+// The list of dumps.\n+\n+Go_dump* dumps;\n+\n+} // End empty namespace.\n+\n+// Create a new dump.\n+\n+Go_dump::Go_dump(const char* name)\n+  : next_(dumps), name_(name), is_enabled_(false)\n+{\n+  dumps = this;\n+}\n+\n+// Enable a dump by name.\n+\n+bool\n+Go_dump::enable_by_name(const char* name)\n+{\n+  bool is_all = strcmp(name, \"all\") == 0;\n+  bool found = false;\n+  for (Go_dump* p = dumps; p != NULL; p = p->next_)\n+    {\n+      if (is_all || strcmp(name, p->name_) == 0)\n+\t{\n+\t  p->is_enabled_ = true;\n+\t  found = true;\n+\t}\n+    }\n+  return found;\n+}\n+\n+// Enable a dump.  Return 1 if this is a real name, 0 if not.\n+\n+GO_EXTERN_C\n+int\n+go_enable_dump(const char* name)\n+{\n+  return Go_dump::enable_by_name(name) ? 1 : 0;\n+}"}, {"sha": "13639bc1215da87c5340b3bd53d023aa955dab3a", "filename": "gcc/go/gofrontend/go-dump.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgo-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgo-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-dump.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,38 @@\n+// go-dump.h -- Go frontend debug dumps.    -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_DUMP_H\n+#define GO_DUMP_H\n+\n+// This class manages different arguments to -fgo-dump-XXX.  If you\n+// want to create a new dump, create a variable of this type with the\n+// name to use for XXX.  You can then use is_enabled to see whether\n+// the -fgo-dump-XXX option was used on the command line.\n+\n+class Go_dump\n+{\n+ public:\n+  Go_dump(const char* name);\n+\n+  // Whether this dump was enabled.\n+  bool\n+  is_enabled() const\n+  { return this->is_enabled_; }\n+\n+  // Enable a dump by name.  Return true if the dump was found.\n+  static bool\n+  enable_by_name(const char*);\n+\n+ private:\n+  // The next dump.  These are not in any order.\n+  Go_dump* next_;\n+  // The name of this dump.\n+  const char* name_;\n+  // Whether this dump was enabled.\n+  bool is_enabled_;\n+};\n+\n+#endif // !defined(GO_DUMP_H)"}, {"sha": "c756084a1dc999aca6f02f362d12dec523087993", "filename": "gcc/go/gofrontend/go.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,153 @@\n+// go.cc -- Go frontend main file for gcc.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"go-c.h\"\n+\n+#include \"lex.h\"\n+#include \"parse.h\"\n+#include \"gogo.h\"\n+\n+// The unique prefix to use for exported symbols.  This is set during\n+// option processing.\n+\n+static std::string unique_prefix;\n+\n+// The data structures we build to represent the file.\n+static Gogo* gogo;\n+\n+// Create the main IR data structure.\n+\n+GO_EXTERN_C\n+void\n+go_create_gogo(int int_type_size, int float_type_size, int pointer_size)\n+{\n+  gcc_assert(::gogo == NULL);\n+  ::gogo = new Gogo(int_type_size, float_type_size, pointer_size);\n+  if (!unique_prefix.empty())\n+    ::gogo->set_unique_prefix(unique_prefix);\n+}\n+\n+// Set the unique prefix we use for exported symbols.\n+\n+GO_EXTERN_C\n+void\n+go_set_prefix(const char* arg)\n+{\n+  unique_prefix = arg;\n+  for (size_t i = 0; i < unique_prefix.length(); ++i)\n+    {\n+      char c = unique_prefix[i];\n+      if ((c >= 'a' && c <= 'z')\n+\t  || (c >= 'A' && c <= 'Z')\n+\t  || (c >= '0' && c <= '9')\n+\t  || c == '_')\n+\t;\n+      else\n+\tunique_prefix[i] = '_';\n+    }\n+}\n+\n+// Parse the input files.\n+\n+GO_EXTERN_C\n+void\n+go_parse_input_files(const char** filenames, unsigned int filename_count,\n+\t\t     bool only_check_syntax, bool require_return_statement)\n+{\n+  gcc_assert(filename_count > 0);\n+  for (unsigned int i = 0; i < filename_count; ++i)\n+    {\n+      if (i > 0)\n+\t::gogo->clear_file_scope();\n+\n+      const char* filename = filenames[i];\n+      FILE* file;\n+      if (strcmp(filename, \"-\") == 0)\n+\tfile = stdin;\n+      else\n+\t{\n+\t  file = fopen(filename, \"r\");\n+\t  if (file == NULL)\n+\t    fatal_error(\"cannot open %s: %m\", filename);\n+\t}\n+\n+      Lex lexer(filename, file);\n+\n+      Parse parse(&lexer, ::gogo);\n+      parse.program();\n+\n+      if (strcmp(filename, \"-\") != 0)\n+\tfclose(file);\n+    }\n+\n+  ::gogo->clear_file_scope();\n+\n+  // If the global predeclared names are referenced but not defined,\n+  // define them now.\n+  ::gogo->define_global_names();\n+\n+  // Finalize method lists and build stub methods for named types.\n+  ::gogo->finalize_methods();\n+\n+  // Now that we have seen all the names, lower the parse tree into a\n+  // form which is easier to use.\n+  ::gogo->lower_parse_tree();\n+\n+  // Now that we have seen all the names, verify that types are\n+  // correct.\n+  ::gogo->verify_types();\n+\n+  // Work out types of unspecified constants and variables.\n+  ::gogo->determine_types();\n+\n+  // Check types and issue errors as appropriate.\n+  ::gogo->check_types();\n+\n+  if (only_check_syntax)\n+    return;\n+\n+  // Check that functions have return statements.\n+  if (require_return_statement)\n+    ::gogo->check_return_statements();\n+\n+  // Export global identifiers as appropriate.\n+  ::gogo->do_exports();\n+\n+  // Build required interface method tables.\n+  ::gogo->build_interface_method_tables();\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  ::gogo->remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  ::gogo->order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  ::gogo->build_recover_thunks();\n+\n+  // Convert complicated go and defer statements into simpler ones.\n+  ::gogo->simplify_thunk_statements();\n+}\n+\n+// Write out globals.\n+\n+GO_EXTERN_C\n+void\n+go_write_globals()\n+{\n+  return ::gogo->write_globals();\n+}\n+\n+// Return the global IR structure.  This is used by some of the\n+// langhooks to pass to other code.\n+\n+Gogo*\n+go_get_gogo()\n+{\n+  return ::gogo;\n+}"}, {"sha": "755a0e9c78467951dc7ebc3014b19e7af32f0ecf", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "added", "additions": 3105, "deletions": 0, "changes": 3105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "0216d6c6b098bd68794c5d0b2e9c698cbf7d877b", "filename": "gcc/go/gofrontend/gogo.cc", "status": "added", "additions": 4274, "deletions": 0, "changes": 4274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d0cfa1e90e08f23d11452bb2c938504e8f69eaa5", "filename": "gcc/go/gofrontend/gogo.h", "status": "added", "additions": 2484, "deletions": 0, "changes": 2484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,2484 @@\n+// gogo.h -- Go frontend parsed representation.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_GOGO_H\n+#define GO_GOGO_H\n+\n+class Traverse;\n+class Type;\n+class Type_hash_identical;\n+class Type_equal;\n+class Type_identical;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Expression;\n+class Statement;\n+class Block;\n+class Function;\n+class Bindings;\n+class Package;\n+class Variable;\n+class Pointer_type;\n+class Struct_type;\n+class Struct_field;\n+class Struct_field_list;\n+class Array_type;\n+class Map_type;\n+class Channel_type;\n+class Interface_type;\n+class Named_type;\n+class Forward_declaration_type;\n+class Method;\n+class Methods;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Export;\n+class Import;\n+\n+// This file declares the basic classes used to hold the internal\n+// representation of Go which is built by the parser.\n+\n+// An initialization function for an imported package.  This is a\n+// magic function which initializes variables and runs the \"init\"\n+// function.\n+\n+class Import_init\n+{\n+ public:\n+  Import_init(const std::string& package_name, const std::string& init_name,\n+\t      int priority)\n+    : package_name_(package_name), init_name_(init_name), priority_(priority)\n+  { }\n+\n+  // The name of the package being imported.\n+  const std::string&\n+  package_name() const\n+  { return this->package_name_; }\n+\n+  // The name of the package's init function.\n+  const std::string&\n+  init_name() const\n+  { return this->init_name_; }\n+\n+  // The priority of the initialization function.  Functions with a\n+  // lower priority number must be run first.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+ private:\n+  // The name of the package being imported.\n+  std::string package_name_;\n+  // The name of the package's init function.\n+  std::string init_name_;\n+  // The priority.\n+  int priority_;\n+};\n+\n+// For sorting purposes.\n+\n+inline bool\n+operator<(const Import_init& i1, const Import_init& i2)\n+{\n+  if (i1.priority() < i2.priority())\n+    return true;\n+  if (i1.priority() > i2.priority())\n+    return false;\n+  if (i1.package_name() != i2.package_name())\n+    return i1.package_name() < i2.package_name();\n+  return i1.init_name() < i2.init_name();\n+}\n+\n+// The holder for the internal representation of the entire\n+// compilation unit.\n+\n+class Gogo\n+{\n+ public:\n+  // Create the IR, passing in the sizes of the types \"int\", \"float\",\n+  // and \"uintptr\" in bits.\n+  Gogo(int int_type_size, int float_type_size, int pointer_size);\n+\n+  // Get the package name.\n+  const std::string&\n+  package_name() const;\n+\n+  // Set the package name.\n+  void\n+  set_package_name(const std::string&, source_location);\n+\n+  // If necessary, adjust the name to use for a hidden symbol.  We add\n+  // a prefix of the package name, so that hidden symbols in different\n+  // packages do not collide.\n+  std::string\n+  pack_hidden_name(const std::string& name, bool is_exported) const\n+  {\n+    return (is_exported\n+\t    ? name\n+\t    : ('.' + this->unique_prefix()\n+\t       + '.' + this->package_name()\n+\t       + '.' + name));\n+  }\n+\n+  // Unpack a name which may have been hidden.  Returns the\n+  // user-visible name of the object.\n+  static std::string\n+  unpack_hidden_name(const std::string& name)\n+  { return name[0] != '.' ? name : name.substr(name.rfind('.') + 1); }\n+\n+  // Return whether a possibly packed name is hidden.\n+  static bool\n+  is_hidden_name(const std::string& name)\n+  { return name[0] == '.'; }\n+\n+  // Return the package prefix of a hidden name.\n+  static std::string\n+  hidden_name_prefix(const std::string& name)\n+  {\n+    gcc_assert(Gogo::is_hidden_name(name));\n+    return name.substr(1, name.rfind('.') - 1);\n+  }\n+\n+  // Given a name which may or may not have been hidden, return the\n+  // name to use in an error message.\n+  static std::string\n+  message_name(const std::string& name);\n+\n+  // Return whether a name is the blank identifier _.\n+  static bool\n+  is_sink_name(const std::string& name)\n+  {\n+    return (name[0] == '.'\n+\t    && name[name.length() - 1] == '_'\n+\t    && name[name.length() - 2] == '.');\n+  }\n+\n+  // Return the unique prefix to use for all exported symbols.\n+  const std::string&\n+  unique_prefix() const;\n+\n+  // Set the unique prefix.\n+  void\n+  set_unique_prefix(const std::string&);\n+\n+  // Return the priority to use for the package we are compiling.\n+  // This is two more than the largest priority of any package we\n+  // import.\n+  int\n+  package_priority() const;\n+\n+  // Import a package.  FILENAME is the file name argument, LOCAL_NAME\n+  // is the local name to give to the package.  If LOCAL_NAME is empty\n+  // the declarations are added to the global scope.\n+  void\n+  import_package(const std::string& filename, const std::string& local_name,\n+\t\t bool is_local_name_exported, source_location);\n+\n+  // Whether we are the global binding level.\n+  bool\n+  in_global_scope() const;\n+\n+  // Look up a name in the current binding contours.\n+  Named_object*\n+  lookup(const std::string&, Named_object** pfunction) const;\n+\n+  // Look up a name in the current block.\n+  Named_object*\n+  lookup_in_block(const std::string&) const;\n+\n+  // Look up a name in the global namespace--the universal scope.\n+  Named_object*\n+  lookup_global(const char*) const;\n+\n+  // Add a new imported package.  REAL_NAME is the real name of the\n+  // package.  ALIAS is the alias of the package; this may be the same\n+  // as REAL_NAME.  This sets *PADD_TO_GLOBALS if symbols added to\n+  // this package should be added to the global namespace; this is\n+  // true if the alias is \".\".  LOCATION is the location of the import\n+  // statement.  This returns the new package, or NULL on error.\n+  Package*\n+  add_imported_package(const std::string& real_name, const std::string& alias,\n+\t\t       bool is_alias_exported,\n+\t\t       const std::string& unique_prefix,\n+\t\t       source_location location,\n+\t\t       bool* padd_to_globals);\n+\n+  // Register a package.  This package may or may not be imported.\n+  // This returns the Package structure for the package, creating if\n+  // it necessary.\n+  Package*\n+  register_package(const std::string& name, const std::string& unique_prefix,\n+\t\t   source_location);\n+\n+  // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a\n+  // method function should be added to the type of its receiver.\n+  Named_object*\n+  start_function(const std::string& name, Function_type* type,\n+\t\t bool add_method_to_type, source_location);\n+\n+  // Finish compiling a function.\n+  void\n+  finish_function(source_location);\n+\n+  // Return the current function.\n+  Named_object*\n+  current_function() const;\n+\n+  // Start a new block.  This is not initially associated with a\n+  // function.\n+  void\n+  start_block(source_location);\n+\n+  // Finish the current block and return it.\n+  Block*\n+  finish_block(source_location);\n+\n+  // Declare an unknown name.  This is used while parsing.  The name\n+  // must be resolved by the end of the parse.  Unknown names are\n+  // always added at the package level.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location);\n+\n+  // Declare a function.\n+  Named_object*\n+  declare_function(const std::string&, Function_type*, source_location);\n+\n+  // Add a label.\n+  Label*\n+  add_label_definition(const std::string&, source_location);\n+\n+  // Add a label reference.\n+  Label*\n+  add_label_reference(const std::string&);\n+\n+  // Add a statement to the current block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a block to the current block.\n+  void\n+  add_block(Block*, source_location);\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier&, Expression*, int iota_value);\n+\n+  // Add a type.\n+  void\n+  add_type(const std::string&, Type*, source_location);\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  void\n+  add_named_type(Named_type*);\n+\n+  // Declare a type.\n+  Named_object*\n+  declare_type(const std::string&, source_location);\n+\n+  // Declare a type at the package level.  This is used when the\n+  // parser sees an unknown name where a type name is required.\n+  Named_object*\n+  declare_package_type(const std::string&, source_location);\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string&, Variable*);\n+\n+  // Add a sink--a reference to the blank identifier _.\n+  Named_object*\n+  add_sink();\n+\n+  // Add a named object to the current namespace.  This is used for\n+  // import . \"package\".\n+  void\n+  add_named_object(Named_object*);\n+\n+  // Return a name to use for a thunk function.  A thunk function is\n+  // one we create during the compilation, for a go statement or a\n+  // defer statement or a method expression.\n+  static std::string\n+  thunk_name();\n+\n+  // Return whether an object is a thunk.\n+  static bool\n+  is_thunk(const Named_object*);\n+\n+  // Note that we've seen an interface type.  This is used to build\n+  // all required interface method tables.\n+  void\n+  record_interface_type(Interface_type*);\n+\n+  // Clear out all names in file scope.  This is called when we start\n+  // parsing a new file.\n+  void\n+  clear_file_scope();\n+\n+  // Traverse the tree.  See the Traverse class.\n+  void\n+  traverse(Traverse*);\n+\n+  // Define the predeclared global names.\n+  void\n+  define_global_names();\n+\n+  // Verify and complete all types.\n+  void\n+  verify_types();\n+\n+  // Lower the parse tree.\n+  void\n+  lower_parse_tree();\n+\n+  // Lower an expression.\n+  void\n+  lower_expression(Named_object* function, Expression**);\n+\n+  // Lower a constant.\n+  void\n+  lower_constant(Named_object*);\n+\n+  // Finalize the method lists and build stub methods for named types.\n+  void\n+  finalize_methods();\n+\n+  // Work out the types to use for unspecified variables and\n+  // constants.\n+  void\n+  determine_types();\n+\n+  // Type check the program.\n+  void\n+  check_types();\n+\n+  // Check the types in a single block.  This is used for complicated\n+  // go statements.\n+  void\n+  check_types_in_block(Block*);\n+\n+  // Check for return statements.\n+  void\n+  check_return_statements();\n+\n+  // Do all exports.\n+  void\n+  do_exports();\n+\n+  // Add an import control function for an imported package to the\n+  // list.\n+  void\n+  add_import_init_fn(const std::string& package_name,\n+\t\t     const std::string& init_name, int prio);\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  void\n+  remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  void\n+  order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  void\n+  build_recover_thunks();\n+\n+  // Simplify statements which might use thunks: go and defer\n+  // statements.\n+  void\n+  simplify_thunk_statements();\n+\n+  // Write out the global values.\n+  void\n+  write_globals();\n+\n+  // Build a call to a builtin function.  PDECL should point to a NULL\n+  // initialized static pointer which will hold the fndecl.  NAME is\n+  // the name of the function.  NARGS is the number of arguments.\n+  // RETTYPE is the return type.  It is followed by NARGS pairs of\n+  // type and argument (both trees).\n+  static tree\n+  call_builtin(tree* pdecl, source_location, const char* name, int nargs,\n+\t       tree rettype, ...);\n+\n+  // Build a call to the runtime error function.\n+  static tree\n+  runtime_error(int code, source_location);\n+\n+  // Build a builtin struct with a list of fields.\n+  static tree\n+  builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n+\t\t int nfields, ...);\n+\n+  // Mark a function declaration as a builtin library function.\n+  static void\n+  mark_fndecl_as_builtin_library(tree fndecl);\n+\n+  // Build the type of the struct that holds a slice for the given\n+  // element type.\n+  tree\n+  slice_type_tree(tree element_type_tree);\n+\n+  // Given a tree for a slice type, return the tree for the element\n+  // type.\n+  static tree\n+  slice_element_type_tree(tree slice_type_tree);\n+\n+  // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n+  // the slice.  VALUES points to the values.  COUNT is the size,\n+  // CAPACITY is the capacity.  If CAPACITY is NULL, it is set to\n+  // COUNT.\n+  static tree\n+  slice_constructor(tree slice_type_tree, tree values, tree count,\n+\t\t    tree capacity);\n+\n+  // Build a constructor for an empty slice.  SLICE_TYPE_TREE is the\n+  // type of the slice.\n+  static tree\n+  empty_slice_constructor(tree slice_type_tree);\n+\n+  // Build a map descriptor.\n+  tree\n+  map_descriptor(Map_type*);\n+\n+  // Return a tree for the type of a map descriptor.  This is struct\n+  // __go_map_descriptor in libgo/runtime/map.h.  This is the same for\n+  // all map types.\n+  tree\n+  map_descriptor_type();\n+\n+  // Build a type descriptor for TYPE using INITIALIZER as the type\n+  // descriptor.  This builds a new decl stored in *PDECL.\n+  void\n+  build_type_descriptor_decl(const Type*, Expression* initializer,\n+\t\t\t     tree* pdecl);\n+\n+  // Build required interface method tables.\n+  void\n+  build_interface_method_tables();\n+\n+  // Build an interface method table for a type: a list of function\n+  // pointers, one for each interface method.  This returns a decl.\n+  tree\n+  interface_method_table_for_type(const Interface_type*, Named_type*,\n+\t\t\t\t  bool is_pointer);\n+\n+  // Return a tree which allocate SIZE bytes to hold values of type\n+  // TYPE.\n+  tree\n+  allocate_memory(Type *type, tree size, source_location);\n+\n+  // Return a type to use for pointer to const char.\n+  static tree\n+  const_char_pointer_type_tree();\n+\n+  // Build a string constant with the right type.\n+  static tree\n+  string_constant_tree(const std::string&);\n+\n+  // Build a Go string constant.  This returns a pointer to the\n+  // constant.\n+  tree\n+  go_string_constant_tree(const std::string&);\n+\n+  // Send a value on a channel.\n+  static tree\n+  send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n+\t\t  source_location);\n+\n+  // Receive a value from a channel.\n+  static tree\n+  receive_from_channel(tree type_tree, tree channel, bool for_select,\n+\t\t       source_location);\n+\n+  // Return a tree for receiving an integer on a channel.\n+  static tree\n+  receive_as_64bit_integer(tree type, tree channel, bool blocking,\n+\t\t\t   bool for_select);\n+\n+\n+  // Make a trampoline which calls FNADDR passing CLOSURE.\n+  tree\n+  make_trampoline(tree fnaddr, tree closure, source_location);\n+\n+ private:\n+  // During parsing, we keep a stack of functions.  Each function on\n+  // the stack is one that we are currently parsing.  For each\n+  // function, we keep track of the current stack of blocks.\n+  struct Open_function\n+  {\n+    // The function.\n+    Named_object* function;\n+    // The stack of active blocks in the function.\n+    std::vector<Block*> blocks;\n+  };\n+\n+  // The stack of functions.\n+  typedef std::vector<Open_function> Open_functions;\n+\n+  // Create trees for implicit builtin functions.\n+  void\n+  define_builtin_function_trees();\n+\n+  // Set up the built-in unsafe package.\n+  void\n+  import_unsafe(const std::string&, bool is_exported, source_location);\n+\n+  // Add a new imported package.\n+  Named_object*\n+  add_package(const std::string& real_name, const std::string& alias,\n+\t      const std::string& unique_prefix, source_location location);\n+\n+  // Return the current binding contour.\n+  Bindings*\n+  current_bindings();\n+\n+  const Bindings*\n+  current_bindings() const;\n+\n+  // Return the current block.\n+  Block*\n+  current_block();\n+\n+  // Get the name of the magic initialization function.\n+  const std::string&\n+  get_init_fn_name();\n+\n+  // Get the decl for the magic initialization function.\n+  tree\n+  initialization_function_decl();\n+\n+  // Write the magic initialization function.\n+  void\n+  write_initialization_function(tree fndecl, tree init_stmt_list);\n+\n+  // Initialize imported packages.\n+  void\n+  init_imports(tree*);\n+\n+  // Register variables with the garbage collector.\n+  void\n+  register_gc_vars(const std::vector<Named_object*>&, tree*);\n+\n+  // Build a pointer to a Go string constant.  This returns a pointer\n+  // to the pointer.\n+  tree\n+  ptr_go_string_constant_tree(const std::string&);\n+\n+  // Return the name to use for a type descriptor decl for an unnamed\n+  // type.\n+  std::string\n+  unnamed_type_descriptor_decl_name(const Type* type);\n+\n+  // Return the name to use for a type descriptor decl for a type\n+  // named NO, defined in IN_FUNCTION.\n+  std::string\n+  type_descriptor_decl_name(const Named_object* no,\n+\t\t\t    const Named_object* in_function);\n+\n+  // Where a type descriptor should be defined.\n+  enum Type_descriptor_location\n+    {\n+      // Defined in this file.\n+      TYPE_DESCRIPTOR_DEFINED,\n+      // Defined in some other file.\n+      TYPE_DESCRIPTOR_UNDEFINED,\n+      // Common definition which may occur in multiple files.\n+      TYPE_DESCRIPTOR_COMMON\n+    };\n+\n+  // Return where the decl for TYPE should be defined.\n+  Type_descriptor_location\n+  type_descriptor_location(const Type* type);\n+\n+  // Return the type of a trampoline.\n+  static tree\n+  trampoline_type_tree();\n+\n+  // Type used to map import names to packages.\n+  typedef std::map<std::string, Package*> Imports;\n+\n+  // Type used to map package names to packages.\n+  typedef std::map<std::string, Package*> Packages;\n+\n+  // Type used to map special names in the sys package.\n+  typedef std::map<std::string, std::string> Sys_names;\n+\n+  // Hash table mapping map types to map descriptor decls.\n+  typedef Unordered_map_hash(const Map_type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Map_descriptors;\n+\n+  // Map unnamed types to type descriptor decls.\n+  typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Type_descriptor_decls;\n+\n+  // The package we are compiling.\n+  Package* package_;\n+  // The list of currently open functions during parsing.\n+  Open_functions functions_;\n+  // The global binding contour.  This includes the builtin functions\n+  // and the package we are compiling.\n+  Bindings* globals_;\n+  // Mapping from import file names to packages.\n+  Imports imports_;\n+  // Whether the magic unsafe package was imported.\n+  bool imported_unsafe_;\n+  // Mapping from package names we have seen to packages.  This does\n+  // not include the package we are compiling.\n+  Packages packages_;\n+  // Mapping from map types to map descriptors.\n+  Map_descriptors* map_descriptors_;\n+  // Mapping from unnamed types to type descriptor decls.\n+  Type_descriptor_decls* type_descriptor_decls_;\n+  // The functions named \"init\", if there are any.\n+  std::vector<Named_object*> init_functions_;\n+  // Whether we need a magic initialization function.\n+  bool need_init_fn_;\n+  // The name of the magic initialization function.\n+  std::string init_fn_name_;\n+  // A list of import control variables for packages that we import.\n+  std::set<Import_init> imported_init_fns_;\n+  // The unique prefix used for all global symbols.\n+  std::string unique_prefix_;\n+  // A list of interface types defined while parsing.\n+  std::vector<Interface_type*> interface_types_;\n+};\n+\n+// A block of statements.\n+\n+class Block\n+{\n+ public:\n+  Block(Block* enclosing, source_location);\n+\n+  // Return the enclosing block.\n+  const Block*\n+  enclosing() const\n+  { return this->enclosing_; }\n+\n+  // Return the bindings of the block.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  const Bindings*\n+  bindings() const\n+  { return this->bindings_; }\n+\n+  // Look at the block's statements.\n+  const std::vector<Statement*>*\n+  statements() const\n+  { return &this->statements_; }\n+\n+  // Return the start location.  This is normally the location of the\n+  // left curly brace which starts the block.\n+  source_location\n+  start_location() const\n+  { return this->start_location_; }\n+\n+  // Return the end location.  This is normally the location of the\n+  // right curly brace which ends the block.\n+  source_location\n+  end_location() const\n+  { return this->end_location_; }\n+\n+  // Add a statement to the block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a statement to the front of the block.\n+  void\n+  add_statement_at_front(Statement*);\n+\n+  // Replace a statement in a block.\n+  void\n+  replace_statement(size_t index, Statement*);\n+\n+  // Add a Statement before statement number INDEX.\n+  void\n+  insert_statement_before(size_t index, Statement*);\n+\n+  // Add a Statement after statement number INDEX.\n+  void\n+  insert_statement_after(size_t index, Statement*);\n+\n+  // Set the end location of the block.\n+  void\n+  set_end_location(source_location location)\n+  { this->end_location_ = location; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Set final types for unspecified variables and constants.\n+  void\n+  determine_types();\n+\n+  // Return true if execution of this block may fall through to the\n+  // next block.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return a tree of the code in this block.\n+  tree\n+  get_tree(Translate_context*);\n+\n+  // Iterate over statements.\n+\n+  typedef std::vector<Statement*>::iterator iterator;\n+\n+  iterator\n+  begin()\n+  { return this->statements_.begin(); }\n+\n+  iterator\n+  end()\n+  { return this->statements_.end(); }\n+\n+ private:\n+  // Enclosing block.\n+  Block* enclosing_;\n+  // Statements in the block.\n+  std::vector<Statement*> statements_;\n+  // Binding contour.\n+  Bindings* bindings_;\n+  // Location of start of block.\n+  source_location start_location_;\n+  // Location of end of block.\n+  source_location end_location_;\n+};\n+\n+// A function.\n+\n+class Function\n+{\n+ public:\n+  Function(Function_type* type, Function*, Block*, source_location);\n+\n+  // Return the function's type.\n+  Function_type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Return the enclosing function if there is one.\n+  Function*\n+  enclosing()\n+  { return this->enclosing_; }\n+\n+  // Set the enclosing function.  This is used when building thunks\n+  // for functions which call recover.\n+  void\n+  set_enclosing(Function* enclosing)\n+  {\n+    gcc_assert(this->enclosing_ == NULL);\n+    this->enclosing_ = enclosing;\n+  }\n+\n+  // Create the named result variables in the outer block.\n+  void\n+  create_named_result_variables();\n+\n+  // Add a new field to the closure variable.\n+  void\n+  add_closure_field(Named_object* var, source_location loc)\n+  { this->closure_fields_.push_back(std::make_pair(var, loc)); }\n+\n+  // Whether this function needs a closure.\n+  bool\n+  needs_closure() const\n+  { return !this->closure_fields_.empty(); }\n+\n+  // Return the closure variable, creating it if necessary.  This is\n+  // passed to the function as a static chain parameter.\n+  Named_object*\n+  closure_var();\n+\n+  // Set the closure variable.  This is used when building thunks for\n+  // functions which call recover.\n+  void\n+  set_closure_var(Named_object* v)\n+  {\n+    gcc_assert(this->closure_var_ == NULL);\n+    this->closure_var_ = v;\n+  }\n+\n+  // Return the variable for a reference to field INDEX in the closure\n+  // variable.\n+  Named_object*\n+  enclosing_var(unsigned int index)\n+  {\n+    gcc_assert(index < this->closure_fields_.size());\n+    return closure_fields_[index].first;\n+  }\n+\n+  // Set the type of the closure variable if there is one.\n+  void\n+  set_closure_type();\n+\n+  // Get the block of statements associated with the function.\n+  Block*\n+  block() const\n+  { return this->block_; }\n+\n+  // Get the location of the start of the function.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return whether this function is actually a method.\n+  bool\n+  is_method() const;\n+\n+  // Add a label definition to the function.\n+  Label*\n+  add_label_definition(const std::string& label_name, source_location);\n+\n+  // Add a label reference to a function.\n+  Label*\n+  add_label_reference(const std::string& label_name);\n+\n+  // Whether this function calls the predeclared recover function.\n+  bool\n+  calls_recover() const\n+  { return this->calls_recover_; }\n+\n+  // Record that this function calls the predeclared recover function.\n+  // This is set during the lowering pass.\n+  void\n+  set_calls_recover()\n+  { this->calls_recover_ = true; }\n+\n+  // Whether this is a recover thunk function.\n+  bool\n+  is_recover_thunk() const\n+  { return this->is_recover_thunk_; }\n+\n+  // Record that this is a thunk built for a function which calls\n+  // recover.\n+  void\n+  set_is_recover_thunk()\n+  { this->is_recover_thunk_ = true; }\n+\n+  // Whether this function already has a recover thunk.\n+  bool\n+  has_recover_thunk() const\n+  { return this->has_recover_thunk_; }\n+\n+  // Record that this function already has a recover thunk.\n+  void\n+  set_has_recover_thunk()\n+  { this->has_recover_thunk_ = true; }\n+\n+  // Swap with another function.  Used only for the thunk which calls\n+  // recover.\n+  void\n+  swap_for_recover(Function *);\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Determine types in the function.\n+  void\n+  determine_types();\n+\n+  // Return the function's decl given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Return the function's decl after it has been built.\n+  tree\n+  get_decl() const\n+  {\n+    gcc_assert(this->fndecl_ != NULL);\n+    return this->fndecl_;\n+  }\n+\n+  // Set the function decl to hold a tree of the function code.\n+  void\n+  build_tree(Gogo*, Named_object*);\n+\n+  // Get the value to return when not explicitly specified.  May also\n+  // add statements to execute first to STMT_LIST.\n+  tree\n+  return_value(Gogo*, Named_object*, source_location, tree* stmt_list) const;\n+\n+  // Get a tree for the variable holding the defer stack.\n+  tree\n+  defer_stack(source_location);\n+\n+  // Export the function.\n+  void\n+  export_func(Export*, const std::string& name) const;\n+\n+  // Export a function with a type.\n+  static void\n+  export_func_with_type(Export*, const std::string& name,\n+\t\t\tconst Function_type*);\n+\n+  // Import a function.\n+  static void\n+  import_func(Import*, std::string* pname, Typed_identifier** receiver,\n+\t      Typed_identifier_list** pparameters,\n+\t      Typed_identifier_list** presults, bool* is_varargs);\n+\n+ private:\n+  // Type for mapping from label names to Label objects.\n+  typedef Unordered_map(std::string, Label*) Labels;\n+\n+  tree\n+  make_receiver_parm_decl(Gogo*, Named_object*, tree);\n+\n+  tree\n+  copy_parm_to_heap(Gogo*, Named_object*, tree);\n+\n+  void\n+  build_defer_wrapper(Gogo*, Named_object*, tree*, tree*);\n+\n+  typedef std::vector<Named_object*> Named_results;\n+\n+  typedef std::vector<std::pair<Named_object*,\n+\t\t\t\tsource_location> > Closure_fields;\n+\n+  // The function's type.\n+  Function_type* type_;\n+  // The enclosing function.  This is NULL when there isn't one, which\n+  // is the normal case.\n+  Function* enclosing_;\n+  // The named result variables, if any.\n+  Named_results* named_results_;\n+  // If there is a closure, this is the list of variables which appear\n+  // in the closure.  This is created by the parser, and then resolved\n+  // to a real type when we lower parse trees.\n+  Closure_fields closure_fields_;\n+  // The closure variable, passed as a parameter using the static\n+  // chain parameter.  Normally NULL.\n+  Named_object* closure_var_;\n+  // The outer block of statements in the function.\n+  Block* block_;\n+  // The source location of the start of the function.\n+  source_location location_;\n+  // Labels defined or referenced in the function.\n+  Labels labels_;\n+  // The function decl.\n+  tree fndecl_;\n+  // A variable holding the defer stack variable.  This is NULL unless\n+  // we actually need a defer stack.\n+  tree defer_stack_;\n+  // True if this function calls the predeclared recover function.\n+  bool calls_recover_;\n+  // True if this a thunk built for a function which calls recover.\n+  bool is_recover_thunk_;\n+  // True if this function already has a recover thunk.\n+  bool has_recover_thunk_;\n+};\n+\n+// A function declaration.\n+\n+class Function_declaration\n+{\n+ public:\n+  Function_declaration(Function_type* fntype, source_location location)\n+    : fntype_(fntype), location_(location), asm_name_(), fndecl_(NULL)\n+  { }\n+\n+  Function_type*\n+  type() const\n+  { return this->fntype_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  const std::string&\n+  asm_name() const\n+  { return this->asm_name_; }\n+\n+  // Set the assembler name.\n+  void\n+  set_asm_name(const std::string& asm_name)\n+  { this->asm_name_ = asm_name; }\n+\n+  // Return a decl for the function given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Export a function declaration.\n+  void\n+  export_func(Export* exp, const std::string& name) const\n+  { Function::export_func_with_type(exp, name, this->fntype_); }\n+\n+ private:\n+  // The type of the function.\n+  Function_type* fntype_;\n+  // The location of the declaration.\n+  source_location location_;\n+  // The assembler name: this is the name to use in references to the\n+  // function.  This is normally empty.\n+  std::string asm_name_;\n+  // The function decl if needed.\n+  tree fndecl_;\n+};\n+\n+// A variable.\n+\n+class Variable\n+{\n+ public:\n+  Variable(Type*, Expression*, bool is_global, bool is_parameter,\n+\t   bool is_receiver, source_location);\n+\n+  // Get the type of the variable.\n+  Type*\n+  type() const;\n+\n+  // Return whether the type is defined yet.\n+  bool\n+  has_type() const\n+  { return this->type_ != NULL; }\n+\n+  // Get the initial value.\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+  // Return whether there are any preinit statements.\n+  bool\n+  has_pre_init() const\n+  { return this->preinit_ != NULL; }\n+\n+  // Return the preinit statements if any.\n+  Block*\n+  preinit() const\n+  { return this->preinit_; }\n+\n+  // Return whether this is a global variable.\n+  bool\n+  is_global() const\n+  { return this->is_global_; }\n+\n+  // Return whether this is a function parameter.\n+  bool\n+  is_parameter() const\n+  { return this->is_parameter_; }\n+\n+  // Return whether this is the receiver parameter of a method.\n+  bool\n+  is_receiver() const\n+  { return this->is_receiver_; }\n+\n+  // Change this parameter to be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_receiver()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_receiver_ = true;\n+  }\n+\n+  // Change this parameter to not be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_not_receiver()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_receiver_ = false;\n+  }\n+\n+  // Return whether this is the varargs parameter of a function.\n+  bool\n+  is_varargs_parameter() const\n+  { return this->is_varargs_parameter_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_ && !this->is_global_; }\n+\n+  // Get the source location of the variable's declaration.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Record that this is the varargs parameter of a function.\n+  void\n+  set_is_varargs_parameter()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_varargs_parameter_ = true;\n+  }\n+\n+  // Clear the initial value; used for error handling.\n+  void\n+  clear_init()\n+  { this->init_ = NULL; }\n+\n+  // Set the initial value; used for converting shortcuts.\n+  void\n+  set_init(Expression* init)\n+  { this->init_ = init; }\n+\n+  // Get the preinit block, a block of statements to be run before the\n+  // initialization expression.\n+  Block*\n+  preinit_block();\n+\n+  // Add a statement to be run before the initialization expression.\n+  // This is only used for global variables.\n+  void\n+  add_preinit_statement(Statement*);\n+\n+  // Lower the initialization expression after parsing is complete.\n+  void\n+  lower_init_expression(Gogo*, Named_object*);\n+\n+  // A special case: the init value is used only to determine the\n+  // type.  This is used if the variable is defined using := with the\n+  // comma-ok form of a map index or a receive expression.  The init\n+  // value is actually the map index expression or receive expression.\n+  // We use this because we may not know the right type at parse time.\n+  void\n+  set_type_from_init_tuple()\n+  { this->type_from_init_tuple_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a range clause.  The init value is the range expression.  The\n+  // type of the variable is the index type of the range expression\n+  // (i.e., the first value returned by a range).\n+  void\n+  set_type_from_range_index()\n+  { this->type_from_range_index_ = true; }\n+\n+  // Another special case: like set_type_from_range_index, but the\n+  // type is the value type of the range expression (i.e., the second\n+  // value returned by a range).\n+  void\n+  set_type_from_range_value()\n+  { this->type_from_range_value_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a case in a select statement.  The init value is the channel.\n+  // The type of the variable is the channel's element type.\n+  void\n+  set_type_from_chan_element()\n+  { this->type_from_chan_element_ = true; }\n+\n+  // After we lower the select statement, we once again set the type\n+  // from the initialization expression.\n+  void\n+  clear_type_from_chan_element()\n+  {\n+    gcc_assert(this->type_from_chan_element_);\n+    this->type_from_chan_element_ = false;\n+  }\n+\n+  // Note that this variable was created for a type switch clause.\n+  void\n+  set_is_type_switch_var()\n+  { this->is_type_switch_var_ = true; }\n+\n+  // Traverse the initializer expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the variable if necessary.\n+  void\n+  determine_type();\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Get the initial value of the variable as a tree.  This may only\n+  // be called if has_pre_init() returns false.\n+  tree\n+  get_init_tree(Gogo*, Named_object* function);\n+\n+  // Return a series of statements which sets the value of the\n+  // variable in DECL.  This should only be called is has_pre_init()\n+  // returns true.  DECL may be NULL for a sink variable.\n+  tree\n+  get_init_block(Gogo*, Named_object* function, tree decl);\n+\n+  // Export the variable.\n+  void\n+  export_var(Export*, const std::string& name) const;\n+\n+  // Import a variable.\n+  static void\n+  import_var(Import*, std::string* pname, Type** ptype);\n+\n+ private:\n+  // The type of a tuple.\n+  Type*\n+  type_from_tuple(Expression*, bool) const;\n+\n+  // The type of a range.\n+  Type*\n+  type_from_range(Expression*, bool, bool) const;\n+\n+  // The element type of a channel.\n+  Type*\n+  type_from_chan_element(Expression*, bool) const;\n+\n+  // The variable's type.  This may be NULL if the type is set from\n+  // the expression.\n+  Type* type_;\n+  // The initial value.  This may be NULL if the variable should be\n+  // initialized to the default value for the type.\n+  Expression* init_;\n+  // Statements to run before the init statement.\n+  Block* preinit_;\n+  // Location of variable definition.\n+  source_location location_;\n+  // Whether this is a global variable.\n+  bool is_global_ : 1;\n+  // Whether this is a function parameter.\n+  bool is_parameter_ : 1;\n+  // Whether this is the receiver parameter of a method.\n+  bool is_receiver_ : 1;\n+  // Whether this is the varargs parameter of a function.\n+  bool is_varargs_parameter_ : 1;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_ : 1;\n+  // True if we have lowered the initialization expression.\n+  bool init_is_lowered_ : 1;\n+  // True if init is a tuple used to set the type.\n+  bool type_from_init_tuple_ : 1;\n+  // True if init is a range clause and the type is the index type.\n+  bool type_from_range_index_ : 1;\n+  // True if init is a range clause and the type is the value type.\n+  bool type_from_range_value_ : 1;\n+  // True if init is a channel and the type is the channel's element type.\n+  bool type_from_chan_element_ : 1;\n+  // True if this is a variable created for a type switch case.\n+  bool is_type_switch_var_ : 1;\n+};\n+\n+// A variable which is really the name for a function return value, or\n+// part of one.\n+\n+class Result_variable\n+{\n+ public:\n+  Result_variable(Type* type, Function* function, int index)\n+    : type_(type), function_(function), index_(index),\n+      is_address_taken_(false)\n+  { }\n+\n+  // Get the type of the result variable.\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Get the function that this is associated with.\n+  Function*\n+  function() const\n+  { return this->function_; }\n+\n+  // Index in the list of function results.\n+  int\n+  index() const\n+  { return this->index_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_; }\n+\n+ private:\n+  // Type of result variable.\n+  Type* type_;\n+  // Function with which this is associated.\n+  Function* function_;\n+  // Index in list of results.\n+  int index_;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_;\n+};\n+\n+// The value we keep for a named constant.  This lets us hold a type\n+// and an expression.\n+\n+class Named_constant\n+{\n+ public:\n+  Named_constant(Type* type, Expression* expr, int iota_value,\n+\t\t source_location location)\n+    : type_(type), expr_(expr), iota_value_(iota_value), location_(location),\n+      lowering_(false)\n+  { }\n+\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n+  int\n+  iota_value() const\n+  { return this->iota_value_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Whether we are lowering.\n+  bool\n+  lowering() const\n+  { return this->lowering_; }\n+\n+  // Set that we are lowering.\n+  void\n+  set_lowering()\n+  { this->lowering_ = true; }\n+\n+  // We are no longer lowering.\n+  void\n+  clear_lowering()\n+  { this->lowering_ = false; }\n+\n+  // Traverse the expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the constant if necessary.\n+  void\n+  determine_type();\n+\n+  // Indicate that we found and reported an error for this constant.\n+  void\n+  set_error();\n+\n+  // Export the constant.\n+  void\n+  export_const(Export*, const std::string& name) const;\n+\n+  // Import a constant.\n+  static void\n+  import_const(Import*, std::string*, Type**, Expression**);\n+\n+ private:\n+  // The type of the constant.\n+  Type* type_;\n+  // The expression for the constant.\n+  Expression* expr_;\n+  // If the predeclared constant iota is used in EXPR_, this is the\n+  // value it will have.  We do this because at parse time we don't\n+  // know whether the name \"iota\" will refer to the predeclared\n+  // constant or to something else.  We put in the right value in when\n+  // we lower.\n+  int iota_value_;\n+  // The location of the definition.\n+  source_location location_;\n+  // Whether we are currently lowering this constant.\n+  bool lowering_;\n+};\n+\n+// A type declaration.\n+\n+class Type_declaration\n+{\n+ public:\n+  Type_declaration(source_location location)\n+    : location_(location), in_function_(NULL), methods_(),\n+      issued_warning_(false)\n+  { }\n+\n+  // Return the location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the function in which this type is declared.  This will\n+  // return NULL for a type declared in global scope.\n+  Named_object*\n+  in_function()\n+  { return this->in_function_; }\n+\n+  // Set the function in which this type is declared.\n+  void\n+  set_in_function(Named_object* f)\n+  { this->in_function_ = f; }\n+\n+  // Add a method to this type.  This is used when methods are defined\n+  // before the type.\n+  Named_object*\n+  add_method(const std::string& name, Function* function);\n+\n+  // Add a method declaration to this type.\n+  Named_object*\n+  add_method_declaration(const std::string& name, Function_type* type,\n+\t\t\t source_location location);\n+\n+  // Return whether any methods were defined.\n+  bool\n+  has_methods() const;\n+\n+  // Define methods when the real type is known.\n+  void\n+  define_methods(Named_type*);\n+\n+  // This is called if we are trying to use this type.  It returns\n+  // true if we should issue a warning.\n+  bool\n+  using_type();\n+\n+ private:\n+  typedef std::vector<Named_object*> Methods;\n+\n+  // The location of the type declaration.\n+  source_location location_;\n+  // If this type is declared in a function, a pointer back to the\n+  // function in which it is defined.\n+  Named_object* in_function_;\n+  // Methods defined before the type is defined.\n+  Methods methods_;\n+  // True if we have issued a warning about a use of this type\n+  // declaration when it is undefined.\n+  bool issued_warning_;\n+};\n+\n+// An unknown object.  These are created by the parser for forward\n+// references to names which have not been seen before.  In a correct\n+// program, these will always point to a real definition by the end of\n+// the parse.  Because they point to another Named_object, these may\n+// only be referenced by Unknown_expression objects.\n+\n+class Unknown_name\n+{\n+ public:\n+  Unknown_name(source_location location)\n+    : location_(location), real_named_object_(NULL)\n+  { }\n+\n+  // Return the location where this name was first seen.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the real named object that this points to, or NULL if it\n+  // was never resolved.\n+  Named_object*\n+  real_named_object() const\n+  { return this->real_named_object_; }\n+\n+  // Set the real named object that this points to.\n+  void\n+  set_real_named_object(Named_object* no);\n+\n+ private:\n+  // The location where this name was first seen.\n+  source_location location_;\n+  // The real named object when it is known.\n+  Named_object*\n+  real_named_object_;\n+};\n+\n+// A named object named.  This is the result of a declaration.  We\n+// don't use a superclass because they all have to be handled\n+// differently.\n+\n+class Named_object\n+{\n+ public:\n+  enum Classification\n+  {\n+    // An uninitialized Named_object.  We should never see this.\n+    NAMED_OBJECT_UNINITIALIZED,\n+    // An unknown name.  This is used for forward references.  In a\n+    // correct program, these will all be resolved by the end of the\n+    // parse.\n+    NAMED_OBJECT_UNKNOWN,\n+    // A const.\n+    NAMED_OBJECT_CONST,\n+    // A type.\n+    NAMED_OBJECT_TYPE,\n+    // A forward type declaration.\n+    NAMED_OBJECT_TYPE_DECLARATION,\n+    // A var.\n+    NAMED_OBJECT_VAR,\n+    // A result variable in a function.\n+    NAMED_OBJECT_RESULT_VAR,\n+    // The blank identifier--the special variable named _.\n+    NAMED_OBJECT_SINK,\n+    // A func.\n+    NAMED_OBJECT_FUNC,\n+    // A forward func declaration.\n+    NAMED_OBJECT_FUNC_DECLARATION,\n+    // A package.\n+    NAMED_OBJECT_PACKAGE\n+  };\n+\n+  // Return the classification.\n+  Classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Classifiers.\n+\n+  bool\n+  is_unknown() const\n+  { return this->classification_ == NAMED_OBJECT_UNKNOWN; }\n+\n+  bool\n+  is_const() const\n+  { return this->classification_ == NAMED_OBJECT_CONST; }\n+\n+  bool\n+  is_type() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE; }\n+\n+  bool\n+  is_type_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE_DECLARATION; }\n+\n+  bool\n+  is_variable() const\n+  { return this->classification_ == NAMED_OBJECT_VAR; }\n+\n+  bool\n+  is_result_variable() const\n+  { return this->classification_ == NAMED_OBJECT_RESULT_VAR; }\n+\n+  bool\n+  is_sink() const\n+  { return this->classification_ == NAMED_OBJECT_SINK; }\n+\n+  bool\n+  is_function() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC; }\n+\n+  bool\n+  is_function_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC_DECLARATION; }\n+\n+  bool\n+  is_package() const\n+  { return this->classification_ == NAMED_OBJECT_PACKAGE; }\n+\n+  // Creators.\n+\n+  static Named_object*\n+  make_unknown_name(const std::string& name, source_location);\n+\n+  static Named_object*\n+  make_constant(const Typed_identifier&, const Package*, Expression*,\n+\t\tint iota_value);\n+\n+  static Named_object*\n+  make_type(const std::string&, const Package*, Type*, source_location);\n+\n+  static Named_object*\n+  make_type_declaration(const std::string&, const Package*, source_location);\n+\n+  static Named_object*\n+  make_variable(const std::string&, const Package*, Variable*);\n+\n+  static Named_object*\n+  make_result_variable(const std::string&, Result_variable*);\n+\n+  static Named_object*\n+  make_sink();\n+\n+  static Named_object*\n+  make_function(const std::string&, const Package*, Function*);\n+\n+  static Named_object*\n+  make_function_declaration(const std::string&, const Package*, Function_type*,\n+\t\t\t    source_location);\n+\n+  static Named_object*\n+  make_package(const std::string& alias, Package* package);\n+\n+  // Getters.\n+\n+  Unknown_name*\n+  unknown_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  const Unknown_name*\n+  unknown_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  Named_constant*\n+  const_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  const Named_constant*\n+  const_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  Named_type*\n+  type_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  const Named_type*\n+  type_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  Type_declaration*\n+  type_declaration_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  const Type_declaration*\n+  type_declaration_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  Variable*\n+  var_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  const Variable*\n+  var_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  Result_variable*\n+  result_var_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  const Result_variable*\n+  result_var_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  Function*\n+  func_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  const Function*\n+  func_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  Function_declaration*\n+  func_declaration_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  const Function_declaration*\n+  func_declaration_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  Package*\n+  package_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const Package*\n+  package_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the name to use in an error message.  The difference is\n+  // that if this Named_object is defined in a different package, this\n+  // will return PACKAGE.NAME.\n+  std::string\n+  message_name() const;\n+\n+  const Package*\n+  package() const\n+  { return this->package_; }\n+\n+  // Resolve an unknown value if possible.  This returns the same\n+  // Named_object or a new one.\n+  Named_object*\n+  resolve()\n+  {\n+    Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tNamed_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  const Named_object*\n+  resolve() const\n+  {\n+    const Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tconst Named_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  // The location where this object was defined or referenced.\n+  source_location\n+  location() const;\n+\n+  // Return a tree for the external identifier for this object.\n+  tree\n+  get_id(Gogo*);\n+\n+  // Return a tree representing this object.\n+  tree\n+  get_tree(Gogo*, Named_object* function);\n+\n+  // Define a type declaration.\n+  void\n+  set_type_value(Named_type*);\n+\n+  // Define a function declaration.\n+  void\n+  set_function_value(Function*);\n+\n+  // Export this object.\n+  void\n+  export_named_object(Export*) const;\n+\n+ private:\n+  Named_object(const std::string&, const Package*, Classification);\n+\n+  // The name of the object.\n+  std::string name_;\n+  // The package that this object is in.  This is NULL if it is in the\n+  // file we are compiling.\n+  const Package* package_;\n+  // The type of object this is.\n+  Classification classification_;\n+  // The real data.\n+  union\n+  {\n+    Unknown_name* unknown_value;\n+    Named_constant* const_value;\n+    Named_type* type_value;\n+    Type_declaration* type_declaration;\n+    Variable* var_value;\n+    Result_variable* result_var_value;\n+    Function* func_value;\n+    Function_declaration* func_declaration_value;\n+    Package* package_value;\n+  } u_;\n+  // The DECL tree for this object if we have already converted it.\n+  tree tree_;\n+};\n+\n+// A binding contour.  This binds names to objects.\n+\n+class Bindings\n+{\n+ public:\n+  // Type for mapping from names to objects.\n+  typedef Unordered_map(std::string, Named_object*) Contour;\n+\n+  Bindings(Bindings* enclosing);\n+\n+  // Add an unknown name.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_unknown_name(name,\n+\t\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, const Package* package,\n+\t       Expression* expr, int iota_value)\n+  {\n+    return this->add_named_object(Named_object::make_constant(tid, package,\n+\t\t\t\t\t\t\t      expr,\n+\t\t\t\t\t\t\t      iota_value));\n+  }\n+\n+  // Add a type.\n+  Named_object*\n+  add_type(const std::string& name, const Package* package, Type* type,\n+\t   source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_type(name, package, type,\n+\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  Named_object*\n+  add_named_type(Named_type* named_type);\n+\n+  // Add a type declaration.\n+  Named_object*\n+  add_type_declaration(const std::string& name, const Package* package,\n+\t\t       source_location location)\n+  {\n+    Named_object* no = Named_object::make_type_declaration(name, package,\n+\t\t\t\t\t\t\t   location);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string& name, const Package* package,\n+\t       Variable* variable)\n+  {\n+    return this->add_named_object(Named_object::make_variable(name, package,\n+\t\t\t\t\t\t\t      variable));\n+  }\n+\n+  // Add a result variable.\n+  Named_object*\n+  add_result_variable(const std::string& name, Result_variable* result)\n+  {\n+    return this->add_named_object(Named_object::make_result_variable(name,\n+\t\t\t\t\t\t\t\t     result));\n+  }\n+\n+  // Add a function.\n+  Named_object*\n+  add_function(const std::string& name, const Package*, Function* function);\n+\n+  // Add a function declaration.\n+  Named_object*\n+  add_function_declaration(const std::string& name, const Package* package,\n+\t\t\t   Function_type* type, source_location location);\n+\n+  // Add a package.  The location is the location of the import\n+  // statement.\n+  Named_object*\n+  add_package(const std::string& alias, Package* package)\n+  {\n+    Named_object* no = Named_object::make_package(alias, package);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a method to the list of objects.  This is not added to the\n+  // lookup table.\n+  void\n+  add_method(Named_object*);\n+\n+  // Add a named object to this binding.\n+  Named_object*\n+  add_named_object(Named_object* no)\n+  { return this->add_named_object_to_contour(&this->bindings_, no); }\n+\n+  // Clear all names in file scope from the bindings.\n+  void\n+  clear_file_scope();\n+\n+  // Look up a name in this binding contour and in any enclosing\n+  // binding contours.  This returns NULL if the name is not found.\n+  Named_object*\n+  lookup(const std::string&) const;\n+\n+  // Look up a name in this binding contour without looking in any\n+  // enclosing binding contours.  Returns NULL if the name is not found.\n+  Named_object*\n+  lookup_local(const std::string&) const;\n+\n+  // Remove a name.\n+  void\n+  remove_binding(Named_object*);\n+\n+  // Traverse the tree.  See the Traverse class.\n+  int\n+  traverse(Traverse*, bool is_global);\n+\n+  // Iterate over definitions.  This does not include things which\n+  // were only declared.\n+\n+  typedef std::vector<Named_object*>::const_iterator\n+    const_definitions_iterator;\n+\n+  const_definitions_iterator\n+  begin_definitions() const\n+  { return this->named_objects_.begin(); }\n+\n+  const_definitions_iterator\n+  end_definitions() const\n+  { return this->named_objects_.end(); }\n+\n+  // Return the number of definitions.\n+  size_t\n+  size_definitions() const\n+  { return this->named_objects_.size(); }\n+\n+  // Return whether there are no definitions.\n+  bool\n+  empty_definitions() const\n+  { return this->named_objects_.empty(); }\n+\n+  // Iterate over declarations.  This is everything that has been\n+  // declared, which includes everything which has been defined.\n+\n+  typedef Contour::const_iterator const_declarations_iterator;\n+\n+  const_declarations_iterator\n+  begin_declarations() const\n+  { return this->bindings_.begin(); }\n+\n+  const_declarations_iterator\n+  end_declarations() const\n+  { return this->bindings_.end(); }\n+\n+  // Return the number of declarations.\n+  size_t\n+  size_declarations() const\n+  { return this->bindings_.size(); }\n+\n+  // Return whether there are no declarations.\n+  bool\n+  empty_declarations() const\n+  { return this->bindings_.empty(); }\n+\n+  // Return the first declaration.\n+  Named_object*\n+  first_declaration()\n+  { return this->bindings_.empty() ? NULL : this->bindings_.begin()->second; }\n+\n+ private:\n+  Named_object*\n+  add_named_object_to_contour(Contour*, Named_object*);\n+\n+  Named_object*\n+  new_definition(Named_object*, Named_object*);\n+\n+  // Enclosing bindings.\n+  Bindings* enclosing_;\n+  // The list of objects.\n+  std::vector<Named_object*> named_objects_;\n+  // The mapping from names to objects.\n+  Contour bindings_;\n+};\n+\n+// A label.\n+\n+class Label\n+{\n+ public:\n+  Label(const std::string& name)\n+    : name_(name), location_(0), decl_(NULL)\n+  { }\n+\n+  // Return the label's name.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return whether the label has been defined.\n+  bool\n+  is_defined() const\n+  { return this->location_ != 0; }\n+\n+  // Return the location of the definition.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Define the label at LOCATION.\n+  void\n+  define(source_location location)\n+  {\n+    gcc_assert(this->location_ == 0);\n+    this->location_ = location;\n+  }\n+\n+  // Return the LABEL_DECL for this decl.\n+  tree\n+  get_decl();\n+\n+  // Return an expression for the address of this label.\n+  tree\n+  get_addr(source_location location);\n+\n+ private:\n+  // The name of the label.\n+  std::string name_;\n+  // The location of the definition.  This is 0 if the label has not\n+  // yet been defined.\n+  source_location location_;\n+  // The LABEL_DECL.\n+  tree decl_;\n+};\n+\n+// An unnamed label.  These are used when lowering loops.\n+\n+class Unnamed_label\n+{\n+ public:\n+  Unnamed_label(source_location location)\n+    : location_(location), decl_(NULL)\n+  { }\n+\n+  // Get the location where the label is defined.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Set the location where the label is defined.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Return a statement which defines this label.\n+  tree\n+  get_definition();\n+\n+  // Return a goto to this label from LOCATION.\n+  tree\n+  get_goto(source_location location);\n+\n+ private:\n+  // Return the LABEL_DECL to use with GOTO_EXPR.\n+  tree\n+  get_decl();\n+\n+  // The location where the label is defined.\n+  source_location location_;\n+  // The LABEL_DECL.\n+  tree decl_;\n+};\n+\n+// An imported package.\n+\n+class Package\n+{\n+ public:\n+  Package(const std::string& name, const std::string& unique_prefix,\n+\t  source_location location);\n+\n+  // The real name of this package.  This may be different from the\n+  // name in the associated Named_object if the import statement used\n+  // an alias.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the location of the import statement.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Get the unique prefix used for all symbols exported from this\n+  // package.\n+  const std::string&\n+  unique_prefix() const\n+  {\n+    gcc_assert(!this->unique_prefix_.empty());\n+    return this->unique_prefix_;\n+  }\n+\n+  // The priority of this package.  The init function of packages with\n+  // lower priority must be run before the init function of packages\n+  // with higher priority.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+  // Set the priority.\n+  void\n+  set_priority(int priority);\n+\n+  // Return the bindings.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  // Whether some symbol from the package was used.\n+  bool\n+  used() const\n+  { return this->used_; }\n+\n+  // Note that some symbol from this package was used.\n+  void\n+  set_used() const\n+  { this->used_ = true; }\n+\n+  // Clear the used field for the next file.\n+  void\n+  clear_used()\n+  { this->used_ = false; }\n+\n+  // Whether this package was imported in the current file.\n+  bool\n+  is_imported() const\n+  { return this->is_imported_; }\n+\n+  // Note that this package was imported in the current file.\n+  void\n+  set_is_imported()\n+  { this->is_imported_ = true; }\n+\n+  // Clear the imported field for the next file.\n+  void\n+  clear_is_imported()\n+  { this->is_imported_ = false; }\n+\n+  // Whether this package was imported with a name of \"_\".\n+  bool\n+  uses_sink_alias() const\n+  { return this->uses_sink_alias_; }\n+\n+  // Note that this package was imported with a name of \"_\".\n+  void\n+  set_uses_sink_alias()\n+  { this->uses_sink_alias_ = true; }\n+\n+  // Clear the sink alias field for the next file.\n+  void\n+  clear_uses_sink_alias()\n+  { this->uses_sink_alias_ = false; }\n+\n+  // Look up a name in the package.  Returns NULL if the name is not\n+  // found.\n+  Named_object*\n+  lookup(const std::string& name) const\n+  { return this->bindings_->lookup(name); }\n+\n+  // Set the location of the package.  This is used if it is seen in a\n+  // different import before it is really imported.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Add a constant to the package.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, Expression* expr)\n+  { return this->bindings_->add_constant(tid, this, expr, 0); }\n+\n+  // Add a type to the package.\n+  Named_object*\n+  add_type(const std::string& name, Type* type, source_location location)\n+  { return this->bindings_->add_type(name, this, type, location); }\n+\n+  // Add a type declaration to the package.\n+  Named_object*\n+  add_type_declaration(const std::string& name, source_location location)\n+  { return this->bindings_->add_type_declaration(name, this, location); }\n+\n+  // Add a variable to the package.\n+  Named_object*\n+  add_variable(const std::string& name, Variable* variable)\n+  { return this->bindings_->add_variable(name, this, variable); }\n+\n+  // Add a function declaration to the package.\n+  Named_object*\n+  add_function_declaration(const std::string& name, Function_type* type,\n+\t\t\t   source_location loc)\n+  { return this->bindings_->add_function_declaration(name, this, type, loc); }\n+\n+  // Determine types of constants.\n+  void\n+  determine_types();\n+\n+ private:\n+  // The real name of this package.\n+  std::string name_;\n+  // The unique prefix for all exported global symbols.\n+  std::string unique_prefix_;\n+  // The names in this package.\n+  Bindings* bindings_;\n+  // The priority of this package.  A package has a priority higher\n+  // than the priority of all of the packages that it imports.  This\n+  // is used to run init functions in the right order.\n+  int priority_;\n+  // The location of the import statement.\n+  source_location location_;\n+  // True if some name from this package was used.  This is mutable\n+  // because we can use a package even if we have a const pointer to\n+  // it.\n+  mutable bool used_;\n+  // True if this package was imported in the current file.\n+  bool is_imported_;\n+  // True if this package was imported with a name of \"_\".\n+  bool uses_sink_alias_;\n+};\n+\n+// Return codes for the traversal functions.  This is not an enum\n+// because we want to be able to declare traversal functions in other\n+// header files without including this one.\n+\n+// Continue traversal as usual.\n+const int TRAVERSE_CONTINUE = -1;\n+\n+// Exit traversal.\n+const int TRAVERSE_EXIT = 0;\n+\n+// Continue traversal, but skip components of the current object.\n+// E.g., if this is returned by Traverse::statement, we do not\n+// traverse the expressions in the statement even if\n+// traverse_expressions is set in the traverse_mask.\n+const int TRAVERSE_SKIP_COMPONENTS = 1;\n+\n+// This class is used when traversing the parse tree.  The caller uses\n+// a subclass which overrides functions as desired.\n+\n+class Traverse\n+{\n+ public:\n+  // These bitmasks say what to traverse.\n+  static const unsigned int traverse_variables =    0x1;\n+  static const unsigned int traverse_constants =    0x2;\n+  static const unsigned int traverse_functions =    0x4;\n+  static const unsigned int traverse_blocks =       0x8;\n+  static const unsigned int traverse_statements =  0x10;\n+  static const unsigned int traverse_expressions = 0x20;\n+  static const unsigned int traverse_types =       0x40;\n+\n+  Traverse(unsigned int traverse_mask)\n+    : traverse_mask_(traverse_mask), types_seen_(NULL), expressions_seen_(NULL)\n+  { }\n+\n+  virtual ~Traverse();\n+\n+  // The bitmask of what to traverse.\n+  unsigned int\n+  traverse_mask() const\n+  { return this->traverse_mask_; }\n+\n+  // Record that we are going to traverse a type.  This returns true\n+  // if the type has already been seen in this traversal.  This is\n+  // required because types, unlike expressions, can form a circular\n+  // graph.\n+  bool\n+  remember_type(const Type*);\n+\n+  // Record that we are going to see an expression.  This returns true\n+  // if the expression has already been seen in this traversal.  This\n+  // is only needed for cases where multiple expressions can point to\n+  // a single one.\n+  bool\n+  remember_expression(const Expression*);\n+\n+  // These functions return one of the TRAVERSE codes defined above.\n+\n+  // If traverse_variables is set in the mask, this is called for\n+  // every variable in the tree.\n+  virtual int\n+  variable(Named_object*);\n+\n+  // If traverse_constants is set in the mask, this is called for\n+  // every named constant in the tree.  The bool parameter is true for\n+  // a global constant.\n+  virtual int\n+  constant(Named_object*, bool);\n+\n+  // If traverse_functions is set in the mask, this is called for\n+  // every function in the tree.\n+  virtual int\n+  function(Named_object*);\n+\n+  // If traverse_blocks is set in the mask, this is called for every\n+  // block in the tree.\n+  virtual int\n+  block(Block*);\n+\n+  // If traverse_statements is set in the mask, this is called for\n+  // every statement in the tree.\n+  virtual int\n+  statement(Block*, size_t* index, Statement*);\n+\n+  // If traverse_expressions is set in the mask, this is called for\n+  // every expression in the tree.\n+  virtual int\n+  expression(Expression**);\n+\n+  // If traverse_types is set in the mask, this is called for every\n+  // type in the tree.\n+  virtual int\n+  type(Type*);\n+\n+ private:\n+  typedef Unordered_set_hash(const Type*, Type_hash_identical,\n+\t\t\t     Type_identical) Types_seen;\n+\n+  typedef Unordered_set(const Expression*) Expressions_seen;\n+\n+  // Bitmask of what sort of objects to traverse.\n+  unsigned int traverse_mask_;\n+  // Types which have been seen in this traversal.\n+  Types_seen* types_seen_;\n+  // Expressions which have been seen in this traversal.\n+  Expressions_seen* expressions_seen_;\n+};\n+\n+// When translating the gogo IR into trees, this is the context we\n+// pass down the blocks and statements.\n+\n+class Translate_context\n+{\n+ public:\n+  Translate_context(Gogo* gogo, Named_object* function, Block* block,\n+\t\t    tree block_tree)\n+    : gogo_(gogo), function_(function), block_(block), block_tree_(block_tree),\n+      is_const_(false)\n+  { }\n+\n+  // Accessors.\n+\n+  Gogo*\n+  gogo()\n+  { return this->gogo_; }\n+\n+  Named_object*\n+  function()\n+  { return this->function_; }\n+\n+  Block*\n+  block()\n+  { return this->block_; }\n+\n+  tree\n+  block_tree()\n+  { return this->block_tree_; }\n+\n+  bool\n+  is_const()\n+  { return this->is_const_; }\n+\n+  // Make a constant context.\n+  void\n+  set_is_const()\n+  { this->is_const_ = true; }\n+\n+ private:\n+  // The IR for the entire compilation unit.\n+  Gogo* gogo_;\n+  // The function we are currently translating.\n+  Named_object* function_;\n+  // The block we are currently translating.\n+  Block *block_;\n+  // The BLOCK node for the current block.\n+  tree block_tree_;\n+  // Whether this is being evaluated in a constant context.  This is\n+  // used for type descriptor initializers.\n+  bool is_const_;\n+};\n+\n+// Runtime error codes.  These must match the values in\n+// libgo/runtime/go-runtime-error.c.\n+\n+// Slice index out of bounds: negative or larger than the length of\n+// the slice.\n+static const int RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS = 0;\n+\n+// Array index out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_INDEX_OUT_OF_BOUNDS = 1;\n+\n+// String index out of bounds.\n+static const int RUNTIME_ERROR_STRING_INDEX_OUT_OF_BOUNDS = 2;\n+\n+// Slice slice out of bounds: negative or larger than the length of\n+// the slice or high bound less than low bound.\n+static const int RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS = 3;\n+\n+// Array slice out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_SLICE_OUT_OF_BOUNDS = 4;\n+\n+// String slice out of bounds.\n+static const int RUNTIME_ERROR_STRING_SLICE_OUT_OF_BOUNDS = 5;\n+\n+// Dereference of nil pointer.  This is used when there is a\n+// dereference of a pointer to a very large struct or array, to ensure\n+// that a gigantic array is not used a proxy to access random memory\n+// locations.\n+static const int RUNTIME_ERROR_NIL_DEREFERENCE = 6;\n+\n+// Slice length or capacity out of bounds in make: negative or\n+// overflow or length greater than capacity.\n+static const int RUNTIME_ERROR_MAKE_SLICE_OUT_OF_BOUNDS = 7;\n+\n+// Map capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS = 8;\n+\n+// Channel capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS = 9;\n+\n+// This is used by some of the langhooks.\n+extern Gogo* go_get_gogo();\n+\n+// Whether we have seen any errors.  FIXME: Replace with a backend\n+// interface.\n+extern bool saw_errors();\n+\n+#endif // !defined(GO_GOGO_H)"}, {"sha": "4356d82cab214bbc8684b10faed8888814fa5944", "filename": "gcc/go/gofrontend/import-archive.cc", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport-archive.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,661 @@\n+// import-archive.cc -- Go frontend read import data from an archive file.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"import.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+// Archive magic numbers.\n+\n+static const char armag[] =\n+{\n+  '!', '<', 'a', 'r', 'c', 'h', '>', '\\n'\n+};\n+\n+static const char armagt[] =\n+{\n+  '!', '<', 't', 'h', 'i', 'n', '>', '\\n'\n+};\n+\n+static const char arfmag[2] = { '`', '\\n' };\n+\n+// The header of an entry in an archive.  This is all readable text,\n+// padded with spaces where necesary.\n+\n+struct Archive_header\n+{\n+  // The entry name.\n+  char ar_name[16];\n+  // The file modification time.\n+  char ar_date[12];\n+  // The user's UID in decimal.\n+  char ar_uid[6];\n+  // The user's GID in decimal.\n+  char ar_gid[6];\n+  // The file mode in octal.\n+  char ar_mode[8];\n+  // The file size in decimal.\n+  char ar_size[10];\n+  // The final magic code.\n+  char ar_fmag[2];\n+};\n+\n+// The functions in this file extract Go export data from an archive.\n+\n+const int Import::archive_magic_len;\n+\n+// Return true if BYTES, which are from the start of the file, are an\n+// archive magic number.\n+\n+bool\n+Import::is_archive_magic(const char* bytes)\n+{\n+  return (memcmp(bytes, armag, Import::archive_magic_len) == 0\n+\t  || memcmp(bytes, armagt, Import::archive_magic_len) == 0);\n+}\n+\n+// An object used to read an archive file.\n+\n+class Archive_file\n+{\n+ public:\n+  Archive_file(const std::string& filename, int fd, source_location location)\n+    : filename_(filename), fd_(fd), filesize_(-1), extended_names_(),\n+      is_thin_archive_(false), location_(location), nested_archives_()\n+  { }\n+\n+  // Initialize.\n+  bool\n+  initialize();\n+\n+  // Return the file name.\n+  const std::string&\n+  filename() const\n+  { return this->filename_; }\n+\n+  // Get the file size.\n+  off_t\n+  filesize() const\n+  { return this->filesize_; }\n+\n+  // Return whether this is a thin archive.\n+  bool\n+  is_thin_archive() const\n+  { return this->is_thin_archive_; }\n+\n+  // Return the location of the import statement.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Read bytes.\n+  bool\n+  read(off_t offset, off_t size, char*);\n+\n+  // Read the archive header at OFF, setting *PNAME, *SIZE, and\n+  // *NESTED_OFF.\n+  bool\n+  read_header(off_t off, std::string* pname, off_t* size, off_t* nested_off);\n+\n+  // Interpret the header of HDR, the header of the archive member at\n+  // file offset OFF.  Return whether it succeeded.  Set *SIZE to the\n+  // size of the member.  Set *PNAME to the name of the member.  Set\n+  // *NESTED_OFF to the offset in a nested archive.\n+  bool\n+  interpret_header(const Archive_header* hdr, off_t off,\n+\t\t   std::string* pname, off_t* size, off_t* nested_off) const;\n+\n+  // Get the file and offset for an archive member.\n+  bool\n+  get_file_and_offset(off_t off, const std::string& hdrname,\n+\t\t      off_t nested_off, int* memfd, off_t* memoff,\n+\t\t      std::string* memname);\n+\n+ private:\n+  // For keeping track of open nested archives in a thin archive file.\n+  typedef std::map<std::string, Archive_file*> Nested_archive_table;\n+\n+  // The name of the file.\n+  std::string filename_;\n+  // The file descriptor.\n+  int fd_;\n+  // The file size;\n+  off_t filesize_;\n+  // The extended name table.\n+  std::string extended_names_;\n+  // Whether this is a thin archive.\n+  bool is_thin_archive_;\n+  // The location of the import statements.\n+  source_location location_;\n+  // Table of nested archives.\n+  Nested_archive_table nested_archives_;\n+};\n+\n+bool\n+Archive_file::initialize()\n+{\n+  struct stat st;\n+  if (fstat(this->fd_, &st) < 0)\n+    {\n+      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      return false;\n+    }\n+  this->filesize_ = st.st_size;\n+\n+  char buf[sizeof(armagt)];\n+  if (::lseek(this->fd_, 0, SEEK_SET) < 0\n+      || ::read(this->fd_, buf, sizeof(armagt)) != sizeof(armagt))\n+    {\n+      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      return false;\n+    }\n+  this->is_thin_archive_ = memcmp(buf, armagt, sizeof(armagt)) == 0;\n+\n+  if (this->filesize_ == sizeof(armag))\n+    {\n+      // Empty archive.\n+      return true;\n+    }\n+\n+  // Look for the extended name table.\n+  std::string filename;\n+  off_t size;\n+  if (!this->read_header(sizeof(armagt), &filename, &size, NULL))\n+    return false;\n+  if (filename.empty())\n+    {\n+      // We found the symbol table.\n+      off_t off = sizeof(armagt) + sizeof(Archive_header) + size;\n+      if ((off & 1) != 0)\n+\t++off;\n+      if (!this->read_header(off, &filename, &size, NULL))\n+\tfilename.clear();\n+    }\n+  if (filename == \"/\")\n+    {\n+      char* buf = new char[size];\n+      if (::read(this->fd_, buf, size) != size)\n+\t{\n+\t  error_at(this->location_, \"%s: could not read extended names\",\n+\t\t   filename.c_str());\n+\t  delete buf;\n+\t  return false;\n+\t}\n+      this->extended_names_.assign(buf, size);\n+      delete buf;\n+    }\n+\n+  return true;\n+}\n+\n+// Read bytes from the file.\n+\n+bool\n+Archive_file::read(off_t offset, off_t size, char* buf)\n+{\n+  if (::lseek(this->fd_, offset, SEEK_SET) < 0\n+      || ::read(this->fd_, buf, size) != size)\n+    {\n+      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      return false;\n+    }\n+  return true;\n+}\n+\n+// Read the header at OFF.  Set *PNAME to the name, *SIZE to the size,\n+// and *NESTED_OFF to the nested offset.\n+\n+bool\n+Archive_file::read_header(off_t off, std::string* pname, off_t* size,\n+\t\t\t  off_t* nested_off)\n+{\n+  Archive_header hdr;\n+  if (::lseek(this->fd_, off, SEEK_SET) < 0)\n+    {\n+      error_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      return false;\n+    }\n+  ssize_t got = ::read(this->fd_, &hdr, sizeof hdr);\n+  if (got != sizeof hdr)\n+    {\n+      if (got < 0)\n+\terror_at(this->location_, \"%s: %m\", this->filename_.c_str());\n+      else if (got > 0)\n+\terror_at(this->location_, \"%s: short archive header at %ld\",\n+\t\t this->filename_.c_str(), static_cast<long>(off));\n+      else\n+\terror_at(this->location_, \"%s: unexpected EOF at %ld\",\n+\t\t this->filename_.c_str(), static_cast<long>(off));\n+    }\n+  off_t local_nested_off;\n+  if (!this->interpret_header(&hdr, off, pname, size, &local_nested_off))\n+    return false;\n+  if (nested_off != NULL)\n+    *nested_off = local_nested_off;\n+  return true;\n+}\n+\n+// Interpret the header of HDR, the header of the archive member at\n+// file offset OFF.\n+\n+bool\n+Archive_file::interpret_header(const Archive_header* hdr, off_t off,\n+\t\t\t       std::string* pname, off_t* size,\n+\t\t\t       off_t* nested_off) const\n+{\n+  if (memcmp(hdr->ar_fmag, arfmag, sizeof arfmag) != 0)\n+    {\n+      error_at(this->location_, \"%s: malformed archive header at %lu\",\n+\t       this->filename_.c_str(), static_cast<unsigned long>(off));\n+      return false;\n+    }\n+\n+  const int size_string_size = sizeof hdr->ar_size;\n+  char size_string[size_string_size + 1];\n+  memcpy(size_string, hdr->ar_size, size_string_size);\n+  char* ps = size_string + size_string_size;\n+  while (ps[-1] == ' ')\n+    --ps;\n+  *ps = '\\0';\n+\n+  errno = 0;\n+  char* end;\n+  *size = strtol(size_string, &end, 10);\n+  if (*end != '\\0'\n+      || *size < 0\n+      || (*size == LONG_MAX && errno == ERANGE))\n+    {\n+      error_at(this->location_, \"%s: malformed archive header size at %lu\",\n+\t       this->filename_.c_str(), static_cast<unsigned long>(off));\n+      return false;\n+    }\n+\n+  if (hdr->ar_name[0] != '/')\n+    {\n+      const char* name_end = strchr(hdr->ar_name, '/');\n+      if (name_end == NULL\n+\t  || name_end - hdr->ar_name >= static_cast<int>(sizeof hdr->ar_name))\n+\t{\n+\t  error_at(this->location_, \"%s: malformed archive header name at %lu\",\n+\t\t   this->filename_.c_str(), static_cast<unsigned long>(off));\n+\t  return false;\n+\t}\n+      pname->assign(hdr->ar_name, name_end - hdr->ar_name);\n+      *nested_off = 0;\n+    }\n+  else if (hdr->ar_name[1] == ' ')\n+    {\n+      // This is the symbol table.\n+      pname->clear();\n+    }\n+  else if (hdr->ar_name[1] == '/')\n+    {\n+      // This is the extended name table.\n+      pname->assign(1, '/');\n+    }\n+  else\n+    {\n+      errno = 0;\n+      long x = strtol(hdr->ar_name + 1, &end, 10);\n+      long y = 0;\n+      if (*end == ':')\n+        y = strtol(end + 1, &end, 10);\n+      if (*end != ' '\n+\t  || x < 0\n+\t  || (x == LONG_MAX && errno == ERANGE)\n+\t  || static_cast<size_t>(x) >= this->extended_names_.size())\n+\t{\n+\t  error_at(this->location_, \"%s: bad extended name index at %lu\",\n+\t\t   this->filename_.c_str(), static_cast<unsigned long>(off));\n+\t  return false;\n+\t}\n+\n+      const char* name = this->extended_names_.data() + x;\n+      const char* name_end = strchr(name, '\\n');\n+      if (static_cast<size_t>(name_end - name) > this->extended_names_.size()\n+\t  || name_end[-1] != '/')\n+\t{\n+\t  error_at(this->location_, \"%s: bad extended name entry at header %lu\",\n+\t\t   this->filename_.c_str(), static_cast<unsigned long>(off));\n+\t  return false;\n+\t}\n+      pname->assign(name, name_end - 1 - name);\n+      if (nested_off != NULL)\n+        *nested_off = y;\n+    }\n+\n+  return true;\n+}\n+\n+// Get the file and offset for an archive member.\n+\n+bool\n+Archive_file::get_file_and_offset(off_t off, const std::string& hdrname,\n+\t\t\t\t  off_t nested_off, int* memfd, off_t* memoff,\n+\t\t\t\t  std::string* memname)\n+{\n+  if (!this->is_thin_archive_)\n+    {\n+      *memfd = this->fd_;\n+      *memoff = off + sizeof(Archive_header);\n+      *memname = this->filename_ + '(' + hdrname + ')';\n+      return true;\n+    }\n+\n+  std::string filename = hdrname;\n+  if (!IS_ABSOLUTE_PATH(filename.c_str()))\n+    {\n+      const char* archive_path = this->filename_.c_str();\n+      const char* basename = lbasename(archive_path);\n+      if (basename > archive_path)\n+\tfilename.replace(0, 0,\n+\t\t\t this->filename_.substr(0, basename - archive_path));\n+    }\n+\n+  if (nested_off > 0)\n+    {\n+      // This is a member of a nested archive.\n+      Archive_file* nfile;\n+      Nested_archive_table::const_iterator p =\n+\tthis->nested_archives_.find(filename);\n+      if (p != this->nested_archives_.end())\n+\tnfile = p->second;\n+      else\n+\t{\n+\t  int nfd = open(filename.c_str(), O_RDONLY | O_BINARY);\n+\t  if (nfd < 0)\n+\t    {\n+\t      error_at(this->location_, \"%s: can't open nested archive %s\",\n+\t\t       this->filename_.c_str(), filename.c_str());\n+\t      return false;\n+\t    }\n+\t  nfile = new Archive_file(filename, nfd, this->location_);\n+\t  if (!nfile->initialize())\n+\t    {\n+\t      delete nfile;\n+\t      return false;\n+\t    }\n+\t  this->nested_archives_[filename] = nfile;\n+\t}\n+\n+      std::string nname;\n+      off_t nsize;\n+      off_t nnested_off;\n+      if (!nfile->read_header(nested_off, &nname, &nsize, &nnested_off))\n+\treturn false;\n+      return nfile->get_file_and_offset(nested_off, nname, nnested_off,\n+\t\t\t\t\tmemfd, memoff, memname);\n+    }\n+\n+  // An external member of a thin archive.\n+  *memfd = open(filename.c_str(), O_RDONLY | O_BINARY);\n+  if (*memfd < 0)\n+    {\n+      error_at(this->location_, \"%s: %m\", filename.c_str());\n+      return false;\n+    }\n+  *memoff = 0;\n+  *memname = filename;\n+  return true;\n+}\n+\n+// An archive member iterator.  This is more-or-less copied from gold.\n+\n+class Archive_iterator\n+{\n+ public:\n+  // The header of an archive member.  This is what this iterator\n+  // points to.\n+  struct Header\n+  {\n+    // The name of the member.\n+    std::string name;\n+    // The file offset of the member.\n+    off_t off;\n+    // The file offset of a nested archive member.\n+    off_t nested_off;\n+    // The size of the member.\n+    off_t size;\n+  };\n+\n+  Archive_iterator(Archive_file* afile, off_t off)\n+    : afile_(afile), off_(off)\n+  { this->read_next_header(); }\n+\n+  const Header&\n+  operator*() const\n+  { return this->header_; }\n+\n+  const Header*\n+  operator->() const\n+  { return &this->header_; }\n+\n+  Archive_iterator&\n+  operator++()\n+  {\n+    if (this->off_ == this->afile_->filesize())\n+      return *this;\n+    this->off_ += sizeof(Archive_header);\n+    if (!this->afile_->is_thin_archive())\n+      this->off_ += this->header_.size;\n+    if ((this->off_ & 1) != 0)\n+      ++this->off_;\n+    this->read_next_header();\n+    return *this;\n+  }\n+\n+  Archive_iterator\n+  operator++(int)\n+  {\n+    Archive_iterator ret = *this;\n+    ++*this;\n+    return ret;\n+  }\n+\n+  bool\n+  operator==(const Archive_iterator p) const\n+  { return this->off_ == p->off; }\n+\n+  bool\n+  operator!=(const Archive_iterator p) const\n+  { return this->off_ != p->off; }\n+\n+ private:\n+  void\n+  read_next_header();\n+\n+  // The underlying archive file.\n+  Archive_file* afile_;\n+  // The current offset in the file.\n+  off_t off_;\n+  // The current archive header.\n+  Header header_;\n+};\n+\n+// Read the next archive header.\n+\n+void\n+Archive_iterator::read_next_header()\n+{\n+  off_t filesize = this->afile_->filesize();\n+  while (true)\n+    {\n+      if (filesize - this->off_ < static_cast<off_t>(sizeof(Archive_header)))\n+\t{\n+\t  if (filesize != this->off_)\n+\t    {\n+\t      error_at(this->afile_->location(),\n+\t\t       \"%s: short archive header at %lu\",\n+\t\t       this->afile_->filename().c_str(),\n+\t\t       static_cast<unsigned long>(this->off_));\n+\t      this->off_ = filesize;\n+\t    }\n+\t  this->header_.off = filesize;\n+\t  return;\n+\t}\n+\n+      char buf[sizeof(Archive_header)];\n+      if (!this->afile_->read(this->off_, sizeof(Archive_header), buf))\n+\t{\n+\t  this->header_.off = filesize;\n+\t  return;\n+\t}\n+\n+      const Archive_header* hdr = reinterpret_cast<const Archive_header*>(buf);\n+      if (!this->afile_->interpret_header(hdr, this->off_, &this->header_.name,\n+\t\t\t\t\t  &this->header_.size,\n+\t\t\t\t\t  &this->header_.nested_off))\n+\t{\n+\t  this->header_.off = filesize;\n+\t  return;\n+\t}\n+      this->header_.off = this->off_;\n+\n+      // Skip special members.\n+      if (!this->header_.name.empty() && this->header_.name != \"/\")\n+\treturn;\n+\n+      this->off_ += sizeof(Archive_header) + this->header_.size;\n+      if ((this->off_ & 1) != 0)\n+\t++this->off_;\n+    }\n+}\n+\n+// Initial iterator.\n+\n+Archive_iterator\n+archive_begin(Archive_file* afile)\n+{\n+  return Archive_iterator(afile, sizeof(armag));\n+}\n+\n+// Final iterator.\n+\n+Archive_iterator\n+archive_end(Archive_file* afile)\n+{\n+  return Archive_iterator(afile, afile->filesize());\n+}\n+\n+// A type of Import_stream which concatenates other Import_streams\n+// together.\n+\n+class Stream_concatenate : public Import::Stream\n+{\n+ public:\n+  Stream_concatenate()\n+    : inputs_()\n+  { }\n+\n+  // Add a new stream.\n+  void\n+  add(Import::Stream* is)\n+  { this->inputs_.push_back(is); }\n+\n+ protected:\n+  bool\n+  do_peek(size_t, const char**);\n+\n+  void\n+  do_advance(size_t);\n+\n+ private:\n+  std::list<Import::Stream*> inputs_;\n+};\n+\n+// Peek ahead.\n+\n+bool\n+Stream_concatenate::do_peek(size_t length, const char** bytes)\n+{\n+  while (true)\n+    {\n+      if (this->inputs_.empty())\n+\treturn false;\n+      if (this->inputs_.front()->peek(length, bytes))\n+\treturn true;\n+      delete this->inputs_.front();\n+      this->inputs_.pop_front();\n+    }\n+}\n+\n+// Advance.\n+\n+void\n+Stream_concatenate::do_advance(size_t skip)\n+{\n+  while (true)\n+    {\n+      if (this->inputs_.empty())\n+\treturn;\n+      if (!this->inputs_.front()->at_eof())\n+\t{\n+\t  // We just assume that this will do the right thing.  It\n+\t  // should be OK since we should never want to skip past\n+\t  // multiple streams.\n+\t  this->inputs_.front()->advance(skip);\n+\t  return;\n+\t}\n+      delete this->inputs_.front();\n+      this->inputs_.pop_front();\n+    }\n+}\n+\n+// Import data from an archive.  We walk through the archive and\n+// import data from each member.\n+\n+Import::Stream*\n+Import::find_archive_export_data(const std::string& filename, int fd,\n+\t\t\t\t source_location location)\n+{\n+  Archive_file afile(filename, fd, location);\n+  if (!afile.initialize())\n+    return NULL;\n+\n+  Stream_concatenate* ret = new Stream_concatenate;\n+\n+  bool any_data = false;\n+  bool any_members = false;\n+  Archive_iterator pend = archive_end(&afile);\n+  for (Archive_iterator p = archive_begin(&afile); p != pend; p++)\n+    {\n+      any_members = true;\n+      int member_fd;\n+      off_t member_off;\n+      std::string member_name;\n+      if (!afile.get_file_and_offset(p->off, p->name, p->nested_off,\n+\t\t\t\t     &member_fd, &member_off, &member_name))\n+\treturn NULL;\n+\n+      Import::Stream* is = Import::find_object_export_data(member_name,\n+\t\t\t\t\t\t\t   member_fd,\n+\t\t\t\t\t\t\t   member_off,\n+\t\t\t\t\t\t\t   location);\n+      if (is != NULL)\n+\t{\n+\t  ret->add(is);\n+\t  any_data = true;\n+\t}\n+    }\n+\n+  if (!any_members)\n+    {\n+      // It's normal to have an empty archive file when using gobuild.\n+      return new Stream_from_string(\"\");\n+    }\n+\n+  if (!any_data)\n+    {\n+      delete ret;\n+      return NULL;\n+    }\n+\n+  return ret;\n+}"}, {"sha": "0f0da89a018168e363ed26058fd9f1a0c2d51497", "filename": "gcc/go/gofrontend/import.cc", "status": "added", "additions": 892, "deletions": 0, "changes": 892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,892 @@\n+// import.cc -- Go frontend import declarations.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"filenames.h\"\n+#include \"simple-object.h\"\n+\n+#include \"go-c.h\"\n+#include \"gogo.h\"\n+#include \"types.h\"\n+#include \"export.h\"\n+#include \"import.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+// The list of paths we search for import files.\n+\n+static std::vector<std::string> search_path;\n+\n+// Add a directory to the search path.  This is called from the option\n+// handling language hook.\n+\n+GO_EXTERN_C\n+void\n+go_add_search_path(const char* path)\n+{\n+  search_path.push_back(std::string(path));\n+}\n+\n+// The name used for parameters, receivers, and results in imported\n+// function types.\n+\n+const char* const Import::import_marker = \"*imported*\";\n+\n+// Find import data.  This searches the file system for FILENAME and\n+// returns a pointer to a Stream object to read the data that it\n+// exports.  If the file is not found, it returns NULL.\n+\n+// When FILENAME is not an absolute path, we use the search path\n+// provided by -I and -L options.\n+\n+// When FILENAME does not exist, we try modifying FILENAME to find the\n+// file.  We use the first of these which exists:\n+//   * We append \".gox\".\n+//   * We turn the base of FILENAME into libFILENAME.so.\n+//   * We turn the base of FILENAME into libFILENAME.a.\n+//   * We append \".o\".\n+\n+// When using a search path, we apply each of these transformations at\n+// each entry on the search path before moving on to the next entry.\n+// If the file exists, but does not contain any Go export data, we\n+// stop; we do not keep looking for another file with the same name\n+// later in the search path.\n+\n+Import::Stream*\n+Import::open_package(const std::string& filename, source_location location)\n+{\n+  if (!IS_ABSOLUTE_PATH(filename))\n+    {\n+      for (std::vector<std::string>::const_iterator p = search_path.begin();\n+\t   p != search_path.end();\n+\t   ++p)\n+\t{\n+\t  std::string indir = *p;\n+\t  if (!indir.empty() && indir[indir.size() - 1] != '/')\n+\t    indir += '/';\n+\t  indir += filename;\n+\t  Stream* s = Import::try_package_in_directory(indir, location);\n+\t  if (s != NULL)\n+\t    return s;\n+\t}\n+    }\n+\n+  Stream* s = Import::try_package_in_directory(filename, location);\n+  if (s != NULL)\n+    return s;\n+\n+  return NULL;\n+}\n+\n+// Try to find the export data for FILENAME.\n+\n+Import::Stream*\n+Import::try_package_in_directory(const std::string& filename,\n+\t\t\t\t source_location location)\n+{\n+  std::string found_filename = filename;\n+  int fd = open(found_filename.c_str(), O_RDONLY | O_BINARY);\n+\n+  if (fd >= 0)\n+    {\n+      struct stat s;\n+      if (fstat(fd, &s) >= 0 && S_ISDIR(s.st_mode))\n+\t{\n+\t  close(fd);\n+\t  fd = -1;\n+\t  errno = EISDIR;\n+\t}\n+    }\n+\n+  if (fd < 0)\n+    {\n+      if (errno != ENOENT && errno != EISDIR)\n+\twarning_at(location, 0, \"%s: %m\", filename.c_str());\n+\n+      fd = Import::try_suffixes(&found_filename);\n+      if (fd < 0)\n+\treturn NULL;\n+    }\n+\n+  // The export data may not be in this file.\n+  Stream* s = Import::find_export_data(found_filename, fd, location);\n+  if (s != NULL)\n+    return s;\n+\n+  close(fd);\n+\n+  error_at(location, \"%s exists but does not contain any Go export data\",\n+\t   found_filename.c_str());\n+\n+  return NULL;\n+}\n+\n+// Given import \"*PFILENAME\", where *PFILENAME does not exist, try\n+// various suffixes.  If we find one, set *PFILENAME to the one we\n+// found.  Return the open file descriptor.\n+\n+int\n+Import::try_suffixes(std::string* pfilename)\n+{\n+  std::string filename = *pfilename + \".gox\";\n+  int fd = open(filename.c_str(), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  const char* basename = lbasename(pfilename->c_str());\n+  size_t basename_pos = basename - pfilename->c_str();\n+  filename = pfilename->substr(0, basename_pos) + \"lib\" + basename + \".so\";\n+  fd = open(filename.c_str(), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  filename = pfilename->substr(0, basename_pos) + \"lib\" + basename + \".a\";\n+  fd = open(filename.c_str(), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  filename = *pfilename + \".o\";\n+  fd = open(filename.c_str(), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  return -1;\n+}\n+\n+// Look for export data in the file descriptor FD.\n+\n+Import::Stream*\n+Import::find_export_data(const std::string& filename, int fd,\n+\t\t\t source_location location)\n+{\n+  // See if we can read this as an object file.\n+  Import::Stream* stream = Import::find_object_export_data(filename, fd, 0,\n+\t\t\t\t\t\t\t   location);\n+  if (stream != NULL)\n+    return stream;\n+\n+  const int len = MAX(Export::v1_magic_len, Import::archive_magic_len);\n+\n+  if (lseek(fd, 0, SEEK_SET) < 0)\n+    {\n+      error_at(location, \"lseek %s failed: %m\", filename.c_str());\n+      return NULL;\n+    }\n+\n+  char buf[len];\n+  ssize_t c = read(fd, buf, len);\n+  if (c < len)\n+    return NULL;\n+\n+  // Check for a file containing nothing but Go export data.\n+  if (memcmp(buf, Export::v1_magic, Export::v1_magic_len) == 0)\n+    return new Stream_from_file(fd);\n+\n+  // See if we can read this as an archive.\n+  if (Import::is_archive_magic(buf))\n+    return Import::find_archive_export_data(filename, fd, location);\n+\n+  return NULL;\n+}\n+\n+// Look for export data in a simple_object.\n+\n+Import::Stream*\n+Import::find_object_export_data(const std::string& filename,\n+\t\t\t\tint fd,\n+\t\t\t\toff_t offset,\n+\t\t\t\tsource_location location)\n+{\n+  const char* errmsg;\n+  int err;\n+  simple_object_read* sobj = simple_object_start_read(fd, offset,\n+\t\t\t\t\t\t      \"__GNU_GO\",\n+\t\t\t\t\t\t      &errmsg, &err);\n+  if (sobj == NULL)\n+    return NULL;\n+\n+  off_t sec_offset;\n+  off_t sec_length;\n+  int found = simple_object_find_section(sobj, \".go_export\", &sec_offset,\n+\t\t\t\t\t &sec_length, &errmsg, &err);\n+\n+  simple_object_release_read(sobj);\n+\n+  if (!found)\n+    return NULL;\n+\n+  if (lseek(fd, offset + sec_offset, SEEK_SET) < 0)\n+    {\n+      error_at(location, \"lseek %s failed: %m\", filename.c_str());\n+      return NULL;\n+    }\n+\n+  char* buf = new char[sec_length];\n+  ssize_t c = read(fd, buf, sec_length);\n+  if (c < 0)\n+    {\n+      error_at(location, \"read %s failed: %m\", filename.c_str());\n+      return NULL;\n+    }\n+  if (c < sec_length)\n+    {\n+      error_at(location, \"%s: short read\", filename.c_str());\n+      return NULL;\n+    }\n+\n+  return new Stream_from_buffer(buf, sec_length);\n+}\n+\n+// Class Import.\n+\n+// Construct an Import object.  We make the builtin_types_ vector\n+// large enough to hold all the builtin types.\n+\n+Import::Import(Stream* stream, source_location location)\n+  : gogo_(NULL), stream_(stream), location_(location), package_(NULL),\n+    add_to_globals_(false),\n+    builtin_types_((- SMALLEST_BUILTIN_CODE) + 1),\n+    types_()\n+{\n+}\n+\n+// Import the data in the associated stream.\n+\n+Package*\n+Import::import(Gogo* gogo, const std::string& local_name,\n+\t       bool is_local_name_exported)\n+{\n+  // Hold on to the Gogo structure.  Otherwise we need to pass it\n+  // through all the import functions, because we need it when reading\n+  // a type.\n+  this->gogo_ = gogo;\n+\n+  // A stream of export data can include data from more than one input\n+  // file.  Here we loop over each input file.\n+  Stream* stream = this->stream_;\n+  while (!stream->at_eof() && !stream->saw_error())\n+    {\n+      // The vector of types is package specific.\n+      this->types_.clear();\n+\n+      stream->require_bytes(this->location_, Export::v1_magic,\n+\t\t\t    Export::v1_magic_len);\n+\n+      this->require_c_string(\"package \");\n+      std::string package_name = this->read_identifier();\n+      this->require_c_string(\";\\n\");\n+\n+      this->require_c_string(\"prefix \");\n+      std::string unique_prefix = this->read_identifier();\n+      this->require_c_string(\";\\n\");\n+\n+      this->package_ = gogo->add_imported_package(package_name, local_name,\n+\t\t\t\t\t\t  is_local_name_exported,\n+\t\t\t\t\t\t  unique_prefix,\n+\t\t\t\t\t\t  this->location_,\n+\t\t\t\t\t\t  &this->add_to_globals_);\n+      if (this->package_ == NULL)\n+\t{\n+\t  stream->set_saw_error();\n+\t  return NULL;\n+\t}\n+\n+      this->require_c_string(\"priority \");\n+      std::string priority_string = this->read_identifier();\n+      int prio;\n+      if (!this->string_to_int(priority_string, false, &prio))\n+\treturn NULL;\n+      this->package_->set_priority(prio);\n+      this->require_c_string(\";\\n\");\n+\n+      if (stream->match_c_string(\"import \"))\n+\tthis->read_import_init_fns(gogo);\n+\n+      // Loop over all the input data for this package.\n+      while (!stream->saw_error())\n+\t{\n+\t  if (stream->match_c_string(\"const \"))\n+\t    this->import_const();\n+\t  else if (stream->match_c_string(\"type \"))\n+\t    this->import_type();\n+\t  else if (stream->match_c_string(\"var \"))\n+\t    this->import_var();\n+\t  else if (stream->match_c_string(\"func \"))\n+\t    this->import_func(this->package_);\n+\t  else if (stream->match_c_string(\"checksum \"))\n+\t    break;\n+\t  else\n+\t    {\n+\t      error_at(this->location_,\n+\t\t       (\"error in import data at %d: \"\n+\t\t\t\"expected %<const%>, %<type%>, %<var%>, \"\n+\t\t\t\"%<func%>, or %<checksum%>\"),\n+\t\t       stream->pos());\n+\t      stream->set_saw_error();\n+\t      return NULL;\n+\t    }\n+\t}\n+\n+      // We currently ignore the checksum.  In the future we could\n+      // store the checksum somewhere in the generated object and then\n+      // verify that the checksum matches at link time or at dynamic\n+      // load time.\n+      this->require_c_string(\"checksum \");\n+      stream->advance(Export::v1_checksum_len * 2);\n+      this->require_c_string(\";\\n\");\n+    }\n+\n+  return this->package_;\n+}\n+\n+// Read the list of import control functions.\n+\n+void\n+Import::read_import_init_fns(Gogo* gogo)\n+{\n+  this->require_c_string(\"import\");\n+  while (!this->match_c_string(\";\"))\n+    {\n+      this->require_c_string(\" \");\n+      std::string package_name = this->read_identifier();\n+      this->require_c_string(\" \");\n+      std::string init_name = this->read_identifier();\n+      this->require_c_string(\" \");\n+      std::string prio_string = this->read_identifier();\n+      int prio;\n+      if (!this->string_to_int(prio_string, false, &prio))\n+\treturn;\n+      gogo->add_import_init_fn(package_name, init_name, prio);\n+    }\n+  this->require_c_string(\";\\n\");\n+}\n+\n+// Import a constant.\n+\n+void\n+Import::import_const()\n+{\n+  std::string name;\n+  Type* type;\n+  Expression* expr;\n+  Named_constant::import_const(this, &name, &type, &expr);\n+  Typed_identifier tid(name, type, this->location_);\n+  Named_object* no = this->package_->add_constant(tid, expr);\n+  if (this->add_to_globals_)\n+    this->gogo_->add_named_object(no);\n+}\n+\n+// Import a type.\n+\n+void\n+Import::import_type()\n+{\n+  Named_type* type;\n+  Named_type::import_named_type(this, &type);\n+\n+  // The named type has been added to the package by the type import\n+  // process.  Here we need to make it visible to the parser, and it\n+  // to the global bindings if necessary.\n+  type->set_is_visible();\n+\n+  if (this->add_to_globals_)\n+    this->gogo_->add_named_type(type);\n+}\n+\n+// Import a variable.\n+\n+void\n+Import::import_var()\n+{\n+  std::string name;\n+  Type* type;\n+  Variable::import_var(this, &name, &type);\n+  Variable* var = new Variable(type, NULL, true, false, false,\n+\t\t\t       this->location_);\n+  Named_object* no;\n+  no = this->package_->add_variable(name, var);\n+  if (this->add_to_globals_)\n+    this->gogo_->add_named_object(no);\n+}\n+\n+// Import a function into PACKAGE.  PACKAGE is normally\n+// THIS->PACKAGE_, but it will be different for a method associated\n+// with a type defined in a different package.\n+\n+Named_object*\n+Import::import_func(Package* package)\n+{\n+  std::string name;\n+  Typed_identifier* receiver;\n+  Typed_identifier_list* parameters;\n+  Typed_identifier_list* results;\n+  bool is_varargs;\n+  Function::import_func(this, &name, &receiver, &parameters, &results,\n+\t\t\t&is_varargs);\n+  Function_type *fntype = Type::make_function_type(receiver, parameters,\n+\t\t\t\t\t\t   results, this->location_);\n+  if (is_varargs)\n+    fntype->set_is_varargs();\n+\n+  source_location loc = this->location_;\n+  Named_object* no;\n+  if (fntype->is_method())\n+    {\n+      Type* rtype = receiver->type()->deref();\n+      if (rtype->is_error_type())\n+\treturn NULL;\n+      Named_type* named_rtype = rtype->named_type();\n+      gcc_assert(named_rtype != NULL);\n+      no = named_rtype->add_method_declaration(name, package, fntype, loc);\n+    }\n+  else\n+    {\n+      no = package->add_function_declaration(name, fntype, loc);\n+      if (this->add_to_globals_)\n+\tthis->gogo_->add_named_object(no);\n+    }\n+  return no;\n+}\n+\n+// Read a type in the import stream.  This records the type by the\n+// type index.  If the type is named, it registers the name, but marks\n+// it as invisible.\n+\n+Type*\n+Import::read_type()\n+{\n+  Stream* stream = this->stream_;\n+  this->require_c_string(\"<type \");\n+\n+  std::string number;\n+  int c;\n+  while (true)\n+    {\n+      c = stream->get_char();\n+      if (c != '-' && (c < '0' || c > '9'))\n+\tbreak;\n+      number += c;\n+    }\n+\n+  int index;\n+  if (!this->string_to_int(number, true, &index))\n+    return Type::make_error_type();\n+\n+  if (c == '>')\n+    {\n+      // This type was already defined.\n+      if (index < 0\n+\t  ? (static_cast<size_t>(- index) >= this->builtin_types_.size()\n+\t     || this->builtin_types_[- index] == NULL)\n+\t  : (static_cast<size_t>(index) >= this->types_.size()\n+\t     || this->types_[index] == NULL))\n+\t{\n+\t  error_at(this->location_,\n+\t\t   \"error in import data at %d: bad type index %d\",\n+\t\t   stream->pos(), index);\n+\t  stream->set_saw_error();\n+\t  return Type::make_error_type();\n+\t}\n+\n+      return index < 0 ? this->builtin_types_[- index] : this->types_[index];\n+    }\n+\n+  if (c != ' ')\n+    {\n+      if (!stream->saw_error())\n+\terror_at(this->location_,\n+\t\t \"error in import data at %d: expect %< %> or %<>%>'\",\n+\t\t stream->pos());\n+      stream->set_saw_error();\n+      stream->advance(1);\n+      return Type::make_error_type();\n+    }\n+\n+  if (index <= 0\n+      || (static_cast<size_t>(index) < this->types_.size()\n+\t  && this->types_[index] != NULL))\n+    {\n+      error_at(this->location_,\n+\t       \"error in import data at %d: type index already defined\",\n+\t       stream->pos());\n+      stream->set_saw_error();\n+      return Type::make_error_type();\n+    }\n+\n+  if (static_cast<size_t>(index) >= this->types_.size())\n+    {\n+      int newsize = std::max(static_cast<size_t>(index) + 1,\n+\t\t\t     this->types_.size() * 2);\n+      this->types_.resize(newsize, NULL);\n+    }\n+\n+  if (stream->peek_char() != '\"')\n+    {\n+      Type* type = Type::import_type(this);\n+      this->require_c_string(\">\");\n+      this->types_[index] = type;\n+      return type;\n+    }\n+\n+  // This type has a name.\n+\n+  stream->advance(1);\n+  std::string type_name;\n+  while ((c = stream->get_char()) != '\"')\n+    type_name += c;\n+\n+  // If this type is in the current package, the name will be\n+  // .PREFIX.PACKAGE.NAME or simply NAME with no dots.  Otherwise, a\n+  // non-hidden symbol will be PREFIX.PACKAGE.NAME and a hidden symbol\n+  // will be .PREFIX.PACKAGE.NAME.\n+  std::string package_name;\n+  std::string unique_prefix;\n+  if (type_name.find('.') != std::string::npos)\n+    {\n+      bool is_hidden = false;\n+      size_t start = 0;\n+      if (type_name[0] == '.')\n+\t{\n+\t  ++start;\n+\t  is_hidden = true;\n+\t}\n+      size_t dot1 = type_name.find('.', start);\n+      size_t dot2;\n+      if (dot1 == std::string::npos)\n+\tdot2 = std::string::npos;\n+      else\n+\tdot2 = type_name.find('.', dot1 + 1);\n+      if (dot1 == std::string::npos || dot2 == std::string::npos)\n+\t{\n+\t  error_at(this->location_,\n+\t\t   (\"error at import data at %d: missing dot in type name\"),\n+\t\t   stream->pos());\n+\t  stream->set_saw_error();\n+\t}\n+      else\n+\t{\n+\t  unique_prefix = type_name.substr(start, dot1 - start);\n+\t  package_name = type_name.substr(dot1 + 1, dot2 - (dot1 + 1));\n+\t}\n+      if (!is_hidden)\n+\ttype_name.erase(0, dot2 + 1);\n+    }\n+\n+  this->require_c_string(\" \");\n+\n+  // Declare the type in the appropriate package.  If we haven't seen\n+  // it before, mark it as invisible.  We declare it before we read\n+  // the actual definition of the type, since the definition may refer\n+  // to the type itself.\n+  Package* package;\n+  if (package_name.empty())\n+    package = this->package_;\n+  else\n+    package = this->gogo_->register_package(package_name, unique_prefix,\n+\t\t\t\t\t    UNKNOWN_LOCATION);\n+\n+  Named_object* no = package->bindings()->lookup(type_name);\n+  if (no == NULL)\n+    no = package->add_type_declaration(type_name, this->location_);\n+  else if (!no->is_type_declaration() && !no->is_type())\n+    {\n+      error_at(this->location_, \"imported %<%s.%s%> both type and non-type\",\n+\t       Gogo::message_name(package->name()).c_str(),\n+\t       Gogo::message_name(type_name).c_str());\n+      stream->set_saw_error();\n+      return Type::make_error_type();\n+    }\n+  else\n+    gcc_assert(no->package() == package);\n+\n+  if (this->types_[index] == NULL)\n+    {\n+      if (no->is_type_declaration())\n+\t{\n+\t  // FIXME: It's silly to make a forward declaration every time.\n+\t  this->types_[index] = Type::make_forward_declaration(no);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert(no->is_type());\n+\t  this->types_[index] = no->type_value();\n+\t}\n+    }\n+\n+  // If there is no type definition, then this is just a forward\n+  // declaration of a type defined in some other file.\n+  Type* type;\n+  if (this->match_c_string(\">\"))\n+    type = this->types_[index];\n+  else\n+    {\n+      type = this->read_type();\n+\n+      if (no->is_type_declaration())\n+\t{\n+\t  // We can define the type now.\n+\n+\t  no = package->add_type(type_name, type, this->location_);\n+\t  Named_type* ntype = no->type_value();\n+\n+\t  // This type has not yet been imported.\n+\t  ntype->clear_is_visible();\n+\n+\t  type = ntype;\n+\t}\n+      else if (no->is_type())\n+\t{\n+\t  // We have seen this type before.  FIXME: it would be a good\n+\t  // idea to check that the two imported types are identical,\n+\t  // but we have not finalized the methds yet, which means\n+\t  // that we can nt reliably compare interface types.\n+\t  type = no->type_value();\n+\n+\t  // Don't change the visibility of the existing type.\n+\t}\n+\n+      this->types_[index] = type;\n+\n+      // Read the type methods.\n+      if (this->match_c_string(\"\\n\"))\n+\t{\n+\t  this->advance(1);\n+\t  while (this->match_c_string(\" func\"))\n+\t    {\n+\t      this->advance(1);\n+\t      this->import_func(package);\n+\t    }\n+\t}\n+    }\n+\n+  this->require_c_string(\">\");\n+\n+  return type;\n+}\n+\n+// Register the builtin types.\n+\n+void\n+Import::register_builtin_types(Gogo* gogo)\n+{\n+  this->register_builtin_type(gogo, \"int8\", BUILTIN_INT8);\n+  this->register_builtin_type(gogo, \"int16\", BUILTIN_INT16);\n+  this->register_builtin_type(gogo, \"int32\", BUILTIN_INT32);\n+  this->register_builtin_type(gogo, \"int64\", BUILTIN_INT64);\n+  this->register_builtin_type(gogo, \"uint8\", BUILTIN_UINT8);\n+  this->register_builtin_type(gogo, \"uint16\", BUILTIN_UINT16);\n+  this->register_builtin_type(gogo, \"uint32\", BUILTIN_UINT32);\n+  this->register_builtin_type(gogo, \"uint64\", BUILTIN_UINT64);\n+  this->register_builtin_type(gogo, \"float32\", BUILTIN_FLOAT32);\n+  this->register_builtin_type(gogo, \"float64\", BUILTIN_FLOAT64);\n+  this->register_builtin_type(gogo, \"complex64\", BUILTIN_COMPLEX64);\n+  this->register_builtin_type(gogo, \"complex128\", BUILTIN_COMPLEX128);\n+  this->register_builtin_type(gogo, \"int\", BUILTIN_INT);\n+  this->register_builtin_type(gogo, \"uint\", BUILTIN_UINT);\n+  this->register_builtin_type(gogo, \"uintptr\", BUILTIN_UINTPTR);\n+  this->register_builtin_type(gogo, \"float\", BUILTIN_FLOAT);\n+  this->register_builtin_type(gogo, \"complex\", BUILTIN_COMPLEX);\n+  this->register_builtin_type(gogo, \"bool\", BUILTIN_BOOL);\n+  this->register_builtin_type(gogo, \"string\", BUILTIN_STRING);\n+}\n+\n+// Register a single builtin type.\n+\n+void\n+Import::register_builtin_type(Gogo* gogo, const char* name, Builtin_code code)\n+{\n+  Named_object* named_object = gogo->lookup_global(name);\n+  gcc_assert(named_object != NULL && named_object->is_type());\n+  int index = - static_cast<int>(code);\n+  gcc_assert(index > 0\n+\t     && static_cast<size_t>(index) < this->builtin_types_.size());\n+  this->builtin_types_[index] = named_object->type_value();\n+}\n+\n+// Read an identifier from the stream.\n+\n+std::string\n+Import::read_identifier()\n+{\n+  std::string ret;\n+  Stream* stream = this->stream_;\n+  int c;\n+  while (true)\n+    {\n+      c = stream->peek_char();\n+      if (c == -1 || c == ' ' || c == ';')\n+\tbreak;\n+      ret += c;\n+      stream->advance(1);\n+    }\n+  return ret;\n+}\n+\n+// Turn a string into a integer with appropriate error handling.\n+\n+bool\n+Import::string_to_int(const std::string &s, bool is_neg_ok, int* ret)\n+{\n+  char* end;\n+  long prio = strtol(s.c_str(), &end, 10);\n+  if (*end != '\\0' || prio > 0x7fffffff || (prio < 0 && !is_neg_ok))\n+    {\n+      error_at(this->location_, \"invalid integer in import data at %d\",\n+\t       this->stream_->pos());\n+      this->stream_->set_saw_error();\n+      return false;\n+    }\n+  *ret = prio;\n+  return true;\n+}\n+\n+// Class Import::Stream.\n+\n+Import::Stream::Stream()\n+  : pos_(0), saw_error_(false)\n+{\n+}\n+\n+Import::Stream::~Stream()\n+{\n+}\n+\n+// Return the next character to come from the stream.\n+\n+int\n+Import::Stream::peek_char()\n+{\n+  const char* read;\n+  if (!this->do_peek(1, &read))\n+    return -1;\n+  // Make sure we return an unsigned char, so that we don't get\n+  // confused by \\xff.\n+  unsigned char ret = *read;\n+  return ret;\n+}\n+\n+// Return true if the next LENGTH characters from the stream match\n+// BYTES\n+\n+bool\n+Import::Stream::match_bytes(const char* bytes, size_t length)\n+{\n+  const char* read;\n+  if (!this->do_peek(length, &read))\n+    return false;\n+  return memcmp(bytes, read, length) == 0;\n+}\n+\n+// Require that the next LENGTH bytes from the stream match BYTES.\n+\n+void\n+Import::Stream::require_bytes(source_location location, const char* bytes,\n+\t\t\t      size_t length)\n+{\n+  const char* read;\n+  if (!this->do_peek(length, &read)\n+      || memcmp(bytes, read, length) != 0)\n+    {\n+      if (!this->saw_error_)\n+\terror_at(location, \"import error at %d: expected %<%.*s%>\",\n+\t\t this->pos(), static_cast<int>(length), bytes);\n+      this->saw_error_ = true;\n+      return;\n+    }\n+  this->advance(length);\n+}\n+\n+// Class Stream_from_file.\n+\n+Stream_from_file::Stream_from_file(int fd)\n+  : fd_(fd), data_()\n+{\n+  if (lseek(fd, 0, SEEK_SET) != 0)\n+    {\n+      error(\"lseek failed: %m\");\n+      this->set_saw_error();\n+    }\n+}\n+\n+Stream_from_file::~Stream_from_file()\n+{\n+  close(this->fd_);\n+}\n+\n+// Read next bytes.\n+\n+bool\n+Stream_from_file::do_peek(size_t length, const char** bytes)\n+{\n+  if (this->data_.length() <= length)\n+    {\n+      *bytes = this->data_.data();\n+      return true;\n+    }\n+  // Don't bother to handle the general case, since we don't need it.\n+  gcc_assert(length < 64);\n+  char buf[64];\n+  ssize_t got = read(this->fd_, buf, length);\n+\n+  if (got < 0)\n+    {\n+      if (!this->saw_error())\n+\terror(\"read failed: %m\");\n+      this->set_saw_error();\n+      return false;\n+    }\n+\n+  if (lseek(this->fd_, - got, SEEK_CUR) != 0)\n+    {\n+      if (!this->saw_error())\n+\terror(\"lseek failed: %m\");\n+      this->set_saw_error();\n+      return false;\n+    }\n+\n+  if (static_cast<size_t>(got) < length)\n+    return false;\n+\n+  this->data_.assign(buf, got);\n+\n+  *bytes = this->data_.data();\n+  return true;\n+}\n+\n+// Advance.\n+\n+void\n+Stream_from_file::do_advance(size_t skip)\n+{\n+  if (lseek(this->fd_, skip, SEEK_CUR) != 0)\n+    {\n+      if (!this->saw_error())\n+\terror(\"lseek failed: %m\");\n+      this->set_saw_error();\n+    }\n+  if (!this->data_.empty())\n+    {\n+      if (this->data_.length() < skip)\n+\tthis->data_.erase(0, skip);\n+      else\n+\tthis->data_.clear();\n+    }\n+}"}, {"sha": "0101a40c963642ad988545769b644ef5f37882a6", "filename": "gcc/go/gofrontend/import.h", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,351 @@\n+// import.h -- Go frontend import declarations.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_IMPORT_H\n+#define GO_IMPORT_H\n+\n+#include \"export.h\"\n+\n+class Gogo;\n+class Package;\n+class Type;\n+class Named_object;\n+class Named_type;\n+class Expression;\n+\n+// This class manages importing Go declarations.\n+\n+class Import\n+{\n+ public:\n+  // The Stream class is an interface used to read the data.  The\n+  // caller should instantiate a child of this class.\n+  class Stream\n+  {\n+   public:\n+    Stream();\n+    virtual ~Stream();\n+\n+    // Return whether we have seen an error.\n+    bool\n+    saw_error() const\n+    { return this->saw_error_; }\n+\n+    // Record that we've seen an error.\n+    void\n+    set_saw_error()\n+    { this->saw_error_ = true; }\n+\n+    // Return the next character (a value from 0 to 0xff) without\n+    // advancing.  Returns -1 at end of stream.\n+    int\n+    peek_char();\n+\n+    // Look for LENGTH characters, setting *BYTES to point to them.\n+    // Returns false if the bytes are not available.  Does not\n+    // advance.\n+    bool\n+    peek(size_t length, const char** bytes)\n+    { return this->do_peek(length, bytes); }\n+\n+    // Return the next character (a value from 0 to 0xff) and advance\n+    // the read position by 1.  Returns -1 at end of stream.\n+    int\n+    get_char()\n+    {\n+      int c = this->peek_char();\n+      this->advance(1);\n+      return c;\n+    }\n+\n+    // Return true if at the end of the stream.\n+    bool\n+    at_eof()\n+    { return this->peek_char() == -1; }\n+\n+    // Return true if the next bytes match STR.\n+    bool\n+    match_c_string(const char* str)\n+    { return this->match_bytes(str, strlen(str)); }\n+\n+    // Return true if the next LENGTH bytes match BYTES.\n+    bool\n+    match_bytes(const char* bytes, size_t length);\n+\n+    // Give an error if the next bytes do not match STR.  Advance the\n+    // read position by the length of STR.\n+    void\n+    require_c_string(source_location location, const char* str)\n+    { this->require_bytes(location, str, strlen(str)); }\n+\n+    // Given an error if the next LENGTH bytes do not match BYTES.\n+    // Advance the read position by LENGTH.\n+    void\n+    require_bytes(source_location, const char* bytes, size_t length);\n+\n+    // Advance the read position by SKIP bytes.\n+    void\n+    advance(size_t skip)\n+    {\n+      this->do_advance(skip);\n+      this->pos_ += skip;\n+    }\n+\n+    // Return the current read position.  This returns int because it\n+    // is more convenient in error reporting.  FIXME.\n+    int\n+    pos()\n+    { return static_cast<int>(this->pos_); }\n+\n+   protected:\n+    // This function should set *BYTES to point to a buffer holding\n+    // the LENGTH bytes at the current read position.  It should\n+    // return false if the bytes are not available.  This should not\n+    // change the current read position.\n+    virtual bool\n+    do_peek(size_t length, const char** bytes) = 0;\n+\n+    // This function should advance the current read position LENGTH\n+    // bytes.\n+    virtual void\n+    do_advance(size_t skip) = 0;\n+\n+   private:\n+    // The current read position.\n+    size_t pos_;\n+    // True if we've seen an error reading from this stream.\n+    bool saw_error_;\n+  };\n+\n+  // Find import data.  This searches the file system for FILENAME and\n+  // returns a pointer to a Stream object to read the data that it\n+  // exports.  LOCATION is the location of the import statement.\n+  static Stream*\n+  open_package(const std::string& filename, source_location location);\n+\n+  // Constructor.\n+  Import(Stream*, source_location);\n+\n+  // Register the builtin types.\n+  void\n+  register_builtin_types(Gogo*);\n+\n+  // Import everything defined in the stream.  LOCAL_NAME is the local\n+  // name to be used for bindings; if it is the string \".\" then\n+  // bindings should be inserted in the global scope.  If LOCAL_NAME\n+  // is the empty string then the name of the package itself is the\n+  // local name.  This returns the imported package, or NULL on error.\n+  Package*\n+  import(Gogo*, const std::string& local_name, bool is_local_name_exported);\n+\n+  // The location of the import statement.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the next character.\n+  int\n+  peek_char()\n+  { return this->stream_->peek_char(); }\n+\n+  // Return the next character and advance.\n+  int\n+  get_char()\n+  { return this->stream_->get_char(); }\n+\n+  // Return true at the end of the stream.\n+  bool\n+  at_eof()\n+  { return this->stream_->at_eof(); }\n+\n+  // Return whether the next bytes match STR.\n+  bool\n+  match_c_string(const char* str)\n+  { return this->stream_->match_c_string(str); }\n+\n+  // Require that the next bytes match STR.\n+  void\n+  require_c_string(const char* str)\n+  { this->stream_->require_c_string(this->location_, str); }\n+\n+  // Advance the stream SKIP bytes.\n+  void\n+  advance(size_t skip)\n+  { this->stream_->advance(skip); }\n+\n+  // Read an identifier.\n+  std::string\n+  read_identifier();\n+\n+  // Read a type.\n+  Type*\n+  read_type();\n+\n+  // The name used for parameters, receivers, and results in imported\n+  // function types.\n+  static const char* const import_marker;\n+\n+ private:\n+  static Stream*\n+  try_package_in_directory(const std::string&, source_location);\n+\n+  static int\n+  try_suffixes(std::string*);\n+\n+  static Stream*\n+  find_export_data(const std::string& filename, int fd, source_location);\n+\n+  static Stream*\n+  find_object_export_data(const std::string& filename, int fd,\n+\t\t\t  off_t offset, source_location);\n+\n+  static const int archive_magic_len = 8;\n+\n+  static bool\n+  is_archive_magic(const char*);\n+\n+  static Stream*\n+  find_archive_export_data(const std::string& filename, int fd,\n+\t\t\t   source_location);\n+\n+  // Read the import control functions.\n+  void\n+  read_import_init_fns(Gogo*);\n+\n+  // Import a constant.\n+  void\n+  import_const();\n+\n+  // Import a type.\n+  void\n+  import_type();\n+\n+  // Import a variable.\n+  void\n+  import_var();\n+\n+  // Import a function.\n+  Named_object*\n+  import_func(Package*);\n+\n+  // Register a single builtin type.\n+  void\n+  register_builtin_type(Gogo*, const char* name, Builtin_code);\n+\n+  // Get an integer from a string.\n+  bool\n+  string_to_int(const std::string&, bool is_neg_ok, int* ret);\n+\n+  // The general IR.\n+  Gogo* gogo_;\n+  // The stream from which to read import data.\n+  Stream* stream_;\n+  // The location of the import statement we are processing.\n+  source_location location_;\n+  // The package we are importing.\n+  Package* package_;\n+  // Whether to add new objects to the global scope, rather than to a\n+  // package scope.\n+  bool add_to_globals_;\n+  // Mapping from negated builtin type codes to Type structures.\n+  std::vector<Named_type*> builtin_types_;\n+  // Mapping from exported type codes to Type structures.\n+  std::vector<Type*> types_;\n+};\n+\n+// Read import data from a string.\n+\n+class Stream_from_string : public Import::Stream\n+{\n+ public:\n+  Stream_from_string(const std::string& str)\n+    : str_(str), pos_(0)\n+  { }\n+\n+ protected:\n+  bool\n+  do_peek(size_t length, const char** bytes)\n+  {\n+    if (this->pos_ + length > this->str_.length())\n+      return false;\n+    *bytes = this->str_.data() + this->pos_;\n+    return true;\n+  }\n+\n+  void\n+  do_advance(size_t len)\n+  { this->pos_ += len; }\n+\n+ private:\n+  // The string of data we are reading.\n+  std::string str_;\n+  // The current position within the string.\n+  size_t pos_;\n+};\n+\n+// Read import data from an allocated buffer.\n+\n+class Stream_from_buffer : public Import::Stream\n+{\n+ public:\n+  Stream_from_buffer(char* buf, size_t length)\n+    : buf_(buf), length_(length), pos_(0)\n+  { }\n+\n+  ~Stream_from_buffer()\n+  { delete[] this->buf_; }\n+\n+ protected:\n+  bool\n+  do_peek(size_t length, const char** bytes)\n+  {\n+    if (this->pos_ + length > this->length_)\n+      return false;\n+    *bytes = this->buf_ + this->pos_;\n+    return true;\n+  }\n+\n+  void\n+  do_advance(size_t len)\n+  { this->pos_ += len; }\n+\n+ private:\n+  // The data we are reading.\n+  char* buf_;\n+  // The length of the buffer.\n+  size_t length_;\n+  // The current position within the buffer.\n+  size_t pos_;\n+};\n+\n+// Read import data from an open file descriptor.\n+\n+class Stream_from_file : public Import::Stream\n+{\n+ public:\n+  Stream_from_file(int fd);\n+\n+  ~Stream_from_file();\n+\n+ protected:\n+  bool\n+  do_peek(size_t, const char**);\n+\n+  void\n+  do_advance(size_t);\n+\n+ private:\n+  // No copying.\n+  Stream_from_file(const Stream_from_file&);\n+  Stream_from_file& operator=(const Stream_from_file&);\n+\n+  // The file descriptor.\n+  int fd_;\n+  // Data read from the file.\n+  std::string data_;\n+};\n+\n+#endif // !defined(GO_IMPORT_H)"}, {"sha": "bc2531e8bd33f7dbc3d4186b8aea6b46f7d4f55d", "filename": "gcc/go/gofrontend/lex.cc", "status": "added", "additions": 2287, "deletions": 0, "changes": 2287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,2287 @@\n+// lex.cc -- Go frontend lexer.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"lex.h\"\n+\n+// Manage mapping from keywords to the Keyword codes.\n+\n+class Keywords\n+{\n+ public:\n+  // The structure which maps keywords to codes.\n+  struct Mapping\n+  {\n+    // Keyword string.\n+    const char* keystring;\n+    // Keyword code.\n+    Keyword keycode;\n+  };\n+\n+  // Return the parsecode corresponding to KEYSTRING, or\n+  // KEYWORD_INVALID if it is not a keyword.\n+  Keyword\n+  keyword_to_code(const char* keyword, size_t len) const;\n+\n+  // Return the string for a keyword.\n+  const char*\n+  keyword_to_string(Keyword) const;\n+\n+ private:\n+  static const Mapping mapping_[];\n+  static const int count_;\n+};\n+\n+// Mapping from keyword string to keyword code.  This array must be\n+// kept in sorted order, and the order must match the Keyword enum.\n+// Strings are looked up using bsearch.\n+\n+const Keywords::Mapping\n+Keywords::mapping_[] =\n+{\n+  { NULL,\t   KEYWORD_INVALID },\n+  { \"__asm__\",\t   KEYWORD_ASM },\n+  { \"break\",\t   KEYWORD_BREAK },\n+  { \"case\",\t   KEYWORD_CASE },\n+  { \"chan\",\t   KEYWORD_CHAN },\n+  { \"const\",\t   KEYWORD_CONST },\n+  { \"continue\",\t   KEYWORD_CONTINUE },\n+  { \"default\",\t   KEYWORD_DEFAULT },\n+  { \"defer\",\t   KEYWORD_DEFER },\n+  { \"else\",\t   KEYWORD_ELSE },\n+  { \"fallthrough\", KEYWORD_FALLTHROUGH },\n+  { \"for\",\t   KEYWORD_FOR },\n+  { \"func\",\t   KEYWORD_FUNC },\n+  { \"go\",\t   KEYWORD_GO },\n+  { \"goto\",\t   KEYWORD_GOTO },\n+  { \"if\",\t   KEYWORD_IF },\n+  { \"import\",\t   KEYWORD_IMPORT },\n+  { \"interface\",   KEYWORD_INTERFACE },\n+  { \"map\",\t   KEYWORD_MAP },\n+  { \"package\",\t   KEYWORD_PACKAGE },\n+  { \"range\",\t   KEYWORD_RANGE },\n+  { \"return\",\t   KEYWORD_RETURN },\n+  { \"select\",\t   KEYWORD_SELECT },\n+  { \"struct\",\t   KEYWORD_STRUCT },\n+  { \"switch\",\t   KEYWORD_SWITCH },\n+  { \"type\",\t   KEYWORD_TYPE },\n+  { \"var\",\t   KEYWORD_VAR }\n+};\n+\n+// Number of entries in the map.\n+\n+const int Keywords::count_ =\n+  sizeof(Keywords::mapping_) / sizeof(Keywords::mapping_[0]);\n+\n+// Comparison function passed to bsearch.\n+\n+extern \"C\"\n+{\n+\n+struct Keywords_search_key\n+{\n+  const char* str;\n+  size_t len;\n+};\n+\n+static int\n+keyword_compare(const void* keyv, const void* mapv)\n+{\n+  const Keywords_search_key* key =\n+    static_cast<const Keywords_search_key*>(keyv);\n+  const Keywords::Mapping* map =\n+    static_cast<const Keywords::Mapping*>(mapv);\n+  if (map->keystring == NULL)\n+    return 1;\n+  int i = strncmp(key->str, map->keystring, key->len);\n+  if (i != 0)\n+    return i;\n+  if (map->keystring[key->len] != '\\0')\n+    return -1;\n+  return 0;\n+}\n+\n+} // End extern \"C\".\n+\n+// Convert a string to a keyword code.  Return KEYWORD_INVALID if the\n+// string is not a keyword.\n+\n+Keyword\n+Keywords::keyword_to_code(const char* keyword, size_t len) const\n+{\n+  Keywords_search_key key;\n+  key.str = keyword;\n+  key.len = len;\n+  void* mapv = bsearch(&key,\n+                       this->mapping_,\n+                       this->count_,\n+                       sizeof(this->mapping_[0]),\n+                       keyword_compare);\n+  if (mapv == NULL)\n+    return KEYWORD_INVALID;\n+  Mapping* map = static_cast<Mapping*>(mapv);\n+  return map->keycode;\n+}\n+\n+// Convert a keyword code to a string.\n+\n+const char*\n+Keywords::keyword_to_string(Keyword code) const\n+{\n+  gcc_assert(code > KEYWORD_INVALID && code < this->count_);\n+  const Mapping* map = &this->mapping_[code];\n+  gcc_assert(map->keycode == code);\n+  return map->keystring;\n+}\n+\n+// There is one instance of the Keywords class.\n+\n+static Keywords keywords;\n+\n+// Class Token.\n+\n+// Make a general token.\n+\n+Token::Token(Classification classification, source_location location)\n+  : classification_(classification), location_(location)\n+{\n+}\n+\n+// Destroy a token.\n+\n+Token::~Token()\n+{\n+  this->clear();\n+}\n+\n+// Clear a token--release memory.\n+\n+void\n+Token::clear()\n+{\n+  if (this->classification_ == TOKEN_INTEGER)\n+    mpz_clear(this->u_.integer_value);\n+  else if (this->classification_ == TOKEN_FLOAT\n+\t   || this->classification_ == TOKEN_IMAGINARY)\n+    mpfr_clear(this->u_.float_value);\n+}\n+\n+// Construct a token.\n+\n+Token::Token(const Token& tok)\n+  : classification_(tok.classification_), location_(tok.location_)\n+{\n+  switch (this->classification_)\n+    {\n+    case TOKEN_INVALID:\n+    case TOKEN_EOF:\n+      break;\n+    case TOKEN_KEYWORD:\n+      this->u_.keyword = tok.u_.keyword;\n+      break;\n+    case TOKEN_IDENTIFIER:\n+    case TOKEN_STRING:\n+      this->u_.string_value = tok.u_.string_value;\n+      break;\n+    case TOKEN_OPERATOR:\n+      this->u_.op = tok.u_.op;\n+      break;\n+    case TOKEN_INTEGER:\n+      mpz_init_set(this->u_.integer_value, tok.u_.integer_value);\n+      break;\n+    case TOKEN_FLOAT:\n+    case TOKEN_IMAGINARY:\n+      mpfr_init_set(this->u_.float_value, tok.u_.float_value, GMP_RNDN);\n+      break;\n+    default:\n+      gcc_unreachable();\n+    }\n+}\n+\n+// Assign to a token.\n+\n+Token&\n+Token::operator=(const Token& tok)\n+{\n+  this->clear();\n+  this->classification_ = tok.classification_;\n+  this->location_ = tok.location_;\n+  switch (tok.classification_)\n+    {\n+    case TOKEN_INVALID:\n+    case TOKEN_EOF:\n+      break;\n+    case TOKEN_KEYWORD:\n+      this->u_.keyword = tok.u_.keyword;\n+      break;\n+    case TOKEN_IDENTIFIER:\n+      this->u_.identifier_value.name = tok.u_.identifier_value.name;\n+      this->u_.identifier_value.is_exported =\n+\ttok.u_.identifier_value.is_exported;\n+      break;\n+    case TOKEN_STRING:\n+      this->u_.string_value = tok.u_.string_value;\n+      break;\n+    case TOKEN_OPERATOR:\n+      this->u_.op = tok.u_.op;\n+      break;\n+    case TOKEN_INTEGER:\n+      mpz_init_set(this->u_.integer_value, tok.u_.integer_value);\n+      break;\n+    case TOKEN_FLOAT:\n+    case TOKEN_IMAGINARY:\n+      mpfr_init_set(this->u_.float_value, tok.u_.float_value, GMP_RNDN);\n+      break;\n+    default:\n+      gcc_unreachable();\n+    }\n+  return *this;\n+}\n+\n+// Print the token for debugging.\n+\n+void\n+Token::print(FILE* file) const\n+{\n+  switch (this->classification_)\n+    {\n+    case TOKEN_INVALID:\n+      fprintf(file, \"invalid\");\n+      break;\n+    case TOKEN_EOF:\n+      fprintf(file, \"EOF\");\n+      break;\n+    case TOKEN_KEYWORD:\n+      fprintf(file, \"keyword %s\", keywords.keyword_to_string(this->u_.keyword));\n+      break;\n+    case TOKEN_IDENTIFIER:\n+      fprintf(file, \"identifier \\\"%s\\\"\", this->u_.string_value->c_str());\n+      break;\n+    case TOKEN_STRING:\n+      fprintf(file, \"quoted string \\\"%s\\\"\", this->u_.string_value->c_str());\n+      break;\n+    case TOKEN_INTEGER:\n+      fprintf(file, \"integer \");\n+      mpz_out_str(file, 10, this->u_.integer_value);\n+      break;\n+    case TOKEN_FLOAT:\n+      fprintf(file, \"float \");\n+      mpfr_out_str(file, 10, 0, this->u_.float_value, GMP_RNDN);\n+      break;\n+    case TOKEN_IMAGINARY:\n+      fprintf(file, \"imaginary \");\n+      mpfr_out_str(file, 10, 0, this->u_.float_value, GMP_RNDN);\n+      break;\n+    case TOKEN_OPERATOR:\n+      fprintf(file, \"operator \");\n+      switch (this->u_.op)\n+\t{\n+\tcase OPERATOR_INVALID:\n+\t  fprintf(file, \"invalid\");\n+\t  break;\n+\tcase OPERATOR_OROR:\n+\t  fprintf(file, \"||\");\n+\t  break;\n+\tcase OPERATOR_ANDAND:\n+\t  fprintf(file, \"&&\");\n+\t  break;\n+\tcase OPERATOR_EQEQ:\n+\t  fprintf(file, \"==\");\n+\t  break;\n+\tcase OPERATOR_NOTEQ:\n+\t  fprintf(file, \"!=\");\n+\t  break;\n+\tcase OPERATOR_LT:\n+\t  fprintf(file, \"<\");\n+\t  break;\n+\tcase OPERATOR_LE:\n+\t  fprintf(file, \"<=\");\n+\t  break;\n+\tcase OPERATOR_GT:\n+\t  fprintf(file, \">\");\n+\t  break;\n+\tcase OPERATOR_GE:\n+\t  fprintf(file, \">=\");\n+\t  break;\n+\tcase OPERATOR_PLUS:\n+\t  fprintf(file, \"+\");\n+\t  break;\n+\tcase OPERATOR_MINUS:\n+\t  fprintf(file, \"-\");\n+\t  break;\n+\tcase OPERATOR_OR:\n+\t  fprintf(file, \"|\");\n+\t  break;\n+\tcase OPERATOR_XOR:\n+\t  fprintf(file, \"^\");\n+\t  break;\n+\tcase OPERATOR_MULT:\n+\t  fprintf(file, \"*\");\n+\t  break;\n+\tcase OPERATOR_DIV:\n+\t  fprintf(file, \"/\");\n+\t  break;\n+\tcase OPERATOR_MOD:\n+\t  fprintf(file, \"%%\");\n+\t  break;\n+\tcase OPERATOR_LSHIFT:\n+\t  fprintf(file, \"<<\");\n+\t  break;\n+\tcase OPERATOR_RSHIFT:\n+\t  fprintf(file, \">>\");\n+\t  break;\n+\tcase OPERATOR_AND:\n+\t  fprintf(file, \"&\");\n+\t  break;\n+\tcase OPERATOR_BITCLEAR:\n+\t  fprintf(file, \"&^\");\n+\t  break;\n+\tcase OPERATOR_NOT:\n+\t  fprintf(file, \"!\");\n+\t  break;\n+\tcase OPERATOR_CHANOP:\n+\t  fprintf(file, \"<-\");\n+\t  break;\n+\tcase OPERATOR_EQ:\n+\t  fprintf(file, \"=\");\n+\t  break;\n+\tcase OPERATOR_PLUSEQ:\n+\t  fprintf(file, \"+=\");\n+\t  break;\n+\tcase OPERATOR_MINUSEQ:\n+\t  fprintf(file, \"-=\");\n+\t  break;\n+\tcase OPERATOR_OREQ:\n+\t  fprintf(file, \"|=\");\n+\t  break;\n+\tcase OPERATOR_XOREQ:\n+\t  fprintf(file, \"^=\");\n+\t  break;\n+\tcase OPERATOR_MULTEQ:\n+\t  fprintf(file, \"*=\");\n+\t  break;\n+\tcase OPERATOR_DIVEQ:\n+\t  fprintf(file, \"/=\");\n+\t  break;\n+\tcase OPERATOR_MODEQ:\n+\t  fprintf(file, \"%%=\");\n+\t  break;\n+\tcase OPERATOR_LSHIFTEQ:\n+\t  fprintf(file, \"<<=\");\n+\t  break;\n+\tcase OPERATOR_RSHIFTEQ:\n+\t  fprintf(file, \">>=\");\n+\t  break;\n+\tcase OPERATOR_ANDEQ:\n+\t  fprintf(file, \"&=\");\n+\t  break;\n+\tcase OPERATOR_BITCLEAREQ:\n+\t  fprintf(file, \"&^=\");\n+\t  break;\n+\tcase OPERATOR_PLUSPLUS:\n+\t  fprintf(file, \"++\");\n+\t  break;\n+\tcase OPERATOR_MINUSMINUS:\n+\t  fprintf(file, \"--\");\n+\t  break;\n+\tcase OPERATOR_COLON:\n+\t  fprintf(file, \":\");\n+\t  break;\n+\tcase OPERATOR_COLONEQ:\n+\t  fprintf(file, \":=\");\n+\t  break;\n+\tcase OPERATOR_SEMICOLON:\n+\t  fprintf(file, \";\");\n+\t  break;\n+\tcase OPERATOR_DOT:\n+\t  fprintf(file, \".\");\n+\t  break;\n+\tcase OPERATOR_COMMA:\n+\t  fprintf(file, \",\");\n+\t  break;\n+\tcase OPERATOR_LPAREN:\n+\t  fprintf(file, \"(\");\n+\t  break;\n+\tcase OPERATOR_RPAREN:\n+\t  fprintf(file, \")\");\n+\t  break;\n+\tcase OPERATOR_LCURLY:\n+\t  fprintf(file, \"{\");\n+\t  break;\n+\tcase OPERATOR_RCURLY:\n+\t  fprintf(file, \"}\");\n+\t  break;\n+\tcase OPERATOR_LSQUARE:\n+\t  fprintf(file, \"[\");\n+\t  break;\n+\tcase OPERATOR_RSQUARE:\n+\t  fprintf(file, \"]\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable();\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable();\n+    }\n+}\n+\n+// Class Lex.\n+\n+Lex::Lex(const char* input_file_name, FILE* input_file)\n+  : input_file_name_(input_file_name), input_file_(input_file),\n+    linebuf_(NULL), linebufsize_(120), linesize_(0), lineno_(0),\n+    add_semi_at_eol_(false)\n+{\n+  this->linebuf_ = new char[this->linebufsize_];\n+  linemap_add(line_table, LC_ENTER, 0, input_file_name, 1);\n+}\n+\n+Lex::~Lex()\n+{\n+  delete[] this->linebuf_;\n+  linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n+}\n+\n+// Read a new line from the file.\n+\n+ssize_t\n+Lex::get_line()\n+{\n+  char* buf = this->linebuf_;\n+  size_t size = this->linebufsize_;\n+\n+  FILE* file = this->input_file_;\n+  size_t cur = 0;\n+  while (true)\n+    {\n+      int c = getc(file);\n+      if (c == EOF)\n+\t{\n+\t  if (cur == 0)\n+\t    return -1;\n+\t  break;\n+\t}\n+      if (cur + 1 >= size)\n+\t{\n+\t  size_t ns = 2 * size + 1;\n+\t  if (ns < size || static_cast<ssize_t>(ns) < 0)\n+\t    error_at(this->location(), \"out of memory\");\n+\t  char* nb = new char[ns];\n+\t  memcpy(nb, buf, cur);\n+\t  delete[] buf;\n+\t  buf = nb;\n+\t  size = ns;\n+\t}\n+      buf[cur] = c;\n+      ++cur;\n+\n+      if (c == '\\n')\n+\tbreak;\n+    }\n+\n+  buf[cur] = '\\0';\n+\n+  this->linebuf_ = buf;\n+  this->linebufsize_ = size;\n+\n+  return cur;\n+}\n+\n+// See if we need to read a new line.  Return true if there is a new\n+// line, false if we are at EOF.\n+\n+bool\n+Lex::require_line()\n+{\n+  if (this->lineoff_ < this->linesize_)\n+    return true;\n+\n+  ssize_t got = this->get_line();\n+  if (got < 0)\n+    return false;\n+  ++this->lineno_;\n+  this->linesize_= got;\n+  this->lineoff_ = 0;\n+\n+  linemap_line_start(line_table, this->lineno_, this->linesize_);\n+\n+  return true;\n+}\n+\n+// Get the current location.\n+\n+source_location\n+Lex::location() const\n+{\n+  source_location location;\n+  LINEMAP_POSITION_FOR_COLUMN(location, line_table, this->lineoff_ + 1);\n+  return location;\n+}\n+\n+// Get a location slightly before the current one.  This is used for\n+// slightly more efficient handling of operator tokens.\n+\n+source_location\n+Lex::earlier_location(int chars) const\n+{\n+  source_location location;\n+  LINEMAP_POSITION_FOR_COLUMN(location, line_table, this->lineoff_ + 1 - chars);\n+  return location;\n+}\n+\n+// Get the next token.\n+\n+Token\n+Lex::next_token()\n+{\n+  while (true)\n+    {\n+      if (!this->require_line())\n+\treturn this->make_eof_token();\n+\n+      const char* p = this->linebuf_ + this->lineoff_;\n+      const char* pend = this->linebuf_ + this->linesize_;\n+\n+      while (p < pend)\n+\t{\n+\t  unsigned char cc = *p;\n+\t  switch (cc)\n+\t    {\n+\t    case ' ': case '\\t': case '\\r':\n+\t      ++p;\n+\t      // Skip whitespace quickly.\n+\t      while (*p == ' ' || *p == '\\t' || *p == '\\r')\n+\t\t++p;\n+\t      break;\n+\n+\t    case '\\n':\n+\t      {\n+\t\t++p;\n+\t\tbool add_semi_at_eol = this->add_semi_at_eol_;\n+\t\tthis->add_semi_at_eol_ = false;\n+\t\tif (add_semi_at_eol)\n+\t\t  {\n+\t\t    this->lineoff_ = p - this->linebuf_;\n+\t\t    return this->make_operator(OPERATOR_SEMICOLON, 1);\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    case '/':\n+\t      if (p[1] == '/')\n+\t\t{\n+\t\t  this->lineoff_ = p + 2 - this->linebuf_;\n+\t\t  this->skip_cpp_comment();\n+\t\t  p = pend;\n+\t\t  if (p[-1] == '\\n' && this->add_semi_at_eol_)\n+\t\t    --p;\n+\t\t}\n+\t      else if (p[1] == '*')\n+\t\t{\n+\t\t  this->lineoff_ = p - this->linebuf_;\n+\t\t  source_location location = this->location();\n+\t\t  if (!this->skip_c_comment())\n+\t\t    return Token::make_invalid_token(location);\n+\t\t  p = this->linebuf_ + this->lineoff_;\n+\t\t  pend = this->linebuf_ + this->linesize_;\n+\t\t}\n+\t      else if (p[1] == '=')\n+\t\t{\n+\t\t  this->add_semi_at_eol_ = false;\n+\t\t  this->lineoff_ = p + 2 - this->linebuf_;\n+\t\t  return this->make_operator(OPERATOR_DIVEQ, 2);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  this->add_semi_at_eol_ = false;\n+\t\t  this->lineoff_ = p + 1 - this->linebuf_;\n+\t\t  return this->make_operator(OPERATOR_DIV, 1);\n+\t\t}\n+\t      break;\n+\n+\t    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+\t    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+\t    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+\t    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+\t    case 'Y': case 'Z':\n+\t    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+\t    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+\t    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+\t    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+\t    case 'y': case 'z':\n+\t    case '_':\n+\t      this->lineoff_ = p - this->linebuf_;\n+\t      return this->gather_identifier();\n+\n+\t    case '0': case '1': case '2': case '3': case '4':\n+\t    case '5': case '6': case '7': case '8': case '9':\n+\t      this->add_semi_at_eol_ = true;\n+\t      this->lineoff_ = p - this->linebuf_;\n+\t      return this->gather_number();\n+\n+\t    case '\\'':\n+\t      this->add_semi_at_eol_ = true;\n+\t      this->lineoff_ = p - this->linebuf_;\n+\t      return this->gather_character();\n+\n+\t    case '\"':\n+\t      this->add_semi_at_eol_ = true;\n+\t      this->lineoff_ = p - this->linebuf_;\n+\t      return this->gather_string();\n+\n+\t    case '`':\n+\t      this->add_semi_at_eol_ = true;\n+\t      this->lineoff_ = p - this->linebuf_;\n+\t      return this->gather_raw_string();\n+\n+\t    case '<':\n+\t    case '>':\n+\t    case '&':\n+\t      if (p + 2 < pend)\n+\t\t{\n+\t\t  this->add_semi_at_eol_ = false;\n+\t\t  Operator op = this->three_character_operator(cc, p[1], p[2]);\n+\t\t  if (op != OPERATOR_INVALID)\n+\t\t    {\n+\t\t      this->lineoff_ = p + 3 - this->linebuf_;\n+\t\t      return this->make_operator(op, 3);\n+\t\t    }\n+\t\t}\n+\t      // Fall through.\n+\t    case '|':\n+\t    case '=':\n+\t    case '!':\n+\t    case '+':\n+\t    case '-':\n+\t    case '^':\n+\t    case '*':\n+\t      // '/' handled above.\n+\t    case '%':\n+\t    case ':':\n+\t    case ';':\n+\t    case ',':\n+\t    case '(': case ')':\n+\t    case '{': case '}':\n+\t    case '[': case ']':\n+\t      {\n+\t\tthis->add_semi_at_eol_ = false;\n+\t\tOperator op = this->two_character_operator(cc, p[1]);\n+\t\tint chars;\n+\t\tif (op != OPERATOR_INVALID)\n+\t\t  {\n+\t\t    ++p;\n+\t\t    chars = 2;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    op = this->one_character_operator(cc);\n+\t\t    chars = 1;\n+\t\t  }\n+\t\tthis->lineoff_ = p + 1 - this->linebuf_;\n+\t\treturn this->make_operator(op, chars);\n+\t      }\n+\n+\t    case '.':\n+\t      if (p[1] >= '0' && p[1] <= '9')\n+\t\t{\n+\t\t  this->add_semi_at_eol_ = true;\n+\t\t  this->lineoff_ = p - this->linebuf_;\n+\t\t  return this->gather_number();\n+\t\t}\n+\t      if (p[1] == '.' && p[2] == '.')\n+\t\t{\n+\t\t  this->add_semi_at_eol_ = false;\n+\t\t  this->lineoff_ = p + 3 - this->linebuf_;\n+\t\t  return this->make_operator(OPERATOR_ELLIPSIS, 3);\n+\t\t}\n+\t      this->add_semi_at_eol_ = false;\n+\t      this->lineoff_ = p + 1 - this->linebuf_;\n+\t      return this->make_operator(OPERATOR_DOT, 1);\n+\n+\t    default:\n+\t      {\n+\t\tunsigned int ci;\n+\t\tbool issued_error;\n+\t\tthis->lineoff_ = p - this->linebuf_;\n+\t\tthis->advance_one_utf8_char(p, &ci, &issued_error);\n+\t\tif (Lex::is_unicode_letter(ci))\n+\t\t  return this->gather_identifier();\n+\n+\t\tif (!issued_error)\n+\t\t  error_at(this->location(),\n+\t\t\t   \"invalid character 0x%x in input file\",\n+\t\t\t   ci);\n+\n+\t\tp = pend;\n+\n+\t\tbreak;\n+\t      }\n+\t    }\n+\t}\n+\n+      this->lineoff_ = p - this->linebuf_;\n+    }\n+}\n+\n+// Fetch one UTF-8 character from a string.  Set *VALUE to the value.\n+// Return the number of bytes read from the string.  Returns 0 if the\n+// string does not point to a valid UTF-8 character.\n+\n+int\n+Lex::fetch_char(const char* p, unsigned int* value)\n+{\n+  unsigned char c = *p;\n+  if (c == 0)\n+    {    \n+      *value = 0xfffd;\n+      return 0;\n+    }\n+  else if (c <= 0x7f)\n+    {\n+      *value = c;\n+      return 1;\n+    }\n+  else if ((c & 0xe0) == 0xc0\n+\t   && (p[1] & 0xc0) == 0x80)\n+    {\n+      *value = (((c & 0x1f) << 6)\n+\t\t+ (p[1] & 0x3f));\n+      if (*value <= 0x7f)\n+\t{\n+\t  *value = 0xfffd;\n+\t  return 0;\n+\t}\n+      return 2;\n+    }\n+  else if ((c & 0xf0) == 0xe0\n+\t   && (p[1] & 0xc0) == 0x80\n+\t   && (p[2] & 0xc0) == 0x80)\n+    {\n+      *value = (((c & 0xf) << 12)\n+\t\t+ ((p[1] & 0x3f) << 6)\n+\t\t+ (p[2] & 0x3f));\n+      if (*value <= 0x7ff)\n+\t{\n+\t  *value = 0xfffd;\n+\t  return 0;\n+\t}\n+      return 3;\n+    }\n+  else if ((c & 0xf8) == 0xf0\n+\t   && (p[1] & 0xc0) == 0x80\n+\t   && (p[2] & 0xc0) == 0x80\n+\t   && (p[3] & 0xc0) == 0x80)\n+    {\n+      *value = (((c & 0x7) << 18)\n+\t\t+ ((p[1] & 0x3f) << 12)\n+\t\t+ ((p[2] & 0x3f) << 6)\n+\t\t+ (p[3] & 0x3f));\n+      if (*value <= 0xffff)\n+\t{\n+\t  *value = 0xfffd;\n+\t  return 0;\n+\t}\n+      return 4;\n+    }\n+  else\n+    {\n+      /* Invalid encoding. Return the Unicode replacement\n+\t character.  */\n+      *value = 0xfffd;\n+      return 0;\n+    }\n+}\n+\n+// Advance one UTF-8 character.  Return the pointer beyond the\n+// character.  Set *VALUE to the value.  Set *ISSUED_ERROR if an error\n+// was issued.\n+\n+const char*\n+Lex::advance_one_utf8_char(const char* p, unsigned int* value,\n+\t\t\t   bool* issued_error)\n+{\n+  *issued_error = false;\n+  int adv = Lex::fetch_char(p, value);\n+  if (adv == 0)\n+    {\n+      if (*p == '\\0')\n+\terror_at(this->location(), \"invalid NUL byte\");\n+      else\n+\terror_at(this->location(), \"invalid UTF-8 encoding\");\n+      *issued_error = true;\n+      return p + 1;\n+    }\n+  return p + adv;\n+}\n+\n+// Pick up an identifier.\n+\n+Token\n+Lex::gather_identifier()\n+{\n+  const char* pstart = this->linebuf_ + this->lineoff_;\n+  const char* p = pstart;\n+  const char* pend = this->linebuf_ + this->linesize_;\n+  bool is_first = true;\n+  bool is_exported = false;\n+  bool has_non_ascii_char = false;\n+  std::string buf;\n+  while (p < pend)\n+    {\n+      unsigned char cc = *p;\n+      if (cc <= 0x7f)\n+\t{\n+\t  if ((cc < 'A' || cc > 'Z')\n+\t      && (cc < 'a' || cc > 'z')\n+\t      && cc != '_'\n+\t      && (cc < '0' || cc > '9'))\n+\t    break;\n+\t  ++p;\n+\t  if (is_first)\n+\t    {\n+\t      is_exported = cc >= 'A' && cc <= 'Z';\n+\t      is_first = false;\n+\t    }\n+\t  if (has_non_ascii_char)\n+\t    buf.push_back(cc);\n+\t}\n+      else\n+\t{\n+\t  unsigned int ci;\n+\t  bool issued_error;\n+\t  this->lineoff_ = p - this->linebuf_;\n+\t  const char* pnext = this->advance_one_utf8_char(p, &ci,\n+\t\t\t\t\t\t\t  &issued_error);\n+\t  if (!Lex::is_unicode_letter(ci) && !Lex::is_unicode_digit(ci))\n+\t    {\n+\t      // There is no valid place for a non-ASCII character\n+\t      // other than an identifier, so we get better error\n+\t      // handling behaviour if we swallow this character after\n+\t      // giving an error.\n+\t      if (!issued_error)\n+\t\terror_at(this->location(),\n+\t\t\t \"invalid character 0x%x in identifier\",\n+\t\t\t ci);\n+\t    }\n+\t  if (is_first)\n+\t    {\n+\t      is_exported = Lex::is_unicode_uppercase(ci);\n+\t      is_first = false;\n+\t    }\n+\t  if (!has_non_ascii_char)\n+\t    {\n+\t      buf.assign(pstart, p - pstart);\n+\t      has_non_ascii_char = true;\n+\t    }\n+\t  p = pnext;\n+\t  char ubuf[50];\n+\t  // This assumes that all assemblers can handle an identifier\n+\t  // with a '$' character.\n+\t  snprintf(ubuf, sizeof ubuf, \"$U%x$\", ci);\n+\t  buf.append(ubuf);\n+\t}\n+    }\n+  source_location location = this->location();\n+  this->add_semi_at_eol_ = true;\n+  this->lineoff_ = p - this->linebuf_;\n+  if (has_non_ascii_char)\n+    return Token::make_identifier_token(buf, is_exported, location);\n+  else\n+    {\n+      Keyword code = keywords.keyword_to_code(pstart, p - pstart);\n+      if (code == KEYWORD_INVALID)\n+\treturn Token::make_identifier_token(std::string(pstart, p - pstart),\n+\t\t\t\t\t    is_exported, location);\n+      else\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case KEYWORD_BREAK:\n+\t    case KEYWORD_CONTINUE:\n+\t    case KEYWORD_FALLTHROUGH:\n+\t    case KEYWORD_RETURN:\n+\t      break;\n+\t    default:\n+\t      this->add_semi_at_eol_ = false;\n+\t      break;\n+\t    }\n+\t  return Token::make_keyword_token(code, location);\n+\t}\n+    }\n+}\n+\n+// Return whether C is a hex digit.\n+\n+bool\n+Lex::is_hex_digit(char c)\n+{\n+  return ((c >= '0' && c <= '9')\n+\t  || (c >= 'A' && c <= 'F')\n+\t  || (c >= 'a' && c <= 'f'));\n+}\n+\n+// Pick up a number.\n+\n+Token\n+Lex::gather_number()\n+{\n+  const char* pstart = this->linebuf_ + this->lineoff_;\n+  const char* p = pstart;\n+  const char* pend = this->linebuf_ + this->linesize_;\n+\n+  source_location location = this->location();\n+\n+  bool neg = false;\n+  if (*p == '+')\n+    ++p;\n+  else if (*p == '-')\n+    {\n+      ++p;\n+      neg = true;\n+    }\n+\n+  const char* pnum = p;\n+  if (*p == '0')\n+    {\n+      int base;\n+      if ((p[1] == 'x' || p[1] == 'X')\n+\t  && Lex::is_hex_digit(p[2]))\n+\t{\n+\t  base = 16;\n+\t  p += 2;\n+\t  pnum = p;\n+\t  while (p < pend)\n+\t    {\n+\t      if (!Lex::is_hex_digit(*p))\n+\t\tbreak;\n+\t      ++p;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  base = 8;\n+\t  pnum = p;\n+\t  while (p < pend)\n+\t    {\n+\t      if (*p < '0' || *p > '7')\n+\t\tbreak;\n+\t      ++p;\n+\t    }\n+\t}\n+\n+      if (*p != '.' && *p != 'e' && *p != 'E' && *p != 'i')\n+\t{\n+\t  std::string s(pnum, p - pnum);\n+\t  mpz_t val;\n+\t  int r = mpz_init_set_str(val, s.c_str(), base);\n+\t  gcc_assert(r == 0);\n+\n+\t  if (neg)\n+\t    mpz_neg(val, val);\n+\n+\t  this->lineoff_ = p - this->linebuf_;\n+\t  Token ret = Token::make_integer_token(val, location);\n+\t  mpz_clear(val);\n+\t  return ret;\n+\t}\n+    }\n+\n+  while (p < pend)\n+    {\n+      if (*p < '0' || *p > '9')\n+\tbreak;\n+      ++p;\n+    }\n+\n+  if (*p != '.' && *p != 'E' && *p != 'e' && *p != 'i')\n+    {\n+      std::string s(pnum, p - pnum);\n+      mpz_t val;\n+      int r = mpz_init_set_str(val, s.c_str(), 10);\n+      gcc_assert(r == 0);\n+\n+      if (neg)\n+\tmpz_neg(val, val);\n+\n+      this->lineoff_ = p - this->linebuf_;\n+      Token ret = Token::make_integer_token(val, location);\n+      mpz_clear(val);\n+      return ret;\n+    }\n+\n+  if (*p != 'i')\n+    {\n+      bool dot = *p == '.';\n+\n+      ++p;\n+\n+      if (!dot)\n+\t{\n+\t  if (*p == '+' || *p == '-')\n+\t    ++p;\n+\t}\n+\n+      while (p < pend)\n+\t{\n+\t  if (*p < '0' || *p > '9')\n+\t    break;\n+\t  ++p;\n+\t}\n+\n+      if (dot && (*p == 'E' || *p == 'e'))\n+\t{\n+\t  ++p;\n+\t  if (*p == '+' || *p == '-')\n+\t    ++p;\n+\t  while (p < pend)\n+\t    {\n+\t      if (*p < '0' || *p > '9')\n+\t\tbreak;\n+\t      ++p;\n+\t    }\n+\t}\n+    }\n+\n+  std::string s(pnum, p - pnum);\n+  mpfr_t val;\n+  int r = mpfr_init_set_str(val, s.c_str(), 10, GMP_RNDN);\n+  gcc_assert(r == 0);\n+\n+  if (neg)\n+    mpfr_neg(val, val, GMP_RNDN);\n+\n+  bool is_imaginary = *p == 'i';\n+  if (is_imaginary)\n+    ++p;\n+\n+  this->lineoff_ = p - this->linebuf_;\n+  if (is_imaginary)\n+    {\n+      Token ret = Token::make_imaginary_token(val, location);\n+      mpfr_clear(val);\n+      return ret;\n+    }\n+  else\n+    {\n+      Token ret = Token::make_float_token(val, location);\n+      mpfr_clear(val);\n+      return ret;\n+    }\n+}\n+\n+// Advance one character, possibly escaped.  Return the pointer beyond\n+// the character.  Set *VALUE to the character.  Set *IS_CHARACTER if\n+// this is a character (e.g., 'a' or '\\u1234') rather than a byte\n+// value (e.g., '\\001').\n+\n+const char*\n+Lex::advance_one_char(const char* p, bool is_single_quote, unsigned int* value,\n+\t\t      bool* is_character)\n+{\n+  *value = 0;\n+  *is_character = true;\n+  if (*p != '\\\\')\n+    {\n+      bool issued_error;\n+      const char* ret = this->advance_one_utf8_char(p, value, &issued_error);\n+      if (is_single_quote\n+\t  && (*value == '\\'' || *value == '\\n')\n+\t  && !issued_error)\n+\terror_at(this->location(), \"invalid character literal\");\n+      return ret;\n+    }\n+  else\n+    {\n+      ++p;\n+      switch (*p)\n+\t{\n+\tcase '0': case '1': case '2': case '3':\n+\tcase '4': case '5': case '6': case '7':\n+\t  *is_character = false;\n+\t  if (p[1] >= '0' && p[1] <= '7'\n+\t      && p[2] >= '0' && p[2] <= '7')\n+\t    {\n+\t      *value = ((Lex::octal_value(p[0]) << 6)\n+\t\t\t+ (Lex::octal_value(p[1]) << 3)\n+\t\t\t+ Lex::octal_value(p[2]));\n+\t      if (*value > 255)\n+\t\t{\n+\t\t  error_at(this->location(), \"invalid octal constant\");\n+\t\t  *value = 255;\n+\t\t}\n+\t      return p + 3;\n+\t    }\n+\t      error_at(this->location(), \"invalid octal character\");\n+\t  return (p[1] >= '0' && p[1] <= '7'\n+\t\t  ? p + 2\n+\t\t  : p + 1);\n+\n+\tcase 'x':\n+\tcase 'X':\n+\t  *is_character = false;\n+\t  if (Lex::is_hex_digit(p[1]) && Lex::is_hex_digit(p[2]))\n+\t    {\n+\t      *value = (hex_value(p[1]) << 4) + hex_value(p[2]);\n+\t      return p + 3;\n+\t    }\n+\t  error_at(this->location(), \"invalid hex character\");\n+\t  return (Lex::is_hex_digit(p[1])\n+\t\t  ? p + 2\n+\t\t  : p + 1);\n+\n+\tcase 'a':\n+\t  *value = '\\a';\n+\t  return p + 1;\n+\tcase 'b':\n+\t  *value = '\\b';\n+\t  return p + 1;\n+\tcase 'f':\n+\t  *value = '\\f';\n+\t  return p + 1;\n+\tcase 'n':\n+\t  *value = '\\n';\n+\t  return p + 1;\n+\tcase 'r':\n+\t  *value = '\\r';\n+\t  return p + 1;\n+\tcase 't':\n+\t  *value = '\\t';\n+\t  return p + 1;\n+\tcase 'v':\n+\t  *value = '\\v';\n+\t  return p + 1;\n+\tcase '\\\\':\n+\t  *value = '\\\\';\n+\t  return p + 1;\n+\tcase '\\'':\n+\t  if (!is_single_quote)\n+\t    error_at(this->location(), \"invalid quoted character\");\n+\t  *value = '\\'';\n+\t  return p + 1;\n+\tcase '\"':\n+\t  if (is_single_quote)\n+\t    error_at(this->location(), \"invalid quoted character\");\n+\t  *value = '\"';\n+\t  return p + 1;\n+\n+\tcase 'u':\n+\t  if (Lex::is_hex_digit(p[1]) && Lex::is_hex_digit(p[2])\n+\t      && Lex::is_hex_digit(p[3]) && Lex::is_hex_digit(p[4]))\n+\t    {\n+\t      *value = ((hex_value(p[1]) << 12)\n+\t\t\t+ (hex_value(p[2]) << 8)\n+\t\t\t+ (hex_value(p[3]) << 4)\n+\t\t\t+ hex_value(p[4]));\n+\t      if (*value >= 0xd800 && *value < 0xe000)\n+\t\t{\n+\t\t  error_at(this->location(),\n+\t\t\t   \"invalid unicode code point 0x%x\",\n+\t\t\t   *value);\n+\t\t  // Use the replacement character.\n+\t\t  *value = 0xfffd;\n+\t\t}\n+\t      return p + 5;\n+\t    }\n+\t  error_at(this->location(), \"invalid little unicode code point\");\n+\t  return p + 1;\n+\n+\tcase 'U':\n+\t  if (Lex::is_hex_digit(p[1]) && Lex::is_hex_digit(p[2])\n+\t      && Lex::is_hex_digit(p[3]) && Lex::is_hex_digit(p[4])\n+\t      && Lex::is_hex_digit(p[5]) && Lex::is_hex_digit(p[6])\n+\t      && Lex::is_hex_digit(p[7]) && Lex::is_hex_digit(p[8]))\n+\t    {\n+\t      *value = ((hex_value(p[1]) << 28)\n+\t\t\t+ (hex_value(p[2]) << 24)\n+\t\t\t+ (hex_value(p[3]) << 20)\n+\t\t\t+ (hex_value(p[4]) << 16)\n+\t\t\t+ (hex_value(p[5]) << 12)\n+\t\t\t+ (hex_value(p[6]) << 8)\n+\t\t\t+ (hex_value(p[7]) << 4)\n+\t\t\t+ hex_value(p[8]));\n+\t      if (*value > 0x10ffff\n+\t\t  || (*value >= 0xd800 && *value < 0xe000))\n+\t\t{\n+\t\t  error_at(this->location(), \"invalid unicode code point 0x%x\",\n+\t\t\t   *value);\n+\t\t  // Use the replacement character.\n+\t\t  *value = 0xfffd;\n+\t\t}\n+\t      return p + 9;\n+\t    }\n+\t  error_at(this->location(), \"invalid big unicode code point\");\n+\t  return p + 1;\n+\n+\tdefault:\n+\t  error_at(this->location(), \"invalid character after %<\\\\%>\");\n+\t  *value = *p;\n+\t  return p + 1;\n+\t}\n+    }\n+}\n+\n+// Append V to STR.  IS_CHARACTER is true for a character which should\n+// be stored in UTF-8, false for a general byte value which should be\n+// stored directly.\n+\n+void\n+Lex::append_char(unsigned int v, bool is_character, std::string* str,\n+\t\t source_location location)\n+{\n+  char buf[4];\n+  size_t len;\n+  if (v <= 0x7f || !is_character)\n+    {\n+      buf[0] = v;\n+      len = 1;\n+    }\n+  else if (v <= 0x7ff)\n+    {\n+      buf[0] = 0xc0 + (v >> 6);\n+      buf[1] = 0x80 + (v & 0x3f);\n+      len = 2;\n+    }\n+  else\n+    {\n+      if (v > 0x10ffff)\n+\t{\n+\t  warning_at(location, 0,\n+\t\t     \"unicode code point 0x%x out of range in string\", v);\n+\t  // Turn it into the \"replacement character\".\n+\t  v = 0xfffd;\n+\t}\n+      if (v <= 0xffff)\n+\t{\n+\t  buf[0] = 0xe0 + (v >> 12);\n+\t  buf[1] = 0x80 + ((v >> 6) & 0x3f);\n+\t  buf[2] = 0x80 + (v & 0x3f);\n+\t  len = 3;\n+\t}\n+      else\n+\t{\n+\t  buf[0] = 0xf0 + (v >> 18);\n+\t  buf[1] = 0x80 + ((v >> 12) & 0x3f);\n+\t  buf[2] = 0x80 + ((v >> 6) & 0x3f);\n+\t  buf[3] = 0x80 + (v & 0x3f);\n+\t  len = 4;\n+\t}\n+    }\n+  str->append(buf, len);\n+}\n+\n+// Pick up a character literal.\n+\n+Token\n+Lex::gather_character()\n+{\n+  ++this->lineoff_;\n+  const char* pstart = this->linebuf_ + this->lineoff_;\n+  const char* p = pstart;\n+\n+  unsigned int value;\n+  bool is_character;\n+  p = this->advance_one_char(p, true, &value, &is_character);\n+\n+  if (*p != '\\'')\n+    {\n+      error_at(this->location(), \"unterminated character constant\");\n+      this->lineoff_ = p - this->linebuf_;\n+      return this->make_invalid_token();\n+    }\n+\n+  mpz_t val;\n+  mpz_init_set_ui(val, value);\n+\n+  source_location location = this->location();\n+  this->lineoff_ = p + 1 - this->linebuf_;\n+  Token ret = Token::make_integer_token(val, location);\n+  mpz_clear(val);\n+  return ret;\n+}\n+\n+// Pick up a quoted string.\n+\n+Token\n+Lex::gather_string()\n+{\n+  const char* pstart = this->linebuf_ + this->lineoff_ + 1;\n+  const char* p = pstart;\n+  const char* pend = this->linebuf_ + this->linesize_;\n+\n+  std::string value;\n+  while (*p != '\"')\n+    {\n+      source_location loc = this->location();\n+      unsigned int c;\n+      bool is_character;\n+      this->lineoff_ = p - this->linebuf_;\n+      p = this->advance_one_char(p, false, &c, &is_character);\n+      if (p >= pend)\n+\t{\n+\t  error_at(this->location(), \"unterminated string\");\n+\t  --p;\n+\t  break;\n+\t}\n+      Lex::append_char(c, is_character, &value, loc);\n+    }\n+\n+  source_location location = this->location();\n+  this->lineoff_ = p + 1 - this->linebuf_;\n+  return Token::make_string_token(value, location);\n+}\n+\n+// Pick up a raw string.\n+\n+Token\n+Lex::gather_raw_string()\n+{\n+  const char* p = this->linebuf_ + this->lineoff_ + 1;\n+  const char* pend = this->linebuf_ + this->linesize_;\n+  source_location location = this->location();\n+\n+  std::string value;\n+  while (true)\n+    {\n+      while (p < pend)\n+\t{\n+\t  if (*p == '`')\n+\t    {\n+\t      this->lineoff_ = p + 1 - this->linebuf_;\n+\t      return Token::make_string_token(value, location);\n+\t    }\n+\t  source_location loc = this->location();\n+\t  unsigned int c;\n+\t  bool issued_error;\n+\t  this->lineoff_ = p - this->linebuf_;\n+\t  p = this->advance_one_utf8_char(p, &c, &issued_error);\n+\t  Lex::append_char(c, true, &value, loc);\n+\t}\n+      this->lineoff_ = p - this->linebuf_;\n+      if (!this->require_line())\n+\t{\n+\t  error_at(location, \"unterminated raw string\");\n+\t  return Token::make_string_token(value, location);\n+\t}\n+      p = this->linebuf_ + this->lineoff_;\n+      pend = this->linebuf_ + this->linesize_;\n+    }\n+}\n+\n+// If C1 C2 C3 are a three character operator, return the code.\n+\n+Operator\n+Lex::three_character_operator(char c1, char c2, char c3)\n+{\n+  if (c3 == '=')\n+    {\n+      if (c1 == '<' && c2 == '<')\n+\treturn OPERATOR_LSHIFTEQ;\n+      else if (c1 == '>' && c2 == '>')\n+\treturn OPERATOR_RSHIFTEQ;\n+      else if (c1 == '&' && c2 == '^')\n+\treturn OPERATOR_BITCLEAREQ;\n+    }\n+  return OPERATOR_INVALID;\n+}\n+\n+// If C1 C2 are a two character operator, return the code.\n+\n+Operator\n+Lex::two_character_operator(char c1, char c2)\n+{\n+  switch (c1)\n+    {\n+    case '|':\n+      if (c2 == '|')\n+\treturn OPERATOR_OROR;\n+      else if (c2 == '=')\n+\treturn OPERATOR_OREQ;\n+      break;\n+    case '&':\n+      if (c2 == '&')\n+\treturn OPERATOR_ANDAND;\n+      else if (c2 == '^')\n+\treturn OPERATOR_BITCLEAR;\n+      else if (c2 == '=')\n+\treturn OPERATOR_ANDEQ;\n+      break;\n+    case '^':\n+      if (c2 == '=')\n+\treturn OPERATOR_XOREQ;\n+      break;\n+    case '=':\n+      if (c2 == '=')\n+\treturn OPERATOR_EQEQ;\n+      break;\n+    case '!':\n+      if (c2 == '=')\n+\treturn OPERATOR_NOTEQ;\n+      break;\n+    case '<':\n+      if (c2 == '=')\n+\treturn OPERATOR_LE;\n+      else if (c2 == '<')\n+\treturn OPERATOR_LSHIFT;\n+      else if (c2 == '-')\n+\treturn OPERATOR_CHANOP;\n+      break;\n+    case '>':\n+      if (c2 == '=')\n+\treturn OPERATOR_GE;\n+      else if (c2 == '>')\n+\treturn OPERATOR_RSHIFT;\n+      break;\n+    case '*':\n+      if (c2 == '=')\n+\treturn OPERATOR_MULTEQ;\n+      break;\n+    case '/':\n+      if (c2 == '=')\n+\treturn OPERATOR_DIVEQ;\n+      break;\n+    case '%':\n+      if (c2 == '=')\n+\treturn OPERATOR_MODEQ;\n+      break;\n+    case '+':\n+      if (c2 == '+')\n+\t{\n+\t  this->add_semi_at_eol_ = true;\n+\t  return OPERATOR_PLUSPLUS;\n+\t}\n+      else if (c2 == '=')\n+\treturn OPERATOR_PLUSEQ;\n+      break;\n+    case '-':\n+      if (c2 == '-')\n+\t{\n+\t  this->add_semi_at_eol_ = true;\n+\t  return OPERATOR_MINUSMINUS;\n+\t}\n+      else if (c2 == '=')\n+\treturn OPERATOR_MINUSEQ;\n+      break;\n+    case ':':\n+      if (c2 == '=')\n+\treturn OPERATOR_COLONEQ;\n+      break;\n+    default:\n+      break;\n+    }\n+  return OPERATOR_INVALID;\n+}\n+\n+// If character C is an operator, return the code.\n+\n+Operator\n+Lex::one_character_operator(char c)\n+{\n+  switch (c)\n+    {\n+    case '<':\n+      return OPERATOR_LT;\n+    case '>':\n+      return OPERATOR_GT;\n+    case '+':\n+      return OPERATOR_PLUS;\n+    case '-':\n+      return OPERATOR_MINUS;\n+    case '|':\n+      return OPERATOR_OR;\n+    case '^':\n+      return OPERATOR_XOR;\n+    case '*':\n+      return OPERATOR_MULT;\n+    case '/':\n+      return OPERATOR_DIV;\n+    case '%':\n+      return OPERATOR_MOD;\n+    case '&':\n+      return OPERATOR_AND;\n+    case '!':\n+      return OPERATOR_NOT;\n+    case '=':\n+      return OPERATOR_EQ;\n+    case ':':\n+      return OPERATOR_COLON;\n+    case ';':\n+      return OPERATOR_SEMICOLON;\n+    case '.':\n+      return OPERATOR_DOT;\n+    case ',':\n+      return OPERATOR_COMMA;\n+    case '(':\n+      return OPERATOR_LPAREN;\n+    case ')':\n+      this->add_semi_at_eol_ = true;\n+      return OPERATOR_RPAREN;\n+    case '{':\n+      return OPERATOR_LCURLY;\n+    case '}':\n+      this->add_semi_at_eol_ = true;\n+      return OPERATOR_RCURLY;\n+    case '[':\n+      return OPERATOR_LSQUARE;\n+    case ']':\n+      this->add_semi_at_eol_ = true;\n+      return OPERATOR_RSQUARE;\n+    default:\n+      return OPERATOR_INVALID;\n+    }\n+}\n+\n+// Skip a C-style comment.\n+\n+bool\n+Lex::skip_c_comment()\n+{\n+  while (true)\n+    {\n+      if (!this->require_line())\n+\t{\n+\t  error_at(this->location(), \"unterminated comment\");\n+\t  return false;\n+\t}\n+\n+      const char* p = this->linebuf_ + this->lineoff_;\n+      const char* pend = this->linebuf_ + this->linesize_;\n+\n+      while (p < pend)\n+\t{\n+\t  if (p[0] == '*' && p + 1 < pend && p[1] == '/')\n+\t    {\n+\t      this->lineoff_ = p + 2 - this->linebuf_;\n+\t      return true;\n+\t    }\n+\n+\t  this->lineoff_ = p - this->linebuf_;\n+\t  unsigned int c;\n+\t  bool issued_error;\n+\t  p = this->advance_one_utf8_char(p, &c, &issued_error);\n+\t}\n+\n+      this->lineoff_ = p - this->linebuf_;\n+    }\n+}\n+\n+// Skip a C++-style comment.\n+\n+void\n+Lex::skip_cpp_comment()\n+{\n+  const char* p = this->linebuf_ + this->lineoff_;\n+  const char* pend = this->linebuf_ + this->linesize_;\n+\n+  // By convention, a C++ comment at the start of the line of the form\n+  //   //line FILE:LINENO\n+  // is interpreted as setting the file name and line number of the\n+  // next source line.\n+\n+  if (this->lineoff_ == 2\n+      && pend - p > 5\n+      && memcmp(p, \"line \", 5) == 0)\n+    {\n+      p += 5;\n+      while (p < pend && *p == ' ')\n+\t++p;\n+      const char* pcolon = static_cast<const char*>(memchr(p, ':', pend - p));\n+      if (pcolon != NULL\n+\t  && pcolon[1] >= '0'\n+\t  && pcolon[1] <= '9')\n+\t{\n+\t  char* plend;\n+\t  long lineno = strtol(pcolon + 1, &plend, 10);\n+\t  if (plend > pcolon + 1\n+\t      && (plend == pend\n+\t\t  || *plend < '0'\n+\t\t  || *plend > '9')\n+\t      && lineno > 0\n+\t      && lineno < 0x7fffffff)\n+\t    {\n+\t      unsigned int filelen = pcolon - p;\n+\t      char* file = new char[filelen + 1];\n+\t      memcpy(file, p, filelen);\n+\t      file[filelen] = '\\0';\n+\n+\t      linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n+\t      linemap_add(line_table, LC_ENTER, 0, file, lineno);\n+\t      this->lineno_ = lineno - 1;\n+\n+\t      p = plend;\n+\t    }\n+\t}\n+    }\n+\n+  while (p < pend)\n+    {\n+      this->lineoff_ = p - this->linebuf_;\n+      unsigned int c;\n+      bool issued_error;\n+      p = this->advance_one_utf8_char(p, &c, &issued_error);\n+    }\n+}\n+\n+// The Unicode tables use this struct.\n+\n+struct Unicode_range\n+{\n+  // The low end of the range.\n+  unsigned int low;\n+  // The high end of the range.\n+  unsigned int high;\n+  // The stride.  This entries represents low, low + stride, low + 2 *\n+  // stride, etc., up to high.\n+  unsigned int stride;\n+};\n+\n+// A table of Unicode digits--Unicode code points classified as\n+// \"Digit\".\n+\n+static const Unicode_range unicode_digits[] =\n+{\n+  { 0x0030, 0x0039, 1},\n+  { 0x0660, 0x0669, 1},\n+  { 0x06f0, 0x06f9, 1},\n+  { 0x07c0, 0x07c9, 1},\n+  { 0x0966, 0x096f, 1},\n+  { 0x09e6, 0x09ef, 1},\n+  { 0x0a66, 0x0a6f, 1},\n+  { 0x0ae6, 0x0aef, 1},\n+  { 0x0b66, 0x0b6f, 1},\n+  { 0x0be6, 0x0bef, 1},\n+  { 0x0c66, 0x0c6f, 1},\n+  { 0x0ce6, 0x0cef, 1},\n+  { 0x0d66, 0x0d6f, 1},\n+  { 0x0e50, 0x0e59, 1},\n+  { 0x0ed0, 0x0ed9, 1},\n+  { 0x0f20, 0x0f29, 1},\n+  { 0x1040, 0x1049, 1},\n+  { 0x17e0, 0x17e9, 1},\n+  { 0x1810, 0x1819, 1},\n+  { 0x1946, 0x194f, 1},\n+  { 0x19d0, 0x19d9, 1},\n+  { 0x1b50, 0x1b59, 1},\n+  { 0xff10, 0xff19, 1},\n+  { 0x104a0, 0x104a9, 1},\n+  { 0x1d7ce, 0x1d7ff, 1},\n+};\n+\n+// A table of Unicode letters--Unicode code points classified as\n+// \"Letter\".\n+\n+static const Unicode_range unicode_letters[] =\n+{\n+  { 0x0041, 0x005a, 1},\n+  { 0x0061, 0x007a, 1},\n+  { 0x00aa, 0x00b5, 11},\n+  { 0x00ba, 0x00ba, 1},\n+  { 0x00c0, 0x00d6, 1},\n+  { 0x00d8, 0x00f6, 1},\n+  { 0x00f8, 0x02c1, 1},\n+  { 0x02c6, 0x02d1, 1},\n+  { 0x02e0, 0x02e4, 1},\n+  { 0x02ec, 0x02ee, 2},\n+  { 0x0370, 0x0374, 1},\n+  { 0x0376, 0x0377, 1},\n+  { 0x037a, 0x037d, 1},\n+  { 0x0386, 0x0386, 1},\n+  { 0x0388, 0x038a, 1},\n+  { 0x038c, 0x038c, 1},\n+  { 0x038e, 0x03a1, 1},\n+  { 0x03a3, 0x03f5, 1},\n+  { 0x03f7, 0x0481, 1},\n+  { 0x048a, 0x0523, 1},\n+  { 0x0531, 0x0556, 1},\n+  { 0x0559, 0x0559, 1},\n+  { 0x0561, 0x0587, 1},\n+  { 0x05d0, 0x05ea, 1},\n+  { 0x05f0, 0x05f2, 1},\n+  { 0x0621, 0x064a, 1},\n+  { 0x066e, 0x066f, 1},\n+  { 0x0671, 0x06d3, 1},\n+  { 0x06d5, 0x06d5, 1},\n+  { 0x06e5, 0x06e6, 1},\n+  { 0x06ee, 0x06ef, 1},\n+  { 0x06fa, 0x06fc, 1},\n+  { 0x06ff, 0x0710, 17},\n+  { 0x0712, 0x072f, 1},\n+  { 0x074d, 0x07a5, 1},\n+  { 0x07b1, 0x07b1, 1},\n+  { 0x07ca, 0x07ea, 1},\n+  { 0x07f4, 0x07f5, 1},\n+  { 0x07fa, 0x07fa, 1},\n+  { 0x0904, 0x0939, 1},\n+  { 0x093d, 0x0950, 19},\n+  { 0x0958, 0x0961, 1},\n+  { 0x0971, 0x0972, 1},\n+  { 0x097b, 0x097f, 1},\n+  { 0x0985, 0x098c, 1},\n+  { 0x098f, 0x0990, 1},\n+  { 0x0993, 0x09a8, 1},\n+  { 0x09aa, 0x09b0, 1},\n+  { 0x09b2, 0x09b2, 1},\n+  { 0x09b6, 0x09b9, 1},\n+  { 0x09bd, 0x09ce, 17},\n+  { 0x09dc, 0x09dd, 1},\n+  { 0x09df, 0x09e1, 1},\n+  { 0x09f0, 0x09f1, 1},\n+  { 0x0a05, 0x0a0a, 1},\n+  { 0x0a0f, 0x0a10, 1},\n+  { 0x0a13, 0x0a28, 1},\n+  { 0x0a2a, 0x0a30, 1},\n+  { 0x0a32, 0x0a33, 1},\n+  { 0x0a35, 0x0a36, 1},\n+  { 0x0a38, 0x0a39, 1},\n+  { 0x0a59, 0x0a5c, 1},\n+  { 0x0a5e, 0x0a5e, 1},\n+  { 0x0a72, 0x0a74, 1},\n+  { 0x0a85, 0x0a8d, 1},\n+  { 0x0a8f, 0x0a91, 1},\n+  { 0x0a93, 0x0aa8, 1},\n+  { 0x0aaa, 0x0ab0, 1},\n+  { 0x0ab2, 0x0ab3, 1},\n+  { 0x0ab5, 0x0ab9, 1},\n+  { 0x0abd, 0x0ad0, 19},\n+  { 0x0ae0, 0x0ae1, 1},\n+  { 0x0b05, 0x0b0c, 1},\n+  { 0x0b0f, 0x0b10, 1},\n+  { 0x0b13, 0x0b28, 1},\n+  { 0x0b2a, 0x0b30, 1},\n+  { 0x0b32, 0x0b33, 1},\n+  { 0x0b35, 0x0b39, 1},\n+  { 0x0b3d, 0x0b3d, 1},\n+  { 0x0b5c, 0x0b5d, 1},\n+  { 0x0b5f, 0x0b61, 1},\n+  { 0x0b71, 0x0b83, 18},\n+  { 0x0b85, 0x0b8a, 1},\n+  { 0x0b8e, 0x0b90, 1},\n+  { 0x0b92, 0x0b95, 1},\n+  { 0x0b99, 0x0b9a, 1},\n+  { 0x0b9c, 0x0b9c, 1},\n+  { 0x0b9e, 0x0b9f, 1},\n+  { 0x0ba3, 0x0ba4, 1},\n+  { 0x0ba8, 0x0baa, 1},\n+  { 0x0bae, 0x0bb9, 1},\n+  { 0x0bd0, 0x0bd0, 1},\n+  { 0x0c05, 0x0c0c, 1},\n+  { 0x0c0e, 0x0c10, 1},\n+  { 0x0c12, 0x0c28, 1},\n+  { 0x0c2a, 0x0c33, 1},\n+  { 0x0c35, 0x0c39, 1},\n+  { 0x0c3d, 0x0c3d, 1},\n+  { 0x0c58, 0x0c59, 1},\n+  { 0x0c60, 0x0c61, 1},\n+  { 0x0c85, 0x0c8c, 1},\n+  { 0x0c8e, 0x0c90, 1},\n+  { 0x0c92, 0x0ca8, 1},\n+  { 0x0caa, 0x0cb3, 1},\n+  { 0x0cb5, 0x0cb9, 1},\n+  { 0x0cbd, 0x0cde, 33},\n+  { 0x0ce0, 0x0ce1, 1},\n+  { 0x0d05, 0x0d0c, 1},\n+  { 0x0d0e, 0x0d10, 1},\n+  { 0x0d12, 0x0d28, 1},\n+  { 0x0d2a, 0x0d39, 1},\n+  { 0x0d3d, 0x0d3d, 1},\n+  { 0x0d60, 0x0d61, 1},\n+  { 0x0d7a, 0x0d7f, 1},\n+  { 0x0d85, 0x0d96, 1},\n+  { 0x0d9a, 0x0db1, 1},\n+  { 0x0db3, 0x0dbb, 1},\n+  { 0x0dbd, 0x0dbd, 1},\n+  { 0x0dc0, 0x0dc6, 1},\n+  { 0x0e01, 0x0e30, 1},\n+  { 0x0e32, 0x0e33, 1},\n+  { 0x0e40, 0x0e46, 1},\n+  { 0x0e81, 0x0e82, 1},\n+  { 0x0e84, 0x0e84, 1},\n+  { 0x0e87, 0x0e88, 1},\n+  { 0x0e8a, 0x0e8d, 3},\n+  { 0x0e94, 0x0e97, 1},\n+  { 0x0e99, 0x0e9f, 1},\n+  { 0x0ea1, 0x0ea3, 1},\n+  { 0x0ea5, 0x0ea7, 2},\n+  { 0x0eaa, 0x0eab, 1},\n+  { 0x0ead, 0x0eb0, 1},\n+  { 0x0eb2, 0x0eb3, 1},\n+  { 0x0ebd, 0x0ebd, 1},\n+  { 0x0ec0, 0x0ec4, 1},\n+  { 0x0ec6, 0x0ec6, 1},\n+  { 0x0edc, 0x0edd, 1},\n+  { 0x0f00, 0x0f00, 1},\n+  { 0x0f40, 0x0f47, 1},\n+  { 0x0f49, 0x0f6c, 1},\n+  { 0x0f88, 0x0f8b, 1},\n+  { 0x1000, 0x102a, 1},\n+  { 0x103f, 0x103f, 1},\n+  { 0x1050, 0x1055, 1},\n+  { 0x105a, 0x105d, 1},\n+  { 0x1061, 0x1061, 1},\n+  { 0x1065, 0x1066, 1},\n+  { 0x106e, 0x1070, 1},\n+  { 0x1075, 0x1081, 1},\n+  { 0x108e, 0x108e, 1},\n+  { 0x10a0, 0x10c5, 1},\n+  { 0x10d0, 0x10fa, 1},\n+  { 0x10fc, 0x10fc, 1},\n+  { 0x1100, 0x1159, 1},\n+  { 0x115f, 0x11a2, 1},\n+  { 0x11a8, 0x11f9, 1},\n+  { 0x1200, 0x1248, 1},\n+  { 0x124a, 0x124d, 1},\n+  { 0x1250, 0x1256, 1},\n+  { 0x1258, 0x1258, 1},\n+  { 0x125a, 0x125d, 1},\n+  { 0x1260, 0x1288, 1},\n+  { 0x128a, 0x128d, 1},\n+  { 0x1290, 0x12b0, 1},\n+  { 0x12b2, 0x12b5, 1},\n+  { 0x12b8, 0x12be, 1},\n+  { 0x12c0, 0x12c0, 1},\n+  { 0x12c2, 0x12c5, 1},\n+  { 0x12c8, 0x12d6, 1},\n+  { 0x12d8, 0x1310, 1},\n+  { 0x1312, 0x1315, 1},\n+  { 0x1318, 0x135a, 1},\n+  { 0x1380, 0x138f, 1},\n+  { 0x13a0, 0x13f4, 1},\n+  { 0x1401, 0x166c, 1},\n+  { 0x166f, 0x1676, 1},\n+  { 0x1681, 0x169a, 1},\n+  { 0x16a0, 0x16ea, 1},\n+  { 0x1700, 0x170c, 1},\n+  { 0x170e, 0x1711, 1},\n+  { 0x1720, 0x1731, 1},\n+  { 0x1740, 0x1751, 1},\n+  { 0x1760, 0x176c, 1},\n+  { 0x176e, 0x1770, 1},\n+  { 0x1780, 0x17b3, 1},\n+  { 0x17d7, 0x17dc, 5},\n+  { 0x1820, 0x1877, 1},\n+  { 0x1880, 0x18a8, 1},\n+  { 0x18aa, 0x18aa, 1},\n+  { 0x1900, 0x191c, 1},\n+  { 0x1950, 0x196d, 1},\n+  { 0x1970, 0x1974, 1},\n+  { 0x1980, 0x19a9, 1},\n+  { 0x19c1, 0x19c7, 1},\n+  { 0x1a00, 0x1a16, 1},\n+  { 0x1b05, 0x1b33, 1},\n+  { 0x1b45, 0x1b4b, 1},\n+  { 0x1b83, 0x1ba0, 1},\n+  { 0x1bae, 0x1baf, 1},\n+  { 0x1c00, 0x1c23, 1},\n+  { 0x1c4d, 0x1c4f, 1},\n+  { 0x1c5a, 0x1c7d, 1},\n+  { 0x1d00, 0x1dbf, 1},\n+  { 0x1e00, 0x1f15, 1},\n+  { 0x1f18, 0x1f1d, 1},\n+  { 0x1f20, 0x1f45, 1},\n+  { 0x1f48, 0x1f4d, 1},\n+  { 0x1f50, 0x1f57, 1},\n+  { 0x1f59, 0x1f5d, 2},\n+  { 0x1f5f, 0x1f7d, 1},\n+  { 0x1f80, 0x1fb4, 1},\n+  { 0x1fb6, 0x1fbc, 1},\n+  { 0x1fbe, 0x1fbe, 1},\n+  { 0x1fc2, 0x1fc4, 1},\n+  { 0x1fc6, 0x1fcc, 1},\n+  { 0x1fd0, 0x1fd3, 1},\n+  { 0x1fd6, 0x1fdb, 1},\n+  { 0x1fe0, 0x1fec, 1},\n+  { 0x1ff2, 0x1ff4, 1},\n+  { 0x1ff6, 0x1ffc, 1},\n+  { 0x2071, 0x207f, 14},\n+  { 0x2090, 0x2094, 1},\n+  { 0x2102, 0x2107, 5},\n+  { 0x210a, 0x2113, 1},\n+  { 0x2115, 0x2115, 1},\n+  { 0x2119, 0x211d, 1},\n+  { 0x2124, 0x2128, 2},\n+  { 0x212a, 0x212d, 1},\n+  { 0x212f, 0x2139, 1},\n+  { 0x213c, 0x213f, 1},\n+  { 0x2145, 0x2149, 1},\n+  { 0x214e, 0x214e, 1},\n+  { 0x2183, 0x2184, 1},\n+  { 0x2c00, 0x2c2e, 1},\n+  { 0x2c30, 0x2c5e, 1},\n+  { 0x2c60, 0x2c6f, 1},\n+  { 0x2c71, 0x2c7d, 1},\n+  { 0x2c80, 0x2ce4, 1},\n+  { 0x2d00, 0x2d25, 1},\n+  { 0x2d30, 0x2d65, 1},\n+  { 0x2d6f, 0x2d6f, 1},\n+  { 0x2d80, 0x2d96, 1},\n+  { 0x2da0, 0x2da6, 1},\n+  { 0x2da8, 0x2dae, 1},\n+  { 0x2db0, 0x2db6, 1},\n+  { 0x2db8, 0x2dbe, 1},\n+  { 0x2dc0, 0x2dc6, 1},\n+  { 0x2dc8, 0x2dce, 1},\n+  { 0x2dd0, 0x2dd6, 1},\n+  { 0x2dd8, 0x2dde, 1},\n+  { 0x2e2f, 0x2e2f, 1},\n+  { 0x3005, 0x3006, 1},\n+  { 0x3031, 0x3035, 1},\n+  { 0x303b, 0x303c, 1},\n+  { 0x3041, 0x3096, 1},\n+  { 0x309d, 0x309f, 1},\n+  { 0x30a1, 0x30fa, 1},\n+  { 0x30fc, 0x30ff, 1},\n+  { 0x3105, 0x312d, 1},\n+  { 0x3131, 0x318e, 1},\n+  { 0x31a0, 0x31b7, 1},\n+  { 0x31f0, 0x31ff, 1},\n+  { 0x3400, 0x4db5, 1},\n+  { 0x4e00, 0x9fc3, 1},\n+  { 0xa000, 0xa48c, 1},\n+  { 0xa500, 0xa60c, 1},\n+  { 0xa610, 0xa61f, 1},\n+  { 0xa62a, 0xa62b, 1},\n+  { 0xa640, 0xa65f, 1},\n+  { 0xa662, 0xa66e, 1},\n+  { 0xa67f, 0xa697, 1},\n+  { 0xa717, 0xa71f, 1},\n+  { 0xa722, 0xa788, 1},\n+  { 0xa78b, 0xa78c, 1},\n+  { 0xa7fb, 0xa801, 1},\n+  { 0xa803, 0xa805, 1},\n+  { 0xa807, 0xa80a, 1},\n+  { 0xa80c, 0xa822, 1},\n+  { 0xa840, 0xa873, 1},\n+  { 0xa882, 0xa8b3, 1},\n+  { 0xa90a, 0xa925, 1},\n+  { 0xa930, 0xa946, 1},\n+  { 0xaa00, 0xaa28, 1},\n+  { 0xaa40, 0xaa42, 1},\n+  { 0xaa44, 0xaa4b, 1},\n+  { 0xac00, 0xd7a3, 1},\n+  { 0xf900, 0xfa2d, 1},\n+  { 0xfa30, 0xfa6a, 1},\n+  { 0xfa70, 0xfad9, 1},\n+  { 0xfb00, 0xfb06, 1},\n+  { 0xfb13, 0xfb17, 1},\n+  { 0xfb1d, 0xfb1d, 1},\n+  { 0xfb1f, 0xfb28, 1},\n+  { 0xfb2a, 0xfb36, 1},\n+  { 0xfb38, 0xfb3c, 1},\n+  { 0xfb3e, 0xfb3e, 1},\n+  { 0xfb40, 0xfb41, 1},\n+  { 0xfb43, 0xfb44, 1},\n+  { 0xfb46, 0xfbb1, 1},\n+  { 0xfbd3, 0xfd3d, 1},\n+  { 0xfd50, 0xfd8f, 1},\n+  { 0xfd92, 0xfdc7, 1},\n+  { 0xfdf0, 0xfdfb, 1},\n+  { 0xfe70, 0xfe74, 1},\n+  { 0xfe76, 0xfefc, 1},\n+  { 0xff21, 0xff3a, 1},\n+  { 0xff41, 0xff5a, 1},\n+  { 0xff66, 0xffbe, 1},\n+  { 0xffc2, 0xffc7, 1},\n+  { 0xffca, 0xffcf, 1},\n+  { 0xffd2, 0xffd7, 1},\n+  { 0xffda, 0xffdc, 1},\n+  { 0x10000, 0x1000b, 1},\n+  { 0x1000d, 0x10026, 1},\n+  { 0x10028, 0x1003a, 1},\n+  { 0x1003c, 0x1003d, 1},\n+  { 0x1003f, 0x1004d, 1},\n+  { 0x10050, 0x1005d, 1},\n+  { 0x10080, 0x100fa, 1},\n+  { 0x10280, 0x1029c, 1},\n+  { 0x102a0, 0x102d0, 1},\n+  { 0x10300, 0x1031e, 1},\n+  { 0x10330, 0x10340, 1},\n+  { 0x10342, 0x10349, 1},\n+  { 0x10380, 0x1039d, 1},\n+  { 0x103a0, 0x103c3, 1},\n+  { 0x103c8, 0x103cf, 1},\n+  { 0x10400, 0x1049d, 1},\n+  { 0x10800, 0x10805, 1},\n+  { 0x10808, 0x10808, 1},\n+  { 0x1080a, 0x10835, 1},\n+  { 0x10837, 0x10838, 1},\n+  { 0x1083c, 0x1083f, 3},\n+  { 0x10900, 0x10915, 1},\n+  { 0x10920, 0x10939, 1},\n+  { 0x10a00, 0x10a00, 1},\n+  { 0x10a10, 0x10a13, 1},\n+  { 0x10a15, 0x10a17, 1},\n+  { 0x10a19, 0x10a33, 1},\n+  { 0x12000, 0x1236e, 1},\n+  { 0x1d400, 0x1d454, 1},\n+  { 0x1d456, 0x1d49c, 1},\n+  { 0x1d49e, 0x1d49f, 1},\n+  { 0x1d4a2, 0x1d4a2, 1},\n+  { 0x1d4a5, 0x1d4a6, 1},\n+  { 0x1d4a9, 0x1d4ac, 1},\n+  { 0x1d4ae, 0x1d4b9, 1},\n+  { 0x1d4bb, 0x1d4bb, 1},\n+  { 0x1d4bd, 0x1d4c3, 1},\n+  { 0x1d4c5, 0x1d505, 1},\n+  { 0x1d507, 0x1d50a, 1},\n+  { 0x1d50d, 0x1d514, 1},\n+  { 0x1d516, 0x1d51c, 1},\n+  { 0x1d51e, 0x1d539, 1},\n+  { 0x1d53b, 0x1d53e, 1},\n+  { 0x1d540, 0x1d544, 1},\n+  { 0x1d546, 0x1d546, 1},\n+  { 0x1d54a, 0x1d550, 1},\n+  { 0x1d552, 0x1d6a5, 1},\n+  { 0x1d6a8, 0x1d6c0, 1},\n+  { 0x1d6c2, 0x1d6da, 1},\n+  { 0x1d6dc, 0x1d6fa, 1},\n+  { 0x1d6fc, 0x1d714, 1},\n+  { 0x1d716, 0x1d734, 1},\n+  { 0x1d736, 0x1d74e, 1},\n+  { 0x1d750, 0x1d76e, 1},\n+  { 0x1d770, 0x1d788, 1},\n+  { 0x1d78a, 0x1d7a8, 1},\n+  { 0x1d7aa, 0x1d7c2, 1},\n+  { 0x1d7c4, 0x1d7cb, 1},\n+  { 0x20000, 0x2a6d6, 1},\n+  { 0x2f800, 0x2fa1d, 1},\n+};\n+\n+// A table of Unicode uppercase letters--Unicode code points\n+// classified as \"Letter, uppercase\".\n+\n+static const Unicode_range unicode_uppercase_letters[] =\n+{\n+  { 0x0041, 0x005a, 1},\n+  { 0x00c0, 0x00d6, 1},\n+  { 0x00d8, 0x00de, 1},\n+  { 0x0100, 0x0136, 2},\n+  { 0x0139, 0x0147, 2},\n+  { 0x014a, 0x0176, 2},\n+  { 0x0178, 0x0179, 1},\n+  { 0x017b, 0x017d, 2},\n+  { 0x0181, 0x0182, 1},\n+  { 0x0184, 0x0184, 1},\n+  { 0x0186, 0x0187, 1},\n+  { 0x0189, 0x018b, 1},\n+  { 0x018e, 0x0191, 1},\n+  { 0x0193, 0x0194, 1},\n+  { 0x0196, 0x0198, 1},\n+  { 0x019c, 0x019d, 1},\n+  { 0x019f, 0x01a0, 1},\n+  { 0x01a2, 0x01a4, 2},\n+  { 0x01a6, 0x01a7, 1},\n+  { 0x01a9, 0x01ac, 3},\n+  { 0x01ae, 0x01af, 1},\n+  { 0x01b1, 0x01b3, 1},\n+  { 0x01b5, 0x01b5, 1},\n+  { 0x01b7, 0x01b8, 1},\n+  { 0x01bc, 0x01c4, 8},\n+  { 0x01c7, 0x01cd, 3},\n+  { 0x01cf, 0x01db, 2},\n+  { 0x01de, 0x01ee, 2},\n+  { 0x01f1, 0x01f4, 3},\n+  { 0x01f6, 0x01f8, 1},\n+  { 0x01fa, 0x0232, 2},\n+  { 0x023a, 0x023b, 1},\n+  { 0x023d, 0x023e, 1},\n+  { 0x0241, 0x0241, 1},\n+  { 0x0243, 0x0246, 1},\n+  { 0x0248, 0x024e, 2},\n+  { 0x0370, 0x0372, 2},\n+  { 0x0376, 0x0386, 16},\n+  { 0x0388, 0x038a, 1},\n+  { 0x038c, 0x038c, 1},\n+  { 0x038e, 0x038f, 1},\n+  { 0x0391, 0x03a1, 1},\n+  { 0x03a3, 0x03ab, 1},\n+  { 0x03cf, 0x03cf, 1},\n+  { 0x03d2, 0x03d4, 1},\n+  { 0x03d8, 0x03ee, 2},\n+  { 0x03f4, 0x03f7, 3},\n+  { 0x03f9, 0x03fa, 1},\n+  { 0x03fd, 0x042f, 1},\n+  { 0x0460, 0x0480, 2},\n+  { 0x048a, 0x04be, 2},\n+  { 0x04c0, 0x04c1, 1},\n+  { 0x04c3, 0x04cd, 2},\n+  { 0x04d0, 0x0522, 2},\n+  { 0x0531, 0x0556, 1},\n+  { 0x10a0, 0x10c5, 1},\n+  { 0x1e00, 0x1e94, 2},\n+  { 0x1e9e, 0x1efe, 2},\n+  { 0x1f08, 0x1f0f, 1},\n+  { 0x1f18, 0x1f1d, 1},\n+  { 0x1f28, 0x1f2f, 1},\n+  { 0x1f38, 0x1f3f, 1},\n+  { 0x1f48, 0x1f4d, 1},\n+  { 0x1f59, 0x1f5f, 2},\n+  { 0x1f68, 0x1f6f, 1},\n+  { 0x1fb8, 0x1fbb, 1},\n+  { 0x1fc8, 0x1fcb, 1},\n+  { 0x1fd8, 0x1fdb, 1},\n+  { 0x1fe8, 0x1fec, 1},\n+  { 0x1ff8, 0x1ffb, 1},\n+  { 0x2102, 0x2107, 5},\n+  { 0x210b, 0x210d, 1},\n+  { 0x2110, 0x2112, 1},\n+  { 0x2115, 0x2115, 1},\n+  { 0x2119, 0x211d, 1},\n+  { 0x2124, 0x2128, 2},\n+  { 0x212a, 0x212d, 1},\n+  { 0x2130, 0x2133, 1},\n+  { 0x213e, 0x213f, 1},\n+  { 0x2145, 0x2183, 62},\n+  { 0x2c00, 0x2c2e, 1},\n+  { 0x2c60, 0x2c60, 1},\n+  { 0x2c62, 0x2c64, 1},\n+  { 0x2c67, 0x2c6b, 2},\n+  { 0x2c6d, 0x2c6f, 1},\n+  { 0x2c72, 0x2c75, 3},\n+  { 0x2c80, 0x2ce2, 2},\n+  { 0xa640, 0xa65e, 2},\n+  { 0xa662, 0xa66c, 2},\n+  { 0xa680, 0xa696, 2},\n+  { 0xa722, 0xa72e, 2},\n+  { 0xa732, 0xa76e, 2},\n+  { 0xa779, 0xa77b, 2},\n+  { 0xa77d, 0xa77e, 1},\n+  { 0xa780, 0xa786, 2},\n+  { 0xa78b, 0xa78b, 1},\n+  { 0xff21, 0xff3a, 1},\n+  { 0x10400, 0x10427, 1},\n+  { 0x1d400, 0x1d419, 1},\n+  { 0x1d434, 0x1d44d, 1},\n+  { 0x1d468, 0x1d481, 1},\n+  { 0x1d49c, 0x1d49c, 1},\n+  { 0x1d49e, 0x1d49f, 1},\n+  { 0x1d4a2, 0x1d4a2, 1},\n+  { 0x1d4a5, 0x1d4a6, 1},\n+  { 0x1d4a9, 0x1d4ac, 1},\n+  { 0x1d4ae, 0x1d4b5, 1},\n+  { 0x1d4d0, 0x1d4e9, 1},\n+  { 0x1d504, 0x1d505, 1},\n+  { 0x1d507, 0x1d50a, 1},\n+  { 0x1d50d, 0x1d514, 1},\n+  { 0x1d516, 0x1d51c, 1},\n+  { 0x1d538, 0x1d539, 1},\n+  { 0x1d53b, 0x1d53e, 1},\n+  { 0x1d540, 0x1d544, 1},\n+  { 0x1d546, 0x1d546, 1},\n+  { 0x1d54a, 0x1d550, 1},\n+  { 0x1d56c, 0x1d585, 1},\n+  { 0x1d5a0, 0x1d5b9, 1},\n+  { 0x1d5d4, 0x1d5ed, 1},\n+  { 0x1d608, 0x1d621, 1},\n+  { 0x1d63c, 0x1d655, 1},\n+  { 0x1d670, 0x1d689, 1},\n+  { 0x1d6a8, 0x1d6c0, 1},\n+  { 0x1d6e2, 0x1d6fa, 1},\n+  { 0x1d71c, 0x1d734, 1},\n+  { 0x1d756, 0x1d76e, 1},\n+  { 0x1d790, 0x1d7a8, 1},\n+  { 0x1d7ca, 0x1d7ca, 1},\n+};\n+\n+// Return true if C is in RANGES.\n+\n+bool\n+Lex::is_in_unicode_range(unsigned int c, const Unicode_range* ranges,\n+\t\t\t size_t range_size)\n+{\n+  if (c < 0x100)\n+    {\n+      // The common case is a small value, and we know that it will be\n+      // in the first few entries of the table.  Do a linear scan\n+      // rather than a binary search.\n+      for (size_t i = 0; i < range_size; ++i)\n+\t{\n+\t  const Unicode_range* p = &ranges[i];\n+\t  if (c <= p->high)\n+\t    {\n+\t      if (c < p->low)\n+\t\treturn false;\n+\t      return (c - p->low) % p->stride == 0;\n+\t    }\n+\t}\n+      return false;\n+    }\n+  else\n+    {\n+      size_t lo = 0;\n+      size_t hi = range_size;\n+      while (lo < hi)\n+\t{\n+\t  size_t mid = lo + (hi - lo) / 2;\n+\t  const Unicode_range* p = &ranges[mid];\n+\t  if (c < p->low)\n+\t    hi = mid;\n+\t  else if (c > p->high)\n+\t    lo = mid + 1;\n+\t  else\n+\t    return (c - p->low) % p->stride == 0;\n+\t}\n+      return false;\n+    }\n+}\n+\n+// Return whether C is a Unicode digit--a Unicode code point\n+// classified as \"Digit\".\n+\n+bool\n+Lex::is_unicode_digit(unsigned int c)\n+{\n+  return Lex::is_in_unicode_range(c, unicode_digits,\n+\t\t\t\t  ARRAY_SIZE(unicode_digits));\n+}\n+\n+// Return whether C is a Unicode letter--a Unicode code point\n+// classified as \"Letter\".\n+\n+bool\n+Lex::is_unicode_letter(unsigned int c)\n+{\n+  return Lex::is_in_unicode_range(c, unicode_letters,\n+\t\t\t\t  ARRAY_SIZE(unicode_letters));\n+}\n+\n+// Return whether C is a Unicode uppercase letter.  a Unicode code\n+// point classified as \"Letter, uppercase\".\n+\n+bool\n+Lex::is_unicode_uppercase(unsigned int c)\n+{\n+  return Lex::is_in_unicode_range(c, unicode_uppercase_letters,\n+\t\t\t\t  ARRAY_SIZE(unicode_uppercase_letters));\n+}\n+\n+// Return whether the identifier NAME should be exported.  NAME is a\n+// mangled name which includes only ASCII characters.\n+\n+bool\n+Lex::is_exported_name(const std::string& name)\n+{\n+  unsigned char c = name[0];\n+  if (c != '$')\n+    return c >= 'A' && c <= 'Z';\n+  else\n+    {\n+      const char* p = name.data();\n+      size_t len = name.length();\n+      if (len < 2 || p[1] != 'U')\n+\treturn false;\n+      unsigned int ci = 0;\n+      for (size_t i = 2; i < len && p[i] != '$'; ++i)\n+\t{\n+\t  c = p[i];\n+\t  if (!hex_p(c))\n+\t    return false;\n+\t  ci <<= 4;\n+\t  ci |= hex_value(c);\n+\t}\n+      return Lex::is_unicode_uppercase(ci);\n+    }\n+}"}, {"sha": "c8def2bf7d5f70b37838802333b0075bfc241e17", "filename": "gcc/go/gofrontend/lex.h", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,446 @@\n+// lex.h -- Go frontend lexer.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_LEX_H\n+#define GO_LEX_H\n+\n+#include <gmp.h>\n+#include <mpfr.h>\n+\n+#include \"operator.h\"\n+\n+struct Unicode_range;\n+\n+// The keywords.  These must be in sorted order, other than\n+// KEYWORD_INVALID.  They must match the Keywords::mapping_ array in\n+// lex.cc.\n+\n+enum Keyword\n+{\n+  KEYWORD_INVALID,\t// Not a keyword.\n+  KEYWORD_ASM,\n+  KEYWORD_BREAK,\n+  KEYWORD_CASE,\n+  KEYWORD_CHAN,\n+  KEYWORD_CONST,\n+  KEYWORD_CONTINUE,\n+  KEYWORD_DEFAULT,\n+  KEYWORD_DEFER,\n+  KEYWORD_ELSE,\n+  KEYWORD_FALLTHROUGH,\n+  KEYWORD_FOR,\n+  KEYWORD_FUNC,\n+  KEYWORD_GO,\n+  KEYWORD_GOTO,\n+  KEYWORD_IF,\n+  KEYWORD_IMPORT,\n+  KEYWORD_INTERFACE,\n+  KEYWORD_MAP,\n+  KEYWORD_PACKAGE,\n+  KEYWORD_RANGE,\n+  KEYWORD_RETURN,\n+  KEYWORD_SELECT,\n+  KEYWORD_STRUCT,\n+  KEYWORD_SWITCH,\n+  KEYWORD_TYPE,\n+  KEYWORD_VAR\n+};\n+\n+// A token returned from the lexer.\n+\n+class Token\n+{\n+ public:\n+  // Token classification.\n+  enum Classification\n+  {\n+    // Token is invalid.\n+    TOKEN_INVALID,\n+    // Token indicates end of input.\n+    TOKEN_EOF,\n+    // Token is a keyword.\n+    TOKEN_KEYWORD,\n+    // Token is an identifier.\n+    TOKEN_IDENTIFIER,\n+    // Token is a string of characters.\n+    TOKEN_STRING,\n+    // Token is an operator.\n+    TOKEN_OPERATOR,\n+    // Token is an integer.\n+    TOKEN_INTEGER,\n+    // Token is a floating point number.\n+    TOKEN_FLOAT,\n+    // Token is an imaginary number.\n+    TOKEN_IMAGINARY\n+  };\n+\n+  ~Token();\n+  Token(const Token&);\n+  Token& operator=(const Token&);\n+\n+  // Get token classification.\n+  Classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Make a token for an invalid value.\n+  static Token\n+  make_invalid_token(source_location location)\n+  { return Token(TOKEN_INVALID, location); }\n+\n+  // Make a token representing end of file.\n+  static Token\n+  make_eof_token(source_location location)\n+  { return Token(TOKEN_EOF, location); }\n+\n+  // Make a keyword token.\n+  static Token\n+  make_keyword_token(Keyword keyword, source_location location)\n+  {\n+    Token tok(TOKEN_KEYWORD, location);\n+    tok.u_.keyword = keyword;\n+    return tok;\n+  }\n+\n+  // Make an identifier token.\n+  static Token\n+  make_identifier_token(const std::string& value, bool is_exported,\n+\t\t\tsource_location location)\n+  {\n+    Token tok(TOKEN_IDENTIFIER, location);\n+    tok.u_.identifier_value.name = new std::string(value);\n+    tok.u_.identifier_value.is_exported = is_exported;\n+    return tok;\n+  }\n+\n+  // Make a quoted string token.\n+  static Token\n+  make_string_token(const std::string& value, source_location location)\n+  {\n+    Token tok(TOKEN_STRING, location);\n+    tok.u_.string_value = new std::string(value);\n+    return tok;\n+  }\n+\n+  // Make an operator token.\n+  static Token\n+  make_operator_token(Operator op, source_location location)\n+  {\n+    Token tok(TOKEN_OPERATOR, location);\n+    tok.u_.op = op;\n+    return tok;\n+  }\n+\n+  // Make an integer token.\n+  static Token\n+  make_integer_token(mpz_t val, source_location location)\n+  {\n+    Token tok(TOKEN_INTEGER, location);\n+    mpz_init(tok.u_.integer_value);\n+    mpz_swap(tok.u_.integer_value, val);\n+    return tok;\n+  }\n+\n+  // Make a float token.\n+  static Token\n+  make_float_token(mpfr_t val, source_location location)\n+  {\n+    Token tok(TOKEN_FLOAT, location);\n+    mpfr_init(tok.u_.float_value);\n+    mpfr_swap(tok.u_.float_value, val);\n+    return tok;\n+  }\n+\n+  // Make a token for an imaginary number.\n+  static Token\n+  make_imaginary_token(mpfr_t val, source_location location)\n+  {\n+    Token tok(TOKEN_IMAGINARY, location);\n+    mpfr_init(tok.u_.float_value);\n+    mpfr_swap(tok.u_.float_value, val);\n+    return tok;\n+  }\n+\n+  // Get the location of the token.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return whether this is an invalid token.\n+  bool\n+  is_invalid() const\n+  { return this->classification_ == TOKEN_INVALID; }\n+\n+  // Return whether this is the EOF token.\n+  bool\n+  is_eof() const\n+  { return this->classification_ == TOKEN_EOF; }\n+\n+  // Return the keyword value for a keyword token.\n+  Keyword\n+  keyword() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_KEYWORD);\n+    return this->u_.keyword;\n+  }\n+\n+  // Return whether this is an identifier.\n+  bool\n+  is_identifier() const\n+  { return this->classification_ == TOKEN_IDENTIFIER; }\n+\n+  // Return the identifier.\n+  const std::string&\n+  identifier() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_IDENTIFIER);\n+    return *this->u_.identifier_value.name;\n+  }\n+\n+  // Return whether the identifier is exported.\n+  bool\n+  is_identifier_exported() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_IDENTIFIER);\n+    return this->u_.identifier_value.is_exported;\n+  }\n+\n+  // Return whether this is a string.\n+  bool\n+  is_string() const\n+  {\n+    return this->classification_ == TOKEN_STRING;\n+  }\n+\n+  // Return the value of a string.  The returned value is a string of\n+  // UTF-8 characters.\n+  std::string\n+  string_value() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_STRING);\n+    return *this->u_.string_value;\n+  }\n+\n+  // Return the value of an integer.\n+  const mpz_t*\n+  integer_value() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_INTEGER);\n+    return &this->u_.integer_value;\n+  }\n+\n+  // Return the value of a float.\n+  const mpfr_t*\n+  float_value() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_FLOAT);\n+    return &this->u_.float_value;\n+  }\n+\n+  // Return the value of an imaginary number.\n+  const mpfr_t*\n+  imaginary_value() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_IMAGINARY);\n+    return &this->u_.float_value;\n+  }\n+\n+  // Return the operator value for an operator token.\n+  Operator\n+  op() const\n+  {\n+    gcc_assert(this->classification_ == TOKEN_OPERATOR);\n+    return this->u_.op;\n+  }\n+\n+  // Return whether this token is KEYWORD.\n+  bool\n+  is_keyword(Keyword keyword) const\n+  {\n+    return (this->classification_ == TOKEN_KEYWORD\n+\t    && this->u_.keyword == keyword);\n+  }\n+\n+  // Return whether this token is OP.\n+  bool\n+  is_op(Operator op) const\n+  { return this->classification_ == TOKEN_OPERATOR && this->u_.op == op; }\n+\n+  // Print the token for debugging.\n+  void\n+  print(FILE*) const;\n+\n+ private:\n+  // Private constructor used by make_..._token functions above.\n+  Token(Classification, source_location);\n+\n+  // Clear the token.\n+  void\n+  clear();\n+\n+  // The token classification.\n+  Classification classification_;\n+  union\n+  {\n+    // The keyword value for TOKEN_KEYWORD.\n+    Keyword keyword;\n+    // The token value for TOKEN_IDENTIFIER.\n+    struct\n+    {\n+      // The name of the identifier.  This has been mangled to only\n+      // include ASCII characters.\n+      std::string* name;\n+      // Whether this name should be exported.  This is true if the\n+      // first letter in the name is upper case.\n+      bool is_exported;\n+    } identifier_value;\n+    // The string value for TOKEN_STRING.\n+    std::string* string_value;\n+    // The token value for TOKEN_INTEGER.\n+    mpz_t integer_value;\n+    // The token value for TOKEN_FLOAT or TOKEN_IMAGINARY.\n+    mpfr_t float_value;\n+    // The token value for TOKEN_OPERATOR or the keyword value\n+    Operator op;\n+  } u_;\n+  // The source location.\n+  source_location location_;\n+};\n+\n+// The lexer itself.\n+\n+class Lex\n+{\n+ public:\n+  Lex(const char* input_file_name, FILE* input_file);\n+\n+  ~Lex();\n+\n+  // Return the next token.\n+  Token\n+  next_token();\n+\n+  // Return whether the identifier NAME should be exported.  NAME is a\n+  // mangled name which includes only ASCII characters.\n+  static bool\n+  is_exported_name(const std::string& name);\n+\n+  // A helper function.  Append V to STR.  IS_CHARACTER is true if V\n+  // is a Unicode character which should be converted into UTF-8,\n+  // false if it is a byte value to be appended directly.  The\n+  // location is used to warn about an out of range character.\n+  static void\n+  append_char(unsigned int v, bool is_charater, std::string* str,\n+\t      source_location);\n+\n+  // A helper function.  Fetch a UTF-8 character from STR and store it\n+  // in *VALUE.  Return the number of bytes read from STR.  Return 0\n+  // if STR does not point to a valid UTF-8 character.\n+  static int\n+  fetch_char(const char* str, unsigned int *value);\n+\n+ private:\n+  ssize_t\n+  get_line();\n+\n+  bool\n+  require_line();\n+\n+  // The current location.\n+  source_location\n+  location() const;\n+\n+  // A position CHARS column positions before the current location.\n+  source_location\n+  earlier_location(int chars) const;\n+\n+  static bool\n+  is_hex_digit(char);\n+\n+  static unsigned char\n+  octal_value(char c)\n+  { return c - '0'; }\n+\n+  Token\n+  make_invalid_token()\n+  { return Token::make_invalid_token(this->location()); }\n+\n+  Token\n+  make_eof_token()\n+  { return Token::make_eof_token(this->location()); }\n+\n+  Token\n+  make_operator(Operator op, int chars)\n+  { return Token::make_operator_token(op, this->earlier_location(chars)); }\n+\n+  Token\n+  gather_identifier();\n+\n+  Token\n+  gather_number();\n+\n+  Token\n+  gather_character();\n+\n+  Token\n+  gather_string();\n+\n+  Token\n+  gather_raw_string();\n+\n+  const char*\n+  advance_one_utf8_char(const char*, unsigned int*, bool*);\n+\n+  const char*\n+  advance_one_char(const char*, bool, unsigned int*, bool*);\n+\n+  static bool\n+  is_unicode_digit(unsigned int c);\n+\n+  static bool\n+  is_unicode_letter(unsigned int c);\n+\n+  static bool\n+  is_unicode_uppercase(unsigned int c);\n+\n+  static bool\n+  is_in_unicode_range(unsigned int C, const Unicode_range* ranges,\n+\t\t      size_t range_size);\n+\n+  Operator\n+  three_character_operator(char, char, char);\n+\n+  Operator\n+  two_character_operator(char, char);\n+\n+  Operator\n+  one_character_operator(char);\n+\n+  bool\n+  skip_c_comment();\n+\n+  void\n+  skip_cpp_comment();\n+\n+  // The input file name.\n+  const char* input_file_name_;\n+  // The input file.\n+  FILE* input_file_;\n+  // The line buffer.  This holds the current line.\n+  char* linebuf_;\n+  // The size of the line buffer.\n+  size_t linebufsize_;\n+  // The nmber of characters in the current line.\n+  size_t linesize_;\n+  // The current offset in linebuf_.\n+  size_t lineoff_;\n+  // The current line number.\n+  size_t lineno_;\n+  // Whether to add a semicolon if we see a newline now.\n+  bool add_semi_at_eol_;\n+};\n+\n+#endif // !defined(GO_LEX_H)"}, {"sha": "f3e0fd0743469622cee5d5a56f3775b8f6618122", "filename": "gcc/go/gofrontend/operator.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Foperator.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,66 @@\n+// operator.h -- Go frontend operators.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_OPERATOR_H\n+#define GO_OPERATOR_H\n+\n+// The operators.\n+\n+enum Operator\n+{\n+  OPERATOR_INVALID,\n+  OPERATOR_OROR,\t// ||\n+  OPERATOR_ANDAND,\t// &&\n+  OPERATOR_EQEQ,\t// ==\n+  OPERATOR_NOTEQ,\t// !=\n+  OPERATOR_LT,\t\t// <\n+  OPERATOR_LE,\t\t// <=\n+  OPERATOR_GT,\t\t// >\n+  OPERATOR_GE,\t\t// >=\n+  OPERATOR_PLUS,\t// +\n+  OPERATOR_MINUS,\t// -\n+  OPERATOR_OR,\t\t// |\n+  OPERATOR_XOR,\t\t// ^\n+  OPERATOR_MULT,\t// *\n+  OPERATOR_DIV,\t\t// /\n+  OPERATOR_MOD,\t\t// %\n+  OPERATOR_LSHIFT,\t// <<\n+  OPERATOR_RSHIFT,\t// >>\n+  OPERATOR_AND,\t\t// &\n+  OPERATOR_NOT,\t\t// !\n+  OPERATOR_BITCLEAR,\t// &^\n+  OPERATOR_CHANOP,\t// <-\n+\n+  OPERATOR_EQ,\t\t// =\n+  OPERATOR_PLUSEQ,\t// +=\n+  OPERATOR_MINUSEQ,\t// -=\n+  OPERATOR_OREQ,\t// |=\n+  OPERATOR_XOREQ,\t// ^=\n+  OPERATOR_MULTEQ,\t// *=\n+  OPERATOR_DIVEQ,\t// /=\n+  OPERATOR_MODEQ,\t// %=\n+  OPERATOR_LSHIFTEQ,\t// <<=\n+  OPERATOR_RSHIFTEQ,\t// >>=\n+  OPERATOR_ANDEQ,\t// &=\n+  OPERATOR_BITCLEAREQ,\t// &^=\n+  OPERATOR_PLUSPLUS,\t// ++\n+  OPERATOR_MINUSMINUS,\t// --\n+\n+  OPERATOR_COLON,\t// :\n+  OPERATOR_COLONEQ,\t// :=\n+  OPERATOR_SEMICOLON,\t// ;\n+  OPERATOR_DOT,\t\t// .\n+  OPERATOR_ELLIPSIS,\t// ...\n+  OPERATOR_COMMA,\t// ,\n+  OPERATOR_LPAREN,\t// (\n+  OPERATOR_RPAREN,\t// )\n+  OPERATOR_LCURLY,\t// {\n+  OPERATOR_RCURLY,\t// }\n+  OPERATOR_LSQUARE,\t// [\n+  OPERATOR_RSQUARE\t// ]\n+};\n+\n+#endif // !defined(GO_OPERATOR_H)"}, {"sha": "c8b55c56214b9dbb999f5c4b27c444105fbee8de", "filename": "gcc/go/gofrontend/parse.cc", "status": "added", "additions": 4730, "deletions": 0, "changes": 4730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "fc2eb12b6d5081ae232ee4e09eb5d4007b526fb9", "filename": "gcc/go/gofrontend/parse.h", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,307 @@\n+// parse.h -- Go frontend parser.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_PARSE_H\n+#define GO_PARSE_H\n+\n+class Set_iota_traverse;\n+class Lex;\n+class Gogo;\n+class Named_object;\n+class Type;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Block;\n+class Expression;\n+class Expression_list;\n+class Struct_field_list;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Statement;\n+class Label;\n+\n+// Parse the program.\n+\n+class Parse\n+{\n+ public:\n+  Parse(Lex*, Gogo*);\n+\n+  // Parse a program.\n+  void\n+  program();\n+\n+ private:\n+  // Precedence values.\n+  enum Precedence\n+  {\n+    PRECEDENCE_INVALID = -1,\n+    PRECEDENCE_NORMAL = 0,\n+    PRECEDENCE_OROR,\n+    PRECEDENCE_ANDAND,\n+    PRECEDENCE_CHANOP,\n+    PRECEDENCE_RELOP,\n+    PRECEDENCE_ADDOP,\n+    PRECEDENCE_MULOP\n+  };\n+\n+  // We use this when parsing the range clause of a for statement.\n+  struct Range_clause\n+  {\n+    // Set to true if we found a range clause.\n+    bool found;\n+    // The index expression.\n+    Expression* index;\n+    // The value expression.\n+    Expression* value;\n+    // The range expression.\n+    Expression* range;\n+\n+    Range_clause()\n+      : found(false), index(NULL), value(NULL), range(NULL)\n+    { }\n+  };\n+\n+  // We use this when parsing the statement at the start of a switch,\n+  // in order to recognize type switches.\n+  struct Type_switch\n+  {\n+    // Set to true if we find a type switch.\n+    bool found;\n+    // The variable name.\n+    std::string name;\n+    // The location of the variable.\n+    source_location location;\n+    // The expression.\n+    Expression* expr;\n+\n+    Type_switch()\n+      : found(false), name(), location(UNKNOWN_LOCATION), expr(NULL)\n+    { }\n+  };\n+\n+  // A variable defined in an enclosing function referenced by the\n+  // current function.\n+  class Enclosing_var\n+  {\n+   public:\n+    Enclosing_var(Named_object* var, Named_object* in_function,\n+\t\t  unsigned int index)\n+      : var_(var), in_function_(in_function), index_(index)\n+    { }\n+\n+    // We put these in a vector, so we need a default constructor.\n+    Enclosing_var()\n+      : var_(NULL), in_function_(NULL), index_(-1U)\n+    { }\n+\n+    Named_object*\n+    var() const\n+    { return this->var_; }\n+\n+    Named_object*\n+    in_function() const\n+    { return this->in_function_; }\n+\n+    unsigned int\n+    index() const\n+    { return this->index_; }\n+\n+   private:\n+    // The variable which is being referred to.\n+    Named_object* var_;\n+    // The function where the variable is defined.\n+    Named_object* in_function_;\n+    // The index of the field in this function's closure struct for\n+    // this variable.\n+    unsigned int index_;\n+  };\n+\n+  // We store Enclosing_var entries in a set, so we need a comparator.\n+  struct Enclosing_var_comparison\n+  {\n+    bool\n+    operator()(const Enclosing_var&, const Enclosing_var&);\n+  };\n+\n+  // A set of Enclosing_var entries.\n+  typedef std::set<Enclosing_var, Enclosing_var_comparison> Enclosing_vars;\n+\n+  // Peek at the current token from the lexer.\n+  const Token*\n+  peek_token();\n+\n+  // Consume the current token, return the next one.\n+  const Token*\n+  advance_token();\n+\n+  // Push a token back on the input stream.\n+  void\n+  unget_token(const Token&);\n+\n+  // The location of the current token.\n+  source_location\n+  location();\n+\n+  // For break and continue we keep a stack of statements with\n+  // associated labels (if any).  The top of the stack is used for a\n+  // break or continue statement with no label.\n+  typedef std::vector<std::pair<Statement*, const Label*> > Bc_stack;\n+\n+  // Parser nonterminals.\n+  void identifier_list(Typed_identifier_list*);\n+  Expression_list* expression_list(Expression*, bool may_be_sink);\n+  bool qualified_ident(std::string*, Named_object**);\n+  Type* type();\n+  bool type_may_start_here();\n+  Type* type_name(bool issue_error);\n+  Type* array_type(bool may_use_ellipsis);\n+  Type* map_type();\n+  Type* struct_type();\n+  void field_decl(Struct_field_list*);\n+  Type* pointer_type();\n+  Type* channel_type();\n+  Function_type* signature(Typed_identifier*, source_location);\n+  Typed_identifier_list* parameters(bool* is_varargs);\n+  Typed_identifier_list* parameter_list(bool* is_varargs);\n+  void parameter_decl(bool, Typed_identifier_list*, bool*, bool*);\n+  Typed_identifier_list* result();\n+  source_location block();\n+  Type* interface_type();\n+  bool method_spec(Typed_identifier_list*);\n+  void declaration();\n+  bool declaration_may_start_here();\n+  void decl(void (Parse::*)(void*), void*);\n+  void list(void (Parse::*)(void*), void*, bool);\n+  void const_decl();\n+  void const_spec(Type**, Expression_list**);\n+  void type_decl();\n+  void type_spec(void*);\n+  void var_decl();\n+  void var_spec(void*);\n+  void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n+\t\t bool is_coloneq, source_location);\n+  bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t   bool is_coloneq, source_location);\n+  bool init_vars_from_map(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t  bool is_coloneq, source_location);\n+  bool init_vars_from_receive(const Typed_identifier_list*, Type*,\n+\t\t\t      Expression*, bool is_coloneq, source_location);\n+  bool init_vars_from_type_guard(const Typed_identifier_list*, Type*,\n+\t\t\t\t Expression*, bool is_coloneq,\n+\t\t\t\t source_location);\n+  Named_object* init_var(const Typed_identifier&, Type*, Expression*,\n+\t\t\t bool is_coloneq, bool type_from_init, bool* is_new);\n+  void simple_var_decl_or_assignment(const std::string&, source_location,\n+\t\t\t\t     Range_clause*, Type_switch*);\n+  void function_decl();\n+  Typed_identifier* receiver();\n+  Expression* operand(bool may_be_sink);\n+  Expression* enclosing_var_reference(Named_object*, Named_object*,\n+\t\t\t\t      source_location);\n+  Expression* composite_lit(Type*, int depth, source_location);\n+  Expression* function_lit();\n+  Expression* create_closure(Named_object* function, Enclosing_vars*,\n+\t\t\t     source_location);\n+  Expression* primary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t   bool* is_type_switch);\n+  Expression* selector(Expression*, bool* is_type_switch);\n+  Expression* index(Expression*);\n+  Expression* call(Expression*);\n+  Expression* expression(Precedence, bool may_be_sink,\n+\t\t\t bool may_be_composite_lit, bool* is_type_switch);\n+  bool expression_may_start_here();\n+  Expression* unary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t bool* is_type_switch);\n+  Expression* qualified_expr(Expression*, source_location);\n+  Expression* id_to_expression(const std::string&, source_location);\n+  void statement(const Label*);\n+  bool statement_may_start_here();\n+  void labeled_stmt(const std::string&, source_location);\n+  Expression* simple_stat(bool, bool, Range_clause*, Type_switch*);\n+  bool simple_stat_may_start_here();\n+  void statement_list();\n+  bool statement_list_may_start_here();\n+  void expression_stat(Expression*);\n+  void inc_dec_stat(Expression*);\n+  void assignment(Expression*, Range_clause*);\n+  void tuple_assignment(Expression_list*, Range_clause*);\n+  void send();\n+  void go_or_defer_stat();\n+  void return_stat();\n+  void if_stat();\n+  void switch_stat(const Label*);\n+  Statement* expr_switch_body(const Label*, Expression*, source_location);\n+  void expr_case_clause(Case_clauses*);\n+  Expression_list* expr_switch_case(bool*);\n+  Statement* type_switch_body(const Label*, const Type_switch&,\n+\t\t\t      source_location);\n+  void type_case_clause(Named_object*, Type_case_clauses*);\n+  void type_switch_case(std::vector<Type*>*, bool*);\n+  void select_stat(const Label*);\n+  void comm_clause(Select_clauses*);\n+  bool comm_case(bool*, Expression**, Expression**, std::string*, bool*);\n+  bool send_or_recv_expr(bool*, Expression**, Expression**, std::string*);\n+  void for_stat(const Label*);\n+  void for_clause(Expression**, Block**);\n+  void range_clause_decl(const Typed_identifier_list*, Range_clause*);\n+  void range_clause_expr(const Expression_list*, Range_clause*);\n+  void push_break_statement(Statement*, const Label*);\n+  void push_continue_statement(Statement*, const Label*);\n+  void pop_break_statement();\n+  void pop_continue_statement();\n+  Statement* find_bc_statement(const Bc_stack*, const std::string&);\n+  void break_stat();\n+  void continue_stat();\n+  void goto_stat();\n+  void package_clause();\n+  void import_decl();\n+  void import_spec(void*);\n+\n+  void reset_iota();\n+  int iota_value();\n+  void increment_iota();\n+\n+  // Skip past an error looking for a semicolon or OP.  Return true if\n+  // all is well, false if we found EOF.\n+  bool\n+  skip_past_error(Operator op);\n+\n+  // Verify that an expression is not a sink, and return either the\n+  // expression or an error.\n+  Expression*\n+  verify_not_sink(Expression*);\n+\n+  // Return the statement associated with a label in a Bc_stack, or\n+  // NULL.\n+  Statement*\n+  find_bc_statement(const Bc_stack*, const std::string&) const;\n+\n+  // The lexer output we are parsing.\n+  Lex* lex_;\n+  // The current token.\n+  Token token_;\n+  // A token pushed back on the input stream.\n+  Token unget_token_;\n+  // Whether unget_token_ is valid.\n+  bool unget_token_valid_;\n+  // The code we are generating.\n+  Gogo* gogo_;\n+  // A stack of statements for which break may be used.\n+  Bc_stack break_stack_;\n+  // A stack of statements for which continue may be used.\n+  Bc_stack continue_stack_;\n+  // The current iota value.\n+  int iota_;\n+  // References from the local function to variables defined in\n+  // enclosing functions.\n+  Enclosing_vars enclosing_vars_;\n+};\n+\n+\n+#endif // !defined(GO_PARSE_H)"}, {"sha": "10fe7e41c564d74c52ff9b536991c69a55cb5cc4", "filename": "gcc/go/gofrontend/statements.cc", "status": "added", "additions": 5146, "deletions": 0, "changes": 5146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6ca586f10a9cf9c9ae0a405f0dd2a698337ee7af", "filename": "gcc/go/gofrontend/statements.h", "status": "added", "additions": 1420, "deletions": 0, "changes": 1420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,1420 @@\n+// statements.h -- Go frontend statements.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_STATEMENTS_H\n+#define GO_STATEMENTS_H\n+\n+#include \"operator.h\"\n+\n+class Gogo;\n+class Traverse;\n+class Block;\n+class Function;\n+class Unnamed_label;\n+class Temporary_statement;\n+class Variable_declaration_statement;\n+class Return_statement;\n+class Thunk_statement;\n+class Label_statement;\n+class For_statement;\n+class For_range_statement;\n+class Switch_statement;\n+class Type_switch_statement;\n+class Select_statement;\n+class Variable;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Expression;\n+class Expression_list;\n+class Struct_type;\n+class Call_expression;\n+class Map_index_expression;\n+class Receive_expression;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Typed_identifier_list;\n+\n+// This class is used to traverse assignments made by a statement\n+// which makes assignments.\n+\n+class Traverse_assignments\n+{\n+ public:\n+  Traverse_assignments()\n+  { }\n+\n+  virtual ~Traverse_assignments()\n+  { }\n+\n+  // This is called for a variable initialization.\n+  virtual void\n+  initialize_variable(Named_object*) = 0;\n+\n+  // This is called for each assignment made by the statement.  PLHS\n+  // points to the left hand side, and PRHS points to the right hand\n+  // side.  PRHS may be NULL if there is no associated expression, as\n+  // in the bool set by a non-blocking receive.\n+  virtual void\n+  assignment(Expression** plhs, Expression** prhs) = 0;\n+\n+  // This is called for each expression which is not passed to the\n+  // assignment function.  This is used for some of the statements\n+  // which assign two values, for which there is no expression which\n+  // describes the value.  For ++ and -- the value is passed to both\n+  // the assignment method and the rhs method.  IS_STORED is true if\n+  // this value is being stored directly.  It is false if the value is\n+  // computed but not stored.  IS_LOCAL is true if the value is being\n+  // stored in a local variable or this is being called by a return\n+  // statement.\n+  virtual void\n+  value(Expression**, bool is_stored, bool is_local) = 0;\n+};\n+\n+// A single statement.\n+\n+class Statement\n+{\n+ public:\n+  // The types of statements.\n+  enum Statement_classification\n+  {\n+    STATEMENT_ERROR,\n+    STATEMENT_VARIABLE_DECLARATION,\n+    STATEMENT_TEMPORARY,\n+    STATEMENT_ASSIGNMENT,\n+    STATEMENT_EXPRESSION,\n+    STATEMENT_BLOCK,\n+    STATEMENT_GO,\n+    STATEMENT_DEFER,\n+    STATEMENT_RETURN,\n+    STATEMENT_BREAK_OR_CONTINUE,\n+    STATEMENT_GOTO,\n+    STATEMENT_GOTO_UNNAMED,\n+    STATEMENT_LABEL,\n+    STATEMENT_UNNAMED_LABEL,\n+    STATEMENT_IF,\n+    STATEMENT_CONSTANT_SWITCH,\n+    STATEMENT_SELECT,\n+\n+    // These statements types are created by the parser, but they\n+    // disappear during the lowering pass.\n+    STATEMENT_ASSIGNMENT_OPERATION,\n+    STATEMENT_TUPLE_ASSIGNMENT,\n+    STATEMENT_TUPLE_MAP_ASSIGNMENT,\n+    STATEMENT_MAP_ASSIGNMENT,\n+    STATEMENT_TUPLE_RECEIVE_ASSIGNMENT,\n+    STATEMENT_TUPLE_TYPE_GUARD_ASSIGNMENT,\n+    STATEMENT_INCDEC,\n+    STATEMENT_FOR,\n+    STATEMENT_FOR_RANGE,\n+    STATEMENT_SWITCH,\n+    STATEMENT_TYPE_SWITCH\n+  };\n+\n+  Statement(Statement_classification, source_location);\n+\n+  virtual ~Statement();\n+\n+  // Make a variable declaration.\n+  static Statement*\n+  make_variable_declaration(Named_object*);\n+\n+  // Make a statement which creates a temporary variable and\n+  // initializes it to an expression.  The block is used if the\n+  // temporary variable has to be explicitly destroyed; the variable\n+  // must still be added to the block.  References to the temporary\n+  // variable may be constructed using make_temporary_reference.\n+  // Either the type or the initialization expression may be NULL, but\n+  // not both.\n+  static Temporary_statement*\n+  make_temporary(Type*, Expression*, source_location);\n+\n+  // Make an assignment statement.\n+  static Statement*\n+  make_assignment(Expression*, Expression*, source_location);\n+\n+  // Make an assignment operation (+=, etc.).\n+  static Statement*\n+  make_assignment_operation(Operator, Expression*, Expression*,\n+\t\t\t    source_location);\n+\n+  // Make a tuple assignment statement.\n+  static Statement*\n+  make_tuple_assignment(Expression_list*, Expression_list*, source_location);\n+\n+  // Make an assignment from a map index to a pair of variables.\n+  static Statement*\n+  make_tuple_map_assignment(Expression* val, Expression* present,\n+\t\t\t    Expression*, source_location);\n+\n+  // Make a statement which assigns a pair of values to a map.\n+  static Statement*\n+  make_map_assignment(Expression*, Expression* val,\n+\t\t      Expression* should_set, source_location);\n+\n+  // Make an assignment from a nonblocking receive to a pair of\n+  // variables.\n+  static Statement*\n+  make_tuple_receive_assignment(Expression* val, Expression* success,\n+\t\t\t\tExpression* channel, source_location);\n+\n+  // Make an assignment from a type guard to a pair of variables.\n+  static Statement*\n+  make_tuple_type_guard_assignment(Expression* val, Expression* ok,\n+\t\t\t\t   Expression* expr, Type* type,\n+\t\t\t\t   source_location);\n+\n+  // Make an expression statement from an Expression.\n+  static Statement*\n+  make_statement(Expression*);\n+\n+  // Make a block statement from a Block.  This is an embedded list of\n+  // statements which may also include variable definitions.\n+  static Statement*\n+  make_block_statement(Block*, source_location);\n+\n+  // Make an increment statement.\n+  static Statement*\n+  make_inc_statement(Expression*);\n+\n+  // Make a decrement statement.\n+  static Statement*\n+  make_dec_statement(Expression*);\n+\n+  // Make a go statement.\n+  static Statement*\n+  make_go_statement(Call_expression* call, source_location);\n+\n+  // Make a defer statement.\n+  static Statement*\n+  make_defer_statement(Call_expression* call, source_location);\n+\n+  // Make a return statement.\n+  static Statement*\n+  make_return_statement(const Typed_identifier_list*, Expression_list*,\n+\t\t\tsource_location);\n+\n+  // Make a break statement.\n+  static Statement*\n+  make_break_statement(Unnamed_label* label, source_location);\n+\n+  // Make a continue statement.\n+  static Statement*\n+  make_continue_statement(Unnamed_label* label, source_location);\n+\n+  // Make a goto statement.\n+  static Statement*\n+  make_goto_statement(Label* label, source_location);\n+\n+  // Make a goto statement to an unnamed label.\n+  static Statement*\n+  make_goto_unnamed_statement(Unnamed_label* label, source_location);\n+\n+  // Make a label statement--where the label is defined.\n+  static Statement*\n+  make_label_statement(Label* label, source_location);\n+\n+  // Make an unnamed label statement--where the label is defined.\n+  static Statement*\n+  make_unnamed_label_statement(Unnamed_label* label);\n+\n+  // Make an if statement.\n+  static Statement*\n+  make_if_statement(Expression* cond, Block* then_block, Block* else_block,\n+\t\t    source_location);\n+\n+  // Make a switch statement.\n+  static Switch_statement*\n+  make_switch_statement(Expression* switch_val, source_location);\n+\n+  // Make a type switch statement.\n+  static Type_switch_statement*\n+  make_type_switch_statement(Named_object* var, Expression*, source_location);\n+\n+  // Make a select statement.\n+  static Select_statement*\n+  make_select_statement(source_location);\n+\n+  // Make a for statement.\n+  static For_statement*\n+  make_for_statement(Block* init, Expression* cond, Block* post,\n+\t\t     source_location location);\n+\n+  // Make a for statement with a range clause.\n+  static For_range_statement*\n+  make_for_range_statement(Expression* index_var, Expression* value_var,\n+\t\t\t   Expression* range, source_location);\n+\n+  // Return the statement classification.\n+  Statement_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Get the statement location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Block*, size_t* index, Traverse*);\n+\n+  // Traverse the contents of this statement--the expressions and\n+  // statements which it contains.\n+  int\n+  traverse_contents(Traverse*);\n+\n+  // If this statement assigns some values, it calls a function for\n+  // each value to which this statement assigns a value, and returns\n+  // true.  If this statement does not assign any values, it returns\n+  // false.\n+  bool\n+  traverse_assignments(Traverse_assignments* tassign);\n+\n+  // Lower a statement.  This is called immediately after parsing to\n+  // simplify statements for further processing.  It returns the same\n+  // Statement or a new one.  BLOCK is the block containing this\n+  // statement.\n+  Statement*\n+  lower(Gogo* gogo, Block* block)\n+  { return this->do_lower(gogo, block); }\n+\n+  // Set type information for unnamed constants.\n+  void\n+  determine_types();\n+\n+  // Check types in a statement.  This simply checks that any\n+  // expressions used by the statement have the right type.\n+  void\n+  check_types(Gogo* gogo)\n+  { this->do_check_types(gogo); }\n+\n+  // Return whether this is a block statement.\n+  bool\n+  is_block_statement() const\n+  { return this->classification_ == STATEMENT_BLOCK; }\n+\n+  // If this is a variable declaration statement, return it.\n+  // Otherwise return NULL.\n+  Variable_declaration_statement*\n+  variable_declaration_statement()\n+  {\n+    return this->convert<Variable_declaration_statement,\n+\t\t\t STATEMENT_VARIABLE_DECLARATION>();\n+  }\n+\n+  // If this is a return statement, return it.  Otherwise return NULL.\n+  Return_statement*\n+  return_statement()\n+  { return this->convert<Return_statement, STATEMENT_RETURN>(); }\n+\n+  // If this is a thunk statement (a go or defer statement), return\n+  // it.  Otherwise return NULL.\n+  Thunk_statement*\n+  thunk_statement();\n+\n+  // If this is a label statement, return it.  Otherwise return NULL.\n+  Label_statement*\n+  label_statement()\n+  { return this->convert<Label_statement, STATEMENT_LABEL>(); }\n+\n+  // If this is a for statement, return it.  Otherwise return NULL.\n+  For_statement*\n+  for_statement()\n+  { return this->convert<For_statement, STATEMENT_FOR>(); }\n+\n+  // If this is a for statement over a range clause, return it.\n+  // Otherwise return NULL.\n+  For_range_statement*\n+  for_range_statement()\n+  { return this->convert<For_range_statement, STATEMENT_FOR_RANGE>(); }\n+\n+  // If this is a switch statement, return it.  Otherwise return NULL.\n+  Switch_statement*\n+  switch_statement()\n+  { return this->convert<Switch_statement, STATEMENT_SWITCH>(); }\n+\n+  // If this is a type switch statement, return it.  Otherwise return\n+  // NULL.\n+  Type_switch_statement*\n+  type_switch_statement()\n+  { return this->convert<Type_switch_statement, STATEMENT_TYPE_SWITCH>(); }\n+\n+  // If this is a select statement, return it.  Otherwise return NULL.\n+  Select_statement*\n+  select_statement()\n+  { return this->convert<Select_statement, STATEMENT_SELECT>(); }\n+\n+  // Return true if this statement may fall through--if after\n+  // executing this statement we may go on to execute the following\n+  // statement, if any.\n+  bool\n+  may_fall_through() const\n+  { return this->do_may_fall_through(); }\n+\n+  // Return the tree for a statement.  BLOCK is the enclosing block.\n+  tree\n+  get_tree(Translate_context*);\n+\n+ protected:\n+  // Implemented by child class: traverse the tree.\n+  virtual int\n+  do_traverse(Traverse*) = 0;\n+\n+  // Implemented by child class: traverse assignments.  Any statement\n+  // which includes an assignment should implement this.\n+  virtual bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { return false; }\n+\n+  // Implemented by the child class: lower this statement to a simpler\n+  // one.\n+  virtual Statement*\n+  do_lower(Gogo*, Block*)\n+  { return this; }\n+\n+  // Implemented by child class: set type information for unnamed\n+  // constants.  Any statement which includes an expression needs to\n+  // implement this.\n+  virtual void\n+  do_determine_types()\n+  { }\n+\n+  // Implemented by child class: check types of expressions used in a\n+  // statement.\n+  virtual void\n+  do_check_types(Gogo*)\n+  { }\n+\n+  // Implemented by child class: return true if this statement may\n+  // fall through.\n+  virtual bool\n+  do_may_fall_through() const\n+  { return true; }\n+\n+  // Implemented by child class: return a tree.\n+  virtual tree\n+  do_get_tree(Translate_context*) = 0;\n+\n+  // Traverse an expression in a statement.\n+  int\n+  traverse_expression(Traverse*, Expression**);\n+\n+  // Traverse an expression list in a statement.  The Expression_list\n+  // may be NULL.\n+  int\n+  traverse_expression_list(Traverse*, Expression_list*);\n+\n+  // Traverse a type in a statement.\n+  int\n+  traverse_type(Traverse*, Type*);\n+\n+  // Build a tree node with one operand, setting the location.  The\n+  // first operand really has type \"enum tree_code\", but that enum is\n+  // not defined here.\n+  tree\n+  build_stmt_1(int tree_code_value, tree);\n+\n+  // For children to call when they detect that they are in error.\n+  void\n+  set_is_error();\n+\n+  // For children to call to report an error conveniently.\n+  void\n+  report_error(const char*);\n+\n+  // For children to return an error statement from lower().\n+  static Statement*\n+  make_error_statement(source_location);\n+\n+ private:\n+  // Convert to the desired statement classification, or return NULL.\n+  // This is a controlled dynamic cast.\n+  template<typename Statement_class, Statement_classification sc>\n+  Statement_class*\n+  convert()\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  template<typename Statement_class, Statement_classification sc>\n+  const Statement_class*\n+  convert() const\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<const Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  // The statement classification.\n+  Statement_classification classification_;\n+  // The location in the input file of the start of this statement.\n+  source_location location_;\n+};\n+\n+// A statement which creates and initializes a temporary variable.\n+\n+class Temporary_statement : public Statement\n+{\n+ public:\n+  Temporary_statement(Type* type, Expression* init, source_location location)\n+    : Statement(STATEMENT_TEMPORARY, location),\n+      type_(type), init_(init), decl_(NULL), is_address_taken_(false)\n+  { }\n+\n+  // Return the type of the temporary variable.\n+  Type*\n+  type() const;\n+\n+  // Return the initialization expression.\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+  // Record that something takes the address of this temporary\n+  // variable.\n+  void\n+  set_is_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Return the tree for the temporary variable itself.  This should\n+  // not be called until after the statement itself has been expanded.\n+  tree\n+  get_decl() const\n+  {\n+    gcc_assert(this->decl_ != NULL);\n+    return this->decl_;\n+  }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The type of the temporary variable.\n+  Type* type_;\n+  // The initial value of the temporary variable.  This may be NULL.\n+  Expression* init_;\n+  // The DECL for the temporary variable.\n+  tree decl_;\n+  // True if something takes the address of this temporary variable.\n+  bool is_address_taken_;\n+};\n+\n+// A variable declaration.  This marks the point in the code where a\n+// variable is declared.  The Variable is also attached to a Block.\n+\n+class Variable_declaration_statement : public Statement\n+{\n+ public:\n+  Variable_declaration_statement(Named_object* var);\n+\n+  // The variable being declared.\n+  Named_object*\n+  var()\n+  { return this->var_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  Named_object* var_;\n+};\n+\n+// A return statement.\n+\n+class Return_statement : public Statement\n+{\n+ public:\n+  Return_statement(const Typed_identifier_list* results, Expression_list* vals,\n+\t\t   source_location location)\n+    : Statement(STATEMENT_RETURN, location),\n+      results_(results), vals_(vals)\n+  { }\n+\n+  // The list of values being returned.  This may be NULL.\n+  const Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->traverse_expression_list(traverse, this->vals_); }\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  bool\n+  do_may_fall_through() const\n+  { return false; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The result types of the function we are returning from.  This is\n+  // here because in some of the traversals it is inconvenient to get\n+  // it.\n+  const Typed_identifier_list* results_;\n+  // Return values.  This may be NULL.\n+  Expression_list* vals_;\n+};\n+\n+// Select_clauses holds the clauses of a select statement.  This is\n+// built by the parser.\n+\n+class Select_clauses\n+{\n+ public:\n+  Select_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  IS_SEND is true if this is a send clause,\n+  // false for a receive clause.  For a send clause CHANNEL is the\n+  // channel and VAL is the value to send.  For a receive clause\n+  // CHANNEL is the channel and VAL is either NULL or a Var_expression\n+  // for the variable to set; if VAL is NULL, VAR may be a variable\n+  // which is initialized with the received value.  IS_DEFAULT is true\n+  // if this is the default clause.  STATEMENTS is the list of\n+  // statements to execute.\n+  void\n+  add(bool is_send, Expression* channel, Expression* val, Named_object* var,\n+      bool is_default, Block* statements, source_location location)\n+  {\n+    this->clauses_.push_back(Select_clause(is_send, channel, val, var,\n+\t\t\t\t\t   is_default, statements, location));\n+  }\n+\n+  // Traverse the select clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower statements.\n+  void\n+  lower(Block*);\n+\n+  // Determine types.\n+  void\n+  determine_types();\n+\n+  // Whether the select clauses may fall through to the statement\n+  // which follows the overall select statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return a tree implementing the select statement.\n+  tree\n+  get_tree(Translate_context*, Unnamed_label* break_label, source_location);\n+\n+ private:\n+  // A single clause.\n+  class Select_clause\n+  {\n+   public:\n+    Select_clause()\n+      : channel_(NULL), val_(NULL), var_(NULL), statements_(NULL),\n+\tis_send_(false), is_default_(false)\n+    { }\n+\n+    Select_clause(bool is_send, Expression* channel, Expression* val,\n+\t\t  Named_object* var, bool is_default, Block* statements,\n+\t\t  source_location location)\n+      : channel_(channel), val_(val), var_(var), statements_(statements),\n+\tlocation_(location), is_send_(is_send), is_default_(is_default),\n+\tis_lowered_(false)\n+    { gcc_assert(is_default ? channel == NULL : channel != NULL); }\n+\n+    // Traverse the select clause.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower statements.\n+    void\n+    lower(Block*);\n+\n+    // Determine types.\n+    void\n+    determine_types();\n+\n+    // Return true if this is the default clause.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // Return the channel.  This will return NULL for the default\n+    // clause.\n+    Expression*\n+    channel() const\n+    { return this->channel_; }\n+\n+    // Return the value.  This will return NULL for the default\n+    // clause, or for a receive clause for which no value was given.\n+    Expression*\n+    val() const\n+    { return this->val_; }\n+\n+    // Return the variable to set when a receive clause is also a\n+    // variable definition (v := <- ch).  This will return NULL for\n+    // the default case, or for a send clause, or for a receive clause\n+    // which does not define a variable.\n+    Named_object*\n+    var() const\n+    { return this->var_; }\n+\n+    // Return true for a send, false for a receive.\n+    bool\n+    is_send() const\n+    {\n+      gcc_assert(!this->is_default_);\n+      return this->is_send_;\n+    }\n+\n+    // Return the statements.\n+    const Block*\n+    statements() const\n+    { return this->statements_; }\n+\n+    // Return the location.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Whether this clause may fall through to the statement which\n+    // follows the overall select statement.\n+    bool\n+    may_fall_through() const;\n+\n+    // Return a tree for the statements to execute.\n+    tree\n+    get_statements_tree(Translate_context*);\n+\n+   private:\n+    // The channel.\n+    Expression* channel_;\n+    // The value to send or the variable to set.\n+    Expression* val_;\n+    // The variable to initialize, for \"case a := <- ch\".\n+    Named_object* var_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // The location of this clause.\n+    source_location location_;\n+    // Whether this is a send or a receive.\n+    bool is_send_;\n+    // Whether this is the default.\n+    bool is_default_;\n+    // Whether this has been lowered.\n+    bool is_lowered_;\n+  };\n+\n+  void\n+  add_clause_tree(Translate_context*, int, Select_clause*, Unnamed_label*,\n+\t\t  tree*);\n+\n+  typedef std::vector<Select_clause> Clauses;\n+\n+  Clauses clauses_;\n+};\n+\n+// A select statement.\n+\n+class Select_statement : public Statement\n+{\n+ public:\n+  Select_statement(source_location location)\n+    : Statement(STATEMENT_SELECT, location),\n+      clauses_(NULL), break_label_(NULL), is_lowered_(false)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Select_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this select statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->clauses_->traverse(traverse); }\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  void\n+  do_determine_types()\n+  { this->clauses_->determine_types(); }\n+\n+  bool\n+  do_may_fall_through() const\n+  { return this->clauses_->may_fall_through(); }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The select clauses.\n+  Select_clauses* clauses_;\n+  // The break label.\n+  Unnamed_label* break_label_;\n+  // Whether this statement has been lowered.\n+  bool is_lowered_;\n+};\n+\n+// A statement which requires a thunk: go or defer.\n+\n+class Thunk_statement : public Statement\n+{\n+ public:\n+  Thunk_statement(Statement_classification, Call_expression*,\n+\t\t  source_location);\n+\n+  // Return the call expression.\n+  Expression*\n+  call()\n+  { return this->call_; }\n+\n+  // Simplify a go or defer statement so that it only uses a single\n+  // parameter.\n+  bool\n+  simplify_statement(Gogo*, Block*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  // Return the function and argument trees for the call.\n+  void\n+  get_fn_and_arg(Translate_context*, tree* pfn, tree* parg);\n+\n+ private:\n+  // Return whether this is a simple go statement.\n+  bool\n+  is_simple(Function_type*) const;\n+\n+  // Build the struct to use for a complex case.\n+  Struct_type*\n+  build_struct(Function_type* fntype);\n+\n+  // Build the thunk.\n+  void\n+  build_thunk(Gogo*, const std::string&, Function_type* fntype);\n+\n+  // The field name used in the thunk structure for the function\n+  // pointer.\n+  static const char* const thunk_field_fn;\n+\n+  // The field name used in the thunk structure for the receiver, if\n+  // there is one.\n+  static const char* const thunk_field_receiver;\n+\n+  // Set the name to use for thunk field N.\n+  void\n+  thunk_field_param(int n, char* buf, size_t buflen);\n+\n+  // The function call to be executed in a separate thread (go) or\n+  // later (defer).\n+  Expression* call_;\n+  // The type used for a struct to pass to a thunk, if this is not a\n+  // simple call.\n+  Struct_type* struct_type_;\n+};\n+\n+// A go statement.\n+\n+class Go_statement : public Thunk_statement\n+{\n+ public:\n+  Go_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_GO, call, location)\n+  { }\n+\n+ protected:\n+  tree\n+  do_get_tree(Translate_context*);\n+};\n+\n+// A defer statement.\n+\n+class Defer_statement : public Thunk_statement\n+{\n+ public:\n+  Defer_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_DEFER, call, location)\n+  { }\n+\n+ protected:\n+  tree\n+  do_get_tree(Translate_context*);\n+};\n+\n+// A label statement.\n+\n+class Label_statement : public Statement\n+{\n+ public:\n+  Label_statement(Label* label, source_location location)\n+    : Statement(STATEMENT_LABEL, location),\n+      label_(label)\n+  { }\n+\n+  // Return the label itself.\n+  const Label*\n+  label() const\n+  { return this->label_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The label.\n+  Label* label_;\n+};\n+\n+// A for statement.\n+\n+class For_statement : public Statement\n+{\n+ public:\n+  For_statement(Block* init, Expression* cond, Block* post,\n+\t\tsource_location location)\n+    : Statement(STATEMENT_FOR, location),\n+      init_(init), cond_(cond), post_(post), statements_(NULL),\n+      break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    gcc_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+  // Set the break and continue labels for this statement.\n+  void\n+  set_break_continue_labels(Unnamed_label* break_label,\n+\t\t\t    Unnamed_label* continue_label);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { gcc_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // The initialization statements.  This may be NULL.\n+  Block* init_;\n+  // The condition.  This may be NULL.\n+  Expression* cond_;\n+  // The statements to run after each iteration.  This may be NULL.\n+  Block* post_;\n+  // The statements in the loop itself.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// A for statement over a range clause.\n+\n+class For_range_statement : public Statement\n+{\n+ public:\n+  For_range_statement(Expression* index_var, Expression* value_var,\n+\t\t      Expression* range, source_location location)\n+    : Statement(STATEMENT_FOR_RANGE, location),\n+      index_var_(index_var), value_var_(value_var), range_(range),\n+      statements_(NULL), break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    gcc_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { gcc_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  Expression*\n+  make_range_ref(Named_object*, Temporary_statement*, source_location);\n+\n+  Expression*\n+  call_builtin(Gogo*, const char* funcname, Expression* arg, source_location);\n+\n+  void\n+  lower_range_array(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t    Temporary_statement*, Temporary_statement*,\n+\t\t    Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_string(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t     Temporary_statement*, Temporary_statement*,\n+\t\t     Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_map(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t  Temporary_statement*, Temporary_statement*,\n+\t\t  Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_channel(Gogo*, Block*, Block*, Named_object*,\n+\t\t      Temporary_statement*, Temporary_statement*,\n+\t\t      Temporary_statement*, Block**, Expression**, Block**,\n+\t\t      Block**);\n+\n+  // The variable which is set to the index value.\n+  Expression* index_var_;\n+  // The variable which is set to the element value.  This may be\n+  // NULL.\n+  Expression* value_var_;\n+  // The expression we are ranging over.\n+  Expression* range_;\n+  // The statements in the block.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// Class Case_clauses holds the clauses of a switch statement.  This\n+// is built by the parser.\n+\n+class Case_clauses\n+{\n+ public:\n+  Case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  CASES is a list of case expressions; it may be\n+  // NULL.  IS_DEFAULT is true if this is the default case.\n+  // STATEMENTS is a block of statements.  IS_FALLTHROUGH is true if\n+  // after the statements the case clause should fall through to the\n+  // next clause.\n+  void\n+  add(Expression_list* cases, bool is_default, Block* statements,\n+      bool is_fallthrough, source_location location)\n+  {\n+    this->clauses_.push_back(Case_clause(cases, is_default, statements,\n+\t\t\t\t\t is_fallthrough, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower for a nonconstant switch.\n+  void\n+  lower(Block*, Temporary_statement*, Unnamed_label*) const;\n+\n+  // Determine types of expressions.  The Type parameter is the type\n+  // of the switch value.\n+  void\n+  determine_types(Type*);\n+\n+  // Check types.  The Type parameter is the type of the switch value.\n+  bool\n+  check_types(Type*);\n+\n+  // Return true if all the clauses are constant values.\n+  bool\n+  is_constant() const;\n+\n+  // Return true if these clauses may fall through to the statements\n+  // following the switch statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return the body of a SWITCH_EXPR when all the clauses are\n+  // constants.\n+  tree\n+  get_constant_tree(Translate_context*, Unnamed_label* break_label) const;\n+\n+ private:\n+  // For a constant tree we need to keep a record of constants we have\n+  // already seen.  Note that INTEGER_CST trees are interned.\n+  typedef Unordered_set(tree) Case_constants;\n+\n+  // One case clause.\n+  class Case_clause\n+  {\n+   public:\n+    Case_clause()\n+      : cases_(NULL), statements_(NULL), is_default_(false),\n+\tis_fallthrough_(false), location_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Case_clause(Expression_list* cases, bool is_default, Block* statements,\n+\t\tbool is_fallthrough, source_location location)\n+      : cases_(cases), statements_(statements), is_default_(is_default),\n+\tis_fallthrough_(is_fallthrough), location_(location)\n+    { }\n+\n+    // Whether this clause falls through to the next clause.\n+    bool\n+    is_fallthrough() const\n+    { return this->is_fallthrough_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower for a nonconstant switch.\n+    void\n+    lower(Block*, Temporary_statement*, Unnamed_label*, Unnamed_label*) const;\n+\n+    // Determine types.\n+    void\n+    determine_types(Type*);\n+\n+    // Check types.\n+    bool\n+    check_types(Type*);\n+\n+    // Return true if all the case expressions are constant.\n+    bool\n+    is_constant() const;\n+\n+    // Return true if this clause may fall through to execute the\n+    // statements following the switch statement.  This is not the\n+    // same as whether this clause falls through to the next clause.\n+    bool\n+    may_fall_through() const;\n+\n+    // Build up the body of a SWITCH_EXPR when the case expressions\n+    // are constant.\n+    void\n+    get_constant_tree(Translate_context*, Unnamed_label* break_label,\n+\t\t      Case_constants* case_constants, tree* stmt_list) const;\n+\n+   private:\n+    // The list of case expressions.\n+    Expression_list* cases_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // Whether this falls through after the statements.\n+    bool is_fallthrough_;\n+    // The location of this case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Case_clause;\n+\n+  // The type of the list of clauses.\n+  typedef std::vector<Case_clause> Clauses;\n+\n+  // All the case clauses.\n+  Clauses clauses_;\n+};\n+\n+// A switch statement.\n+\n+class Switch_statement : public Statement\n+{\n+ public:\n+  Switch_statement(Expression* val, source_location location)\n+    : Statement(STATEMENT_SWITCH, location),\n+      val_(val), clauses_(NULL), break_label_(NULL)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Case_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // The value to switch on.  This may be NULL.\n+  Expression* val_;\n+  // The case clauses.\n+  Case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+// Class Type_case_clauses holds the clauses of a type switch\n+// statement.  This is built by the parser.\n+\n+class Type_case_clauses\n+{\n+ public:\n+  Type_case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  TYPE is the type for this clause; it may be\n+  // NULL.  IS_FALLTHROUGH is true if this falls through to the next\n+  // clause; in this case STATEMENTS will be NULL.  IS_DEFAULT is true\n+  // if this is the default case.  STATEMENTS is a block of\n+  // statements; it may be NULL.\n+  void\n+  add(Type* type, bool is_fallthrough, bool is_default, Block* statements,\n+      source_location location)\n+  {\n+    this->clauses_.push_back(Type_case_clause(type, is_fallthrough, is_default,\n+\t\t\t\t\t      statements, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the type case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Check for duplicates.\n+  void\n+  check_duplicates() const;\n+\n+  // Lower to if and goto statements.\n+  void\n+  lower(Block*, Temporary_statement* descriptor_temp,\n+\tUnnamed_label* break_label) const;\n+\n+ private:\n+  // One type case clause.\n+  class Type_case_clause\n+  {\n+   public:\n+    Type_case_clause()\n+      : type_(NULL), statements_(NULL), is_default_(false),\n+\tlocation_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Type_case_clause(Type* type, bool is_fallthrough, bool is_default,\n+\t\t     Block* statements, source_location location)\n+      : type_(type), statements_(statements), is_fallthrough_(is_fallthrough),\n+\tis_default_(is_default), location_(location)\n+    { }\n+\n+    // The type.\n+    Type*\n+    type() const\n+    { return this->type_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this type clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower to if and goto statements.\n+    void\n+    lower(Block*, Temporary_statement* descriptor_temp,\n+\t  Unnamed_label* break_label, Unnamed_label** stmts_label) const;\n+\n+   private:\n+    // The type for this type clause.\n+    Type* type_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this falls through--this is true for \"case T1, T2\".\n+    bool is_fallthrough_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // The location of this type case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Type_case_clause;\n+\n+  // The type of the list of type clauses.\n+  typedef std::vector<Type_case_clause> Type_clauses;\n+\n+  // All the type case clauses.\n+  Type_clauses clauses_;\n+};\n+\n+// A type switch statement.\n+\n+class Type_switch_statement : public Statement\n+{\n+ public:\n+  Type_switch_statement(Named_object* var, Expression* expr,\n+\t\t\tsource_location location)\n+    : Statement(STATEMENT_TYPE_SWITCH, location),\n+      var_(var), expr_(expr), clauses_(NULL), break_label_(NULL)\n+  { gcc_assert(var == NULL || expr == NULL); }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Type_case_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this type switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // Get the type descriptor.\n+  tree\n+  get_type_descriptor(Translate_context*, Type*, tree);\n+\n+  // The variable holding the value we are switching on.\n+  Named_object* var_;\n+  // The expression we are switching on if there is no variable.\n+  Expression* expr_;\n+  // The type case clauses.\n+  Type_case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+#endif // !defined(GO_STATEMENTS_H)"}, {"sha": "b030a420fe04ca8ae6d2f348fcfe6f9d14786418", "filename": "gcc/go/gofrontend/types.cc", "status": "added", "additions": 8078, "deletions": 0, "changes": 8078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "025f85f401b169ac427c525bfa971eefce58912c", "filename": "gcc/go/gofrontend/types.h", "status": "added", "additions": 2730, "deletions": 0, "changes": 2730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,2730 @@\n+// types.h -- Go frontend types.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_TYPES_H\n+#define GO_TYPES_H\n+\n+class Gogo;\n+class Package;\n+class Traverse;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Integer_type;\n+class Float_type;\n+class Complex_type;\n+class String_type;\n+class Function_type;\n+class Struct_field;\n+class Struct_field_list;\n+class Struct_type;\n+class Pointer_type;\n+class Array_type;\n+class Map_type;\n+class Channel_type;\n+class Interface_type;\n+class Named_type;\n+class Forward_declaration_type;\n+class Method;\n+class Methods;\n+class Type_hash_identical;\n+class Type_identical;\n+class Expression;\n+class Expression_list;\n+class Call_expression;\n+class Field_reference_expression;\n+class Bound_method_expression;\n+class Bindings;\n+class Named_object;\n+class Function;\n+class Translate_context;\n+class Export;\n+class Import;\n+\n+// Type codes used in type descriptors.  These must match the values\n+// in libgo/runtime/go-type.h.  They also match the values in the gc\n+// compiler in src/cmd/gc/reflect.c and src/pkg/runtime/type.go,\n+// although this is not required.\n+\n+static const int RUNTIME_TYPE_KIND_BOOL = 1;\n+static const int RUNTIME_TYPE_KIND_INT = 2;\n+static const int RUNTIME_TYPE_KIND_INT8 = 3;\n+static const int RUNTIME_TYPE_KIND_INT16 = 4;\n+static const int RUNTIME_TYPE_KIND_INT32 = 5;\n+static const int RUNTIME_TYPE_KIND_INT64 = 6;\n+static const int RUNTIME_TYPE_KIND_UINT = 7;\n+static const int RUNTIME_TYPE_KIND_UINT8 = 8;\n+static const int RUNTIME_TYPE_KIND_UINT16 = 9;\n+static const int RUNTIME_TYPE_KIND_UINT32 = 10;\n+static const int RUNTIME_TYPE_KIND_UINT64 = 11;\n+static const int RUNTIME_TYPE_KIND_UINTPTR = 12;\n+static const int RUNTIME_TYPE_KIND_FLOAT = 13;\n+static const int RUNTIME_TYPE_KIND_FLOAT32 = 14;\n+static const int RUNTIME_TYPE_KIND_FLOAT64 = 15;\n+static const int RUNTIME_TYPE_KIND_COMPLEX = 16;\n+static const int RUNTIME_TYPE_KIND_COMPLEX64 = 17;\n+static const int RUNTIME_TYPE_KIND_COMPLEX128 = 18;\n+static const int RUNTIME_TYPE_KIND_ARRAY = 19;\n+static const int RUNTIME_TYPE_KIND_CHAN = 20;\n+static const int RUNTIME_TYPE_KIND_FUNC = 21;\n+static const int RUNTIME_TYPE_KIND_INTERFACE = 22;\n+static const int RUNTIME_TYPE_KIND_MAP = 23;\n+static const int RUNTIME_TYPE_KIND_PTR = 24;\n+static const int RUNTIME_TYPE_KIND_SLICE = 25;\n+static const int RUNTIME_TYPE_KIND_STRING = 26;\n+static const int RUNTIME_TYPE_KIND_STRUCT = 27;\n+static const int RUNTIME_TYPE_KIND_UNSAFE_POINTER = 28;\n+\n+// To build the complete list of methods for a named type we need to\n+// gather all methods from anonymous fields.  Those methods may\n+// require an arbitrary set of indirections and field offsets.  There\n+// is also the possibility of ambiguous methods, which we could ignore\n+// except that we want to give a better error message for that case.\n+// This is a base class.  There are two types of methods: named\n+// methods, and methods which are inherited from an anonymous field of\n+// interface type.\n+\n+class Method\n+{\n+ public:\n+  // For methods in anonymous types we need to know the sequence of\n+  // field references used to extract the pointer to pass to the\n+  // method.  Since each method for a particular anonymous field will\n+  // have the sequence of field indexes, and since the indexes can be\n+  // shared going down the chain, we use a manually managed linked\n+  // list.  The first entry in the list is the field index for the\n+  // last field, the one passed to the method.\n+\n+  struct Field_indexes\n+  {\n+    const Field_indexes* next;\n+    unsigned int field_index;\n+  };\n+\n+  virtual ~Method()\n+  { }\n+\n+  // Get the list of field indexes.\n+  const Field_indexes*\n+  field_indexes() const\n+  { return this->field_indexes_; }\n+\n+  // Get the depth.\n+  unsigned int\n+  depth() const\n+  { return this->depth_; }\n+\n+  // Return whether this is a value method--a method which does not\n+  // require a pointer expression.\n+  bool\n+  is_value_method() const\n+  { return this->is_value_method_; }\n+\n+  // Return whether we need a stub method--this is true if we can't\n+  // just pass the main object to the method.\n+  bool\n+  needs_stub_method() const\n+  { return this->needs_stub_method_; }\n+\n+  // Return whether this is an ambiguous method name.\n+  bool\n+  is_ambiguous() const\n+  { return this->is_ambiguous_; }\n+\n+  // Note that this method is ambiguous.\n+  void\n+  set_is_ambiguous()\n+  { this->is_ambiguous_ = true; }\n+\n+  // Return the type of the method.\n+  Function_type*\n+  type() const\n+  { return this->do_type(); }\n+\n+  // Return the location of the method receiver.\n+  source_location\n+  receiver_location() const\n+  { return this->do_receiver_location(); }\n+\n+  // Return an expression which binds this method to EXPR.  This is\n+  // something which can be used with a function call.\n+  Expression*\n+  bind_method(Expression* expr, source_location location) const;\n+\n+  // Return the named object for this method.  This may only be called\n+  // after methods are finalized.\n+  Named_object*\n+  named_object() const;\n+\n+  // Get the stub object.\n+  Named_object*\n+  stub_object() const\n+  {\n+    gcc_assert(this->stub_ != NULL);\n+    return this->stub_;\n+  }\n+\n+  // Set the stub object.\n+  void\n+  set_stub_object(Named_object* no)\n+  {\n+    gcc_assert(this->stub_ == NULL);\n+    this->stub_ = no;\n+  }\n+\n+ protected:\n+  // These objects are only built by the child classes.\n+  Method(const Field_indexes* field_indexes, unsigned int depth,\n+\t bool is_value_method, bool needs_stub_method)\n+    : field_indexes_(field_indexes), depth_(depth), stub_(NULL),\n+      is_value_method_(is_value_method), needs_stub_method_(needs_stub_method),\n+      is_ambiguous_(false)\n+  { }\n+\n+  // The named object for this method.\n+  virtual Named_object*\n+  do_named_object() const = 0;\n+\n+  // The type of the method.\n+  virtual Function_type*\n+  do_type() const = 0;\n+\n+  // Return the location of the method receiver.\n+  virtual source_location\n+  do_receiver_location() const = 0;\n+\n+  // Bind a method to an object.\n+  virtual Expression*\n+  do_bind_method(Expression* expr, source_location location) const = 0;\n+\n+ private:\n+  // The sequence of field indexes used for this method.  If this is\n+  // NULL, then the method is defined for the current type.\n+  const Field_indexes* field_indexes_;\n+  // The depth at which this method was found.\n+  unsigned int depth_;\n+  // If a stub method is required, this is its object.  This is only\n+  // set after stub methods are built in finalize_methods.\n+  Named_object* stub_;\n+  // Whether this is a value method--a method that does not require a\n+  // pointer.\n+  bool is_value_method_;\n+  // Whether a stub method is required.\n+  bool needs_stub_method_;\n+  // Whether this method is ambiguous.\n+  bool is_ambiguous_;\n+};\n+\n+// A named method.  This is what you get with a method declaration,\n+// either directly on the type, or inherited from some anonymous\n+// embedded field.\n+\n+class Named_method : public Method\n+{\n+ public:\n+  Named_method(Named_object* named_object, const Field_indexes* field_indexes,\n+\t       unsigned int depth, bool is_value_method,\n+\t       bool needs_stub_method)\n+    : Method(field_indexes, depth, is_value_method, needs_stub_method),\n+      named_object_(named_object)\n+  { }\n+\n+ protected:\n+  // Get the Named_object for the method.\n+  Named_object*\n+  do_named_object() const\n+  { return this->named_object_; }\n+\n+  // The type of the method.\n+  Function_type*\n+  do_type() const;\n+\n+  // Return the location of the method receiver.\n+  source_location\n+  do_receiver_location() const;\n+\n+  // Bind a method to an object.\n+  Expression*\n+  do_bind_method(Expression* expr, source_location location) const;\n+\n+ private:\n+  // The method itself.  For a method which needs a stub, this starts\n+  // out as the underlying method, and is later replaced with the stub\n+  // method.\n+  Named_object* named_object_;\n+};\n+\n+// An interface method.  This is used when an interface appears as an\n+// anonymous field in a named struct.\n+\n+class Interface_method : public Method\n+{\n+ public:\n+  Interface_method(const std::string& name, source_location location,\n+\t\t   Function_type* fntype, const Field_indexes* field_indexes,\n+\t\t   unsigned int depth)\n+    : Method(field_indexes, depth, true, true),\n+      name_(name), location_(location), fntype_(fntype)\n+  { }\n+\n+ protected:\n+  // Get the Named_object for the method.  This should never be\n+  // called, as we always create a stub.\n+  Named_object*\n+  do_named_object() const\n+  { gcc_unreachable(); }\n+\n+  // The type of the method.\n+  Function_type*\n+  do_type() const\n+  { return this->fntype_; }\n+\n+  // Return the location of the method receiver.\n+  source_location\n+  do_receiver_location() const\n+  { return this->location_; }\n+\n+  // Bind a method to an object.\n+  Expression*\n+  do_bind_method(Expression* expr, source_location location) const;\n+\n+ private:\n+  // The name of the interface method to call.\n+  std::string name_;\n+  // The location of the definition of the interface method.\n+  source_location location_;\n+  // The type of the interface method.\n+  Function_type* fntype_;\n+};\n+\n+// A mapping from method name to Method.  This is a wrapper around a\n+// hash table.\n+\n+class Methods\n+{\n+ private:\n+  typedef Unordered_map(std::string, Method*) Method_map;\n+\n+ public:\n+  typedef Method_map::const_iterator const_iterator;\n+\n+  Methods()\n+    : methods_()\n+  { }\n+\n+  // Insert a new method.  Returns true if it was inserted, false if\n+  // it was overidden or ambiguous.\n+  bool\n+  insert(const std::string& name, Method* m);\n+\n+  // The number of (unambiguous) methods.\n+  size_t\n+  count() const;\n+\n+  // Iterate.\n+  const_iterator\n+  begin() const\n+  { return this->methods_.begin(); }\n+\n+  const_iterator\n+  end() const\n+  { return this->methods_.end(); }\n+\n+  // Lookup.\n+  const_iterator\n+  find(const std::string& name) const\n+  { return this->methods_.find(name); }\n+\n+ private:\n+  Method_map methods_;\n+};\n+\n+// The base class for all types.\n+\n+class Type\n+{\n+ public:\n+  // The types of types.\n+  enum Type_classification\n+  {\n+    TYPE_ERROR,\n+    TYPE_VOID,\n+    TYPE_BOOLEAN,\n+    TYPE_INTEGER,\n+    TYPE_FLOAT,\n+    TYPE_COMPLEX,\n+    TYPE_STRING,\n+    TYPE_SINK,\n+    TYPE_FUNCTION,\n+    TYPE_POINTER,\n+    TYPE_NIL,\n+    TYPE_CALL_MULTIPLE_RESULT,\n+    TYPE_STRUCT,\n+    TYPE_ARRAY,\n+    TYPE_MAP,\n+    TYPE_CHANNEL,\n+    TYPE_INTERFACE,\n+    TYPE_NAMED,\n+    TYPE_FORWARD\n+  };\n+\n+  virtual ~Type();\n+\n+  // Creators.\n+\n+  static Type*\n+  make_error_type();\n+\n+  static Type*\n+  make_void_type();\n+\n+  // Get the unnamed bool type.\n+  static Type*\n+  make_boolean_type();\n+\n+  // Get the named type \"bool\".\n+  static Named_type*\n+  lookup_bool_type();\n+\n+  // Make the named type \"bool\".\n+  static Named_type*\n+  make_named_bool_type();\n+\n+  // Make an abstract integer type.\n+  static Integer_type*\n+  make_abstract_integer_type();\n+\n+  // Make a named integer type with a specified size.\n+  // RUNTIME_TYPE_KIND is the code to use in reflection information,\n+  // to distinguish int and int32.\n+  static Named_type*\n+  make_integer_type(const char* name, bool is_unsigned, int bits,\n+\t\t    int runtime_type_kind);\n+\n+  // Look up a named integer type.\n+  static Named_type*\n+  lookup_integer_type(const char* name);\n+\n+  // Make an abstract floating point type.\n+  static Float_type*\n+  make_abstract_float_type();\n+\n+  // Make a named floating point type with a specific size.\n+  // RUNTIME_TYPE_KIND is the code to use in reflection information,\n+  // to distinguish float and float32.\n+  static Named_type*\n+  make_float_type(const char* name, int bits, int runtime_type_kind);\n+\n+  // Look up a named float type.\n+  static Named_type*\n+  lookup_float_type(const char* name);\n+\n+  // Make an abstract complex type.\n+  static Complex_type*\n+  make_abstract_complex_type();\n+\n+  // Make a named complex type with a specific size.\n+  // RUNTIME_TYPE_KIND is the code to use in reflection information,\n+  // to distinguish complex and complex64.\n+  static Named_type*\n+  make_complex_type(const char* name, int bits, int runtime_type_kind);\n+\n+  // Look up a named complex type.\n+  static Named_type*\n+  lookup_complex_type(const char* name);\n+\n+  // Get the unnamed string type.\n+  static Type*\n+  make_string_type();\n+\n+  // Get the named type \"string\".\n+  static Named_type*\n+  lookup_string_type();\n+\n+  // Make the named type \"string\".\n+  static Named_type*\n+  make_named_string_type();\n+\n+  static Type*\n+  make_sink_type();\n+\n+  static Function_type*\n+  make_function_type(Typed_identifier* receiver,\n+\t\t     Typed_identifier_list* parameters,\n+\t\t     Typed_identifier_list* results,\n+\t\t     source_location);\n+\n+  static Pointer_type*\n+  make_pointer_type(Type*);\n+\n+  static Type*\n+  make_nil_type();\n+\n+  static Type*\n+  make_call_multiple_result_type(Call_expression*);\n+\n+  static Struct_type*\n+  make_struct_type(Struct_field_list* fields, source_location);\n+\n+  static Array_type*\n+  make_array_type(Type* element_type, Expression* length);\n+\n+  static Map_type*\n+  make_map_type(Type* key_type, Type* value_type, source_location);\n+\n+  static Channel_type*\n+  make_channel_type(bool send, bool receive, Type*);\n+\n+  static Interface_type*\n+  make_interface_type(Typed_identifier_list* methods, source_location);\n+\n+  static Type*\n+  make_type_descriptor_type();\n+\n+  static Type*\n+  make_type_descriptor_ptr_type();\n+\n+  static Named_type*\n+  make_named_type(Named_object*, Type*, source_location);\n+\n+  static Type*\n+  make_forward_declaration(Named_object*);\n+\n+  // Traverse a type.\n+  static int\n+  traverse(Type*, Traverse*);\n+\n+  // Verify the type.  This is called after parsing, and verifies that\n+  // types are complete and meet the language requirements.  This\n+  // returns false if the type is invalid.\n+  bool\n+  verify()\n+  { return this->do_verify(); }\n+\n+  // Return true if two types are identical.  If this returns false,\n+  // and REASON is not NULL, it may set *REASON.\n+  static bool\n+  are_identical(const Type* lhs, const Type* rhs, std::string* reason);\n+\n+  // Return true if two types are compatible for use in a binary\n+  // operation, other than a shift, comparison, or channel send.  This\n+  // is an equivalence relation.\n+  static bool\n+  are_compatible_for_binop(const Type* t1, const Type* t2);\n+\n+  // Return true if a value with type RHS is assignable to a variable\n+  // with type LHS.  This is not an equivalence relation.  If this\n+  // returns false, and REASON is not NULL, it sets *REASON.\n+  static bool\n+  are_assignable(const Type* lhs, const Type* rhs, std::string* reason);\n+\n+  // Return true if a value with type RHS may be converted to type\n+  // LHS.  If this returns false, and REASON is not NULL, it sets\n+  // *REASON.\n+  static bool\n+  are_convertible(const Type* lhs, const Type* rhs, std::string* reason);\n+\n+  // Whether this type has any hidden fields which are not visible in\n+  // the current compilation, such as a field whose name begins with a\n+  // lower case letter in a struct imported from a different package.\n+  // WITHIN is not NULL if we are looking at fields in a named type.\n+  bool\n+  has_hidden_fields(const Named_type* within, std::string* reason) const;\n+\n+  // Return a hash code for this type for the method hash table.\n+  // Types which are equivalent according to are_identical will have\n+  // the same hash code.\n+  unsigned int\n+  hash_for_method(Gogo*) const;\n+\n+  // Return the type classification.\n+  Type_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Return the base type for this type.  This looks through forward\n+  // declarations and names.  Using this with a forward declaration\n+  // which has not been defined will return an error type.\n+  Type*\n+  base();\n+\n+  const Type*\n+  base() const;\n+\n+  // Return the type skipping defined forward declarations.  If this\n+  // type is a forward declaration which has not been defined, it will\n+  // return the Forward_declaration_type.  This differs from base() in\n+  // that it will return a Named_type, and for a\n+  // Forward_declaration_type which is not defined it will return that\n+  // type rather than an error type.\n+  Type*\n+  forwarded();\n+\n+  const Type*\n+  forwarded() const;\n+\n+  // Return true if this is a basic type: a type which is not composed\n+  // of other types, and is not void.\n+  bool\n+  is_basic_type() const;\n+\n+  // Return true if this is an abstract type--an integer, floating\n+  // point, or complex type whose size has not been determined.\n+  bool\n+  is_abstract() const;\n+\n+  // Return a non-abstract version of an abstract type.\n+  Type*\n+  make_non_abstract_type();\n+\n+  // Return true if this type is or contains a pointer.  This\n+  // determines whether the garbage collector needs to look at a value\n+  // of this type.\n+  bool\n+  has_pointer() const\n+  { return this->do_has_pointer(); }\n+\n+  // Return true if this is an error type.  An error type indicates a\n+  // parsing error.\n+  bool\n+  is_error_type() const;\n+\n+  // Return true if this is a void type.\n+  bool\n+  is_void_type() const\n+  { return this->classification_ == TYPE_VOID; }\n+\n+  // If this is an integer type, return the Integer_type.  Otherwise,\n+  // return NULL.  This is a controlled dynamic_cast.\n+  Integer_type*\n+  integer_type()\n+  { return this->convert<Integer_type, TYPE_INTEGER>(); }\n+\n+  const Integer_type*\n+  integer_type() const\n+  { return this->convert<const Integer_type, TYPE_INTEGER>(); }\n+\n+  // If this is a floating point type, return the Float_type.\n+  // Otherwise, return NULL.  This is a controlled dynamic_cast.\n+  Float_type*\n+  float_type()\n+  { return this->convert<Float_type, TYPE_FLOAT>(); }\n+\n+  const Float_type*\n+  float_type() const\n+  { return this->convert<const Float_type, TYPE_FLOAT>(); }\n+\n+  // If this is a complex type, return the Complex_type.  Otherwise,\n+  // return NULL.\n+  Complex_type*\n+  complex_type()\n+  { return this->convert<Complex_type, TYPE_COMPLEX>(); }\n+\n+  const Complex_type*\n+  complex_type() const\n+  { return this->convert<const Complex_type, TYPE_COMPLEX>(); }\n+\n+  // Return true if this is a boolean type.\n+  bool\n+  is_boolean_type() const\n+  { return this->base()->classification_ == TYPE_BOOLEAN; }\n+\n+  // Return true if this is an abstract boolean type.\n+  bool\n+  is_abstract_boolean_type() const\n+  { return this->classification_ == TYPE_BOOLEAN; }\n+\n+  // Return true if this is a string type.\n+  bool\n+  is_string_type() const\n+  { return this->base()->classification_ == TYPE_STRING; }\n+\n+  // Return true if this is an abstract string type.\n+  bool\n+  is_abstract_string_type() const\n+  { return this->classification_ == TYPE_STRING; }\n+\n+  // Return true if this is the sink type.  This is the type of the\n+  // blank identifier _.\n+  bool\n+  is_sink_type() const\n+  { return this->base()->classification_ == TYPE_SINK; }\n+\n+  // If this is a function type, return it.  Otherwise, return NULL.\n+  Function_type*\n+  function_type()\n+  { return this->convert<Function_type, TYPE_FUNCTION>(); }\n+\n+  const Function_type*\n+  function_type() const\n+  { return this->convert<const Function_type, TYPE_FUNCTION>(); }\n+\n+  // If this is a pointer type, return the type to which it points.\n+  // Otherwise, return NULL.\n+  Type*\n+  points_to() const;\n+\n+  // If this is a pointer type, return the type to which it points.\n+  // Otherwise, return the type itself.\n+  Type*\n+  deref()\n+  {\n+    Type* pt = this->points_to();\n+    return pt != NULL ? pt : this;\n+  }\n+\n+  const Type*\n+  deref() const\n+  {\n+    const Type* pt = this->points_to();\n+    return pt != NULL ? pt : this;\n+  }\n+\n+  // Return true if this is the nil type.  We don't use base() here,\n+  // because this can be called during parse, and there is no way to\n+  // name the nil type anyhow.\n+  bool\n+  is_nil_type() const\n+  { return this->classification_ == TYPE_NIL; }\n+\n+  // Return true if this is the predeclared constant nil being used as\n+  // a type.  This is what the parser produces for type switches which\n+  // use \"case nil\".\n+  bool\n+  is_nil_constant_as_type() const;\n+\n+  // Return true if this is the return type of a function which\n+  // returns multiple values.\n+  bool\n+  is_call_multiple_result_type() const\n+  { return this->base()->classification_ == TYPE_CALL_MULTIPLE_RESULT; }\n+\n+  // If this is a struct type, return it.  Otherwise, return NULL.\n+  Struct_type*\n+  struct_type()\n+  { return this->convert<Struct_type, TYPE_STRUCT>(); }\n+\n+  const Struct_type*\n+  struct_type() const\n+  { return this->convert<const Struct_type, TYPE_STRUCT>(); }\n+\n+  // If this is an array type, return it.  Otherwise, return NULL.\n+  Array_type*\n+  array_type()\n+  { return this->convert<Array_type, TYPE_ARRAY>(); }\n+\n+  const Array_type*\n+  array_type() const\n+  { return this->convert<const Array_type, TYPE_ARRAY>(); }\n+\n+  // Return whether if this is an open array type.\n+  bool\n+  is_open_array_type() const;\n+\n+  // If this is a map type, return it.  Otherwise, return NULL.\n+  Map_type*\n+  map_type()\n+  { return this->convert<Map_type, TYPE_MAP>(); }\n+\n+  const Map_type*\n+  map_type() const\n+  { return this->convert<const Map_type, TYPE_MAP>(); }\n+\n+  // If this is a channel type, return it.  Otherwise, return NULL.\n+  Channel_type*\n+  channel_type()\n+  { return this->convert<Channel_type, TYPE_CHANNEL>(); }\n+\n+  const Channel_type*\n+  channel_type() const\n+  { return this->convert<const Channel_type, TYPE_CHANNEL>(); }\n+\n+  // If this is an interface type, return it.  Otherwise, return NULL.\n+  Interface_type*\n+  interface_type()\n+  { return this->convert<Interface_type, TYPE_INTERFACE>(); }\n+\n+  const Interface_type*\n+  interface_type() const\n+  { return this->convert<const Interface_type, TYPE_INTERFACE>(); }\n+\n+  // If this is a named type, return it.  Otherwise, return NULL.\n+  Named_type*\n+  named_type();\n+\n+  const Named_type*\n+  named_type() const;\n+\n+  // If this is a forward declaration, return it.  Otherwise, return\n+  // NULL.\n+  Forward_declaration_type*\n+  forward_declaration_type()\n+  { return this->convert_no_base<Forward_declaration_type, TYPE_FORWARD>(); }\n+\n+  const Forward_declaration_type*\n+  forward_declaration_type() const\n+  {\n+    return this->convert_no_base<const Forward_declaration_type,\n+\t\t\t\t TYPE_FORWARD>();\n+  }\n+\n+  // Return true if this type is not yet defined.\n+  bool\n+  is_undefined() const;\n+\n+  // Return true if this is the unsafe.pointer type.  We currently\n+  // represent that as pointer-to-void.\n+  bool\n+  is_unsafe_pointer_type() const\n+  { return this->points_to() != NULL && this->points_to()->is_void_type(); }\n+\n+  // Look for field or method NAME for TYPE.  Return an expression for\n+  // it, bound to EXPR.\n+  static Expression*\n+  bind_field_or_method(Gogo*, const Type* type, Expression* expr,\n+\t\t       const std::string& name, source_location);\n+\n+  // Return true if NAME is an unexported field or method of TYPE.\n+  static bool\n+  is_unexported_field_or_method(Gogo*, const Type*, const std::string&);\n+\n+  // This type was passed to the builtin function make.  ARGS are the\n+  // arguments passed to make after the type; this may be NULL if\n+  // there were none.  Issue any required errors.\n+  bool\n+  check_make_expression(Expression_list* args, source_location location)\n+  { return this->do_check_make_expression(args, location); }\n+\n+  // Return a tree representing this type.\n+  tree\n+  get_tree(Gogo*);\n+\n+  // Return a tree representing a zero initialization for this type.\n+  // This will be something like an INTEGER_CST or a CONSTRUCTOR.  If\n+  // IS_CLEAR is true, then the memory is known to be zeroed; in that\n+  // case, this will return NULL if there is nothing to be done.\n+  tree\n+  get_init_tree(Gogo*, bool is_clear);\n+\n+  // Like get_init_tree, but passing in the type to use for the\n+  // initializer.\n+  tree\n+  get_typed_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n+  { return this->do_get_init_tree(gogo, type_tree, is_clear); }\n+\n+  // Return a tree for a make expression applied to this type.\n+  tree\n+  make_expression_tree(Translate_context* context, Expression_list* args,\n+\t\t       source_location location)\n+  { return this->do_make_expression_tree(context, args, location); }\n+\n+  // Build a type descriptor entry for this type.  Return a pointer to\n+  // it.\n+  tree\n+  type_descriptor_pointer(Gogo* gogo);\n+\n+  // Return the type reflection string for this type.\n+  std::string\n+  reflection(Gogo*) const;\n+\n+  // Return a mangled name for the type.  This is a name which can be\n+  // used in assembler code.  Identical types should have the same\n+  // manged name.\n+  std::string\n+  mangled_name(Gogo*) const;\n+\n+  // Export the type.\n+  void\n+  export_type(Export* exp) const\n+  { this->do_export(exp); }\n+\n+  // Import a type.\n+  static Type*\n+  import_type(Import*);\n+\n+ protected:\n+  Type(Type_classification);\n+\n+  // Functions implemented by the child class.\n+\n+  // Traverse the subtypes.\n+  virtual int\n+  do_traverse(Traverse*);\n+\n+  // Verify the type.\n+  virtual bool\n+  do_verify()\n+  { return true; }\n+\n+  virtual bool\n+  do_has_pointer() const\n+  { return false; }\n+\n+  virtual unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  virtual bool\n+  do_check_make_expression(Expression_list* args, source_location);\n+\n+\n+  virtual tree\n+  do_get_tree(Gogo*) = 0;\n+\n+  virtual tree\n+  do_get_init_tree(Gogo*, tree, bool) = 0;\n+\n+  virtual tree\n+  do_make_expression_tree(Translate_context*, Expression_list*,\n+\t\t\t  source_location);\n+\n+  virtual Expression*\n+  do_type_descriptor(Gogo*, Named_type* name) = 0;\n+\n+  virtual void\n+  do_reflection(Gogo*, std::string*) const = 0;\n+\n+\n+  virtual void\n+  do_mangled_name(Gogo*, std::string*) const = 0;\n+\n+  virtual void\n+  do_export(Export*) const;\n+\n+  // Return whether an expression is an integer.\n+  static bool\n+  check_int_value(Expression*, const char*, source_location);\n+\n+  // Return whether a method expects a pointer as the receiver.\n+  static bool\n+  method_expects_pointer(const Named_object*);\n+\n+  // Finalize the methods for a type.\n+  static void\n+  finalize_methods(Gogo*, const Type*, source_location, Methods**);\n+\n+  // Return a method from a set of methods.\n+  static Method*\n+  method_function(const Methods*, const std::string& name,\n+\t\t  bool* is_ambiguous);\n+\n+  // Return a composite literal for the type descriptor entry for a\n+  // type.\n+  static Expression*\n+  type_descriptor(Gogo*, Type*);\n+\n+  // Return a composite literal for the type descriptor entry for\n+  // TYPE, using NAME as the name of the type.\n+  static Expression*\n+  named_type_descriptor(Gogo*, Type* type, Named_type* name);\n+\n+  // Return a composite literal for a plain type descriptor for this\n+  // type with the given kind and name.\n+  Expression*\n+  plain_type_descriptor(Gogo*, int runtime_type_kind, Named_type* name);\n+\n+  // Build a composite literal for the basic type descriptor.\n+  Expression*\n+  type_descriptor_constructor(Gogo*, int runtime_type_kind, Named_type*,\n+\t\t\t      const Methods*, bool only_value_methods);\n+\n+  // Make a builtin struct type from a list of fields.\n+  static Struct_type*\n+  make_builtin_struct_type(int nfields, ...);\n+\n+  // Make a builtin named type.\n+  static Named_type*\n+  make_builtin_named_type(const char* name, Type* type);\n+\n+  // For the benefit of child class reflection string generation.\n+  void\n+  append_reflection(const Type* type, Gogo* gogo, std::string* ret) const\n+  { type->do_reflection(gogo, ret); }\n+\n+  // For the benefit of child class mangling.\n+  void\n+  append_mangled_name(const Type* type, Gogo* gogo, std::string* ret) const\n+  { type->do_mangled_name(gogo, ret); }\n+\n+  // Incorporate a string into a hash code.\n+  static unsigned int\n+  hash_string(const std::string&, unsigned int);\n+\n+  // Return a tree for the underlying type of a named type.\n+  static tree\n+  get_named_type_tree(Gogo* gogo, Type* base_type)\n+  { return base_type->get_tree_without_hash(gogo); }\n+\n+ private:\n+  // Convert to the desired type classification, or return NULL.  This\n+  // is a controlled dynamic_cast.\n+  template<typename Type_class, Type_classification type_classification>\n+  Type_class*\n+  convert()\n+  {\n+    Type* base = this->base();\n+    return (base->classification_ == type_classification\n+\t    ? static_cast<Type_class*>(base)\n+\t    : NULL);\n+  }\n+\n+  template<typename Type_class, Type_classification type_classification>\n+  const Type_class*\n+  convert() const\n+  {\n+    const Type* base = this->base();\n+    return (base->classification_ == type_classification\n+\t    ? static_cast<Type_class*>(base)\n+\t    : NULL);\n+  }\n+\n+  template<typename Type_class, Type_classification type_classification>\n+  Type_class*\n+  convert_no_base()\n+  {\n+    return (this->classification_ == type_classification\n+\t    ? static_cast<Type_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  template<typename Type_class, Type_classification type_classification>\n+  const Type_class*\n+  convert_no_base() const\n+  {\n+    return (this->classification_ == type_classification\n+\t    ? static_cast<Type_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  // Get the hash and equality functions for a type.\n+  void\n+  type_functions(const char** hash_fn, const char** equal_fn) const;\n+\n+  // Build a composite literal for the uncommon type information.\n+  Expression*\n+  uncommon_type_constructor(Gogo*, Type* uncommon_type,\n+\t\t\t    Named_type*, const Methods*,\n+\t\t\t    bool only_value_methods) const;\n+\n+  // Build a composite literal for the methods.\n+  Expression*\n+  methods_constructor(Gogo*, Type* methods_type, const Methods*,\n+\t\t      bool only_value_methods) const;\n+\n+  // Build a composite literal for one method.\n+  Expression*\n+  method_constructor(Gogo*, Type* method_type, const std::string& name,\n+\t\t     const Method*) const;\n+\n+  static tree\n+  build_receive_return_type(tree type);\n+\n+  // A hash table we use to avoid infinite recursion.\n+  typedef Unordered_set_hash(const Named_type*, Type_hash_identical,\n+\t\t\t     Type_identical) Types_seen;\n+\n+  // Add all methods for TYPE to the list of methods for THIS.\n+  static void\n+  add_methods_for_type(const Type* type, const Method::Field_indexes*,\n+\t\t       unsigned int depth, bool, bool, Types_seen*,\n+\t\t       Methods**);\n+\n+  static void\n+  add_local_methods_for_type(const Named_type* type,\n+\t\t\t     const Method::Field_indexes*,\n+\t\t\t     unsigned int depth, bool, bool, Methods**);\n+\n+  static void\n+  add_embedded_methods_for_type(const Type* type,\n+\t\t\t\tconst Method::Field_indexes*,\n+\t\t\t\tunsigned int depth, bool, bool, Types_seen*,\n+\t\t\t\tMethods**);\n+\n+  static void\n+  add_interface_methods_for_type(const Type* type,\n+\t\t\t\t const Method::Field_indexes*,\n+\t\t\t\t unsigned int depth, Methods**);\n+\n+  // Build stub methods for a type.\n+  static void\n+  build_stub_methods(Gogo*, const Type* type, const Methods* methods,\n+\t\t     source_location);\n+\n+  static void\n+  build_one_stub_method(Gogo*, Method*, const char* receiver_name,\n+\t\t\tconst Typed_identifier_list*, bool is_varargs,\n+\t\t\tsource_location);\n+\n+  static Expression*\n+  apply_field_indexes(Expression*, const Method::Field_indexes*,\n+\t\t      source_location);\n+\n+  // Look for a field or method named NAME in TYPE.\n+  static bool\n+  find_field_or_method(const Type* type, const std::string& name,\n+\t\t       bool receiver_can_be_pointer,\n+\t\t       int* level, bool* is_method,\n+\t\t       bool* found_pointer_method,\n+\t\t       std::string* ambig1, std::string* ambig2);\n+\n+  // Get a tree for a type without looking in the hash table for\n+  // identical types.\n+  tree\n+  get_tree_without_hash(Gogo*);\n+\n+  // A mapping from Type to tree, used to ensure that the GIMPLE\n+  // representation of identical types is identical.\n+  typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Type_trees;\n+\n+  static Type_trees type_trees;\n+\n+  // The type classification.\n+  Type_classification classification_;\n+  // The tree representation of the type, once it has been determined.\n+  tree tree_;\n+  // The decl for the type descriptor for this type.  This starts out\n+  // as NULL and is filled in as needed.\n+  tree type_descriptor_decl_;\n+};\n+\n+// Type hash table operations.\n+\n+class Type_hash_identical\n+{\n+ public:\n+  unsigned int\n+  operator()(const Type* type) const\n+  { return type->hash_for_method(NULL); }\n+};\n+\n+class Type_identical\n+{\n+ public:\n+  bool\n+  operator()(const Type* t1, const Type* t2) const\n+  { return Type::are_identical(t1, t2, NULL); }\n+};\n+\n+// An identifier with a type.\n+\n+class Typed_identifier\n+{\n+ public:\n+  Typed_identifier(const std::string& name, Type* type,\n+\t\t   source_location location)\n+    : name_(name), type_(type), location_(location)\n+  { }\n+\n+  // Get the name.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Get the type.\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Return the location where the name was seen.  This is not always\n+  // meaningful.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Set the type--sometimes we see the identifier before the type.\n+  void\n+  set_type(Type* type)\n+  {\n+    gcc_assert(this->type_ == NULL || type->is_error_type());\n+    this->type_ = type;\n+  }\n+\n+ private:\n+  // Identifier name.\n+  std::string name_;\n+  // Type.\n+  Type* type_;\n+  // The location where the name was seen.\n+  source_location location_;\n+};\n+\n+// A list of Typed_identifiers.\n+\n+class Typed_identifier_list\n+{\n+ public:\n+  Typed_identifier_list()\n+    : entries_()\n+  { }\n+\n+  // Whether the list is empty.\n+  bool\n+  empty() const\n+  { return this->entries_.empty(); }\n+\n+  // Return the number of entries in the list.\n+  size_t\n+  size() const\n+  { return this->entries_.size(); }\n+\n+  // Add an entry to the end of the list.\n+  void\n+  push_back(const Typed_identifier& td)\n+  { this->entries_.push_back(td); }\n+\n+  // Remove an entry from the end of the list.\n+  void\n+  pop_back()\n+  { this->entries_.pop_back(); }\n+\n+  // Set the type of entry I to TYPE.\n+  void\n+  set_type(size_t i, Type* type)\n+  {\n+    gcc_assert(i < this->entries_.size());\n+    this->entries_[i].set_type(type);\n+  }\n+\n+  // Sort the entries by name.\n+  void\n+  sort_by_name();\n+\n+  // Traverse types.\n+  int\n+  traverse(Traverse*);\n+\n+  // Return the first and last elements.\n+  Typed_identifier&\n+  front()\n+  { return this->entries_.front(); }\n+\n+  const Typed_identifier&\n+  front() const\n+  { return this->entries_.front(); }\n+\n+  Typed_identifier&\n+  back()\n+  { return this->entries_.back(); }\n+\n+  const Typed_identifier&\n+  back() const\n+  { return this->entries_.back(); }\n+\n+  const Typed_identifier&\n+  at(size_t i) const\n+  { return this->entries_.at(i); }\n+\n+  void\n+  set(size_t i, const Typed_identifier& t)\n+  { this->entries_.at(i) = t; }\n+\n+  void\n+  resize(size_t c)\n+  {\n+    gcc_assert(c <= this->entries_.size());\n+    this->entries_.resize(c, Typed_identifier(\"\", NULL, UNKNOWN_LOCATION));\n+  }\n+\n+  // Iterators.\n+\n+  typedef std::vector<Typed_identifier>::iterator iterator;\n+  typedef std::vector<Typed_identifier>::const_iterator const_iterator;\n+\n+  iterator\n+  begin()\n+  { return this->entries_.begin(); }\n+\n+  const_iterator\n+  begin() const\n+  { return this->entries_.begin(); }\n+\n+  iterator\n+  end()\n+  { return this->entries_.end(); }\n+\n+  const_iterator\n+  end() const\n+  { return this->entries_.end(); }\n+\n+  // Return a copy of this list.  This returns an independent copy of\n+  // the vector, but does not copy the types.\n+  Typed_identifier_list*\n+  copy() const;\n+\n+ private:\n+  std::vector<Typed_identifier> entries_;\n+};\n+\n+// The type of an integer.\n+\n+class Integer_type : public Type\n+{\n+ public:\n+  // Create a new integer type.\n+  static Named_type*\n+  create_integer_type(const char* name, bool is_unsigned, int bits,\n+\t\t      int runtime_type_kind);\n+\n+  // Look up an existing integer type.\n+  static Named_type*\n+  lookup_integer_type(const char* name);\n+\n+  // Create an abstract integer type.\n+  static Integer_type*\n+  create_abstract_integer_type();\n+\n+  // Whether this is an abstract integer type.\n+  bool\n+  is_abstract() const\n+  { return this->is_abstract_; }\n+\n+  // Whether this is an unsigned type.\n+  bool\n+  is_unsigned() const\n+  { return this->is_unsigned_; }\n+\n+  // The number of bits.\n+  int\n+  bits() const\n+  { return this->bits_; }\n+\n+  // Whether this type is the same as T.\n+  bool\n+  is_identical(const Integer_type* t) const;\n+\n+ protected:\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+ private:\n+  Integer_type(bool is_abstract, bool is_unsigned, int bits,\n+\t       int runtime_type_kind)\n+    : Type(TYPE_INTEGER),\n+      is_abstract_(is_abstract), is_unsigned_(is_unsigned), bits_(bits),\n+      runtime_type_kind_(runtime_type_kind)\n+  { }\n+\n+  // Map names of integer types to the types themselves.\n+  typedef std::map<std::string, Named_type*> Named_integer_types;\n+  static Named_integer_types named_integer_types;\n+\n+  // True if this is an abstract type.\n+  bool is_abstract_;\n+  // True if this is an unsigned type.\n+  bool is_unsigned_;\n+  // The number of bits.\n+  int bits_;\n+  // The runtime type code used in the type descriptor for this type.\n+  int runtime_type_kind_;\n+};\n+\n+// The type of a floating point number.\n+\n+class Float_type : public Type\n+{\n+ public:\n+  // Create a new float type.\n+  static Named_type*\n+  create_float_type(const char* name, int bits, int runtime_type_kind);\n+\n+  // Look up an existing float type.\n+  static Named_type*\n+  lookup_float_type(const char* name);\n+\n+  // Create an abstract float type.\n+  static Float_type*\n+  create_abstract_float_type();\n+\n+  // Whether this is an abstract float type.\n+  bool\n+  is_abstract() const\n+  { return this->is_abstract_; }\n+\n+  // The number of bits.\n+  int\n+  bits() const\n+  { return this->bits_; }\n+\n+  // Whether this type is the same as T.\n+  bool\n+  is_identical(const Float_type* t) const;\n+\n+  // Return a tree for this type without using a Gogo*.\n+  tree\n+  type_tree() const;\n+\n+ protected:\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+ private:\n+  Float_type(bool is_abstract, int bits, int runtime_type_kind)\n+    : Type(TYPE_FLOAT),\n+      is_abstract_(is_abstract), bits_(bits),\n+      runtime_type_kind_(runtime_type_kind)\n+  { }\n+\n+  // Map names of float types to the types themselves.\n+  typedef std::map<std::string, Named_type*> Named_float_types;\n+  static Named_float_types named_float_types;\n+\n+  // True if this is an abstract type.\n+  bool is_abstract_;\n+  // The number of bits in the floating point value.\n+  int bits_;\n+  // The runtime type code used in the type descriptor for this type.\n+  int runtime_type_kind_;\n+};\n+\n+// The type of a complex number.\n+\n+class Complex_type : public Type\n+{\n+ public:\n+  // Create a new complex type.\n+  static Named_type*\n+  create_complex_type(const char* name, int bits, int runtime_type_kind);\n+\n+  // Look up an existing complex type.\n+  static Named_type*\n+  lookup_complex_type(const char* name);\n+\n+  // Create an abstract complex type.\n+  static Complex_type*\n+  create_abstract_complex_type();\n+\n+  // Whether this is an abstract complex type.\n+  bool\n+  is_abstract() const\n+  { return this->is_abstract_; }\n+\n+  // The number of bits: 64 or 128.\n+  int bits() const\n+  { return this->bits_; }\n+\n+  // Whether this type is the same as T.\n+  bool\n+  is_identical(const Complex_type* t) const;\n+\n+  // Return a tree for this type without using a Gogo*.\n+  tree\n+  type_tree() const;\n+\n+ protected:\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+ private:\n+  Complex_type(bool is_abstract, int bits, int runtime_type_kind)\n+    : Type(TYPE_COMPLEX),\n+      is_abstract_(is_abstract), bits_(bits),\n+      runtime_type_kind_(runtime_type_kind)\n+  { }\n+\n+  // Map names of complex types to the types themselves.\n+  typedef std::map<std::string, Named_type*> Named_complex_types;\n+  static Named_complex_types named_complex_types;\n+\n+  // True if this is an abstract type.\n+  bool is_abstract_;\n+  // The number of bits in the complex value--64 or 128.\n+  int bits_;\n+  // The runtime type code used in the type descriptor for this type.\n+  int runtime_type_kind_;\n+};\n+\n+// The type of a string.\n+\n+class String_type : public Type\n+{\n+ public:\n+  String_type()\n+    : Type(TYPE_STRING)\n+  { }\n+\n+  // Return a tree for the length of STRING.\n+  static tree\n+  length_tree(Gogo*, tree string);\n+\n+  // Return a tree which points to the bytes of STRING.\n+  static tree\n+  bytes_tree(Gogo*, tree string);\n+\n+ protected:\n+  bool\n+  do_has_pointer() const\n+  { return true; }\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo* gogo, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string* ret) const;\n+\n+ private:\n+  // The named string type.\n+  static Named_type* string_type_;\n+};\n+\n+// The type of a function.\n+\n+class Function_type : public Type\n+{\n+ public:\n+  Function_type(Typed_identifier* receiver, Typed_identifier_list* parameters,\n+\t\tTyped_identifier_list* results, source_location location)\n+    : Type(TYPE_FUNCTION),\n+      receiver_(receiver), parameters_(parameters), results_(results),\n+      location_(location), is_varargs_(false), is_builtin_(false)\n+  { }\n+\n+  // Get the receiver.\n+  const Typed_identifier*\n+  receiver() const\n+  { return this->receiver_; }\n+\n+  // Get the return names and types.\n+  const Typed_identifier_list*\n+  results() const\n+  { return this->results_; }\n+\n+  // Get the parameter names and types.\n+  const Typed_identifier_list*\n+  parameters() const\n+  { return this->parameters_; }\n+\n+  // Whether this is a varargs function.\n+  bool\n+  is_varargs() const\n+  { return this->is_varargs_; }\n+\n+  // Whether this is a builtin function.\n+  bool\n+  is_builtin() const\n+  { return this->is_builtin_; }\n+\n+  // The location where this type was defined.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return whether this is a method type.\n+  bool\n+  is_method() const\n+  { return this->receiver_ != NULL; }\n+\n+  // Whether T is a valid redeclaration of this type.  This is called\n+  // when a function is declared more than once.\n+  bool\n+  is_valid_redeclaration(const Function_type* t, std::string*) const;\n+\n+  // Whether this type is the same as T.\n+  bool\n+  is_identical(const Function_type* t, bool ignore_receiver,\n+\t       std::string*) const;\n+\n+  // Record that this is a varargs function.\n+  void\n+  set_is_varargs()\n+  { this->is_varargs_ = true; }\n+\n+  // Record that this is a builtin function.\n+  void\n+  set_is_builtin()\n+  { this->is_builtin_ = true; }\n+\n+  // Import a function type.\n+  static Function_type*\n+  do_import(Import*);\n+\n+  // Return a copy of this type without a receiver.  This is only\n+  // valid for a method type.\n+  Function_type*\n+  copy_without_receiver() const;\n+\n+  // Return a copy of this type with a receiver.  This is used when an\n+  // interface method is attached to a named or struct type.\n+  Function_type*\n+  copy_with_receiver(Type*) const;\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  // A trampoline function has a pointer which matters for GC.\n+  bool\n+  do_has_pointer() const\n+  { return true; }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  static Type*\n+  make_function_type_descriptor_type();\n+\n+  Expression*\n+  type_descriptor_params(Type*, const Typed_identifier*,\n+\t\t\t const Typed_identifier_list*);\n+\n+  // The receiver name and type.  This will be NULL for a normal\n+  // function, non-NULL for a method.\n+  Typed_identifier* receiver_;\n+  // The parameter names and types.\n+  Typed_identifier_list* parameters_;\n+  // The result names and types.  This will be NULL if no result was\n+  // specified.\n+  Typed_identifier_list* results_;\n+  // The location where this type was defined.  This exists solely to\n+  // give a location for the fields of the struct if this function\n+  // returns multiple values.\n+  source_location location_;\n+  // Whether this function takes a variable number of arguments.\n+  bool is_varargs_;\n+  // Whether this is a special builtin function which can not simply\n+  // be called.  This is used for len, cap, etc.\n+  bool is_builtin_;\n+};\n+\n+// The type of a pointer.\n+\n+class Pointer_type : public Type\n+{\n+ public:\n+  Pointer_type(Type* to_type)\n+    : Type(TYPE_POINTER),\n+      to_type_(to_type)\n+  {}\n+\n+  Type*\n+  points_to() const\n+  { return this->to_type_; }\n+\n+  // Import a pointer type.\n+  static Pointer_type*\n+  do_import(Import*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_has_pointer() const\n+  { return true; }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  static Type*\n+  make_pointer_type_descriptor_type();\n+\n+  // The type to which this type points.\n+  Type* to_type_;\n+};\n+\n+// The type of a field in a struct.\n+\n+class Struct_field\n+{\n+ public:\n+  explicit Struct_field(const Typed_identifier& typed_identifier)\n+    : typed_identifier_(typed_identifier), tag_(NULL)\n+  { }\n+\n+  // The field name.\n+  const std::string&\n+  field_name() const;\n+\n+  // The field type.\n+  Type*\n+  type() const\n+  { return this->typed_identifier_.type(); }\n+\n+  // The field location.\n+  source_location\n+  location() const\n+  { return this->typed_identifier_.location(); }\n+\n+  // Whether the field has a tag.\n+  bool\n+  has_tag() const\n+  { return this->tag_ != NULL; }\n+\n+  // The tag.\n+  const std::string&\n+  tag() const\n+  {\n+    gcc_assert(this->tag_ != NULL);\n+    return *this->tag_;\n+  }\n+\n+  // Whether this is an anonymous field.\n+  bool\n+  is_anonymous() const\n+  { return this->typed_identifier_.name().empty(); }\n+\n+  // Set the tag.  FIXME: This is never freed.\n+  void\n+  set_tag(const std::string& tag)\n+  { this->tag_ = new std::string(tag); }\n+\n+  // Set the type.  This is only used in error cases.\n+  void\n+  set_type(Type* type)\n+  { this->typed_identifier_.set_type(type); }\n+\n+ private:\n+  // The field name, type, and location.\n+  Typed_identifier typed_identifier_;\n+  // The field tag.  This is NULL if the field has no tag.\n+  std::string* tag_;\n+};\n+\n+// A list of struct fields.\n+\n+class Struct_field_list\n+{\n+ public:\n+  Struct_field_list()\n+    : entries_()\n+  { }\n+\n+  // Whether the list is empty.\n+  bool\n+  empty() const\n+  { return this->entries_.empty(); }\n+\n+  // Return the number of entries.\n+  size_t\n+  size() const\n+  { return this->entries_.size(); }\n+\n+  // Add an entry to the end of the list.\n+  void\n+  push_back(const Struct_field& sf)\n+  { this->entries_.push_back(sf); }\n+\n+  // Index into the list.\n+  const Struct_field&\n+  at(size_t i) const\n+  { return this->entries_.at(i); }\n+\n+  // Last entry in list.\n+  Struct_field&\n+  back()\n+  { return this->entries_.back(); }\n+\n+  // Iterators.\n+\n+  typedef std::vector<Struct_field>::iterator iterator;\n+  typedef std::vector<Struct_field>::const_iterator const_iterator;\n+\n+  iterator\n+  begin()\n+  { return this->entries_.begin(); }\n+\n+  const_iterator\n+  begin() const\n+  { return this->entries_.begin(); }\n+\n+  iterator\n+  end()\n+  { return this->entries_.end(); }\n+\n+  const_iterator\n+  end() const\n+  { return this->entries_.end(); }\n+\n+ private:\n+  std::vector<Struct_field> entries_;\n+};\n+\n+// The type of a struct.\n+\n+class Struct_type : public Type\n+{\n+ public:\n+  Struct_type(Struct_field_list* fields, source_location location)\n+    : Type(TYPE_STRUCT),\n+      fields_(fields), location_(location), all_methods_(NULL)\n+  { }\n+\n+  // Return the field NAME.  This only looks at local fields, not at\n+  // embedded types.  If the field is found, and PINDEX is not NULL,\n+  // this sets *PINDEX to the field index.  If the field is not found,\n+  // this returns NULL.\n+  const Struct_field*\n+  find_local_field(const std::string& name, unsigned int *pindex) const;\n+\n+  // Return the field number INDEX.\n+  const Struct_field*\n+  field(unsigned int index) const\n+  { return &this->fields_->at(index); }\n+\n+  // Get the struct fields.\n+  const Struct_field_list*\n+  fields() const\n+  { return this->fields_; }\n+\n+  // Return the number of fields.\n+  size_t\n+  field_count() const\n+  { return this->fields_->size(); }\n+\n+  // Push a new field onto the end of the struct.  This is used when\n+  // building a closure variable.\n+  void\n+  push_field(const Struct_field& sf)\n+  { this->fields_->push_back(sf); }\n+\n+  // Return an expression referring to field NAME in STRUCT_EXPR, or\n+  // NULL if there is no field with that name.\n+  Field_reference_expression*\n+  field_reference(Expression* struct_expr, const std::string& name,\n+\t\t  source_location) const;\n+\n+  // Return the total number of fields, including embedded fields.\n+  // This is the number of values which can appear in a conversion to\n+  // this type.\n+  unsigned int\n+  total_field_count() const;\n+\n+  // Whether this type is identical with T.\n+  bool\n+  is_identical(const Struct_type* t) const;\n+\n+  // Whether this struct type has any hidden fields.  This returns\n+  // true if any fields have hidden names, or if any non-pointer\n+  // anonymous fields have types with hidden fields.\n+  bool\n+  struct_has_hidden_fields(const Named_type* within, std::string*) const;\n+\n+  // Return whether NAME is a local field which is not exported.  This\n+  // is only used for better error reporting.\n+  bool\n+  is_unexported_local_field(Gogo*, const std::string& name) const;\n+\n+  // If this is an unnamed struct, build the complete list of methods,\n+  // including those from anonymous fields, and build methods stubs if\n+  // needed.\n+  void\n+  finalize_methods(Gogo*);\n+\n+  // Return whether this type has any methods.  This should only be\n+  // called after the finalize_methods pass.\n+  bool\n+  has_any_methods() const\n+  { return this->all_methods_ != NULL; }\n+\n+  // Return the methods for tihs type.  This should only be called\n+  // after the finalize_methods pass.\n+  const Methods*\n+  methods() const\n+  { return this->all_methods_; }\n+\n+  // Return the method to use for NAME.  This returns NULL if there is\n+  // no such method or if the method is ambiguous.  When it returns\n+  // NULL, this sets *IS_AMBIGUOUS if the method name is ambiguous.\n+  Method*\n+  method_function(const std::string& name, bool* is_ambiguous) const;\n+\n+  // Traverse just the field types of a struct type.\n+  int\n+  traverse_field_types(Traverse* traverse)\n+  { return this->do_traverse(traverse); }\n+\n+  // Import a struct type.\n+  static Struct_type*\n+  do_import(Import*);\n+\n+  // Fill in the fields for a named struct type.\n+  tree\n+  fill_in_tree(Gogo*, tree);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_verify();\n+\n+  bool\n+  do_has_pointer() const;\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  Field_reference_expression*\n+  field_reference_depth(Expression* struct_expr, const std::string& name,\n+\t\t\tsource_location, unsigned int* depth) const;\n+\n+  static Type*\n+  make_struct_type_descriptor_type();\n+\n+  // The fields of the struct.\n+  Struct_field_list* fields_;\n+  // The place where the struct was declared.\n+  source_location location_;\n+  // If this struct is unnamed, a list of methods.\n+  Methods* all_methods_;\n+};\n+\n+// The type of an array.\n+\n+class Array_type : public Type\n+{\n+ public:\n+  Array_type(Type* element_type, Expression* length)\n+    : Type(TYPE_ARRAY),\n+      element_type_(element_type), length_(length), length_tree_(NULL)\n+  { }\n+\n+  // Return the element type.\n+  Type*\n+  element_type() const\n+  { return this->element_type_; }\n+\n+  // Return the length.  This will return NULL for an open array.\n+  Expression*\n+  length() const\n+  { return this->length_; }\n+\n+  // Whether this type is identical with T.\n+  bool\n+  is_identical(const Array_type* t) const;\n+\n+  // Whether this type has any hidden fields.\n+  bool\n+  array_has_hidden_fields(const Named_type* within, std::string* reason) const\n+  { return this->element_type_->has_hidden_fields(within, reason); }\n+\n+  // Return a tree for the pointer to the values in an array.\n+  tree\n+  value_pointer_tree(Gogo*, tree array) const;\n+\n+  // Return a tree for the length of an array with this type.\n+  tree\n+  length_tree(Gogo*, tree array);\n+\n+  // Return a tree for the capacity of an array with this type.\n+  tree\n+  capacity_tree(Gogo*, tree array);\n+\n+  // Import an array type.\n+  static Array_type*\n+  do_import(Import*);\n+\n+  // Fill in the fields for a named slice type.\n+  tree\n+  fill_in_tree(Gogo*, tree);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_verify();\n+\n+  bool\n+  do_has_pointer() const\n+  {\n+    return this->length_ == NULL || this->element_type_->has_pointer();\n+  }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  bool\n+  do_check_make_expression(Expression_list*, source_location);\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  tree\n+  do_make_expression_tree(Translate_context*, Expression_list*,\n+\t\t\t  source_location);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  bool\n+  verify_length();\n+\n+  tree\n+  get_length_tree(Gogo*);\n+\n+  Type*\n+  make_array_type_descriptor_type();\n+\n+  Type*\n+  make_slice_type_descriptor_type();\n+\n+  Expression*\n+  array_type_descriptor(Gogo*, Named_type*);\n+\n+  Expression*\n+  slice_type_descriptor(Gogo*, Named_type*);\n+\n+  // The type of elements of the array.\n+  Type* element_type_;\n+  // The number of elements.  This may be NULL.\n+  Expression* length_;\n+  // The length as a tree.  We only want to compute this once.\n+  tree length_tree_;\n+};\n+\n+// The type of a map.\n+\n+class Map_type : public Type\n+{\n+ public:\n+  Map_type(Type* key_type, Type* val_type, source_location location)\n+    : Type(TYPE_MAP),\n+      key_type_(key_type), val_type_(val_type), location_(location)\n+  { }\n+\n+  // Return the key type.\n+  Type*\n+  key_type() const\n+  { return this->key_type_; }\n+\n+  // Return the value type.\n+  Type*\n+  val_type() const\n+  { return this->val_type_; }\n+\n+  // Whether this type is identical with T.\n+  bool\n+  is_identical(const Map_type* t) const;\n+\n+  // Import a map type.\n+  static Map_type*\n+  do_import(Import*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_verify();\n+\n+  bool\n+  do_has_pointer() const\n+  { return true; }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  bool\n+  do_check_make_expression(Expression_list*, source_location);\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  tree\n+  do_make_expression_tree(Translate_context*, Expression_list*,\n+\t\t\t  source_location);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  static Type*\n+  make_map_type_descriptor_type();\n+\n+  // The key type.\n+  Type* key_type_;\n+  // The value type.\n+  Type* val_type_;\n+  // Where the type was defined.\n+  source_location location_;\n+};\n+\n+// The type of a channel.\n+\n+class Channel_type : public Type\n+{\n+ public:\n+  Channel_type(bool may_send, bool may_receive, Type* element_type)\n+    : Type(TYPE_CHANNEL),\n+      may_send_(may_send), may_receive_(may_receive),\n+      element_type_(element_type)\n+  { gcc_assert(may_send || may_receive); }\n+\n+  // Whether this channel can send data.\n+  bool\n+  may_send() const\n+  { return this->may_send_; }\n+\n+  // Whether this channel can receive data.\n+  bool\n+  may_receive() const\n+  { return this->may_receive_; }\n+\n+  // The type of the values that may be sent on this channel.  This is\n+  // NULL if any type may be sent.\n+  Type*\n+  element_type() const\n+  { return this->element_type_; }\n+\n+  // Whether this type is identical with T.\n+  bool\n+  is_identical(const Channel_type* t) const;\n+\n+  // Import a channel type.\n+  static Channel_type*\n+  do_import(Import*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return Type::traverse(this->element_type_, traverse); }\n+\n+  bool\n+  do_has_pointer() const\n+  { return true; }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  bool\n+  do_check_make_expression(Expression_list*, source_location);\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo*, tree, bool);\n+\n+  tree\n+  do_make_expression_tree(Translate_context*, Expression_list*,\n+\t\t\t  source_location);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  static Type*\n+  make_chan_type_descriptor_type();\n+\n+  // Whether this channel can send data.\n+  bool may_send_;\n+  // Whether this channel can receive data.\n+  bool may_receive_;\n+  // The types of elements which may be sent on this channel.  If this\n+  // is NULL, it means that any type may be sent.\n+  Type* element_type_;\n+};\n+\n+// An interface type.\n+\n+class Interface_type : public Type\n+{\n+ public:\n+  Interface_type(Typed_identifier_list* methods, source_location location)\n+    : Type(TYPE_INTERFACE),\n+      methods_(methods), location_(location)\n+  { gcc_assert(methods == NULL || !methods->empty()); }\n+\n+  // Return whether this is an empty interface.\n+  bool\n+  is_empty() const\n+  { return this->methods_ == NULL; }\n+\n+  // Return the list of methods.  This will return NULL for an empty\n+  // interface.\n+  const Typed_identifier_list*\n+  methods() const\n+  { return this->methods_; }\n+\n+  // Return the number of methods.\n+  size_t\n+  method_count() const\n+  { return this->methods_ == NULL ? 0 : this->methods_->size(); }\n+\n+  // Return the method NAME, or NULL.\n+  const Typed_identifier*\n+  find_method(const std::string& name) const;\n+\n+  // Return the zero-based index of method NAME.\n+  size_t\n+  method_index(const std::string& name) const;\n+\n+  // Finalize the methods.  This handles interface inheritance.\n+  void\n+  finalize_methods();\n+\n+  // Return true if T implements this interface.  If this returns\n+  // false, and REASON is not NULL, it sets *REASON to the reason that\n+  // it fails.\n+  bool\n+  implements_interface(const Type* t, std::string* reason) const;\n+\n+  // Whether this type is identical with T.  REASON is as in\n+  // implements_interface.\n+  bool\n+  is_identical(const Interface_type* t) const;\n+\n+  // Whether we can assign T to this type.  is_identical is known to\n+  // be false.\n+  bool\n+  is_compatible_for_assign(const Interface_type*, std::string* reason) const;\n+\n+  // Return whether NAME is a method which is not exported.  This is\n+  // only used for better error reporting.\n+  bool\n+  is_unexported_method(Gogo*, const std::string& name) const;\n+\n+  // Import an interface type.\n+  static Interface_type*\n+  do_import(Import*);\n+\n+  // Fill in the fields for a named interface type.\n+  tree\n+  fill_in_tree(Gogo*, tree);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_has_pointer() const\n+  { return true; }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo* gogo, tree, bool);\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string*) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  static Type*\n+  make_interface_type_descriptor_type();\n+\n+  // The list of methods associated with the interface.  This will be\n+  // NULL for the empty interface.\n+  Typed_identifier_list* methods_;\n+  // The location where the interface was defined.\n+  source_location location_;\n+};\n+\n+// The value we keep for a named type.  This lets us get the right\n+// name when we convert to trees.  Note that we don't actually keep\n+// the name here; the name is in the Named_object which points to\n+// this.  This object exists to hold a unique tree which represents\n+// the type.\n+\n+class Named_type : public Type\n+{\n+ public:\n+  Named_type(Named_object* named_object, Type* type, source_location location)\n+    : Type(TYPE_NAMED),\n+      named_object_(named_object), in_function_(NULL), type_(type),\n+      local_methods_(NULL), all_methods_(NULL),\n+      interface_method_tables_(NULL), pointer_interface_method_tables_(NULL),\n+      location_(location), named_tree_(NULL), is_visible_(true),\n+      is_error_(false), seen_(false)\n+  { }\n+\n+  // Return the associated Named_object.  This holds the actual name.\n+  Named_object*\n+  named_object()\n+  { return this->named_object_; }\n+\n+  const Named_object*\n+  named_object() const\n+  { return this->named_object_; }\n+\n+  // Set the Named_object.  This is used when we see a type\n+  // declaration followed by a type.\n+  void\n+  set_named_object(Named_object* no)\n+  { this->named_object_ = no; }\n+\n+  // Return the function in which this type is defined.  This will\n+  // return NULL for a type defined in global scope.\n+  const Named_object*\n+  in_function() const\n+  { return this->in_function_; }\n+\n+  // Set the function in which this type is defined.\n+  void\n+  set_in_function(Named_object* f)\n+  { this->in_function_ = f; }\n+\n+  // Return the name of the type.\n+  const std::string&\n+  name() const;\n+\n+  // Return the name of the type for an error message.  The difference\n+  // is that if the type is defined in a different package, this will\n+  // return PACKAGE.NAME.\n+  std::string\n+  message_name() const;\n+\n+  // Return the underlying type.\n+  Type*\n+  real_type()\n+  { return this->type_; }\n+\n+  const Type*\n+  real_type() const\n+  { return this->type_; }\n+\n+  // Return the location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Whether this type is visible.  This only matters when parsing.\n+  bool\n+  is_visible() const\n+  { return this->is_visible_; }\n+\n+  // Mark this type as visible.\n+  void\n+  set_is_visible()\n+  { this->is_visible_ = true; }\n+\n+  // Mark this type as invisible.\n+  void\n+  clear_is_visible()\n+  { this->is_visible_ = false; }\n+\n+  // Whether this is a builtin type.\n+  bool\n+  is_builtin() const\n+  { return this->location_ == BUILTINS_LOCATION; }\n+\n+  // Add a method to this type.\n+  Named_object*\n+  add_method(const std::string& name, Function*);\n+\n+  // Add a method declaration to this type.\n+  Named_object*\n+  add_method_declaration(const std::string& name, Package* package,\n+\t\t\t Function_type* type, source_location location);\n+\n+  // Add an existing method--one defined before the type itself was\n+  // defined--to a type.\n+  void\n+  add_existing_method(Named_object*);\n+\n+  // Look up a local method.\n+  Named_object*\n+  find_local_method(const std::string& name) const;\n+\n+  // Return the list of local methods.\n+  const Bindings*\n+  local_methods() const\n+  { return this->local_methods_; }\n+\n+  // Build the complete list of methods, including those from\n+  // anonymous fields, and build method stubs if needed.\n+  void\n+  finalize_methods(Gogo*);\n+\n+  // Return whether this type has any methods.  This should only be\n+  // called after the finalize_methods pass.\n+  bool\n+  has_any_methods() const\n+  { return this->all_methods_ != NULL; }\n+\n+  // Return the methods for this type.  This should only be called\n+  // after the finalized_methods pass.\n+  const Methods*\n+  methods() const\n+  { return this->all_methods_; }\n+\n+  // Return the method to use for NAME.  This returns NULL if there is\n+  // no such method or if the method is ambiguous.  When it returns\n+  // NULL, this sets *IS_AMBIGUOUS if the method name is ambiguous.\n+  Method*\n+  method_function(const std::string& name, bool *is_ambiguous) const;\n+\n+  // Return whether NAME is a known field or method which is not\n+  // exported.  This is only used for better error reporting.\n+  bool\n+  is_unexported_local_method(Gogo*, const std::string& name) const;\n+\n+  // Return a pointer to the interface method table for this type for\n+  // the interface INTERFACE.  If IS_POINTER is true, set the type\n+  // descriptor to a pointer to this type, otherwise set it to this\n+  // type.\n+  tree\n+  interface_method_table(Gogo*, const Interface_type* interface,\n+\t\t\t bool is_pointer);\n+\n+  // Whether this type has any hidden fields.\n+  bool\n+  named_type_has_hidden_fields(std::string* reason) const;\n+\n+  // Export the type.\n+  void\n+  export_named_type(Export*, const std::string& name) const;\n+\n+  // Import a named type.\n+  static void\n+  import_named_type(Import*, Named_type**);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return Type::traverse(this->type_, traverse); }\n+\n+  bool\n+  do_verify();\n+\n+  bool\n+  do_has_pointer() const\n+  { return this->type_->has_pointer(); }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo*) const;\n+\n+  bool\n+  do_check_make_expression(Expression_list* args, source_location location)\n+  { return this->type_->check_make_expression(args, location); }\n+\n+  tree\n+  do_get_tree(Gogo*);\n+\n+  tree\n+  do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n+  { return this->type_->get_typed_init_tree(gogo, type_tree, is_clear); }\n+\n+  tree\n+  do_make_expression_tree(Translate_context* context, Expression_list* args,\n+\t\t\t  source_location location)\n+  { return this->type_->make_expression_tree(context, args, location); }\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string* ret) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  // A mapping from interfaces to the associated interface method\n+  // tables for this type.  This maps to a decl.\n+  typedef Unordered_map_hash(const Interface_type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Interface_method_tables;\n+\n+  // A pointer back to the Named_object for this type.\n+  Named_object* named_object_;\n+  // If this type is defined in a function, a pointer back to the\n+  // function in which it is defined.\n+  Named_object* in_function_;\n+  // The actual type.\n+  Type* type_;\n+  // The list of methods defined for this type.  Any named type can\n+  // have methods.\n+  Bindings* local_methods_;\n+  // The full list of methods for this type, including methods\n+  // declared for anonymous fields.\n+  Methods* all_methods_;\n+  // A mapping from interfaces to the associated interface method\n+  // tables for this type.\n+  Interface_method_tables* interface_method_tables_;\n+  // A mapping from interfaces to the associated interface method\n+  // tables for pointers to this type.\n+  Interface_method_tables* pointer_interface_method_tables_;\n+  // The location where this type was defined.\n+  source_location location_;\n+  // The tree for this type while converting to GENERIC.  This is used\n+  // to avoid endless recursion when a named type refers to itself.\n+  tree named_tree_;\n+  // Whether this type is visible.  This is false if this type was\n+  // created because it was referenced by an imported object, but the\n+  // type itself was not exported.  This will always be true for types\n+  // created in the current package.\n+  bool is_visible_;\n+  // Whether this type is erroneous.\n+  bool is_error_;\n+  // In a recursive operation such as has_hidden_fields, this flag is\n+  // used to prevent infinite recursion when a type refers to itself.\n+  // This is mutable because it is always reset to false when the\n+  // function exits.\n+  mutable bool seen_;\n+};\n+\n+// A forward declaration.  This handles a type which has been declared\n+// but not defined.\n+\n+class Forward_declaration_type : public Type\n+{\n+ public:\n+  Forward_declaration_type(Named_object* named_object);\n+\n+  // The named object associated with this type declaration.  This\n+  // will be resolved.\n+  Named_object*\n+  named_object();\n+\n+  const Named_object*\n+  named_object() const;\n+\n+  // Return the name of the type.\n+  const std::string&\n+  name() const;\n+\n+  // Return the type to which this points.  Give an error if the type\n+  // has not yet been defined.\n+  Type*\n+  real_type();\n+\n+  const Type*\n+  real_type() const;\n+\n+  // Whether the base type has been defined.\n+  bool\n+  is_defined() const;\n+\n+  // Add a method to this type.\n+  Named_object*\n+  add_method(const std::string& name, Function*);\n+\n+  // Add a method declaration to this type.\n+  Named_object*\n+  add_method_declaration(const std::string& name, Function_type*,\n+\t\t\t source_location);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_has_pointer() const\n+  { return this->base()->has_pointer(); }\n+\n+  unsigned int\n+  do_hash_for_method(Gogo* gogo) const\n+  { return this->real_type()->hash_for_method(gogo); }\n+\n+  bool\n+  do_check_make_expression(Expression_list* args, source_location location)\n+  { return this->base()->check_make_expression(args, location); }\n+\n+  tree\n+  do_get_tree(Gogo* gogo);\n+\n+  tree\n+  do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n+  { return this->base()->get_typed_init_tree(gogo, type_tree, is_clear); }\n+\n+  tree\n+  do_make_expression_tree(Translate_context* context, Expression_list* args,\n+\t\t\t  source_location location)\n+  { return this->base()->make_expression_tree(context, args, location); }\n+\n+  Expression*\n+  do_type_descriptor(Gogo*, Named_type*);\n+\n+  void\n+  do_reflection(Gogo*, std::string*) const;\n+\n+  void\n+  do_mangled_name(Gogo*, std::string* ret) const;\n+\n+  void\n+  do_export(Export*) const;\n+\n+ private:\n+  // Issue a warning about a use of an undefined type.\n+  void\n+  warn() const;\n+\n+  // The type declaration.\n+  Named_object* named_object_;\n+  // Whether we have issued a warning about this type.\n+  mutable bool warned_;\n+};\n+\n+// The Type_context struct describes what we expect for the type of an\n+// expression.\n+\n+struct Type_context\n+{\n+  // The exact type we expect, if known.  This may be NULL.\n+  Type* type;\n+  // Whether an abstract type is permitted.\n+  bool may_be_abstract;\n+\n+  // Constructors.\n+  Type_context()\n+    : type(NULL), may_be_abstract(false)\n+  { }\n+\n+  Type_context(Type* a_type, bool a_may_be_abstract)\n+    : type(a_type), may_be_abstract(a_may_be_abstract)\n+  { }\n+};\n+\n+#endif // !defined(GO_TYPES_H)"}, {"sha": "51d812b3d8f3967ec94086a57a8874d346b2bf99", "filename": "gcc/go/gofrontend/unsafe.cc", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,134 @@\n+// unsafe.cc -- Go frontend builtin unsafe package.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"types.h\"\n+#include \"gogo.h\"\n+\n+// Set up the builtin unsafe package.  This should probably be driven\n+// by a table.\n+\n+void\n+Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n+\t\t    source_location location)\n+{\n+  location_t bloc = BUILTINS_LOCATION;\n+\n+  bool add_to_globals;\n+  Package* package = this->add_imported_package(\"unsafe\", local_name,\n+\t\t\t\t\t\tis_local_name_exported,\n+\t\t\t\t\t\t\"libgo_unsafe\",\n+\t\t\t\t\t\tlocation, &add_to_globals);\n+  package->set_is_imported();\n+\n+  Bindings* bindings = package->bindings();\n+\n+  // The type may have already been created by an import.\n+  Named_object* no = package->bindings()->lookup(\"Pointer\");\n+  if (no == NULL)\n+    {\n+      Type* type = Type::make_pointer_type(Type::make_void_type());\n+      no = bindings->add_type(\"Pointer\", package, type, UNKNOWN_LOCATION);\n+    }\n+  else\n+    {\n+      gcc_assert(no->package() == package);\n+      gcc_assert(no->is_type());\n+      gcc_assert(no->type_value()->is_unsafe_pointer_type());\n+      no->type_value()->set_is_visible();\n+    }\n+  Named_type* pointer_type = no->type_value();\n+  if (add_to_globals)\n+    this->add_named_type(pointer_type);\n+\n+  Type* int_type = this->lookup_global(\"int\")->type_value();\n+\n+  // Sizeof.\n+  Typed_identifier_list* results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  Function_type* fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Sizeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Offsetof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Offsetof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Alignof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Alignof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Typeof.\n+  Type* empty_interface = Type::make_interface_type(NULL, bloc);\n+  Typed_identifier_list* parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"i\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Typeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Reflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"it\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Reflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Unreflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"addr\", pointer_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Unreflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // New.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"New\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // NewArray.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"n\", int_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"NewArray\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  this->imported_unsafe_ = true;\n+}"}, {"sha": "c8f2badb709c13cf76b9b52d89f7711c9e5ac5de", "filename": "gcc/go/gospec.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgospec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Fgospec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgospec.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,327 @@\n+/* gospec.c -- Specific flags and argument handling of the gcc Go front end.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"gcc.h\"\n+#include \"opts.h\"\n+\n+/* This bit is set if we saw a `-xfoo' language specification.  */\n+#define LANGSPEC\t(1<<1)\n+/* This bit is set if they did `-lm' or `-lmath'.  */\n+#define MATHLIB\t\t(1<<2)\n+/* This bit is set if they did `-lpthread'.  */\n+#define THREADLIB\t(1<<3)\n+/* This bit is set if they did `-lc'.  */\n+#define WITHLIBC\t(1<<4)\n+/* Skip this option.  */\n+#define SKIPOPT\t\t(1<<5)\n+\n+#ifndef MATH_LIBRARY\n+#define MATH_LIBRARY \"m\"\n+#endif\n+#ifndef MATH_LIBRARY_PROFILE\n+#define MATH_LIBRARY_PROFILE MATH_LIBRARY\n+#endif\n+\n+#define THREAD_LIBRARY \"pthread\"\n+#define THREAD_LIBRARY_PROFILE THREAD_LIBRARY\n+\n+#define LIBGO \"go\"\n+#define LIBGO_PROFILE LIBGO\n+#define LIBGOBEGIN \"gobegin\"\n+\n+void\n+lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n+\t\t      unsigned int *in_decoded_options_count,\n+\t\t      int *in_added_libraries)\n+{\n+  unsigned int i, j;\n+\n+  /* If true, the user gave us the `-p' or `-pg' flag.  */\n+  bool saw_profile_flag = false;\n+\n+  /* This is a tristate:\n+     -1 means we should not link in libgo\n+     0  means we should link in libgo if it is needed\n+     1  means libgo is needed and should be linked in.\n+     2  means libgo is needed and should be linked statically.  */\n+  int library = 0;\n+\n+  /* The new argument list will be contained in this.  */\n+  struct cl_decoded_option *new_decoded_options;\n+\n+  /* \"-lm\" or \"-lmath\" if it appears on the command line.  */\n+  const struct cl_decoded_option *saw_math = 0;\n+\n+  /* \"-lpthread\" if it appears on the command line.  */\n+  const struct cl_decoded_option *saw_thread = 0;\n+\n+  /* \"-lc\" if it appears on the command line.  */\n+  const struct cl_decoded_option *saw_libc = 0;\n+\n+  /* An array used to flag each argument that needs a bit set for\n+     LANGSPEC, MATHLIB, or WITHLIBC.  */\n+  int *args;\n+\n+  /* Whether we need the thread library.  */\n+  int need_thread = 0;\n+\n+  /* By default, we throw on the math library if we have one.  */\n+  int need_math = (MATH_LIBRARY[0] != '\\0');\n+\n+  /* True if we saw -static.  */\n+  int static_link = 0;\n+\n+  /* True if we should add -shared-libgcc to the command-line.  */\n+  int shared_libgcc = 1;\n+\n+  /* The total number of arguments with the new stuff.  */\n+  unsigned int argc;\n+\n+  /* The argument list.  */\n+  struct cl_decoded_option *decoded_options;\n+\n+  /* The number of libraries added in.  */\n+  int added_libraries;\n+\n+  /* The total number of arguments with the new stuff.  */\n+  int num_args = 1;\n+\n+  argc = *in_decoded_options_count;\n+  decoded_options = *in_decoded_options;\n+  added_libraries = *in_added_libraries;\n+\n+  args = XCNEWVEC (int, argc);\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      const char *arg = decoded_options[i].arg;\n+\n+      switch (decoded_options[i].opt_index)\n+\t{\n+\tcase OPT_nostdlib:\n+\tcase OPT_nodefaultlibs:\n+\t  library = -1;\n+\t  break;\n+\n+\tcase OPT_l:\n+\t  if (strcmp (arg, MATH_LIBRARY) == 0)\n+\t    {\n+\t      args[i] |= MATHLIB;\n+\t      need_math = 0;\n+\t    }\n+\t  else if (strcmp (arg, THREAD_LIBRARY) == 0)\n+\t    args[i] |= THREADLIB;\n+\t  else if (strcmp (arg, \"c\") == 0)\n+\t    args[i] |= WITHLIBC;\n+\t  else\n+\t    /* Unrecognized libraries (e.g. -lfoo) may require libgo.  */\n+\t    library = (library == 0) ? 1 : library;\n+\t  break;\n+\n+\tcase OPT_pg:\n+\tcase OPT_p:\n+\t  saw_profile_flag = true;\n+\t  break;\n+\n+\tcase OPT_x:\n+\t  if (library == 0 && strcmp (arg, \"go\") == 0)\n+\t    library = 1;\n+\t  break;\n+\n+\tcase OPT_Xlinker:\n+\tcase OPT_Wl_:\n+\t  /* Arguments that go directly to the linker might be .o files,\n+\t     or something, and so might cause libgo to be needed.  */\n+\t  if (library == 0)\n+\t    library = 1;\n+\t  break;\n+\n+\tcase OPT_c:\n+\tcase OPT_S:\n+\tcase OPT_E:\n+\tcase OPT_M:\n+\tcase OPT_MM:\n+\tcase OPT_fsyntax_only:\n+\t  /* Don't specify libraries if we won't link, since that would\n+\t     cause a warning.  */\n+\t  library = -1;\n+\t  break;\n+\n+\tcase OPT_static:\n+\t  static_link = 1;\n+\t  break;\n+\n+\tcase OPT_static_libgcc:\n+\t  shared_libgcc = 0;\n+\t  break;\n+\n+\tcase OPT_static_libgo:\n+\t  library = library >= 0 ? 2 : library;\n+\t  args[i] |= SKIPOPT;\n+\t  break;\n+\n+\tcase OPT_SPECIAL_input_file:\n+\t  if (library == 0)\n+\t    library = 1;\n+\t  break;\n+\t}\n+    }\n+\n+  /* There's no point adding -shared-libgcc if we don't have a shared\n+     libgcc.  */\n+#ifndef ENABLE_SHARED_LIBGCC\n+  shared_libgcc = 0;\n+#endif\n+\n+  /* Make sure to have room for the trailing NULL argument.  */\n+  num_args = argc + need_math + shared_libgcc + (library > 0) * 5 + 5;\n+  new_decoded_options = XNEWVEC (struct cl_decoded_option, num_args);\n+\n+  i = 0;\n+  j = 0;\n+\n+  /* Copy the 0th argument, i.e., the name of the program itself.  */\n+  new_decoded_options[j++] = decoded_options[i++];\n+\n+  /* If we are linking, pass -fsplit-stack if it is supported.  */\n+#ifdef TARGET_CAN_SPLIT_STACK\n+  if (library >= 0)\n+    {\n+      generate_option (OPT_fsplit_stack, NULL, 1, CL_DRIVER,\n+\t\t       &new_decoded_options[j]);\n+      j++;\n+    }\n+#endif\n+\n+  /* NOTE: We start at 1 now, not 0.  */\n+  while (i < argc)\n+    {\n+      new_decoded_options[j] = decoded_options[i];\n+\n+      /* Make sure -lgo is before the math library, since libgo itself\n+\t uses those math routines.  */\n+      if (!saw_math && (args[i] & MATHLIB) && library > 0)\n+\t{\n+\t  --j;\n+\t  saw_math = &decoded_options[i];\n+\t}\n+\n+      if (!saw_thread && (args[i] & THREADLIB) && library > 0)\n+\t{\n+\t  --j;\n+\t  saw_thread = &decoded_options[i];\n+\t}\n+\n+      if (!saw_libc && (args[i] & WITHLIBC) && library > 0)\n+\t{\n+\t  --j;\n+\t  saw_libc = &decoded_options[i];\n+\t}\n+\n+      if ((args[i] & SKIPOPT) != 0)\n+\t--j;\n+\n+      i++;\n+      j++;\n+    }\n+\n+  /* Add `-lgo' if we haven't already done so.  */\n+  if (library > 0)\n+    {\n+      generate_option (OPT_l, LIBGOBEGIN, 1, CL_DRIVER,\n+\t\t       &new_decoded_options[j]);\n+      added_libraries++;\n+      j++;\n+\n+#ifdef HAVE_LD_STATIC_DYNAMIC\n+      if (library > 1 && !static_link)\n+\t{\n+\t  generate_option (OPT_Wl_, \"-Bstatic\", 1, CL_DRIVER,\n+\t\t\t   &new_decoded_options[j]);\n+\t  j++;\n+\t}\n+#endif\n+\n+      generate_option (OPT_l, saw_profile_flag ? LIBGO_PROFILE : LIBGO, 1,\n+\t\t       CL_DRIVER, &new_decoded_options[j]);\n+      added_libraries++;\n+      j++;\n+\n+#ifdef HAVE_LD_STATIC_DYNAMIC\n+      if (library > 1 && !static_link)\n+\t{\n+\t  generate_option (OPT_Wl_, \"-Bdynamic\", 1, CL_DRIVER,\n+\t\t\t   &new_decoded_options[j]);\n+\t  j++;\n+\t}\n+#endif\n+\n+      /* When linking libgo statically we also need to link with the\n+\t pthread library.  */\n+      if (library > 1 || static_link)\n+\tneed_thread = 1;\n+    }\n+\n+  if (saw_thread)\n+    new_decoded_options[j++] = *saw_thread;\n+  else if (library > 0 && need_thread)\n+    {\n+      generate_option (OPT_l,\n+\t\t       (saw_profile_flag\n+\t\t\t? THREAD_LIBRARY_PROFILE\n+\t\t\t: THREAD_LIBRARY),\n+\t\t       1, CL_DRIVER, &new_decoded_options[j]);\n+      added_libraries++;\n+      j++;\n+    }\n+\n+  if (saw_math)\n+    new_decoded_options[j++] = *saw_math;\n+  else if (library > 0 && need_math)\n+    {\n+      generate_option (OPT_l,\n+\t\t       saw_profile_flag ? MATH_LIBRARY_PROFILE : MATH_LIBRARY,\n+\t\t       1, CL_DRIVER, &new_decoded_options[j]);\n+      added_libraries++;\n+      j++;\n+    }\n+\n+  if (saw_libc)\n+    new_decoded_options[j++] = *saw_libc;\n+  if (shared_libgcc && !static_link)\n+    generate_option (OPT_shared_libgcc, NULL, 1, CL_DRIVER,\n+\t\t     &new_decoded_options[j++]);\n+\n+  *in_decoded_options_count = j;\n+  *in_decoded_options = new_decoded_options;\n+  *in_added_libraries = added_libraries;\n+}\n+\n+/* Called before linking.  Returns 0 on success and -1 on failure.  */\n+int lang_specific_pre_link (void)  /* Not used for Go.  */\n+{\n+  return 0;\n+}\n+\n+/* Number of extra output files that lang_specific_pre_link may generate.  */\n+int lang_specific_extra_outfiles = 0;  /* Not used for Go.  */"}, {"sha": "a47379d0e1ffd3d2aba2e3626a8034dc935b44a3", "filename": "gcc/go/lang-specs.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Flang-specs.h?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,25 @@\n+/* lang-specs.h -- gcc driver specs for Go frontend.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This is the contribution to the `default_compilers' array in gcc.c\n+   for the Go language.  */\n+\n+{\".go\",  \"@go\", 0, 1, 0},\n+{\"@go\",  \"go1 %i %(cc1_options) %{I*} %{L*} %D %{!fsyntax-only:%(invoke_as)}\",\n+    0, 1, 0},"}, {"sha": "9d9b1ffdca48196199a9cc08f3c78b3bc2445906", "filename": "gcc/go/lang.opt", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Fgo%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Flang.opt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,56 @@\n+; lang.opt -- Options for the gcc Go front end.\n+\n+; Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+; \n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+; \n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+; See the GCC internals manual for a description of this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+Language\n+Go\n+\n+I\n+Go Joined Separate\n+; Documented in c.opt\n+\n+L\n+Go Joined Separate\n+; Not documented\n+\n+Wall\n+Go\n+; Documented in c.opt\n+\n+fgo-dump-\n+Go Joined RejectNegative\n+-fgo-dump-<type>\tDump Go frontend internal information\n+\n+fgo-prefix=\n+Go Joined RejectNegative\n+-fgo-prefix=<string>\tSet package-specific prefix for exported Go names\n+\n+frequire-return-statement\n+Go Var(go_require_return_statement) Init(1) Warning\n+Functions which return values must end with return statements\n+\n+o\n+Go Joined Separate\n+; Documented in common.opt\n+\n+; This comment is to ensure we retain the blank line above."}, {"sha": "e0769f5d8e2171af021ad46035d390d4fe94596a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -1,4 +1,11 @@\n-2010-11-02  Eric Botcazou  <ebotcazou@adacore.com>\n+2010-12-02  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lib/go.exp: New file.\n+\t* lib/go-dg.exp: New file.\n+\t* lib/go-torture.exp: New file.\n+\t* lib/target-supports.exp (check_compile): Match // Go.\n+\n+2010-12-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/pr46685.c: New test.\n "}, {"sha": "62c8c0644724b27e55b176b505e1d3c8a9e0f655", "filename": "gcc/testsuite/go.dg/dg.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.dg%2Fdg.exp?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,36 @@\n+#   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib go-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_GOCFLAGS\n+if ![info exists DEFAULT_GOCFLAGS] then {\n+    set DEFAULT_GOCFLAGS \" -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+go-dg-runtest [lsort \\\n+       [glob -nocomplain $srcdir/$subdir/*.go ] ] $DEFAULT_GOCFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "0536d762b2a7eed53a4fe4c48ac782af6f508eba", "filename": "gcc/testsuite/go.dg/err-1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Ferr-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Ferr-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.dg%2Ferr-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile }\n+\n+package main\n+\n+func main() {\n+  var ret;\t\t// { dg-error \"expected type\" }\n+}"}, {"sha": "e20fe4de96bc951279c7f3feb2f85ea8cdaaf859", "filename": "gcc/testsuite/go.dg/goto-1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Fgoto-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Fgoto-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.dg%2Fgoto-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile }\n+\n+package main\n+\n+func main() {\n+  goto lab;\t// { dg-error \"undefined label\" }\n+}"}, {"sha": "e3ea918c2e79131f1118140b94a00fed0270a19a", "filename": "gcc/testsuite/go.dg/undef-1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Fundef-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.dg%2Fundef-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.dg%2Fundef-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile }\n+\n+package main\n+\n+func main() {\n+  sys.Exit(i)\t\t// { dg-error \"undefined\" }\n+}"}, {"sha": "7b34eca192231f528a3c19b2deecadce63c2bd0d", "filename": "gcc/testsuite/go.go-torture/execute/array-1.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Farray-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Farray-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Farray-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,10 @@\n+package main\n+var a [2]int;\n+func fn() {\n+  a[0] = 1;\n+  a[1] = 1;\n+}\n+func main() {\n+  fn();\n+  if a[0] != a[1] { panic(0) }\n+}"}, {"sha": "516a131e4e93f77a6ea7cbe53ed66ff76acd353e", "filename": "gcc/testsuite/go.go-torture/execute/array-2.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Farray-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Farray-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Farray-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,19 @@\n+package main\n+\n+func fn(a []int) int {\n+  alen := len(a);\n+  for i := 0; i < alen; i++ {\n+    a[i] = i\n+  }\n+  return alen;\n+}\n+\n+func main() {\n+  var a [2]int;\n+  if fn(a[0:]) != 2 {\n+    panic(0);\n+  }\n+  if a[0] != 0 || a[1] != 1 {\n+    panic(1);\n+  }\n+}"}, {"sha": "c3d4ddb1114c44a4f5507d904fa78eb4130a881f", "filename": "gcc/testsuite/go.go-torture/execute/chan-1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fchan-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fchan-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fchan-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+func main() {\n+  c := make(chan int, 1);\n+  c <- 0;\n+  if <-c != 0 { panic(0) }\n+}"}, {"sha": "2292692ea23787a5ae377f5eb81179e6f24bd38b", "filename": "gcc/testsuite/go.go-torture/execute/const-1.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fconst-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fconst-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fconst-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,6 @@\n+package main\n+\n+func main() {\n+  const c = 2;\n+  if c != 2 { panic(0) }\n+}"}, {"sha": "a7301a5c5f6c1e0a6244e58d73adcc940c0a17eb", "filename": "gcc/testsuite/go.go-torture/execute/const-2.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fconst-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fconst-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fconst-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+const c = 3;\n+\n+func main() {\n+  if c != 3 { panic(0) }\n+}"}, {"sha": "350d75114261b4b2ff7229a1c26461d4eec5b238", "filename": "gcc/testsuite/go.go-torture/execute/execute.exp", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fexecute.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fexecute.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fexecute.exp?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,33 @@\n+# Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This is based on a file written by Rob Savoye (rob@cygnus.com) and\n+# Jeffrey Wheat (cassidy@cygnus.com).\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# load support procs\n+load_lib go-torture.exp\n+\n+foreach testcase [lsort [glob -nocomplain $srcdir/$subdir/*.go]] {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $testcase] then {\n+\tcontinue\n+    }\n+    go-torture-execute $testcase\n+}"}, {"sha": "076388a6e4c012a408fead399473a9fd216a7229", "filename": "gcc/testsuite/go.go-torture/execute/expr-1.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fexpr-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fexpr-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fexpr-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,11 @@\n+package main\n+\n+func main() {\n+  var v1 = 1;\n+  var v2 = 1;\n+  var v3 = (v1 + v2) / (v1 + v2);\n+  var v4 = (v3 * v3) % (v3 * v3);\n+  if v4 != 0 {\n+    panic(0)\n+  }\n+}"}, {"sha": "7aa91f004269ee562abf894cabe9a11d9c36b7f3", "filename": "gcc/testsuite/go.go-torture/execute/for-1.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffor-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffor-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffor-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,9 @@\n+package main\n+\n+func main() {\n+  sum := 0;\n+  for i := 0; i < 10; i++ {\n+    sum += i;\n+  }\n+  if sum != 45 { panic(0) }\n+}"}, {"sha": "af790edf80cc49429e4347ccd23745690fb2dc3f", "filename": "gcc/testsuite/go.go-torture/execute/for-2.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffor-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffor-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffor-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,52 @@\n+package main\n+\n+func f1() {\n+  j := 0;\n+  for i := 0; i < 10; i++ {\n+    if i > 2 {\n+      break;\n+    }\n+    j = i;\n+  }\n+  if (j != 2) {\n+    panic(0);\n+  }\n+}\n+\n+func f2() {\n+  for i := 0; i < 10; i++ {\n+    if i >= 0 {\n+      continue;\n+    }\n+    panic(1);\n+  }\n+}\n+\n+func f3() {\n+  lab1:\n+  for i := 0; i < 10; i++ {\n+    for j := 0; j < 10; j++ {\n+      if j > 2 {\n+        break lab1;\n+      }\n+    }\n+    panic(2);\n+  }\n+}\n+\n+func f4() {\n+  lab1:\n+  for i := 0; i < 10; i++ {\n+    for j := 0; j < 10; j++ {\n+      continue lab1;\n+    }\n+    panic(3);\n+  }\n+}\n+\n+func main() {\n+  f1();\n+  f2();\n+  f3();\n+  f4()\n+}"}, {"sha": "06244ac1563cf82a01eba1343121556bb1a79e19", "filename": "gcc/testsuite/go.go-torture/execute/function-1.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffunction-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffunction-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffunction-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,9 @@\n+package main\n+\n+func subr() int {\n+  return 0\n+}\n+\n+func main() {\n+  if subr() != 0 { panic(0) }\n+}"}, {"sha": "8b9aa878ed3b263d36857796b777fc4cedf77821", "filename": "gcc/testsuite/go.go-torture/execute/function-2.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffunction-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffunction-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Ffunction-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,9 @@\n+package main\n+\n+func subr(p int) int {\n+  return p\n+}\n+\n+func main() {\n+  if subr(0) != 0 { panic(0) }\n+}"}, {"sha": "7d9dbd469a98380a0c627a0c52d104750b36acbd", "filename": "gcc/testsuite/go.go-torture/execute/go-1.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,11 @@\n+package main\n+\n+func send_one(c chan <- int) {\n+  c <- 0;\n+}\n+\n+func main() {\n+  c := make(chan int);\n+  go send_one(c);\n+  if <-c != 0 { panic(0) }\n+}"}, {"sha": "8ce5fc8791cef2ecb762a5c7bb7eb66761ae9ca4", "filename": "gcc/testsuite/go.go-torture/execute/go-2.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,11 @@\n+package main\n+\n+func send_one(c chan <- int, val int) {\n+  c <- val;\n+}\n+\n+func main() {\n+  c := make(chan int);\n+  go send_one(c, 0);\n+  if <-c != 0 { panic(0) }\n+}"}, {"sha": "af8fa385e47739fd409dff48e6f4a2c52c51c1a5", "filename": "gcc/testsuite/go.go-torture/execute/go-3.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgo-3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,14 @@\n+package main\n+\n+type I interface { send(chan <- int) }\n+\n+type S struct { v int }\n+func (p *S) send(c chan <- int) { c <- p.v }\n+\n+func main() {\n+  s := S{0};\n+  var i I = &s;\n+  c := make(chan int);\n+  go i.send(c);\n+  if <- c != 0 { panic(0) }\n+}"}, {"sha": "0a10c2ef29499727dcc3b38c97f9cc8d5314be7f", "filename": "gcc/testsuite/go.go-torture/execute/goto-1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgoto-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgoto-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fgoto-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+func main() {\n+  goto lab;\n+  panic(0);\n+ lab:\n+}"}, {"sha": "8307c6c98cd43abc5ae5e3142b62d0e6cf46018e", "filename": "gcc/testsuite/go.go-torture/execute/map-1.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmap-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmap-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmap-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,46 @@\n+package main\n+\n+func main() {\n+  v := make(map[int] int);\n+  v[0] = 0;\n+  v[1000000] = 1;\n+  if v[0] != 0 {\n+    panic(1)\n+  }\n+  val, present := v[0];\n+  if !present || val != 0 {\n+    panic(2)\n+  }\n+  val = 5;\n+  val, present = v[1];\n+  if present || val != 0 {\n+    panic(3);\n+  }\n+  if v[2] != 0 {\n+    panic(4)\n+  }\n+  val, present = v[2];\n+  if present {\n+    panic(5)\n+  }\n+  if len(v) != 2 {\n+    panic(6)\n+  }\n+  v[0] = 0, false;\n+  if len(v) != 1 {\n+    panic(7)\n+  }\n+\n+  w := make(map[string] string);\n+  if len(w) != 0 {\n+    panic(8)\n+  }\n+  w[\"Hello\"] = \"world\";\n+  w[\"Goodbye\"] = \"sweet prince\";\n+  if w[\"Hello\"] != \"world\" {\n+    panic(9)\n+  }\n+  if w[\"Hej\"] != \"\" {\n+    panic(10)\n+  }\n+}"}, {"sha": "e4c17c174fa7a0b03066b3f01bb0e12b5660d774", "filename": "gcc/testsuite/go.go-torture/execute/method-1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmethod-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmethod-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmethod-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+package main\n+type s struct { i int };\n+func (v *s) val() int { return v.i }\n+func main() {\n+  p := new(s);\n+  if p.val() != 0 { panic(0) }\n+}"}, {"sha": "cbd96f23a4fc2a6e393604eda677c970ba6e10bd", "filename": "gcc/testsuite/go.go-torture/execute/nested-1.go", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnested-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnested-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnested-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,4 @@\n+package main\n+func main() {\n+  if func (i int) int { return i} (0) != 0 { panic(0) }\n+}"}, {"sha": "f6b30a1a0706d0ecb2ace5d2874e1301aa6bdbda", "filename": "gcc/testsuite/go.go-torture/execute/pointer-1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fpointer-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fpointer-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fpointer-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+func main() {\n+  p := new(int);\n+  *p = 0;\n+  if *p != 0 { panic(0) }\n+}"}, {"sha": "da29a2cadf1e00b14b1a4bd0a52780888bf3e532", "filename": "gcc/testsuite/go.go-torture/execute/return-1.go", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,4 @@\n+package main\n+\n+func main() {\n+}"}, {"sha": "08b2e61a05dbc3814d55064cce0c11e38118efd8", "filename": "gcc/testsuite/go.go-torture/execute/return-2.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,18 @@\n+package main\n+\n+func fn() (i, j int) {\n+     i = 1;\n+     j = 2;\n+     return;\n+}\n+\n+func main() {\n+  var i, j = fn();\n+  var ret int;\n+  if i == 1 && j == 2 {\n+    ret = 0;\n+  } else {\n+    ret = 1;\n+  }\n+  if ret != 0 { panic(0) }\n+}"}, {"sha": "f7fe09c422e1c593d1daf81ed7b1b0ef3fb7acf4", "filename": "gcc/testsuite/go.go-torture/execute/return-3.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Freturn-3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,16 @@\n+package main\n+\n+func fn() (i, j int) {\n+     return 1, 2\n+}\n+\n+func main() {\n+  var i, j = fn();\n+  var ret int;\n+  if i == 1 && j == 2 {\n+    ret = 0;\n+  } else {\n+    ret = 1;\n+  }\n+  if ret != 0 { panic(0) }\n+}"}, {"sha": "8fc6963be3556725b4a88e3ce90c6c729c8774d7", "filename": "gcc/testsuite/go.go-torture/execute/select-1.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fselect-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fselect-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fselect-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,28 @@\n+package main\n+\n+func main() {\n+  ch1 := make(chan int);\n+  ch2 := make(chan int);\n+  go func (ch1, ch2 chan int) { ch1 <- 1; ch2 <- 2; } (ch1, ch2);\n+  count := 0;\n+  var v int;\n+  for count != 2 {\n+      select\n+\t{\n+\tcase v := <- ch1:\n+\t  if v != 1 {\n+\t    panic(0)\n+\t  }\n+\t  count++\n+\n+\tcase v = <- ch2:\n+\t  if v != 2 {\n+\t    panic(1)\n+\t  }\n+\t  count++\n+\t}\n+    }\n+  if v != 2 {\n+    panic(2)\n+  }\n+}"}, {"sha": "f999d87525b11e646fd6a3a4b5584951b0173e1c", "filename": "gcc/testsuite/go.go-torture/execute/string-1.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstring-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstring-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstring-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,15 @@\n+package main\n+\n+func fn(s string) int {\n+  if s[0] != 'a' || s[1] != 'b' || s[2] != 'c' {\n+    panic(0);\n+  }\n+  return len(s);\n+}\n+\n+func main() {\n+  s := \"abc\";\n+  if fn(s) != 3 {\n+    panic(1);\n+  }\n+}"}, {"sha": "72b0f23343838cca9776f5b9842bb42ff67ead83", "filename": "gcc/testsuite/go.go-torture/execute/string-2.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstring-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstring-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstring-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,16 @@\n+package main\n+\n+func fn(s string) string {\n+  if len(s) != 3 {\n+    panic(0)\n+  }\n+  i := len(s) - 1;\n+  return s + s[0 : i];\n+}\n+\n+func main() {\n+  s := fn(\"abc\");\n+  if s != \"abcab\" {\n+    panic(1)\n+  }\n+}"}, {"sha": "edf38b2bf06a4fc6795c582b685c42006038a2de", "filename": "gcc/testsuite/go.go-torture/execute/struct-1.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstruct-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstruct-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstruct-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,8 @@\n+package main\n+\n+func main() {\n+  type s struct { x int; };\n+  var ret s;\n+  ret.x = 1;\n+  if ret.x != 1 { panic(0) }\n+}"}, {"sha": "cc01f6b9c65c088a4056b0cac32a5e66a7bbee61", "filename": "gcc/testsuite/go.go-torture/execute/struct-2.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstruct-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstruct-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fstruct-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+func main() {\n+  type s struct { x int; y int; };\n+  var ret s = s{1, 2};\n+  if ret.y - (ret.x + ret.x) != 0 { panic(0) }\n+}"}, {"sha": "fdc93ce60ac5c2f328a7cfe310d0fcd665b7baed", "filename": "gcc/testsuite/go.go-torture/execute/switch-1.go", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fswitch-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fswitch-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fswitch-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,68 @@\n+package main\n+\n+func f1(i int) bool {\n+  switch j := i; j {\n+  case 3: fallthrough\n+  case 1: return true\n+  case 2: return false\n+  default: return false\n+  case 4: return true\n+  }\n+}\n+\n+func f2(i int) int {\n+  switch {\n+    case i < 0: return -1\n+    case i > 0: return 1\n+    default: return 0\n+    case i != 0: return 1000\n+  }\n+  panic(0)\n+}\n+\n+func f3(i int) int {\n+ lab:\n+  switch i {\n+    case 1: break\n+    case 2: return 2\n+    case 3, 4:\n+      switch i {\n+        case 3: break lab\n+        case 4: break\n+      }\n+      return 4\n+  }\n+  return 1\n+}\n+\n+func main() {\n+  if !f1(1) {\n+    panic(1);\n+  }\n+  if f1(2) {\n+    panic(2);\n+  }\n+  if !f1(3) {\n+    panic(3);\n+  }\n+  if !f1(4) {\n+    panic(4);\n+  }\n+  if f1(5) {\n+    panic(5);\n+  }\n+\n+  if f2(-100) != -1 {\n+    panic(6);\n+  }\n+  if f2(1000) != 1 {\n+    panic(7);\n+  }\n+  if f2(0) != 0 {\n+    panic(8);\n+  }\n+\n+  if f3(1) != 1 || f3(2) != 2 || f3(3) != 1 || f3(4) != 4 {\n+    panic(9);\n+  }\n+}"}, {"sha": "d4b20b6c09b123d082e3202e78a27c86ba4f8dbc", "filename": "gcc/testsuite/go.go-torture/execute/var-1.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,6 @@\n+package main\n+\n+func main() {\n+  var ret = 0;\n+  if ret != 0 { panic(0) }\n+}"}, {"sha": "dd0ec4ee37a7eb089d759d653ad4483c1388d50d", "filename": "gcc/testsuite/go.go-torture/execute/var-2.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,6 @@\n+package main\n+\n+func main() {\n+  var ret int;\n+  if ret != 0 { panic(0) }\n+}"}, {"sha": "80b10041a5ff66a68001d83b0aa6e21cd4d70f8e", "filename": "gcc/testsuite/go.go-torture/execute/var-3.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fvar-3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,6 @@\n+package main\n+\n+func main() {\n+  ret := 0;\n+  if ret != 0 { panic(0) }\n+}"}, {"sha": "6226dd1c925035349ad73211a05c6e9f3f2bf990", "filename": "gcc/testsuite/go.test/go-test.exp", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Fgo-test.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Fgo-test.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Fgo-test.exp?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,666 @@\n+#   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+#   Written by Ian Lance Taylor <iant@google.com>.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+# Test using the testsuite for the gc Go compiler.  In these tests the\n+# first line is a shell script to run.  That line expects the\n+# following environment variables to be set:\n+#   A   The file extension of the object file and the name of the executable\n+#   G   The name of the compiler\n+#   L   The name of the linker\n+#   F   The basename of the test\n+#   D   The directory of the test.\n+#\n+# Typical command lines:\n+# // $G $D/$F.go && $L $F.$A && ./$A.out\n+# // $G $D/$F.go && $L $F.$A || echo BUG: known to fail incorrectly\n+# // $G $D/$F.go && echo BUG: compilation succeeds incorrectly\n+# // $G $D/$F.go || echo BUG: compilation should succeed\n+\n+load_lib go-dg.exp\n+load_lib go-torture.exp\n+\n+# Implement errchk\n+proc errchk { test } {\n+    global dg-do-what-default\n+    global DEFAULT_GOCFLAGS\n+\n+    set saved-dg-do-what-default ${dg-do-what-default}\n+    set dg-do-what-default compile\n+    set filename [file tail $test]\n+    if { \"$filename\" == \"$test\" } {\n+\tset filename \"errchk-$filename\"\n+    }\n+    set fdin [open $test r]\n+    fconfigure $fdin -encoding binary\n+    set fdout [open $filename w]\n+    fconfigure $fdout -encoding binary\n+    while { [gets $fdin copy_line] >= 0 } {\n+\tregsub \"// \\(GCCGO_\\)?ERROR \\\"\\(\\[^\\\"\\]*\\)\\\".*$\" $copy_line \"// \\{ dg-error \\\"\\\\2\\\" \\}\" out_line\n+\tif [string match \"*dg-error*.\\**\" $out_line] {\n+\t    # I worked out the right number of backslashes by\n+\t    # experimentation, not analysis.\n+\t    regsub -all \"\\\\.\\\\*\" $out_line \"\\\\\\\\\\[ -~\\\\\\\\\\]*\" out_line\n+\t}\n+\tif [string match \"*dg-error*\\{*\" $out_line] {\n+\t    set index [string first \"dg-error\" $out_line]\n+\t    regsub -start $index -all \"\\{\" $out_line \"\\\\\\\\\\[\\\\\\{\\\\\\\\\\]\" out_line\n+\t}\n+\tif [string match \"*dg-error*\\}*\\}\" $out_line] {\n+\t    set index [string first \"dg-error\" $out_line]\n+\t    regsub -start $index -all \"\\}\\(.\\)\" $out_line \"\\\\\\\\\\[\\\\\\}\\\\\\\\\\]\\\\1\" out_line\n+\t}\n+\tif [string match \"*dg-error*\\[.\\]*\" $out_line] {\n+\t    set index [string first \"dg-error\" $out_line]\n+\t    regsub -all \"\\\\\\[\\\\.\\\\\\]\" $out_line \"\\\\\\\\\\[.\\\\\\\\\\]\" out_line\n+\t}\n+\tputs $fdout $out_line\n+    }\n+    close $fdin\n+    close $fdout\n+    go-dg-runtest $filename \"-fno-show-column $DEFAULT_GOCFLAGS\"\n+    file delete $filename\n+    set dg-do-what-default ${saved-dg-do-what-default}\n+}\n+\n+# This is an execution test which should fail.\n+proc go-execute-xfail { test } {\n+    global DEFAULT_GOCFLAGS\n+\n+    set filename [file tail $test]\n+    set fdin [open $test r]\n+    set fdout [open $filename w]\n+    puts $fdout \"// { dg-do run { xfail *-*-* } }\"\n+    while { [gets $fdin copy_line] >= 0 } {\n+\tputs $fdout $copy_line\n+    }\n+    close $fdin\n+    close $fdout\n+    go-dg-runtest $filename \"-w $DEFAULT_GOCFLAGS\"\n+    file delete $filename\n+}\n+\n+proc go-gc-tests { } {\n+    global srcdir subdir\n+    global runtests\n+    global GCC_UNDER_TEST\n+    global TOOL_OPTIONS\n+    global TORTURE_OPTIONS\n+    global dg-do-what-default\n+    global go_execute_args\n+    global target_triplet\n+\n+    # If a testcase doesn't have special options, use these.\n+    global DEFAULT_GOCFLAGS\n+    if ![info exists DEFAULT_GOCFLAGS] {\n+\tset DEFAULT_GOCFLAGS \" -pedantic-errors\"\n+    }\n+\n+    # Running all the torture options takes too long and, since the\n+    # frontend ignores the standard options, it doesn't significantly\n+    # improve testing.\n+    set saved_torture_options $TORTURE_OPTIONS\n+    set TORTURE_OPTIONS [ list { -O2 -g }]\n+\n+    set saved-dg-do-what-default ${dg-do-what-default}\n+\n+    set testdir [pwd]\n+\n+    set tests [lsort [find $srcdir/$subdir *.go]]\n+    foreach test $tests {\n+\tif ![runtest_file_p $runtests $test] {\n+\t    continue\n+\t}\n+\n+\t# Skip the files in bench and garbage; they are not tests.\n+\tif [string match \"*go.test/test/bench/*\" $test] {\n+\t    continue\n+\t}\n+\tif [string match \"*go.test/test/garbage/*\" $test] {\n+\t    continue\n+\t}\n+\n+\t# Skip files in sub-subdirectories: they are components of\n+\t# other tests.\n+\tif [string match \"*go.test/test/*/*/*\" $test] {\n+\t    continue\n+\t}\n+\n+\tset name [dg-trim-dirname $srcdir $test]\n+\n+\t# Skip certain tests if target is RTEMS OS.\n+\tif [istarget \"*-*-rtems*\"] {\n+\t    if { [string match \"*go.test/test/args.go\" \\\n+\t\t   $test] \\\n+\t\t || [string match \"*go.test/test/env.go\" \\\n+\t\t   $test] } {\n+\t\t    untested \"$name: uses the command-line or environment variables\"\n+\t\t    continue\n+\t    }\n+\n+\t    if { [string match \"*go.test/test/stack.go\" \\\n+\t\t   $test] \\\n+\t\t || [string match \"*go.test/test/peano.go\" \\\n+\t\t   $test] \\\n+\t\t || [string match \"*go.test/test/chan/goroutines.go\" \\\n+\t\t   $test] } {\n+\t\t    untested \"$name: has very high memory requirement\"\n+\t\t    continue\n+\t    }\n+\t}\n+\n+\tset fd [open $test r]\n+\n+\tset lines_ok 1\n+\n+\twhile 1 {\n+\t    if { [gets $fd test_line] < 0 } {\n+\t\tclose $fd\n+\t\tclone_output \"$test: could not read first line\"\n+\t\tunresolved $name\n+\t\tset lines_ok 0\n+\t\tbreak\n+\t    }\n+\n+\t    if { [ string match \"*nacl*exit 0*\" $test_line ] \\\n+\t\t     || [ string match \"*exit 0*nacl*\" $test_line ] \\\n+\t\t     || [ string match \"*Android*exit 0*\" $test_line ] \\\n+\t\t     || [ string match \"*exit 0*Android*\" $test_line ] } {\n+\t\tcontinue\n+\t    }\n+\n+\t    break\n+\t}\n+\n+\tif { $lines_ok == 0 } {\n+\t    continue\n+\t}\n+\n+\tset lineno 1\n+\tset test_line1 $test_line\n+\n+\twhile { [eval \"string match \\\"//*&&\\\" \\${test_line$lineno}\"] } {\n+\t    set lineno [expr $lineno + 1]\n+\t    if { [eval \"gets \\$fd test_line$lineno\"] < 0 } {\n+\t\tclose $fd\n+\t\tclone_output \"$test: could not read line $lineno\"\n+\t\tunresolved $name\n+\t\tset lines_ok 0\n+\t\tbreak\n+\t    }\n+\t}\n+\tif { $lines_ok == 0 } {\n+\t    continue\n+\t}\n+\n+\tclose $fd\n+\n+\tset go_execute_args \"\"\n+\tif { [regexp \".*\\\\\\$A.out (\\[^|&>\\].*)\\$\" $test_line match progargs] } {\n+\t    set go_execute_args $progargs\n+\t    verbose -log \"$test: go_execute_args is $go_execute_args\"\n+\t    set index [string last \" $progargs\" $test_line]\n+\t    set test_line [string replace $test_line $index end]\n+\t}\n+\n+\tif { $test_line == \"// \\$G \\$D/\\$F\\.go && \\$L \\$F\\.\\$A && \\./\\$A\\.out >tmp.go &&\" \\\n+\t     && $test_line2 == \"// \\$G tmp\\.go && \\$L tmp\\.\\$A && \\./\\$A\\.out || echo BUG: 64bit\" } {\n+\t    # 64bit.go is a special case.\n+\t    set go_execute_args \"\"\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"link\"\n+\t    dg-test -keep-output $test \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    set base \"[file rootname [file tail $test]]\"\n+\t    if [isnative] {\n+\t\tif { [catch \"exec $output_file >$base-out.go\"] != 0 } {\n+\t\t    fail \"$name execution\"\n+\t\t} else {\n+\t\t    pass \"$name execution\"\n+\t\t    file delete $base-out.x\n+\t\t    go-torture-execute \"./$base-out.go\"\n+\t\t}\n+\t\tfile delete $base-out.go\n+\t    }\n+\t    file delete $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { $test_line == \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ./\\$A.out\" \\\n+\t\t   || $test_line == \"// \\$G \\$F.go && \\$L \\$F.\\$A && ./\\$A.out\" \\\n+\t\t   || $test_line == \"// \\$G \\$F.go && \\$L \\$F.\\$A &&./\\$A.out\" \\\n+\t\t   || $test_line == \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && \\$A.out\" \\\n+\t\t   || [string match \\\n+\t\t\t   \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ./\\$A.out || echo BUG*\" \\\n+\t\t\t   $test_line]\n+\t\t   || [string match \\\n+\t\t\t   \"// \\$G \\$F.go && \\$L \\$F.\\$A && (./\\$A.out || echo BUG*\" \\\n+\t\t\t   $test_line]\n+\t\t   || [string match \\\n+\t\t\t   \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && (./\\$A.out || echo BUG*\" \\\n+\t\t\t   $test_line]\n+\t\t   || [string match \\\n+\t\t\t   \"// \\$G \\$F.go && \\$L \\$F.\\$A && GOMAXPROCS=* ./\\$A.out\" \\\n+\t\t\t   $test_line]\n+\t\t   || [string match \\\n+\t\t\t   \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ./\\$A.out >* || echo BUG*\" \\\n+\t\t\t   $test_line] } {\n+\t    # This is a vanilla execution test.\n+\t    go-torture-execute $test\n+\t    file delete core [glob -nocomplain core.*]\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A || echo BUG*\" \\\n+\t\t\t$test_line] \\\n+\t\t   || [string match \"// \\$G \\$F.go && \\$L \\$F.\\$A  #*\" \\\n+\t\t\t   $test_line] } {\n+\t    # This is a vanilla compile and link test.\n+\t    set dg-do-what-default \"link\"\n+\t    go-dg-runtest $test \"-w $DEFAULT_GOCFLAGS\"\n+\t} elseif { [string match \"// \\$G \\$D/\\$F.go\" $test_line] \\\n+\t\t   || [string match \"// \\$G \\$D/\\$F.go || echo BUG*\" \\\n+\t\t\t   $test_line] \\\n+\t\t   || [string match \"// \\$G \\$F.go || echo BUG*\" \\\n+\t\t\t   $test_line] \\\n+\t\t   || [string match \"// ! \\$G \\$D/\\$F.go && echo BUG*\" \\\n+\t\t\t   $test_line] } {\n+\t    # This is a vanilla compile test.\n+\t    set dg-do-what-default \"assemble\"\n+\t    go-dg-runtest $test \"-w $DEFAULT_GOCFLAGS\"\n+\t} elseif { [string match \"// \\$G \\$D/\\$F.go && echo BUG*\" \\\n+\t\t\t$test_line] \\\n+\t\t   || $test_line == \"// ! \\$G \\$D/\\$F.go >/dev/null\" \\\n+\t\t   || $test_line == \"// ! \\$G \\$D/\\$F.go\" \\\n+\t\t   || $test_line == \"// ! \\$G \\$F.go\" \\\n+\t           || [string match \"// ! \\$G \\$D/\\$F.go || echo BUG*\" \\\n+\t\t\t$test_line] } {\n+\t    # This is a compile test which should fail.\n+\t    set dg-do-what-default \"assemble\"\n+\t    setup_xfail \"*-*-*\"\n+\t    go-dg-runtest $test \"-w $DEFAULT_GOCFLAGS\"\n+\t} elseif { [string match \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ! ./\\$A.out\" \\\n+\t\t\t$test_line] \\\n+\t\t   || [string match \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ! ./\\$A.out || echo BUG: *\" \\\n+\t\t\t$test_line] \\\n+\t\t   || [string match \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && (! ./\\$A.out || echo BUG: *\" \\\n+\t\t\t$test_line] \\\n+\t\t   || ($test_line == \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A &&\"\n+\t\t       && $test_line2 == \"//\t((! sh -c ./\\$A.out) >/dev/null 2>&1 || echo BUG: should fail)\") } {\n+\t    go-execute-xfail $test\n+\t} elseif { [string match \"// errchk \\$G \\$F.go\" $test_line] \\\n+\t\t    || [string match \"// errchk \\$G -e \\$F.go\" $test_line] \\\n+\t\t    || [string match \"// errchk \\$G \\$D/\\$F.go\" $test_line] \\\n+\t\t    || [string match \"//errchk \\$G \\$D/\\$F.go\" $test_line] \\\n+\t\t    || [string match \"// errchk \\$G -e \\$D/\\$F.go\" \\\n+\t\t\t    $test_line] \\\n+\t\t    || [string match \"// ! errchk \\$G \\$D/\\$F.go\" $test_line] \\\n+\t\t    || [string match \"// ! errchk \\$G -e \\$D/\\$F.go\" \\\n+\t\t\t    $test_line] \\\n+\t\t    || [string match \"// errchk \\$G \\$F.go || true\" \\\n+\t\t\t    $test_line] \\\n+\t\t    || [string match \"// errchk \\$G \\$D/\\$F.go || true\" \\\n+\t\t\t    $test_line] \\\n+\t\t    || [string match \"// errchk \\$G -e \\$D/\\$F.go || true\" \\\n+\t\t\t    $test_line] \\\n+\t\t    || [string match \"// errchk \\$G \\$D/\\$F.go || echo BUG*\" \\\n+\t\t\t    $test_line] } {\n+\t    errchk $test\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.dir/bug0.go && \\$G \\$D/\\$F.dir/bug1.go || echo BUG*\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug0.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug1.go\" file2\n+\t    dg-test $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    file delete \"[file rootname [file tail $file1]].o\"\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.dir/bug0.go && errchk \\$G \\$D/\\$F.dir/bug1.go\" \\\n+\t\t\t$test_line] \\\n+\t\t       || [string match \\\n+\t\t\t       \"// \\$G \\$D/\\$F.dir/p1.go && \\$G \\$D/\\$F.dir/p2.go\" \\\n+\t\t\t       $test_line] } {\n+\t    if { [string match \\\n+\t\t      \"// \\$G \\$D/\\$F.dir/p1.go && \\$G \\$D/\\$F.dir/p2.go\" \\\n+\t\t      $test_line] } {\n+\t\tset name1 \"p1.go\"\n+\t\tset name2 \"p2.go\"\n+\t    } else {\n+\t\tset name1 \"bug0.go\"\n+\t\tset name2 \"bug1.go\"\n+\t    }\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/$name1\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/$name2\" file2\n+\t    errchk $file2\n+\t    file delete \"[file rootname [file tail $file1]].o\"\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.dir/bug0.go && (! \\$G \\$D/\\$F.dir/bug1.go || echo BUG*\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug0.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug1.go\" file2\n+\t    setup_xfail \"*-*-*\"\n+\t    dg-test $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    file delete \"[file rootname [file tail $file1]].o\"\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.dir/bug0.go && \\$G \\$D/\\$F.dir/bug1.go && (! \\$G \\$D/\\$F.dir/bug2.go || echo BUG*\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug0.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug1.go\" file2\n+\t    dg-test -keep-output $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug2.go\" file3\n+\t    setup_xfail \"*-*-*\"\n+\t    dg-test $file3 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    file delete \"[file rootname [file tail $file1]].o\"\n+\t    file delete \"[file rootname [file tail $file2]].o\"\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.dir/bug0.go && \\$G \\$D/\\$F.dir/bug1.go && errchk \\$G \\$D/\\$F.dir/bug2.go\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug0.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug1.go\" file2\n+\t    dg-test -keep-output $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug2.go\" file3\n+\t    errchk $file3\n+\t    file delete \"[file rootname [file tail $file1]].o\"\n+\t    file delete \"[file rootname [file tail $file2]].o\"\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/bug160.dir/x.go && \\$G \\$D/bug160.dir/y.go && \\$L y.\\$A && ./\\$A.out\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/x.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile1 \"[file rootname [file tail $file1]].o\"\n+\t    regsub \"\\\\.go$\" $test \".dir/y.go\" file2\n+\t    dg-test -keep-output $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile2 \"[file rootname [file tail $file2]].o\"\n+\t    set dg-do-what-default \"link\"\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    set comp_output [go_target_compile \"$ofile1 $ofile2\" \\\n+\t\t\t\t $output_file \"executable\" \"$DEFAULT_GOCFLAGS\"]\n+\t    set comp_output [go-dg-prune $target_triplet $comp_output]\n+\t    verbose -log $comp_output\n+\t    set result [go_load \"$output_file\" \"\" \"\"]\n+\t    set status [lindex $result 0]\n+\t    $status $name\n+\t    file delete $ofile1 $ofile2 $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/bug191.dir/a.go && \\$G \\$D/bug191.dir/b.go && \\$G \\$D/\\$F.go && \\$L \\$F.\\$A\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/a.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile1 \"[file rootname [file tail $file1]].o\"\n+\t    regsub \"\\\\.go$\" $test \".dir/b.go\" file2\n+\t    dg-test -keep-output $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile2 \"[file rootname [file tail $file2]].o\"\n+\t    dg-test -keep-output \"$test\" \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile3 \"[file rootname [file tail $test]].o\"\n+\t    set dg-do-what-default \"link\"\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    set comp_output [go_target_compile \"$ofile1 $ofile2 $ofile3\" \\\n+\t\t\t\t $output_file \"executable\" \"$DEFAULT_GOCFLAGS\"]\n+\t    set comp_output [go-dg-prune $target_triplet $comp_output]\n+\t    if [string match \"\" $comp_output] {\n+\t\tpass $name\n+\t    } else {\n+\t\tverbose -log $comp_output\n+\t\tfail $name\n+\t    }\n+\t    file delete $ofile1 $ofile2 $ofile3 $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/embed0.go && \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ./\\$A.out\" \\\n+\t\t\t$test_line ] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"/\\[^/\\]*$\" $test \"/embed0.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile1 \"[file rootname [file tail $file1]].o\"\n+\t    dg-test -keep-output $test \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile2 \"[file rootname [file tail $test]].o\"\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    set comp_output [go_target_compile \"$ofile1 $ofile2\" \\\n+\t\t\t\t $output_file \"executable\" \"$DEFAULT_GOCFLAGS\"]\n+\t    set comp_output [go-dg-prune $target_triplet $comp_output]\n+\t    if [string match \"\" $comp_output] {\n+\t\tset result [go_load \"$output_file\" \"\" \"\"]\n+\t\tset status [lindex $result 0]\n+\t\t$status $name\n+\t    } else {\n+\t\tverbose -log $comp_output\n+\t\tfail $name\n+\t    }\n+\t    file delete $ofile1 $ofile2 $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.dir/chanbug.go && \\$G -I. \\$D/\\$F.dir/chanbug2.go\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/chanbug.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/chanbug2.go\" file2\n+\t    dg-test $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    file delete \"[file rootname [file tail $file1]].o\"\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \\\n+\t\t\t\"// (! \\$G \\$D/\\$F.go) | grep 'initialization loop' *\" \\\n+\t\t\t$test_line] } {\n+\t    set dg-do-what-default \"assemble\"\n+\t    setup_xfail \"*-*-*\"\n+\t    go-dg-runtest $test \"-w $DEFAULT_GOCFLAGS\"\n+\t} elseif { [string match \\\n+\t\t\t\"// \\$G \\$D/\\$F.dir/x.go && errchk \\$G \\$D/\\$F.dir/y.go\" \\\n+\t\t\t$test_line] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/x.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    regsub \"\\\\.go$\" $test \".dir/y.go\" file2\n+\t    errchk $file2\n+\t    file delete \"[file rootname [file tail $file1]].o\"\n+\t    set runtests $hold_runtests\n+\t} elseif { [string match \"// true*\" $test_line] } {\n+\t    # Not a real test, just ignore.\n+\t} elseif { $test_line == \"// \\$G \\$D/\\$F.dir/bug0.go &&\" \\\n+\t\t       && $test_line2 == \"// \\$G \\$D/\\$F.dir/bug1.go &&\" \\\n+\t\t       && $test_line3 == \"// \\$G \\$D/\\$F.dir/bug2.go &&\" \\\n+\t\t       && $test_line4 == \"// errchk \\$G -e \\$D/\\$F.dir/bug3.go &&\" \\\n+\t\t       && $test_line5 == \"// \\$L bug2.\\$A &&\" \\\n+\t\t       && [string match \"// ./\\$A.out || echo BUG*\" $test_line6] } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug0.go\" file0\n+\t    dg-test -keep-output $file0 \"-O -fgo-prefix=bug0\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile0 \"[file rootname [file tail $file0]].o\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug1.go\" file1\n+\t    dg-test -keep-output $file1 \"-O -fgo-prefix=bug1\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile1 \"[file rootname [file tail $file1]].o\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug2.go\" file2\n+\t    dg-test -keep-output $file2 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile2 \"[file rootname [file tail $file2]].o\"\n+\t    regsub \"\\\\.go$\" $test \".dir/bug3.go\" file3\n+\t    errchk $file3\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    set comp_output [go_target_compile \"$ofile0 $ofile1 $ofile2\" \\\n+\t\t\t\t $output_file \"executable\" \"$DEFAULT_GOCFLAGS\"]\n+\t    set comp-output [go-dg-prune $target_triplet $comp_output]\n+\t    if [string match \"\" $comp_output] {\n+\t\tset result [go_load \"$output_file\" \"\" \"\"]\n+\t\tset status [lindex $result 0]\n+\t\t$status $name\n+\t    } else {\n+\t\tverbose -log $comp_output\n+\t\tfail $name\n+\t    }\n+\t    file delete $ofile0 $ofile1 $ofile2 $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { $test_line == \"// \\$G \\$D/import2.go && \\$G \\$D/\\$F\\.go\" } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"/\\[^/\\]*$\" $test \"/import2.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile1 \"[file rootname [file tail $file1]].o\"\n+\t    dg-test $test \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    file delete $ofile1\n+\t    set runtests $hold_runtests\n+\t} elseif { $test_line == \"// \\$G \\$D/ddd2.go && \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ./\\$A.out\" } {\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"assemble\"\n+\t    regsub \"/\\[^/\\]*$\" $test \"/ddd2.go\" file1\n+\t    dg-test -keep-output $file1 \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile1 \"[file rootname [file tail $file1]].o\"\n+\t    dg-test -keep-output $test \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set ofile2 \"[file rootname [file tail $test]].o\"\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    set comp_output [go_target_compile \"$ofile1 $ofile2\" \\\n+\t\t\t\t $output_file \"executable\" \"$DEFAULT_GOCFLAGS\"]\n+\t    set comp_output [go-dg-prune $target_triplet $comp_output]\n+\t    if [string match \"\" $comp_output] {\n+\t\tset result [go_load \"$output_file\" \"\" \"\"]\n+\t\tset status [lindex $result 0]\n+\t\t$status $name\n+\t    } else {\n+\t\tverbose -log $comp_output\n+\t\tfail $name\n+\t    }\n+\t    file delete $ofile1 $ofile2 $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { $test_line == \"// \\$G \\$D/\\$F.go \\$D/cmplxdivide1.go && \\$L \\$D/\\$F.\\$A && ./\\$A.out\" } {\n+\t    regsub \"/\\[^/\\]*$\" $test \"/cmplxdivide1.go\" test2\n+\t    set output_file \"./[file rootname [file tail $test]].o\"\n+\t    set comp_output [go_target_compile \"$test $test2\" \\\n+\t\t\t     $output_file \"executable\" \"$DEFAULT_GOCFLAGS\"]\n+\t    set comp_output [go-dg-prune $target_triplet $comp_output]\n+\t    if [string match \"\" $comp_output] {\n+\t\tset result [go_load \"$output_file\" \"\" \"\"]\n+\t\tset status [lindex $result 0]\n+\t\t$status $name\n+\t    } else {\n+\t\tverbose -log $comp_output\n+\t\tfail $name\n+\t    }\n+\t    file delete $output_file\n+\t} elseif { $test_line == \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A &&\" \\\n+\t\t       && $test_line2 == \"// ./\\$A.out -pass 0 >tmp.go && \\$G tmp.go && \\$L -o tmp1.\\$A tmp.\\$A && ./tmp1.\\$A &&\" \\\n+\t\t       && $test_line3 == \"// ./\\$A.out -pass 1 >tmp.go && errchk \\$G -e tmp.go &&\" \\\n+\t\t       && $test_line4 == \"// ./\\$A.out -pass 2 >tmp.go && errchk \\$G -e tmp.go\" } {\n+\t    set go_execute_args \"\"\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"link\"\n+\t    dg-test -keep-output $test \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    if [isnative] {\n+\t\tif { [catch \"exec $output_file -pass 0 >tmp.go\"] != 0 } {\n+\t\t    fail \"$name execution 0\"\n+\t\t} else {\n+\t\t    pass \"$name execution 0\"\n+\t\t    file delete tmp.x\n+\t\t    go-torture-execute \"./tmp.go\"\n+\t\t}\n+\t\tif { [catch \"exec $output_file -pass 1 >tmp.go\"] != 0 } {\n+\t\t    fail \"$name execution 1\"\n+\t\t} else {\n+\t\t    pass \"$name execution 1\"\n+\t\t    errchk tmp.go\n+\t\t}\n+\t\tif { [catch \"exec $output_file -pass 2 >tmp.go\"] != 0 } {\n+\t\t    fail \"$name execution 2\"\n+\t\t} else {\n+\t\t    pass \"$name execution 2\"\n+\t\t    errchk tmp.go\n+\t\t}\n+\t\tfile delete tmp.go\n+\t    }\n+\t    file delete $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { $test_line == \"// \\$G \\$D/\\$F.go && \\$L \\$F.\\$A && ./\\$A.out >tmp.go &&\" \\\n+\t\t\t&& $test_line2 == \"// errchk \\$G -e tmp.go\" } {\n+\t    set go_execute_args \"\"\n+\t    set hold_runtests $runtests\n+\t    set runtests \"go-test.exp\"\n+\t    set dg-do-what-default \"link\"\n+\t    dg-test -keep-output $test \"-O\" \"-w $DEFAULT_GOCFLAGS\"\n+\t    set output_file \"./[file rootname [file tail $test]].exe\"\n+\t    if [isnative] {\n+\t\tif { [catch \"exec $output_file >tmp.go\"] != 0 } {\n+\t\t    fail \"$name execution\"\n+\t\t} else {\n+\t\t    pass \"$name execution\"\n+\t\t    file delete tmp.x\n+\t\t    errchk tmp.go\n+\t\t}\n+\t    }\n+\t    file delete $output_file\n+\t    set runtests $hold_runtests\n+\t} elseif { $test_line == \"// # generated by cmplxdivide.c\" } {\n+\t    # Ignore.\n+\t} elseif { $test_line == \"// \\$G \\$D/bug302.dir/p.go && gopack grc pp.a p.\\$A && \\$G \\$D/bug302.dir/main.go\" \\\n+\t\t   || $test_line == \"// \\$G \\$D/empty.go && errchk \\$G \\$D/\\$F.go\" } {\n+\t    # These tests import the same package under two different\n+\t    # names, which gccgo does not support.\n+\t} elseif { $test_line == \"// \\$G -S \\$D/\\$F.go | egrep initdone >/dev/null && echo FAIL || true\" } {\n+\t    # This tests whether initializers are written out\n+\t    # statically.  gccgo does not provide a way to test that,\n+\t    # as an initializer will be generated for any code which\n+\t    # has global variables which need to be registered as GC\n+\t    # roots.\n+\t} else {\n+\t    clone_output \"$name: unrecognized test line: $test_line\"\n+\t    unsupported $name\n+\t}\n+\n+\tset go_execute_args \"\"\n+    }\n+\n+    set dg-do-what-default ${saved-dg-do-what-default}\n+    set TORTURE_OPTIONS $saved_torture_options\n+}\n+\n+go-gc-tests"}, {"sha": "03143a60d83fef499ccc34dd798cc7aecdb9e870", "filename": "gcc/testsuite/go.test/test/235.go", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2F235.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2F235.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2F235.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,72 @@\n+// $G $F.go && $L $F.$A && ./$A.out\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+type T chan uint64\n+\n+func M(f uint64) (in, out T) {\n+\tin = make(T, 100)\n+\tout = make(T, 100)\n+\tgo func(in, out T, f uint64) {\n+\t\tfor {\n+\t\t\tout <- f*<-in\n+\t\t}\n+\t}(in, out, f)\n+\treturn in, out\n+}\n+\n+\n+func min(xs []uint64) uint64 {\n+\tm := xs[0]\n+\tfor i := 1; i < len(xs); i++ {\n+\t\tif xs[i] < m {\n+\t\t\tm = xs[i]\n+\t\t}\n+\t}\n+\treturn m\n+}\n+\n+\n+func main() {\n+\tF := []uint64{2, 3, 5}\n+\tvar n = len(F)\n+\tOUT := []uint64{\n+\t\t2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36,\n+\t\t40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125,\n+\t\t128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250,\n+\t\t256, 270, 288, 300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480,\n+\t\t486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768,\n+\t\t800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215,\n+\t\t1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536, 1600}\n+\n+\tx := uint64(1)\n+\tins := make([]T, n)\n+\touts := make([]T, n)\n+\txs := make([]uint64, n)\n+\tfor i := 0; i < n; i++ {\n+\t\tins[i], outs[i] = M(F[i])\n+\t\txs[i] = x\n+\t}\n+\n+\tfor i := 0; i < len(OUT); i++ {\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tins[i] <- x\n+\t\t}\n+\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tif xs[i] == x {\n+\t\t\t\txs[i] = <-outs[i]\n+\t\t\t}\n+\t\t}\n+\n+\t\tx = min(xs)\n+\t\tif x != OUT[i] {\n+\t\t\tprintln(\"bad: \", x, \" should be \", OUT[i])\n+\t\t\tpanic(\"235\")\n+\t\t}\n+\t}\n+}"}, {"sha": "9e91a97fd5781b1fced3388844f50c1e0e7c16c1", "filename": "gcc/testsuite/go.test/test/64bit.go", "status": "added", "additions": 709, "deletions": 0, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2F64bit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2F64bit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2F64bit.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,709 @@\n+// $G $D/$F.go && $L $F.$A && ./$A.out >tmp.go &&\n+// $G tmp.go && $L tmp.$A && ./$A.out || echo BUG: 64bit\n+// rm -f tmp.go\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Generate test of 64-bit arithmetic.\n+// Most synthesized routines have different cases for\n+// constants vs variables and even the generated code has\n+// different cases for large and small constants,\n+// so try a good range of inputs.\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var bout *bufio.Writer\n+\n+// 64-bit math without using 64-bit numbers,\n+// so that we can generate the test program even\n+// if the compiler has buggy or missing 64-bit support.\n+\n+type Uint64 struct {\n+\thi\tuint32\n+\tlo\tuint32\n+}\n+\n+type Int64 struct {\n+\thi\tint32\n+\tlo\tuint32\n+}\n+\n+func (a Uint64) Int64() (c Int64) {\n+\tc.hi = int32(a.hi)\n+\tc.lo = a.lo\n+\treturn\n+}\n+\n+func (a Uint64) Cmp(b Uint64) int {\n+\tswitch {\n+\tcase a.hi < b.hi:\n+\t\treturn -1\n+\tcase a.hi > b.hi:\n+\t\treturn 1\n+\tcase a.lo < b.lo:\n+\t\treturn -1\n+\tcase a.lo > b.lo:\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+func (a Uint64) LeftShift(b uint) (c Uint64) {\n+\tswitch {\n+\tcase b >= 64:\n+\t\tc.hi = 0\n+\t\tc.lo = 0\n+\tcase b >= 32:\n+\t\tc.hi = a.lo << (b - 32)\n+\t\tc.lo = 0\n+\tdefault:\n+\t\tc.hi = a.hi<<b | a.lo>>(32-b)\n+\t\tc.lo = a.lo << b\n+\t}\n+\treturn\n+}\n+\n+func (a Uint64) RightShift(b uint) (c Uint64) {\n+\tswitch {\n+\tcase b >= 64:\n+\t\tc.hi = 0\n+\t\tc.lo = a.hi\n+\tcase b >= 32:\n+\t\tc.hi = 0\n+\t\tc.lo = a.hi >> (b - 32)\n+\tdefault:\n+\t\tc.hi = a.hi >> b\n+\t\tc.lo = a.hi<<(32-b) | a.lo>>b\n+\t}\n+\treturn\n+}\n+\n+func (a Uint64) LeftShift64(b Uint64) (c Uint64) {\n+\tif b.hi != 0 || b.lo >= 64 {\n+\t\treturn\n+\t}\n+\treturn a.LeftShift(uint(b.lo))\n+}\n+\n+func (a Uint64) RightShift64(b Uint64) (c Uint64) {\n+\tif b.hi != 0 || b.lo >= 64 {\n+\t\treturn\n+\t}\n+\treturn a.RightShift(uint(b.lo))\n+}\n+\n+func (a Uint64) Plus(b Uint64) (c Uint64) {\n+\tvar carry uint32\n+\tif c.lo = a.lo + b.lo; c.lo < a.lo {\n+\t\tcarry = 1\n+\t}\n+\tc.hi = a.hi + b.hi + carry\n+\treturn\n+}\n+\n+func (a Uint64) Minus(b Uint64) (c Uint64) {\n+\tvar borrow uint32\n+\tif c.lo = a.lo - b.lo; c.lo > a.lo {\n+\t\tborrow = 1\n+\t}\n+\tc.hi = a.hi - b.hi - borrow\n+\treturn\n+}\n+\n+func (a Uint64) Neg() (c Uint64) {\n+\tvar zero Uint64\n+\treturn zero.Minus(a)\n+}\n+\n+func (a Uint64) Com() (c Uint64) {\n+\tc.hi = ^a.hi\n+\tc.lo = ^a.lo\n+\treturn\n+}\n+\n+func (a Uint64) Len() int {\n+\tswitch {\n+\tcase a.hi != 0:\n+\t\tfor i := 31; i >= 0; i-- {\n+\t\t\tif a.hi&(1<<uint(i)) != 0 {\n+\t\t\t\treturn i + 1 + 32\n+\t\t\t}\n+\t\t}\n+\tcase a.lo != 0:\n+\t\tfor i := 31; i >= 0; i-- {\n+\t\t\tif a.lo&(1<<uint(i)) != 0 {\n+\t\t\t\treturn i + 1\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+func (a Uint64) HasBit(b uint) bool {\n+\tswitch {\n+\tcase b >= 64:\n+\t\treturn false\n+\tcase b >= 32:\n+\t\treturn a.hi&(1<<(b-32)) != 0\n+\t}\n+\treturn a.lo&(1<<b) != 0\n+}\n+\n+func (a Uint64) Times(b Uint64) (c Uint64) {\n+\tfor i := uint(0); i < 64; i++ {\n+\t\tif b.HasBit(i) {\n+\t\t\tc = c.Plus(a.LeftShift(i))\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func (a Uint64) DivMod(b Uint64) (quo, rem Uint64) {\n+\tn := a.Len() - b.Len()\n+\tif n >= 0 {\n+\t\tb = b.LeftShift(uint(n))\n+\t\tfor i := 0; i <= n; i++ {\n+\t\t\tquo = quo.LeftShift(1)\n+\t\t\tif b.Cmp(a) <= 0 {\t// b <= a\n+\t\t\t\tquo.lo |= 1\n+\t\t\t\ta = a.Minus(b)\n+\t\t\t}\n+\t\t\tb = b.RightShift(1)\n+\t\t}\n+\t}\n+\trem = a\n+\treturn\n+}\n+\n+func (a Uint64) And(b Uint64) (c Uint64) {\n+\tc.hi = a.hi & b.hi\n+\tc.lo = a.lo & b.lo\n+\treturn\n+}\n+\n+func (a Uint64) AndNot(b Uint64) (c Uint64) {\n+\tc.hi = a.hi &^ b.hi\n+\tc.lo = a.lo &^ b.lo\n+\treturn\n+}\n+\n+func (a Uint64) Or(b Uint64) (c Uint64) {\n+\tc.hi = a.hi | b.hi\n+\tc.lo = a.lo | b.lo\n+\treturn\n+}\n+\n+func (a Uint64) Xor(b Uint64) (c Uint64) {\n+\tc.hi = a.hi ^ b.hi\n+\tc.lo = a.lo ^ b.lo\n+\treturn\n+}\n+\n+func (a Uint64) String() string\t{ return fmt.Sprintf(\"%#x%08x\", a.hi, a.lo) }\n+\n+func (a Int64) Uint64() (c Uint64) {\n+\tc.hi = uint32(a.hi)\n+\tc.lo = a.lo\n+\treturn\n+}\n+\n+func (a Int64) Cmp(b Int64) int {\n+\t// Same body as Uint64.Cmp,\n+\t// but behaves differently\n+\t// because hi is uint32 not int32.\n+\tswitch {\n+\tcase a.hi < b.hi:\n+\t\treturn -1\n+\tcase a.hi > b.hi:\n+\t\treturn 1\n+\tcase a.lo < b.lo:\n+\t\treturn -1\n+\tcase a.lo > b.lo:\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+func (a Int64) LeftShift(b uint) (c Int64)\t{ return a.Uint64().LeftShift(b).Int64() }\n+\n+func (a Int64) RightShift(b uint) (c Int64) {\n+\tswitch {\n+\tcase b >= 64:\n+\t\tc.hi = a.hi >> 31\t// sign extend\n+\t\tc.lo = uint32(c.hi)\n+\tcase b >= 32:\n+\t\tc.hi = a.hi >> 31\t// sign extend\n+\t\tc.lo = uint32(a.hi >> (b - 32))\n+\tdefault:\n+\t\tc.hi = a.hi >> b\n+\t\tc.lo = uint32(a.hi<<(32-b)) | a.lo>>b\n+\t}\n+\treturn\n+}\n+\n+func (a Int64) LeftShift64(b Uint64) (c Int64) {\n+\tif b.hi != 0 || b.lo >= 64 {\n+\t\treturn\n+\t}\n+\treturn a.LeftShift(uint(b.lo))\n+}\n+\n+func (a Int64) RightShift64(b Uint64) (c Int64) {\n+\tif b.hi != 0 || b.lo >= 64 {\n+\t\treturn a.RightShift(64)\n+\t}\n+\treturn a.RightShift(uint(b.lo))\n+}\n+\n+func (a Int64) Plus(b Int64) (c Int64)\t{ return a.Uint64().Plus(b.Uint64()).Int64() }\n+\n+func (a Int64) Minus(b Int64) (c Int64)\t{ return a.Uint64().Minus(b.Uint64()).Int64() }\n+\n+func (a Int64) Neg() (c Int64)\t{ return a.Uint64().Neg().Int64() }\n+\n+func (a Int64) Com() (c Int64)\t{ return a.Uint64().Com().Int64() }\n+\n+func (a Int64) Times(b Int64) (c Int64)\t{ return a.Uint64().Times(b.Uint64()).Int64() }\n+\n+func (a Int64) DivMod(b Int64) (quo Int64, rem Int64) {\n+\tvar zero Int64\n+\n+\tquoSign := +1\n+\tremSign := +1\n+\tif a.Cmp(zero) < 0 {\n+\t\tquoSign = -1\n+\t\tremSign = -1\n+\t\ta = a.Neg()\n+\t}\n+\tif b.Cmp(zero) < 0 {\n+\t\tquoSign = -quoSign\n+\t\tb = b.Neg()\n+\t}\n+\n+\tq, r := a.Uint64().DivMod(b.Uint64())\n+\tquo = q.Int64()\n+\trem = r.Int64()\n+\n+\tif quoSign < 0 {\n+\t\tquo = quo.Neg()\n+\t}\n+\tif remSign < 0 {\n+\t\trem = rem.Neg()\n+\t}\n+\treturn\n+}\n+\n+func (a Int64) And(b Int64) (c Int64)\t{ return a.Uint64().And(b.Uint64()).Int64() }\n+\n+func (a Int64) AndNot(b Int64) (c Int64)\t{ return a.Uint64().AndNot(b.Uint64()).Int64() }\n+\n+func (a Int64) Or(b Int64) (c Int64)\t{ return a.Uint64().Or(b.Uint64()).Int64() }\n+\n+func (a Int64) Xor(b Int64) (c Int64)\t{ return a.Uint64().Xor(b.Uint64()).Int64() }\n+\n+func (a Int64) String() string {\n+\tif a.hi < 0 {\n+\t\treturn fmt.Sprintf(\"-%s\", a.Neg().Uint64())\n+\t}\n+\treturn a.Uint64().String()\n+}\n+\n+var int64Values = []Int64{\n+\tInt64{0, 0},\n+\tInt64{0, 1},\n+\tInt64{0, 2},\n+\tInt64{0, 3},\n+\tInt64{0, 100},\n+\tInt64{0, 10001},\n+\tInt64{0, 1<<31 - 1},\n+\tInt64{0, 1 << 31},\n+\tInt64{0, 1<<31 + 1},\n+\tInt64{0, 1<<32 - 1<<30},\n+\tInt64{0, 1<<32 - 1},\n+\tInt64{1, 0},\n+\tInt64{1, 1},\n+\tInt64{2, 0},\n+\tInt64{1<<31 - 1, 1<<32 - 10000},\n+\tInt64{1<<31 - 1, 1<<32 - 1},\n+\tInt64{0x789abcde, 0xf0123456},\n+\n+\tInt64{-1, 1<<32 - 1},\n+\tInt64{-1, 1<<32 - 2},\n+\tInt64{-1, 1<<32 - 3},\n+\tInt64{-1, 1<<32 - 100},\n+\tInt64{-1, 1<<32 - 10001},\n+\tInt64{-1, 1<<32 - (1<<31 - 1)},\n+\tInt64{-1, 1<<32 - 1<<31},\n+\tInt64{-1, 1<<32 - (1<<31 + 1)},\n+\tInt64{-1, 1<<32 - (1<<32 - 1<<30)},\n+\tInt64{-1, 0},\n+\tInt64{-1, 1},\n+\tInt64{-2, 0},\n+\tInt64{-(1 << 31), 10000},\n+\tInt64{-(1 << 31), 1},\n+\tInt64{-(1 << 31), 0},\n+\tInt64{-0x789abcde, 0xf0123456},\n+}\n+\n+var uint64Values = []Uint64{\n+\tUint64{0, 0},\n+\tUint64{0, 1},\n+\tUint64{0, 2},\n+\tUint64{0, 3},\n+\tUint64{0, 100},\n+\tUint64{0, 10001},\n+\tUint64{0, 1<<31 - 1},\n+\tUint64{0, 1 << 31},\n+\tUint64{0, 1<<31 + 1},\n+\tUint64{0, 1<<32 - 1<<30},\n+\tUint64{0, 1<<32 - 1},\n+\tUint64{1, 0},\n+\tUint64{1, 1},\n+\tUint64{2, 0},\n+\tUint64{1<<31 - 1, 1<<32 - 10000},\n+\tUint64{1<<31 - 1, 1<<32 - 1},\n+\tUint64{1<<32 - 1<<30, 0},\n+\tUint64{1<<32 - 1, 0},\n+\tUint64{1<<32 - 1, 1<<32 - 100},\n+\tUint64{1<<32 - 1, 1<<32 - 1},\n+\tUint64{0x789abcde, 0xf0123456},\n+\tUint64{0xfedcba98, 0x76543210},\n+}\n+\n+var shiftValues = []Uint64{\n+\tUint64{0, 0},\n+\tUint64{0, 1},\n+\tUint64{0, 2},\n+\tUint64{0, 3},\n+\tUint64{0, 15},\n+\tUint64{0, 16},\n+\tUint64{0, 17},\n+\tUint64{0, 31},\n+\tUint64{0, 32},\n+\tUint64{0, 33},\n+\tUint64{0, 61},\n+\tUint64{0, 62},\n+\tUint64{0, 63},\n+\tUint64{0, 64},\n+\tUint64{0, 65},\n+\tUint64{0, 1<<32 - 1},\n+\tUint64{1, 0},\n+\tUint64{1, 1},\n+\tUint64{1 << 28, 0},\n+\tUint64{1 << 31, 0},\n+\tUint64{1<<32 - 1, 0},\n+\tUint64{1<<32 - 1, 1<<32 - 1},\n+}\n+\n+var ntest = 0\n+\n+// Part 1 is tests of variable operations; generic functions\n+// called by repetitive code.  Could make a table but not worth it.\n+\n+const prolog = \"\\n\" +\n+\t\"package main\\n\" +\n+\t\"\\n\" +\n+\t\"import \\\"os\\\"\\n\" +\n+\t\"\\n\" +\n+\t\"var ok = true\\n\" +\n+\t\"\\n\" +\n+\t\"func testInt64Unary(a, plus, xor, minus int64) {\\n\" +\n+\t\"\tif n, op, want := +a, `+`, plus; n != want { ok=false; println(`int64`, op, a, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := ^a, `^`, xor; n != want { ok=false; println(`int64`, op, a, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := -a, `-`, minus; n != want { ok=false; println(`int64`, op, a, `=`, n, `should be`, want); }\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\" +\n+\t\"func testInt64Binary(a, b, add, sub, mul, div, mod, and, or, xor, andnot int64, dodiv bool) {\\n\" +\n+\t\"\tif n, op, want := a + b, `+`, add; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a - b, `-`, sub; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a * b, `*`, mul; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif dodiv {\\n\" +\n+\t\"\t\tif n, op, want := a / b, `/`, div; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, want := a % b, `%`, mod; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif n, op, want := a & b, `&`, and; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a | b, `|`, or; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(`int64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\" +\n+\t\"func testInt64Shift(a int64, b uint64, left, right int64) {\\n\" +\n+\t\"\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif uint64(uint(b)) == b {\\n\" +\n+\t\"\t\tb := uint(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif uint64(uint32(b)) == b {\\n\" +\n+\t\"\t\tb := uint32(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif uint64(uint16(b)) == b {\\n\" +\n+\t\"\t\tb := uint16(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif uint64(uint8(b)) == b {\\n\" +\n+\t\"\t\tb := uint8(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`int64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`int64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\" +\n+\t\"func testUint64Unary(a, plus, xor, minus uint64) {\\n\" +\n+\t\"\tif n, op, want := +a, `+`, plus; n != want { ok=false; println(`uint64`, op, a, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := ^a, `^`, xor; n != want { ok=false; println(`uint64`, op, a, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := -a, `-`, minus; n != want { ok=false; println(`uint64`, op, a, `=`, n, `should be`, want); }\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\" +\n+\t\"func testUint64Binary(a, b, add, sub, mul, div, mod, and, or, xor, andnot uint64, dodiv bool) {\\n\" +\n+\t\"\tif n, op, want := a + b, `+`, add; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a - b, `-`, sub; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a * b, `*`, mul; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif dodiv {\\n\" +\n+\t\"\t\tif n, op, want := a / b, `/`, div; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, want := a % b, `%`, mod; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif n, op, want := a & b, `&`, and; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a | b, `|`, or; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(`uint64`, a, op, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\" +\n+\t\"func testUint64Shift(a, b, left, right uint64) {\\n\" +\n+\t\"\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint64`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif uint64(uint(b)) == b {\\n\" +\n+\t\"\t\tb := uint(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif uint64(uint32(b)) == b {\\n\" +\n+\t\"\t\tb := uint32(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint32`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif uint64(uint16(b)) == b {\\n\" +\n+\t\"\t\tb := uint16(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint16`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif uint64(uint8(b)) == b {\\n\" +\n+\t\"\t\tb := uint8(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(`uint64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(`uint64`, a, op, `uint8`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\"\n+\n+func varTests() {\n+\tfmt.Fprint(bout, prolog)\n+\tfor _, a := range int64Values {\n+\t\tfmt.Fprintf(bout, \"func test%v() {\\n\", ntest)\n+\t\tntest++\n+\t\tfmt.Fprintf(bout, \"\\ttestInt64Unary(%v, %v, %v, %v);\\n\", a, a, a.Com(), a.Neg())\n+\t\tfor _, b := range int64Values {\n+\t\t\tvar div, mod Int64\n+\t\t\tdodiv := false\n+\t\t\tvar zero Int64\n+\t\t\tif b.Cmp(zero) != 0 {\t// b != 0\n+\t\t\t\t// Can't divide by zero but also can't divide -0x8000...000 by -1.\n+\t\t\t\tvar bigneg = Int64{-0x80000000, 0}\n+\t\t\t\tvar minus1 = Int64{-1, ^uint32(0)}\n+\t\t\t\tif a.Cmp(bigneg) != 0 || b.Cmp(minus1) != 0 {\t// a != -1<<63 || b != -1\n+\t\t\t\t\tdiv, mod = a.DivMod(b)\n+\t\t\t\t\tdodiv = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintf(bout, \"\\ttestInt64Binary(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\\n\",\n+\t\t\t\ta, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,\n+\t\t\t\ta.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)\n+\t\t}\n+\t\tfor _, b := range shiftValues {\n+\t\t\tfmt.Fprintf(bout, \"\\ttestInt64Shift(%v, %v, %v, %v);\\n\",\n+\t\t\t\ta, b, a.LeftShift64(b), a.RightShift64(b))\n+\t\t}\n+\t\tfmt.Fprintf(bout, \"}\\n\")\n+\t}\n+\n+\tfor _, a := range uint64Values {\n+\t\tfmt.Fprintf(bout, \"func test%v() {\\n\", ntest)\n+\t\tntest++\n+\t\tfmt.Fprintf(bout, \"\\ttestUint64Unary(%v, %v, %v, %v);\\n\", a, a, a.Com(), a.Neg())\n+\t\tfor _, b := range uint64Values {\n+\t\t\tvar div, mod Uint64\n+\t\t\tdodiv := false\n+\t\t\tvar zero Uint64\n+\t\t\tif b.Cmp(zero) != 0 {\t// b != 0\n+\t\t\t\tdiv, mod = a.DivMod(b)\n+\t\t\t\tdodiv = true\n+\t\t\t}\n+\t\t\tfmt.Fprintf(bout, \"\\ttestUint64Binary(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\\n\",\n+\t\t\t\ta, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,\n+\t\t\t\ta.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)\n+\t\t}\n+\t\tfor _, b := range shiftValues {\n+\t\t\tfmt.Fprintf(bout, \"\\ttestUint64Shift(%v, %v, %v, %v);\\n\",\n+\t\t\t\ta, b, a.LeftShift64(b), a.RightShift64(b))\n+\t\t}\n+\t\tfmt.Fprintf(bout, \"}\\n\")\n+\t}\n+}\n+\n+// Part 2 is tests of operations involving one variable and one constant.\n+\n+const binaryConstL = \"func test%vBinaryL%v(b, add, sub, mul, div, mod, and, or, xor, andnot %v, dodiv bool) {\\n\" +\n+\t\"\tconst a %v = %v;\\n\" +\n+\t\"\tconst typ = `%s`;\\n\" +\n+\t\"\tif n, op, want := a + b, `+`, add; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a - b, `-`, sub; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a * b, `*`, mul; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif dodiv {\\n\" +\n+\t\"\t\tif n, op, want := a / b, `/`, div; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, want := a %% b, `%%`, mod; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif n, op, want := a & b, `&`, and; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a | b, `|`, or; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(typ, `const`, a, op, `var`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\"\n+\n+const binaryConstR = \"func test%vBinaryR%v(a, add, sub, mul, div, mod, and, or, xor, andnot %v, dodiv bool) {\\n\" +\n+\t\"\tconst b %v = %v;\\n\" +\n+\t\"\tconst typ = `%s`;\\n\" +\n+\t\"\tif n, op, want := a + b, `+`, add; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a - b, `-`, sub; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a * b, `*`, mul; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif dodiv {\\n\" +\n+\t\"\t\tif n, op, want := a / b, `/`, div; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, want := a %% b, `%%`, mod; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"\tif n, op, want := a & b, `&`, and; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a | b, `|`, or; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a ^ b, `^`, xor; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, want := a &^ b, `&^`, andnot; n != want { ok=false; println(typ, `var`, a, op, `const`, b, `=`, n, `should be`, want); }\\n\" +\n+\t\"}\\n\" +\n+\t\"\\n\"\n+\n+const shiftConstL = \"func test%vShiftL%v(b uint64, left, right %v) {\\n\" +\n+\t\"\tconst a %v = %v;\\n\" +\n+\t\"\tconst typ = `%s`;\\n\" +\n+\t\"\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif uint64(uint32(b)) == b {\\n\" +\n+\t\"\t\tb := uint32(b);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `const`, a, op, `var`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"}\\n\"\n+\n+const shiftConstR = \"func test%vShiftR%v(a, left, right %v) {\\n\" +\n+\t\"\tconst b uint64 = %v;\\n\" +\n+\t\"\tconst typ = `%s`;\\n\" +\n+\t\"\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\tif b & 0xffffffff == b {\\n\" +\n+\t\"\t\tconst b = uint32(b & 0xffffffff);\\n\" +\n+\t\"\t\tif n, op, s, want := a << b, `<<`, b, left; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t\tif n, op, s, want := a >> b, `>>`, b, right; n != want { ok=false; println(typ, `var`, a, op, `const`, s, `=`, n, `should be`, want); }\\n\" +\n+\t\"\t}\\n\" +\n+\t\"}\\n\"\n+\n+func constTests() {\n+\tfor i, a := range int64Values {\n+\t\tfmt.Fprintf(bout, binaryConstL, \"Int64\", i, \"int64\", \"int64\", a, \"int64\")\n+\t\tfmt.Fprintf(bout, binaryConstR, \"Int64\", i, \"int64\", \"int64\", a, \"int64\")\n+\t\tfmt.Fprintf(bout, shiftConstL, \"Int64\", i, \"int64\", \"int64\", a, \"int64\")\n+\t}\n+\tfor i, a := range uint64Values {\n+\t\tfmt.Fprintf(bout, binaryConstL, \"Uint64\", i, \"uint64\", \"uint64\", a, \"uint64\")\n+\t\tfmt.Fprintf(bout, binaryConstR, \"Uint64\", i, \"uint64\", \"uint64\", a, \"uint64\")\n+\t\tfmt.Fprintf(bout, shiftConstL, \"Uint64\", i, \"uint64\", \"uint64\", a, \"uint64\")\n+\t}\n+\tfor i, a := range shiftValues {\n+\t\tfmt.Fprintf(bout, shiftConstR, \"Int64\", i, \"int64\", a, \"int64\")\n+\t\tfmt.Fprintf(bout, shiftConstR, \"Uint64\", i, \"uint64\", a, \"uint64\")\n+\t}\n+\tfor i, a := range int64Values {\n+\t\tfmt.Fprintf(bout, \"func test%v() {\\n\", ntest)\n+\t\tntest++\n+\t\tfor j, b := range int64Values {\n+\t\t\tvar div, mod Int64\n+\t\t\tdodiv := false\n+\t\t\tvar zero Int64\n+\t\t\tif b.Cmp(zero) != 0 {\t// b != 0\n+\t\t\t\t// Can't divide by zero but also can't divide -0x8000...000 by -1.\n+\t\t\t\tvar bigneg = Int64{-0x80000000, 0}\n+\t\t\t\tvar minus1 = Int64{-1, ^uint32(0)}\n+\t\t\t\tif a.Cmp(bigneg) != 0 || b.Cmp(minus1) != 0 {\t// a != -1<<63 || b != -1\n+\t\t\t\t\tdiv, mod = a.DivMod(b)\n+\t\t\t\t\tdodiv = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintf(bout, \"\\ttestInt64BinaryL%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\\n\",\n+\t\t\t\ti, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,\n+\t\t\t\ta.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)\n+\t\t\tfmt.Fprintf(bout, \"\\ttestInt64BinaryR%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\\n\",\n+\t\t\t\tj, a, a.Plus(b), a.Minus(b), a.Times(b), div, mod,\n+\t\t\t\ta.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)\n+\t\t}\n+\t\tfor j, b := range shiftValues {\n+\t\t\tfmt.Fprintf(bout, \"\\ttestInt64ShiftL%v(%v, %v, %v);\\n\",\n+\t\t\t\ti, b, a.LeftShift64(b), a.RightShift64(b))\n+\t\t\tfmt.Fprintf(bout, \"\\ttestInt64ShiftR%v(%v, %v, %v);\\n\",\n+\t\t\t\tj, a, a.LeftShift64(b), a.RightShift64(b))\n+\t\t}\n+\t\tfmt.Fprintf(bout, \"}\\n\")\n+\t}\n+\tfor i, a := range uint64Values {\n+\t\tfmt.Fprintf(bout, \"func test%v() {\\n\", ntest)\n+\t\tntest++\n+\t\tfor j, b := range uint64Values {\n+\t\t\tvar div, mod Uint64\n+\t\t\tdodiv := false\n+\t\t\tvar zero Uint64\n+\t\t\tif b.Cmp(zero) != 0 {\t// b != 0\n+\t\t\t\tdiv, mod = a.DivMod(b)\n+\t\t\t\tdodiv = true\n+\t\t\t}\n+\t\t\tfmt.Fprintf(bout, \"\\ttestUint64BinaryL%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\\n\",\n+\t\t\t\ti, b, a.Plus(b), a.Minus(b), a.Times(b), div, mod,\n+\t\t\t\ta.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)\n+\t\t\tfmt.Fprintf(bout, \"\\ttestUint64BinaryR%v(%v, %v, %v, %v, %v, %v, %v, %v, %v, %v, %v);\\n\",\n+\t\t\t\tj, a, a.Plus(b), a.Minus(b), a.Times(b), div, mod,\n+\t\t\t\ta.And(b), a.Or(b), a.Xor(b), a.AndNot(b), dodiv)\n+\t\t}\n+\t\tfor j, b := range shiftValues {\n+\t\t\tfmt.Fprintf(bout, \"\\ttestUint64ShiftL%v(%v, %v, %v);\\n\",\n+\t\t\t\ti, b, a.LeftShift64(b), a.RightShift64(b))\n+\t\t\tfmt.Fprintf(bout, \"\\ttestUint64ShiftR%v(%v, %v, %v);\\n\",\n+\t\t\t\tj, a, a.LeftShift64(b), a.RightShift64(b))\n+\t\t}\n+\t\tfmt.Fprintf(bout, \"}\\n\")\n+\t}\n+}\n+\n+func main() {\n+\tbout = bufio.NewWriter(os.Stdout)\n+\tvarTests()\n+\tconstTests()\n+\n+\tfmt.Fprintf(bout, \"func main() {\\n\")\n+\tfor i := 0; i < ntest; i++ {\n+\t\tfmt.Fprintf(bout, \"\\ttest%v();\\n\", i)\n+\t}\n+\tfmt.Fprintf(bout, \"\\tif !ok { os.Exit(1) }\\n\")\n+\tfmt.Fprintf(bout, \"}\\n\")\n+\tbout.Flush()\n+}"}, {"sha": "446110fecb3ae49ec0f6aa0e6fac6e20b4d4e6cb", "filename": "gcc/testsuite/go.test/test/README.gcc", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2FREADME.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2FREADME.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2FREADME.gcc?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,7 @@\n+This directory is an exact copy (except for this file) of the Go\n+testsuite from the test subdirectory of http://code.google.com/p/go.\n+This is here so that we run the same tests as the gc Go compiler.  We\n+do not, however, run the tests in the same way.  The gc compiler uses\n+the run shell script in this directory.  For gccgo, we use the file\n+go-test.exp in the parent directory to run the tests in gcc's usual\n+DejaGNU test harness."}, {"sha": "ba9a377a6f8e228bffb47fa7a7b25cbe81bf16f0", "filename": "gcc/testsuite/go.test/test/args.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fargs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fargs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fargs.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,21 @@\n+// $G $F.go && $L $F.$A && ./$A.out arg1 arg2\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"os\"\n+\n+func main() {\n+\tif len(os.Args) != 3 {\n+\t\tpanic(\"argc\")\n+\t}\n+\tif os.Args[1] != \"arg1\" {\n+\t\tpanic(\"arg1\")\n+\t}\n+\tif os.Args[2] != \"arg2\" {\n+\t\tpanic(\"arg2\")\n+\t}\n+}"}, {"sha": "2c7230f100a01569a633ad3ccee74b8da5e97ee7", "filename": "gcc/testsuite/go.test/test/arm-pass.txt", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Farm-pass.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Farm-pass.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Farm-pass.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,488 @@\n+./235.go\n+# ./64bit.go\t# fail, flaky on android build\n+./args.go\n+./assign.go\n+./assign1.go\n+./bigalg.go\n+./bigmap.go\n+./blank.go\n+./blank1.go\n+./chancap.go\n+./char_lit.go\n+./char_lit1.go\n+./closedchan.go\n+./closure.go\n+./cmp1.go\n+./cmp2.go\n+./cmp3.go\n+./cmp4.go\n+./cmp5.go\n+./cmplx.go\n+# ./cmplxdivide.go\t# fail, BUG\n+./cmplxdivide1.go\n+./complit.go\n+./compos.go\n+./const.go\n+./const1.go\n+./const2.go\n+./const3.go\n+./convert.go\n+./convert3.go\n+./convlit.go\n+./convlit1.go\n+./copy.go\n+./ddd.go\n+./ddd1.go\n+./ddd2.go\n+./ddd3.go\n+./decl.go\n+./declbad.go\n+./defer.go\n+./deferprint.go\n+./empty.go\n+./env.go\n+./escape.go\n+./float_lit.go\n+./floatcmp.go\n+./for.go\n+./func.go\n+./func1.go\n+./func2.go\n+./func3.go\n+./func4.go\n+./func5.go\n+./gc.go\n+./gc1.go\n+./hashmap.go\n+./helloworld.go\n+./if.go\n+./if1.go\n+./import.go\n+./import1.go\n+./import2.go\n+./import3.go\n+./import4.go\n+./indirect.go\n+./indirect1.go\n+./initcomma.go\n+./initialize.go\n+./initializerr.go\n+./initsyscall.go\n+./int_lit.go\n+./intcvt.go\n+./iota.go\n+./literal.go\n+./malloc1.go\n+# ./mallocfin.go\t# fail\n+./mallocrand.go\n+./mallocrep.go\n+./mallocrep1.go\n+# ./map.go\t# fail\n+./method.go\n+./method1.go\n+./method2.go\n+./method3.go\n+./named.go\n+./named1.go\n+./nil.go\n+./nul1.go\n+./parentype.go\n+./peano.go\n+./printbig.go\n+./range.go\n+./recover.go\n+./recover1.go\n+./recover2.go\n+# ./recover3.go\t# fail\n+./rename.go\n+./rename1.go\n+./runtime.go\n+./sieve.go\n+./sigchld.go\n+./simassign.go\n+./sinit.go\n+./stack.go\n+./string_lit.go\n+./stringrange.go\n+./switch.go\n+./switch1.go\n+./test0.go\n+./turing.go\n+./typeswitch.go\n+./typeswitch1.go\n+./typeswitch2.go\n+./undef.go\n+./utf.go\n+./varerr.go\n+./varinit.go\n+./vectors.go\n+./zerodivide.go\n+ken/array.go\n+ken/chan.go\n+ken/chan1.go\n+ken/complit.go\n+# ken/cplx0.go\t# output fail\n+# ken/cplx1.go\t# fail\n+# ken/cplx2.go\t# fail\n+# ken/cplx3.go\t# output fail\n+# ken/cplx4.go\t# fail, BUG\n+# ken/cplx5.go\t# output fail\n+ken/divconst.go\n+ken/divmod.go\n+ken/embed.go\n+ken/for.go\n+ken/interbasic.go\n+ken/interfun.go\n+ken/intervar.go\n+ken/label.go\n+ken/litfun.go\n+ken/mfunc.go\n+ken/modconst.go\n+ken/ptrfun.go\n+ken/ptrvar.go\n+ken/range.go\n+ken/rob1.go\n+ken/rob2.go\n+ken/robfor.go\n+ken/robfunc.go\n+ken/robif.go\n+ken/shift.go\n+ken/simparray.go\n+ken/simpbool.go\n+ken/simpconv.go\n+ken/simpfun.go\n+ken/simpprint.go\n+ken/simpswitch.go\n+ken/simpvar.go\n+ken/slicearray.go\n+ken/sliceslice.go\n+ken/string.go\n+ken/strvar.go\n+chan/doubleselect.go\n+chan/fifo.go\n+chan/goroutines.go\n+chan/nonblock.go\n+chan/perm.go\n+chan/powser1.go\n+chan/powser2.go\n+chan/select.go\n+chan/select2.go\n+# chan/select3.go\t# fail\n+chan/sieve1.go\n+chan/sieve2.go\n+interface/bigdata.go\n+interface/convert.go\n+interface/convert1.go\n+interface/convert2.go\n+interface/embed.go\n+interface/embed0.go\n+interface/embed1.go\n+interface/explicit.go\n+interface/fail.go\n+interface/fake.go\n+interface/pointer.go\n+interface/receiver.go\n+interface/receiver1.go\n+interface/recursive.go\n+interface/returntype.go\n+interface/struct.go\n+nilptr/arrayindex.go\n+nilptr/arrayindex1.go\n+nilptr/arraytoslice.go\n+nilptr/arraytoslice1.go\n+nilptr/arraytoslice2.go\n+nilptr/slicearray.go\n+nilptr/structfield.go\n+nilptr/structfield1.go\n+nilptr/structfield2.go\n+nilptr/structfieldaddr.go\n+syntax/forvar.go\n+syntax/import.go\n+syntax/interface.go\n+syntax/semi1.go\n+syntax/semi2.go\n+syntax/semi3.go\n+syntax/semi4.go\n+syntax/semi5.go\n+syntax/semi6.go\n+syntax/semi7.go\n+syntax/slice.go\n+syntax/topexpr.go\n+syntax/vareq.go\n+syntax/vareq1.go\n+fixedbugs/bug000.go\n+fixedbugs/bug001.go\n+fixedbugs/bug002.go\n+fixedbugs/bug003.go\n+fixedbugs/bug004.go\n+fixedbugs/bug005.go\n+fixedbugs/bug006.go\n+fixedbugs/bug007.go\n+fixedbugs/bug008.go\n+fixedbugs/bug009.go\n+fixedbugs/bug010.go\n+fixedbugs/bug011.go\n+fixedbugs/bug012.go\n+fixedbugs/bug013.go\n+fixedbugs/bug014.go\n+fixedbugs/bug015.go\n+fixedbugs/bug016.go\n+fixedbugs/bug017.go\n+fixedbugs/bug020.go\n+fixedbugs/bug021.go\n+fixedbugs/bug022.go\n+fixedbugs/bug023.go\n+fixedbugs/bug024.go\n+fixedbugs/bug026.go\n+fixedbugs/bug027.go\n+fixedbugs/bug028.go\n+fixedbugs/bug030.go\n+fixedbugs/bug031.go\n+fixedbugs/bug035.go\n+fixedbugs/bug036.go\n+fixedbugs/bug037.go\n+fixedbugs/bug038.go\n+fixedbugs/bug039.go\n+fixedbugs/bug040.go\n+fixedbugs/bug045.go\n+fixedbugs/bug046.go\n+fixedbugs/bug047.go\n+fixedbugs/bug048.go\n+fixedbugs/bug049.go\n+fixedbugs/bug050.go\n+fixedbugs/bug051.go\n+fixedbugs/bug052.go\n+fixedbugs/bug053.go\n+fixedbugs/bug054.go\n+fixedbugs/bug055.go\n+fixedbugs/bug056.go\n+fixedbugs/bug057.go\n+fixedbugs/bug058.go\n+fixedbugs/bug059.go\n+fixedbugs/bug060.go\n+fixedbugs/bug061.go\n+fixedbugs/bug062.go\n+fixedbugs/bug063.go\n+fixedbugs/bug064.go\n+fixedbugs/bug065.go\n+fixedbugs/bug066.go\n+fixedbugs/bug067.go\n+fixedbugs/bug068.go\n+fixedbugs/bug069.go\n+fixedbugs/bug070.go\n+fixedbugs/bug071.go\n+fixedbugs/bug072.go\n+fixedbugs/bug073.go\n+fixedbugs/bug074.go\n+fixedbugs/bug075.go\n+fixedbugs/bug076.go\n+fixedbugs/bug077.go\n+fixedbugs/bug078.go\n+fixedbugs/bug080.go\n+fixedbugs/bug081.go\n+fixedbugs/bug082.go\n+fixedbugs/bug083.go\n+fixedbugs/bug084.go\n+fixedbugs/bug085.go\n+fixedbugs/bug086.go\n+fixedbugs/bug087.go\n+fixedbugs/bug088.go\n+fixedbugs/bug089.go\n+fixedbugs/bug090.go\n+fixedbugs/bug091.go\n+fixedbugs/bug092.go\n+fixedbugs/bug093.go\n+fixedbugs/bug094.go\n+fixedbugs/bug096.go\n+fixedbugs/bug097.go\n+fixedbugs/bug098.go\n+fixedbugs/bug099.go\n+fixedbugs/bug101.go\n+fixedbugs/bug102.go\n+fixedbugs/bug103.go\n+fixedbugs/bug104.go\n+fixedbugs/bug106.go\n+fixedbugs/bug107.go\n+fixedbugs/bug108.go\n+fixedbugs/bug109.go\n+fixedbugs/bug110.go\n+fixedbugs/bug111.go\n+fixedbugs/bug112.go\n+fixedbugs/bug113.go\n+fixedbugs/bug114.go\n+fixedbugs/bug115.go\n+fixedbugs/bug116.go\n+fixedbugs/bug117.go\n+fixedbugs/bug118.go\n+fixedbugs/bug119.go\n+fixedbugs/bug120.go\n+fixedbugs/bug121.go\n+fixedbugs/bug122.go\n+fixedbugs/bug123.go\n+fixedbugs/bug126.go\n+fixedbugs/bug127.go\n+fixedbugs/bug128.go\n+fixedbugs/bug129.go\n+fixedbugs/bug130.go\n+fixedbugs/bug131.go\n+fixedbugs/bug132.go\n+fixedbugs/bug133.go\n+fixedbugs/bug135.go\n+fixedbugs/bug136.go\n+fixedbugs/bug137.go\n+fixedbugs/bug139.go\n+fixedbugs/bug140.go\n+fixedbugs/bug141.go\n+fixedbugs/bug142.go\n+fixedbugs/bug143.go\n+fixedbugs/bug144.go\n+fixedbugs/bug145.go\n+fixedbugs/bug146.go\n+fixedbugs/bug147.go\n+fixedbugs/bug148.go\n+fixedbugs/bug149.go\n+fixedbugs/bug150.go\n+fixedbugs/bug151.go\n+fixedbugs/bug152.go\n+fixedbugs/bug154.go\n+fixedbugs/bug155.go\n+fixedbugs/bug156.go\n+fixedbugs/bug157.go\n+fixedbugs/bug158.go\n+fixedbugs/bug159.go\n+fixedbugs/bug160.go\n+fixedbugs/bug161.go\n+fixedbugs/bug163.go\n+fixedbugs/bug164.go\n+fixedbugs/bug165.go\n+fixedbugs/bug167.go\n+fixedbugs/bug168.go\n+fixedbugs/bug169.go\n+fixedbugs/bug170.go\n+fixedbugs/bug171.go\n+fixedbugs/bug172.go\n+fixedbugs/bug173.go\n+fixedbugs/bug174.go\n+fixedbugs/bug175.go\n+fixedbugs/bug176.go\n+fixedbugs/bug177.go\n+fixedbugs/bug178.go\n+fixedbugs/bug179.go\n+fixedbugs/bug180.go\n+fixedbugs/bug181.go\n+fixedbugs/bug182.go\n+fixedbugs/bug183.go\n+fixedbugs/bug184.go\n+fixedbugs/bug185.go\n+fixedbugs/bug186.go\n+fixedbugs/bug187.go\n+fixedbugs/bug188.go\n+fixedbugs/bug189.go\n+fixedbugs/bug190.go\n+fixedbugs/bug191.go\n+fixedbugs/bug192.go\n+fixedbugs/bug193.go\n+fixedbugs/bug194.go\n+fixedbugs/bug195.go\n+fixedbugs/bug196.go\n+fixedbugs/bug197.go\n+fixedbugs/bug198.go\n+fixedbugs/bug199.go\n+fixedbugs/bug200.go\n+fixedbugs/bug201.go\n+fixedbugs/bug202.go\n+fixedbugs/bug203.go\n+fixedbugs/bug204.go\n+fixedbugs/bug205.go\n+fixedbugs/bug206.go\n+fixedbugs/bug207.go\n+fixedbugs/bug208.go\n+fixedbugs/bug209.go\n+fixedbugs/bug211.go\n+fixedbugs/bug212.go\n+fixedbugs/bug213.go\n+fixedbugs/bug214.go\n+fixedbugs/bug215.go\n+fixedbugs/bug216.go\n+fixedbugs/bug217.go\n+fixedbugs/bug218.go\n+fixedbugs/bug219.go\n+fixedbugs/bug220.go\n+fixedbugs/bug221.go\n+fixedbugs/bug222.go\n+fixedbugs/bug223.go\n+fixedbugs/bug224.go\n+fixedbugs/bug225.go\n+fixedbugs/bug226.go\n+fixedbugs/bug227.go\n+fixedbugs/bug228.go\n+fixedbugs/bug229.go\n+fixedbugs/bug230.go\n+fixedbugs/bug231.go\n+fixedbugs/bug232.go\n+fixedbugs/bug233.go\n+fixedbugs/bug234.go\n+fixedbugs/bug235.go\n+fixedbugs/bug236.go\n+fixedbugs/bug237.go\n+fixedbugs/bug238.go\n+fixedbugs/bug239.go\n+fixedbugs/bug240.go\n+fixedbugs/bug241.go\n+fixedbugs/bug242.go\n+# fixedbugs/bug243.go\t# fail, flaky on android build\n+fixedbugs/bug244.go\n+fixedbugs/bug245.go\n+fixedbugs/bug246.go\n+fixedbugs/bug247.go\n+fixedbugs/bug248.go\n+fixedbugs/bug249.go\n+fixedbugs/bug250.go\n+fixedbugs/bug251.go\n+fixedbugs/bug252.go\n+fixedbugs/bug253.go\n+fixedbugs/bug254.go\n+fixedbugs/bug255.go\n+fixedbugs/bug256.go\n+fixedbugs/bug257.go\n+fixedbugs/bug258.go\n+fixedbugs/bug259.go\n+fixedbugs/bug261.go\n+fixedbugs/bug262.go\n+fixedbugs/bug263.go\n+fixedbugs/bug264.go\n+fixedbugs/bug265.go\n+fixedbugs/bug266.go\n+fixedbugs/bug267.go\n+fixedbugs/bug268.go\n+fixedbugs/bug269.go\n+fixedbugs/bug270.go\n+fixedbugs/bug271.go\n+fixedbugs/bug272.go\n+fixedbugs/bug273.go\n+fixedbugs/bug274.go\n+fixedbugs/bug275.go\n+fixedbugs/bug276.go\n+fixedbugs/bug277.go\n+fixedbugs/bug278.go\n+fixedbugs/bug279.go\n+fixedbugs/bug280.go\n+fixedbugs/bug281.go\n+fixedbugs/bug282.go\n+fixedbugs/bug283.go\n+fixedbugs/bug284.go\n+fixedbugs/bug285.go\n+fixedbugs/bug286.go\n+fixedbugs/bug287.go\n+fixedbugs/bug288.go\n+fixedbugs/bug289.go\n+fixedbugs/bug290.go\n+fixedbugs/bug291.go\n+fixedbugs/bug292.go\n+fixedbugs/bug293.go\n+fixedbugs/bug294.go\n+fixedbugs/bug295.go\n+fixedbugs/bug296.go\n+fixedbugs/bug297.go\n+fixedbugs/bug298.go\n+# bugs/bug260.go\t# fail, BUG"}, {"sha": "59471388c069531a119183abcba147644194ec1d", "filename": "gcc/testsuite/go.test/test/assign.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fassign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fassign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fassign.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,53 @@\n+// errchk $G -e $D/$F.go\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"sync\"\n+\n+type T struct {\n+\tint\n+\tsync.Mutex\n+}\n+\n+func main() {\n+\t{\n+\t\tvar x, y sync.Mutex\n+\t\tx = y\t// ERROR \"assignment.*Mutex\"\n+\t\t_ = x\n+\t}\n+\t{\n+\t\tvar x, y T\n+\t\tx = y\t// ERROR \"assignment.*Mutex\"\n+\t\t_ = x\n+\t}\n+\t{\n+\t\tvar x, y [2]sync.Mutex\n+\t\tx = y\t// ERROR \"assignment.*Mutex\"\n+\t\t_ = x\n+\t}\n+\t{\n+\t\tvar x, y [2]T\n+\t\tx = y\t// ERROR \"assignment.*Mutex\"\n+\t\t_ = x\n+\t}\n+\t{\n+\t\tx := sync.Mutex{0, 0}\t// ERROR \"assignment.*Mutex\"\n+\t\t_ = x\n+\t}\n+\t{\n+\t\tx := sync.Mutex{key: 0}\t// ERROR \"(unknown|assignment).*Mutex\"\n+\t\t_ = x\n+\t}\n+\t{\n+\t\tx := &sync.Mutex{}\t// ok\n+\t\tvar y sync.Mutex\t// ok\n+\t\ty = *x\t// ERROR \"assignment.*Mutex\"\n+\t\t*x = y\t// ERROR \"assignment.*Mutex\"\n+\t\t_ = x\n+\t\t_ = y\n+\t}\t\t\n+}"}, {"sha": "71e5b406439f02539b51d61f5ca59020d8ab3949", "filename": "gcc/testsuite/go.test/test/assign1.go", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fassign1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fassign1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fassign1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,343 @@\n+// errchk $G -e $D/$F.go\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+type (\n+\tA [10]int\n+\tB []int\n+\tC chan int\n+\tF func() int\n+\tI interface {\n+\t\tm() int\n+\t}\n+\tM map[int]int\n+\tP *int\n+\tS struct {\n+\t\tX int\n+\t}\n+\n+\tA1 [10]int\n+\tB1 []int\n+\tC1 chan int\n+\tF1 func() int\n+\tI1 interface {\n+\t\tm() int\n+\t}\n+\tM1 map[int]int\n+\tP1 *int\n+\tS1 struct {\n+\t\tX int\n+\t}\n+)\n+\n+var (\n+\ta0 [10]int\n+\tb0 []int\n+\tc0 chan int\n+\tf0 func() int\n+\ti0 interface {\n+\t\tm() int\n+\t}\n+\tm0 map[int]int\n+\tp0 *int\n+\ts0 struct {\n+\t\tX int\n+\t}\n+\n+\ta A\n+\tb B\n+\tc C\n+\tf F\n+\ti I\n+\tm M\n+\tp P\n+\ts S\n+\n+\ta1 A1\n+\tb1 B1\n+\tc1 C1\n+\tf1 F1\n+\ti1 I1\n+\tm1 M1\n+\tp1 P1\n+\ts1 S1\n+\n+\tpa0 *[10]int\n+\tpb0 *[]int\n+\tpc0 *chan int\n+\tpf0 *func() int\n+\tpi0 *interface {\n+\t\tm() int\n+\t}\n+\tpm0 *map[int]int\n+\tpp0 **int\n+\tps0 *struct {\n+\t\tX int\n+\t}\n+\n+\tpa *A\n+\tpb *B\n+\tpc *C\n+\tpf *F\n+\tpi *I\n+\tpm *M\n+\tpp *P\n+\tps *S\n+\n+\tpa1 *A1\n+\tpb1 *B1\n+\tpc1 *C1\n+\tpf1 *F1\n+\tpi1 *I1\n+\tpm1 *M1\n+\tpp1 *P1\n+\tps1 *S1\n+)\n+\n+func main() {\n+\ta0 = a\n+\ta0 = a1\n+\ta = a0\n+\ta = a1 // ERROR \"cannot use\"\n+\ta1 = a0\n+\ta1 = a // ERROR \"cannot use\"\n+\n+\tb0 = b\n+\tb0 = b1\n+\tb = b0\n+\tb = b1 // ERROR \"cannot use\"\n+\tb1 = b0\n+\tb1 = b // ERROR \"cannot use\"\n+\n+\tc0 = c\n+\tc0 = c1\n+\tc = c0\n+\tc = c1 // ERROR \"cannot use\"\n+\tc1 = c0\n+\tc1 = c // ERROR \"cannot use\"\n+\n+\tf0 = f\n+\tf0 = f1\n+\tf = f0\n+\tf = f1 // ERROR \"cannot use\"\n+\tf1 = f0\n+\tf1 = f // ERROR \"cannot use\"\n+\n+\ti0 = i\n+\ti0 = i1\n+\ti = i0\n+\ti = i1\n+\ti1 = i0\n+\ti1 = i\n+\n+\tm0 = m\n+\tm0 = m1\n+\tm = m0\n+\tm = m1 // ERROR \"cannot use\"\n+\tm1 = m0\n+\tm1 = m // ERROR \"cannot use\"\n+\n+\tp0 = p\n+\tp0 = p1\n+\tp = p0\n+\tp = p1 // ERROR \"cannot use\"\n+\tp1 = p0\n+\tp1 = p // ERROR \"cannot use\"\n+\n+\ts0 = s\n+\ts0 = s1\n+\ts = s0\n+\ts = s1 // ERROR \"cannot use\"\n+\ts1 = s0\n+\ts1 = s // ERROR \"cannot use\"\n+\n+\tpa0 = pa  // ERROR \"cannot use|incompatible\"\n+\tpa0 = pa1 // ERROR \"cannot use|incompatible\"\n+\tpa = pa0  // ERROR \"cannot use|incompatible\"\n+\tpa = pa1  // ERROR \"cannot use|incompatible\"\n+\tpa1 = pa0 // ERROR \"cannot use|incompatible\"\n+\tpa1 = pa  // ERROR \"cannot use|incompatible\"\n+\n+\tpb0 = pb  // ERROR \"cannot use|incompatible\"\n+\tpb0 = pb1 // ERROR \"cannot use|incompatible\"\n+\tpb = pb0  // ERROR \"cannot use|incompatible\"\n+\tpb = pb1  // ERROR \"cannot use|incompatible\"\n+\tpb1 = pb0 // ERROR \"cannot use|incompatible\"\n+\tpb1 = pb  // ERROR \"cannot use|incompatible\"\n+\n+\tpc0 = pc  // ERROR \"cannot use|incompatible\"\n+\tpc0 = pc1 // ERROR \"cannot use|incompatible\"\n+\tpc = pc0  // ERROR \"cannot use|incompatible\"\n+\tpc = pc1  // ERROR \"cannot use|incompatible\"\n+\tpc1 = pc0 // ERROR \"cannot use|incompatible\"\n+\tpc1 = pc  // ERROR \"cannot use|incompatible\"\n+\n+\tpf0 = pf  // ERROR \"cannot use|incompatible\"\n+\tpf0 = pf1 // ERROR \"cannot use|incompatible\"\n+\tpf = pf0  // ERROR \"cannot use|incompatible\"\n+\tpf = pf1  // ERROR \"cannot use|incompatible\"\n+\tpf1 = pf0 // ERROR \"cannot use|incompatible\"\n+\tpf1 = pf  // ERROR \"cannot use|incompatible\"\n+\n+\tpi0 = pi  // ERROR \"cannot use|incompatible\"\n+\tpi0 = pi1 // ERROR \"cannot use|incompatible\"\n+\tpi = pi0  // ERROR \"cannot use|incompatible\"\n+\tpi = pi1  // ERROR \"cannot use|incompatible\"\n+\tpi1 = pi0 // ERROR \"cannot use|incompatible\"\n+\tpi1 = pi  // ERROR \"cannot use|incompatible\"\n+\n+\tpm0 = pm  // ERROR \"cannot use|incompatible\"\n+\tpm0 = pm1 // ERROR \"cannot use|incompatible\"\n+\tpm = pm0  // ERROR \"cannot use|incompatible\"\n+\tpm = pm1  // ERROR \"cannot use|incompatible\"\n+\tpm1 = pm0 // ERROR \"cannot use|incompatible\"\n+\tpm1 = pm  // ERROR \"cannot use|incompatible\"\n+\n+\tpp0 = pp  // ERROR \"cannot use|incompatible\"\n+\tpp0 = pp1 // ERROR \"cannot use|incompatible\"\n+\tpp = pp0  // ERROR \"cannot use|incompatible\"\n+\tpp = pp1  // ERROR \"cannot use|incompatible\"\n+\tpp1 = pp0 // ERROR \"cannot use|incompatible\"\n+\tpp1 = pp  // ERROR \"cannot use|incompatible\"\n+\n+\tps0 = ps  // ERROR \"cannot use|incompatible\"\n+\tps0 = ps1 // ERROR \"cannot use|incompatible\"\n+\tps = ps0  // ERROR \"cannot use|incompatible\"\n+\tps = ps1  // ERROR \"cannot use|incompatible\"\n+\tps1 = ps0 // ERROR \"cannot use|incompatible\"\n+\tps1 = ps  // ERROR \"cannot use|incompatible\"\n+\n+\n+\ta0 = [10]int(a)\n+\ta0 = [10]int(a1)\n+\ta = A(a0)\n+\ta = A(a1)\n+\ta1 = A1(a0)\n+\ta1 = A1(a)\n+\n+\tb0 = []int(b)\n+\tb0 = []int(b1)\n+\tb = B(b0)\n+\tb = B(b1)\n+\tb1 = B1(b0)\n+\tb1 = B1(b)\n+\n+\tc0 = chan int(c)\n+\tc0 = chan int(c1)\n+\tc = C(c0)\n+\tc = C(c1)\n+\tc1 = C1(c0)\n+\tc1 = C1(c)\n+\n+\tf0 = func() int(f)\n+\tf0 = func() int(f1)\n+\tf = F(f0)\n+\tf = F(f1)\n+\tf1 = F1(f0)\n+\tf1 = F1(f)\n+\n+\ti0 = interface {\n+\t\tm() int\n+\t}(i)\n+\ti0 = interface {\n+\t\tm() int\n+\t}(i1)\n+\ti = I(i0)\n+\ti = I(i1)\n+\ti1 = I1(i0)\n+\ti1 = I1(i)\n+\n+\tm0 = map[int]int(m)\n+\tm0 = map[int]int(m1)\n+\tm = M(m0)\n+\tm = M(m1)\n+\tm1 = M1(m0)\n+\tm1 = M1(m)\n+\n+\tp0 = (*int)(p)\n+\tp0 = (*int)(p1)\n+\tp = P(p0)\n+\tp = P(p1)\n+\tp1 = P1(p0)\n+\tp1 = P1(p)\n+\n+\ts0 = struct {\n+\t\tX int\n+\t}(s)\n+\ts0 = struct {\n+\t\tX int\n+\t}(s1)\n+\ts = S(s0)\n+\ts = S(s1)\n+\ts1 = S1(s0)\n+\ts1 = S1(s)\n+\n+\tpa0 = (*[10]int)(pa)\n+\tpa0 = (*[10]int)(pa1)\n+\tpa = (*A)(pa0)\n+\tpa = (*A)(pa1)\n+\tpa1 = (*A1)(pa0)\n+\tpa1 = (*A1)(pa)\n+\n+\tpb0 = (*[]int)(pb)\n+\tpb0 = (*[]int)(pb1)\n+\tpb = (*B)(pb0)\n+\tpb = (*B)(pb1)\n+\tpb1 = (*B1)(pb0)\n+\tpb1 = (*B1)(pb)\n+\n+\tpc0 = (*chan int)(pc)\n+\tpc0 = (*chan int)(pc1)\n+\tpc = (*C)(pc0)\n+\tpc = (*C)(pc1)\n+\tpc1 = (*C1)(pc0)\n+\tpc1 = (*C1)(pc)\n+\n+\tpf0 = (*func() int)(pf)\n+\tpf0 = (*func() int)(pf1)\n+\tpf = (*F)(pf0)\n+\tpf = (*F)(pf1)\n+\tpf1 = (*F1)(pf0)\n+\tpf1 = (*F1)(pf)\n+\n+\tpi0 = (*interface {\n+\t\tm() int\n+\t})(pi)\n+\tpi0 = (*interface {\n+\t\tm() int\n+\t})(pi1)\n+\tpi = (*I)(pi0)\n+\tpi = (*I)(pi1)\n+\tpi1 = (*I1)(pi0)\n+\tpi1 = (*I1)(pi)\n+\n+\tpm0 = (*map[int]int)(pm)\n+\tpm0 = (*map[int]int)(pm1)\n+\tpm = (*M)(pm0)\n+\tpm = (*M)(pm1)\n+\tpm1 = (*M1)(pm0)\n+\tpm1 = (*M1)(pm)\n+\n+\tpp0 = (**int)(pp)\n+\tpp0 = (**int)(pp1)\n+\tpp = (*P)(pp0)\n+\tpp = (*P)(pp1)\n+\tpp1 = (*P1)(pp0)\n+\tpp1 = (*P1)(pp)\n+\n+\tps0 = (*struct {\n+\t\tX int\n+\t})(ps)\n+\tps0 = (*struct {\n+\t\tX int\n+\t})(ps1)\n+\tps = (*S)(ps0)\n+\tps = (*S)(ps1)\n+\tps1 = (*S1)(ps0)\n+\tps1 = (*S1)(ps)\n+\n+}"}, {"sha": "071a4e06e7b270d6c104edb0408dd0dc74975ba1", "filename": "gcc/testsuite/go.test/test/bench/binary-tree-freelist.go", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree-freelist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree-freelist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree-freelist.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,129 @@\n+/*\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    * Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in the\n+    documentation and/or other materials provided with the distribution.\n+\n+    * Neither the name of \"The Computer Language Benchmarks Game\" nor the\n+    name of \"The Computer Language Shootout Benchmarks\" nor the names of\n+    its contributors may be used to endorse or promote products derived\n+    from this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+/* The Computer Language Benchmarks Game\n+ * http://shootout.alioth.debian.org/\n+ *\n+ * contributed by The Go Authors.\n+ * based on C program by Kevin Carson\n+ */\n+\n+package main\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+)\n+\n+var n = flag.Int(\"n\", 15, \"depth\")\n+\n+type Node struct {\n+\titem        int\n+\tleft, right *Node\n+}\n+\n+type Arena struct {\n+\thead *Node\n+}\n+\n+var arena Arena\n+\n+func (n *Node) free() {\n+\tif n.left != nil {\n+\t\tn.left.free()\n+\t}\n+\tif n.right != nil {\n+\t\tn.right.free()\n+\t}\n+\tn.left = arena.head\n+\tarena.head = n\n+}\n+\n+func (a *Arena) New(item int, left, right *Node) *Node {\n+\tif a.head == nil {\n+\t\tnodes := make([]Node, 3<<uint(*n))\n+\t\tfor i := 0; i < len(nodes)-1; i++ {\n+\t\t\tnodes[i].left = &nodes[i+1]\n+\t\t}\n+\t\ta.head = &nodes[0]\n+\t}\n+\tn := a.head\n+\ta.head = a.head.left\n+\tn.item = item\n+\tn.left = left\n+\tn.right = right\n+\treturn n\n+}\n+\n+func bottomUpTree(item, depth int) *Node {\n+\tif depth <= 0 {\n+\t\treturn arena.New(item, nil, nil)\n+\t}\n+\treturn arena.New(item, bottomUpTree(2*item-1, depth-1), bottomUpTree(2*item, depth-1))\n+}\n+\n+func (n *Node) itemCheck() int {\n+\tif n.left == nil {\n+\t\treturn n.item\n+\t}\n+\treturn n.item + n.left.itemCheck() - n.right.itemCheck()\n+}\n+\n+const minDepth = 4\n+\n+func main() {\n+\tflag.Parse()\n+\n+\tmaxDepth := *n\n+\tif minDepth+2 > *n {\n+\t\tmaxDepth = minDepth + 2\n+\t}\n+\tstretchDepth := maxDepth + 1\n+\n+\tcheck := bottomUpTree(0, stretchDepth).itemCheck()\n+\tfmt.Printf(\"stretch tree of depth %d\\t check: %d\\n\", stretchDepth, check)\n+\n+\tlongLivedTree := bottomUpTree(0, maxDepth)\n+\n+\tfor depth := minDepth; depth <= maxDepth; depth += 2 {\n+\t\titerations := 1 << uint(maxDepth-depth+minDepth)\n+\t\tcheck = 0\n+\n+\t\tfor i := 1; i <= iterations; i++ {\n+\t\t\tt := bottomUpTree(i, depth)\n+\t\t\tcheck += t.itemCheck()\n+\t\t\tt.free()\n+\t\t\tt = bottomUpTree(-i, depth)\n+\t\t\tcheck += t.itemCheck()\n+\t\t\tt.free()\n+\t\t}\n+\t\tfmt.Printf(\"%d\\t trees of depth %d\\t check: %d\\n\", iterations*2, depth, check)\n+\t}\n+\tfmt.Printf(\"long lived tree of depth %d\\t check: %d\\n\", maxDepth, longLivedTree.itemCheck())\n+}"}, {"sha": "f8286dd88bd490f57323048f4e333a37ede0453d", "filename": "gcc/testsuite/go.test/test/bench/binary-tree-freelist.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree-freelist.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree-freelist.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree-freelist.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c", "patch": "@@ -0,0 +1,8 @@\n+stretch tree of depth 16\t check: -1\n+65536\t trees of depth 4\t check: -65536\n+16384\t trees of depth 6\t check: -16384\n+4096\t trees of depth 8\t check: -4096\n+1024\t trees of depth 10\t check: -1024\n+256\t trees of depth 12\t check: -256\n+64\t trees of depth 14\t check: -64\n+long lived tree of depth 15\t check: -1"}, {"sha": "1b4070406f3eb4375fb4fb23c835f85fb85b4a58", "filename": "gcc/testsuite/go.test/test/bench/binary-tree.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "9f867d11a70f8d454d37611868f07b98a12aa544", "filename": "gcc/testsuite/go.test/test/bench/binary-tree.go", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f8286dd88bd490f57323048f4e333a37ede0453d", "filename": "gcc/testsuite/go.test/test/bench/binary-tree.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fbinary-tree.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ed78c31d7ba09a80430eed112021c81cb6d57548", "filename": "gcc/testsuite/go.test/test/bench/chameneosredux.c", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2cb1440041f5cc29f94940a8aff3d247e4d65b6d", "filename": "gcc/testsuite/go.test/test/bench/chameneosredux.go", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6016d59a8c9e65ce1b99a1763e24015e0158f19d", "filename": "gcc/testsuite/go.test/test/bench/chameneosredux.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fchameneosredux.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d56c0e39405d4af111fff814627f0df37c341e20", "filename": "gcc/testsuite/go.test/test/bench/clean.bash", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fclean.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fclean.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fclean.bash?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7897eac05246ad7e0e12bf91c18e8c4bca879528", "filename": "gcc/testsuite/go.test/test/bench/fannkuch-parallel.go", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch-parallel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch-parallel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch-parallel.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e66f779ea1d18ea1b153c33e43d41c4bc12bad35", "filename": "gcc/testsuite/go.test/test/bench/fannkuch-parallel.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch-parallel.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch-parallel.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch-parallel.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e576b5441f994b0f829c4839ab5c71f012f0c0e5", "filename": "gcc/testsuite/go.test/test/bench/fannkuch.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b554c77b10490a0a403d0f423e1b05ca05b8f200", "filename": "gcc/testsuite/go.test/test/bench/fannkuch.go", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e66f779ea1d18ea1b153c33e43d41c4bc12bad35", "filename": "gcc/testsuite/go.test/test/bench/fannkuch.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffannkuch.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f1caba0d628000ab62a51a1b731e61bb0db8d559", "filename": "gcc/testsuite/go.test/test/bench/fasta-1000.out", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta-1000.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta-1000.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta-1000.out?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "78a8490d71028d635111ad68f6a95b766f7ca02d", "filename": "gcc/testsuite/go.test/test/bench/fasta.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "470bdb3285aec9f12b845b9f9896390b3b3a6677", "filename": "gcc/testsuite/go.test/test/bench/fasta.go", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f1caba0d628000ab62a51a1b731e61bb0db8d559", "filename": "gcc/testsuite/go.test/test/bench/fasta.txt", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ffasta.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "0234f33d113a0f28e988768ed97a394e7e4ed7e4", "filename": "gcc/testsuite/go.test/test/bench/k-nucleotide-parallel.go", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide-parallel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide-parallel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide-parallel.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "84169b8ec36c670035ca85db716a4d166144cfc9", "filename": "gcc/testsuite/go.test/test/bench/k-nucleotide-parallel.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide-parallel.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide-parallel.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide-parallel.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "3bace391c4d7c69a47d480183695d1553f7b6a72", "filename": "gcc/testsuite/go.test/test/bench/k-nucleotide.c", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "fdc98ed472505be7bba50fb60eaf50627fa1c94e", "filename": "gcc/testsuite/go.test/test/bench/k-nucleotide.go", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "84169b8ec36c670035ca85db716a4d166144cfc9", "filename": "gcc/testsuite/go.test/test/bench/k-nucleotide.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fk-nucleotide.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c177c088ca6fbe6beec65e58bd1b607472efb43d", "filename": "gcc/testsuite/go.test/test/bench/mandelbrot.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "1f9fbfd3d4418345a603b53f0ab2f529755f13ee", "filename": "gcc/testsuite/go.test/test/bench/mandelbrot.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2f7bbbc6b0a127b8883712eda12c04a786055753", "filename": "gcc/testsuite/go.test/test/bench/mandelbrot.txt", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmandelbrot.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "19c43402c8c4bd6580eb7922d2328f2c80b6d3cd", "filename": "gcc/testsuite/go.test/test/bench/meteor-contest.c", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6660810ebd048597cb038a459085b6590ae2878b", "filename": "gcc/testsuite/go.test/test/bench/meteor-contest.go", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "38d9783d64fb7d1eb058c5754c930402c27e758d", "filename": "gcc/testsuite/go.test/test/bench/meteor-contest.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fmeteor-contest.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "3b95b05929eec67c9159de2226410587362bc99c", "filename": "gcc/testsuite/go.test/test/bench/nbody.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e9f4517e8e7b74d17f9f210d1a1ac7e850368934", "filename": "gcc/testsuite/go.test/test/bench/nbody.go", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "1731557ce19f86112c5a71d266c4f5d3b4e86a19", "filename": "gcc/testsuite/go.test/test/bench/nbody.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fnbody.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c064da0dd20e125ab744ab7b9c933cc31c8cc0e3", "filename": "gcc/testsuite/go.test/test/bench/pidigits.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dcfb502ce2a65255c73b1603934dd5845efd490d", "filename": "gcc/testsuite/go.test/test/bench/pidigits.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ad946a9e85d9f9b7e99dd3d88f0a1cefd8de10c4", "filename": "gcc/testsuite/go.test/test/bench/pidigits.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fpidigits.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e8e62b806da62a1633e98430ab83809132eb808c", "filename": "gcc/testsuite/go.test/test/bench/regex-dna-parallel.go", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna-parallel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna-parallel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna-parallel.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e23e71fd6eb93073f1a980601c684b2699948d04", "filename": "gcc/testsuite/go.test/test/bench/regex-dna-parallel.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna-parallel.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna-parallel.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna-parallel.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "134f8215c7f48e8dc04f90d8b464808f6bf71a8c", "filename": "gcc/testsuite/go.test/test/bench/regex-dna.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dc31db7685a4b1d5f1af39911e7895ca97631cde", "filename": "gcc/testsuite/go.test/test/bench/regex-dna.go", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e23e71fd6eb93073f1a980601c684b2699948d04", "filename": "gcc/testsuite/go.test/test/bench/regex-dna.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fregex-dna.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b34c84696ed0e1644dc8e221c1cc44c0555f82fa", "filename": "gcc/testsuite/go.test/test/bench/reverse-complement.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "baa30ffccc8c38a0042a5bebec535349b02dcc97", "filename": "gcc/testsuite/go.test/test/bench/reverse-complement.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "14d792ade8d52eaf0f7a9059d1d78d58d57096c0", "filename": "gcc/testsuite/go.test/test/bench/reverse-complement.txt", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Freverse-complement.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2706f39ec3d593e56c93d5ba4a4ad88ba0dbcbba", "filename": "gcc/testsuite/go.test/test/bench/spectral-norm-parallel.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm-parallel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm-parallel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm-parallel.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "832eb3d2176016ff98b021703bd3ac95a614dd1a", "filename": "gcc/testsuite/go.test/test/bench/spectral-norm.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6667f3e04a5e1bc39238d4ff7d603e34c7997e9d", "filename": "gcc/testsuite/go.test/test/bench/spectral-norm.go", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b9885983ee4387f942ee8510c1c9c05bfcb1af5f", "filename": "gcc/testsuite/go.test/test/bench/spectral-norm.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fspectral-norm.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2c4fb77515af0c3ef3efa18b4320b543c4759284", "filename": "gcc/testsuite/go.test/test/bench/threadring.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "031908a20f60c0c675e5ca4e0fbb6dedcfe7ab7a", "filename": "gcc/testsuite/go.test/test/bench/threadring.go", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f9aaa4d565f4a169e1033d0aa0aa7eb4a22e351f", "filename": "gcc/testsuite/go.test/test/bench/threadring.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fthreadring.txt?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e7b0b48c11f4bcf04662536a1464c8f5e4cc12bb", "filename": "gcc/testsuite/go.test/test/bench/timing.log", "status": "added", "additions": 500, "deletions": 0, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ftiming.log", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ftiming.log", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ftiming.log?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c52c0af94a6fffa50988d7958263a6a0439d0ff6", "filename": "gcc/testsuite/go.test/test/bench/timing.sh", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ftiming.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ftiming.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Ftiming.sh?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "902ba8410773065afba3d6bd96850d20e9fba6d1", "filename": "gcc/testsuite/go.test/test/bigalg.go", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbigalg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbigalg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbigalg.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "843a151741f239dd7a8f1cad8607e0710903897c", "filename": "gcc/testsuite/go.test/test/bigmap.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbigmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbigmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbigmap.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b9d3a32a8176305b8ad01c050fb6ba3a619a4542", "filename": "gcc/testsuite/go.test/test/blank.go", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "5bc1efce5fd2b7daf10d2d27e88fb60715ec26d2", "filename": "gcc/testsuite/go.test/test/blank1.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6a6331e65b3d6c87a403cd3702f71709087fc81a", "filename": "gcc/testsuite/go.test/test/bugs/bug260.go", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbugs%2Fbug260.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbugs%2Fbug260.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbugs%2Fbug260.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b816d34fc345d808a088db8f0dc509a78415c832", "filename": "gcc/testsuite/go.test/test/bugs/placeholder", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbugs%2Fplaceholder", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbugs%2Fplaceholder", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbugs%2Fplaceholder?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "592d2f54a431e0c71bcfaa5f411929793093d243", "filename": "gcc/testsuite/go.test/test/chan/doubleselect.go", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fdoubleselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fdoubleselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fdoubleselect.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "0dddfcaa0bddf78862d24a581bbfee46d7597736", "filename": "gcc/testsuite/go.test/test/chan/fifo.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Ffifo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Ffifo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Ffifo.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d8f8803dfe82b59f458d85ca0f0dde67bcb76a07", "filename": "gcc/testsuite/go.test/test/chan/goroutines.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fgoroutines.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fgoroutines.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fgoroutines.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "52f04bfb12f53c4d87c1c653616bfcd1f5a094f6", "filename": "gcc/testsuite/go.test/test/chan/nonblock.go", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fnonblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fnonblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fnonblock.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d08c035193de0366005b370d695c7b5558be3cdc", "filename": "gcc/testsuite/go.test/test/chan/perm.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fperm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fperm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fperm.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dc4ff53255d5f69b72478db8af50d05bd4cb7bc9", "filename": "gcc/testsuite/go.test/test/chan/powser1.go", "status": "added", "additions": 709, "deletions": 0, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fpowser1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fpowser1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fpowser1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "bc329270dbce05cf097bb9a6c43c97fdeb14f131", "filename": "gcc/testsuite/go.test/test/chan/powser2.go", "status": "added", "additions": 722, "deletions": 0, "changes": 722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fpowser2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fpowser2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fpowser2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "be4eb3f42d6fe1cfb6822e241fa9971865995ed7", "filename": "gcc/testsuite/go.test/test/chan/select.go", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e24c51ed16c2b7b932d6b08b662644c2c80a3b61", "filename": "gcc/testsuite/go.test/test/chan/select2.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "a1a2ef50b56ed38ca935e3bf013406728779c41b", "filename": "gcc/testsuite/go.test/test/chan/select3.go", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "55076c9253c6aaceb304d0e52b763f9e37664502", "filename": "gcc/testsuite/go.test/test/chan/sieve1.go", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7f2ed9157990f3c8e1ee894a0f9736f12f123974", "filename": "gcc/testsuite/go.test/test/chan/sieve2.go", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "3f3789fbcc08f93ef7dedeeb2ac235b3b7b6df30", "filename": "gcc/testsuite/go.test/test/chancap.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchancap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchancap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchancap.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "99be77a570e9fae8b52a24e2263b81110f7c10eb", "filename": "gcc/testsuite/go.test/test/char_lit.go", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchar_lit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchar_lit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchar_lit.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dc5385291d0c108e853698c41773588bdcc3e992", "filename": "gcc/testsuite/go.test/test/char_lit1.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchar_lit1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchar_lit1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchar_lit1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c7c759be3b3edfcad980be8dd0155493db7f7aab", "filename": "gcc/testsuite/go.test/test/closedchan.go", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosedchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosedchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosedchan.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "54e4cf8eae3d707860e18f6d7ee30f1fe05687a7", "filename": "gcc/testsuite/go.test/test/closure.go", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosure.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosure.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosure.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "db0a486dd339f6f6df3688a02a725bade8d5f77b", "filename": "gcc/testsuite/go.test/test/cmp1.go", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f6f124f2e8aaed1a72c0561a60c2614ce27e6f9b", "filename": "gcc/testsuite/go.test/test/cmp2.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dd90bfb03e0ae4cb7ada98514f97d2f1b45d62b1", "filename": "gcc/testsuite/go.test/test/cmp3.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "3f9b2c0b8b6b1dbce2106f7bf8605330a0ca84eb", "filename": "gcc/testsuite/go.test/test/cmp4.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp4.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "3a7d733f0249199a9b6b795beedf846a4191f5d1", "filename": "gcc/testsuite/go.test/test/cmp5.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp5.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6262c682d0bb375ec8b448520d13290cd77eed7f", "filename": "gcc/testsuite/go.test/test/cmplx.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplx.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b3c6055ed2301288f273767a6b41e714707c7ada", "filename": "gcc/testsuite/go.test/test/cmplxdivide.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.c?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6a67b175de1eee9f2e959d40c97bce45c4b4dba2", "filename": "gcc/testsuite/go.test/test/cmplxdivide.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "96ea704a3e280c5997668008d12fc769bde5ffab", "filename": "gcc/testsuite/go.test/test/cmplxdivide1.go", "status": "added", "additions": 2407, "deletions": 0, "changes": 2407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmplxdivide1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f3b7c9abe7115d113345243201de4efb4eaad537", "filename": "gcc/testsuite/go.test/test/complit.go", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcomplit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcomplit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcomplit.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "70f90f37945a3047084a095b6f3ccfabee714ef8", "filename": "gcc/testsuite/go.test/test/compos.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcompos.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcompos.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcompos.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "a55e13a40de1f2143190b7fc6da5430ce1802850", "filename": "gcc/testsuite/go.test/test/const.go", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "427d61e59c3b748a868cae67322348e3f7e8d9f5", "filename": "gcc/testsuite/go.test/test/const1.go", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "bea1b991254423bb37f171bc7d69de6a5f7d2be2", "filename": "gcc/testsuite/go.test/test/const2.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dd5c88958d762250b78286e0267f78734a993d14", "filename": "gcc/testsuite/go.test/test/const3.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconst3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e7361aa87f8f1e0f6e97d04dc277a098009afc6d", "filename": "gcc/testsuite/go.test/test/convert.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "be68c95b36207e4278ebbde3e3045efb1f127eb4", "filename": "gcc/testsuite/go.test/test/convert3.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "94889d4a963b4e531cc0b522e4164f2574bbd602", "filename": "gcc/testsuite/go.test/test/convlit.go", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "1e6673cb641b9742a5f46f1a3f4bf559f3f7e606", "filename": "gcc/testsuite/go.test/test/convlit1.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvlit1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "037d3f41fe623d6e95a800e71209cbd2029cc50e", "filename": "gcc/testsuite/go.test/test/copy.go", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcopy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcopy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcopy.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c9949c36e2079d058aa9cb00d9e63429de5f2868", "filename": "gcc/testsuite/go.test/test/ddd.go", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6f714c078aaca50ceb8a9e51ebf0f3a27c1cb6ff", "filename": "gcc/testsuite/go.test/test/ddd1.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "a06af0c06578725dc697cddefdf4c715a67202a9", "filename": "gcc/testsuite/go.test/test/ddd2.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd2.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "5d5ebdf0faea9741981d201bba8e5b7ef0b08186", "filename": "gcc/testsuite/go.test/test/ddd3.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fddd3.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c31082bcfdc844bfa4992503e01b1e0a48111298", "filename": "gcc/testsuite/go.test/test/decl.go", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdecl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdecl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdecl.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "269ebdefb53e2ce87bcc01e03234855c0c843817", "filename": "gcc/testsuite/go.test/test/declbad.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeclbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeclbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeclbad.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "8b8312235d1c2f7d99d27bb49637ef1b1376cb19", "filename": "gcc/testsuite/go.test/test/defer.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdefer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdefer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdefer.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f1e75266f785d3c8cd85eff72c6d534ddbec0cfb", "filename": "gcc/testsuite/go.test/test/deferprint.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeferprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeferprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeferprint.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "fa10d6931d9286362fc6ae7fbf1e36f5e3a14883", "filename": "gcc/testsuite/go.test/test/empty.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fempty.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fempty.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fempty.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7646e07dd687cd02ef37e2d5e8ebfc573a6ac08f", "filename": "gcc/testsuite/go.test/test/env.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fenv.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ab7192da2a823f86959ad5b900bb69ee72ed64d9", "filename": "gcc/testsuite/go.test/test/errchk", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ferrchk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ferrchk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ferrchk?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d4d844704efc6137934672b1ab62dd1ec4e51750", "filename": "gcc/testsuite/go.test/test/escape.go", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ccb24e8e9bb9dc188be255bfbb074c37b4f572fd", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug000.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug000.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug000.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug000.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2df8791fffbdfe34b3709a1826d1870700950f38", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug001.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug001.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug001.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug001.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "230841974f39ba37e0b58ceaff64a4046ebaad8b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug002.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug002.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug002.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug002.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e45975be41adb679f2c203600f7632094b035e4b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug003.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug003.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug003.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug003.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "20f467a5f4ef5e63bc5eae64e7ae06903bb9169f", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug004.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug004.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug004.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug004.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "3bd2fe815ed7bc6bccb4d4e333d5da956822d9ad", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug005.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug005.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug005.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug005.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e7694f95b564d07add36fce1243ec866351012e8", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug006.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug006.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug006.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug006.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "bd970de5f92a08720ca11285e187f39166bd0e62", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug007.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug007.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug007.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug007.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2baead11e36e838e4e52b83fa9612a5e435e5e9b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug008.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug008.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug008.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug008.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ef8263bb24057f18c0db31d36b6c2f346fcb2315", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug009.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug009.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug009.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug009.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e71c4d7f0bccdc76c70abf05f4e3aa06115ac5d6", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug010.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug010.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug010.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug010.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "551adb77dfc84eee21941cee303192a4815b5602", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug011.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug011.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug011.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug011.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ffd5b55706591a11e8b68479edc56d9fd609eec2", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug012.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug012.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug012.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug012.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "4b106775c28bb84b4c8982d102f1a2bfc40348a9", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug013.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug013.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug013.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug013.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dac2ce5174a48c95a377d9adc4a9cdba18f2b1ee", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug014.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug014.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug014.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug014.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "9178f626fc7eef8f27a90469a72cda2396d77672", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug015.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug015.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug015.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug015.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "461bcf82ac44c67a153332f2a0cdfa01a4c7dd5f", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug016.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug016.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug016.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug016.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "fdc986d9def30efc28654091ce1f9288f18e2977", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug017.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug017.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug017.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug017.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "896bf5707c04342b6d34d702eac2f2ed5887cef4", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug020.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug020.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug020.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug020.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "201fa5f0390d80a047cdb7d91a09c07ae0caff46", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug021.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug021.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug021.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug021.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f94a5856936fe37ac2516faf12e5ba6ab1cb1f7b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug022.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug022.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug022.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug022.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b3d3d4a3c150450b270b6bf0cc5653d26d79fe82", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug023.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug023.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug023.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug023.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c7b17b7c09256aebda95ff0b691084ca4ffcc7fe", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug024.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug024.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug024.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug024.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "eacea37459feb48d1a1fa21b045a991df838f9af", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug026.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug026.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug026.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug026.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "acc295d51aad46b833fc8164e3370634d5f81ad5", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug027.go", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug027.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug027.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug027.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "0488ad2cba8d3e46f9f5a5840ad4d1f2d947e572", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug028.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug028.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug028.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug028.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7efde9b4453c9abd446dc11a800e8d0bc2a603d2", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug030.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug030.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug030.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug030.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "acb4741e9f747ed58984d02b347f78092bdb4462", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug031.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug031.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug031.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug031.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "461c0607ac9cae6d1c0083cbe093182a2a25bb24", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug035.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug035.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug035.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug035.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "cc20516ce89488f3074c47c9135316406894cf19", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug036.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug036.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug036.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug036.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ff7d28710a111d483db41a2604e5e743a35e6ffa", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug037.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug037.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug037.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug037.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7585376a36fbf013dd3c0f8213bee76a5b6c1b30", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug038.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug038.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug038.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug038.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7ac02ceeb29e39e0e5381ab4c23a675d954d9a95", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug039.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug039.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug039.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug039.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "912316cb6fffa53a1d3d281280e29602b57d80f4", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug040.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug040.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug040.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug040.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "94888c40e2e381d42d79f34aa19d299cf8aa9c14", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug045.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug045.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug045.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug045.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "8a9b797074d6f831d39f40b3b6b071ac70d626af", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug046.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug046.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug046.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug046.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f3749e73972d5e9f8395a8786396ceff8dcbde9d", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug047.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug047.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug047.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug047.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b9fee7899c8a9d513b1c88f1a701bf2234ceb699", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug048.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug048.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug048.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug048.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "8fd67ccd51b03689813321ce3afa9b87469e8fc1", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug049.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug049.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug049.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug049.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "585c44623723439e405f56c824dd1b8e88d3c93a", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug050.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug050.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug050.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug050.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dd1662306dcd21bd1137130ddfb6c6a373effdbe", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug051.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug051.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug051.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug051.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d2c1b50617aa00fb01797f373a54c9af27e8b2d0", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug052.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug052.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug052.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug052.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c981403edcff1f08aabee5386f21d77abcf11ad3", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug053.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug053.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug053.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug053.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c8a2272c23644c5550deea8f250e3f9d2269c9fc", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug054.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug054.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug054.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug054.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "0326d828f2cad4206a4570102afd748ea0d6b005", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug055.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug055.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug055.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug055.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "050a4a5c5d347e3a6819b62fc81802baf854edd9", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug056.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug056.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug056.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug056.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d5d0f1d620e725202c2b5684967ebe47e989cf92", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug057.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug057.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug057.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug057.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e2b4a241a6326123ebd3e66792a0e8a7e9033356", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug058.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug058.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug058.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug058.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6a77367d6765abcf63a3ba3895eb06f88187bc29", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug059.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug059.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug059.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug059.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "82778b8386f3418d22f6f023c7afea35da20c1de", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug060.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug060.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug060.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug060.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "aedcf70fefe2190db04a8f12dd5788c73632e637", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug061.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug061.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug061.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug061.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "8ee5c84cb9d046bca187d34fe1b9ba617d2c42b1", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug062.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug062.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug062.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug062.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "543e0b7260784055a4cd252e0fc10c726e232799", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug063.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug063.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug063.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug063.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "92d2154236fe890a7b103e10c39c798c4158139d", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug064.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug064.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug064.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug064.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "a5d1bedddb977a83c2648fffc4a6e5d6f57ab449", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug065.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug065.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug065.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug065.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2fa5048f1bfe63904aecbf16070b9e2e30e09664", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug066.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug066.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug066.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug066.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b812f01169c817f6f485aea6587de6c6ad49b921", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug067.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug067.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug067.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug067.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "a7cf4239c43ea0d2f57e7c53b85953e1623e3057", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug068.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug068.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug068.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug068.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d6796cd72be19cdf4427c31208643f519d028633", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug069.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug069.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug069.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug069.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "6afdd467d995fa00ffa4e4de83fcec58624d7f6a", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug070.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug070.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug070.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug070.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "a5003ffb9762fe1ec3011b7744d56161f8cd471a", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug071.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug071.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug071.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug071.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "efe5626db591de4c054a64b79440633be575ef4e", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug072.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug072.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug072.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug072.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "99e7cd19ee41f4a368eda2bb14a964cce583b924", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug073.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug073.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug073.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug073.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7b6d14e7e63429957d5eb69c004eccdacc0aa28f", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug074.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug074.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug074.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug074.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "7aed13089dfaabb2f7ef88487443a9e1d2a432cf", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug075.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug075.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug075.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug075.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "065cecc015bcd46f31294e5d6038908c22097a91", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug076.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug076.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug076.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug076.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "08028ab10fa902acf1d103894514d74bff4734b4", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug077.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug077.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug077.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug077.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ddd3faeba41333e8b16cd73701b7367c892d65b4", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug078.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug078.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug078.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug078.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "a5003d29b1f3a262c24ce431b711412ed515b3a9", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug080.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug080.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug080.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug080.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ccb3699534345d6bacdea054a481805059731e25", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug081.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug081.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug081.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug081.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "8353ec200e4c633026abe1834f5cf520d254647c", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug082.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug082.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug082.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug082.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e312256c461d3930b7cf7c9a2763a436ec298954", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug083.dir/bug0.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.dir%2Fbug0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.dir%2Fbug0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.dir%2Fbug0.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "486fe760734e1f910fff048f020c0b6de9c7f0a1", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug083.dir/bug1.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.dir%2Fbug1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.dir%2Fbug1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.dir%2Fbug1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "984969d47f7071a0c9e348c5d79f7d313536d0a0", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug083.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug083.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c1054e550cc1702880211e47908711f352a2cee2", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug084.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug084.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug084.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug084.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "02be717534039bd903743737b56d0b4e7eab4f2c", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug085.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug085.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug085.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug085.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f96472fbb35728efd2e83ecacefee04ca239f3dd", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug086.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug086.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug086.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug086.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "4af8d976f876f18942645cc72194fc4b1087f0e0", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug087.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug087.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug087.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug087.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "af9d991e607dc16ef867526adf1ab150ac526ab9", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug088.dir/bug0.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.dir%2Fbug0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.dir%2Fbug0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.dir%2Fbug0.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "cadf0e698a565bf141a364e9da2edb1399601e62", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug088.dir/bug1.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.dir%2Fbug1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.dir%2Fbug1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.dir%2Fbug1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "9715a703cb156905cccc18da8e9581f60a5cf2c3", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug088.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug088.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "fd3dff3ec903d10554323165a33757ae219c1fe8", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug089.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug089.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug089.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug089.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "8318ab9c0c0ac1f78e924bc98dc9924b2940fa35", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug090.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug090.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug090.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug090.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "cfbb09cd820b1c747d1b977e316bddc86e451bc8", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug091.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug091.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug091.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug091.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "8f05c478f5c973813f8a21cb1cab48443990930e", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug092.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug092.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug092.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug092.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f80eee01fa7fb09815273a44f0a94ab51a1341c7", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug093.go", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug093.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug093.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug093.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "2953eb28d370be8084ce401cea88ee3c1c24defe", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug094.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug094.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug094.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug094.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "9be687a7bb4004aa22dde076b224d2d2a5bb240b", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug096.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug096.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug096.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug096.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "ec3c21543d336b2120932053b88fd510dce08256", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug097.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug097.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug097.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug097.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "1dad4d502aa17e0dd172c0f009db1d863a38c15e", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug098.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug098.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug098.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug098.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "f76f0e873cf8d1f81ca0c175c14815a89e2cd5b7", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug099.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug099.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug099.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug099.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "92487deaac64b2b9300f6c4785f36bf9041261ad", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug101.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug101.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug101.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug101.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "1d97eb4a8d34b7a62a4d640693df1a84d7f1a501", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug102.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug102.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug102.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug102.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "b789be1c4579dafd3c20ba225c9ca66c3671f8c1", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug103.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug103.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug103.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug103.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "dd4bb5834fe0993eda12443bc5680ed11885b3a0", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug104.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug104.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug104.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug104.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d9c26a00bd1c93c684d0eef8594fc11d9cd16171", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug106.dir/bug0.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.dir%2Fbug0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.dir%2Fbug0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.dir%2Fbug0.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "0f1d20e47d982dde412736b2a508362b3ac62567", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug106.dir/bug1.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.dir%2Fbug1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.dir%2Fbug1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.dir%2Fbug1.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "1874b204491203dee8e0f8976a8165ad053312d8", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug106.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug106.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "d0b062a65907de3b4485b00353265fa719adf731", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug107.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug107.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug107.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug107.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "5c7649f0819d3baafb9d773f7b5345a3a4dca31a", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug108.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug108.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug108.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug108.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "c679771f2ec107e6797e16410d6b230893290188", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug109.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug109.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug109.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug109.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "4e43d1c01b8051a450e9cd90b2d836322042ab9a", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug110.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug110.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug110.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug110.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}, {"sha": "e72b343ae3da482965d236b24d766bdd585e2705", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug111.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug111.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a9389330e91acc3ed05deac2d198af25d13cf3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug111.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug111.go?ref=7a9389330e91acc3ed05deac2d198af25d13cf3c"}]}