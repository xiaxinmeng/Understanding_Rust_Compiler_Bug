{"sha": "4dd1130557b74008d0404d3af7b384fba5edb8a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRkMTEzMDU1N2I3NDAwOGQwNDA0ZDNhZjdiMzg0ZmJhNWVkYjhhOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2019-03-24T15:20:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-03-24T15:20:52Z"}, "message": "re PR rtl-optimization/87761 ([MIPS] New FAIL: gcc.target/mips/fix-r4000-10.c   -O1 start with r265398)\n\n\tPR rtl-optimization/87761\n\t* regcprop.c (copyprop_hardreg_forward_1): Check may_trap_p on SET,\n\tnot INSN.  Also check RTX_FRAME_RELATED_P.  Queue insns for DF rescan\n\tas needed.\n\t(pass_cprop_hardreg::execute): Add df note problem and defer insn\n\trescans.  Reprocess blocks as needed, calling df_analyze before\n\treprocessing.  Always call df_analyze before fixing up debug bind\n\tinsns.\n\nFrom-SVN: r269896", "tree": {"sha": "05f29fc92c639b95be87b57d7447e70b47c638dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05f29fc92c639b95be87b57d7447e70b47c638dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dd1130557b74008d0404d3af7b384fba5edb8a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dd1130557b74008d0404d3af7b384fba5edb8a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dd1130557b74008d0404d3af7b384fba5edb8a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dd1130557b74008d0404d3af7b384fba5edb8a8/comments", "author": null, "committer": null, "parents": [{"sha": "866664a3813a97fda8c7b6ebdd32d10d4915bb83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866664a3813a97fda8c7b6ebdd32d10d4915bb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866664a3813a97fda8c7b6ebdd32d10d4915bb83"}], "stats": {"total": 90, "additions": 61, "deletions": 29}, "files": [{"sha": "4a5b122eedd45e409ea6ad7c47e5a6c70296a3e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dd1130557b74008d0404d3af7b384fba5edb8a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dd1130557b74008d0404d3af7b384fba5edb8a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4dd1130557b74008d0404d3af7b384fba5edb8a8", "patch": "@@ -1,3 +1,14 @@\n+2019-03-26  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/87761\n+\t* regcprop.c (copyprop_hardreg_forward_1): Check may_trap_p on SET,\n+\tnot INSN.  Also check RTX_FRAME_RELATED_P.  Queue insns for DF rescan\n+\tas needed.\n+\t(pass_cprop_hardreg::execute): Add df note problem and defer insn\n+\trescans.  Reprocess blocks as needed, calling df_analyze before\n+\treprocessing.  Always call df_analyze before fixing up debug bind\n+\tinsns.\n+\t\n 2019-03-23  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/xmmintrin.h (_mm_movemask_pi8): Implement for 32-bit\n@@ -8,7 +19,7 @@\n \t* config/aarch64/aarch64.md (zero_extendsidi2_aarch64): Fix type\n \tattrribute for uxtw.\n \n-2019-02-26  Jeff Law  <law@redhat.com>\n+2019-03-26  Jeff Law  <law@redhat.com>\n \n \tPR rtl-optimization/87761\n \t* config/mips/mips-protos.h (mips_split_move): Add new argument."}, {"sha": "8ca523ffe23adba6be1cd3197c3f76e466a21b14", "filename": "gcc/regcprop.c", "status": "modified", "additions": 49, "deletions": 28, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dd1130557b74008d0404d3af7b384fba5edb8a8/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dd1130557b74008d0404d3af7b384fba5edb8a8/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=4dd1130557b74008d0404d3af7b384fba5edb8a8", "patch": "@@ -800,8 +800,9 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \n       /* Detect obviously dead sets (via REG_UNUSED notes) and remove them.  */\n       if (set\n+\t  && !may_trap_p (set)\n+\t  && !RTX_FRAME_RELATED_P (insn)\n \t  && INSN_P (insn)\n-\t  && !may_trap_p (insn)\n \t  && find_reg_note (insn, REG_UNUSED, SET_DEST (set))\n \t  && !side_effects_p (SET_SRC (set))\n \t  && !side_effects_p (SET_DEST (set)))\n@@ -1034,6 +1035,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t     DEBUG_INSNs can be applied.  */\n \t  if (vd->n_debug_insn_changes)\n \t    note_uses (&PATTERN (insn), cprop_find_used_regs, vd);\n+\t  df_insn_rescan (insn);\n \t}\n \n       ksvd.vd = vd;\n@@ -1112,7 +1114,10 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \n \t  /* Notice copies.  */\n \t  if (copy_p)\n-\t    copy_value (SET_DEST (set), SET_SRC (set), vd);\n+\t    {\n+\t      df_insn_rescan (insn);\n+\t      copy_value (SET_DEST (set), SET_SRC (set), vd);\n+\t    }\n \t}\n \n       if (insn == BB_END (bb))\n@@ -1282,47 +1287,68 @@ pass_cprop_hardreg::execute (function *fun)\n {\n   struct value_data *all_vd;\n   basic_block bb;\n-  bool analyze_called = false;\n \n   all_vd = XNEWVEC (struct value_data, last_basic_block_for_fn (fun));\n \n   auto_sbitmap visited (last_basic_block_for_fn (fun));\n   bitmap_clear (visited);\n \n+  df_note_add_problem ();\n+\n+  /* It is tempting to set DF_LR_RUN_DCE, but DCE may choose to delete\n+     an insn and this pass would not have visibility into the removal.\n+     This pass would then potentially use the source of that\n+     INSN for propagation purposes, generating invalid code.\n+\n+     So we just ask for updated notes and handle trivial deletions\n+     within this pass where we can update this passes internal\n+     data structures appropriately.  */\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       bitmap_set_bit (visited, bb->index);\n \n-      /* If a block has a single predecessor, that we've already\n-\t processed, begin with the value data that was live at\n-\t the end of the predecessor block.  */\n-      /* ??? Ought to use more intelligent queuing of blocks.  */\n-      if (single_pred_p (bb)\n-\t  && bitmap_bit_p (visited, single_pred (bb)->index)\n-\t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n+      for (int pass = 0; pass < 2; pass++)\n \t{\n-\t  all_vd[bb->index] = all_vd[single_pred (bb)->index];\n-\t  if (all_vd[bb->index].n_debug_insn_changes)\n+\t  /* If a block has a single predecessor, that we've already\n+\t     processed, begin with the value data that was live at\n+\t    the end of the predecessor block.  */\n+\t  /* ??? Ought to use more intelligent queuing of blocks.  */\n+\t  if (single_pred_p (bb)\n+\t      && bitmap_bit_p (visited, single_pred (bb)->index)\n+\t      && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n \t    {\n-\t      unsigned int regno;\n-\n-\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t      all_vd[bb->index] = all_vd[single_pred (bb)->index];\n+\t      if (all_vd[bb->index].n_debug_insn_changes)\n \t\t{\n-\t\t  if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t\t  unsigned int regno;\n+\n+\t\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\t    {\n-\t\t      all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n-\t\t      if (--all_vd[bb->index].n_debug_insn_changes == 0)\n-\t\t\tbreak;\n+\t\t      if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t\t\t{\n+\t\t\t  all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n+\t\t\t  if (--all_vd[bb->index].n_debug_insn_changes == 0)\n+\t\t\t    break;\n+\t\t\t}\n \t\t    }\n \t\t}\n \t    }\n-\t}\n-      else\n-\tinit_value_data (all_vd + bb->index);\n+\t  else\n+\t    init_value_data (all_vd + bb->index);\n \n-      copyprop_hardreg_forward_1 (bb, all_vd + bb->index);\n+\t  /* If we were unable to propagate, then break the loop.  */\n+\t  if (!copyprop_hardreg_forward_1 (bb, all_vd + bb->index))\n+\t    break;\n+\t  df_analyze ();\n+\t}\n     }\n \n+  /* We must call df_analyze here unconditionally to ensure that the\n+     REG_UNUSED and REG_DEAD notes are consistent with and without -g.  */\n+  df_analyze ();\n+\n   if (MAY_HAVE_DEBUG_BIND_INSNS)\n     {\n       FOR_EACH_BB_FN (bb, fun)\n@@ -1332,11 +1358,6 @@ pass_cprop_hardreg::execute (function *fun)\n \t    unsigned int regno;\n \t    bitmap live;\n \n-\t    if (!analyze_called)\n-\t      {\n-\t\tdf_analyze ();\n-\t\tanalyze_called = true;\n-\t      }\n \t    live = df_get_live_out (bb);\n \t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t      if (all_vd[bb->index].e[regno].debug_insn_changes)"}]}