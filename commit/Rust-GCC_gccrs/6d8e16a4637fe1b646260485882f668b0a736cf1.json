{"sha": "6d8e16a4637fe1b646260485882f668b0a736cf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ4ZTE2YTQ2MzdmZTFiNjQ2MjYwNDg1ODgyZjY2OGIwYTczNmNmMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@unitus.it", "date": "2002-03-19T22:33:06Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2002-03-19T22:33:06Z"}, "message": "locale-inst.cc (__convert_from_v): Add an additional __size parameter in the declarations.\n\n2002-03-19  Paolo Carlini  <pcarlini@unitus.it>\n\t    Ulrich Drepper  <drepper@redhat.com>\n\n\t* src/locale-inst.cc (__convert_from_v): Add an additional\n\t__size parameter in the declarations.\n\t* include/bits/locale_facets.tcc\n\t(__convert_from_v): When available (that is,\n\t_GLIBCPP_USE_C99 defined) use snprintf instead of sprintf.\n\t(num_put::_M_convert_float): Depending on _GLIBCPP_USE_C99\n\tbeing defined or not, call and use __convert_from_v in the\n\tappropriate way.\n\t(num_put::_M_convert_int): Same here.\n\t(money_put::do_put(long double)): Same here.\n\nCo-Authored-By: Ulrich Drepper <drepper@redhat.com>\n\nFrom-SVN: r51050", "tree": {"sha": "9f539fec7bb1f4014bbdd77a0b9b316e9b070056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f539fec7bb1f4014bbdd77a0b9b316e9b070056"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d8e16a4637fe1b646260485882f668b0a736cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8e16a4637fe1b646260485882f668b0a736cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d8e16a4637fe1b646260485882f668b0a736cf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8e16a4637fe1b646260485882f668b0a736cf1/comments", "author": null, "committer": null, "parents": [{"sha": "1e82682ba4cdba6ec02c26aae84ed7a9ce5a1003", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e82682ba4cdba6ec02c26aae84ed7a9ce5a1003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e82682ba4cdba6ec02c26aae84ed7a9ce5a1003"}], "stats": {"total": 149, "additions": 117, "deletions": 32}, "files": [{"sha": "eca9f6f8a7df3a2d60793a698e0a5e8992e0042e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8e16a4637fe1b646260485882f668b0a736cf1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8e16a4637fe1b646260485882f668b0a736cf1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6d8e16a4637fe1b646260485882f668b0a736cf1", "patch": "@@ -1,3 +1,17 @@\n+2002-03-19  Paolo Carlini  <pcarlini@unitus.it>\n+            Ulrich Drepper  <drepper@redhat.com>\n+\n+\t* src/locale-inst.cc (__convert_from_v): Add an additional\n+\t__size parameter in the declarations.\n+\t* include/bits/locale_facets.tcc\n+\t(__convert_from_v): When available (that is,\n+\t_GLIBCPP_USE_C99 defined) use snprintf instead of sprintf.\n+\t(num_put::_M_convert_float): Depending on _GLIBCPP_USE_C99\n+\tbeing defined or not, call and use __convert_from_v in the\n+\tappropriate way.\n+\t(num_put::_M_convert_int): Same here.\n+\t(money_put::do_put(long double)): Same here.\n+\n 2002-03-19  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/html/faq/index.html (#3.6):  Rewrap and close <a href> tags."}, {"sha": "30e6632873772cc0f991acfe37ba38f50d11a633", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 97, "deletions": 26, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8e16a4637fe1b646260485882f668b0a736cf1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8e16a4637fe1b646260485882f668b0a736cf1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=6d8e16a4637fe1b646260485882f668b0a736cf1", "patch": "@@ -592,16 +592,15 @@ namespace std\n       return __beg;\n     }\n \n-\n-  // The following code uses sprintf() to convert floating point\n-  // values for insertion into a stream.  An optimization would be to\n-  // replace sprintf() with code that works directly on a wide buffer\n-  // and then use __pad to do the padding. It would be good\n-  // to replace sprintf() anyway to avoid accidental buffer overruns\n-  // and to gain back the efficiency that C++ provides by knowing up\n-  // front the type of the values to insert. This implementation\n-  // follows the C++ standard fairly directly as outlined in 22.2.2.2\n-  // [lib.locale.num.put]\n+  // The following code uses snprintf (or sprintf(), when _GLIBCPP_USE_C99\n+  // is not defined) to convert floating point values for insertion into a\n+  // stream.  An optimization would be to replace them with code that works\n+  // directly on a wide buffer and then use __pad to do the padding.\n+  // It would be good to replace them anyway to gain back the efficiency\n+  // that C++ provides by knowing up front the type of the values to insert.\n+  // Also, sprintf is dangerous since may lead to accidental buffer overruns.\n+  // This implementation follows the C++ standard fairly directly as\n+  // outlined in 22.2.2.2 [lib.locale.num.put]\n   template<typename _CharT, typename _OutIter>\n     template<typename _ValueT>\n       _OutIter\n@@ -613,13 +612,38 @@ namespace std\n \t// we get the full available precision.\n \tconst int __max_digits = numeric_limits<_ValueT>::digits10 + 1;\n \tstreamsize __prec = __io.precision();\n-\t// Protect against sprintf() buffer overflows.\n+\n \tif (__prec > static_cast<streamsize>(__max_digits))\n \t  __prec = static_cast<streamsize>(__max_digits);\n \n \t// Long enough for the max format spec.\n \tchar __fbuf[16];\n \n+\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n+\tint __len;\n+#ifdef _GLIBCPP_USE_C99\n+\t// First try a buffer perhaps big enough (for sure sufficient for\n+\t// non-ios_base::fixed outputs)\n+\tint __cs_size = __max_digits * 3;\n+\tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n+\n+\tconst bool __fp = _S_format_float(__io, __fbuf, __mod, __prec);\n+\tif (__fp)\n+\t  __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, _S_c_locale, __prec);\n+\telse\n+\t  __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, _S_c_locale);\n+\n+\t// If the buffer was not large enough, try again with the correct size.\n+\tif (__len >= __cs_size)\n+\t  {\n+\t    __cs_size = __len + 1; \n+\t    __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n+\t    if (__fp)\n+\t      __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, _S_c_locale, __prec);\n+\t    else\n+\t      __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, _S_c_locale);\n+\t  }\n+#else\n \t// Consider the possibility of long ios_base::fixed outputs\n \tconst bool __fixed = __io.flags() & ios_base::fixed;\n \tconst int __max_exp = numeric_limits<_ValueT>::max_exponent10;\n@@ -632,12 +656,11 @@ namespace std\n \t                              : __max_digits * 3;\n \tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n \n-\tint __len;\n-\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n \tif (_S_format_float(__io, __fbuf, __mod, __prec))\n-\t  __len = __convert_from_v(__cs, __fbuf, __v, _S_c_locale, __prec);\n+\t  __len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale, __prec);\n \telse\n-\t  __len = __convert_from_v(__cs, __fbuf, __v, _S_c_locale);\n+\t  __len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale);\n+#endif\n \treturn _M_widen_float(__s, __io, __fill, __cs, __len);\n       }\n \n@@ -649,13 +672,28 @@ namespace std\n \t\t     char __modl, _ValueT __v) const\n       {\n \t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n-\t// Leave room for \"+/-,\" \"0x,\" and commas. This size is\n-\t// arbitrary, but should work.\n-\tchar __cs[64];\n+\n \t// Long enough for the max format spec.\n \tchar __fbuf[16];\n \t_S_format_int(__io, __fbuf, __mod, __modl);\n-\tint __len = __convert_from_v(__cs, __fbuf, __v, _S_c_locale);\n+#ifdef _GLIBCPP_USE_C99\n+\t// First try a buffer perhaps big enough.\n+\tint __cs_size = 64;\n+\tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n+\tint __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, _S_c_locale);\n+\t// If the buffer was not large enough, try again with the correct size.\n+\tif (__len >= __cs_size)\n+\t  {\n+\t    __cs_size = __len + 1;\n+\t    __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n+\t    __len = __convert_from_v(__cs, __cs_size, __fbuf, __v, _S_c_locale);\n+\t  }\n+#else\n+\t// Leave room for \"+/-,\" \"0x,\" and commas. This size is\n+\t// arbitrary, but should be largely sufficient.\n+\tchar __cs[128];\n+\tint __len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale);\n+#endif\n \treturn _M_widen_int(__s, __io, __fill, __cs, __len);\n       }\n \n@@ -1111,12 +1149,26 @@ namespace std\n     { \n       const locale __loc = __io.getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+#ifdef _GLIBCPP_USE_C99\n+      // First try a buffer perhaps big enough.\n+      int __cs_size = 64;\n+      char* __cs = static_cast<char*>(__builtin_alloca(sizeof(char) * __cs_size));\n+      int __len = __convert_from_v(__cs, __cs_size, \"%.01Lf\", __units, _S_c_locale);\n+      // If the buffer was not large enough, try again with the correct size.\n+      if (__len >= __cs_size)\n+\t{\n+\t  __cs_size = __len + 1;\n+\t  __cs = static_cast<char*>(__builtin_alloca(sizeof(char) * __cs_size));\n+\t  __len = __convert_from_v(__cs, __cs_size, \"%.01Lf\", __units, _S_c_locale);\n+\t}\n+#else\n       // max_exponent10 + 1 for the integer part, + 4 for sign, decimal point,\n       // decimal digit, '\\0'. \n-      const int __n = numeric_limits<long double>::max_exponent10 + 5;\n-      char* __cs = static_cast<char*>(__builtin_alloca(sizeof(char) * __n));\n-      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n-      int __len = __convert_from_v(__cs, \"%.01Lf\", __units, _S_c_locale);\n+      const int __cs_size = numeric_limits<long double>::max_exponent10 + 5;\n+      char* __cs = static_cast<char*>(__builtin_alloca(sizeof(char) * __cs_size));\n+      int __len = __convert_from_v(__cs, 0, \"%.01Lf\", __units, _S_c_locale);\n+#endif\n+      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __cs_size));\n       __ctype.widen(__cs, __cs + __len, __ws);\n       string_type __digits(__ws);\n       return this->do_put(__s, __intl, __io, __fill, __digits); \n@@ -1894,20 +1946,39 @@ namespace std\n \t\t   const __c_locale& __cloc, int __base = 10);\n \n   // Convert numeric value of type _Tv to string and return length of string.\n+  // If snprintf is available use it, otherwise fall back to the unsafe sprintf\n+  // which, in general, can be dangerous and should be avoided.\n+#ifdef _GLIBCPP_USE_C99\n+  template<typename _Tv>\n+    int\n+    __convert_from_v(char* __out, const int __size, const char* __fmt,\n+\t\t     _Tv __v, const __c_locale&, int __prec = -1)\n+    {\n+      int __ret;\n+      const char* __old = setlocale(LC_ALL, \"C\");\n+      if (__prec >= 0)\n+        __ret = snprintf(__out, __size, __fmt, __prec, __v);\n+      else\n+        __ret = snprintf(__out, __size, __fmt, __v);\n+      setlocale(LC_ALL, __old);\n+      return __ret;\n+    }\n+#else\n   template<typename _Tv>\n     int\n-    __convert_from_v(char* __out, const char* __fmt, _Tv __v, \n+    __convert_from_v(char* __out, const int, const char* __fmt, _Tv __v,\n \t\t     const __c_locale&, int __prec = -1)\n     {\n       int __ret;\n       const char* __old = setlocale(LC_ALL, \"C\");\n       if (__prec >= 0)\n-\t__ret = sprintf(__out, __fmt, __prec, __v);\n+        __ret = sprintf(__out, __fmt, __prec, __v);\n       else\n-\t__ret = sprintf(__out, __fmt, __v);\n+        __ret = sprintf(__out, __fmt, __v);\n       setlocale(LC_ALL, __old);\n       return __ret;\n     }\n+#endif\n \n   // Construct correctly padded string, as per 22.2.2.2.2\n   // Assumes "}, {"sha": "8662c1065286c2fdade9f47e8c3563f7321941a2", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8e16a4637fe1b646260485882f668b0a736cf1/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8e16a4637fe1b646260485882f668b0a736cf1/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=6d8e16a4637fe1b646260485882f668b0a736cf1", "patch": "@@ -461,28 +461,28 @@ namespace std\n \n   template\n     int\n-    __convert_from_v(char*, const char*, double, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, double, const __c_locale&, int);\n \n   template\n     int\n-    __convert_from_v(char*, const char*, long double, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, long double, const __c_locale&, int);\n \n   template\n     int\n-    __convert_from_v(char*, const char*, long, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, long, const __c_locale&, int);\n \n   template\n     int\n-    __convert_from_v(char*, const char*, unsigned long, \n+    __convert_from_v(char*, const int, const char*, unsigned long, \n \t\t     const __c_locale&, int);\n \n   template\n     int\n-    __convert_from_v(char*, const char*, long long, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, long long, const __c_locale&, int);\n \n   template\n     int\n-    __convert_from_v(char*, const char*, unsigned long long, \n+    __convert_from_v(char*, const int, const char*, unsigned long long, \n \t\t     const __c_locale&, int);\n \n   template "}]}