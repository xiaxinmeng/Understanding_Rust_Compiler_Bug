{"sha": "9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiNzk4ZDc2Y2U0ZTc2ODJlMGFhMTg0NjI3NWU4ZmI2ZjY0ZjhjYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-03-11T14:52:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-03-11T14:52:57Z"}, "message": "function.h (frame_offset_overflow): Declare.\n\n\t* function.h (frame_offset_overflow): Declare.\n\t* function.c (frame_offset_overflow): New function.\n\t(assign_stack_local_1): Call it to detect that the offset overflows.\n\t* cfgexpand.c (alloc_stack_frame_space): Likewise.\n\nFrom-SVN: r111964", "tree": {"sha": "85ac110020df9a0d5ae2303c5c233d027bad4d3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85ac110020df9a0d5ae2303c5c233d027bad4d3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/comments", "author": null, "committer": null, "parents": [{"sha": "6dd3c0a5996256d8159c9c6be925114f692c398e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd3c0a5996256d8159c9c6be925114f692c398e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd3c0a5996256d8159c9c6be925114f692c398e"}], "stats": {"total": 52, "additions": 38, "deletions": 14}, "files": [{"sha": "4d2e41435e2fae42009b8bb77ca1dfef3853887f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "patch": "@@ -1,3 +1,10 @@\n+2006-03-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* function.h (frame_offset_overflow): Declare.\n+\t* function.c (frame_offset_overflow): New function.\n+\t(assign_stack_local_1): Call it to detect that the offset overflows.\n+\t* cfgexpand.c (alloc_stack_frame_space): Likewise.\n+\n 2006-03-11  Steven Bosscher  <stevenb.gcc@gmail.com>\n \n \t* config/sh/sh.c: Include alloc-pool.h."}, {"sha": "75d8e9d394b08860ca92d66c987555dd86c14c40", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "patch": "@@ -192,6 +192,9 @@ alloc_stack_frame_space (HOST_WIDE_INT size, HOST_WIDE_INT align)\n     }\n   frame_offset = new_frame_offset;\n \n+  if (frame_offset_overflow (frame_offset, cfun->decl))\n+    frame_offset = offset = 0;\n+\n   return offset;\n }\n "}, {"sha": "988d613c4d78982c57a3e21f6cbdb85287c0e2f6", "filename": "gcc/function.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "patch": "@@ -358,12 +358,33 @@ get_func_frame_size (struct function *f)\n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n    the caller may have to do that.  */\n+\n HOST_WIDE_INT\n get_frame_size (void)\n {\n   return get_func_frame_size (cfun);\n }\n \n+/* Issue an error message and return TRUE if frame OFFSET overflows in\n+   the signed target pointer arithmetics for function FUNC.  Otherwise\n+   return FALSE.  */\n+\n+bool\n+frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n+{  \n+  unsigned HOST_WIDE_INT size = FRAME_GROWS_DOWNWARD ? -offset : offset;\n+\n+  if (size > ((unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (Pmode) - 1))\n+\t       /* Leave room for the fixed part of the frame.  */\n+\t       - 64 * UNITS_PER_WORD)\n+    {\n+      error (\"%Jtotal size of local objects too large\", func);\n+      return TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it\n    with machine mode MODE.\n \n@@ -479,20 +500,8 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n   function->x_stack_slot_list\n     = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);\n \n-  /* Try to detect frame size overflows on native platforms.  */\n-#if BITS_PER_WORD >= 32\n-  if ((FRAME_GROWS_DOWNWARD\n-       ? (unsigned HOST_WIDE_INT) -function->x_frame_offset\n-       : (unsigned HOST_WIDE_INT) function->x_frame_offset)\n-\t> ((unsigned HOST_WIDE_INT) 1 << (BITS_PER_WORD - 1))\n-\t    /* Leave room for the fixed part of the frame.  */\n-\t    - 64 * UNITS_PER_WORD)\n-    {\n-      error (\"%Jtotal size of local objects too large\", function->decl);\n-      /* Avoid duplicate error messages as much as possible.  */\n-      function->x_frame_offset = 0;\n-    }\n-#endif\n+  if (frame_offset_overflow (function->x_frame_offset, function->decl))\n+    function->x_frame_offset = 0;\n \n   return x;\n }"}, {"sha": "1b2484e452242b677a684e330dcd4eae1ee3f546", "filename": "gcc/function.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=9fb798d76ce4e7682e0aa1846275e8fb6f64f8cc", "patch": "@@ -534,6 +534,11 @@ extern void free_block_changes (void);\n    the caller may have to do that.  */\n extern HOST_WIDE_INT get_frame_size (void);\n \n+/* Issue an error message and return TRUE if frame OFFSET overflows in\n+   the signed target pointer arithmetics for function FUNC.  Otherwise\n+   return FALSE.  */\n+extern bool frame_offset_overflow (HOST_WIDE_INT, tree);\n+\n /* A pointer to a function to create target specific, per-function\n    data structures.  */\n extern struct machine_function * (*init_machine_status) (void);"}]}