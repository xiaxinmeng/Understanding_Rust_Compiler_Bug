{"sha": "794511d20a377c604fa6b0752ad9ba0e035ccfb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0NTExZDIwYTM3N2M2MDRmYTZiMDc1MmFkOWJhMGUwMzVjY2ZiMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-02-10T22:52:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-02-10T22:52:51Z"}, "message": "alias.h (record_alias_subset): Declare.\n\n\t* alias.h (record_alias_subset): Declare.\n\t* alias.c (record_alias_subset): Make global.\nada/\n\t* gcc-interface/decl.c (enum alias_set_op): New enumeration.\n\t(copy_alias_set): Rename into...\n\t(relate_alias_sets): ...this. \u00a0Add third parameter OP. \u00a0Retrieve the\n\tunderlying array of unconstrained arrays for the new type as well.\n\tIf the old and new alias sets don't conflict, make one a subset of\n\tthe other as per the OP parameter.\n\t(gnat_to_gnu_entity): Adjust calls to copy_alias_set.\n\t<E_Record_Type>: Do not copy the alias set for derived types.\n\tFor all types, make the alias set of derived types a superset of\n\tthat of their parent type.\n\t(make_aligning_type): Adjust calls to copy_alias_set.\n\t(make_packable_type): Likewise.\n\t* gcc-interface/trans.c (gnat_to_gnu)<N_Validate_Unchecked_Conversion>:\n\tCheck for alias set conflict instead of strict equality to issue the\n\twarning.\n\nFrom-SVN: r144084", "tree": {"sha": "c6469e15d39deb72fd8e5bd7eaf74835dda07e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6469e15d39deb72fd8e5bd7eaf74835dda07e18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/794511d20a377c604fa6b0752ad9ba0e035ccfb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794511d20a377c604fa6b0752ad9ba0e035ccfb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/794511d20a377c604fa6b0752ad9ba0e035ccfb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794511d20a377c604fa6b0752ad9ba0e035ccfb0/comments", "author": null, "committer": null, "parents": [{"sha": "493e377c04278267043c9320532792e1ea40ae14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/493e377c04278267043c9320532792e1ea40ae14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/493e377c04278267043c9320532792e1ea40ae14"}], "stats": {"total": 228, "additions": 188, "deletions": 40}, "files": [{"sha": "ed15ef60a225dcd437cee3780ddc14a7c4523caa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -1,3 +1,8 @@\n+2009-02-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* alias.h (record_alias_subset): Declare.\n+\t* alias.c (record_alias_subset): Make global.\n+\n 2009-02-10  Nick Clifton  <nickc@redhat.com>\n \n \t* tree-parloops.c: Change license to GPLv3."}, {"sha": "1422cc3366a46b24dfafe8eb1acb4aba09e6c323", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -1,3 +1,22 @@\n+2009-02-10  Olivier Hainque  <hainque@adacore.com>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (enum alias_set_op): New enumeration.\n+\t(copy_alias_set): Rename into...\n+\t(relate_alias_sets): ...this.  Add third parameter OP.  Retrieve the\n+\tunderlying array of unconstrained arrays for the new type as well.\n+\tIf the old and new alias sets don't conflict, make one a subset of\n+\tthe other as per the OP parameter.\n+\t(gnat_to_gnu_entity): Adjust calls to copy_alias_set.\n+\t<E_Record_Type>: Do not copy the alias set for derived types.\n+\tFor all types, make the alias set of derived types a superset of\n+\tthat of their parent type.\n+\t(make_aligning_type): Adjust calls to copy_alias_set.\n+\t(make_packable_type): Likewise.\n+\t* gcc-interface/trans.c (gnat_to_gnu)<N_Validate_Unchecked_Conversion>:\n+\tCheck for alias set conflict instead of strict equality to issue the\n+\twarning.\n+\n 2009-02-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_String_Literal_Subtype>:"}, {"sha": "981b4518cb750e18c3ecda23af26693a24e11922", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 112, "deletions": 34, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -115,7 +115,15 @@ static VEC (tree,heap) *defer_finalize_list;\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n \n-static void copy_alias_set (tree, tree);\n+enum alias_set_op\n+{\n+  ALIAS_SET_COPY,\n+  ALIAS_SET_SUBSET,\n+  ALIAS_SET_SUPERSET\n+};\n+\n+static void relate_alias_sets (tree, tree, enum alias_set_op);\n+\n static tree substitution_list (Entity_Id, Entity_Id, tree, bool);\n static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute_to (struct attrib **,\n@@ -1632,7 +1640,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* Inherit our alias set from what we're a subtype of.  Subtypes\n \t are not different types and a pointer can designate any instance\n \t within a subtype hierarchy.  */\n-      copy_alias_set (gnu_type, TREE_TYPE (gnu_type));\n+      relate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n \n       /* If the type we are dealing with is to represent a packed array,\n \t we need to have the bits left justified on big-endian targets\n@@ -1674,7 +1682,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));\n \n-\t  copy_alias_set (gnu_type, gnu_field_type);\n+\t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \t}\n \n       /* If the type we are dealing with has got a smaller alignment than the\n@@ -1709,7 +1717,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_IS_PADDING_P (gnu_type) = 1;\n \t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));\n \n-\t  copy_alias_set (gnu_type, gnu_field_type);\n+\t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \t}\n \n       /* Otherwise reset the alignment lest we computed it above.  */\n@@ -1784,7 +1792,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Inherit our alias set from what we're a subtype of, as for\n \t   integer subtypes.  */\n-\tcopy_alias_set (gnu_type, TREE_TYPE (gnu_type));\n+\trelate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n       }\n     break;\n \n@@ -2477,7 +2485,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* Set our alias set to that of our base type.  This gives all\n \t     array subtypes the same alias set.  */\n-\t  copy_alias_set (gnu_type, gnu_base_type);\n+\t  relate_alias_sets (gnu_type, gnu_base_type, ALIAS_SET_COPY);\n \t}\n \n       /* If this is a packed type, make this type the same as the packed\n@@ -2617,7 +2625,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      gnu_index_type);\n \tif (array_type_has_nonaliased_component (gnat_entity, gnu_type))\n \t  TYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n-\tcopy_alias_set (gnu_type, gnu_string_type);\n+\trelate_alias_sets (gnu_type, gnu_string_type, ALIAS_SET_COPY);\n       }\n       break;\n \n@@ -2880,14 +2888,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (Is_Tagged_Type (gnat_entity) || Is_Limited_Record (gnat_entity))\n \t  SET_TYPE_MODE (gnu_type, BLKmode);\n \n-\t/* If this is a derived type, we must make the alias set of this type\n-\t   the same as that of the type we are derived from.  We assume here\n-\t   that the other type is already frozen.  */\n-\tif (Etype (gnat_entity) != gnat_entity\n-\t    && !(Is_Private_Type (Etype (gnat_entity))\n-\t\t && Full_View (Etype (gnat_entity)) == gnat_entity))\n-\t  copy_alias_set (gnu_type, gnat_to_gnu_type (Etype (gnat_entity)));\n-\n \t/* Fill in locations of fields.  */\n \tannotate_rep (gnat_entity, gnu_type);\n \n@@ -3003,7 +3003,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_SIZE_UNIT (gnu_type) = TYPE_SIZE_UNIT (gnu_base_type);\n \t      SET_TYPE_ADA_SIZE (gnu_type, TYPE_ADA_SIZE (gnu_base_type));\n \t      TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_base_type);\n-\t      copy_alias_set (gnu_type, gnu_base_type);\n+\t      relate_alias_sets (gnu_type, gnu_base_type, ALIAS_SET_COPY);\n \n \t      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n \t\tfor (gnu_temp = gnu_subst_list;\n@@ -4531,6 +4531,49 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     {\n       gnu_type = TREE_TYPE (gnu_decl);\n \n+      /* If this is a derived type, relate its alias set to that of its parent\n+\t to avoid troubles when a call to an inherited primitive is inlined in\n+\t a context where a derived object is accessed.  The inlined code works\n+\t on the parent view so the resulting code may access the same object\n+\t using both the parent and the derived alias sets, which thus have to\n+\t conflict.  As the same issue arises with component references, the\n+\t parent alias set also has to conflict with composite types enclosing\n+\t derived components.  For instance, if we have:\n+\n+\t    type D is new T;\n+\t    type R is record\n+\t       Component : D;\n+\t    end record;\n+\n+\t we want T to conflict with both D and R, in addition to R being a\n+\t superset of D by record/component construction.\n+\n+\t One way to achieve this is to perform an alias set copy from the\n+\t parent to the derived type.  This is not quite appropriate, though,\n+\t as we don't want separate derived types to conflict with each other:\n+\n+\t    type I1 is new Integer;\n+\t    type I2 is new Integer;\n+\n+\t We want I1 and I2 to both conflict with Integer but we do not want\n+\t I1 to conflict with I2, and an alias set copy on derivation would\n+\t have that effect.\n+\n+\t The option chosen is to make the alias set of the derived type a\n+\t superset of that of its parent type.  It trivially fulfills the\n+\t simple requirement for the Integer derivation example above, and\n+\t the component case as well by superset transitivity:\n+\n+\t\t   superset      superset\n+\t\tR ----------> D ----------> T\n+\n+\t The language rules ensure the parent type is already frozen here.  */\n+      if (Is_Derived_Type (gnat_entity))\n+\t{\n+\t  tree gnu_parent_type = gnat_to_gnu_type (Etype (gnat_entity));\n+\t  relate_alias_sets (gnu_type, gnu_parent_type, ALIAS_SET_SUPERSET);\n+\t}\n+\n       /* Back-annotate the Alignment of the type if not already in the\n \t tree.  Likewise for sizes.  */\n       if (Unknown_Alignment (gnat_entity))\n@@ -5158,11 +5201,16 @@ mark_out_of_scope (Entity_Id gnat_entity)\n     }\n }\n \f\n-/* Set the alias set of GNU_NEW_TYPE to be that of GNU_OLD_TYPE.  If this\n-   is a multi-dimensional array type, do this recursively.  */\n+/* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP.\n+   If this is a multi-dimensional array type, do this recursively.\n+\n+   OP may be\n+   - ALIAS_SET_COPY:     the new set is made a copy of the old one.\n+   - ALIAS_SET_SUPERSET: the new set is made a superset of the old one.\n+   - ALIAS_SET_SUBSET:   the new set is made a subset of the old one.  */\n \n static void\n-copy_alias_set (tree gnu_new_type, tree gnu_old_type)\n+relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n {\n   /* Remove any padding from GNU_OLD_TYPE.  It doesn't matter in the case\n      of a one-dimensional array, since the padding has the same alias set\n@@ -5173,30 +5221,60 @@ copy_alias_set (tree gnu_new_type, tree gnu_old_type)\n \t     || TYPE_IS_PADDING_P (gnu_old_type)))\n     gnu_old_type = TREE_TYPE (TYPE_FIELDS (gnu_old_type));\n \n-  /* We need to be careful here in case GNU_OLD_TYPE is an unconstrained\n-     array.  In that case, it doesn't have the same shape as GNU_NEW_TYPE,\n-     so we need to go down to what does.  */\n+  /* Unconstrained array types are deemed incomplete and would thus be given\n+     alias set 0.  Retrieve the underlying array type.  */\n   if (TREE_CODE (gnu_old_type) == UNCONSTRAINED_ARRAY_TYPE)\n     gnu_old_type\n       = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_old_type))));\n+  if (TREE_CODE (gnu_new_type) == UNCONSTRAINED_ARRAY_TYPE)\n+    gnu_new_type\n+      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_new_type))));\n \n   if (TREE_CODE (gnu_new_type) == ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (gnu_new_type)) == ARRAY_TYPE\n       && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_new_type)))\n-    copy_alias_set (TREE_TYPE (gnu_new_type), TREE_TYPE (gnu_old_type));\n+    relate_alias_sets (TREE_TYPE (gnu_new_type), TREE_TYPE (gnu_old_type), op);\n \n-  /* The alias set shouldn't be copied between array types with different\n-     aliasing settings because this can break the aliasing relationship\n-     between the array type and its element type.  */\n+  switch (op)\n+    {\n+    case ALIAS_SET_COPY:\n+      /* The alias set shouldn't be copied between array types with different\n+\t aliasing settings because this can break the aliasing relationship\n+\t between the array type and its element type.  */\n #ifndef ENABLE_CHECKING\n-  if (flag_strict_aliasing)\n+      if (flag_strict_aliasing)\n #endif\n-    gcc_assert (!(TREE_CODE (gnu_new_type) == ARRAY_TYPE\n-\t\t  && TREE_CODE (gnu_old_type) == ARRAY_TYPE\n-\t\t  && TYPE_NONALIASED_COMPONENT (gnu_new_type)\n-\t\t     != TYPE_NONALIASED_COMPONENT (gnu_old_type)));\n+\tgcc_assert (!(TREE_CODE (gnu_new_type) == ARRAY_TYPE\n+\t\t      && TREE_CODE (gnu_old_type) == ARRAY_TYPE\n+\t\t      && TYPE_NONALIASED_COMPONENT (gnu_new_type)\n+\t\t\t != TYPE_NONALIASED_COMPONENT (gnu_old_type)));\n+\n+      TYPE_ALIAS_SET (gnu_new_type) = get_alias_set (gnu_old_type);\n+      break;\n+\n+    case ALIAS_SET_SUBSET:\n+    case ALIAS_SET_SUPERSET:\n+      {\n+\talias_set_type old_set = get_alias_set (gnu_old_type);\n+\talias_set_type new_set = get_alias_set (gnu_new_type);\n+\n+\t/* Do nothing if the alias sets conflict.  This ensures that we\n+\t   never call record_alias_subset several times for the same pair\n+\t   or at all for alias set 0.  */\n+\tif (!alias_sets_conflict_p (old_set, new_set))\n+\t  {\n+\t    if (op == ALIAS_SET_SUBSET)\n+\t      record_alias_subset (old_set, new_set);\n+\t    else\n+\t      record_alias_subset (new_set, old_set);\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  TYPE_ALIAS_SET (gnu_new_type) = get_alias_set (gnu_old_type);\n   record_component_aliases (gnu_new_type);\n }\n \f\n@@ -5600,7 +5678,7 @@ make_aligning_type (tree type, unsigned int align, tree size,\n \n   SET_TYPE_MODE (record_type, BLKmode);\n \n-  copy_alias_set (record_type, type);\n+  relate_alias_sets (record_type, type, ALIAS_SET_COPY);\n   return record_type;\n }\n \f\n@@ -5722,7 +5800,7 @@ make_packable_type (tree type, bool in_record)\n     }\n \n   finish_record_type (new_type, nreverse (field_list), 2, true);\n-  copy_alias_set (new_type, type);\n+  relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n \n   /* If this is a padding record, we never want to make the size smaller\n      than what was specified.  For QUAL_UNION_TYPE, also copy the size.  */"}, {"sha": "17433e90d309f619e3918fe184f11d08eec1ebaf", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -4940,8 +4940,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t!= TYPE_DUMMY_P (gnu_target_desig_type))\n \t\t    || (TYPE_DUMMY_P (gnu_source_desig_type)\n \t\t\t&& gnu_source_desig_type != gnu_target_desig_type)\n-\t\t    || (get_alias_set (gnu_source_desig_type)\n-\t\t\t!= get_alias_set (gnu_target_desig_type))))\n+\t\t    || !alias_sets_conflict_p\n+\t\t\t(get_alias_set (gnu_source_desig_type),\n+\t\t\t get_alias_set (gnu_target_desig_type))))\n \t      {\n \t\tpost_error_ne\n \t\t  (\"?possible aliasing problem for type&\",\n@@ -4973,8 +4974,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t!= TYPE_DUMMY_P (gnu_target_array_type))\n \t\t    || (TYPE_DUMMY_P (gnu_source_array_type)\n \t\t\t&& gnu_source_array_type != gnu_target_array_type)\n-\t\t    || (get_alias_set (gnu_source_array_type)\n-\t\t\t!= get_alias_set (gnu_target_array_type))))\n+\t\t    || !alias_sets_conflict_p\n+\t\t\t(get_alias_set (gnu_source_array_type),\n+\t\t\t get_alias_set (gnu_target_array_type))))\n \t      {\n \t\tpost_error_ne\n \t\t  (\"?possible aliasing problem for type&\","}, {"sha": "d8d8e3f290dd03e2ed066f84091ff913a018361c", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -167,7 +167,6 @@ static rtx adjust_offset_for_component_ref (tree, rtx);\n static int write_dependence_p (const_rtx, const_rtx, int);\n \n static void memory_modified_1 (rtx, const_rtx, void *);\n-static void record_alias_subset (alias_set_type, alias_set_type);\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -735,7 +734,7 @@ new_alias_set (void)\n    It is illegal for SUPERSET to be zero; everything is implicitly a\n    subset of alias set zero.  */\n \n-static void\n+void\n record_alias_subset (alias_set_type superset, alias_set_type subset)\n {\n   alias_set_entry superset_entry;"}, {"sha": "dd197f0a68ab5e33f0fc99cf2473d2873e206230", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -36,6 +36,7 @@ extern alias_set_type get_varargs_alias_set (void);\n extern alias_set_type get_frame_alias_set (void);\n extern bool component_uses_parent_alias_set (const_tree);\n extern bool alias_set_subset_of (alias_set_type, alias_set_type);\n+extern void record_alias_subset (alias_set_type, alias_set_type);\n extern void record_component_aliases (tree);\n extern int alias_sets_conflict_p (alias_set_type, alias_set_type);\n extern int alias_sets_must_conflict_p (alias_set_type, alias_set_type);"}, {"sha": "d9a63e073be36c16873c86bfc4e88984cde3919e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -1,3 +1,8 @@\n+2009-02-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/aliasing3.adb: New test.\n+\t* gnat.dg/aliasing3_pkg.ad[sb]: New helper.\n+\n 2009-02-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/34397"}, {"sha": "916821c552d47ebce54895319794c2c2cc0bd15a", "filename": "gcc/testsuite/gnat.dg/aliasing3.adb", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3.adb?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -0,0 +1,10 @@\n+-- { dg-do run }\n+-- { dg-options \"-O2 -gnatn\" }\n+\n+with Aliasing3_Pkg; use Aliasing3_Pkg;\n+\n+procedure Aliasing3 is\n+begin\n+  Pointer.A(1) := 5;\n+  Test (Block.A);\n+end;"}, {"sha": "73c1e3e2cf3d6ef7abc53a82a3ce639f092c57ca", "filename": "gcc/testsuite/gnat.dg/aliasing3_pkg.adb", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3_pkg.adb?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -0,0 +1,10 @@\n+package body Aliasing3_Pkg is\n+\n+  procedure Test (A : Arr) is\n+  begin\n+    if A(1) /= 5 then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+end Aliasing3_Pkg;"}, {"sha": "4704a7c53963dbd8f0c592e2162c17ad0a65a221", "filename": "gcc/testsuite/gnat.dg/aliasing3_pkg.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794511d20a377c604fa6b0752ad9ba0e035ccfb0/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing3_pkg.ads?ref=794511d20a377c604fa6b0752ad9ba0e035ccfb0", "patch": "@@ -0,0 +1,19 @@\n+package Aliasing3_Pkg is\n+\n+  type Arr is array (1..3) of Integer;\n+\n+  procedure Test (A : Arr);\n+  pragma Inline (Test);\n+\n+  type My_Arr is new Arr;\n+\n+  type Rec is record\n+    A : My_Arr;\n+  end record;\n+\n+  type Ptr is access all Rec;\n+\n+  Block : aliased Rec;\n+  Pointer : Ptr := Block'Access;\n+\n+end Aliasing3_Pkg;"}]}