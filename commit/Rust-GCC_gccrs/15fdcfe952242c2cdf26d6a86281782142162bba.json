{"sha": "15fdcfe952242c2cdf26d6a86281782142162bba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVmZGNmZTk1MjI0MmMyY2RmMjZkNmE4NjI4MTc4MjE0MjE2MmJiYQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-12T16:15:18Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-12T16:15:18Z"}, "message": "Extensive changes.\n\n\ufffd\nExtensive changes.  See ChangeLog.\n\nFrom-SVN: r23621", "tree": {"sha": "0e0c77067b0cde2a4cd2a77e57acccb37045957c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e0c77067b0cde2a4cd2a77e57acccb37045957c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15fdcfe952242c2cdf26d6a86281782142162bba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fdcfe952242c2cdf26d6a86281782142162bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15fdcfe952242c2cdf26d6a86281782142162bba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fdcfe952242c2cdf26d6a86281782142162bba/comments", "author": null, "committer": null, "parents": [{"sha": "124728549279ad7f021d0f873b20fa51960a6168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124728549279ad7f021d0f873b20fa51960a6168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124728549279ad7f021d0f873b20fa51960a6168"}], "stats": {"total": 763, "additions": 393, "deletions": 370}, "files": [{"sha": "380cf50b68c4004eec1718f21538257fbd625149", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=15fdcfe952242c2cdf26d6a86281782142162bba", "patch": "@@ -191,16 +191,13 @@ java.install-info:\n \n java.mostlyclean:\n \t-rm -f java/*$(objext) $(DEMANGLER_PROG)\n-# CYGNUS LOCAL - Delete these files here instead of in realclean because they\n-# are now created in the build subdirectories.\n-\t-rm -f java/parse.c java/parse-scan.c java/parse.output java/y.tab.c\n java.clean:\n java.distclean:\n \t-rm -f java/config.status java/Makefile\n \t-rm -f java/parse.output\n java.extraclean:\n java.maintainer-clean:\n-\n+\t-rm -f java/parse.c java/parse-scan.c java/parse.output java/y.tab.c\n \f\n # Stage hooks:\n # The main makefile has already created stage?/java."}, {"sha": "c62507598926abd24e5b01ccc7dfa5aebfc4ebc8", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=15fdcfe952242c2cdf26d6a86281782142162bba", "patch": "@@ -431,6 +431,8 @@ init_decl_processing ()\n   TREE_TYPE (size_zero_node) = sizetype;\n   size_one_node = build_int_2 (1, 0);\n   TREE_TYPE (size_one_node) = sizetype;\n+  /* Used by the parser to represent empty statements and blocks. */\n+  CAN_COMPLETE_NORMALLY (size_zero_node) = 1;\n \n   byte_type_node = make_signed_type (8);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"byte\"), byte_type_node));"}, {"sha": "0df6106bcaa6305812b76dc53cfa261b97a4d993", "filename": "gcc/java/expr.c", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=15fdcfe952242c2cdf26d6a86281782142162bba", "patch": "@@ -1337,9 +1337,7 @@ build_known_method_ref (method, method_type, self_type, method_signature, arg_li\n      tree method, method_type, self_type, method_signature, arg_list;\n {\n   tree func;\n-  if (flag_emit_class_files)\n-    return method;\n-  else if (is_compiled_class (self_type))\n+  if (is_compiled_class (self_type))\n     {\n       make_decl_rtl (method, NULL, 1);\n       func = build1 (ADDR_EXPR, method_ptr_type_node, method);\n@@ -1696,6 +1694,18 @@ load_type_state (label)\n     type_map [i] = TREE_VEC_ELT (vec, i);\n }\n \n+/* Do the expansion of a Java switch. With Gcc, switches are front-end\n+   dependant things, but they rely on gcc routines. This function is\n+   placed here because it uses things defined locally in parse.y. */\n+\n+static tree\n+case_identity (t, v)\n+     tree t __attribute__ ((__unused__));\n+     tree v;\n+{\n+  return v;\n+}\n+\n struct rtx_def *\n java_lang_expand_expr (exp, target, tmode, modifier)\n      register tree exp;\n@@ -1716,6 +1726,7 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n       if (BLOCK_EXPR_BODY (exp))\n \t{\n \t  tree local;\n+\t  tree body = BLOCK_EXPR_BODY (exp);\n \t  struct rtx_def *to_return;\n \t  pushlevel (2);\t/* 2 and above */\n \t  expand_start_bindings (0);\n@@ -1727,16 +1738,41 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t      expand_decl (pushdecl (local));\n \t      local = next;\n \t    }\n-\t  to_return =\n-\t    expand_expr (BLOCK_EXPR_BODY (exp), target, tmode, modifier);\n+\t  /* Avoid deep recursion for long block.  */\n+\t  while (TREE_CODE (body) == COMPOUND_EXPR)\n+\t    {\n+\t      expand_expr (TREE_OPERAND (body, 0), const0_rtx, VOIDmode, 0);\n+\t      body = TREE_OPERAND (body, 1);\n+\t    }\n+\t  to_return = expand_expr (body, target, tmode, modifier);\n \t  poplevel (1, 1, 0);\n \t  expand_end_bindings (getdecls (), 1, 0);\n \t  return to_return;\n \t}\n       break;\n \n+    case CASE_EXPR:\n+      {\n+\ttree duplicate;\n+\tif (pushcase (TREE_OPERAND (exp, 0), case_identity,\n+\t\t      build_decl (LABEL_DECL, NULL_TREE, NULL_TREE), &duplicate) == 2)\n+\t  {\n+\t    EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (exp);\n+\t    parse_error_context\n+\t      (wfl_operator, \"Duplicate case label: `%s'\",\n+\t       print_int_node (TREE_OPERAND (exp, 0)));\n+\t  }\n+\treturn const0_rtx;\n+      }\n+\n+    case DEFAULT_EXPR:\n+      pushcase (NULL_TREE, 0, build_decl (LABEL_DECL, NULL_TREE, NULL_TREE), NULL);\n+      return const0_rtx;\n+\n     case SWITCH_EXPR:\n-      java_expand_switch (exp);\n+      expand_start_case (0, TREE_OPERAND (exp, 0), int_type_node, \"switch\");\n+      expand_expr_stmt (TREE_OPERAND (exp, 1));\n+      expand_end_case (TREE_OPERAND (exp, 0));\n       return const0_rtx;\n \n     case TRY_EXPR:"}, {"sha": "dfa05607ff3ff0f05326a4164c733baae591ce9e", "filename": "gcc/java/parse.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=15fdcfe952242c2cdf26d6a86281782142162bba", "patch": "@@ -439,6 +439,9 @@ static jdeplist *reverse_jdep_list ();\n \n #define BLOCK_EXPR_DECLS(NODE)  BLOCK_VARS(NODE)\n #define BLOCK_EXPR_BODY(NODE)   BLOCK_SUBBLOCKS(NODE)\n+\n+/* For an artificial BLOCK (created to house a local variable declaration not\n+   at the start of an existing block), the parent block;  otherwise NULL. */\n #define BLOCK_EXPR_ORIGIN(NODE) BLOCK_ABSTRACT_ORIGIN(NODE)\n \n /* Merge an other line to the source line number of a decl. Used to\n@@ -601,7 +604,7 @@ struct parser_ctxt {\n   tree import_list;\t\t    /* List of import */\n   tree import_demand_list;\t    /* List of import on demand */\n \n-  tree current_loop;\t\t     /* List of the currently nested loops */\n+  tree current_loop;\t\t     /* List of the currently nested loops/switches */\n   tree current_labeled_block;\t     /* List of currently nested\n \t\t\t\t\tlabeled blocks. */\n \n@@ -618,7 +621,6 @@ struct parser_ctxt {\n /* Functions declarations */\n #ifndef JC1_LITE\n static char *java_accstring_lookup PROTO ((int));\n-static void  parse_error PROTO ((char *));\n static void  classitf_redefinition_error PROTO ((char *,tree, tree, tree));\n static void  variable_redefinition_error PROTO ((tree, tree, tree, int));\n static void  check_modifiers PROTO ((char *, int, int));\n@@ -637,9 +639,8 @@ static tree lookup_java_method2 PROTO ((tree, tree, int));\n static tree method_header PROTO ((int, tree, tree, tree));\n static void fix_method_argument_names PROTO ((tree ,tree));\n static tree method_declarator PROTO ((tree, tree));\n-static void parse_error_context VPROTO ((tree cl, char *msg, ...));\n static void parse_warning_context VPROTO ((tree cl, char *msg, ...));\n-static void issue_warning_error_from_context PROTO ((tree, char *msg));\n+static void issue_warning_error_from_context PROTO ((tree, char *msg, va_list));\n static tree parse_jdk1_1_error PROTO ((char *));\n static void complete_class_report_errors PROTO ((jdep *));\n static int process_imports PROTO ((void));\n@@ -662,8 +663,8 @@ static tree resolve_expression_name PROTO ((tree, tree *));\n static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n static int check_class_interface_creation PROTO ((int, int, tree, \n \t\t\t\t\t\t  tree, tree, tree));\n-static tree patch_method_invocation_stmt PROTO ((tree, tree, tree, \n-\t\t\t\t\t\t int *, tree *, int));\n+static tree patch_method_invocation PROTO ((tree, tree, tree, \n+\t\t\t\t\t    int *, tree *, int));\n static int breakdown_qualified PROTO ((tree *, tree *, tree));\n static tree resolve_and_layout PROTO ((tree, tree));\n static tree resolve_no_layout PROTO ((tree, tree));"}, {"sha": "3dc35f47e1375f53dfea0616bb1411b44065aaa9", "filename": "gcc/java/parse.y", "status": "modified", "additions": 341, "deletions": 354, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fdcfe952242c2cdf26d6a86281782142162bba/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=15fdcfe952242c2cdf26d6a86281782142162bba", "patch": "@@ -99,7 +99,7 @@ static enum tree_code binop_lookup[19] =\n \n /* Fake WFL used to report error message. It is initialized once if\n    needed and reused with it's location information is overriden.  */\n-static tree wfl_operator = NULL_TREE;\n+tree wfl_operator = NULL_TREE;\n \n /* The \"$L\" identifier we use to create labels.  */\n static tree label_id = NULL_TREE;\n@@ -206,8 +206,6 @@ static tree wfl_to_string = NULL_TREE;\n \t\t\tvariable_initializers constructor_body\n \n %type\t <node>\t\tclass_body block_end\n-%type\t <node>\t\tblock_statement local_variable_declaration_statement\n-\t\t\tblock_statements local_variable_declaration\n %type\t <node>\t\tstatement statement_without_trailing_substatement\n \t\t\tlabeled_statement if_then_statement label_decl\n \t\t\tif_then_else_statement while_statement for_statement\n@@ -233,11 +231,8 @@ static tree wfl_to_string = NULL_TREE;\n \t\t\tleft_hand_side assignment for_header for_begin\n \t\t\tconstant_expression do_statement_begin empty_statement\n \t\t\tswitch_statement synchronized_statement throw_statement\n-\t\t\ttry_statement switch_expression switch_block\n-\t\t\tswitch_block_statement_groups switch_labels\n-\t\t\tswitch_block_statement_group switch_label\n-\t\t\tgroup_of_labels catches catch_clause \n-\t\t\tcatch_clause_parameter finally\n+\t\t\ttry_statement switch_expression\n+\t\t\tcatches catch_clause catch_clause_parameter finally\n %type    <node>         return_statement break_statement continue_statement\n \n %type    <operator>     ASSIGN_TK      MULT_ASSIGN_TK  DIV_ASSIGN_TK  \n@@ -982,9 +977,9 @@ block_statements:\n block_statement:\n \tlocal_variable_declaration_statement\n |\tstatement\n-\t\t{ $$ = java_method_add_stmt (current_function_decl, $1); }\n+\t\t{ java_method_add_stmt (current_function_decl, $1); }\n |\tclass_declaration\t/* Added, JDK1.1 inner classes */\n-\t\t{ $$ = parse_jdk1_1_error (\"inner class declaration\"); }\n+\t\t{ parse_jdk1_1_error (\"inner class declaration\"); }\n ;\n \n local_variable_declaration_statement:\n@@ -1162,9 +1157,16 @@ if_then_else_statement_nsi:\n ;\n \n switch_statement:\n-\tswitch_expression switch_block\n+\tswitch_expression\n+\t\t{\n+\t\t  enter_block ();\n+\t\t}\n+\tswitch_block\n \t\t{ \n-\t\t  TREE_OPERAND ($1, 1) = $2;\n+\t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n+\t\t     I.e. make the last statment also have its own COMPOUND_EXPR. */\n+\t\t  maybe_absorb_scoping_blocks ();\n+\t\t  TREE_OPERAND ($1, 1) = exit_block ();\n \t\t  $$ = build_debugable_stmt (EXPR_WFL_LINECOL ($1), $1);\n \t\t}\n ;\n@@ -1185,62 +1187,37 @@ switch_expression:\n \n switch_block:\n \tOCB_TK CCB_TK\n-\t\t{ $$ = NULL_TREE; }\n |\tOCB_TK switch_labels CCB_TK\n-\t\t{ $$ = build_tree_list ($2, NULL_TREE); }\n |\tOCB_TK switch_block_statement_groups CCB_TK\n-\t\t{ $$ = $2; }\n |\tOCB_TK switch_block_statement_groups switch_labels CCB_TK\n-\t\t{ \n-\t\t  /* Switch labels alone are empty switch statements */\n-\t\t  tree sl = build_tree_list ($3, NULL_TREE);\n-\t\t  TREE_CHAIN (sl) = $2;\n-\t\t  $$ = sl;\n-\t\t}\n ;\n \n switch_block_statement_groups: \n \tswitch_block_statement_group\n |\tswitch_block_statement_groups switch_block_statement_group\n-\t\t{ \n-\t\t  TREE_CHAIN ($2) = $1;\n-\t\t  $$ = $2;\n-\t\t}\n ;\n \n switch_block_statement_group:\n-\tgroup_of_labels block_statements\n-\t\t{ $$ = build_tree_list ($1, exit_block ()); }\n+\tswitch_labels block_statements\n ;\n \n-group_of_labels:\n-\tswitch_labels\n-\t\t{ \n-\t\t  /* All statements attached to this group of cases\n-\t\t     will be stored in a block */\n-\t\t  enter_block ();\n-\t\t  $$ = $1;\n-\t\t}\n-\n switch_labels:\n \tswitch_label\n |\tswitch_labels switch_label\n-\t\t{\n-\t\t  TREE_CHAIN ($2) = $1;\n-\t\t  $$ = $2;\n-\t\t}\n ;\n \n switch_label:\n \tCASE_TK constant_expression REL_CL_TK\n \t\t{ \n-\t\t  $$ = build1 (CASE_EXPR, NULL_TREE, $2);\n-\t\t  EXPR_WFL_LINECOL ($$) = $1.location;\n+\t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, $2);\n+\t\t  EXPR_WFL_LINECOL (lab) = $1.location;\n+\t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t}\n |\tDEFAULT_TK REL_CL_TK\n \t\t{ \n-\t\t  $$ = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n-\t\t  EXPR_WFL_LINECOL ($$) = $1.location;\n+\t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n+\t\t  EXPR_WFL_LINECOL (lab) = $1.location;\n+\t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t}\n |\tCASE_TK error\n \t\t{yyerror (\"Missing or invalid constant expression\"); RECOVER;}\n@@ -2259,19 +2236,15 @@ yyerror (msg)\n }\n \n static void\n-parse_error (msg)\n-     char *msg;\n-{\n-  java_error (NULL);\n-  java_error (msg);\n-}\n-\n-static void\n-issue_warning_error_from_context (cl, msg)\n+issue_warning_error_from_context (cl, msg, ap)\n      tree cl;\n      char *msg;\n+     va_list ap;\n {\n   char *saved;\n+  char buffer [4096];\n+  vsprintf (buffer, msg, ap);\n+  force_error = 1;\n \n   ctxp->elc.line = EXPR_WFL_LINENO (cl);\n   ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));\n@@ -2280,33 +2253,30 @@ issue_warning_error_from_context (cl, msg)\n   saved = ctxp->filename;\n   if (TREE_CODE (cl) == EXPR_WITH_FILE_LOCATION && EXPR_WFL_FILENAME_NODE (cl))\n     ctxp->filename = EXPR_WFL_FILENAME (cl);\n-  parse_error (msg);\n+  java_error (NULL);\n+  java_error (buffer);\n   ctxp->filename = saved;\n+  force_error = 0;\n }\n \n /* Issue an error message at a current source line CL */\n \n-static void\n+void\n parse_error_context VPROTO ((tree cl, char *msg, ...))\n {\n #ifndef __STDC__\n   tree cl;\n   char *msg;\n #endif\n-  char buffer [4096];\n-  char *saved;\n   va_list ap;\n \n   VA_START (ap, msg);\n #ifndef __STDC__\n   cl = va_arg (ap, tree);\n   msg = va_arg (ap, char *);\n #endif\n-  vsprintf (buffer, msg, ap);\n-\n-  force_error = 1;\n-  issue_warning_error_from_context (cl, buffer);\n-  force_error = 0;\n+  issue_warning_error_from_context (cl, msg, ap);\n+  va_end (ap);\n }\n \n /* Issue a warning at a current source line CL */\n@@ -2318,20 +2288,18 @@ parse_warning_context VPROTO ((tree cl, char *msg, ...))\n   tree cl;\n   char *msg;\n #endif\n-  char buffer [4096];\n-  char *saved;\n   va_list ap;\n \n   VA_START (ap, msg);\n #ifndef __STDC__\n   cl = va_arg (ap, tree);\n   msg = va_arg (ap, char *);\n #endif\n-  vsprintf (buffer, msg, ap);\n \n-  force_error = do_warning = 1;\n-  issue_warning_error_from_context (cl, buffer);\n-  do_warning = force_error = 0;\n+  do_warning = 1;\n+  issue_warning_error_from_context (cl, msg, ap);\n+  force_error = 0;\n+  va_end (ap);\n }\n \n void\n@@ -2624,7 +2592,7 @@ add_superinterfaces (decl, interface_list)\n    defined.  */\n   for (node = interface_list; node; node = TREE_CHAIN (node))\n     {\n-      tree current = TREE_PURPOSE (node), interface_decl;\n+      tree current = TREE_PURPOSE (node);\n       tree idecl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (current));\n       if (idecl && CLASS_LOADED_P (TREE_TYPE (idecl)))\n \t{\n@@ -3614,7 +3582,6 @@ void\n safe_layout_class (class)\n      tree class;\n {\n-  tree list;\n   tree save_current_class = current_class;\n   char *save_input_filename = input_filename;\n   int save_lineno = lineno;\n@@ -4789,7 +4756,6 @@ resolve_package (pkg, next)\n {\n   tree type_name = NULL_TREE;\n   char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (pkg));\n-  int   length = IDENTIFIER_LENGTH (EXPR_WFL_NODE (pkg));\n \n   /* The trick is to determine when the package name stops and were\n      the name of something contained in the package starts. Then we\n@@ -5153,21 +5119,10 @@ static tree\n add_stmt_to_compound (existing, type, stmt)\n      tree existing, type, stmt;\n {\n-  tree node;\n-\n-  if (existing && (TREE_CODE (existing) == COMPOUND_EXPR)\n-      && TREE_OPERAND (existing, 1) == size_zero_node)\n-    {\n-      TREE_OPERAND (existing, 1) = stmt;\n-      TREE_TYPE (existing) = type;\n-      return existing;\n-    }\n-  else if (existing)\n-    node = build (COMPOUND_EXPR, type, existing, stmt);\n+  if (existing)\n+    return build (COMPOUND_EXPR, type, existing, stmt);\n   else\n-    node = build (COMPOUND_EXPR, type, stmt, size_zero_node);\n-  \n-  return node;\n+    return stmt;\n }\n \n /* Hold THIS for the scope of the current public method decl.  */\n@@ -5726,7 +5681,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \t\t\t\t     type_found, DECL_NAME (decl));\n       if (field_ref == error_mark_node)\n \treturn error_mark_node;\n-      if (is_static && !static_final_found)\n+      if (is_static && !static_final_found\n+\t  && ! flag_emit_class_files)\n \t{\n \t  field_ref = build_class_init (type_found, field_ref);\n \t  /* If the static field was identified by an expression that\n@@ -5785,8 +5741,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  if (complete_function_arguments (qual_wfl))\n \t    return 1;\n \t  *where_found = \n-\t    patch_method_invocation_stmt (qual_wfl, decl, type,\n-\t\t\t\t\t  &is_static, NULL, from_super);\n+\t    patch_method_invocation (qual_wfl, decl, type,\n+\t\t\t\t     &is_static, NULL, from_super);\n \t  if (*where_found == error_mark_node)\n \t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (*where_found);\n@@ -6147,6 +6103,8 @@ check_deprecation (wfl, decl)\n \tcase TYPE_DECL:\n \t  strcpy (the, \"class\");\n \t  break;\n+\tdefault:\n+\t  fatal (\"unexpected DECL code - check_deprecation\");\n \t}\n       parse_warning_context \n \t(wfl, \"The %s `%s' in class `%s' has been deprecated\", \n@@ -6207,12 +6165,12 @@ maybe_access_field (decl, where, type)\n   return decl;\n }\n \n-/* Build a method invocation statement, by patching PATCH. If non NULL\n+/* Build a method invocation, by patching PATCH. If non NULL\n    and according to the situation, PRIMARY and WHERE may be\n    used. IS_STATIC is set to 1 if the invoked function is static. */\n \n static tree\n-patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n+patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n      tree patch, primary, where;\n      int *is_static;\n      tree *ret_decl;\n@@ -6485,7 +6443,6 @@ patch_invoke (patch, method, args, from_super)\n {\n   int im;\n   tree dtable, func;\n-  tree signature = build_java_signature (TREE_TYPE (method));\n   tree original_call, t, ta;\n \n   /* Last step for args: convert build-in types. If we're dealing with\n@@ -6500,31 +6457,39 @@ patch_invoke (patch, method, args, from_super)\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n   \n-  switch ((im = invocation_mode (method, from_super)))\n+  if (flag_emit_class_files)\n+    func = method;\n+  else\n     {\n-    case INVOKE_VIRTUAL:\n-      dtable = invoke_build_dtable (0, args);\n-      func = build_invokevirtual (dtable, method);\n-      break;\n+      tree signature = build_java_signature (TREE_TYPE (method));\n+      switch ((im = invocation_mode (method, from_super)))\n+\t{\n+\tcase INVOKE_VIRTUAL:\n+\t  dtable = invoke_build_dtable (0, args);\n+\t  func = build_invokevirtual (dtable, method);\n+\t  break;\n \n-    case INVOKE_SUPER:\n-    case INVOKE_STATIC:\n-      func = build_known_method_ref (method, TREE_TYPE (method),\n-\t\t\t\t     DECL_CONTEXT (method), signature, args);\n-      break;\n+\tcase INVOKE_SUPER:\n+\tcase INVOKE_STATIC:\n+\t  func = build_known_method_ref (method, TREE_TYPE (method),\n+\t\t\t\t\t DECL_CONTEXT (method),\n+\t\t\t\t\t signature, args);\n+\t  break;\n \n-    case INVOKE_INTERFACE:\n-      dtable = invoke_build_dtable (1, args);\n-      func = build_invokeinterface (dtable, DECL_NAME (method), signature);\n-      break;\n+\tcase INVOKE_INTERFACE:\n+\t  dtable = invoke_build_dtable (1, args);\n+\t  func = build_invokeinterface (dtable, DECL_NAME (method), signature);\n+\t  break;\n \n-    default:\n-      fatal (\"Unknown invocation mode `%d' - build_invoke\", im);\n-      return NULL_TREE;\n+\tdefault:\n+\t  fatal (\"Unknown invocation mode `%d' - build_invoke\", im);\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* Ensure self_type is initialized, (invokestatic). FIXME */\n+      func = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (method)), func);\n     }\n \n-  /* Ensure self_type is initialized, (invokestatic). FIXME */\n-  func = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (method)), func);\n   TREE_TYPE (patch) = TREE_TYPE (TREE_TYPE (method));\n   TREE_OPERAND (patch, 0) = func;\n   TREE_OPERAND (patch, 1) = args;\n@@ -6539,6 +6504,11 @@ patch_invoke (patch, method, args, from_super)\n     {\n       tree class = DECL_CONTEXT (method);\n       tree c1, saved_new, size, new;\n+      if (flag_emit_class_files)\n+\t{\n+\t  TREE_TYPE (patch) = build_pointer_type (class);\n+\t  return patch;\n+\t}\n       if (!TYPE_SIZE (class))\n \tsafe_layout_class (class);\n       size = size_in_bytes (class);\n@@ -7023,11 +6993,66 @@ java_complete_tree (node)\n \t  IDENTIFIER_LOCAL_VALUE (DECL_NAME (cn)) = cn;\n \t  INITIALIZED_P (cn) = 0;\n \t}\n-      if (BLOCK_EXPR_BODY (node))\n+      if (BLOCK_EXPR_BODY (node) == NULL_TREE)\n+\t  CAN_COMPLETE_NORMALLY (node) = 1;\n+      else\n \t{\n-\t  BLOCK_EXPR_BODY (node) = java_complete_tree (BLOCK_EXPR_BODY (node));\n-\t  if (BLOCK_EXPR_BODY (node) == error_mark_node)\n+\t  tree stmt = BLOCK_EXPR_BODY (node);\n+\t  tree *ptr;\n+\t  int error_seen = 0;\n+\t  if (TREE_CODE (stmt) == COMPOUND_EXPR)\n+\t    {\n+\t      /* Re-order from (((A; B); C); ...; Z) to (A; (B; (C ; (...; Z)))).\n+\t\t This makes it easier to scan the statements left-to-right\n+\t\t without using recursion (which might overflow the stack\n+\t\t if the block has many statements. */\n+\t      for (;;)\n+\t\t{\n+\t\t  tree left = TREE_OPERAND (stmt, 0);\n+\t\t  if (TREE_CODE (left) != COMPOUND_EXPR)\n+\t\t    break;\n+\t\t  TREE_OPERAND (stmt, 0) = TREE_OPERAND (left, 1);\n+\t\t  TREE_OPERAND (left, 1) = stmt;\n+\t\t  stmt = left;\n+\t\t}\n+\t      BLOCK_EXPR_BODY (node) = stmt;\n+\t    }\n+\n+\t  /* Now do the actual complete, without deep recursion for long blocks. */\n+\t  ptr = &BLOCK_EXPR_BODY (node);\n+\t  while (TREE_CODE (*ptr) == COMPOUND_EXPR)\n+\t    {\n+\t      tree cur = java_complete_tree (TREE_OPERAND (*ptr, 0));\n+\t      tree *next = &TREE_OPERAND (*ptr, 1);\n+\t      TREE_OPERAND (*ptr, 0) = cur;\n+\t      if (TREE_CODE (cur) == ERROR_MARK)\n+\t\terror_seen++;\n+\t      else if (! CAN_COMPLETE_NORMALLY (cur))\n+\t\t{\n+\t\t  wfl_op2 = *next;\n+\t\t  for (;;)\n+\t\t    {\n+\t\t      if (TREE_CODE (wfl_op2) == BLOCK)\n+\t\t\twfl_op2 = BLOCK_EXPR_BODY (wfl_op2);\n+\t\t      else if (TREE_CODE (wfl_op2) == COMPOUND_EXPR)\n+\t\t\twfl_op2 = TREE_OPERAND (wfl_op2, 0);\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  if (TREE_CODE (wfl_op2) != CASE_EXPR\n+\t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n+\t\t    {\n+\t\t      SET_WFL_OPERATOR (wfl_operator, *ptr, wfl_op2);\n+\t\t      parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t\t    }\n+\t\t}\n+\t      ptr = next;\n+\t    }\n+\t  *ptr = java_complete_tree (*ptr);\n+\n+\t  if (TREE_CODE (*ptr) == ERROR_MARK || error_seen > 0)\n \t    return error_mark_node;\n+\t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (*ptr);\n \t}\n       /* Turn local bindings to null */\n       for (cn = BLOCK_EXPR_DECLS (node); cn; cn = TREE_CHAIN (cn))\n@@ -7041,6 +7066,7 @@ java_complete_tree (node)\n     case THROW_EXPR:\n       wfl_op1 = TREE_OPERAND (node, 0);\n       COMPLETE_CHECK_OP_0 (node);\n+      /* CAN_COMPLETE_NORMALLY (node) = 0; */\n       return patch_throw_statement (node, wfl_op1);\n \n     case SYNCHRONIZED_EXPR:\n@@ -7058,13 +7084,67 @@ java_complete_tree (node)\n \tCOMPLETE_CHECK_OP_1 (node);\n       TREE_TYPE (node) = void_type_node;\n       POP_LABELED_BLOCK ();\n+      if (CAN_COMPLETE_NORMALLY (LABELED_BLOCK_BODY (node)))\n+\tCAN_COMPLETE_NORMALLY (node) = 1;\n       return node;\n \n     case EXIT_BLOCK_EXPR:\n       /* We don't complete operand 1, because it's the return value of\n          the EXIT_BLOCK_EXPR which doesn't exist it Java */\n       return patch_bc_statement (node);\n \n+    case CASE_EXPR:\n+      cn = java_complete_tree (TREE_OPERAND (node, 0));\n+      if (cn == error_mark_node)\n+\treturn cn;\n+\n+      /* First, the case expression must be constant */\n+      cn = fold (cn);\n+\n+      if (!TREE_CONSTANT (cn))\n+\t{\n+\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n+\t  parse_error_context (node, \"Constant expression required\");\n+\t  return error_mark_node;\n+\t}\n+\n+      nn = ctxp->current_loop;\n+\n+      /* It must be assignable to the type of the switch expression. */\n+      if (!try_builtin_assignconv (NULL_TREE, TREE_TYPE (TREE_OPERAND (nn, 0)), cn))\n+\t{\n+\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n+\t  parse_error_context \n+\t    (wfl_operator,\n+\t     \"Incompatible type for case. Can't convert `%s' to `int'\",\n+\t     lang_printable_name (TREE_TYPE (cn), 0));\n+\t  return error_mark_node;\n+\t}\n+\n+      cn = fold (convert (int_type_node, cn));\n+\n+      /* Multiple instance of a case label bearing the same\n+\t value is checked during code generation. The case\n+\t expression is allright so far. */\n+      TREE_OPERAND (node, 0) = cn;\n+      CAN_COMPLETE_NORMALLY (node) = 1;\n+      break;\n+\n+    case DEFAULT_EXPR:\n+      nn = ctxp->current_loop;\n+      /* Only one default label is allowed per switch statement */\n+      if (SWITCH_HAS_DEFAULT (nn))\n+\t{\n+\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n+\t  parse_error_context (wfl_operator, \n+\t\t\t       \"Duplicate case label: `default'\");\n+\t  return error_mark_node;\n+\t}\n+      else\n+\tSWITCH_HAS_DEFAULT (nn) = 1;\n+      CAN_COMPLETE_NORMALLY (node) = 1;\n+      break;\n+\n     case SWITCH_EXPR:\n     case LOOP_EXPR:\n       PUSH_LOOP (node);\n@@ -7086,7 +7166,11 @@ java_complete_tree (node)\n       /* If we returned something different, that's because we\n          inserted a label. Pop the label too. */\n       if (nn != node)\n-\tPOP_LABELED_BLOCK ();\n+\t{\n+\t  if (CAN_COMPLETE_NORMALLY (node))\n+\t    CAN_COMPLETE_NORMALLY (nn) = 1;\n+\t  POP_LABELED_BLOCK ();\n+\t}\n       POP_LOOP ();\n       return nn;\n \n@@ -7121,24 +7205,38 @@ java_complete_tree (node)\n \n       /* 3- Expression section */\n     case COMPOUND_EXPR:\n-      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));\n+      wfl_op2 = TREE_OPERAND (node, 1);\n+      TREE_OPERAND (node, 0) = nn = java_complete_tree (TREE_OPERAND (node, 0));\n+      if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK)\n+\t{\n+\t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n+\t  parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t}\n       TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n       if (TREE_OPERAND (node, 1) == error_mark_node)\n \treturn error_mark_node;\n       TREE_TYPE (node) = TREE_TYPE (TREE_OPERAND (node, 1));\n+      CAN_COMPLETE_NORMALLY (node)\n+\t= CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n       break;\n \n     case RETURN_EXPR:\n+      /* CAN_COMPLETE_NORMALLY (node) = 0; */\n       return patch_return (node);\n \n     case EXPR_WITH_FILE_LOCATION:\n       if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n \t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n-        return resolve_expression_name (node, NULL);\n+\t{\n+\t  node = resolve_expression_name (node, NULL);\n+\t  CAN_COMPLETE_NORMALLY (node) = 1;\n+\t}\n       else\n \t{\n-\t  EXPR_WFL_NODE (node) = java_complete_tree (EXPR_WFL_NODE (node));\n+\t  tree body = java_complete_tree (EXPR_WFL_NODE (node));\n+\t  EXPR_WFL_NODE (node) = body;\n \t  TREE_SIDE_EFFECTS (node) = 1;\n+\t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n \t  if (EXPR_WFL_NODE (node) == error_mark_node)\n \t    {\n \t      /* Its important for the evaluation of assignment that\n@@ -7148,6 +7246,7 @@ java_complete_tree (node)\n \t    }\n \t  else\n \t    TREE_TYPE (node) = TREE_TYPE (EXPR_WFL_NODE (node));\n+\t  \n \t}\n       break;\n \n@@ -7175,10 +7274,12 @@ java_complete_tree (node)\n \t}\n       /* They complete the array creation expression, if no errors\n          were found. */\n+      CAN_COMPLETE_NORMALLY (node) = 1;\n       return (flag ? error_mark_node : patch_newarray (node));\n \n     case NEW_CLASS_EXPR:\n     case CALL_EXPR:\n+      CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Complete function's argument(s) first */\n       if (complete_function_arguments (node))\n \treturn error_mark_node;\n@@ -7187,8 +7288,8 @@ java_complete_tree (node)\n \t  tree decl, wfl = TREE_OPERAND (node, 0);\n \t  int in_this = CALL_THIS_CONSTRUCTOR_P (node);\n \n-\t  node = patch_method_invocation_stmt (node, NULL_TREE, \n-\t\t\t\t\t       NULL_TREE, 0, &decl, 0);\n+\t  node = patch_method_invocation (node, NULL_TREE,\n+\t\t\t\t\t  NULL_TREE, 0, &decl, 0);\n \t  if (node != error_mark_node)\n \t    {\n \t      check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n@@ -7228,14 +7329,6 @@ java_complete_tree (node)\n       nn = java_complete_tree (TREE_OPERAND (node, 1));\n       if (nn == error_mark_node)\n \t{\n-\t  /* It's hopeless, but we can further things on to discover\n-\t     an error during the assignment. In any cases, the\n-\t     assignment operation fails. */\n-\t  if (TREE_CODE (TREE_OPERAND (node, 1)) != EXPR_WITH_FILE_LOCATION\n-\t      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node\n-\t      && TREE_TYPE (TREE_OPERAND (node, 1)))\n-\t    patch_assignment (node, wfl_op1, wfl_op2);\n-\n \t  /* Now, we still mark the lhs as initialized */\n \t  if (DECL_P (TREE_OPERAND (node, 0)))\n \t    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;\n@@ -7249,7 +7342,9 @@ java_complete_tree (node)\n \t STRING_CST or a StringBuffer at this stage */\n       if ((nn = patch_string (TREE_OPERAND (node, 1))))\n \tTREE_OPERAND (node, 1) = nn;\n-      return patch_assignment (node, wfl_op1, wfl_op2);\n+      node = patch_assignment (node, wfl_op1, wfl_op2);\n+      CAN_COMPLETE_NORMALLY (node) = 1;\n+      return node;\n \n     case MULT_EXPR:\n     case PLUS_EXPR:\n@@ -7275,6 +7370,7 @@ java_complete_tree (node)\n       wfl_op1 = TREE_OPERAND (node, 0);\n       wfl_op2 = TREE_OPERAND (node, 1);\n \n+      CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Don't complete string nodes if dealing with the PLUS operand. */\n       if (TREE_CODE (node) != PLUS_EXPR || !JSTRING_P (wfl_op1))\n \t{\n@@ -7307,6 +7403,7 @@ java_complete_tree (node)\n       /* There are cases were wfl_op1 is a WFL. patch_unaryop knows\n \t how to handle those cases. */\n       wfl_op1 = TREE_OPERAND (node, 0);\n+      CAN_COMPLETE_NORMALLY (node) = 1;\n       TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n@@ -7352,6 +7449,7 @@ java_complete_tree (node)\n       return current_this;\n \n     default:\n+      CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Ok: may be we have a STRING_CST or a crafted `StringBuffer'\n \t and it's time to turn it into the appropriate String object\n \t */\n@@ -7607,7 +7705,7 @@ build_assignment (op, op_location, lhs, rhs)\n \n /* Print an INTEGER_CST node in a static buffer, and return the buffer. */\n \n-static char *\n+char *\n print_int_node (node)\n     tree node;\n {\n@@ -8072,6 +8170,17 @@ valid_cast_to_p (source, dest)\n    converted to type DEST through the methond invocation conversion\n    process (5.3) */\n \n+static tree\n+do_unary_numeric_promotion (arg)\n+     tree arg;\n+{\n+  tree type = TREE_TYPE (arg);\n+  if (TREE_CODE (type) == INTEGER_TYPE ? TYPE_PRECISION (type) < 32\n+      : TREE_CODE (type) == CHAR_TYPE)\n+    arg = convert (int_type_node, arg);\n+  return arg;\n+}\n+\n static int\n valid_method_invocation_conversion_p (dest, source)\n      tree dest, source;\n@@ -8275,8 +8384,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n \n       /* Unary numeric promotion (5.6.1) is performed on each operand\n          separatly */\n-      op1 = convert (promote_type (op1_type), op1);\n-      op2 = convert (promote_type (op2_type), op2);\n+      op1 = do_unary_numeric_promotion (op1);\n+      op2 = do_unary_numeric_promotion (op2);\n \n       /* The type of the shift expression is the type of the promoted\n          type of the left-hand operand */\n@@ -8291,7 +8400,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t\t\t   build_int_2 (0x3f, 0)));\n \n       /* The >>> operator is a >> operating on unsigned quantities */\n-      if (code == URSHIFT_EXPR)\n+      if (code == URSHIFT_EXPR && ! flag_emit_class_files)\n \t{\n \t  op1 = convert (unsigned_type (prom_type), op1);\n \t  TREE_SET_CODE (node, RSHIFT_EXPR);\n@@ -8325,6 +8434,11 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t  /* If the first operand is null, the result is always false */\n \t  if (op1 == null_pointer_node)\n \t    return boolean_false_node;\n+\t  else if (flag_emit_class_files)\n+\t    {\n+\t      TREE_OPERAND (node, 1) = op2_type;\n+\t      return node;\n+\t    }\n \t  /* Otherwise we have to invoke instance of to figure it out */\n \t  else\n \t    {\n@@ -8665,10 +8779,13 @@ patch_string_cst (node)\n      tree node;\n {\n   int location;\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-  node = get_identifier (TREE_STRING_POINTER (node));\n-  location = alloc_name_constant (CONSTANT_String, node);\n-  node = build_ref_from_constant_pool (location);\n+  if (! flag_emit_class_files)\n+    {\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      node = get_identifier (TREE_STRING_POINTER (node));\n+      location = alloc_name_constant (CONSTANT_String, node);\n+      node = build_ref_from_constant_pool (location);\n+    }\n   TREE_TYPE (node) = promote_type (string_type_node);\n   TREE_CONSTANT (node) = 1;\n   return node;\n@@ -8821,8 +8938,8 @@ patch_unaryop (node, wfl_op)\n       /* Unary numeric promotion is performed on operand */\n       else\n \t{\n-\t  prom_type = promote_type (op_type);\n-\t  op = convert (prom_type, op);\n+\t  op = do_unary_numeric_promotion (op);\n+\t  prom_type = TREE_TYPE (op);\n \t  if (code == UNARY_PLUS_EXPR)\n \t    node = op;\n \t}\n@@ -8838,8 +8955,8 @@ patch_unaryop (node, wfl_op)\n \t}\n       else\n \t{\n-\t  prom_type = promote_type (op_type);\n-\t  op = convert (prom_type, op);\n+\t  op = do_unary_numeric_promotion (op);\n+\t  prom_type = TREE_TYPE (op);\n \t}\n       break;\n \n@@ -8859,22 +8976,11 @@ patch_unaryop (node, wfl_op)\n     case CONVERT_EXPR:\n       value = patch_cast (node, wfl_operator);\n       if (value == error_mark_node)\n-\t{\n-\t  TREE_TYPE (node) = error_mark_node;\n-\t  error_found = 1;\n-\t}\n-      else\n-\tnode = value;\n+\treturn value;\n+      node = value;\n       break;\n     }\n   \n-  /* Check variable initialization */\n-  if (not_initialized_as_it_should_p (op))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op, DECL_NAME (op));\n-      INITIALIZED_P (op) = 1;\n-    }\n-  \n   if (error_found)\n     return error_mark_node;\n   /* In the case of UNARY_PLUS_EXPR, we replaced NODE by a new one */\n@@ -8958,7 +9064,16 @@ patch_cast (node, wfl_operator)\n          conversion (5.2) */\n \n       if (valid_ref_assignconv_cast_p (op_type, cast_type, 0))\n-\treturn node;\n+\t{\n+\t  TREE_SET_CODE (node, NOP_EXPR);\n+\t  return node;\n+\t}\n+\n+      if (flag_emit_class_files)\n+\t{\n+\t  TREE_SET_CODE (node, CONVERT_EXPR);\n+\t  return node;\n+\t}\n \n       /* The cast requires a run-time check */\n       return build (CALL_EXPR, promote_type (cast_type),\n@@ -9009,17 +9124,10 @@ patch_array_ref (node, wfl_array, wfl_index)\n   tree array_type  = TREE_TYPE (array);\n   tree index = TREE_OPERAND (node, 1);\n   tree index_type = TREE_TYPE (index);\n-  tree promoted_index_type;\n   int error_found = 0;\n \n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n-  if (not_initialized_as_it_should_p (array))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (wfl_array, DECL_NAME (array));\n-      INITIALIZED_P (array) = 1;\n-    }\n-\n   if (TREE_CODE (array_type) == POINTER_TYPE)\n     array_type = TREE_TYPE (array_type);\n \n@@ -9035,8 +9143,8 @@ patch_array_ref (node, wfl_array, wfl_index)\n \n   /* The array index underdoes unary numeric promotion. The promoted\n      type must be int */\n-  promoted_index_type = promote_type (index_type);\n-  if (promoted_index_type != int_type_node)\n+  index = do_unary_numeric_promotion (index);\n+  if (TREE_TYPE (index) != int_type_node)\n     {\n       int could_cast = valid_cast_to_p (index_type, int_type_node);\n       parse_error_context \n@@ -9049,26 +9157,15 @@ patch_array_ref (node, wfl_array, wfl_index)\n       error_found = 1;\n     }\n \n-  /* Now if the index is a var/parm decl, check on its initialization */\n-  if (not_initialized_as_it_should_p (index))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (wfl_index, DECL_NAME (index));\n-      INITIALIZED_P (index) = 1;\n-    }\n-\n   if (error_found)\n     return error_mark_node;\n-  index = convert (promoted_index_type, index);\n \n   array_type = TYPE_ARRAY_ELEMENT (array_type);\n-  if (TREE_CODE (array_type) == RECORD_TYPE \n-      && !JPRIMITIVE_TYPE_P (TREE_TYPE (array_type)))\n-    array_type = promote_type (array_type);\n \n   if (flag_emit_class_files)\n     {\n-      TREE_OPERAND (node, 0)= array;\n-      TREE_OPERAND (node, 1)= index;\n+      TREE_OPERAND (node, 0) = array;\n+      TREE_OPERAND (node, 1) = index;\n     }\n   else\n     node = build_java_arrayaccess (array, array_type, index);\n@@ -9100,7 +9197,6 @@ patch_newarray (node)\n   int error_found = 0;\n   int ndims = 0;\n   int xdims = TREE_INT_CST_LOW (TREE_OPERAND (node, 2));\n-  int total_dims;\n \n   /* Dimension types are verified. It's better for the types to be\n      verified in order. */\n@@ -9120,7 +9216,7 @@ patch_newarray (node)\n \t promoted type must be int. */\n       else\n \t{\n-\t  dim = convert (promote_type (TREE_TYPE (dim)), dim);\n+\t  dim = do_unary_numeric_promotion (dim);\n \t  if (TREE_TYPE (dim) != int_type_node)\n \t    dim_error = 1;\n \t}\n@@ -9138,15 +9234,6 @@ patch_newarray (node)\n \t  error_found = 1;\n \t}\n \n-      /* Check for uninitialized variables */\n-      if (not_initialized_as_it_should_p (dim))\n-\t{\n-\t  ERROR_VARIABLE_NOT_INITIALIZED (TREE_PURPOSE (cdim), \n-\t\t\t\t\t  DECL_NAME (dim));\n-\t  INITIALIZED_P (dim) = 1;\n-\t  error_found = 1;\n-\t}\n-\n       TREE_PURPOSE (cdim) = NULL_TREE;\n     }\n \n@@ -9162,12 +9249,30 @@ patch_newarray (node)\n       return error_mark_node;\n     }\n \n+  /* Set array_type to the actual (promoted) array type of the result. */\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    type = build_pointer_type (type);\n+  while (--xdims >= 0)\n+    {\n+      type = promote_type (build_java_array_type (type, -1));\n+    }\n+  dims = nreverse (dims);\n+  array_type = type;\n+  for (cdim = dims; cdim; cdim = TREE_CHAIN (cdim))\n+    {\n+      type = array_type;\n+      array_type = build_java_array_type (type,\n+\t\t\t\t\t  TREE_CODE (cdim) == INTEGER_CST ?\n+\t\t\t\t\t  TREE_INT_CST_LOW (cdim) : -1);\n+      array_type = promote_type (array_type);\n+    }\n+  dims = nreverse (dims);\n+\n   /* The node is transformed into a function call. Things are done\n      differently according to the number of dimensions. If the number\n      of dimension is equal to 1, then the nature of the base type\n      (primitive or not) matters. */\n-  total_dims = xdims + ndims;\n-  if (total_dims == 1)\n+  if (ndims == 1)\n     {\n       if (JPRIMITIVE_TYPE_P (type))\n \t{\n@@ -9193,28 +9298,16 @@ patch_newarray (node)\n \t  return build_newarray (type_code, TREE_VALUE (dims));\n \t}\n       else\n-\treturn build_anewarray (type, TREE_VALUE (dims));\n+\treturn build_anewarray (TREE_TYPE (type), TREE_VALUE (dims));\n     }\n   \n-  /* Add extra dimensions as unknown dimensions */\n-  while (xdims--)\n-    dims = \n-      chainon (dims, build_tree_list (NULL_TREE, integer_negative_one_node));\n-  dims = chainon (dims, build_tree_list (NULL_TREE, integer_zero_node));\n-\n   /* Can't reuse what's already written in expr.c because it uses the\n      JVM stack representation. Provide a build_multianewarray. FIXME */\n-  array_type = type;\n-  for (cdim = TREE_CHAIN (dims); cdim; cdim = TREE_CHAIN (cdim))\n-    array_type = build_java_array_type (promote_type (array_type), \n-\t\t\t\t\tTREE_CODE (cdim) == INTEGER_CST ?\n-\t\t\t\t\tTREE_INT_CST_LOW (cdim) : -1);\n-  return build (CALL_EXPR,\n-\t\tpromote_type (array_type),\n+  return build (CALL_EXPR, array_type,\n \t\tbuild_address_of (soft_multianewarray_node),\n-\t\ttree_cons (NULL_TREE, build_class_ref (array_type),\n+\t\ttree_cons (NULL_TREE, build_class_ref (TREE_TYPE (array_type)),\n \t\t\t   tree_cons (NULL_TREE, \n-\t\t\t\t      build_int_2 (total_dims, 0), dims )),\n+\t\t\t\t      build_int_2 (ndims, 0), dims )),\n \t\tNULL_TREE);\n }\n \n@@ -9363,6 +9456,9 @@ patch_if_else_statement (node)\n   \n   TREE_TYPE (node) = void_type_node;\n   TREE_SIDE_EFFECTS (node) = 1;\n+  CAN_COMPLETE_NORMALLY (node)\n+    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0))\n+    | CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n   return node;\n }\n \n@@ -9676,9 +9772,11 @@ patch_bc_statement (node)\n       /* Everything looks good. We can fix the `continue' jump to go\n          at the place in the loop were the continue is. The continue\n \t is the current labeled block, by construction. */\n-      EXIT_BLOCK_LABELED_BLOCK (node) = ctxp->current_labeled_block;\n+      EXIT_BLOCK_LABELED_BLOCK (node) = bc_label = ctxp->current_labeled_block;\n     }\n \n+  CAN_COMPLETE_NORMALLY (bc_label) = 1;\n+\n   /* Our break/continue don't return values. */\n   TREE_TYPE (node) = void_type_node;\n   /* Encapsulate the break within a compound statement so that it's\n@@ -9714,6 +9812,15 @@ patch_exit_expr (node)\n      return */\n   TREE_OPERAND (node, 0) = \n     fold (build1 (TRUTH_NOT_EXPR, boolean_type_node, expression));\n+\n+  if (! integer_zerop (TREE_OPERAND (node, 0))\n+      && ctxp->current_loop != NULL_TREE\n+      && TREE_CODE (ctxp->current_loop) == LOOP_EXPR)\n+    CAN_COMPLETE_NORMALLY (ctxp->current_loop) = 1;\n+  if (! integer_onep (TREE_OPERAND (node, 0)))\n+    CAN_COMPLETE_NORMALLY (node) = 1;\n+\n+\n   TREE_TYPE (node) = void_type_node;\n   return node;\n }\n@@ -9724,9 +9831,7 @@ static tree\n patch_switch_statement (node)\n      tree node;\n {\n-  int error_found = 0;\n   tree se = TREE_OPERAND (node, 0), se_type, sb;\n-  tree default_found = NULL_TREE;\n \n   /* Complete the switch expression */\n   se = TREE_OPERAND (node, 0) = java_complete_tree (se);\n@@ -9744,150 +9849,21 @@ patch_switch_statement (node)\n       return error_mark_node;\n     }\n \n-  /* Process the switch body. We should have a list of TREE_LIST. The\n-     PURPOSE of each node should be a list of case values, VALUE\n-     should be the associated block. We try to process all cases and\n-     defaults before returning, possibly finding errors.  */\n-  TREE_OPERAND (node, 1) = nreverse (TREE_OPERAND (node, 1));\n-  for (sb = TREE_OPERAND (node, 1); sb; sb = TREE_CHAIN (sb))\n-    {\n-      tree label;\n-\n-      /* If we don't have a TREE_LIST here, we have a statement inside\n-\t the switch that isn't tied to a label. This error is caught\n-\t by the parser and we don't have to report it here. */\n-\n-      TREE_PURPOSE (sb) = nreverse (TREE_PURPOSE (sb));\n-      for (label = TREE_PURPOSE (sb); label; label = TREE_CHAIN (label))\n-\t{\n-\t  tree case_expr;\n-\t  \n-\t  /* Verification of the default label */\n-\t  if (TREE_CODE (label) == DEFAULT_EXPR)\n-\t    {\n-\t      /* Only one default label is allowed per switch\n-                 statement */\n-\t      if (default_found)\n-\t\t{\n-\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n-\t\t  parse_error_context (wfl_operator, \n-\t\t\t\t       \"Duplicate case label: `default'\");\n-\t\t  error_found = 1;\n-\t\t}\n-\t      else\n-\t\tdefault_found = label;\n-\t      continue;\n-\t    }\n-\t  /* Verification of case labels */\n-\t  else\n-\t    {\n-\t      case_expr = java_complete_tree (TREE_OPERAND (label, 0));\n-\t      if (case_expr == error_mark_node)\n-\t\tcontinue;\n-\n-\t      /* First, the case expression must be constant */\n-\t      case_expr = fold (case_expr);\n-\t      if (!TREE_CONSTANT (case_expr))\n-\t\t{\n-\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n-\t\t  parse_error_context (label, \"Constant expression required\");\n-\t\t  error_found = 1;\n-\t\t  break;\n-\t\t}\n-\t      \n-\t      /* It must be assignable to the type of the switch\n-\t\t expression. */\n-\t      if (!try_builtin_assignconv (NULL_TREE, se_type, case_expr))\n-\t\t{\n-\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n-\t\t  parse_error_context \n-\t\t    (wfl_operator,\n-\t\t     \"Incompatible type for case. Can't convert `%s' to `int'\",\n-\t\t     lang_printable_name (TREE_TYPE (case_expr), 0));\n-\t\t  error_found = 1;\n-\t\t  break;\n-\t\t}\n-\n-\t      /* Multiple instance of a case label bearing the same\n-                 value is checked during code generation. The case\n-                 expression is allright so far. */\n-\t      TREE_OPERAND (label, 0) = case_expr;\n-\t    }\n-\t}\n-\n-      /* First TREE_VALUE should be the block tied to this list of\n-         cases. Check that this block exists and the walk it */\n-      if (TREE_VALUE (sb))\n-\t{\n-\t  TREE_VALUE (sb) = java_complete_tree (TREE_VALUE (sb));\n-\t  if (TREE_VALUE (sb) == error_mark_node)\n-\t    error_found = 1;\n-\t}\n-    }\n+  TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n \n   /* Ready to return */\n-  if (error_found)\n+  if (TREE_CODE (TREE_OPERAND (node, 1)) == ERROR_MARK)\n     {\n       TREE_TYPE (node) = error_mark_node;\n       return error_mark_node;\n     }\n   TREE_TYPE (node) = void_type_node;\n   TREE_SIDE_EFFECTS (node) = 1;\n+  CAN_COMPLETE_NORMALLY (node)\n+    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1)) ||\t! SWITCH_HAS_DEFAULT (node);\n   return node;\n }\n \n-/* Do the expansion of a Java switch. With Gcc, switches are front-end\n-   dependant things, but they rely on gcc routines. This function is\n-   placed here because it uses things defined locally in parse.y. */\n-\n-static tree case_identity (t, v)\n-     tree t __attribute__ ((__unused__));\n-     tree v;\n-{\n-  return v;\n-}\n-\n-void\n-java_expand_switch (exp)\n-     tree exp;\n-{\n-  tree sb;\n-  expand_start_case (0, TREE_OPERAND (exp, 0), int_type_node, \"switch\");\n-\n-  for (sb = TREE_OPERAND (exp, 1); sb; sb = TREE_CHAIN (sb))\n-    {\n-      /* We have a list of TREE_LIST. PURPOSE is the case value, and\n-\t when it exists, VALUE is the associated block */\n-      \n-      /* The first CASE element should contain the associated block,\n-\t if any. All other should be case statements related to the\n-\t same block */\n-      tree label;\n-      for (label = TREE_PURPOSE (sb); label; label = TREE_CHAIN (label))\n-\t{\n-\t  tree label_decl = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\t  if (TREE_CODE (label) == CASE_EXPR)\n-\t    {\n-\t      tree duplicate;\n-\t      if (pushcase (TREE_OPERAND (label, 0), case_identity,\n-\t\t\t    label_decl, &duplicate) == 2)\n-\t\t{\n-\t\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (label);\n-\t\t  parse_error_context\n-\t\t    (wfl_operator, \"Duplicate case label: `%s'\",\n-\t\t     print_int_node (TREE_OPERAND (label, 0)));\n-\t\t}\n-\t    }\n-\t  else\n-\t    pushcase (NULL_TREE, 0, label_decl, NULL);\n-\t}\n-      /* Expand the associated block, if any */\n-      if (TREE_VALUE (sb))\n-\texpand_expr_stmt (TREE_VALUE (sb));\n-    } \n-  expand_end_case (TREE_OPERAND (exp, 0));\n-}\n-\n /* 14.18 The try statement */\n \n /* Wrap BLOCK around a LABELED_BLOCK, set DECL to the newly generated\n@@ -9926,7 +9902,7 @@ build_try_statement (location, try_block, catches, finally)\n {\n   tree node, rff;\n \n-  if (finally)\n+  if (finally && ! flag_emit_class_files)\n     {\n       /* This block defines a scope for the entire try[-catch]-finally\n \t sequence. It hold a local variable used to return from the\n@@ -9993,7 +9969,8 @@ build_try_statement (location, try_block, catches, finally)\n   /* If we have a finally, surround this whole thing by a block where\n      the RFF local variable is defined. */\n \n-  return (finally ? build_expr_block (node, rff) : node);\n+  return (finally && ! flag_emit_class_files ? build_expr_block (node, rff)\n+\t  : node);\n }\n \n /* Get the catch clause block from an element of the catch clause\n@@ -10100,13 +10077,6 @@ patch_try_statement (node)\n \t      break;\n \t    }\n \t}\n-      if (unreachable)\n-\tcontinue;\n-\n-      /* Things to do here: the exception must be thrown */\n-\n-      /* Link this type to the caught type list */\n-      caught_type_list = tree_cons (NULL_TREE, carg_type, caught_type_list);\n \n       /* Complete the catch clause block */\n       catch_block = java_complete_tree (TREE_OPERAND (current, 0));\n@@ -10115,21 +10085,36 @@ patch_try_statement (node)\n \t  error_found = 1;\n \t  continue;\n \t}\n+      if (CAN_COMPLETE_NORMALLY (catch_block))\n+\tCAN_COMPLETE_NORMALLY (node) = 1;\n       TREE_OPERAND (current, 0) = catch_block;\n+\n+      if (unreachable)\n+\tcontinue;\n+\n+      /* Things to do here: the exception must be thrown */\n+\n+      /* Link this type to the caught type list */\n+      caught_type_list = tree_cons (NULL_TREE, carg_type, caught_type_list);\n+\n     }\n \n   PUSH_EXCEPTIONS (caught_type_list);\n   if ((try = java_complete_tree (try)) == error_mark_node)\n     error_found = 1;\n+  if (CAN_COMPLETE_NORMALLY (try))\n+    CAN_COMPLETE_NORMALLY (node) = 1;\n   POP_EXCEPTIONS ();\n \n   /* Process finally */\n   if (finally)\n     {\n-      FINALLY_EXPR_BLOCK (finally) = \n-\tjava_complete_tree (FINALLY_EXPR_BLOCK (finally));\n-      if (FINALLY_EXPR_BLOCK (finally) == error_mark_node)\n+      current = java_complete_tree (FINALLY_EXPR_BLOCK (finally));\n+      FINALLY_EXPR_BLOCK (finally) = current;\n+      if (current == error_mark_node)\n \terror_found = 1;\n+      if (! CAN_COMPLETE_NORMALLY (current))\n+\tCAN_COMPLETE_NORMALLY (node) = 0;\n     }\n \n   /* Verification ends here */\n@@ -10276,7 +10261,8 @@ patch_throw_statement (node, wfl_op1)\n      unchecked exception or its value is always caught by some try\n      statement that contains it. FIXME, static initializer. */\n   \n-  BUILD_THROW (node, expr);\n+  if (! flag_emit_class_files)\n+    BUILD_THROW (node, expr);\n   return node;\n }\n \n@@ -10447,5 +10433,6 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n \n   TREE_TYPE (node) = resulting_type;\n   TREE_SET_CODE (node, COND_EXPR);\n+  CAN_COMPLETE_NORMALLY (node) = 1;\n   return node;\n }"}]}