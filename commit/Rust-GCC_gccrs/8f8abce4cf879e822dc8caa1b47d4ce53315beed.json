{"sha": "8f8abce4cf879e822dc8caa1b47d4ce53315beed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY4YWJjZTRjZjg3OWU4MjJkYzhjYWExYjQ3ZDRjZTUzMzE1YmVlZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-06-16T18:09:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-16T18:09:34Z"}, "message": "re PR tree-optimization/22035 (complex float comparison broken)\n\n        PR tree-opt/22035\n        * builtins.c (fold_builtin_complex_mul): Remove.\n        (fold_builtin_complex_div): Remove.\n        (fold_builtin_1): Don't call them.\n        * fold-const.c (fold_complex_add, fold_complex_mult_parts,\n        fold_complex_mult, fold_complex_div_parts, fold_complex_div): Remove.\n        (fold_binary): Don't call them.  Don't expand complex comparisons to\n        elementary comparisons.\n        * tree-complex.c (init_dont_simulate_again): Enhance search for\n        stmts that require decomposition.\n        (complex_visit_stmt): Handle RETURN_EXPR properly.\n        (create_components): Handle no referenced variables properly.\n        * tree.h (fold_complex_mult_parts): Remove.\n        (fold_complex_div_parts): Remove.\n\nFrom-SVN: r101086", "tree": {"sha": "1a237f09f037eeb1745ba50100af6c885b4f29ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a237f09f037eeb1745ba50100af6c885b4f29ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f8abce4cf879e822dc8caa1b47d4ce53315beed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f8abce4cf879e822dc8caa1b47d4ce53315beed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f8abce4cf879e822dc8caa1b47d4ce53315beed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f8abce4cf879e822dc8caa1b47d4ce53315beed/comments", "author": null, "committer": null, "parents": [{"sha": "2f84b963e9556be5bc0219aec23941ea15b61596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f84b963e9556be5bc0219aec23941ea15b61596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f84b963e9556be5bc0219aec23941ea15b61596"}], "stats": {"total": 482, "additions": 71, "deletions": 411}, "files": [{"sha": "f3dff19d71eb5b3773db4f5253c7c4b8fee09dbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f8abce4cf879e822dc8caa1b47d4ce53315beed", "patch": "@@ -1,3 +1,20 @@\n+2005-06-16  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/22035\n+\t* builtins.c (fold_builtin_complex_mul): Remove.\n+\t(fold_builtin_complex_div): Remove.\n+\t(fold_builtin_1): Don't call them.\n+\t* fold-const.c (fold_complex_add, fold_complex_mult_parts,\n+\tfold_complex_mult, fold_complex_div_parts, fold_complex_div): Remove.\n+\t(fold_binary): Don't call them.  Don't expand complex comparisons to\n+\telementary comparisons.\n+\t* tree-complex.c (init_dont_simulate_again): Enhance search for \n+\tstmts that require decomposition.\n+\t(complex_visit_stmt): Handle RETURN_EXPR properly.\n+\t(create_components): Handle no referenced variables properly.\n+\t* tree.h (fold_complex_mult_parts): Remove.\n+\t(fold_complex_div_parts): Remove.\n+\n 2005-06-16  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* doc/extend.texi: Document sseregparm target attribute."}, {"sha": "b0e3f40a9425541ef5b9df7dd55042240490be6b", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8f8abce4cf879e822dc8caa1b47d4ce53315beed", "patch": "@@ -8430,44 +8430,6 @@ fold_builtin_unordered_cmp (tree fndecl, tree arglist,\n \t\t       fold (build2 (code, type, arg0, arg1))));\n }\n \n-/* Fold a call to one of the external complex multiply libcalls.  */\n-\n-static tree\n-fold_builtin_complex_mul (tree type, tree arglist)\n-{\n-  tree ar, ai, br, bi;\n-\n-  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, REAL_TYPE,\n-\t\t\t REAL_TYPE, VOID_TYPE))\n-    return NULL;\n-\n-  ar = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n-  ai = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n-  br = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n-  bi = TREE_VALUE (arglist);\n-\n-  return fold_complex_mult_parts (type, ar, ai, br, bi);\n-}\n-\n-/* Fold a call to one of the external complex division libcalls.  */\n-\n-static tree\n-fold_builtin_complex_div (tree type, tree arglist)\n-{\n-  tree ar, ai, br, bi;\n-\n-  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, REAL_TYPE,\n-\t\t\t REAL_TYPE, VOID_TYPE))\n-    return NULL;\n-\n-  ar = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n-  ai = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n-  br = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n-  bi = TREE_VALUE (arglist);\n-\n-  return fold_complex_div_parts (type, ar, ai, br, bi, RDIV_EXPR);\n-}\n-\n /* Used by constant folding to simplify calls to builtin functions.  EXP is\n    the CALL_EXPR of a call to a builtin function.  IGNORE is true if the\n    result of the function call is ignored.  This function returns NULL_TREE\n@@ -8826,12 +8788,6 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n       break;\n \n     default:\n-      if (fcode >= BUILT_IN_COMPLEX_MUL_MIN\n-\t  && fcode <= BUILT_IN_COMPLEX_MUL_MAX)\n-\treturn fold_builtin_complex_mul (type, arglist);\n-      if (fcode >= BUILT_IN_COMPLEX_DIV_MIN\n-\t  && fcode <= BUILT_IN_COMPLEX_DIV_MAX)\n-\treturn fold_builtin_complex_div (type, arglist);\n       break;\n     }\n "}, {"sha": "8433d1dfd9889acee0ad9fe175deaf6c80d5fc0d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 356, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8f8abce4cf879e822dc8caa1b47d4ce53315beed", "patch": "@@ -6493,300 +6493,6 @@ fold_to_nonsharp_ineq_using_bound (tree ineq, tree bound)\n   return fold_build2 (GE_EXPR, type, a, y);\n }\n \n-/* Fold complex addition when both components are accessible by parts.\n-   Return non-null if successful.  CODE should be PLUS_EXPR for addition,\n-   or MINUS_EXPR for subtraction.  */\n-\n-static tree\n-fold_complex_add (tree type, tree ac, tree bc, enum tree_code code)\n-{\n-  tree ar, ai, br, bi, rr, ri, inner_type;\n-\n-  if (TREE_CODE (ac) == COMPLEX_EXPR)\n-    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n-  else if (TREE_CODE (ac) == COMPLEX_CST)\n-    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n-  else\n-    return NULL;\n-\n-  if (TREE_CODE (bc) == COMPLEX_EXPR)\n-    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n-  else if (TREE_CODE (bc) == COMPLEX_CST)\n-    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n-  else\n-    return NULL;\n-\n-  inner_type = TREE_TYPE (type);\n-\n-  rr = fold_build2 (code, inner_type, ar, br); \n-  ri = fold_build2 (code, inner_type, ai, bi); \n-\n-  return fold_build2 (COMPLEX_EXPR, type, rr, ri);\n-}\n-\n-/* Perform some simplifications of complex multiplication when one or more\n-   of the components are constants or zeros.  Return non-null if successful.  */\n-\n-tree\n-fold_complex_mult_parts (tree type, tree ar, tree ai, tree br, tree bi)\n-{\n-  tree rr, ri, inner_type, zero;\n-  bool ar0, ai0, br0, bi0, bi1;\n-\n-  inner_type = TREE_TYPE (type);\n-  zero = NULL;\n-\n-  if (SCALAR_FLOAT_TYPE_P (inner_type))\n-    {\n-      ar0 = ai0 = br0 = bi0 = bi1 = false;\n-\n-      /* We're only interested in +0.0 here, thus we don't use real_zerop.  */\n-\n-      if (TREE_CODE (ar) == REAL_CST\n-\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ar), dconst0))\n-\tar0 = true, zero = ar;\n-\n-      if (TREE_CODE (ai) == REAL_CST\n-\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ai), dconst0))\n-\tai0 = true, zero = ai;\n-\n-      if (TREE_CODE (br) == REAL_CST\n-\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (br), dconst0))\n-\tbr0 = true, zero = br;\n-\n-      if (TREE_CODE (bi) == REAL_CST)\n-\t{\n-\t  if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst0))\n-\t    bi0 = true, zero = bi;\n-\t  else if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst1))\n-\t    bi1 = true;\n-\t}\n-    }\n-  else\n-    {\n-      ar0 = integer_zerop (ar);\n-      if (ar0)\n-\tzero = ar;\n-      ai0 = integer_zerop (ai);\n-      if (ai0)\n-\tzero = ai;\n-      br0 = integer_zerop (br);\n-      if (br0)\n-\tzero = br;\n-      bi0 = integer_zerop (bi);\n-      if (bi0)\n-\t{\n-\t  zero = bi;\n-\t  bi1 = false;\n-\t}\n-      else\n-\tbi1 = integer_onep (bi);\n-    }\n-\n-  /* We won't optimize anything below unless something is zero.  */\n-  if (zero == NULL)\n-    return NULL;\n-\n-  if (ai0 && br0 && bi1)\n-    {\n-      rr = zero;\n-      ri = ar;\n-    }\n-  else if (ai0 && bi0)\n-    {\n-      rr = fold_build2 (MULT_EXPR, inner_type, ar, br);\n-      ri = zero;\n-    }\n-  else if (ai0 && br0)\n-    {\n-      rr = zero;\n-      ri = fold_build2 (MULT_EXPR, inner_type, ar, bi);\n-    }\n-  else if (ar0 && bi0)\n-    {\n-      rr = zero;\n-      ri = fold_build2 (MULT_EXPR, inner_type, ai, br);\n-    }\n-  else if (ar0 && br0)\n-    {\n-      rr = fold_build2 (MULT_EXPR, inner_type, ai, bi);\n-      rr = fold_build1 (NEGATE_EXPR, inner_type, rr);\n-      ri = zero;\n-    }\n-  else if (bi0)\n-    {\n-      rr = fold_build2 (MULT_EXPR, inner_type, ar, br);\n-      ri = fold_build2 (MULT_EXPR, inner_type, ai, br);\n-    }\n-  else if (ai0)\n-    {\n-      rr = fold_build2 (MULT_EXPR, inner_type, ar, br);\n-      ri = fold_build2 (MULT_EXPR, inner_type, ar, bi);\n-    }\n-  else if (br0)\n-    {\n-      rr = fold_build2 (MULT_EXPR, inner_type, ai, bi);\n-      rr = fold_build1 (NEGATE_EXPR, inner_type, rr);\n-      ri = fold_build2 (MULT_EXPR, inner_type, ar, bi);\n-    }\n-  else if (ar0)\n-    {\n-      rr = fold_build2 (MULT_EXPR, inner_type, ai, bi);\n-      rr = fold_build1 (NEGATE_EXPR, inner_type, rr);\n-      ri = fold_build2 (MULT_EXPR, inner_type, ai, br);\n-    }\n-  else\n-    return NULL;\n-\n-  return fold_build2 (COMPLEX_EXPR, type, rr, ri);\n-}\n-\n-static tree\n-fold_complex_mult (tree type, tree ac, tree bc)\n-{\n-  tree ar, ai, br, bi;\n-\n-  if (TREE_CODE (ac) == COMPLEX_EXPR)\n-    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n-  else if (TREE_CODE (ac) == COMPLEX_CST)\n-    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n-  else\n-    return NULL;\n-\n-  if (TREE_CODE (bc) == COMPLEX_EXPR)\n-    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n-  else if (TREE_CODE (bc) == COMPLEX_CST)\n-    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n-  else\n-    return NULL;\n-\n-  return fold_complex_mult_parts (type, ar, ai, br, bi);\n-}\n-\n-/* Perform some simplifications of complex division when one or more of\n-   the components are constants or zeros.  Return non-null if successful.  */\n-\n-tree\n-fold_complex_div_parts (tree type, tree ar, tree ai, tree br, tree bi,\n-\t\t\tenum tree_code code)\n-{\n-  tree rr, ri, inner_type, zero;\n-  bool ar0, ai0, br0, bi0, bi1;\n-\n-  inner_type = TREE_TYPE (type);\n-  zero = NULL;\n-\n-  if (SCALAR_FLOAT_TYPE_P (inner_type))\n-    {\n-      ar0 = ai0 = br0 = bi0 = bi1 = false;\n-\n-      /* We're only interested in +0.0 here, thus we don't use real_zerop.  */\n-\n-      if (TREE_CODE (ar) == REAL_CST\n-\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ar), dconst0))\n-\tar0 = true, zero = ar;\n-\n-      if (TREE_CODE (ai) == REAL_CST\n-\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ai), dconst0))\n-\tai0 = true, zero = ai;\n-\n-      if (TREE_CODE (br) == REAL_CST\n-\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (br), dconst0))\n-\tbr0 = true, zero = br;\n-\n-      if (TREE_CODE (bi) == REAL_CST)\n-\t{\n-\t  if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst0))\n-\t    bi0 = true, zero = bi;\n-\t  else if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst1))\n-\t    bi1 = true;\n-\t}\n-    }\n-  else\n-    {\n-      ar0 = integer_zerop (ar);\n-      if (ar0)\n-\tzero = ar;\n-      ai0 = integer_zerop (ai);\n-      if (ai0)\n-\tzero = ai;\n-      br0 = integer_zerop (br);\n-      if (br0)\n-\tzero = br;\n-      bi0 = integer_zerop (bi);\n-      if (bi0)\n-\t{\n-\t  zero = bi;\n-\t  bi1 = false;\n-\t}\n-      else\n-\tbi1 = integer_onep (bi);\n-    }\n-\n-  /* We won't optimize anything below unless something is zero.  */\n-  if (zero == NULL)\n-    return NULL;\n-\n-  if (ai0 && bi0)\n-    {\n-      rr = fold_build2 (code, inner_type, ar, br);\n-      ri = zero;\n-    }\n-  else if (ai0 && br0)\n-    {\n-      rr = zero;\n-      ri = fold_build2 (code, inner_type, ar, bi);\n-      ri = fold_build1 (NEGATE_EXPR, inner_type, ri);\n-    }\n-  else if (ar0 && bi0)\n-    {\n-      rr = zero;\n-      ri = fold_build2 (code, inner_type, ai, br);\n-    }\n-  else if (ar0 && br0)\n-    {\n-      rr = fold_build2 (code, inner_type, ai, bi);\n-      ri = zero;\n-    }\n-  else if (bi0)\n-    {\n-      rr = fold_build2 (code, inner_type, ar, br);\n-      ri = fold_build2 (code, inner_type, ai, br);\n-    }\n-  else if (br0)\n-    {\n-      rr = fold_build2 (code, inner_type, ai, bi);\n-      ri = fold_build2 (code, inner_type, ar, bi);\n-      ri = fold_build1 (NEGATE_EXPR, inner_type, ri);\n-    }\n-  else\n-    return NULL;\n-\n-  return fold_build2 (COMPLEX_EXPR, type, rr, ri);\n-}\n-\n-static tree\n-fold_complex_div (tree type, tree ac, tree bc, enum tree_code code)\n-{\n-  tree ar, ai, br, bi;\n-\n-  if (TREE_CODE (ac) == COMPLEX_EXPR)\n-    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n-  else if (TREE_CODE (ac) == COMPLEX_CST)\n-    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n-  else\n-    return NULL;\n-\n-  if (TREE_CODE (bc) == COMPLEX_EXPR)\n-    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n-  else if (TREE_CODE (bc) == COMPLEX_CST)\n-    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n-  else\n-    return NULL;\n-\n-  return fold_complex_div_parts (type, ar, ai, br, bi, code);\n-}\n-\n /* Fold a unary expression of code CODE and type TYPE with operand\n    OP0.  Return the folded expression if folding is successful.\n    Otherwise, return NULL_TREE.  */\n@@ -7418,13 +7124,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && integer_onep (arg1))\n \treturn fold_build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0));\n \n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_add (type, arg0, arg1, PLUS_EXPR);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n@@ -7870,13 +7569,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && integer_all_onesp (arg0))\n \treturn fold_build1 (BIT_NOT_EXPR, type, arg1);\n \n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_add (type, arg0, arg1, MINUS_EXPR);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (! wins && integer_zerop (arg0))\n@@ -8033,13 +7725,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t    negate_expr (arg0),\n \t\t\t    TREE_OPERAND (arg1, 0));\n \n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_mult (type, arg0, arg1);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n@@ -8501,13 +8186,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\tTREE_OPERAND (arg1, 0));\n \t}\n \n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_div (type, arg0, arg1, code);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n       if (flag_unsafe_math_optimizations)\n \t{\n \t  enum built_in_function fcode = builtin_mathfn_code (arg1);\n@@ -8631,12 +8309,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE)))\n \treturn fold_convert (type, tem);\n \n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_div (type, arg0, arg1, code);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n       goto binary;\n \n     case CEIL_MOD_EXPR:\n@@ -9926,34 +9598,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    }\n \t}\n \n-      /* If this is a comparison of complex values and either or both sides\n-\t are a COMPLEX_EXPR or COMPLEX_CST, it is best to split up the\n-\t comparisons and join them with a TRUTH_ANDIF_EXPR or TRUTH_ORIF_EXPR.\n-\t This may prevent needless evaluations.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (TREE_TYPE (arg0)) == COMPLEX_TYPE\n-\t  && (TREE_CODE (arg0) == COMPLEX_EXPR\n-\t      || TREE_CODE (arg1) == COMPLEX_EXPR\n-\t      || TREE_CODE (arg0) == COMPLEX_CST\n-\t      || TREE_CODE (arg1) == COMPLEX_CST))\n-\t{\n-\t  tree subtype = TREE_TYPE (TREE_TYPE (arg0));\n-\t  tree real0, imag0, real1, imag1;\n-\n-\t  arg0 = save_expr (arg0);\n-\t  arg1 = save_expr (arg1);\n-\t  real0 = fold_build1 (REALPART_EXPR, subtype, arg0);\n-\t  imag0 = fold_build1 (IMAGPART_EXPR, subtype, arg0);\n-\t  real1 = fold_build1 (REALPART_EXPR, subtype, arg1);\n-\t  imag1 = fold_build1 (IMAGPART_EXPR, subtype, arg1);\n-\n-\t  return fold_build2 ((code == EQ_EXPR ? TRUTH_ANDIF_EXPR\n-\t\t\t       : TRUTH_ORIF_EXPR),\n-\t\t\t      type,\n-\t\t\t      fold_build2 (code, type, real0, real1),\n-\t\t\t      fold_build2 (code, type, imag0, imag1));\n-\t}\n-\n       /* Optimize comparisons of strlen vs zero to a compare of the\n \t first character of the string vs zero.  To wit,\n \t\tstrlen(ptr) == 0   =>  *ptr == 0"}, {"sha": "a4c7329d3dd47e14dd08efd1fe48d3431cca2949", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=8f8abce4cf879e822dc8caa1b47d4ce53315beed", "patch": "@@ -150,7 +150,7 @@ init_dont_simulate_again (void)\n   basic_block bb;\n   block_stmt_iterator bsi;\n   tree phi;\n-  bool saw_a_complex_value = false;\n+  bool saw_a_complex_op = false;\n \n   FOR_EACH_BB (bb)\n     {\n@@ -159,21 +159,62 @@ init_dont_simulate_again (void)\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n-\t  tree stmt = bsi_stmt (bsi);\n+\t  tree orig_stmt, stmt, rhs = NULL;\n \t  bool dsa = true;\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && is_complex_reg (TREE_OPERAND (stmt, 0)))\n+\t  orig_stmt = stmt = bsi_stmt (bsi);\n+\t  switch (TREE_CODE (stmt))\n \t    {\n-\t      dsa = false;\n-\t      saw_a_complex_value = true;\n+\t    case RETURN_EXPR:\n+\t      stmt = TREE_OPERAND (stmt, 0);\n+\t      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n+\t\tbreak;\n+\t      /* FALLTHRU */\n+\n+\t    case MODIFY_EXPR:\n+\t      dsa = !is_complex_reg (TREE_OPERAND (stmt, 0));\n+\t      rhs = TREE_OPERAND (stmt, 1);\n+\t      break;\n+\n+\t    case COND_EXPR:\n+\t      rhs = TREE_OPERAND (stmt, 0);\n+\t      break;\n+\n+\t    default:\n+\t      break;\n \t    }\n \n-\t  DONT_SIMULATE_AGAIN (stmt) = dsa;\n+\t  if (rhs)\n+\t    switch (TREE_CODE (rhs))\n+\t      {\n+\t      case EQ_EXPR:\n+\t      case NE_EXPR:\n+\t\trhs = TREE_OPERAND (rhs, 0);\n+\t\t/* FALLTHRU */\n+\n+\t      case PLUS_EXPR:\n+\t      case MINUS_EXPR:\n+\t      case MULT_EXPR:\n+\t      case TRUNC_DIV_EXPR:\n+\t      case CEIL_DIV_EXPR:\n+\t      case FLOOR_DIV_EXPR:\n+\t      case ROUND_DIV_EXPR:\n+\t      case RDIV_EXPR:\n+\t      case NEGATE_EXPR:\n+\t      case CONJ_EXPR:\n+\t\tif (TREE_CODE (TREE_TYPE (rhs)) == COMPLEX_TYPE)\n+\t\t  saw_a_complex_op = true;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\n+\t  DONT_SIMULATE_AGAIN (orig_stmt) = dsa;\n \t}\n     }\n \n-  return saw_a_complex_value;\n+  return saw_a_complex_op;\n }\n \n \n@@ -189,6 +230,8 @@ complex_visit_stmt (tree stmt, edge *taken_edge_p ATTRIBUTE_UNUSED,\n \n   /* These conditions should be satisfied due to the initial filter\n      set up in init_dont_simulate_again.  */\n+  if (TREE_CODE (stmt) == RETURN_EXPR)\n+    stmt = TREE_OPERAND (stmt, 0);\n   gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n \n   lhs = TREE_OPERAND (stmt, 0);\n@@ -308,6 +351,9 @@ create_components (void)\n   size_t k, n;\n \n   n = num_referenced_vars;\n+  if (n == 0)\n+    return;\n+\n   complex_variable_components = VEC_alloc (tree, heap, 2*n);\n   VEC_safe_grow (tree, heap, complex_variable_components, 2*n);\n "}, {"sha": "c434f2fe509e3c8a47fa772e31589b91bca219aa", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f8abce4cf879e822dc8caa1b47d4ce53315beed/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8f8abce4cf879e822dc8caa1b47d4ce53315beed", "patch": "@@ -3611,9 +3611,6 @@ extern tree build_fold_indirect_ref (tree);\n extern tree fold_indirect_ref (tree);\n extern tree constant_boolean_node (int, tree);\n extern tree build_low_bits_mask (tree, unsigned);\n-extern tree fold_complex_mult_parts (tree, tree, tree, tree, tree);\n-extern tree fold_complex_div_parts (tree, tree, tree, tree, tree,\n-\t\t\t\t    enum tree_code);\n \n extern bool tree_swap_operands_p (tree, tree, bool);\n extern enum tree_code swap_tree_comparison (enum tree_code);"}]}