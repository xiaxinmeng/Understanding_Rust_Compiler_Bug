{"sha": "e6858a844797a41452b08bc0a58791fc4f061e51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4NThhODQ0Nzk3YTQxNDUyYjA4YmMwYTU4NzkxZmM0ZjA2MWU1MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-08-04T13:13:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-08-04T13:13:56Z"}, "message": "re PR c++/7470 (Vtable: virtual function pointers not in declaration order)\n\n\tPR 7470.\n\tC++ ABI change - vfunc ordering.\n\t* class.c (add_virtual_function): Remove.\n\t(dfs_modify_all_vtables): Take list of all declared\n\tvirtuals. Assign all that are not in primary base.\n\t(check_for_override): Adjust comments.\n\t(create_vtable_ptr): Take single list of virtuals. Build chain\n\tof declared virtuals here.\n\t(layout_class_type): Take single list of virtuals. Adjust.\n\t(finish_struct_1): Keep virtuals on single list. Adjust.\n\nFrom-SVN: r56021", "tree": {"sha": "d222251a6da9c3c55f51ebf2147fe5e9d271ffbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d222251a6da9c3c55f51ebf2147fe5e9d271ffbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6858a844797a41452b08bc0a58791fc4f061e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6858a844797a41452b08bc0a58791fc4f061e51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6858a844797a41452b08bc0a58791fc4f061e51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6858a844797a41452b08bc0a58791fc4f061e51/comments", "author": null, "committer": null, "parents": [{"sha": "9cc7dbc4a8c7ede5f071536a48e281779eab0614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc7dbc4a8c7ede5f071536a48e281779eab0614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cc7dbc4a8c7ede5f071536a48e281779eab0614"}], "stats": {"total": 190, "additions": 66, "deletions": 124}, "files": [{"sha": "6b08e3c3d9f5e23c16872647a2f8fb4f1a83a28f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6858a844797a41452b08bc0a58791fc4f061e51/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6858a844797a41452b08bc0a58791fc4f061e51/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6858a844797a41452b08bc0a58791fc4f061e51", "patch": "@@ -1,3 +1,16 @@\n+2002-08-03  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR 7470.\n+\tC++ ABI change - vfunc ordering.\n+\t* class.c (add_virtual_function): Remove.\n+\t(dfs_modify_all_vtables): Take list of all declared\n+\tvirtuals. Assign all that are not in primary base.\n+\t(check_for_override): Adjust comments.\n+\t(create_vtable_ptr): Take single list of virtuals. Build chain\n+\tof declared virtuals here.\n+\t(layout_class_type): Take single list of virtuals. Adjust.\n+\t(finish_struct_1): Keep virtuals on single list. Adjust.\n+\n 2002-08-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* init.c (build_member_call): Use build_new_method_call, not"}, {"sha": "eabe544c9a11ae68c105537e8b25691c0e9d7586", "filename": "gcc/cp/class.c", "status": "modified", "additions": 53, "deletions": 124, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6858a844797a41452b08bc0a58791fc4f061e51/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6858a844797a41452b08bc0a58791fc4f061e51/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e6858a844797a41452b08bc0a58791fc4f061e51", "patch": "@@ -112,7 +112,6 @@ static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n static void finish_vtbls PARAMS ((tree));\n static void modify_vtable_entry PARAMS ((tree, tree, tree, tree, tree *));\n-static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n static tree delete_duplicate_fields_1 PARAMS ((tree, tree));\n static void delete_duplicate_fields PARAMS ((tree));\n static void finish_struct_bits PARAMS ((tree));\n@@ -148,8 +147,8 @@ static void check_methods PARAMS ((tree));\n static void remove_zero_width_bit_fields PARAMS ((tree));\n static void check_bases PARAMS ((tree, int *, int *, int *));\n static void check_bases_and_members PARAMS ((tree, int *));\n-static tree create_vtable_ptr PARAMS ((tree, int *, int *, tree *, tree *));\n-static void layout_class_type PARAMS ((tree, int *, int *, tree *, tree *));\n+static tree create_vtable_ptr PARAMS ((tree, int *, int *, tree *));\n+static void layout_class_type PARAMS ((tree, int *, int *, tree *));\n static void fixup_pending_inline PARAMS ((tree));\n static void fixup_inline_methods PARAMS ((tree));\n static void set_primary_base PARAMS ((tree, tree, int *));\n@@ -754,61 +753,6 @@ set_vindex (decl, vfuns_p)\n \t       ? TARGET_VTABLE_USES_DESCRIPTORS : 1);\n   DECL_VINDEX (decl) = build_shared_int_cst (vindex);\n }\n-\n-/* Add a virtual function to all the appropriate vtables for the class\n-   T.  DECL_VINDEX(X) should be error_mark_node, if we want to\n-   allocate a new slot in our table.  If it is error_mark_node, we\n-   know that no other function from another vtable is overridden by X.\n-   VFUNS_P keeps track of how many virtuals there are in our\n-   main vtable for the type, and we build upon the NEW_VIRTUALS list\n-   and return it.  */\n-\n-static void\n-add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n-\t\t      vfuns_p, fndecl, t)\n-     tree *new_virtuals_p;\n-     tree *overridden_virtuals_p;\n-     int *vfuns_p;\n-     tree fndecl;\n-     tree t; /* Structure type.  */\n-{\n-  tree new_virtual;\n-\n-  /* If this function doesn't override anything from a base class, we\n-     can just assign it a new DECL_VINDEX now.  Otherwise, if it does\n-     override something, we keep it around and assign its DECL_VINDEX\n-     later, in modify_all_vtables.  */\n-  if (TREE_CODE (DECL_VINDEX (fndecl)) == INTEGER_CST)\n-    /* We've already dealt with this function.  */\n-    return;\n-\n-  new_virtual = make_node (TREE_LIST);\n-  BV_FN (new_virtual) = fndecl;\n-  BV_DELTA (new_virtual) = integer_zero_node;\n-\n-  if (DECL_VINDEX (fndecl) == error_mark_node)\n-    {\n-      /* FNDECL is a new virtual function; it doesn't override any\n-\t virtual function in a base class.  */\n-\n-      /* We remember that this was the base sub-object for rtti.  */\n-      CLASSTYPE_RTTI (t) = t;\n-\n-      /* Now assign virtual dispatch information.  */\n-      set_vindex (fndecl, vfuns_p);\n-      DECL_VIRTUAL_CONTEXT (fndecl) = t;\n-\n-      /* Save the state we've computed on the NEW_VIRTUALS list.  */\n-      TREE_CHAIN (new_virtual) = *new_virtuals_p;\n-      *new_virtuals_p = new_virtual;\n-    }\n-  else\n-    {\n-      /* FNDECL overrides a function from a base class.  */\n-      TREE_CHAIN (new_virtual) = *overridden_virtuals_p;\n-      *overridden_virtuals_p = new_virtual;\n-    }\n-}\n \f\n /* Add method METHOD to class TYPE.  If ERROR_P is true, we are adding\n    the method after the class has already been defined because a\n@@ -2626,18 +2570,18 @@ dfs_modify_vtables (binfo, data)\n \n /* Update all of the primary and secondary vtables for T.  Create new\n    vtables as required, and initialize their RTTI information.  Each\n-   of the functions in OVERRIDDEN_VIRTUALS overrides a virtual\n-   function from a base class; find and modify the appropriate entries\n-   to point to the overriding functions.  Returns a list, in\n-   declaration order, of the functions that are overridden in this\n-   class, but do not appear in the primary base class vtable, and\n-   which should therefore be appended to the end of the vtable for T.  */\n+   of the functions in VIRTUALS is declared in T and may override a\n+   virtual function from a base class; find and modify the appropriate\n+   entries to point to the overriding functions.  Returns a list, in\n+   declaration order, of the virtual functions that are declared in T,\n+   but do not appear in the primary base class vtable, and which\n+   should therefore be appended to the end of the vtable for T.  */\n \n static tree\n-modify_all_vtables (t, vfuns_p, overridden_virtuals)\n+modify_all_vtables (t, vfuns_p, virtuals)\n      tree t;\n      int *vfuns_p;\n-     tree overridden_virtuals;\n+     tree virtuals;\n {\n   tree binfo = TYPE_BINFO (t);\n   tree *fnsp;\n@@ -2649,14 +2593,16 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n \t    t);\n   dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n \n-  /* Include overriding functions for secondary vtables in our primary\n-     vtable.  */\n-  for (fnsp = &overridden_virtuals; *fnsp; )\n+  /* Add virtual functions not already in our primary vtable. These\n+     will be both those introduced by this class, and those overridden\n+     from secondary bases.  It does not include virtuals merely\n+     inherited from secondary bases.  */\n+  for (fnsp = &virtuals; *fnsp; )\n     {\n       tree fn = TREE_VALUE (*fnsp);\n \n-      if (!BINFO_VIRTUALS (binfo)\n-\t  || !value_member (fn, BINFO_VIRTUALS (binfo)))\n+      if (!value_member (fn, BINFO_VIRTUALS (binfo))\n+\t  || DECL_VINDEX (fn) == error_mark_node)\n \t{\n \t  /* Set the vtable index.  */\n \t  set_vindex (fn, vfuns_p);\n@@ -2669,16 +2615,15 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n \t  BV_DELTA (*fnsp) = integer_zero_node;\n \t  BV_VCALL_INDEX (*fnsp) = NULL_TREE;\n \n-\t  /* This is an overridden function not already in our\n-\t     vtable.  Keep it.  */\n+\t  /* This is a function not already in our vtable.  Keep it.  */\n \t  fnsp = &TREE_CHAIN (*fnsp);\n \t}\n       else\n \t/* We've already got an entry for this function.  Skip it.  */\n \t*fnsp = TREE_CHAIN (*fnsp);\n     }\n   \n-  return overridden_virtuals;\n+  return virtuals;\n }\n \n /* Here, we already know that they match in every respect.\n@@ -2748,16 +2693,14 @@ check_for_override (decl, ctype)\n        || IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)))\n       && look_for_overrides (ctype, decl)\n       && !DECL_STATIC_FUNCTION_P (decl))\n-    {\n-      /* Set DECL_VINDEX to a value that is neither an\n-\t INTEGER_CST nor the error_mark_node so that\n-\t add_virtual_function will realize this is an\n-\t overriding function.  */\n-      DECL_VINDEX (decl) = decl;\n-    }\n+    /* Set DECL_VINDEX to a value that is neither an INTEGER_CST nor\n+       the error_mark_node so that we know it is an overriding\n+       function.  */\n+    DECL_VINDEX (decl) = decl;\n+\n   if (DECL_VIRTUAL_P (decl))\n     {\n-      if (DECL_VINDEX (decl) == NULL_TREE)\n+      if (!DECL_VINDEX (decl))\n \tDECL_VINDEX (decl) = error_mark_node;\n       IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)) = 1;\n     }\n@@ -4379,31 +4322,37 @@ check_bases_and_members (t, empty_p)\n    accordingly.  If a new vfield was created (because T doesn't have a\n    primary base class), then the newly created field is returned.  It\n    is not added to the TYPE_FIELDS list; it is the caller's\n-   responsibility to do that.  */\n+   responsibility to do that.  Accumulate declared virtual functions\n+   on VIRTUALS_P.  */\n \n static tree\n-create_vtable_ptr (t, empty_p, vfuns_p,\n-\t\t   new_virtuals_p, overridden_virtuals_p)\n+create_vtable_ptr (t, empty_p, vfuns_p, virtuals_p)\n      tree t;\n      int *empty_p;\n      int *vfuns_p;\n-     tree *new_virtuals_p;\n-     tree *overridden_virtuals_p;\n+     tree *virtuals_p;\n {\n   tree fn;\n \n-  /* Loop over the virtual functions, adding them to our various\n-     vtables.  */\n+  /* Collect the virtual functions declared in T.  */\n   for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n-    if (DECL_VINDEX (fn) && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n-      add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n-\t\t\t    vfuns_p, fn, t);\n+    if (DECL_VINDEX (fn) && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn)\n+\t&& TREE_CODE (DECL_VINDEX (fn)) != INTEGER_CST)\n+      {\n+\ttree new_virtual = make_node (TREE_LIST);\n+\t\n+\tBV_FN (new_virtual) = fn;\n+\tBV_DELTA (new_virtual) = integer_zero_node;\n \n+\tTREE_CHAIN (new_virtual) = *virtuals_p;\n+\t*virtuals_p = new_virtual;\n+      }\n+  \n   /* If we couldn't find an appropriate base class, create a new field\n      here.  Even if there weren't any new virtual functions, we might need a\n      new virtual function table if we're supposed to include vptrs in\n      all classes that need them.  */\n-  if (!TYPE_VFIELD (t) && (*vfuns_p || TYPE_CONTAINS_VPTR_P (t)))\n+  if (!TYPE_VFIELD (t) && (*virtuals_p || TYPE_CONTAINS_VPTR_P (t)))\n     {\n       /* We build this decl with vtbl_ptr_type_node, which is a\n \t `vtable_entry_type*'.  It might seem more precise to use\n@@ -4795,16 +4744,14 @@ splay_tree_compare_integer_csts (k1, k2)\n \n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n    BINFO_OFFSETs for all of the base-classes.  Position the vtable\n-   pointer.  */\n+   pointer.  Accumulate declared virtual functions on VIRTUALS_P. */\n \n static void\n-layout_class_type (t, empty_p, vfuns_p, \n-\t\t   new_virtuals_p, overridden_virtuals_p)\n+layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n      tree t;\n      int *empty_p;\n      int *vfuns_p;\n-     tree *new_virtuals_p;\n-     tree *overridden_virtuals_p;\n+     tree *virtuals_p;\n {\n   tree non_static_data_members;\n   tree field;\n@@ -4826,8 +4773,7 @@ layout_class_type (t, empty_p, vfuns_p,\n   determine_primary_base (t, vfuns_p);\n \n   /* Create a pointer to our virtual function table.  */\n-  vptr = create_vtable_ptr (t, empty_p, vfuns_p,\n-\t\t\t    new_virtuals_p, overridden_virtuals_p);\n+  vptr = create_vtable_ptr (t, empty_p, vfuns_p, virtuals_p);\n \n   /* The vptr is always the first thing in the class.  */\n   if (vptr)\n@@ -5034,15 +4980,8 @@ finish_struct_1 (t)\n {\n   tree x;\n   int vfuns;\n-  /* The NEW_VIRTUALS is a TREE_LIST.  The TREE_VALUE of each node is\n-     a FUNCTION_DECL.  Each of these functions is a virtual function\n-     declared in T that does not override any virtual function from a\n-     base class.  */\n-  tree new_virtuals = NULL_TREE;\n-  /* The OVERRIDDEN_VIRTUALS list is like the NEW_VIRTUALS list,\n-     except that each declaration here overrides the declaration from\n-     a base class.  */\n-  tree overridden_virtuals = NULL_TREE;\n+  /* A TREE_LIST.  The TREE_VALUE of each node is a FUNCTION_DECL. */\n+  tree virtuals = NULL_TREE;\n   int n_fields = 0;\n   tree vfield;\n   int empty = 1;\n@@ -5072,8 +5011,7 @@ finish_struct_1 (t)\n   check_bases_and_members (t, &empty);\n \n   /* Layout the class itself.  */\n-  layout_class_type (t, &empty, &vfuns,\n-\t\t     &new_virtuals, &overridden_virtuals);\n+  layout_class_type (t, &empty, &vfuns, &virtuals);\n \n   /* Make sure that we get our own copy of the vfield FIELD_DECL.  */\n   vfield = TYPE_VFIELD (t);\n@@ -5097,8 +5035,7 @@ finish_struct_1 (t)\n   else\n     my_friendly_assert (!vfield || DECL_FIELD_CONTEXT (vfield) == t, 20010726);\n \n-  overridden_virtuals \n-    = modify_all_vtables (t, &vfuns, nreverse (overridden_virtuals));\n+  virtuals = modify_all_vtables (t, &vfuns, nreverse (virtuals));\n \n   /* If we created a new vtbl pointer for this class, add it to the\n      list.  */\n@@ -5107,9 +5044,8 @@ finish_struct_1 (t)\n       = chainon (CLASSTYPE_VFIELDS (t), build_tree_list (NULL_TREE, t));\n \n   /* If necessary, create the primary vtable for this class.  */\n-  if (new_virtuals || overridden_virtuals || TYPE_CONTAINS_VPTR_P (t))\n+  if (virtuals || TYPE_CONTAINS_VPTR_P (t))\n     {\n-      new_virtuals = nreverse (new_virtuals);\n       /* We must enter these virtuals into the table.  */\n       if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \tbuild_primary_vtable (NULL_TREE, t);\n@@ -5122,7 +5058,6 @@ finish_struct_1 (t)\n \t constructors might clobber the virtual function table.  But\n \t they don't if the derived class shares the exact vtable of the base\n \t class.  */\n-\n       CLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n   /* If we didn't need a new vtable, see if we should copy one from\n@@ -5148,14 +5083,8 @@ finish_struct_1 (t)\n \t\t\t    20000116);\n \n       CLASSTYPE_VSIZE (t) = vfuns;\n-      /* Entries for virtual functions defined in the primary base are\n-\t followed by entries for new functions unique to this class.  */\n-      TYPE_BINFO_VIRTUALS (t) \n-\t= chainon (TYPE_BINFO_VIRTUALS (t), new_virtuals);\n-      /* Finally, add entries for functions that override virtuals\n-\t from non-primary bases.  */\n-      TYPE_BINFO_VIRTUALS (t) \n-\t= chainon (TYPE_BINFO_VIRTUALS (t), overridden_virtuals);\n+      /* Add entries for virtual functions introduced by this class.  */\n+      TYPE_BINFO_VIRTUALS (t) = chainon (TYPE_BINFO_VIRTUALS (t), virtuals);\n     }\n \n   finish_struct_bits (t);"}]}