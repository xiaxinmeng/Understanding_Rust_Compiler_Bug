{"sha": "caaa218f912ccf932fdb79243ded68bb462bbe63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FhYTIxOGY5MTJjY2Y5MzJmZGI3OTI0M2RlZDY4YmI0NjJiYmU2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-21T18:00:22Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-21T18:00:22Z"}, "message": "Inline functions with builtin_constant_p more agressively.\n\nThis patch implements heuristics that increases inline limits (by the hints\nmechanism) for inline functions that use builtin_constant_p on parameter. Those\nare very likely intended to be always inlined and simplify after inlining.\n\nThe PR is about a function that we used to inline with\n --param inline-insns-single=200 but with new default of 70 for -O2 we no longer\ndo so.  Hints are currently configured to bump the bound up twice, so we\nget limit of 140 that is still not enough to inline the particular testcase\nbut it should help in general.  I can implement a stronger bump if that seems\nuseful (maybe it is). The example is bit operation written as a decision chain\nwith 64 conditions.\nThis blows up the limit on number of conditions we track per funtion (which is\n30) and thus the size/time estimates are not working that well.\n\ngcc/ChangeLog:\n\n\tPR ipa/97445\n\t* ipa-fnsummary.c (ipa_dump_hints): Add INLINE_HINT_builtin_constant_p.\n\t(ipa_fn_summary::~ipa_fn_summary): Free builtin_constant_p_parms.\n\t(ipa_fn_summary_t::duplicate): Duplicate builtin_constant_p_parms.\n\t(ipa_dump_fn_summary): Dump builtin_constant_p_parms.\n\t(add_builtin_constant_p_parm): New function\n\t(set_cond_stmt_execution_predicate): Update builtin_constant_p_parms.\n\t(ipa_call_context::estimate_size_and_time): Set\n\tINLINE_HINT_builtin_constant_p..\n\t(ipa_merge_fn_summary_after_inlining): Merge builtin_constant_p_parms.\n\t(inline_read_section): Read builtin_constant_p_parms.\n\t(ipa_fn_summary_write): Write builtin_constant_p_parms.\n\t* ipa-fnsummary.h (enum ipa_hints_vals): Add\n\tINLINE_HINT_builtin_constant_p.\n\t* ipa-inline.c (want_inline_small_function_p): Use\n\tINLINE_HINT_builtin_constant_p.\n\t(edge_badness): Use INLINE_HINT_builtin_constant_p.\n\ngcc/testsuite/ChangeLog:\n\n\tPR ipa/97445\n\t* gcc.dg/ipa/inlinehint-5.c: New test.", "tree": {"sha": "759306f33556c3c19d797f001e97e016717d3296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/759306f33556c3c19d797f001e97e016717d3296"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caaa218f912ccf932fdb79243ded68bb462bbe63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caaa218f912ccf932fdb79243ded68bb462bbe63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caaa218f912ccf932fdb79243ded68bb462bbe63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caaa218f912ccf932fdb79243ded68bb462bbe63/comments", "author": null, "committer": null, "parents": [{"sha": "6bd2f2d080c52b73edac7dcb9fa9dcb58e6170bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd2f2d080c52b73edac7dcb9fa9dcb58e6170bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd2f2d080c52b73edac7dcb9fa9dcb58e6170bb"}], "stats": {"total": 122, "additions": 117, "deletions": 5}, "files": [{"sha": "f680e4221e740a3197f8c25e22c679a7b88b791f", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=caaa218f912ccf932fdb79243ded68bb462bbe63", "patch": "@@ -141,6 +141,11 @@ ipa_dump_hints (FILE *f, ipa_hints hints)\n       hints &= ~INLINE_HINT_known_hot;\n       fprintf (f, \" known_hot\");\n     }\n+  if (hints & INLINE_HINT_builtin_constant_p)\n+    {\n+      hints &= ~INLINE_HINT_builtin_constant_p;\n+      fprintf (f, \" builtin_constant_p\");\n+    }\n   gcc_assert (!hints);\n }\n \n@@ -751,6 +756,7 @@ ipa_fn_summary::~ipa_fn_summary ()\n   vec_free (call_size_time_table);\n   vec_free (loop_iterations);\n   vec_free (loop_strides);\n+  builtin_constant_p_parms.release ();\n }\n \n void\n@@ -899,7 +905,8 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t  new_predicate = es->predicate->remap_after_duplication\n \t\t\t\t (possible_truths);\n \t  if (new_predicate == false && *es->predicate != false)\n-\t    optimized_out_size += es->call_stmt_size * ipa_fn_summary::size_scale;\n+\t    optimized_out_size\n+\t\t += es->call_stmt_size * ipa_fn_summary::size_scale;\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n       info->loop_iterations\n@@ -908,6 +915,15 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       info->loop_strides\n \t= remap_freqcounting_preds_after_dup (info->loop_strides,\n \t\t\t\t\t      possible_truths);\n+      if (info->builtin_constant_p_parms.length())\n+\t{\n+\t  vec <int, va_heap, vl_ptr> parms = info->builtin_constant_p_parms;\n+\t  int ip;\n+\t  info->builtin_constant_p_parms = vNULL;\n+\t  for (i = 0; parms.iterate (i, &ip); i++)\n+\t    if (!avals.m_known_vals[ip])\n+\t      info->builtin_constant_p_parms.safe_push (ip);\n+\t}\n \n       /* If inliner or someone after inliner will ever start producing\n          non-trivial clones, we will get trouble with lack of information\n@@ -921,6 +937,9 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       info->loop_iterations = vec_safe_copy (info->loop_iterations);\n       info->loop_strides = vec_safe_copy (info->loop_strides);\n \n+      info->builtin_constant_p_parms\n+\t     = info->builtin_constant_p_parms.copy ();\n+\n       ipa_freqcounting_predicate *f;\n       for (int i = 0; vec_safe_iterate (info->loop_iterations, i, &f); i++)\n \t{\n@@ -1066,6 +1085,13 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n \t    fprintf (f, \" inlinable\");\n \t  if (s->fp_expressions)\n \t    fprintf (f, \" fp_expression\");\n+\t  if (s->builtin_constant_p_parms.length ())\n+\t    {\n+\t      fprintf (f, \" builtin_constant_p_parms\");\n+\t      for (unsigned int i = 0;\n+\t\t   i < s->builtin_constant_p_parms.length (); i++)\n+\t\tfprintf (f, \" %i\", s->builtin_constant_p_parms[i]);\n+\t    }\n \t  fprintf (f, \"\\n  global time:     %f\\n\", s->time.to_double ());\n \t  fprintf (f, \"  self size:       %i\\n\", ss->self_size);\n \t  fprintf (f, \"  global size:     %i\\n\", ss->size);\n@@ -1517,6 +1543,21 @@ decompose_param_expr (struct ipa_func_body_info *fbi,\n   return false;\n }\n \n+/* Record to SUMMARY that PARM is used by builtin_constant_p.  */\n+\n+static void\n+add_builtin_constant_p_parm (class ipa_fn_summary *summary, int parm)\n+{\n+  int ip;\n+\n+  /* Avoid duplicates.  */\n+  for (unsigned int i = 0;\n+       summary->builtin_constant_p_parms.iterate (i, &ip); i++)\n+    if (ip == parm)\n+      return;\n+  summary->builtin_constant_p_parms.safe_push (parm);\n+}\n+\n /* If BB ends by a conditional we can turn into predicates, attach corresponding\n    predicates to the CFG edges.   */\n \n@@ -1598,6 +1639,8 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   op2 = gimple_call_arg (set_stmt, 0);\n   if (!decompose_param_expr (fbi, set_stmt, op2, &index, &param_type, &aggpos))\n     return;\n+  if (!aggpos.by_ref)\n+    add_builtin_constant_p_parm (summary, index);\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n       predicate p = add_condition (summary, params_summary, index,\n@@ -3717,6 +3760,9 @@ ipa_call_context::estimate_size_and_time (ipa_call_estimates *estimates,\n \thints |= INLINE_HINT_in_scc;\n       if (DECL_DECLARED_INLINE_P (m_node->decl))\n \thints |= INLINE_HINT_declared_inline;\n+      if (info->builtin_constant_p_parms.length ()\n+\t  && DECL_DECLARED_INLINE_P (m_node->decl))\n+\thints |= INLINE_HINT_builtin_constant_p;\n \n       ipa_freqcounting_predicate *fcp;\n       for (i = 0; vec_safe_iterate (info->loop_iterations, i, &fcp); i++)\n@@ -4044,8 +4090,13 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t  operand_map[i] = map;\n \t  gcc_assert (map < ipa_get_param_count (params_summary));\n \t}\n+\n+      int ip;\n+      for (i = 0; callee_info->builtin_constant_p_parms.iterate (i, &ip); i++)\n+\tif (ip < count && operand_map[ip] >= 0)\n+\t  add_builtin_constant_p_parm (info, operand_map[ip]);\n     }\n-  sreal freq =  edge->sreal_frequency ();\n+  sreal freq = edge->sreal_frequency ();\n   for (i = 0; vec_safe_iterate (callee_info->size_time_table, i, &e); i++)\n     {\n       predicate p;\n@@ -4443,6 +4494,15 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t      vec_safe_push (info->loop_strides, fcp);\n \t    }\n \t}\n+      count2 = streamer_read_uhwi (&ib);\n+      if (info && count2)\n+\tinfo->builtin_constant_p_parms.reserve_exact (count2);\n+      for (j = 0; j < count2; j++)\n+\t{\n+\t  int parm = streamer_read_uhwi (&ib);\n+\t  if (info)\n+\t    info->builtin_constant_p_parms.quick_push (parm);\n+\t}\n       for (e = node->callees; e; e = e->next_callee)\n \tread_ipa_call_summary (&ib, e, info != NULL);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -4618,6 +4678,11 @@ ipa_fn_summary_write (void)\n \t      fcp->predicate->stream_out (ob);\n \t      fcp->freq.stream_out (ob);\n \t    }\n+\t  streamer_write_uhwi (ob, info->builtin_constant_p_parms.length ());\n+\t  int ip;\n+\t  for (i = 0; info->builtin_constant_p_parms.iterate (i, &ip);\n+\t       i++)\n+\t    streamer_write_uhwi (ob, ip);\n \t  for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t    write_ipa_call_summary (ob, edge);\n \t  for (edge = cnode->indirect_calls; edge; edge = edge->next_callee)"}, {"sha": "3ecedb5125f9bfea6a0ad57432bc690cf791d66c", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=caaa218f912ccf932fdb79243ded68bb462bbe63", "patch": "@@ -49,7 +49,10 @@ enum ipa_hints_vals {\n      Set by simple_edge_hints in ipa-inline-analysis.c.   */\n   INLINE_HINT_cross_module = 64,\n   /* We know that the callee is hot by profile.  */\n-  INLINE_HINT_known_hot = 128\n+  INLINE_HINT_known_hot = 128,\n+  /* There is builtin_constant_p dependent on parameter which is usually\n+     a strong hint to inline.  */\n+  INLINE_HINT_builtin_constant_p = 256\n };\n \n typedef int ipa_hints;\n@@ -123,10 +126,12 @@ class GTY(()) ipa_fn_summary\n   ipa_fn_summary ()\n     : min_size (0),\n       inlinable (false), single_caller (false),\n-      fp_expressions (false), estimated_stack_size (false),\n+      fp_expressions (false),\n+      estimated_stack_size (false),\n       time (0), conds (NULL),\n       size_time_table (NULL), call_size_time_table (NULL),\n       loop_iterations (NULL), loop_strides (NULL),\n+      builtin_constant_p_parms (vNULL),\n       growth (0), scc_no (0)\n   {\n   }\n@@ -140,6 +145,7 @@ class GTY(()) ipa_fn_summary\n     time (s.time), conds (s.conds), size_time_table (s.size_time_table),\n     call_size_time_table (NULL),\n     loop_iterations (s.loop_iterations), loop_strides (s.loop_strides),\n+    builtin_constant_p_parms (s.builtin_constant_p_parms),\n     growth (s.growth), scc_no (s.scc_no)\n   {}\n \n@@ -182,6 +188,8 @@ class GTY(()) ipa_fn_summary\n   vec<ipa_freqcounting_predicate, va_gc> *loop_iterations;\n   /* Predicates on when some loops in the function can have known strides.  */\n   vec<ipa_freqcounting_predicate, va_gc> *loop_strides;\n+  /* Parameters tested by builtin_constant_p.  */\n+  vec<int, va_heap, vl_ptr> GTY((skip)) builtin_constant_p_parms;\n   /* Estimated growth for inlining all copies of the function before start\n      of small functions inlining.\n      This value will get out of date as the callers are duplicated, but"}, {"sha": "bc846eabb5889e7c705318b2c74c71ade5dd5525", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=caaa218f912ccf932fdb79243ded68bb462bbe63", "patch": "@@ -878,7 +878,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       bool apply_hints = (hints & (INLINE_HINT_indirect_call\n \t\t\t\t   | INLINE_HINT_known_hot\n \t\t\t\t   | INLINE_HINT_loop_iterations\n-\t\t\t\t   | INLINE_HINT_loop_stride));\n+\t\t\t\t   | INLINE_HINT_loop_stride\n+\t\t\t\t   | INLINE_HINT_builtin_constant_p));\n \n       if (growth <= opt_for_fn (to->decl,\n \t\t\t\tparam_max_inline_insns_size))\n@@ -1317,6 +1318,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t| INLINE_HINT_loop_stride))\n       || callee_info->growth <= 0)\n     badness = badness.shift (badness > 0 ? -2 : 2);\n+  if (hints & INLINE_HINT_builtin_constant_p)\n+    badness = badness.shift (badness > 0 ? -4 : 4);\n   if (hints & (INLINE_HINT_same_scc))\n     badness = badness.shift (badness > 0 ? 3 : -3);\n   else if (hints & (INLINE_HINT_in_scc))"}, {"sha": "218f80573c00846bc4b1b25af833cf30c64c3afc", "filename": "gcc/testsuite/gcc.dg/ipa/inlinehint-5.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caaa218f912ccf932fdb79243ded68bb462bbe63/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-5.c?ref=caaa218f912ccf932fdb79243ded68bb462bbe63", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-options \"-O2 -fdump-ipa-inline-details -fno-early-inlining \" } */\n+/* { dg-add-options bind_pic_locally } */\n+int j,k,l;\n+int test3(int);\n+int test4(int);\n+\n+static inline int\n+test2(int i)\n+{\n+  if (__builtin_constant_p (i))\n+    {\n+\tswitch (i)\n+\t{\n+\tcase 1: return j;\n+\tcase 2: return k;\n+\tcase 3: return l;\n+\t}\n+    }\n+  else return test3(i)+test4(i);\n+}\n+\n+static inline int\n+test (int i)\n+{\n+  return test2(i) + test2(i+1) + test3 (i) + test3(i) + test3(i) + test3 (i);\n+}\n+\n+int\n+run (int i)\n+{\n+   return test (i) + test (i);\n+}\n+/* The test should work by first inlining test2->test and then test to run\n+   Both are called twice, so 4 hints (the second make sure that we propagate\n+   to callers.  */\n+/* { dg-final { scan-ipa-dump-times \"hints: declared_inline builtin_constant_p\" 4 \"inline\"  } } */"}]}