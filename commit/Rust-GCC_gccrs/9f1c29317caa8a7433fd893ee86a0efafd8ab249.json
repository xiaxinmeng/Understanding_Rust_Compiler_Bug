{"sha": "9f1c29317caa8a7433fd893ee86a0efafd8ab249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYxYzI5MzE3Y2FhOGE3NDMzZmQ4OTNlZTg2YTBlZmFmZDhhYjI0OQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-05T20:09:42Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-05T20:09:42Z"}, "message": "* doc/cppinternals.texi: Update.\n\nFrom-SVN: r46040", "tree": {"sha": "8a08b94ac6909d29a844e866a141c8e9c5bcb979", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a08b94ac6909d29a844e866a141c8e9c5bcb979"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f1c29317caa8a7433fd893ee86a0efafd8ab249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1c29317caa8a7433fd893ee86a0efafd8ab249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f1c29317caa8a7433fd893ee86a0efafd8ab249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1c29317caa8a7433fd893ee86a0efafd8ab249/comments", "author": null, "committer": null, "parents": [{"sha": "744ee8b72bb691da99469bab14853e9a4a3e86b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744ee8b72bb691da99469bab14853e9a4a3e86b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/744ee8b72bb691da99469bab14853e9a4a3e86b7"}], "stats": {"total": 157, "additions": 111, "deletions": 46}, "files": [{"sha": "b3d96f4f51c08bcf467157cb52719f6d76f6357c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1c29317caa8a7433fd893ee86a0efafd8ab249/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1c29317caa8a7433fd893ee86a0efafd8ab249/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f1c29317caa8a7433fd893ee86a0efafd8ab249", "patch": "@@ -1,3 +1,7 @@\n+2001-10-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* doc/cppinternals.texi: Update.\n+\n 2001-10-05  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2out.c (FRAME_BEGIN_LABEL): New."}, {"sha": "dee2dea513369f5d1dfcb1db832f25c063d5e72d", "filename": "gcc/doc/cppinternals.texi", "status": "modified", "additions": 107, "deletions": 46, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1c29317caa8a7433fd893ee86a0efafd8ab249/gcc%2Fdoc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1c29317caa8a7433fd893ee86a0efafd8ab249/gcc%2Fdoc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppinternals.texi?ref=9f1c29317caa8a7433fd893ee86a0efafd8ab249", "patch": "@@ -164,17 +164,17 @@ management of lexed lines.  I discuss these issues in a separate section\n (@pxref{Lexing a line}).\n \n The lexer places the token it lexes into storage pointed to by the\n-variable @var{cur_token}, and then increments it.  This variable is\n+variable @code{cur_token}, and then increments it.  This variable is\n important for correct diagnostic positioning.  Unless a specific line\n and column are passed to the diagnostic routines, they will examine the\n-@var{line} and @var{col} values of the token just before the location\n-that @var{cur_token} points to, and use that location to report the\n+@code{line} and @code{col} values of the token just before the location\n+that @code{cur_token} points to, and use that location to report the\n diagnostic.\n \n The lexer does not consider whitespace to be a token in its own right.\n If whitespace (other than a new line) precedes a token, it sets the\n @code{PREV_WHITE} bit in the token's flags.  Each token has its\n-@var{line} and @var{col} variables set to the line and column of the\n+@code{line} and @code{col} variables set to the line and column of the\n first character of the token.  This line number is the line number in\n the translation unit, and can be converted to a source (file, line) pair\n using the line map code.\n@@ -193,7 +193,7 @@ New lines are treated specially; exactly how the lexer handles them is\n context-dependent.  The C standard mandates that directives are\n terminated by the first unescaped newline character, even if it appears\n in the middle of a macro expansion.  Therefore, if the state variable\n-@var{in_directive} is set, the lexer returns a @code{CPP_EOF} token,\n+@code{in_directive} is set, the lexer returns a @code{CPP_EOF} token,\n which is normally used to indicate end-of-file, to indicate\n end-of-directive.  In a directive a @code{CPP_EOF} token never means\n end-of-file.  Conveniently, if the caller was @code{collect_args}, it\n@@ -203,14 +203,14 @@ error about an unterminated macro argument list.\n The C standard also specifies that a new line in the middle of the\n arguments to a macro is treated as whitespace.  This white space is\n important in case the macro argument is stringified.  The state variable\n-@var{parsing_args} is non-zero when the preprocessor is collecting the\n+@code{parsing_args} is non-zero when the preprocessor is collecting the\n arguments to a macro call.  It is set to 1 when looking for the opening\n parenthesis to a function-like macro, and 2 when collecting the actual\n arguments up to the closing parenthesis, since these two cases need to\n be distinguished sometimes.  One such time is here: the lexer sets the\n @code{PREV_WHITE} flag of a token if it meets a new line when\n-@var{parsing_args} is set to 2.  It doesn't set it if it meets a new\n-line when @var{parsing_args} is 1, since then code like\n+@code{parsing_args} is set to 2.  It doesn't set it if it meets a new\n+line when @code{parsing_args} is 1, since then code like\n \n @smallexample\n #define foo() bar\n@@ -383,7 +383,7 @@ issues, but not all.  The opening parenthesis after a function-like\n macro name might lie on a different line, and the front ends definitely\n want the ability to look ahead past the end of the current line.  So\n cpplib only moves back to the start of the token run at the end of a\n-line if the variable @var{keep_tokens} is zero.  Line-buffering is\n+line if the variable @code{keep_tokens} is zero.  Line-buffering is\n quite natural for the preprocessor, and as a result the only time cpplib\n needs to increment this variable is whilst looking for the opening\n parenthesis to, and reading the arguments of, a function-like macro.  In\n@@ -596,32 +596,93 @@ one is not strictly needed.\n @unnumbered Line numbering\n @cindex line numbers\n \n-The preprocessor takes great care to ensure it keeps track of both the\n-position of a token in the source file, for diagnostic purposes, and\n-where it should appear in the output file, because using CPP for other\n-languages like assembler requires this.  The two positions may differ\n-for the following reasons:\n+@section Just which line number anyway?\n+\n+There are three reasonable requirements a cpplib client might have for\n+the line number of a token passed to it:\n \n @itemize @bullet\n @item\n-Escaped newlines are deleted, so lines spliced in this way are joined to\n-form a single logical line.\n+The source line it was lexed on.\n+@item\n+The line it is output on.  This can be different to the line it was\n+lexed on if, for example, there are intervening escaped newlines or\n+C-style comments.  For example:\n+\n+@smallexample\n+foo /* A long\n+comment */ bar \\\n+baz\n+@result{}\n+foo bar baz\n+@end smallexample\n \n @item\n-A macro expansion replaces the tokens that form its invocation, but any\n-newlines appearing in the macro's arguments are interpreted as a single\n-space, with the result that the macro's replacement appears in full on\n-the same line that the macro name appeared in the source file.  This is\n-particularly important for stringification of arguments---newlines\n-embedded in the arguments must appear in the string as spaces.\n+If the token results from a macro expansion, the line of the macro name,\n+or possibly the line of the closing parenthesis in the case of\n+function-like macro expansion.\n @end itemize\n \n-The source file location is maintained in the @code{lineno} member of the\n-@code{cpp_buffer} structure, and the column number inferred from the\n-current position in the buffer relative to the @code{line_base} buffer\n-variable, which is updated with every newline whether escaped or not.\n-\n-@c FINISH THIS\n+The @code{cpp_token} structure contains @code{line} and @code{col}\n+members.  The lexer fills these in with the line and column of the first\n+character of the token.  Consequently, but maybe unexpectedly, a token\n+from the replacement list of a macro expansion carries the location of\n+the token within the @code{#define} directive, because cpplib expands a\n+macro by returning pointers to the tokens in its replacement list.  The\n+current implementation of cpplib assigns tokens created from built-in\n+macros and the @samp{#} and @samp{##} operators the location of the most\n+recently lexed token.  This is a because they are allocated from the\n+lexer's token runs, and because of the way the diagnostic routines infer\n+the appropriate location to report.\n+\n+The diagnostic routines in cpplib display the location of the most\n+recently @emph{lexed} token, unless they are passed a specific line and\n+column to report.  For diagnostics regarding tokens that arise from\n+macro expansions, it might also be helpful for the user to see the\n+original location in the macro definition that the token came from.\n+Since that is exactly the information each token carries, such an\n+enhancement could be made relatively easily in future.\n+\n+The stand-alone preprocessor faces a similar problem when determining\n+the correct line to output the token on: the position attached to a\n+token is fairly useless if the token came from a macro expansion.  All\n+tokens on a logical line should be output on its first physical line, so\n+the token's reported location is also wrong if it is part of a physical\n+line other than the first.\n+\n+To solve these issues, cpplib provides a callback that is generated\n+whenever it lexes a preprocessing token that starts a new logical line\n+other than a directive.  It passes this token (which may be a\n+@code{CPP_EOF} token indicating the end of the translation unit) to the\n+callback routine, which can then use the line and column of this token\n+to produce correct output.\n+\n+@section Representation of line numbers\n+\n+As mentioned above, cpplib stores with each token the line number that\n+it was lexed on.  In fact, this number is not the number of the line in\n+the source file, but instead bears more resemblance to the number of the\n+line in the translation unit.\n+\n+The preprocessor maintains a monotonic increasing line count, which is\n+incremented at every new line character (and also at the end of any\n+buffer that does not end in a new line).  Since a line number of zero is\n+useful to indicate certain special states and conditions, this variable\n+starts counting from one.\n+\n+This variable therefore uniquely enumerates each line in the translation\n+unit.  With some simple infrastructure, it is straight forward to map\n+from this to the original source file and line number pair, saving space\n+whenever line number information needs to be saved.  The code the\n+implements this mapping lies in the files @file{line-map.c} and\n+@file{line-map.h}.\n+\n+Command-line macros and assertions are implemented by pushing a buffer\n+containing the right hand side of an equivalent @code{#define} or\n+@code{#assert} directive.  Some built-in macros are handled similarly.\n+Since these are all processed before the first line of the main input\n+file, it will typically have an assigned line closer to twenty than to\n+one.\n \n @node Guard Macros\n @unnumbered The Multiple-Include Optimization\n@@ -641,7 +702,7 @@ Header files are often of the form\n @noindent\n to prevent the compiler from processing them more than once.  The\n preprocessor notices such header files, so that if the header file\n-appears in a subsequent @code{#include} directive and @var{FOO} is\n+appears in a subsequent @code{#include} directive and @code{FOO} is\n defined, then it is ignored and it doesn't preprocess or even re-open\n the file a second time.  This is referred to as the @dfn{multiple\n include optimization}.\n@@ -665,15 +726,15 @@ the @dfn{null directive} (a line containing nothing other than a single\n @item\n The opening directive must be of the form\n \n-@display\n+@smallexample\n #ifndef FOO\n-@end display\n+@end smallexample\n \n or\n \n-@display\n+@smallexample\n #if !defined FOO     [equivalently, #if !defined(FOO)]\n-@end display\n+@end smallexample\n \n @item\n In the second form above, the tokens forming the @code{#if} expression\n@@ -689,15 +750,15 @@ of interest to a subsequent pass.\n @end enumerate\n \n First, when pushing a new file on the buffer stack,\n-@code{_stack_include_file} sets the controlling macro @var{mi_cmacro} to\n-@code{NULL}, and sets @var{mi_valid} to @code{true}.  This indicates\n+@code{_stack_include_file} sets the controlling macro @code{mi_cmacro} to\n+@code{NULL}, and sets @code{mi_valid} to @code{true}.  This indicates\n that the preprocessor has not yet encountered anything that would\n invalidate the multiple-include optimization.  As described in the next\n few paragraphs, these two variables having these values effectively\n indicates top-of-file.\n \n When about to return a token that is not part of a directive,\n-@code{_cpp_lex_token} sets @var{mi_valid} to @code{false}.  This\n+@code{_cpp_lex_token} sets @code{mi_valid} to @code{false}.  This\n enforces the constraint that tokens outside the controlling conditional\n block invalidate the optimization.\n \n@@ -711,42 +772,42 @@ and we're at top-of-file (as described above).  If an @code{#elif} or\n @code{#else} directive is encountered, the controlling macro for that\n block is cleared to @code{NULL}.  Otherwise, it survives until the\n @code{#endif} closing the block, upon which @code{do_endif} sets\n-@var{mi_valid} to true and stores the controlling macro in\n-@var{mi_cmacro}.\n+@code{mi_valid} to true and stores the controlling macro in\n+@code{mi_cmacro}.\n \n-@code{_cpp_handle_directive} clears @var{mi_valid} when processing any\n+@code{_cpp_handle_directive} clears @code{mi_valid} when processing any\n directive other than an opening conditional and the null directive.\n With this, and requiring top-of-file to record a controlling macro, and\n no @code{#else} or @code{#elif} for it to survive and be copied to\n-@var{mi_cmacro} by @code{do_endif}, we have enforced the absence of\n+@code{mi_cmacro} by @code{do_endif}, we have enforced the absence of\n directives outside the main conditional block for the optimization to be\n on.\n \n-Note that whilst we are inside the conditional block, @var{mi_valid} is\n+Note that whilst we are inside the conditional block, @code{mi_valid} is\n likely to be reset to @code{false}, but this does not matter since the\n the closing @code{#endif} restores it to @code{true} if appropriate.\n \n Finally, since @code{_cpp_lex_direct} pops the file off the buffer stack\n at @code{EOF} without returning a token, if the @code{#endif} directive\n-was not followed by any tokens, @var{mi_valid} is @code{true} and\n+was not followed by any tokens, @code{mi_valid} is @code{true} and\n @code{_cpp_pop_file_buffer} remembers the controlling macro associated\n with the file.  Subsequent calls to @code{stack_include_file} result in\n no buffer being pushed if the controlling macro is defined, effecting\n the optimization.\n \n A quick word on how we handle the\n \n-@display\n+@smallexample\n #if !defined FOO\n-@end display\n+@end smallexample\n \n @noindent\n case.  @code{_cpp_parse_expr} and @code{parse_defined} take steps to see\n whether the three stages @samp{!}, @samp{defined-expression} and\n @samp{end-of-directive} occur in order in a @code{#if} expression.  If\n so, they return the guard macro to @code{do_if} in the variable\n-@var{mi_ind_cmacro}, and otherwise set it to @code{NULL}.\n-@code{enter_macro_context} sets @var{mi_valid} to false, so if a macro\n+@code{mi_ind_cmacro}, and otherwise set it to @code{NULL}.\n+@code{enter_macro_context} sets @code{mi_valid} to false, so if a macro\n was expanded whilst parsing any part of the expression, then the\n top-of-file test in @code{push_conditional} fails and the optimization\n is turned off."}]}