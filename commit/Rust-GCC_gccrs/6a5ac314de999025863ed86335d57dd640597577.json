{"sha": "6a5ac314de999025863ed86335d57dd640597577", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE1YWMzMTRkZTk5OTAyNTg2M2VkODYzMzVkNTdkZDY0MDU5NzU3Nw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-12-06T10:27:20Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-12-06T10:27:20Z"}, "message": "cgraphunit.c: Remove struct tags when referring to class ipa_opt_pass_d or class opt_pass.\n\n\t* cgraphunit.c: Remove struct tags when referring to class\n\tipa_opt_pass_d or class opt_pass.\n\t* function.h: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* pass_manager.h: Likewise.\n\t* passes.c: Likewise.\n\t* tree-pass.h: Likewise.\n\nFrom-SVN: r205732", "tree": {"sha": "5c80da4d8b4788522bc541036d8290d5067c7960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c80da4d8b4788522bc541036d8290d5067c7960"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a5ac314de999025863ed86335d57dd640597577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a5ac314de999025863ed86335d57dd640597577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a5ac314de999025863ed86335d57dd640597577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a5ac314de999025863ed86335d57dd640597577/comments", "author": null, "committer": null, "parents": [{"sha": "041508a2ec3b8f19e3d46b8925892e9c0cbb4273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041508a2ec3b8f19e3d46b8925892e9c0cbb4273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041508a2ec3b8f19e3d46b8925892e9c0cbb4273"}], "stats": {"total": 155, "additions": 82, "deletions": 73}, "files": [{"sha": "6ec496838218ff2ff0fe1573398a8f44a6190d84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5ac314de999025863ed86335d57dd640597577/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5ac314de999025863ed86335d57dd640597577/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a5ac314de999025863ed86335d57dd640597577", "patch": "@@ -1,3 +1,13 @@\n+2013-12-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* cgraphunit.c: Remove struct tags when referring to class\n+\tipa_opt_pass_d or class opt_pass.\n+\t* function.h: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* pass_manager.h: Likewise.\n+\t* passes.c: Likewise.\n+\t* tree-pass.h: Likewise.\n+\n 2013-12-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59058"}, {"sha": "7aee8d62814dd154ac3b5abc2f9fb344dddad886", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5ac314de999025863ed86335d57dd640597577/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5ac314de999025863ed86335d57dd640597577/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6a5ac314de999025863ed86335d57dd640597577", "patch": "@@ -2019,7 +2019,7 @@ ipa_passes (void)\n       cgraph_process_new_functions ();\n \n       execute_ipa_summary_passes\n-\t((struct ipa_opt_pass_d *) passes->all_regular_ipa_passes);\n+\t((ipa_opt_pass_d *) passes->all_regular_ipa_passes);\n     }\n \n   /* Some targets need to handle LTO assembler output specially.  */"}, {"sha": "fcbebc105b5950487f8a08fc132cb6aedf000feb", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5ac314de999025863ed86335d57dd640597577/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5ac314de999025863ed86335d57dd640597577/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6a5ac314de999025863ed86335d57dd640597577", "patch": "@@ -167,8 +167,8 @@ typedef struct temp_slot *temp_slot_p;\n struct call_site_record_d;\n struct dw_fde_struct;\n \n-struct ipa_opt_pass_d;\n-typedef struct ipa_opt_pass_d *ipa_opt_pass;\n+class ipa_opt_pass_d;\n+typedef ipa_opt_pass_d *ipa_opt_pass;\n \n \n struct GTY(()) varasm_status {"}, {"sha": "d2807411236c042ec74addff9f4c2d4e7d2912e2", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5ac314de999025863ed86335d57dd640597577/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5ac314de999025863ed86335d57dd640597577/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=6a5ac314de999025863ed86335d57dd640597577", "patch": "@@ -389,7 +389,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   intptr_t ref;\n   bool in_other_partition = false;\n   struct cgraph_node *clone_of, *ultimate_clone_of;\n-  struct ipa_opt_pass_d *pass;\n+  ipa_opt_pass_d *pass;\n   int i;\n   bool alias_p;\n \n@@ -1060,12 +1060,12 @@ input_node (struct lto_file_decl_data *file_data,\n   node->ipa_transforms_to_apply = vNULL;\n   for (i = 0; i < count; i++)\n     {\n-      struct opt_pass *pass;\n+      opt_pass *pass;\n       int pid = streamer_read_hwi (ib);\n \n       gcc_assert (pid < passes->passes_by_id_size);\n       pass = passes->passes_by_id[pid];\n-      node->ipa_transforms_to_apply.safe_push ((struct ipa_opt_pass_d *) pass);\n+      node->ipa_transforms_to_apply.safe_push ((ipa_opt_pass_d *) pass);\n     }\n \n   if (tag == LTO_symtab_analyzed_node)"}, {"sha": "b5e10c373cfbaaee08549f30d492a0ceb73f25d1", "filename": "gcc/pass_manager.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5ac314de999025863ed86335d57dd640597577/gcc%2Fpass_manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5ac314de999025863ed86335d57dd640597577/gcc%2Fpass_manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpass_manager.h?ref=6a5ac314de999025863ed86335d57dd640597577", "patch": "@@ -51,7 +51,7 @@ class pass_manager\n   pass_manager (context *ctxt);\n \n   void register_pass (struct register_pass_info *pass_info);\n-  void register_one_dump_file (struct opt_pass *pass);\n+  void register_one_dump_file (opt_pass *pass);\n \n   opt_pass *get_pass_for_id (int id) const;\n \n@@ -91,8 +91,8 @@ class pass_manager\n \n private:\n   void set_pass_for_id (int id, opt_pass *pass);\n-  int register_dump_files_1 (struct opt_pass *pass, int properties);\n-  void register_dump_files (struct opt_pass *pass, int properties);\n+  int register_dump_files_1 (opt_pass *pass, int properties);\n+  void register_dump_files (opt_pass *pass, int properties);\n \n private:\n   context *m_ctxt;"}, {"sha": "5097c792544620174d407d022cd7d09a64407881", "filename": "gcc/passes.c", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5ac314de999025863ed86335d57dd640597577/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5ac314de999025863ed86335d57dd640597577/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6a5ac314de999025863ed86335d57dd640597577", "patch": "@@ -90,9 +90,9 @@ using namespace gcc;\n /* This is used for debugging.  It allows the current pass to printed\n    from anywhere in compilation.\n    The variable current_pass is also used for statistics and plugins.  */\n-struct opt_pass *current_pass;\n+opt_pass *current_pass;\n \n-static void register_pass_name (struct opt_pass *, const char *);\n+static void register_pass_name (opt_pass *, const char *);\n \n /* Most passes are single-instance (within their context) and thus don't\n    need to implement cloning, but passes that support multiple instances\n@@ -613,12 +613,12 @@ make_pass_postreload (gcc::context *ctxt)\n \n void\n pass_manager::\n-set_pass_for_id (int id, struct opt_pass *pass)\n+set_pass_for_id (int id, opt_pass *pass)\n {\n   pass->static_pass_number = id;\n   if (passes_by_id_size <= id)\n     {\n-      passes_by_id = XRESIZEVEC (struct opt_pass *, passes_by_id, id + 1);\n+      passes_by_id = XRESIZEVEC (opt_pass *, passes_by_id, id + 1);\n       memset (passes_by_id + passes_by_id_size, 0,\n \t      (id + 1 - passes_by_id_size) * sizeof (void *));\n       passes_by_id_size = id + 1;\n@@ -628,7 +628,7 @@ set_pass_for_id (int id, struct opt_pass *pass)\n \n /* Return the pass with the static pass number ID.  */\n \n-struct opt_pass *\n+opt_pass *\n pass_manager::get_pass_for_id (int id) const\n {\n   if (id >= passes_by_id_size)\n@@ -641,13 +641,13 @@ pass_manager::get_pass_for_id (int id) const\n    enabled or not.  */\n \n void\n-register_one_dump_file (struct opt_pass *pass)\n+register_one_dump_file (opt_pass *pass)\n {\n   g->get_passes ()->register_one_dump_file (pass);\n }\n \n void\n-pass_manager::register_one_dump_file (struct opt_pass *pass)\n+pass_manager::register_one_dump_file (opt_pass *pass)\n {\n   char *dot_name, *flag_name, *glob_name;\n   const char *name, *full_name, *prefix;\n@@ -707,7 +707,7 @@ pass_manager::register_one_dump_file (struct opt_pass *pass)\n \n int\n pass_manager::\n-register_dump_files_1 (struct opt_pass *pass, int properties)\n+register_dump_files_1 (opt_pass *pass, int properties)\n {\n   do\n     {\n@@ -740,7 +740,7 @@ register_dump_files_1 (struct opt_pass *pass, int properties)\n \n void\n pass_manager::\n-register_dump_files (struct opt_pass *pass,int properties)\n+register_dump_files (opt_pass *pass,int properties)\n {\n   pass->properties_required |= properties;\n   register_dump_files_1 (pass, properties);\n@@ -749,7 +749,7 @@ register_dump_files (struct opt_pass *pass,int properties)\n struct pass_registry\n {\n   const char* unique_name;\n-  struct opt_pass *pass;\n+  opt_pass *pass;\n };\n \n /* Helper for pass_registry hash table.  */\n@@ -783,7 +783,7 @@ static hash_table <pass_registry_hasher> name_to_pass_map;\n /* Register PASS with NAME.  */\n \n static void\n-register_pass_name (struct opt_pass *pass, const char *name)\n+register_pass_name (opt_pass *pass, const char *name)\n {\n   struct pass_registry **slot;\n   struct pass_registry pr;\n@@ -816,7 +816,7 @@ static vec<char_ptr> pass_tab = vNULL;\n int\n passes_pass_traverse (pass_registry **p, void *data ATTRIBUTE_UNUSED)\n {\n-  struct opt_pass *pass = (*p)->pass;\n+  opt_pass *pass = (*p)->pass;\n \n   gcc_assert (pass->static_pass_number > 0);\n   gcc_assert (pass_tab.exists ());\n@@ -839,13 +839,13 @@ create_pass_tab (void)\n   name_to_pass_map.traverse <void *, passes_pass_traverse> (NULL);\n }\n \n-static bool override_gate_status (struct opt_pass *, tree, bool);\n+static bool override_gate_status (opt_pass *, tree, bool);\n \n /* Dump the instantiated name for PASS. IS_ON indicates if PASS\n    is turned on or not.  */\n \n static void\n-dump_one_pass (struct opt_pass *pass, int pass_indent)\n+dump_one_pass (opt_pass *pass, int pass_indent)\n {\n   int indent = 3 * pass_indent;\n   const char *pn;\n@@ -869,7 +869,7 @@ dump_one_pass (struct opt_pass *pass, int pass_indent)\n /* Dump pass list PASS with indentation INDENT.  */\n \n static void\n-dump_pass_list (struct opt_pass *pass, int indent)\n+dump_pass_list (opt_pass *pass, int indent)\n {\n   do\n     {\n@@ -920,7 +920,7 @@ pass_manager::dump_passes () const\n \n /* Returns the pass with NAME.  */\n \n-static struct opt_pass *\n+static opt_pass *\n get_pass_by_name (const char *name)\n {\n   struct pass_registry **slot, pr;\n@@ -967,7 +967,7 @@ static vec<uid_range_p>\n static void\n enable_disable_pass (const char *arg, bool is_enable)\n {\n-  struct opt_pass *pass;\n+  opt_pass *pass;\n   char *range_str, *phase_name;\n   char *argstr = xstrdup (arg);\n   vec<uid_range_p> *tab = 0;\n@@ -1150,7 +1150,7 @@ disable_pass (const char *arg)\n /* Returns true if PASS is explicitly enabled/disabled for FUNC.  */\n \n static bool\n-is_pass_explicitly_enabled_or_disabled (struct opt_pass *pass,\n+is_pass_explicitly_enabled_or_disabled (opt_pass *pass,\n \t\t\t\t\ttree func,\n \t\t\t\t\tvec<uid_range_p> tab)\n {\n@@ -1216,7 +1216,7 @@ is_pass_explicitly_enabled_or_disabled (struct opt_pass *pass,\n      (TDI_end + current value of extra_dump_files_in_use) )  */\n \n static void\n-add_pass_instance (struct opt_pass *new_pass, bool track_duplicates,\n+add_pass_instance (opt_pass *new_pass, bool track_duplicates,\n \t\t   opt_pass *initial_pass)\n {\n   /* Are we dealing with the first pass of its kind, or a clone?  */\n@@ -1248,9 +1248,8 @@ add_pass_instance (struct opt_pass *new_pass, bool track_duplicates,\n /* Add a pass to the pass list. Duplicate the pass if it's already\n    in the list.  */\n \n-static struct opt_pass **\n-next_pass_1 (struct opt_pass **list, struct opt_pass *pass,\n-\t     struct opt_pass *initial_pass)\n+static opt_pass **\n+next_pass_1 (opt_pass **list, opt_pass *pass, opt_pass *initial_pass)\n {\n   /* Every pass should have a name so that plugins can refer to them.  */\n   gcc_assert (pass->name != NULL);\n@@ -1270,7 +1269,7 @@ next_pass_1 (struct opt_pass **list, struct opt_pass *pass,\n \n struct pass_list_node\n {\n-  struct opt_pass *pass;\n+  opt_pass *pass;\n   struct pass_list_node *next;\n };\n \n@@ -1284,10 +1283,9 @@ static struct pass_list_node *prev_added_pass_node;\n    PASS_LIST - root of the pass list to insert the new pass to  */\n \n static bool\n-position_pass (struct register_pass_info *new_pass_info,\n-               struct opt_pass **pass_list)\n+position_pass (struct register_pass_info *new_pass_info, opt_pass **pass_list)\n {\n-  struct opt_pass *pass = *pass_list, *prev_pass = NULL;\n+  opt_pass *pass = *pass_list, *prev_pass = NULL;\n   bool success = false;\n \n   for ( ; pass; prev_pass = pass, pass = pass->next)\n@@ -1303,7 +1301,7 @@ position_pass (struct register_pass_info *new_pass_info,\n               || (new_pass_info->ref_pass_instance_number == 1\n                   && pass->todo_flags_start & TODO_mark_first_instance)))\n         {\n-          struct opt_pass *new_pass;\n+          opt_pass *new_pass;\n           struct pass_list_node *new_pass_node;\n \n \t  if (new_pass_info->ref_pass_instance_number == 0)\n@@ -1503,7 +1501,7 @@ pass_manager::pass_manager (context *ctxt)\n   all_late_ipa_passes (NULL), passes_by_id (NULL), passes_by_id_size (0),\n   m_ctxt (ctxt)\n {\n-  struct opt_pass **p;\n+  opt_pass **p;\n \n   /* Initialize the pass_lists array.  */\n #define DEF_PASS_LIST(LIST) pass_lists[PASS_LIST_NO_##LIST] = &LIST;\n@@ -1517,7 +1515,7 @@ pass_manager::pass_manager (context *ctxt)\n \n #define PUSH_INSERT_PASSES_WITHIN(PASS) \\\n   { \\\n-    struct opt_pass **p = &(PASS ## _1)->sub;\n+    opt_pass **p = &(PASS ## _1)->sub;\n \n #define POP_INSERT_PASSES() \\\n   }\n@@ -1936,7 +1934,7 @@ verify_curr_properties (void *data)\n /* This is non-static so that the plugins can use it.  */\n \n bool\n-pass_init_dump_file (struct opt_pass *pass)\n+pass_init_dump_file (opt_pass *pass)\n {\n   /* If a dump file name is present, open it if enabled.  */\n   if (pass->static_pass_number != -1)\n@@ -1964,7 +1962,7 @@ pass_init_dump_file (struct opt_pass *pass)\n /* This is non-static so that plugins can use it.  */\n \n void\n-pass_fini_dump_file (struct opt_pass *pass)\n+pass_fini_dump_file (opt_pass *pass)\n {\n   timevar_push (TV_DUMP);\n \n@@ -1985,19 +1983,19 @@ pass_fini_dump_file (struct opt_pass *pass)\n static void\n update_properties_after_pass (void *data)\n {\n-  struct opt_pass *pass = (struct opt_pass *) data;\n+  opt_pass *pass = (opt_pass *) data;\n   cfun->curr_properties = (cfun->curr_properties | pass->properties_provided)\n \t\t           & ~pass->properties_destroyed;\n }\n \n /* Execute summary generation for all of the passes in IPA_PASS.  */\n \n void\n-execute_ipa_summary_passes (struct ipa_opt_pass_d *ipa_pass)\n+execute_ipa_summary_passes (ipa_opt_pass_d *ipa_pass)\n {\n   while (ipa_pass)\n     {\n-      struct opt_pass *pass = ipa_pass;\n+      opt_pass *pass = ipa_pass;\n \n       /* Execute all of the IPA_PASSes in the list.  */\n       if (ipa_pass->type == IPA_PASS\n@@ -2018,17 +2016,17 @@ execute_ipa_summary_passes (struct ipa_opt_pass_d *ipa_pass)\n \n \t  pass_fini_dump_file (pass);\n \t}\n-      ipa_pass = (struct ipa_opt_pass_d *)ipa_pass->next;\n+      ipa_pass = (ipa_opt_pass_d *)ipa_pass->next;\n     }\n }\n \n /* Execute IPA_PASS function transform on NODE.  */\n \n static void\n execute_one_ipa_transform_pass (struct cgraph_node *node,\n-\t\t\t\tstruct ipa_opt_pass_d *ipa_pass)\n+\t\t\t\tipa_opt_pass_d *ipa_pass)\n {\n-  struct opt_pass *pass = ipa_pass;\n+  opt_pass *pass = ipa_pass;\n   unsigned int todo_after = 0;\n \n   current_pass = pass;\n@@ -2115,7 +2113,7 @@ apply_ipa_transforms (void *data)\n    default.  */\n \n static bool\n-override_gate_status (struct opt_pass *pass, tree func, bool gate_status)\n+override_gate_status (opt_pass *pass, tree func, bool gate_status)\n {\n   bool explicitly_enabled = false;\n   bool explicitly_disabled = false;\n@@ -2136,7 +2134,7 @@ override_gate_status (struct opt_pass *pass, tree func, bool gate_status)\n /* Execute PASS. */\n \n bool\n-execute_one_pass (struct opt_pass *pass)\n+execute_one_pass (opt_pass *pass)\n {\n   unsigned int todo_after = 0;\n \n@@ -2237,7 +2235,7 @@ execute_one_pass (struct opt_pass *pass)\n     {\n       struct cgraph_node *node;\n       FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-\tnode->ipa_transforms_to_apply.safe_push ((struct ipa_opt_pass_d *)pass);\n+\tnode->ipa_transforms_to_apply.safe_push ((ipa_opt_pass_d *)pass);\n     }\n \n   if (!current_function_decl)\n@@ -2259,7 +2257,7 @@ execute_one_pass (struct opt_pass *pass)\n }\n \n void\n-execute_pass_list (struct opt_pass *pass)\n+execute_pass_list (opt_pass *pass)\n {\n   do\n     {\n@@ -2289,11 +2287,11 @@ write_lto (void)\n    those node in SET. */\n \n static void\n-ipa_write_summaries_2 (struct opt_pass *pass, struct lto_out_decl_state *state)\n+ipa_write_summaries_2 (opt_pass *pass, struct lto_out_decl_state *state)\n {\n   while (pass)\n     {\n-      struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *)pass;\n+      ipa_opt_pass_d *ipa_pass = (ipa_opt_pass_d *)pass;\n       gcc_assert (!current_function_decl);\n       gcc_assert (!cfun);\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n@@ -2406,11 +2404,12 @@ ipa_write_summaries (void)\n    only those node in SET. */\n \n static void\n-ipa_write_optimization_summaries_1 (struct opt_pass *pass, struct lto_out_decl_state *state)\n+ipa_write_optimization_summaries_1 (opt_pass *pass,\n+\t\t\t\t    struct lto_out_decl_state *state)\n {\n   while (pass)\n     {\n-      struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *)pass;\n+      ipa_opt_pass_d *ipa_pass = (ipa_opt_pass_d *)pass;\n       gcc_assert (!current_function_decl);\n       gcc_assert (!cfun);\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n@@ -2484,11 +2483,11 @@ ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)\n    are local passes.  */\n \n static void\n-ipa_read_summaries_1 (struct opt_pass *pass)\n+ipa_read_summaries_1 (opt_pass *pass)\n {\n   while (pass)\n     {\n-      struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *) pass;\n+      ipa_opt_pass_d *ipa_pass = (ipa_opt_pass_d *) pass;\n \n       gcc_assert (!current_function_decl);\n       gcc_assert (!cfun);\n@@ -2534,11 +2533,11 @@ ipa_read_summaries (void)\n    are local passes.  */\n \n static void\n-ipa_read_optimization_summaries_1 (struct opt_pass *pass)\n+ipa_read_optimization_summaries_1 (opt_pass *pass)\n {\n   while (pass)\n     {\n-      struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *) pass;\n+      ipa_opt_pass_d *ipa_pass = (ipa_opt_pass_d *) pass;\n \n       gcc_assert (!current_function_decl);\n       gcc_assert (!cfun);\n@@ -2582,7 +2581,7 @@ ipa_read_optimization_summaries (void)\n /* Same as execute_pass_list but assume that subpasses of IPA passes\n    are local passes.  */\n void\n-execute_ipa_pass_list (struct opt_pass *pass)\n+execute_ipa_pass_list (opt_pass *pass)\n {\n   do\n     {\n@@ -2614,16 +2613,16 @@ execute_ipa_pass_list (struct opt_pass *pass)\n /* Execute stmt fixup hooks of all passes in PASS for NODE and STMTS.  */\n \n static void\n-execute_ipa_stmt_fixups (struct opt_pass *pass,\n-\t\t\t  struct cgraph_node *node, gimple *stmts)\n+execute_ipa_stmt_fixups (opt_pass *pass,\n+\t\t\t struct cgraph_node *node, gimple *stmts)\n {\n   while (pass)\n     {\n       /* Execute all of the IPA_PASSes in the list.  */\n       if (pass->type == IPA_PASS\n \t  && ((!pass->has_gate) || pass->gate ()))\n \t{\n-\t  struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *) pass;\n+\t  ipa_opt_pass_d *ipa_pass = (ipa_opt_pass_d *) pass;\n \n \t  if (ipa_pass->stmt_fixup)\n \t    {"}, {"sha": "13d0c44094d309a66be1860471cd30bb25ef594a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5ac314de999025863ed86335d57dd640597577/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5ac314de999025863ed86335d57dd640597577/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=6a5ac314de999025863ed86335d57dd640597577", "patch": "@@ -106,10 +106,10 @@ class opt_pass : public pass_data\n \n public:\n   /* A list of sub-passes to run, dependent on gate predicate.  */\n-  struct opt_pass *sub;\n+  opt_pass *sub;\n \n   /* Next in the list of passes to run, independent of gate predicate.  */\n-  struct opt_pass *next;\n+  opt_pass *next;\n \n   /* Static pass number, used as a fragment of the dump file name.  */\n   int static_pass_number;\n@@ -321,7 +321,7 @@ enum pass_positioning_ops\n \n struct register_pass_info\n {\n-  struct opt_pass *pass;            /* New pass to register.  */\n+  opt_pass *pass;\t\t    /* New pass to register.  */\n   const char *reference_pass_name;  /* Name of the reference pass for hooking\n                                        up the new pass.  */\n   int ref_pass_instance_number;     /* Insert the pass at the specified\n@@ -583,16 +583,16 @@ extern gimple_opt_pass *make_pass_update_address_taken (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_convert_switch (gcc::context *ctxt);\n \n /* Current optimization pass.  */\n-extern struct opt_pass *current_pass;\n+extern opt_pass *current_pass;\n \n-extern bool execute_one_pass (struct opt_pass *);\n-extern void execute_pass_list (struct opt_pass *);\n-extern void execute_ipa_pass_list (struct opt_pass *);\n-extern void execute_ipa_summary_passes (struct ipa_opt_pass_d *);\n+extern bool execute_one_pass (opt_pass *);\n+extern void execute_pass_list (opt_pass *);\n+extern void execute_ipa_pass_list (opt_pass *);\n+extern void execute_ipa_summary_passes (ipa_opt_pass_d *);\n extern void execute_all_ipa_transforms (void);\n extern void execute_all_ipa_stmt_fixups (struct cgraph_node *, gimple *);\n-extern bool pass_init_dump_file (struct opt_pass *);\n-extern void pass_fini_dump_file (struct opt_pass *);\n+extern bool pass_init_dump_file (opt_pass *);\n+extern void pass_fini_dump_file (opt_pass *);\n \n extern const char *get_current_pass_name (void);\n extern void print_current_pass (FILE *);\n@@ -601,7 +601,7 @@ extern void ipa_write_summaries (void);\n extern void ipa_write_optimization_summaries (struct lto_symtab_encoder_d *);\n extern void ipa_read_summaries (void);\n extern void ipa_read_optimization_summaries (void);\n-extern void register_one_dump_file (struct opt_pass *);\n+extern void register_one_dump_file (opt_pass *);\n extern bool function_called_by_processed_nodes_p (void);\n \n /* Set to true if the pass is called the first time during compilation of the"}]}