{"sha": "f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc5ZTFiMGY4ZGQ1YTU2NzdjMTFmNTU4YWI1YzVhMmI1MzMzY2NhNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-11-08T12:14:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-11-08T12:14:51Z"}, "message": "re PR target/46208 (redundant extensions of argument registers)\n\n\tPR target/46208\n\t* config/sparc/sparc.c (TARGET_PROMOTE_PROTOTYPES): Delete.\n\t(sparc_promote_prototypes): Likewise.\n\t(sparc_promote_function_mode): Promote in 32-bit mode as well.\n\t(sparc_return_in_memory): Remove superfluous parentheses.\n\t(sparc_struct_value_rtx): Fix long lines.\n\t(sparc_function_value_1): Promote in 32-bit mode as well.\n\nFrom-SVN: r166433", "tree": {"sha": "668ed1a0f83183690923ace27807bd0f88e565a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668ed1a0f83183690923ace27807bd0f88e565a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7/comments", "author": null, "committer": null, "parents": [{"sha": "79770339d5fec4830d342c46814d4029e9626254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79770339d5fec4830d342c46814d4029e9626254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79770339d5fec4830d342c46814d4029e9626254"}], "stats": {"total": 71, "additions": 35, "deletions": 36}, "files": [{"sha": "963cfe0f7894cfa1336ec2462b73b39db64165fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7", "patch": "@@ -1,3 +1,13 @@\n+2010-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/46208\n+\t* config/sparc/sparc.c (TARGET_PROMOTE_PROTOTYPES): Delete.\n+\t(sparc_promote_prototypes): Likewise.\n+\t(sparc_promote_function_mode): Promote in 32-bit mode as well.\n+\t(sparc_return_in_memory): Remove superfluous parentheses.\n+\t(sparc_struct_value_rtx): Fix long lines.\n+\t(sparc_function_value_1): Promote in 32-bit mode as well.\n+\n 2010-11-08  Andrey Belevantsev  <abel@ispras.ru>\n \n \t PR rtl-optimization/45352"}, {"sha": "afea74c72708ae31734523949052897a6662a021", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f79e1b0f8dd5a5677c11f558ab5c5a2b5333cca7", "patch": "@@ -405,7 +405,6 @@ static rtx sparc_tls_got (void);\n static const char *get_some_local_dynamic_name (void);\n static int get_some_local_dynamic_name_1 (rtx *, void *);\n static bool sparc_rtx_costs (rtx, int, int, int *, bool);\n-static bool sparc_promote_prototypes (const_tree);\n static rtx sparc_function_value (const_tree, const_tree, bool);\n static rtx sparc_libcall_value (enum machine_mode, const_rtx);\n static bool sparc_function_value_regno_p (const unsigned int);\n@@ -554,9 +553,6 @@ static const struct default_options sparc_option_optimization_table[] =\n #undef TARGET_PROMOTE_FUNCTION_MODE\n #define TARGET_PROMOTE_FUNCTION_MODE sparc_promote_function_mode\n \n-#undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES sparc_promote_prototypes\n-\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE sparc_function_value\n #undef TARGET_LIBCALL_VALUE\n@@ -4909,15 +4905,6 @@ init_cumulative_args (struct sparc_args *cum, tree fntype,\n   cum->libcall_p = fntype == 0;\n }\n \n-/* Handle the TARGET_PROMOTE_PROTOTYPES target hook.\n-   When a prototype says `char' or `short', really pass an `int'.  */\n-\n-static bool\n-sparc_promote_prototypes (const_tree fntype ATTRIBUTE_UNUSED)\n-{\n-  return TARGET_ARCH32 ? true : false;\n-}\n-\n /* Handle promotion of pointer and integer arguments.  */\n \n static enum machine_mode\n@@ -4933,12 +4920,8 @@ sparc_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n       return Pmode;\n     }\n \n-  /* For TARGET_ARCH64 we need this, as we don't have instructions\n-     for arithmetic operations which do zero/sign extension at the same time,\n-     so without this we end up with a srl/sra after every assignment to an\n-     user variable,  which means very very bad code.  */\n-  if (TARGET_ARCH64\n-      && GET_MODE_CLASS (mode) == MODE_INT\n+  /* Integral arguments are passed as full words, as per the ABI.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n     return word_mode;\n \n@@ -5959,8 +5942,8 @@ sparc_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n        integers are returned like floats of the same size, that is in\n        registers.  Return all vector floats like structure and unions;\n        note that they always have BLKmode like the latter.  */\n-    return ((TYPE_MODE (type) == BLKmode\n-\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 32));\n+    return (TYPE_MODE (type) == BLKmode\n+\t    && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 32);\n }\n \n /* Handle the TARGET_STRUCT_VALUE target hook.\n@@ -6001,22 +5984,22 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n \t  tree size = TYPE_SIZE_UNIT (TREE_TYPE (fndecl));\n \t  rtx size_rtx = GEN_INT (TREE_INT_CST_LOW (size) & 0xfff);\n \t  /* Construct a temporary return value */\n-\t  rtx temp_val = assign_stack_local (Pmode, TREE_INT_CST_LOW (size), 0);\n+\t  rtx temp_val\n+\t    = assign_stack_local (Pmode, TREE_INT_CST_LOW (size), 0);\n \n-\t  /* Implement SPARC 32-bit psABI callee returns struck checking\n-\t     requirements:\n+\t  /* Implement SPARC 32-bit psABI callee return struct checking:\n \n-\t      Fetch the instruction where we will return to and see if\n+\t     Fetch the instruction where we will return to and see if\n \t     it's an unimp instruction (the most significant 10 bits\n \t     will be zero).  */\n \t  emit_move_insn (scratch, gen_rtx_MEM (SImode,\n \t\t\t\t\t\tplus_constant (ret_rtx, 8)));\n \t  /* Assume the size is valid and pre-adjust */\n \t  emit_insn (gen_add3_insn (ret_rtx, ret_rtx, GEN_INT (4)));\n-\t  emit_cmp_and_jump_insns (scratch, size_rtx, EQ, const0_rtx, SImode, 0, endlab);\n+\t  emit_cmp_and_jump_insns (scratch, size_rtx, EQ, const0_rtx, SImode,\n+\t\t\t\t   0, endlab);\n \t  emit_insn (gen_sub3_insn (ret_rtx, ret_rtx, GEN_INT (4)));\n-\t  /* Assign stack temp:\n-\t     Write the address of the memory pointed to by temp_val into\n+\t  /* Write the address of the memory pointed to by temp_val into\n \t     the memory pointed to by mem */\n \t  emit_move_insn (mem, XEXP (temp_val, 0));\n \t  emit_label (endlab);\n@@ -6107,12 +6090,19 @@ sparc_function_value_1 (const_tree type, enum machine_mode mode,\n \t    mclass = MODE_INT;\n \t}\n \n-      /* This must match sparc_promote_function_mode.\n-\t ??? Maybe 32-bit pointers should actually remain in Pmode?  */\n+      /* We should only have pointer and integer types at this point.  This\n+\t must match sparc_promote_function_mode.  */\n       else if (mclass == MODE_INT && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \tmode = word_mode;\n     }\n \n+  /* We should only have pointer and integer types at this point.  This must\n+     match sparc_promote_function_mode.  */\n+  else if (TARGET_ARCH32\n+\t   && mclass == MODE_INT\n+\t   && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+    mode = word_mode;\n+\n   if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT) && TARGET_FPU)\n     regno = SPARC_FP_ARG_FIRST;\n   else\n@@ -6122,9 +6112,8 @@ sparc_function_value_1 (const_tree type, enum machine_mode mode,\n }\n \n /* Handle TARGET_FUNCTION_VALUE.\n-\n-   On SPARC the value is found in the first \"output\" register, but the called\n-   function leaves it in the first \"input\" register.  */\n+   On the SPARC, the value is found in the first \"output\" register, but the\n+   called function leaves it in the first \"input\" register.  */\n \n static rtx\n sparc_function_value (const_tree valtype,\n@@ -6143,9 +6132,9 @@ sparc_libcall_value (enum machine_mode mode,\n   return sparc_function_value_1 (NULL_TREE, mode, false);\n }\n \n-/* Handle FUNCTION_VALUE_REGNO_P.  \n-   On SPARC, the first \"output\" reg is used for integer values, and\n-   the first floating point register is used for floating point values.  */\n+/* Handle FUNCTION_VALUE_REGNO_P.\n+   On the SPARC, the first \"output\" reg is used for integer values, and the\n+   first floating point register is used for floating point values.  */\n \n static bool\n sparc_function_value_regno_p (const unsigned int regno)"}]}