{"sha": "b0e5fa9401bbcb065adc9a79c0bda071d712491d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBlNWZhOTQwMWJiY2IwNjVhZGM5YTc5YzBiZGEwNzFkNzEyNDkxZA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-03-29T17:47:00Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-03-29T17:47:00Z"}, "message": "re PR fortran/37423 (Fortran 2003: DEFERRED bindings not yet implemented)\n\n2009-03-29  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37423\n\t* gfortran.h (struct gfc_typebound_proc): Added new flag `deferred' and\n\tadded a comment explaining DEFERRED binding handling.\n\t* decl.c (match_binding_attributes): Really match DEFERRED attribute.\n\t(match_procedure_in_type): Really match PROCEDURE(interface) syntax\n\tand do some validity checks for DEFERRED and this construct.\n\t* module.c (binding_overriding): New string constant for DEFERRED.\n\t(mio_typebound_proc): Module-IO DEFERRED flag.\n\t* resolve.c (check_typebound_override): Ensure that a non-DEFERRED\n\tbinding is not overridden by a DEFERRED one.\n\t(resolve_typebound_procedure): Allow abstract interfaces as targets\n\tfor DEFERRED bindings.\n\t(ensure_not_abstract_walker), (ensure_not_abstract): New methods.\n\t(resolve_fl_derived): Use new `ensure_not_abstract' method for\n\tnon-ABSTRACT types extending ABSTRACT ones to ensure each DEFERRED\n\tbinding is overridden.\n\t(check_typebound_baseobject): New method.\n\t(resolve_compcall), (resolve_typebound_call): Check base-object of\n\tthe type-bound procedure call.\n\t* gfc-internals.texi (Type-bound procedures): Document a little bit\n\tabout internal handling of DEFERRED bindings.\n\n2009-03-29  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37423\n\t* gfortran.dg/typebound_proc_4.f03: Remove not-implemented check for\n\tDEFERRED bindings.\n\t* gfortran.dg/typebound_proc_9.f03: New test.\n\t* gfortran.dg/typebound_proc_10.f03: New test.\n\t* gfortran.dg/typebound_proc_11.f03: New test.\n\t* gfortran.dg/abstract_type_5.f03: New test.\n\nFrom-SVN: r145248", "tree": {"sha": "35f65c6aad1726518da105f2c369fcb510dd32a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35f65c6aad1726518da105f2c369fcb510dd32a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0e5fa9401bbcb065adc9a79c0bda071d712491d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e5fa9401bbcb065adc9a79c0bda071d712491d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e5fa9401bbcb065adc9a79c0bda071d712491d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e5fa9401bbcb065adc9a79c0bda071d712491d/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0340f2ba6e7a3dd55135da0254c72eb3b47de802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0340f2ba6e7a3dd55135da0254c72eb3b47de802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0340f2ba6e7a3dd55135da0254c72eb3b47de802"}], "stats": {"total": 390, "additions": 373, "deletions": 17}, "files": [{"sha": "3156df6d339750db7965725edcb5510f24b638f8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -1,3 +1,27 @@\n+2009-03-29  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37423\n+\t* gfortran.h (struct gfc_typebound_proc): Added new flag `deferred' and\n+\tadded a comment explaining DEFERRED binding handling.\n+\t* decl.c (match_binding_attributes): Really match DEFERRED attribute.\n+\t(match_procedure_in_type): Really match PROCEDURE(interface) syntax\n+\tand do some validity checks for DEFERRED and this construct.\n+\t* module.c (binding_overriding): New string constant for DEFERRED.\n+\t(mio_typebound_proc): Module-IO DEFERRED flag.\n+\t* resolve.c (check_typebound_override): Ensure that a non-DEFERRED\n+\tbinding is not overridden by a DEFERRED one.\n+\t(resolve_typebound_procedure): Allow abstract interfaces as targets\n+\tfor DEFERRED bindings.\n+\t(ensure_not_abstract_walker), (ensure_not_abstract): New methods.\n+\t(resolve_fl_derived): Use new `ensure_not_abstract' method for\n+\tnon-ABSTRACT types extending ABSTRACT ones to ensure each DEFERRED\n+\tbinding is overridden.\n+\t(check_typebound_baseobject): New method.\n+\t(resolve_compcall), (resolve_typebound_call): Check base-object of\n+\tthe type-bound procedure call.\n+\t* gfc-internals.texi (Type-bound procedures): Document a little bit\n+\tabout internal handling of DEFERRED bindings.\n+\n 2008-03-29  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/38507"}, {"sha": "54a32f173afa432c7f13236b2840bbde60cb7bed", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -6732,6 +6732,7 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n   ba->pass_arg_num = 0;\n   ba->nopass = 0;\n   ba->non_overridable = 0;\n+  ba->deferred = 0;\n \n   /* If we find a comma, we believe there are binding attributes.  */\n   if (gfc_match_char (',') == MATCH_NO)\n@@ -6813,14 +6814,19 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n \t    }\n \n \t  /* DEFERRED flag.  */\n-\t  /* TODO: Handle really once implemented.  */\n \t  m = gfc_match (\" deferred\");\n \t  if (m == MATCH_ERROR)\n \t    goto error;\n \t  if (m == MATCH_YES)\n \t    {\n-\t      gfc_error (\"DEFERRED not yet implemented at %C\");\n-\t      goto error;\n+\t      if (ba->deferred)\n+\t\t{\n+\t\t  gfc_error (\"Duplicate DEFERRED at %C\");\n+\t\t  goto error;\n+\t\t}\n+\n+\t      ba->deferred = 1;\n+\t      continue;\n \t    }\n \n \t  /* PASS possibly including argument.  */\n@@ -6861,6 +6867,13 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n     }\n   while (gfc_match_char (',') == MATCH_YES);\n \n+  /* NON_OVERRIDABLE and DEFERRED exclude themselves.  */\n+  if (ba->non_overridable && ba->deferred)\n+    {\n+      gfc_error (\"NON_OVERRIDABLE and DEFERRED can't both appear at %C\");\n+      goto error;\n+    }\n+\n   if (ba->access == ACCESS_UNKNOWN)\n     ba->access = gfc_typebound_default_access;\n \n@@ -6879,7 +6892,7 @@ match_procedure_in_type (void)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   char target_buf[GFC_MAX_SYMBOL_LEN + 1];\n-  char* target;\n+  char* target = NULL;\n   gfc_typebound_proc* tb;\n   bool seen_colons;\n   bool seen_attrs;\n@@ -6893,11 +6906,25 @@ match_procedure_in_type (void)\n   block = gfc_state_stack->previous->sym;\n   gcc_assert (block);\n \n-  /* TODO: Really implement PROCEDURE(interface).  */\n+  /* Try to match PROCEDURE(interface).  */\n   if (gfc_match (\" (\") == MATCH_YES)\n     {\n-      gfc_error (\"PROCEDURE(interface) at %C is not yet implemented\");\n-      return MATCH_ERROR;\n+      m = gfc_match_name (target_buf);\n+      if (m == MATCH_ERROR)\n+\treturn m;\n+      if (m != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Interface-name expected after '(' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_match (\" )\") != MATCH_YES)\n+\t{\n+\t  gfc_error (\"')' expected at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      target = target_buf;\n     }\n \n   /* Construct the data structure.  */\n@@ -6911,6 +6938,19 @@ match_procedure_in_type (void)\n     return m;\n   seen_attrs = (m == MATCH_YES);\n \n+  /* Check that attribute DEFERRED is given iff an interface is specified, which\n+     means target != NULL.  */\n+  if (tb->deferred && !target)\n+    {\n+      gfc_error (\"Interface must be specified for DEFERRED binding at %C\");\n+      return MATCH_ERROR;\n+    }\n+  if (target && !tb->deferred)\n+    {\n+      gfc_error (\"PROCEDURE(interface) at %C should be declared DEFERRED\");\n+      return MATCH_ERROR;\n+    }\n+\n   /* Match the colons.  */\n   m = gfc_match (\" ::\");\n   if (m == MATCH_ERROR)\n@@ -6933,12 +6973,17 @@ match_procedure_in_type (void)\n     }\n \n   /* Try to match the '=> target', if it's there.  */\n-  target = NULL;\n   m = gfc_match (\" =>\");\n   if (m == MATCH_ERROR)\n     return m;\n   if (m == MATCH_YES)\n     {\n+      if (tb->deferred)\n+\t{\n+\t  gfc_error (\"'=> target' is invalid for DEFERRED binding at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n       if (!seen_colons)\n \t{\n \t  gfc_error (\"'::' needed in PROCEDURE binding with explicit target\"\n@@ -6975,6 +7020,14 @@ match_procedure_in_type (void)\n   ns = block->f2k_derived;\n   gcc_assert (ns);\n \n+  /* If the binding is DEFERRED, check that the containing type is ABSTRACT.  */\n+  if (tb->deferred && !block->attr.abstract)\n+    {\n+      gfc_error (\"Type '%s' containing DEFERRED binding at %C is not ABSTRACT\",\n+\t\t block->name);\n+      return MATCH_ERROR;\n+    }\n+\n   /* See if we already have a binding with this name in the symtree which would\n      be an error.  If a GENERIC already targetted this binding, it may be\n      already there but then typebound is still NULL.  */"}, {"sha": "97aec7ba89f4099f4b6363e4e17032f707ae847d", "filename": "gcc/fortran/gfc-internals.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fgfc-internals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fgfc-internals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfc-internals.texi?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -601,6 +601,11 @@ name, and later during resolution phase the corresponding argument is looked for\n and its position remembered as @code{pass_arg_num} in @code{gfc_typebound_proc}.\n The binding's target procedure is pointed-to by @code{u.specific}.\n \n+@code{DEFERRED} bindings are just like ordinary specific bindings, except\n+that their @code{deferred} flag is set of course and that @code{u.specific}\n+points to their ``interface'' defining symbol (might be an abstract interface)\n+instead of the target procedure.\n+\n At the moment, all type-bound procedure calls are statically dispatched and\n transformed into ordinary procedure calls at resolution time; their actual\n argument list is updated to include at the right position the passed-object"}, {"sha": "0bc5596a938f4eaa7e6397d2582304c4ba935f18", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -1019,7 +1019,7 @@ typedef struct gfc_typebound_proc\n \n   union\n   {\n-    struct gfc_symtree* specific;\n+    struct gfc_symtree* specific; /* The interface if DEFERRED.  */\n     gfc_tbp_generic* generic;\n   }\n   u;\n@@ -1038,6 +1038,7 @@ typedef struct gfc_typebound_proc\n \n   unsigned nopass:1; /* Whether we have NOPASS (PASS otherwise).  */\n   unsigned non_overridable:1;\n+  unsigned deferred:1;\n   unsigned is_generic:1;\n   unsigned function:1, subroutine:1;\n   unsigned error:1; /* Ignore it, when an error occurred during resolution.  */"}, {"sha": "b5b79d03992b7ed48f24f44d9e9d536cc47a797e", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -1700,6 +1700,7 @@ static const mstring binding_overriding[] =\n {\n     minit (\"OVERRIDABLE\", 0),\n     minit (\"NON_OVERRIDABLE\", 1),\n+    minit (\"DEFERRED\", 2),\n     minit (NULL, -1)\n };\n static const mstring binding_generic[] =\n@@ -3205,6 +3206,7 @@ static void\n mio_typebound_proc (gfc_typebound_proc** proc)\n {\n   int flag;\n+  int overriding_flag;\n \n   if (iomode == IO_INPUT)\n     {\n@@ -3217,9 +3219,15 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n \n   (*proc)->access = MIO_NAME (gfc_access) ((*proc)->access, access_types);\n \n+  /* IO the NON_OVERRIDABLE/DEFERRED combination.  */\n+  gcc_assert (!((*proc)->deferred && (*proc)->non_overridable));\n+  overriding_flag = ((*proc)->deferred << 1) | (*proc)->non_overridable;\n+  overriding_flag = mio_name (overriding_flag, binding_overriding);\n+  (*proc)->deferred = ((overriding_flag & 2) != 0);\n+  (*proc)->non_overridable = ((overriding_flag & 1) != 0);\n+  gcc_assert (!((*proc)->deferred && (*proc)->non_overridable));\n+\n   (*proc)->nopass = mio_name ((*proc)->nopass, binding_passing);\n-  (*proc)->non_overridable = mio_name ((*proc)->non_overridable,\n-\t\t\t\t       binding_overriding);\n   (*proc)->is_generic = mio_name ((*proc)->is_generic, binding_generic);\n \n   if (iomode == IO_INPUT)"}, {"sha": "b79e4851ea32e8d3dfcd8abe688b6cadf39a2fd8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -4551,6 +4551,30 @@ update_compcall_arglist (gfc_expr* e)\n }\n \n \n+/* Check that the object a TBP is called on is valid, i.e. it must not be\n+   of ABSTRACT type (as in subobject%abstract_parent%tbp()).  */\n+\n+static gfc_try\n+check_typebound_baseobject (gfc_expr* e)\n+{\n+  gfc_expr* base;\n+\n+  base = extract_compcall_passed_object (e);\n+  if (!base)\n+    return FAILURE;\n+\n+  gcc_assert (base->ts.type == BT_DERIVED);\n+  if (base->ts.derived->attr.abstract)\n+    {\n+      gfc_error (\"Base object for type-bound procedure call at %L is of\"\n+\t\t \" ABSTRACT type '%s'\", &e->where, base->ts.derived->name);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve a call to a type-bound procedure, either function or subroutine,\n    statically from the data in an EXPR_COMPCALL expression.  The adapted\n    arglist and the target-procedure symtree are returned.  */\n@@ -4668,6 +4692,9 @@ resolve_typebound_call (gfc_code* c)\n       return FAILURE;\n     }\n \n+  if (check_typebound_baseobject (c->expr) == FAILURE)\n+    return FAILURE;\n+\n   if (resolve_typebound_generic_call (c->expr) == FAILURE)\n     return FAILURE;\n \n@@ -4704,6 +4731,9 @@ resolve_compcall (gfc_expr* e)\n       return FAILURE;\n     }\n \n+  if (check_typebound_baseobject (e) == FAILURE)\n+    return FAILURE;\n+\n   if (resolve_typebound_generic_call (e) == FAILURE)\n     return FAILURE;\n   gcc_assert (!e->value.compcall.tbp->is_generic);\n@@ -8163,6 +8193,14 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n       return FAILURE;\n     }\n \n+  /* It's an error to override a non-DEFERRED procedure with a DEFERRED one.  */\n+  if (!old->typebound->deferred && proc->typebound->deferred)\n+    {\n+      gfc_error (\"'%s' at %L must not be DEFERRED as it overrides a\"\n+\t\t \" non-DEFERRED binding\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n   /* If the overridden binding is PURE, the overriding must be, too.  */\n   if (old_target->attr.pure && !proc_target->attr.pure)\n     {\n@@ -8505,11 +8543,11 @@ resolve_typebound_procedure (gfc_symtree* stree)\n   gcc_assert (stree->typebound->access != ACCESS_UNKNOWN);\n \n   /* It should be a module procedure or an external procedure with explicit\n-     interface.  */\n+     interface.  For DEFERRED bindings, abstract interfaces are ok as well.  */\n   if ((!proc->attr.subroutine && !proc->attr.function)\n       || (proc->attr.proc != PROC_MODULE\n \t  && proc->attr.if_source != IFSRC_IFBODY)\n-      || proc->attr.abstract)\n+      || (proc->attr.abstract && !stree->typebound->deferred))\n     {\n       gfc_error (\"'%s' must be a module procedure or an external procedure with\"\n \t\t \" an explicit interface at %L\", proc->name, &where);\n@@ -8664,6 +8702,67 @@ add_dt_to_dt_list (gfc_symbol *derived)\n }\n \n \n+/* Ensure that a derived-type is really not abstract, meaning that every\n+   inherited DEFERRED binding is overridden by a non-DEFERRED one.  */\n+\n+static gfc_try\n+ensure_not_abstract_walker (gfc_symbol* sub, gfc_symtree* st)\n+{\n+  if (!st)\n+    return SUCCESS;\n+\n+  if (ensure_not_abstract_walker (sub, st->left) == FAILURE)\n+    return FAILURE;\n+  if (ensure_not_abstract_walker (sub, st->right) == FAILURE)\n+    return FAILURE;\n+\n+  if (st->typebound && st->typebound->deferred)\n+    {\n+      gfc_symtree* overriding;\n+      overriding = gfc_find_typebound_proc (sub, NULL, st->name, true);\n+      gcc_assert (overriding && overriding->typebound);\n+      if (overriding->typebound->deferred)\n+\t{\n+\t  gfc_error (\"Derived-type '%s' declared at %L must be ABSTRACT because\"\n+\t\t     \" '%s' is DEFERRED and not overridden\",\n+\t\t     sub->name, &sub->declared_at, st->name);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+static gfc_try\n+ensure_not_abstract (gfc_symbol* sub, gfc_symbol* ancestor)\n+{\n+  /* The algorithm used here is to recursively travel up the ancestry of sub\n+     and for each ancestor-type, check all bindings.  If any of them is\n+     DEFERRED, look it up starting from sub and see if the found (overriding)\n+     binding is not DEFERRED.\n+     This is not the most efficient way to do this, but it should be ok and is\n+     clearer than something sophisticated.  */\n+\n+  gcc_assert (ancestor && ancestor->attr.abstract && !sub->attr.abstract);\n+\n+  /* Walk bindings of this ancestor.  */\n+  if (ancestor->f2k_derived)\n+    {\n+      gfc_try t;\n+      t = ensure_not_abstract_walker (sub, ancestor->f2k_derived->sym_root);\n+      if (t == FAILURE)\n+\treturn FAILURE;\n+    }\n+\n+  /* Find next ancestor type and recurse on it.  */\n+  ancestor = gfc_get_derived_super_type (ancestor);\n+  if (ancestor)\n+    return ensure_not_abstract (sub, ancestor);\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve the components of a derived type.  */\n \n static gfc_try\n@@ -8791,6 +8890,12 @@ resolve_fl_derived (gfc_symbol *sym)\n   if (gfc_resolve_finalizers (sym) == FAILURE)\n     return FAILURE;\n \n+  /* If this is a non-ABSTRACT type extending an ABSTRACT one, ensure that\n+     all DEFERRED bindings are overridden.  */\n+  if (super_type && super_type->attr.abstract && !sym->attr.abstract\n+      && ensure_not_abstract (sym, super_type) == FAILURE)\n+    return FAILURE;\n+\n   /* Add derived type to the derived type list.  */\n   add_dt_to_dt_list (sym);\n "}, {"sha": "f264b33f301a0c63f50ed4465df95abea4045e4a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -1,3 +1,13 @@\n+2009-03-29  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37423\n+\t* gfortran.dg/typebound_proc_4.f03: Remove not-implemented check for\n+\tDEFERRED bindings.\n+\t* gfortran.dg/typebound_proc_9.f03: New test.\n+\t* gfortran.dg/typebound_proc_10.f03: New test.\n+\t* gfortran.dg/typebound_proc_11.f03: New test.\n+\t* gfortran.dg/abstract_type_5.f03: New test.\n+\n 2008-03-29  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/38507"}, {"sha": "a0060f81795d5b2032b491f7d09c27c96d5076da", "filename": "gcc/testsuite/gfortran.dg/abstract_type_5.f03", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_5.f03?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do \"compile\" }\n+\n+! Abstract Types.\n+! Check for correct handling of abstract-typed base object references.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE, ABSTRACT :: abstract_t\n+    INTEGER :: i\n+  CONTAINS\n+    PROCEDURE, NOPASS :: proc\n+    PROCEDURE, NOPASS :: func\n+  END TYPE abstract_t\n+\n+  TYPE, EXTENDS(abstract_t) :: concrete_t\n+  END TYPE concrete_t\n+\n+CONTAINS\n+\n+  SUBROUTINE proc ()\n+    IMPLICIT NONE\n+    ! Do nothing\n+  END SUBROUTINE proc\n+\n+  INTEGER FUNCTION func ()\n+    IMPLICIT NONE\n+    func = 1234\n+  END FUNCTION func\n+\n+  SUBROUTINE test ()\n+    IMPLICIT NONE\n+    TYPE(concrete_t) :: obj\n+\n+    ! These are ok.\n+    obj%abstract_t%i = 42\n+    CALL obj%proc ()\n+    PRINT *, obj%func ()\n+\n+    ! These are errors (even though the procedures are not DEFERRED!).\n+    CALL obj%abstract_t%proc () ! { dg-error \"is of ABSTRACT type\" }\n+    PRINT *, obj%abstract_t%func () ! { dg-error \"is of ABSTRACT type\" }\n+  END SUBROUTINE test\n+\n+END MODULE m"}, {"sha": "3f372c815f23f14abde163171543500e2b4a972d", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_10.f03", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_10.f03?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test for resolution errors with DEFERRED, namely checks about invalid\n+! overriding and taking into account inherited DEFERRED bindings.\n+! Also check that DEFERRED attribute is saved to module correctly.\n+\n+MODULE m1\n+  IMPLICIT NONE\n+\n+  ABSTRACT INTERFACE\n+    SUBROUTINE intf ()\n+    END SUBROUTINE intf\n+  END INTERFACE\n+\n+  TYPE, ABSTRACT :: abstract_type\n+  CONTAINS\n+    PROCEDURE(intf), DEFERRED, NOPASS :: def\n+    PROCEDURE, NOPASS :: nodef => realproc\n+  END TYPE abstract_type\n+\n+CONTAINS\n+\n+  SUBROUTINE realproc ()\n+  END SUBROUTINE realproc\n+\n+END MODULE m1\n+\n+MODULE m2\n+  USE m1\n+  IMPLICIT NONE\n+\n+  TYPE, ABSTRACT, EXTENDS(abstract_type) :: sub_type1\n+  CONTAINS\n+    PROCEDURE(intf), DEFERRED, NOPASS :: nodef ! { dg-error \"must not be DEFERRED\" }\n+  END TYPE sub_type1\n+\n+  TYPE, EXTENDS(abstract_type) :: sub_type2 ! { dg-error \"must be ABSTRACT\" }\n+  END TYPE sub_type2\n+\n+END MODULE m2\n+\n+! { dg-final { cleanup-modules \"m1\" } }"}, {"sha": "fafc149f574cdd6f92bc785291c3bf4f7b2b671c", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_11.f03", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_11.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_11.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_11.f03?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test that legal usage of DEFERRED is accepted.\n+\n+MODULE testmod\n+  IMPLICIT NONE\n+\n+  ABSTRACT INTERFACE\n+    SUBROUTINE intf ()\n+    END SUBROUTINE intf\n+  END INTERFACE\n+\n+  TYPE, ABSTRACT :: abstract_type\n+  CONTAINS\n+    PROCEDURE(intf), DEFERRED, NOPASS :: p1\n+    PROCEDURE(realproc), DEFERRED, NOPASS :: p2\n+  END TYPE abstract_type\n+\n+  TYPE, EXTENDS(abstract_type) :: sub_type\n+  CONTAINS\n+    PROCEDURE, NOPASS :: p1 => realproc\n+    PROCEDURE, NOPASS :: p2 => realproc\n+  END TYPE sub_type\n+\n+CONTAINS\n+\n+  SUBROUTINE realproc ()\n+  END SUBROUTINE realproc\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }"}, {"sha": "92adc1a852aede49bcacb35413773ad11305c779", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_4.f03", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -30,10 +30,6 @@ MODULE testmod\n     PROCEDURE, PUBLIC, PRIVATE ! { dg-error \"Duplicate\" }\n     PROCEDURE, NON_OVERRIDABLE, NON_OVERRIDABLE ! { dg-error \"Duplicate\" }\n     PROCEDURE, NOPASS, NOPASS ! { dg-error \"illegal NOPASS\" }\n-\n-    ! TODO: Correct these when things get implemented.\n-    PROCEDURE, DEFERRED :: x ! { dg-error \"not yet implemented\" }\n-    PROCEDURE(abc) ! { dg-error \"not yet implemented\" }\n   END TYPE t\n \n CONTAINS"}, {"sha": "9106de695799cd213416240b4b33a5bd8e3ff014", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_9.f03", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5fa9401bbcb065adc9a79c0bda071d712491d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_9.f03?ref=b0e5fa9401bbcb065adc9a79c0bda071d712491d", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test for basic parsing errors for invalid DEFERRED.\n+\n+MODULE testmod\n+  IMPLICIT NONE\n+\n+  ABSTRACT INTERFACE\n+    SUBROUTINE intf ()\n+    END SUBROUTINE intf\n+  END INTERFACE\n+\n+  TYPE not_abstract\n+  CONTAINS\n+    PROCEDURE(intf), DEFERRED, NOPASS :: proc ! { dg-error \"is not ABSTRACT\" }\n+  END TYPE not_abstract\n+\n+  TYPE, ABSTRACT :: abstract_type\n+  CONTAINS\n+    PROCEDURE, DEFERRED :: p2 ! { dg-error \"Interface must be specified\" }\n+    PROCEDURE(intf), NOPASS :: p3 ! { dg-error \"should be declared DEFERRED\" }\n+    PROCEDURE(intf), DEFERRED, NON_OVERRIDABLE :: p4 ! { dg-error \"can't both\" }\n+    PROCEDURE(unknown), DEFERRED :: p5 ! { dg-error \"has no IMPLICIT|module procedure\" }\n+    PROCEDURE(intf), DEFERRED, DEFERRED :: p6 ! { dg-error \"Duplicate DEFERRED\" }\n+    PROCEDURE(intf), DEFERRED :: p6 => proc ! { dg-error \"is invalid for DEFERRED\" }\n+    PROCEDURE(), DEFERRED :: p7 ! { dg-error \"Interface-name expected\" }\n+    PROCEDURE(intf, DEFERRED) :: p8 ! { dg-error \"'\\\\)' expected\" }\n+  END TYPE abstract_type\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }"}]}