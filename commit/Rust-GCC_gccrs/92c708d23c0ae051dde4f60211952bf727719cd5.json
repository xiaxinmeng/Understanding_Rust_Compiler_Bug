{"sha": "92c708d23c0ae051dde4f60211952bf727719cd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJjNzA4ZDIzYzBhZTA1MWRkZTRmNjAyMTE5NTJiZjcyNzcxOWNkNQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2008-05-21T07:01:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-21T07:01:56Z"}, "message": "New file.\n\nFrom-SVN: r135709", "tree": {"sha": "ed67f701808fb8b079d9754bc15cf10d941bbbb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed67f701808fb8b079d9754bc15cf10d941bbbb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92c708d23c0ae051dde4f60211952bf727719cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c708d23c0ae051dde4f60211952bf727719cd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92c708d23c0ae051dde4f60211952bf727719cd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c708d23c0ae051dde4f60211952bf727719cd5/comments", "author": null, "committer": null, "parents": [{"sha": "765f7c95f2ab60dfb5b54f6e4102a2541ef2e9c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765f7c95f2ab60dfb5b54f6e4102a2541ef2e9c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/765f7c95f2ab60dfb5b54f6e4102a2541ef2e9c9"}], "stats": {"total": 409, "additions": 409, "deletions": 0}, "files": [{"sha": "b752aefad404f2fbedf8609afa454e6ff5f7afce", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c708d23c0ae051dde4f60211952bf727719cd5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c708d23c0ae051dde4f60211952bf727719cd5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=92c708d23c0ae051dde4f60211952bf727719cd5", "patch": "@@ -1,3 +1,7 @@\n+2008-05-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-sothco.ads, g-sothco.adb: New files.\n+\n 2008-05-20  Thomas Quinot  <quinot@adacore.com>\n \n \t* Makefile.rtl (GNAT.Sockets.Thin_Common): New unit."}, {"sha": "590bffeee800483c143ed2986c8151008a0f2a38", "filename": "gcc/ada/g-sothco.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c708d23c0ae051dde4f60211952bf727719cd5/gcc%2Fada%2Fg-sothco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c708d23c0ae051dde4f60211952bf727719cd5/gcc%2Fada%2Fg-sothco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sothco.adb?ref=92c708d23c0ae051dde4f60211952bf727719cd5", "patch": "@@ -0,0 +1,79 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--              G N A T . S O C K E T S . T H I N _ C O M M O N             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                       Copyright (C) 2008, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Sockets.Thin_Common is\n+\n+   -----------------\n+   -- Set_Address --\n+   -----------------\n+\n+   procedure Set_Address\n+     (Sin     : Sockaddr_In_Access;\n+      Address : In_Addr)\n+   is\n+   begin\n+      Sin.Sin_Addr := Address;\n+   end Set_Address;\n+\n+   ----------------\n+   -- Set_Family --\n+   ----------------\n+\n+   procedure Set_Family\n+     (Length_And_Family : out Sockaddr_Length_And_Family;\n+      Family            : Family_Type)\n+   is\n+      C_Family : C.int renames Families (Family);\n+      Has_Sockaddr_Len : constant Boolean := Constants.Has_Sockaddr_Len /= 0;\n+   begin\n+      if Has_Sockaddr_Len then\n+         Length_And_Family.Length       := Lengths (Family);\n+         Length_And_Family.Char_Family  := C.unsigned_char  (C_Family);\n+      else\n+         Length_And_Family.Short_Family := C.unsigned_short (C_Family);\n+      end if;\n+   end Set_Family;\n+\n+   --------------\n+   -- Set_Port --\n+   --------------\n+\n+   procedure Set_Port\n+     (Sin  : Sockaddr_In_Access;\n+      Port : C.unsigned_short)\n+   is\n+   begin\n+      Sin.Sin_Port := Port;\n+   end Set_Port;\n+\n+end GNAT.Sockets.Thin_Common;"}, {"sha": "fee37615fb4192df8978cbec6b7441bfee7e2cbb", "filename": "gcc/ada/g-sothco.ads", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c708d23c0ae051dde4f60211952bf727719cd5/gcc%2Fada%2Fg-sothco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c708d23c0ae051dde4f60211952bf727719cd5/gcc%2Fada%2Fg-sothco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sothco.ads?ref=92c708d23c0ae051dde4f60211952bf727719cd5", "patch": "@@ -0,0 +1,326 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--              G N A T . S O C K E T S . T H I N _ C O M M O N             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2008, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the target-independent part of the thin sockets mapping.\n+--  This package should not be directly with'ed by an applications program.\n+\n+with Ada.Unchecked_Conversion;\n+\n+with Interfaces.C;\n+with Interfaces.C.Pointers;\n+with Interfaces.C.Strings;\n+\n+with GNAT.Sockets.Constants;\n+\n+package GNAT.Sockets.Thin_Common is\n+\n+   package C renames Interfaces.C;\n+\n+   use type C.int;\n+   --  This is so we can declare the Failure constant below\n+\n+   Success : constant C.int :=  0;\n+   Failure : constant C.int := -1;\n+\n+   type time_t is\n+     range -2 ** (8 * Constants.SIZEOF_tv_sec - 1)\n+         .. 2 ** (8 * Constants.SIZEOF_tv_sec - 1) - 1;\n+   for time_t'Size use 8 * Constants.SIZEOF_tv_sec;\n+   pragma Convention (C, time_t);\n+\n+   type suseconds_t is\n+     range -2 ** (8 * Constants.SIZEOF_tv_usec - 1)\n+         .. 2 ** (8 * Constants.SIZEOF_tv_usec - 1) - 1;\n+   for suseconds_t'Size use 8 * Constants.SIZEOF_tv_usec;\n+   pragma Convention (C, suseconds_t);\n+\n+   type Timeval is record\n+      Tv_Sec  : time_t;\n+      Tv_Usec : suseconds_t;\n+   end record;\n+   pragma Convention (C, Timeval);\n+\n+   type Timeval_Access is access all Timeval;\n+   pragma Convention (C, Timeval_Access);\n+\n+   Immediat : constant Timeval := (0, 0);\n+\n+   -------------------------------------------\n+   -- Mapping tables to low level constants --\n+   -------------------------------------------\n+\n+   Families : constant array (Family_Type) of C.int :=\n+                (Family_Inet  => Constants.AF_INET,\n+                 Family_Inet6 => Constants.AF_INET6);\n+\n+   Lengths  : constant array (Family_Type) of C.unsigned_char :=\n+                (Family_Inet  => Constants.SIZEOF_sockaddr_in,\n+                 Family_Inet6 => Constants.SIZEOF_sockaddr_in6);\n+\n+   ----------------------------\n+   -- Generic socket address --\n+   ----------------------------\n+\n+   --  Common header\n+\n+   --  All socket address types (struct sockaddr, struct sockaddr_storage,\n+   --  and protocol specific address types) start with the same 2-byte header,\n+   --  which is either a length and a family (one byte each) or just a two-byte\n+   --  family. The following unchecked union describes the two possible layouts\n+   --  and is meant to be constrained with Constants.Have_Sockaddr_Len.\n+\n+   type Sockaddr_Length_And_Family\n+     (Has_Sockaddr_Len : Boolean := False)\n+   is record\n+      case Has_Sockaddr_Len is\n+         when True =>\n+            Length      : C.unsigned_char;\n+            Char_Family : C.unsigned_char;\n+\n+         when False =>\n+            Short_Family : C.unsigned_short;\n+      end case;\n+   end record;\n+   pragma Unchecked_Union (Sockaddr_Length_And_Family);\n+   pragma Convention (C, Sockaddr_Length_And_Family);\n+\n+   procedure Set_Family\n+     (Length_And_Family : out Sockaddr_Length_And_Family;\n+      Family            : Family_Type);\n+   --  Set the family component to the appropriate value for Family, and also\n+   --  set Length accordingly if applicable on this platform.\n+\n+   type Sockaddr is record\n+      Sa_Family : Sockaddr_Length_And_Family;\n+      --  Address family (and address length on some platforms)\n+\n+      Sa_Data   : C.char_array (1 .. 14) := (others => C.nul);\n+      --  Family-specific data\n+      --  Note that some platforms require that all unused (reserved) bytes\n+      --  in addresses be initialized to 0 (e.g. VxWorks).\n+   end record;\n+   pragma Convention (C, Sockaddr);\n+   --  Generic socket address\n+\n+   type Sockaddr_Access is access all Sockaddr;\n+   pragma Convention (C, Sockaddr_Access);\n+   --  Access to socket address\n+\n+   ----------------------------\n+   -- AF_INET socket address --\n+   ----------------------------\n+\n+   type In_Addr is record\n+      S_B1, S_B2, S_B3, S_B4 : C.unsigned_char;\n+   end record;\n+   for In_Addr'Alignment use C.int'Alignment;\n+   pragma Convention (C, In_Addr);\n+   --  IPv4 address, represented as a network-order C.int. Note that the\n+   --  underlying operating system may assume that values of this type have\n+   --  C.int alignment, so we need to provide a suitable alignment clause here.\n+\n+   function To_In_Addr is new Ada.Unchecked_Conversion (C.int, In_Addr);\n+   function To_Int     is new Ada.Unchecked_Conversion (In_Addr, C.int);\n+\n+   type In_Addr_Access is access all In_Addr;\n+   pragma Convention (C, In_Addr_Access);\n+   --  Access to internet address\n+\n+   Inaddr_Any : aliased constant In_Addr := (others => 0);\n+   --  Any internet address (all the interfaces)\n+\n+   type In_Addr_Access_Array is array (C.size_t range <>)\n+     of aliased In_Addr_Access;\n+   pragma Convention (C, In_Addr_Access_Array);\n+\n+   package In_Addr_Access_Pointers is new C.Pointers\n+     (C.size_t, In_Addr_Access, In_Addr_Access_Array, null);\n+   --  Array of internet addresses\n+\n+   type Sockaddr_In is record\n+      Sin_Family : Sockaddr_Length_And_Family;\n+      --  Address family (and address length on some platforms)\n+\n+      Sin_Port   : C.unsigned_short;\n+      --  Port in network byte order\n+\n+      Sin_Addr   : In_Addr;\n+      --  IPv4 address\n+\n+      Sin_Zero   : C.char_array (1 .. 8) := (others => C.nul);\n+      --  Padding\n+      --  Note that some platforms require that all unused (reserved) bytes\n+      --  in addresses be initialized to 0 (e.g. VxWorks).\n+   end record;\n+   pragma Convention (C, Sockaddr_In);\n+   --  Internet socket address\n+\n+   type Sockaddr_In_Access is access all Sockaddr_In;\n+   pragma Convention (C, Sockaddr_In_Access);\n+   --  Access to internet socket address\n+\n+   procedure Set_Port\n+     (Sin  : Sockaddr_In_Access;\n+      Port : C.unsigned_short);\n+   pragma Inline (Set_Port);\n+   --  Set Sin.Sin_Port to Port\n+\n+   procedure Set_Address\n+     (Sin     : Sockaddr_In_Access;\n+      Address : In_Addr);\n+   pragma Inline (Set_Address);\n+   --  Set Sin.Sin_Addr to Address\n+\n+   ---------------------\n+   -- Service entries --\n+   ---------------------\n+\n+   type Chars_Ptr_Array is array (C.size_t range <>) of\n+     aliased C.Strings.chars_ptr;\n+\n+   package Chars_Ptr_Pointers is\n+      new C.Pointers (C.size_t, C.Strings.chars_ptr, Chars_Ptr_Array,\n+                      C.Strings.Null_Ptr);\n+   --  Arrays of C (char *)\n+\n+   type Servent is record\n+      S_Name    : C.Strings.chars_ptr;\n+      S_Aliases : Chars_Ptr_Pointers.Pointer;\n+      S_Port    : C.int;\n+      S_Proto   : C.Strings.chars_ptr;\n+   end record;\n+   pragma Convention (C, Servent);\n+   --  Service entry\n+\n+   type Servent_Access is access all Servent;\n+   pragma Convention (C, Servent_Access);\n+   --  Access to service entry\n+\n+   ------------------\n+   -- Host entries --\n+   ------------------\n+\n+   type Hostent is record\n+      H_Name      : C.Strings.chars_ptr;\n+      H_Aliases   : Chars_Ptr_Pointers.Pointer;\n+      H_Addrtype  : Constants.H_Addrtype_T;\n+      H_Length    : Constants.H_Length_T;\n+      H_Addr_List : In_Addr_Access_Pointers.Pointer;\n+   end record;\n+   pragma Convention (C, Hostent);\n+   --  Host entry\n+\n+   type Hostent_Access is access all Hostent;\n+   pragma Convention (C, Hostent_Access);\n+   --  Access to host entry\n+\n+   ----------------------------\n+   -- Socket sets management --\n+   ----------------------------\n+\n+   type Int_Access is access all C.int;\n+   pragma Convention (C, Int_Access);\n+   --  Access to C integers\n+\n+   procedure Free_Socket_Set (Set : Fd_Set_Access);\n+   --  Free system-dependent socket set\n+\n+   procedure Get_Socket_From_Set\n+     (Set    : Fd_Set_Access;\n+      Socket : Int_Access;\n+      Last   : Int_Access);\n+   --  Get last socket in Socket and remove it from the socket set. The\n+   --  parameter Last is a maximum value of the largest socket. This hint is\n+   --  used to avoid scanning very large socket sets. After a call to\n+   --  Get_Socket_From_Set, Last is set back to the real largest socket in the\n+   --  socket set.\n+\n+   procedure Insert_Socket_In_Set\n+     (Set    : Fd_Set_Access;\n+      Socket : C.int);\n+   --  Insert socket in the socket set\n+\n+   function  Is_Socket_In_Set\n+     (Set    : Fd_Set_Access;\n+      Socket : C.int) return C.int;\n+   --  Check whether Socket is in the socket set, return a non-zero\n+   --  value if it is, zero if it is not.\n+\n+   procedure Last_Socket_In_Set\n+     (Set    : Fd_Set_Access;\n+      Last   : Int_Access);\n+   --  Find the largest socket in the socket set. This is needed for select().\n+   --  When Last_Socket_In_Set is called, parameter Last is a maximum value of\n+   --  the largest socket. This hint is used to avoid scanning very large\n+   --  socket sets. After the call, Last is set back to the real largest socket\n+   --  in the socket set.\n+\n+   function  New_Socket_Set\n+     (Set : Fd_Set_Access) return Fd_Set_Access;\n+   --  Allocate a new socket set which is a system-dependent structure and\n+   --  initialize by copying Set if it is non-null, by making it empty\n+   --  otherwise.\n+\n+   procedure Remove_Socket_From_Set\n+     (Set    : Fd_Set_Access;\n+      Socket : C.int);\n+   --  Remove socket from the socket set\n+\n+   ------------------------------------------\n+   -- Pairs of signalling file descriptors --\n+   ------------------------------------------\n+\n+   type Two_Ints is array (0 .. 1) of C.int;\n+   pragma Convention (C, Two_Ints);\n+   --  Container for two int values\n+\n+   subtype Fd_Pair is Two_Ints;\n+   --  Two_Ints as used for Create_Signalling_Fds: a pair of connected file\n+   --  descriptors, one of which (the \"read end\" of the connection) being used\n+   --  for reading, the other one (the \"write end\") being used for writing.\n+\n+   Read_End  : constant := 0;\n+   Write_End : constant := 1;\n+   --  Indices into an Fd_Pair value providing access to each of the connected\n+   --  file descriptors.\n+\n+private\n+\n+   pragma Import (C, Free_Socket_Set, \"__gnat_free_socket_set\");\n+   pragma Import (C, Get_Socket_From_Set, \"__gnat_get_socket_from_set\");\n+   pragma Import (C, Is_Socket_In_Set, \"__gnat_is_socket_in_set\");\n+   pragma Import (C, Last_Socket_In_Set, \"__gnat_last_socket_in_set\");\n+   pragma Import (C, New_Socket_Set, \"__gnat_new_socket_set\");\n+   pragma Import (C, Insert_Socket_In_Set, \"__gnat_insert_socket_in_set\");\n+   pragma Import (C, Remove_Socket_From_Set, \"__gnat_remove_socket_from_set\");\n+end GNAT.Sockets.Thin_Common;"}]}