{"sha": "150760dd6dd1899705790183d646fa5fc004554e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwNzYwZGQ2ZGQxODk5NzA1NzkwMTgzZDY0NmZhNWZjMDA0NTU0ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-18T10:59:10Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-27T10:53:34Z"}, "message": "cselib: Fix handling of multireg values for call insns [PR93170]\n\ng:3bd2918594dae34ae84f mishandled the case in which only the\ntail end of a multireg hard register is invalidated by the call.\nWalking all the entries should be both safer and more precise.\n\nAvoiding cselib_invalidate_regno also means that we no longer\nwalk the same list multiple times (which is something we did\nbefore g:3bd2918594dae34ae84f too).\n\n2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR rtl-optimization/93170\n\t* cselib.c (cselib_invalidate_regno_val): New function, split out\n\tfrom...\n\t(cselib_invalidate_regno): ...here.\n\t(cselib_invalidated_by_call_p): New function.\n\t(cselib_process_insn): Iterate over all the hard-register entries in\n\tREG_VALUES and invalidate any that cross call-clobbered registers.\n\ngcc/testsuite/\n\t* gcc.dg/torture/pr93170.c: New test.", "tree": {"sha": "3b067c8902f0587db70d5992d8f42e36f4e93e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b067c8902f0587db70d5992d8f42e36f4e93e49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/150760dd6dd1899705790183d646fa5fc004554e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150760dd6dd1899705790183d646fa5fc004554e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150760dd6dd1899705790183d646fa5fc004554e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150760dd6dd1899705790183d646fa5fc004554e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7974a14692cec3ecafed24bc275df803373f3230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7974a14692cec3ecafed24bc275df803373f3230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7974a14692cec3ecafed24bc275df803373f3230"}], "stats": {"total": 186, "additions": 127, "deletions": 59}, "files": [{"sha": "db2421d1c947e3f48f9cac6b1a6026d00b8fdab7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150760dd6dd1899705790183d646fa5fc004554e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150760dd6dd1899705790183d646fa5fc004554e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=150760dd6dd1899705790183d646fa5fc004554e", "patch": "@@ -1,3 +1,13 @@\n+2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/93170\n+\t* cselib.c (cselib_invalidate_regno_val): New function, split out\n+\tfrom...\n+\t(cselib_invalidate_regno): ...here.\n+\t(cselib_invalidated_by_call_p): New function.\n+\t(cselib_process_insn): Iterate over all the hard-register entries in\n+\tREG_VALUES and invalidate any that cross call-clobbered registers.\n+\n 2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* dojump.c (split_comparison): Use HONOR_NANS rather than"}, {"sha": "3e0c69d67b81c1f95d0d0026a292ba97898d96bd", "filename": "gcc/cselib.c", "status": "modified", "additions": 80, "deletions": 59, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150760dd6dd1899705790183d646fa5fc004554e/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150760dd6dd1899705790183d646fa5fc004554e/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=150760dd6dd1899705790183d646fa5fc004554e", "patch": "@@ -2156,6 +2156,52 @@ cselib_lookup (rtx x, machine_mode mode,\n   return ret;\n }\n \n+/* Invalidate the value at *L, which is part of REG_VALUES (REGNO).  */\n+\n+static void\n+cselib_invalidate_regno_val (unsigned int regno, struct elt_list **l)\n+{\n+  cselib_val *v = (*l)->elt;\n+  if (*l == REG_VALUES (regno))\n+    {\n+      /* Maintain the invariant that the first entry of\n+\t REG_VALUES, if present, must be the value used to set\n+\t the register, or NULL.  This is also nice because\n+\t then we won't push the same regno onto user_regs\n+\t multiple times.  */\n+      (*l)->elt = NULL;\n+      l = &(*l)->next;\n+    }\n+  else\n+    unchain_one_elt_list (l);\n+\n+  v = canonical_cselib_val (v);\n+\n+  bool had_locs = v->locs != NULL;\n+  rtx_insn *setting_insn = v->locs ? v->locs->setting_insn : NULL;\n+\n+  /* Now, we clear the mapping from value to reg.  It must exist, so\n+     this code will crash intentionally if it doesn't.  */\n+  for (elt_loc_list **p = &v->locs; ; p = &(*p)->next)\n+    {\n+      rtx x = (*p)->loc;\n+\n+      if (REG_P (x) && REGNO (x) == regno)\n+\t{\n+\t  unchain_one_elt_loc_list (p);\n+\t  break;\n+\t}\n+    }\n+\n+  if (had_locs && v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n+    {\n+      if (setting_insn && DEBUG_INSN_P (setting_insn))\n+\tn_useless_debug_values++;\n+      else\n+\tn_useless_values++;\n+    }\n+}\n+\n /* Invalidate any entries in reg_values that overlap REGNO.  This is called\n    if REGNO is changing.  MODE is the mode of the assignment to REGNO, which\n    is used to determine how many hard registers are being changed.  If MODE\n@@ -2202,9 +2248,6 @@ cselib_invalidate_regno (unsigned int regno, machine_mode mode)\n       while (*l)\n \t{\n \t  cselib_val *v = (*l)->elt;\n-\t  bool had_locs;\n-\t  rtx_insn *setting_insn;\n-\t  struct elt_loc_list **p;\n \t  unsigned int this_last = i;\n \n \t  if (i < FIRST_PSEUDO_REGISTER && v != NULL)\n@@ -2219,44 +2262,7 @@ cselib_invalidate_regno (unsigned int regno, machine_mode mode)\n \t    }\n \n \t  /* We have an overlap.  */\n-\t  if (*l == REG_VALUES (i))\n-\t    {\n-\t      /* Maintain the invariant that the first entry of\n-\t\t REG_VALUES, if present, must be the value used to set\n-\t\t the register, or NULL.  This is also nice because\n-\t\t then we won't push the same regno onto user_regs\n-\t\t multiple times.  */\n-\t      (*l)->elt = NULL;\n-\t      l = &(*l)->next;\n-\t    }\n-\t  else\n-\t    unchain_one_elt_list (l);\n-\n-\t  v = canonical_cselib_val (v);\n-\n-\t  had_locs = v->locs != NULL;\n-\t  setting_insn = v->locs ? v->locs->setting_insn : NULL;\n-\n-\t  /* Now, we clear the mapping from value to reg.  It must exist, so\n-\t     this code will crash intentionally if it doesn't.  */\n-\t  for (p = &v->locs; ; p = &(*p)->next)\n-\t    {\n-\t      rtx x = (*p)->loc;\n-\n-\t      if (REG_P (x) && REGNO (x) == i)\n-\t\t{\n-\t\t  unchain_one_elt_loc_list (p);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (had_locs && v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n-\t    {\n-\t      if (setting_insn && DEBUG_INSN_P (setting_insn))\n-\t\tn_useless_debug_values++;\n-\t      else\n-\t\tn_useless_values++;\n-\t    }\n+\t  cselib_invalidate_regno_val (i, l);\n \t}\n     }\n }\n@@ -2714,6 +2720,28 @@ fp_setter_insn (rtx_insn *insn)\n   return true;\n }\n \n+/* V is one of the values in REG_VALUES (REGNO).  Return true if it\n+   would be invalidated by CALLEE_ABI.  */\n+\n+static bool\n+cselib_invalidated_by_call_p (const function_abi &callee_abi,\n+\t\t\t      unsigned int regno, cselib_val *v)\n+{\n+  machine_mode mode = GET_MODE (v->val_rtx);\n+  if (mode == VOIDmode)\n+    {\n+      v = REG_VALUES (regno)->elt;\n+      if (!v)\n+\t/* If we don't know what the mode of the constant value is, and we\n+\t   don't know what mode the register was set in, conservatively\n+\t   assume that the register is clobbered.  The value's going to be\n+\t   essentially useless in this case anyway.  */\n+\treturn true;\n+      mode = GET_MODE (v->val_rtx);\n+    }\n+  return callee_abi.clobbers_reg_p (mode, regno);\n+}\n+\n /* Record the effects of INSN.  */\n \n void\n@@ -2748,24 +2776,17 @@ cselib_process_insn (rtx_insn *insn)\n     {\n       function_abi callee_abi = insn_callee_abi (insn);\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (elt_list *values = REG_VALUES (i))\n-\t  {\n-\t    /* If we know what mode the value was set in, check whether\n-\t       it is still available after the call in that mode.  If we\n-\t       don't know the mode, we have to check for the worst-case\n-\t       scenario instead.  */\n-\t    if (values->elt)\n-\t      {\n-\t\tmachine_mode mode = GET_MODE (values->elt->val_rtx);\n-\t\tif (callee_abi.clobbers_reg_p (mode, i))\n-\t\t  cselib_invalidate_regno (i, mode);\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (callee_abi.clobbers_at_least_part_of_reg_p (i))\n-\t\t  cselib_invalidate_regno (i, reg_raw_mode[i]);\n-\t      }\n-\t  }\n+\t{\n+\t  elt_list **l = &REG_VALUES (i);\n+\t  while (*l)\n+\t    {\n+\t      cselib_val *v = (*l)->elt;\n+\t      if (v && cselib_invalidated_by_call_p (callee_abi, i, v))\n+\t\tcselib_invalidate_regno_val (i, l);\n+\t      else\n+\t\tl = &(*l)->next;\n+\t    }\n+\t}\n \n       /* Since it is not clear how cselib is going to be used, be\n \t conservative here and treat looping pure or const functions"}, {"sha": "16ddef07516a4d0579efcfb90137f499a3506d2f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150760dd6dd1899705790183d646fa5fc004554e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150760dd6dd1899705790183d646fa5fc004554e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=150760dd6dd1899705790183d646fa5fc004554e", "patch": "@@ -1,3 +1,7 @@\n+2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/torture/pr93170.c: New test.\n+\n 2020-01-27  Martin Liska  <mliska@suse.cz>\n \n \tPR target/93274"}, {"sha": "25a93a3743e62b5e150983cb9c2f51fd919e207e", "filename": "gcc/testsuite/gcc.dg/torture/pr93170.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150760dd6dd1899705790183d646fa5fc004554e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93170.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150760dd6dd1899705790183d646fa5fc004554e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93170.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93170.c?ref=150760dd6dd1899705790183d646fa5fc004554e", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target int128 } */\n+/* { dg-additional-options \"-frename-registers -fno-tree-forwprop -fno-tree-fre -fira-algorithm=priority -mstringop-strategy=loop --param=hot-bb-frequency-fraction=0 -Wno-psabi\" { target { x86_64-*-* i?86-*-* } } } */\n+\n+typedef unsigned char v64u8 __attribute__ ((vector_size (64)));\n+typedef unsigned short v64u16 __attribute__ ((vector_size (64)));\n+typedef unsigned int v64u32 __attribute__ ((vector_size (64)));\n+typedef unsigned long long v64u64 __attribute__ ((vector_size (64)));\n+typedef unsigned __int128 u128;\n+typedef unsigned __int128 v64u128 __attribute__ ((vector_size (64)));\n+\n+int a, b, d, e;\n+v64u64 c;\n+\n+v64u128\n+foo (u128 g, v64u16 h, v64u32 i, v64u128 j)\n+{\n+  c[e] = 0;\n+  j &= (i[1] <<= b);\n+  j >>= ((v64u128) h <= j);\n+  d = __builtin_popcountll (-((v64u8) i)[0]);\n+  return a + g + j;\n+}\n+\n+int\n+main (void)\n+{\n+  v64u128 x = foo (0, (v64u16) { 0, 0, 0, 0, 0, 0, 0, 0, 5 }, (v64u32) { 2 },\n+\t\t   (v64u128) { });\n+  if (x[0] || x[1] || x[2] || x[3])\n+    __builtin_abort ();\n+  return 0;\n+}"}]}