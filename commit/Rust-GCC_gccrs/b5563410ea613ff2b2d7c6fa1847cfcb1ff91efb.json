{"sha": "b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "node_id": "C_kwDOANBUbNoAKGI1NTYzNDEwZWE2MTNmZjJiMmQ3YzZmYTE4NDdjZmNiMWZmOTFlZmI", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-06T19:00:52Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-13T15:28:38Z"}, "message": "Add partial equivalence support to the relation oracle.\n\nThis provides enhancements to the equivalence oracle to also track\npartial equivalences.  They are tracked similar to equivalences, except\nit tracks a 'slice' of another ssa name.   8, 16, 32 and 64 bit slices are\ntracked.  This will allow casts and mask of the same value to compare\nequal.\n\n\t* value-relation.cc (equiv_chain::dump): Don't print empty\n\tequivalences.\n\t(equiv_oracle::equiv_oracle): Allocate a partial equiv table.\n\t(equiv_oracle::~equiv_oracle): Release the partial equiv table.\n\t(equiv_oracle::add_partial_equiv): New.\n\t(equiv_oracle::partial_equiv_set): New.\n\t(equiv_oracle::partial_equiv): New.\n\t(equiv_oracle::query_relation): Check for partial equivs too.\n\t(equiv_oracle::dump): Also dump partial equivs.\n\t(dom_oracle::register_relation): Handle partial equivs.\n\t(dom_oracle::query_relation): Check for partial equivs.\n\t* value-relation.h (enum relation_kind_t): Add partial equivs.\n\t(relation_partial_equiv_p): New.\n\t(relation_equiv_p): New.\n\t(class pe_slice): New.\n\t(class equiv_oracle): Add prototypes.\n\t(pe_to_bits): New.\n\t(bits_to_pe): New.\n\t(pe_min): New.", "tree": {"sha": "05cfe03ae8b832ab2a20077408a54e9b22434205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05cfe03ae8b832ab2a20077408a54e9b22434205"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb/comments", "author": null, "committer": null, "parents": [{"sha": "3130e70dab1e64a7b014391fe941090d5f3b6b7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3130e70dab1e64a7b014391fe941090d5f3b6b7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3130e70dab1e64a7b014391fe941090d5f3b6b7d"}], "stats": {"total": 243, "additions": 229, "deletions": 14}, "files": [{"sha": "ceeca53e0a166effbf3ef9a51517b73b9a76b7f6", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 153, "deletions": 12, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "patch": "@@ -32,10 +32,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"dominance.h\"\n \n-#define VREL_LAST               VREL_NE\n+#define VREL_LAST               VREL_PE64\n \n static const char *kind_string[VREL_LAST + 1] =\n-{ \"varying\", \"undefined\", \"<\", \"<=\", \">\", \">=\", \"==\", \"!=\" };\n+{ \"varying\", \"undefined\", \"<\", \"<=\", \">\", \">=\", \"==\", \"!=\", \"pe8\", \"pe16\",\n+  \"pe32\", \"pe64\" };\n \n // Print a relation_kind REL to file F.\n \n@@ -302,7 +303,7 @@ equiv_chain::dump (FILE *f) const\n   bitmap_iterator bi;\n   unsigned i;\n \n-  if (!m_names)\n+  if (!m_names || bitmap_empty_p (m_names))\n     return;\n   fprintf (f, \"Equivalence set : [\");\n   unsigned c = 0;\n@@ -329,18 +330,124 @@ equiv_oracle::equiv_oracle ()\n   obstack_init (&m_chain_obstack);\n   m_self_equiv.create (0);\n   m_self_equiv.safe_grow_cleared (num_ssa_names + 1);\n+  m_partial.create (0);\n+  m_partial.safe_grow_cleared (num_ssa_names + 1);\n }\n \n // Destruct an equivalency oracle.\n \n equiv_oracle::~equiv_oracle ()\n {\n+  m_partial.release ();\n   m_self_equiv.release ();\n   obstack_free (&m_chain_obstack, NULL);\n   m_equiv.release ();\n   bitmap_obstack_release (&m_bitmaps);\n }\n \n+// Add a partial equivalence R between OP1 and OP2.\n+\n+void\n+equiv_oracle::add_partial_equiv (relation_kind r, tree op1, tree op2)\n+{\n+  int v1 = SSA_NAME_VERSION (op1);\n+  int v2 = SSA_NAME_VERSION (op2);\n+  int prec2 = TYPE_PRECISION (TREE_TYPE (op2));\n+  int bits = pe_to_bits (r);\n+  gcc_checking_assert (bits && prec2 >= bits);\n+\n+  if (v1 >= (int)m_partial.length () || v2 >= (int)m_partial.length ())\n+    m_partial.safe_grow_cleared (num_ssa_names + 1);\n+  gcc_checking_assert (v1 < (int)m_partial.length ()\n+\t\t       && v2 < (int)m_partial.length ());\n+\n+  pe_slice &pe1 = m_partial[v1];\n+  pe_slice &pe2 = m_partial[v2];\n+\n+  if (pe1.members)\n+    {\n+      // If the definition pe1 already has an entry, either the stmt is\n+      // being re-evaluated, or the def was used before being registered.\n+      // In either case, if PE2 has an entry, we simply do nothing.\n+      if (pe2.members)\n+\treturn;\n+      // PE1 is the LHS and already has members, so everything in the set\n+      // should be a slice of PE2 rather than PE1.\n+      pe2.code = pe_min (r, pe1.code);\n+      pe2.ssa_base = op2;\n+      pe2.members = pe1.members;\n+      bitmap_iterator bi;\n+      unsigned x;\n+      EXECUTE_IF_SET_IN_BITMAP (pe1.members, 0, x, bi)\n+\t{\n+\t  m_partial[x].ssa_base = op2;\n+\t  m_partial[x].code = pe2.code;\n+\t}\n+      bitmap_set_bit (pe1.members, v2);\n+      return;\n+    }\n+  if (pe2.members)\n+    {\n+      pe1.ssa_base = pe2.ssa_base;\n+      // If pe2 is a 16 bit value, but only an 8 bit copy, we can't be any\n+      // more than an 8 bit equivalence here, so choose MIN value.\n+      pe1.code = pe_min (r, pe2.code);\n+      pe1.members = pe2.members;\n+      bitmap_set_bit (pe1.members, v1);\n+    }\n+  else\n+    {\n+      // Neither name has an entry, simply create op1 as slice of op2.\n+      pe2.code = bits_to_pe (TYPE_PRECISION (TREE_TYPE (op2)));\n+      if (pe2.code == VREL_VARYING)\n+\treturn;\n+      pe2.ssa_base = op2;\n+      pe2.members = BITMAP_ALLOC (&m_bitmaps);\n+      bitmap_set_bit (pe2.members, v2);\n+      pe1.ssa_base = op2;\n+      pe1.code = r;\n+      pe1.members = pe2.members;\n+      bitmap_set_bit (pe1.members, v1);\n+    }\n+}\n+\n+// Return the set of partial equivalences associated with NAME.  The bitmap\n+// will be NULL if there are none.\n+\n+const pe_slice *\n+equiv_oracle::partial_equiv_set (tree name)\n+{\n+  int v = SSA_NAME_VERSION (name);\n+  if (v >= (int)m_partial.length ())\n+    return NULL;\n+  return &m_partial[v];\n+}\n+\n+// Query if there is a partial equivalence between SSA1 and SSA2.  Return\n+// VREL_VARYING if there is not one.  If BASE is non-null, return the base\n+// ssa-name this is a slice of.\n+\n+relation_kind\n+equiv_oracle::partial_equiv (tree ssa1, tree ssa2, tree *base) const\n+{\n+  int v1 = SSA_NAME_VERSION (ssa1);\n+  int v2 = SSA_NAME_VERSION (ssa2);\n+\n+  if (v1 >= (int)m_partial.length () || v2 >= (int)m_partial.length ())\n+    return VREL_VARYING;\n+\n+  const pe_slice &pe1 = m_partial[v1];\n+  const pe_slice &pe2 = m_partial[v2];\n+  if (pe1.members && pe2.members == pe1.members)\n+    {\n+      if (base)\n+\t*base = pe1.ssa_base;\n+      return pe_min (pe1.code, pe2.code);\n+    }\n+  return VREL_VARYING;\n+}\n+\n+\n // Find and return the equivalency set for SSA along the dominators of BB.\n // This is the external API.\n \n@@ -365,15 +472,17 @@ equiv_oracle::equiv_set (tree ssa, basic_block bb)\n   return m_self_equiv[v];\n }\n \n-// Query if thre is a relation (equivalence) between 2 SSA_NAMEs.\n+// Query if there is a relation (equivalence) between 2 SSA_NAMEs.\n \n relation_kind\n equiv_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n {\n   // If the 2 ssa names share the same equiv set, they are equal.\n   if (equiv_set (ssa1, bb) == equiv_set (ssa2, bb))\n     return VREL_EQ;\n-  return VREL_VARYING;\n+\n+  // Check if there is a partial equivalence.\n+  return partial_equiv (ssa1, ssa2);\n }\n \n // Query if thre is a relation (equivalence) between 2 SSA_NAMEs.\n@@ -515,6 +624,12 @@ void\n equiv_oracle::register_relation (basic_block bb, relation_kind k, tree ssa1,\n \t\t\t\t tree ssa2)\n {\n+  // Process partial equivalencies.\n+  if (relation_partial_equiv_p (k))\n+    {\n+      add_partial_equiv (k, ssa1, ssa2);\n+      return;\n+    }\n   // Only handle equality relations.\n   if (k != VREL_EQ)\n     return;\n@@ -611,12 +726,34 @@ equiv_oracle::dump (FILE *f, basic_block bb) const\n {\n   if (bb->index >= (int)m_equiv.length ())\n     return;\n-  if (!m_equiv[bb->index])\n-    return;\n-\n-  equiv_chain *ptr = m_equiv[bb->index]->m_next;\n-  for (; ptr; ptr = ptr->m_next)\n-    ptr->dump (f);\n+  // Process equivalences.\n+  if (m_equiv[bb->index])\n+    {\n+      equiv_chain *ptr = m_equiv[bb->index]->m_next;\n+      for (; ptr; ptr = ptr->m_next)\n+\tptr->dump (f);\n+    }\n+  // Look for partial equivalences defined in this block..\n+  for (unsigned i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      if (!gimple_range_ssa_p (name) || !SSA_NAME_DEF_STMT (name))\n+\tcontinue;\n+      if (i >= m_partial.length ())\n+\tbreak;\n+     tree base = m_partial[i].ssa_base;\n+      if (base && name != base && gimple_bb (SSA_NAME_DEF_STMT (name)) == bb)\n+\t{\n+\t  relation_kind k = partial_equiv (name, base);\n+\t  if (k != VREL_VARYING)\n+\t    {\n+\t      value_relation vr (k, name, base);\n+\t      fprintf (f, \"Partial equiv \");\n+\t      vr.dump (f);\n+\t      fputc ('\\n',f);\n+\t    }\n+\t}\n+    }\n }\n \n // Dump all equivalence sets known to the oracle.\n@@ -906,7 +1043,7 @@ dom_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n     return;\n \n   // Equivalencies are handled by the equivalence oracle.\n-  if (k == VREL_EQ)\n+  if (relation_equiv_p (k))\n     equiv_oracle::register_relation (bb, k, op1, op2);\n   else\n     {\n@@ -1210,6 +1347,10 @@ dom_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n   if (bitmap_bit_p (equiv1, v2) && bitmap_bit_p (equiv2, v1))\n     return VREL_EQ;\n \n+  kind = partial_equiv (ssa1, ssa2);\n+  if (kind != VREL_VARYING)\n+    return kind;\n+\n   // Initially look for a direct relationship and just return that.\n   kind = find_relation_dom (bb, v1, v2);\n   if (kind != VREL_VARYING)"}, {"sha": "f5f2524ad56ef67c88fa650447c21d18399cb9c8", "filename": "gcc/value-relation.h", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=b5563410ea613ff2b2d7c6fa1847cfcb1ff91efb", "patch": "@@ -70,7 +70,11 @@ typedef enum relation_kind_t\n   VREL_GT,\t\t// r1 > r2\n   VREL_GE,\t\t// r1 >= r2\n   VREL_EQ,\t\t// r1 == r2\n-  VREL_NE\t\t// r1 != r2\n+  VREL_NE,\t\t// r1 != r2\n+  VREL_PE8,\t\t// 8 bit partial equivalency\n+  VREL_PE16,\t\t// 16 bit partial equivalency\n+  VREL_PE32,\t\t// 32 bit partial equivalency\n+  VREL_PE64\t\t// 64 bit partial equivalency\n } relation_kind;\n \n // General relation kind transformations.\n@@ -79,7 +83,12 @@ relation_kind relation_intersect (relation_kind r1, relation_kind r2);\n relation_kind relation_negate (relation_kind r);\n relation_kind relation_swap (relation_kind r);\n inline bool relation_lt_le_gt_ge_p (relation_kind r)\n-\t\t\t\t    { return (r >= VREL_LT && r <= VREL_GE); }\n+\t\t      { return (r >= VREL_LT && r <= VREL_GE); }\n+inline bool relation_partial_equiv_p (relation_kind r)\n+\t\t      { return (r >= VREL_PE8 && r <= VREL_PE64); }\n+inline bool relation_equiv_p (relation_kind r)\n+\t\t      { return r == VREL_EQ || relation_partial_equiv_p (r); }\n+\n void print_relation (FILE *f, relation_kind rel);\n \n class relation_oracle\n@@ -93,6 +102,7 @@ class relation_oracle\n \n   // Return equivalency set for an SSA name in a basic block.\n   virtual const_bitmap equiv_set (tree, basic_block) = 0;\n+  virtual const class pe_slice *partial_equiv_set (tree) { return NULL; }\n   // register a relation between 2 ssa names in a basic block.\n   virtual void register_relation (basic_block, relation_kind, tree, tree) = 0;\n   // Query for a relation between two ssa names in a basic block.\n@@ -125,6 +135,14 @@ class equiv_chain\n   equiv_chain *find (unsigned ssa);\n };\n \n+class pe_slice\n+{\n+public:\n+  tree ssa_base;  \t// Slice of this name.\n+  relation_kind code;\t// bits that are equivalent.\n+  bitmap members;\t// Other members in the partial equivalency.\n+};\n+\n // The equivalency oracle maintains equivalencies using the dominator tree.\n // Equivalencies apply to an entire basic block.  Equivalencies on edges\n // can be represented only on edges whose destination is a single-pred block,\n@@ -137,9 +155,12 @@ class equiv_oracle : public relation_oracle\n   ~equiv_oracle ();\n \n   const_bitmap equiv_set (tree ssa, basic_block bb) final override;\n+  const pe_slice *partial_equiv_set (tree name) final override;\n   void register_relation (basic_block bb, relation_kind k, tree ssa1,\n \t\t\t  tree ssa2) override;\n \n+  void add_partial_equiv (relation_kind, tree, tree);\n+  relation_kind partial_equiv (tree ssa1, tree ssa2, tree *base = NULL) const;\n   relation_kind query_relation (basic_block, tree, tree) override;\n   relation_kind query_relation (basic_block, const_bitmap, const_bitmap)\n     override;\n@@ -153,6 +174,7 @@ class equiv_oracle : public relation_oracle\n   bitmap m_equiv_set;\t// Index by ssa-name. true if an equivalence exists.\n   vec <equiv_chain *> m_equiv;\t// Index by BB.  list of equivalences.\n   vec <bitmap> m_self_equiv;  // Index by ssa-name, self equivalency set.\n+  vec <pe_slice> m_partial;  // Partial equivalencies.\n \n   void limit_check (basic_block bb = NULL);\n   equiv_chain *find_equiv_block (unsigned ssa, int bb) const;\n@@ -315,4 +337,56 @@ value_relation::value_relation (relation_kind kind, tree n1, tree n2)\n   set_relation (kind, n1, n2);\n }\n \n+// Return the number of bits associated with partial equivalency T.\n+// Return 0 if this is not a supported partial equivalency relation.\n+\n+inline int\n+pe_to_bits (relation_kind t)\n+{\n+  switch (t)\n+  {\n+    case VREL_PE8:\n+      return 8;\n+    case VREL_PE16:\n+      return 16;\n+    case VREL_PE32:\n+      return 32;\n+    case VREL_PE64:\n+      return 64;\n+    default:\n+      return 0;\n+  }\n+}\n+\n+// Return the partial equivalency code associated with the number of BITS.\n+// return VREL_VARYING if there is no exact match.\n+\n+inline relation_kind\n+bits_to_pe (int bits)\n+{\n+  switch (bits)\n+  {\n+    case 8:\n+      return VREL_PE8;\n+    case 16:\n+      return VREL_PE16;\n+    case 32:\n+      return VREL_PE32;\n+    case 64:\n+      return VREL_PE64;\n+    default:\n+      return VREL_VARYING;\n+  }\n+}\n+\n+// Given partial equivalencies T1 and T2, return the snmallest kind.\n+\n+inline relation_kind\n+pe_min (relation_kind t1, relation_kind t2)\n+{\n+  gcc_checking_assert (relation_partial_equiv_p (t1));\n+  gcc_checking_assert (relation_partial_equiv_p (t2));\n+  // VREL_PE are declared small to large, so simple min will suffice.\n+  return MIN (t1, t2);\n+}\n #endif  /* GCC_VALUE_RELATION_H */"}]}