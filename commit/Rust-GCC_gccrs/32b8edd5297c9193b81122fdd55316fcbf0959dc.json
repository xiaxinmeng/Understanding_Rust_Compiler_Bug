{"sha": "32b8edd5297c9193b81122fdd55316fcbf0959dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJiOGVkZDUyOTdjOTE5M2I4MTEyMmZkZDU1MzE2ZmNiZjA5NTlkYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:38Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:38Z"}, "message": "vect: Ensure reduc_inputs always have vectype\n\nVector reduction accumulators can differ in signedness from the\nfinal scalar result.  The conversions to handle that case were\ndistributed through vect_create_epilog_for_reduction; this patch\ndoes the conversion up-front instead.\n\ngcc/\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Convert\n\tthe phi results to vectype after creating them.  Remove later\n\tconversion code that thus becomes redundant.", "tree": {"sha": "c26baf3e12275a9c2770dfca606c26d4fe317b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c26baf3e12275a9c2770dfca606c26d4fe317b9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32b8edd5297c9193b81122fdd55316fcbf0959dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b8edd5297c9193b81122fdd55316fcbf0959dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32b8edd5297c9193b81122fdd55316fcbf0959dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b8edd5297c9193b81122fdd55316fcbf0959dc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81ad6bfc078ca36a42446e2f2295102ffaac9ee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ad6bfc078ca36a42446e2f2295102ffaac9ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ad6bfc078ca36a42446e2f2295102ffaac9ee1"}], "stats": {"total": 28, "additions": 11, "deletions": 17}, "files": [{"sha": "1bd9a6ea52c2ab089a0862c28201491c12b919ef", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b8edd5297c9193b81122fdd55316fcbf0959dc/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b8edd5297c9193b81122fdd55316fcbf0959dc/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=32b8edd5297c9193b81122fdd55316fcbf0959dc", "patch": "@@ -5214,9 +5214,11 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   if (double_reduc)\n     loop = outer_loop;\n   exit_bb = single_exit (loop)->dest;\n+  exit_gsi = gsi_after_labels (exit_bb);\n   reduc_inputs.create (slp_node ? vec_num : ncopies);\n   for (unsigned i = 0; i < vec_num; i++)\n     {\n+      gimple_seq stmts = NULL;\n       if (slp_node)\n \tdef = vect_get_slp_vect_def (slp_node, i);\n       else\n@@ -5228,12 +5230,12 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t  if (j)\n \t    def = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[j]);\n \t  SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, def);\n+\t  new_def = gimple_convert (&stmts, vectype, new_def);\n \t  reduc_inputs.quick_push (new_def);\n \t}\n+      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n     }\n \n-  exit_gsi = gsi_after_labels (exit_bb);\n-\n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3\n          (i.e. when reduc_fn is not available) and in the final adjustment\n \t code (if needed).  Also get the original scalar reduction variable as\n@@ -5277,17 +5279,14 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       || ncopies > 1)\n     {\n       gimple_seq stmts = NULL;\n-      tree first_vect = gimple_convert (&stmts, vectype, reduc_inputs[0]);\n+      tree single_input = reduc_inputs[0];\n       for (k = 1; k < reduc_inputs.length (); k++)\n-        {\n-\t  tree second_vect = gimple_convert (&stmts, vectype, reduc_inputs[k]);\n-          first_vect = gimple_build (&stmts, code, vectype,\n-\t\t\t\t     first_vect, second_vect);\n-        }\n+\tsingle_input = gimple_build (&stmts, code, vectype,\n+\t\t\t\t     single_input, reduc_inputs[k]);\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n \n       reduc_inputs.truncate (0);\n-      reduc_inputs.safe_push (first_vect);\n+      reduc_inputs.safe_push (single_input);\n     }\n \n   if (STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION\n@@ -5323,10 +5322,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       /* Vector of {0, 0, 0,...}.  */\n       tree zero_vec = build_zero_cst (vectype);\n \n-      gimple_seq stmts = NULL;\n-      reduc_inputs[0] = gimple_convert (&stmts, vectype, reduc_inputs[0]);\n-      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n-\n       /* Find maximum value from the vector of found indexes.  */\n       tree max_index = make_ssa_name (index_scalar_type);\n       gcall *max_index_stmt = gimple_build_call_internal (IFN_REDUC_MAX,\n@@ -5394,7 +5389,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \n       /* Convert the reduced value back to the result type and set as the\n \t result.  */\n-      stmts = NULL;\n+      gimple_seq stmts = NULL;\n       new_temp = gimple_build (&stmts, VIEW_CONVERT_EXPR, scalar_type,\n \t\t\t       data_reduc);\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n@@ -5412,7 +5407,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t     val = data_reduc[i], idx_val = induction_index[i];\n \t return val;  */\n \n-      tree data_eltype = TREE_TYPE (TREE_TYPE (reduc_inputs[0]));\n+      tree data_eltype = TREE_TYPE (vectype);\n       tree idx_eltype = TREE_TYPE (TREE_TYPE (induction_index));\n       unsigned HOST_WIDE_INT el_size = tree_to_uhwi (TYPE_SIZE (idx_eltype));\n       poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (TREE_TYPE (induction_index));\n@@ -5488,8 +5483,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t\t\t \"Reduce using direct vector reduction.\\n\");\n \n       gimple_seq stmts = NULL;\n-      reduc_inputs[0] = gimple_convert (&stmts, vectype, reduc_inputs[0]);\n-      vec_elem_type = TREE_TYPE (TREE_TYPE (reduc_inputs[0]));\n+      vec_elem_type = TREE_TYPE (vectype);\n       new_temp = gimple_build (&stmts, as_combined_fn (reduc_fn),\n \t\t\t       vec_elem_type, reduc_inputs[0]);\n       new_temp = gimple_convert (&stmts, scalar_type, new_temp);"}]}