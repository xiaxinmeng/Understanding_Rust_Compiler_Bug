{"sha": "7a6cf439109c013148426537f69468fe60add3a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E2Y2Y0MzkxMDljMDEzMTQ4NDI2NTM3ZjY5NDY4ZmU2MGFkZDNhMg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T07:46:50Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T07:46:50Z"}, "message": "sparc.h (cpu_type): New enum.\n\n\t* sparc/sparc.h (cpu_type): New enum.\n\t(CPP_PREDEFINES,CPP_SPEC): Add v9 support.\n\t(NO_BUILTIN_PTRDIFF_TYPE, NO_BUILTIN_SIZE_TYPE, MAX_WCHAR_TYPE_SIZE,\n\tSHORT_TYPE_SIZE, INT_TYPE_SIZE, LONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE,\n\tFLOAT_TYPE_SIZE, DOUBLE_TYPE_SIZE, MAX_INT_TYPE_SIZE,\n\tMAX_LONG_TYPE_SIZE): Define.\n\t(PTRDIFF_TYPE, SIZE_TYPE, BITS_PER_WORD, MAX_BITS_PER_WORD,\n\tUNITS_PER_WORD, MAX_UNITS_PER_WORD, LONG_DOUBLE_TYPE_SIZE,\n\tPOINTER_SIZE, PARM_BOUNDARY, STACK_BOUNDARY, SPARC_STACK_ALIGN,\n\tEMPTY_FIELD_BOUNDARY, BIGGEST_ALIGNMENT, FIRST_PSEUDO_REGISTER,\n\tFIXED_REGISTERS, CALL_USED_REGISTERS, CONDITIONAL_REGISTER_USAGE):\n\tAdd v9 support.\n\t(sparc_override_options, sparc_code_model): Declare.\n\t(OVERRIDE_OPTIONS): Call it.\n\t(MASK_*): Define bits set by target flags.\n\t(TARGET_*): Use them.\n\t({MASK,TARGET}_{V9,INT64,LONG64,PTR64,ENV32,STACK_BIAS,\n\tMEDLOW,MEDANY,FULLANY}): Define.\n\t(MEDANY_BASE_REG): Define.\n\t(V9_SWITCHES, TARGET_OPTIONS): Define.\n\t(TARGET_SWITCHES, TARGET_DEFAULT): Use MASK_*.\n\t(SPARC_STACK_BIAS, SECONDARY_MEMORY_NEEDED_MODE): Define.\n\t(SECONDARY_MEMORY_NEEDED): Simplify.\n\t(hard_regno_mode_class, sparc_mode_class, sparc_cpu_type): Declare.\n\t(REG_PARM_STACK_SPACE): Do not define if v9.\n\t(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK, MODES_TIEABLE_P,\n\tRETURN_IN_MEMORY, STRUCT_VALUE, STRUCT_VALUE_INCOMING, reg_class,\n\tREG_CLASS_NAMES, REG_CLASS_CONTENTS, REGNO_REG_CLASS, REG_ALLOC_ORDER,\n\tREG_LEAF_ALLOC_ORDER, LEAF_REGISTERS, REG_CLASS_FROM_LETTER,\n\tCLASS_MAX_NREGS, STARTING_FRAME_OFFSET, FIRST_PARM_OFFSET,\n\tBASE_RETURN_VALUE_REG, BASE_OUTGOING_VALUE_REG, BASE_PASSING_ARG_REG,\n\tBASE_INCOMING_ARG_REG, FUNCTION_ARG_REGNO_P): Add v9 support.\n\t(sparc_arg_class): New enum (v9 only).\n\t(sparc_args): New struct to record v9 arguments.\n\t(CUMULATIVE_ARGS): Use it (v9 only).\n\t(GET_SPARC_ARG_CLASS): Define.\n\t(sparc_arg_count, sparc_n_named_args): Declare.\n\t(PASS_IN_REG_P): Define.\n\t(ROUND_REG, ROUND_ADVANCE, INIT_CUMULATIVE_ARGS, FUNCTION_ARG_ADVANCE,\n\tFUNCTION_ARG, FUNCTION_INCOMING_ARG, FUNCTION_ARG_PARTIAL_NREGS,\n\tFUNCTION_ARG_PASS_BY_REFERENCE, FUNCTION_ARG_CALLEE_COPIES):\n\tAdd v9 support.\n\t(sparc64_init_expanders, sparc64_fpconv_stack_temp): Declare.\n\t(INIT_EXPANDERS): Define (v9 only).\n\t(gen_v9_scc, output_v9branch): Declare.\n\t(HAVE_conditional_move): Define.\n\t(FUNCTION_PROFILER, FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tDYNAMIC_CHAIN_ADDRESS, RETURN_ADDR_RTX, REGNO_OK_FOR_FP_P,\n\tREG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P, EXTRA_CONSTRAINT,\n\tCASE_VECTOR_MODE, Pmode, EXTRA_CC_MODES, EXTRA_CC_NAMES,\n\tSELECT_CC_MODE, REGISTER_NAMES): Add v9 support.\n\t(REGNO_OK_FOR_CCFP_P): Define.\n\t(sparc_initialize_trampoline, sparc64_initialize_trampoline): Declare.\n\t(INITIALIZE_TRAMPOLINE): Call them.\n\t(ENCODE_SECTION_INFO): Mark functions in v9.\n\t(RTX_COSTS): Assume MULT costs the same for v9 as v8.\n\t(ASM_LONGLONG, ASM_FLOAT): Define.\n\t(ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Add v9 support.\n\nFrom-SVN: r7485", "tree": {"sha": "3b892a9a8a701fcd3b4c4bde4245f29a0c060cbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b892a9a8a701fcd3b4c4bde4245f29a0c060cbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a6cf439109c013148426537f69468fe60add3a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6cf439109c013148426537f69468fe60add3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a6cf439109c013148426537f69468fe60add3a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6cf439109c013148426537f69468fe60add3a2/comments", "author": null, "committer": null, "parents": [{"sha": "df9da8adc888027139572e2bae8017dc6f2fbac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df9da8adc888027139572e2bae8017dc6f2fbac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df9da8adc888027139572e2bae8017dc6f2fbac8"}], "stats": {"total": 1053, "additions": 809, "deletions": 244}, "files": [{"sha": "9f445bb7c3ce8bae967a6a711b99e33999ecc75d", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 809, "deletions": 244, "changes": 1053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cf439109c013148426537f69468fe60add3a2/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cf439109c013148426537f69468fe60add3a2/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=7a6cf439109c013148426537f69468fe60add3a2", "patch": "@@ -1,6 +1,8 @@\n /* Definitions of target machine for GNU compiler, for Sun SPARC.\n    Copyright (C) 1987, 1988, 1989, 1992, 1994 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n+   64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n+   at Cygnus Support.\n \n This file is part of GNU CC.\n \n@@ -21,6 +23,43 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Note that some other tm.h files include this one and then override\n    many of the definitions that relate to assembler syntax.  */\n \n+/* Sparc64 support has been added by trying to allow for a day when one\n+   compiler can handle both v8 and v9.  There are a few cases where this\n+   isn't doable, but keep them to a minimum!  Two macros are used to help out:\n+   TARGET_V9 is used to select (at runtime) !v9-ness or v9-ness.\n+   SPARCV9 is defined when compiling for sparc64 only.\n+   In places where it is possible to choose between the two at runtime, use\n+   TARGET_V9.  In places where it is currently not possible to select\n+   between the two at runtime use SPARCV9.  Again, keep uses of SPARCV9 to a\n+   minimum.  No attempt is made to support both v8 and v9 in the v9 compiler.\n+\n+   If a combination v8/v9 compiler is too slow, it should always be possible\n+   to #define TARGET_V9 as 0 (and potentially other v9-only options), and\n+   #undef SPARCV9.  */\n+\n+/* What cpu we're compiling for.  This must coincide with the `cpu_type'\n+   attribute in the .md file.  The names were chosen to avoid potential\n+   misunderstandings with the various 32 bit flavors (v7, v8, etc.): if we\n+   used CPU_V9 then we'd want to use something like CPU_V8 but that could be\n+   misleading and CPU_NOTV9 sounds klunky.  */\n+enum cpu_type { CPU_32BIT, CPU_64BIT };\n+extern enum cpu_type sparc_cpu_type;\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+/* ??? The GCC_NEW_VARARGS macro is now obsolete, because gcc always uses\n+   the right varags.h file when bootstrapping.  */\n+\n+#ifdef SPARCV9\n+#define CPP_PREDEFINES \\\n+  \"-Dsparc -Dsun -Dunix -D__sparc_v9__ \\\n+   -Asystem(unix) -Asystem(bsd) -Acpu(sparc64) -Amachine(sparc64)\"\n+#else\n+#define CPP_PREDEFINES \\\n+  \"-Dsparc -Dsun -Dunix -D__GCC_NEW_VARARGS__ \\\n+   -Asystem(unix) -Asystem(bsd)\"\n+#endif\n+\n #define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} %{g:-lg}\"\n \n /* Provide required defaults for linker -e and -d switches.  */\n@@ -33,20 +72,38 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define ASM_SPEC \" %| %{!pg:%{!p:%{fpic:-k} %{fPIC:-k}}}\"\n \n /* Define macros to distinguish architectures.  */\n-#define CPP_SPEC \"%{msparclite:-D__sparclite__} %{mf930:-D__sparclite__} \\\n-%{mf934:-D__sparclite__} %{mv8:-D__sparc_v8__}\"\n+#define CPP_SPEC \"\\\n+%{msparclite:-D__sparclite__} \\\n+%{mf930:-D__sparclite__} %{mf934:-D__sparclite__} \\\n+%{mv8:-D__sparc_v8__} \\\n+%{!mv9:-Acpu(sparc) -Amachine(sparc)} \\\n+%{mv9:-D__sparc_v9__ -Acpu(sparc64) -Amachine(sparc64)} \\\n+%{mint64:-D__INT_MAX__=9223372036854775807LL -D__LONG_MAX__=9223372036854775807LL} \\\n+%{mlong64:-D__LONG_MAX__=9223372036854775807LL} \\\n+\"\n \n /* Prevent error on `-sun4' and `-target sun4' options.  */\n /* This used to translate -dalign to -malign, but that is no good\n    because it can't turn off the usual meaning of making debugging dumps.  */\n \n #define CC1_SPEC \"%{sun4:} %{target:}\"\n \n-#define PTRDIFF_TYPE \"int\"\n-/* In 2.4 it should work to delete this.\n-   #define SIZE_TYPE \"int\"  */\n+#define NO_BUILTIN_PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \\\n+  (POINTER_SIZE == 64 ? \"long long int\"\t\t\t\t\\\n+   : POINTER_SIZE == 32 && LONG_TYPE_SIZE == 32 ? \"long int\"\t\\\n+   : 0 /*abort*/)\n+\n+#define NO_BUILTIN_SIZE_TYPE\n+#define SIZE_TYPE \\\n+  (POINTER_SIZE == 64 ? \"long long unsigned int\"\t\t\\\n+   : POINTER_SIZE == 32 && LONG_TYPE_SIZE == 32 ? \"long unsigned int\" \\\n+   : 0 /*abort*/)\n+\n+/* ??? This should be 32 bits for v9 but what can we do?  */\n #define WCHAR_TYPE \"short unsigned int\"\n #define WCHAR_TYPE_SIZE 16\n+#define MAX_WCHAR_TYPE_SIZE 16\n \n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n@@ -55,21 +112,24 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    code into the rtl.  Also, if we are profiling, we cannot eliminate\n    the frame pointer (because the return address will get smashed).  */\n \n+void sparc_override_options ();\n+\n #define OVERRIDE_OPTIONS \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (profile_flag || profile_block_flag)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (flag_pic)\t\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-\t  char *pic_string = (flag_pic == 1) ? \"-fpic\" : \"-fPIC\";\t\\\n-\t  warning (\"%s and profiling conflict: disabling %s\", pic_string,\\\n-\t\t   pic_string);\t\t\t\t\t\t\\\n-\t  flag_pic = 0;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      flag_omit_frame_pointer = 0;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\t\\\n-}\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (profile_flag || profile_block_flag)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (flag_pic)\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    char *pic_string = (flag_pic == 1) ? \"-fpic\" : \"-fPIC\";\t\\\n+\t    warning (\"%s and profiling conflict: disabling %s\",\t\t\\\n+\t\t     pic_string, pic_string);\t\t\t\t\\\n+\t    flag_pic = 0;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tflag_omit_frame_pointer = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\t\\\n+    sparc_override_options ();\t\t\t\t\t\t\\\n+  } while (0)\n \n /* This is meant to be redefined in the host dependent files */\n #define SUBTARGET_OVERRIDE_OPTIONS\n@@ -80,54 +140,53 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n  (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\t\t\t\t\\\n   || !strcmp (STR, \"target\") || !strcmp (STR, \"assert\"))\n \n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-/* ??? The GCC_NEW_VARARGS macro is now obsolete, because gcc always uses\n-   the right varags.h file when bootstrapping.  */\n-\n-#define CPP_PREDEFINES \\\n-  \"-Dsparc -Dsun -Dunix -D__GCC_NEW_VARARGS__ \\\n-   -Asystem(unix) -Asystem(bsd) -Acpu(sparc) -Amachine(sparc)\"\n-\n /* Print subsidiary information on the compiler version in use.  */\n \n #define TARGET_VERSION fprintf (stderr, \" (sparc)\");\n \n /* Generate DBX debugging information.  */\n \n #define DBX_DEBUGGING_INFO\n-\n+\f\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n extern int target_flags;\n \n /* Nonzero if we should generate code to use the fpu.  */\n-#define TARGET_FPU (target_flags & 1)\n+#define MASK_FPU 1\n+#define TARGET_FPU (target_flags & MASK_FPU)\n \n /* Nonzero if we should use FUNCTION_EPILOGUE.  Otherwise, we\n    use fast return insns, but lose some generality.  */\n-#define TARGET_EPILOGUE (target_flags & 2)\n+#define MASK_EPILOGUE 2\n+#define TARGET_EPILOGUE (target_flags & MASK_EPILOGUE)\n \n /* Nonzero if we should assume that double pointers might be unaligned.\n    This can happen when linking gcc compiled code with other compilers,\n    because the ABI only guarantees 4 byte alignment.  */\n-#define TARGET_UNALIGNED_DOUBLES (target_flags & 4)\n+#define MASK_UNALIGNED_DOUBLES 4\n+#define TARGET_UNALIGNED_DOUBLES (target_flags & MASK_UNALIGNED_DOUBLES)\n+\n+/* ??? Bits 0x38 are currently unused.  */\n \n /* Nonzero means that we should generate code for a v8 sparc.  */\n-#define TARGET_V8 (target_flags & 64)\n+#define MASK_V8 0x40\n+#define TARGET_V8 (target_flags & MASK_V8)\n \n /* Nonzero means that we should generate code for a sparclite.\n    This enables the sparclite specific instructions, but does not affect\n    whether FPU instructions are emitted.  */\n-#define TARGET_SPARCLITE (target_flags & 128)\n+#define MASK_SPARCLITE 0x80\n+#define TARGET_SPARCLITE (target_flags & MASK_SPARCLITE)\n \n /* Nonzero means that we should generate code using a flat register window\n    model, i.e. no save/restore instructions are generated, in the most\n    efficient manner.  This code is not compatible with normal sparc code.  */\n /* This is not a user selectable option yet, because it requires changes\n    that are not yet switchable via command line arguments.  */\n /* ??? This flag is deprecated and may disappear at some point.  */\n-#define TARGET_FRW (target_flags & 256)\n+#define MASK_FRW 0x100\n+#define TARGET_FRW (target_flags & MASK_FRW)\n \n /* Nonzero means that we should generate code using a flat register window\n    model, i.e. no save/restore instructions are generated, but which is\n@@ -136,16 +195,70 @@ extern int target_flags;\n /* ??? This use to be named TARGET_FRW_COMPAT.  At some point TARGET_FRW will\n    go away, but until that time only use this one when necessary.\n    -mflat sets both.  */\n-#define TARGET_FLAT (target_flags & 512)\n+#define MASK_FLAT 0x200\n+#define TARGET_FLAT (target_flags & MASK_FLAT)\n \n /* Nonzero means use the registers that the Sparc ABI reserves for\n-   application software.  This is the default.  */\n-#define TARGET_APP_REGS (target_flags & 1024)\n+   application software.  This is the default for v8, but not v9.  */\n+#define MASK_APP_REGS 0x400\n+#define TARGET_APP_REGS (target_flags & MASK_APP_REGS)\n \n /*  Option to select how quad word floating point is implemented.\n     When TARGET_HARD_QUAD is true, we use the hardware quad instructions.\n     Otherwise, we use the SPARC ABI quad library functions.  */\n-#define TARGET_HARD_QUAD (target_flags & 2048)\n+#define MASK_HARD_QUAD 0x800\n+#define TARGET_HARD_QUAD (target_flags & MASK_HARD_QUAD)\n+\n+/* Nonzero if we're compiling for 64 bit sparc.  */\n+#define MASK_V9 0x1000\n+#define TARGET_V9 (target_flags & MASK_V9)\n+\n+/* Nonzero if ints are 64 bits.\n+   This automatically implies longs are 64 bits too.\n+   This option is for v9 only.  */\n+#define MASK_INT64 0x2000\n+#define TARGET_INT64 (target_flags & MASK_INT64)\n+\n+/* Nonzero if longs are 64 bits.\n+   This option is for v9 only.  */\n+#define MASK_LONG64 0x4000\n+#define TARGET_LONG64 (target_flags & MASK_LONG64)\n+\n+/* Nonzero if pointers are 64 bits.\n+   This option is for v9 only.  */\n+#define MASK_PTR64 0x8000\n+#define TARGET_PTR64 (target_flags & MASK_PTR64)\n+\n+/* Nonzero if we are generating code to be tested in a 32 bit environment.\n+   Hence, we assume the upper 32 bits of symbolic addresses are zero, and\n+   avoid generating %uhi and %ulo terms.\n+   Pointers are still 64 bits though!  This option is for v9 only.  */\n+#define MASK_ENV32 0x10000\n+#define TARGET_ENV32 (target_flags & MASK_ENV32)\n+\n+/* Memory models.\n+   Two memory models are supported:\n+   TARGET_MEDLOW: 32 bit address space, top 32 bits = 0\n+   TARGET_MEDANY: 32 bit address space, data segment loaded anywhere\n+                  (use %g4 as offset).\n+   TARGET_FULLANY: not supported yet.\n+   These options are for v9 only.  All mask values are nonzero so the v8\n+   compiler can assume this stuff won't interfere.  */\n+#define MASK_MEDLOW 0x20000\n+#define MASK_MEDANY 0x40000\n+#define MASK_FULLANY 0x60000\n+#define MASK_CODE_MODEL (MASK_MEDLOW + MASK_MEDANY)\n+#define TARGET_MEDLOW ((target_flags & MASK_CODE_MODEL) == MASK_MEDLOW)\n+#define TARGET_MEDANY ((target_flags & MASK_CODE_MODEL) == MASK_MEDANY)\n+#define TARGET_FULLANY ((target_flags & MASK_CODE_MODEL) == MASK_FULLANY)\n+\n+/* ??? There are hardcoded references to this reg in the .md file.  */\n+#define MEDANY_BASE_REG \"%g4\"\n+\n+/* Non-zero means use a stack bias of 2047.  Stack offsets are obtained by\n+   adding 2047 to %sp.  This option is for v9 only and is the default.  */\n+#define MASK_STACK_BIAS 0x80000\n+#define TARGET_STACK_BIAS (target_flags & MASK_STACK_BIAS)\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n@@ -154,50 +267,99 @@ extern int target_flags;\n    An empty string NAME is used to identify the default VALUE.  */\n \n /* The Fujitsu MB86930 is the original sparclite chip, with no fpu.\n-   The Fujitsu MB86934 is the recent sparclite chip, with an fup.\n+   The Fujitsu MB86934 is the recent sparclite chip, with an fpu.\n    We use -mf930 and -mf934 options to choose which.\n    ??? These should perhaps be -mcpu= options.  */\n \n #define TARGET_SWITCHES  \\\n-  { {\"fpu\", 1},\t\t\t\\\n-    {\"no-fpu\", -1},\t\t\\\n-    {\"hard-float\", 1},\t\t\\\n-    {\"soft-float\", -1},\t\t\\\n-    {\"epilogue\", 2},\t\t\\\n-    {\"no-epilogue\", -2},\t\\\n-    {\"unaligned-doubles\", 4},\t\\\n-    {\"no-unaligned-doubles\", -4},\\\n-    {\"v8\", 64},\t\t\t\\\n-    {\"no-v8\", -64},\t\t\\\n-    {\"sparclite\", 128},\t\t\\\n-    {\"no-sparclite\", -128},\t\\\n-    {\"f930\", 128},\t\t\\\n-    {\"f930\", -1},\t\t\\\n-    {\"f934\", 128},\t\t\\\n-    {\"flat\", 256+512},\t\t\\\n-    {\"no-flat\", -(256+512)},\t\\\n-    {\"app-regs\", 1024},\t\t\\\n-    {\"no-app-regs\", -1024},\t\\\n-    {\"hard-quad-float\", 2048},        \\\n-    {\"soft-quad-float\", -2048},       \\\n-    SUBTARGET_SWITCHES\t\t\\\n+  { {\"fpu\", MASK_FPU},\t\t\t\\\n+    {\"no-fpu\", -MASK_FPU},\t\t\\\n+    {\"hard-float\", MASK_FPU},\t\t\\\n+    {\"soft-float\", -MASK_FPU},\t\t\\\n+    {\"epilogue\", MASK_EPILOGUE},\t\\\n+    {\"no-epilogue\", -MASK_EPILOGUE},\t\\\n+    {\"unaligned-doubles\", MASK_UNALIGNED_DOUBLES}, \\\n+    {\"no-unaligned-doubles\", -MASK_UNALIGNED_DOUBLES}, \\\n+    {\"v8\", MASK_V8},\t\t\t\\\n+    {\"no-v8\", -MASK_V8},\t\t\\\n+    {\"sparclite\", MASK_SPARCLITE},\t\\\n+    {\"no-sparclite\", -MASK_SPARCLITE},\t\\\n+    {\"f930\", MASK_SPARCLITE},\t\t\\\n+    {\"f930\", -MASK_FPU},\t\t\\\n+    {\"f934\", MASK_SPARCLITE},\t\t\\\n+    {\"flat\", MASK_FRW+MASK_FLAT},\t\\\n+    {\"no-flat\", -(MASK_FRW+MASK_FLAT)},\t\\\n+    {\"app-regs\", MASK_APP_REGS},\t\\\n+    {\"no-app-regs\", -MASK_APP_REGS},\t\\\n+    {\"hard-quad-float\", MASK_HARD_QUAD}, \\\n+    {\"soft-quad-float\", -MASK_HARD_QUAD}, \\\n+    SUBTARGET_SWITCHES\t\t\t\\\n+    V9_SWITCHES\t\t\t\t\\\n     { \"\", TARGET_DEFAULT}}\n \n-#define TARGET_DEFAULT (1024+3)\n+#define TARGET_DEFAULT (MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n \n /* This is meant to be redefined in the host dependent files */\n #define SUBTARGET_SWITCHES\n-\f\n-/* target machine storage layout */\n \n-#if 0\n-/* ??? This does not work in SunOS 4.x, so it is not enabled here.\n-   Instead, it is enabled in sol2.h, because it does work under Solaris.  */\n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n-   Sparc ABI says that long double is 4 words.  */\n-#define LONG_DOUBLE_TYPE_SIZE 128\n+/* ??? Until we support a combination v8/v9 compiler, the v9 specific options\n+   are only defined for the v9 compiler.  */\n+/* ??? code models should be selected with -mcode-model=xxx.  */\n+#ifdef SPARCV9\n+#define V9_SWITCHES \\\n+    {\"v9\", MASK_V9},\t\t\t\\\n+    {\"no-v9\", -MASK_V9},\t\t\\\n+    {\"int64\", MASK_INT64+MASK_LONG64},\t\\\n+    {\"int32\", -MASK_INT64},\t\t\\\n+    {\"long64\", MASK_LONG64},\t\t\\\n+    {\"long32\", -MASK_LONG64},\t\t\\\n+    {\"ptr64\", MASK_PTR64},\t\t\\\n+    {\"ptr32\", -MASK_PTR64},\t\t\\\n+    {\"env32\", MASK_ENV32},\t\t\\\n+    {\"no-env32\", -MASK_ENV32},\t\t\\\n+    {\"stack-bias\", MASK_STACK_BIAS},\t\\\n+    {\"no-stack-bias\", -MASK_STACK_BIAS},\n+#else\n+#define V9_SWITCHES\n #endif\n \n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable. \n+   The variable, type `char *', is set to the variable part of the\n+   given option if the fixed part matches.  The actual option name\n+   is made by prepending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+\textern char *m88k_short_data;\n+\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+\n+/* For v9, two values of \"code model\" are currently supported.\n+\n+   medium-low\n+\t32 bit address space starting at 0\n+\n+   medium-anywhere\n+\t32 bit text segment starting at 0\n+\t32 bit data segment(s) starting anywhere (determined at link time)\n+\tMEDANY_BASE_REG points to the start\n+*/\n+\n+extern char *sparc_code_model;\n+\n+#define TARGET_OPTIONS \\\n+{\t\t\t\t\t\t\t\\\n+  { \"code-model=\",\t&sparc_code_model\t}\t\\\n+}\n+\f\n+/* target machine storage layout */\n+\n /* Define for cross-compilation to a sparc target with no TFmode from a host\n    with a different float format (e.g. VAX).  */\n #define REAL_ARITHMETIC\n@@ -223,31 +385,54 @@ extern int target_flags;\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n-#define MAX_BITS_PER_WORD 32\n+#define BITS_PER_WORD\t\t(TARGET_V9 ? 64 : 32)\n+#define MAX_BITS_PER_WORD\t64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n+#define UNITS_PER_WORD\t\t(TARGET_V9 ? 8 : 4)\n+#define MAX_UNITS_PER_WORD\t8\n+\n+/* Now define the sizes of the C data types.  */\n+\n+#define SHORT_TYPE_SIZE\t\t16\n+#define INT_TYPE_SIZE\t\t(TARGET_INT64 ? 64 : 32)\n+#define LONG_TYPE_SIZE\t\t(TARGET_LONG64 ? 64 : 32)\n+#define LONG_LONG_TYPE_SIZE\t64\n+#define FLOAT_TYPE_SIZE\t\t32\n+#define DOUBLE_TYPE_SIZE\t64\n+\n+#define MAX_INT_TYPE_SIZE\t64\n+#define MAX_LONG_TYPE_SIZE\t64\n+\n+#ifdef SPARCV9\n+/* ??? This does not work in SunOS 4.x, so it is not enabled here.\n+   Instead, it is enabled in sol2.h, because it does work under Solaris.  */\n+/* Define for support of TFmode long double and REAL_ARITHMETIC.\n+   Sparc ABI says that long double is 4 words.  */\n+#define LONG_DOUBLE_TYPE_SIZE 128\n+#endif\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n+#define POINTER_SIZE (TARGET_PTR64 ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n+#define PARM_BOUNDARY (TARGET_V9 ? 64 : 32)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 64\n+#define STACK_BOUNDARY (TARGET_V9 ? 128 : 64)\n \n /* ALIGN FRAMES on double word boundaries */\n \n-#define SPARC_STACK_ALIGN(LOC) (((LOC)+7) & (~7))\n+#define SPARC_STACK_ALIGN(LOC) \\\n+  (TARGET_V9 ? (((LOC)+15) & ~15) : (((LOC)+7) & ~7))\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n \n /* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n+/* ??? Should this be based on TARGET_INT64?  */\n+#define EMPTY_FIELD_BOUNDARY (TARGET_V9 ? 64 : 32)\n \n /* Every structure's size must be a multiple of this.  */\n #define STRUCTURE_SIZE_BOUNDARY 8\n@@ -256,7 +441,7 @@ extern int target_flags;\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n /* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 64\n+#define BIGGEST_ALIGNMENT (TARGET_V9 ? 128 : 64)\n \n /* The best alignment to use in cases where we have a choice.  */\n #define FASTEST_ALIGNMENT 64\n@@ -279,9 +464,10 @@ extern int target_flags;\n \n /* Things that must be doubleword aligned cannot go in the text section,\n    because the linker fails to align the text section enough!\n-   Put them in the data section.  */\n+   Put them in the data section.  This macro is only used in this file.  */\n #define MAX_TEXT_ALIGN 32\n \n+/* This is defined differently for v9 in a cover file.  */\n #define SELECT_SECTION(T,RELOC)\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (TREE_CODE (T) == VAR_DECL)\t\t\t\t\t\\\n@@ -313,6 +499,7 @@ extern int target_flags;\n \n /* Use text section for a constant\n    unless we need more alignment than that offers.  */\n+/* This is defined differently for v9 in a cover file.  */\n #define SELECT_RTX_SECTION(MODE, X)\t\t\\\n {\t\t\t\t\t\t\\\n   if (GET_MODE_BITSIZE (MODE) <= MAX_TEXT_ALIGN \\\n@@ -330,18 +517,57 @@ extern int target_flags;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.\n \n-   SPARC has 32 integer registers and 32 floating point registers.  */\n+   SPARC has 32 integer registers and 32 floating point registers.\n+   64 bit SPARC has 32 additional fp regs, but the odd numbered ones are not\n+   accessible.  We still account for them to simplify register computations\n+   (eg: in CLASS_MAX_NREGS).  There are also 4 fp condition code registers, so\n+   32+32+32+4 == 100.\n+   Register 0 is used as the integer condition code register.  */\n \n+#ifdef SPARCV9\n+#define FIRST_PSEUDO_REGISTER 100\n+#else\n #define FIRST_PSEUDO_REGISTER 64\n+#endif\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    g0 is used for the condition code and not to represent %g0, which is\n    hardwired to 0, so reg 0 is *not* fixed.\n+   On non-v9 systems:\n    g1 is free to use as temporary.\n    g2-g4 are reserved for applications.  Gcc normally uses them as\n    temporaries, but this can be disabled via the -mno-app-regs option.\n-   g5 through g7 are reserved for the operating system.  */\n+   g5 through g7 are reserved for the operating system.\n+   On v9 systems:\n+   g1 and g5 are free to use as temporaries.\n+   g2-g4 are reserved for applications (the compiler will not normally use\n+   them, but they can be used as temporaries with -mapp-regs).\n+   g6-g7 are reserved for the operating system.\n+   ??? Register 1 is used as a temporary by the 64 bit sethi pattern, so must\n+   currently be a fixed register until this pattern is rewritten.\n+   Register 1 is also used when restoring call-preserved registers in large\n+   stack frames.  */\n+\n+#ifdef SPARCV9\n+#define FIXED_REGISTERS  \\\n+ {0, 1, 1, 1, 1, 0, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+\t\t\t\t\\\n+  0, 0, 0, 0}\n+#else\n #define FIXED_REGISTERS  \\\n  {0, 0, 0, 0, 0, 1, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n@@ -352,13 +578,34 @@ extern int target_flags;\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0}\n+#endif\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n+\n+#ifdef SPARCV9\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1}\n+#else\n #define CALL_USED_REGISTERS  \\\n  {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -369,17 +616,18 @@ extern int target_flags;\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1}\n+#endif\n \n /* If !TARGET_FPU, then make the fp registers fixed so that they won't\n-   be allocated.  */\n+   be allocated.  On v9, also make the fp cc regs fixed.  */\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     if (! TARGET_FPU)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tint regno;\t\t\t\t\t\t\\\n-\tfor (regno = 32; regno < 64; regno++)\t\t\t\\\n+\tfor (regno = 32; regno < FIRST_PSEUDO_REGISTER; regno++) \\\n \t  fixed_regs[regno] = 1;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     if (! TARGET_APP_REGS)\t\t\t\t\t\\\n@@ -388,6 +636,12 @@ do\t\t\t\t\t\t\t\t\\\n \tfixed_regs[3] = 1;\t\t\t\t\t\\\n \tfixed_regs[4] = 1;\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfixed_regs[2] = 0;\t\t\t\t\t\\\n+\tfixed_regs[3] = 0;\t\t\t\t\t\\\n+\tfixed_regs[4] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n     if (TARGET_FLAT)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \t/* Let the compiler believe the frame pointer is still\t\\\n@@ -414,29 +668,38 @@ while (0)\n \n    On SPARC, ordinary registers hold 32 bits worth;\n    this means both integer and floating point registers.\n+   On v9, integer regs hold 64 bits worth; floating point regs hold\n+   32 bits worth (this includes the new fp regs as even the odd ones are\n+   included in the hard register count).  */\n \n-   We use vectors to keep this information about registers.  */\n-\n-/* How many hard registers it takes to make a register of this mode.  */\n-extern int hard_regno_nregs[];\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if register/mode pair is acceptable on sparc.  */\n-extern int hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+  (TARGET_V9\t\t\t\t\t\t\t\t\\\n+   ?  ((REGNO) < 32\t\t\t\t\t\t\t\\\n+       ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\t\\\n+       : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    See sparc.c for how we initialize this.  */\n+extern int *hard_regno_mode_classes;\n+extern int sparc_mode_class[];\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((hard_regno_mode_ok[REGNO] & (1<<(int)(MODE))) != 0)\n+  ((hard_regno_mode_classes[REGNO] & sparc_mode_class[MODE]) != 0)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   for any hard reg, then this must be 0 for correct output.\n+\n+   For V9: SFmode can't be combined with other float modes, because they can't\n+   be allocated to the %d registers.  Also, DFmode won't fit in odd %f\n+   registers, but SFmode will.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+  ((MODE1) == (MODE2)\t\t\t\t\t\t\\\n+   || (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2)\t\t\\\n+       && (! TARGET_V9\t\t\t\t\t\t\\\n+\t   || (GET_MODE_CLASS (MODE1) != MODE_FLOAT\t\t\\\n+\t       || (MODE1 != SFmode && MODE2 != SFmode)))))\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -447,12 +710,16 @@ extern int hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM 14\n \n-/* Actual top-of-stack address is 92 greater than the contents\n-   of the stack pointer register.  92 = 68 + 24.  64 bytes reserving space\n-   for the ins and local registers, 4 byte for structure return address, and\n-   24 bytes for the 6 register parameters.  */\n+/* Actual top-of-stack address is 92/136 greater than the contents of the\n+   stack pointer register for !v9/v9.  That is:\n+   - !v9: 64 bytes for the in and local registers, 4 bytes for structure return\n+     address, and 24 bytes for the 6 register parameters.\n+   - v9: 128 bytes for the in and local registers + 8 bytes reserved.  */\n #define STACK_POINTER_OFFSET FIRST_PARM_OFFSET(0)\n \n+/* The stack bias (amount by which the hardware register is offset by).  */\n+#define SPARC_STACK_BIAS (TARGET_STACK_BIAS ? 2047 : 0)\n+\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM 30\n \n@@ -487,7 +754,8 @@ extern int leaf_function;\n #define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n \n /* Register in which static-chain is passed to a function.  This must\n-   not be a register used by the prologue.  */\n+   not be a register used by the prologue.\n+   ??? v9: Since %g2 is reserved but %g5 is available, perhaps use %g5.  */\n #define STATIC_CHAIN_REGNUM 2\n \n /* Register which holds offset table for position-independent\n@@ -499,24 +767,31 @@ extern int leaf_function;\n #define FINALIZE_PIC finalize_pic ()\n \n /* Sparc ABI says that quad-precision floats and all structures are returned\n-   in memory.  */\n-#define RETURN_IN_MEMORY(TYPE)\t\\\n-  (TYPE_MODE (TYPE) == BLKmode || TYPE_MODE (TYPE) == TFmode)\n+   in memory.\n+   For v9, all aggregates are returned in memory.  */\n+#define RETURN_IN_MEMORY(TYPE) \\\n+  (TYPE_MODE (TYPE) == BLKmode || (! TARGET_V9 && TYPE_MODE (TYPE) == TFmode))\n \n /* Functions which return large structures get the address\n    to place the wanted value at offset 64 from the frame.\n-   Must reserve 64 bytes for the in and local registers.  */\n+   Must reserve 64 bytes for the in and local registers.\n+   v9: Functions which return large structures get the address to place the\n+   wanted value from an invisible first argument.  */\n /* Used only in other #defines in this file.  */\n #define STRUCT_VALUE_OFFSET 64\n \n #define STRUCT_VALUE \\\n-  gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n-\t   gen_rtx (PLUS, Pmode, stack_pointer_rtx,\t\\\n-\t\t    gen_rtx (CONST_INT, VOIDmode, STRUCT_VALUE_OFFSET)))\n+  (TARGET_V9\t\t\t\t\t\t\\\n+   ? 0\t\t\t\t\t\t\t\\\n+   : gen_rtx (MEM, Pmode,\t\t\t\t\\\n+\t      gen_rtx (PLUS, Pmode, stack_pointer_rtx,\t\\\n+\t\t       gen_rtx (CONST_INT, VOIDmode, STRUCT_VALUE_OFFSET))))\n #define STRUCT_VALUE_INCOMING \\\n-  gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n-\t   gen_rtx (PLUS, Pmode, frame_pointer_rtx,\t\\\n-\t\t    gen_rtx (CONST_INT, VOIDmode, STRUCT_VALUE_OFFSET)))\n+  (TARGET_V9\t\t\t\t\t\t\\\n+   ? 0\t\t\t\t\t\t\t\\\n+   : gen_rtx (MEM, Pmode,\t\t\t\t\\\n+\t      gen_rtx (PLUS, Pmode, frame_pointer_rtx,\t\\\n+\t\t       gen_rtx (CONST_INT, VOIDmode, STRUCT_VALUE_OFFSET))))\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -538,42 +813,92 @@ extern int leaf_function;\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-/* The SPARC has two kinds of registers, general and floating point.  */\n-\n+/* The SPARC has two kinds of registers, general and floating point.\n+   v9 also has 4 floating point condition code registers.  Since we don't\n+   have a class that is the union of FPCC_REGS with either of the others,\n+   it is important that it appear first.  Otherwise the compiler will die\n+   trying to compile _fixunsdfsi because fix_truncdfsi2 won't match its\n+   constraints.  */\n+   /* ??? As an experiment for v9, we treat all fp regs similarily here.  */\n+\n+#ifdef SPARCV9\n+enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n+\t\t ALL_REGS, LIM_REG_CLASSES };\n+#else\n enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n+#endif\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n+#ifdef SPARCV9\n #define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+  {\"NO_REGS\", \"FPCC_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"GENERAL_OR_FP_REGS\", \\\n+   \"ALL_REGS\" }\n+#else\n+#define REG_CLASS_NAMES \\\n+  {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+#endif\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n+#ifdef SPARCV9\n+#define REG_CLASS_CONTENTS \\\n+  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {-2, 0, 0, 0}, {0, -1, -1, 0}, \\\n+   {-2, -1, -1, 0}, {-2, -1, -1, 0xf}}\n+#else\n #if 0 && defined (__GNUC__)\n #define REG_CLASS_CONTENTS {0LL, 0xfffffffeLL, 0xffffffff00000000LL, 0xfffffffffffffffeLL}\n #else\n #define REG_CLASS_CONTENTS {{0, 0}, {-2, 0}, {0, -1}, {-2, -1}}\n #endif\n+#endif\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n+#ifdef SPARCV9\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\t\\\n+  ((REGNO) == 0 ? NO_REGS\t\t\t\t\\\n+   : ((REGNO) < 32 ? GENERAL_REGS\t\t\t\\\n+      : ((REGNO) < 96 ? FP_REGS\t\t\t\t\\\n+\t : FPCC_REGS)))\n+#else\n #define REGNO_REG_CLASS(REGNO) \\\n   ((REGNO) >= 32 ? FP_REGS : (REGNO) == 0 ? NO_REGS : GENERAL_REGS)\n+#endif\n \n-/* This is the order in which to allocate registers\n-   normally.  \n+/* This is the order in which to allocate registers normally.  \n    \n    We put %f0/%f1 last among the float registers, so as to make it more\n    likely that a pseudo-register which dies in the float return register\n    will get allocated to the float return register, thus saving a move\n-   instruction at the end of the function.  */\n+   instruction at the end of the function.\n+\n+   On v9, the float registers are ordered a little \"funny\" because some\n+   of them (%f16-%f47) are call-preserved.  */\n+#ifdef SPARCV9\n+#define REG_ALLOC_ORDER \\\n+{ 8, 9, 10, 11, 12, 13,\t\t\t\\\n+  15, 16, 17, 18, 19, 20, 21, 22,\t\\\n+  23, 24, 25, 26, 27, 28, 29, 31,\t\\\n+  34, 35, 36, 37, 38, 39,\t\t/* %f2-%f7 */   \\\n+  40, 41, 42, 43, 44, 45, 46, 47,\t/* %f8-%f15 */  \\\n+  80, 81, 82, 83, 84, 85, 86, 87,\t/* %f48-%f55 */ \\\n+  88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */ \\\n+  48, 49, 50, 51, 52, 53, 54, 55,\t/* %f16-%f23 */ \\\n+  56, 57, 58, 59, 60, 61, 62, 63,\t/* %f24-%f31 */ \\\n+  64, 65, 66, 67, 68, 69, 70, 71,\t/* %f32-%f39 */ \\\n+  72, 73, 74, 75, 76, 77, 78, 79,\t/* %f40-%f47 */ \\\n+  32, 33,\t\t\t\t/* %f0,%f1 */   \\\n+  96, 97, 98, 99,\t\t\t/* %fcc0-3 */   \\\n+  1, 5, 2, 3, 4, 6, 7, 0, 14, 30}\n+#else\n #define REG_ALLOC_ORDER \\\n { 8, 9, 10, 11, 12, 13, 2, 3, \t\t\\\n   15, 16, 17, 18, 19, 20, 21, 22, \t\\\n@@ -584,10 +909,30 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   56, 57, 58, 59, 60, 61, 62, 63,\t\\\n   32, 33,\t\t\t\t\\\n   1, 4, 5, 6, 7, 0, 14, 30}\n+#endif\n \n /* This is the order in which to allocate registers for\n    leaf functions.  If all registers can fit in the \"i\" registers,\n-   then we have the possibility of having a leaf function.  */\n+   then we have the possibility of having a leaf function.\n+   v9: The floating point registers are ordered a little \"funny\" because some\n+   of them (%f16-%f47) are call-preserved.   */\n+#ifdef SPARCV9\n+#define REG_LEAF_ALLOC_ORDER \\\n+{ 24, 25, 26, 27, 28, 29,\t\t\\\n+  15, 8, 9, 10, 11, 12, 13,\t\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23,\t\\\n+  34, 35, 36, 37, 38, 39,\t\t\\\n+  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  80, 81, 82, 83, 84, 85, 86, 87,\t\\\n+  88, 89, 90, 91, 92, 93, 94, 95,\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n+  56, 57, 58, 59, 60, 61, 62, 63,\t\\\n+  64, 65, 66, 67, 68, 69, 70, 71,\t\\\n+  72, 73, 74, 75, 76, 77, 78, 79,\t\\\n+  32, 33,\t\t\t\t\\\n+  96, 97, 98, 99,\t\t\t\\\n+  1, 5, 2, 3, 4, 6, 7, 0, 14, 30, 31}\n+#else\n #define REG_LEAF_ALLOC_ORDER \\\n { 2, 3, 24, 25, 26, 27, 28, 29,\t\t\\\n   15, 8, 9, 10, 11, 12, 13,\t\t\\\n@@ -598,6 +943,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   56, 57, 58, 59, 60, 61, 62, 63,\t\\\n   32, 33,\t\t\t\t\\\n   1, 4, 5, 6, 7, 0, 14, 30, 31}\n+#endif\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n@@ -606,6 +952,22 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    register is used and is not permitted in a leaf function.  We make %g7\n    a global reg if -mflat and voila.  Since %g7 is a system register and is\n    fixed it won't be used by gcc anyway.  */\n+#ifdef SPARCV9\n+#define LEAF_REGISTERS \\\n+{ 1, 1, 1, 1, 1, 1, 1, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 0, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1}\n+#else\n #define LEAF_REGISTERS \\\n { 1, 1, 1, 1, 1, 1, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n@@ -615,6 +977,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1}\n+#endif\n \n extern char leaf_reg_remap[];\n #define LEAF_REG_REMAP(REGNO) (leaf_reg_remap[REGNO])\n@@ -625,8 +988,13 @@ extern char leaf_reg_remap[];\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n \n+#ifdef SPARCV9\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FP_REGS : (C) == 'c' ? FPCC_REGS : NO_REGS)\n+#else\n #define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS : (C) == 'r' ? GENERAL_REGS : NO_REGS)\n+  ((C) == 'f' ? FP_REGS : NO_REGS)\n+#endif\n \n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -693,26 +1061,42 @@ extern char leaf_reg_remap[];\n \n /* On SPARC it is not possible to directly move data between \n    GENERAL_REGS and FP_REGS.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)  \\\n-  (((CLASS1) == FP_REGS && (CLASS2) == GENERAL_REGS)\t\\\n-   || ((CLASS1) == GENERAL_REGS && (CLASS2) == FP_REGS))\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) ((CLASS1) != (CLASS2))\n \n /* Return the stack location to use for secondary memory needed reloads.  */\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n   gen_rtx (MEM, MODE, gen_rtx (PLUS, Pmode, frame_pointer_rtx,\t\\\n \t   GEN_INT (STARTING_FRAME_OFFSET)))\n \n+/* Get_secondary_mem widens it's argument to BITS_PER_WORD which loses on v9\n+   because the movsi and movsf patterns don't handle r/f moves.\n+   For v8 we copy the default definition.  */\n+#define SECONDARY_MEMORY_NEEDED_MODE(MODE) \\\n+  (TARGET_V9\t\t\t\t\t\t\t\\\n+   ? (GET_MODE_BITSIZE (mode) < 32\t\t\t\t\\\n+      ? mode_for_size (32, GET_MODE_CLASS (mode), 0)\t\t\\\n+      : MODE)\t\t\t\t\t\t\t\\\n+   : (GET_MODE_BITSIZE (mode) < BITS_PER_WORD\t\t\t\\\n+      ? mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0)\t\\\n+      : MODE))\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On SPARC, this is the size of MODE in words.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+  ((CLASS) == FP_REGS ? (GET_MODE_SIZE (MODE) + 3) / 4 \\\n+   : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define the number of register that can hold parameters.\n-   These two macros are used only in other macro definitions below.  */\n-#define NPARM_REGS 6\n+   These two macros are used only in other macro definitions below.\n+   MODE is the mode of the argument.\n+   !v9: All args are passed in %o0-%o5.\n+   v9: Non-float args are passed in %o0-5 and float args are passed in\n+   %f0-%f15.  */\n+#define NPARM_REGS(MODE) \\\n+  (TARGET_V9 ? (GET_MODE_CLASS (MODE) == MODE_FLOAT ? 16 : 6) : 6)\n \n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n@@ -730,21 +1114,27 @@ extern char leaf_reg_remap[];\n    of the first local allocated.  */\n /* This allows space for one TFmode floating point value.  */\n #define STARTING_FRAME_OFFSET \\\n-  (-SPARC_STACK_ALIGN (LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT))\n+  (TARGET_V9 ? (SPARC_STACK_BIAS - 16) \\\n+   : (-SPARC_STACK_ALIGN (LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)))\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n    On SPARC, don't define this because there are no push insns.  */\n /*  #define PUSH_ROUNDING(BYTES) */\n \n /* Offset of first parameter from the argument pointer register value.\n-   This is 64 for the ins and locals, plus 4 for the struct-return reg\n-   even if this function isn't going to use it.  */\n-#define FIRST_PARM_OFFSET(FNDECL) (STRUCT_VALUE_OFFSET + UNITS_PER_WORD)\n+   !v9: This is 64 for the ins and locals, plus 4 for the struct-return reg\n+   even if this function isn't going to use it.\n+   v9: This is 128 for the ins and locals, plus a reserved space of 8.  */\n+#define FIRST_PARM_OFFSET(FNDECL) \\\n+  (TARGET_V9 ? (SPARC_STACK_BIAS + 136) \\\n+   : (STRUCT_VALUE_OFFSET + UNITS_PER_WORD))\n \n /* When a parameter is passed in a register, stack space is still\n    allocated for it.  */\n-#define REG_PARM_STACK_SPACE(DECL) (NPARM_REGS * UNITS_PER_WORD)\n+#ifndef SPARCV9\n+#define REG_PARM_STACK_SPACE(DECL) (NPARM_REGS (SImode) * UNITS_PER_WORD)\n+#endif\n \n /* Keep the stack pointer constant throughout the function.\n    This is both an optimization and a necessity: longjmp\n@@ -764,12 +1154,20 @@ extern char leaf_reg_remap[];\n    When !TARGET_FPU, put float return values in the general registers,\n    since we don't have any fp registers.  */\n #define BASE_RETURN_VALUE_REG(MODE) \\\n- (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32 : 8)\n+  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n+   : (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32 : 8))\n #define BASE_OUTGOING_VALUE_REG(MODE) \\\n- (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32\t\\\n-  : (TARGET_FRW ? 8 : 24))\n-#define BASE_PASSING_ARG_REG(MODE) (8)\n-#define BASE_INCOMING_ARG_REG(MODE) (TARGET_FRW ? 8 : 24)\n+  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n+\t\t: TARGET_FRW ? 8 : 24) \\\n+   : (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32\t\\\n+      : (TARGET_FRW ? 8 : 24)))\n+#define BASE_PASSING_ARG_REG(MODE) \\\n+  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n+   : (8))\n+#define BASE_INCOMING_ARG_REG(MODE) \\\n+  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n+\t\t: TARGET_FRW ? 8 : 24) \\\n+   : (TARGET_FRW ? 8 : 24))\n \n /* Define this macro if the target machine has \"register windows\".  This\n    C expression returns the register number as seen by the called function\n@@ -821,25 +1219,78 @@ extern char leaf_reg_remap[];\n #define APPLY_RESULT_SIZE 16\n \n /* 1 if N is a possible register number for function argument passing.\n-   On SPARC, these are the \"output\" registers.  */\n+   On SPARC, these are the \"output\" registers.  v9 also uses %f0-%f15.  */\n \n-#define FUNCTION_ARG_REGNO_P(N) ((N) < 14 && (N) > 7)\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  (TARGET_V9 ? (((N) < 14 && (N) > 7) || (N) > 31 && (N) < 48) \\\n+   : ((N) < 14 && (N) > 7))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   On SPARC, this is a single integer, which is a number of words\n+   On SPARC (!v9), this is a single integer, which is a number of words\n    of arguments scanned so far (including the invisible argument,\n    if any, which holds the structure-value-address).\n-   Thus 7 or more means all following args should go on the stack.  */\n+   Thus 7 or more means all following args should go on the stack.\n+\n+   For v9, we record how many of each type has been passed.  Different\n+   types get passed differently.\n+\n+\t- Float args are passed in %f0-15, after which they go to the stack\n+\t  where floats and doubles are passed 8 byte aligned and long doubles\n+\t  are passed 16 byte aligned.\n+\t- All aggregates are passed by reference.  The callee copies\n+\t  the structure if necessary, except if stdarg/varargs and the struct\n+\t  matches the ellipse in which case the caller makes a copy.\n+\t- Any non-float argument might be split between memory and reg %o5.\n+\t  ??? I don't think this can ever happen now that structs are no\n+\t  longer passed in regs.\n+\n+   For v9 return values:\n+\n+\t- For all aggregates, the caller allocates space for the return value,\n+          and passes the pointer as an implicit first argument, which is\n+          allocated like all other arguments.\n+\t- The unimp instruction stuff for structure returns is gone.  */\n+\n+#ifdef SPARCV9\n+enum sparc_arg_class { SPARC_ARG_INT = 0, SPARC_ARG_FLOAT = 1 };\n+struct sparc_args {\n+    int arg_count[2];\t/* must be int! (for __builtin_args_info) */\n+};\n+#define CUMULATIVE_ARGS struct sparc_args\n+\n+/* Return index into CUMULATIVE_ARGS.  */\n+\n+#define GET_SPARC_ARG_CLASS(MODE) \\\n+  (GET_MODE_CLASS (MODE) == MODE_FLOAT ? SPARC_ARG_FLOAT : SPARC_ARG_INT)\n \n+/* Round a register number up to a proper boundary for an arg of mode MODE.\n+   This macro is only used in this file.\n+\n+   The \"& (0x10000 - ...)\" is used to round up to the next appropriate reg.  */\n+\n+#define ROUND_REG(CUM, MODE)\t\t\t\t\\\n+  (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\\\n+   ? (CUM).arg_count[(int) GET_SPARC_ARG_CLASS (MODE)]\t\\\n+   : ((CUM).arg_count[(int) GET_SPARC_ARG_CLASS (MODE)]\t\\\n+      + GET_MODE_UNIT_SIZE (MODE) / 4 - 1)\t\t\\\n+     & (0x10000 - GET_MODE_UNIT_SIZE (MODE) / 4))\n+\n+#define ROUND_ADVANCE(SIZE)\t\\\n+  (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#else /* ! SPARCV9 */\n #define CUMULATIVE_ARGS int\n \n+#define ROUND_REG(CUM, MODE) (CUM)\n+\n #define ROUND_ADVANCE(SIZE)\t\\\n   ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#endif /* ! SPARCV9 */\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -848,16 +1299,63 @@ extern char leaf_reg_remap[];\n    On SPARC, the offset always starts at 0: the first parm reg is always\n    the same reg.  */\n \n+#ifdef SPARCV9\n+extern int sparc_arg_count,sparc_n_named_args;\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    (CUM).arg_count[(int) SPARC_ARG_INT] = 0;\t\t\t\\\n+    (CUM).arg_count[(int) SPARC_ARG_FLOAT] = 0;\t\t\t\\\n+    sparc_arg_count = 0;\t\t\t\t\t\\\n+    sparc_n_named_args =\t\t\t\t\t\\\n+      ((FNTYPE) && TYPE_ARG_TYPES (FNTYPE)\t\t\t\\\n+       ? (list_length (TYPE_ARG_TYPES (FNTYPE))\t\t\t\\\n+\t  + (TREE_CODE (TREE_TYPE (FNTYPE)) == RECORD_TYPE\t\\\n+\t     || TREE_CODE (TREE_TYPE (FNTYPE)) == UNION_TYPE))\t\\\n+       /* Can't tell, treat 'em all as named.  */\t\t\\\n+       : 10000);\t\t\t\t\t\t\\\n+  } while (0)\n+#else\n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) ((CUM) = 0)\n+#endif\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n+#ifdef SPARCV9\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    (CUM).arg_count[(int) GET_SPARC_ARG_CLASS (MODE)] =\t\t\\\n+      ROUND_REG ((CUM), (MODE))\t\t\t\t\t\\\n+\t+ (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n+\t   ? GET_MODE_SIZE (MODE) / 4\t\t\t\t\\\n+\t   : ROUND_ADVANCE ((MODE) == BLKmode\t\t\t\\\n+\t\t\t    ? GET_MODE_SIZE (Pmode)\t\t\\\n+\t\t\t    : GET_MODE_SIZE (MODE)));\t\t\\\n+    sparc_arg_count++;\t\t\t\t\t\t\\\n+  } while (0)\n+#else\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   ((CUM) += ((MODE) != BLKmode\t\t\t\t\\\n \t     ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n \t     : ROUND_ADVANCE (int_size_in_bytes (TYPE))))\n+#endif\n+\n+/* Return boolean indicating arg of mode MODE will be passed in a reg.\n+   This macro is only used in this file.  */\n+\n+#ifdef SPARCV9\n+#define PASS_IN_REG_P(CUM, MODE, TYPE)\t\t\t\t\\\n+  (ROUND_REG ((CUM), (MODE)) < NPARM_REGS (MODE)\t\t\\\n+   && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n+   && ((TYPE)==0 || (MODE) != BLKmode))\n+#else\n+#define PASS_IN_REG_P(CUM, MODE, TYPE)\t\t\t\t\\\n+  ((CUM) < NPARM_REGS (SImode)\t\t\t\t\t\\\n+   && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n+   && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\\\n+       || (TYPE_ALIGN (TYPE) % PARM_BOUNDARY == 0)))\n+#endif\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -874,52 +1372,77 @@ extern char leaf_reg_remap[];\n \n /* On SPARC the first six args are normally in registers\n    and the rest are pushed.  Any arg that starts within the first 6 words\n+   is at least partially passed in a register unless its data type forbids.\n+   For v9, the first 6 int args are passed in regs and the first N\n+   float args are passed in regs (where N is such that %f0-15 are filled).\n+   The rest are pushed.  Any arg that starts within the first 6 words\n    is at least partially passed in a register unless its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n-((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n- && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n- && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n-     || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n- ? gen_rtx (REG, (MODE), (BASE_PASSING_ARG_REG (MODE) + (CUM)))\t\t\\\n- : 0)\n+  (PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n+   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n+\t      (BASE_PASSING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\\\n+   : 0)\n \n /* Define where a function finds its arguments.\n    This is different from FUNCTION_ARG because of register windows.  */\n \n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n- && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n- && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n-     || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n- ? gen_rtx (REG, (MODE), (BASE_INCOMING_ARG_REG (MODE) + (CUM)))\t\\\n- : 0)\n+  (PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n+   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n+\t      (BASE_INCOMING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\\\n+   : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.\n    Any arg that starts in the first 6 regs but won't entirely fit in them\n-   needs partial registers on the Sparc.  */\n+   needs partial registers on the Sparc (!v9).  On v9, there are no arguments\n+   that are passed partially in registers (??? complex values?).  */\n \n+#ifndef SPARCV9\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n-  ((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n-    && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n-    && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n-\t|| (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n-    && ((CUM) + ((MODE) == BLKmode\t\t\t\t\t\\\n-\t\t ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\\\n-\t\t : ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS > 0)\\\n-   ? (NPARM_REGS - (CUM))\t\t\t\t\t\t\\\n+  (PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n+   && ((CUM) + ((MODE) == BLKmode\t\t\t\t\t\\\n+\t\t? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\\\n+\t\t: ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS (SImode) > 0)\\\n+   ? (NPARM_REGS (SImode) - (CUM))\t\t\t\t\t\\\n    : 0)\n+#endif\n \n /* The SPARC ABI stipulates passing struct arguments (of any size) and\n-   quad-precision floats by invisible reference.\n+   (!v9) quad-precision floats by invisible reference.\n    For Pascal, also pass arrays by reference.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n   ((TYPE && (TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\t\\\n \t    || TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n     \t    || TREE_CODE (TYPE) == ARRAY_TYPE))\t\t\t\t\\\n-   || (MODE == TFmode))\n+   || (!TARGET_V9 && MODE == TFmode))\n+\n+/* A C expression that indicates when it is the called function's\n+   responsibility to make copies of arguments passed by reference.\n+   If the callee can determine that the argument won't be modified, it can\n+   avoid the copy.  */\n+/* ??? We'd love to be able to use NAMED here.  Unfortunately, it doesn't\n+   include the last named argument so we keep track of the args ourselves.  */\n+\n+#ifdef SPARCV9\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n+  (sparc_arg_count < sparc_n_named_args)\n+#endif\n+\f\n+/* Initialize data used by insn expanders.  This is called from\n+   init_emit, once for each function, before code is generated.\n+   For v9, clear the temp slot used by float/int DImode conversions.\n+   ??? There is the 16 bytes at [%fp-16], however we'd like to delete this\n+   space at some point.\n+   ??? Use assign_stack_temp?  */\n+\n+extern void sparc64_init_expanders ();\n+extern struct rtx_def *sparc64_fpconv_stack_temp ();\n+#ifdef SPARCV9\n+#define INIT_EXPANDERS sparc64_init_expanders ()\n+#endif\n \n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n@@ -930,6 +1453,13 @@ extern struct rtx_def *sparc_compare_op0, *sparc_compare_op1;\n /* Define the function that build the compare insn for scc and bcc.  */\n \n extern struct rtx_def *gen_compare_reg ();\n+\n+/* This function handles all v9 scc insns */\n+\n+extern int gen_v9_scc ();\n+\n+/* ??? This is a hack until conditional move support is complete.  */\n+#define HAVE_conditional_move (TARGET_V9)\n \f\n /* Generate the special assembly code needed to tell the assembler whatever\n    it might need to know about the return value of a function.\n@@ -976,7 +1506,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     fputs (\"\\tsethi %hi(\", (FILE));\t\t\t\t\\\n     ASM_OUTPUT_INTERNAL_LABELREF (FILE, \"LP\", LABELNO);\t\t\\\n-    fputs (\"),%o0\\n\\tcall mcount\\n\\tor %lo(\", (FILE));\t\t\\\n+    fputs (\"),%o0\\n\", (FILE));\t\t\t\t\t\\\n+    if (TARGET_MEDANY)\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tadd %%o0,%s,%%o0\\n\",\t\t\t\\\n+\t       MEDANY_BASE_REG);\t\t\t\t\\\n+    fputs (\"\\tcall mcount\\n\\tadd %lo(\", (FILE));\t\t\\\n     ASM_OUTPUT_INTERNAL_LABELREF (FILE, \"LP\", LABELNO);\t\t\\\n     fputs (\"),%o0,%o0\\n\", (FILE));\t\t\t\t\\\n   } while (0)\n@@ -987,18 +1521,28 @@ do {\t\t\t\t\t\t\t\t\t\\\n    above FUNCTION_PROFILER).  Broken on Solaris-2.   --gnu@cygnus.com */\n \n #define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tld [%%lo(LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%%lo(LPBX0),%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\",  \\\n-\t   (LABELNO), (LABELNO))\n+  do { \\\n+    if (TARGET_MEDANY) \\\n+      fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tor %%0,%%lo(LPBX0),%%o0\\n\\tld [%s+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%s,%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\", \\\n+\t       MEDANY_BASE_REG, (LABELNO), MEDANY_BASE_REG, (LABELNO)); \\\n+    else \\\n+      fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tld [%%lo(LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%%lo(LPBX0),%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\", \\\n+\t       (LABELNO), (LABELNO)); \\\n+  } while (0)\n \n /* Output assembler code to FILE to increment the entry-count for\n    the BLOCKNO'th basic block in this source file.  */\n \n #define BLOCK_PROFILER(FILE, BLOCKNO) \\\n-{\t\t\t\t\t\t\t\t\\\n-  int blockn = (BLOCKNO);\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tld [%%lo(LPBX2+%d)+%%g1],%%g2\\n\\\n-\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(LPBX2+%d)+%%g1]\\n\",\t\t\\\n-\t   4 * blockn, 4 * blockn, 4 * blockn);\t\t\t\\\n+{ \\\n+  int blockn = (BLOCKNO); \\\n+  if (TARGET_MEDANY) \\\n+    fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tor %%g1,%%lo(LPBX2+%d),%%g1\\n\\tld [%%g1+%s],%%g2\\n\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%g1+%s]\\n\", \\\n+\t     4 * blockn, 4 * blockn, MEDANY_BASE_REG, MEDANY_BASE_REG); \\\n+  else \\\n+    fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tld [%%lo(LPBX2+%d)+%%g1],%%g2\\n\\\n+\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(LPBX2+%d)+%%g1]\\n\", \\\n+\t     4 * blockn, 4 * blockn, 4 * blockn); \\\n }\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n@@ -1062,55 +1606,17 @@ extern union tree_node *current_function_decl;\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.\n-\n-   This takes 16 insns: 2 shifts & 2 ands (to split up addresses), 4 sethi\n-   (to load in opcodes), 4 iors (to merge address and opcodes), and 4 writes\n-   (to store insns).  This is a bit excessive.  Perhaps a different\n-   mechanism would be better here.\n-\n-   Emit 3 FLUSH instructions (UNSPEC_VOLATILE 2) to synchonize the data\n-   and instruction caches.  */\n+   CXT is an RTX for the static chain value for the function.  */\n \n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx high_cxt = expand_shift (RSHIFT_EXPR, SImode, CXT,\t\t\\\n-\t\t\t      size_int (10), 0, 1);\t\t\t\\\n-  rtx high_fn = expand_shift (RSHIFT_EXPR, SImode, FNADDR,\t\t\\\n-\t\t\t     size_int (10), 0, 1);\t\t\t\\\n-  rtx low_cxt = expand_and (CXT, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0); \\\n-  rtx low_fn = expand_and (FNADDR, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0); \\\n-  rtx g1_sethi = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x03000000));\t\\\n-  rtx g2_sethi = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x05000000));\t\\\n-  rtx g1_ori = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n-\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x82106000));\t\\\n-  rtx g2_ori = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n-\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x8410A000));\t\\\n-  rtx tem = gen_reg_rtx (SImode);\t\t\t\t\t\\\n-  emit_move_insn (tem, g1_sethi);\t\t\t\t\t\\\n-  emit_insn (gen_iorsi3 (high_fn, high_fn, tem));\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 0)), high_fn);\\\n-  emit_move_insn (tem, g1_ori);\t\t\t\t\t\t\\\n-  emit_insn (gen_iorsi3 (low_fn, low_fn, tem));\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), low_fn);\\\n-  emit_move_insn (tem, g2_sethi);\t\t\t\t\t\\\n-  emit_insn (gen_iorsi3 (high_cxt, high_cxt, tem));\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 8)), high_cxt);\\\n-  emit_move_insn (tem, g2_ori);\t\t\t\t\t\t\\\n-  emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), low_cxt);\\\n-  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\t\t\t\\\n-\t\t      gen_rtvec (1, plus_constant (TRAMP, 0)),\t\t\\\n-\t\t      2));\t\t\t\t\t\t\\\n-  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\t\t\t\\\n-\t\t      gen_rtvec (1, plus_constant (TRAMP, 8)),\t\t\\\n-\t\t      2));\t\t\t\t\t\t\\\n-  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\t\t\t\\\n-\t\t      gen_rtvec (1, plus_constant (TRAMP, 16)),\t\t\\\n-\t\t      2));\t\t\t\t\t\t\\\n-}\n+void sparc_initialize_trampoline ();\n+void sparc64_initialize_trampoline ();\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (TARGET_V9)\t\t\t\t\t\t\\\n+      sparc64_initialize_trampoline (TRAMP, FNADDR, CXT);\t\\\n+    else\t\t\t\t\t\t\t\\\n+      sparc_initialize_trampoline (TRAMP, FNADDR, CXT);\t\t\\\n+  } while (0)\n \f\n /* Generate necessary RTL for __builtin_saveregs().\n    ARGLIST is the argument list; see expr.c.  */\n@@ -1124,9 +1630,10 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n \n /* Given an rtx for the address of a frame,\n    return an rtx for the address of the word in the frame\n-   that holds the dynamic chain--the previous frame's address.  */\n+   that holds the dynamic chain--the previous frame's address.\n+   ??? -mflat support? */\n #define DYNAMIC_CHAIN_ADDRESS(frame) \\\n-  gen_rtx (PLUS, Pmode, frame, gen_rtx (CONST_INT, VOIDmode, 56))\n+  gen_rtx (PLUS, Pmode, frame, gen_rtx (CONST_INT, VOIDmode, 14 * UNITS_PER_WORD))\n \n /* The return address isn't on the stack, it is in a register, so we can't\n    access it from the current frame pointer.  We can access it from the\n@@ -1142,7 +1649,7 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n   ((count == -1)\t\t\t\t\\\n    ? gen_rtx (REG, Pmode, 31)\t\t\t\\\n    : copy_to_reg (gen_rtx (MEM, Pmode,\t\t\\\n-\t\t\t   memory_address (Pmode, plus_constant (frame, 60)))))\n+\t\t\t   memory_address (Pmode, plus_constant (frame, 15 * UNITS_PER_WORD)))))\n \f\n /* Addressing modes, and classification of registers for them.  */\n \n@@ -1165,8 +1672,11 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n (((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32) && (REGNO) != 0)\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n-(((REGNO) ^ 0x20) < 32\t\\\n- || (((REGNO) != 0) && (unsigned) (reg_renumber[REGNO] ^ 0x20) < 32))\n+  (((unsigned) (REGNO) - 32 < (TARGET_V9 ? 64 : 32)) \\\n+   || ((unsigned) reg_renumber[REGNO] - 32 < (TARGET_V9 ? 64 : 32)))\n+#define REGNO_OK_FOR_CCFP_P(REGNO) \\\n+ (TARGET_V9 \\\n+  && ((unsigned) (REGNO) - 96 < 4) || ((unsigned) reg_renumber[REGNO] - 96 < 4))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n@@ -1225,27 +1735,31 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    these things in insns and then not re-recognize the insns, causing\n    constrain_operands to fail.\n \n-   `S' handles constraints for calls.  */\n+   `S' handles constraints for calls.  ??? So where is it?  */\n \n #ifndef REG_OK_STRICT\n \n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) (((unsigned) REGNO (X)) - 32 >= 32 && REGNO (X) != 0)\n+#define REG_OK_FOR_INDEX_P(X) \\\n+  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32) && REGNO (X) != 0)\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) (((unsigned) REGNO (X)) - 32 >= 32 && REGNO (X) != 0)\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32) && REGNO (X) != 0)\n+\n+/* 'T', 'U' are for aligned memory loads which aren't needed for v9.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n   ((C) == 'Q'\t\t\t\t\t\t\\\n    ? ((GET_CODE (OP) == MEM\t\t\t\t\\\n-       && memory_address_p (GET_MODE (OP), XEXP (OP, 0))\t\\\n+       && memory_address_p (GET_MODE (OP), XEXP (OP, 0)) \\\n        && ! symbolic_memory_operand (OP, VOIDmode))\t\\\n       || (reload_in_progress && GET_CODE (OP) == REG\t\\\n \t  && REGNO (OP) >= FIRST_PSEUDO_REGISTER))\t\\\n-   : (C) == 'T'\t\t\t\t\t\t\\\n+   : ! TARGET_V9 && (C) == 'T'\t\t\t\\\n    ? (mem_aligned_8 (OP))\t\t\t\t\\\n-   : (C) == 'U'\t\t\t\t\t\t\\\n+   : ! TARGET_V9 && (C) == 'U'\t\t\t\t\t\t\\\n    ? (register_ok_for_ldd (OP))\t\t\t\t\\\n    : 0)\n  \n@@ -1262,9 +1776,9 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n       ? (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n \t && reg_renumber[REGNO (OP)] < 0)\t\t\\\n       : GET_CODE (OP) == MEM)\t\t\t\t\\\n-   : (C) == 'T'\t\t\t\t\t\t\\\n+   : ! TARGET_V9 && (C) == 'T'\t\t\t\\\n    ? mem_aligned_8 (OP) && strict_memory_address_p (Pmode, XEXP (OP, 0)) \\\n-   : (C) == 'U'\t\t\t\t\t\t\\\n+   : ! TARGET_V9 && (C) == 'U'\t\t\t\\\n    ? (GET_CODE (OP) == REG\t\t\t\t\\\n       && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\t\\\n \t  || reg_renumber[REGNO (OP)] > 0)\t\t\\\n@@ -1390,10 +1904,20 @@ extern struct rtx_def *legitimize_pic_address ();\n    On the SPARC this is never true.  */\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\n+/* If we are referencing a function make the SYMBOL_REF special.\n+   In the Medium/Anywhere code model, %g4 points to the data segment so we\n+   must not add it to function addresses.  */\n+\n+#define ENCODE_SECTION_INFO(DECL) \\\n+  do {\t\t\t\t\t\t\t\\\n+    if (TARGET_MEDANY && TREE_CODE (DECL) == FUNCTION_DECL) \\\n+      SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\\\n+  } while (0)\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n+#define CASE_VECTOR_MODE Pmode\n \n /* Define this if the tablejump instruction expects the table\n    to contain offsets from the address of the table.\n@@ -1458,7 +1982,7 @@ extern struct rtx_def *legitimize_pic_address ();\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n+#define Pmode (TARGET_PTR64 ? DImode : SImode)\n \n /* Generate calls to memcpy, memcmp and memset.  */\n #define TARGET_MEM_FUNCTIONS\n@@ -1473,11 +1997,15 @@ extern struct rtx_def *legitimize_pic_address ();\n    in the floating-point condition code register.  One for comparisons which\n    will generate an exception if the result is unordered (CCFPEmode) and\n    one for comparisons which will never trap (CCFPmode).  This really should\n-   be a separate register, but we don't want to go to 65 registers.  */\n-#define EXTRA_CC_MODES CC_NOOVmode, CCFPmode, CCFPEmode\n+   be a separate register, but we don't want to go to 65 registers.\n+\n+   CCXmode and CCX_NOOVmode are only used by v9.  */\n+\n+#define EXTRA_CC_MODES CCXmode, CC_NOOVmode, CCX_NOOVmode, CCFPmode, CCFPEmode\n \n /* Define the names for the modes specified above.  */\n-#define EXTRA_CC_NAMES \"CC_NOOV\", \"CCFP\", \"CCFPE\"\n+\n+#define EXTRA_CC_NAMES \"CCX\", \"CC_NOOV\", \"CCX_NOOV\", \"CCFP\", \"CCFPE\"\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n@@ -1489,7 +2017,8 @@ extern struct rtx_def *legitimize_pic_address ();\n    ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)\t\t\t\\\n    : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\t\\\n        || GET_CODE (X) == NEG || GET_CODE (X) == ASHIFT)\t\t\\\n-      ? CC_NOOVmode : CCmode))\n+      ? (TARGET_V9 && GET_MODE (X) == DImode ? CCX_NOOVmode : CC_NOOVmode) \\\n+      : (TARGET_V9 && GET_MODE (X) == DImode ? CCXmode : CCmode)))\n \n /* Return non-zero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n@@ -1568,12 +2097,14 @@ extern struct rtx_def *legitimize_pic_address ();\n     return 8;\n \n /* Compute the cost of an address.  For the sparc, all valid addresses are\n-   the same cost.  */\n+   the same cost.\n+   ??? Is this true for v9?  */\n \n #define ADDRESS_COST(RTX)  1\n \n /* Compute extra cost of moving data between one register class\n-   and another.  */\n+   and another.\n+   ??? v9: We ignore FPCC_REGS on the assumption they'll never be seen.  */\n #define REGISTER_MOVE_COST(CLASS1, CLASS2) \\\n   (((CLASS1 == FP_REGS && CLASS2 == GENERAL_REGS) \\\n     || (CLASS1 == GENERAL_REGS && CLASS2 == FP_REGS)) ? 6 : 2)\n@@ -1587,7 +2118,7 @@ extern struct rtx_def *legitimize_pic_address ();\n \n #define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n-    return TARGET_V8 ? COSTS_N_INSNS (5) : COSTS_N_INSNS (25);\t\\\n+    return (TARGET_V8 || TARGET_V9) ? COSTS_N_INSNS (5) : COSTS_N_INSNS (25);\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n@@ -1621,9 +2152,15 @@ extern struct rtx_def *legitimize_pic_address ();\n \n #define ASM_APP_OFF \"\"\n \n+/* ??? Try to make the style consistent here (_OP?).  */\n+\n+#define ASM_LONGLONG\t\".xword\"\n #define ASM_LONG\t\".word\"\n #define ASM_SHORT\t\".half\"\n #define ASM_BYTE_OP\t\".byte\"\n+#define ASM_FLOAT\t\".single\"\n+#define ASM_DOUBLE\t\".double\"\n+#define ASM_LONGDOUBLE\t\".xxx\"\t\t/* ??? Not known (or used yet). */\n \n /* Output before read-only data.  */\n \n@@ -1636,6 +2173,22 @@ extern struct rtx_def *legitimize_pic_address ();\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n+#ifdef SPARCV9\n+#define REGISTER_NAMES \\\n+{\"%g0\", \"%g1\", \"%g2\", \"%g3\", \"%g4\", \"%g5\", \"%g6\", \"%g7\",\t\t\\\n+ \"%o0\", \"%o1\", \"%o2\", \"%o3\", \"%o4\", \"%o5\", \"%sp\", \"%o7\",\t\t\\\n+ \"%l0\", \"%l1\", \"%l2\", \"%l3\", \"%l4\", \"%l5\", \"%l6\", \"%l7\",\t\t\\\n+ \"%i0\", \"%i1\", \"%i2\", \"%i3\", \"%i4\", \"%i5\", \"%fp\", \"%i7\",\t\t\\\n+ \"%f0\", \"%f1\", \"%f2\", \"%f3\", \"%f4\", \"%f5\", \"%f6\", \"%f7\",\t\t\\\n+ \"%f8\", \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\t\t\\\n+ \"%f16\", \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\t\\\n+ \"%f24\", \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\",\t\\\n+ \"%f32\", \"%f33\", \"%f34\", \"%f35\", \"%f36\", \"%f37\", \"%f38\", \"%f39\",\t\\\n+ \"%f40\", \"%f41\", \"%f42\", \"%f43\", \"%f44\", \"%f45\", \"%f46\", \"%f47\",\t\\\n+ \"%f48\", \"%f49\", \"%f50\", \"%f51\", \"%f52\", \"%f53\", \"%f54\", \"%f55\",\t\\\n+ \"%f56\", \"%f57\", \"%f58\", \"%f59\", \"%f60\", \"%f61\", \"%f62\", \"%f63\",\t\\\n+ \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\"}\n+#else\n #define REGISTER_NAMES \\\n {\"%g0\", \"%g1\", \"%g2\", \"%g3\", \"%g4\", \"%g5\", \"%g6\", \"%g7\",\t\t\\\n  \"%o0\", \"%o1\", \"%o2\", \"%o3\", \"%o4\", \"%o5\", \"%sp\", \"%o7\",\t\t\\\n@@ -1645,6 +2198,7 @@ extern struct rtx_def *legitimize_pic_address ();\n  \"%f8\", \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\t\t\\\n  \"%f16\", \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\t\\\n  \"%f24\", \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\"}\n+#endif\n \n /* Define additional names for use in asm clobbers and asm declarations.\n \n@@ -1779,7 +2333,12 @@ extern struct rtx_def *legitimize_pic_address ();\n do {\t\t\t\t\t\t\t\t\t\\\n   char label[30];\t\t\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\\n-  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\t\\\n+  if (Pmode == SImode)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\\\n+  else if (TARGET_ENV32)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word\\t0\\n\\t.word\\t\");\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.xword\\t\");\t\t\t\t\t\\\n   assemble_name (FILE, label);\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n } while (0)\n@@ -1791,7 +2350,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   char label[30];\t\t\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\\n-  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\t\\\n+  if (Pmode == SImode)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\\\n+  else if (TARGET_ENV32)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word\\t0\\n\\t.word\\t\");\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.xword\\t\");\t\t\t\t\t\\\n   assemble_name (FILE, label);\t\t\t\t\t\t\\\n   fprintf (FILE, \"-1b\\n\");\t\t\t\t\t\t\\\n } while (0)\n@@ -1934,6 +2498,7 @@ extern char *output_fp_move_quad ();\n extern char *output_block_move ();\n extern char *output_scc_insn ();\n extern char *output_cbranch ();\n+extern char *output_v9branch ();\n extern char *output_return ();\n \n /* Defined in flags.h, but insn-emit.c does not include flags.h.  */"}]}