{"sha": "c62c265908370049de8565fe666386a33e35e73a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYyYzI2NTkwODM3MDA0OWRlODU2NWZlNjY2Mzg2YTMzZTM1ZTczYQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-12-03T14:35:17Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-03T14:35:17Z"}, "message": "Move scheduling visualization code to separate file.\n\nFrom-SVN: r37974", "tree": {"sha": "8e1519b6c485246fa05db887a92f46681e72cc23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e1519b6c485246fa05db887a92f46681e72cc23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c62c265908370049de8565fe666386a33e35e73a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c62c265908370049de8565fe666386a33e35e73a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c62c265908370049de8565fe666386a33e35e73a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c62c265908370049de8565fe666386a33e35e73a/comments", "author": null, "committer": null, "parents": [{"sha": "1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1708fd40bb4b2ee252fad6a569a83d11e598aa7d"}], "stats": {"total": 1871, "additions": 970, "deletions": 901}, "files": [{"sha": "efabdb459f592d5acff9a144a720b10136b31c1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c265908370049de8565fe666386a33e35e73a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c265908370049de8565fe666386a33e35e73a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c62c265908370049de8565fe666386a33e35e73a", "patch": "@@ -1,5 +1,26 @@\n 2000-12-03  Bernd Schmidt  <bernds@redhat.co.uk>\n \n+\t* Makefile.in (OBJS): Add sched-vis.o.\n+\t(sched-vis.o): New rule.\n+\t* haifa-sched.c (get_unit_last_insn): New function.\n+\t(sched_dump, insn_unit, actual_hazard_this_instance): No longer\n+\tstatic.\n+\t(schedule_block): Call visualize_alloc and visualize_free.  Delete\n+\tspurious return statement.\n+\t(init_target_units, insn_print_units, get_visual_tbl_length,\n+\tinit_block_visualization, print_block_visualization, safe_concat,\n+\tvisualize_scheduled_inns, visualize_no_unit, visualize_stall_cycles,\n+\tprint_exp, print_value, print_pattern, print_insn, target_units,\n+\tMAX_VISUAL_LINES, INSN_LEN, n_visual_lines, visual_tbl,\n+\tn_vis_no_unit, vis_no_unit): Move scheduling visualization\n+\tfunctions/variables...\n+\t* sched-vis.c: ...here.  New file.\n+\t(visualize_alloc, visualize_free): New functions.\n+\t(visualize_scheduled_insns, visualize_stall_cycles,\n+\tprint_block_visualization): Lose basic block argument.  All callers\n+\tchanged.\n+\t(visualize_scheduled_insns): Use new function get_unit_last_insn.\n+\n \t* sched-int.h: New file.\n \t* Makefile.in (haifa-sched.o): Depend on it.\n \t* haifa-sched.c: Include it."}, {"sha": "6cb0d77a0c70e6aa05dc9c931959d34e3cbe5b59", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c265908370049de8565fe666386a33e35e73a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c265908370049de8565fe666386a33e35e73a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c62c265908370049de8565fe666386a33e35e73a", "patch": "@@ -737,7 +737,7 @@ OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o  \\\n  mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t      \\\n  lists.o ggc-common.o $(GGC) stringpool.o simplify-rtx.o ssa.o bb-reorder.o   \\\n  sibcall.o conflict.o timevar.o ifcvt.o dominance.o dependence.o dce.o \\\n- hashtab.o\n+ sched-vis.o hashtab.o\n \n BACKEND = toplev.o libbackend.a\n \n@@ -1455,6 +1455,8 @@ regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n haifa-sched.o : haifa-sched.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h\n+sched-vis.o : sched-vis.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n+   $(INSN_ATTR_H) $(REGS_H)\n final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) function.h \\\n    real.h output.h hard-reg-set.h insn-flags.h insn-codes.h gstab.h except.h \\"}, {"sha": "f89f2a1dd777aac4e22251c2fcc65b7025ac4bd8", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 17, "deletions": 900, "changes": 917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c265908370049de8565fe666386a33e35e73a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c265908370049de8565fe666386a33e35e73a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c62c265908370049de8565fe666386a33e35e73a", "patch": "@@ -177,15 +177,6 @@ extern rtx *reg_known_value;\n \n #ifdef INSN_SCHEDULING\n \n-/* target_units bitmask has 1 for each unit in the cpu.  It should be\n-   possible to compute this variable from the machine description.\n-   But currently it is computed by examining the insn list.  Since\n-   this is only needed for visualization, it seems an acceptable\n-   solution.  (For understanding the mapping of bits to units, see\n-   definition of function_units[] in \"insn-attrtab.c\".)  */\n-\n-static int target_units = 0;\n-\n /* issue_rate is the number of insns that can be scheduled in the same\n    machine cycle.  It can be defined in the config/mach/mach.h file,\n    otherwise we set it to 1.  */\n@@ -216,7 +207,7 @@ static int nr_inter, nr_spec;\n \n /* Debugging file.  All printouts are sent to dump, which is always set,\n    either to stderr, or to the dump listing file (-dRS).  */\n-static FILE *sched_dump = 0;\n+FILE *sched_dump = 0;\n \n /* Highest uid before scheduling.  */\n static int old_max_uid;\n@@ -502,10 +493,8 @@ static void add_dependence PARAMS ((rtx, rtx, enum reg_note));\n static void remove_dependence PARAMS ((rtx, rtx));\n static rtx find_insn_list PARAMS ((rtx, rtx));\n static void set_sched_group_p PARAMS ((rtx));\n-static int insn_unit PARAMS ((rtx));\n static unsigned int blockage_range PARAMS ((int, rtx));\n static void clear_units PARAMS ((void));\n-static int actual_hazard_this_instance PARAMS ((int, int, rtx, int, int));\n static void schedule_unit PARAMS ((int, rtx, int));\n static int actual_hazard PARAMS ((int, rtx, int, int));\n static int potential_hazard PARAMS ((int, rtx, int));\n@@ -525,7 +514,6 @@ static void queue_insn PARAMS ((rtx, int));\n static void schedule_insn PARAMS ((rtx, struct ready_list *, int));\n static void find_insn_reg_weight PARAMS ((int));\n static void schedule_block PARAMS ((int, int));\n-static char *safe_concat PARAMS ((char *, char *, const char *));\n static int insn_issue_delay PARAMS ((rtx));\n static void adjust_priority PARAMS ((rtx));\n \n@@ -802,18 +790,6 @@ static rtx ready_remove_first PARAMS ((struct ready_list *));\n static void queue_to_ready PARAMS ((struct ready_list *));\n \n static void debug_ready_list PARAMS ((struct ready_list *));\n-static void init_target_units PARAMS ((void));\n-static void insn_print_units PARAMS ((rtx));\n-static int get_visual_tbl_length PARAMS ((void));\n-static void init_block_visualization PARAMS ((void));\n-static void print_block_visualization PARAMS ((int, const char *));\n-static void visualize_scheduled_insns PARAMS ((int, int));\n-static void visualize_no_unit PARAMS ((rtx));\n-static void visualize_stall_cycles PARAMS ((int, int));\n-static void print_exp PARAMS ((char *, rtx, int));\n-static void print_value PARAMS ((char *, rtx, int));\n-static void print_pattern PARAMS ((char *, rtx, int));\n-static void print_insn PARAMS ((char *, rtx, int));\n void debug_reg_vector PARAMS ((regset));\n \n static rtx move_insn1 PARAMS ((rtx, rtx));\n@@ -2914,7 +2890,7 @@ find_insn_mem_list (insn, x, list, list1)\n    mask if the value is negative.  A function unit index is the\n    non-negative encoding.  */\n \n-HAIFA_INLINE static int\n+HAIFA_INLINE int\n insn_unit (insn)\n      rtx insn;\n {\n@@ -2986,6 +2962,15 @@ static int unit_tick[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n    that remain to use the unit.  */\n static int unit_n_insns[FUNCTION_UNITS_SIZE];\n \n+/* Access the unit_last_insn array.  Used by the visualization code.  */\n+\n+rtx\n+get_unit_last_insn (instance)\n+     int instance;\n+{\n+  return unit_last_insn[instance];\n+}\n+\n /* Reset the function unit state to the null state.  */\n \n static void\n@@ -3028,7 +3013,7 @@ insn_issue_delay (insn)\n    instance INSTANCE at time CLOCK if the previous actual hazard cost\n    was COST.  */\n \n-HAIFA_INLINE static int\n+HAIFA_INLINE int\n actual_hazard_this_instance (unit, instance, insn, clock, cost)\n      int unit, instance, clock, cost;\n      rtx insn;\n@@ -4899,7 +4884,7 @@ queue_to_ready (ready)\n \t}\n \n       if (sched_verbose && stalls)\n-\tvisualize_stall_cycles (BB_TO_BLOCK (target_bb), stalls);\n+\tvisualize_stall_cycles (stalls);\n       q_ptr = NEXT_Q_AFTER (q_ptr, stalls);\n       clock_var += stalls;\n     }\n@@ -4923,873 +4908,6 @@ debug_ready_list (ready)\n   fprintf (sched_dump, \"\\n\");\n }\n \n-/* Print names of units on which insn can/should execute, for debugging.  */\n-\n-static void\n-insn_print_units (insn)\n-     rtx insn;\n-{\n-  int i;\n-  int unit = insn_unit (insn);\n-\n-  if (unit == -1)\n-    fprintf (sched_dump, \"none\");\n-  else if (unit >= 0)\n-    fprintf (sched_dump, \"%s\", function_units[unit].name);\n-  else\n-    {\n-      fprintf (sched_dump, \"[\");\n-      for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n-\tif (unit & 1)\n-\t  {\n-\t    fprintf (sched_dump, \"%s\", function_units[i].name);\n-\t    if (unit != 1)\n-\t      fprintf (sched_dump, \" \");\n-\t  }\n-      fprintf (sched_dump, \"]\");\n-    }\n-}\n-\n-/* MAX_VISUAL_LINES is the maximum number of lines in visualization table\n-   of a basic block.  If more lines are needed, table is splitted to two.\n-   n_visual_lines is the number of lines printed so far for a block.\n-   visual_tbl contains the block visualization info.\n-   vis_no_unit holds insns in a cycle that are not mapped to any unit.  */\n-#define MAX_VISUAL_LINES 100\n-#define INSN_LEN 30\n-int n_visual_lines;\n-char *visual_tbl;\n-int n_vis_no_unit;\n-rtx vis_no_unit[10];\n-\n-/* Finds units that are in use in this fuction.  Required only\n-   for visualization.  */\n-\n-static void\n-init_target_units ()\n-{\n-  rtx insn;\n-  int unit;\n-\n-  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-    {\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      unit = insn_unit (insn);\n-\n-      if (unit < 0)\n-\ttarget_units |= ~unit;\n-      else\n-\ttarget_units |= (1 << unit);\n-    }\n-}\n-\n-/* Return the length of the visualization table.  */\n-\n-static int\n-get_visual_tbl_length ()\n-{\n-  int unit, i;\n-  int n, n1;\n-  char *s;\n-\n-  /* Compute length of one field in line.  */\n-  s = (char *) alloca (INSN_LEN + 6);\n-  sprintf (s, \"  %33s\", \"uname\");\n-  n1 = strlen (s);\n-\n-  /* Compute length of one line.  */\n-  n = strlen (\";; \");\n-  n += n1;\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tn += n1;\n-  n += n1;\n-  n += strlen (\"\\n\") + 2;\n-\n-  /* Compute length of visualization string.  */\n-  return (MAX_VISUAL_LINES * n);\n-}\n-\n-/* Init block visualization debugging info.  */\n-\n-static void\n-init_block_visualization ()\n-{\n-  strcpy (visual_tbl, \"\");\n-  n_visual_lines = 0;\n-  n_vis_no_unit = 0;\n-}\n-\n-#define BUF_LEN 2048\n-\n-static char *\n-safe_concat (buf, cur, str)\n-     char *buf;\n-     char *cur;\n-     const char *str;\n-{\n-  char *end = buf + BUF_LEN - 2;\t/* Leave room for null.  */\n-  int c;\n-\n-  if (cur > end)\n-    {\n-      *end = '\\0';\n-      return end;\n-    }\n-\n-  while (cur < end && (c = *str++) != '\\0')\n-    *cur++ = c;\n-\n-  *cur = '\\0';\n-  return cur;\n-}\n-\n-/* This recognizes rtx, I classified as expressions.  These are always\n-   represent some action on values or results of other expression, that\n-   may be stored in objects representing values.  */\n-\n-static void\n-print_exp (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n-{\n-  char tmp[BUF_LEN];\n-  const char *st[4];\n-  char *cur = buf;\n-  const char *fun = (char *) 0;\n-  const char *sep;\n-  rtx op[4];\n-  int i;\n-\n-  for (i = 0; i < 4; i++)\n-    {\n-      st[i] = (char *) 0;\n-      op[i] = NULL_RTX;\n-    }\n-\n-  switch (GET_CODE (x))\n-    {\n-    case PLUS:\n-      op[0] = XEXP (x, 0);\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (x, 1)) < 0)\n-\t{\n-\t  st[1] = \"-\";\n-\t  op[1] = GEN_INT (-INTVAL (XEXP (x, 1)));\n-\t}\n-      else\n-\t{\n-\t  st[1] = \"+\";\n-\t  op[1] = XEXP (x, 1);\n-\t}\n-      break;\n-    case LO_SUM:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"+low(\";\n-      op[1] = XEXP (x, 1);\n-      st[2] = \")\";\n-      break;\n-    case MINUS:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"-\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case COMPARE:\n-      fun = \"cmp\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case NEG:\n-      st[0] = \"-\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case MULT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"*\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case DIV:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"/\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UDIV:\n-      fun = \"udiv\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case MOD:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"%\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UMOD:\n-      fun = \"umod\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case SMIN:\n-      fun = \"smin\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case SMAX:\n-      fun = \"smax\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UMIN:\n-      fun = \"umin\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UMAX:\n-      fun = \"umax\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case NOT:\n-      st[0] = \"!\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case AND:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"&\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case IOR:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"|\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case XOR:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"^\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ASHIFT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<<\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LSHIFTRT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \" 0>>\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ASHIFTRT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">>\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ROTATE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<-<\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ROTATERT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">->\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ABS:\n-      fun = \"abs\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case SQRT:\n-      fun = \"sqrt\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FFS:\n-      fun = \"ffs\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case EQ:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"==\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case NE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"!=\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case GT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case GTU:\n-      fun = \"gtu\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LTU:\n-      fun = \"ltu\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case GE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">=\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case GEU:\n-      fun = \"geu\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<=\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LEU:\n-      fun = \"leu\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case SIGN_EXTRACT:\n-      fun = (verbose) ? \"sign_extract\" : \"sxt\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      op[2] = XEXP (x, 2);\n-      break;\n-    case ZERO_EXTRACT:\n-      fun = (verbose) ? \"zero_extract\" : \"zxt\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      op[2] = XEXP (x, 2);\n-      break;\n-    case SIGN_EXTEND:\n-      fun = (verbose) ? \"sign_extend\" : \"sxn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case ZERO_EXTEND:\n-      fun = (verbose) ? \"zero_extend\" : \"zxn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FLOAT_EXTEND:\n-      fun = (verbose) ? \"float_extend\" : \"fxn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case TRUNCATE:\n-      fun = (verbose) ? \"trunc\" : \"trn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FLOAT_TRUNCATE:\n-      fun = (verbose) ? \"float_trunc\" : \"ftr\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FLOAT:\n-      fun = (verbose) ? \"float\" : \"flt\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case UNSIGNED_FLOAT:\n-      fun = (verbose) ? \"uns_float\" : \"ufl\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FIX:\n-      fun = \"fix\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case UNSIGNED_FIX:\n-      fun = (verbose) ? \"uns_fix\" : \"ufx\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case PRE_DEC:\n-      st[0] = \"--\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case PRE_INC:\n-      st[0] = \"++\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case POST_DEC:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"--\";\n-      break;\n-    case POST_INC:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"++\";\n-      break;\n-    case CALL:\n-      st[0] = \"call \";\n-      op[0] = XEXP (x, 0);\n-      if (verbose)\n-\t{\n-\t  st[1] = \" argc:\";\n-\t  op[1] = XEXP (x, 1);\n-\t}\n-      break;\n-    case IF_THEN_ELSE:\n-      st[0] = \"{(\";\n-      op[0] = XEXP (x, 0);\n-      st[1] = \")?\";\n-      op[1] = XEXP (x, 1);\n-      st[2] = \":\";\n-      op[2] = XEXP (x, 2);\n-      st[3] = \"}\";\n-      break;\n-    case TRAP_IF:\n-      fun = \"trap_if\";\n-      op[0] = TRAP_CONDITION (x);\n-      break;\n-    case UNSPEC:\n-    case UNSPEC_VOLATILE:\n-      {\n-\tcur = safe_concat (buf, cur, \"unspec\");\n-\tif (GET_CODE (x) == UNSPEC_VOLATILE)\n-\t  cur = safe_concat (buf, cur, \"/v\");\n-\tcur = safe_concat (buf, cur, \"[\");\n-\tsep = \"\";\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (tmp, XVECEXP (x, 0, i), verbose);\n-\t    cur = safe_concat (buf, cur, sep);\n-\t    cur = safe_concat (buf, cur, tmp);\n-\t    sep = \",\";\n-\t  }\n-\tcur = safe_concat (buf, cur, \"] \");\n-\tsprintf (tmp, \"%d\", XINT (x, 1));\n-\tcur = safe_concat (buf, cur, tmp);\n-      }\n-      break;\n-    default:\n-      /* If (verbose) debug_rtx (x);  */\n-      st[0] = GET_RTX_NAME (GET_CODE (x));\n-      break;\n-    }\n-\n-  /* Print this as a function?  */\n-  if (fun)\n-    {\n-      cur = safe_concat (buf, cur, fun);\n-      cur = safe_concat (buf, cur, \"(\");\n-    }\n-\n-  for (i = 0; i < 4; i++)\n-    {\n-      if (st[i])\n-\tcur = safe_concat (buf, cur, st[i]);\n-\n-      if (op[i])\n-\t{\n-\t  if (fun && i != 0)\n-\t    cur = safe_concat (buf, cur, \",\");\n-\n-\t  print_value (tmp, op[i], verbose);\n-\t  cur = safe_concat (buf, cur, tmp);\n-\t}\n-    }\n-\n-  if (fun)\n-    cur = safe_concat (buf, cur, \")\");\n-}\t\t/* print_exp */\n-\n-/* Prints rtxes, I customly classified as values.  They're constants,\n-   registers, labels, symbols and memory accesses.  */\n-\n-static void\n-print_value (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n-{\n-  char t[BUF_LEN];\n-  char *cur = buf;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case CONST_INT:\n-      sprintf (t, HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\n-      cur = safe_concat (buf, cur, t);\n-      break;\n-    case CONST_DOUBLE:\n-      sprintf (t, \"<0x%lx,0x%lx>\", (long) XWINT (x, 2), (long) XWINT (x, 3));\n-      cur = safe_concat (buf, cur, t);\n-      break;\n-    case CONST_STRING:\n-      cur = safe_concat (buf, cur, \"\\\"\");\n-      cur = safe_concat (buf, cur, XSTR (x, 0));\n-      cur = safe_concat (buf, cur, \"\\\"\");\n-      break;\n-    case SYMBOL_REF:\n-      cur = safe_concat (buf, cur, \"`\");\n-      cur = safe_concat (buf, cur, XSTR (x, 0));\n-      cur = safe_concat (buf, cur, \"'\");\n-      break;\n-    case LABEL_REF:\n-      sprintf (t, \"L%d\", INSN_UID (XEXP (x, 0)));\n-      cur = safe_concat (buf, cur, t);\n-      break;\n-    case CONST:\n-      print_value (t, XEXP (x, 0), verbose);\n-      cur = safe_concat (buf, cur, \"const(\");\n-      cur = safe_concat (buf, cur, t);\n-      cur = safe_concat (buf, cur, \")\");\n-      break;\n-    case HIGH:\n-      print_value (t, XEXP (x, 0), verbose);\n-      cur = safe_concat (buf, cur, \"high(\");\n-      cur = safe_concat (buf, cur, t);\n-      cur = safe_concat (buf, cur, \")\");\n-      break;\n-    case REG:\n-      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  int c = reg_names[REGNO (x)][0];\n-\t  if (c >= '0' && c <= '9')\n-\t    cur = safe_concat (buf, cur, \"%\");\n-\n-\t  cur = safe_concat (buf, cur, reg_names[REGNO (x)]);\n-\t}\n-      else\n-\t{\n-\t  sprintf (t, \"r%d\", REGNO (x));\n-\t  cur = safe_concat (buf, cur, t);\n-\t}\n-      break;\n-    case SUBREG:\n-      print_value (t, SUBREG_REG (x), verbose);\n-      cur = safe_concat (buf, cur, t);\n-      sprintf (t, \"#%d\", SUBREG_WORD (x));\n-      cur = safe_concat (buf, cur, t);\n-      break;\n-    case SCRATCH:\n-      cur = safe_concat (buf, cur, \"scratch\");\n-      break;\n-    case CC0:\n-      cur = safe_concat (buf, cur, \"cc0\");\n-      break;\n-    case PC:\n-      cur = safe_concat (buf, cur, \"pc\");\n-      break;\n-    case MEM:\n-      print_value (t, XEXP (x, 0), verbose);\n-      cur = safe_concat (buf, cur, \"[\");\n-      cur = safe_concat (buf, cur, t);\n-      cur = safe_concat (buf, cur, \"]\");\n-      break;\n-    default:\n-      print_exp (t, x, verbose);\n-      cur = safe_concat (buf, cur, t);\n-      break;\n-    }\n-}\t\t\t\t/* print_value */\n-\n-/* The next step in insn detalization, its pattern recognition.  */\n-\n-static void\n-print_pattern (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n-{\n-  char t1[BUF_LEN], t2[BUF_LEN], t3[BUF_LEN];\n-\n-  switch (GET_CODE (x))\n-    {\n-    case SET:\n-      print_value (t1, SET_DEST (x), verbose);\n-      print_value (t2, SET_SRC (x), verbose);\n-      sprintf (buf, \"%s=%s\", t1, t2);\n-      break;\n-    case RETURN:\n-      sprintf (buf, \"return\");\n-      break;\n-    case CALL:\n-      print_exp (buf, x, verbose);\n-      break;\n-    case CLOBBER:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"clobber %s\", t1);\n-      break;\n-    case USE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"use %s\", t1);\n-      break;\n-    case COND_EXEC:\n-      if (GET_CODE (COND_EXEC_TEST (x)) == NE\n-\t  && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n-\tprint_value (t1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n-      else if (GET_CODE (COND_EXEC_TEST (x)) == EQ\n-               && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n-        {\n-\t  t1[0] = '!';\n-\t  print_value (t1 + 1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n-\t}\n-      else\n-        print_value (t1, COND_EXEC_TEST (x), verbose);\n-      print_pattern (t2, COND_EXEC_CODE (x), verbose);\n-      sprintf (buf, \"(%s) %s\", t1, t2);\n-      break;\n-    case PARALLEL:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s}\", t1);\n-      }\n-      break;\n-    case SEQUENCE:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"%%{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_insn (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s%%}\", t1);\n-      }\n-      break;\n-    case ASM_INPUT:\n-      sprintf (buf, \"asm {%s}\", XSTR (x, 0));\n-      break;\n-    case ADDR_VEC:\n-      break;\n-    case ADDR_DIFF_VEC:\n-      print_value (buf, XEXP (x, 0), verbose);\n-      break;\n-    case TRAP_IF:\n-      print_value (t1, TRAP_CONDITION (x), verbose);\n-      sprintf (buf, \"trap_if %s\", t1);\n-      break;\n-    case UNSPEC:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"unspec{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s}\", t1);\n-      }\n-      break;\n-    case UNSPEC_VOLATILE:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"unspec/v{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s}\", t1);\n-      }\n-      break;\n-    default:\n-      print_value (buf, x, verbose);\n-    }\n-}\t\t\t\t/* print_pattern */\n-\n-/* This is the main function in rtl visualization mechanism. It\n-   accepts an rtx and tries to recognize it as an insn, then prints it\n-   properly in human readable form, resembling assembler mnemonics.\n-   For every insn it prints its UID and BB the insn belongs too.\n-   (Probably the last \"option\" should be extended somehow, since it\n-   depends now on sched.c inner variables ...)  */\n-\n-static void\n-print_insn (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n-{\n-  char t[BUF_LEN];\n-  rtx insn = x;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case INSN:\n-      print_pattern (t, PATTERN (x), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (x, 1),\n-\t\t t);\n-      else\n-\tsprintf (buf, \"%-4d %s\", INSN_UID (x), t);\n-      break;\n-    case JUMP_INSN:\n-      print_pattern (t, PATTERN (x), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"%s: jump %s\", (*current_sched_info->print_insn) (x, 1),\n-\t\t t);\n-      else\n-\tsprintf (buf, \"%-4d %s\", INSN_UID (x), t);\n-      break;\n-    case CALL_INSN:\n-      x = PATTERN (insn);\n-      if (GET_CODE (x) == PARALLEL)\n-\t{\n-\t  x = XVECEXP (x, 0, 0);\n-\t  print_pattern (t, x, verbose);\n-\t}\n-      else\n-\tstrcpy (t, \"call <...>\");\n-      if (verbose)\n-\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (x, 1), t);\n-      else\n-\tsprintf (buf, \"%-4d %s\", INSN_UID (insn), t);\n-      break;\n-    case CODE_LABEL:\n-      sprintf (buf, \"L%d:\", INSN_UID (x));\n-      break;\n-    case BARRIER:\n-      sprintf (buf, \"i% 4d: barrier\", INSN_UID (x));\n-      break;\n-    case NOTE:\n-      if (NOTE_LINE_NUMBER (x) > 0)\n-\tsprintf (buf, \"%4d note \\\"%s\\\" %d\", INSN_UID (x),\n-\t\t NOTE_SOURCE_FILE (x), NOTE_LINE_NUMBER (x));\n-      else\n-\tsprintf (buf, \"%4d %s\", INSN_UID (x),\n-\t\t GET_NOTE_INSN_NAME (NOTE_LINE_NUMBER (x)));\n-      break;\n-    default:\n-      if (verbose)\n-\t{\n-\t  sprintf (buf, \"Not an INSN at all\\n\");\n-\t  debug_rtx (x);\n-\t}\n-      else\n-\tsprintf (buf, \"i%-4d  <What?>\", INSN_UID (x));\n-    }\n-}\t\t\t\t/* print_insn */\n-\n-/* Print visualization debugging info.  */\n-\n-static void\n-print_block_visualization (b, s)\n-     int b;\n-     const char *s;\n-{\n-  int unit, i;\n-\n-  /* Print header.  */\n-  fprintf (sched_dump, \"\\n;;   ==================== scheduling visualization for block %d %s \\n\", b, s);\n-\n-  /* Print names of units.  */\n-  fprintf (sched_dump, \";;   %-8s\", \"clock\");\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tfprintf (sched_dump, \"  %-33s\", function_units[unit].name);\n-  fprintf (sched_dump, \"  %-8s\\n\", \"no-unit\");\n-\n-  fprintf (sched_dump, \";;   %-8s\", \"=====\");\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tfprintf (sched_dump, \"  %-33s\", \"==============================\");\n-  fprintf (sched_dump, \"  %-8s\\n\", \"=======\");\n-\n-  /* Print insns in each cycle.  */\n-  fprintf (sched_dump, \"%s\\n\", visual_tbl);\n-}\n-\n-/* Print insns in the 'no_unit' column of visualization.  */\n-\n-static void\n-visualize_no_unit (insn)\n-     rtx insn;\n-{\n-  vis_no_unit[n_vis_no_unit] = insn;\n-  n_vis_no_unit++;\n-}\n-\n-/* Print insns scheduled in clock, for visualization.  */\n-\n-static void\n-visualize_scheduled_insns (b, clock)\n-     int b, clock;\n-{\n-  int i, unit;\n-\n-  /* If no more room, split table into two.  */\n-  if (n_visual_lines >= MAX_VISUAL_LINES)\n-    {\n-      print_block_visualization (b, \"(incomplete)\");\n-      init_block_visualization ();\n-    }\n-\n-  n_visual_lines++;\n-\n-  sprintf (visual_tbl + strlen (visual_tbl), \";;   %-8d\", clock);\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\t{\n-\t  int instance = unit + i * FUNCTION_UNITS_SIZE;\n-\t  rtx insn = unit_last_insn[instance];\n-\n-\t  /* Print insns that still keep the unit busy.  */\n-\t  if (insn &&\n-\t      actual_hazard_this_instance (unit, instance, insn, clock, 0))\n-\t    {\n-\t      char str[BUF_LEN];\n-\t      print_insn (str, insn, 0);\n-\t      str[INSN_LEN] = '\\0';\n-\t      sprintf (visual_tbl + strlen (visual_tbl), \"  %-33s\", str);\n-\t    }\n-\t  else\n-\t    sprintf (visual_tbl + strlen (visual_tbl), \"  %-33s\", \"------------------------------\");\n-\t}\n-\n-  /* Print insns that are not assigned to any unit.  */\n-  for (i = 0; i < n_vis_no_unit; i++)\n-    sprintf (visual_tbl + strlen (visual_tbl), \"  %-8d\",\n-\t     INSN_UID (vis_no_unit[i]));\n-  n_vis_no_unit = 0;\n-\n-  sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n-}\n-\n-/* Print stalled cycles.  */\n-\n-static void\n-visualize_stall_cycles (b, stalls)\n-     int b, stalls;\n-{\n-  int i;\n-\n-  /* If no more room, split table into two.  */\n-  if (n_visual_lines >= MAX_VISUAL_LINES)\n-    {\n-      print_block_visualization (b, \"(incomplete)\");\n-      init_block_visualization ();\n-    }\n-\n-  n_visual_lines++;\n-\n-  sprintf (visual_tbl + strlen (visual_tbl), \";;       \");\n-  for (i = 0; i < stalls; i++)\n-    sprintf (visual_tbl + strlen (visual_tbl), \".\");\n-  sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n-}\n-\n /* The number of insns from the current block scheduled so far.  */\n static int sched_target_n_insns;\n /* The number of insns from the current block to be scheduled in total.  */\n@@ -6248,7 +5366,7 @@ schedule_block (bb, rgn_n_insns)\n       fprintf (sched_dump, \";;   ======================================================\\n\");\n       fprintf (sched_dump, \"\\n\");\n \n-      visual_tbl = (char *) alloca (get_visual_tbl_length ());\n+      visualize_alloc ();\n       init_block_visualization ();\n     }\n \n@@ -6356,15 +5474,15 @@ schedule_block (bb, rgn_n_insns)\n \n       /* Debug info.  */\n       if (sched_verbose)\n-\tvisualize_scheduled_insns (b, clock_var);\n+\tvisualize_scheduled_insns (clock_var);\n     }\n \n   /* Debug info.  */\n   if (sched_verbose)\n     {\n       fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n-      print_block_visualization (b, \"\");\n+      print_block_visualization (\"\");\n     }\n \n   /* Sanity check -- queue must be empty now.  Meaningless if region has\n@@ -6402,14 +5520,13 @@ schedule_block (bb, rgn_n_insns)\n \t       clock_var, INSN_UID (head));\n       fprintf (sched_dump, \";;   new tail = %d\\n\\n\",\n \t       INSN_UID (tail));\n+      visualize_free ();\n     }\n \n   current_sched_info->head = head;\n   current_sched_info->tail = tail;\n \n   free (ready.vec);\n-\n-  return 1;\n }\n \f\n /* Print the bit-set of registers, S, callable from debugger.  */"}, {"sha": "9bbc4357d7ce15119f7618e04e3b7371241b289a", "filename": "gcc/sched-vis.c", "status": "added", "additions": 929, "deletions": 0, "changes": 929, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c265908370049de8565fe666386a33e35e73a/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c265908370049de8565fe666386a33e35e73a/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=c62c265908370049de8565fe666386a33e35e73a", "patch": "@@ -0,0 +1,929 @@\n+/* Instruction scheduling pass.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n+   and currently maintained by, Jim Wilson (wilson@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\f\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"toplev.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"regs.h\"\n+#include \"insn-attr.h\"\n+#include \"sched-int.h\"\n+\n+/* target_units bitmask has 1 for each unit in the cpu.  It should be\n+   possible to compute this variable from the machine description.\n+   But currently it is computed by examining the insn list.  Since\n+   this is only needed for visualization, it seems an acceptable\n+   solution.  (For understanding the mapping of bits to units, see\n+   definition of function_units[] in \"insn-attrtab.c\".)  */\n+\n+static int target_units = 0;\n+\n+static char *safe_concat PARAMS ((char *, char *, const char *));\n+static int get_visual_tbl_length PARAMS ((void));\n+static void print_exp PARAMS ((char *, rtx, int));\n+static void print_value PARAMS ((char *, rtx, int));\n+static void print_pattern PARAMS ((char *, rtx, int));\n+static void print_insn PARAMS ((char *, rtx, int));\n+\n+/* Print names of units on which insn can/should execute, for debugging.  */\n+\n+void\n+insn_print_units (insn)\n+     rtx insn;\n+{\n+  int i;\n+  int unit = insn_unit (insn);\n+\n+  if (unit == -1)\n+    fprintf (sched_dump, \"none\");\n+  else if (unit >= 0)\n+    fprintf (sched_dump, \"%s\", function_units[unit].name);\n+  else\n+    {\n+      fprintf (sched_dump, \"[\");\n+      for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n+\tif (unit & 1)\n+\t  {\n+\t    fprintf (sched_dump, \"%s\", function_units[i].name);\n+\t    if (unit != 1)\n+\t      fprintf (sched_dump, \" \");\n+\t  }\n+      fprintf (sched_dump, \"]\");\n+    }\n+}\n+\n+/* MAX_VISUAL_LINES is the maximum number of lines in visualization table\n+   of a basic block.  If more lines are needed, table is splitted to two.\n+   n_visual_lines is the number of lines printed so far for a block.\n+   visual_tbl contains the block visualization info.\n+   vis_no_unit holds insns in a cycle that are not mapped to any unit.  */\n+#define MAX_VISUAL_LINES 100\n+#define INSN_LEN 30\n+int n_visual_lines;\n+char *visual_tbl;\n+int n_vis_no_unit;\n+rtx vis_no_unit[10];\n+\n+/* Finds units that are in use in this fuction.  Required only\n+   for visualization.  */\n+\n+void\n+init_target_units ()\n+{\n+  rtx insn;\n+  int unit;\n+\n+  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+    {\n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      unit = insn_unit (insn);\n+\n+      if (unit < 0)\n+\ttarget_units |= ~unit;\n+      else\n+\ttarget_units |= (1 << unit);\n+    }\n+}\n+\n+/* Return the length of the visualization table.  */\n+\n+static int\n+get_visual_tbl_length ()\n+{\n+  int unit, i;\n+  int n, n1;\n+  char *s;\n+\n+  /* Compute length of one field in line.  */\n+  s = (char *) alloca (INSN_LEN + 6);\n+  sprintf (s, \"  %33s\", \"uname\");\n+  n1 = strlen (s);\n+\n+  /* Compute length of one line.  */\n+  n = strlen (\";; \");\n+  n += n1;\n+  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n+    if (function_units[unit].bitmask & target_units)\n+      for (i = 0; i < function_units[unit].multiplicity; i++)\n+\tn += n1;\n+  n += n1;\n+  n += strlen (\"\\n\") + 2;\n+\n+  /* Compute length of visualization string.  */\n+  return (MAX_VISUAL_LINES * n);\n+}\n+\n+/* Init block visualization debugging info.  */\n+\n+void\n+init_block_visualization ()\n+{\n+  strcpy (visual_tbl, \"\");\n+  n_visual_lines = 0;\n+  n_vis_no_unit = 0;\n+}\n+\n+#define BUF_LEN 2048\n+\n+static char *\n+safe_concat (buf, cur, str)\n+     char *buf;\n+     char *cur;\n+     const char *str;\n+{\n+  char *end = buf + BUF_LEN - 2;\t/* Leave room for null.  */\n+  int c;\n+\n+  if (cur > end)\n+    {\n+      *end = '\\0';\n+      return end;\n+    }\n+\n+  while (cur < end && (c = *str++) != '\\0')\n+    *cur++ = c;\n+\n+  *cur = '\\0';\n+  return cur;\n+}\n+\n+/* This recognizes rtx, I classified as expressions.  These are always\n+   represent some action on values or results of other expression, that\n+   may be stored in objects representing values.  */\n+\n+static void\n+print_exp (buf, x, verbose)\n+     char *buf;\n+     rtx x;\n+     int verbose;\n+{\n+  char tmp[BUF_LEN];\n+  const char *st[4];\n+  char *cur = buf;\n+  const char *fun = (char *) 0;\n+  const char *sep;\n+  rtx op[4];\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      st[i] = (char *) 0;\n+      op[i] = NULL_RTX;\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case PLUS:\n+      op[0] = XEXP (x, 0);\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) < 0)\n+\t{\n+\t  st[1] = \"-\";\n+\t  op[1] = GEN_INT (-INTVAL (XEXP (x, 1)));\n+\t}\n+      else\n+\t{\n+\t  st[1] = \"+\";\n+\t  op[1] = XEXP (x, 1);\n+\t}\n+      break;\n+    case LO_SUM:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"+low(\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \")\";\n+      break;\n+    case MINUS:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"-\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case COMPARE:\n+      fun = \"cmp\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case NEG:\n+      st[0] = \"-\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case MULT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"*\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case DIV:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"/\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UDIV:\n+      fun = \"udiv\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case MOD:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"%\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UMOD:\n+      fun = \"umod\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case SMIN:\n+      fun = \"smin\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case SMAX:\n+      fun = \"smax\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UMIN:\n+      fun = \"umin\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UMAX:\n+      fun = \"umax\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case NOT:\n+      st[0] = \"!\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case AND:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"&\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case IOR:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"|\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case XOR:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"^\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ASHIFT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<<\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LSHIFTRT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \" 0>>\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ASHIFTRT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">>\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ROTATE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<-<\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ROTATERT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">->\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ABS:\n+      fun = \"abs\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case SQRT:\n+      fun = \"sqrt\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FFS:\n+      fun = \"ffs\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case EQ:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"==\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case NE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"!=\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case GT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case GTU:\n+      fun = \"gtu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LTU:\n+      fun = \"ltu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case GE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">=\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case GEU:\n+      fun = \"geu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<=\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LEU:\n+      fun = \"leu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case SIGN_EXTRACT:\n+      fun = (verbose) ? \"sign_extract\" : \"sxt\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      op[2] = XEXP (x, 2);\n+      break;\n+    case ZERO_EXTRACT:\n+      fun = (verbose) ? \"zero_extract\" : \"zxt\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      op[2] = XEXP (x, 2);\n+      break;\n+    case SIGN_EXTEND:\n+      fun = (verbose) ? \"sign_extend\" : \"sxn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case ZERO_EXTEND:\n+      fun = (verbose) ? \"zero_extend\" : \"zxn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FLOAT_EXTEND:\n+      fun = (verbose) ? \"float_extend\" : \"fxn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case TRUNCATE:\n+      fun = (verbose) ? \"trunc\" : \"trn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FLOAT_TRUNCATE:\n+      fun = (verbose) ? \"float_trunc\" : \"ftr\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FLOAT:\n+      fun = (verbose) ? \"float\" : \"flt\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case UNSIGNED_FLOAT:\n+      fun = (verbose) ? \"uns_float\" : \"ufl\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FIX:\n+      fun = \"fix\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case UNSIGNED_FIX:\n+      fun = (verbose) ? \"uns_fix\" : \"ufx\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case PRE_DEC:\n+      st[0] = \"--\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case PRE_INC:\n+      st[0] = \"++\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case POST_DEC:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"--\";\n+      break;\n+    case POST_INC:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"++\";\n+      break;\n+    case CALL:\n+      st[0] = \"call \";\n+      op[0] = XEXP (x, 0);\n+      if (verbose)\n+\t{\n+\t  st[1] = \" argc:\";\n+\t  op[1] = XEXP (x, 1);\n+\t}\n+      break;\n+    case IF_THEN_ELSE:\n+      st[0] = \"{(\";\n+      op[0] = XEXP (x, 0);\n+      st[1] = \")?\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \":\";\n+      op[2] = XEXP (x, 2);\n+      st[3] = \"}\";\n+      break;\n+    case TRAP_IF:\n+      fun = \"trap_if\";\n+      op[0] = TRAP_CONDITION (x);\n+      break;\n+    case UNSPEC:\n+    case UNSPEC_VOLATILE:\n+      {\n+\tcur = safe_concat (buf, cur, \"unspec\");\n+\tif (GET_CODE (x) == UNSPEC_VOLATILE)\n+\t  cur = safe_concat (buf, cur, \"/v\");\n+\tcur = safe_concat (buf, cur, \"[\");\n+\tsep = \"\";\n+\tfor (i = 0; i < XVECLEN (x, 0); i++)\n+\t  {\n+\t    print_pattern (tmp, XVECEXP (x, 0, i), verbose);\n+\t    cur = safe_concat (buf, cur, sep);\n+\t    cur = safe_concat (buf, cur, tmp);\n+\t    sep = \",\";\n+\t  }\n+\tcur = safe_concat (buf, cur, \"] \");\n+\tsprintf (tmp, \"%d\", XINT (x, 1));\n+\tcur = safe_concat (buf, cur, tmp);\n+      }\n+      break;\n+    default:\n+      /* If (verbose) debug_rtx (x);  */\n+      st[0] = GET_RTX_NAME (GET_CODE (x));\n+      break;\n+    }\n+\n+  /* Print this as a function?  */\n+  if (fun)\n+    {\n+      cur = safe_concat (buf, cur, fun);\n+      cur = safe_concat (buf, cur, \"(\");\n+    }\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (st[i])\n+\tcur = safe_concat (buf, cur, st[i]);\n+\n+      if (op[i])\n+\t{\n+\t  if (fun && i != 0)\n+\t    cur = safe_concat (buf, cur, \",\");\n+\n+\t  print_value (tmp, op[i], verbose);\n+\t  cur = safe_concat (buf, cur, tmp);\n+\t}\n+    }\n+\n+  if (fun)\n+    cur = safe_concat (buf, cur, \")\");\n+}\t\t/* print_exp */\n+\n+/* Prints rtxes, I customly classified as values.  They're constants,\n+   registers, labels, symbols and memory accesses.  */\n+\n+static void\n+print_value (buf, x, verbose)\n+     char *buf;\n+     rtx x;\n+     int verbose;\n+{\n+  char t[BUF_LEN];\n+  char *cur = buf;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+      sprintf (t, HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\n+      cur = safe_concat (buf, cur, t);\n+      break;\n+    case CONST_DOUBLE:\n+      sprintf (t, \"<0x%lx,0x%lx>\", (long) XWINT (x, 2), (long) XWINT (x, 3));\n+      cur = safe_concat (buf, cur, t);\n+      break;\n+    case CONST_STRING:\n+      cur = safe_concat (buf, cur, \"\\\"\");\n+      cur = safe_concat (buf, cur, XSTR (x, 0));\n+      cur = safe_concat (buf, cur, \"\\\"\");\n+      break;\n+    case SYMBOL_REF:\n+      cur = safe_concat (buf, cur, \"`\");\n+      cur = safe_concat (buf, cur, XSTR (x, 0));\n+      cur = safe_concat (buf, cur, \"'\");\n+      break;\n+    case LABEL_REF:\n+      sprintf (t, \"L%d\", INSN_UID (XEXP (x, 0)));\n+      cur = safe_concat (buf, cur, t);\n+      break;\n+    case CONST:\n+      print_value (t, XEXP (x, 0), verbose);\n+      cur = safe_concat (buf, cur, \"const(\");\n+      cur = safe_concat (buf, cur, t);\n+      cur = safe_concat (buf, cur, \")\");\n+      break;\n+    case HIGH:\n+      print_value (t, XEXP (x, 0), verbose);\n+      cur = safe_concat (buf, cur, \"high(\");\n+      cur = safe_concat (buf, cur, t);\n+      cur = safe_concat (buf, cur, \")\");\n+      break;\n+    case REG:\n+      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int c = reg_names[REGNO (x)][0];\n+\t  if (c >= '0' && c <= '9')\n+\t    cur = safe_concat (buf, cur, \"%\");\n+\n+\t  cur = safe_concat (buf, cur, reg_names[REGNO (x)]);\n+\t}\n+      else\n+\t{\n+\t  sprintf (t, \"r%d\", REGNO (x));\n+\t  cur = safe_concat (buf, cur, t);\n+\t}\n+      break;\n+    case SUBREG:\n+      print_value (t, SUBREG_REG (x), verbose);\n+      cur = safe_concat (buf, cur, t);\n+      sprintf (t, \"#%d\", SUBREG_WORD (x));\n+      cur = safe_concat (buf, cur, t);\n+      break;\n+    case SCRATCH:\n+      cur = safe_concat (buf, cur, \"scratch\");\n+      break;\n+    case CC0:\n+      cur = safe_concat (buf, cur, \"cc0\");\n+      break;\n+    case PC:\n+      cur = safe_concat (buf, cur, \"pc\");\n+      break;\n+    case MEM:\n+      print_value (t, XEXP (x, 0), verbose);\n+      cur = safe_concat (buf, cur, \"[\");\n+      cur = safe_concat (buf, cur, t);\n+      cur = safe_concat (buf, cur, \"]\");\n+      break;\n+    default:\n+      print_exp (t, x, verbose);\n+      cur = safe_concat (buf, cur, t);\n+      break;\n+    }\n+}\t\t\t\t/* print_value */\n+\n+/* The next step in insn detalization, its pattern recognition.  */\n+\n+static void\n+print_pattern (buf, x, verbose)\n+     char *buf;\n+     rtx x;\n+     int verbose;\n+{\n+  char t1[BUF_LEN], t2[BUF_LEN], t3[BUF_LEN];\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SET:\n+      print_value (t1, SET_DEST (x), verbose);\n+      print_value (t2, SET_SRC (x), verbose);\n+      sprintf (buf, \"%s=%s\", t1, t2);\n+      break;\n+    case RETURN:\n+      sprintf (buf, \"return\");\n+      break;\n+    case CALL:\n+      print_exp (buf, x, verbose);\n+      break;\n+    case CLOBBER:\n+      print_value (t1, XEXP (x, 0), verbose);\n+      sprintf (buf, \"clobber %s\", t1);\n+      break;\n+    case USE:\n+      print_value (t1, XEXP (x, 0), verbose);\n+      sprintf (buf, \"use %s\", t1);\n+      break;\n+    case COND_EXEC:\n+      if (GET_CODE (COND_EXEC_TEST (x)) == NE\n+\t  && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n+\tprint_value (t1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n+      else if (GET_CODE (COND_EXEC_TEST (x)) == EQ\n+               && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n+        {\n+\t  t1[0] = '!';\n+\t  print_value (t1 + 1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n+\t}\n+      else\n+        print_value (t1, COND_EXEC_TEST (x), verbose);\n+      print_pattern (t2, COND_EXEC_CODE (x), verbose);\n+      sprintf (buf, \"(%s) %s\", t1, t2);\n+      break;\n+    case PARALLEL:\n+      {\n+\tint i;\n+\n+\tsprintf (t1, \"{\");\n+\tfor (i = 0; i < XVECLEN (x, 0); i++)\n+\t  {\n+\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n+\t    sprintf (t3, \"%s%s;\", t1, t2);\n+\t    strcpy (t1, t3);\n+\t  }\n+\tsprintf (buf, \"%s}\", t1);\n+      }\n+      break;\n+    case SEQUENCE:\n+      {\n+\tint i;\n+\n+\tsprintf (t1, \"%%{\");\n+\tfor (i = 0; i < XVECLEN (x, 0); i++)\n+\t  {\n+\t    print_insn (t2, XVECEXP (x, 0, i), verbose);\n+\t    sprintf (t3, \"%s%s;\", t1, t2);\n+\t    strcpy (t1, t3);\n+\t  }\n+\tsprintf (buf, \"%s%%}\", t1);\n+      }\n+      break;\n+    case ASM_INPUT:\n+      sprintf (buf, \"asm {%s}\", XSTR (x, 0));\n+      break;\n+    case ADDR_VEC:\n+      break;\n+    case ADDR_DIFF_VEC:\n+      print_value (buf, XEXP (x, 0), verbose);\n+      break;\n+    case TRAP_IF:\n+      print_value (t1, TRAP_CONDITION (x), verbose);\n+      sprintf (buf, \"trap_if %s\", t1);\n+      break;\n+    case UNSPEC:\n+      {\n+\tint i;\n+\n+\tsprintf (t1, \"unspec{\");\n+\tfor (i = 0; i < XVECLEN (x, 0); i++)\n+\t  {\n+\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n+\t    sprintf (t3, \"%s%s;\", t1, t2);\n+\t    strcpy (t1, t3);\n+\t  }\n+\tsprintf (buf, \"%s}\", t1);\n+      }\n+      break;\n+    case UNSPEC_VOLATILE:\n+      {\n+\tint i;\n+\n+\tsprintf (t1, \"unspec/v{\");\n+\tfor (i = 0; i < XVECLEN (x, 0); i++)\n+\t  {\n+\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n+\t    sprintf (t3, \"%s%s;\", t1, t2);\n+\t    strcpy (t1, t3);\n+\t  }\n+\tsprintf (buf, \"%s}\", t1);\n+      }\n+      break;\n+    default:\n+      print_value (buf, x, verbose);\n+    }\n+}\t\t\t\t/* print_pattern */\n+\n+/* This is the main function in rtl visualization mechanism. It\n+   accepts an rtx and tries to recognize it as an insn, then prints it\n+   properly in human readable form, resembling assembler mnemonics.\n+   For every insn it prints its UID and BB the insn belongs too.\n+   (Probably the last \"option\" should be extended somehow, since it\n+   depends now on sched.c inner variables ...)  */\n+\n+static void\n+print_insn (buf, x, verbose)\n+     char *buf;\n+     rtx x;\n+     int verbose;\n+{\n+  char t[BUF_LEN];\n+  rtx insn = x;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case INSN:\n+      print_pattern (t, PATTERN (x), verbose);\n+      if (verbose)\n+\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (x, 1),\n+\t\t t);\n+      else\n+\tsprintf (buf, \"%-4d %s\", INSN_UID (x), t);\n+      break;\n+    case JUMP_INSN:\n+      print_pattern (t, PATTERN (x), verbose);\n+      if (verbose)\n+\tsprintf (buf, \"%s: jump %s\", (*current_sched_info->print_insn) (x, 1),\n+\t\t t);\n+      else\n+\tsprintf (buf, \"%-4d %s\", INSN_UID (x), t);\n+      break;\n+    case CALL_INSN:\n+      x = PATTERN (insn);\n+      if (GET_CODE (x) == PARALLEL)\n+\t{\n+\t  x = XVECEXP (x, 0, 0);\n+\t  print_pattern (t, x, verbose);\n+\t}\n+      else\n+\tstrcpy (t, \"call <...>\");\n+      if (verbose)\n+\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (x, 1), t);\n+      else\n+\tsprintf (buf, \"%-4d %s\", INSN_UID (insn), t);\n+      break;\n+    case CODE_LABEL:\n+      sprintf (buf, \"L%d:\", INSN_UID (x));\n+      break;\n+    case BARRIER:\n+      sprintf (buf, \"i% 4d: barrier\", INSN_UID (x));\n+      break;\n+    case NOTE:\n+      if (NOTE_LINE_NUMBER (x) > 0)\n+\tsprintf (buf, \"%4d note \\\"%s\\\" %d\", INSN_UID (x),\n+\t\t NOTE_SOURCE_FILE (x), NOTE_LINE_NUMBER (x));\n+      else\n+\tsprintf (buf, \"%4d %s\", INSN_UID (x),\n+\t\t GET_NOTE_INSN_NAME (NOTE_LINE_NUMBER (x)));\n+      break;\n+    default:\n+      if (verbose)\n+\t{\n+\t  sprintf (buf, \"Not an INSN at all\\n\");\n+\t  debug_rtx (x);\n+\t}\n+      else\n+\tsprintf (buf, \"i%-4d  <What?>\", INSN_UID (x));\n+    }\n+}\t\t\t\t/* print_insn */\n+\n+/* Print visualization debugging info.  */\n+\n+void\n+print_block_visualization (s)\n+     const char *s;\n+{\n+  int unit, i;\n+\n+  /* Print header.  */\n+  fprintf (sched_dump, \"\\n;;   ==================== scheduling visualization %s \\n\", s);\n+\n+  /* Print names of units.  */\n+  fprintf (sched_dump, \";;   %-8s\", \"clock\");\n+  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n+    if (function_units[unit].bitmask & target_units)\n+      for (i = 0; i < function_units[unit].multiplicity; i++)\n+\tfprintf (sched_dump, \"  %-33s\", function_units[unit].name);\n+  fprintf (sched_dump, \"  %-8s\\n\", \"no-unit\");\n+\n+  fprintf (sched_dump, \";;   %-8s\", \"=====\");\n+  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n+    if (function_units[unit].bitmask & target_units)\n+      for (i = 0; i < function_units[unit].multiplicity; i++)\n+\tfprintf (sched_dump, \"  %-33s\", \"==============================\");\n+  fprintf (sched_dump, \"  %-8s\\n\", \"=======\");\n+\n+  /* Print insns in each cycle.  */\n+  fprintf (sched_dump, \"%s\\n\", visual_tbl);\n+}\n+\n+/* Print insns in the 'no_unit' column of visualization.  */\n+\n+void\n+visualize_no_unit (insn)\n+     rtx insn;\n+{\n+  vis_no_unit[n_vis_no_unit] = insn;\n+  n_vis_no_unit++;\n+}\n+\n+/* Print insns scheduled in clock, for visualization.  */\n+\n+void\n+visualize_scheduled_insns (clock)\n+     int clock;\n+{\n+  int i, unit;\n+\n+  /* If no more room, split table into two.  */\n+  if (n_visual_lines >= MAX_VISUAL_LINES)\n+    {\n+      print_block_visualization (\"(incomplete)\");\n+      init_block_visualization ();\n+    }\n+\n+  n_visual_lines++;\n+\n+  sprintf (visual_tbl + strlen (visual_tbl), \";;   %-8d\", clock);\n+  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n+    if (function_units[unit].bitmask & target_units)\n+      for (i = 0; i < function_units[unit].multiplicity; i++)\n+\t{\n+\t  int instance = unit + i * FUNCTION_UNITS_SIZE;\n+\t  rtx insn = get_unit_last_insn (instance);\n+\n+\t  /* Print insns that still keep the unit busy.  */\n+\t  if (insn\n+\t      && actual_hazard_this_instance (unit, instance, insn, clock, 0))\n+\t    {\n+\t      char str[BUF_LEN];\n+\t      print_insn (str, insn, 0);\n+\t      str[INSN_LEN] = '\\0';\n+\t      sprintf (visual_tbl + strlen (visual_tbl), \"  %-33s\", str);\n+\t    }\n+\t  else\n+\t    sprintf (visual_tbl + strlen (visual_tbl), \"  %-33s\", \"------------------------------\");\n+\t}\n+\n+  /* Print insns that are not assigned to any unit.  */\n+  for (i = 0; i < n_vis_no_unit; i++)\n+    sprintf (visual_tbl + strlen (visual_tbl), \"  %-8d\",\n+\t     INSN_UID (vis_no_unit[i]));\n+  n_vis_no_unit = 0;\n+\n+  sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n+}\n+\n+/* Print stalled cycles.  */\n+\n+void\n+visualize_stall_cycles (stalls)\n+     int stalls;\n+{\n+  int i;\n+\n+  /* If no more room, split table into two.  */\n+  if (n_visual_lines >= MAX_VISUAL_LINES)\n+    {\n+      print_block_visualization (\"(incomplete)\");\n+      init_block_visualization ();\n+    }\n+\n+  n_visual_lines++;\n+\n+  sprintf (visual_tbl + strlen (visual_tbl), \";;       \");\n+  for (i = 0; i < stalls; i++)\n+    sprintf (visual_tbl + strlen (visual_tbl), \".\");\n+  sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n+}\n+\n+/* Allocate data used for visualization during scheduling.  */\n+\n+void\n+visualize_alloc ()\n+{\n+  visual_tbl = xmalloc (get_visual_tbl_length ());\n+}\n+\n+/* Free data used for visualization.  */\n+\n+void\n+visualize_free ()\n+{\n+  free (visual_tbl);\n+}"}]}