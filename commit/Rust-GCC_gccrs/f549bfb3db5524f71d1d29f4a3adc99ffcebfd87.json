{"sha": "f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU0OWJmYjNkYjU1MjRmNzFkMWQyOWY0YTNhZGM5OWZmY2ViZmQ4Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-01-01T17:36:41Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-01-01T17:36:41Z"}, "message": "re PR fortran/83076 (ICE in gfc_deallocate_scalar_with_status, at fortran/trans.c:1598)\n\n2018-01-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/83076\n\t* resolve.c (resolve_fl_derived0): Add caf_token fields for\n\tallocatable and pointer scalars, when -fcoarray selected.\n\t* trans-types.c (gfc_copy_dt_decls_ifequal): Copy the token\n\tfield as well as the backend_decl.\n\t(gfc_get_derived_type): Flag GFC_FCOARRAY_LIB for module\n\tderived types that are not vtypes. Components with caf_token\n\tattribute are pvoid types. For a component requiring it, find\n\tthe caf_token field and have the component token field point to\n\tits backend_decl.\n\n\tPR fortran/83319\n\t*trans-types.c (gfc_get_array_descriptor_base): Add the token\n\tfield to the descriptor even when codimen not set.\n\n\n2018-01-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/83076\n\t* gfortran.dg/coarray_45.f90 : New test.\n\n\tPR fortran/83319\n\t* gfortran.dg/coarray_46.f90 : New test.\n\nFrom-SVN: r256065", "tree": {"sha": "458601ba76bd1b82c6cbf785c4a8da76fd5f1cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/458601ba76bd1b82c6cbf785c4a8da76fd5f1cb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/comments", "author": null, "committer": null, "parents": [{"sha": "3a60f9fd1af9554ab1a032df0af6cb0e1eefca60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a60f9fd1af9554ab1a032df0af6cb0e1eefca60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a60f9fd1af9554ab1a032df0af6cb0e1eefca60"}], "stats": {"total": 135, "additions": 119, "deletions": 16}, "files": [{"sha": "ad2ff35b610503c2f0c4e0e544e223d141272aa0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "patch": "@@ -1,3 +1,20 @@\n+2018-01-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/83076\n+\t* resolve.c (resolve_fl_derived0): Add caf_token fields for\n+\tallocatable and pointer scalars, when -fcoarray selected.\n+\t* trans-types.c (gfc_copy_dt_decls_ifequal): Copy the token\n+\tfield as well as the backend_decl.\n+\t(gfc_get_derived_type): Flag GFC_FCOARRAY_LIB for module\n+\tderived types that are not vtypes. Components with caf_token\n+\tattribute are pvoid types. For a component requiring it, find\n+\tthe caf_token field and have the component token field point to\n+\tits backend_decl.\n+\n+\tPR fortran/83319\n+\t*trans-types.c (gfc_get_array_descriptor_base): Add the token\n+\tfield to the descriptor even when codimen not set.\n+\n 2017-12-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR Fortran/83548"}, {"sha": "662d34f7c0aefac1f720e9ba8b115000160d8ac2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "patch": "@@ -870,7 +870,7 @@ typedef struct\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n \t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,\n \t   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1,\n-\t   has_dtio_procs:1;\n+\t   has_dtio_procs:1, caf_token:1;\n \n   /* This is a temporary selector for SELECT TYPE or an associate\n      variable for SELECT_TYPE or ASSOCIATE.  */"}, {"sha": "c1d8a426dc9d3ed6a640719c6c7cf2e485e086f3", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "patch": "@@ -13993,6 +13993,31 @@ resolve_fl_derived0 (gfc_symbol *sym)\n   if (!success)\n     return false;\n \n+  /* Now add the caf token field, where needed.  */\n+  if (flag_coarray != GFC_FCOARRAY_NONE\n+      && !sym->attr.is_class && !sym->attr.vtype)\n+    {\n+      for (c = sym->components; c; c = c->next)\n+\tif (!c->attr.dimension && !c->attr.codimension\n+\t    && (c->attr.allocatable || c->attr.pointer))\n+\t  {\n+\t    char name[GFC_MAX_SYMBOL_LEN+9];\n+\t    gfc_component *token;\n+\t    sprintf (name, \"_caf_%s\", c->name);\n+\t    token = gfc_find_component (sym, name, true, true, NULL);\n+\t    if (token == NULL)\n+\t      {\n+\t\tif (!gfc_add_component (sym, name, &token))\n+\t\t  return false;\n+\t\ttoken->ts.type = BT_VOID;\n+\t\ttoken->ts.kind = gfc_default_integer_kind;\n+\t\ttoken->attr.access = ACCESS_PRIVATE;\n+\t\ttoken->attr.artificial = 1;\n+\t\ttoken->attr.caf_token = 1;\n+\t      }\n+\t  }\n+    }\n+\n   check_defined_assignments (sym);\n \n   if (!sym->attr.defined_assign_comp && super_type)"}, {"sha": "73f75ccf58be92da987a54338b22c813b32c8499", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "patch": "@@ -1837,7 +1837,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n       TREE_NO_WARNING (decl) = 1;\n     }\n \n-  if (flag_coarray == GFC_FCOARRAY_LIB && codimen)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       decl = gfc_add_field_to_struct_1 (fat_type,\n \t\t\t\t\tget_identifier (\"token\"),\n@@ -2373,6 +2373,7 @@ gfc_copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to,\n   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)\n     {\n       to_cm->backend_decl = from_cm->backend_decl;\n+      to_cm->caf_token = from_cm->caf_token;\n       if (from_cm->ts.type == BT_UNION)\n         gfc_get_union_type (to_cm->ts.u.derived);\n       else if (from_cm->ts.type == BT_DERIVED\n@@ -2483,6 +2484,10 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n   gfc_dt_list *dt;\n   gfc_namespace *ns;\n   tree tmp;\n+  bool coarray_flag;\n+\n+  coarray_flag = flag_coarray == GFC_FCOARRAY_LIB\n+\t\t && derived->module && !derived->attr.vtype;\n \n   gcc_assert (!derived->attr.pdt_template);\n \n@@ -2677,7 +2682,9 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n \t  field_type = build_pointer_type (tmp);\n \t}\n       else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n-        field_type = c->ts.u.derived->backend_decl;\n+\tfield_type = c->ts.u.derived->backend_decl;\n+      else if (c->attr.caf_token)\n+\tfield_type = pvoid_type_node;\n       else\n \t{\n \t  if (c->ts.type == BT_CHARACTER\n@@ -2762,19 +2769,6 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n \t  && !(c->ts.type == BT_DERIVED\n \t       && strcmp (c->name, \"_data\") == 0))\n \tGFC_DECL_PTR_ARRAY_P (c->backend_decl) = 1;\n-\n-      /* Do not add a caf_token field for classes' data components.  */\n-      if (codimen && !c->attr.dimension && !c->attr.codimension\n-\t  && (c->attr.allocatable || c->attr.pointer)\n-\t  && c->caf_token == NULL_TREE && strcmp (\"_data\", c->name) != 0)\n-\t{\n-\t  char caf_name[GFC_MAX_SYMBOL_LEN];\n-\t  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, \"_caf_%s\", c->name);\n-\t  c->caf_token = gfc_add_field_to_struct (typenode,\n-\t\t\t\t\t\t  get_identifier (caf_name),\n-\t\t\t\t\t\t  pvoid_type_node, &chain);\n-\t  TREE_NO_WARNING (c->caf_token) = 1;\n-\t}\n     }\n \n   /* Now lay out the derived type, including the fields.  */\n@@ -2800,6 +2794,24 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n \n copy_derived_types:\n \n+  for (c = derived->components; c; c = c->next)\n+    {\n+      /* Do not add a caf_token field for class container components.  */\n+      if ((codimen || coarray_flag)\n+\t  && !c->attr.dimension && !c->attr.codimension\n+\t  && (c->attr.allocatable || c->attr.pointer)\n+\t  && !derived->attr.is_class)\n+\t{\n+\t  char caf_name[GFC_MAX_SYMBOL_LEN];\n+\t  gfc_component *token;\n+\t  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, \"_caf_%s\", c->name);\n+\t  token = gfc_find_component (derived, caf_name, true, true, NULL);\n+\t  gcc_assert (token);\n+\t  c->caf_token = token->backend_decl;\n+\t  TREE_NO_WARNING (c->caf_token) = 1;\n+\t}\n+    }\n+\n   for (dt = gfc_derived_types; dt; dt = dt->next)\n     gfc_copy_dt_decls_ifequal (derived, dt->derived, false);\n "}, {"sha": "e4dd14f7e15186b9407a320d4bc89df13dbcccb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "patch": "@@ -1,3 +1,11 @@\n+2018-01-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/83076\n+\t* gfortran.dg/coarray_45.f90 : New test.\n+\n+\tPR fortran/83319\n+\t* gfortran.dg/coarray_46.f90 : New test.\n+\n 2018-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/83581"}, {"sha": "87763563efe84a1d7ffb1b2d3eb0f5bdc04d0b55", "filename": "gcc/testsuite/gfortran.dg/coarray_45.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_45.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_45.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_45.f90?ref=f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -lcaf_single \" }\n+!\n+! Test the fix for PR83076\n+!\n+module m\n+   type t\n+      integer, pointer :: z\n+   end type\n+   type(t) :: ptr\n+contains\n+   function g(x)\n+      type(t) :: x[*]\n+      if (associated (x%z, ptr%z)) deallocate (x%z) ! This used to ICE with -fcoarray=lib\n+   end\n+end module\n+\n+  use m\n+contains\n+   function f(x)\n+      type(t) :: x[*]\n+      if (associated (x%z, ptr%z)) deallocate (x%z)\n+   end\n+end"}, {"sha": "273c6e86840d889aced074e00d9c503a8e5fdad1", "filename": "gcc/testsuite/gfortran.dg/coarray_46.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_46.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f549bfb3db5524f71d1d29f4a3adc99ffcebfd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_46.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_46.f90?ref=f549bfb3db5524f71d1d29f4a3adc99ffcebfd87", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+!\n+! Test the fix for PR83319\n+!\n+module foo_module\n+  implicit none\n+  type foo\n+    integer, allocatable :: i(:)\n+  end type\n+end module\n+\n+  use foo_module\n+  implicit none\n+  type(foo), save :: bar[*]\n+  allocate(bar%i(1))     ! Used to ICE here.\n+end"}]}