{"sha": "36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZmNGJjOWNlODIzNjM4MjBjZTNhYWM0YmIzZjdmYmZkZWVmMTY2Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-17T12:37:30Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-17T12:37:30Z"}, "message": "cp-tree.h (ovl_iterator::using_p): New predicate.\n\n\t* cp-tree.h (ovl_iterator::using_p): New predicate.\n\t(ovl_iterator::remove_node): New worker.\n\t(ovl_insert): Declare.\n\t* tree.c (ovl_insert): New.\n\t(ovl_iterator::remove_node): New.\n\t* class.c (add_method): Use ovl_iterator, ovl_insert.\n\t(clone_function_decl): Fix description.\n\t(clone_constructors_and_destructors): Use ovl_iterator.\n\nFrom-SVN: r248151", "tree": {"sha": "7f697bfed6d1dcc1a532bb1f77b8e4df25bcfdf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f697bfed6d1dcc1a532bb1f77b8e4df25bcfdf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19b476fb8de6533a76db72b04db6421857fa9fcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b476fb8de6533a76db72b04db6421857fa9fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b476fb8de6533a76db72b04db6421857fa9fcf"}], "stats": {"total": 152, "additions": 110, "deletions": 42}, "files": [{"sha": "7136b5d8946e4c18bc4f751f9d0d9be8c07c7e6f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "patch": "@@ -1,5 +1,14 @@\n 2017-05-17  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (ovl_iterator::using_p): New predicate.\n+\t(ovl_iterator::remove_node): New worker.\n+\t(ovl_insert): Declare.\n+\t* tree.c (ovl_insert): New.\n+\t(ovl_iterator::remove_node): New.\n+\t* class.c (add_method): Use ovl_iterator, ovl_insert.\n+\t(clone_function_decl): Fix description.\n+\t(clone_constructors_and_destructors): Use ovl_iterator.\n+\n \t* class.c (handle_using_decl): Use OVL_FIRST, ovl_iterator.\n \t(maybe_warn_about_overly_private_class): Use ovl_iterator.\n \t(method_name_cmp, resort_method_name_cmp): Use OVL_NAME."}, {"sha": "6f3f3e6eea93faeb01e4b9b34b2f4bbbcf52dd65", "filename": "gcc/cp/class.c", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "patch": "@@ -1010,7 +1010,6 @@ bool\n add_method (tree type, tree method, bool via_using)\n {\n   unsigned slot;\n-  tree overload;\n   bool template_conv_p = false;\n   bool conv_p;\n   vec<tree, va_gc> *method_vec;\n@@ -1059,7 +1058,7 @@ add_method (tree type, tree method, bool via_using)\n \t   vec_safe_iterate (method_vec, slot, &m);\n \t   ++slot)\n \t{\n-\t  m = OVL_CURRENT (m);\n+\t  m = OVL_FIRST (m);\n \t  if (template_conv_p)\n \t    {\n \t      if (TREE_CODE (m) == TEMPLATE_DECL\n@@ -1083,24 +1082,23 @@ add_method (tree type, tree method, bool via_using)\n   current_fns = insert_p ? NULL_TREE : (*method_vec)[slot];\n \n   /* Check to see if we've already got this method.  */\n-  for (tree *p = &current_fns; *p; )\n+  for (ovl_iterator iter (current_fns); iter; ++iter)\n     {\n-      tree fns = *p;\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       tree fn_type;\n       tree method_type;\n       tree parms1;\n       tree parms2;\n \n       if (TREE_CODE (fn) != TREE_CODE (method))\n-\tgoto cont;\n+\tcontinue;\n \n       /* Two using-declarations can coexist, we'll complain about ambiguity in\n \t overload resolution.  */\n-      if (via_using && TREE_CODE (fns) == OVERLOAD && OVL_USED (fns)\n+      if (via_using && iter.using_p ()\n \t  /* Except handle inherited constructors specially.  */\n \t  && ! DECL_CONSTRUCTOR_P (fn))\n-\tgoto cont;\n+\tcontinue;\n \n       /* [over.load] Member function declarations with the\n \t same name and the same parameter types cannot be\n@@ -1134,7 +1132,7 @@ add_method (tree type, tree method, bool via_using)\n \t      == FUNCTION_REF_QUALIFIED (method_type))\n \t  && (type_memfn_quals (fn_type) != type_memfn_quals (method_type)\n \t      || type_memfn_rqual (fn_type) != type_memfn_rqual (method_type)))\n-\t  goto cont;\n+\t  continue;\n \n       /* For templates, the return type and template parameters\n \t must be identical.  */\n@@ -1143,7 +1141,7 @@ add_method (tree type, tree method, bool via_using)\n \t\t\t    TREE_TYPE (method_type))\n \t      || !comp_template_parms (DECL_TEMPLATE_PARMS (fn),\n \t\t\t\t       DECL_TEMPLATE_PARMS (method))))\n-\tgoto cont;\n+\tcontinue;\n \n       if (! DECL_STATIC_FUNCTION_P (fn))\n \tparms1 = TREE_CHAIN (parms1);\n@@ -1187,8 +1185,9 @@ add_method (tree type, tree method, bool via_using)\n \t\t    mangle_decl (method);\n \t\t}\n \t      cgraph_node::record_function_versions (fn, method);\n-\t      goto cont;\n+\t      continue;\n \t    }\n+\n \t  if (DECL_INHERITED_CTOR (method))\n \t    {\n \t      if (DECL_INHERITED_CTOR (fn))\n@@ -1202,15 +1201,15 @@ add_method (tree type, tree method, bool via_using)\n \t\t\t  /* Inheriting the same constructor along different\n \t\t\t     paths, combine them.  */\n \t\t\t  SET_DECL_INHERITED_CTOR\n-\t\t\t    (fn, ovl_cons (DECL_INHERITED_CTOR (method),\n+\t\t\t    (fn, ovl_make (DECL_INHERITED_CTOR (method),\n \t\t\t\t\t   DECL_INHERITED_CTOR (fn)));\n \t\t\t  /* And discard the new one.  */\n \t\t\t  return false;\n \t\t\t}\n \t\t      else\n \t\t\t/* Inherited ctors can coexist until overload\n \t\t\t   resolution.  */\n-\t\t\tgoto cont;\n+\t\t\tcontinue;\n \t\t    }\n \t\t  error_at (DECL_SOURCE_LOCATION (method),\n \t\t\t    \"%q#D\", method);\n@@ -1228,8 +1227,8 @@ add_method (tree type, tree method, bool via_using)\n \t  else if (flag_new_inheriting_ctors\n \t\t   && DECL_INHERITED_CTOR (fn))\n \t    {\n-\t      /* Hide the inherited constructor.  */\n-\t      *p = OVL_NEXT (fns);\n+\t      /* Remove the inherited constructor.  */\n+\t      current_fns = iter.remove_node (current_fns);\n \t      continue;\n \t    }\n \t  else\n@@ -1238,33 +1237,19 @@ add_method (tree type, tree method, bool via_using)\n \t      error (\"with %q+#D\", fn);\n \t      return false;\n \t    }\n-\n \t}\n-\n-    cont:\n-      if (TREE_CODE (fns) == OVERLOAD)\n-\tp = &OVL_CHAIN (fns);\n-      else\n-\tbreak;\n     }\n \n   /* A class should never have more than one destructor.  */\n   if (current_fns && DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n     return false;\n \n-  /* Add the new binding.  */\n-  if (via_using)\n-    {\n-      overload = ovl_cons (method, current_fns);\n-      OVL_USED (overload) = true;\n-    }\n-  else\n-    overload = build_overload (method, current_fns);\n+  current_fns = ovl_insert (method, current_fns, via_using);\n \n   if (conv_p)\n     TYPE_HAS_CONVERSION (type) = 1;\n   else if (slot >= CLASSTYPE_FIRST_CONVERSION_SLOT && !complete_p)\n-    push_class_level_binding (DECL_NAME (method), overload);\n+    push_class_level_binding (DECL_NAME (method), current_fns);\n \n   if (insert_p)\n     {\n@@ -1279,13 +1264,13 @@ add_method (tree type, tree method, bool via_using)\n       if (reallocated)\n \tCLASSTYPE_METHOD_VEC (type) = method_vec;\n       if (slot == method_vec->length ())\n-\tmethod_vec->quick_push (overload);\n+\tmethod_vec->quick_push (current_fns);\n       else\n-\tmethod_vec->quick_insert (slot, overload);\n+\tmethod_vec->quick_insert (slot, current_fns);\n     }\n   else\n     /* Replace the current slot.  */\n-    (*method_vec)[slot] = overload;\n+    (*method_vec)[slot] = current_fns;\n   return true;\n }\n \n@@ -4873,8 +4858,7 @@ decl_cloned_function_p (const_tree decl, bool just_testing)\n \n /* Produce declarations for all appropriate clones of FN.  If\n    UPDATE_METHODS is true, the clones are added to the\n-   CLASTYPE_METHOD_VEC.  VIA_USING indicates whether these are cloning\n-   decls brought in via using declarations (i.e. inheriting ctors).  */\n+   CLASSTYPE_METHOD_VEC.  */\n \n void\n clone_function_decl (tree fn, bool update_methods)\n@@ -5017,19 +5001,17 @@ adjust_clone_args (tree decl)\n static void\n clone_constructors_and_destructors (tree t)\n {\n-  tree fns;\n-\n   /* If for some reason we don't have a CLASSTYPE_METHOD_VEC, we bail\n      out now.  */\n   if (!CLASSTYPE_METHOD_VEC (t))\n     return;\n \n   /* While constructors can be via a using declaration, at this point\n      we no longer need to know that.  */\n-  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-    clone_function_decl (OVL_CURRENT (fns), /*update_methods=*/true);\n-  for (fns = CLASSTYPE_DESTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-    clone_function_decl (OVL_CURRENT (fns), /*update_methods=*/true);\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+    clone_function_decl (*iter, /*update_methods=*/true);\n+  for (ovl_iterator iter (CLASSTYPE_DESTRUCTORS (t)); iter; ++iter)\n+    clone_function_decl (*iter, /*update_methods=*/true);\n }\n \n /* Deduce noexcept for a destructor DTOR.  */"}, {"sha": "942ac6195b6df694c116a2de6fa4a0b101711c23", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "patch": "@@ -680,6 +680,22 @@ class ovl_iterator\n \n     return fn;\n   }\n+\n+ public:\n+  /* Whether this overload was introduced by a using decl.  */\n+  bool using_p () const\n+  {\n+    return TREE_CODE (ovl) == OVERLOAD && OVL_USED (ovl);\n+  }\n+  tree remove_node (tree head)\n+  {\n+    return remove_node (head, ovl);\n+  }\n+\n+ private:\n+  /* We make this a static function to avoid the address of the\n+     iterator escaping the local context.  */\n+  static tree remove_node (tree head, tree node);\n };\n \n /* Iterator over a (potentially) 2 dimensional overload, which is\n@@ -6768,6 +6784,8 @@ extern tree build_ref_qualified_type\t\t(tree, cp_ref_qualifier);\n inline tree ovl_first\t\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree ovl_make\t\t\t\t(tree fn,\n \t\t\t\t\t\t tree next = NULL_TREE);\n+extern tree ovl_insert\t\t\t\t(tree fn, tree maybe_ovl,\n+\t\t\t\t\t\t bool using_p = false);\n extern tree lookup_add\t\t\t\t(tree lookup, tree ovl);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree dependent_name\t\t\t(tree);"}, {"sha": "7ea6ce2e37b0f92eefac1b2b11d87cee3897dd21", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "patch": "@@ -2124,6 +2124,65 @@ ovl_make (tree fn, tree next)\n   return result;\n }\n \n+/* Add FN to the (potentially NULL) overload set OVL.  USING_P is\n+   true, if FN is via a using declaration.  Overloads are ordered as\n+   using, regular.  */\n+\n+tree\n+ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n+{\n+  int weight = using_p;\n+\n+  tree result = NULL_TREE;\n+  tree insert_after = NULL_TREE;\n+\n+  /* Find insertion point.  */\n+  while (maybe_ovl && TREE_CODE (maybe_ovl) == OVERLOAD\n+\t && (weight < OVL_USED (maybe_ovl)))\n+    {\n+      if (!result)\n+\tresult = maybe_ovl;\n+      insert_after = maybe_ovl;\n+      maybe_ovl = OVL_CHAIN (maybe_ovl);\n+    }\n+\n+  tree trail = fn;\n+  if (maybe_ovl || using_p || TREE_CODE (fn) == TEMPLATE_DECL)\n+    {\n+      trail = ovl_make (fn, maybe_ovl);\n+      if (using_p)\n+\tOVL_USED (trail) = true;\n+    }\n+\n+  if (insert_after)\n+    {\n+      TREE_CHAIN (insert_after) = trail;\n+      TREE_TYPE (insert_after) = unknown_type_node;\n+    }\n+  else\n+    result = trail;\n+\n+  return result;\n+}\n+\n+/* NODE is on the overloads of OVL.  Remove it.  */\n+\n+tree\n+ovl_iterator::remove_node (tree overload, tree node)\n+{\n+  tree *slot = &overload;\n+  while (*slot != node)\n+    slot = &OVL_CHAIN (*slot);\n+\n+  /* Stitch out NODE.  We don't have to worry about now making a\n+     singleton overload (and consequently maybe setting its type),\n+     because all uses of this function will be followed by inserting a\n+     new node that must follow the place we've cut this out from.  */\n+  *slot = OVL_CHAIN (node);\n+\n+  return overload;\n+}\n+\n /* Add a potential overload into a lookup set.  */\n \n tree"}]}