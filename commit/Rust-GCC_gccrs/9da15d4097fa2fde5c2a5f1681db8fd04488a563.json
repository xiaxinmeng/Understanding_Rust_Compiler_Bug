{"sha": "9da15d4097fa2fde5c2a5f1681db8fd04488a563", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRhMTVkNDA5N2ZhMmZkZTVjMmE1ZjE2ODFkYjhmZDA0NDg4YTU2Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-05T19:57:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-05T19:57:39Z"}, "message": "Make mode_for_vector return an opt_mode\n\n...following on from the mode_for_size change.  The patch also removes\nmachmode.h versions of the stor-layout.c comments, since the comments\nin the .c file are more complete.\n\n2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* machmode.h (mode_for_vector): Return an opt_mode.\n\t* stor-layout.c (mode_for_vector): Likewise.\n\t(mode_for_int_vector): Update accordingly.\n\t(layout_type): Likewise.\n\t* config/i386/i386.c (emit_memmov): Likewise.\n\t(ix86_expand_set_or_movmem): Likewise.\n\t(ix86_expand_vector_init): Likewise.\n\t(ix86_get_mask_mode): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_expand_vec_perm_const_1):\n\tLikewise.\n\t* config/rs6000/rs6000.c (rs6000_expand_vec_perm_const_1): Likewise.\n\t* expmed.c (extract_bit_field_1): Likewise.\n\t* expr.c (expand_expr_real_2): Likewise.\n\t* optabs-query.c (can_vec_perm_p): Likewise.\n\t(can_vec_mask_load_store_p): Likewise.\n\t* optabs.c (expand_vec_perm): Likewise.\n\t* targhooks.c (default_get_mask_mode): Likewise.\n\t* tree-vect-stmts.c (vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(get_vectype_for_scalar_type_and_size): Likewise.\n\nFrom-SVN: r251730", "tree": {"sha": "4f9be4daf0cecba38b9ccc0040c50f9f84bf3f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f9be4daf0cecba38b9ccc0040c50f9f84bf3f6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9da15d4097fa2fde5c2a5f1681db8fd04488a563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9da15d4097fa2fde5c2a5f1681db8fd04488a563", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9da15d4097fa2fde5c2a5f1681db8fd04488a563", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9da15d4097fa2fde5c2a5f1681db8fd04488a563/comments", "author": null, "committer": null, "parents": [{"sha": "ddc203a7b15306287792a3eed6abfe306e3d26ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc203a7b15306287792a3eed6abfe306e3d26ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc203a7b15306287792a3eed6abfe306e3d26ad"}], "stats": {"total": 165, "additions": 86, "deletions": 79}, "files": [{"sha": "067040bc98ec5a56027bea7601e859a000dfb459", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -1,3 +1,26 @@\n+2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* machmode.h (mode_for_vector): Return an opt_mode.\n+\t* stor-layout.c (mode_for_vector): Likewise.\n+\t(mode_for_int_vector): Update accordingly.\n+\t(layout_type): Likewise.\n+\t* config/i386/i386.c (emit_memmov): Likewise.\n+\t(ix86_expand_set_or_movmem): Likewise.\n+\t(ix86_expand_vector_init): Likewise.\n+\t(ix86_get_mask_mode): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_expand_vec_perm_const_1):\n+\tLikewise.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vec_perm_const_1): Likewise.\n+\t* expmed.c (extract_bit_field_1): Likewise.\n+\t* expr.c (expand_expr_real_2): Likewise.\n+\t* optabs-query.c (can_vec_perm_p): Likewise.\n+\t(can_vec_mask_load_store_p): Likewise.\n+\t* optabs.c (expand_vec_perm): Likewise.\n+\t* targhooks.c (default_get_mask_mode): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(get_vectype_for_scalar_type_and_size): Likewise.\n+\n 2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* machmode.h (mode_for_int_vector): New function."}, {"sha": "8c17da24c1d31face574aa4008bef1257bab95e0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -27536,9 +27536,8 @@ emit_memmov (rtx destmem, rtx *srcmem, rtx destptr, rtx srcptr,\n   if (GET_MODE_SIZE (move_mode) > GET_MODE_SIZE (word_mode))\n     {\n       int nunits = GET_MODE_SIZE (move_mode) / GET_MODE_SIZE (word_mode);\n-      move_mode = mode_for_vector (word_mode, nunits);\n-      code = optab_handler (mov_optab, move_mode);\n-      if (code == CODE_FOR_nothing)\n+      if (!mode_for_vector (word_mode, nunits).exists (&move_mode)\n+\t  || (code = optab_handler (mov_optab, move_mode)) == CODE_FOR_nothing)\n \t{\n \t  move_mode = word_mode;\n \t  piece_size = GET_MODE_SIZE (move_mode);\n@@ -28770,8 +28769,8 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n       if (GET_MODE_SIZE (move_mode) > GET_MODE_SIZE (word_mode))\n \t{\n \t  int nunits = GET_MODE_SIZE (move_mode) / GET_MODE_SIZE (word_mode);\n-\t  move_mode = mode_for_vector (word_mode, nunits);\n-\t  if (optab_handler (mov_optab, move_mode) == CODE_FOR_nothing)\n+\t  if (!mode_for_vector (word_mode, nunits).exists (&move_mode)\n+\t      || optab_handler (mov_optab, move_mode) == CODE_FOR_nothing)\n \t    move_mode = word_mode;\n \t}\n       gcc_assert (optab_handler (mov_optab, move_mode) != CODE_FOR_nothing);\n@@ -44613,11 +44612,9 @@ ix86_expand_vector_init (bool mmx_ok, rtx target, rtx vals)\n \t  rtx ops[2] = { XVECEXP (vals, 0, 0), XVECEXP (vals, 0, 1) };\n \t  if (inner_mode == QImode || inner_mode == HImode)\n \t    {\n-\t      mode = mode_for_vector (SImode,\n-\t\t\t\t      n_elts * GET_MODE_SIZE (inner_mode) / 4);\n-\t      inner_mode\n-\t\t= mode_for_vector (SImode,\n-\t\t\t\t   n_elts * GET_MODE_SIZE (inner_mode) / 8);\n+\t      unsigned int n_bits = n_elts * GET_MODE_SIZE (inner_mode);\n+\t      mode = mode_for_vector (SImode, n_bits / 4).require ();\n+\t      inner_mode = mode_for_vector (SImode, n_bits / 8).require ();\n \t      ops[0] = gen_lowpart (inner_mode, ops[0]);\n \t      ops[1] = gen_lowpart (inner_mode, ops[1]);\n \t      subtarget = gen_reg_rtx (mode);\n@@ -51735,7 +51732,7 @@ ix86_get_mask_mode (unsigned nunits, unsigned vector_size)\n \n   gcc_assert (elem_size * nunits == vector_size);\n \n-  return mode_for_vector (elem_mode, nunits);\n+  return mode_for_vector (elem_mode, nunits).else_blk ();\n }\n \n \f"}, {"sha": "b964e6ed776bf569ba2c72333430daef1997995f", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -38679,7 +38679,7 @@ rs6000_expand_vec_perm_const_1 (rtx target, rtx op0, rtx op1,\n \n       vmode = GET_MODE (target);\n       gcc_assert (GET_MODE_NUNITS (vmode) == 2);\n-      dmode = mode_for_vector (GET_MODE_INNER (vmode), 4);\n+      dmode = mode_for_vector (GET_MODE_INNER (vmode), 4).require ();\n       x = gen_rtx_VEC_CONCAT (dmode, op0, op1);\n       v = gen_rtvec (2, GEN_INT (perm0), GEN_INT (perm1));\n       x = gen_rtx_VEC_SELECT (vmode, x, gen_rtx_PARALLEL (VOIDmode, v));"}, {"sha": "6d613c38b757cd76229b2c0add41ffac8ff939e1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -35525,7 +35525,7 @@ rs6000_expand_vec_perm_const_1 (rtx target, rtx op0, rtx op1,\n \n       vmode = GET_MODE (target);\n       gcc_assert (GET_MODE_NUNITS (vmode) == 2);\n-      dmode = mode_for_vector (GET_MODE_INNER (vmode), 4);\n+      dmode = mode_for_vector (GET_MODE_INNER (vmode), 4).require ();\n       x = gen_rtx_VEC_CONCAT (dmode, op0, op1);\n       v = gen_rtvec (2, GEN_INT (perm0), GEN_INT (perm1));\n       x = gen_rtx_VEC_SELECT (vmode, x, gen_rtx_PARALLEL (VOIDmode, v));"}, {"sha": "7f0cb0a0ec057a73891a6e208b55b6853e8bdc91", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -1578,10 +1578,11 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       machine_mode new_mode = GET_MODE (op0);\n       if (GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode))\n \t{\n-\t  new_mode = mode_for_vector (GET_MODE_INNER (tmode),\n-\t\t\t\t      GET_MODE_BITSIZE (GET_MODE (op0))\n-\t\t\t\t      / GET_MODE_UNIT_BITSIZE (tmode));\n-\t  if (!VECTOR_MODE_P (new_mode)\n+\t  scalar_mode inner_mode = GET_MODE_INNER (tmode);\n+\t  unsigned int nunits = (GET_MODE_BITSIZE (GET_MODE (op0))\n+\t\t\t\t / GET_MODE_UNIT_BITSIZE (tmode));\n+\t  if (!mode_for_vector (inner_mode, nunits).exists (&new_mode)\n+\t      || !VECTOR_MODE_P (new_mode)\n \t      || GET_MODE_SIZE (new_mode) != GET_MODE_SIZE (GET_MODE (op0))\n \t      || GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode)\n \t      || !targetm.vector_mode_supported_p (new_mode))"}, {"sha": "c97f4a63bd2fcb38384766a8546d3fcda2cd6e15", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -9445,7 +9445,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t  tree sel_type = TREE_TYPE (treeop2);\n \t  machine_mode vmode\n \t    = mode_for_vector (SCALAR_TYPE_MODE (TREE_TYPE (sel_type)),\n-\t\t\t       TYPE_VECTOR_SUBPARTS (sel_type));\n+\t\t\t       TYPE_VECTOR_SUBPARTS (sel_type)).require ();\n \t  gcc_assert (GET_MODE_CLASS (vmode) == MODE_VECTOR_INT);\n \t  op2 = simplify_subreg (vmode, op2, TYPE_MODE (sel_type), 0);\n \t  gcc_assert (op2 && GET_CODE (op2) == CONST_VECTOR);"}, {"sha": "ca3092477398a800ba175b508d839b45c4bfd9c4", "filename": "gcc/machmode.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -682,8 +682,6 @@ decimal_float_mode_for_size (unsigned int size)\n     (mode_for_size (size, MODE_DECIMAL_FLOAT, 0));\n }\n \n-/* Similar to mode_for_size, but find the smallest mode for a given width.  */\n-\n extern machine_mode smallest_mode_for_size (unsigned int, enum mode_class);\n \n /* Find the narrowest integer mode that contains at least SIZE bits.\n@@ -695,17 +693,9 @@ smallest_int_mode_for_size (unsigned int size)\n   return as_a <scalar_int_mode> (smallest_mode_for_size (size, MODE_INT));\n }\n \n-/* Return an integer mode of exactly the same size as the input mode.  */\n-\n extern opt_scalar_int_mode int_mode_for_mode (machine_mode);\n-\n extern machine_mode bitwise_mode_for_mode (machine_mode);\n-\n-/* Return a mode that is suitable for representing a vector,\n-   or BLKmode on failure.  */\n-\n-extern machine_mode mode_for_vector (scalar_mode, unsigned);\n-\n+extern opt_machine_mode mode_for_vector (scalar_mode, unsigned);\n extern opt_machine_mode mode_for_int_vector (unsigned int, unsigned int);\n \n /* Return the integer vector equivalent of MODE, if one exists.  In other"}, {"sha": "9afdd1fe4f3e93aee118e2f1d623d343d1cab497", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -376,10 +376,9 @@ can_vec_perm_p (machine_mode mode, bool variable,\n     return true;\n \n   /* We allow fallback to a QI vector mode, and adjust the mask.  */\n-  if (GET_MODE_INNER (mode) == QImode)\n-    return false;\n-  qimode = mode_for_vector (QImode, GET_MODE_SIZE (mode));\n-  if (!VECTOR_MODE_P (qimode))\n+  if (GET_MODE_INNER (mode) == QImode\n+      || !mode_for_vector (QImode, GET_MODE_SIZE (mode)).exists (&qimode)\n+      || !VECTOR_MODE_P (qimode))\n     return false;\n \n   /* ??? For completeness, we ought to check the QImode version of\n@@ -547,12 +546,14 @@ can_vec_mask_load_store_p (machine_mode mode,\n       vector_sizes &= ~cur;\n       if (cur <= GET_MODE_SIZE (smode))\n \tcontinue;\n-      vmode = mode_for_vector (smode, cur / GET_MODE_SIZE (smode));\n-      mask_mode = targetm.vectorize.get_mask_mode (GET_MODE_NUNITS (vmode),\n-\t\t\t\t\t\t   cur);\n-      if (VECTOR_MODE_P (vmode)\n-\t  && convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n-\treturn true;\n+      unsigned int nunits = cur / GET_MODE_SIZE (smode);\n+      if (mode_for_vector (smode, nunits).exists (&vmode)\n+\t  && VECTOR_MODE_P (vmode))\n+\t{\n+\t  mask_mode = targetm.vectorize.get_mask_mode (nunits, cur);\n+\t  if (convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n+\t    return true;\n+\t}\n     }\n   return false;\n }"}, {"sha": "67dfa58ff462b9393bc5d049c526b5f930dd7e25", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -5434,13 +5434,10 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n \n   /* Set QIMODE to a different vector mode with byte elements.\n      If no such mode, or if MODE already has byte elements, use VOIDmode.  */\n-  qimode = VOIDmode;\n-  if (GET_MODE_INNER (mode) != QImode)\n-    {\n-      qimode = mode_for_vector (QImode, w);\n-      if (!VECTOR_MODE_P (qimode))\n-\tqimode = VOIDmode;\n-    }\n+  if (GET_MODE_INNER (mode) == QImode\n+      || !mode_for_vector (QImode, w).exists (&qimode)\n+      || !VECTOR_MODE_P (qimode))\n+    qimode = VOIDmode;\n \n   /* If the input is a constant, expand it specially.  */\n   gcc_assert (GET_MODE_CLASS (GET_MODE (sel)) == MODE_VECTOR_INT);"}, {"sha": "baaf5f340a5a718477905399ed375089ff1795b9", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -471,11 +471,11 @@ bitwise_type_for_mode (machine_mode mode)\n   return inner_type;\n }\n \n-/* Find a mode that is suitable for representing a vector with\n-   NUNITS elements of mode INNERMODE.  Returns BLKmode if there\n-   is no suitable mode.  */\n+/* Find a mode that is suitable for representing a vector with NUNITS\n+   elements of mode INNERMODE, if one exists.  The returned mode can be\n+   either an integer mode or a vector mode.  */\n \n-machine_mode\n+opt_machine_mode\n mode_for_vector (scalar_mode innermode, unsigned nunits)\n {\n   machine_mode mode;\n@@ -499,22 +499,18 @@ mode_for_vector (scalar_mode innermode, unsigned nunits)\n   FOR_EACH_MODE_FROM (mode, mode)\n     if (GET_MODE_NUNITS (mode) == nunits\n \t&& GET_MODE_INNER (mode) == innermode)\n-      break;\n+      return mode;\n \n   /* For integers, try mapping it to a same-sized scalar mode.  */\n-  if (mode == VOIDmode\n-      && GET_MODE_CLASS (innermode) == MODE_INT)\n+  if (GET_MODE_CLASS (innermode) == MODE_INT)\n     {\n       unsigned int nbits = nunits * GET_MODE_BITSIZE (innermode);\n-      mode = int_mode_for_size (nbits, 0).else_blk ();\n+      if (int_mode_for_size (nbits, 0).exists (&mode)\n+\t  && have_regs_of_mode[mode])\n+\treturn mode;\n     }\n \n-  if (mode == VOIDmode\n-      || (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && !have_regs_of_mode[mode]))\n-    return BLKmode;\n-\n-  return mode;\n+  return opt_machine_mode ();\n }\n \n /* Return the mode for a vector that has NUNITS integer elements of\n@@ -525,12 +521,10 @@ opt_machine_mode\n mode_for_int_vector (unsigned int int_bits, unsigned int nunits)\n {\n   scalar_int_mode int_mode;\n-  if (int_mode_for_size (int_bits, 0).exists (&int_mode))\n-    {\n-      machine_mode vec_mode = mode_for_vector (int_mode, nunits);\n-      if (vec_mode != BLKmode)\n-\treturn vec_mode;\n-    }\n+  machine_mode vec_mode;\n+  if (int_mode_for_size (int_bits, 0).exists (&int_mode)\n+      && mode_for_vector (int_mode, nunits).exists (&vec_mode))\n+    return vec_mode;\n   return opt_machine_mode ();\n }\n \n@@ -2264,7 +2258,7 @@ layout_type (tree type)\n \tif (TYPE_MODE (type) == VOIDmode)\n \t  SET_TYPE_MODE (type,\n \t\t\t mode_for_vector (SCALAR_TYPE_MODE (innertype),\n-\t\t\t\t\t  nunits));\n+\t\t\t\t\t  nunits).else_blk ());\n \n \tTYPE_SATURATING (type) = TYPE_SATURATING (TREE_TYPE (type));\n         TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));"}, {"sha": "078647c191c1995885f1d7fcd8f08fa7d3125fef", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -1210,8 +1210,8 @@ default_get_mask_mode (unsigned nunits, unsigned vector_size)\n \n   gcc_assert (elem_size * nunits == vector_size);\n \n-  vector_mode = mode_for_vector (elem_mode, nunits);\n-  if (!VECTOR_MODE_P (vector_mode)\n+  if (!mode_for_vector (elem_mode, nunits).exists (&vector_mode)\n+      || !VECTOR_MODE_P (vector_mode)\n       || !targetm.vector_mode_supported_p (vector_mode))\n     vector_mode = BLKmode;\n "}, {"sha": "6b12f7a63aa3e2212bec45dfc08726d48798e4f4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da15d4097fa2fde5c2a5f1681db8fd04488a563/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9da15d4097fa2fde5c2a5f1681db8fd04488a563", "patch": "@@ -6038,8 +6038,9 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      /* First check if vec_extract optab doesn't support extraction\n \t\t of vector elts directly.  */\n \t      scalar_mode elmode = SCALAR_TYPE_MODE (elem_type);\n-\t      machine_mode vmode = mode_for_vector (elmode, group_size);\n-\t      if (! VECTOR_MODE_P (vmode)\n+\t      machine_mode vmode;\n+\t      if (!mode_for_vector (elmode, group_size).exists (&vmode)\n+\t\t  || !VECTOR_MODE_P (vmode)\n \t\t  || (convert_optab_handler (vec_extract_optab,\n \t\t\t\t\t     TYPE_MODE (vectype), vmode)\n \t\t      == CODE_FOR_nothing))\n@@ -6052,11 +6053,12 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  unsigned lsize\n \t\t    = group_size * GET_MODE_BITSIZE (elmode);\n \t\t  elmode = int_mode_for_size (lsize, 0).require ();\n-\t\t  vmode = mode_for_vector (elmode, nunits / group_size);\n \t\t  /* If we can't construct such a vector fall back to\n \t\t     element extracts from the original vector type and\n \t\t     element size stores.  */\n-\t\t  if (VECTOR_MODE_P (vmode)\n+\t\t  if (mode_for_vector (elmode,\n+\t\t\t\t       nunits / group_size).exists (&vmode)\n+\t\t      && VECTOR_MODE_P (vmode)\n \t\t      && (convert_optab_handler (vec_extract_optab,\n \t\t\t\t\t\t vmode, elmode)\n \t\t\t  != CODE_FOR_nothing))\n@@ -7076,8 +7078,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      /* First check if vec_init optab supports construction from\n \t\t vector elts directly.  */\n \t      scalar_mode elmode = SCALAR_TYPE_MODE (TREE_TYPE (vectype));\n-\t      machine_mode vmode = mode_for_vector (elmode, group_size);\n-\t      if (VECTOR_MODE_P (vmode)\n+\t      machine_mode vmode;\n+\t      if (mode_for_vector (elmode, group_size).exists (&vmode)\n+\t\t  && VECTOR_MODE_P (vmode)\n \t\t  && (convert_optab_handler (vec_init_optab,\n \t\t\t\t\t     TYPE_MODE (vectype), vmode)\n \t\t      != CODE_FOR_nothing))\n@@ -7098,10 +7101,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  unsigned lsize\n \t\t    = group_size * TYPE_PRECISION (TREE_TYPE (vectype));\n \t\t  elmode = int_mode_for_size (lsize, 0).require ();\n-\t\t  vmode = mode_for_vector (elmode, nunits / group_size);\n \t\t  /* If we can't construct such a vector fall back to\n \t\t     element loads of the original vector type.  */\n-\t\t  if (VECTOR_MODE_P (vmode)\n+\t\t  if (mode_for_vector (elmode,\n+\t\t\t\t       nunits / group_size).exists (&vmode)\n+\t\t      && VECTOR_MODE_P (vmode)\n \t\t      && (convert_optab_handler (vec_init_optab, vmode, elmode)\n \t\t\t  != CODE_FOR_nothing))\n \t\t    {\n@@ -9104,8 +9108,8 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n      lookup a vector mode of the specified size.  */\n   if (size == 0)\n     simd_mode = targetm.vectorize.preferred_simd_mode (inner_mode);\n-  else\n-    simd_mode = mode_for_vector (inner_mode, size / nbytes);\n+  else if (!mode_for_vector (inner_mode, size / nbytes).exists (&simd_mode))\n+    return NULL_TREE;\n   nunits = GET_MODE_SIZE (simd_mode) / nbytes;\n   /* NOTE: nunits == 1 is allowed to support single element vector types.  */\n   if (nunits < 1)"}]}