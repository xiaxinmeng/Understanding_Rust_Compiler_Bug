{"sha": "91581bccd5c8d82d2a6e06236f346dceab8ae86e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE1ODFiY2NkNWM4ZDgyZDJhNmUwNjIzNmYzNDZkY2VhYjhhZTg2ZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-05-13T20:55:06Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-05-13T20:55:06Z"}, "message": "tree-ssa-forwprop.c (record_single_argument_cond_exprs): Accept new parameters for the statement and variable worklist as well as a...\n\n\n\t* tree-ssa-forwprop.c (record_single_argument_cond_exprs): Accept\n\tnew parameters for the statement and variable worklist as well\n\tas a bitmap of interesting SSA_NAMEs.  Walk over the statement\n\tworklist recording interesting variables in the variable worklist\n\tand bitmap.  Handle casts between integral and boolean types.\n\t(substitute_single_use_vars): Accept new parameters for the statement\n\tand variable worklist.  When a substitution is made add a new\n\tentry to the statement worklist.  Handle casts between integral\n\tand boolean types.\n\t(tree_ssa_forward_propagate_single_use_vars): Rework to pass\n\tworklists to children.  Iterate until the statement worklist\n\tis empty.\n\n\t* gcc.dg/tree-ssa/20040513-1.c: New test.\n\t* gcc.dg/tree-ssa/20040513-2.c: New test.\n\nFrom-SVN: r81803", "tree": {"sha": "530fd846bdc26aea8b21becd4c83cfefd837112e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/530fd846bdc26aea8b21becd4c83cfefd837112e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91581bccd5c8d82d2a6e06236f346dceab8ae86e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91581bccd5c8d82d2a6e06236f346dceab8ae86e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91581bccd5c8d82d2a6e06236f346dceab8ae86e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91581bccd5c8d82d2a6e06236f346dceab8ae86e/comments", "author": null, "committer": null, "parents": [{"sha": "30107ebef8976647bff8c48911202b6cc13d989e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30107ebef8976647bff8c48911202b6cc13d989e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30107ebef8976647bff8c48911202b6cc13d989e"}], "stats": {"total": 227, "additions": 185, "deletions": 42}, "files": [{"sha": "8106136886c3b7fd105d74ebf3ca4c38d3b47122", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91581bccd5c8d82d2a6e06236f346dceab8ae86e", "patch": "@@ -1,3 +1,18 @@\n+2004-05-13  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-forwprop.c (record_single_argument_cond_exprs): Accept\n+\tnew parameters for the statement and variable worklist as well\n+\tas a bitmap of interesting SSA_NAMEs.  Walk over the statement\n+\tworklist recording interesting variables in the variable worklist\n+\tand bitmap.  Handle casts between integral and boolean types.\n+\t(substitute_single_use_vars): Accept new parameters for the statement\n+\tand variable worklist.  When a substitution is made add a new\n+\tentry to the statement worklist.  Handle casts between integral\n+\tand boolean types.\n+\t(tree_ssa_forward_propagate_single_use_vars): Rework to pass\n+\tworklists to children.  Iterate until the statement worklist\n+\tis empty.\n+\n 2004-05-13  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* tree-outof-ssa.c (rewrite_vars_out_of_ssa): Free map at"}, {"sha": "ff52fb52901727c623c975fea2fad1d754d92332", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91581bccd5c8d82d2a6e06236f346dceab8ae86e", "patch": "@@ -1,3 +1,8 @@\n+2004-05-13  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20040513-1.c: New test.\n+\t* gcc.dg/tree-ssa/20040513-2.c: New test.\n+\n 2004-05-13  Paul Brook  <paul@codesourcery.com>\n \n \t* gcc.dg/tree-ssa/20030808-1.c: Force enum size."}, {"sha": "d53d81849fd33f364c2083766c80d15ca0d183fb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040513-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040513-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040513-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040513-1.c?ref=91581bccd5c8d82d2a6e06236f346dceab8ae86e", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-forwprop1\" } */\n+void bar (void);\n+\n+void\n+foo (unsigned int a)\n+{\n+  if ((a >> 5) & 1)\n+    bar ();\n+}\n+\n+\n+\n+/* There should be no casts to a _Bool since we can use the temporary\n+   holding (a>>5)&1 directly.  */\n+/* { dg-final { scan-tree-dump-times \"\\\\(_Bool\\\\)\" 0 \"forwprop1\"} } */\n+                                                                                \n+"}, {"sha": "acd6c68652fc4c1f0107272d45b7364b62326a82", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040513-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040513-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040513-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040513-2.c?ref=91581bccd5c8d82d2a6e06236f346dceab8ae86e", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-dom2\" } */\n+int link_error(void);\n+int s(void);\n+\n+int t(int i)\n+{\n+  _Bool g = i == 4;\n+ int h = g;\n+ _Bool j = h;\n+ int k = j;\n+ _Bool l = k == 0;\n+ _Bool o = !l;\n+ int m = o;\n+\n+ if (m)\n+  if (i != 4)\n+   return link_error();\n+ return 0;\n+}\n+\n+/* There should be no link_error calls, if there is any, the\n+   optimization has failed */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"dom2\"} } */"}, {"sha": "d4e893c1067565922e49909dfb52d729e41ade76", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 123, "deletions": 42, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91581bccd5c8d82d2a6e06236f346dceab8ae86e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=91581bccd5c8d82d2a6e06236f346dceab8ae86e", "patch": "@@ -80,10 +80,33 @@ Boston, MA 02111-1307, USA.  */\n    For these cases, we propagate A into all, possibly more than one,\n    COND_EXPRs that use X.\n \n+   Or\n+\n+     bb0:\n+       x = (typecast) a\n+       if (x) goto ... else goto ...\n+\n+   Will be transformed into:\n+\n+     bb0:\n+        if (a != 0) goto ... else goto ...\n+\n+   (Assuming a is an integral type and x is a boolean or x is an\n+    integral and a is a boolean.)\n+\n+   Similarly for the tests (x == 0), (x != 0), (x == 1) and (x != 1).\n+   For these cases, we propagate A into all, possibly more than one,\n+   COND_EXPRs that use X.\n+\n    In addition to eliminating the variable and the statement which assigns\n    a value to the variable, we may be able to later thread the jump without\n    adding insane complexity in the dominator optimizer. \n \n+   Also note these transformations can cascade.  We handle this by having\n+   a worklist of COND_EXPR statements to examine.  As we make a change to\n+   a statement, we put it back on the worklist to examine on the next\n+   iteration of the main loop.\n+\n    This will (of course) be extended as other needs arise.  */\n \n /* Bitmap of variables for which we want immediate uses.  This is set\n@@ -92,8 +115,10 @@ static bitmap vars;\n \n static bool need_imm_uses_for (tree);\n static void tree_ssa_forward_propagate_single_use_vars (void);\n-static varray_type record_single_argument_cond_exprs (void);\n-static void substitute_single_use_vars (varray_type);\n+static void record_single_argument_cond_exprs (varray_type,\n+\t\t\t\t\t       varray_type *,\n+\t\t\t\t\t       bitmap);\n+static void substitute_single_use_vars (varray_type *, varray_type);\n \n /* Function indicating whether we ought to include information for 'var'\n    when calculating immediate uses.  */\n@@ -115,24 +140,22 @@ need_imm_uses_for (tree var)\n    filter out here, the faster this pass will run since its runtime is\n    dominated by the time to build immediate uses.  */\n \n-static varray_type\n-record_single_argument_cond_exprs (void)\n-{\n-  basic_block bb;\n-  varray_type retval;\n-\n-  vars = BITMAP_XMALLOC ();\n-\n-  VARRAY_TREE_INIT (retval, 10, \"forward propagation vars\");\n+static void\n+record_single_argument_cond_exprs (varray_type cond_worklist,\n+\t\t\t\t   varray_type *vars_worklist,\n+\t\t\t\t   bitmap vars)\n \n+{\n   /* The first pass over the blocks gathers the set of variables we need\n      immediate uses for as well as the set of interesting COND_EXPRs.\n \n      A simpler implementation may be appropriate if/when we have a lower\n      overhead means of getting immediate use information.  */\n-  FOR_EACH_BB (bb)\n+  while (VARRAY_ACTIVE_SIZE (cond_worklist) > 0)\n     {\n-      tree last = last_stmt (bb);\n+      tree last = VARRAY_TOP_TREE (cond_worklist);\n+\n+      VARRAY_POP (cond_worklist);\n \n       /* See if this block ends in a COND_EXPR.  */\n       if (last && TREE_CODE (last) == COND_EXPR)\n@@ -225,20 +248,40 @@ record_single_argument_cond_exprs (void)\n \t\t\t      && !is_gimple_min_invariant (def_rhs))\n \t\t\t    continue;\n \t\t\t}\n+\n+\t\t      /* If TEST_VAR was set from a cast of an integer type\n+\t\t\t to a boolean type or a cast of a boolean to an\n+\t\t\t integral, then it is interesting.  */\n+\t\t      else if (TREE_CODE (def_rhs) == NOP_EXPR\n+\t\t\t       || TREE_CODE (def_rhs) == CONVERT_EXPR)\n+\t\t\t{\n+\t\t\t  tree outer_type;\n+\t\t\t  tree inner_type;\n+\n+\t\t\t  outer_type = TREE_TYPE (def_rhs);\n+\t\t\t  inner_type = TREE_TYPE (TREE_OPERAND (def_rhs, 0));\n+\n+\t\t\t  if ((TREE_CODE (outer_type) == BOOLEAN_TYPE\n+\t\t\t       && INTEGRAL_TYPE_P (inner_type))\n+\t\t\t      || (TREE_CODE (inner_type) == BOOLEAN_TYPE\n+\t\t\t\t  && INTEGRAL_TYPE_P (outer_type)))\n+\t\t\t    ;\n+\t\t\t  else\n+\t\t\t    continue;\n+\t\t\t}\n \t\t      else\n \t\t\tcontinue;\n \t\t    }\n \t\t  else\n \t\t    continue;\n \n \t\t  /* All the tests passed, record TEST_VAR as interesting.  */\n-\t\t  VARRAY_PUSH_TREE (retval, test_var);\n+\t\t  VARRAY_PUSH_TREE (*vars_worklist, test_var);\n \t\t  bitmap_set_bit (vars, SSA_NAME_VERSION (test_var));\n \t\t}\n \t    }\n \t}\n     }\n-  return retval;\n }\n \n /* Given FORWPROP_DATA containing SSA_NAMEs which are used in COND_EXPRs\n@@ -247,18 +290,19 @@ record_single_argument_cond_exprs (void)\n    SSA_NAME used in the COND_EXPR.  */\n   \n static void\n-substitute_single_use_vars (varray_type forwprop_data)\n+substitute_single_use_vars (varray_type *cond_worklist,\n+\t\t\t    varray_type vars_worklist)\n {\n-  unsigned int i;\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (forwprop_data); i++)\n+  while (VARRAY_ACTIVE_SIZE (vars_worklist) > 0)\n     {\n-      tree test_var = VARRAY_TREE (forwprop_data, i);\n+      tree test_var = VARRAY_TOP_TREE (vars_worklist);\n       tree def = SSA_NAME_DEF_STMT (test_var);\n       dataflow_t df;\n       int j, num_uses, propagated_uses;\n       block_stmt_iterator bsi;\n \n+      VARRAY_POP (vars_worklist);\n+\n       /* Now compute the immediate uses of TEST_VAR.  */\n       df = get_immediate_uses (def);\n       num_uses = num_immediate_uses (df);\n@@ -345,21 +389,30 @@ substitute_single_use_vars (varray_type forwprop_data)\n \t    }\n \t  else\n \t    {\n-\t      /* TEST_VAR was set from a TRUTH_NOT_EXPR.  */\n+\t      bool invert = false;\n+\t      enum tree_code new_code;\n+\n+\t      /* TEST_VAR was set from a TRUTH_NOT_EXPR or a NOP_EXPR.  */\n+\t      if (def_rhs_code == TRUTH_NOT_EXPR)\n+\t\tinvert = true;\n+\t\t\n \t      if (cond_code == SSA_NAME\n \t\t  || (cond_code == NE_EXPR\n \t\t      && integer_zerop (TREE_OPERAND (cond, 1)))\n \t\t  || (cond_code == EQ_EXPR\n \t\t      && integer_onep (TREE_OPERAND (cond, 1))))\n-\t\tnew_cond = build (EQ_EXPR, boolean_type_node,\n-\t\t\t\t  TREE_OPERAND (def_rhs, 0),\n-\t\t\t\t  convert (TREE_TYPE (def_rhs),\n-\t\t\t\t\t   integer_zero_node));\n+\t\tnew_code = NE_EXPR;\n \t      else\n-\t\tnew_cond = build (NE_EXPR, boolean_type_node,\n-\t\t\t\t  TREE_OPERAND (def_rhs, 0),\n-\t\t\t\t  convert (TREE_TYPE (def_rhs),\n-\t\t\t\t\t   integer_zero_node));\n+\t\tnew_code = EQ_EXPR;\n+\n+\t      if (invert)\n+\t\tnew_code = (new_code == EQ_EXPR ? NE_EXPR  : EQ_EXPR);\n+\n+\t      new_cond = build (new_code, \n+\t\t\t\tboolean_type_node,\n+\t\t\t\tTREE_OPERAND (def_rhs, 0),\n+\t\t\t\tconvert (TREE_TYPE (def_rhs),\n+\t\t\t\t\t integer_zero_node));\n \t    }\n \n \t  /* Dump details.  */\n@@ -376,6 +429,7 @@ substitute_single_use_vars (varray_type forwprop_data)\n \t  COND_EXPR_COND (cond_stmt) = new_cond;\n \t  modify_stmt (cond_stmt);\n \t  propagated_uses++;\n+\t  VARRAY_PUSH_TREE (*cond_worklist, cond_stmt);\n \t}\n \n       /* If we propagated into all the uses, then we can delete DEF.\n@@ -400,25 +454,52 @@ substitute_single_use_vars (varray_type forwprop_data)\n static void\n tree_ssa_forward_propagate_single_use_vars (void)\n {\n-  varray_type forwprop_data;\n+  basic_block bb;\n+  varray_type vars_worklist, cond_worklist;\n \n-  /* First get a list of all the interesting COND_EXPRs and potential single\n-     use variables which feed those COND_EXPRs.  */\n-  forwprop_data = record_single_argument_cond_exprs ();\n+  vars = BITMAP_XMALLOC ();\n+  VARRAY_TREE_INIT (vars_worklist, 10, \"VARS worklist\");\n+  VARRAY_TREE_INIT (cond_worklist, 10, \"COND worklist\");\n \n-  /* Now compute immediate uses for all the variables we care about.  */\n-  compute_immediate_uses (TDFA_USE_OPS, need_imm_uses_for);\n+  /* Prime the COND_EXPR worklist by placing all the COND_EXPRs on the\n+     worklist.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      tree last = last_stmt (bb);\n+      if (last && TREE_CODE (last) == COND_EXPR)\n+\tVARRAY_PUSH_TREE (cond_worklist, last);\n+    }\n \n-  /* We are done with the VARS bitmap and other dataflow information.  */\n-  BITMAP_XFREE (vars);\n-  vars = NULL;\n+  while (VARRAY_ACTIVE_SIZE (cond_worklist) > 0)\n+    {\n+      /* First get a list of all the interesting COND_EXPRs and potential\n+\t single use variables which feed those COND_EXPRs.  This will drain\n+\t COND_WORKLIST and initialize VARS_WORKLIST.  */\n+      record_single_argument_cond_exprs (cond_worklist, &vars_worklist, vars);\n \n-  /* And optimize.  */\n-  substitute_single_use_vars (forwprop_data);\n+      if (VARRAY_ACTIVE_SIZE (vars_worklist) > 0)\n+\t{\n+\t  /* Now compute immediate uses for all the variables we care about.  */\n+\t  compute_immediate_uses (TDFA_USE_OPS, need_imm_uses_for);\n+\n+\t  /* We've computed immediate uses, so we can/must clear the VARS\n+\t     bitmap for the next iteration.  */\n+\t  bitmap_clear (vars);\n+\n+\t  /* And optimize.  This will drain VARS_WORKLIST and initialize\n+\t     COND_WORKLIST for the next iteration.  */\n+\t  substitute_single_use_vars (&cond_worklist, vars_worklist);\n+\n+\t  /* We do not incrementally update the dataflow information\n+\t     so we must free it here and recompute the necessary bits\n+\t     on the next iteration.  If this turns out to be expensive,\n+\t     methods for incrementally updating the dataflow are known.  */\n+\t  free_df ();\n+\t}\n+    }\n \n   /* All done.  Clean up.  */\n-  free_df ();\n-  VARRAY_CLEAR (forwprop_data);\n+  BITMAP_XFREE (vars);\n }\n \n "}]}