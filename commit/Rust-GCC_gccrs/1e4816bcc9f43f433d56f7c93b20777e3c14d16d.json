{"sha": "1e4816bcc9f43f433d56f7c93b20777e3c14d16d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU0ODE2YmNjOWY0M2Y0MzNkNTZmN2M5M2IyMDc3N2UzYzE0ZDE2ZA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-03-17T23:07:34Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-03-17T23:07:34Z"}, "message": "re PR tree-optimization/29922 ([Linux] ICE in insert_into_preds_of_block)\n\n2007-03-16  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/29922\n\t* tree-ssa-pre.c (bb_bitmap_sets): Remove RVUSE_* members.\n\t(get_representative): Removed.\n\t(value_dies_in_block_x): Update for rvuse removal.\n\t(valid_in_sets): Update for renaming of vuses_dies_in_block_x.\n\t(compute_antic_aux): Handle when PHI nodes appear in\n\tnon-single-successors. \n\t(dump_bitmap_of_names): Removed.\n\t(compute_antic_safe): Renamed and removed rvuse calculation.\n\tCalculate only antic safe.\n\t(insert_into_preds_of_block): Remove assert.\n\t(execute_pre): Update for renamed functions.\n\t(defer_or_phi_translate_block): New function.\n\nFrom-SVN: r123029", "tree": {"sha": "fad92e166885d60b7474cf4450b63bbebd13d9b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fad92e166885d60b7474cf4450b63bbebd13d9b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e4816bcc9f43f433d56f7c93b20777e3c14d16d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4816bcc9f43f433d56f7c93b20777e3c14d16d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4816bcc9f43f433d56f7c93b20777e3c14d16d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4816bcc9f43f433d56f7c93b20777e3c14d16d/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f85ab62b70089d6568902e6d74c37e8bbcc8e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f85ab62b70089d6568902e6d74c37e8bbcc8e43"}], "stats": {"total": 533, "additions": 155, "deletions": 378}, "files": [{"sha": "181e4735eb38aa63192b9bf1dfebe1247d42897b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4816bcc9f43f433d56f7c93b20777e3c14d16d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4816bcc9f43f433d56f7c93b20777e3c14d16d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e4816bcc9f43f433d56f7c93b20777e3c14d16d", "patch": "@@ -1,3 +1,19 @@\n+2007-03-16  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/29922\n+\t* tree-ssa-pre.c (bb_bitmap_sets): Remove RVUSE_* members.\n+\t(get_representative): Removed.\n+\t(value_dies_in_block_x): Update for rvuse removal.\n+\t(valid_in_sets): Update for renaming of vuses_dies_in_block_x.\n+\t(compute_antic_aux): Handle when PHI nodes appear in\n+\tnon-single-successors. \n+\t(dump_bitmap_of_names): Removed.\n+\t(compute_antic_safe): Renamed and removed rvuse calculation.\n+\tCalculate only antic safe.\n+\t(insert_into_preds_of_block): Remove assert.\n+\t(execute_pre): Update for renamed functions.\n+\t(defer_or_phi_translate_block): New function.\n+\t\n 2007-03-17  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/arm/arm.c, config/arm/thumb2.md, config/m68k/m68k.c,"}, {"sha": "94a3d00bd2e09d46395029117ca8290de9e8fcc3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4816bcc9f43f433d56f7c93b20777e3c14d16d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4816bcc9f43f433d56f7c93b20777e3c14d16d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre12.c?ref=1e4816bcc9f43f433d56f7c93b20777e3c14d16d", "patch": "@@ -11,5 +11,5 @@ int f(int tt)\n     return g((*t1)[0]);\n }\n \n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "7275acf07fbce20f0bc35c6e18c2865cafb4ca1c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 138, "deletions": 377, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4816bcc9f43f433d56f7c93b20777e3c14d16d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4816bcc9f43f433d56f7c93b20777e3c14d16d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1e4816bcc9f43f433d56f7c93b20777e3c14d16d", "patch": "@@ -55,11 +55,6 @@ Boston, MA 02110-1301, USA.  */\n       we can repair later on.\n    3. We can do back-substitution or smarter value numbering to catch\n       commutative expressions split up over multiple statements.\n-   4. ANTIC_SAFE_LOADS could be a lot smarter than it is now.\n-      Right now, it is simply calculating loads that occur before\n-      any store in a block, instead of loads that occur before\n-      stores that affect them.  This is relatively more expensive, and\n-      it's not clear how much more it will buy us.\n */\n \n /* For ease of terminology, \"expression node\" in the below refers to\n@@ -306,16 +301,8 @@ typedef struct bb_bitmap_sets\n      the current iteration.  */\n   bitmap_set_t new_sets;\n \n-  /* The RVUSE sets, which are used during ANTIC computation to ensure\n-     that we don't mark loads ANTIC once they have died.  */\n-  bitmap rvuse_in;\n-  bitmap rvuse_out;\n-  bitmap rvuse_gen;\n-  bitmap rvuse_kill;\n-\n-  /* For actually occurring loads, as long as they occur before all the\n-     other stores in the block, we know they are antic at the top of\n-     the block, regardless of RVUSE_KILL.  */\n+  /* These are the loads that will be ANTIC_IN at the top of the\n+     block, and are actually generated in the block.  */\n   bitmap_set_t antic_safe_loads;\n \n   /* True if we have visited this block during ANTIC calculation.  */\n@@ -332,10 +319,6 @@ typedef struct bb_bitmap_sets\n #define AVAIL_OUT(BB)\t((bb_value_sets_t) ((BB)->aux))->avail_out\n #define ANTIC_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->antic_in\n #define PA_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->pa_in\n-#define RVUSE_IN(BB)    ((bb_value_sets_t) ((BB)->aux))->rvuse_in\n-#define RVUSE_GEN(BB)   ((bb_value_sets_t) ((BB)->aux))->rvuse_gen\n-#define RVUSE_KILL(BB)   ((bb_value_sets_t) ((BB)->aux))->rvuse_kill\n-#define RVUSE_OUT(BB)    ((bb_value_sets_t) ((BB)->aux))->rvuse_out\n #define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n #define ANTIC_SAFE_LOADS(BB) ((bb_value_sets_t) ((BB)->aux))->antic_safe_loads\n #define BB_VISITED(BB) ((bb_value_sets_t) ((BB)->aux))->visited\n@@ -1399,37 +1382,32 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n   return NULL;\n }\n \n-/* Given the vuse representative map, MAP, and an SSA version number,\n-   ID, return the bitmap of names ID represents, or NULL, if none\n-   exists.  */\n-\n-static bitmap\n-get_representative (bitmap *map, int id)\n-{\n-  if (map[id] != NULL)\n-    return map[id];\n-  return NULL;\n-}\n-\n-/* A vuse is anticipable at the top of block x, from the bottom of the\n-   block, if it reaches the top of the block, and is not killed in the\n-   block.  In effect, we are trying to see if the vuse is transparent\n-   backwards in the block.  */\n+/* Determine if VALUE, a memory operation, is ANTIC_IN at the top of\n+   BLOCK by seeing if it is not killed in the block.  Note that we are\n+   only determining whether there is a store that kills it.  Because\n+   of the order in which clean iterates over values, we are guaranteed\n+   that altered operands will have caused us to be eliminated from the\n+   ANTIC_IN set already.  */\n \n static bool\n-vuses_dies_in_block_x (VEC (tree, gc) *vuses, basic_block block)\n+value_dies_in_block_x (tree vh, basic_block block)\n {\n   int i;\n   tree vuse;\n-\n+  VEC (tree, gc) *vuses = VALUE_HANDLE_VUSES (vh);\n+  \n+  /* Conservatively, a value dies if it's vuses are defined in this\n+     block, unless they come from phi nodes (which are merge operations,\n+     rather than stores.  */\n   for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n     {\n-      /* Any places where this is too conservative, are places\n-\t where we created a new version and shouldn't have.  */\n-\n-      if (!bitmap_bit_p (RVUSE_IN (block), SSA_NAME_VERSION (vuse))\n-\t  || bitmap_bit_p (RVUSE_KILL (block), SSA_NAME_VERSION (vuse)))\n-\treturn true;\n+      tree def = SSA_NAME_DEF_STMT (vuse);\n+      \n+      if (bb_for_stmt (def) != block)\n+\tcontinue;\n+      if (TREE_CODE (def) == PHI_NODE)\n+\tcontinue;\n+      return true;\n     }\n   return false;\n }\n@@ -1438,6 +1416,7 @@ vuses_dies_in_block_x (VEC (tree, gc) *vuses, basic_block block)\n    ONLY SET2 CAN BE NULL.\n    This means that we have a leader for each part of the expression\n    (if it consists of values), or the expression is an SSA_NAME.\n+   For loads/calls, we also see if the vuses are killed in this block.\n \n    NB: We never should run into a case where we have SSA_NAME +\n    SSA_NAME or SSA_NAME + value.  The sets valid_in_sets is called on,\n@@ -1494,7 +1473,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n \t\tif (!union_contains_value (set1, set2, arg))\n \t\t  return false;\n \t      }\n-\t    return !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh), block);\n+\t    return !value_dies_in_block_x (vh, block);\n \t  }\n \treturn false;\n       }\n@@ -1532,8 +1511,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n \t    }\n \t  return bitmap_set_contains_value (ANTIC_SAFE_LOADS (block),\n \t\t\t\t\t    vh)\n-\t    || !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh),\n-\t\t\t\t       block);\n+\t    || !value_dies_in_block_x (vh, block);\n \t  }\n       }\n       return false;\n@@ -1545,7 +1523,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n       }\n \n     case tcc_declaration:\n-      return !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh), block);\n+      return !value_dies_in_block_x (vh, block);\n \n     default:\n       /* No other cases should be encountered.  */\n@@ -1594,12 +1572,32 @@ clean (bitmap_set_t set, basic_block block)\n }\n \n static sbitmap has_abnormal_preds;\n-\n-\n+\t\t\t      \n /* List of blocks that may have changed during ANTIC computation and\n    thus need to be iterated over.  */\n \n static sbitmap changed_blocks;\n+\n+/* Decide whether to defer a block for a later iteration, or PHI\n+   translate SOURCE to DEST using phis in PHIBLOCK.  Return false if we\n+   should defer the block, and true if we processed it.  */\n+\n+static bool\n+defer_or_phi_translate_block (bitmap_set_t dest, bitmap_set_t source,\n+\t\t\t      basic_block block, basic_block phiblock)\n+{\n+  if (!BB_VISITED (phiblock))\n+    {\n+      SET_BIT (changed_blocks, block->index);\n+      BB_VISITED (block) = 0;\n+      BB_DEFERRED (block) = 1;\n+      return false;\n+    }\n+  else\n+    phi_translate_set (dest, source, block, phiblock);\n+  return true;\n+}\n+\n /* Compute the ANTIC set for BLOCK.\n \n    If succs(BLOCK) > 1 then\n@@ -1657,22 +1655,16 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t with maximal set fix/with deferring: 11 seconds\n      */\n \n-      if (!BB_VISITED (succ_bb))\n+      if (!defer_or_phi_translate_block (ANTIC_OUT, ANTIC_IN (succ_bb),\n+\t\t\t\t\tblock, succ_bb))\n \t{\n \t  changed = true;\n-\t  SET_BIT (changed_blocks, block->index);\n-\t  BB_VISITED (block) = 0;\n-\t  BB_DEFERRED (block) = 1;\n \t  goto maybe_dump_sets;\n \t}\n-      else\n-\tphi_translate_set (ANTIC_OUT, ANTIC_IN (succ_bb),\n-\t\t\t   block, succ_bb);\n     }\n-\n-\n   /* If we have multiple successors, we take the intersection of all of\n-     them.  */\n+     them.  Note that in the case of loop exit phi nodes, we may have\n+     phis to translate through.  */\n   else\n     {\n       VEC(basic_block, heap) * worklist;\n@@ -1684,17 +1676,42 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \tVEC_quick_push (basic_block, worklist, e->dest);\n       first = VEC_index (basic_block, worklist, 0);\n \n-      if (!BB_VISITED (first))\n-\tbitmap_set_copy (ANTIC_OUT, maximal_set);\n+      if (phi_nodes (first))\n+\t{\n+\t  bitmap_set_t from = ANTIC_IN (first);\n+\t      \n+\t  if (!BB_VISITED (first))\n+\t    from = maximal_set;\n+\t  phi_translate_set (ANTIC_OUT, from, block, first);\n+\t}\n       else\n-\tbitmap_set_copy (ANTIC_OUT, ANTIC_IN (first));\n+\t{\n+\t  if (!BB_VISITED (first))\n+\t    bitmap_set_copy (ANTIC_OUT, maximal_set);\n+\t  else\n+\t    bitmap_set_copy (ANTIC_OUT, ANTIC_IN (first));\n+\t}\n \n       for (i = 1; VEC_iterate (basic_block, worklist, i, bprime); i++)\n \t{\n-\t  if (!BB_VISITED (bprime))\n-\t    bitmap_set_and (ANTIC_OUT, maximal_set);\n-\t  else\n-\t    bitmap_set_and (ANTIC_OUT, ANTIC_IN (bprime));\n+\t  if (phi_nodes (bprime)) \n+\t    {\n+\t      bitmap_set_t tmp = bitmap_set_new ();\n+\t      bitmap_set_t from = ANTIC_IN (bprime);\n+\t      \n+\t      if (!BB_VISITED (bprime))\n+\t\tfrom = maximal_set;\n+\t      phi_translate_set (tmp, from, block, bprime);\n+\t      bitmap_set_and (ANTIC_OUT, tmp);\n+\t      bitmap_set_free (tmp);\n+\t    }\n+\t  else \n+\t    {\n+\t      if (!BB_VISITED (bprime))\n+\t\tbitmap_set_and (ANTIC_OUT, maximal_set);\n+\t      else \n+\t\tbitmap_set_and (ANTIC_OUT, ANTIC_IN (bprime));\n+\t    }\n \t}\n       VEC_free (basic_block, heap, worklist);\n     }\n@@ -1830,10 +1847,19 @@ compute_partial_antic_aux (basic_block block,\n \t      FOR_EACH_EXPR_ID_IN_SET (ANTIC_IN (bprime), i, bi)\n \t\tbitmap_value_insert_into_set (PA_OUT,\n \t\t\t\t\t      expression_for_id (i));\n-\n-\t      FOR_EACH_EXPR_ID_IN_SET (PA_IN (bprime), i, bi)\n-\t\tbitmap_value_insert_into_set (PA_OUT,\n-\t\t\t\t\t      expression_for_id (i));\n+\t      if (phi_nodes (bprime))\n+\t\t{\n+\t\t  bitmap_set_t pa_in = bitmap_set_new ();\n+\t\t  phi_translate_set (pa_in, PA_IN (bprime), block, bprime);\n+\t\t  FOR_EACH_EXPR_ID_IN_SET (pa_in, i, bi)\n+\t\t    bitmap_value_insert_into_set (PA_OUT,\n+\t\t\t\t\t\t  expression_for_id (i));\n+\t\t  bitmap_set_free (pa_in);\n+\t\t}\n+\t      else\n+\t\tFOR_EACH_EXPR_ID_IN_SET (PA_IN (bprime), i, bi)\n+\t\t  bitmap_value_insert_into_set (PA_OUT,\n+\t\t\t\t\t\texpression_for_id (i));\n \t    }\n \t}\n       VEC_free (basic_block, heap, worklist);\n@@ -1980,310 +2006,70 @@ compute_antic (void)\n   sbitmap_free (changed_blocks);\n }\n \n-/* Print the names represented by the bitmap NAMES, to the file OUT.  */\n+/*\n+   ANTIC_SAFE_LOADS are those loads generated in a block that actually\n+   occur before any kill to their vuses in the block, and thus, are\n+   safe at the top of the block.  This function computes the set by\n+   walking the EXP_GEN set for the block, and checking the VUSES.  \n \n-static void\n-dump_bitmap_of_names (FILE *out, bitmap names)\n-{\n-  bitmap_iterator bi;\n-  unsigned int i;\n-\n-  fprintf (out, \" { \");\n-  EXECUTE_IF_SET_IN_BITMAP (names, 0, i, bi)\n-    {\n-      print_generic_expr (out, ssa_name (i), 0);\n-      fprintf (out, \" \");\n-    }\n-  fprintf (out, \"}\\n\");\n-}\n-\n-  /* Compute a set of representative vuse versions for each phi.  This\n-     is so we can compute conservative kill sets in terms of all vuses\n-     that are killed, instead of continually walking chains.\n+   This set could be computed as ANTIC calculation is proceeding, but\n+   but because it does not actually change during that computation, it is\n+   quicker to pre-calculate the results and use them than to do it on\n+   the fly (particularly in the presence of multiple iteration).  */\n \n-     We also have to be able kill all names associated with a phi when\n-     the phi dies in order to ensure we don't generate overlapping\n-     live ranges, which are not allowed in virtual SSA.  */\n-\n-static bitmap *vuse_names;\n static void\n-compute_vuse_representatives (void)\n+compute_antic_safe (void)\n {\n-  tree phi;\n   basic_block bb;\n-  VEC (tree, heap) *phis = NULL;\n-  bool changed = true;\n-  size_t i;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      for (phi = phi_nodes (bb);\n-\t   phi;\n-\t   phi = PHI_CHAIN (phi))\n-\tif (!is_gimple_reg (PHI_RESULT (phi)))\n-\t  VEC_safe_push (tree, heap, phis, phi);\n-    }\n-\n-  while (changed)\n-    {\n-      changed = false;\n-\n-      for (i = 0; VEC_iterate (tree, phis, i, phi); i++)\n-\t{\n-\t  size_t ver = SSA_NAME_VERSION (PHI_RESULT (phi));\n-\t  use_operand_p usep;\n-\t  ssa_op_iter iter;\n-\n-\t  if (vuse_names[ver] == NULL)\n-\t    {\n-\t      vuse_names[ver] = BITMAP_ALLOC (&grand_bitmap_obstack);\n-\t      bitmap_set_bit (vuse_names[ver], ver);\n-\t    }\n-\t  FOR_EACH_PHI_ARG (usep, phi, iter, SSA_OP_ALL_USES)\n-\t    {\n-\t      tree use = USE_FROM_PTR (usep);\n-\t      bitmap usebitmap = get_representative (vuse_names,\n-\t\t\t\t\t\t     SSA_NAME_VERSION (use));\n-\t      if (usebitmap != NULL)\n-\t\t{\n-\t\t  changed |= bitmap_ior_into (vuse_names[ver],\n-\t\t\t\t\t      usebitmap);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  changed |= !bitmap_bit_p (vuse_names[ver],\n-\t\t\t\t\t    SSA_NAME_VERSION (use));\n-\t\t  if (changed)\n-\t\t    bitmap_set_bit (vuse_names[ver],\n-\t\t\t\t    SSA_NAME_VERSION (use));\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    for (i = 0; VEC_iterate (tree, phis, i, phi); i++)\n-      {\n-\tbitmap reps = get_representative (vuse_names,\n-\t\t\t\t\t  SSA_NAME_VERSION (PHI_RESULT (phi)));\n-\tif (reps)\n-\t  {\n-\t    print_generic_expr (dump_file, PHI_RESULT (phi), 0);\n-\t    fprintf (dump_file, \" represents \");\n-\t    dump_bitmap_of_names (dump_file, reps);\n-\t  }\n-      }\n-  VEC_free (tree, heap, phis);\n-}\n-\n-/* Compute reaching vuses and antic safe loads.  RVUSE computation is\n-   is a small bit of iterative dataflow to determine what virtual uses\n-   reach what blocks.  Because we can't generate overlapping virtual\n-   uses, and virtual uses *do* actually die, this ends up being faster\n-   in most cases than continually walking the virtual use/def chains\n-   to determine whether we are inside a block where a given virtual is\n-   still available to be used.\n-\n-   ANTIC_SAFE_LOADS are those loads that actually occur before any kill to\n-   their vuses in the block,and thus, are safe at the top of the\n-   block.\n-\n-   An example:\n-\n-   <block begin>\n-   b = *a\n-   *a = 9\n-   <block end>\n-\n-   b = *a is an antic safe load because it still safe to consider it\n-   ANTIC at the top of the block.\n-\n-   We currently compute a conservative approximation to\n-   ANTIC_SAFE_LOADS.  We compute those loads that occur before *any*\n-   stores in the block.  This is not because it is difficult to\n-   compute the precise answer, but because it is expensive.  More\n-   testing is necessary to determine whether it is worth computing the\n-   precise answer.  */\n-\n-static void\n-compute_rvuse_and_antic_safe (void)\n-{\n-\n+  bitmap_iterator bi;\n   unsigned int i;\n-  tree phi;\n-  basic_block bb;\n-  bool changed = true;\n-  unsigned int *first_store_uid;\n-\n-  first_store_uid = xcalloc (n_basic_blocks, sizeof (unsigned int));\n-\n-  compute_vuse_representatives ();\n-\n-  FOR_ALL_BB (bb)\n-    {\n-      RVUSE_IN (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n-      RVUSE_GEN (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n-      RVUSE_KILL (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n-      RVUSE_OUT (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n-      ANTIC_SAFE_LOADS (bb) = NULL;\n-    }\n-\n-  /* Mark live on entry */\n-  for (i = 0; i < num_ssa_names; i++)\n-    {\n-      tree name = ssa_name (i);\n-      if (name && !is_gimple_reg (name)\n-\t  && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (name)))\n-\tbitmap_set_bit (RVUSE_OUT (ENTRY_BLOCK_PTR),\n-\t\t\tSSA_NAME_VERSION (name));\n-    }\n-\n-  /* Compute local sets for reaching vuses.\n-     GEN(block) = generated in block and not locally killed.\n-     KILL(block) = set of vuses killed in block.\n-  */\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator bsi;\n-      ssa_op_iter iter;\n-      def_operand_p defp;\n-      use_operand_p usep;\n-\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  tree stmt = bsi_stmt (bsi);\n-\n-\t  if (first_store_uid[bb->index] == 0 \n-\t      && !ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYUSE | SSA_OP_VDEF))\n-\t    {\n-\t      first_store_uid[bb->index] = stmt_ann (stmt)->uid;\n-\t    }\n-\n-\t  FOR_EACH_SSA_USE_OPERAND (usep, stmt, iter, SSA_OP_VMAYUSE)\n-\t    {\n-\t      tree use = USE_FROM_PTR (usep);\n-\t      bitmap repbit = get_representative (vuse_names,\n-\t\t\t\t\t\t  SSA_NAME_VERSION (use));\n-\t      if (repbit != NULL)\n-\t\t{\n-\t\t  bitmap_and_compl_into (RVUSE_GEN (bb), repbit);\n-\t\t  bitmap_ior_into (RVUSE_KILL (bb), repbit);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  bitmap_set_bit (RVUSE_KILL (bb), SSA_NAME_VERSION (use));\n-\t\t  bitmap_clear_bit (RVUSE_GEN (bb), SSA_NAME_VERSION (use));\n-\t\t}\n-\t    }\n-\t  FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n-\t    {\n-\t      tree def = DEF_FROM_PTR (defp);\n-\t      bitmap_set_bit (RVUSE_GEN (bb), SSA_NAME_VERSION (def));\n-\t    }\n-\t}\n-    }\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  if (!is_gimple_reg (PHI_RESULT (phi)))\n-\t    {\n-\t      edge e;\n-\t      edge_iterator ei;\n-\n-\t      tree def = PHI_RESULT (phi);\n-\t      /* In reality, the PHI result is generated at the end of\n-\t\t each predecessor block.  This will make the value\n-\t\t LVUSE_IN for the bb containing the PHI, which is\n-\t\t correct.  */\n-\t      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\tbitmap_set_bit (RVUSE_GEN (e->src), SSA_NAME_VERSION (def));\n-\t    }\n-\t}\n-    }\n-\n-  /* Solve reaching vuses.\n-\n-     RVUSE_IN[BB] = Union of RVUSE_OUT of predecessors.\n-     RVUSE_OUT[BB] = RVUSE_GEN[BB] U (RVUSE_IN[BB] - RVUSE_KILL[BB])\n-  */\n-\n-  changed = true;\n-  while (changed)\n-    {\n-      int j;\n-      changed = false;\n-      for (j = n_basic_blocks - NUM_FIXED_BLOCKS - 1; j >= 0; j--)\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  bb = BASIC_BLOCK (postorder[j]);\n-\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    bitmap_ior_into (RVUSE_IN (bb), RVUSE_OUT (e->src));\n-\n-\t  changed |= bitmap_ior_and_compl (RVUSE_OUT (bb),\n-\t\t\t\t\t   RVUSE_GEN (bb),\n-\t\t\t\t\t   RVUSE_IN (bb),\n-\t\t\t\t\t   RVUSE_KILL (bb));\n-\t}\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      FOR_ALL_BB (bb)\n-\t{\n-\t  fprintf (dump_file, \"RVUSE_IN (%d) =\", bb->index);\n-\t  dump_bitmap_of_names (dump_file, RVUSE_IN (bb));\n-\n-\t  fprintf (dump_file, \"RVUSE_KILL (%d) =\", bb->index);\n-\t  dump_bitmap_of_names (dump_file, RVUSE_KILL (bb));\n-\n-\t  fprintf (dump_file, \"RVUSE_GEN (%d) =\", bb->index);\n-\t  dump_bitmap_of_names (dump_file, RVUSE_GEN (bb));\n-\n-\t  fprintf (dump_file, \"RVUSE_OUT (%d) =\", bb->index);\n-\t  dump_bitmap_of_names (dump_file, RVUSE_OUT (bb));\n-\t}\n-    }\n-\n+  \n   FOR_EACH_BB (bb)\n     {\n-      bitmap_iterator bi;\n-\n-      if (bitmap_empty_p (RVUSE_KILL (bb)))\n-\tcontinue;\n-\n       FOR_EACH_EXPR_ID_IN_SET (EXP_GEN (bb), i, bi)\n \t{\n \t  tree expr = expression_for_id (i);\n \t  if (REFERENCE_CLASS_P (expr))\n \t    {\n \t      tree vh = get_value_handle (expr);\n \t      tree maybe = bitmap_find_leader (AVAIL_OUT (bb), vh);\n-\n-\t      if (maybe)\n-\t\t{\n-\t\t  tree def = SSA_NAME_DEF_STMT (maybe);\n-\n+\t      ssa_op_iter i;\n+\t      tree vuse;\n+\t      tree stmt;\n+\t      bool okay = true;\n+\t      \n+\t      if (!maybe)\n+\t\tcontinue;\n+\t      stmt = SSA_NAME_DEF_STMT (maybe);\n+\t      \n+\t      FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, i,\n+\t\t\t\t\t SSA_OP_VIRTUAL_USES)\n+\t\t{\t\t      \n+\t\t  tree def = SSA_NAME_DEF_STMT (vuse);\n+\t\t  \n \t\t  if (bb_for_stmt (def) != bb)\n \t\t    continue;\n-\n-\t\t  if (TREE_CODE (def) == PHI_NODE\n-\t\t      || stmt_ann (def)->uid < first_store_uid[bb->index])\n+\t\t  \n+\t\t  /* See if the vuse is defined by a statement that\n+\t\t     comes before us in the block.  Phi nodes are not\n+\t\t     stores, so they do not count.  */\n+\t\t  if (TREE_CODE (def) != PHI_NODE\n+\t\t      && stmt_ann (def)->uid < stmt_ann (stmt)->uid)\n \t\t    {\n-\t\t      if (ANTIC_SAFE_LOADS (bb) == NULL)\n-\t\t\tANTIC_SAFE_LOADS (bb) = bitmap_set_new ();\n-\t\t      bitmap_value_insert_into_set (ANTIC_SAFE_LOADS (bb),\n-\t\t\t\t\t     expr);\n+\t\t      okay = false;      \n+\t\t      break;\n \t\t    }\n \t\t}\n+\t      if (okay)\n+\t\t{\n+\t\t  if (ANTIC_SAFE_LOADS (bb) == NULL)\n+\t\t    ANTIC_SAFE_LOADS (bb) = bitmap_set_new ();\n+\t\t  bitmap_value_insert_into_set (ANTIC_SAFE_LOADS (bb),\n+\t\t\t\t\t\texpr);\n+\t\t}\n \t    }\n \t}\n     }\n-  free (first_store_uid);\n }\n \n /* Return true if we can value number the call in STMT.  This is true\n@@ -2701,29 +2487,6 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \n       if (can_PRE_operation (eprime))\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  tree vh;\n-\n-\t  /* eprime may be an invariant.  */\n-\t  vh = TREE_CODE (eprime) == VALUE_HANDLE\n-\t    ? eprime\n-\t    : get_value_handle (eprime);\n-\n-\t  /* ensure that the virtual uses we need reach our block.  */\n-\t  if (TREE_CODE (vh) == VALUE_HANDLE)\n-\t    {\n-\t      int i;\n-\t      tree vuse;\n-\t      for (i = 0;\n-\t\t   VEC_iterate (tree, VALUE_HANDLE_VUSES (vh), i, vuse);\n-\t\t   i++)\n-\t\t{\n-\t\t  size_t id = SSA_NAME_VERSION (vuse);\n-\t\t  gcc_assert (bitmap_bit_p (RVUSE_OUT (bprime), id)\n-\t\t\t      || IS_EMPTY_STMT (SSA_NAME_DEF_STMT (vuse)));\n-\t\t}\n-\t    }\n-#endif\n \t  builtexpr = create_expression_by_pieces (bprime,\n \t\t\t\t\t\t   eprime,\n \t\t\t\t\t\t   stmts);\n@@ -4127,11 +3890,9 @@ execute_pre (bool do_fre)\n      computing ANTIC, either, even though it's plenty fast.  */\n   if (!do_fre && n_basic_blocks < 4000)\n     {\n-      vuse_names = XCNEWVEC (bitmap, num_ssa_names);\n-      compute_rvuse_and_antic_safe ();\n+      compute_antic_safe ();\n       compute_antic ();\n       insert ();\n-      free (vuse_names);\n     }\n \n   /* Remove all the redundant expressions.  */"}]}