{"sha": "c5a64cfec7388ddb685071d99dc7b23c918af16c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhNjRjZmVjNzM4OGRkYjY4NTA3MWQ5OWRjN2IyM2M5MThhZjE2Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-11-13T21:51:32Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-13T21:51:32Z"}, "message": "omp-low.c (scan_sharing_clauses): Accept INDEPENDENT, AUTO & SEQ.\n\n\tgcc/\n\t* gcc/omp-low.c (scan_sharing_clauses): Accept INDEPENDENT, AUTO &\n\tSEQ.\n\t(oacc_loop_fixed_partitions): Correct return type to bool.\n\t(oacc_loop_auto_partitions): New.\n\t(oacc_loop_partition): Take mask argument, call\n\toacc_loop_auto_partitions.\n\t(execute_oacc_device_lower): Provide mask to oacc_loop_partition.\n\n\tgcc/testsuite/\n\t* c-c++-common/goacc/loop-auto-1.c: New.\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/loop-auto-1.c: New.\n\nFrom-SVN: r230354", "tree": {"sha": "9bc316e20fe71f3245e275f4fa8f8192ebe85381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bc316e20fe71f3245e275f4fa8f8192ebe85381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5a64cfec7388ddb685071d99dc7b23c918af16c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a64cfec7388ddb685071d99dc7b23c918af16c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a64cfec7388ddb685071d99dc7b23c918af16c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a64cfec7388ddb685071d99dc7b23c918af16c/comments", "author": null, "committer": null, "parents": [{"sha": "7bcc3c8608f201d618b27dc6fbf3aaf176599033", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bcc3c8608f201d618b27dc6fbf3aaf176599033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bcc3c8608f201d618b27dc6fbf3aaf176599033"}], "stats": {"total": 549, "additions": 532, "deletions": 17}, "files": [{"sha": "00d587753c0c8a4c82e6e61cece27ee0e8065aef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5a64cfec7388ddb685071d99dc7b23c918af16c", "patch": "@@ -1,3 +1,13 @@\n+2015-11-13  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcc/omp-low.c (scan_sharing_clauses): Accept INDEPENDENT, AUTO &\n+\tSEQ.\n+\t(oacc_loop_fixed_partitions): Correct return type to bool.\n+\t(oacc_loop_auto_partitions): New.\n+\t(oacc_loop_partition): Take mask argument, call\n+\toacc_loop_auto_partitions.\n+\t(execute_oacc_device_lower): Provide mask to oacc_loop_partition.\n+\n 2015-11-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/constraints.md (we constraint): New constraint for"}, {"sha": "4b2b47772216724814c573015a4afa46d0bc75a5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c5a64cfec7388ddb685071d99dc7b23c918af16c", "patch": "@@ -2124,6 +2124,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_WORKER:\n \tcase OMP_CLAUSE_VECTOR:\n \tcase OMP_CLAUSE_TILE:\n+\tcase OMP_CLAUSE_INDEPENDENT:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -2136,9 +2139,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_DEVICE_RESIDENT:\n \tcase OMP_CLAUSE_USE_DEVICE:\n \tcase OMP_CLAUSE__CACHE_:\n-\tcase OMP_CLAUSE_INDEPENDENT:\n-\tcase OMP_CLAUSE_AUTO:\n-\tcase OMP_CLAUSE_SEQ:\n \t  sorry (\"Clause not supported yet\");\n \t  break;\n \n@@ -2299,14 +2299,14 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_WORKER:\n \tcase OMP_CLAUSE_VECTOR:\n \tcase OMP_CLAUSE_TILE:\n+\tcase OMP_CLAUSE_INDEPENDENT:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n \t  break;\n \n \tcase OMP_CLAUSE_DEVICE_RESIDENT:\n \tcase OMP_CLAUSE_USE_DEVICE:\n \tcase OMP_CLAUSE__CACHE_:\n-\tcase OMP_CLAUSE_INDEPENDENT:\n-\tcase OMP_CLAUSE_AUTO:\n-\tcase OMP_CLAUSE_SEQ:\n \t  sorry (\"Clause not supported yet\");\n \t  break;\n \n@@ -19230,10 +19230,10 @@ oacc_loop_process (oacc_loop *loop)\n \n /* Walk the OpenACC loop heirarchy checking and assigning the\n    programmer-specified partitionings.  OUTER_MASK is the partitioning\n-   this loop is contained within.  Return partitiong mask used within\n-   this loop nest.  */\n+   this loop is contained within.  Return true if we contain an\n+   auto-partitionable loop.  */\n \n-static unsigned\n+static bool\n oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n {\n   unsigned this_mask = loop->mask;\n@@ -19337,18 +19337,63 @@ oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n   return has_auto;\n }\n \n+/* Walk the OpenACC loop heirarchy to assign auto-partitioned loops.\n+   OUTER_MASK is the partitioning this loop is contained within.\n+   Return the cumulative partitioning used by this loop, siblings and\n+   children.  */\n+\n+static unsigned\n+oacc_loop_auto_partitions (oacc_loop *loop, unsigned outer_mask)\n+{\n+  unsigned inner_mask = 0;\n+  bool noisy = true;\n+\n+#ifdef ACCEL_COMPILER\n+  /* When device_type is supported, we want the device compiler to be\n+     noisy, if the loop parameters are device_type-specific.  */\n+  noisy = false;\n+#endif\n+\n+  if (loop->child)\n+    inner_mask |= oacc_loop_auto_partitions (loop->child,\n+\t\t\t\t\t     outer_mask | loop->mask);\n+\n+  if ((loop->flags & OLF_AUTO) && (loop->flags & OLF_INDEPENDENT))\n+    {\n+      unsigned this_mask = 0;\n+      \n+      /* Determine the outermost partitioning used within this loop. */\n+      this_mask = inner_mask | GOMP_DIM_MASK (GOMP_DIM_MAX);\n+      this_mask = (this_mask & -this_mask);\n+\n+      /* Pick the partitioning just inside that one.  */\n+      this_mask >>= 1;\n+\n+      /* And avoid picking one use by an outer loop. */\n+      this_mask &= ~outer_mask;\n+\n+      if (!this_mask && noisy)\n+\twarning_at (loop->loc, 0,\n+\t\t    \"insufficient partitioning available to parallelize loop\");\n+\n+      loop->mask = this_mask;\n+    }\n+  inner_mask |= loop->mask;\n+  \n+  if (loop->sibling)\n+    inner_mask |= oacc_loop_auto_partitions (loop->sibling, outer_mask);\n+\n+  return inner_mask;\n+}\n+\n /* Walk the OpenACC loop heirarchy to check and assign partitioning\n    axes.  */\n \n static void\n-oacc_loop_partition (oacc_loop *loop, int fn_level)\n+oacc_loop_partition (oacc_loop *loop, unsigned outer_mask)\n {\n-  unsigned outer_mask = 0;\n-\n-  if (fn_level >= 0)\n-    outer_mask = GOMP_DIM_MASK (fn_level) - 1;\n-\n-  oacc_loop_fixed_partitions (loop, outer_mask);\n+  if (oacc_loop_fixed_partitions (loop, outer_mask))\n+    oacc_loop_auto_partitions (loop, outer_mask);\n }\n \n /* Default fork/join early expander.  Delete the function calls if\n@@ -19429,7 +19474,8 @@ execute_oacc_device_lower ()\n \n   /* Discover, partition and process the loops.  */\n   oacc_loop *loops = oacc_loop_discovery ();\n-  oacc_loop_partition (loops, fn_level);\n+  unsigned outer_mask = fn_level >= 0 ? GOMP_DIM_MASK (fn_level) - 1 : 0;\n+  oacc_loop_partition (loops, outer_mask);\n   oacc_loop_process (loops);\n   if (dump_file)\n     {"}, {"sha": "33011306f354298406571506b6791ff5a3741847", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5a64cfec7388ddb685071d99dc7b23c918af16c", "patch": "@@ -1,5 +1,7 @@\n 2015-11-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* c-c++-common/goacc/loop-auto-1.c: New.\n+\n \t* lib/target-supports.exp (check_effective_target_offload_nvptx): New.\n \t* gcc.dg/goacc/nvptx-merged-loop.c: New.\n "}, {"sha": "ee6d28c2e8cb5701be3931fa948b4772823a866f", "filename": "gcc/testsuite/c-c++-common/goacc/loop-auto-1.c", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a64cfec7388ddb685071d99dc7b23c918af16c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-auto-1.c?ref=c5a64cfec7388ddb685071d99dc7b23c918af16c", "patch": "@@ -0,0 +1,230 @@\n+\n+void Foo ()\n+{\n+  \n+#pragma acc parallel num_gangs(10) num_workers(32) vector_length(32)\n+  {\n+#pragma acc loop vector\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop seq\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+      }\n+\n+#pragma acc loop worker\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop vector\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+      }\n+\n+#pragma acc loop gang\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+#pragma acc loop worker\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+#pragma acc loop vector\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop vector\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+      }\n+    \n+#pragma acc loop auto\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+      }\n+  }\n+}\n+\n+#pragma acc routine gang\n+void Gang (void)\n+{\n+#pragma acc loop vector\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop seq\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+      }\n+\n+#pragma acc loop worker\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop vector\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+      }\n+\n+#pragma acc loop gang\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+#pragma acc loop worker\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+#pragma acc loop vector\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop vector\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+\n+      }\n+    \n+#pragma acc loop auto\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+      }\n+}\n+\n+#pragma acc routine worker\n+void Worker (void)\n+{\n+#pragma acc loop vector\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop seq\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+      }\n+\n+#pragma acc loop worker\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop vector\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+      }\n+\n+#pragma acc loop auto\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+      }\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++)\n+\t  {\n+#pragma acc loop auto\n+\t    for (int kx = 0; kx < 10; kx++) {}\n+\t  }\n+      }\n+}\n+\n+#pragma acc routine vector\n+void Vector (void)\n+{\n+#pragma acc loop vector\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop seq\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+      }\n+\n+#pragma acc loop auto\n+    for (int ix = 0; ix < 10; ix++) {}\n+\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+    for (int ix = 0; ix < 10; ix++)\n+      {\n+#pragma acc loop auto\n+\tfor (int jx = 0; jx < 10; jx++) {}\n+      }\n+}\n+\n+#pragma acc routine seq\n+void Seq (void)\n+{\n+#pragma acc loop auto /* { dg-warning \"insufficient partitioning\" } */\n+    for (int ix = 0; ix < 10; ix++) {}\n+}"}, {"sha": "2f5a4d189daa6dca6d0d571d97d10321808691ff", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a64cfec7388ddb685071d99dc7b23c918af16c/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a64cfec7388ddb685071d99dc7b23c918af16c/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=c5a64cfec7388ddb685071d99dc7b23c918af16c", "patch": "@@ -1,5 +1,7 @@\n 2015-11-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* testsuite/libgomp.oacc-c-c++-common/loop-auto-1.c: New.\n+\n \t* testsuite/libgomp.oacc-c-c++-common/collapse-2.c: Sequential\n \tloop is sequential.\n "}, {"sha": "174af919792e5a8a526c1e5bbef0dea4b7743572", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-auto-1.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a64cfec7388ddb685071d99dc7b23c918af16c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-auto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a64cfec7388ddb685071d99dc7b23c918af16c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-auto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-auto-1.c?ref=c5a64cfec7388ddb685071d99dc7b23c918af16c", "patch": "@@ -0,0 +1,225 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O2\" */\n+\n+#include <stdio.h>\n+#include <openacc.h>\n+\n+int check (const int *ary, int size, int gp, int wp, int vp)\n+{\n+  int exit = 0;\n+  int ix;\n+  int gangs[32], workers[32], vectors[32];\n+\n+  for (ix = 0; ix < 32; ix++)\n+    gangs[ix] = workers[ix] = vectors[ix] = 0;\n+  \n+  for (ix = 0; ix < size; ix++)\n+    {\n+      vectors[ary[ix] & 0xff]++;\n+      workers[(ary[ix] >> 8) & 0xff]++;\n+      gangs[(ary[ix] >> 16) & 0xff]++;\n+    }\n+\n+  for (ix = 0; ix < 32; ix++)\n+    {\n+      if (gp)\n+\t{\n+\t  int expect = gangs[0];\n+\t  if (gangs[ix] != expect)\n+\t    {\n+\t      exit = 1;\n+\t      printf (\"gang %d not used %d times\\n\", ix, expect);\n+\t    }\n+\t}\n+      else if (ix && gangs[ix])\n+\t{\n+\t  exit = 1;\n+\t  printf (\"gang %d unexpectedly used\\n\", ix);\n+\t}\n+\n+      if (wp)\n+\t{\n+\t  int expect = workers[0];\n+\t  if (workers[ix] != expect)\n+\t    {\n+\t      exit = 1;\n+\t      printf (\"worker %d not used %d times\\n\", ix, expect);\n+\t    }\n+\t}\n+      else if (ix && workers[ix])\n+\t{\n+\t  exit = 1;\n+\t  printf (\"worker %d unexpectedly used\\n\", ix);\n+\t}\n+\n+      if (vp)\n+\t{\n+\t  int expect = vectors[0];\n+\t  if (vectors[ix] != expect)\n+\t    {\n+\t      exit = 1;\n+\t      printf (\"vector %d not used %d times\\n\", ix, expect);\n+\t    }\n+\t}\n+      else if (ix && vectors[ix])\n+\t{\n+\t  exit = 1;\n+\t  printf (\"vector %d unexpectedly used\\n\", ix);\n+\t}\n+      \n+    }\n+  return exit;\n+}\n+\n+#pragma acc routine seq\n+static int __attribute__((noinline)) place ()\n+{\n+  int r = 0;\n+\n+  if (acc_on_device (acc_device_nvidia))\n+    {\n+      int g = 0, w = 0, v = 0;\n+\n+      __asm__ volatile (\"mov.u32 %0,%%ctaid.x;\" : \"=r\" (g));\n+      __asm__ volatile (\"mov.u32 %0,%%tid.y;\" : \"=r\" (w));\n+      __asm__ volatile (\"mov.u32 %0,%%tid.x;\" : \"=r\" (v));\n+      r = (g << 16) | (w << 8) | v;\n+    }\n+  return r;\n+}\n+\n+static void clear (int *ary, int size)\n+{\n+  int ix;\n+\n+  for (ix = 0; ix < size; ix++)\n+    ary[ix] = -1;\n+}\n+\n+int vector_1 (int *ary, int size)\n+{\n+  clear (ary, size);\n+  \n+#pragma acc parallel num_workers (32) vector_length(32) copy(ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop auto\n+    for (int ix = 0; ix < size; ix++)\n+      ary[ix] = place ();\n+  }\n+\n+  return check (ary, size, 0, 0, 1);\n+}\n+\n+int vector_2 (int *ary, int size)\n+{\n+  clear (ary, size);\n+  \n+#pragma acc parallel num_workers (32) vector_length(32) copy(ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop worker\n+    for (int jx = 0; jx <  size  / 64; jx++)\n+#pragma acc loop auto\n+      for (int ix = 0; ix < 64; ix++)\n+\tary[ix + jx * 64] = place ();\n+  }\n+\n+  return check (ary, size, 0, 1, 1);\n+}\n+\n+int worker_1 (int *ary, int size)\n+{\n+  clear (ary, size);\n+  \n+#pragma acc parallel num_workers (32) vector_length(32) copy(ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop auto\n+    for (int jx = 0; jx <  size  / 64; jx++)\n+#pragma acc loop vector\n+      for (int ix = 0; ix < 64; ix++)\n+\tary[ix + jx * 64] = place ();\n+  }\n+\n+  return check (ary, size, 0, 1, 1);\n+}\n+\n+int worker_2 (int *ary, int size)\n+{\n+  clear (ary, size);\n+  \n+#pragma acc parallel num_workers (32) vector_length(32) copy(ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop auto\n+    for (int jx = 0; jx <  size  / 64; jx++)\n+#pragma acc loop auto\n+      for (int ix = 0; ix < 64; ix++)\n+\tary[ix + jx * 64] = place ();\n+  }\n+\n+  return check (ary, size, 0, 1, 1);\n+}\n+\n+int gang_1 (int *ary, int size)\n+{\n+  clear (ary, size);\n+  \n+#pragma acc parallel num_gangs (32) num_workers (32) vector_length(32) copy(ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop auto\n+    for (int jx = 0; jx <  size  / 64; jx++)\n+#pragma acc loop worker\n+      for (int ix = 0; ix < 64; ix++)\n+\tary[ix + jx * 64] = place ();\n+  }\n+\n+  return check (ary, size, 1, 1, 0);\n+}\n+\n+int gang_2 (int *ary, int size)\n+{\n+  clear (ary, size);\n+  \n+#pragma acc parallel num_gangs (32) num_workers (32) vector_length(32) copy(ary[0:size]) firstprivate (size)\n+  {\n+#pragma acc loop auto\n+    for (int kx = 0; kx < size / (32 * 32); kx++)\n+#pragma acc loop auto\n+      for (int jx = 0; jx <  32; jx++)\n+#pragma acc loop auto\n+\tfor (int ix = 0; ix < 32; ix++)\n+\t  ary[ix + jx * 32 + kx * 32 * 32] = place ();\n+  }\n+\n+  return check (ary, size, 1, 1, 1);\n+}\n+\n+#define N (32*32*32)\n+int main ()\n+{\n+  int ondev = 0;\n+\n+#pragma acc parallel copy(ondev)\n+  {\n+    ondev = acc_on_device (acc_device_not_host);\n+  }\n+  if (!ondev)\n+    return 0;\n+  \n+  int ary[N];\n+\n+  if (vector_1 (ary,  N))\n+    return 1;\n+  if (vector_2 (ary,  N))\n+    return 1;\n+\n+  if (worker_1 (ary,  N))\n+    return 1;\n+  if (worker_2 (ary,  N))\n+    return 1;\n+  \n+  if (gang_1 (ary,  N))\n+    return 1;\n+  if (gang_2 (ary,  N))\n+    return 1;\n+\n+  return 0;\n+}"}]}