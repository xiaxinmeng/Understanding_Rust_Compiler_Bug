{"sha": "99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlkMTMzMGI3OWE2Yjg0NTdiNDViYmEyYTdiOTk0MGIxZjJlOWFjZA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-05-10T21:37:35Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-05-10T22:31:49Z"}, "message": "Handle inherited type arguments for methods\n\nMethodCallExpr's support generic arguments so we need to handle adjusting\nany inherited type arguments from the receiver and apply them to the func.\n\nThis changes the handle_substitutions function for ADT, FnType and Params\nto be permissive that we can send single arguments to partially substitute\nthe type such as the case when we inherit arguments in methods calls. This\nis safe because the other interfaces enforce the type checking and number\nof arguments etc.\n\nFixes #423", "tree": {"sha": "43459717de6d35d858dce11932a29700444967d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43459717de6d35d858dce11932a29700444967d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ff2b34d5bf7bd4e9bb3cadcb72c1d91c8771f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff2b34d5bf7bd4e9bb3cadcb72c1d91c8771f82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ff2b34d5bf7bd4e9bb3cadcb72c1d91c8771f82"}], "stats": {"total": 305, "additions": 218, "deletions": 87}, "files": [{"sha": "3e081ec30d29c310d728b467c5df9399139ed95b", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "patch": "@@ -255,13 +255,70 @@ class TypeCheckExpr : public TypeCheckBase\n \tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver_tyty);\n \tif (adt->has_substitutions () && fn->needs_substitution ())\n \t  {\n-\t    rust_assert (adt->was_substituted ());\n-\t    auto used_args_in_prev_segment = GetUsedSubstArgs::From (adt);\n-\t    lookup\n-\t      = SubstMapperInternal::Resolve (fn, used_args_in_prev_segment);\n+\t    // consider the case where we have:\n+\t    //\n+\t    // struct Foo<X,Y>(X,Y);\n+\t    //\n+\t    // impl<T> Foo<T, i32> {\n+\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t    // }\n+\t    //\n+\t    // In this case we end up with an fn type of:\n+\t    //\n+\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t    //\n+\t    // This means the instance or self we are calling this method for\n+\t    // will be substituted such that we can get the inherited type\n+\t    // arguments but then need to use the turbo fish if available or\n+\t    // infer the remaining arguments. Luckily rust does not allow for\n+\t    // default types GenericParams on impl blocks since these must\n+\t    // always be at the end of the list\n+\n+\t    auto s = fn->get_self_type ();\n+\t    rust_assert (s->can_eq (adt));\n+\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t    TyTy::ADTType *self_adt = static_cast<TyTy::ADTType *> (s);\n+\n+\t    // we need to grab the Self substitutions as the inherit type\n+\t    // parameters for this\n+\t    if (self_adt->needs_substitution ())\n+\t      {\n+\t\trust_assert (adt->was_substituted ());\n+\n+\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t  = GetUsedSubstArgs::From (adt);\n+\n+\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n+\t\t    used_args_in_prev_segment);\n+\n+\t\t// there may or may not be inherited type arguments\n+\t\tif (!inherit_type_args.is_error ())\n+\t\t  {\n+\t\t    // need to apply the inherited type arguments to the\n+\t\t    // function\n+\t\t    lookup = fn->handle_substitions (inherit_type_args);\n+\t\t  }\n+\t      }\n \t  }\n       }\n \n+    // apply any remaining generic arguments\n+    if (expr.get_method_name ().has_generic_args ())\n+      {\n+\tHIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+\tlookup\n+\t  = SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n+\t\t\t\t  &args);\n+\tif (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+    else if (lookup->needs_generic_substitutions ())\n+      {\n+\tlookup = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\t  expr.get_method_name ().get_locus ());\n+      }\n+\n     TyTy::BaseType *function_ret_tyty\n       = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n     if (function_ret_tyty == nullptr"}, {"sha": "e74ab936417afc5fbde5ec85c46b61dbacd7a920", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 80, "deletions": 83, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "patch": "@@ -247,6 +247,9 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n       return SubstitutionArgumentMappings::error ();\n     }\n \n+  // for inherited arguments\n+  size_t offs = used_arguments.size ();\n+\n   std::vector<SubstitutionArg> mappings;\n   for (auto &arg : args.get_type_args ())\n     {\n@@ -257,8 +260,8 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n \t  return SubstitutionArgumentMappings::error ();\n \t}\n \n-      SubstitutionArg subst_arg (&substitutions.at (mappings.size ()),\n-\t\t\t\t resolved);\n+      SubstitutionArg subst_arg (&substitutions.at (offs), resolved);\n+      offs++;\n       mappings.push_back (std::move (subst_arg));\n     }\n \n@@ -345,6 +348,31 @@ SubstitutionRef::adjust_mappings_for_this (\n \t\t\t\t       mappings.get_locus ());\n }\n \n+// this function assumes that the mappings being passed are for the same type as\n+// this new substitution reference so ordering matters here\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_mappings_from_receiver_for_self (\n+  SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  rust_assert (mappings.size () == get_num_substitutions ());\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      SubstitutionParamMapping &param_mapping = substitutions.at (i);\n+      SubstitutionArg &arg = mappings.get_mappings ().at (i);\n+\n+      if (param_mapping.needs_substitution ())\n+\t{\n+\t  SubstitutionArg adjusted (&param_mapping, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_locus ());\n+}\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -457,13 +485,6 @@ ADTType::clone ()\n ADTType *\n ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n-  if (subst_mappings.size () != get_num_substitutions ())\n-    {\n-      rust_error_at (subst_mappings.get_locus (),\n-\t\t     \"invalid number of generic arguments to generic ADT type\");\n-      return nullptr;\n-    }\n-\n   ADTType *adt = static_cast<ADTType *> (clone ());\n   adt->set_ty_ref (mappings->get_next_hir_id ());\n   adt->used_arguments = subst_mappings;\n@@ -473,8 +494,8 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       SubstitutionArg arg = SubstitutionArg::error ();\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n-      rust_assert (ok);\n-      sub.fill_param_ty (arg.get_tyty ());\n+      if (ok)\n+\tsub.fill_param_ty (arg.get_tyty ());\n     }\n \n   adt->iterate_fields ([&] (StructFieldType *field) mutable -> bool {\n@@ -486,27 +507,22 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n \tSubstitutionArg arg = SubstitutionArg::error ();\n \tbool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n-\tif (!ok)\n-\t  {\n-\t    rust_error_at (subst_mappings.get_locus (),\n-\t\t\t   \"Failed to resolve parameter type: %s\",\n-\t\t\t   p->as_string ().c_str ());\n-\t    return false;\n-\t  }\n-\n-\tauto argt = arg.get_tyty ();\n-\tbool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n-\n-\tif (arg_is_param || arg_is_concrete)\n-\t  {\n-\t    auto new_field = argt->clone ();\n-\t    new_field->set_ref (fty->get_ref ());\n-\t    field->set_field_type (new_field);\n-\t  }\n-\telse\n+\tif (ok)\n \t  {\n-\t    field->get_field_type ()->set_ty_ref (argt->get_ref ());\n+\t    auto argt = arg.get_tyty ();\n+\t    bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t    bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t    if (arg_is_param || arg_is_concrete)\n+\t      {\n+\t\tauto new_field = argt->clone ();\n+\t\tnew_field->set_ref (fty->get_ref ());\n+\t\tfield->set_field_type (new_field);\n+\t      }\n+\t    else\n+\t      {\n+\t\tfield->get_field_type ()->set_ty_ref (argt->get_ref ());\n+\t      }\n \t  }\n       }\n     else if (fty->has_subsititions_defined ()\n@@ -695,14 +711,6 @@ FnType::clone ()\n FnType *\n FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n-  if (subst_mappings.size () != get_num_substitutions ())\n-    {\n-      rust_error_at (\n-\tsubst_mappings.get_locus (),\n-\t\"invalid number of generic arguments to generic Function type\");\n-      return nullptr;\n-    }\n-\n   FnType *fn = static_cast<FnType *> (clone ());\n   fn->set_ty_ref (mappings->get_next_hir_id ());\n   fn->used_arguments = subst_mappings;\n@@ -713,8 +721,8 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n-      rust_assert (ok);\n-      sub.fill_param_ty (arg.get_tyty ());\n+      if (ok)\n+\tsub.fill_param_ty (arg.get_tyty ());\n     }\n \n   auto fty = fn->get_return_type ();\n@@ -725,27 +733,22 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n       SubstitutionArg arg = SubstitutionArg::error ();\n       bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n-      if (!ok)\n+      if (ok)\n \t{\n-\t  rust_error_at (subst_mappings.get_locus (),\n-\t\t\t \"Failed to resolve parameter type: %s\",\n-\t\t\t p->as_string ().c_str ());\n-\t  return nullptr;\n-\t}\n-\n-      auto argt = arg.get_tyty ();\n-      bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n-      bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n \n-      if (arg_is_param || arg_is_concrete)\n-\t{\n-\t  auto new_field = argt->clone ();\n-\t  new_field->set_ref (fty->get_ref ());\n-\t  fn->type = new_field;\n-\t}\n-      else\n-\t{\n-\t  fty->set_ty_ref (argt->get_ref ());\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      fn->type = new_field;\n+\t    }\n+\t  else\n+\t    {\n+\t      fty->set_ty_ref (argt->get_ref ());\n+\t    }\n \t}\n     }\n   else if (fty->needs_generic_substitutions ()\n@@ -778,27 +781,22 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n \t  SubstitutionArg arg = SubstitutionArg::error ();\n \t  bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n-\t  if (!ok)\n+\t  if (ok)\n \t    {\n-\t      rust_error_at (subst_mappings.get_locus (),\n-\t\t\t     \"Failed to resolve parameter type: %s\",\n-\t\t\t     p->as_string ().c_str ());\n-\t      return nullptr;\n-\t    }\n-\n-\t  auto argt = arg.get_tyty ();\n-\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n-\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n-\n-\t  if (arg_is_param || arg_is_concrete)\n-\t    {\n-\t      auto new_field = argt->clone ();\n-\t      new_field->set_ref (fty->get_ref ());\n-\t      param.second = new_field;\n-\t    }\n-\t  else\n-\t    {\n-\t      fty->set_ty_ref (argt->get_ref ());\n+\t      auto argt = arg.get_tyty ();\n+\t      bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t      bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t      if (arg_is_param || arg_is_concrete)\n+\t\t{\n+\t\t  auto new_field = argt->clone ();\n+\t\t  new_field->set_ref (fty->get_ref ());\n+\t\t  param.second = new_field;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fty->set_ty_ref (argt->get_ref ());\n+\t\t}\n \t    }\n \t}\n       else if (fty->has_subsititions_defined ()\n@@ -1396,9 +1394,8 @@ ParamType::handle_substitions (SubstitutionArgumentMappings mappings)\n \n   SubstitutionArg arg = SubstitutionArg::error ();\n   bool ok = mappings.get_argument_for_symbol (this, &arg);\n-  rust_assert (ok);\n-\n-  p->set_ty_ref (arg.get_tyty ()->get_ref ());\n+  if (ok)\n+    p->set_ty_ref (arg.get_tyty ()->get_ref ());\n \n   return p;\n }"}, {"sha": "74250307cee758cfd9ce9ad162621dd3bc174911", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "patch": "@@ -698,6 +698,21 @@ class SubstitutionRef\n   SubstitutionArgumentMappings\n   adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n \n+  // struct Foo<A, B>(A, B);\n+  //\n+  // impl<T> Foo<T, f32>;\n+  //     -> fn test<X>(self, a: X) -> X\n+  //\n+  // We might invoke this via:\n+  //\n+  // a = Foo(123, 456f32);\n+  // b = a.test::<bool>(false);\n+  //\n+  // we need to figure out relevant generic arguemts for self to apply to the\n+  // fntype\n+  SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n+    SubstitutionArgumentMappings &mappings);\n+\n   BaseType *infer_substitions (Location locus)\n   {\n     std::vector<SubstitutionArg> args;"}, {"sha": "e09a1044574fbc6deb565b89af482603194d7cd9", "filename": "gcc/testsuite/rust.test/compile/generics29.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics29.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics29.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics29.rs?ref=99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "patch": "@@ -0,0 +1,16 @@\n+struct Foo<A, B>(A, B);\n+\n+impl Foo<i32, f32> {\n+    fn test<X>(self, a: X) -> X {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test::<bool>(false);\n+}"}, {"sha": "229f6d1254b76b5b55ed6df7d48fa1fcc06e67ca", "filename": "gcc/testsuite/rust.test/compile/generics30.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics30.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics30.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics30.rs?ref=99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "patch": "@@ -0,0 +1,16 @@\n+struct Foo<A, B>(A, B);\n+\n+impl<T> Foo<T, f32> {\n+    fn test<X>(self, a: X) -> X {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test::<bool>(false);\n+}"}, {"sha": "68ad4bf9a96f1d6a6bcbac4389ee682d96ab5e42", "filename": "gcc/testsuite/rust.test/compile/generics31.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics31.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics31.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics31.rs?ref=99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "patch": "@@ -0,0 +1,15 @@\n+struct Foo<A, B>(A, B);\n+\n+impl<T> Foo<T, f32> {\n+    fn test<X>(self, a: X) -> (T, X) {\n+        (self.0, a)\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test::<bool>(false);\n+}"}, {"sha": "21b9cae7409656e7bfa88f4eb59fc87ecfa7d683", "filename": "gcc/testsuite/rust.test/compile/generics32.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics32.rs?ref=99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "patch": "@@ -0,0 +1,15 @@\n+struct Foo<A, B>(A, B);\n+\n+impl<T> Foo<T, f32> {\n+    fn test<X>(self, a: X) -> (T, X) {\n+        (self.0, a)\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test(false);\n+}"}]}