{"sha": "f781e7e5af1a787e14014485df8d7fc9e6fd5f06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc4MWU3ZTVhZjFhNzg3ZTE0MDE0NDg1ZGY4ZDdmYzllNmZkNWYwNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-17T23:47:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-17T23:47:58Z"}, "message": "compiler: support new numeric literal syntax\n    \n    Support 0b, 0o, and hex floats.\n    \n    Tested against test/literal2.go in the gc repo.\n    \n    Updates golang/go#12711\n    Updates golang/go#19308\n    Updates golang/go#28493\n    Updates golang/go#29008\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/189718\n\nFrom-SVN: r274614", "tree": {"sha": "59750280927d5567c17a476791cea376217a6cbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59750280927d5567c17a476791cea376217a6cbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f781e7e5af1a787e14014485df8d7fc9e6fd5f06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f781e7e5af1a787e14014485df8d7fc9e6fd5f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f781e7e5af1a787e14014485df8d7fc9e6fd5f06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f781e7e5af1a787e14014485df8d7fc9e6fd5f06/comments", "author": null, "committer": null, "parents": [{"sha": "e68035acfd6997ed97eb32aec4f277f3b6858550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68035acfd6997ed97eb32aec4f277f3b6858550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68035acfd6997ed97eb32aec4f277f3b6858550"}], "stats": {"total": 289, "additions": 224, "deletions": 65}, "files": [{"sha": "74577f57adeb86e262b01b26ad7b415f8ce0dbb5", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f781e7e5af1a787e14014485df8d7fc9e6fd5f06/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f781e7e5af1a787e14014485df8d7fc9e6fd5f06/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f781e7e5af1a787e14014485df8d7fc9e6fd5f06", "patch": "@@ -1,4 +1,4 @@\n-4b47cadf938caadf563f8d0bb3f7111d06f61752\n+85857977230437f2b3dcbeea009efbb8b2789039\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3276de4f5d8401d7aab689382f969ede3a722805", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 216, "deletions": 63, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f781e7e5af1a787e14014485df8d7fc9e6fd5f06/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f781e7e5af1a787e14014485df8d7fc9e6fd5f06/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=f781e7e5af1a787e14014485df8d7fc9e6fd5f06", "patch": "@@ -986,6 +986,26 @@ Lex::is_hex_digit(char c)\n \t  || (c >= 'a' && c <= 'f'));\n }\n \n+// Return whether C is a valid digit in BASE.\n+\n+bool\n+Lex::is_base_digit(int base, char c)\n+{\n+  switch (base)\n+    {\n+    case 2:\n+      return c == '0' || c == '1';\n+    case 8:\n+      return c >= '0' && c <= '7';\n+    case 10:\n+      return c >= '0' && c <= '9';\n+    case 16:\n+      return Lex::is_hex_digit(c);\n+    default:\n+      go_unreachable();\n+    }\n+}\n+\n // not a hex value\n #define NHV 100\n \n@@ -1032,13 +1052,24 @@ Lex::hex_val(char c)\n   return hex_value_lookup_table[static_cast<unsigned char>(c)];\n }\n \n-// Return whether an exponent could start at P.\n+// Return whether an exponent could start at P, in base BASE.\n \n bool\n-Lex::could_be_exponent(const char* p, const char* pend)\n+Lex::could_be_exponent(int base, const char* p, const char* pend)\n {\n-  if (*p != 'e' && *p != 'E')\n-    return false;\n+  switch (base)\n+    {\n+    case 10:\n+      if (*p != 'e' && *p != 'E')\n+\treturn false;\n+      break;\n+    case 16:\n+      if (*p != 'p' && *p != 'P')\n+\treturn false;\n+      break;\n+    default:\n+      go_unreachable();\n+    }\n   ++p;\n   if (p >= pend)\n     return false;\n@@ -1062,87 +1093,160 @@ Lex::gather_number()\n \n   Location location = this->location();\n \n-  bool neg = false;\n-  if (*p == '+')\n-    ++p;\n-  else if (*p == '-')\n-    {\n-      ++p;\n-      neg = true;\n-    }\n-\n-  const char* pnum = p;\n+  int base = 10;\n+  std::string num;\n   if (*p == '0')\n     {\n-      int base;\n-      if ((p[1] == 'x' || p[1] == 'X')\n-\t  && Lex::is_hex_digit(p[2]))\n+      int basecheck;\n+      int off;\n+      if (p[1] == 'x' || p[1] == 'X')\n \t{\n \t  base = 16;\n-\t  p += 2;\n-\t  pnum = p;\n-\t  while (p < pend)\n-\t    {\n-\t      if (!Lex::is_hex_digit(*p))\n-\t\tbreak;\n-\t      ++p;\n-\t    }\n+\t  basecheck = 16;\n+\t  off = 2;\n+\t}\n+      else if (p[1] == 'o' || p[1] == 'O')\n+\t{\n+\t  base = 8;\n+\t  basecheck = 8;\n+\t  off = 2;\n+\t}\n+      else if (p[1] == 'b' || p[1] == 'B')\n+\t{\n+\t  base = 2;\n+\t  basecheck = 2;\n+\t  off = 2;\n \t}\n       else\n \t{\n+\t  // Old style octal literal.  May also be the start of a\n+\t  // floating-point number (e.g., 09.2, 09e2) or an imaginary\n+\t  // literal (e.g., 09i), so we have to accept decimal digits.\n \t  base = 8;\n-\t  pnum = p;\n-\t  while (p < pend)\n-\t    {\n-\t      if (*p < '0' || *p > '9')\n-\t\tbreak;\n-\t      ++p;\n-\t    }\n+\t  basecheck = 10;\n+\t  off = 0;\n+\t}\n+\n+      p += off;\n+      if (*p == '_' && Lex::is_base_digit(basecheck, p[1]))\n+\t++p;\n+\n+      while (Lex::is_base_digit(basecheck, *p))\n+\t{\n+\t  num.push_back(*p);\n+\t  ++p;\n+\t  if (*p == '_' && Lex::is_base_digit(basecheck, p[1]))\n+\t    ++p;\n+\t}\n+\n+      // We must see at least one valid digit, except for a case like\n+      // 0x.0p1.\n+      if (num.length() == 0 && (base != 16 || *p != '.'))\n+\t{\n+\t  go_error_at(this->location(), \"invalid numeric literal\");\n+\t  this->lineoff_ = p - this->linebuf_;\n+\t  mpz_t val;\n+\t  mpz_init_set_ui(val, 0);\n+\t  Token ret = Token::make_integer_token(val, location);\n+\t  mpz_clear(val);\n+\t  return ret;\n+\t}\n+\n+      bool is_float = false;\n+      // A number that looks like an old-style octal literal might\n+      // actually be the beginning of a floating-point or imaginary\n+      // literal, in which case the value is decimal digits.  Handle\n+      // that case below by treating the leading '0' as decimal.\n+      if (off == 0\n+\t  && (*p == '.' || *p == 'i' || Lex::could_be_exponent(10, p, pend)))\n+\t{\n+\t  is_float = true;\n+\t  base = 10;\n \t}\n+      else if (base == 16\n+\t       && (*p == '.' || Lex::could_be_exponent(16, p, pend)))\n+\tis_float = true;\n \n-      // A partial token that looks like an octal literal might actually be the\n-      // beginning of a floating-point or imaginary literal.\n-      if (base == 16 || (*p != '.' && *p != 'i' && !Lex::could_be_exponent(p, pend)))\n+      if (!is_float)\n \t{\n-\t  std::string s(pnum, p - pnum);\n \t  mpz_t val;\n-\t  int r = mpz_init_set_str(val, s.c_str(), base);\n+\t  int r = mpz_init_set_str(val, num.c_str(), base);\n           if (r != 0)\n             {\n-              if (base == 8)\n-                go_error_at(this->location(), \"invalid octal literal\");\n-              else\n-                go_error_at(this->location(), \"invalid hex literal\");\n+\t      const char *errword;\n+\t      switch (base)\n+\t\t{\n+\t\tcase 2:\n+\t\t  errword = \"binary\";\n+\t\t  break;\n+\t\tcase 8:\n+\t\t  errword = \"octal\";\n+\t\t  break;\n+\t\tcase 16:\n+\t\t  errword = \"hex\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  go_unreachable();\n+\t\t}\n+\t      go_error_at(this->location(), \"invalid %s literal\", errword);\n             }\n \n-\t  if (neg)\n-\t    mpz_neg(val, val);\n+\t  bool is_imaginary = *p == 'i';\n+\t  if (is_imaginary)\n+\t    ++p;\n \n \t  this->lineoff_ = p - this->linebuf_;\n-\t  Token ret = Token::make_integer_token(val, location);\n-\t  mpz_clear(val);\n-\t  return ret;\n+\n+\t  if (*p == 'e' || *p == 'E' || *p == 'p' || *p == 'P')\n+\t    {\n+\t      go_error_at(location,\n+\t\t\t  \"invalid prefix for floating constant\");\n+\t      this->skip_exponent();\n+\t    }\n+\n+\t  if (!is_imaginary)\n+\t    {\n+\t      Token ret = Token::make_integer_token(val, location);\n+\t      mpz_clear(val);\n+\t      return ret;\n+\t    }\n+\t  else\n+\t    {\n+\t      mpfr_t ival;\n+\t      mpfr_init_set_z(ival, val, GMP_RNDN);\n+\t      mpz_clear(val);\n+\t      Token ret = Token::make_imaginary_token(ival, location);\n+\t      mpfr_clear(ival);\n+\t      return ret;\n+\t    }\n \t}\n     }\n \n   while (p < pend)\n     {\n-      if (*p < '0' || *p > '9')\n+      if (*p == '_' && p[1] >= '0' && p[1] <= '9')\n+\t++p;\n+      else if (*p < '0' || *p > '9')\n \tbreak;\n+      num.push_back(*p);\n       ++p;\n     }\n \n-  if (*p != '.' && *p != 'i' && !Lex::could_be_exponent(p, pend))\n+  if (*p != '.' && *p != 'i' && !Lex::could_be_exponent(base, p, pend))\n     {\n-      std::string s(pnum, p - pnum);\n       mpz_t val;\n-      int r = mpz_init_set_str(val, s.c_str(), 10);\n+      int r = mpz_init_set_str(val, num.c_str(), 10);\n       go_assert(r == 0);\n \n-      if (neg)\n-\tmpz_neg(val, val);\n-\n       this->lineoff_ = p - this->linebuf_;\n+\n+      if (*p == 'e' || *p == 'E' || *p == 'p' || *p == 'P')\n+\t{\n+\t  go_error_at(location,\n+\t\t      \"invalid prefix for floating constant\");\n+\t  this->skip_exponent();\n+\t}\n+\n       Token ret = Token::make_integer_token(val, location);\n       mpz_clear(val);\n       return ret;\n@@ -1152,48 +1256,76 @@ Lex::gather_number()\n     {\n       bool dot = *p == '.';\n \n+      num.push_back(*p);\n       ++p;\n \n       if (!dot)\n \t{\n \t  if (*p == '+' || *p == '-')\n-\t    ++p;\n+\t    {\n+\t      num.push_back(*p);\n+\t      ++p;\n+\t    }\n \t}\n \n+      bool first = true;\n       while (p < pend)\n \t{\n-\t  if (*p < '0' || *p > '9')\n+\t  if (!first && *p == '_' && Lex::is_base_digit(base, p[1]))\n+\t    ++p;\n+\t  else if (!Lex::is_base_digit(base, *p))\n \t    break;\n+\t  num.push_back(*p);\n \t  ++p;\n+\t  first = false;\n \t}\n \n-      if (dot && Lex::could_be_exponent(p, pend))\n+      if (dot && Lex::could_be_exponent(base, p, pend))\n \t{\n+\t  num.push_back(*p);\n \t  ++p;\n \t  if (*p == '+' || *p == '-')\n-\t    ++p;\n+\t    {\n+\t      num.push_back(*p);\n+\t      ++p;\n+\t    }\n+\t  first = true;\n \t  while (p < pend)\n \t    {\n-\t      if (*p < '0' || *p > '9')\n+\t      if (!first && *p == '_' && p[1] >= '0' && p[1] <= '9')\n+\t\t++p;\n+\t      else if (*p < '0' || *p > '9')\n \t\tbreak;\n+\t      num.push_back(*p);\n \t      ++p;\n+\t      first = false;\n \t    }\n \t}\n+      else if (dot && base == 16)\n+\t{\n+\t  go_error_at(this->location(),\n+\t\t      \"invalid hex floating-point literal with no exponent\");\n+\t  num.append(\"p0\");\n+\t}\n     }\n \n-  std::string s(pnum, p - pnum);\n   mpfr_t val;\n-  int r = mpfr_init_set_str(val, s.c_str(), 10, GMP_RNDN);\n+  int r = mpfr_init_set_str(val, num.c_str(), base, GMP_RNDN);\n   go_assert(r == 0);\n \n-  if (neg)\n-    mpfr_neg(val, val, GMP_RNDN);\n-\n   bool is_imaginary = *p == 'i';\n   if (is_imaginary)\n     ++p;\n \n   this->lineoff_ = p - this->linebuf_;\n+\n+  if (*p == 'e' || *p == 'E' || *p == 'p' || *p == 'P')\n+    {\n+      go_error_at(location,\n+\t\t  \"invalid prefix for floating constant\");\n+      this->skip_exponent();\n+    }\n+\n   if (is_imaginary)\n     {\n       Token ret = Token::make_imaginary_token(val, location);\n@@ -1208,6 +1340,27 @@ Lex::gather_number()\n     }\n }\n \n+// Skip an exponent after reporting an error.\n+\n+void\n+Lex::skip_exponent()\n+{\n+  const char* p = this->linebuf_ + this->lineoff_;\n+  const char* pend = this->linebuf_ + this->linesize_;\n+  if (*p != 'e' && *p != 'E' && *p != 'p' && *p != 'P')\n+    return;\n+  ++p;\n+  if (*p == '+' || *p == '-')\n+    ++p;\n+  while (p < pend)\n+    {\n+      if ((*p < '0' || *p > '9') && *p != '_')\n+\tbreak;\n+      ++p;\n+    }\n+  this->lineoff_ = p - this->linebuf_;\n+}\n+\n // Advance one character, possibly escaped.  Return the pointer beyond\n // the character.  Set *VALUE to the character.  Set *IS_CHARACTER if\n // this is a character (e.g., 'a' or '\\u1234') rather than a byte"}, {"sha": "59b770ca94a0212bac728a3b0eae5ce027987def", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f781e7e5af1a787e14014485df8d7fc9e6fd5f06/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f781e7e5af1a787e14014485df8d7fc9e6fd5f06/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=f781e7e5af1a787e14014485df8d7fc9e6fd5f06", "patch": "@@ -462,6 +462,9 @@ class Lex\n   static bool\n   is_hex_digit(char);\n \n+  static bool\n+  is_base_digit(int base, char);\n+\n   static unsigned char\n   octal_value(char c)\n   { return c - '0'; }\n@@ -482,11 +485,14 @@ class Lex\n   gather_identifier();\n \n   static bool\n-  could_be_exponent(const char*, const char*);\n+  could_be_exponent(int base, const char*, const char*);\n \n   Token\n   gather_number();\n \n+  void\n+  skip_exponent();\n+\n   Token\n   gather_character();\n "}]}