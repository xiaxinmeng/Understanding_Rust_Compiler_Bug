{"sha": "44a10091cf20b5f4580c4e7bc33e8162acce97dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRhMTAwOTFjZjIwYjVmNDU4MGM0ZTdiYzMzZTgxNjJhY2NlOTdkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:18:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:18:09Z"}, "message": "[multiple changes]\n\n2011-08-05  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Set_All_DT_Position): Cleanup code and improve support\n\tfor renamings of predefined primitives.\n\t(In_Predef_Prims_DT): New subprogram.\n\n2011-08-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb, sem_util.ads (Check_Implicit_Dereference): If a\n\tpossible interpretation of name is a reference type, add an\n\tinterpretation that is the designated type of the reference\n\tdiscriminant of that type.\n\t* sem_res.adb (resolve): If the interpretation imposed by context is an\n\timplicit dereference, rewrite the node as the deference of the\n\treference discriminant.\n\t* sem_ch3.adb (Analyze_Subtype_Declaration, Build_Derived_Record_Type,\n\tBuild_Discriminated_Subtype): Inherit Has_Implicit_Dereference from\n\tparent type or base type.\n\t* sem_ch4.adb (Process_Indexed_Component,\n\tProcess_Overloaded_Indexed_Component, Indicate_Name_And_Type,\n\tAnalyze_Overloaded_Selected_Component, Analyze_Selected_Component):\n\tCheck for implicit dereference.\n\t(List_Operand_Interps): Indicate when an implicit dereference is\n\tambiguous.\n\t* sem_ch8.adb (Find_Direct_Name): Check for implicit dereference.\n\n2011-08-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* scos.ads: Update documentation of SCO table. Pragma statements can now\n\tbe marked as disabled (using 'p' instead of 'P' as the statement kind).\n\t* par_sco.ads, par_sco.adb: Implement the above change.\n\t(Process_Decisions_Defer): Generate a P decision for the first parameter\n\tof a dyadic pragma Debug.\n\t* sem_prag.adb (Analyze_Pragma, case Debug): Mark pragma as enabled if\n\tnecessary.\n\t* put_scos.adb: Code simplification based on above change.\n\nFrom-SVN: r177442", "tree": {"sha": "1a26e8ca549a60121572a15150d39632dbafbb1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a26e8ca549a60121572a15150d39632dbafbb1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44a10091cf20b5f4580c4e7bc33e8162acce97dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a10091cf20b5f4580c4e7bc33e8162acce97dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a10091cf20b5f4580c4e7bc33e8162acce97dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a10091cf20b5f4580c4e7bc33e8162acce97dc/comments", "author": null, "committer": null, "parents": [{"sha": "bb3c784c7dad97ec1ed3fafead1986d4319a5246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb3c784c7dad97ec1ed3fafead1986d4319a5246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb3c784c7dad97ec1ed3fafead1986d4319a5246"}], "stats": {"total": 505, "additions": 371, "deletions": 134}, "files": [{"sha": "13fdfccabd368a41869f57939a07148323ca46b6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -1,3 +1,40 @@\n+2011-08-05  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Set_All_DT_Position): Cleanup code and improve support\n+\tfor renamings of predefined primitives.\n+\t(In_Predef_Prims_DT): New subprogram.\n+\n+2011-08-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb, sem_util.ads (Check_Implicit_Dereference): If a\n+\tpossible interpretation of name is a reference type, add an\n+\tinterpretation that is the designated type of the reference\n+\tdiscriminant of that type.\n+\t* sem_res.adb (resolve): If the interpretation imposed by context is an\n+\timplicit dereference, rewrite the node as the deference of the\n+\treference discriminant.\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration, Build_Derived_Record_Type,\n+\tBuild_Discriminated_Subtype): Inherit Has_Implicit_Dereference from\n+\tparent type or base type.\n+\t* sem_ch4.adb (Process_Indexed_Component,\n+\tProcess_Overloaded_Indexed_Component, Indicate_Name_And_Type,\n+\tAnalyze_Overloaded_Selected_Component, Analyze_Selected_Component):\n+\tCheck for implicit dereference.\n+\t(List_Operand_Interps): Indicate when an implicit dereference is\n+\tambiguous.\n+\t* sem_ch8.adb (Find_Direct_Name): Check for implicit dereference.\n+\n+2011-08-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* scos.ads: Update documentation of SCO table. Pragma statements can now\n+\tbe marked as disabled (using 'p' instead of 'P' as the statement kind).\n+\t* par_sco.ads, par_sco.adb: Implement the above change.\n+\t(Process_Decisions_Defer): Generate a P decision for the first parameter\n+\tof a dyadic pragma Debug.\n+\t* sem_prag.adb (Analyze_Pragma, case Debug): Mark pragma as enabled if\n+\tnecessary.\n+\t* put_scos.adb: Code simplification based on above change.\n+\n 2011-08-05  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, gnatcmd.adb, switch-c.adb, exp_attr.adb, make.adb,"}, {"sha": "10c0d799e7e2f842e165c1ebf760185612c49c11", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -7722,11 +7722,59 @@ package body Exp_Disp is\n \n    procedure Set_All_DT_Position (Typ : Entity_Id) is\n \n+      function In_Predef_Prims_DT (Prim : Entity_Id) return Boolean;\n+      --  Returns True if Prim is located in the dispatch table of\n+      --  predefined primitives\n+\n       procedure Validate_Position (Prim : Entity_Id);\n       --  Check that the position assigned to Prim is completely safe\n       --  (it has not been assigned to a previously defined primitive\n       --   operation of Typ)\n \n+      ------------------------\n+      -- In_Predef_Prims_DT --\n+      ------------------------\n+\n+      function In_Predef_Prims_DT (Prim : Entity_Id) return Boolean is\n+         E : Entity_Id;\n+\n+      begin\n+         --  Predefined primitives\n+\n+         if Is_Predefined_Dispatching_Operation (Prim) then\n+            return True;\n+\n+         --  Renamings of predefined primitives\n+\n+         elsif Present (Alias (Prim))\n+           and then Is_Predefined_Dispatching_Operation (Ultimate_Alias (Prim))\n+         then\n+            if Chars (Ultimate_Alias (Prim)) /= Name_Op_Eq then\n+               return True;\n+\n+            --  User-defined renamings of predefined equality have their own\n+            --  slot in the primary dispatch table\n+\n+            else\n+               E := Prim;\n+               while Present (Alias (E)) loop\n+                  if Comes_From_Source (E) then\n+                     return False;\n+                  end if;\n+\n+                  E := Alias (E);\n+               end loop;\n+\n+               return not Comes_From_Source (E);\n+            end if;\n+\n+         --  User-defined primitives\n+\n+         else\n+            return False;\n+         end if;\n+      end In_Predef_Prims_DT;\n+\n       -----------------------\n       -- Validate_Position --\n       -----------------------\n@@ -7850,10 +7898,7 @@ package body Exp_Disp is\n \n          --  Predefined primitives have a separate dispatch table\n \n-         if not (Is_Predefined_Dispatching_Operation (Prim)\n-                   or else\n-                 Is_Predefined_Dispatching_Alias (Prim))\n-         then\n+         if not In_Predef_Prims_DT (Prim) then\n             Count_Prim := Count_Prim + 1;\n          end if;\n \n@@ -7978,12 +8023,14 @@ package body Exp_Disp is\n             --  Predefined primitives have a separate table and all its\n             --  entries are at predefined fixed positions.\n \n-            if Is_Predefined_Dispatching_Operation (Prim) then\n-               Set_DT_Position (Prim, Default_Prim_Op_Position (Prim));\n+            if In_Predef_Prims_DT (Prim) then\n+               if Is_Predefined_Dispatching_Operation (Prim) then\n+                  Set_DT_Position (Prim, Default_Prim_Op_Position (Prim));\n \n-            elsif Is_Predefined_Dispatching_Alias (Prim) then\n-               Set_DT_Position (Prim,\n-                 Default_Prim_Op_Position (Ultimate_Alias (Prim)));\n+               else pragma Assert (Present (Alias (Prim)));\n+                  Set_DT_Position (Prim,\n+                    Default_Prim_Op_Position (Ultimate_Alias (Prim)));\n+               end if;\n \n             --  Overriding primitives of ancestor abstract interfaces\n \n@@ -8124,8 +8171,7 @@ package body Exp_Disp is\n \n          --  Calculate real size of the dispatch table\n \n-         if not (Is_Predefined_Dispatching_Operation (Prim)\n-                   or else Is_Predefined_Dispatching_Alias (Prim))\n+         if not In_Predef_Prims_DT (Prim)\n            and then UI_To_Int (DT_Position (Prim)) > DT_Length\n          then\n             DT_Length := UI_To_Int (DT_Position (Prim));\n@@ -8134,8 +8180,8 @@ package body Exp_Disp is\n          --  Ensure that the assigned position to non-predefined\n          --  dispatching operations in the dispatch table is correct.\n \n-         if not (Is_Predefined_Dispatching_Operation (Prim)\n-                   or else Is_Predefined_Dispatching_Alias (Prim))\n+         if not Is_Predefined_Dispatching_Operation (Prim)\n+           and then not Is_Predefined_Dispatching_Alias (Prim)\n          then\n             Validate_Position (Prim);\n          end if;"}, {"sha": "e9c17bd07aacc325b8ab8a23e89191ddb28c8058", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -315,7 +315,6 @@ begin\n \n             declare\n                Loc : Source_Location;\n-               C2v : Character;\n \n             begin\n                --  Acquire location information\n@@ -326,18 +325,9 @@ begin\n                   Get_Source_Location (Loc);\n                end if;\n \n-               --  C2 is a space except for pragmas where it is 'e' since\n-               --  clearly the pragma is enabled if it was written out.\n-\n-               if C = 'P' then\n-                  C2v := 'e';\n-               else\n-                  C2v := ' ';\n-               end if;\n-\n                Add_SCO\n                  (C1   => Dtyp,\n-                  C2   => C2v,\n+                  C2   => ' ',\n                   From => Loc,\n                   To   => No_Source_Location,\n                   Last => False);"}, {"sha": "8f76dd25039b4613d3e8a93bd718a32d08090c50", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 115, "deletions": 80, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -69,9 +69,9 @@ package body Par_SCO is\n \n    --  We need to be able to get to conditions quickly for handling the calls\n    --  to Set_SCO_Condition efficiently, and similarly to get to pragmas to\n-   --  handle calls to Set_SCO_Pragma_Enabled. For this purpose we identify the\n-   --  conditions and pragmas in the table by their starting sloc, and use this\n-   --  hash table to map from these starting sloc values to SCO_Table indexes.\n+   --  handle calls to Set_SCO_Pragma_Enabled. For this purpose we identify\n+   --  the conditions and pragmas in the table by their starting sloc, and use\n+   --  this hash table to map from these sloc values to SCO_Table indexes.\n \n    type Header_Num is new Integer range 0 .. 996;\n    --  Type for hash table headers\n@@ -101,15 +101,21 @@ package body Par_SCO is\n    --  excluding OR and AND) and returns True if so, False otherwise, it does\n    --  no other processing.\n \n-   procedure Process_Decisions (N : Node_Id; T : Character);\n+   procedure Process_Decisions\n+     (N           : Node_Id;\n+      T           : Character;\n+      Pragma_Sloc : Source_Ptr);\n    --  If N is Empty, has no effect. Otherwise scans the tree for the node N,\n    --  to output any decisions it contains. T is one of IEGPWX (for context of\n    --  expression: if/exit when/entry guard/pragma/while/expression). If T is\n    --  other than X, the node N is the conditional expression involved, and a\n    --  decision is always present (at the very least a simple decision is\n    --  present at the top level).\n \n-   procedure Process_Decisions (L : List_Id; T : Character);\n+   procedure Process_Decisions\n+     (L           : List_Id;\n+      T           : Character;\n+      Pragma_Sloc : Source_Ptr);\n    --  Calls above procedure for each element of the list L\n \n    procedure Set_Table_Entry\n@@ -316,25 +322,32 @@ package body Par_SCO is\n \n    --  Version taking a list\n \n-   procedure Process_Decisions (L : List_Id; T : Character) is\n+   procedure Process_Decisions\n+     (L           : List_Id;\n+      T           : Character;\n+      Pragma_Sloc : Source_Ptr)\n+   is\n       N : Node_Id;\n    begin\n       if L /= No_List then\n          N := First (L);\n          while Present (N) loop\n-            Process_Decisions (N, T);\n+            Process_Decisions (N, T, Pragma_Sloc);\n             Next (N);\n          end loop;\n       end if;\n    end Process_Decisions;\n \n    --  Version taking a node\n \n-   Pragma_Sloc : Source_Ptr := No_Location;\n-   --  While processing decisions within a pragma Assert/Debug/PPC, this is set\n-   --  to the sloc of the pragma.\n+   Current_Pragma_Sloc : Source_Ptr := No_Location;\n+   --  While processing a pragma, this is set to the sloc of the N_Pragma node\n \n-   procedure Process_Decisions (N : Node_Id; T : Character) is\n+   procedure Process_Decisions\n+     (N           : Node_Id;\n+      T           : Character;\n+      Pragma_Sloc : Source_Ptr)\n+   is\n       Mark : Nat;\n       --  This is used to mark the location of a decision sequence in the SCO\n       --  table. We use it for backing out a simple decision in an expression\n@@ -466,14 +479,6 @@ package body Par_SCO is\n \n                Loc := Sloc (Parent (Parent (N)));\n \n-               if T = 'P' then\n-\n-                  --  Record sloc of pragma (pragmas don't nest)\n-\n-                  pragma Assert (Pragma_Sloc = No_Location);\n-                  Pragma_Sloc := Loc;\n-               end if;\n-\n             when 'X' =>\n \n                --  For an expression, no Sloc\n@@ -493,17 +498,6 @@ package body Par_SCO is\n             To          => No_Location,\n             Last        => False,\n             Pragma_Sloc => Pragma_Sloc);\n-\n-         if T = 'P' then\n-\n-            --  For pragmas we also must make an entry in the hash table for\n-            --  later access by Set_SCO_Pragma_Enabled. We set the pragma as\n-            --  disabled now, the call will change C2 to 'e' to enable the\n-            --  pragma header entry.\n-\n-            SCO_Table.Table (SCO_Table.Last).C2 := 'd';\n-            Condition_Pragma_Hash_Table.Set (Loc, SCO_Table.Last);\n-         end if;\n       end Output_Header;\n \n       ------------------------------\n@@ -521,7 +515,7 @@ package body Par_SCO is\n             Process_Decision_Operand (Right_Opnd (N));\n \n          else\n-            Process_Decisions (N, 'X');\n+            Process_Decisions (N, 'X', Pragma_Sloc);\n          end if;\n       end Process_Decision_Operand;\n \n@@ -595,9 +589,9 @@ package body Par_SCO is\n                   Thnx : constant Node_Id := Next (Cond);\n                   Elsx : constant Node_Id := Next (Thnx);\n                begin\n-                  Process_Decisions (Cond, 'I');\n-                  Process_Decisions (Thnx, 'X');\n-                  Process_Decisions (Elsx, 'X');\n+                  Process_Decisions (Cond, 'I', Pragma_Sloc);\n+                  Process_Decisions (Thnx, 'X', Pragma_Sloc);\n+                  Process_Decisions (Elsx, 'X', Pragma_Sloc);\n                   return Skip;\n                end;\n \n@@ -635,12 +629,6 @@ package body Par_SCO is\n       end if;\n \n       Traverse (N);\n-\n-      --  Reset Pragma_Sloc after full subtree traversal\n-\n-      if T = 'P' then\n-         Pragma_Sloc := No_Location;\n-      end if;\n    end Process_Decisions;\n \n    -----------\n@@ -771,8 +759,12 @@ package body Par_SCO is\n       --  disabled.\n \n       if Index /= 0 then\n-         pragma Assert (SCO_Table.Table (Index).C1 = 'P');\n-         return SCO_Table.Table (Index).C2 = 'd';\n+         declare\n+            T : SCO_Table_Entry renames SCO_Table.Table (Index);\n+         begin\n+            pragma Assert (T.C1 = 'S' or else T.C1 = 's');\n+            return T.C2 = 'p';\n+         end;\n \n       else\n          return False;\n@@ -899,8 +891,17 @@ package body Par_SCO is\n       --  The test here for zero is to deal with possible previous errors\n \n       if Index /= 0 then\n-         pragma Assert (SCO_Table.Table (Index).C1 = 'P');\n-         SCO_Table.Table (Index).C2 := 'e';\n+         declare\n+            T : SCO_Table_Entry renames SCO_Table.Table (Index);\n+         begin\n+            --  Called multiple times for the same sloc (need to allow for\n+            --  C2 = 'P') ???\n+\n+            pragma Assert ((T.C1 = 'S' or else T.C1 = 's')\n+                             and then\n+                           (T.C2 = 'p' or else T.C2 = 'P'));\n+            T.C2 := 'P';\n+         end;\n       end if;\n    end Set_SCO_Pragma_Enabled;\n \n@@ -987,12 +988,14 @@ package body Par_SCO is\n       Nod : Node_Id;\n       Lst : List_Id;\n       Typ : Character;\n+      Plo : Source_Ptr;\n    end record;\n    --  Used to store a single entry in the following table. Nod is the node to\n    --  be searched for decisions for the case of Process_Decisions_Defer with a\n    --  node argument (with Lst set to No_List. Lst is the list to be searched\n    --  for decisions for the case of Process_Decisions_Defer with a List\n-   --  argument (in which case Nod is set to Empty).\n+   --  argument (in which case Nod is set to Empty). Plo is the sloc of the\n+   --  enclosing pragma, if any.\n \n    package SD is new Table.Table (\n      Table_Component_Type => SD_Entry,\n@@ -1077,11 +1080,15 @@ package body Par_SCO is\n                SCE         : SC_Entry renames SC.Table (J);\n                Pragma_Sloc : Source_Ptr := No_Location;\n             begin\n-               --  For the statement SCO for a pragma, set Pragma_Sloc so that\n-               --  the SCO can be omitted if the pragma is disabled.\n+               --  For the statement SCO for a pragma controlled by\n+               --  Set_SCO_Pragma_Enable, set Pragma_Sloc so that the SCO (and\n+               --  those of any nested decision) is emitted only if the pragma\n+               --  is enabled.\n \n-               if SCE.Typ = 'P' then\n+               if SCE.Typ = 'p' then\n                   Pragma_Sloc := SCE.From;\n+                  Condition_Pragma_Hash_Table.Set\n+                    (Pragma_Sloc, SCO_Table.Last + 1);\n                end if;\n \n                Set_Table_Entry\n@@ -1105,9 +1112,9 @@ package body Par_SCO is\n                SDE : SD_Entry renames SD.Table (J);\n             begin\n                if Present (SDE.Nod) then\n-                  Process_Decisions (SDE.Nod, SDE.Typ);\n+                  Process_Decisions (SDE.Nod, SDE.Typ, SDE.Plo);\n                else\n-                  Process_Decisions (SDE.Lst, SDE.Typ);\n+                  Process_Decisions (SDE.Lst, SDE.Typ, SDE.Plo);\n                end if;\n             end;\n          end loop;\n@@ -1148,12 +1155,12 @@ package body Par_SCO is\n \n       procedure Process_Decisions_Defer (N : Node_Id; T : Character) is\n       begin\n-         SD.Append ((N, No_List, T));\n+         SD.Append ((N, No_List, T, Current_Pragma_Sloc));\n       end Process_Decisions_Defer;\n \n       procedure Process_Decisions_Defer (L : List_Id; T : Character) is\n       begin\n-         SD.Append ((Empty, L, T));\n+         SD.Append ((Empty, L, T, Current_Pragma_Sloc));\n       end Process_Decisions_Defer;\n \n    --  Start of processing for Traverse_Declarations_Or_Statements\n@@ -1391,42 +1398,70 @@ package body Par_SCO is\n                --  Pragma\n \n                when N_Pragma =>\n-                  Extend_Statement_Sequence (N, 'P');\n+\n+                  --  Record sloc of pragma (pragmas don't nest)\n+\n+                  pragma Assert (Current_Pragma_Sloc = No_Location);\n+                  Current_Pragma_Sloc := Sloc (N);\n \n                   --  Processing depends on the kind of pragma\n \n-                  case Pragma_Name (N) is\n-                     when Name_Assert        |\n-                          Name_Check         |\n-                          Name_Precondition  |\n-                          Name_Postcondition =>\n-\n-                        --  For Assert/Check/Precondition/Postcondition, we\n-                        --  must generate a P entry for the decision. Note that\n-                        --  this is done unconditionally at this stage. Output\n-                        --  for disabled pragmas is suppressed later on, when\n-                        --  we output the decision line in Put_SCOs.\n-\n-                        declare\n-                           Nam : constant Name_Id :=\n-                                   Chars (Pragma_Identifier (N));\n-                           Arg : Node_Id :=\n-                                   First (Pragma_Argument_Associations (N));\n-\n-                        begin\n+                  declare\n+                     Nam : constant Name_Id := Pragma_Name (N);\n+                     Arg : Node_Id := First (Pragma_Argument_Associations (N));\n+                     Typ : Character;\n+\n+                  begin\n+                     case Nam is\n+                        when Name_Assert        |\n+                             Name_Check         |\n+                             Name_Precondition  |\n+                             Name_Postcondition =>\n+\n+                           --  For Assert/Check/Precondition/Postcondition, we\n+                           --  must generate a P entry for the decision. Note\n+                           --  that this is done unconditionally at this stage.\n+                           --  Output for disabled pragmas is suppressed later\n+                           --  on, when we output the decision line in\n+                           --  Put_SCOs, depending on marker sets by\n+                           --  Set_SCO_Pragma_Disabled.\n+\n                            if Nam = Name_Check then\n                               Next (Arg);\n                            end if;\n \n                            Process_Decisions_Defer (Expression (Arg), 'P');\n-                        end;\n+                           Typ := 'p';\n \n-                     --  For all other pragmas, we generate decision entries\n-                     --  for any embedded expressions.\n+                        when Name_Debug =>\n+                           if Present (Arg) and then Present (Next (Arg)) then\n \n-                     when others =>\n-                        Process_Decisions_Defer (N, 'X');\n-                  end case;\n+                              --  Case of a dyadic pragma Debug: first argument\n+                              --  is a P decision, any nested decision in the\n+                              --  second argument is an X decision.\n+\n+                              Process_Decisions_Defer (Expression (Arg), 'P');\n+                              Next (Arg);\n+                           end if;\n+\n+                           Process_Decisions_Defer (Expression (Arg), 'X');\n+                           Typ := 'p';\n+\n+                        --  For all other pragmas, we generate decision entries\n+                        --  for any embedded expressions, and the pragma is\n+                        --  never disabled.\n+\n+                        when others =>\n+                           Process_Decisions_Defer (N, 'X');\n+                           Typ := 'P';\n+                     end case;\n+\n+                     --  Add statement SCO\n+\n+                     Extend_Statement_Sequence (N, Typ);\n+\n+                     Current_Pragma_Sloc := No_Location;\n+                  end;\n \n                --  Object declaration. Ignored if Prev_Ids is set, since the\n                --  parser generates multiple instances of the whole declaration\n@@ -1512,7 +1547,7 @@ package body Par_SCO is\n \n       --  Now output any embedded decisions\n \n-      Process_Decisions (N, 'X');\n+      Process_Decisions (N, 'X', No_Location);\n    end Traverse_Generic_Instantiation;\n \n    ------------------------------------------\n@@ -1521,7 +1556,7 @@ package body Par_SCO is\n \n    procedure Traverse_Generic_Package_Declaration (N : Node_Id) is\n    begin\n-      Process_Decisions (Generic_Formal_Declarations (N), 'X');\n+      Process_Decisions (Generic_Formal_Declarations (N), 'X', No_Location);\n       Traverse_Package_Declaration (N);\n    end Traverse_Generic_Package_Declaration;\n "}, {"sha": "5bcad0c30b50a593cd78273e578d90162230cb3c", "filename": "gcc/ada/par_sco.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -50,9 +50,9 @@ package Par_SCO is\n    --  original tree associated with Cond.\n \n    procedure Set_SCO_Pragma_Enabled (Loc : Source_Ptr);\n-   --  This procedure is called from Sem_Prag when a pragma is enabled (i.e.\n-   --  when the Pragma_Enabled flag is set). Loc is the Sloc of the N_Pragma\n-   --  node. This is used to enable the corresponding SCO table entry. Note\n+   --  This procedure is called from Sem_Prag when a pragma is disabled (i.e.\n+   --  when the Pragma_Enabled flag is unset). Loc is the Sloc of the N_Pragma\n+   --  node. This is used to disable the corresponding SCO table entry. Note\n    --  that we use the Sloc as the key here, since in the generic case, the\n    --  analysis is on a copy of the node, which is different from the node\n    --  seen by Par_SCO in the parse tree (but the Sloc values are the same)."}, {"sha": "65dfbc80046d7e338fd50d12770cada95de49f86", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -107,9 +107,8 @@ begin\n                      Ctr := 0;\n                      Continuation := False;\n                      loop\n-                        if SCO_Table.Table (Start).C2 = 'P'\n-                             and then SCO_Pragma_Disabled\n-                                        (SCO_Table.Table (Start).Pragma_Sloc)\n+                        if SCO_Pragma_Disabled\n+                             (SCO_Table.Table (Start).Pragma_Sloc)\n                         then\n                            goto Next_Statement;\n                         end if;\n@@ -160,13 +159,10 @@ begin\n                   when 'I' | 'E' | 'G' | 'P' | 'W' | 'X' =>\n                      Start := Start + 1;\n \n-                     --  For disabled pragma, or nested decision nested, skip\n+                     --  For disabled pragma, or nested decision therein, skip\n                      --  decision output.\n \n-                     if (T.C1 = 'P' and then T.C2 = 'd')\n-                          or else\n-                        SCO_Pragma_Disabled (T.Pragma_Sloc)\n-                     then\n+                     if SCO_Pragma_Disabled (T.Pragma_Sloc) then\n                         while not SCO_Table.Table (Start).Last loop\n                            Start := Start + 1;\n                         end loop;"}, {"sha": "bdf5610c59e19b4094940de06ce241712914776d", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -152,6 +152,7 @@ package SCOs is\n    --      E  EXIT statement\n    --      F  FOR loop statement (from FOR through end of iteration scheme)\n    --      I  IF statement (from IF through end of condition)\n+   --      p  disabled PRAGMA\n    --      P  PRAGMA\n    --      R  extended RETURN statement\n    --      W  WHILE loop statement (from WHILE through end of condition)\n@@ -194,12 +195,12 @@ package SCOs is\n    --    Decisions are either simple or complex. A simple decision is a top\n    --    level boolean expression that has only one condition and that occurs\n    --    in the context of a control structure in the source program, including\n-   --    WHILE, IF, EXIT WHEN, or in an Assert, Check, Pre_Condition or\n-   --    Post_Condition pragma. For pragmas, decision SCOs are generated only\n-   --    if the corresponding pragma is enabled. Note that a top level boolean\n-   --    expression with only one condition that occurs in any other context,\n-   --    for example as right hand side of an assignment, is not considered to\n-   --    be a (simple) decision.\n+   --    WHILE, IF, EXIT WHEN, or immediately within an Assert, Check,\n+   --    Pre_Condition or Post_Condition pragma, or as the first argument of a\n+   --    dyadic pragma Debug. Note that a top level boolean expression with\n+   --    only one condition that occurs in any other context, for example as\n+   --    right hand side of an assignment, is not considered to be a (simple)\n+   --    decision.\n \n    --    A complex decision is a top level boolean expression that has more\n    --    than one condition. A complex decision may occur in any boolean\n@@ -336,6 +337,10 @@ package SCOs is\n    --    entries appear in one logical statement sequence, continuation lines\n    --    are marked by Cc and appear immediately after the CC line.\n \n+   --  Disabled pragmas\n+\n+   --    No SCO is generated for disabled pragmas.\n+\n    ---------------------------------------------------------------------\n    -- Internal table used to store Source Coverage Obligations (SCOs) --\n    ---------------------------------------------------------------------\n@@ -392,22 +397,19 @@ package SCOs is\n \n    --    Decision (PRAGMA)\n    --      C1   = 'P'\n-   --      C2   = 'e'/'d' for enabled/disabled\n+   --      C2   = ' '\n    --      From = PRAGMA token\n    --      To   = No_Source_Location\n    --      Last = unused\n \n    --      Note: when the parse tree is first scanned, we unconditionally build\n    --      a pragma decision entry for any decision in a pragma (here as always\n    --      in SCO contexts, the only pragmas with decisions are Assert, Check,\n-   --      Precondition and Postcondition), and we mark the pragma as disabled.\n-   --\n-   --      During analysis, if the pragma is enabled, Set_SCO_Pragma_Enabled to\n-   --      mark the SCO decision table entry as enabled (C2 set to 'e'). Then\n-   --      in Put_SCOs, we only output the decision for a pragma if C2 is 'e'.\n+   --      dyadic Debug, Precondition and Postcondition).\n    --\n-   --      When we read SCOs from an ALI file (in Get_SCOs), we always set C2\n-   --      to 'e', since clearly the pragma is enabled if it was written out.\n+   --      During analysis, if the pragma is enabled, Set_SCO_Pragma_Enabled\n+   --      marks the statement SCO table entry as enaabled (C1 changed from 'p'\n+   --      to 'P') to cause the entry to be emitted in Put_SCOs.\n \n    --    Decision (Expression)\n    --      C1   = 'X'"}, {"sha": "c0187d7a2dc8fcd6c698fb3ce8c674fc274f1f59", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -4215,6 +4215,8 @@ package body Sem_Ch3 is\n                Set_Has_Discriminants    (Id, Has_Discriminants  (T));\n                Set_Is_Constrained       (Id, Is_Constrained     (T));\n                Set_Is_Limited_Record    (Id, Is_Limited_Record  (T));\n+               Set_Has_Implicit_Dereference\n+                                        (Id, Has_Implicit_Dereference (T));\n                Set_Has_Unknown_Discriminants\n                                         (Id, Has_Unknown_Discriminants (T));\n \n@@ -4248,6 +4250,8 @@ package body Sem_Ch3 is\n                Set_Last_Entity        (Id, Last_Entity           (T));\n                Set_Private_Dependents (Id, New_Elmt_List);\n                Set_Is_Limited_Record  (Id, Is_Limited_Record     (T));\n+               Set_Has_Implicit_Dereference\n+                                        (Id, Has_Implicit_Dereference (T));\n                Set_Has_Unknown_Discriminants\n                                       (Id, Has_Unknown_Discriminants (T));\n                Set_Known_To_Have_Preelab_Init\n@@ -7875,6 +7879,8 @@ package body Sem_Ch3 is\n             Set_Stored_Constraint\n               (Derived_Type, Expand_To_Stored_Constraint (Parent_Type, Discs));\n             Replace_Components (Derived_Type, New_Decl);\n+            Set_Has_Implicit_Dereference\n+              (Derived_Type, Has_Implicit_Dereference (Parent_Type));\n          end if;\n \n          --  Insert the new derived type declaration\n@@ -8586,6 +8592,8 @@ package body Sem_Ch3 is\n \n       Set_First_Entity      (Def_Id, First_Entity   (T));\n       Set_Last_Entity       (Def_Id, Last_Entity    (T));\n+      Set_Has_Implicit_Dereference\n+                            (Def_Id, Has_Implicit_Dereference (T));\n \n       --  If the subtype is the completion of a private declaration, there may\n       --  have been representation clauses for the partial view, and they must"}, {"sha": "e2521687627a3d7ba20461a2c4742ffed2ec0c1e", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -301,7 +301,24 @@ package body Sem_Ch4 is\n                Nam := Opnd;\n             elsif Nkind (Opnd) = N_Function_Call then\n                Nam := Name (Opnd);\n-            else\n+            elsif Ada_Version >= Ada_2012 then\n+               declare\n+                  It : Interp;\n+                  I  : Interp_Index;\n+\n+               begin\n+                  Get_First_Interp (Opnd, I, It);\n+                  while Present (It.Nam) loop\n+                     if Has_Implicit_Dereference (It.Typ) then\n+                        Error_Msg_N\n+                          (\"can be interpreted as implicit dereference\", Opnd);\n+                        return;\n+                     end if;\n+\n+                     Get_Next_Interp (I, It);\n+                  end loop;\n+               end;\n+\n                return;\n             end if;\n \n@@ -2068,6 +2085,7 @@ package body Sem_Ch4 is\n             end loop;\n \n             Set_Etype (N, Component_Type (Array_Type));\n+            Check_Implicit_Dereference (N, Etype (N));\n \n             if Present (Index) then\n                Error_Msg_N\n@@ -2164,9 +2182,13 @@ package body Sem_Ch4 is\n                end loop;\n \n                if Found and then No (Index) and then No (Exp) then\n-                  Add_One_Interp (N,\n-                     Etype (Component_Type (Typ)),\n-                     Etype (Component_Type (Typ)));\n+                  declare\n+                     CT : constant Entity_Id :=\n+                            Base_Type (Component_Type (Typ));\n+                  begin\n+                     Add_One_Interp (N, CT, CT);\n+                     Check_Implicit_Dereference (N, CT);\n+                  end;\n                end if;\n             end if;\n \n@@ -2644,6 +2666,7 @@ package body Sem_Ch4 is\n       procedure Indicate_Name_And_Type is\n       begin\n          Add_One_Interp (N, Nam, Etype (Nam));\n+         Check_Implicit_Dereference (N, Etype (Nam));\n          Success := True;\n \n          --  If the prefix of the call is a name, indicate the entity\n@@ -3133,6 +3156,7 @@ package body Sem_Ch4 is\n                      Set_Entity (Sel, Comp);\n                      Set_Etype (Sel, Etype (Comp));\n                      Add_One_Interp (N, Etype (Comp), Etype (Comp));\n+                     Check_Implicit_Dereference (N, Etype (Comp));\n \n                      --  This also specifies a candidate to resolve the name.\n                      --  Further overloading will be resolved from context.\n@@ -3740,6 +3764,7 @@ package body Sem_Ch4 is\n            New_Occurrence_Of (Comp, Sloc (N)));\n          Set_Original_Discriminant (Selector_Name (N), Comp);\n          Set_Etype (N, Etype (Comp));\n+         Check_Implicit_Dereference (N, Etype (Comp));\n \n          if Is_Access_Type (Etype (Name)) then\n             Insert_Explicit_Dereference (Name);\n@@ -3876,6 +3901,7 @@ package body Sem_Ch4 is\n                   Set_Etype (N, Etype (Comp));\n                end if;\n \n+               Check_Implicit_Dereference (N, Etype (N));\n                return;\n             end if;\n \n@@ -3941,6 +3967,7 @@ package body Sem_Ch4 is\n \n                   Set_Etype (Sel, Etype (Comp));\n                   Set_Etype (N,   Etype (Comp));\n+                  Check_Implicit_Dereference (N, Etype (N));\n \n                   if Is_Generic_Type (Prefix_Type)\n                     or else Is_Generic_Type (Root_Type (Prefix_Type))"}, {"sha": "75813a4d7299d7ea61b0208265841802576ec9da", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -4818,6 +4818,7 @@ package body Sem_Ch8 is\n             end if;\n \n             Set_Entity_Or_Discriminal (N, E);\n+            Check_Implicit_Dereference (N, Etype (E));\n          end if;\n       end;\n    end Find_Direct_Name;"}, {"sha": "d699fd4eb9ada9fcdd7569ae5a2a7243cedde6d9", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -1794,7 +1794,7 @@ package body Sem_Prag is\n               (Get_Pragma_Arg (Arg2), Standard_String);\n          end if;\n \n-         --  Record if pragma is enabled\n+         --  Record if pragma is disabled\n \n          if Check_Enabled (Pname) then\n             Set_SCO_Pragma_Enabled (Loc);\n@@ -7604,6 +7604,10 @@ package body Sem_Prag is\n                 (Boolean_Literals (Debug_Pragmas_Enabled and Expander_Active),\n                  Loc);\n \n+            if Debug_Pragmas_Enabled then\n+               Set_SCO_Pragma_Enabled (Loc);\n+            end if;\n+\n             if Arg_Count = 2 then\n                Cond :=\n                  Make_And_Then (Loc,"}, {"sha": "362e739b8ca3fcd63780ceb82bf6d88ffde6c49c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -1753,6 +1753,15 @@ package body Sem_Res is\n       It1       : Interp;\n       Seen      : Entity_Id := Empty; -- prevent junk warning\n \n+      procedure Build_Explicit_Dereference\n+        (Expr : Node_Id;\n+         Disc : Entity_Id);\n+      --  AI05-139 : names with implicit dereference. If the expression N is a\n+      --  reference type and the context imposes the corresponding designated\n+      --  type, convert N into N.Disc.all. Such expressions are always over-\n+      --  loaded with both interpretations, and the dereference interpretation\n+      --  carries the name of the reference discriminant.\n+\n       function Comes_From_Predefined_Lib_Unit (Nod : Node_Id) return Boolean;\n       --  Determine whether a node comes from a predefined library unit or\n       --  Standard.\n@@ -1768,6 +1777,30 @@ package body Sem_Res is\n       procedure Resolution_Failed;\n       --  Called when attempt at resolving current expression fails\n \n+      --------------------------------\n+      -- Build_Explicit_Dereference --\n+      --------------------------------\n+\n+      procedure Build_Explicit_Dereference\n+        (Expr : Node_Id;\n+         Disc : Entity_Id)\n+      is\n+         Loc : constant Source_Ptr := Sloc (Expr);\n+\n+      begin\n+         Set_Is_Overloaded (Expr, False);\n+         Rewrite (Expr,\n+           Make_Explicit_Dereference (Loc,\n+             Prefix =>\n+               Make_Selected_Component (Loc,\n+                 Prefix => Relocate_Node (Expr),\n+                 Selector_Name =>\n+               New_Occurrence_Of (Disc, Loc))));\n+\n+         Set_Etype (Prefix (Expr), Etype (Disc));\n+         Set_Etype (Expr, Typ);\n+      end Build_Explicit_Dereference;\n+\n       ------------------------------------\n       -- Comes_From_Predefined_Lib_Unit --\n       -------------------------------------\n@@ -2279,6 +2312,22 @@ package body Sem_Res is\n                elsif Nkind (N) = N_Conditional_Expression then\n                   Set_Etype (N, Expr_Type);\n \n+               --  AI05-0139-2 : expression is overloaded because\n+               --  type has implicit dereference. If type matches\n+               --  context, no implicit dereference is involved.\n+\n+               elsif Has_Implicit_Dereference (Expr_Type) then\n+                  Set_Etype (N, Expr_Type);\n+                  Set_Is_Overloaded (N, False);\n+                  exit Interp_Loop;\n+\n+               elsif Is_Overloaded (N)\n+                 and then Present (It.Nam)\n+                 and then Ekind (It.Nam) = E_Discriminant\n+                 and then Has_Implicit_Dereference (It.Nam)\n+               then\n+                  Build_Explicit_Dereference (N, It.Nam);\n+\n                --  For an explicit dereference, attribute reference, range,\n                --  short-circuit form (which is not an operator node), or call\n                --  with a name that is an explicit dereference, there is"}, {"sha": "1ee06ba0b83dd308c937c5837e8a34600f740ae4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -1104,6 +1104,43 @@ package body Sem_Util is\n       end if;\n    end Cannot_Raise_Constraint_Error;\n \n+   --------------------------------\n+   -- Check_Implicit_Dereference --\n+   --------------------------------\n+\n+   procedure Check_Implicit_Dereference (Nam : Node_Id;  Typ : Entity_Id)\n+   is\n+      Disc  : Entity_Id;\n+      Desig : Entity_Id;\n+\n+   begin\n+      if Ada_Version < Ada_2012\n+        or else not Has_Implicit_Dereference (Base_Type (Typ))\n+      then\n+         return;\n+\n+      elsif not Comes_From_Source (Nam) then\n+         return;\n+\n+      elsif Is_Entity_Name (Nam)\n+        and then Is_Type (Entity (Nam))\n+      then\n+         null;\n+\n+      else\n+         Disc := First_Discriminant (Typ);\n+         while Present (Disc) loop\n+            if Has_Implicit_Dereference (Disc) then\n+               Desig := Designated_Type (Etype (Disc));\n+               Add_One_Interp (Nam, Disc, Desig);\n+               exit;\n+            end if;\n+\n+            Next_Discriminant (Disc);\n+         end loop;\n+      end if;\n+   end Check_Implicit_Dereference;\n+\n    ---------------------------------------\n    -- Check_Later_Vs_Basic_Declarations --\n    ---------------------------------------"}, {"sha": "f66caf391b1ed9e0b197f64bc32ff313655502c0", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a10091cf20b5f4580c4e7bc33e8162acce97dc/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=44a10091cf20b5f4580c4e7bc33e8162acce97dc", "patch": "@@ -147,6 +147,11 @@ package Sem_Util is\n    --  not necessarily mean that CE could be raised, but a response of True\n    --  means that for sure CE cannot be raised.\n \n+   procedure Check_Implicit_Dereference (Nam : Node_Id; Typ : Entity_Id);\n+   --  AI05-139-2 : accessors and iterators for containers. This procedure\n+   --  checks whether T is a reference type, and if so it adds an interprettion\n+   --  to Expr whose type is the designated type of the reference_discriminant.\n+\n    procedure Check_Later_Vs_Basic_Declarations\n      (Decls          : List_Id;\n       During_Parsing : Boolean);"}]}