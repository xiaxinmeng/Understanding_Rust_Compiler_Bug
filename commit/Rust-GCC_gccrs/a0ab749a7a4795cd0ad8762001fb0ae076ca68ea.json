{"sha": "a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhYjc0OWE3YTQ3OTVjZDBhZDg3NjIwMDFmYjBhZTA3NmNhNjhlYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-20T23:47:00Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-20T23:47:00Z"}, "message": "m32r.c: Follow spelling conventions.\n\n\t* config/m32r/m32r.c: Follow spelling conventions.\n\t* config/m32r/m32r.h: Likewise.\n\t* config/m32r/m32r.md: Likewise.\n\t* config/m68k/m68k.c: Likewise.\n\t* config/m88k/m88k.c: Likewise.\n\t* config/mcore/mcore.c: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/mips/mips.h: Likewise.\n\t* config/mmix/mmix.c: Likewise.\n\t* config/mn10200/mn10200.c: Likewise.\n\t* config/ns32k/ns32k.h: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/pa/pa64-linux.h: Likewise.\n\t* config/pdp11/pdp11.h: Likewise.\n\t* config/romp/romp.c: Likewise.\n\t* config/romp/romp.h: Likewise.\n\t* config/rs6000/eabi.asm: Likewise.\n\t* config/rs6000/linux64.h: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/rs6000/rs6000.h: Likewise.\n\t* config/rs6000/rs6000.md: Likewise.\n\t* config/rs6000/sysv4.h: Likewise.\n\t* config/rs6000/xcoff.h: Likewise.\n\nFrom-SVN: r57376", "tree": {"sha": "fda5c473683c0b2fa65d1aab8f3ebaab96576610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fda5c473683c0b2fa65d1aab8f3ebaab96576610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/comments", "author": null, "committer": null, "parents": [{"sha": "2f0da74c47f38593e6e5d21eed97d9c4447fd88e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f0da74c47f38593e6e5d21eed97d9c4447fd88e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f0da74c47f38593e6e5d21eed97d9c4447fd88e"}], "stats": {"total": 150, "additions": 88, "deletions": 62}, "files": [{"sha": "31a3dc86dbf7be7575c7c38eaa6f597ce0642b74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1,3 +1,29 @@\n+2002-09-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/m32r/m32r.c: Follow spelling conventions.\n+\t* config/m32r/m32r.h: Likewise.\n+\t* config/m32r/m32r.md: Likewise.\n+\t* config/m68k/m68k.c: Likewise.\n+\t* config/m88k/m88k.c: Likewise.\n+\t* config/mcore/mcore.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/mips/mips.h: Likewise.\n+\t* config/mmix/mmix.c: Likewise.\n+\t* config/mn10200/mn10200.c: Likewise.\n+\t* config/ns32k/ns32k.h: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/pa/pa64-linux.h: Likewise.\n+\t* config/pdp11/pdp11.h: Likewise.\n+\t* config/romp/romp.c: Likewise.\n+\t* config/romp/romp.h: Likewise.\n+\t* config/rs6000/eabi.asm: Likewise.\n+\t* config/rs6000/linux64.h: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/rs6000/rs6000.h: Likewise.\n+\t* config/rs6000/rs6000.md: Likewise.\n+\t* config/rs6000/sysv4.h: Likewise.\n+\t* config/rs6000/xcoff.h: Likewise.\n+\n 2002-09-20  Jim Wilson  <wilson@redhat.com>\n \n \t* config/v850/v850/lib1funcs.asm (__muldi3): Change r5 to r28."}, {"sha": "b3c0767b5eca8598998dd28c12bc493f00894461", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1029,7 +1029,7 @@ extend_operand (op, mode)\n     }\n }\n \n-/* Return non-zero if the operand is an insn that is a small insn.\n+/* Return nonzero if the operand is an insn that is a small insn.\n    Allow const_int 0 as well, which is a placeholder for NOP slots.  */\n \n int\n@@ -1046,7 +1046,7 @@ small_insn_p (op, mode)\n   return get_attr_length (op) == 2;\n }\n \n-/* Return non-zero if the operand is an insn that is a large insn.  */\n+/* Return nonzero if the operand is an insn that is a large insn.  */\n \n int\n large_insn_p (op, mode)\n@@ -2181,7 +2181,7 @@ m32r_output_function_epilogue (file, size)\n   m32r_compute_function_type (NULL_TREE);\n }\n \f\n-/* Return non-zero if this function is known to have a null or 1 instruction\n+/* Return nonzero if this function is known to have a null or 1 instruction\n    epilogue.  */\n \n int\n@@ -2590,7 +2590,7 @@ zero_and_one (operand1, operand2)\n \t||((INTVAL (operand1) == 1) && (INTVAL (operand2) == 0)));\n }\n \n-/* Return non-zero if the operand is suitable for use in a conditional move sequence.  */\n+/* Return nonzero if the operand is suitable for use in a conditional move sequence.  */\n int\n conditional_move_operand (operand, mode)\n      rtx operand;\n@@ -2862,7 +2862,7 @@ m32r_output_block_move (insn, operands)\n      stores are done without any increment, then the remaining ones can use\n      the pre-increment addressing mode.\n      \n-     Note: expand_block_move() also relies upon this behaviour when building\n+     Note: expand_block_move() also relies upon this behavior when building\n      loops to copy large blocks.  */\n   first_time = 1;\n   "}, {"sha": "80dffd133fc7479407439f4c8fec88c173de37c0", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -185,7 +185,7 @@ Boston, MA 02111-1307, USA.  */\n \n extern int target_flags;\n \n-/* If non-zero, tell the linker to do relaxing.\n+/* If nonzero, tell the linker to do relaxing.\n    We don't do anything with the option, other than recognize it.\n    LINK_SPEC handles passing -relax to the linker.\n    This can cause incorrect debugging information as line numbers may\n@@ -972,7 +972,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n  { ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM },\t\\\n  { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM }}\n \n-/* A C expression that returns non-zero if the compiler is allowed to\n+/* A C expression that returns nonzero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n    TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n    defined, and will usually be the constant 1, since most of the\n@@ -1414,7 +1414,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Condition code usage.  */\n \n-/* Return non-zero if SELECT_CC_MODE will never return MODE for a\n+/* Return nonzero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n #define REVERSIBLE_CC_MODE(MODE) 1 /*???*/\n \f"}, {"sha": "83976a8737d522f77a928b8d37389fd286b72366", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1242,7 +1242,7 @@\n ;; reg == small constant comparisons are best handled by putting the result\n ;; of the comparison in a tmp reg and then using beqz/bnez.\n ;; ??? The result register doesn't contain 0/STORE_FLAG_VALUE,\n-;; it contains 0/non-zero.\n+;; it contains 0/nonzero.\n \n (define_insn \"cmp_ne_small_const_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")"}, {"sha": "cc038793dd81c10c1a77e2d24927dc9c49d5231c", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1119,7 +1119,7 @@ valid_dbcc_comparison_p (x, mode)\n     }\n }\n \n-/* Return non-zero if flags are currently in the 68881 flag register.  */\n+/* Return nonzero if flags are currently in the 68881 flag register.  */\n int\n flags_in_68881 ()\n {\n@@ -3115,7 +3115,7 @@ print_operand (file, op, letter)\n    macro.  See m68k/sgs.h for an example; for versions without the bug.\n    Some assemblers refuse all the above solutions.  The workaround is to\n    emit \"K(pc,d0.l*2)\" with K being a small constant known to give the\n-   right behaviour.\n+   right behavior.\n \n    They also do not like things like \"pea 1.w\", so we simple leave off\n    the .w on small constants. "}, {"sha": "a6eae5efb3610551601fcf0b598bdd229a09b298", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1906,7 +1906,7 @@ m88k_layout_frame ()\n   m88k_stack_size = m88k_fp_offset + STARTING_FRAME_OFFSET;\n \n   /* First, combine m88k_stack_size and size.  If m88k_stack_size is\n-     non-zero, align the frame size to 8 mod 16; otherwise align the\n+     nonzero, align the frame size to 8 mod 16; otherwise align the\n      frame size to 0 mod 16.  (If stacks are 8 byte aligned, this ends\n      up as a NOP.  */\n   {"}, {"sha": "fa14654a757e6c277b390d9bcf24aca73e70eb69", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1296,7 +1296,7 @@ mcore_output_inline_const_forced (insn, operands, mode)\n \n   /* Now, work our way backwards emitting the constant.  */\n \n-  /* Emit the value that remains -- it will be non-zero.  */\n+  /* Emit the value that remains -- it will be nonzero.  */\n   operands[1] = GEN_INT (value);\n   output_asm_insn (output_inline_const (SImode, operands), operands);\n  \n@@ -3268,15 +3268,15 @@ mcore_function_arg_partial_nregs (cum, mode, type, named)\n   return reg;\n }\n \f\n-/* Return non-zero if SYMBOL is marked as being dllexport'd.  */\n+/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n int\n mcore_dllexport_name_p (symbol)\n      const char * symbol;\n {\n   return symbol[0] == '@' && symbol[1] == 'e' && symbol[2] == '.';\n }\n \n-/* Return non-zero if SYMBOL is marked as being dllimport'd.  */\n+/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n int\n mcore_dllimport_name_p (symbol)\n      const char * symbol;"}, {"sha": "610beb743e9adcd1976cf26ca5fc812f927e071d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -216,7 +216,7 @@ struct mips_arg_info\n   unsigned int stack_words;\n \n   /* The offset from the start of the stack overflow area of the argument's\n-     first stack word.  Only meaningful when STACK_WORDS is non-zero.  */\n+     first stack word.  Only meaningful when STACK_WORDS is nonzero.  */\n   unsigned int stack_offset;\n };\n \n@@ -238,7 +238,7 @@ int sdb_label_count = 0;\n /* Next label # for each statement for Silicon Graphics IRIS systems.  */\n int sym_lineno = 0;\n \n-/* Non-zero if inside of a function, because the stupid MIPS asm can't\n+/* Nonzero if inside of a function, because the stupid MIPS asm can't\n    handle .files inside of functions.  */\n int inside_function = 0;\n \n@@ -1455,7 +1455,7 @@ mips_reg_mode_ok_for_base_p (reg, mode, strict)\n \n /* This function is used to implement GO_IF_LEGITIMATE_ADDRESS.  It\n    returns a nonzero value if XINSN is a legitimate address for a\n-   memory operand of the indicated MODE.  STRICT is non-zero if this\n+   memory operand of the indicated MODE.  STRICT is nonzero if this\n    function is called during reload.  */\n \n int\n@@ -3103,7 +3103,7 @@ map_test_to_internal_test (test_code)\n    ??? This is called with result nonzero by the Scond patterns in\n    mips.md.  These patterns are called with a target in the mode of\n    the Scond instruction pattern.  Since this must be a constant, we\n-   must use SImode.  This means that if RESULT is non-zero, it will\n+   must use SImode.  This means that if RESULT is nonzero, it will\n    always be an SImode register, even if TARGET_64BIT is true.  We\n    cope with this by calling convert_move rather than emit_move_insn.\n    This will sometimes lead to an unnecessary extension of the result;\n@@ -3345,7 +3345,7 @@ gen_conditional_branch (operands, test_code)\n \t  test_code = NE;\n \t}\n       else if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n-\t/* We don't want to build a comparison against a non-zero\n+\t/* We don't want to build a comparison against a nonzero\n \t   constant.  */\n \tcmp1 = force_reg (mode, cmp1);\n \n@@ -6013,7 +6013,7 @@ mips_assemble_integer (x, size, aligned_p)\n \n    If we have -G 0, or the extern size is unknown, or the object is in a user\n    specified section that is not .sbss/.sdata, don't bother emitting the\n-   .externs.  In the case of user specified sections this behaviour is\n+   .externs.  In the case of user specified sections this behavior is\n    required as otherwise GAS will think the object lives in .sbss/.sdata.  */\n \n int\n@@ -7889,7 +7889,7 @@ mips_can_use_return_insn ()\n   return compute_frame_size (get_frame_size ()) == 0;\n }\n \f\n-/* Returns non-zero if X contains a SYMBOL_REF.  */\n+/* Returns nonzero if X contains a SYMBOL_REF.  */\n \n static int\n symbolic_expression_p (x)\n@@ -8722,7 +8722,7 @@ mips16_constant (x, mode, addr, addend)\n /* Write out code to move floating point arguments in or out of\n    general registers.  Output the instructions to FILE.  FP_CODE is\n    the code describing which arguments are present (see the comment at\n-   the definition of CUMULATIVE_ARGS in mips.h).  FROM_FP_P is non-zero if\n+   the definition of CUMULATIVE_ARGS in mips.h).  FROM_FP_P is nonzero if\n    we are copying from the floating point registers.  */\n \n static void\n@@ -9919,11 +9919,11 @@ mips_adjust_insn_length (insn, length)\n    INSN is the branch instruction.  OPERANDS[0] is the condition.\n    OPERANDS[1] is the target of the branch.  OPERANDS[2] is the target\n    of the first operand to the condition.  If TWO_OPERANDS_P is\n-   non-zero the comparison takes two operands; OPERANDS[3] will be the\n+   nonzero the comparison takes two operands; OPERANDS[3] will be the\n    second operand.\n \n-   If INVERTED_P is non-zero we are to branch if the condition does\n-   not hold.  If FLOAT_P is non-zero this is a floating-point comparison.\n+   If INVERTED_P is nonzero we are to branch if the condition does\n+   not hold.  If FLOAT_P is nonzero this is a floating-point comparison.\n \n    LENGTH is the length (in bytes) of the sequence we are to generate.\n    That tells us whether to generate a simple conditional branch, or a\n@@ -9945,7 +9945,7 @@ mips_output_conditional_branch (insn,\n   static char buffer[200];\n   /* The kind of comparison we are doing.  */\n   enum rtx_code code = GET_CODE (operands[0]);\n-  /* Non-zero if the opcode for the comparison needs a `z' indicating\n+  /* Nonzero if the opcode for the comparison needs a `z' indicating\n      that it is a comparision against zero.  */\n   int need_z_p;\n   /* A string to use in the assembly output to represent the first\n@@ -9972,7 +9972,7 @@ mips_output_conditional_branch (insn,\n \t subtract B from A and then look at the sign bit.  But, if we\n \t are doing an unsigned comparison, and B is zero, we don't\n \t have to do the subtraction.  Instead, we can just check to\n-\t see if A is non-zero.  Thus, we change the CODE here to\n+\t see if A is nonzero.  Thus, we change the CODE here to\n \t reflect the simpler comparison operation.  */\n       switch (code)\n \t{"}, {"sha": "9239707a5ce176cff7594abfc3a79cb6ca57029b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -2299,7 +2299,7 @@ extern enum reg_class mips_char_to_class[256];\n \n /* Certain machines have the property that some registers cannot be\n    copied to some other registers without using memory.  Define this\n-   macro on those machines to be a C expression that is non-zero if\n+   macro on those machines to be a C expression that is nonzero if\n    objects of mode MODE in registers of CLASS1 can only be copied to\n    registers of class CLASS2 by storing a register of CLASS1 into\n    memory and loading that memory location into a register of CLASS2.\n@@ -2471,7 +2471,7 @@ extern enum reg_class mips_char_to_class[256];\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 17}}\n \n-/* A C expression that returns non-zero if the compiler is allowed to\n+/* A C expression that returns nonzero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n    TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n    defined, and will usually be the constant 1, since most of the"}, {"sha": "61af93a9608c34f5eaa364f680f9499d6727c208", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1985,7 +1985,7 @@ mmix_get_hard_reg_initial_val (mode, regno)\n   return get_hard_reg_initial_val (mode, regno);\n }\n \n-/* Non-zero when the function epilogue is simple enough that a single\n+/* Nonzero when the function epilogue is simple enough that a single\n    \"POP %d,0\" should be used even within the function.  */\n \n int"}, {"sha": "b41c61fafcaf20f8bea3ef7cf5c895b3829f6e75", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -943,7 +943,7 @@ secondary_reload_class (class, mode, in, input)\n \n    The basic shift methods:\n \n-     * loop shifts -- emit a loop using one (or two on H8/S) bit shifts;\n+     * loop shifts -- emit a loop using one (or two on H8S) bit shifts;\n      this is the default.  SHIFT_LOOP\n \n      * inlined shifts -- emit straight line code for the shift; this is"}, {"sha": "4ecb47b46d5f38f6dff0b94110ca54dec7cc6f8a", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -863,7 +863,7 @@ __transfer_from_trampoline ()\t\t\\\n \n /*  Certain machines have the property that some registers cannot be\n     copied to some other registers without using memory.  Define this\n-    macro on those machines to be a C expression that is non-zero if\n+    macro on those machines to be a C expression that is nonzero if\n     objects of mode M in registers of CLASS1 can only be copied to\n     registers of class CLASS2 by storing a register of CLASS1 into\n     memory and loading that memory location into a register of CLASS2."}, {"sha": "98944da118120bb94fa6e9adaa4c6c5adec0ea3f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -305,7 +305,7 @@ override_options ()\n     }\n }\n \n-/* Return non-zero only if OP is a register of mode MODE,\n+/* Return nonzero only if OP is a register of mode MODE,\n    or CONST0_RTX.  */\n int\n reg_or_0_operand (op, mode)\n@@ -315,7 +315,7 @@ reg_or_0_operand (op, mode)\n   return (op == CONST0_RTX (mode) || register_operand (op, mode));\n }\n \n-/* Return non-zero if OP is suitable for use in a call to a named\n+/* Return nonzero if OP is suitable for use in a call to a named\n    function.\n \n    For 2.5 try to eliminate either call_operand_address or"}, {"sha": "1691633d1cb03106c92d2a0e3a27ada93d6837e2", "filename": "gcc/config/pa/pa64-linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-linux.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n   {ARG_POINTER_REGNUM,\t FRAME_POINTER_REGNUM},\t\t\t\t\\\n }\n \n-/* A C expression that returns non-zero if the compiler is allowed to try to\n+/* A C expression that returns nonzero if the compiler is allowed to try to\n    replace register number FROM with register number TO.  The frame pointer\n    is automatically handled.  */\n "}, {"sha": "d01621c7cf7d096e017d138faa2ed3f5f1b77b3d", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -508,7 +508,7 @@ loading is easier into LOAD_FPU_REGS than FPU_REGS! */\n extern int current_first_parm_offset;\n \n /* Offset of first parameter from the argument pointer register value.  \n-   For the pdp11, this is non-zero to account for the return address.\n+   For the pdp11, this is nonzero to account for the return address.\n \t1 - return address\n \t2 - frame pointer (always saved, even when not used!!!!)\n \t\t-- chnage some day !!!:q!"}, {"sha": "44d422a37160b64f992889c7557156f6155d8d78", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -229,7 +229,7 @@ update_cc (body, insn)\n       break;\n \n     case CC_TBIT:\n-      /* Insn sets T bit if result is non-zero.  Next insn must be branch.  */\n+      /* Insn sets T bit if result is nonzero.  Next insn must be branch.  */\n       CC_STATUS_INIT;\n       cc_status.flags = CC_IN_TB | CC_NOT_NEGATIVE;\n       break;\n@@ -389,7 +389,7 @@ current_function_operand (op, mode)\n \t  && ! strcmp (current_function_name, XSTR (op, 0)));\n }\n \n-/* Return non-zero if this function is known to have a null epilogue.  */\n+/* Return nonzero if this function is known to have a null epilogue.  */\n \n int\n null_epilogue ()\n@@ -786,7 +786,7 @@ print_operand (file, x, code)\n       break;\n \n     case 'Z':\n-      /* Upper or lower half, depending on which is non-zero or not\n+      /* Upper or lower half, depending on which is nonzero or not\n \t all ones.  Must be consistent with 'z' above.  */\n       if (GET_CODE (x) != CONST_INT)\n \toutput_operand_lossage (\"invalid %%Z value\");\n@@ -1032,7 +1032,7 @@ romp_sa_size ()\n   return size * 4;\n }\n \n-/* Return non-zero if this function makes calls or has fp operations\n+/* Return nonzero if this function makes calls or has fp operations\n    (which are really calls).  */\n \n int\n@@ -1059,7 +1059,7 @@ romp_makes_calls ()\n   return 0;\n }\n \n-/* Return non-zero if this function will use r14 as a pointer to its\n+/* Return nonzero if this function will use r14 as a pointer to its\n    constant pool.  */\n \n int\n@@ -1071,7 +1071,7 @@ romp_using_r14 ()\n \t  || get_pool_size () != 0 || romp_makes_calls ());\n }\n \n-/* Return non-zero if this function needs to push space on the stack.  */\n+/* Return nonzero if this function needs to push space on the stack.  */\n \n int\n romp_pushes_stack ()"}, {"sha": "c2d1505159f3915155e753a306f85ec62bf20d7b", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -1085,7 +1085,7 @@ struct rt_cargs {int gregs, fregs; };\n #define MOVE_MAX 4\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n-   Also non-zero if doing byte operations (specifically shifts) in registers\n+   Also nonzero if doing byte operations (specifically shifts) in registers\n    is undesirable.  */\n #define SLOW_BYTE_ACCESS 1\n "}, {"sha": "058f9b9d5e7663a5872960b8cd03f071f73864b4", "filename": "gcc/config/rs6000/eabi.asm", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Feabi.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Feabi.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.asm?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -139,7 +139,7 @@ FUNC_START(__eabi)\n \taddi\t11,11,.LCTOC1@l\n \tcmplwi\t2,9,0\t\t\t\t/* init flag != 0? */\n \tbnelr\t2\t\t\t\t/* return now, if we've been called already */\n-\tstw\t1,.Linit_p@l(10)\t\t/* store a non-zero value in the done flag */\n+\tstw\t1,.Linit_p@l(10)\t\t/* store a nonzero value in the done flag */\n \n #else /* -mrelocatable */\n \tmflr\t0\n@@ -155,7 +155,7 @@ FUNC_START(__eabi)\n \tcmplwi\t2,9,0\t\t\t\t/* init flag != 0? */\n \tmtlr\t0\t\t\t\t/* restore in case branch was taken */\n \tbnelr\t2\t\t\t\t/* return now, if we've been called already */\n-\tstwx\t1,10,12\t\t\t\t/* store a non-zero value in the done flag */\n+\tstwx\t1,10,12\t\t\t\t/* store a nonzero value in the done flag */\n \tbeq+\t0,.Lsdata\t\t\t/* skip if we don't need to relocate */\n \n /* We need to relocate the .got2 pointers.  */"}, {"sha": "77902c830c20a652baec22cf5dcd91e4538419a0", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -286,7 +286,7 @@ do {\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* Return non-zero if this entry is to be written into the constant\n+/* Return nonzero if this entry is to be written into the constant\n    pool in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF\n    or a CONST containing one of them.  If -mfp-in-toc (the default),\n    we also do this for floating-point constants.  We actually can only"}, {"sha": "4cb67f645d0790f233c4160374439f2133c7a6b4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -92,7 +92,7 @@ int rs6000_fprs = 1;\n /* String from -misel=.  */\n const char *rs6000_isel_string;\n \n-/* Set to non-zero once AIX common-mode calls have been defined.  */\n+/* Set to nonzero once AIX common-mode calls have been defined.  */\n static int common_mode_defined;\n \n /* Private copy of original value of flag_pic for ABI_AIX.  */\n@@ -822,7 +822,7 @@ rs6000_file_start (file, default_cpu)\n     }\n }\n \f\n-/* Return non-zero if this function is known to have a null epilogue.  */\n+/* Return nonzero if this function is known to have a null epilogue.  */\n \n int\n direct_return ()\n@@ -8348,7 +8348,7 @@ rs6000_emit_cbranch (code, loc)\n    condition code register and its mode specifies what kind of\n    comparison we made.\n \n-   REVERSED is non-zero if we should reverse the sense of the comparison.\n+   REVERSED is nonzero if we should reverse the sense of the comparison.\n \n    INSN is the insn.  */\n "}, {"sha": "b913ff6dd2e61ee626d2336bed07cfb90602484e", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -651,7 +651,7 @@ extern int rs6000_default_long_calls;\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Non-zero if move instructions will actually fail to work\n+/* Nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n \n@@ -1226,8 +1226,8 @@ enum reg_class\n    Return 1 if VALUE is in the range specified by C.\n \n    `I' is a signed 16-bit constant\n-   `J' is a constant with only the high-order 16 bits non-zero\n-   `K' is a constant with only the low-order 16 bits non-zero\n+   `J' is a constant with only the high-order 16 bits nonzero\n+   `K' is a constant with only the low-order 16 bits nonzero\n    `L' is a signed 16-bit constant shifted left 16 bits\n    `M' is a constant that is greater than 31\n    `N' is a positive constant that is an exact power of two\n@@ -1694,13 +1694,13 @@ typedef struct rs6000_args\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   function_arg_advance (&CUM, MODE, TYPE, NAMED)\n \n-/* Non-zero if we can use a floating-point register to pass this arg.  */\n+/* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE,TYPE) \\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT  \\\n    && (CUM).fregno <= FP_ARG_MAX_REG    \\\n    && TARGET_HARD_FLOAT && TARGET_FPRS)\n \n-/* Non-zero if we can use an AltiVec register to pass this arg.  */\n+/* Nonzero if we can use an AltiVec register to pass this arg.  */\n #define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,TYPE)\t\\\n   (ALTIVEC_VECTOR_MODE (MODE)\t\t\t\\\n    && (CUM).vregno <= ALTIVEC_ARG_MAX_REG\t\\\n@@ -1817,7 +1817,7 @@ typedef struct rs6000_args\n    the stack pointer does not matter. No definition is equivalent to\n    always zero.\n \n-   On the RS/6000, this is non-zero because we can restore the stack from\n+   On the RS/6000, this is nonzero because we can restore the stack from\n    its backpointer, which we maintain.  */\n #define EXIT_IGNORE_STACK\t1\n \n@@ -2261,7 +2261,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n #define MAX_MOVE_MAX 8\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n-   Also non-zero if doing byte operations (specifically shifts) in registers\n+   Also nonzero if doing byte operations (specifically shifts) in registers\n    is undesirable.  */\n #define SLOW_BYTE_ACCESS 1\n "}, {"sha": "c1a84786f6d27bfd84b27cd80a44f7571c85d3a7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -10465,7 +10465,7 @@\n }\")\n \n ;; Call to function in current module.  No TOC pointer reload needed.\n-;; Operand2 is non-zero if we are using the V.4 calling sequence and\n+;; Operand2 is nonzero if we are using the V.4 calling sequence and\n ;; either the function was not prototyped, or it was prototyped as a\n ;; variable argument function.  It is > 0 if FP registers were passed\n ;; and < 0 if they were not.\n@@ -10551,7 +10551,7 @@\n \n ;; Call to function which may be in another module.  Restore the TOC\n ;; pointer (r2) after the call unless this is System V.\n-;; Operand2 is non-zero if we are using the V.4 calling sequence and\n+;; Operand2 is nonzero if we are using the V.4 calling sequence and\n ;; either the function was not prototyped, or it was prototyped as a\n ;; variable argument function.  It is > 0 if FP registers were passed\n ;; and < 0 if they were not."}, {"sha": "56aa702aa9f26f94438ee17cce6a3c523f8b0a48", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -551,7 +551,7 @@ fini_section ()\t\t\t\t\t\t\t\t\\\n #define\tTARGET_ASM_SELECT_SECTION  rs6000_elf_select_section\n #define TARGET_ASM_UNIQUE_SECTION  rs6000_elf_unique_section\n \n-/* Return non-zero if this entry is to be written into the constant pool\n+/* Return nonzero if this entry is to be written into the constant pool\n    in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF or a CONST\n    containing one of them.  If -mfp-in-toc (the default), we also do\n    this for floating-point constants.  We actually can only do this\n@@ -1401,7 +1401,7 @@ ncrtn.o%s\"\n    pack(pop)'.  The pack(push,<n>) pragma specifies the maximum\n    alignment (in bytes) of fields within a structure, in much the\n    same way as the __aligned__' and __packed__' __attribute__'s\n-   do.  A pack value of zero resets the behaviour to the default.\n+   do.  A pack value of zero resets the behavior to the default.\n    Successive invocations of this pragma cause the previous values to\n    be stacked, so that invocations of #pragma pack(pop)' will return\n    to the previous value.  */"}, {"sha": "cad39819fff0e942372b473fc3ffe1d85b45b370", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab749a7a4795cd0ad8762001fb0ae076ca68ea/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=a0ab749a7a4795cd0ad8762001fb0ae076ca68ea", "patch": "@@ -135,7 +135,7 @@ toc_section ()\t\t\t\t\t\t\\\n \n #define READONLY_DATA_SECTION read_only_data_section\n \n-/* Return non-zero if this entry is to be written into the constant\n+/* Return nonzero if this entry is to be written into the constant\n    pool in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF\n    or a CONST containing one of them.  If -mfp-in-toc (the default),\n    we also do this for floating-point constants.  We actually can only"}]}