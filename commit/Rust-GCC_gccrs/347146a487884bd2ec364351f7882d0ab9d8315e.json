{"sha": "347146a487884bd2ec364351f7882d0ab9d8315e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ3MTQ2YTQ4Nzg4NGJkMmVjMzY0MzUxZjc4ODJkMGFiOWQ4MzE1ZQ==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2008-10-21T23:40:41Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2008-10-21T23:40:41Z"}, "message": "re PR target/37633 (wrong register use on sh64)\n\n\tPR target/37633\n\t* config/sh/sh.c (sh_hard_regno_mode_ok): New function.\n\t* config/sh/sh.h (HARD_REGNO_MODE_OK): Use it.\n\t* config/sh/sh-protos.h (sh_hard_regno_mode_ok): Declare.\n\nFrom-SVN: r141282", "tree": {"sha": "8a734a168b86d6a35016d05123952c28510d6d50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a734a168b86d6a35016d05123952c28510d6d50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/347146a487884bd2ec364351f7882d0ab9d8315e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347146a487884bd2ec364351f7882d0ab9d8315e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/347146a487884bd2ec364351f7882d0ab9d8315e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347146a487884bd2ec364351f7882d0ab9d8315e/comments", "author": null, "committer": null, "parents": [{"sha": "e58d5f65d7b44bb7c1e620501cc7877a677152a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e58d5f65d7b44bb7c1e620501cc7877a677152a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e58d5f65d7b44bb7c1e620501cc7877a677152a2"}], "stats": {"total": 161, "additions": 114, "deletions": 47}, "files": [{"sha": "f95f4e4afc9d7c0d5cfc56b397297ec3156bb019", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=347146a487884bd2ec364351f7882d0ab9d8315e", "patch": "@@ -1,3 +1,10 @@\n+2008-10-22  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/37633\n+\t* config/sh/sh.c (sh_hard_regno_mode_ok): New function.\n+\t* config/sh/sh.h (HARD_REGNO_MODE_OK): Use it.\n+\t* config/sh/sh-protos.h (sh_hard_regno_mode_ok): Declare.\n+\n 2008-10-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/37880"}, {"sha": "5b971960f2daaec228a57ad4059e7393b756775e", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=347146a487884bd2ec364351f7882d0ab9d8315e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for Renesas / SuperH SH.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2003,\n-   2004, 2005, 2006, 2007\n+   2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n@@ -174,7 +174,7 @@ extern enum reg_class sh_secondary_reload (bool, rtx, enum reg_class,\n extern int sh2a_get_function_vector_number (rtx);\n extern int sh2a_is_function_vector_call (rtx);\n extern void sh_fix_range (const char *);\n-\n+extern bool sh_hard_regno_mode_ok (unsigned int, enum machine_mode);\n #endif /* ! GCC_SH_PROTOS_H */\n \n #ifdef SYMBIAN"}, {"sha": "14892ce310a47347036b8483e324f10d8117e682", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=347146a487884bd2ec364351f7882d0ab9d8315e", "patch": "@@ -10193,6 +10193,108 @@ sh_expand_binop_v2sf (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n   emit_insn (gen_binary_sf_op1 (op0, op1, op2, op));\n }\n \n+/* Return true if hard register REGNO can hold a value of machine-mode MODE.\n+   We can allow any mode in any general register.  The special registers\n+   only allow SImode.  Don't allow any mode in the PR.\n+\n+   We cannot hold DCmode values in the XD registers because alter_reg\n+   handles subregs of them incorrectly.  We could work around this by\n+   spacing the XD registers like the DR registers, but this would require\n+   additional memory in every compilation to hold larger register vectors.\n+   We could hold SFmode / SCmode values in XD registers, but that\n+   would require a tertiary reload when reloading from / to memory,\n+   and a secondary reload to reload from / to general regs; that\n+   seems to be a loosing proposition.\n+\n+   We want to allow TImode FP regs so that when V4SFmode is loaded as TImode,\n+   it won't be ferried through GP registers first.  */\n+\n+bool\n+sh_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+{\n+  if (SPECIAL_REGISTER_P (regno))\n+    return mode == SImode;\n+\n+  if (regno == FPUL_REG)\n+    return (mode == SImode || mode == SFmode);\n+\n+  if (FP_REGISTER_P (regno) && mode == SFmode)\n+    return true;\n+\n+  if (mode == V2SFmode)\n+    {\n+      if (((FP_REGISTER_P (regno) && (regno - FIRST_FP_REG) % 2 == 0)\n+\t   || GENERAL_REGISTER_P (regno)))\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n+\n+  if (mode == V4SFmode)\n+    {\n+      if ((FP_REGISTER_P (regno) && (regno - FIRST_FP_REG) % 4 == 0)\n+\t  || GENERAL_REGISTER_P (regno))\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n+\n+  if (mode == V16SFmode)\n+    {\n+      if (TARGET_SHMEDIA)\n+\t{\n+\t  if (FP_REGISTER_P (regno) && (regno - FIRST_FP_REG) % 16 == 0)\n+\t    return true;\n+\t  else\n+\t    return false;\n+\t}\n+      else\n+\treturn regno == FIRST_XD_REG;\n+    }\n+\n+  if (FP_REGISTER_P (regno))\n+    {\n+      if (mode == SFmode\n+\t  || mode == SImode\n+\t  || ((TARGET_SH2E || TARGET_SHMEDIA) && mode == SCmode)\n+\t  || ((((TARGET_SH4 || TARGET_SH2A_DOUBLE) && mode == DFmode)\n+\t       || mode == DCmode\n+\t       || (TARGET_SHMEDIA\n+\t\t   && (mode == DFmode || mode == DImode\n+\t\t       || mode == V2SFmode || mode == TImode)))\n+\t      && ((regno - FIRST_FP_REG) & 1) == 0)\n+\t  || ((TARGET_SH4 || TARGET_SHMEDIA) && mode == TImode\n+\t      && ((regno - FIRST_FP_REG) & 3) == 0))\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n+\n+  if (XD_REGISTER_P (regno))\n+    return mode == DFmode;\n+\n+  if (TARGET_REGISTER_P (regno))\n+    return (mode == DImode || mode == SImode || mode == PDImode);\n+\n+  if (regno == PR_REG)\n+    return mode == SImode;\n+\n+  if (regno == FPSCR_REG)\n+    return mode == PSImode;\n+\n+  /* FIXME.  This works around PR target/37633 for -O0.  */\n+  if (!optimize && TARGET_SHMEDIA32 && GET_MODE_SIZE (mode) > 4)\n+    {\n+      unsigned int n = GET_MODE_SIZE (mode) / 8;\n+\n+      if (regno >= FIRST_GENERAL_REG + 10 - n + 1\n+\t  && regno <= FIRST_GENERAL_REG + 14)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Return the class of registers for which a mode change from FROM to TO\n    is invalid.  */\n bool"}, {"sha": "6a4ccb0f0e64f80ac44a0174e329ce396c1461af", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347146a487884bd2ec364351f7882d0ab9d8315e/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=347146a487884bd2ec364351f7882d0ab9d8315e", "patch": "@@ -1208,52 +1208,10 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n     ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD/2 - 1) / (UNITS_PER_WORD/2)) \\\n     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   We can allow any mode in any general register.  The special registers\n-   only allow SImode.  Don't allow any mode in the PR.  */\n-\n-/* We cannot hold DCmode values in the XD registers because alter_reg\n-   handles subregs of them incorrectly.  We could work around this by\n-   spacing the XD registers like the DR registers, but this would require\n-   additional memory in every compilation to hold larger register vectors.\n-   We could hold SFmode / SCmode values in XD registers, but that\n-   would require a tertiary reload when reloading from / to memory,\n-   and a secondary reload to reload from / to general regs; that\n-   seems to be a loosing proposition.  */\n-/* We want to allow TImode FP regs so that when V4SFmode is loaded as TImode,\n-   it won't be ferried through GP registers first.  */\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+\n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n-  (SPECIAL_REGISTER_P (REGNO) ? (MODE) == SImode \\\n-   : (REGNO) == FPUL_REG ? (MODE) == SImode || (MODE) == SFmode\t\\\n-   : FP_REGISTER_P (REGNO) && (MODE) == SFmode \\\n-   ? 1 \\\n-   : (MODE) == V2SFmode \\\n-   ? ((FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 2 == 0) \\\n-      || GENERAL_REGISTER_P (REGNO)) \\\n-   : (MODE) == V4SFmode \\\n-   ? ((FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 4 == 0) \\\n-      || GENERAL_REGISTER_P (REGNO)) \\\n-   : (MODE) == V16SFmode \\\n-   ? (TARGET_SHMEDIA \\\n-      ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 16 == 0) \\\n-      : (REGNO) == FIRST_XD_REG) \\\n-   : FP_REGISTER_P (REGNO) \\\n-   ? ((MODE) == SFmode || (MODE) == SImode \\\n-      || ((TARGET_SH2E || TARGET_SHMEDIA) && (MODE) == SCmode) \\\n-      || ((((TARGET_SH4 || TARGET_SH2A_DOUBLE) && (MODE) == DFmode) || (MODE) == DCmode \\\n-\t   || (TARGET_SHMEDIA && ((MODE) == DFmode || (MODE) == DImode \\\n-\t\t\t\t  || (MODE) == V2SFmode || (MODE) == TImode))) \\\n-\t  && (((REGNO) - FIRST_FP_REG) & 1) == 0) \\\n-      || ((TARGET_SH4 || TARGET_SHMEDIA) \\\n-\t  && (MODE) == TImode \\\n-\t  && (((REGNO) - FIRST_FP_REG) & 3) == 0)) \\\n-   : XD_REGISTER_P (REGNO) \\\n-   ? (MODE) == DFmode \\\n-   : TARGET_REGISTER_P (REGNO) \\\n-   ? ((MODE) == DImode || (MODE) == SImode || (MODE) == PDImode) \\\n-   : (REGNO) == PR_REG ? (MODE) == SImode \\\n-   : (REGNO) == FPSCR_REG ? (MODE) == PSImode \\\n-   : 1)\n+  sh_hard_regno_mode_ok ((REGNO), (MODE))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2."}]}