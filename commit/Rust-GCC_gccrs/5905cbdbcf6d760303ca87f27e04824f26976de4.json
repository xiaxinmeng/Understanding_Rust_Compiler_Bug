{"sha": "5905cbdbcf6d760303ca87f27e04824f26976de4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwNWNiZGJjZjZkNzYwMzAzY2E4N2YyN2UwNDgyNGYyNjk3NmRlNA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-05T15:50:49Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-05T15:52:57Z"}, "message": "d: Merge upstream dmd 56f0a65c4.\n\nUpdates the Target interface, removing static from all members, so all\nfield accesses and member function calls go through a single global\n'target'.  Information relating to extern ABI are now in TargetC,\nTargetCPP, and TargetObjC for each supported language respectively.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11228\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 56f0a65c4.\n\t* d-builtins.cc (build_frontend_type): Remove static.\n\t(d_build_builtins_module): Use target.va_listType() to get front-end\n\ttype for va_list.\n\t(d_init_builtins): Move creation of va_list to Target::va_listType.\n\t* d-codegen.cc (build_interface_binfo): Use new target global.\n\t(build_vindex_ref): Likewise.\n\t(identity_compare_p): Likewise.\n\t* d-ctfloat.cc (CTFloat::parse): Likewise.\n\t* d-lang.cc (d_init): Likewise.\n\t* d-port.cc (Port::isFloat32LiteralOutOfRange): Likewise.\n\t(Port::isFloat64LiteralOutOfRange): Likewise.\n\t* d-target.cc (define_float_constants): Initialize constants through a\n\treference, instead of setting globals.\n\t(Target::_init): Initialize new fields instead of setting globals.\n\t(Target::va_listType): Build front-end type from va_list_type_node.\n\t(Target::toCppMangle): Renamed to ...\n\t(TargetCPP::toMangle): ... this.\n\t(Target::cppTypeInfoMangle): Renamed to ...\n\t(TargetCPP::typeInfoMangle): ... this.\n\t(Target::cppTypeMangle): Renamed to ...\n\t(TargetCPP::typeMangle): this.\n\t(Target::cppParameterType): Renamed to ...\n\t(TargetCPP::parameterType): ... this.  Use target.va_listType() to get\n\tfront-end type for va_list.\n\t(Target::cppFundamentalType): Renamed to ...\n\t(TargetCPP::fundamentalType): ... this.\n\t* d-tree.h (build_frontend_type): Declare.\n\t* decl.cc (base_vtable_offset): Use new target global.\n\t* typeinfo.cc (layout_classinfo_interfaces): Likewise.\n\t(layout_cpp_typeinfo): Likewise.\n\t* types.cc (valist_array_p): Use target.va_listType() to get front-end\n\ttype for va_list.\n\t(layout_aggregate_type): Use new target global.", "tree": {"sha": "16ea452b43613d027a78c18b033f7659f0cdbbbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16ea452b43613d027a78c18b033f7659f0cdbbbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5905cbdbcf6d760303ca87f27e04824f26976de4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5905cbdbcf6d760303ca87f27e04824f26976de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5905cbdbcf6d760303ca87f27e04824f26976de4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5905cbdbcf6d760303ca87f27e04824f26976de4/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "300452d7bf1d3a0ff3f7585a1166f3d473c70556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/300452d7bf1d3a0ff3f7585a1166f3d473c70556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/300452d7bf1d3a0ff3f7585a1166f3d473c70556"}], "stats": {"total": 539, "additions": 269, "deletions": 270}, "files": [{"sha": "cbc745581068a6fcbeb1975ed4f9b1b0b013abfe", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dmd/identifier.h\"\n #include \"dmd/module.h\"\n #include \"dmd/mtype.h\"\n+#include \"dmd/target.h\"\n \n #include \"tree.h\"\n #include \"fold-const.h\"\n@@ -67,7 +68,7 @@ static vec<builtin_data> builtin_converted_decls;\n    as casting from `C char' to `D char', which also means that `char *`\n    needs to be specially handled.  */\n \n-static Type *\n+Type *\n build_frontend_type (tree type)\n {\n   Type *dtype;\n@@ -598,14 +599,12 @@ d_build_builtins_module (Module *m)\n \t}\n     }\n \n-  /* va_list should already be built, so no need to convert to D type again.  */\n-  StructDeclaration *sd = (Type::tvalist->ty == Tstruct)\n-    ? ((TypeStruct *) Type::tvalist)->sym : NULL;\n+  /* Expose target-specific va_list type.  */\n+  Type *tvalist = target.va_listType (Loc (), NULL);\n+  StructDeclaration *sd = (tvalist->ty == Tstruct)\n+    ? ((TypeStruct *) tvalist)->sym : NULL;\n   if (sd == NULL || !sd->isAnonymous ())\n-    {\n-      members->push (build_alias_declaration (\"__builtin_va_list\",\n-\t\t\t\t\t      Type::tvalist));\n-    }\n+    members->push (build_alias_declaration (\"__builtin_va_list\", tvalist));\n   else\n     {\n       sd->ident = Identifier::idPool (\"__builtin_va_list\");\n@@ -1152,16 +1151,6 @@ d_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n void\n d_init_builtins (void)\n {\n-  /* Build the \"standard\" abi va_list.  */\n-  Type::tvalist = build_frontend_type (va_list_type_node);\n-  if (!Type::tvalist)\n-    sorry (\"cannot represent built-in %<va_list%> type in D\");\n-\n-  /* Map the va_list type to the D frontend Type.  This is to prevent both\n-     errors in gimplification or an ICE in targetm.canonical_va_list_type.  */\n-  Type::tvalist->ctype = va_list_type_node;\n-  TYPE_LANG_SPECIFIC (va_list_type_node) = build_lang_type (Type::tvalist);\n-\n   d_build_c_type_nodes ();\n   d_build_d_type_nodes ();\n "}, {"sha": "cf98d4be7e9092c1f2f4fe9588ca1e875d4c5375", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -362,7 +362,7 @@ build_interface_binfo (tree super, ClassDeclaration *cd, unsigned& offset)\n   /* Want RECORD_TYPE, not POINTER_TYPE.  */\n   BINFO_TYPE (binfo) = TREE_TYPE (ctype);\n   BINFO_INHERITANCE_CHAIN (binfo) = super;\n-  BINFO_OFFSET (binfo) = size_int (offset * Target::ptrsize);\n+  BINFO_OFFSET (binfo) = size_int (offset * target.ptrsize);\n   BINFO_VIRTUAL_P (binfo) = 1;\n \n   for (size_t i = 0; i < cd->baseclasses->length; i++, offset++)\n@@ -499,7 +499,7 @@ build_vindex_ref (tree object, tree fntype, size_t index)\n \n   gcc_assert (POINTER_TYPE_P (fntype));\n \n-  return build_memref (fntype, result, size_int (Target::ptrsize * index));\n+  return build_memref (fntype, result, size_int (target.ptrsize * index));\n }\n \n /* Return TRUE if EXP is a valid lvalue.  Lvalue references cannot be\n@@ -819,7 +819,7 @@ identity_compare_p (StructDeclaration *sd)\n \n       /* Check for types that may have padding.  */\n       if ((tb->ty == Tcomplex80 || tb->ty == Tfloat80 || tb->ty == Timaginary80)\n-\t  && Target::realpad != 0)\n+\t  && target.realpad != 0)\n \treturn false;\n \n       if (offset <= vd->offset)"}, {"sha": "606bcf524bd2b5ae02e51da80b08cc89b5e69e36", "filename": "gcc/d/d-ctfloat.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-ctfloat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-ctfloat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-ctfloat.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -92,7 +92,7 @@ CTFloat::parse (const char *buffer, bool *overflow)\n   real_from_string3 (&r.rv (), buffer, TYPE_MODE (long_double_type_node));\n \n   /* Front-end checks overflow to see if the value is representable.  */\n-  if (overflow && r == Target::RealProperties::infinity)\n+  if (overflow && r == target.RealProperties.infinity)\n     *overflow = true;\n \n   return r;"}, {"sha": "51a87a018135e581a2683c3f58d05a6c26c5ce1b", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -387,7 +387,7 @@ d_init (void)\n   /* This is the C main, not the D main.  */\n   main_identifier_node = get_identifier (\"main\");\n \n-  Target::_init ();\n+  target._init (global.params);\n   d_init_versions ();\n \n   /* Insert all library-configured identifiers and import paths.  */"}, {"sha": "f129fd8843d5c87e1fd4a823842a70bd69e9edd8", "filename": "gcc/d/d-port.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-port.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-port.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-port.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -78,7 +78,7 @@ Port::isFloat32LiteralOutOfRange (const char *buffer)\n \n   real_from_string3 (&r.rv (), buffer, TYPE_MODE (float_type_node));\n \n-  return r == Target::RealProperties::infinity;\n+  return r == target.RealProperties.infinity;\n }\n \n /* Return true if the real_t value from string BUFFER overflows\n@@ -91,7 +91,7 @@ Port::isFloat64LiteralOutOfRange (const char *buffer)\n \n   real_from_string3 (&r.rv (), buffer, TYPE_MODE (double_type_node));\n \n-  return r == Target::RealProperties::infinity;\n+  return r == target.RealProperties.infinity;\n }\n \n /* Fetch a little-endian 16-bit value from BUFFER.  */"}, {"sha": "29f5eaf5c2823e84a0d80fb829427f9d317560fb", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 65, "deletions": 71, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -42,37 +42,14 @@ along with GCC; see the file COPYING3.  If not see\n /* Implements the Target interface defined by the front end.\n    Used for retrieving target-specific information.  */\n \n-/* Type size information used by frontend.  */\n-int Target::ptrsize;\n-int Target::c_longsize;\n-int Target::realsize;\n-int Target::realpad;\n-int Target::realalignsize;\n-bool Target::reverseCppOverloads;\n-bool Target::cppExceptions;\n-int Target::classinfosize;\n-unsigned long long Target::maxStaticDataSize;\n-\n-/* Floating-point constants for .max, .min, and other properties.  */\n-template <typename T> real_t Target::FPTypeProperties<T>::max;\n-template <typename T> real_t Target::FPTypeProperties<T>::min_normal;\n-template <typename T> real_t Target::FPTypeProperties<T>::nan;\n-template <typename T> real_t Target::FPTypeProperties<T>::snan;\n-template <typename T> real_t Target::FPTypeProperties<T>::infinity;\n-template <typename T> real_t Target::FPTypeProperties<T>::epsilon;\n-template <typename T> d_int64 Target::FPTypeProperties<T>::dig;\n-template <typename T> d_int64 Target::FPTypeProperties<T>::mant_dig;\n-template <typename T> d_int64 Target::FPTypeProperties<T>::max_exp;\n-template <typename T> d_int64 Target::FPTypeProperties<T>::min_exp;\n-template <typename T> d_int64 Target::FPTypeProperties<T>::max_10_exp;\n-template <typename T> d_int64 Target::FPTypeProperties<T>::min_10_exp;\n+Target target;\n \n \n /* Initialize the floating-point constants for TYPE.  */\n \n template <typename T>\n static void\n-define_float_constants (tree type)\n+define_float_constants (T &f, tree type)\n {\n   const double log10_2 = 0.30102999566398119521;\n   char buf[128];\n@@ -83,106 +60,109 @@ define_float_constants (tree type)\n \n   /* The largest representable value that's not infinity.  */\n   get_max_float (fmt, buf, sizeof (buf), false);\n-  real_from_string (&T::max.rv (), buf);\n+  real_from_string (&f.max.rv (), buf);\n \n   /* The smallest representable normalized value that's not 0.  */\n   snprintf (buf, sizeof (buf), \"0x1p%d\", fmt->emin - 1);\n-  real_from_string (&T::min_normal.rv (), buf);\n+  real_from_string (&f.min_normal.rv (), buf);\n \n   /* Floating-point NaN.  */\n-  real_nan (&T::nan.rv (), \"\", 1, mode);\n+  real_nan (&f.nan.rv (), \"\", 1, mode);\n \n   /* Signalling floating-point NaN.  */\n-  real_nan (&T::snan.rv (), \"\", 0, mode);\n+  real_nan (&f.snan.rv (), \"\", 0, mode);\n \n   /* Floating-point +Infinity if the target supports infinities.  */\n-  real_inf (&T::infinity.rv ());\n+  real_inf (&f.infinity.rv ());\n \n   /* The smallest increment to the value 1.  */\n   if (fmt->pnan < fmt->p)\n     snprintf (buf, sizeof (buf), \"0x1p%d\", fmt->emin - fmt->p);\n   else\n     snprintf (buf, sizeof (buf), \"0x1p%d\", 1 - fmt->p);\n-  real_from_string (&T::epsilon.rv (), buf);\n+  real_from_string (&f.epsilon.rv (), buf);\n \n   /* The number of decimal digits of precision.  */\n-  T::dig = (fmt->p - 1) * log10_2;\n+  f.dig = (fmt->p - 1) * log10_2;\n \n   /* The number of bits in mantissa.  */\n-  T::mant_dig = fmt->p;\n+  f.mant_dig = fmt->p;\n \n   /* The maximum int value such that 2** (value-1) is representable.  */\n-  T::max_exp = fmt->emax;\n+  f.max_exp = fmt->emax;\n \n   /* The minimum int value such that 2** (value-1) is representable as a\n      normalized value.  */\n-  T::min_exp = fmt->emin;\n+  f.min_exp = fmt->emin;\n \n   /* The maximum int value such that 10**value is representable.  */\n-  T::max_10_exp = fmt->emax * log10_2;\n+  f.max_10_exp = fmt->emax * log10_2;\n \n   /* The minimum int value such that 10**value is representable as a\n      normalized value.  */\n-  T::min_10_exp = (fmt->emin - 1) * log10_2;\n+  f.min_10_exp = (fmt->emin - 1) * log10_2;\n }\n \n /* Initialize all variables of the Target structure.  */\n \n void\n-Target::_init (void)\n+Target::_init (const Param &)\n {\n   /* Map D frontend type and sizes to GCC back-end types.  */\n-  Target::ptrsize = (POINTER_SIZE / BITS_PER_UNIT);\n-  Target::realsize = int_size_in_bytes (long_double_type_node);\n-  Target::realpad = (Target::realsize -\n-\t\t     (TYPE_PRECISION (long_double_type_node) / BITS_PER_UNIT));\n-  Target::realalignsize = TYPE_ALIGN_UNIT (long_double_type_node);\n+  this->ptrsize = (POINTER_SIZE / BITS_PER_UNIT);\n+  this->realsize = int_size_in_bytes (long_double_type_node);\n+  this->realpad = (this->realsize -\n+\t\t   (TYPE_PRECISION (long_double_type_node) / BITS_PER_UNIT));\n+  this->realalignsize = TYPE_ALIGN_UNIT (long_double_type_node);\n \n   /* Size of run-time TypeInfo object.  */\n-  Target::classinfosize = 19 * Target::ptrsize;\n+  this->classinfosize = 19 * this->ptrsize;\n \n   /* Much of the dmd front-end uses ints for sizes and offsets, and cannot\n      handle any larger data type without some pervasive rework.  */\n-  Target::maxStaticDataSize = tree_to_shwi (TYPE_MAX_VALUE (integer_type_node));\n+  this->maxStaticDataSize = tree_to_shwi (TYPE_MAX_VALUE (integer_type_node));\n \n   /* Define what type to use for size_t, ptrdiff_t.  */\n-  if (Target::ptrsize == 8)\n+  if (this->ptrsize == 8)\n     {\n       global.params.isLP64 = true;\n-      Tsize_t = Tuns64;\n-      Tptrdiff_t = Tint64;\n+      Type::tsize_t = Type::basic[Tuns64];\n+      Type::tptrdiff_t = Type::basic[Tint64];\n     }\n-  else if (Target::ptrsize == 4)\n+  else if (this->ptrsize == 4)\n     {\n-      Tsize_t = Tuns32;\n-      Tptrdiff_t = Tint32;\n+      Type::tsize_t = Type::basic[Tuns32];\n+      Type::tptrdiff_t = Type::basic[Tint32];\n     }\n-  else if (Target::ptrsize == 2)\n+  else if (this->ptrsize == 2)\n     {\n-      Tsize_t = Tuns16;\n-      Tptrdiff_t = Tint16;\n+      Type::tsize_t = Type::basic[Tuns16];\n+      Type::tptrdiff_t = Type::basic[Tint16];\n     }\n   else\n     sorry (\"D does not support pointers on this target.\");\n \n-  Type::tsize_t = Type::basic[Tsize_t];\n-  Type::tptrdiff_t = Type::basic[Tptrdiff_t];\n   Type::thash_t = Type::tsize_t;\n \n   /* Set-up target C ABI.  */\n-  Target::c_longsize = int_size_in_bytes (long_integer_type_node);\n+  this->c.longsize = int_size_in_bytes (long_integer_type_node);\n+  this->c.long_doublesize = int_size_in_bytes (long_double_type_node);\n \n   /* Set-up target C++ ABI.  */\n-  Target::reverseCppOverloads = false;\n-  Target::cppExceptions = true;\n+  this->cpp.reverseOverloads = false;\n+  this->cpp.exceptions = true;\n+  this->cpp.twoDtorInVtable = true;\n+\n+  /* Set-up target Objective-C ABI.  */\n+  this->objc.supported = false;\n \n   /* Initialize all compile-time properties for floating-point types.\n      Should ensure that our real_t type is able to represent real_value.  */\n   gcc_assert (sizeof (real_t) >= sizeof (real_value));\n \n-  define_float_constants <Target::FloatProperties> (float_type_node);\n-  define_float_constants <Target::DoubleProperties> (double_type_node);\n-  define_float_constants <Target::RealProperties> (long_double_type_node);\n+  define_float_constants (this->FloatProperties, float_type_node);\n+  define_float_constants (this->DoubleProperties, double_type_node);\n+  define_float_constants (this->RealProperties, long_double_type_node);\n \n   /* Commonly used floating-point constants.  */\n   const machine_mode mode = TYPE_MODE (long_double_type_node);\n@@ -238,9 +218,22 @@ Target::critsecsize (void)\n /* Returns a Type for the va_list type of the target.  */\n \n Type *\n-Target::va_listType (void)\n+Target::va_listType (const Loc &, Scope *)\n {\n-  return Type::tvalist;\n+  if (this->tvalist)\n+    return this->tvalist;\n+\n+  /* Build the \"standard\" abi va_list.  */\n+  this->tvalist = build_frontend_type (va_list_type_node);\n+  if (!this->tvalist)\n+    sorry (\"cannot represent built-in %<va_list%> type in D\");\n+\n+  /* Map the va_list type to the D frontend Type.  This is to prevent both\n+     errors in gimplification or an ICE in targetm.canonical_va_list_type.  */\n+  this->tvalist->ctype = va_list_type_node;\n+  TYPE_LANG_SPECIFIC (va_list_type_node) = build_lang_type (this->tvalist);\n+\n+  return this->tvalist;\n }\n \n /* Checks whether the target supports a vector type with total size SZ\n@@ -335,15 +328,15 @@ Target::isVectorOpSupported (Type *type, TOK op, Type *)\n /* Return the symbol mangling of S for C++ linkage.  */\n \n const char *\n-Target::toCppMangle (Dsymbol *s)\n+TargetCPP::toMangle (Dsymbol *s)\n {\n   return toCppMangleItanium (s);\n }\n \n /* Return the symbol mangling of CD for C++ linkage.  */\n \n const char *\n-Target::cppTypeInfoMangle (ClassDeclaration *cd)\n+TargetCPP::typeInfoMangle (ClassDeclaration *cd)\n {\n   return cppTypeInfoMangleItanium (cd);\n }\n@@ -352,7 +345,7 @@ Target::cppTypeInfoMangle (ClassDeclaration *cd)\n    In all other cases, return NULL.  */\n \n const char *\n-Target::cppTypeMangle (Type *type)\n+TargetCPP::typeMangle (Type *type)\n {\n   if (type->isTypeBasic () || type->ty == Tvector || type->ty == Tstruct)\n     {\n@@ -367,7 +360,7 @@ Target::cppTypeMangle (Type *type)\n    ARG to an extern(C++) function.  */\n \n Type *\n-Target::cppParameterType (Parameter *arg)\n+TargetCPP::parameterType (Parameter *arg)\n {\n   Type *t = arg->type->merge2 ();\n   if (arg->storageClass & (STCout | STCref))\n@@ -381,10 +374,11 @@ Target::cppParameterType (Parameter *arg)\n     }\n \n   /* Could be a va_list, which we mangle as a pointer.  */\n-  if (t->ty == Tsarray && Type::tvalist->ty == Tsarray)\n+  Type *tvalist = target.va_listType (Loc (), NULL);\n+  if (t->ty == Tsarray && tvalist->ty == Tsarray)\n     {\n       Type *tb = t->toBasetype ()->mutableOf ();\n-      if (tb == Type::tvalist)\n+      if (tb == tvalist)\n \t{\n \t  tb = t->nextOf ()->pointerTo ();\n \t  t = tb->castMod (t->mod);\n@@ -398,7 +392,7 @@ Target::cppParameterType (Parameter *arg)\n    in IS_FUNDAMENTAL and returns true if the parameter was set.  */\n \n bool\n-Target::cppFundamentalType (const Type *, bool &)\n+TargetCPP::fundamentalType (const Type *, bool &)\n {\n   return false;\n }"}, {"sha": "3338e88b27844fe9e24d760003f1af714ac1881b", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -489,6 +489,7 @@ extern void apply_user_attributes (Dsymbol *, tree);\n /* In d-builtins.cc.  */\n extern const attribute_spec d_langhook_attribute_table[];\n extern const attribute_spec d_langhook_common_attribute_table[];\n+extern Type *build_frontend_type (tree);\n \n extern tree d_builtin_function (tree);\n extern void d_init_builtins (void);"}, {"sha": "f2d39a74cc8d9867e2e4749990062dd11d333044", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -2011,7 +2011,7 @@ mark_needed (tree decl)\n unsigned\n base_vtable_offset (ClassDeclaration *cd, BaseClass *bc)\n {\n-  unsigned csymoffset = Target::classinfosize;\n+  unsigned csymoffset = target.classinfosize;\n   unsigned interfacesize = int_size_in_bytes (vtbl_interface_type_node);\n   csymoffset += cd->vtblInterfaces->length * interfacesize;\n \n@@ -2020,7 +2020,7 @@ base_vtable_offset (ClassDeclaration *cd, BaseClass *bc)\n       BaseClass *b = (*cd->vtblInterfaces)[i];\n       if (b == bc)\n \treturn csymoffset;\n-      csymoffset += b->sym->vtbl.length * Target::ptrsize;\n+      csymoffset += b->sym->vtbl.length * target.ptrsize;\n     }\n \n   /* Check all overriding interface vtbl[]s.  */\n@@ -2033,7 +2033,7 @@ base_vtable_offset (ClassDeclaration *cd, BaseClass *bc)\n \t    {\n \t      if (bc == bs)\n \t\treturn csymoffset;\n-\t      csymoffset += bs->sym->vtbl.length * Target::ptrsize;\n+\t      csymoffset += bs->sym->vtbl.length * target.ptrsize;\n \t    }\n \t}\n     }"}, {"sha": "f413bd1751430e0bc0ee7fc28c46f52a9c66c19f", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -1,4 +1,4 @@\n-6d5bffa54f7da21d388d9999e586fd8a11ebcdb1\n+56f0a65c493463633a293d71faf37cdf710041ef\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "184af1f288c2b2b5a37f0e60bcac60f9da85dc7e", "filename": "gcc/d/dmd/attrib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fattrib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fattrib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -516,7 +516,7 @@ LinkDeclaration::LinkDeclaration(LINK p, Dsymbols *decl)\n         : AttribDeclaration(decl)\n {\n     //printf(\"LinkDeclaration(linkage = %d, decl = %p)\\n\", p, decl);\n-    linkage = (p == LINKsystem) ? Target::systemLinkage() : p;\n+    linkage = (p == LINKsystem) ? target.systemLinkage() : p;\n }\n \n LinkDeclaration *LinkDeclaration::create(LINK p, Dsymbols *decl)"}, {"sha": "38e6191698d738543c6072179249766d39ec3617", "filename": "gcc/d/dmd/constfold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fconstfold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fconstfold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -623,7 +623,7 @@ UnionExp Pow(Loc loc, Type *type, Expression *e1, Expression *e2)\n         // x ^^ y for x < 0 and y not an integer is not defined; so set result as NaN\n         if (e1->toReal() < CTFloat::zero)\n         {\n-            new(&ue) RealExp(loc, Target::RealProperties::nan, type);\n+            new(&ue) RealExp(loc, target.RealProperties.nan, type);\n         }\n         else\n             new(&ue) CTFEExp(TOKcantexp);"}, {"sha": "f39c24844606215512f701697f0cbafe23b160ac", "filename": "gcc/d/dmd/cppmangle.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fcppmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fcppmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -131,7 +131,7 @@ class CppMangleVisitor : public Visitor\n     {\n         // First check the target whether some specific ABI is being followed.\n         bool isFundamental;\n-        if (Target::cppFundamentalType(t, isFundamental))\n+        if (target.cpp.fundamentalType(t, isFundamental))\n             return isFundamental;\n         if (t->ty == Tenum)\n         {\n@@ -672,7 +672,7 @@ class CppMangleVisitor : public Visitor\n             {\n                 ParamsCppMangle *p = (ParamsCppMangle *)ctx;\n                 CppMangleVisitor *mangler = p->mangler;\n-                Type *t = Target::cppParameterType(fparam);\n+                Type *t = target.cpp.parameterType(fparam);\n                 if (t->ty == Tsarray)\n                 {\n                     // Static arrays in D are passed by value; no counterpart in C++\n@@ -803,7 +803,7 @@ class CppMangleVisitor : public Visitor\n             return error(t);\n \n         // Handle any target-specific basic types.\n-        if (const char *tm = Target::cppTypeMangle(t))\n+        if (const char *tm = target.cpp.typeMangle(t))\n         {\n             // Only do substitutions for non-fundamental types.\n             if (!isFundamentalType(t) || t->isConst())\n@@ -862,10 +862,10 @@ class CppMangleVisitor : public Visitor\n             case Tuns32:                c = 'j';        break;\n             case Tfloat32:              c = 'f';        break;\n             case Tint64:\n-                c = (Target::c_longsize == 8 ? 'l' : 'x');\n+                c = (target.c.longsize == 8 ? 'l' : 'x');\n                 break;\n             case Tuns64:\n-                c = (Target::c_longsize == 8 ? 'm' : 'y');\n+                c = (target.c.longsize == 8 ? 'm' : 'y');\n                 break;\n             case Tint128:                c = 'n';       break;\n             case Tuns128:                c = 'o';       break;\n@@ -899,7 +899,7 @@ class CppMangleVisitor : public Visitor\n         CV_qualifiers(t);\n \n         // Handle any target-specific vector types.\n-        if (const char *tm = Target::cppTypeMangle(t))\n+        if (const char *tm = target.cpp.typeMangle(t))\n         {\n             buf->writestring(tm);\n         }\n@@ -1030,7 +1030,7 @@ class CppMangleVisitor : public Visitor\n         CV_qualifiers(t);\n \n         // Handle any target-specific struct types.\n-        if (const char *tm = Target::cppTypeMangle(t))\n+        if (const char *tm = target.cpp.typeMangle(t))\n         {\n             buf->writestring(tm);\n         }"}, {"sha": "535679e10be03c4a5f3d05c536bc98be67e1ec16", "filename": "gcc/d/dmd/dclass.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -1048,7 +1048,7 @@ static unsigned membersPlace(BaseClasses *vtblInterfaces, size_t &bi, ClassDecla\n         assert(b->sym->sizeok == SIZEOKdone);\n \n         if (!b->sym->alignsize)\n-            b->sym->alignsize = Target::ptrsize;\n+            b->sym->alignsize = target.ptrsize;\n         cd->alignmember(b->sym->alignsize, b->sym->alignsize, &offset);\n         assert(bi < vtblInterfaces->length);\n         BaseClass *bv = (*vtblInterfaces)[bi];\n@@ -1092,16 +1092,16 @@ void ClassDeclaration::finalizeSize()\n     {\n         if (interfaces.length == 0)\n         {\n-            alignsize = Target::ptrsize;\n-            structsize = Target::ptrsize;      // allow room for __vptr\n+            alignsize = target.ptrsize;\n+            structsize = target.ptrsize;      // allow room for __vptr\n         }\n     }\n     else\n     {\n-        alignsize = Target::ptrsize;\n-        structsize = Target::ptrsize;      // allow room for __vptr\n+        alignsize = target.ptrsize;\n+        structsize = target.ptrsize;      // allow room for __vptr\n         if (!isCPPclass())\n-            structsize += Target::ptrsize; // allow room for __monitor\n+            structsize += target.ptrsize; // allow room for __monitor\n     }\n \n     //printf(\"finalizeSize() %s, sizeok = %d\\n\", toChars(), sizeok);"}, {"sha": "04f7a34ea9761d30ed9878a68c56f5cec41ec8a5", "filename": "gcc/d/dmd/declaration.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdeclaration.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdeclaration.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -1778,7 +1778,7 @@ void VarDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset,\n     const d_uns64 sz = t->size(loc);\n     assert(sz != SIZE_INVALID && sz < UINT32_MAX);\n     unsigned memsize = (unsigned)sz;                 // size of member\n-    unsigned memalignsize = Target::fieldalign(t);   // size of member for alignment purposes\n+    unsigned memalignsize = target.fieldalign(t);   // size of member for alignment purposes\n \n     offset = AggregateDeclaration::placeField(poffset, memsize, memalignsize, alignment,\n                 &ad->structsize, &ad->alignsize, isunion);\n@@ -2220,7 +2220,7 @@ TypeInfoDeclaration::TypeInfoDeclaration(Type *tinfo)\n     storage_class = STCstatic | STCgshared;\n     protection = Prot(PROTpublic);\n     linkage = LINKc;\n-    alignment = Target::ptrsize;\n+    alignment = target.ptrsize;\n }\n \n TypeInfoDeclaration *TypeInfoDeclaration::create(Type *tinfo)"}, {"sha": "c1a186de645e819ee71af05a9229db749cb25ab6", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -421,7 +421,7 @@ class Mangler : public Visitor\n                     return;\n \n                 case LINKcpp:\n-                    buf->writestring(Target::toCppMangle(d));\n+                    buf->writestring(target.cpp.toMangle(d));\n                     return;\n \n                 case LINKdefault:"}, {"sha": "891d469cebf5df74228125e8fa97d4bbf2ac3a4f", "filename": "gcc/d/dmd/dstruct.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -799,7 +799,7 @@ void AggregateDeclaration::alignmember(\n             break;\n \n         case (structalign_t) STRUCTALIGN_DEFAULT:\n-            // Alignment in Target::fieldalignsize must match what the\n+            // Alignment in target.fieldalignsize must match what the\n             // corresponding C compiler's default alignment behavior is.\n             assert(size > 0 && !(size & (size - 1)));\n             *poffset = (*poffset + size - 1) & ~(size - 1);\n@@ -1307,7 +1307,7 @@ void StructDeclaration::finalizeSize()\n         }\n     }\n \n-    TypeTuple *tt = Target::toArgTypes(type);\n+    TypeTuple *tt = target.toArgTypes(type);\n     size_t dim = tt ? tt->arguments->length : 0;\n     if (dim >= 1)\n     {"}, {"sha": "29103c1bac3c464fcf38d12edc7515fc4bfdc827", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -2925,11 +2925,11 @@ void IntegerExp::normalize()\n         case Tint64:        value = (d_int64) value;        break;\n         case Tuns64:        value = (d_uns64) value;        break;\n         case Tpointer:\n-            if (Target::ptrsize == 8)\n+            if (target.ptrsize == 8)\n                 value = (d_uns64) value;\n-            else if (Target::ptrsize == 4)\n+            else if (target.ptrsize == 4)\n                 value = (d_uns32) value;\n-            else if (Target::ptrsize == 2)\n+            else if (target.ptrsize == 2)\n                 value = (d_uns16) value;\n             else\n                 assert(0);"}, {"sha": "ffcfeb4e6cdbbecdbf20ef755a8bbc74eb9aeaca", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -2073,7 +2073,7 @@ class ExpressionSemanticVisitor : public Visitor\n                      * The results of this are highly platform dependent, and intended\n                      * primarly for use in implementing va_arg().\n                      */\n-                    tded = Target::toArgTypes(e->targ);\n+                    tded = target.toArgTypes(e->targ);\n                     if (!tded)\n                         goto Lno;           // not valid for a parameter\n                     break;\n@@ -2295,7 +2295,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 exp->e2 = exp->e2->castTo(sc, Type::tshiftcnt);\n         }\n \n-        if (!Target::isVectorOpSupported(exp->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(exp->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -3917,7 +3917,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (!Target::isVectorOpSupported(tb, exp->op))\n+        if (!target.isVectorOpSupported(tb, exp->op))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -3941,7 +3941,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (!Target::isVectorOpSupported(exp->e1->type->toBasetype(), exp->op))\n+        if (!target.isVectorOpSupported(exp->e1->type->toBasetype(), exp->op))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -3982,7 +3982,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (!Target::isVectorOpSupported(tb, exp->op))\n+        if (!target.isVectorOpSupported(tb, exp->op))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -4024,7 +4024,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (!Target::isVectorOpSupported(e->e1->type->toBasetype(), e->op))\n+        if (!target.isVectorOpSupported(e->e1->type->toBasetype(), e->op))\n         {\n             result = e->incompatibleTypes();\n             return;\n@@ -6410,7 +6410,7 @@ class ExpressionSemanticVisitor : public Visitor\n         }\n \n         tb1 = exp->e1->type->toBasetype();\n-        if (!Target::isVectorOpSupported(tb1, exp->op, tb2))\n+        if (!target.isVectorOpSupported(tb1, exp->op, tb2))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -6543,7 +6543,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         t1 = exp->e1->type->toBasetype();\n         t2 = exp->e2->type->toBasetype();\n-        if (!Target::isVectorOpSupported(t1, exp->op, t2))\n+        if (!target.isVectorOpSupported(t1, exp->op, t2))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -6864,7 +6864,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 exp->type = t1;  // t1 is complex\n             }\n         }\n-        else if (!Target::isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n+        else if (!target.isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -6964,7 +6964,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 exp->type = t1;  // t1 is complex\n             }\n         }\n-        else if (!Target::isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n+        else if (!target.isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7009,7 +7009,7 @@ class ExpressionSemanticVisitor : public Visitor\n             result = exp;\n             return;\n         }\n-        if (!Target::isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7091,7 +7091,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (exp->checkArithmeticBin())\n             return setError();\n \n-        if (!Target::isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7191,7 +7191,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         if (exp->checkIntegralBin())\n             return setError();\n-        if (!Target::isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7226,7 +7226,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         if (exp->checkIntegralBin())\n             return setError();\n-        if (!Target::isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7261,7 +7261,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         if (exp->checkIntegralBin())\n             return setError();\n-        if (!Target::isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(exp->e1->type->toBasetype(), exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7320,7 +7320,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (!Target::isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7377,7 +7377,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (!Target::isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7434,7 +7434,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (!Target::isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n+        if (!target.isVectorOpSupported(tb, exp->op, exp->e2->type->toBasetype()))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7756,7 +7756,7 @@ class ExpressionSemanticVisitor : public Visitor\n             exp->error(\"%s is not defined for associative arrays\", Token::toChars(exp->op));\n             return setError();\n         }\n-        else if (!Target::isVectorOpSupported(t1, exp->op, t2))\n+        else if (!target.isVectorOpSupported(t1, exp->op, t2))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7905,7 +7905,7 @@ class ExpressionSemanticVisitor : public Visitor\n         Type *t1 = exp->e1->type->toBasetype();\n         Type *t2 = exp->e2->type->toBasetype();\n \n-        if (!Target::isVectorOpSupported(t1, exp->op, t2))\n+        if (!target.isVectorOpSupported(t1, exp->op, t2))\n         {\n             result = exp->incompatibleTypes();\n             return;\n@@ -7958,7 +7958,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         Type *tb1 = exp->e1->type->toBasetype();\n         Type *tb2 = exp->e2->type->toBasetype();\n-        if (!Target::isVectorOpSupported(tb1, exp->op, tb2))\n+        if (!target.isVectorOpSupported(tb1, exp->op, tb2))\n         {\n             result = exp->incompatibleTypes();\n             return;"}, {"sha": "807565df12b54af6a370d3083765bccda8fb007d", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -902,7 +902,7 @@ void FuncDeclaration::semantic(Scope *sc)\n                 {\n                     //printf(\"\\tintroducing function %s\\n\", toChars());\n                     introducing = 1;\n-                    if (cd->isCPPclass() && Target::reverseCppOverloads)\n+                    if (cd->isCPPclass() && target.cpp.reverseOverloads)\n                     {\n                         // with dmc, overloaded functions are grouped and in reverse order\n                         vtblIndex = (int)cd->vtbl.length;\n@@ -1553,7 +1553,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n             if (f->linkage == LINKd || (f->parameters && Parameter::dim(f->parameters)))\n             {\n                 // Declare _argptr\n-                Type *t = Type::tvalist;\n+                Type *t = target.va_listType(loc, sc);\n                 v_argptr = new VarDeclaration(Loc(), t, Id::_argptr, NULL);\n                 v_argptr->storage_class |= STCtemp;\n                 v_argptr->semantic(sc2);"}, {"sha": "d61a244175f51299efad04798f23dd87a50e225c", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -2212,11 +2212,11 @@ class PrettyPrintVisitor : public Visitor\n             if ((sinteger_t)uval >= 0)\n             {\n                 dinteger_t sizemax;\n-                if (Target::ptrsize == 8)\n+                if (target.ptrsize == 8)\n                     sizemax = 0xFFFFFFFFFFFFFFFFULL;\n-                else if (Target::ptrsize == 4)\n+                else if (target.ptrsize == 4)\n                     sizemax = 0xFFFFFFFFUL;\n-                else if (Target::ptrsize == 2)\n+                else if (target.ptrsize == 2)\n                     sizemax = 0xFFFFUL;\n                 else\n                     assert(0);\n@@ -2358,7 +2358,7 @@ class PrettyPrintVisitor : public Visitor\n                     buf->writestring(\"cast(\");\n                     buf->writestring(t->toChars());\n                     buf->writeByte(')');\n-                    if (Target::ptrsize == 8)\n+                    if (target.ptrsize == 8)\n                         goto L4;\n                     else\n                         goto L3;"}, {"sha": "e2511a4fd6277def653ec3c59914cba1f1e015de", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 49, "deletions": 63, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -44,9 +44,6 @@ Expression *typeToExpression(Type *t);\n Expression *typeToExpressionHelper(TypeQualified *t, Expression *e, size_t i = 0);\n Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n \n-int Tsize_t = Tuns32;\n-int Tptrdiff_t = Tint32;\n-\n /***************************** Type *****************************/\n \n ClassDeclaration *Type::dtypeinfo;\n@@ -109,7 +106,6 @@ Type *Type::tvoidptr;\n Type *Type::tstring;\n Type *Type::twstring;\n Type *Type::tdstring;\n-Type *Type::tvalist;\n Type *Type::basic[TMAX];\n unsigned char Type::sizeTy[TMAX];\n StringTable Type::stringtable;\n@@ -262,21 +258,11 @@ void Type::_init()\n     tstring = tchar->immutableOf()->arrayOf();\n     twstring = twchar->immutableOf()->arrayOf();\n     tdstring = tdchar->immutableOf()->arrayOf();\n-    tvalist = Target::va_listType();\n \n-    if (global.params.isLP64)\n-    {\n-        Tsize_t = Tuns64;\n-        Tptrdiff_t = Tint64;\n-    }\n-    else\n-    {\n-        Tsize_t = Tuns32;\n-        Tptrdiff_t = Tint32;\n-    }\n+    const bool isLP64 = global.params.isLP64;\n \n-    tsize_t = basic[Tsize_t];\n-    tptrdiff_t = basic[Tptrdiff_t];\n+    tsize_t = basic[isLP64 ? Tuns64 : Tuns32];\n+    tptrdiff_t = basic[isLP64 ? Tint64 : Tint32];\n     thash_t = tsize_t;\n }\n \n@@ -3041,15 +3027,15 @@ d_uns64 TypeBasic::size(Loc)\n                         size = 8;       break;\n         case Tfloat80:\n         case Timaginary80:\n-                        size = Target::realsize; break;\n+                        size = target.realsize; break;\n         case Tcomplex32:\n                         size = 8;               break;\n         case Tcomplex64:\n         case Tint128:\n         case Tuns128:\n                         size = 16;              break;\n         case Tcomplex80:\n-                        size = Target::realsize * 2; break;\n+                        size = target.realsize * 2; break;\n \n         case Tvoid:\n             //size = Type::size();      // error message\n@@ -3071,7 +3057,7 @@ d_uns64 TypeBasic::size(Loc)\n \n unsigned TypeBasic::alignsize()\n {\n-    return Target::alignsize(this);\n+    return target.alignsize(this);\n }\n \n \n@@ -3125,17 +3111,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            fvalue = Target::FloatProperties::max;\n+            fvalue = target.FloatProperties.max;\n             goto Lfvalue;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            fvalue = Target::DoubleProperties::max;\n+            fvalue = target.DoubleProperties.max;\n             goto Lfvalue;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            fvalue = Target::RealProperties::max;\n+            fvalue = target.RealProperties.max;\n             goto Lfvalue;\n         }\n     }\n@@ -3200,17 +3186,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            fvalue = Target::FloatProperties::min_normal;\n+            fvalue = target.FloatProperties.min_normal;\n             goto Lfvalue;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            fvalue = Target::DoubleProperties::min_normal;\n+            fvalue = target.DoubleProperties.min_normal;\n             goto Lfvalue;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            fvalue = Target::RealProperties::min_normal;\n+            fvalue = target.RealProperties.min_normal;\n             goto Lfvalue;\n         }\n     }\n@@ -3227,7 +3213,7 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tfloat32:\n         case Tfloat64:\n         case Tfloat80:\n-            fvalue = Target::RealProperties::nan;\n+            fvalue = target.RealProperties.nan;\n             goto Lfvalue;\n         }\n     }\n@@ -3244,7 +3230,7 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tfloat32:\n         case Tfloat64:\n         case Tfloat80:\n-            fvalue = Target::RealProperties::infinity;\n+            fvalue = target.RealProperties.infinity;\n             goto Lfvalue;\n         }\n     }\n@@ -3255,17 +3241,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            ivalue = Target::FloatProperties::dig;\n+            ivalue = target.FloatProperties.dig;\n             goto Lint;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            ivalue = Target::DoubleProperties::dig;\n+            ivalue = target.DoubleProperties.dig;\n             goto Lint;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            ivalue = Target::RealProperties::dig;\n+            ivalue = target.RealProperties.dig;\n             goto Lint;\n         }\n     }\n@@ -3276,17 +3262,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            fvalue = Target::FloatProperties::epsilon;\n+            fvalue = target.FloatProperties.epsilon;\n             goto Lfvalue;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            fvalue = Target::DoubleProperties::epsilon;\n+            fvalue = target.DoubleProperties.epsilon;\n             goto Lfvalue;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            fvalue = Target::RealProperties::epsilon;\n+            fvalue = target.RealProperties.epsilon;\n             goto Lfvalue;\n         }\n     }\n@@ -3297,17 +3283,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            ivalue = Target::FloatProperties::mant_dig;\n+            ivalue = target.FloatProperties.mant_dig;\n             goto Lint;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            ivalue = Target::DoubleProperties::mant_dig;\n+            ivalue = target.DoubleProperties.mant_dig;\n             goto Lint;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            ivalue = Target::RealProperties::mant_dig;\n+            ivalue = target.RealProperties.mant_dig;\n             goto Lint;\n         }\n     }\n@@ -3318,17 +3304,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            ivalue = Target::FloatProperties::max_10_exp;\n+            ivalue = target.FloatProperties.max_10_exp;\n             goto Lint;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            ivalue = Target::DoubleProperties::max_10_exp;\n+            ivalue = target.DoubleProperties.max_10_exp;\n             goto Lint;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            ivalue = Target::RealProperties::max_10_exp;\n+            ivalue = target.RealProperties.max_10_exp;\n             goto Lint;\n         }\n     }\n@@ -3339,17 +3325,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            ivalue = Target::FloatProperties::max_exp;\n+            ivalue = target.FloatProperties.max_exp;\n             goto Lint;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            ivalue = Target::DoubleProperties::max_exp;\n+            ivalue = target.DoubleProperties.max_exp;\n             goto Lint;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            ivalue = Target::RealProperties::max_exp;\n+            ivalue = target.RealProperties.max_exp;\n             goto Lint;\n         }\n     }\n@@ -3360,17 +3346,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            ivalue = Target::FloatProperties::min_10_exp;\n+            ivalue = target.FloatProperties.min_10_exp;\n             goto Lint;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            ivalue = Target::DoubleProperties::min_10_exp;\n+            ivalue = target.DoubleProperties.min_10_exp;\n             goto Lint;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            ivalue = Target::RealProperties::min_10_exp;\n+            ivalue = target.RealProperties.min_10_exp;\n             goto Lint;\n         }\n     }\n@@ -3381,17 +3367,17 @@ Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)\n         case Tcomplex32:\n         case Timaginary32:\n         case Tfloat32:\n-            ivalue = Target::FloatProperties::min_exp;\n+            ivalue = target.FloatProperties.min_exp;\n             goto Lint;\n         case Tcomplex64:\n         case Timaginary64:\n         case Tfloat64:\n-            ivalue = Target::DoubleProperties::min_exp;\n+            ivalue = target.DoubleProperties.min_exp;\n             goto Lint;\n         case Tcomplex80:\n         case Timaginary80:\n         case Tfloat80:\n-            ivalue = Target::RealProperties::min_exp;\n+            ivalue = target.RealProperties.min_exp;\n             goto Lint;\n         }\n     }\n@@ -3514,13 +3500,13 @@ Expression *TypeBasic::defaultInit(Loc loc)\n         case Tfloat32:\n         case Tfloat64:\n         case Tfloat80:\n-            return new RealExp(loc, Target::RealProperties::snan, this);\n+            return new RealExp(loc, target.RealProperties.snan, this);\n \n         case Tcomplex32:\n         case Tcomplex64:\n         case Tcomplex80:\n         {   // Can't use fvalue + I*fvalue (the im part becomes a quiet NaN).\n-            complex_t cvalue = complex_t(Target::RealProperties::snan, Target::RealProperties::snan);\n+            complex_t cvalue = complex_t(target.RealProperties.snan, target.RealProperties.snan);\n             return new ComplexExp(loc, cvalue, this);\n         }\n \n@@ -3730,7 +3716,7 @@ Type *TypeVector::semantic(Loc loc, Scope *sc)\n     }\n     TypeSArray *t = (TypeSArray *)basetype;\n     int sz = (int)t->size(loc);\n-    switch (Target::isVectorTypeSupported(sz, t->nextOf()))\n+    switch (target.isVectorTypeSupported(sz, t->nextOf()))\n     {\n     case 0: // valid\n         break;\n@@ -4142,7 +4128,7 @@ Type *TypeSArray::semantic(Loc loc, Scope *sc)\n         {\n         Loverflow:\n             error(loc, \"%s size %llu * %llu exceeds 0x%llx size limit for static array\",\n-                toChars(), (unsigned long long)tbn->size(loc), (unsigned long long)d1, Target::maxStaticDataSize);\n+                toChars(), (unsigned long long)tbn->size(loc), (unsigned long long)d1, target.maxStaticDataSize);\n             goto Lerror;\n         }\n \n@@ -4166,7 +4152,7 @@ Type *TypeSArray::semantic(Loc loc, Scope *sc)\n              * run on them for the size, since they may be forward referenced.\n              */\n             bool overflow = false;\n-            if (mulu(tbn->size(loc), d2, overflow) >= Target::maxStaticDataSize || overflow)\n+            if (mulu(tbn->size(loc), d2, overflow) >= target.maxStaticDataSize || overflow)\n                 goto Loverflow;\n         }\n     }\n@@ -4405,14 +4391,14 @@ Type *TypeDArray::syntaxCopy()\n d_uns64 TypeDArray::size(Loc)\n {\n     //printf(\"TypeDArray::size()\\n\");\n-    return Target::ptrsize * 2;\n+    return target.ptrsize * 2;\n }\n \n unsigned TypeDArray::alignsize()\n {\n     // A DArray consists of two ptr-sized values, so align it on pointer size\n     // boundary\n-    return Target::ptrsize;\n+    return target.ptrsize;\n }\n \n Type *TypeDArray::semantic(Loc loc, Scope *sc)\n@@ -4604,7 +4590,7 @@ Type *TypeAArray::syntaxCopy()\n \n d_uns64 TypeAArray::size(Loc)\n {\n-    return Target::ptrsize;\n+    return target.ptrsize;\n }\n \n Type *TypeAArray::semantic(Loc loc, Scope *sc)\n@@ -4967,7 +4953,7 @@ Type *TypePointer::semantic(Loc loc, Scope *sc)\n \n d_uns64 TypePointer::size(Loc)\n {\n-    return Target::ptrsize;\n+    return target.ptrsize;\n }\n \n MATCH TypePointer::implicitConvTo(Type *to)\n@@ -5111,7 +5097,7 @@ Type *TypeReference::semantic(Loc loc, Scope *sc)\n \n d_uns64 TypeReference::size(Loc)\n {\n-    return Target::ptrsize;\n+    return target.ptrsize;\n }\n \n Expression *TypeReference::dotExp(Scope *sc, Expression *e, Identifier *ident, int flag)\n@@ -6474,12 +6460,12 @@ Type *TypeDelegate::addStorageClass(StorageClass stc)\n \n d_uns64 TypeDelegate::size(Loc)\n {\n-    return Target::ptrsize * 2;\n+    return target.ptrsize * 2;\n }\n \n unsigned TypeDelegate::alignsize()\n {\n-    return Target::ptrsize;\n+    return target.ptrsize;\n }\n \n MATCH TypeDelegate::implicitConvTo(Type *to)\n@@ -8148,7 +8134,7 @@ Expression *TypeStruct::defaultInitLiteral(Loc loc)\n     /* Copy from the initializer symbol for larger symbols,\n      * otherwise the literals expressed as code get excessively large.\n      */\n-    if (size(loc) > Target::ptrsize * 4U && !needsNested())\n+    if (size(loc) > target.ptrsize * 4U && !needsNested())\n         structinit->useStaticInit = true;\n \n     structinit->type = this;\n@@ -8401,7 +8387,7 @@ Type *TypeClass::semantic(Loc, Scope *sc)\n \n d_uns64 TypeClass::size(Loc)\n {\n-    return Target::ptrsize;\n+    return target.ptrsize;\n }\n \n Dsymbol *TypeClass::toDsymbol(Scope *)"}, {"sha": "4efeddd7af5163b31224c14fcaac6923126ecfb0", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -99,9 +99,6 @@ enum ENUMTY\n };\n typedef unsigned char TY;       // ENUMTY\n \n-extern int Tsize_t;\n-extern int Tptrdiff_t;\n-\n #define SIZE_INVALID (~(d_uns64)0)   // error return from size() functions\n \n \n@@ -193,7 +190,6 @@ class Type : public RootObject\n     static Type *tstring;               // immutable(char)[]\n     static Type *twstring;              // immutable(wchar)[]\n     static Type *tdstring;              // immutable(dchar)[]\n-    static Type *tvalist;               // va_list alias\n     static Type *terror;                // for error recovery\n     static Type *tnull;                 // for null type\n "}, {"sha": "08274af8bd479b841fbccf18e1e1ceb73bc6ba04", "filename": "gcc/d/dmd/safe.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fsafe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fsafe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsafe.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -58,8 +58,8 @@ bool checkUnsafeAccess(Scope *sc, Expression *e, bool readonly, bool printmsg)\n \n         if (v->type->hasPointers() && v->type->toBasetype()->ty != Tstruct)\n         {\n-            if ((ad->type->alignment() < (unsigned)Target::ptrsize ||\n-                 (v->offset & (Target::ptrsize - 1))) &&\n+            if ((ad->type->alignment() < target.ptrsize ||\n+                 (v->offset & (target.ptrsize - 1))) &&\n                 sc->func->setUnsafe())\n             {\n                 if (printmsg)"}, {"sha": "bfcb4b4db9c88502f435a487f3c28fb1c5e3ac0a", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -1153,7 +1153,7 @@ class StatementSemanticVisitor : public Visitor\n                         fs->key = new VarDeclaration(loc, Type::tsize_t, idkey, NULL);\n                         fs->key->storage_class |= STCtemp;\n                     }\n-                    else if (fs->key->type->ty != Tsize_t)\n+                    else if (fs->key->type->ty != Type::tsize_t->ty)\n                     {\n                         tmp_length = new CastExp(loc, tmp_length, fs->key->type);\n                     }\n@@ -1585,8 +1585,8 @@ class StatementSemanticVisitor : public Visitor\n                         d_uns64 keysize = taa->index->size();\n                         if (keysize == SIZE_INVALID)\n                             goto Lerror2;\n-                        assert(keysize < UINT64_MAX - Target::ptrsize);\n-                        keysize = (keysize + (Target::ptrsize- 1)) & ~(Target::ptrsize - 1);\n+                        assert(keysize < UINT64_MAX - target.ptrsize);\n+                        keysize = (keysize + (target.ptrsize - 1)) & ~(target.ptrsize - 1);\n                         // paint delegate argument to the type runtime expects\n                         if (!fldeTy[i]->equals(flde->type))\n                         {\n@@ -3248,7 +3248,7 @@ class StatementSemanticVisitor : public Visitor\n              *  try { body } finally { _d_criticalexit(critsec.ptr); }\n              */\n             Identifier *id = Identifier::generateId(\"__critsec\");\n-            Type *t = Type::tint8->sarrayOf(Target::ptrsize + Target::critsecsize());\n+            Type *t = Type::tint8->sarrayOf(target.ptrsize + target.critsecsize());\n             VarDeclaration *tmp = new VarDeclaration(ss->loc, t, id, NULL);\n             tmp->storage_class |= STCtemp | STCgshared | STCstatic;\n \n@@ -3829,7 +3829,7 @@ void semantic(Catch *c, Scope *sc)\n         }\n         else if (cd->isCPPclass())\n         {\n-            if (!Target::cppExceptions)\n+            if (!target.cpp.exceptions)\n             {\n                 error(c->loc, \"catching C++ class objects not supported for this target\");\n                 c->errors = true;"}, {"sha": "d76a9f89abd0025f933c3d55380cf28f8509835d", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 72, "deletions": 40, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -24,55 +24,87 @@ class Type;\n class TypeTuple;\n struct OutBuffer;\n \n+struct TargetC\n+{\n+    unsigned longsize;            // size of a C 'long' or 'unsigned long' type\n+    unsigned long_doublesize;     // size of a C 'long double'\n+    unsigned criticalSectionSize; // size of os critical section\n+};\n+\n+struct TargetCPP\n+{\n+    bool reverseOverloads;    // with dmc and cl, overloaded functions are grouped and in reverse order\n+    bool exceptions;          // set if catching C++ exceptions is supported\n+    bool twoDtorInVtable;     // target C++ ABI puts deleting and non-deleting destructor into vtable\n+\n+    const char *toMangle(Dsymbol *s);\n+    const char *typeInfoMangle(ClassDeclaration *cd);\n+    const char *typeMangle(Type *t);\n+    Type *parameterType(Parameter *p);\n+    bool fundamentalType(const Type *t, bool& isFundamental);\n+};\n+\n+struct TargetObjC\n+{\n+    bool supported;     // set if compiler can interface with Objective-C\n+};\n+\n struct Target\n {\n-    static int ptrsize;\n-    static int realsize;             // size a real consumes in memory\n-    static int realpad;              // 'padding' added to the CPU real size to bring it up to realsize\n-    static int realalignsize;        // alignment for reals\n-    static bool reverseCppOverloads; // with dmc and cl, overloaded functions are grouped and in reverse order\n-    static bool cppExceptions;       // set if catching C++ exceptions is supported\n-    static int c_longsize;           // size of a C 'long' or 'unsigned long' type\n-    static int c_long_doublesize;    // size of a C 'long double'\n-    static int classinfosize;        // size of 'ClassInfo'\n-    static unsigned long long maxStaticDataSize;  // maximum size of static data\n+    // D ABI\n+    unsigned ptrsize;\n+    unsigned realsize;           // size a real consumes in memory\n+    unsigned realpad;            // 'padding' added to the CPU real size to bring it up to realsize\n+    unsigned realalignsize;      // alignment for reals\n+    unsigned classinfosize;      // size of 'ClassInfo'\n+    unsigned long long maxStaticDataSize;  // maximum size of static data\n+\n+    // C ABI\n+    TargetC c;\n+\n+    // C++ ABI\n+    TargetCPP cpp;\n+\n+    // Objective-C ABI\n+    TargetObjC objc;\n \n     template <typename T>\n     struct FPTypeProperties\n     {\n-        static real_t max;\n-        static real_t min_normal;\n-        static real_t nan;\n-        static real_t snan;\n-        static real_t infinity;\n-        static real_t epsilon;\n-\n-        static d_int64 dig;\n-        static d_int64 mant_dig;\n-        static d_int64 max_exp;\n-        static d_int64 min_exp;\n-        static d_int64 max_10_exp;\n-        static d_int64 min_10_exp;\n+        real_t max;\n+        real_t min_normal;\n+        real_t nan;\n+        real_t snan;\n+        real_t infinity;\n+        real_t epsilon;\n+\n+        d_int64 dig;\n+        d_int64 mant_dig;\n+        d_int64 max_exp;\n+        d_int64 min_exp;\n+        d_int64 max_10_exp;\n+        d_int64 min_10_exp;\n     };\n \n-    typedef FPTypeProperties<float> FloatProperties;\n-    typedef FPTypeProperties<double> DoubleProperties;\n-    typedef FPTypeProperties<real_t> RealProperties;\n+    FPTypeProperties<float> FloatProperties;\n+    FPTypeProperties<double> DoubleProperties;\n+    FPTypeProperties<real_t> RealProperties;\n \n-    static void _init();\n+private:\n+    Type *tvalist;\n+\n+public:\n+    void _init(const Param& params);\n     // Type sizes and support.\n-    static unsigned alignsize(Type* type);\n-    static unsigned fieldalign(Type* type);\n-    static unsigned critsecsize();\n-    static Type *va_listType();  // get type of va_list\n-    static int isVectorTypeSupported(int sz, Type *type);\n-    static bool isVectorOpSupported(Type *type, TOK op, Type *t2 = NULL);\n+    unsigned alignsize(Type *type);\n+    unsigned fieldalign(Type *type);\n+    unsigned critsecsize();\n+    Type *va_listType(const Loc &loc, Scope *sc);  // get type of va_list\n+    int isVectorTypeSupported(int sz, Type *type);\n+    bool isVectorOpSupported(Type *type, TOK op, Type *t2 = NULL);\n     // ABI and backend.\n-    static const char *toCppMangle(Dsymbol *s);\n-    static const char *cppTypeInfoMangle(ClassDeclaration *cd);\n-    static const char *cppTypeMangle(Type *t);\n-    static Type *cppParameterType(Parameter *p);\n-    static bool cppFundamentalType(const Type *t, bool& isFundamental);\n-    static LINK systemLinkage();\n-    static TypeTuple *toArgTypes(Type *t);\n+    LINK systemLinkage();\n+    TypeTuple *toArgTypes(Type *t);\n };\n+\n+extern Target target;"}, {"sha": "1c5d669abf8850ff2ec0d5e1cc41c9c97c68ef8b", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -1223,7 +1223,7 @@ layout_classinfo_interfaces (ClassDeclaration *decl)\n \n \t      field = create_field_decl (vtbltype, NULL, 1, 1);\n \t      insert_aggregate_field (type, field, offset);\n-\t      structsize += id->vtbl.length * Target::ptrsize;\n+\t      structsize += id->vtbl.length * target.ptrsize;\n \t    }\n \t}\n     }\n@@ -1247,7 +1247,7 @@ layout_classinfo_interfaces (ClassDeclaration *decl)\n \n \t      tree field = create_field_decl (vtbltype, NULL, 1, 1);\n \t      insert_aggregate_field (type, field, offset);\n-\t      structsize += id->vtbl.length * Target::ptrsize;\n+\t      structsize += id->vtbl.length * target.ptrsize;\n \t    }\n \t}\n     }\n@@ -1415,7 +1415,7 @@ layout_cpp_typeinfo (ClassDeclaration *cd)\n \n   /* Let C++ do the RTTI generation, and just reference the symbol as\n      extern, knowing the underlying type is not required.  */\n-  const char *ident = Target::cppTypeInfoMangle (cd);\n+  const char *ident = target.cpp.typeInfoMangle (cd);\n   tree typeinfo = declare_extern_var (get_identifier (ident),\n \t\t\t\t      unknown_type_node);\n   TREE_READONLY (typeinfo) = 1;"}, {"sha": "0fda81c31e78d6b7c1ac3dd86dc175db36553a92", "filename": "gcc/d/types.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5905cbdbcf6d760303ca87f27e04824f26976de4/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=5905cbdbcf6d760303ca87f27e04824f26976de4", "patch": "@@ -49,10 +49,11 @@ along with GCC; see the file COPYING3.  If not see\n bool\n valist_array_p (Type *type)\n {\n-  if (Type::tvalist->ty == Tsarray)\n+  Type *tvalist = target.va_listType (Loc (), NULL);\n+  if (tvalist->ty == Tsarray)\n     {\n       Type *tb = type->toBasetype ();\n-      if (same_type_p (tb, Type::tvalist))\n+      if (same_type_p (tb, tvalist))\n \treturn true;\n     }\n \n@@ -423,7 +424,7 @@ layout_aggregate_type (AggregateDeclaration *decl, tree type,\n \t    {\n \t      tree field = create_field_decl (ptr_type_node, \"__monitor\", 1,\n \t\t\t\t\t      inherited_p);\n-\t      insert_aggregate_field (type, field, Target::ptrsize);\n+\t      insert_aggregate_field (type, field, target.ptrsize);\n \t    }\n \t}\n "}]}