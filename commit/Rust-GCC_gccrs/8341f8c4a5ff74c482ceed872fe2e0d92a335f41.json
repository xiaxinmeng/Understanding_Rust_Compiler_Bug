{"sha": "8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM0MWY4YzRhNWZmNzRjNDgyY2VlZDg3MmZlMmUwZDkyYTMzNWY0MQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2016-12-15T15:41:26Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2016-12-15T15:41:26Z"}, "message": "[arm] Introduce arm_active_target.\n\nThis patch creates a new data structure for carrying around the data\nrelating to the current compilation target.  The idea behind this is\nthat this data structure can be updated to reflect the overall\ncompilation target as new information is gathered (from command line\noptions) or architectural extensions.  We will no-longer have to grub\naround looking in multiple places for this information.\n\nThere are some small behaviour changes around how we handle selecting\na default CPU if thumb or interworking are specified on the command\nline and the default CPU does not support thumb, but I believe the\nexisting code was broken in that respect.  This code will go away once\nwe obsolete pre-armv4t devices.\n\n\t* arm-protos.h (arm_build_target): New structure.\n\t(arm_active_target): Declare it.\n\t* arm.c (arm_active_target): New variable.\n\t(bitmap_popcount): New function.\n\t(feature_count): Delete.\n\t(arm_initialize_isa): New function.\n\tisa_fpubits): New variable.\n\t(arm_configure_build_target): New function.\n\t(arm_option_override): Initialize isa_fpubits and arm_active_target.isa.\n\tUse arm_configure_build_target.\n\nFrom-SVN: r243698", "tree": {"sha": "9f850e8c307c6acb3d34262c622dfaccf3a95531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f850e8c307c6acb3d34262c622dfaccf3a95531"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8341f8c4a5ff74c482ceed872fe2e0d92a335f41/comments", "author": null, "committer": null, "parents": [{"sha": "00d1c28c7b63b35558b3b239d20fec812fbf30a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d1c28c7b63b35558b3b239d20fec812fbf30a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00d1c28c7b63b35558b3b239d20fec812fbf30a7"}], "stats": {"total": 241, "additions": 181, "deletions": 60}, "files": [{"sha": "f919f84c6b7b07a2e9b515705e561a5c86061588", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8341f8c4a5ff74c482ceed872fe2e0d92a335f41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8341f8c4a5ff74c482ceed872fe2e0d92a335f41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "patch": "@@ -1,3 +1,16 @@\n+2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm-protos.h (arm_build_target): New structure.\n+\t(arm_active_target): Declare it.\n+\t* arm.c (arm_active_target): New variable.\n+\t(bitmap_popcount): New function.\n+\t(feature_count): Delete.\n+\t(arm_initialize_isa): New function.\n+\tisa_fpubits): New variable.\n+\t(arm_configure_build_target): New function.\n+\t(arm_option_override): Initialize isa_fpubits and arm_active_target.isa.\n+\tUse arm_configure_build_target.\n+\n 2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm-isa.h: New file."}, {"sha": "7673e3ac507c0efa1fbc6b11bcae81d1a5cc060e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8341f8c4a5ff74c482ceed872fe2e0d92a335f41/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8341f8c4a5ff74c482ceed872fe2e0d92a335f41/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "patch": "@@ -449,6 +449,31 @@ extern int arm_arch_no_volatile_ce;\n    than core registers.  */\n extern int prefer_neon_for_64bits;\n \n+/* Structure defining the current overall architectural target and tuning.  */\n+struct arm_build_target\n+{\n+  /* Name of the target CPU, if known, or NULL if the target CPU was not\n+     specified by the user (and inferred from the -march option).  */\n+  const char *core_name;\n+  /* Name of the target ARCH.  NULL if there is a selected CPU.  */\n+  const char *arch_name;\n+  /* Preprocessor substring (never NULL).  */\n+  const char *arch_pp_name;\n+  /* CPU identifier for the core we're compiling for (architecturally).  */\n+  enum processor_type arch_core;\n+  /* The base architecture value.  */\n+  enum base_architecture base_arch;\n+  /* Bitmap encapsulating the isa_bits for the target environment.  */\n+  sbitmap isa;\n+  /* Flags used for tuning.  Long term, these move into tune_params.  */\n+  unsigned int tune_flags;\n+  /* Tables with more detailed tuning information.  */\n+  const struct tune_params *tune;\n+  /* CPU identifier for the tuning target.  */\n+  enum processor_type tune_core;\n+};\n+\n+extern struct arm_build_target arm_active_target;\n \n \n #endif /* ! GCC_ARM_PROTOS_H */"}, {"sha": "deab5288907d6fbad08247ef0e922f072bc634ce", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 143, "deletions": 60, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8341f8c4a5ff74c482ceed872fe2e0d92a335f41/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8341f8c4a5ff74c482ceed872fe2e0d92a335f41/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "patch": "@@ -88,7 +88,7 @@ static void arm_add_gc_roots (void);\n static int arm_gen_constant (enum rtx_code, machine_mode, rtx,\n \t\t\t     unsigned HOST_WIDE_INT, rtx, rtx, int, int);\n static unsigned bit_count (unsigned long);\n-static unsigned feature_count (const arm_feature_set*);\n+static unsigned bitmap_popcount (const sbitmap);\n static int arm_address_register_rtx_p (rtx, int);\n static int arm_legitimate_index_p (machine_mode, rtx, RTX_CODE, int);\n static bool is_called_in_ARM_mode (tree);\n@@ -791,6 +791,10 @@ unsigned int tune_flags = 0;\n    target.  */\n enum base_architecture arm_base_arch = BASE_ARCH_0;\n \n+/* Active target architecture and tuning.  */\n+\n+struct arm_build_target arm_active_target;\n+\n /* The following are used in the arm.md file as equivalents to bits\n    in the above two flag variables.  */\n \n@@ -2376,12 +2380,17 @@ bit_count (unsigned long value)\n   return count;\n }\n \n-/* Return the number of features in feature-set SET.  */\n+/* Return the number of bits set in BMAP.  */\n static unsigned\n-feature_count (const arm_feature_set * set)\n+bitmap_popcount (const sbitmap bmap)\n {\n-  return (bit_count (ARM_FSET_CPU1 (*set))\n-\t  + bit_count (ARM_FSET_CPU2 (*set)));\n+  unsigned int count = 0;\n+  unsigned int n = 0;\n+  sbitmap_iterator sbi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (bmap, 0, n, sbi)\n+    count++;\n+  return count;\n }\n \n typedef struct\n@@ -3038,100 +3047,149 @@ arm_option_override_internal (struct gcc_options *opts,\n #endif\n }\n \n-/* Fix up any incompatible options that the user has specified.  */\n+/* Convert a static initializer array of feature bits to sbitmap\n+   representation.  */\n static void\n-arm_option_override (void)\n+arm_initialize_isa (sbitmap isa, const enum isa_feature *isa_bits)\n+{\n+  bitmap_clear (isa);\n+  while (*isa_bits != isa_nobit)\n+    bitmap_set_bit (isa, *(isa_bits++));\n+}\n+\n+static sbitmap isa_fpubits;\n+\n+/* Configure a build target TARGET from the user-specified options OPTS and\n+   OPTS_SET.  If WARN_COMPATIBLE, emit a diagnostic if both the CPU and\n+   architecture have been specified, but the two are not identical.  */\n+static void\n+arm_configure_build_target (struct arm_build_target *target,\n+\t\t\t    struct gcc_options *opts,\n+\t\t\t    struct gcc_options *opts_set,\n+\t\t\t    bool warn_compatible)\n {\n   arm_selected_arch = NULL;\n   arm_selected_cpu = NULL;\n   arm_selected_tune = NULL;\n \n-  if (global_options_set.x_arm_arch_option)\n-    arm_selected_arch = &all_architectures[arm_arch_option];\n+  bitmap_clear (target->isa);\n+  target->core_name = NULL;\n+  target->arch_name = NULL;\n+\n+  if (opts_set->x_arm_arch_option)\n+    arm_selected_arch = &all_architectures[opts->x_arm_arch_option];\n \n-  if (global_options_set.x_arm_cpu_option)\n+  if (opts_set->x_arm_cpu_option)\n     {\n-      arm_selected_cpu = &all_cores[(int) arm_cpu_option];\n-      arm_selected_tune = &all_cores[(int) arm_cpu_option];\n+      arm_selected_cpu = &all_cores[(int) opts->x_arm_cpu_option];\n+      arm_selected_tune = &all_cores[(int) opts->x_arm_cpu_option];\n     }\n \n-  if (global_options_set.x_arm_tune_option)\n-    arm_selected_tune = &all_cores[(int) arm_tune_option];\n-\n-#ifdef SUBTARGET_OVERRIDE_OPTIONS\n-  SUBTARGET_OVERRIDE_OPTIONS;\n-#endif\n+  if (opts_set->x_arm_tune_option)\n+    arm_selected_tune = &all_cores[(int) opts->x_arm_tune_option];\n \n   if (arm_selected_arch)\n     {\n+      arm_initialize_isa (target->isa, arm_selected_arch->isa_bits);\n+\n       if (arm_selected_cpu)\n \t{\n-\t  const arm_feature_set tuning_flags = ARM_FSET_MAKE_CPU1 (FL_TUNE);\n-\t  arm_feature_set selected_flags;\n-\t  ARM_FSET_XOR (selected_flags, arm_selected_cpu->flags,\n-\t\t\tarm_selected_arch->flags);\n-\t  ARM_FSET_EXCLUDE (selected_flags, selected_flags, tuning_flags);\n-\t  /* Check for conflict between mcpu and march.  */\n-\t  if (!ARM_FSET_IS_EMPTY (selected_flags))\n+\t  auto_sbitmap cpu_isa (isa_num_bits);\n+\n+\t  arm_initialize_isa (cpu_isa, arm_selected_cpu->isa_bits);\n+\t  bitmap_xor (cpu_isa, cpu_isa, target->isa);\n+\t  /* Ignore (for now) any bits that might be set by -mfpu.  */\n+\t  bitmap_and_compl (cpu_isa, cpu_isa, isa_fpubits);\n+\n+\t  if (!bitmap_empty_p (cpu_isa))\n \t    {\n-\t      warning (0, \"switch -mcpu=%s conflicts with -march=%s switch\",\n-\t\t       arm_selected_cpu->name, arm_selected_arch->name);\n+\t      if (warn_compatible)\n+\t\twarning (0, \"switch -mcpu=%s conflicts with -march=%s switch\",\n+\t\t\t arm_selected_cpu->name, arm_selected_arch->name);\n \t      /* -march wins for code generation.\n-\t         -mcpu wins for default tuning.  */\n+\t\t -mcpu wins for default tuning.  */\n \t      if (!arm_selected_tune)\n \t\tarm_selected_tune = arm_selected_cpu;\n \n \t      arm_selected_cpu = arm_selected_arch;\n \t    }\n \t  else\n-\t    /* -mcpu wins.  */\n-\t    arm_selected_arch = NULL;\n+\t    {\n+\t      /* Architecture and CPU are essentially the same.\n+\t\t Prefer the CPU setting.  */\n+\t      arm_selected_arch = NULL;\n+\t    }\n \t}\n       else\n-\t/* Pick a CPU based on the architecture.  */\n-\tarm_selected_cpu = arm_selected_arch;\n+\t{\n+\t  /* Pick a CPU based on the architecture.  */\n+\t  arm_selected_cpu = arm_selected_arch;\n+\t  target->arch_name = arm_selected_arch->name;\n+\t}\n     }\n \n   /* If the user did not specify a processor, choose one for them.  */\n   if (!arm_selected_cpu)\n     {\n       const struct processors * sel;\n-      arm_feature_set sought = ARM_FSET_EMPTY;;\n+      auto_sbitmap sought_isa (isa_num_bits);\n+      bitmap_clear (sought_isa);\n+      auto_sbitmap default_isa (isa_num_bits);\n \n       arm_selected_cpu = &all_cores[TARGET_CPU_DEFAULT];\n       gcc_assert (arm_selected_cpu->name);\n \n+      /* RWE: All of the selection logic below (to the end of this\n+\t 'if' clause) looks somewhat suspect.  It appears to be mostly\n+\t there to support forcing thumb support when the default CPU\n+\t does not have thumb (somewhat dubious in terms of what the\n+\t user might be expecting).  I think it should be removed once\n+\t support for the pre-thumb era cores is removed.  */\n       sel = arm_selected_cpu;\n-      insn_flags = sel->flags;\n+      arm_initialize_isa (default_isa, sel->isa_bits);\n \n-      /* Now check to see if the user has specified some command line\n-\t switch that require certain abilities from the cpu.  */\n+      /* Now check to see if the user has specified any command line\n+\t switches that require certain abilities from the cpu.  */\n \n       if (TARGET_INTERWORK || TARGET_THUMB)\n \t{\n-\t  ARM_FSET_ADD_CPU1 (sought, FL_THUMB);\n-\t  ARM_FSET_ADD_CPU1 (sought, FL_MODE32);\n+\t  bitmap_set_bit (sought_isa, isa_bit_thumb);\n+\t  bitmap_set_bit (sought_isa, isa_bit_mode32);\n \n \t  /* There are no ARM processors that support both APCS-26 and\n-\t     interworking.  Therefore we force FL_MODE26 to be removed\n-\t     from insn_flags here (if it was set), so that the search\n-\t     below will always be able to find a compatible processor.  */\n-\t  ARM_FSET_DEL_CPU1 (insn_flags, FL_MODE26);\n+\t     interworking.  Therefore we forcibly remove MODE26 from\n+\t     from the isa features here (if it was set), so that the\n+\t     search below will always be able to find a compatible\n+\t     processor.  */\n+\t  bitmap_clear_bit (default_isa, isa_bit_mode26);\n \t}\n \n-      if (!ARM_FSET_IS_EMPTY (sought)\n-\t  && !(ARM_FSET_CPU_SUBSET (sought, insn_flags)))\n+      /* If there are such requirements and the default CPU does not\n+\t satisfy them, we need to run over the complete list of\n+\t cores looking for one that is satisfactory.  */\n+      if (!bitmap_empty_p (sought_isa)\n+\t  && !bitmap_subset_p (sought_isa, default_isa))\n \t{\n+\t  auto_sbitmap candidate_isa (isa_num_bits);\n+\t  /* We're only interested in a CPU with at least the\n+\t     capabilities of the default CPU and the required\n+\t     additional features.  */\n+\t  bitmap_ior (default_isa, default_isa, sought_isa);\n+\n \t  /* Try to locate a CPU type that supports all of the abilities\n \t     of the default CPU, plus the extra abilities requested by\n \t     the user.  */\n \t  for (sel = all_cores; sel->name != NULL; sel++)\n-\t    if (ARM_FSET_CPU_SUBSET (sought, sel->flags))\n-\t      break;\n+\t    {\n+\t      arm_initialize_isa (candidate_isa, sel->isa_bits);\n+\t      /* An exact match?  */\n+\t      if (bitmap_equal_p (default_isa, candidate_isa))\n+\t\tbreak;\n+\t    }\n \n \t  if (sel->name == NULL)\n \t    {\n-\t      unsigned current_bit_count = 0;\n+\t      unsigned current_bit_count = isa_num_bits;\n \t      const struct processors * best_fit = NULL;\n \n \t      /* Ideally we would like to issue an error message here\n@@ -3141,32 +3199,34 @@ arm_option_override (void)\n \t\t ought to use the -mcpu=<name> command line option to\n \t\t override the default CPU type.\n \n-\t\t If we cannot find a cpu that has both the\n-\t\t characteristics of the default cpu and the given\n+\t\t If we cannot find a CPU that has exactly the\n+\t\t characteristics of the default CPU and the given\n \t\t command line options we scan the array again looking\n-\t\t for a best match.  */\n+\t\t for a best match.  The best match must have at least\n+\t\t the capabilities of the perfect match.  */\n \t      for (sel = all_cores; sel->name != NULL; sel++)\n \t\t{\n-\t\t  arm_feature_set required = ARM_FSET_EMPTY;\n-\t\t  ARM_FSET_UNION (required, sought, insn_flags);\n-\t\t  if (ARM_FSET_CPU_SUBSET (required, sel->flags))\n+\t\t  arm_initialize_isa (candidate_isa, sel->isa_bits);\n+\n+\t\t  if (bitmap_subset_p (default_isa, candidate_isa))\n \t\t    {\n \t\t      unsigned count;\n-\t\t      arm_feature_set flags;\n-\t\t      ARM_FSET_INTER (flags, sel->flags, insn_flags);\n-\t\t      count = feature_count (&flags);\n \n-\t\t      if (count >= current_bit_count)\n+\t\t      bitmap_and_compl (candidate_isa, candidate_isa,\n+\t\t\t\t\tdefault_isa);\n+\t\t      count = bitmap_popcount (candidate_isa);\n+\n+\t\t      if (count < current_bit_count)\n \t\t\t{\n \t\t\t  best_fit = sel;\n \t\t\t  current_bit_count = count;\n \t\t\t}\n \t\t    }\n+\n+\t\t  gcc_assert (best_fit);\n+\t\t  sel = best_fit;\n \t\t}\n-\t      gcc_assert (best_fit);\n-\t      sel = best_fit;\n \t    }\n-\n \t  arm_selected_cpu = sel;\n \t}\n     }\n@@ -3176,6 +3236,29 @@ arm_option_override (void)\n   if (!arm_selected_tune)\n     arm_selected_tune = &all_cores[arm_selected_cpu->core];\n \n+  target->arch_pp_name = arm_selected_cpu->arch;\n+  target->tune_flags = arm_selected_tune->tune_flags;\n+  target->tune = arm_selected_tune->tune;\n+}\n+\n+/* Fix up any incompatible options that the user has specified.  */\n+static void\n+arm_option_override (void)\n+{\n+  static const enum isa_feature fpu_bitlist[] = { ISA_ALL_FPU, isa_nobit };\n+\n+  isa_fpubits = sbitmap_alloc (isa_num_bits);\n+  arm_initialize_isa (isa_fpubits, fpu_bitlist);\n+\n+  arm_active_target.isa = sbitmap_alloc (isa_num_bits);\n+\n+  arm_configure_build_target (&arm_active_target, &global_options,\n+\t\t\t      &global_options_set, true);\n+\n+#ifdef SUBTARGET_OVERRIDE_OPTIONS\n+  SUBTARGET_OVERRIDE_OPTIONS;\n+#endif\n+\n   sprintf (arm_arch_name, \"__ARM_ARCH_%s__\", arm_selected_cpu->arch);\n   insn_flags = arm_selected_cpu->flags;\n   arm_base_arch = arm_selected_cpu->base_arch;"}]}