{"sha": "71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFmYzQ2NTVhYjg2YWI2NmI0MDE2NWIyY2I0OWMxMzk1Y2E4MmE5YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-25T00:47:57Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-25T00:47:57Z"}, "message": "analyzer; reset sm-state for SSA names at def-stmts [PR93695,PR99044,PR99716]\n\nVarious false positives from -fanalyzer involve SSA names in loops,\nwhere sm-state associated with an SSA name from one iteration is\nerroneously reused in a subsequent iteration.\n\nFor example, PR analyzer/99716 describes a false\n  \"double 'fclose' of FILE 'fp'\"\non:\n\n  for (i = 0; i < 2; ++i) {\n    FILE *fp = fopen (\"/tmp/test\", \"w\");\n    fprintf (fp, \"hello\");\n    fclose (fp);\n  }\n\nwhere the gimple of the loop body is:\n\n  fp_7 = fopen (\"/tmp/test\", \"w\");\n  __builtin_fwrite (\"hello\", 1, 5, fp_7);\n  fclose (fp_7);\n  i_10 = i_1 + 1;\n\nwhere fp_7 transitions to \"closed\" at the fclose, but is not\nreset at the subsequent fopen, leading to the false positive\nwhen the fclose is re-reached.\n\nThe fix is to reset sm-state for svalues that involve an SSA name\nat the SSA name's def-stmt, since the def-stmt effectively changes\nthe meaning of those related svalues.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/93695\n\tPR analyzer/99044\n\tPR analyzer/99716\n\t* engine.cc (exploded_node::on_stmt): Clear sm-state involving\n\tan SSA name at the def-stmt of that SSA name.\n\t* program-state.cc (sm_state_map::purge_state_involving): New.\n\t* program-state.h (sm_state_map::purge_state_involving): New decl.\n\t* region-model.cc (selftest::test_involves_p): New.\n\t(selftest::analyzer_region_model_cc_tests): Call it.\n\t* svalue.cc (class involvement_visitor): New class\n\t(svalue::involves_p): New.\n\t* svalue.h (svalue::involves_p): New decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/93695\n\tPR analyzer/99044\n\tPR analyzer/99716\n\t* gcc.dg/analyzer/attr-malloc-CVE-2019-19078-usb-leak.c: Remove\n\txfail.\n\t* gcc.dg/analyzer/pr93695-1.c: New test.\n\t* gcc.dg/analyzer/pr99044-1.c: New test.\n\t* gcc.dg/analyzer/pr99044-2.c: New test.\n\t* gcc.dg/analyzer/pr99716-1.c: New test.\n\t* gcc.dg/analyzer/pr99716-2.c: New test.\n\t* gcc.dg/analyzer/pr99716-3.c: New test.", "tree": {"sha": "cd0439f92df03d57f9d79983cdd9b76ead8f09fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd0439f92df03d57f9d79983cdd9b76ead8f09fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf52ffa92f7d1539cbb82fbc0e95389e084ec31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf52ffa92f7d1539cbb82fbc0e95389e084ec31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf52ffa92f7d1539cbb82fbc0e95389e084ec31"}], "stats": {"total": 375, "additions": 372, "deletions": 3}, "files": [{"sha": "d7866b5598b4fcb791ec6ff511dde9b7615e7794", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -1244,6 +1244,31 @@ exploded_node::on_stmt (exploded_graph &eg,\n       sm_state_map *new_smap = state->m_checker_states[sm_idx];\n       impl_sm_context sm_ctxt (eg, sm_idx, sm, this, &old_state, state,\n \t\t\t       old_smap, new_smap);\n+\n+      /* If we're at the def-stmt of an SSA name, then potentially purge\n+\t any sm-state for svalues that involve that SSA name.  This avoids\n+\t false positives in loops, since a symbolic value referring to the\n+\t SSA name will be referring to the previous value of that SSA name.\n+\t For example, in:\n+\t   while ((e = hashmap_iter_next(&iter))) {\n+\t     struct oid2strbuf *e_strbuf = (struct oid2strbuf *)e;\n+\t     free (e_strbuf->value);\n+\t   }\n+\t at the def-stmt of e_8:\n+\t   e_8 = hashmap_iter_next (&iter);\n+\t we should purge the \"freed\" state of:\n+\t   INIT_VAL(CAST_REG(\u2018struct oid2strbuf\u2019, (*INIT_VAL(e_8))).value)\n+\t which is the \"e_strbuf->value\" value from the previous iteration,\n+\t or we will erroneously report a double-free - the \"e_8\" within it\n+\t refers to the previous value.  */\n+      if (tree lhs = gimple_get_lhs (stmt))\n+\tif (TREE_CODE (lhs) == SSA_NAME)\n+\t  {\n+\t    const svalue *sval\n+\t      = old_state.m_region_model->get_rvalue (lhs, &ctxt);\n+\t    new_smap->purge_state_involving (sval, eg.get_ext_state ());\n+\t  }\n+\n       /* Allow the state_machine to handle the stmt.  */\n       if (sm.on_stmt (&sm_ctxt, snode, stmt))\n \tunknown_side_effects = false;"}, {"sha": "fcea5ce436d2a287cde9f34617cb63d6cf422198", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -586,6 +586,36 @@ sm_state_map::on_unknown_change (const svalue *sval,\n     impl_set_state (*iter, (state_machine::state_t)0, NULL, ext_state);\n }\n \n+/* Purge state for things involving SVAL.\n+   For use when SVAL changes meaning, at the def_stmt on an SSA_NAME.   */\n+\n+void\n+sm_state_map::purge_state_involving (const svalue *sval,\n+\t\t\t\t     const extrinsic_state &ext_state)\n+{\n+  /* Currently svalue::involves_p requires this.  */\n+  if (sval->get_kind () != SK_INITIAL)\n+    return;\n+\n+  svalue_set svals_to_unset;\n+\n+  for (map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      const svalue *key = (*iter).first;\n+      entry_t e = (*iter).second;\n+      if (!m_sm.can_purge_p (e.m_state))\n+\tcontinue;\n+      if (key->involves_p (sval))\n+\tsvals_to_unset.add (key);\n+    }\n+\n+  for (svalue_set::iterator iter = svals_to_unset.begin ();\n+       iter != svals_to_unset.end (); ++iter)\n+    impl_set_state (*iter, (state_machine::state_t)0, NULL, ext_state);\n+}\n+\n /* Comparator for imposing an order on sm_state_map instances.  */\n \n int"}, {"sha": "54fdb5b167c0eb1f31da811defffa808412ec609", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -157,6 +157,9 @@ class sm_state_map\n \t\t\t  bool is_mutable,\n \t\t\t  const extrinsic_state &ext_state);\n \n+  void purge_state_involving (const svalue *sval,\n+\t\t\t      const extrinsic_state &ext_state);\n+\n   iterator_t begin () const { return m_map.begin (); }\n   iterator_t end () const { return m_map.end (); }\n   size_t elements () const { return m_map.elements (); }"}, {"sha": "fb5dc39fc66f2e3bbd0552915e2944a5645736bc", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -5114,6 +5114,37 @@ test_alloca ()\n   ASSERT_EQ (model.get_rvalue (p, &ctxt)->get_kind (), SK_POISONED);\n }\n \n+/* Verify that svalue::involves_p works.  */\n+\n+static void\n+test_involves_p ()\n+{\n+  region_model_manager mgr;\n+  tree int_star = build_pointer_type (integer_type_node);\n+  tree p = build_global_decl (\"p\", int_star);\n+  tree q = build_global_decl (\"q\", int_star);\n+\n+  test_region_model_context ctxt;\n+  region_model model (&mgr);\n+  const svalue *p_init = model.get_rvalue (p, &ctxt);\n+  const svalue *q_init = model.get_rvalue (q, &ctxt);\n+\n+  ASSERT_TRUE (p_init->involves_p (p_init));\n+  ASSERT_FALSE (p_init->involves_p (q_init));\n+\n+  const region *star_p_reg = mgr.get_symbolic_region (p_init);\n+  const region *star_q_reg = mgr.get_symbolic_region (q_init);\n+\n+  const svalue *init_star_p = mgr.get_or_create_initial_value (star_p_reg);\n+  const svalue *init_star_q = mgr.get_or_create_initial_value (star_q_reg);\n+\n+  ASSERT_TRUE (init_star_p->involves_p (p_init));\n+  ASSERT_FALSE (p_init->involves_p (init_star_p));\n+  ASSERT_FALSE (init_star_p->involves_p (q_init));\n+  ASSERT_TRUE (init_star_q->involves_p (q_init));\n+  ASSERT_FALSE (init_star_q->involves_p (p_init));\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -5150,6 +5181,7 @@ analyzer_region_model_cc_tests ()\n   test_POINTER_PLUS_EXPR_then_MEM_REF ();\n   test_malloc ();\n   test_alloca ();\n+  test_involves_p ();\n }\n \n } // namespace selftest"}, {"sha": "897e84e8464d9543232a6521399b43056327997c", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -481,6 +481,40 @@ svalue::cmp_ptr_ptr (const void *p1, const void *p2)\n   return cmp_ptr (sval1, sval2);\n }\n \n+/* Subclass of visitor for use in implementing svalue::involves_p.  */\n+\n+class involvement_visitor : public visitor\n+{\n+public:\n+  involvement_visitor (const svalue *needle)\n+  : m_needle (needle), m_found (false) {}\n+\n+  void visit_initial_svalue (const initial_svalue *candidate)\n+  {\n+    if (candidate == m_needle)\n+      m_found = true;\n+  }\n+\n+  bool found_p () const { return m_found; }\n+\n+private:\n+  const svalue *m_needle;\n+  bool m_found;\n+};\n+\n+/* Return true iff this svalue is defined in terms of OTHER.  */\n+\n+bool\n+svalue::involves_p (const svalue *other) const\n+{\n+  /* Currently only implemented for initial_svalue.  */\n+  gcc_assert (other->get_kind () == SK_INITIAL);\n+\n+  involvement_visitor v (other);\n+  accept (&v);\n+  return v.found_p ();\n+}\n+\n /* class region_svalue : public svalue.  */\n \n /* Implementation of svalue::dump_to_pp vfunc for region_svalue.  */"}, {"sha": "7fe0ba3a603ff28f83a0b4d30a77355de0b9e10f", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -136,6 +136,8 @@ class svalue\n   static int cmp_ptr (const svalue *, const svalue *);\n   static int cmp_ptr_ptr (const void *, const void *);\n \n+  bool involves_p (const svalue *other) const;\n+\n  protected:\n   svalue (complexity c, tree type)\n   : m_complexity (c), m_type (type)"}, {"sha": "e086843c42b68852d2a15757f0ff27e253052e3c", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-CVE-2019-19078-usb-leak.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-CVE-2019-19078-usb-leak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-CVE-2019-19078-usb-leak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-CVE-2019-19078-usb-leak.c?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -192,9 +192,7 @@ static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n \t\t\tgoto err_free_urb_to_pipe;\n \t\t}\n \n-\t\t/* TODO: the loop confuses the double-free checker (another\n-\t\t   instance of PR analyzer/93695).  */\n-\t\tusb_free_urb(urb); /* { dg-bogus \"double-'usb_free_urb' of 'urb'\" \"\" { xfail *-*-* } } */\n+\t\tusb_free_urb(urb); /* { dg-bogus \"double-'usb_free_urb' of 'urb'\" } */\n \t}\n \n \treturn 0;"}, {"sha": "e0500c49be727bab0e49564492bd386fb6fd0587", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93695-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93695-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93695-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93695-1.c?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+/* TODO: remove the need for this option (PR analyzer/93695).  */\n+\n+#define NELEMS 10\n+#define ARRAY_SIZE(a) (sizeof (a) / sizeof (a[0]))\n+\n+void\n+test_1 (void)\n+{\n+  int *p[NELEMS];\n+  int i;\n+\n+  for (i = 0; i < ARRAY_SIZE (p); ++i)\n+    p[i] = __builtin_malloc (sizeof (i));\n+\n+  for (i = 0; i < ARRAY_SIZE (p); ++i)\n+    __builtin_free (p [i]);\n+}\n+\n+void\n+test_2 (int n)\n+{\n+  int **p;\n+  int i;\n+\n+  p = (int **)__builtin_malloc (sizeof (int *) * n);\n+  if (!p)\n+    return;\n+\n+  for (i = 0; i < n; ++i)\n+    p[i] = __builtin_malloc (sizeof (i));\n+\n+  for (i = 0; i < n; ++i)\n+    __builtin_free (p [i]);\n+\n+  __builtin_free (p);\n+}\n+\n+void\n+test_3 (int **p, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    p[i] = __builtin_malloc (sizeof (i));\n+}\n+\n+void\n+test_4 (void **p, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    __builtin_free (p[i]);\n+}"}, {"sha": "6b5d9010fd96b4e1768cec67953b826e28322d5b", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99044-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99044-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99044-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99044-1.c?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -0,0 +1,60 @@\n+#include <stdlib.h>\n+\n+struct hashmap_entry {\n+\tstruct hashmap_entry *next;\n+\tunsigned int hash;\n+};\n+\n+struct strbuf {\n+\tsize_t alloc;\n+\tsize_t len;\n+\tchar *buf;\n+};\n+\n+struct oid2strbuf {\n+\tstruct hashmap_entry ent; /* must be the first member! */\n+\tunsigned char key[21];\n+\tstruct strbuf *value;\n+};\n+\n+\n+struct hashmap_iter {\n+\tstruct hashmap *map;\n+\tstruct hashmap_entry *next;\n+\tunsigned int tablepos;\n+};\n+\n+struct hashmap {\n+\tstruct hashmap_entry **table;\n+\t// hashmap_cmp_fn cmpfn;\n+\tunsigned int size, tablesize, grow_at, shrink_at;\n+\tunsigned disallow_rehash : 1;\n+};\n+void strbuf_init(struct strbuf *, size_t);\n+void *hashmap_iter_next(struct hashmap_iter *iter);\n+void hashmap_free(struct hashmap *map, int free_entries);\n+void hashmap_iter_init(struct hashmap *map, struct hashmap_iter *iter);\n+\n+void strbuf_release(struct strbuf *sb)\n+{\n+\tif (sb->alloc) {  /* { dg-bogus \"use after 'free'\" } */\n+\t\tfree(sb->buf);\n+\t\tstrbuf_init(sb, 0);\n+\t}\n+}\n+\n+void oid2strbuf_free(struct hashmap *map) {\n+\tstruct hashmap_iter iter;\n+\tstruct hashmap_entry *e;\n+\n+\thashmap_iter_init(map, &iter);\n+\twhile ((e = hashmap_iter_next(&iter))) {\n+\t\tstruct oid2strbuf *e_strbuf = (struct oid2strbuf *)e;\n+\t\tstrbuf_release(e_strbuf->value); /* { dg-bogus \"use after 'free'\" } */\n+\t\tfree(e_strbuf->value);\n+\t\tfree(e);\n+\t}\n+\n+\thashmap_free(map, 0);\n+}\n+"}, {"sha": "fd71d35d7e4e7828408d31e1bf02f450b440077d", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99044-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99044-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99044-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99044-2.c?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -0,0 +1,42 @@\n+struct node\n+{\n+  struct node *next;\n+};\n+\n+void test_1 (struct node *n)\n+{\n+  while (n)\n+    {\n+      struct node *next = n->next;\n+      __builtin_free (n);\n+      n = next;\n+    }\n+}\n+\n+extern void *get_ptr (void);\n+\n+void test_2 (void)\n+{\n+  void *p;\n+  while (p = get_ptr ())\n+    __builtin_free (p); /* { dg-bogus \"double-'free' of 'p'\" } */\n+}\n+\n+extern void **get_ptr_ptr (void);\n+\n+void test_3 (void)\n+{\n+  void **p;\n+  while (p = get_ptr_ptr ())\n+    __builtin_free (*p); /* { dg-bogus \"double-'free'\" } */\n+}\n+\n+void test_4 (void)\n+{\n+  void *p = (void *)0;\n+  while (1)\n+    {\n+      __builtin_free (p); /* { dg-bogus \"double-'free' of 'p'\" } */\n+      p = get_ptr ();\n+    }\n+}"}, {"sha": "6720c3c198b9eb07e8f4cdf524b4b1e883587f2f", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99716-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-1.c?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -0,0 +1,40 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+void\n+test_1 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 2; ++i) {\n+    FILE *fp = fopen (\"/tmp/test\", \"w\");\n+    fprintf (fp, \"hello:%s \", \"world\");\n+    fclose (fp); /* { dg-bogus \"double 'fclose'\" } */\n+  }\n+}\n+\n+void\n+test_2 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 2; ++i) {\n+    FILE *fp = fopen (\"/tmp/test\", \"w\");\n+    fprintf (fp, \"hello\");\n+  }\n+} /* { dg-warning \"leak of FILE 'fp'\" } */\n+\n+FILE *fp3;\n+\n+void\n+test_3 (FILE **fpp)\n+{\n+  int i;\n+\n+  for (i = 0; i < 2; ++i) {\n+    *fpp = fopen (\"/tmp/test\", \"w\");\n+    fprintf (*fpp, \"hello\");\n+    fclose (*fpp); /* { dg-bogus \"double 'fclose'\" } */\n+    *fpp = NULL;\n+  }\n+}"}, {"sha": "7c9881c61ff9df1de6f708f75ff2d4382a5cf384", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99716-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-2.c?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -0,0 +1,34 @@\n+/* Reduced from\n+   https://github.com/libguestfs/libguestfs/blob/e0a11061035d47b118c95706240bcc17fd576edc/tests/mount-local/test-parallel-mount-local.c#L299-L335\n+   which is GPLv2 or later.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+extern int foo (void);\n+\n+void\n+test_mountpoint (const char *mp)\n+{\n+  const int nr_passes = 5 + (random () & 31);\n+  int pass;\n+  int ret = 1;\n+  FILE *fp;\n+\n+  for (pass = 0; pass < nr_passes; ++pass) {\n+    if (foo ()) {\n+      goto error;\n+    }\n+    fp = fopen (\"file\", \"w\");\n+    if (fp == NULL) {\n+      goto error;\n+    }\n+    fprintf (fp, \"hello world\\n\");\n+    fclose (fp); /* { dg-bogus \"double 'fclose'\" } */\n+  }\n+\n+  ret = 0;\n+\n+ error:\n+  exit (ret);\n+}"}, {"sha": "77d450ea3be0d3b69e52dddfaaf51fa869214c55", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99716-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fc4655ab86ab66b40165b2cb49c1395ca82a9a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99716-3.c?ref=71fc4655ab86ab66b40165b2cb49c1395ca82a9a", "patch": "@@ -0,0 +1,16 @@\n+#include <stdlib.h>\n+\n+extern void foo (void *);\n+\n+void\n+test_1 (int nr_passes)\n+{\n+  int pass;\n+  void *p;\n+\n+  for (pass = 0; pass < nr_passes; ++pass) {\n+    p = malloc (1024);\n+    foo (p);\n+    free (p);\n+  }\n+}"}]}