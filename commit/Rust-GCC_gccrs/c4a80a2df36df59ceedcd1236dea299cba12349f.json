{"sha": "c4a80a2df36df59ceedcd1236dea299cba12349f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRhODBhMmRmMzZkZjU5Y2VlZGNkMTIzNmRlYTI5OWNiYTEyMzQ5Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-09-20T12:04:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-09-20T12:04:21Z"}, "message": "dwarf2out.c (add_const_value_attribute): Return true if successful.\n\n\t* dwarf2out.c (add_const_value_attribute): Return true if successful.\n\t(add_location_or_const_value_attribute): Rewrite using loc_list_from_tree.\n\t(tree_add_const_value_attribute): Return true if successful.\n\t(tree_add_const_value_attribute_for_decl): Likewise.\n\n\t* dwarf2out.c (address_of_int_loc_descriptor): Break out from ...\n\t(loc_descriptor): ... here;\n\t(loc_list_for_address_of_addr_expr_of_indirect_ref): New function.\n\t(cst_pool_loc_descr): Break out from ...; do not reffer constant\n\tpool items that was not marked for output.\n\t(loc_list_from_tree): ... here; handle special cases of ADDR_EXPR;\n\t(loc_list_for_address_of_addr_expr_of_indirect_ref): New function.\n\t(loc_list_for_address_of_addr_expr_of_indirect_ref): New function.\n\thandle ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF, REALPART_EXPR,\n\tIMAGPART_EXPR; handle address of INTEGER_CST; improve handling of\n\tCONSTRUCTOR; handle REAL_CST, STRING_CST, COMPLEX_CST; use\n\tDW_OP_stack_value to get address of items that are not available\n\tas addresses.\n\t(dw_loc_list): Handle single element lists correctly.\n\nFrom-SVN: r151901", "tree": {"sha": "55ab5f5feb7fa46dc52c03bf3c1614a6ac8f40b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55ab5f5feb7fa46dc52c03bf3c1614a6ac8f40b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4a80a2df36df59ceedcd1236dea299cba12349f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4a80a2df36df59ceedcd1236dea299cba12349f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4a80a2df36df59ceedcd1236dea299cba12349f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4a80a2df36df59ceedcd1236dea299cba12349f/comments", "author": null, "committer": null, "parents": [{"sha": "0b1d7060b5971207d0cb09d58ca363c943805768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b1d7060b5971207d0cb09d58ca363c943805768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b1d7060b5971207d0cb09d58ca363c943805768"}], "stats": {"total": 543, "additions": 317, "deletions": 226}, "files": [{"sha": "bb7dc70f2831801c4920ce8839e6bf8ec4a4eafa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4a80a2df36df59ceedcd1236dea299cba12349f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4a80a2df36df59ceedcd1236dea299cba12349f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4a80a2df36df59ceedcd1236dea299cba12349f", "patch": "@@ -1,3 +1,25 @@\n+2009-09-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* dwarf2out.c (add_const_value_attribute): Return true if successful.\n+\t(add_location_or_const_value_attribute): Rewrite using loc_list_from_tree.\n+\t(tree_add_const_value_attribute): Return true if successful.\n+\t(tree_add_const_value_attribute_for_decl): Likewise.\n+\n+\t* dwarf2out.c (address_of_int_loc_descriptor): Break out from ...\n+\t(loc_descriptor): ... here;\n+\t(loc_list_for_address_of_addr_expr_of_indirect_ref): New function.\n+\t(cst_pool_loc_descr): Break out from ...; do not reffer constant\n+\tpool items that was not marked for output.\n+\t(loc_list_from_tree): ... here; handle special cases of ADDR_EXPR;\n+\t(loc_list_for_address_of_addr_expr_of_indirect_ref): New function.\n+\t(loc_list_for_address_of_addr_expr_of_indirect_ref): New function.\n+\thandle ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF, REALPART_EXPR,\n+\tIMAGPART_EXPR; handle address of INTEGER_CST; improve handling of\n+\tCONSTRUCTOR; handle REAL_CST, STRING_CST, COMPLEX_CST; use\n+\tDW_OP_stack_value to get address of items that are not available\n+\tas addresses.\n+\t(dw_loc_list): Handle single element lists correctly.\n+\n 2009-09-20  Kai Tietz  <kai.tietz@onevision.com>\n \t    Pascal Obry  <obry@adacore.com>\n "}, {"sha": "19eabacfde98cc81a41c6dc8750bc2e489f51091", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 295, "deletions": 226, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4a80a2df36df59ceedcd1236dea299cba12349f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4a80a2df36df59ceedcd1236dea299cba12349f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c4a80a2df36df59ceedcd1236dea299cba12349f", "patch": "@@ -5961,14 +5961,14 @@ static HOST_WIDE_INT field_byte_offset (const_tree);\n static void add_AT_location_description\t(dw_die_ref, enum dwarf_attribute,\n \t\t\t\t\t dw_loc_list_ref);\n static void add_data_member_location_attribute (dw_die_ref, tree);\n-static void add_const_value_attribute (dw_die_ref, rtx);\n+static bool add_const_value_attribute (dw_die_ref, rtx);\n static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n static void insert_float (const_rtx, unsigned char *);\n static rtx rtl_for_decl_location (tree);\n-static void add_location_or_const_value_attribute (dw_die_ref, tree,\n+static bool add_location_or_const_value_attribute (dw_die_ref, tree,\n \t\t\t\t\t\t   enum dwarf_attribute);\n-static void tree_add_const_value_attribute (dw_die_ref, tree);\n-static void tree_add_const_value_attribute_for_decl (dw_die_ref, tree);\n+static bool tree_add_const_value_attribute (dw_die_ref, tree);\n+static bool tree_add_const_value_attribute_for_decl (dw_die_ref, tree);\n static void add_name_attribute (dw_die_ref, const char *);\n static void add_comp_dir_attribute (dw_die_ref);\n static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);\n@@ -10882,6 +10882,64 @@ int_loc_descriptor (HOST_WIDE_INT i)\n \n   return new_loc_descr (op, i, 0);\n }\n+\n+/* Return loc description representing \"address\" of integer value.\n+   This can appear only as toplevel expression.  */\n+\n+static dw_loc_descr_ref\n+address_of_int_loc_descriptor (int size, HOST_WIDE_INT i)\n+{\n+  int litsize;\n+  dw_loc_descr_ref loc_result = NULL;\n+\n+  if (i >= 0)\n+    {\n+      if (i <= 31)\n+\tlitsize = 1;\n+      else if (i <= 0xff)\n+\tlitsize = 2;\n+      else if (i <= 0xffff)\n+\tlitsize = 3;\n+      else if (HOST_BITS_PER_WIDE_INT == 32\n+\t       || i <= 0xffffffff)\n+\tlitsize = 5;\n+      else\n+\tlitsize = 1 + size_of_uleb128 ((unsigned HOST_WIDE_INT) i);\n+    }\n+  else\n+    {\n+      if (i >= -0x80)\n+\tlitsize = 2;\n+      else if (i >= -0x8000)\n+\tlitsize = 3;\n+      else if (HOST_BITS_PER_WIDE_INT == 32\n+\t       || i >= -0x80000000)\n+\tlitsize = 5;\n+      else\n+\tlitsize = 1 + size_of_sleb128 (i);\n+    }\n+  /* Determine if DW_OP_stack_value or DW_OP_implicit_value\n+     is more compact.  For DW_OP_stack_value we need:\n+     litsize + 1 (DW_OP_stack_value) + 1 (DW_OP_bit_size)\n+     + 1 (mode size)\n+     and for DW_OP_implicit_value:\n+     1 (DW_OP_implicit_value) + 1 (length) + mode_size.  */\n+  if (DWARF2_ADDR_SIZE >= size\n+      && litsize + 1 + 1 + 1 < 1 + 1 + size)\n+    {\n+      loc_result = int_loc_descriptor (i);\n+      add_loc_descr (&loc_result,\n+\t\t     new_loc_descr (DW_OP_stack_value, 0, 0));\n+      add_loc_descr_op_piece (&loc_result, size);\n+      return loc_result;\n+    }\n+\n+  loc_result = new_loc_descr (DW_OP_implicit_value,\n+\t\t\t      size, 0);\n+  loc_result->dw_loc_oprnd2.val_class = dw_val_class_const;\n+  loc_result->dw_loc_oprnd2.v.val_int = i;\n+  return loc_result;\n+}\n #endif\n \n #ifdef DWARF2_DEBUGGING_INFO\n@@ -11778,56 +11836,8 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \n     case CONST_INT:\n       if (mode != VOIDmode && mode != BLKmode)\n-        {\n-          HOST_WIDE_INT i = INTVAL (rtl);\n-          int litsize;\n-          if (i >= 0)\n-            {\n-              if (i <= 31)\n-\t\tlitsize = 1;\n-\t      else if (i <= 0xff)\n-\t\tlitsize = 2;\n-\t      else if (i <= 0xffff)\n-\t\tlitsize = 3;\n-\t      else if (HOST_BITS_PER_WIDE_INT == 32\n-\t\t       || i <= 0xffffffff)\n-\t\tlitsize = 5;\n-\t      else\n-\t\tlitsize = 1 + size_of_uleb128 ((unsigned HOST_WIDE_INT) i);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (i >= -0x80)\n-\t\tlitsize = 2;\n-\t      else if (i >= -0x8000)\n-\t\tlitsize = 3;\n-\t      else if (HOST_BITS_PER_WIDE_INT == 32\n-\t\t       || i >= -0x80000000)\n-\t\tlitsize = 5;\n-\t      else\n-\t\tlitsize = 1 + size_of_sleb128 (i);\n-\t    }\n-\t  /* Determine if DW_OP_stack_value or DW_OP_implicit_value\n-\t     is more compact.  For DW_OP_stack_value we need:\n-\t     litsize + 1 (DW_OP_stack_value) + 1 (DW_OP_bit_size)\n-\t     + 1 (mode size)\n-\t     and for DW_OP_implicit_value:\n-\t     1 (DW_OP_implicit_value) + 1 (length) + mode_size.  */\n-\t  if (DWARF2_ADDR_SIZE >= GET_MODE_SIZE (mode)\n-\t      && litsize + 1 + 1 + 1 < 1 + 1 + GET_MODE_SIZE (mode))\n-\t    {\n-\t      loc_result = int_loc_descriptor (i);\n-\t      add_loc_descr (&loc_result,\n-\t\t\t     new_loc_descr (DW_OP_stack_value, 0, 0));\n-\t      add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n-\t      return loc_result;\n-\t    }\n-\n-\t  loc_result = new_loc_descr (DW_OP_implicit_value,\n-\t\t\t\t      GET_MODE_SIZE (mode), 0);\n-\t  loc_result->dw_loc_oprnd2.val_class = dw_val_class_const;\n-\t  loc_result->dw_loc_oprnd2.v.val_int = i;\n-\t}\n+\tloc_result = address_of_int_loc_descriptor (GET_MODE_SIZE (mode),\n+\t\t\t\t\t\t    INTVAL (rtl));\n       break;\n \n     case CONST_DOUBLE:\n@@ -12071,6 +12081,14 @@ loc_by_reference (dw_loc_descr_ref loc, tree decl)\n   return loc;\n }\n \n+/* Return single element location list containing loc descr REF.  */\n+\n+static dw_loc_list_ref\n+single_element_loc_list (dw_loc_descr_ref ref)\n+{\n+  return new_loc_list (ref, NULL, NULL, NULL, 0);\n+}\n+\n /* Return dwarf representation of location list representing for\n    LOC_LIST of DECL.  */\n \n@@ -12122,15 +12140,10 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n   else\n     descr = loc_descriptor (varloc, DECL_MODE (decl), initialized);\n \n-  if (!current_function_decl)\n-    endname = text_end_label;\n+  if (loc_list && loc_list->first != loc_list->last)\n+    list = new_loc_list (descr, node->label, node->next->label, secname, 1);\n   else\n-    {\n-      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n-\t\t\t\t   current_function_funcdef_no);\n-      endname = ggc_strdup (label_id);\n-    }\n-  list = new_loc_list (descr, node->label, node->next ? node->next->label : endname, secname, 1);\n+    return single_element_loc_list (descr);\n   node = node->next;\n \n   if (!node)\n@@ -12168,6 +12181,15 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n       enum var_init_status initialized =\n \tNOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n \n+      if (!current_function_decl)\n+\tendname = text_end_label;\n+      else\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t       current_function_funcdef_no);\n+\t  endname = ggc_strdup (label_id);\n+\t}\n+\n       varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n       if (!toplevel || by_reference)\n \t{\n@@ -12187,14 +12209,6 @@ dw_loc_list (var_loc_list * loc_list, tree decl, bool toplevel)\n   return list;\n }\n \n-/* Return single element location list containing loc descr REF.  */\n-\n-static dw_loc_list_ref\n-single_element_loc_list (dw_loc_descr_ref ref)\n-{\n-  return new_loc_list (ref, NULL, NULL, NULL, 0);\n-}\n-\n /* Return if the loc_list has only single element and thus can be represented\n    as location description.   */\n \n@@ -12267,6 +12281,105 @@ add_loc_list (dw_loc_list_ref *ret, dw_loc_list_ref list)\n   return;\n }\n \n+/* LOC is constant expression.  Try a luck, look it up in constant\n+   pool and return its loc_descr of its address.  */\n+\n+static dw_loc_descr_ref\n+cst_pool_loc_descr (tree loc)\n+{\n+  /* Get an RTL for this, if something has been emitted.  */\n+  rtx rtl = lookup_constant_def (loc);\n+  enum machine_mode mode;\n+\n+  if (!rtl || !MEM_P (rtl))\n+    {\n+      gcc_assert (!rtl);\n+      return 0;\n+    }\n+  gcc_assert (GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF);\n+\n+  /* TODO: We might get more coverage if we was actually delaying expansion\n+     of all expressions till end of compilation when constant pools are fully\n+     populated.  */\n+  if (!TREE_ASM_WRITTEN (SYMBOL_REF_DECL (XEXP (rtl, 0))))\n+    {\n+      expansion_failed (loc, NULL_RTX,\n+\t\t\t\"CST value in contant pool but not marked.\");\n+      return 0;\n+    }\n+  mode = GET_MODE (rtl);\n+  rtl = XEXP (rtl, 0);\n+  return mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n+}\n+\n+/* Return dw_loc_list representing address of addr_expr LOC\n+   by looking for innder INDIRECT_REF expression and turing it\n+   into simple arithmetics.  */\n+\n+static dw_loc_list_ref\n+loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev)\n+{\n+  tree obj, offset;\n+  HOST_WIDE_INT bitsize, bitpos, bytepos;\n+  enum machine_mode mode;\n+  int volatilep;\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));\n+  dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n+\n+  obj = get_inner_reference (TREE_OPERAND (loc, 0),\n+\t\t\t     &bitsize, &bitpos, &offset, &mode,\n+\t\t\t     &unsignedp, &volatilep, false);\n+  STRIP_NOPS (obj);\n+  if (bitpos % BITS_PER_UNIT)\n+    {\n+      expansion_failed (loc, NULL_RTX, \"bitfield access\");\n+      return 0;\n+    }\n+  if (!INDIRECT_REF_P (obj))\n+    {\n+      expansion_failed (obj,\n+\t\t\tNULL_RTX, \"no indirect ref in inner refrence\");\n+      return 0;\n+    }\n+  if (!offset && !bitpos)\n+    list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), toplev ? 2 : 1);\n+  else if (toplev\n+\t   && int_size_in_bytes (TREE_TYPE (loc)) <= DWARF2_ADDR_SIZE)\n+    {\n+      list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), 0);\n+      if (!list_ret)\n+\treturn 0;\n+      if (offset)\n+\t{\n+\t  /* Variable offset.  */\n+\t  list_ret1 = loc_list_from_tree (offset, 0);\n+\t  if (list_ret1 == 0)\n+\t    return 0;\n+\t  add_loc_list (&list_ret, list_ret1);\n+\t  if (!list_ret)\n+\t    return 0;\n+\t  add_loc_descr_to_each (list_ret,\n+\t\t\t\t new_loc_descr (DW_OP_plus, 0, 0));\n+\t}\n+      bytepos = bitpos / BITS_PER_UNIT;\n+      if (bytepos > 0)\n+\tadd_loc_descr_to_each (list_ret,\n+\t\t\t       new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t      bytepos, 0));\n+      else if (bytepos < 0)\n+\tloc_list_plus_const (list_ret, bytepos);\n+      add_loc_descr_to_each (list_ret,\n+\t\t\t     new_loc_descr (DW_OP_stack_value, 0, 0));\n+      add_loc_descr_to_each (list_ret,\n+\t\t\t     new_loc_descr (DW_OP_piece,\n+\t\t\t\t\t    int_size_in_bytes (TREE_TYPE\n+\t\t\t\t\t\t\t       (loc)),\n+\t\t\t\t\t    0));\n+    }\n+  return list_ret;\n+}\n+\n+\n /* Generate Dwarf location list representing LOC.\n    If WANT_ADDRESS is false, expression computing LOC will be computed\n    If WANT_ADDRESS is 1, expression computing address of LOC will be returned\n@@ -12318,15 +12431,28 @@ loc_list_from_tree (tree loc, int want_address)\n       return 0;\n \n     case ADDR_EXPR:\n-      /* If we already want an address, there's nothing we can do.  */\n+      /* If we already want an address, see if there is INDIRECT_REF inside\n+         e.g. for &this->field.  */\n       if (want_address)\n \t{\n-\t  expansion_failed (loc, NULL_RTX, \"need address of ADDR_EXPR\");\n-\t  return 0;\n+\t  list_ret = loc_list_for_address_of_addr_expr_of_indirect_ref\n+\t\t       (loc, want_address == 2);\n+\t  if (list_ret)\n+\t    have_address = 1;\n+\t  else if (decl_address_ip_invariant_p (TREE_OPERAND (loc, 0))\n+\t  \t   && (ret = cst_pool_loc_descr (loc)))\n+\t    have_address = 1;\n \t}\n-\n-      /* Otherwise, process the argument and look for the address.  */\n-      return loc_list_from_tree (TREE_OPERAND (loc, 0), 1);\n+        /* Otherwise, process the argument and look for the address.  */\n+      if (!list_ret && !ret)\n+        list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 1);\n+      else\n+\t{\n+\t  if (want_address)\n+\t    expansion_failed (loc, NULL_RTX, \"need address of ADDR_EXPR\");\n+\t  return NULL;\n+\t}\n+      break;\n \n     case VAR_DECL:\n       if (DECL_THREAD_LOCAL_P (loc))\n@@ -12387,7 +12513,7 @@ loc_list_from_tree (tree loc, int want_address)\n     case PARM_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (loc))\n \treturn loc_list_from_tree (DECL_VALUE_EXPR (loc),\n-\t\t\t\t\t      want_address);\n+\t\t\t\t   want_address);\n       /* FALLTHRU */\n \n     case RESULT_DECL:\n@@ -12451,6 +12577,8 @@ loc_list_from_tree (tree loc, int want_address)\n       break;\n \n     case INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n       list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n       have_address = 1;\n       break;\n@@ -12468,6 +12596,8 @@ loc_list_from_tree (tree loc, int want_address)\n     case BIT_FIELD_REF:\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n       {\n \ttree obj, offset;\n \tHOST_WIDE_INT bitsize, bitpos, bytepos;\n@@ -12480,7 +12610,11 @@ loc_list_from_tree (tree loc, int want_address)\n \n \tgcc_assert (obj != loc);\n \n-\tlist_ret = loc_list_from_tree (obj, 1);\n+\tlist_ret = loc_list_from_tree (obj,\n+\t\t\t\t       want_address == 2\n+\t\t\t\t       && !bitpos && !offset ? 2 : 1);\n+\t/* TODO: We can extract value of the small expression via shifting even\n+\t   for nonzero bitpos.  */\n \tif (list_ret == 0)\n \t  return 0;\n \tif (bitpos % BITS_PER_UNIT != 0 || bitsize % BITS_PER_UNIT != 0)\n@@ -12513,7 +12647,16 @@ loc_list_from_tree (tree loc, int want_address)\n       }\n \n     case INTEGER_CST:\n-      if (host_integerp (loc, 0))\n+      if ((want_address || !host_integerp (loc, 0))\n+\t  && (ret = cst_pool_loc_descr (loc)))\n+\thave_address = 1;\n+      else if (want_address == 2\n+\t       && host_integerp (loc, 0)\n+\t       && (ret = address_of_int_loc_descriptor\n+\t       \t\t   (int_size_in_bytes (TREE_TYPE (loc)),\n+\t       \t\t    tree_low_cst (loc, 0))))\n+\thave_address = 1;\n+      else if (host_integerp (loc, 0))\n \tret = int_loc_descriptor (tree_low_cst (loc, 0));\n       else\n \t{\n@@ -12524,19 +12667,16 @@ loc_list_from_tree (tree loc, int want_address)\n       break;\n \n     case CONSTRUCTOR:\n-      {\n-\t/* Get an RTL for this, if something has been emitted.  */\n-\trtx rtl = lookup_constant_def (loc);\n-\tenum machine_mode mode;\n-\n-\tif (!rtl || !MEM_P (rtl))\n-\t  return 0;\n-\tmode = GET_MODE (rtl);\n-\trtl = XEXP (rtl, 0);\n-\tret = mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n+    case REAL_CST:\n+    case STRING_CST:\n+    case COMPLEX_CST:\n+      if ((ret = cst_pool_loc_descr (loc)))\n \thave_address = 1;\n-\tbreak;\n-      }\n+      else\n+      /* We can construct small constants here using int_loc_descriptor.  */\n+\texpansion_failed (loc, NULL_RTX,\n+\t\t\t  \"constructor or constant not in constant pool\");\n+      break;\n \n     case TRUTH_AND_EXPR:\n     case TRUTH_ANDIF_EXPR:\n@@ -12743,6 +12883,23 @@ loc_list_from_tree (tree loc, int want_address)\n   if (!ret && !list_ret)\n     return 0;\n \n+  if (want_address == 2 && !have_address)\n+    {\n+      if (int_size_in_bytes (TREE_TYPE (loc)) > DWARF2_ADDR_SIZE)\n+\t{\n+\t  expansion_failed (loc, NULL_RTX,\n+\t\t\t    \"DWARF address size mismatch\");\n+\t  return 0;\n+\t}\n+      add_loc_descr_to_each (list_ret,\n+\t\t\t     new_loc_descr (DW_OP_stack_value, 0, 0));\n+      add_loc_descr_to_each (list_ret,\n+\t\t\t     new_loc_descr (DW_OP_piece,\n+\t\t\t\t\t    int_size_in_bytes (TREE_TYPE\n+\t\t\t\t\t\t\t       (loc)),\n+\t\t\t\t\t    0));\n+      have_address = 1;\n+    }\n   /* Show if we can't fill the request for an address.  */\n   if (want_address && !have_address)\n     {\n@@ -13170,7 +13327,7 @@ insert_float (const_rtx rtl, unsigned char *array)\n    to an inlined function.  They can also arise in C++ where declared\n    constants do not necessarily get memory \"homes\".  */\n \n-static void\n+static bool\n add_const_value_attribute (dw_die_ref die, rtx rtl)\n {\n   switch (GET_CODE (rtl))\n@@ -13184,7 +13341,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \telse\n \t  add_AT_unsigned (die, DW_AT_const_value, (unsigned HOST_WIDE_INT) val);\n       }\n-      break;\n+      return true;\n \n     case CONST_DOUBLE:\n       /* Note that a CONST_DOUBLE rtx could represent either an integer or a\n@@ -13205,7 +13362,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \telse\n \t  add_AT_long_long (die, DW_AT_const_value, rtl);\n       }\n-      break;\n+      return true;\n \n     case CONST_VECTOR:\n       {\n@@ -13273,27 +13430,27 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \n \tadd_AT_vec (die, DW_AT_const_value, length, elt_size, array);\n       }\n-      break;\n+      return true;\n \n     case CONST_STRING:\n       add_AT_string (die, DW_AT_const_value, XSTR (rtl, 0));\n-      break;\n+      return true;\n \n     case CONST:\n       if (CONSTANT_P (XEXP (rtl, 0)))\n \t{\n \t  add_const_value_attribute (die, XEXP (rtl, 0));\n-\t  return;\n+\t  return true;\n \t}\n       /* FALLTHROUGH */\n     case SYMBOL_REF:\n       if (GET_CODE (rtl) == SYMBOL_REF\n \t  && SYMBOL_REF_TLS_MODEL (rtl) != TLS_MODEL_NONE)\n-\tbreak;\n+\treturn false;\n     case LABEL_REF:\n       add_AT_addr (die, DW_AT_const_value, rtl);\n       VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n-      break;\n+      return true;\n \n     case PLUS:\n       /* In cases where an inlined instance of an inline function is passed\n@@ -13307,13 +13464,13 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \t *value* which the artificial local variable always has during its\n \t lifetime.  We currently have no way to represent such quasi-constant\n \t values in Dwarf, so for now we just punt and generate nothing.  */\n-      break;\n+      return false;\n \n     default:\n       /* No other kinds of rtx should be possible here.  */\n       gcc_unreachable ();\n     }\n-\n+  return false;\n }\n \n /* Determine whether the evaluation of EXPR references any variables\n@@ -13706,151 +13863,56 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n    pointer.  This can happen for example if an actual argument in an inlined\n    function call evaluates to a compile-time constant address.  */\n \n-static void\n+static bool\n add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t\t\t\t       enum dwarf_attribute attr)\n {\n   rtx rtl;\n-  dw_loc_descr_ref descr;\n-  dw_loc_list_ref descr_list;\n+  dw_loc_list_ref list;\n   var_loc_list *loc_list;\n-  struct var_loc_node *node;\n+\n   if (TREE_CODE (decl) == ERROR_MARK)\n-    return;\n+    return false;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL);\n \n-  /* See if we possibly have multiple locations for this variable.  */\n-  loc_list = lookup_decl_loc (decl);\n-\n-  /* If it truly has multiple locations, the first and last node will\n-     differ.  */\n-  if (loc_list && loc_list->first != loc_list->last)\n-    {\n-      const char *endname, *secname;\n-      dw_loc_list_ref list;\n-      rtx varloc;\n-      enum var_init_status initialized;\n-\n-      /* Now that we know what section we are using for a base,\n-\t actually construct the list of locations.\n-\t The first location information is what is passed to the\n-\t function that creates the location list, and the remaining\n-\t locations just get added on to that list.\n-\t Note that we only know the start address for a location\n-\t (IE location changes), so to build the range, we use\n-\t the range [current location start, next location start].\n-\t This means we have to special case the last node, and generate\n-\t a range of [last location start, end of function label].  */\n-\n-      node = loc_list->first;\n-      varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-      secname = secname_for_decl (decl);\n-\n-      if (NOTE_VAR_LOCATION_LOC (node->var_loc_note))\n-\tinitialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-      else\n-\tinitialized = VAR_INIT_STATUS_INITIALIZED;\n-\n-      descr = loc_by_reference (loc_descriptor (varloc, DECL_MODE (decl),\n-\t\t\t\t\t\tinitialized), decl);\n-      list = new_loc_list (descr, node->label, node->next->label, secname, 1);\n-      node = node->next;\n-\n-      for (; node->next; node = node->next)\n-\tif (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n-\t  {\n-\t    /* The variable has a location between NODE->LABEL and\n-\t       NODE->NEXT->LABEL.  */\n-\t    enum var_init_status initialized =\n-\t      NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-\t    varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-\t    descr = loc_by_reference (loc_descriptor (varloc, DECL_MODE (decl),\n-\t\t\t\t      initialized), decl);\n-\t    add_loc_descr_to_loc_list (&list, descr,\n-\t\t\t\t       node->label, node->next->label, secname);\n-\t  }\n-\n-      /* If the variable has a location at the last label\n-\t it keeps its location until the end of function.  */\n-      if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n-\t{\n-\t  char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n-\t  enum var_init_status initialized =\n-\t    NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-\n-\t  varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-\t  if (!current_function_decl)\n-\t    endname = text_end_label;\n-\t  else\n-\t    {\n-\t      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n-\t\t\t\t\t   current_function_funcdef_no);\n-\t      endname = ggc_strdup (label_id);\n-\t    }\n-\t  descr = loc_by_reference (loc_descriptor (varloc,\n-\t\t\t\t\t\t    DECL_MODE (decl),\n-\t\t\t\t\t\t    initialized),\n-\t\t\t\t    decl);\n-\t  add_loc_descr_to_loc_list (&list, descr,\n-\t\t\t\t     node->label, endname, secname);\n-\t}\n-\n-      /* Finally, add the location list to the DIE, and we are done.  */\n-      add_AT_loc_list (die, attr, list);\n-      return;\n-    }\n-\n   /* Try to get some constant RTL for this decl, and use that as the value of\n      the location.  */\n \n   rtl = rtl_for_decl_location (decl);\n-  if (rtl && (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING))\n-    {\n-      add_const_value_attribute (die, rtl);\n-      return;\n-    }\n+  if (rtl && (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n+      && add_const_value_attribute (die, rtl))\n+    return true;\n \n-  /* If we have tried to generate the location otherwise, and it\n-     didn't work out (we wouldn't be here if we did), and we have a one entry\n-     location list, try generating a location from that.  */\n-  if (loc_list && loc_list->first)\n+  /* See if we have single element location list that is equivalent to\n+     a constant value.  That way we are better to use add_const_value_attribute\n+     rather than expanding constant value equivalent.  */\n+  loc_list = lookup_decl_loc (decl);\n+  if (loc_list && loc_list->first && loc_list->first == loc_list->last)\n     {\n       enum var_init_status status;\n+      struct var_loc_node *node;\n+\n       node = loc_list->first;\n       status = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n       rtl = NOTE_VAR_LOCATION (node->var_loc_note);\n       if (GET_CODE (rtl) == VAR_LOCATION\n \t  && GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n \trtl = XEXP (XEXP (rtl, 1), 0);\n-      if (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n-\t{\n-\t  add_const_value_attribute (die, rtl);\n-\t  return;\n-\t}\n-      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note),\n-\t\t\t      DECL_MODE (decl), status);\n-      if (descr)\n-\t{\n-\t  descr = loc_by_reference (descr, decl);\n-\t  add_AT_location_description (die, attr, single_element_loc_list (descr));\n-\t  return;\n-\t}\n+      if ((CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n+\t  && add_const_value_attribute (die, rtl))\n+\t return true;\n     }\n-\n-  /* We couldn't get any rtl, so try directly generating the location\n-     description from the tree.  */\n-  descr_list = loc_list_from_tree (decl, 2);\n-  if (descr_list)\n+  list = loc_list_from_tree (decl, 2);\n+  if (list)\n     {\n-      descr = loc_by_reference (descr, decl);\n-      add_AT_location_description (die, attr, descr_list);\n-      return;\n+      add_AT_location_description (die, attr, list);\n+      return true;\n     }\n   /* None of that worked, so it must not really have a location;\n      try adding a constant value attribute from the DECL_INITIAL.  */\n-  tree_add_const_value_attribute_for_decl (die, decl);\n+  return tree_add_const_value_attribute_for_decl (die, decl);\n }\n \n /* Add VARIABLE and DIE into deferred locations list.  */\n@@ -14014,22 +14076,25 @@ native_encode_initializer (tree init, unsigned char *array, int size)\n /* Attach a DW_AT_const_value attribute to DIE. The value of the\n    attribute is the const value T.  */\n \n-static void\n+static bool\n tree_add_const_value_attribute (dw_die_ref die, tree t)\n {\n   tree init;\n   tree type = TREE_TYPE (t);\n   rtx rtl;\n \n   if (!t || !TREE_TYPE (t) || TREE_TYPE (t) == error_mark_node)\n-    return;\n+    return false;\n \n   init = t;\n   gcc_assert (!DECL_P (init));\n \n   rtl = rtl_for_decl_init (init, type);\n   if (rtl)\n-    add_const_value_attribute (die, rtl);\n+    {\n+      add_const_value_attribute (die, rtl);\n+      return true;\n+    }\n   /* If the host and target are sane, try harder.  */\n   else if (CHAR_BIT == 8 && BITS_PER_UNIT == 8\n \t   && initializer_constant_valid_p (init, type))\n@@ -14040,33 +14105,37 @@ tree_add_const_value_attribute (dw_die_ref die, tree t)\n \t  unsigned char *array = GGC_CNEWVEC (unsigned char, size);\n \n \t  if (native_encode_initializer (init, array, size))\n-\t    add_AT_vec (die, DW_AT_const_value, size, 1, array);\n+\t    {\n+\t      add_AT_vec (die, DW_AT_const_value, size, 1, array);\n+\t      return true;\n+\t    }\n \t}\n     }\n+  return false;\n }\n \n /* Attach a DW_AT_const_value attribute to VAR_DIE. The value of the\n    attribute is the const value of T, where T is an integral constant\n    variable with static storage duration\n    (so it can't be a PARM_DECL or a RESULT_DECL).  */\n \n-static void\n+static bool\n tree_add_const_value_attribute_for_decl (dw_die_ref var_die, tree decl)\n {\n \n   if (!decl\n       || (TREE_CODE (decl) != VAR_DECL\n \t  && TREE_CODE (decl) != CONST_DECL))\n-    return;\n+    return false;\n \n     if (TREE_READONLY (decl)\n \t&& ! TREE_THIS_VOLATILE (decl)\n \t&& DECL_INITIAL (decl))\n       /* OK */;\n     else\n-      return;\n+      return false;\n \n-    tree_add_const_value_attribute (var_die, DECL_INITIAL (decl));\n+  return tree_add_const_value_attribute (var_die, DECL_INITIAL (decl));\n }\n \n /* Convert the CFI instructions for the current function into a"}]}