{"sha": "86b5812c1817f234a0f3e283e587f14c70fa90ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZiNTgxMmMxODE3ZjIzNGEwZjNlMjgzZTU4N2YxNGM3MGZhOTBiYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:12:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:12:25Z"}, "message": "(expand_expr, case COMPONENT_REF):  If taking value from a CONSTRUCTOR,\n\nmust mask/sign-extend if bitfield.\n(expand_builtin, case BUILT_IN_LONGJMP): Pass type, not IDENTIFIER,\nto send arg of RETURN_POPS_ARGS.\n\nFrom-SVN: r13373", "tree": {"sha": "9a19f78e3d5993d87592752ce470da3a948e1393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a19f78e3d5993d87592752ce470da3a948e1393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86b5812c1817f234a0f3e283e587f14c70fa90ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b5812c1817f234a0f3e283e587f14c70fa90ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b5812c1817f234a0f3e283e587f14c70fa90ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b5812c1817f234a0f3e283e587f14c70fa90ba/comments", "author": null, "committer": null, "parents": [{"sha": "ac01eace31d7c08ffb77c1f732258c1a93eb972f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac01eace31d7c08ffb77c1f732258c1a93eb972f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac01eace31d7c08ffb77c1f732258c1a93eb972f"}], "stats": {"total": 48, "additions": 44, "deletions": 4}, "files": [{"sha": "e4c66095c4293a35e7175440e2fc28517050d969", "filename": "gcc/expr.c", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86b5812c1817f234a0f3e283e587f14c70fa90ba/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86b5812c1817f234a0f3e283e587f14c70fa90ba/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=86b5812c1817f234a0f3e283e587f14c70fa90ba", "patch": "@@ -5467,8 +5467,46 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  for (elt = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)); elt;\n \t       elt = TREE_CHAIN (elt))\n-\t    if (TREE_PURPOSE (elt) == TREE_OPERAND (exp, 1))\n-\t      return expand_expr (TREE_VALUE (elt), target, tmode, modifier);\n+\t    if (TREE_PURPOSE (elt) == TREE_OPERAND (exp, 1)\n+\t\t/* We can normally use the value of the field in the\n+\t\t   CONSTRUCTOR.  However, if this is a bitfield in\n+\t\t   an integral mode that we can fit in a HOST_WIDE_INT,\n+\t\t   we must mask only the number of bits in the bitfield,\n+\t\t   since this is done implicitly by the constructor.  If\n+\t\t   the bitfield does not meet either of those conditions,\n+\t\t   we can't do this optimization.  */\n+\t\t&& (! DECL_BIT_FIELD (TREE_PURPOSE (elt))\n+\t\t    || ((GET_MODE_CLASS (DECL_MODE (TREE_PURPOSE (elt)))\n+\t\t\t == MODE_INT)\n+\t\t\t&& (GET_MODE_BITSIZE (DECL_MODE (TREE_PURPOSE (elt)))\n+\t\t\t    <= HOST_BITS_PER_WIDE_INT))))\n+\t      {\n+\t\top0 =  expand_expr (TREE_VALUE (elt), target, tmode, modifier);\n+\t\tif (DECL_BIT_FIELD (TREE_PURPOSE (elt)))\n+\t\t  {\n+\t\t    int bitsize = DECL_FIELD_SIZE (TREE_PURPOSE (elt));\n+\t\t    enum machine_mode imode\n+\t\t      = TYPE_MODE (TREE_TYPE (TREE_PURPOSE (elt)));\n+\n+\t\t    if (TREE_UNSIGNED (TREE_TYPE (TREE_PURPOSE (elt))))\n+\t\t      {\n+\t\t\top1 = GEN_INT (((HOST_WIDE_INT) 1 << bitsize) - 1);\n+\t\t\top0 = expand_and (op0, op1, target);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\ttree count\n+\t\t\t  = build_int_2 (imode - bitsize, 0);\n+\n+\t\t\top0 = expand_shift (LSHIFT_EXPR, imode, op0, count,\n+\t\t\t\t\t    target, 0);\n+\t\t\top0 = expand_shift (RSHIFT_EXPR, imode, op0, count,\n+\t\t\t\t\t    target, 0);\n+\t\t      }\n+\t\t  }\n+\n+\t\treturn op0;\n+\t      }\n \t}\n \n       {\n@@ -8838,8 +8876,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \tenum machine_mode sa_mode = Pmode;\n \trtx stack_save;\n \tint old_inhibit_defer_pop = inhibit_defer_pop;\n-\tint return_pops = RETURN_POPS_ARGS (get_identifier (\"__dummy\"),\n-\t\t\t\t\t    get_identifier (\"__dummy\"), 0);\n+\tint return_pops\n+\t  =  RETURN_POPS_ARGS (get_identifier (\"__dummy\"),\n+\t\t\t       build_function_type (void_type_node, NULL_TREE),\n+\t\t\t       0);\n \trtx next_arg_reg;\n \tCUMULATIVE_ARGS args_so_far;\n \tint i;"}]}