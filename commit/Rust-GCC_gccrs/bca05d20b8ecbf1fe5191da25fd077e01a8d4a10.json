{"sha": "bca05d20b8ecbf1fe5191da25fd077e01a8d4a10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNhMDVkMjBiOGVjYmYxZmU1MTkxZGEyNWZkMDc3ZTAxYThkNGExMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-03-21T20:19:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-03-21T20:19:21Z"}, "message": "cse.c (find_comparison_args): Remove previous change.\n\n\t* cse.c (find_comparison_args): Remove previous change.\n\t* ifcvt.c (noce_process_if_block): When moving an insn, remove any\n\tREG_EQUAL notes.\n\nFrom-SVN: r40715", "tree": {"sha": "e42e2f734c28162f0a326545e885574fa66bf024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e42e2f734c28162f0a326545e885574fa66bf024"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10/comments", "author": null, "committer": null, "parents": [{"sha": "37c7da7b70e2d53e1053463bbdb92fb153316ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37c7da7b70e2d53e1053463bbdb92fb153316ae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37c7da7b70e2d53e1053463bbdb92fb153316ae1"}], "stats": {"total": 90, "additions": 43, "deletions": 47}, "files": [{"sha": "15a3dc92ccabd995c5c9b5811f285d2bef3a7219", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bca05d20b8ecbf1fe5191da25fd077e01a8d4a10", "patch": "@@ -1,5 +1,9 @@\n Wed Mar 21 14:27:11 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* cse.c (find_comparison_args): Remove previous change.\n+\t* ifcvt.c (noce_process_if_block): When moving an insn, remove any\n+\tREG_EQUAL notes.\n+\n \t* config/i386/i386.md (conditional_trap): Remove warning.\n \n \t* recog.c (push_operand): Fix error in last change that caused"}, {"sha": "38ba919f115abe387795afd8099739e5f2752478", "filename": "gcc/cse.c", "status": "modified", "additions": 31, "deletions": 47, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bca05d20b8ecbf1fe5191da25fd077e01a8d4a10", "patch": "@@ -3086,25 +3086,17 @@ find_best_addr (insn, loc, mode)\n #endif\n }\n \f\n-/* This routine accepts a comparison as input and attempts to return a\n-   comparision that is cheaper to compute.\n+/* Given an operation (CODE, *PARG1, *PARG2), where code is a comparison\n+   operation (EQ, NE, GT, etc.), follow it back through the hash table and\n+   what values are being compared.\n \n-   On input, *PARG1 and *PARG2 should be set to the first and second\n-   arguments to the comparison, respectively.  CODE is the comparision\n-   code.  For example, if the comparison is:\n+   *PARG1 and *PARG2 are updated to contain the rtx representing the values\n+   actually being compared.  For example, if *PARG1 was (cc0) and *PARG2\n+   was (const_int 0), *PARG1 and *PARG2 will be set to the objects that were\n+   compared to produce cc0.\n \n-     (ne:SI (reg:CC 24 cc)\n-            (const_int 0 [0x0])))\n-\n-   The CODE should be NE, *PARG1 should be `(reg:CC 24 cc)' and \n-   *PARG2 should be `(const_int 0)'.\n-\n-   Upon return, *PARG1 and and *PARG2 may have new values, indicating\n-   arguments to a cheaper comparison.  *PMODE1 and *PMODE2 will be the\n-   modes that should be used for those arguments.  The return value\n-   itself will be the comparison code that should be used to compare\n-   *PARG1 and *PARG2 in order to obtain a value equivalent to that\n-   given by the original comparison.  */\n+   The return value is the comparison operator and is either the code of\n+   A or the code corresponding to the inverse of the comparison.  */\n \n static enum rtx_code\n find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n@@ -3195,38 +3187,30 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n \t  if (! exp_equiv_p (p->exp, p->exp, 1, 0))\n \t    continue;\n \n-\t  /* `(COMPARE A B) != 0)' is equivalent to `(COMPARE A B)'.\n-\t     If CODE is EQ, rather than NE, then we are out of luck;\n-\t     there is no way to reverse the sense of a COMPARE.  */\n-\t  if (code == NE && GET_CODE (p->exp) == COMPARE)\n-\t    {\n-\t      x = p->exp;\n-\t      break;\n-\t    }\n-\t  /* Another possibility is that this machine has a compare\n-\t     insn that includes the comparison code.  In that case,\n-\t     ARG1 would be equivalent to a comparison operation that\n-\t     would set ARG1 to either STORE_FLAG_VALUE or zero.  If\n-\t     this is an NE operation, ORIG_CODE is the actual\n-\t     comparison being done; if it is an EQ, we must reverse\n-\t     ORIG_CODE.  On machine with a negative value for\n-\t     STORE_FLAG_VALUE, also look at LT and GE operations.  */\n-\t  else if ((code == NE\n-\t\t    || (code == LT\n-\t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t&& (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t    <= HOST_BITS_PER_WIDE_INT)\n-\t\t\t&& (STORE_FLAG_VALUE\n-\t\t\t    & ((HOST_WIDE_INT) 1\n-\t\t\t       << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t  if (GET_CODE (p->exp) == COMPARE\n+\t      /* Another possibility is that this machine has a compare insn\n+\t\t that includes the comparison code.  In that case, ARG1 would\n+\t\t be equivalent to a comparison operation that would set ARG1 to\n+\t\t either STORE_FLAG_VALUE or zero.  If this is an NE operation,\n+\t\t ORIG_CODE is the actual comparison being done; if it is an EQ,\n+\t\t we must reverse ORIG_CODE.  On machine with a negative value\n+\t\t for STORE_FLAG_VALUE, also look at LT and GE operations.  */\n+\t      || ((code == NE\n+\t\t   || (code == LT\n+\t\t       && GET_MODE_CLASS (inner_mode) == MODE_INT\n+\t\t       && (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t   <= HOST_BITS_PER_WIDE_INT)\n+\t\t       && (STORE_FLAG_VALUE\n+\t\t\t   & ((HOST_WIDE_INT) 1\n+\t\t\t      << (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n-\t\t    || (code == LT\n-\t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t\t&& (REAL_VALUE_NEGATIVE\n-\t\t\t    (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n+\t\t   || (code == LT\n+\t\t       && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n+\t\t       && (REAL_VALUE_NEGATIVE\n+\t\t\t   (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n #endif\n-\t\t    )\n-\t\t   && GET_RTX_CLASS (GET_CODE (p->exp)) == '<')\n+\t\t   )\n+\t\t  && GET_RTX_CLASS (GET_CODE (p->exp)) == '<'))\n \t    {\n \t      x = p->exp;\n \t      break;"}, {"sha": "d21cb4daf4911ae4cd98cc36d832a62e3f5d3ab0", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bca05d20b8ecbf1fe5191da25fd077e01a8d4a10/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=bca05d20b8ecbf1fe5191da25fd077e01a8d4a10", "patch": "@@ -1563,9 +1563,17 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \t that case don't do anything and let the code below delete INSN_A.  */\n       if (insn_b && else_bb)\n \t{\n+\t  rtx note;\n+\n \t  if (else_bb && insn_b == else_bb->end)\n \t    else_bb->end = PREV_INSN (insn_b);\n \t  reorder_insns (insn_b, insn_b, PREV_INSN (if_info.cond_earliest));\n+\n+\t  /* If there was a REG_EQUAL note, delete it since it may have been\n+\t     true due to this insn being after a jump.  */\n+\t  if ((note = find_reg_note (insn_b, REG_EQUAL, NULL_RTX)) != 0)\n+\t    remove_note (insn_b, note);\n+\n \t  insn_b = NULL_RTX;\n \t}\n       /* If we have \"x = b; if (...) x = a;\", and x has side-effects, then"}]}