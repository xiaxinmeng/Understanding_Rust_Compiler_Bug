{"sha": "737df6e61771e330559a152be1653b173012172b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM3ZGY2ZTYxNzcxZTMzMDU1OWExNTJiZTE2NTNiMTczMDEyMTcyYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-10-31T15:46:59Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-10-31T15:46:59Z"}, "message": "complex.c (csqrtq): NaN and INF fixes.\n\n2012-10-31  Tobias Burnus  <burnus@net-b.de>\n            Joseph Myers <joseph@codesourcery.com>\n            David S. Miller <davem@davemloft.net>\n            Ulrich Drepper <drepper@redhat.com>\n            Marek Polacek <polacek@redhat.com>:\n            Petr Baudis <pasky@suse.cz>\n\n        * math/complex.c (csqrtq): NaN and INF fixes.\n        * math/sqrtq.c (sqrt): NaN, INF and < 0 fixes.\n        * math/expm1q.c (expm1q): Changes from GLIBC. Use expq for\n        large parameters. Fix errno for boundary conditions.\n        * math/finiteq.c (finiteq): Add comment.\n        * math/fmaq.c (fmaq): Changes from GLIBC. Fix missing underflows\n        and bad results for some subnormal results. Fix sign of inexact\n        zero return. Fix sign of exact zero return.\n        Ensure additions are not scheduled after fetestexcept.\n        * math/jnq.c (jnq): Changes from GLIBC. Set up errno properly\n        for ynq. Fix jnq precision.\n        * math/nearbyintq.c (nearbyintq): Changes from GLIBC. Do not\n        manipulate bits before adding and subtracting TWO112[sx].\n        * math/rintq.c (rintq): Ditto.\n        * math/scalbnq.c (scalbnq): Changes from GLIBC. Fix integer\n        overflow.\n\n\nCo-Authored-By: David S. Miller <davem@davemloft.net>\nCo-Authored-By: Joseph Myers <joseph@codesourcery.com>\nCo-Authored-By: Ulrich Drepper <drepper@redhat.com>\n\nFrom-SVN: r193037", "tree": {"sha": "1e8de664570b1111159d9aecd98b3bd2f96c3923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e8de664570b1111159d9aecd98b3bd2f96c3923"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/737df6e61771e330559a152be1653b173012172b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737df6e61771e330559a152be1653b173012172b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/737df6e61771e330559a152be1653b173012172b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737df6e61771e330559a152be1653b173012172b/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be028f913fb3e7fc33d4b97f2c67a346f3ff0215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be028f913fb3e7fc33d4b97f2c67a346f3ff0215", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be028f913fb3e7fc33d4b97f2c67a346f3ff0215"}], "stats": {"total": 205, "additions": 131, "deletions": 74}, "files": [{"sha": "37cc5a250288ea02496600aaf5c1e23e21728465", "filename": "libquadmath/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FChangeLog?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -1,3 +1,27 @@\n+2012-10-31  Tobias Burnus  <burnus@net-b.de>\n+\t    Joseph Myers <joseph@codesourcery.com>\n+\t    David S. Miller <davem@davemloft.net>\n+\t    Ulrich Drepper <drepper@redhat.com>\n+\t    Marek Polacek <polacek@redhat.com>:\n+\t    Petr Baudis <pasky@suse.cz>\n+\n+\t* math/complex.c (csqrtq): NaN and INF fixes. \n+\t* math/sqrtq.c (sqrt): NaN, INF and < 0 fixes.\n+\t* math/expm1q.c (expm1q): Changes from GLIBC. Use expq for\n+\tlarge parameters. Fix errno for boundary conditions.\n+\t* math/finiteq.c (finiteq): Add comment.\n+\t* math/fmaq.c (fmaq): Changes from GLIBC. Fix missing underflows\n+\tand bad results for some subnormal results. Fix sign of inexact\n+\tzero return. Fix sign of exact zero return. \n+\tEnsure additions are not scheduled after fetestexcept.\n+\t* math/jnq.c (jnq): Changes from GLIBC. Set up errno properly\n+\tfor ynq. Fix jnq precision.\n+\t* math/nearbyintq.c (nearbyintq): Changes from GLIBC. Do not\n+\tmanipulate bits before adding and subtracting TWO112[sx].\n+\t* math/rintq.c (rintq): Ditto.\n+\t* math/scalbnq.c (scalbnq): Changes from GLIBC. Fix integer\n+\toverflow.\n+\n 2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure: Regenerated."}, {"sha": "9953f52ca6ba20325da64d5f65e8365927d36d8b", "filename": "libquadmath/math/complex.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fcomplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fcomplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcomplex.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -177,7 +177,11 @@ csqrtq (__complex128 z)\n \n   if (im == 0)\n   {\n-    if (re < 0)\n+    if (isnanq (re))\n+    {\n+      COMPLEX_ASSIGN (v, -re, -re);\n+    }\n+    else if (re < 0)\n     {\n       COMPLEX_ASSIGN (v, 0, copysignq (sqrtq (-re), im));\n     }\n@@ -186,6 +190,10 @@ csqrtq (__complex128 z)\n       COMPLEX_ASSIGN (v, fabsq (sqrtq (re)), copysignq (0, im));\n     }\n   }\n+  else if (isinfq (im))\n+  {\n+    COMPLEX_ASSIGN (v, fabsq (im), im);\n+  }\n   else if (re == 0)\n   {\n     __float128 r = sqrtq (0.5 * fabsq (im));"}, {"sha": "8cfdd8eec944f1b59f149072fdbcee28a6de0a78", "filename": "libquadmath/math/expm1q.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fexpm1q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fexpm1q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fexpm1q.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -53,6 +53,7 @@\n \n \n \n+#include <errno.h>\n #include \"quadmath-imp.h\"\n \n /* exp(x) - 1 = x + 0.5 x^2 + x^3 P(x)/Q(x)\n@@ -100,6 +101,11 @@ expm1q (__float128 x)\n   ix = u.words32.w0;\n   sign = ix & 0x80000000;\n   ix &= 0x7fffffff;\n+  if (!sign && ix >= 0x40060000)\n+    {\n+      /* If num is positive and exp >= 6 use plain exp.  */\n+      return expq (x);\n+    }\n   if (ix >= 0x7fff0000)\n     {\n       /* Infinity. */\n@@ -120,7 +126,10 @@ expm1q (__float128 x)\n \n   /* Overflow.  */\n   if (x > maxlog)\n-    return (HUGE_VALQ * HUGE_VALQ);\n+    {\n+      errno = ERANGE;\n+      return (HUGE_VALQ * HUGE_VALQ);\n+    }\n \n   /* Minimum value.  */\n   if (x < minarg)"}, {"sha": "663c92892638ed5236820332658beabb1940b1c1", "filename": "libquadmath/math/finiteq.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Ffiniteq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Ffiniteq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffiniteq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -15,6 +15,11 @@\n \n #include \"quadmath-imp.h\"\n \n+/*\n+ * finiteq(x) returns 1 is x is finite, else 0;\n+ * no branching!\n+ */\n+\n int\n finiteq (const __float128 x)\n {"}, {"sha": "23e3188669e0eade80072c92aab12b628b931647", "filename": "libquadmath/math/fmaq.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Ffmaq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Ffmaq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffmaq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -1,5 +1,5 @@\n /* Compute x * y + z as ternary operation.\n-   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2010-2012 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Jakub Jelinek <jakub@redhat.com>, 2010.\n \n@@ -57,6 +57,11 @@ fmaq (__float128 x, __float128 y, __float128 z)\n \t  && u.ieee.exponent != 0x7fff\n           && v.ieee.exponent != 0x7fff)\n \treturn (z + x) + y;\n+      /* If z is zero and x are y are nonzero, compute the result\n+\t as x * y to avoid the wrong sign of a zero result if x * y\n+\t underflows to 0.  */\n+      if (z == 0 && x != 0 && y != 0)\n+\treturn x * y;\n       /* If x or y or z is Inf/NaN, or if fma will certainly overflow,\n \t or if x * y is less than half of FLT128_DENORM_MIN,\n \t compute as x * y + z.  */\n@@ -136,6 +141,11 @@ fmaq (__float128 x, __float128 y, __float128 z)\n       y = v.value;\n       z = w.value;\n     }\n+\n+  /* Ensure correct sign of exact 0 + 0.  */\n+  if (__builtin_expect ((x == 0 || y == 0) && z == 0, 0))\n+    return x * y + z;\n+\n   /* Multiplication m1 + m2 = x * y using Dekker's algorithm.  */\n #define C ((1LL << (FLT128_MANT_DIG + 1) / 2) + 1)\n   __float128 x1 = x * C;\n@@ -191,7 +201,7 @@ fmaq (__float128 x, __float128 y, __float128 z)\n #endif\n       v.value = a1 + u.value;\n       /* Ensure the addition is not scheduled after fetestexcept call.  */\n-      asm volatile (\"\" : : \"m\" (v));\n+      asm volatile (\"\" : : \"m\" (v.value));\n #ifdef USE_FENV_H\n       int j = fetestexcept (FE_INEXACT) != 0;\n       feupdateenv (&env);\n@@ -220,20 +230,14 @@ fmaq (__float128 x, __float128 y, __float128 z)\n \t{\n \t  /* v.ieee.mant_low & 2 is LSB bit of the result before rounding,\n \t     v.ieee.mant_low & 1 is the round bit and j is our sticky\n-\t     bit.  In round-to-nearest 001 rounds down like 00,\n-\t     011 rounds up, even though 01 rounds down (thus we need\n-\t     to adjust), 101 rounds down like 10 and 111 rounds up\n-\t     like 11.  */\n-\t  if ((v.ieee.mant_low & 3) == 1)\n-\t    {\n-\t      v.value *= 0x1p-226Q;\n-\t      if (v.ieee.negative)\n-\t\treturn v.value - 0x1p-16494Q /* __FLT128_DENORM_MIN__ */;\n-\t      else\n-\t\treturn v.value + 0x1p-16494Q /* __FLT128_DENORM_MIN__ */;\n-\t    }\n-\t  else\n-\t    return v.value * 0x1p-226Q;\n+\t     bit. */\n+\t  w.value = 0.0Q;\n+\t  w.ieee.mant_low = ((v.ieee.mant_low & 3) << 1) | j;\n+\t  w.ieee.negative = v.ieee.negative;\n+\t  v.ieee.mant_low &= ~3U;\n+\t  v.value *= 0x1p-226L;\n+\t  w.value *= 0x1p-2L;\n+\t  return v.value + w.value;\n \t}\n       v.ieee.mant_low |= j;\n       return v.value * 0x1p-226Q;"}, {"sha": "56a183604c1267067daf1e8e7213d3d3fb5857a8", "filename": "libquadmath/math/jnq.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fjnq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fjnq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fjnq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -11,9 +11,9 @@\n \n /* Modifications for 128-bit long double are\n    Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>\n-   and are incorporated herein by permission of the author.  The author \n+   and are incorporated herein by permission of the author.  The author\n    reserves the right to distribute this material elsewhere under different\n-   copying permissions.  These modifications are distributed here under \n+   copying permissions.  These modifications are distributed here under\n    the following terms:\n \n     This library is free software; you can redistribute it and/or\n@@ -56,6 +56,7 @@\n  *\n  */\n \n+#include <errno.h>\n #include \"quadmath-imp.h\"\n \n static const __float128\n@@ -273,7 +274,16 @@ jnq (int n, __float128 x)\n \t\t    }\n \t\t}\n \t    }\n-\t  b = (t * j0q (x) / b);\n+\t  /* j0() and j1() suffer enormous loss of precision at and\n+\t   * near zero; however, we know that their zero points never\n+\t   * coincide, so just choose the one further away from zero.\n+\t   */\n+\t  z = j0q (x);\n+\t  w = j1q (x);\n+\t  if (fabsq (z) >= fabsq (w))\n+\t    b = (t * z / b);\n+\t  else\n+\t    b = (t * w / a);\n \t}\n     }\n   if (sgn == 1)\n@@ -374,6 +384,9 @@ ynq (int n, __float128 x)\n \t  a = temp;\n \t}\n     }\n+  /* If B is +-Inf, set up errno accordingly.  */\n+  if (! finiteq (b))\n+    errno = ERANGE;\n   if (sign > 0)\n     return b;\n   else"}, {"sha": "207124808e77ad4fbe6fa65b351a32e4a0fd665b", "filename": "libquadmath/math/nearbyintq.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fnearbyintq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fnearbyintq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fnearbyintq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -44,18 +44,13 @@ nearbyintq(__float128 x)\n \tfenv_t env;\n #endif\n \tint64_t i0,j0,sx;\n-\tuint64_t i,i1;\n+\tuint64_t i1;\n \t__float128 w,t;\n \tGET_FLT128_WORDS64(i0,i1,x);\n \tsx = (((uint64_t)i0)>>63);\n \tj0 = ((i0>>48)&0x7fff)-0x3fff;\n-\tif(j0<48) {\n+\tif(j0<112) {\n \t    if(j0<0) {\n-\t\tif(((i0&0x7fffffffffffffffLL)|i1)==0) return x;\n-\t\ti1 |= (i0&0x0000ffffffffffffLL);\n-\t\ti0 &= 0xffffe00000000000ULL;\n-\t\ti0 |= ((i1|-i1)>>16)&0x0000800000000000LL;\n-\t\tSET_FLT128_MSW64(x,i0);\n #ifdef USE_FENV_H\n \t\tfeholdexcept (&env);\n #endif\n@@ -67,25 +62,11 @@ nearbyintq(__float128 x)\n \t\tGET_FLT128_MSW64(i0,t);\n \t\tSET_FLT128_MSW64(t,(i0&0x7fffffffffffffffLL)|(sx<<63));\n \t        return t;\n-\t    } else {\n-\t\ti = (0x0000ffffffffffffLL)>>j0;\n-\t\tif(((i0&i)|i1)==0) return x; /* x is integral */\n-\t\ti>>=1;\n-\t\tif(((i0&i)|i1)!=0) {\n-\t\t    if(j0==47) i1 = 0x4000000000000000ULL; else\n-\t\t    i0 = (i0&(~i))|((0x0000200000000000LL)>>j0);\n-\t\t}\n \t    }\n-\t} else if (j0>111) {\n+\t} else {\n \t    if(j0==0x4000) return x+x;\t/* inf or NaN */\n \t    else return x;\t\t/* x is integral */\n-\t} else {\n-\t    i = -1ULL>>(j0-48);\n-\t    if((i1&i)==0) return x;\t/* x is integral */\n-\t    i>>=1;\n-\t    if((i1&i)!=0) i1 = (i1&(~i))|((0x4000000000000000LL)>>(j0-48));\n \t}\n-\tSET_FLT128_WORDS64(x,i0,i1);\n #ifdef USE_FENV_H\n \tfeholdexcept (&env);\n #endif"}, {"sha": "8a93fdbfa782745c8fc4b785aea3da96e0f95228", "filename": "libquadmath/math/rintq.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Frintq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Frintq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Frintq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -13,6 +13,16 @@\n  * ====================================================\n  */\n \n+/*\n+ * rintq(x)\n+ * Return x rounded to integral value according to the prevailing\n+ * rounding mode.\n+ * Method:\n+ *\tUsing floating addition.\n+ * Exception:\n+ *\tInexact flag raised if x not equal to rintq(x).\n+ */\n+\n #include \"quadmath-imp.h\"\n \n static const __float128\n@@ -25,42 +35,23 @@ __float128\n rintq (__float128 x)\n {\n \tint64_t i0,j0,sx;\n-\tuint64_t i,i1;\n+\tuint64_t i1;\n \t__float128 w,t;\n \tGET_FLT128_WORDS64(i0,i1,x);\n \tsx = (((uint64_t)i0)>>63);\n \tj0 = ((i0>>48)&0x7fff)-0x3fff;\n-\tif(j0<48) {\n+\tif(j0<112) {\n \t    if(j0<0) {\n-\t\tif(((i0&0x7fffffffffffffffLL)|i1)==0) return x;\n-\t\ti1 |= (i0&0x0000ffffffffffffLL);\n-\t\ti0 &= 0xffffe00000000000ULL;\n-\t\ti0 |= ((i1|-i1)>>16)&0x0000800000000000LL;\n-\t\tSET_FLT128_MSW64(x,i0);\n \t        w = TWO112[sx]+x;\n \t        t = w-TWO112[sx];\n \t\tGET_FLT128_MSW64(i0,t);\n \t\tSET_FLT128_MSW64(t,(i0&0x7fffffffffffffffLL)|(sx<<63));\n \t        return t;\n-\t    } else {\n-\t\ti = (0x0000ffffffffffffLL)>>j0;\n-\t\tif(((i0&i)|i1)==0) return x; /* x is integral */\n-\t\ti>>=1;\n-\t\tif(((i0&i)|i1)!=0) {\n-\t\t    if(j0==47) i1 = 0x4000000000000000ULL; else\n-\t\t    i0 = (i0&(~i))|((0x0000200000000000LL)>>j0);\n-\t\t}\n \t    }\n-\t} else if (j0>111) {\n+\t} else {\n \t    if(j0==0x4000) return x+x;\t/* inf or NaN */\n \t    else return x;\t\t/* x is integral */\n-\t} else {\n-\t    i = -1ULL>>(j0-48);\n-\t    if((i1&i)==0) return x;\t/* x is integral */\n-\t    i>>=1;\n-\t    if((i1&i)!=0) i1 = (i1&(~i))|((0x4000000000000000LL)>>(j0-48));\n \t}\n-\tSET_FLT128_WORDS64(x,i0,i1);\n \tw = TWO112[sx]+x;\n \treturn w-TWO112[sx];\n }"}, {"sha": "b2332250c6123bb4ff434954efb9d4886138eefc", "filename": "libquadmath/math/scalblnq.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fscalblnq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fscalblnq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fscalblnq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -13,6 +13,13 @@\n  * ====================================================\n  */\n \n+/*\n+ * scalblnq (_float128 x, long int n)\n+ * scalblnq(x,n) returns x* 2**n  computed by  exponent\n+ * manipulation rather than by actually performing an\n+ * exponentiation or a multiplication.\n+ */\n+\n #include \"quadmath-imp.h\"\n \n static const __float128\n@@ -34,10 +41,12 @@ scalblnq (__float128 x, long int n)\n \t    k = ((hx>>48)&0x7fff) - 114;\n \t}\n         if (k==0x7fff) return x+x;\t\t/* NaN or Inf */\n-        k = k+n;\n-        if (n> 50000 || k > 0x7ffe)\n-\t  return huge*copysignq(huge,x); /* overflow  */\n \tif (n< -50000) return tiny*copysignq(tiny,x); /*underflow*/\n+        if (n> 50000 || k+n > 0x7ffe)\n+\t  return huge*copysignq(huge,x); /* overflow  */\n+\t/* Now k and n are bounded we know that k = k+n does not\n+\t   overflow.  */\n+        k = k+n;\n         if (k > 0) \t\t\t\t/* normal result */\n \t    {SET_FLT128_MSW64(x,(hx&0x8000ffffffffffffULL)|(k<<48)); return x;}\n         if (k <= -114)"}, {"sha": "f0852ee038dcfec1f608fa010a491082b795f5d1", "filename": "libquadmath/math/scalbnq.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fscalbnq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fscalbnq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fscalbnq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -13,6 +13,14 @@\n  * ====================================================\n  */\n \n+\n+/*\n+ * scalbnq (__float128 x, int n)\n+ * scalbnq(x,n) returns x* 2**n  computed by  exponent\n+ * manipulation rather than by actually performing an\n+ * exponentiation or a multiplication.\n+ */\n+\n #include \"quadmath-imp.h\"\n \n static const __float128\n@@ -34,10 +42,12 @@ scalbnq (__float128 x, int n)\n \t    k = ((hx>>48)&0x7fff) - 114;\n \t}\n         if (k==0x7fff) return x+x;\t\t/* NaN or Inf */\n-        k = k+n;\n-        if (n> 50000 || k > 0x7ffe)\n-\t  return huge*copysignq(huge,x); /* overflow  */\n \tif (n< -50000) return tiny*copysignq(tiny,x); /*underflow*/\n+        if (n> 50000 || k+n > 0x7ffe)\n+\t  return huge*copysignq(huge,x); /* overflow  */\n+\t/* Now k and n are bounded we know that k = k+n does not\n+\t   overflow.  */\n+        k = k+n;\n         if (k > 0) \t\t\t\t/* normal result */\n \t    {SET_FLT128_MSW64(x,(hx&0x8000ffffffffffffULL)|(k<<48)); return x;}\n         if (k <= -114)"}, {"sha": "f63c0d1f6d2749f235a611173b5c17291a7217d7", "filename": "libquadmath/math/sqrtq.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fsqrtq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737df6e61771e330559a152be1653b173012172b/libquadmath%2Fmath%2Fsqrtq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fsqrtq.c?ref=737df6e61771e330559a152be1653b173012172b", "patch": "@@ -8,14 +8,17 @@ sqrtq (const __float128 x)\n   __float128 y;\n   int exp;\n \n-  if (x == 0)\n+  if (isnanq (x) || (isinfq (x) && x > 0))\n     return x;\n \n-  if (isnanq (x))\n+  if (x == 0)\n     return x;\n \n   if (x < 0)\n-    return nanq (\"\");\n+    {\n+      /* Return NaN with invalid signal.  */\n+      return (x - x) / (x - x);\n+    }\n \n   if (x <= DBL_MAX && x >= DBL_MIN)\n   {"}]}