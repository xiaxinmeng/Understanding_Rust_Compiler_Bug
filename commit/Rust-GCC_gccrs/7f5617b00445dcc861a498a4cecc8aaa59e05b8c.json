{"sha": "7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y1NjE3YjAwNDQ1ZGNjODYxYTQ5OGE0Y2VjYzhhYWE1OWUwNWI4Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-24T11:56:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-24T11:56:39Z"}, "message": "sccvn: Handle bitfields in push_partial_def [PR93582]\n\nThe following patch adds support for bitfields to push_partial_def.\nPreviously pd.offset and pd.size were counted in bytes and maxsizei\nin bits, now everything is counted in bits.\n\nNot really sure how much of the further code can be outlined and moved, e.g.\nthe full def and partial def code doesn't have pretty much anything in\ncommon (the partial defs case basically have some load bit range and a set\nof store bit ranges that at least partially overlap and we need to handle\nall the different cases, like negative pd.offset or non-negative, little vs.\nbit endian, size so small that we need to preserve original bits on both\nsides of the byte, size that fits or is too large.\nPerhaps the storing of some value into a middle of existing buffer (i.e.\nwhat push_partial_def now does in the loop) could, but the candidate for\nsharing would be most likely store-merging rather than the other spots in\nsccvn, and I think it is better not to touch store-merging at this stage.\n\nYes, I've thought about trying to do everything in place, but the code is\nquite hard to understand and get right already now and if we tried to do the\noptimize on the fly, it would need more special cases and would for gcov\ncoverage need more testcases to cover it.  Most of the time the sizes will\nbe small.  Furthermore, for bitfields native_encode_expr stores actually\nnumber of bytes in the mode and not say actual bitsize rounded up to bytes,\nso it wouldn't be just a matter of saving/restoring bytes at the start and\nend, but we might need even 7 further bytes e.g. for __int128 bitfields.\nPerhaps we could have just a fast path for the case where everything is byte\naligned and (for integral types the mode bitsize is equal to the size too)?\n\n2020-02-24  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/93582\n\t* tree-ssa-sccvn.c (vn_walk_cb_data::push_partial_def): Consider\n\tpd.offset and pd.size to be counted in bits rather than bytes, add\n\tsupport for maxsizei that is not a multiple of BITS_PER_UNIT and\n\thandle bitfield stores and loads.\n\t(vn_reference_lookup_3): Don't call ranges_known_overlap_p with\n\tuncomparable quantities - bytes vs. bits.  Allow push_partial_def\n\ton offsets/sizes that aren't multiple of BITS_PER_UNIT and adjust\n\tpd.offset/pd.size to be counted in bits rather than bytes.\n\tFormatting fix.  Rename shadowed len variable to buflen.\n\n\t* gcc.dg/tree-ssa/pr93582-4.c: New test.\n\t* gcc.dg/tree-ssa/pr93582-5.c: New test.\n\t* gcc.dg/tree-ssa/pr93582-6.c: New test.\n\t* gcc.dg/tree-ssa/pr93582-7.c: New test.\n\t* gcc.dg/tree-ssa/pr93582-8.c: New test.", "tree": {"sha": "5d7841580c0462c271e5028ddf10cbcdbe38a5b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d7841580c0462c271e5028ddf10cbcdbe38a5b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd8c3ff3511df8781dd9f3777efab20572d29ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd8c3ff3511df8781dd9f3777efab20572d29ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bd8c3ff3511df8781dd9f3777efab20572d29ab"}], "stats": {"total": 371, "additions": 316, "deletions": 55}, "files": [{"sha": "e974410308a284d9903f1abf334732afb2bded33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -1,3 +1,16 @@\n+2020-02-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93582\n+\t* tree-ssa-sccvn.c (vn_walk_cb_data::push_partial_def): Consider\n+\tpd.offset and pd.size to be counted in bits rather than bytes, add\n+\tsupport for maxsizei that is not a multiple of BITS_PER_UNIT and\n+\thandle bitfield stores and loads.\n+\t(vn_reference_lookup_3): Don't call ranges_known_overlap_p with\n+\tuncomparable quantities - bytes vs. bits.  Allow push_partial_def\n+\ton offsets/sizes that aren't multiple of BITS_PER_UNIT and adjust\n+\tpd.offset/pd.size to be counted in bits rather than bytes.\n+\tFormatting fix.  Rename shadowed len variable to buflen.\n+\n 2020-02-24  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \t    Kugan Vivekandarajah  <kugan.vivekanandarajah@linaro.org>\n "}, {"sha": "9ca2d75189c3da5e110077e68b79560da2c483ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -1,3 +1,12 @@\n+2020-02-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93582\n+\t* gcc.dg/tree-ssa/pr93582-4.c: New test.\n+\t* gcc.dg/tree-ssa/pr93582-5.c: New test.\n+\t* gcc.dg/tree-ssa/pr93582-6.c: New test.\n+\t* gcc.dg/tree-ssa/pr93582-7.c: New test.\n+\t* gcc.dg/tree-ssa/pr93582-8.c: New test.\n+\n 2020-02-24  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR fortran/93552"}, {"sha": "4c9dce55d314ba75ef527baad80d14f9e8000d1b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-4.c?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -0,0 +1,23 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return -1991560811;\" \"fre1\" { target le } } } */\n+/* { dg-final { scan-tree-dump \"return -733324916;\" \"fre1\" { target be } } } */\n+\n+union U {\n+  struct S { int a : 1, b : 4, c : 27; } s;\n+  unsigned int i;\n+};\n+struct A { char a[24]; union U u; };\n+void bar (struct A *);\n+\n+int\n+foo (void)\n+{\n+  struct A a;\n+  bar (&a);\n+  a.u.s.a = -1;\n+  a.u.s.b = -6;\n+  a.u.s.c = -62236276;\n+  return a.u.i;\n+}"}, {"sha": "426aa8a98b683db16d2913f4c28499f87d94baf7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-5.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-5.c?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -0,0 +1,25 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return -1462729318;\" \"fre1\" { target le } } } */\n+/* { dg-final { scan-tree-dump \"return 1300568597;\" \"fre1\" { target be } } } */\n+\n+union U {\n+  struct S { int a : 1, b : 7, c : 8, d : 11, e : 5; } s;\n+  unsigned int i;\n+};\n+struct A { char a[8]; union U u; };\n+void bar (struct A *);\n+\n+int\n+foo (void)\n+{\n+  struct A a;\n+  bar (&a);\n+  a.u.s.a = 0;\n+  a.u.s.b = -51;\n+  a.u.s.c = -123;\n+  a.u.s.d = 208;\n+  a.u.s.e = -11;\n+  return a.u.i;\n+}"}, {"sha": "569a6e2253b0d305be7368af120a1d946bb0d5e8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-6.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-6.c?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -0,0 +1,24 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return 890118;\" \"fre1\" { target le } } } */\n+/* { dg-final { scan-tree-dump \"return 447899;\" \"fre1\" { target be } } } */\n+\n+union U {\n+  struct S { int a : 16, b : 5, c : 10, d : 1; } s;\n+  struct T { int a : 8, b : 21, c : 3; } t;\n+};\n+struct A { char a[4]; union U u; };\n+void bar (struct A *);\n+\n+int\n+foo (void)\n+{\n+  struct A a;\n+  bar (&a);\n+  a.u.s.a = 1590;\n+  a.u.s.b = -11;\n+  a.u.s.c = 620;\n+  a.u.s.d = -1;\n+  return a.u.t.b;\n+}"}, {"sha": "b9683932968c08dbe11b5ccab06182dee5d44cae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-7.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-7.c?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -0,0 +1,24 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return -413012;\" \"fre1\" { target le } } } */\n+/* { dg-final { scan-tree-dump \"return -611112;\" \"fre1\" { target be } } } */\n+\n+union U {\n+  struct S { int a : 12, b : 5, c : 10, d : 5; } s;\n+  struct T { int a : 7, b : 21, c : 4; } t;\n+};\n+struct A { char a[48]; union U u; };\n+void bar (struct A *);\n+\n+int\n+foo (void)\n+{\n+  struct A a;\n+  bar (&a);\n+  a.u.s.a = 1590;\n+  a.u.s.b = -11;\n+  a.u.s.c = -404;\n+  a.u.s.d = 7;\n+  return a.u.t.b;\n+}"}, {"sha": "14b631507ffc4ed15a3f7cfe79cae1e433354bfc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-8.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-8.c?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -0,0 +1,14 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return 0;\" \"fre1\" { target le } } } */\n+/* { dg-final { scan-tree-dump \"return -8531;\" \"fre1\" { target be } } } */\n+\n+short\n+foo (void)\n+{\n+  union U { char c[32]; short s[16]; int i[8]; } u;\n+  __builtin_memset (u.c + 1, '\\0', 5);\n+  u.s[3] = 0xdead;\n+  return u.i[1];\n+}"}, {"sha": "a3fba2878f86a8f4dd7afe2391cc09ae97def368", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 184, "deletions": 55, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5617b00445dcc861a498a4cecc8aaa59e05b8c/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=7f5617b00445dcc861a498a4cecc8aaa59e05b8c", "patch": "@@ -1774,7 +1774,11 @@ vn_walk_cb_data::push_partial_def (const pd_data &pd,\n   const HOST_WIDE_INT bufsize = 64;\n   /* We're using a fixed buffer for encoding so fail early if the object\n      we want to interpret is bigger.  */\n-  if (maxsizei > bufsize * BITS_PER_UNIT)\n+  if (maxsizei > bufsize * BITS_PER_UNIT\n+      || CHAR_BIT != 8\n+      || BITS_PER_UNIT != 8\n+      /* Not prepared to handle PDP endian.  */\n+      || BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n     return (void *)-1;\n \n   bool pd_constant_p = (TREE_CODE (pd.rhs) == CONSTRUCTOR\n@@ -1854,56 +1858,192 @@ vn_walk_cb_data::push_partial_def (const pd_data &pd,\n   /* Now we have merged newr into the range tree.  When we have covered\n      [offseti, sizei] then the tree will contain exactly one node which has\n      the desired properties and it will be 'r'.  */\n-  if (!known_subrange_p (0, maxsizei / BITS_PER_UNIT, r->offset, r->size))\n+  if (!known_subrange_p (0, maxsizei, r->offset, r->size))\n     /* Continue looking for partial defs.  */\n     return NULL;\n \n   /* Now simply native encode all partial defs in reverse order.  */\n   unsigned ndefs = partial_defs.length ();\n   /* We support up to 512-bit values (for V8DFmode).  */\n-  unsigned char buffer[bufsize];\n+  unsigned char buffer[bufsize + 1];\n+  unsigned char this_buffer[bufsize + 1];\n   int len;\n \n+  memset (buffer, 0, bufsize + 1);\n+  unsigned needed_len = ROUND_UP (maxsizei, BITS_PER_UNIT) / BITS_PER_UNIT;\n   while (!partial_defs.is_empty ())\n     {\n       pd_data pd = partial_defs.pop ();\n-      gcc_checking_assert (pd.offset < bufsize);\n+      unsigned int amnt;\n       if (TREE_CODE (pd.rhs) == CONSTRUCTOR)\n-\t/* Empty CONSTRUCTOR.  */\n-\tmemset (buffer + MAX (0, pd.offset),\n-\t\t0, MIN (bufsize - MAX (0, pd.offset),\n-\t\t\tpd.size + MIN (0, pd.offset)));\n+\t{\n+\t  /* Empty CONSTRUCTOR.  */\n+\t  if (pd.size >= needed_len * BITS_PER_UNIT)\n+\t    len = needed_len;\n+\t  else\n+\t    len = ROUND_UP (pd.size, BITS_PER_UNIT) / BITS_PER_UNIT;\n+\t  memset (this_buffer, 0, len);\n+\t}\n       else\n \t{\n-\t  unsigned pad = 0;\n-\t  if (BYTES_BIG_ENDIAN\n-\t      && is_a <scalar_mode> (TYPE_MODE (TREE_TYPE (pd.rhs))))\n-\t    {\n-\t      /* On big-endian the padding is at the 'front' so just skip\n-\t\t the initial bytes.  */\n-\t      fixed_size_mode mode\n-\t\t= as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (pd.rhs)));\n-\t      pad = GET_MODE_SIZE (mode) - pd.size;\n-\t    }\n-\t  len = native_encode_expr (pd.rhs, buffer + MAX (0, pd.offset),\n-\t\t\t\t    bufsize - MAX (0, pd.offset),\n-\t\t\t\t    MAX (0, -pd.offset) + pad);\n-\t  if (len <= 0 || len < (pd.size - MAX (0, -pd.offset)))\n+\t  len = native_encode_expr (pd.rhs, this_buffer, bufsize,\n+\t\t\t\t    MAX (0, -pd.offset) / BITS_PER_UNIT);\n+\t  if (len <= 0\n+\t      || len < (ROUND_UP (pd.size, BITS_PER_UNIT) / BITS_PER_UNIT\n+\t\t\t- MAX (0, -pd.offset) / BITS_PER_UNIT))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"Failed to encode %u \"\n \t\t\t \"partial definitions\\n\", ndefs);\n \t      return (void *)-1;\n \t    }\n \t}\n+\n+      unsigned char *p = buffer;\n+      HOST_WIDE_INT size = pd.size;\n+      if (pd.offset < 0)\n+\tsize -= ROUND_DOWN (-pd.offset, BITS_PER_UNIT);\n+      this_buffer[len] = 0;\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  /* LSB of this_buffer[len - 1] byte should be at\n+\t     pd.offset + pd.size - 1 bits in buffer.  */\n+\t  amnt = ((unsigned HOST_WIDE_INT) pd.offset\n+\t\t  + pd.size) % BITS_PER_UNIT;\n+\t  if (amnt)\n+\t    shift_bytes_in_array_right (this_buffer, len + 1, amnt);\n+\t  unsigned char *q = this_buffer;\n+\t  unsigned int off = 0;\n+\t  if (pd.offset >= 0)\n+\t    {\n+\t      unsigned int msk;\n+\t      off = pd.offset / BITS_PER_UNIT;\n+\t      gcc_assert (off < needed_len);\n+\t      p = buffer + off;\n+\t      if (size <= amnt)\n+\t\t{\n+\t\t  msk = ((1 << size) - 1) << (BITS_PER_UNIT - amnt);\n+\t\t  *p = (*p & ~msk) | (this_buffer[len] & msk);\n+\t\t  size = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (TREE_CODE (pd.rhs) != CONSTRUCTOR)\n+\t\t    q = (this_buffer + len\n+\t\t\t - (ROUND_UP (size - amnt, BITS_PER_UNIT)\n+\t\t\t    / BITS_PER_UNIT));\n+\t\t  if (pd.offset % BITS_PER_UNIT)\n+\t\t    {\n+\t\t      msk = -1U << (BITS_PER_UNIT\n+\t\t\t\t    - (pd.offset % BITS_PER_UNIT));\n+\t\t      *p = (*p & msk) | (*q & ~msk);\n+\t\t      p++;\n+\t\t      q++;\n+\t\t      off++;\n+\t\t      size -= BITS_PER_UNIT - (pd.offset % BITS_PER_UNIT);\n+\t\t      gcc_assert (size >= 0);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (TREE_CODE (pd.rhs) != CONSTRUCTOR)\n+\t    {\n+\t      q = (this_buffer + len\n+\t\t   - (ROUND_UP (size - amnt, BITS_PER_UNIT)\n+\t\t      / BITS_PER_UNIT));\n+\t      if (pd.offset % BITS_PER_UNIT)\n+\t\t{\n+\t\t  q++;\n+\t\t  size -= BITS_PER_UNIT - ((unsigned HOST_WIDE_INT) pd.offset\n+\t\t\t\t\t   % BITS_PER_UNIT);\n+\t\t  gcc_assert (size >= 0);\n+\t\t}\n+\t    }\n+\t  if ((unsigned HOST_WIDE_INT) size / BITS_PER_UNIT + off\n+\t      > needed_len)\n+\t    size = (needed_len - off) * BITS_PER_UNIT;\n+\t  memcpy (p, q, size / BITS_PER_UNIT);\n+\t  if (size % BITS_PER_UNIT)\n+\t    {\n+\t      unsigned int msk\n+\t\t= -1U << (BITS_PER_UNIT - (size % BITS_PER_UNIT));\n+\t      p += size / BITS_PER_UNIT;\n+\t      q += size / BITS_PER_UNIT;\n+\t      *p = (*q & msk) | (*p & ~msk);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  size = MIN (size, (HOST_WIDE_INT) needed_len * BITS_PER_UNIT);\n+\t  if (pd.offset >= 0)\n+\t    {\n+\t      /* LSB of this_buffer[0] byte should be at pd.offset bits\n+\t\t in buffer.  */\n+\t      unsigned int msk;\n+\t      amnt = pd.offset % BITS_PER_UNIT;\n+\t      if (amnt)\n+\t\tshift_bytes_in_array_left (this_buffer, len + 1, amnt);\n+\t      unsigned int off = pd.offset / BITS_PER_UNIT;\n+\t      gcc_assert (off < needed_len);\n+\t      p = buffer + off;\n+\t      if (amnt + size < BITS_PER_UNIT)\n+\t\t{\n+\t\t  /* Low amnt bits come from *p, then size bits\n+\t\t     from this_buffer[0] and the remaining again from\n+\t\t     *p.  */\n+\t\t  msk = ((1 << size) - 1) << amnt;\n+\t\t  *p = (*p & ~msk) | (this_buffer[0] & msk);\n+\t\t  size = 0;\n+\t\t}\n+\t      else if (amnt)\n+\t\t{\n+\t\t  msk = -1U << amnt;\n+\t\t  *p = (*p & ~msk) | (this_buffer[0] & msk);\n+\t\t  p++;\n+\t\t  size -= (BITS_PER_UNIT - amnt);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      amnt = (unsigned HOST_WIDE_INT) pd.offset % BITS_PER_UNIT;\n+\t      if (amnt)\n+\t\tshift_bytes_in_array_left (this_buffer, len + 1, amnt);\n+\t    }\n+\t  memcpy (p, this_buffer + (amnt != 0), size / BITS_PER_UNIT);\n+\t  p += size / BITS_PER_UNIT;\n+\t  if (size % BITS_PER_UNIT)\n+\t    {\n+\t      unsigned int msk = -1U << (size % BITS_PER_UNIT);\n+\t      *p = (this_buffer[(amnt != 0) + size / BITS_PER_UNIT]\n+\t\t    & ~msk) | (*p & msk);\n+\t    }\n+\t}\n     }\n \n   tree type = vr->type;\n   /* Make sure to interpret in a type that has a range covering the whole\n      access size.  */\n   if (INTEGRAL_TYPE_P (vr->type) && maxsizei != TYPE_PRECISION (vr->type))\n     type = build_nonstandard_integer_type (maxsizei, TYPE_UNSIGNED (type));\n-  tree val = native_interpret_expr (type, buffer, maxsizei / BITS_PER_UNIT);\n+  tree val;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      unsigned sz = needed_len;\n+      if (maxsizei % BITS_PER_UNIT)\n+\tshift_bytes_in_array_right (buffer, needed_len,\n+\t\t\t\t    BITS_PER_UNIT\n+\t\t\t\t    - (maxsizei % BITS_PER_UNIT));\n+      if (INTEGRAL_TYPE_P (type))\n+\tsz = GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (type));\n+      if (sz > needed_len)\n+\t{\n+\t  memcpy (this_buffer + (sz - needed_len), buffer, needed_len);\n+\t  val = native_interpret_expr (type, this_buffer, sz);\n+\t}\n+      else\n+\tval = native_interpret_expr (type, buffer, needed_len);\n+    }\n+  else\n+    val = native_interpret_expr (type, buffer, bufsize);\n   /* If we chop off bits because the types precision doesn't match the memory\n      access size this is ok when optimizing reads but not when called from\n      the DSE code during elimination.  */\n@@ -2478,8 +2618,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t  tree val;\n \t  if (integer_zerop (gimple_call_arg (def_stmt, 1)))\n \t    val = build_zero_cst (vr->type);\n-\t  else if (INTEGRAL_TYPE_P (vr->type)\n-\t\t   && known_eq (ref->size, 8))\n+\t  else if (INTEGRAL_TYPE_P (vr->type) && known_eq (ref->size, 8))\n \t    {\n \t      gimple_match_op res_op (gimple_match_cond::UNCOND, NOP_EXPR,\n \t\t\t\t      vr->type, gimple_call_arg (def_stmt, 1));\n@@ -2491,11 +2630,11 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t    }\n \t  else\n \t    {\n-\t      unsigned len = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (vr->type));\n-\t      unsigned char *buf = XALLOCAVEC (unsigned char, len);\n+\t      unsigned buflen = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (vr->type));\n+\t      unsigned char *buf = XALLOCAVEC (unsigned char, buflen);\n \t      memset (buf, TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 1)),\n-\t\t      len);\n-\t      val = native_interpret_expr (vr->type, buf, len);\n+\t\t      buflen);\n+\t      val = native_interpret_expr (vr->type, buf, buflen);\n \t      if (!val)\n \t\treturn (void *)-1;\n \t    }\n@@ -2506,15 +2645,17 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t       && integer_zerop (gimple_call_arg (def_stmt, 1))\n \t       && tree_fits_poly_int64_p (len)\n \t       && tree_to_poly_int64 (len).is_constant (&leni)\n+\t       && leni <= INTTYPE_MAXIMUM (HOST_WIDE_INT) / BITS_PER_UNIT\n \t       && offset.is_constant (&offseti)\n \t       && offset2.is_constant (&offset2i)\n \t       && maxsize.is_constant (&maxsizei)\n-\t       && ranges_known_overlap_p (offseti, maxsizei, offset2i, leni))\n+\t       && ranges_known_overlap_p (offseti, maxsizei, offset2i,\n+\t\t\t\t\t  leni << LOG2_BITS_PER_UNIT))\n \t{\n \t  pd_data pd;\n \t  pd.rhs = build_constructor (NULL_TREE, NULL);\n-\t  pd.offset = (offset2i - offseti) / BITS_PER_UNIT;\n-\t  pd.size = leni;\n+\t  pd.offset = offset2i - offseti;\n+\t  pd.size = leni << LOG2_BITS_PER_UNIT;\n \t  return data->push_partial_def (pd, 0, maxsizei);\n \t}\n     }\n@@ -2558,13 +2699,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t    }\n \t  else if (known_eq (ref->size, maxsize)\n \t\t   && maxsize.is_constant (&maxsizei)\n-\t\t   && maxsizei % BITS_PER_UNIT == 0\n \t\t   && offset.is_constant (&offseti)\n-\t\t   && offseti % BITS_PER_UNIT == 0\n \t\t   && offset2.is_constant (&offset2i)\n-\t\t   && offset2i % BITS_PER_UNIT == 0\n \t\t   && size2.is_constant (&size2i)\n-\t\t   && size2i % BITS_PER_UNIT == 0\n \t\t   && ranges_known_overlap_p (offseti, maxsizei,\n \t\t\t\t\t      offset2i, size2i))\n \t    {\n@@ -2573,8 +2710,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t by a later def.  */\n \t      pd_data pd;\n \t      pd.rhs = gimple_assign_rhs1 (def_stmt);\n-\t      pd.offset = (offset2i - offseti) / BITS_PER_UNIT;\n-\t      pd.size = size2i / BITS_PER_UNIT;\n+\t      pd.offset = offset2i - offseti;\n+\t      pd.size = size2i;\n \t      return data->push_partial_def (pd, get_alias_set (lhs), maxsizei);\n \t    }\n \t}\n@@ -2719,19 +2856,15 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t}\n \t    }\n \t  else if (ranges_known_overlap_p (offseti, maxsizei, offset2i,\n-\t\t\t\t\t   size2i)\n-\t\t   && maxsizei % BITS_PER_UNIT == 0\n-\t\t   && offseti % BITS_PER_UNIT == 0\n-\t\t   && size2i % BITS_PER_UNIT == 0\n-\t\t   && offset2i % BITS_PER_UNIT == 0)\n+\t\t\t\t\t   size2i))\n \t    {\n \t      pd_data pd;\n \t      tree rhs = gimple_assign_rhs1 (def_stmt);\n \t      if (TREE_CODE (rhs) == SSA_NAME)\n \t\trhs = SSA_VAL (rhs);\n \t      pd.rhs = rhs;\n-\t      pd.offset = (offset2i - offseti) / BITS_PER_UNIT;\n-\t      pd.size = size2i / BITS_PER_UNIT;\n+\t      pd.offset = offset2i - offseti;\n+\t      pd.size = size2i;\n \t      return data->push_partial_def (pd, get_alias_set (lhs), maxsizei);\n \t    }\n \t}\n@@ -2803,19 +2936,15 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\treturn data->finish (get_alias_set (lhs), val);\n \t    }\n \t  else if (maxsize.is_constant (&maxsizei)\n-\t\t   && maxsizei % BITS_PER_UNIT == 0\n \t\t   && offset.is_constant (&offseti)\n-\t\t   && offseti % BITS_PER_UNIT == 0\n \t\t   && offset2.is_constant (&offset2i)\n-\t\t   && offset2i % BITS_PER_UNIT == 0\n \t\t   && size2.is_constant (&size2i)\n-\t\t   && size2i % BITS_PER_UNIT == 0\n \t\t   && ranges_known_overlap_p (offset, maxsize, offset2, size2))\n \t    {\n \t      pd_data pd;\n \t      pd.rhs = SSA_VAL (def_rhs);\n-\t      pd.offset = (offset2i - offseti) / BITS_PER_UNIT;\n-\t      pd.size = size2i / BITS_PER_UNIT;\n+\t      pd.offset = offset2i - offseti;\n+\t      pd.size = size2i;\n \t      return data->push_partial_def (pd, get_alias_set (lhs), maxsizei);\n \t    }\n \t}\n@@ -2945,14 +3074,14 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t     coming from targets that like to gimplify init-ctors as\n \t     aggregate copies from constant data like aarch64 for\n \t     PR83518.  */\n-\t  if (maxsize.is_constant (&maxsizei)\n-\t      && known_eq (ref->size, maxsize))\n+\t  if (maxsize.is_constant (&maxsizei) && known_eq (ref->size, maxsize))\n \t    {\n \t      pd_data pd;\n \t      pd.rhs = val;\n \t      pd.offset = 0;\n-\t      pd.size = maxsizei / BITS_PER_UNIT;\n-\t      return data->push_partial_def (pd, get_alias_set (lhs), maxsizei);\n+\t      pd.size = maxsizei;\n+\t      return data->push_partial_def (pd, get_alias_set (lhs),\n+\t\t\t\t\t     maxsizei);\n \t    }\n \t}\n "}]}