{"sha": "aa90c676b36ca5590e58f09cf3e256ac037aa9c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE5MGM2NzZiMzZjYTU1OTBlNThmMDljZjNlMjU2YWMwMzdhYTljMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2018-05-10T22:46:21Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-05-10T22:46:21Z"}, "message": "rs6000.c (mode_supports_dq_form): Rename mode_supports_vsx_dform_quad to mode_supports_dq_form.\n\n2018-05-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (mode_supports_dq_form): Rename\n\tmode_supports_vsx_dform_quad to mode_supports_dq_form.\n\t(mode_supports_vsx_dform_quad): Likewise.\n\t(mode_supports_vmx_dform): Move these functions to be next to the\n\tother mode_supports functions.\n\t(mode_supports_dq_form): Likewise.\n\t(quad_address_p): Change calls of mode_supports_vsx_dform_quad to\n\tmode_supports_dq_form.\n\t(reg_offset_addressing_ok_p): Likewise.\n\t(offsettable_ok_by_alignment): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(legitimate_lo_sum_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_legitimize_reload_address): Likewise.\n\t(rs6000_secondary_reload_inner): Likewise.\n\t(rs6000_preferred_reload_class): Likewise.\n\t(rs6000_output_move_128bit): Likewise.\n\nFrom-SVN: r260140", "tree": {"sha": "115044259bcdedc990bd04c96a3c3ffb770779a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/115044259bcdedc990bd04c96a3c3ffb770779a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa90c676b36ca5590e58f09cf3e256ac037aa9c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa90c676b36ca5590e58f09cf3e256ac037aa9c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa90c676b36ca5590e58f09cf3e256ac037aa9c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa90c676b36ca5590e58f09cf3e256ac037aa9c3/comments", "author": null, "committer": null, "parents": [{"sha": "14ee7de064f757c7677b906010f7e67e702b62c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ee7de064f757c7677b906010f7e67e702b62c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14ee7de064f757c7677b906010f7e67e702b62c7"}], "stats": {"total": 80, "additions": 50, "deletions": 30}, "files": [{"sha": "e5c1d8e7c92099775c385cb7592d95fd0166452f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa90c676b36ca5590e58f09cf3e256ac037aa9c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa90c676b36ca5590e58f09cf3e256ac037aa9c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa90c676b36ca5590e58f09cf3e256ac037aa9c3", "patch": "@@ -1,3 +1,23 @@\n+2018-05-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (mode_supports_dq_form): Rename\n+\tmode_supports_vsx_dform_quad to mode_supports_dq_form.\n+\t(mode_supports_vsx_dform_quad): Likewise.\n+\t(mode_supports_vmx_dform): Move these functions to be next to the\n+\tother mode_supports functions.\n+\t(mode_supports_dq_form): Likewise.\n+\t(quad_address_p): Change calls of mode_supports_vsx_dform_quad to\n+\tmode_supports_dq_form.\n+\t(reg_offset_addressing_ok_p): Likewise.\n+\t(offsettable_ok_by_alignment): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(legitimate_lo_sum_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_legitimize_reload_address): Likewise.\n+\t(rs6000_secondary_reload_inner): Likewise.\n+\t(rs6000_preferred_reload_class): Likewise.\n+\t(rs6000_output_move_128bit): Likewise.\n+\n 2018-05-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_expand_builtin) <case IX86_BUILTIN_RDPID>:"}, {"sha": "c5b3a1333189d26dbbde73f68a5679969e3b6903", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa90c676b36ca5590e58f09cf3e256ac037aa9c3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa90c676b36ca5590e58f09cf3e256ac037aa9c3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=aa90c676b36ca5590e58f09cf3e256ac037aa9c3", "patch": "@@ -553,6 +553,23 @@ mode_supports_pre_modify_p (machine_mode mode)\n \t  != 0);\n }\n \n+/* Return true if we have D-form addressing in altivec registers.  */\n+static inline bool\n+mode_supports_vmx_dform (machine_mode mode)\n+{\n+  return ((reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_OFFSET) != 0);\n+}\n+\n+/* Return true if we have D-form addressing in VSX registers.  This addressing\n+   is more limited than normal d-form addressing in that the offset must be\n+   aligned on a 16-byte boundary.  */\n+static inline bool\n+mode_supports_dq_form (machine_mode mode)\n+{\n+  return ((reg_addr[mode].addr_mask[RELOAD_REG_ANY] & RELOAD_REG_QUAD_OFFSET)\n+\t  != 0);\n+}\n+\n /* Given that there exists at least one variable that is set (produced)\n    by OUT_INSN and read (consumed) by IN_INSN, return true iff\n    IN_INSN represents one or more memory store operations and none of\n@@ -638,23 +655,6 @@ rs6000_store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n   return store_data_bypass_p (out_insn, in_insn);\n }\n \n-/* Return true if we have D-form addressing in altivec registers.  */\n-static inline bool\n-mode_supports_vmx_dform (machine_mode mode)\n-{\n-  return ((reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_OFFSET) != 0);\n-}\n-\n-/* Return true if we have D-form addressing in VSX registers.  This addressing\n-   is more limited than normal d-form addressing in that the offset must be\n-   aligned on a 16-byte boundary.  */\n-static inline bool\n-mode_supports_vsx_dform_quad (machine_mode mode)\n-{\n-  return ((reg_addr[mode].addr_mask[RELOAD_REG_ANY] & RELOAD_REG_QUAD_OFFSET)\n-\t  != 0);\n-}\n-\n \f\n /* Processor costs (relative to an add) */\n \n@@ -7878,7 +7878,7 @@ quad_address_p (rtx addr, machine_mode mode, bool strict)\n   if (legitimate_indirect_address_p (addr, strict))\n     return true;\n \n-  if (VECTOR_MODE_P (mode) && !mode_supports_vsx_dform_quad (mode))\n+  if (VECTOR_MODE_P (mode) && !mode_supports_dq_form (mode))\n     return false;\n \n   if (GET_CODE (addr) != PLUS)\n@@ -8060,7 +8060,7 @@ reg_offset_addressing_ok_p (machine_mode mode)\n \t IEEE 128-bit floating point that is passed in a single vector\n \t register.  */\n       if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n-\treturn mode_supports_vsx_dform_quad (mode);\n+\treturn mode_supports_dq_form (mode);\n       break;\n \n     case E_SDmode:\n@@ -8120,7 +8120,7 @@ offsettable_ok_by_alignment (rtx op, HOST_WIDE_INT offset,\n \n   /* ISA 3.0 vector d-form addressing is restricted, don't allow\n      SYMBOL_REF.  */\n-  if (mode_supports_vsx_dform_quad (mode))\n+  if (mode_supports_dq_form (mode))\n     return false;\n \n   dsize = GET_MODE_SIZE (mode);\n@@ -8291,7 +8291,7 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n-  if (mode_supports_vsx_dform_quad (mode))\n+  if (mode_supports_dq_form (mode))\n     return quad_address_p (x, mode, strict);\n   if (!reg_offset_addressing_ok_p (mode))\n     return virtual_stack_registers_memory_p (x);\n@@ -8404,7 +8404,7 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n   /* quad word addresses are restricted, and we can't use LO_SUM.  */\n-  if (mode_supports_vsx_dform_quad (mode))\n+  if (mode_supports_dq_form (mode))\n     return false;\n   x = XEXP (x, 1);\n \n@@ -8468,7 +8468,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   unsigned int extra;\n \n   if (!reg_offset_addressing_ok_p (mode)\n-      || mode_supports_vsx_dform_quad (mode))\n+      || mode_supports_dq_form (mode))\n     {\n       if (virtual_stack_registers_memory_p (x))\n \treturn x;\n@@ -9182,7 +9182,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \t\t\t\t  int ind_levels ATTRIBUTE_UNUSED, int *win)\n {\n   bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n-  bool quad_offset_p = mode_supports_vsx_dform_quad (mode);\n+  bool quad_offset_p = mode_supports_dq_form (mode);\n \n   /* Nasty hack for vsx_splat_v2df/v2di load from mem, which takes a\n      DFmode/DImode MEM.  Ditto for ISA 3.0 vsx_splat_v4sf/v4si.  */\n@@ -9468,7 +9468,7 @@ static bool\n rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n {\n   bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n-  bool quad_offset_p = mode_supports_vsx_dform_quad (mode);\n+  bool quad_offset_p = mode_supports_dq_form (mode);\n \n   /* If this is an unaligned stvx/ldvx type address, discard the outer AND.  */\n   if (VECTOR_MEM_ALTIVEC_P (mode)\n@@ -19562,7 +19562,7 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t    }\n \t}\n \n-      else if (mode_supports_vsx_dform_quad (mode) && CONST_INT_P (op1))\n+      else if (mode_supports_dq_form (mode) && CONST_INT_P (op1))\n \t{\n \t  if (((addr_mask & RELOAD_REG_QUAD_OFFSET) == 0)\n \t      || !quad_address_p (addr, mode, false))\n@@ -19603,7 +19603,7 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t}\n \n       /* Quad offsets are restricted and can't handle normal addresses.  */\n-      else if (mode_supports_vsx_dform_quad (mode))\n+      else if (mode_supports_dq_form (mode))\n \t{\n \t  emit_insn (gen_rtx_SET (scratch, addr));\n \t  new_addr = scratch;\n@@ -19798,7 +19798,7 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n \n       /* D-form addressing can easily reload the value.  */\n       if (mode_supports_vmx_dform (mode)\n-\t  || mode_supports_vsx_dform_quad (mode))\n+\t  || mode_supports_dq_form (mode))\n \treturn rclass;\n \n       /* If this is a scalar floating point value and we don't have D-form\n@@ -20201,7 +20201,7 @@ rs6000_output_move_128bit (rtx operands[])\n \n       else if (TARGET_VSX && dest_vsx_p)\n \t{\n-\t  if (mode_supports_vsx_dform_quad (mode)\n+\t  if (mode_supports_dq_form (mode)\n \t      && quad_address_p (XEXP (src, 0), mode, true))\n \t    return \"lxv %x0,%1\";\n \n@@ -20239,7 +20239,7 @@ rs6000_output_move_128bit (rtx operands[])\n \n       else if (TARGET_VSX && src_vsx_p)\n \t{\n-\t  if (mode_supports_vsx_dform_quad (mode)\n+\t  if (mode_supports_dq_form (mode)\n \t      && quad_address_p (XEXP (dest, 0), mode, true))\n \t    return \"stxv %x1,%0\";\n "}]}