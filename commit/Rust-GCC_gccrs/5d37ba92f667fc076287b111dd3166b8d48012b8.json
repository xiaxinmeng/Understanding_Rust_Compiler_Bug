{"sha": "5d37ba92f667fc076287b111dd3166b8d48012b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQzN2JhOTJmNjY3ZmMwNzYyODdiMTExZGQzMTY2YjhkNDgwMTJiOA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:38:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:38:20Z"}, "message": "einfo.ads, einfo.adb: Create a limited view of an incomplete type...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* einfo.ads, einfo.adb: Create a limited view of an incomplete type,\n\tto make treatment of limited views uniform for all visible declarations\n\tin a limited_withed package.\n\tImprove warnings for in out parameters\n\t(Set_Related_Interaface/Related_Interface): Allow the use of this\n\tattribute with constants.\n\t(Write_Field26_Name): Handle attribute Related_Interface in constants.\n\tWarn on duplicate pragma Preelaborable_Initialialization\n\n\t* sem_ch6.ads, sem_ch6.adb (Analyze_Subprogram_Body): Force the\n\tgeneration of a freezing node to ensure proper management of null\n\texcluding access types in the backend.\n\t(Create_Extra_Formals): Test base type of the formal when checking for\n\tthe need to add an extra accessibility-level formal. Pass the entity E\n\ton all calls to Add_Extra_Formal (rather than Scope (Formal) as was\n\toriginally being done in a couple of cases), to ensure that the\n\tExtra_Formals list gets set on the entity E when the first entity is\n\tadded.\n\t(Conforming_Types): Add missing calls to Base_Type to the code that\n\thandles anonymous access types. This is required to handle the\n\tgeneral case because Process_Formals builds internal subtype entities\n\tto handle null-excluding access types.\n\t(Make_Controlling_Function_Wrappers): Create wrappers for constructor\n\tfunctions that need it, even when not marked Requires_Overriding.\n\tImprove warnings for in out parameters\n\t(Analyze_Function_Return): Warn for disallowed null return\n\tWarn on return from procedure with unset out parameter\n\tEnsure consistent use of # in error messages\n\t(Check_Overriding_Indicator): Add in parameter Is_Primitive.\n\t(Analyze_Function_Return): Move call to Apply_Constraint_Check before\n\tthe implicit conversion of the expression done for anonymous access\n\ttypes. This is required to generate the code of the null excluding\n\tcheck (if required).\n\n\t* sem_warn.ads, sem_warn.adb (Check_References.Publicly_Referenceable):\n\tA formal parameter is never publicly referenceable outside of its body.\n\t(Check_References): For an unreferenced formal parameter in an accept\n\tstatement, use the same warning circuitry as for subprogram formal\n\tparameters.\n\t(Warn_On_Unreferenced_Entity): New subprogram, taken from\n\tOutput_Unreferenced_Messages, containing the part of that routine that\n\tis now reused for entry formals as described above.\n\t(Goto_Spec_Entity): New function\n\t(Check_References): Do not give IN OUT warning for dispatching operation\n\tImprove warnings for in out parameters\n\t(Test_Ref): Check that the entity is not undefinite before calling\n\tScope_Within, in order to avoid infinite loops.\n\tWarn on return from procedure with unset out parameter\n\tImproved warnings for unused variables\n\nFrom-SVN: r127415", "tree": {"sha": "4d387c15f40b2718d420ab1768d7ccccf1af12ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d387c15f40b2718d420ab1768d7ccccf1af12ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d37ba92f667fc076287b111dd3166b8d48012b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d37ba92f667fc076287b111dd3166b8d48012b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d37ba92f667fc076287b111dd3166b8d48012b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d37ba92f667fc076287b111dd3166b8d48012b8/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b99282c4c10fcb8fb8a5cf30736e5b8a1a4e3cec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99282c4c10fcb8fb8a5cf30736e5b8a1a4e3cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b99282c4c10fcb8fb8a5cf30736e5b8a1a4e3cec"}], "stats": {"total": 1236, "additions": 740, "deletions": 496}, "files": [{"sha": "035cca141e036a2dae63d77d4a4db4a0aa8ece0c", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 115, "deletions": 18, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=5d37ba92f667fc076287b111dd3166b8d48012b8", "patch": "@@ -474,15 +474,12 @@ package body Einfo is\n    --    Has_Up_Level_Access             Flag215\n    --    Universal_Aliasing              Flag216\n    --    Suppress_Value_Tracking_On_Call Flag217\n+   --    Is_Primitive                    Flag218\n+   --    Has_Initial_Value               Flag219\n+   --    Has_Dispatch_Table              Flag220\n \n-   --    (unused)                        Flag77\n-\n-   --    (unused)                        Flag218\n-   --    (unused)                        Flag219\n-   --    (unused)                        Flag220\n-\n-   --    (unused)                        Flag221\n-   --    (unused)                        Flag222\n+   --    Has_Pragma_Preelab_Init         Flag221\n+   --    Used_As_Generic_Actual          Flag222\n    --    (unused)                        Flag223\n    --    (unused)                        Flag224\n    --    (unused)                        Flag225\n@@ -1194,6 +1191,12 @@ package body Einfo is\n       return Flag5 (Id);\n    end Has_Discriminants;\n \n+   function Has_Dispatch_Table (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Tagged_Type (Id));\n+      return Flag220 (Id);\n+   end Has_Dispatch_Table;\n+\n    function Has_Enumeration_Rep_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n@@ -1231,6 +1234,13 @@ package body Einfo is\n       return Flag56 (Id);\n    end Has_Homonym;\n \n+   function Has_Initial_Value (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Variable or else Is_Formal (Id));\n+      return Flag219 (Id);\n+   end Has_Initial_Value;\n+\n    function Has_Machine_Radix_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Decimal_Fixed_Point_Type (Id));\n@@ -1297,6 +1307,11 @@ package body Einfo is\n       return Flag121 (Implementation_Base_Type (Id));\n    end Has_Pragma_Pack;\n \n+   function Has_Pragma_Preelab_Init (Id : E) return B is\n+   begin\n+      return Flag221 (Id);\n+   end Has_Pragma_Preelab_Init;\n+\n    function Has_Pragma_Pure (Id : E) return B is\n    begin\n       return Flag203 (Id);\n@@ -1830,6 +1845,15 @@ package body Einfo is\n       return Flag59 (Id);\n    end Is_Preelaborated;\n \n+   function Is_Primitive (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Is_Overloadable (Id)\n+         or else Ekind (Id) = E_Generic_Function\n+         or else Ekind (Id) = E_Generic_Procedure);\n+      return Flag218 (Id);\n+   end Is_Primitive;\n+\n    function Is_Primitive_Wrapper (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -2297,7 +2321,8 @@ package body Einfo is\n \n    function Related_Interface (Id : E) return E is\n    begin\n-      pragma Assert (Ekind (Id) = E_Component);\n+      pragma Assert\n+        (Ekind (Id) = E_Component or else Ekind (Id) = E_Constant);\n       return Node26 (Id);\n    end Related_Interface;\n \n@@ -2506,6 +2531,11 @@ package body Einfo is\n       return Node16 (Id);\n    end Unset_Reference;\n \n+   function Used_As_Generic_Actual (Id : E) return B is\n+   begin\n+      return Flag222 (Id);\n+   end Used_As_Generic_Actual;\n+\n    function Uses_Sec_Stack (Id : E) return B is\n    begin\n       return Flag95 (Id);\n@@ -3428,6 +3458,13 @@ package body Einfo is\n       Set_Flag5 (Id, V);\n    end Set_Has_Discriminants;\n \n+   procedure Set_Has_Dispatch_Table (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Record_Type\n+        and then Is_Tagged_Type (Id));\n+      Set_Flag220 (Id, V);\n+   end Set_Has_Dispatch_Table;\n+\n    procedure Set_Has_Enumeration_Rep_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n@@ -3465,6 +3502,13 @@ package body Einfo is\n       Set_Flag56 (Id, V);\n    end Set_Has_Homonym;\n \n+   procedure Set_Has_Initial_Value (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Variable or else Ekind (Id) = E_Out_Parameter);\n+      Set_Flag219 (Id, V);\n+   end Set_Has_Initial_Value;\n+\n    procedure Set_Has_Machine_Radix_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Decimal_Fixed_Point_Type (Id));\n@@ -3542,6 +3586,11 @@ package body Einfo is\n       Set_Flag121 (Id, V);\n    end Set_Has_Pragma_Pack;\n \n+   procedure Set_Has_Pragma_Preelab_Init (Id : E; V : B := True) is\n+   begin\n+      Set_Flag221 (Id, V);\n+   end Set_Has_Pragma_Preelab_Init;\n+\n    procedure Set_Has_Pragma_Pure (Id : E; V : B := True) is\n    begin\n       Set_Flag203 (Id, V);\n@@ -4097,6 +4146,15 @@ package body Einfo is\n       Set_Flag59 (Id, V);\n    end Set_Is_Preelaborated;\n \n+   procedure Set_Is_Primitive (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Is_Overloadable (Id)\n+         or else Ekind (Id) = E_Generic_Function\n+         or else Ekind (Id) = E_Generic_Procedure);\n+      Set_Flag218 (Id, V);\n+   end Set_Is_Primitive;\n+\n    procedure Set_Is_Primitive_Wrapper (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -4574,7 +4632,8 @@ package body Einfo is\n \n    procedure Set_Related_Interface (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Component);\n+      pragma Assert\n+        (Ekind (Id) = E_Component or else Ekind (Id) = E_Constant);\n       Set_Node26 (Id, V);\n    end Set_Related_Interface;\n \n@@ -4793,6 +4852,11 @@ package body Einfo is\n       Set_Flag95 (Id, V);\n    end Set_Uses_Sec_Stack;\n \n+   procedure Set_Used_As_Generic_Actual (Id : E; V : B := True) is\n+   begin\n+      Set_Flag222 (Id, V);\n+   end Set_Used_As_Generic_Actual;\n+\n    procedure Set_Vax_Float (Id : E; V : B := True) is\n    begin\n       pragma Assert (Id = Base_Type (Id));\n@@ -4918,7 +4982,7 @@ package body Einfo is\n    begin\n       Set_Uint8  (Id, No_Uint);  -- Normalized_First_Bit\n       Set_Uint10 (Id, No_Uint);  -- Normalized_Position_Max\n-      Set_Uint11 (Id, No_Uint);  -- Component_First_Bit\n+      Set_Uint11 (Id, No_Uint);  -- Component_Bit_Offset\n       Set_Uint12 (Id, Uint_0);   -- Esize\n       Set_Uint14 (Id, No_Uint);  -- Normalized_Position\n    end Init_Component_Location;\n@@ -5161,7 +5225,10 @@ package body Einfo is\n       if Is_Incomplete_Type (Id)\n         and then Present (Non_Limited_View (Id))\n       then\n-         return Non_Limited_View (Id);\n+         --  The non-limited view may itself be an incomplete type, in\n+         --  which case get its full view.\n+\n+         return Get_Full_View (Non_Limited_View (Id));\n \n       elsif Is_Class_Wide_Type (Id)\n         and then Is_Incomplete_Type (Etype (Id))\n@@ -5327,7 +5394,6 @@ package body Einfo is\n             P := Parent (P);\n          end if;\n       end loop;\n-\n    end Declaration_Node;\n \n    ---------------------\n@@ -5681,6 +5747,28 @@ package body Einfo is\n       return Empty;\n    end Get_Attribute_Definition_Clause;\n \n+   -------------------\n+   -- Get_Full_View --\n+   -------------------\n+\n+   function Get_Full_View (T : Entity_Id) return Entity_Id is\n+   begin\n+      if Ekind (T) = E_Incomplete_Type\n+        and then Present (Full_View (T))\n+      then\n+         return Full_View (T);\n+\n+      elsif Is_Class_Wide_Type (T)\n+        and then Ekind (Root_Type (T)) = E_Incomplete_Type\n+        and then Present (Full_View (Root_Type (T)))\n+      then\n+         return Class_Wide_Type (Full_View (Root_Type (T)));\n+\n+      else\n+         return T;\n+      end if;\n+   end Get_Full_View;\n+\n    --------------------\n    -- Get_Rep_Pragma --\n    --------------------\n@@ -6565,6 +6653,11 @@ package body Einfo is\n       elsif Ekind (T) = E_Class_Wide_Subtype then\n          return Etype (Base_Type (T));\n \n+         --  ??? T comes from Base_Type, how can it be a subtype?\n+         --  Also Base_Type is supposed to be idempotent, so either way\n+         --  this is equivalent to \"return Etype (T)\" and should be merged\n+         --  with the E_Class_Wide_Type case.\n+\n       --  All other cases\n \n       else\n@@ -7007,6 +7100,7 @@ package body Einfo is\n       W (\"Has_Fully_Qualified_Name\",        Flag173 (Id));\n       W (\"Has_Gigi_Rep_Item\",               Flag82  (Id));\n       W (\"Has_Homonym\",                     Flag56  (Id));\n+      W (\"Has_Initial_Value\",               Flag219 (Id));\n       W (\"Has_Machine_Radix_Clause\",        Flag83  (Id));\n       W (\"Has_Master_Entity\",               Flag21  (Id));\n       W (\"Has_Missing_Return\",              Flag142 (Id));\n@@ -7019,6 +7113,7 @@ package body Einfo is\n       W (\"Has_Pragma_Elaborate_Body\",       Flag150 (Id));\n       W (\"Has_Pragma_Inline\",               Flag157 (Id));\n       W (\"Has_Pragma_Pack\",                 Flag121 (Id));\n+      W (\"Has_Pragma_Preelab_Init\",         Flag221 (Id));\n       W (\"Has_Pragma_Pure\",                 Flag203 (Id));\n       W (\"Has_Pragma_Pure_Function\",        Flag179 (Id));\n       W (\"Has_Pragma_Unreferenced\",         Flag180 (Id));\n@@ -7172,8 +7267,10 @@ package body Einfo is\n       W (\"Suppress_Init_Proc\",              Flag105 (Id));\n       W (\"Suppress_Style_Checks\",           Flag165 (Id));\n       W (\"Suppress_Value_Tracking_On_Call\", Flag217 (Id));\n+      W (\"Is_Primitive\",                    Flag218 (Id));\n       W (\"Treat_As_Volatile\",               Flag41  (Id));\n       W (\"Universal_Aliasing\",              Flag216 (Id));\n+      W (\"Used_As_Generic_Actual\",          Flag222 (Id));\n       W (\"Uses_Sec_Stack\",                  Flag95  (Id));\n       W (\"Vax_Float\",                       Flag151 (Id));\n       W (\"Warnings_Off\",                    Flag96  (Id));\n@@ -7741,9 +7838,9 @@ package body Einfo is\n       end case;\n    end Write_Field17_Name;\n \n-   -----------------------\n+   ------------------------\n    -- Write_Field18_Name --\n-   -----------------------\n+   ------------------------\n \n    procedure Write_Field18_Name (Id : Entity_Id) is\n    begin\n@@ -7770,8 +7867,7 @@ package body Einfo is\n          when Fixed_Point_Kind                             =>\n             Write_Str (\"Delta_Value\");\n \n-         when E_Constant                                   |\n-              E_Variable                                   =>\n+         when Object_Kind                                  =>\n             Write_Str (\"Renamed_Object\");\n \n          when E_Exception                                  |\n@@ -8114,7 +8210,8 @@ package body Einfo is\n    procedure Write_Field26_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Component                                  =>\n+         when E_Component                                  |\n+              E_Constant                                   =>\n             Write_Str (\"Related_Interface\");\n \n          when E_Generic_Package                            |"}, {"sha": "234caab9ef61d19beaa49ad1246ee6659728aedd", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 106, "deletions": 26, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=5d37ba92f667fc076287b111dd3166b8d48012b8", "patch": "@@ -193,7 +193,7 @@ package Einfo is\n --    Object_Size of this first-named subtype to the given value padded up\n --    to an appropriate boundary. It is a consequence of the default rules\n --    above that this Object_Size will apply to all further subtypes. On the\n---    otyher hand, Value_Size is affected only for the first subtype, any\n+--    other hand, Value_Size is affected only for the first subtype, any\n --    dynamic subtypes obtained from it directly, and any statically matching\n --    subtypes. The Value_Size of any other static subtypes is not affected.\n \n@@ -245,6 +245,10 @@ package Einfo is\n --  and Value_Size are the same (and equivalent to the RM attribute Size).\n --  Only Size may be specified for such types.\n \n+--  All size attributes are stored as Uint values. Negative values are used to\n+--  reference GCC expressions for the case of non-static sizes, as explained\n+--  in Repinfo.\n+\n -----------------------\n -- Entity Attributes --\n -----------------------\n@@ -347,7 +351,8 @@ package Einfo is\n --       Present in all entities. Set if the Address or Unrestricted_Access\n --       attribute is applied directly to the entity, i.e. the entity is the\n --       entity of the prefix of the attribute reference. Used by Gigi to\n---       make sure that the address can be meaningfully taken.\n+--       make sure that the address can be meaningfully taken, and also in\n+--       the case of subprograms to control output of certain warnings.\n \n --    Alias (Node18)\n --       Present in overloaded entities (literals, subprograms, entries) and\n@@ -1388,6 +1393,14 @@ package Einfo is\n --       and incomplete types), indicates if the corresponding type or subtype\n --       has a known discriminant part. Always false for all other types.\n \n+--    Has_Dispatch_Table (Flag220)\n+--       Present in E_Record_Types that are tagged. Set to indicate that the\n+--       corresponding dispatch table is already built. This flag is used to\n+--       avoid duplicate construction of library level dispatch tables (because\n+--       the declaration of library level objects cause premature construction\n+--       of the table); otherwise the code that builds the table is added at\n+--       the end of the list of declarations of the package.\n+\n --    Has_Entries (synthesized)\n --       Applies to concurrent types. True if any entries are declared\n --       within the task or protected definition for the type.\n@@ -1446,7 +1459,16 @@ package Einfo is\n --    Has_Homonym (Flag56)\n --       Present in all entities. Set if an entity has a homonym in the same\n --       scope. Used by Gigi to generate unique names for such entities.\n-\n+--\n+--    Has_Initial_Value (Flag219)\n+--       Present in entities for variables and out parameters. Set if there\n+--       is an explicit initial value expression in the declaration of the\n+--       variable. Note that this is set only if this initial value is\n+--       explicit, it is not set for the case of implicit initialization\n+--       of access types or controlled types. Always set to False for out\n+--       parameters. Also present in entities for in and in-out parameters,\n+--       but always false in these cases.\n+--\n --    Has_Interrupt_Handler (synthesized)\n --       Applies to all protected type entities. Set if the protected type\n --       definition contains at least one procedure to which a pragma\n@@ -1546,6 +1568,10 @@ package Einfo is\n --       was given for the entity. In some cases, we need to test whether\n --       Is_Pure was explicitly set using this pragma.\n \n+--    Has_Pragma_Preelab_Init (Flag221)\n+--       Present in type and subtype entities. If set indicates that a valid\n+--       pragma Preelaborable_Initialization applies to the type.\n+\n --    Has_Pragma_Pure_Function (Flag179)\n --       Present in all entities. If set, indicates that a valid pragma\n --       Pure_Function was given for the entity. In some cases, we need to\n@@ -2144,9 +2170,12 @@ package Einfo is\n --    Is_Internal (Flag17)\n --       Present in all entities. Set to indicate an entity created during\n --       semantic processing (e.g. an implicit type, or a temporary). The\n---       only current use of this flag is to indicate that temporaries\n+--       current uses of this flag are: 1) to indicate that temporaries\n --       generated for the result of an inlined function call need not be\n---       initialized, even when scalars are initialized or normalized.\n+--       initialized, even when scalars are initialized or normalized, and\n+--       2) to indicate object declarations generated by the expander that are\n+--       implicitly imported or exported, so that they can be appropriately\n+--       marked in Sprint output.\n \n --    Is_Interrupt_Handler (Flag89)\n --       Present in procedures. Set if a pragma Interrupt_Handler applies\n@@ -2388,6 +2417,12 @@ package Einfo is\n --       flag is set does not necesarily mean that no elaboration code is\n --       generated for the package.\n \n+--    Is_Primitive (Flag218)\n+--       Present in overloadable entities and in generic subprograms. Set to\n+--       indicate that this is a primitive operation of some type, which may be\n+--       a tagged type or a non-tagged type. Used to verify overriding\n+--       indicators in bodies.\n+\n --    Is_Primitive_Wrapper (Flag195)\n --       Present in E_Procedures. Primitive wrappers are Expander-generated\n --       procedures that wrap entries of protected or task types implementing\n@@ -2757,13 +2792,15 @@ package Einfo is\n --       entities when the return type is an array type, and a call can be\n --       interpreted as an indexing of the result of the call. It is also\n --       used to resolve various cases of entry calls.\n-\n+--\n --    Never_Set_In_Source (Flag115)\n --       Present in all entities, but relevant only for variables and\n---       parameters. This flag is set if the object is never assigned\n---       a value in user source code, either by assignment or by the\n---       use of an initial value, or by some other means.\n-\n+--       parameters. This flag is set if the object is never assigned a value\n+--       in user source code, either by assignment or by being used as an out\n+--       or in out parameter. Note that this flag is not reset from using an\n+--       initial value, so if you want to test for this case as well, test the\n+--       Has_Initial_Value flag also.\n+--\n --       This flag is only for the purposes of issuing warnings, it must not\n --       be used by the code generator to indicate that the variable is in\n --       fact a constant, since some assignments in generated code do not\n@@ -3095,15 +3132,15 @@ package Einfo is\n \n --    Referenced (Flag156)\n --       Present in all entities, set if the entity is referenced, except\n---       for the case of an appearence of a simple variable that is not a\n+--       for the case of an appearence of a simple variable, that is not a\n --       renaming, as the left side of an assignment in which case the flag\n --       Referenced_As_LHS is set instead.\n \n---    Referenced_As_LHS (Flag36): This flag is set instead of\n---       Referenced if a simple variable that is not a renaming appears as\n---       the left side of an assignment. The reason we distinguish this kind\n---       of reference is that we have a separate warning for variables that\n---       are only assigned and never read.\n+--    Referenced_As_LHS (Flag36):\n+--       This flag is set instead of Referenced if a simple variable that is\n+--       not a renaming appears as the left side of an assignment. The reason\n+--       we distinguish this kind of reference is that we have a separate\n+--       warning for variables that are only assigned and never read.\n \n --    Referenced_Object (Node10)\n --       Present in all type entities. Set non-Empty only for type entities\n@@ -3132,9 +3169,8 @@ package Einfo is\n --       must correspond to the name and scope of the related instance.\n \n --    Related_Interface (Node26)\n---       Present in components associated with secondary dispatch tables\n---       (dispatch table pointers and offset components). Set to point to the\n---       entity of the corresponding interface type.\n+--       Present in components and constants associated with dispatch tables.\n+--       Set to point to the entity of the associated interface type.\n \n --    Renamed_Entity (Node18)\n --       Present in exceptions, packages, subprograms and generic units. Set\n@@ -3144,15 +3180,16 @@ package Einfo is\n \n --    Renamed_Object (Node18)\n --       Present in all objects (constants, variables, components, formal\n---       parameters, generic formal parameters, and loop parameters). Set\n---       non-Empty if the object was declared by a renaming declaration, in\n---       which case it references the tree node for the name of the renamed\n+--       parameters, generic formal parameters, and loop parameters).\n+--       ??? Present in discriminants?\n+--       Set non-Empty if the object was declared by a renaming declaration,\n+--       in which case it references the tree node for the name of the renamed\n --       object. This is only possible for the variable and constant cases.\n --       For formal parameters, this field is used in the course of inline\n --       expansion, to map the formals of a subprogram into the corresponding\n --       actuals. For formals of a task entry, it denotes the local renaming\n---       that replaces the actual within the accept statement.\n---       The field is Empty otherwise.\n+--       that replaces the actual within the accept statement. The field is\n+--       Empty otherwise (it is always empty for loop parameters).\n \n --    Renaming_Map (Uint9)\n --       Present in generic subprograms, generic packages, and their\n@@ -3474,6 +3511,10 @@ package Einfo is\n --       is identified. This field is used to generate a warning message if\n --       necessary (see Sem_Warn.Check_Unset_Reference).\n \n+--    Used_As_Generic_Actual (Flag222)\n+--       Present in all entities, set if the entity is used as an argument to\n+--       a generic instantiation. Used to tune certain warning messages.\n+\n --    Uses_Sec_Stack (Flag95)\n --       Present in scope entities (blocks,functions, procedures, tasks,\n --       entries). Set to True when secondary stack is used in this scope and\n@@ -4085,7 +4126,7 @@ package Einfo is\n    subtype Formal_Kind                 is Entity_Kind range\n        E_In_Parameter ..\n    --  E_Out_Parameter\n-     E_In_Out_Parameter;\n+       E_In_Out_Parameter;\n \n    subtype Formal_Object_Kind          is Entity_Kind range\n        E_Generic_In_Out_Parameter ..\n@@ -4364,6 +4405,7 @@ package Einfo is\n    --    Suppress_Elaboration_Warnings       (Flag148)\n    --    Suppress_Style_Checks               (Flag165)\n    --    Suppress_Value_Tracking_On_Call     (Flag217)\n+   --    Used_As_Generic_Actual              (Flag222)\n    --    Was_Hidden                          (Flag196)\n \n    --    Declaration_Node                    (synth)\n@@ -4400,6 +4442,7 @@ package Einfo is\n    --    Has_Discriminants                   (Flag5)\n    --    Has_Non_Standard_Rep                (Flag75)   (base type only)\n    --    Has_Object_Size_Clause              (Flag172)\n+   --    Has_Pragma_Preelab_Init             (Flag221)\n    --    Has_Pragma_Unreferenced_Objects     (Flag212)\n    --    Has_Primitive_Operations            (Flag120)  (base type only)\n    --    Has_Size_Clause                     (Flag29)\n@@ -4587,15 +4630,16 @@ package Einfo is\n    --    Actual_Subtype                      (Node17)\n    --    Renamed_Object                      (Node18)\n    --    Size_Check_Code                     (Node19)   (constants only)\n-   --    In_Private_Part                     (Flag45)\n    --    Interface_Name                      (Node21)\n+   --    Related_Interface                   (Node26)   (constants only)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Completion                      (Flag26)   (constants only)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Up_Level_Access                 (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n+   --    In_Private_Part                     (Flag45)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_True_Constant                    (Flag163)\n@@ -4763,6 +4807,7 @@ package Einfo is\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n    --    Is_Overriding_Operation             (Flag39)   (non-generic case only)\n+   --    Is_Primitive                        (Flag218)\n    --    Is_Private_Descendant               (Flag53)\n    --    Is_Pure                             (Flag44)\n    --    Is_Visible_Child_Unit               (Flag116)\n@@ -4828,6 +4873,7 @@ package Einfo is\n    --    Default_Expr_Function               (Node21)\n    --    Protected_Formal                    (Node22)\n    --    Extra_Constrained                   (Node23)\n+   --    Has_Initial_Value                   (Flag219)\n    --    Is_Controlling_Formal               (Flag97)\n    --    Is_Entry_Formal                     (Flag52)\n    --    Is_Optional_Parameter               (Flag134)\n@@ -4884,6 +4930,7 @@ package Einfo is\n    --    Is_Pure                             (Flag44)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Overriding_Operation             (Flag39)\n+   --    Is_Primitive                        (Flag218)\n    --    Default_Expressions_Processed       (Flag108)\n \n    --  E_Ordinary_Fixed_Point_Type\n@@ -5018,6 +5065,7 @@ package Einfo is\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc                   (Flag178)\n    --    Is_Overriding_Operation             (Flag39)   (non-generic case only)\n+   --    Is_Primitive                        (Flag218)\n    --    Is_Primitive_Wrapper                (Flag195)  (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n    --    Is_Pure                             (Flag44)\n@@ -5073,6 +5121,7 @@ package Einfo is\n    --    Abstract_Interfaces                 (Elist25)\n    --    Component_Alignment                 (special)  (base type only)\n    --    C_Pass_By_Copy                      (Flag125)  (base type only)\n+   --    Has_Dispatch_Table                  (Flag220)  (base tagged type only)\n    --    Has_External_Tag_Rep_Clause         (Flag110)\n    --    Has_Record_Rep_Clause               (Flag65)   (base type only)\n    --    Has_Static_Discriminants            (Flag211)  (subtype only)\n@@ -5204,6 +5253,7 @@ package Einfo is\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n+   --    Has_Initial_Value                   (Flag219)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Volatile_Components             (Flag87)\n    --    In_Private_Part                     (Flag45)\n@@ -5562,12 +5612,14 @@ package Einfo is\n    function Has_Convention_Pragma               (Id : E) return B;\n    function Has_Delayed_Freeze                  (Id : E) return B;\n    function Has_Discriminants                   (Id : E) return B;\n+   function Has_Dispatch_Table                  (Id : E) return B;\n    function Has_Enumeration_Rep_Clause          (Id : E) return B;\n    function Has_Exit                            (Id : E) return B;\n    function Has_External_Tag_Rep_Clause         (Id : E) return B;\n    function Has_Fully_Qualified_Name            (Id : E) return B;\n    function Has_Gigi_Rep_Item                   (Id : E) return B;\n    function Has_Homonym                         (Id : E) return B;\n+   function Has_Initial_Value                   (Id : E) return B;\n    function Has_Interrupt_Handler               (Id : E) return B;\n    function Has_Machine_Radix_Clause            (Id : E) return B;\n    function Has_Master_Entity                   (Id : E) return B;\n@@ -5583,6 +5635,7 @@ package Einfo is\n    function Has_Pragma_Elaborate_Body           (Id : E) return B;\n    function Has_Pragma_Inline                   (Id : E) return B;\n    function Has_Pragma_Pack                     (Id : E) return B;\n+   function Has_Pragma_Preelab_Init             (Id : E) return B;\n    function Has_Pragma_Pure                     (Id : E) return B;\n    function Has_Pragma_Pure_Function            (Id : E) return B;\n    function Has_Pragma_Unreferenced             (Id : E) return B;\n@@ -5673,6 +5726,7 @@ package Einfo is\n    function Is_Packed_Array_Type                (Id : E) return B;\n    function Is_Potentially_Use_Visible          (Id : E) return B;\n    function Is_Preelaborated                    (Id : E) return B;\n+   function Is_Primitive                        (Id : E) return B;\n    function Is_Primitive_Wrapper                (Id : E) return B;\n    function Is_Private_Composite                (Id : E) return B;\n    function Is_Private_Descendant               (Id : E) return B;\n@@ -5790,6 +5844,7 @@ package Einfo is\n    function Underlying_Full_View                (Id : E) return E;\n    function Universal_Aliasing                  (Id : E) return B;\n    function Unset_Reference                     (Id : E) return N;\n+   function Used_As_Generic_Actual              (Id : E) return B;\n    function Uses_Sec_Stack                      (Id : E) return B;\n    function Vax_Float                           (Id : E) return B;\n    function Warnings_Off                        (Id : E) return B;\n@@ -6088,12 +6143,14 @@ package Einfo is\n    procedure Set_Has_Convention_Pragma           (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Freeze              (Id : E; V : B := True);\n    procedure Set_Has_Discriminants               (Id : E; V : B := True);\n+   procedure Set_Has_Dispatch_Table              (Id : E; V : B := True);\n    procedure Set_Has_Enumeration_Rep_Clause      (Id : E; V : B := True);\n    procedure Set_Has_Exit                        (Id : E; V : B := True);\n    procedure Set_Has_External_Tag_Rep_Clause     (Id : E; V : B := True);\n    procedure Set_Has_Fully_Qualified_Name        (Id : E; V : B := True);\n    procedure Set_Has_Gigi_Rep_Item               (Id : E; V : B := True);\n    procedure Set_Has_Homonym                     (Id : E; V : B := True);\n+   procedure Set_Has_Initial_Value               (Id : E; V : B := True);\n    procedure Set_Has_Machine_Radix_Clause        (Id : E; V : B := True);\n    procedure Set_Has_Master_Entity               (Id : E; V : B := True);\n    procedure Set_Has_Missing_Return              (Id : E; V : B := True);\n@@ -6108,6 +6165,7 @@ package Einfo is\n    procedure Set_Has_Pragma_Elaborate_Body       (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Inline               (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Pack                 (Id : E; V : B := True);\n+   procedure Set_Has_Pragma_Preelab_Init         (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Pure                 (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Pure_Function        (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Unreferenced         (Id : E; V : B := True);\n@@ -6205,6 +6263,7 @@ package Einfo is\n    procedure Set_Is_Packed_Array_Type            (Id : E; V : B := True);\n    procedure Set_Is_Potentially_Use_Visible      (Id : E; V : B := True);\n    procedure Set_Is_Preelaborated                (Id : E; V : B := True);\n+   procedure Set_Is_Primitive                    (Id : E; V : B := True);\n    procedure Set_Is_Primitive_Wrapper            (Id : E; V : B := True);\n    procedure Set_Is_Private_Composite            (Id : E; V : B := True);\n    procedure Set_Is_Private_Descendant           (Id : E; V : B := True);\n@@ -6322,6 +6381,7 @@ package Einfo is\n    procedure Set_Underlying_Full_View            (Id : E; V : E);\n    procedure Set_Universal_Aliasing              (Id : E; V : B := True);\n    procedure Set_Unset_Reference                 (Id : E; V : N);\n+   procedure Set_Used_As_Generic_Actual          (Id : E; V : B := True);\n    procedure Set_Uses_Sec_Stack                  (Id : E; V : B := True);\n    procedure Set_Vax_Float                       (Id : E; V : B := True);\n    procedure Set_Warnings_Off                    (Id : E; V : B := True);\n@@ -6353,6 +6413,11 @@ package Einfo is\n    --  This is particularly true for the RM_Size field, where a value of zero\n    --  is legitimate and causes some kludges around the code.\n \n+   --  Contrary to the corresponding Set procedures above, these routines\n+   --  do NOT check the entity kind of their argument, instead they set the\n+   --  underlying Uint fields directly (this allows them to be used for\n+   --  entities whose Ekind has not been set yet).\n+\n    procedure Init_Alignment                (Id : E; V : Int);\n    procedure Init_Component_Size           (Id : E; V : Int);\n    procedure Init_Component_Bit_Offset     (Id : E; V : Int);\n@@ -6489,6 +6554,11 @@ package Einfo is\n    procedure Append_Entity (Id : Entity_Id; V : Entity_Id);\n    --  Add an entity to the list of entities declared in the scope V\n \n+   function Get_Full_View (T : Entity_Id) return Entity_Id;\n+   --  If T is an incomplete type and the full declaration has been\n+   --  seen, or is the name of a class_wide type whose root is incomplete.\n+   --  return the corresponding full declaration.\n+\n    function Is_Entity_Name (N : Node_Id) return Boolean;\n    --  Test if the node N is the name of an entity (i.e. is an identifier,\n    --  expanded name, or an attribute reference that returns an entity).\n@@ -6666,12 +6736,14 @@ package Einfo is\n    pragma Inline (Has_Convention_Pragma);\n    pragma Inline (Has_Delayed_Freeze);\n    pragma Inline (Has_Discriminants);\n+   pragma Inline (Has_Dispatch_Table);\n    pragma Inline (Has_Enumeration_Rep_Clause);\n    pragma Inline (Has_Exit);\n    pragma Inline (Has_External_Tag_Rep_Clause);\n    pragma Inline (Has_Fully_Qualified_Name);\n    pragma Inline (Has_Gigi_Rep_Item);\n    pragma Inline (Has_Homonym);\n+   pragma Inline (Has_Initial_Value);\n    pragma Inline (Has_Machine_Radix_Clause);\n    pragma Inline (Has_Master_Entity);\n    pragma Inline (Has_Missing_Return);\n@@ -6685,6 +6757,7 @@ package Einfo is\n    pragma Inline (Has_Pragma_Elaborate_Body);\n    pragma Inline (Has_Pragma_Inline);\n    pragma Inline (Has_Pragma_Pack);\n+   pragma Inline (Has_Pragma_Preelab_Init);\n    pragma Inline (Has_Pragma_Pure);\n    pragma Inline (Has_Pragma_Pure_Function);\n    pragma Inline (Has_Pragma_Unreferenced);\n@@ -6812,6 +6885,7 @@ package Einfo is\n    pragma Inline (Is_Packed_Array_Type);\n    pragma Inline (Is_Potentially_Use_Visible);\n    pragma Inline (Is_Preelaborated);\n+   pragma Inline (Is_Primitive);\n    pragma Inline (Is_Primitive_Wrapper);\n    pragma Inline (Is_Private_Composite);\n    pragma Inline (Is_Private_Descendant);\n@@ -6940,6 +7014,7 @@ package Einfo is\n    pragma Inline (Underlying_Full_View);\n    pragma Inline (Universal_Aliasing);\n    pragma Inline (Unset_Reference);\n+   pragma Inline (Used_As_Generic_Actual);\n    pragma Inline (Uses_Sec_Stack);\n    pragma Inline (Vax_Float);\n    pragma Inline (Warnings_Off);\n@@ -7061,12 +7136,14 @@ package Einfo is\n    pragma Inline (Set_Has_Convention_Pragma);\n    pragma Inline (Set_Has_Delayed_Freeze);\n    pragma Inline (Set_Has_Discriminants);\n+   pragma Inline (Set_Has_Dispatch_Table);\n    pragma Inline (Set_Has_Enumeration_Rep_Clause);\n    pragma Inline (Set_Has_Exit);\n    pragma Inline (Set_Has_External_Tag_Rep_Clause);\n    pragma Inline (Set_Has_Fully_Qualified_Name);\n    pragma Inline (Set_Has_Gigi_Rep_Item);\n    pragma Inline (Set_Has_Homonym);\n+   pragma Inline (Set_Has_Initial_Value);\n    pragma Inline (Set_Has_Machine_Radix_Clause);\n    pragma Inline (Set_Has_Master_Entity);\n    pragma Inline (Set_Has_Missing_Return);\n@@ -7080,6 +7157,7 @@ package Einfo is\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);\n    pragma Inline (Set_Has_Pragma_Inline);\n    pragma Inline (Set_Has_Pragma_Pack);\n+   pragma Inline (Set_Has_Pragma_Preelab_Init);\n    pragma Inline (Set_Has_Pragma_Pure);\n    pragma Inline (Set_Has_Pragma_Pure_Function);\n    pragma Inline (Set_Has_Pragma_Unreferenced);\n@@ -7178,6 +7256,7 @@ package Einfo is\n    pragma Inline (Set_Is_Packed_Array_Type);\n    pragma Inline (Set_Is_Potentially_Use_Visible);\n    pragma Inline (Set_Is_Preelaborated);\n+   pragma Inline (Set_Is_Primitive);\n    pragma Inline (Set_Is_Primitive_Wrapper);\n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n@@ -7295,6 +7374,7 @@ package Einfo is\n    pragma Inline (Set_Underlying_Full_View);\n    pragma Inline (Set_Universal_Aliasing);\n    pragma Inline (Set_Unset_Reference);\n+   pragma Inline (Set_Used_As_Generic_Actual);\n    pragma Inline (Set_Uses_Sec_Stack);\n    pragma Inline (Set_Vax_Float);\n    pragma Inline (Set_Warnings_Off);"}, {"sha": "c5d36b3e7e27bf605aca09ff825942311917f95f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 517, "deletions": 450, "changes": 967, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5d37ba92f667fc076287b111dd3166b8d48012b8", "patch": "@@ -80,12 +80,6 @@ with Validsw;  use Validsw;\n \n package body Sem_Ch6 is\n \n-   Enable_New_Return_Processing : constant Boolean := True;\n-   --  ??? This flag is temporary. False causes the compiler to use the old\n-   --  version of Analyze_Return_Statement; True, the new version, which does\n-   --  not yet work. You probably want this to match the corresponding thing\n-   --  in exp_ch5.adb.\n-\n    May_Hide_Profile : Boolean := False;\n    --  This flag is used to indicate that two formals in two subprograms being\n    --  checked for conformance differ only in that one is an access parameter\n@@ -99,11 +93,11 @@ package body Sem_Ch6 is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Analyze_A_Return_Statement (N : Node_Id);\n+   procedure Analyze_Return_Statement (N : Node_Id);\n    --  Common processing for simple_ and extended_return_statements\n \n    procedure Analyze_Function_Return (N : Node_Id);\n-   --  Subsidiary to Analyze_A_Return_Statement.\n+   --  Subsidiary to Analyze_Return_Statement.\n    --  Called when the return statement applies to a [generic] function.\n \n    procedure Analyze_Return_Type (N : Node_Id);\n@@ -147,11 +141,13 @@ package body Sem_Ch6 is\n \n    procedure Check_Overriding_Indicator\n      (Subp            : Entity_Id;\n-      Overridden_Subp : Entity_Id := Empty);\n+      Overridden_Subp : Entity_Id;\n+      Is_Primitive    : Boolean);\n    --  Verify the consistency of an overriding_indicator given for subprogram\n-   --  declaration, body, renaming, or instantiation. Overridden_Subp is set\n-   --  if the scope into which we are introducing the subprogram contains a\n+   --  declaration, body, renaming, or instantiation.  Overridden_Subp is set\n+   --  if the scope where we are introducing the subprogram contains a\n    --  type-conformant subprogram that becomes hidden by the new subprogram.\n+   --  Is_Primitive indicates whether the subprogram is primitive.\n \n    procedure Check_Subprogram_Order (N : Node_Id);\n    --  N is the N_Subprogram_Body node for a subprogram. This routine applies\n@@ -212,36 +208,33 @@ package body Sem_Ch6 is\n    --  setting the proper validity status for this entity, which depends\n    --  on the kind of parameter and the validity checking mode.\n \n-   --------------------------------\n-   -- Analyze_A_Return_Statement --\n-   --------------------------------\n+   ------------------------------\n+   -- Analyze_Return_Statement --\n+   ------------------------------\n \n-   procedure Analyze_A_Return_Statement (N : Node_Id) is\n-      --  ???This should be called Analyze_Return_Statement, and\n-      --  Analyze_Return_Statement should be called\n-      --  Analyze_Simple_Return_Statement!\n+   procedure Analyze_Return_Statement (N : Node_Id) is\n \n-      pragma Assert (Nkind (N) = N_Return_Statement\n-                     or else Nkind (N) = N_Extended_Return_Statement);\n+      pragma Assert (Nkind (N) = N_Simple_Return_Statement\n+                       or else\n+                     Nkind (N) = N_Extended_Return_Statement);\n \n       Returns_Object : constant Boolean :=\n-        Nkind (N) = N_Extended_Return_Statement\n-         or else\n-           (Nkind (N) = N_Return_Statement and then Present (Expression (N)));\n-\n+                         Nkind (N) = N_Extended_Return_Statement\n+                           or else\n+                            (Nkind (N) = N_Simple_Return_Statement\n+                              and then Present (Expression (N)));\n       --  True if we're returning something; that is, \"return <expression>;\"\n-      --  or \"return Result : T [:= ...]\". False for \"return;\".\n-      --  Used for error checking: If Returns_Object is True, N should apply\n-      --  to a function body; otherwise N should apply to a procedure body,\n-      --  entry body, accept statement, or extended return statement.\n+      --  or \"return Result : T [:= ...]\". False for \"return;\". Used for error\n+      --  checking: If Returns_Object is True, N should apply to a function\n+      --  body; otherwise N should apply to a procedure body, entry body,\n+      --  accept statement, or extended return statement.\n \n       function Find_What_It_Applies_To return Entity_Id;\n       --  Find the entity representing the innermost enclosing body, accept\n-      --  statement, or extended return statement. If the result is a\n-      --  callable construct or extended return statement, then this will be\n-      --  the value of the Return_Applies_To attribute. Otherwise, the program\n-      --  is illegal. See RM-6.5(4/2). I am disinclined to call this\n-      --  Find_The_Construct_To_Which_This_Return_Statement_Applies. ;-)\n+      --  statement, or extended return statement. If the result is a callable\n+      --  construct or extended return statement, then this will be the value\n+      --  of the Return_Applies_To attribute. Otherwise, the program is\n+      --  illegal. See RM-6.5(4/2).\n \n       -----------------------------\n       -- Find_What_It_Applies_To --\n@@ -261,41 +254,45 @@ package body Sem_Ch6 is\n \n          pragma Assert (Present (Result));\n          return Result;\n-\n       end Find_What_It_Applies_To;\n \n+      --  Local declarations\n+\n       Scope_Id   : constant Entity_Id   := Find_What_It_Applies_To;\n       Kind       : constant Entity_Kind := Ekind (Scope_Id);\n-\n       Loc        : constant Source_Ptr  := Sloc (N);\n       Stm_Entity : constant Entity_Id   :=\n                      New_Internal_Entity\n                        (E_Return_Statement, Current_Scope, Loc, 'R');\n \n-   --  Start of processing for Analyze_A_Return_Statement\n+   --  Start of processing for Analyze_Return_Statement\n \n    begin\n-\n       Set_Return_Statement_Entity (N, Stm_Entity);\n \n       Set_Etype (Stm_Entity, Standard_Void_Type);\n       Set_Return_Applies_To (Stm_Entity, Scope_Id);\n \n-      --  Place the Return entity on scope stack, to simplify enforcement\n-      --  of 6.5 (4/2): an inner return statement will apply to this extended\n-      --  return.\n+      --  Place Return entity on scope stack, to simplify enforcement of 6.5\n+      --  (4/2): an inner return statement will apply to this extended return.\n \n       if Nkind (N) = N_Extended_Return_Statement then\n          Push_Scope (Stm_Entity);\n       end if;\n \n-      --  Check that pragma No_Return is obeyed:\n+      --  Check that pragma No_Return is obeyed\n \n       if No_Return (Scope_Id) then\n          Error_Msg_N (\"RETURN statement not allowed (No_Return)\", N);\n       end if;\n \n-      --  Check that functions return objects, and other things do not:\n+      --  Warn on any unassigned OUT parameters if in procedure\n+\n+      if Ekind (Scope_Id) = E_Procedure then\n+         Warn_On_Unassigned_Out_Parameter (N, Scope_Id);\n+      end if;\n+\n+      --  Check that functions return objects, and other things do not\n \n       if Kind = E_Function or else Kind = E_Generic_Function then\n          if not Returns_Object then\n@@ -340,7 +337,7 @@ package body Sem_Ch6 is\n       end if;\n \n       Check_Unreachable_Code (N);\n-   end Analyze_A_Return_Statement;\n+   end Analyze_Return_Statement;\n \n    ---------------------------------------------\n    -- Analyze_Abstract_Subprogram_Declaration --\n@@ -362,6 +359,19 @@ package body Sem_Ch6 is\n       if Ekind (Scope (Designator)) = E_Protected_Type then\n          Error_Msg_N\n            (\"abstract subprogram not allowed in protected type\", N);\n+\n+      --  Issue a warning if the abstract subprogram is neither a dispatching\n+      --  operation nor an operation that overrides an inherited subprogram or\n+      --  predefined operator, since this most likely indicates a mistake.\n+\n+      elsif Warn_On_Redundant_Constructs\n+        and then not Is_Dispatching_Operation (Designator)\n+        and then not Is_Overriding_Operation (Designator)\n+        and then (not Is_Operator_Symbol_Name (Chars (Designator))\n+                   or else Scop /= Scope (Etype (First_Formal (Designator))))\n+      then\n+         Error_Msg_N\n+           (\"?abstract subprogram is not dispatching or overriding\", N);\n       end if;\n \n       Generate_Reference_To_Formals (Designator);\n@@ -373,7 +383,7 @@ package body Sem_Ch6 is\n \n    procedure Analyze_Extended_Return_Statement (N : Node_Id) is\n    begin\n-      Analyze_A_Return_Statement (N);\n+      Analyze_Return_Statement (N);\n    end Analyze_Extended_Return_Statement;\n \n    ----------------------------\n@@ -430,7 +440,7 @@ package body Sem_Ch6 is\n       Stm_Entity : constant Entity_Id   := Return_Statement_Entity (N);\n       Scope_Id   : constant Entity_Id   := Return_Applies_To (Stm_Entity);\n \n-      R_Type : constant Entity_Id   := Etype (Scope_Id);\n+      R_Type : constant Entity_Id := Etype (Scope_Id);\n       --  Function result subtype\n \n       procedure Check_Limited_Return (Expr : Node_Id);\n@@ -466,7 +476,7 @@ package body Sem_Ch6 is\n             then\n                Error_Msg_N\n                  (\"(Ada 2005) cannot copy object of a limited type \" &\n-                  \"('R'M'-2005 6.5(5.5/2))\", Expr);\n+                  \"(RM-2005 6.5(5.5/2))\", Expr);\n                if Is_Inherently_Limited_Type (R_Type) then\n                   Error_Msg_N\n                     (\"\\return by reference not permitted in Ada 2005\", Expr);\n@@ -482,11 +492,11 @@ package body Sem_Ch6 is\n                if Is_Inherently_Limited_Type (R_Type) then\n                   Error_Msg_N\n                     (\"return by reference not permitted in Ada 2005 \" &\n-                     \"('R'M'-2005 6.5(5.5/2))?\", Expr);\n+                     \"(RM-2005 6.5(5.5/2))?\", Expr);\n                else\n                   Error_Msg_N\n                     (\"cannot copy object of a limited type in Ada 2005 \" &\n-                     \"('R'M'-2005 6.5(5.5/2))?\", Expr);\n+                     \"(RM-2005 6.5(5.5/2))?\", Expr);\n                end if;\n \n             --  Ada 95 mode, compatibility warnings disabled\n@@ -585,7 +595,8 @@ package body Sem_Ch6 is\n          --  needed. ???)\n \n          elsif Is_Class_Wide_Type (R_Type)\n-           and then R_Type = Etype (Object_Definition (Obj_Decl))\n+           and then\n+             R_Type = Etype (Object_Definition (Original_Node (Obj_Decl)))\n          then\n             null;\n \n@@ -606,7 +617,7 @@ package body Sem_Ch6 is\n    begin\n       Set_Return_Present (Scope_Id);\n \n-      if Nkind (N) = N_Return_Statement then\n+      if Nkind (N) = N_Simple_Return_Statement then\n          Expr := Expression (N);\n          Analyze_And_Resolve (Expr, R_Type);\n          Check_Limited_Return (Expr);\n@@ -649,13 +660,21 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n+      --  Case of Expr present (Etype check defends against previous errors)\n+\n       if Present (Expr)\n-        and then Present (Etype (Expr)) --  Could be False in case of errors.\n+        and then Present (Etype (Expr))\n       then\n-         --  Ada 2005 (AI-318-02): When the result type is an anonymous\n-         --  access type, apply an implicit conversion of the expression\n-         --  to that type to force appropriate static and run-time\n-         --  accessibility checks.\n+         --  Apply constraint check. Note that this is done before the implicit\n+         --  conversion of the expression done for anonymous access types to\n+         --  ensure correct generation of the null-excluding check asssociated\n+         --  with null-excluding expressions found in return statements.\n+\n+         Apply_Constraint_Check (Expr, R_Type);\n+\n+         --  Ada 2005 (AI-318-02): When the result type is an anonymous access\n+         --  type, apply an implicit conversion of the expression to that type\n+         --  to force appropriate static and run-time accessibility checks.\n \n          if Ada_Version >= Ada_05\n            and then Ekind (R_Type) = E_Anonymous_Access_Type\n@@ -672,8 +691,6 @@ package body Sem_Ch6 is\n               (\"dynamically tagged expression not allowed!\", Expr);\n          end if;\n \n-         Apply_Constraint_Check (Expr, R_Type);\n-\n          --  ??? A real run-time accessibility check is needed in cases\n          --  involving dereferences of access parameters. For now we just\n          --  check the static cases.\n@@ -694,6 +711,17 @@ package body Sem_Ch6 is\n               (\"\\& will be raised at run time?\",\n                N, Standard_Program_Error);\n          end if;\n+\n+         if Known_Null (Expr)\n+           and then Nkind (Parent (Scope_Id)) = N_Function_Specification\n+           and then Null_Exclusion_Present (Parent (Scope_Id))\n+         then\n+            Apply_Compile_Time_Constraint_Error\n+              (N      => Expr,\n+               Msg    => \"(Ada 2005) null not allowed for \"\n+                         & \"null-excluding return?\",\n+               Reason => CE_Null_Not_Allowed);\n+         end if;\n       end if;\n    end Analyze_Function_Return;\n \n@@ -864,7 +892,10 @@ package body Sem_Ch6 is\n \n       Set_Ekind (Gen_Id, Kind);\n       Generate_Reference (Gen_Id, Body_Id, 'b', Set_Ref => False);\n-      Style.Check_Identifier (Body_Id, Gen_Id);\n+\n+      if Style_Check then\n+         Style.Check_Identifier (Body_Id, Gen_Id);\n+      end if;\n       End_Generic;\n    end Analyze_Generic_Subprogram_Body;\n \n@@ -1127,142 +1158,18 @@ package body Sem_Ch6 is\n       end if;\n    end Analyze_Procedure_Call;\n \n-   ------------------------------\n-   -- Analyze_Return_Statement --\n-   ------------------------------\n-\n-   procedure Analyze_Return_Statement (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      Expr     : Node_Id;\n-      Scope_Id : Entity_Id;\n-      Kind     : Entity_Kind;\n-      R_Type   : Entity_Id;\n-\n-      Stm_Entity : constant Entity_Id   :=\n-                     New_Internal_Entity\n-                       (E_Return_Statement, Current_Scope, Loc, 'R');\n+   -------------------------------------\n+   -- Analyze_Simple_Return_Statement --\n+   -------------------------------------\n \n+   procedure Analyze_Simple_Return_Statement (N : Node_Id) is\n    begin\n-      if Enable_New_Return_Processing then --  ???Temporary hack.\n-         Analyze_A_Return_Statement (N);\n-         return;\n-      end if;\n-\n-      --  Find subprogram or accept statement enclosing the return statement\n-\n-      Scope_Id := Empty;\n-      for J in reverse 0 .. Scope_Stack.Last loop\n-         Scope_Id := Scope_Stack.Table (J).Entity;\n-         exit when Ekind (Scope_Id) /= E_Block and then\n-                   Ekind (Scope_Id) /= E_Loop;\n-      end loop;\n-\n-      pragma Assert (Present (Scope_Id));\n-\n-      Set_Return_Statement_Entity (N, Stm_Entity);\n-      Set_Return_Applies_To (Stm_Entity, Scope_Id);\n-\n-      Kind := Ekind (Scope_Id);\n-      Expr := Expression (N);\n-\n-      if Kind /= E_Function\n-        and then Kind /= E_Generic_Function\n-        and then Kind /= E_Procedure\n-        and then Kind /= E_Generic_Procedure\n-        and then Kind /= E_Entry\n-        and then Kind /= E_Entry_Family\n-      then\n-         Error_Msg_N (\"illegal context for return statement\", N);\n-\n-      elsif Present (Expr) then\n-         if Kind = E_Function or else Kind = E_Generic_Function then\n-            Set_Return_Present (Scope_Id);\n-            R_Type := Etype (Scope_Id);\n-            Analyze_And_Resolve (Expr, R_Type);\n-\n-            --  Ada 2005 (AI-318-02): When the result type is an anonymous\n-            --  access type, apply an implicit conversion of the expression\n-            --  to that type to force appropriate static and run-time\n-            --  accessibility checks.\n-\n-            if Ada_Version >= Ada_05\n-              and then Ekind (R_Type) = E_Anonymous_Access_Type\n-            then\n-               Rewrite (Expr, Convert_To (R_Type, Relocate_Node (Expr)));\n-               Analyze_And_Resolve (Expr, R_Type);\n-            end if;\n-\n-            if (Is_Class_Wide_Type (Etype (Expr))\n-                 or else Is_Dynamically_Tagged (Expr))\n-              and then not Is_Class_Wide_Type (R_Type)\n-            then\n-               Error_Msg_N\n-                 (\"dynamically tagged expression not allowed!\", Expr);\n-            end if;\n-\n-            Apply_Constraint_Check (Expr, R_Type);\n-\n-            --  Ada 2005 (AI-318-02): Return-by-reference types have been\n-            --  removed and replaced by anonymous access results. This is\n-            --  an incompatibility with Ada 95. Not clear whether this\n-            --  should be enforced yet or perhaps controllable with a\n-            --  special switch. ???\n-\n-            --  if Ada_Version >= Ada_05\n-            --    and then Is_Limited_Type (R_Type)\n-            --    and then Nkind (Expr) /= N_Aggregate\n-            --    and then Nkind (Expr) /= N_Extension_Aggregate\n-            --    and then Nkind (Expr) /= N_Function_Call\n-            --  then\n-            --     Error_Msg_N\n-            --       (\"(Ada 2005) illegal operand for limited return\", N);\n-            --  end if;\n-\n-            --  ??? A real run-time accessibility check is needed in cases\n-            --  involving dereferences of access parameters. For now we just\n-            --  check the static cases.\n-\n-            if Is_Inherently_Limited_Type (Etype (Scope_Id))\n-              and then Object_Access_Level (Expr)\n-                > Subprogram_Access_Level (Scope_Id)\n-            then\n-               Rewrite (N,\n-                 Make_Raise_Program_Error (Loc,\n-                   Reason => PE_Accessibility_Check_Failed));\n-               Analyze (N);\n-\n-               Error_Msg_N\n-                 (\"cannot return a local value by reference?\", N);\n-               Error_Msg_NE\n-                 (\"\\& will be raised at run time?\",\n-                  N, Standard_Program_Error);\n-            end if;\n-\n-         elsif Kind = E_Procedure or else Kind = E_Generic_Procedure then\n-            Error_Msg_N (\"procedure cannot return value (use function)\", N);\n-\n-         else\n-            Error_Msg_N (\"accept statement cannot return value\", N);\n-         end if;\n-\n-      --  No expression present\n-\n-      else\n-         if Kind = E_Function or Kind = E_Generic_Function then\n-            Error_Msg_N (\"missing expression in return from function\", N);\n-         end if;\n-\n-         if (Ekind (Scope_Id) = E_Procedure\n-              or else Ekind (Scope_Id) = E_Generic_Procedure)\n-           and then No_Return (Scope_Id)\n-         then\n-            Error_Msg_N\n-              (\"RETURN statement not allowed (No_Return)\", N);\n-         end if;\n+      if Present (Expression (N)) then\n+         Mark_Coextensions (N, Expression (N));\n       end if;\n \n-      Check_Unreachable_Code (N);\n-   end Analyze_Return_Statement;\n+      Analyze_Return_Statement (N);\n+   end Analyze_Simple_Return_Statement;\n \n    -------------------------\n    -- Analyze_Return_Type --\n@@ -1528,12 +1435,20 @@ package body Sem_Ch6 is\n             Error_Msg_NE\n               (\"subprogram& is not overriding\", Body_Spec, Spec_Id);\n \n-         elsif Must_Not_Override (Body_Spec)\n-              and then Is_Overriding_Operation (Spec_Id)\n-         then\n-            Error_Msg_NE\n-              (\"subprogram& overrides inherited operation\",\n-                 Body_Spec, Spec_Id);\n+         elsif Must_Not_Override (Body_Spec) then\n+            if Is_Overriding_Operation (Spec_Id) then\n+               Error_Msg_NE\n+                 (\"subprogram& overrides inherited operation\",\n+                    Body_Spec, Spec_Id);\n+\n+            --  If this is not a primitive operation the overriding indicator\n+            --  is altogether illegal.\n+\n+            elsif not Is_Primitive (Spec_Id) then\n+               Error_Msg_N (\"overriding indicator only allowed \" &\n+                \"if subprogram is primitive\",\n+                Body_Spec);\n+            end if;\n          end if;\n       end Verify_Overriding_Indicator;\n \n@@ -1731,6 +1646,28 @@ package body Sem_Ch6 is\n       elsif Present (Spec_Id) then\n          Spec_Decl := Unit_Declaration_Node (Spec_Id);\n          Verify_Overriding_Indicator;\n+\n+         --  In general, the spec will be frozen when we start analyzing the\n+         --  body. However, for internally generated operations, such as\n+         --  wrapper functions for inherited operations with controlling\n+         --  results, the spec may not have been frozen by the time we\n+         --  expand the freeze actions that include the bodies. In particular,\n+         --  extra formals for accessibility or for return-in-place may need\n+         --  to be generated. Freeze nodes, if any, are inserted before the\n+         --  current body.\n+\n+         if not Is_Frozen (Spec_Id)\n+           and then Expander_Active\n+         then\n+            --  Force the generation of its freezing node to ensure proper\n+            --  management of access types in the backend.\n+\n+            --  This is definitely needed for some cases, but it is not clear\n+            --  why, to be investigated further???\n+\n+            Set_Has_Delayed_Freeze (Spec_Id);\n+            Insert_Actions (N, Freeze_Entity (Spec_Id, Loc));\n+         end if;\n       end if;\n \n       --  Place subprogram on scope stack, and make formals visible. If there\n@@ -1808,22 +1745,41 @@ package body Sem_Ch6 is\n          if Nkind (N) /= N_Subprogram_Body_Stub then\n             Set_Corresponding_Spec (N, Spec_Id);\n \n-            --  Ada 2005 (AI-345): Restore the correct Etype: here we undo the\n-            --  work done by Analyze_Subprogram_Specification to allow the\n-            --  overriding of task, protected and interface primitives.\n+            --  Ada 2005 (AI-345): If the operation is a primitive operation\n+            --  of a concurrent type, the type of the first parameter has been\n+            --  replaced with the corresponding record, which is the proper\n+            --  run-time structure to use. However, within the body there may\n+            --  be uses of the formals that depend on primitive operations\n+            --  of the type (in particular calls in prefixed form) for which\n+            --  we need the original concurrent type. The operation may have\n+            --  several controlling formals, so the replacement must be done\n+            --  for all of them.\n \n             if Comes_From_Source (Spec_Id)\n               and then Present (First_Entity (Spec_Id))\n               and then Ekind (Etype (First_Entity (Spec_Id))) = E_Record_Type\n               and then Is_Tagged_Type (Etype (First_Entity (Spec_Id)))\n-              and then Present (Abstract_Interfaces\n-                                (Etype (First_Entity (Spec_Id))))\n-              and then Present (Corresponding_Concurrent_Type\n-                                (Etype (First_Entity (Spec_Id))))\n+              and then\n+                Present (Abstract_Interfaces (Etype (First_Entity (Spec_Id))))\n+              and then\n+                Present\n+                 (Corresponding_Concurrent_Type\n+                   (Etype (First_Entity (Spec_Id))))\n             then\n-               Set_Etype (First_Entity (Spec_Id),\n-                 Corresponding_Concurrent_Type\n-                   (Etype (First_Entity (Spec_Id))));\n+               declare\n+                  Typ  : constant Entity_Id := Etype (First_Entity (Spec_Id));\n+                  Form : Entity_Id;\n+\n+               begin\n+                  Form := First_Formal (Spec_Id);\n+                  while Present (Form) loop\n+                     if Etype (Form) = Typ then\n+                        Set_Etype (Form, Corresponding_Concurrent_Type (Typ));\n+                     end if;\n+\n+                     Next_Formal (Form);\n+                  end loop;\n+               end;\n             end if;\n \n             --  Now make the formals visible, and place subprogram\n@@ -2677,7 +2633,7 @@ package body Sem_Ch6 is\n \n          function Check_Return (N : Node_Id) return Traverse_Result is\n          begin\n-            if Nkind (N) = N_Return_Statement then\n+            if Nkind (N) = N_Simple_Return_Statement then\n                if Present (Expression (N))\n                  and then Is_Entity_Name (Expression (N))\n                then\n@@ -3038,7 +2994,7 @@ package body Sem_Ch6 is\n         and then New_Type /= Standard_Void_Type\n       then\n          if not Conforming_Types (Old_Type, New_Type, Ctype, Get_Inst) then\n-            Conformance_Error (\"return type does not match!\", New_Id);\n+            Conformance_Error (\"\\return type does not match!\", New_Id);\n             return;\n          end if;\n \n@@ -3053,7 +3009,7 @@ package body Sem_Ch6 is\n               or else Is_Access_Constant (Etype (Old_Type))\n                         /= Is_Access_Constant (Etype (New_Type)))\n          then\n-            Conformance_Error (\"return type does not match!\", New_Id);\n+            Conformance_Error (\"\\return type does not match!\", New_Id);\n             return;\n          end if;\n \n@@ -3062,7 +3018,7 @@ package body Sem_Ch6 is\n       elsif Old_Type /= Standard_Void_Type\n         or else New_Type /= Standard_Void_Type\n       then\n-         Conformance_Error (\"functions can only match functions!\", New_Id);\n+         Conformance_Error (\"\\functions can only match functions!\", New_Id);\n          return;\n       end if;\n \n@@ -3086,18 +3042,18 @@ package body Sem_Ch6 is\n                Error_Msg_Name_2 :=\n                  Name_Ada + Convention_Id'Pos (Convention (New_Id));\n \n-               Conformance_Error (\"prior declaration for% has convention %!\");\n+               Conformance_Error (\"\\prior declaration for% has convention %!\");\n \n             else\n-               Conformance_Error (\"calling conventions do not match!\");\n+               Conformance_Error (\"\\calling conventions do not match!\");\n             end if;\n \n             return;\n \n          elsif Is_Formal_Subprogram (Old_Id)\n            or else Is_Formal_Subprogram (New_Id)\n          then\n-            Conformance_Error (\"formal subprograms not allowed!\");\n+            Conformance_Error (\"\\formal subprograms not allowed!\");\n             return;\n          end if;\n       end if;\n@@ -3126,7 +3082,7 @@ package body Sem_Ch6 is\n             --  this before checking that the types of the formals match.\n \n             if Chars (Old_Formal) /= Chars (New_Formal) then\n-               Conformance_Error (\"name & does not match!\", New_Formal);\n+               Conformance_Error (\"\\name & does not match!\", New_Formal);\n \n                --  Set error posted flag on new formal as well to stop\n                --  junk cascaded messages in some cases.\n@@ -3159,10 +3115,10 @@ package body Sem_Ch6 is\n          Access_Types_Match := Ada_Version >= Ada_05\n \n             --  Ensure that this rule is only applied when New_Id is a\n-            --  renaming of Old_Id\n+            --  renaming of Old_Id.\n \n-           and then Nkind (Parent (Parent (New_Id)))\n-                      = N_Subprogram_Renaming_Declaration\n+           and then Nkind (Parent (Parent (New_Id))) =\n+                      N_Subprogram_Renaming_Declaration\n            and then Nkind (Name (Parent (Parent (New_Id)))) in N_Has_Entity\n            and then Present (Entity (Name (Parent (Parent (New_Id)))))\n            and then Entity (Name (Parent (Parent (New_Id)))) = Old_Id\n@@ -3171,6 +3127,30 @@ package body Sem_Ch6 is\n \n            and then Is_Access_Type (Old_Formal_Base)\n            and then Is_Access_Type (New_Formal_Base)\n+\n+            --  The type kinds must match. The only exception occurs with\n+            --  multiple generics of the form:\n+\n+            --   generic                    generic\n+            --     type F is private;         type A is private;\n+            --     type F_Ptr is access F;    type A_Ptr is access A;\n+            --     with proc F_P (X : F_Ptr); with proc A_P (X : A_Ptr);\n+            --   package F_Pack is ...      package A_Pack is\n+            --                                package F_Inst is\n+            --                                  new F_Pack (A, A_Ptr, A_P);\n+\n+            --  When checking for conformance between the parameters of A_P\n+            --  and F_P, the type kinds of F_Ptr and A_Ptr will not match\n+            --  because the compiler has transformed A_Ptr into a subtype of\n+            --  F_Ptr. We catch this case in the code below.\n+\n+           and then (Ekind (Old_Formal_Base) = Ekind (New_Formal_Base)\n+                  or else\n+                    (Is_Generic_Type (Old_Formal_Base)\n+                       and then Is_Generic_Type (New_Formal_Base)\n+                       and then Is_Internal (New_Formal_Base)\n+                       and then Etype (Etype (New_Formal_Base)) =\n+                                  Old_Formal_Base))\n            and then Directly_Designated_Type (Old_Formal_Base) =\n                       Directly_Designated_Type (New_Formal_Base)\n            and then ((Is_Itype (Old_Formal_Base)\n@@ -3193,28 +3173,39 @@ package body Sem_Ch6 is\n                       Get_Inst => Get_Inst)\n                and then not Access_Types_Match\n             then\n-               Conformance_Error (\"type of & does not match!\", New_Formal);\n+               Conformance_Error (\"\\type of & does not match!\", New_Formal);\n                return;\n             end if;\n \n          elsif not Conforming_Types\n-                     (T1       => Etype (Old_Formal),\n-                      T2       => Etype (New_Formal),\n+                     (T1       => Old_Formal_Base,\n+                      T2       => New_Formal_Base,\n                       Ctype    => Ctype,\n                       Get_Inst => Get_Inst)\n            and then not Access_Types_Match\n          then\n-            Conformance_Error (\"type of & does not match!\", New_Formal);\n+            Conformance_Error (\"\\type of & does not match!\", New_Formal);\n             return;\n          end if;\n \n          --  For mode conformance, mode must match\n \n-         if Ctype >= Mode_Conformant\n-           and then Parameter_Mode (Old_Formal) /= Parameter_Mode (New_Formal)\n-         then\n-            Conformance_Error (\"mode of & does not match!\", New_Formal);\n-            return;\n+         if Ctype >= Mode_Conformant then\n+            if Parameter_Mode (Old_Formal) /= Parameter_Mode (New_Formal) then\n+               Conformance_Error (\"\\mode of & does not match!\", New_Formal);\n+               return;\n+\n+            --  Part of mode conformance for access types is having the same\n+            --  constant modifier.\n+\n+            elsif Access_Types_Match\n+              and then Is_Access_Constant (Old_Formal_Base) /=\n+                       Is_Access_Constant (New_Formal_Base)\n+            then\n+               Conformance_Error\n+                 (\"\\constant modifier does not match!\", New_Formal);\n+               return;\n+            end if;\n          end if;\n \n          if Ctype >= Subtype_Conformant then\n@@ -3246,7 +3237,7 @@ package body Sem_Ch6 is\n                     and then TSS_Name /= TSS_Stream_Output\n                   then\n                      Conformance_Error\n-                       (\"type of & does not match!\", New_Formal);\n+                       (\"\\type of & does not match!\", New_Formal);\n                      return;\n                   end if;\n                end;\n@@ -3289,7 +3280,7 @@ package body Sem_Ch6 is\n                                      Default_Value (New_Formal))\n                      then\n                         Conformance_Error\n-                          (\"default expression for & does not match!\",\n+                          (\"\\default expression for & does not match!\",\n                            New_Formal);\n                         return;\n                      end if;\n@@ -3320,7 +3311,7 @@ package body Sem_Ch6 is\n                  and then Ctype = Fully_Conformant\n                then\n                   Conformance_Error\n-                    (\"(Ada 83) IN must appear in both declarations\",\n+                    (\"\\(Ada 83) IN must appear in both declarations\",\n                      New_Formal);\n                   return;\n                end if;\n@@ -3338,7 +3329,7 @@ package body Sem_Ch6 is\n                  or else Prev_Ids (Old_Param) /= Prev_Ids (New_Param)\n                then\n                   Conformance_Error\n-                    (\"grouping of & does not match!\", New_Formal);\n+                    (\"\\grouping of & does not match!\", New_Formal);\n                   return;\n                end if;\n             end;\n@@ -3353,11 +3344,11 @@ package body Sem_Ch6 is\n       end loop;\n \n       if Present (Old_Formal) then\n-         Conformance_Error (\"too few parameters!\");\n+         Conformance_Error (\"\\too few parameters!\");\n          return;\n \n       elsif Present (New_Formal) then\n-         Conformance_Error (\"too many parameters!\", New_Formal);\n+         Conformance_Error (\"\\too many parameters!\", New_Formal);\n          return;\n       end if;\n    end Check_Conformance;\n@@ -3769,7 +3760,8 @@ package body Sem_Ch6 is\n \n    procedure Check_Overriding_Indicator\n      (Subp            : Entity_Id;\n-      Overridden_Subp : Entity_Id := Empty)\n+      Overridden_Subp : Entity_Id;\n+      Is_Primitive    : Boolean)\n    is\n       Decl : Node_Id;\n       Spec : Node_Id;\n@@ -3807,47 +3799,59 @@ package body Sem_Ch6 is\n             Error_Msg_Sloc := Sloc (Overridden_Subp);\n \n             if Ekind (Subp) = E_Entry then\n-               Error_Msg_NE (\"entry & overrides inherited operation #\",\n-                             Spec, Subp);\n-\n+               Error_Msg_NE\n+                 (\"entry & overrides inherited operation #\", Spec, Subp);\n             else\n-               Error_Msg_NE (\"subprogram & overrides inherited operation #\",\n-                             Spec, Subp);\n+               Error_Msg_NE\n+                 (\"subprogram & overrides inherited operation #\", Spec, Subp);\n             end if;\n          end if;\n \n       --  If Subp is an operator, it may override a predefined operation.\n       --  In that case overridden_subp is empty because of our implicit\n-      --  representation for predefined operators. We have to check whether\n-      --  the signature of Subp matches that of a predefined operator.\n-      --  Note that first argument provides the name of the operator, and\n-      --  the second argument the signature that may match that of a standard\n-      --  operation.\n+      --  representation for predefined operators. We have to check whether the\n+      --  signature of Subp matches that of a predefined operator. Note that\n+      --  first argument provides the name of the operator, and the second\n+      --  argument the signature that may match that of a standard operation.\n \n       elsif Nkind (Subp) = N_Defining_Operator_Symbol\n         and then  Must_Not_Override (Spec)\n       then\n          if Operator_Matches_Spec (Subp, Subp) then\n             Error_Msg_NE\n-              (\"subprogram & overrides predefined operation \",\n+              (\"subprogram & overrides predefined operator \",\n                  Spec, Subp);\n          end if;\n \n-      else\n-         if Must_Override (Spec) then\n-            if Ekind (Subp) = E_Entry then\n-               Error_Msg_NE (\"entry & is not overriding\", Spec, Subp);\n-\n-            elsif Nkind (Subp) = N_Defining_Operator_Symbol then\n-               if not Operator_Matches_Spec (Subp, Subp) then\n-                  Error_Msg_NE\n-                    (\"subprogram & is not overriding\", Spec, Subp);\n-               end if;\n+      elsif Must_Override (Spec) then\n+         if Ekind (Subp) = E_Entry then\n+            Error_Msg_NE (\"entry & is not overriding\", Spec, Subp);\n \n-            else\n-               Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n+         elsif Nkind (Subp) = N_Defining_Operator_Symbol then\n+            if not Operator_Matches_Spec (Subp, Subp) then\n+               Error_Msg_NE\n+                 (\"subprogram & is not overriding\", Spec, Subp);\n             end if;\n+\n+         else\n+            Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n          end if;\n+\n+      --  If the operation is marked \"not overriding\" and it's not primitive\n+      --  then an error is issued, unless this is an operation of a task or\n+      --  protected type (RM05-8.3.1(3/2-4/2)). Error cases where \"overriding\"\n+      --  has been specified have already been checked above.\n+\n+      elsif Must_Not_Override (Spec)\n+        and then not Is_Primitive\n+        and then Ekind (Subp) /= E_Entry\n+        and then Ekind (Scope (Subp)) /= E_Protected_Type\n+      then\n+         Error_Msg_N\n+           (\"overriding indicator only allowed if subprogram is primitive\",\n+            Subp);\n+\n+         return;\n       end if;\n    end Check_Overriding_Indicator;\n \n@@ -4177,10 +4181,10 @@ package body Sem_Ch6 is\n          if Mode = 'F' then\n             if not Raise_Exception_Call then\n                Error_Msg_N\n-                 (\"?RETURN statement missing following this statement\",\n+                 (\"?RETURN statement missing following this statement!\",\n                   Last_Stm);\n                Error_Msg_N\n-                 (\"\\?Program_Error may be raised at run time\",\n+                 (\"\\?Program_Error may be raised at run time!\",\n                   Last_Stm);\n             end if;\n \n@@ -4375,6 +4379,12 @@ package body Sem_Ch6 is\n       --  spurious ambiguities in an instantiation that may arise if two\n       --  distinct generic types are instantiated with the same actual.\n \n+      function Find_Designated_Type (T : Entity_Id) return Entity_Id;\n+      --  An access parameter can designate an incomplete type. If the\n+      --  incomplete type is the limited view of a type from a limited_\n+      --  with_clause, check whether the non-limited view is available. If\n+      --  it is a (non-limited) incomplete type, get the full view.\n+\n       function Matches_Limited_With_View (T1, T2 : Entity_Id) return Boolean;\n       --  Returns True if and only if either T1 denotes a limited view of T2\n       --  or T2 denotes a limited view of T1. This can arise when the limited\n@@ -4407,6 +4417,34 @@ package body Sem_Ch6 is\n          end if;\n       end Base_Types_Match;\n \n+      --------------------------\n+      -- Find_Designated_Type --\n+      --------------------------\n+\n+      function Find_Designated_Type (T : Entity_Id) return Entity_Id is\n+         Desig : Entity_Id;\n+\n+      begin\n+         Desig := Directly_Designated_Type (T);\n+\n+         if Ekind (Desig) = E_Incomplete_Type then\n+\n+            --  If regular incomplete type, get full view if available\n+\n+            if Present (Full_View (Desig)) then\n+               Desig := Full_View (Desig);\n+\n+            --  If limited view of a type, get non-limited view if available,\n+            --  and check again for a regular incomplete type.\n+\n+            elsif Present (Non_Limited_View (Desig)) then\n+               Desig := Get_Full_View (Non_Limited_View (Desig));\n+            end if;\n+         end if;\n+\n+         return Desig;\n+      end Find_Designated_Type;\n+\n       -------------------------------\n       -- Matches_Limited_With_View --\n       -------------------------------\n@@ -4490,44 +4528,36 @@ package body Sem_Ch6 is\n                Ekind (Type_1) = E_Anonymous_Access_Protected_Subprogram_Type);\n \n       --  Test anonymous access type case. For this case, static subtype\n-      --  matching is required for mode conformance (RM 6.3.1(15))\n+      --  matching is required for mode conformance (RM 6.3.1(15)). We check\n+      --  the base types because we may have built internal subtype entities\n+      --  to handle null-excluding types (see Process_Formals).\n \n-      if (Ekind (Type_1) = E_Anonymous_Access_Type\n-            and then Ekind (Type_2) = E_Anonymous_Access_Type)\n+      if (Ekind (Base_Type (Type_1)) = E_Anonymous_Access_Type\n+            and then\n+          Ekind (Base_Type (Type_2)) = E_Anonymous_Access_Type)\n         or else Are_Anonymous_Access_To_Subprogram_Types -- Ada 2005 (AI-254)\n       then\n          declare\n             Desig_1 : Entity_Id;\n             Desig_2 : Entity_Id;\n \n          begin\n-            Desig_1 := Directly_Designated_Type (Type_1);\n-\n-            --  An access parameter can designate an incomplete type\n-            --  If the incomplete type is the limited view of a type\n-            --  from a limited_with_clause, check whether the non-limited\n-            --  view is available.\n-\n-            if Ekind (Desig_1) = E_Incomplete_Type then\n-               if Present (Full_View (Desig_1)) then\n-                  Desig_1 := Full_View (Desig_1);\n+            --  In Ada2005, access constant indicators must match for\n+            --  subtype conformance.\n \n-               elsif Present (Non_Limited_View (Desig_1)) then\n-                  Desig_1 := Non_Limited_View (Desig_1);\n-               end if;\n+            if Ada_Version >= Ada_05\n+              and then Ctype >= Subtype_Conformant\n+              and then\n+                Is_Access_Constant (Type_1) /= Is_Access_Constant (Type_2)\n+            then\n+               return False;\n             end if;\n \n-            Desig_2 := Directly_Designated_Type (Type_2);\n+            Desig_1 := Find_Designated_Type (Type_1);\n \n-            if Ekind (Desig_2) = E_Incomplete_Type then\n-               if Present (Full_View (Desig_2)) then\n-                  Desig_2 := Full_View (Desig_2);\n-               elsif Present (Non_Limited_View (Desig_2)) then\n-                  Desig_2 := Non_Limited_View (Desig_2);\n-               end if;\n-            end if;\n+            Desig_2 := Find_Designated_Type (Type_2);\n \n-            --  The context is an instance association for a formal\n+            --  If the context is an instance association for a formal\n             --  access-to-subprogram type; formal access parameter designated\n             --  types require mapping because they may denote other formal\n             --  parameters of the generic unit.\n@@ -4699,7 +4729,6 @@ package body Sem_Ch6 is\n       end if;\n \n       Formal := First_Formal (E);\n-\n       while Present (Formal) loop\n \n          --  Create extra formal for supporting the attribute 'Constrained.\n@@ -4733,9 +4762,7 @@ package body Sem_Ch6 is\n               and then not Is_Indefinite_Subtype (Formal_Type)\n             then\n                Set_Extra_Constrained\n-                 (Formal,\n-                  Add_Extra_Formal\n-                    (Formal, Standard_Boolean, Scope (Formal), \"F\"));\n+                 (Formal, Add_Extra_Formal (Formal, Standard_Boolean, E, \"F\"));\n             end if;\n          end if;\n \n@@ -4745,6 +4772,8 @@ package body Sem_Ch6 is\n          --  case can occur when Expand_Dispatching_Call creates a subprogram\n          --  type and substitutes the types of access-to-class-wide actuals\n          --  for the anonymous access-to-specific-type of controlling formals.\n+         --  Base_Type is applied because in cases where there is a null\n+         --  exclusion the formal may have an access subtype.\n \n          --  This is suppressed if we specifically suppress accessibility\n          --  checks at the package level for either the subprogram, or the\n@@ -4754,9 +4783,9 @@ package body Sem_Ch6 is\n          --  different suppression setting. The explicit checks at the\n          --  package level are safe from this point of view.\n \n-         if (Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n+         if (Ekind (Base_Type (Etype (Formal))) = E_Anonymous_Access_Type\n               or else (Is_Controlling_Formal (Formal)\n-                        and then Is_Access_Type (Etype (Formal))))\n+                        and then Is_Access_Type (Base_Type (Etype (Formal)))))\n            and then not\n              (Explicit_Suppress (E, Accessibility_Check)\n                or else\n@@ -4773,9 +4802,7 @@ package body Sem_Ch6 is\n               and then Nkind (Parent (Parent (Parent (E)))) /= N_Protected_Body\n             then\n                Set_Extra_Accessibility\n-                 (Formal,\n-                  Add_Extra_Formal\n-                    (Formal, Standard_Natural, Scope (Formal), \"F\"));\n+                 (Formal, Add_Extra_Formal (Formal, Standard_Natural, E, \"F\"));\n             end if;\n          end if;\n \n@@ -4984,7 +5011,6 @@ package body Sem_Ch6 is\n \n    begin\n       E := Current_Entity (Designator);\n-\n       while Present (E) loop\n \n          --  We are looking for a matching spec. It must have the same scope,\n@@ -5059,10 +5085,9 @@ package body Sem_Ch6 is\n               and then\n                 Nkind (Unit_Declaration_Node (Designator)) = N_Subprogram_Body\n               and then\n-                Nkind (Parent (Unit_Declaration_Node (Designator)))\n-                  = N_Compilation_Unit\n+                Nkind (Parent (Unit_Declaration_Node (Designator))) =\n+                                                             N_Compilation_Unit\n             then\n-\n                --  Child units cannot be overloaded, so a conformance mismatch\n                --  between body and a previous spec is an error.\n \n@@ -5482,6 +5507,10 @@ package body Sem_Ch6 is\n       function Conforming_Ranges (R1, R2 : Node_Id) return Boolean;\n       --  Check both bounds\n \n+      -----------------------\n+      -- Conforming_Bounds --\n+      -----------------------\n+\n       function Conforming_Bounds (B1, B2 : Node_Id) return Boolean is\n       begin\n          if Is_Entity_Name (B1)\n@@ -5495,6 +5524,10 @@ package body Sem_Ch6 is\n          end if;\n       end Conforming_Bounds;\n \n+      -----------------------\n+      -- Conforming_Ranges --\n+      -----------------------\n+\n       function Conforming_Ranges (R1, R2 : Node_Id) return Boolean is\n       begin\n          return\n@@ -5566,9 +5599,8 @@ package body Sem_Ch6 is\n       G_Typ  : Entity_Id := Empty;\n \n       function Get_Generic_Parent_Type (F_Typ : Entity_Id) return Entity_Id;\n-      --  If F_Type is a derived type associated with a generic actual\n-      --  subtype, then return its Generic_Parent_Type attribute, else return\n-      --  Empty.\n+      --  If F_Type is a derived type associated with a generic actual subtype,\n+      --  then return its Generic_Parent_Type attribute, else return Empty.\n \n       function Types_Correspond\n         (P_Type : Entity_Id;\n@@ -5793,9 +5825,9 @@ package body Sem_Ch6 is\n                Make_Defining_Identifier (Sloc (FF),\n                  Chars => Chars (FF));\n \n-         B  : constant Entity_Id :=\n-                Make_Defining_Identifier (Sloc (NF),\n-                  Chars => Chars (NF));\n+         B : constant Entity_Id :=\n+               Make_Defining_Identifier (Sloc (NF),\n+                 Chars => Chars (NF));\n \n       begin\n          Op_Name := Make_Defining_Operator_Symbol (Loc, Name_Op_Ne);\n@@ -5862,7 +5894,6 @@ package body Sem_Ch6 is\n    begin\n       F := First_Formal (Fun);\n       B := True;\n-\n       while Present (F) loop\n          if No (Default_Value (F)) then\n             B := False;\n@@ -5898,12 +5929,23 @@ package body Sem_Ch6 is\n       --  Set if the current scope has an operation that is type-conformant\n       --  with S, and becomes hidden by S.\n \n+      Is_Primitive_Subp : Boolean;\n+      --  Set to True if the new subprogram is primitive\n+\n       E : Entity_Id;\n       --  Entity that S overrides\n \n       Prev_Vis : Entity_Id := Empty;\n       --  Predecessor of E in Homonym chain\n \n+      procedure Check_For_Primitive_Subprogram\n+        (Is_Primitive  : out Boolean;\n+         Is_Overriding : Boolean := False);\n+      --  If the subprogram being analyzed is a primitive operation of the type\n+      --  of a formal or result, set the Has_Primitive_Operations flag on the\n+      --  type, and set Is_Primitive to True (otherwise set to False). Set the\n+      --  corresponding flag on the entity itself for later use.\n+\n       procedure Check_Synchronized_Overriding\n         (Def_Id          : Entity_Id;\n          First_Hom       : Entity_Id;\n@@ -5921,130 +5963,14 @@ package body Sem_Ch6 is\n       --  set when freezing entities, so we must examine the place of the\n       --  declaration in the tree, and recognize wrapper packages as well.\n \n-      procedure Maybe_Primitive_Operation (Is_Overriding : Boolean := False);\n-      --  If the subprogram being analyzed is a primitive operation of\n-      --  the type of one of its formals, set the corresponding flag.\n+      ------------------------------------\n+      -- Check_For_Primitive_Subprogram --\n+      ------------------------------------\n \n-      -----------------------------------\n-      -- Check_Synchronized_Overriding --\n-      -----------------------------------\n-\n-      procedure Check_Synchronized_Overriding\n-        (Def_Id          : Entity_Id;\n-         First_Hom       : Entity_Id;\n-         Overridden_Subp : out Entity_Id)\n+      procedure Check_For_Primitive_Subprogram\n+        (Is_Primitive  : out Boolean;\n+         Is_Overriding : Boolean := False)\n       is\n-         Formal_Typ  : Entity_Id;\n-         Ifaces_List : Elist_Id;\n-         In_Scope    : Boolean;\n-         Typ         : Entity_Id;\n-\n-      begin\n-         Overridden_Subp := Empty;\n-\n-         --  Def_Id must be an entry or a subprogram\n-\n-         if Ekind (Def_Id) /= E_Entry\n-           and then Ekind (Def_Id) /= E_Function\n-           and then Ekind (Def_Id) /= E_Procedure\n-         then\n-            return;\n-         end if;\n-\n-         --  Search for the concurrent declaration since it contains the list\n-         --  of all implemented interfaces. In this case, the subprogram is\n-         --  declared within the scope of a protected or a task type.\n-\n-         if Present (Scope (Def_Id))\n-           and then Is_Concurrent_Type (Scope (Def_Id))\n-           and then not Is_Generic_Actual_Type (Scope (Def_Id))\n-         then\n-            Typ := Scope (Def_Id);\n-            In_Scope := True;\n-\n-         --  The subprogram may be a primitive of a concurrent type\n-\n-         elsif Present (First_Formal (Def_Id)) then\n-            Formal_Typ := Etype (First_Formal (Def_Id));\n-\n-            if Is_Concurrent_Type (Formal_Typ)\n-              and then not Is_Generic_Actual_Type (Formal_Typ)\n-            then\n-               Typ := Formal_Typ;\n-               In_Scope := False;\n-\n-            --  This case occurs when the concurrent type is declared within\n-            --  a generic unit. As a result the corresponding record has been\n-            --  built and used as the type of the first formal, we just have\n-            --  to retrieve the corresponding concurrent type.\n-\n-            elsif Is_Concurrent_Record_Type (Formal_Typ)\n-              and then Present (Corresponding_Concurrent_Type (Formal_Typ))\n-            then\n-               Typ := Corresponding_Concurrent_Type (Formal_Typ);\n-               In_Scope := False;\n-\n-            else\n-               return;\n-            end if;\n-         else\n-            return;\n-         end if;\n-\n-         --  Gather all limited, protected and task interfaces that Typ\n-         --  implements. There is no overriding to check if is an inherited\n-         --  operation in a type derivation on for a generic actual.\n-\n-         if Nkind (Parent (Typ)) /= N_Full_Type_Declaration\n-           and then Nkind (Parent (Def_Id)) /= N_Subtype_Declaration\n-           and then Nkind (Parent (Def_Id)) /= N_Task_Type_Declaration\n-           and then Nkind (Parent (Def_Id)) /= N_Protected_Type_Declaration\n-         then\n-            Collect_Abstract_Interfaces (Typ, Ifaces_List);\n-\n-            if not Is_Empty_Elmt_List (Ifaces_List) then\n-               Overridden_Subp :=\n-                 Find_Overridden_Synchronized_Primitive\n-                   (Def_Id, First_Hom, Ifaces_List, In_Scope);\n-            end if;\n-         end if;\n-      end Check_Synchronized_Overriding;\n-\n-      ----------------------------\n-      -- Is_Private_Declaration --\n-      ----------------------------\n-\n-      function Is_Private_Declaration (E : Entity_Id) return Boolean is\n-         Priv_Decls : List_Id;\n-         Decl       : constant Node_Id := Unit_Declaration_Node (E);\n-\n-      begin\n-         if Is_Package_Or_Generic_Package (Current_Scope)\n-           and then In_Private_Part (Current_Scope)\n-         then\n-            Priv_Decls :=\n-              Private_Declarations (\n-                Specification (Unit_Declaration_Node (Current_Scope)));\n-\n-            return In_Package_Body (Current_Scope)\n-              or else\n-                (Is_List_Member (Decl)\n-                   and then List_Containing (Decl) = Priv_Decls)\n-              or else (Nkind (Parent (Decl)) = N_Package_Specification\n-                         and then not Is_Compilation_Unit (\n-                           Defining_Entity (Parent (Decl)))\n-                         and then List_Containing (Parent (Parent (Decl)))\n-                           = Priv_Decls);\n-         else\n-            return False;\n-         end if;\n-      end Is_Private_Declaration;\n-\n-      -------------------------------\n-      -- Maybe_Primitive_Operation --\n-      -------------------------------\n-\n-      procedure Maybe_Primitive_Operation (Is_Overriding : Boolean := False) is\n          Formal : Entity_Id;\n          F_Typ  : Entity_Id;\n          B_Typ  : Entity_Id;\n@@ -6079,7 +6005,7 @@ package body Sem_Ch6 is\n                            or else not Is_Abstract_Subprogram (E))\n                then\n                   Error_Msg_N (\"abstract subprograms must be visible \"\n-                                   & \"('R'M 3.9.3(10))!\", S);\n+                                   & \"(RM 3.9.3(10))!\", S);\n \n                elsif Ekind (S) = E_Function\n                  and then Is_Tagged_Type (T)\n@@ -6091,7 +6017,7 @@ package body Sem_Ch6 is\n                      & \" override visible-part function\", S);\n                   Error_Msg_N\n                     (\"\\move subprogram to the visible part\"\n-                     & \" ('R'M 3.9.3(10))\", S);\n+                     & \" (RM 3.9.3(10))\", S);\n                end if;\n             end if;\n          end Check_Private_Overriding;\n@@ -6141,29 +6067,42 @@ package body Sem_Ch6 is\n             return False;\n          end Visible_Part_Type;\n \n-      --  Start of processing for Maybe_Primitive_Operation\n+      --  Start of processing for Check_For_Primitive_Subprogram\n \n       begin\n+         Is_Primitive := False;\n+\n          if not Comes_From_Source (S) then\n             null;\n \n-         --  If the subprogram is at library level, it is not primitive\n-         --  operation.\n+         --  If subprogram is at library level, it is not primitive operation\n \n          elsif Current_Scope = Standard_Standard then\n             null;\n \n-         elsif (Ekind (Current_Scope) = E_Package\n+         elsif ((Ekind (Current_Scope) = E_Package\n+                  or else Ekind (Current_Scope) = E_Generic_Package)\n                  and then not In_Package_Body (Current_Scope))\n            or else Is_Overriding\n          then\n             --  For function, check return type\n \n             if Ekind (S) = E_Function then\n-               B_Typ := Base_Type (Etype (S));\n+               if Ekind (Etype (S)) = E_Anonymous_Access_Type then\n+                  F_Typ := Designated_Type (Etype (S));\n+               else\n+                  F_Typ := Etype (S);\n+               end if;\n+\n+               B_Typ := Base_Type (F_Typ);\n \n-               if Scope (B_Typ) = Current_Scope then\n+               if Scope (B_Typ) = Current_Scope\n+                 and then not Is_Class_Wide_Type (B_Typ)\n+                 and then not Is_Generic_Type (B_Typ)\n+               then\n+                  Is_Primitive := True;\n                   Set_Has_Primitive_Operations (B_Typ);\n+                  Set_Is_Primitive (S);\n                   Check_Private_Overriding (B_Typ);\n                end if;\n             end if;\n@@ -6184,15 +6123,135 @@ package body Sem_Ch6 is\n                   B_Typ := Base_Type (B_Typ);\n                end if;\n \n-               if Scope (B_Typ) = Current_Scope then\n+               if Scope (B_Typ) = Current_Scope\n+                 and then not Is_Class_Wide_Type (B_Typ)\n+                 and then not Is_Generic_Type (B_Typ)\n+               then\n+                  Is_Primitive := True;\n+                  Set_Is_Primitive (S);\n                   Set_Has_Primitive_Operations (B_Typ);\n                   Check_Private_Overriding (B_Typ);\n                end if;\n \n                Next_Formal (Formal);\n             end loop;\n          end if;\n-      end Maybe_Primitive_Operation;\n+      end Check_For_Primitive_Subprogram;\n+\n+      -----------------------------------\n+      -- Check_Synchronized_Overriding --\n+      -----------------------------------\n+\n+      procedure Check_Synchronized_Overriding\n+        (Def_Id          : Entity_Id;\n+         First_Hom       : Entity_Id;\n+         Overridden_Subp : out Entity_Id)\n+      is\n+         Formal_Typ  : Entity_Id;\n+         Ifaces_List : Elist_Id;\n+         In_Scope    : Boolean;\n+         Typ         : Entity_Id;\n+\n+      begin\n+         Overridden_Subp := Empty;\n+\n+         --  Def_Id must be an entry or a subprogram\n+\n+         if Ekind (Def_Id) /= E_Entry\n+           and then Ekind (Def_Id) /= E_Function\n+           and then Ekind (Def_Id) /= E_Procedure\n+         then\n+            return;\n+         end if;\n+\n+         --  Search for the concurrent declaration since it contains the list\n+         --  of all implemented interfaces. In this case, the subprogram is\n+         --  declared within the scope of a protected or a task type.\n+\n+         if Present (Scope (Def_Id))\n+           and then Is_Concurrent_Type (Scope (Def_Id))\n+           and then not Is_Generic_Actual_Type (Scope (Def_Id))\n+         then\n+            Typ := Scope (Def_Id);\n+            In_Scope := True;\n+\n+         --  The subprogram may be a primitive of a concurrent type\n+\n+         elsif Present (First_Formal (Def_Id)) then\n+            Formal_Typ := Etype (First_Formal (Def_Id));\n+\n+            if Is_Concurrent_Type (Formal_Typ)\n+              and then not Is_Generic_Actual_Type (Formal_Typ)\n+            then\n+               Typ := Formal_Typ;\n+               In_Scope := False;\n+\n+            --  This case occurs when the concurrent type is declared within\n+            --  a generic unit. As a result the corresponding record has been\n+            --  built and used as the type of the first formal, we just have\n+            --  to retrieve the corresponding concurrent type.\n+\n+            elsif Is_Concurrent_Record_Type (Formal_Typ)\n+              and then Present (Corresponding_Concurrent_Type (Formal_Typ))\n+            then\n+               Typ := Corresponding_Concurrent_Type (Formal_Typ);\n+               In_Scope := False;\n+\n+            else\n+               return;\n+            end if;\n+         else\n+            return;\n+         end if;\n+\n+         --  Gather all limited, protected and task interfaces that Typ\n+         --  implements. There is no overriding to check if is an inherited\n+         --  operation in a type derivation on for a generic actual.\n+\n+         if Nkind (Parent (Typ)) /= N_Full_Type_Declaration\n+           and then Nkind (Parent (Def_Id)) /= N_Subtype_Declaration\n+           and then Nkind (Parent (Def_Id)) /= N_Task_Type_Declaration\n+           and then Nkind (Parent (Def_Id)) /= N_Protected_Type_Declaration\n+         then\n+            Collect_Abstract_Interfaces (Typ, Ifaces_List);\n+\n+            if not Is_Empty_Elmt_List (Ifaces_List) then\n+               Overridden_Subp :=\n+                 Find_Overridden_Synchronized_Primitive\n+                   (Def_Id, First_Hom, Ifaces_List, In_Scope);\n+            end if;\n+         end if;\n+      end Check_Synchronized_Overriding;\n+\n+      ----------------------------\n+      -- Is_Private_Declaration --\n+      ----------------------------\n+\n+      function Is_Private_Declaration (E : Entity_Id) return Boolean is\n+         Priv_Decls : List_Id;\n+         Decl       : constant Node_Id := Unit_Declaration_Node (E);\n+\n+      begin\n+         if Is_Package_Or_Generic_Package (Current_Scope)\n+           and then In_Private_Part (Current_Scope)\n+         then\n+            Priv_Decls :=\n+              Private_Declarations (\n+                Specification (Unit_Declaration_Node (Current_Scope)));\n+\n+            return In_Package_Body (Current_Scope)\n+              or else\n+                (Is_List_Member (Decl)\n+                   and then List_Containing (Decl) = Priv_Decls)\n+              or else (Nkind (Parent (Decl)) = N_Package_Specification\n+                         and then not Is_Compilation_Unit (\n+                           Defining_Entity (Parent (Decl)))\n+                         and then List_Containing (Parent (Parent (Decl)))\n+                           = Priv_Decls);\n+         else\n+            return False;\n+         end if;\n+      end Is_Private_Declaration;\n \n    --  Start of processing for New_Overloaded_Entity\n \n@@ -6208,14 +6267,15 @@ package body Sem_Ch6 is\n       if No (E) then\n          Enter_Overloaded_Entity (S);\n          Check_Dispatching_Operation (S, Empty);\n-         Maybe_Primitive_Operation;\n+         Check_For_Primitive_Subprogram (Is_Primitive_Subp);\n \n          --  If subprogram has an explicit declaration, check whether it\n          --  has an overriding indicator.\n \n          if Comes_From_Source (S) then\n             Check_Synchronized_Overriding (S, Homonym (S), Overridden_Subp);\n-            Check_Overriding_Indicator (S, Overridden_Subp);\n+            Check_Overriding_Indicator\n+              (S, Overridden_Subp, Is_Primitive => Is_Primitive_Subp);\n          end if;\n \n       --  If there is a homonym that is not overloadable, then we have an\n@@ -6241,7 +6301,7 @@ package body Sem_Ch6 is\n             Enter_Overloaded_Entity (S);\n             Set_Homonym (S, Homonym (E));\n             Check_Dispatching_Operation (S, Empty);\n-            Check_Overriding_Indicator (S, Empty);\n+            Check_Overriding_Indicator (S, Empty, Is_Primitive => False);\n \n          --  If the subprogram is implicit it is hidden by the previous\n          --  declaration. However if it is dispatching, it must appear in the\n@@ -6261,12 +6321,14 @@ package body Sem_Ch6 is\n \n          else\n             Error_Msg_Sloc := Sloc (E);\n-            Error_Msg_N (\"& conflicts with declaration#\", S);\n \n-            --  Useful additional warning\n+            --  Generate message,with useful additionalwarning if in generic\n \n             if Is_Generic_Unit (E) then\n-               Error_Msg_N (\"\\previous generic unit cannot be overloaded\", S);\n+               Error_Msg_N (\"previous generic unit cannot be overloaded\", S);\n+               Error_Msg_N (\"\\& conflicts with declaration#\", S);\n+            else\n+               Error_Msg_N (\"& conflicts with declaration#\", S);\n             end if;\n \n             return;\n@@ -6349,7 +6411,7 @@ package body Sem_Ch6 is\n                   Set_Is_Overriding_Operation (E);\n \n                   if Comes_From_Source (E) then\n-                     Check_Overriding_Indicator (E, S);\n+                     Check_Overriding_Indicator (E, S, Is_Primitive => False);\n \n                      --  Indicate that E overrides the operation from which\n                      --  S is inherited.\n@@ -6513,7 +6575,7 @@ package body Sem_Ch6 is\n \n                      Enter_Overloaded_Entity (S);\n                      Set_Is_Overriding_Operation (S);\n-                     Check_Overriding_Indicator (S, E);\n+                     Check_Overriding_Indicator (S, E, Is_Primitive => True);\n \n                      --  Indicate that S overrides the operation from which\n                      --  E is inherited.\n@@ -6539,7 +6601,8 @@ package body Sem_Ch6 is\n                         Check_Dispatching_Operation (S, Empty);\n                      end if;\n \n-                     Maybe_Primitive_Operation (Is_Overriding => True);\n+                     Check_For_Primitive_Subprogram\n+                       (Is_Primitive_Subp, Is_Overriding => True);\n                      goto Check_Inequality;\n                   end;\n \n@@ -6567,13 +6630,17 @@ package body Sem_Ch6 is\n \n                   Set_Scope (S, Current_Scope);\n \n-                  Error_Msg_N (\"& conflicts with declaration#\", S);\n+                  --  Generate error, with extra useful warning for the case\n+                  --  of a generic instance with no completion.\n \n                   if Is_Generic_Instance (S)\n                     and then not Has_Completion (E)\n                   then\n                      Error_Msg_N\n-                       (\"\\instantiation cannot provide body for it\", S);\n+                       (\"instantiation cannot provide body for&\", S);\n+                     Error_Msg_N (\"\\& conflicts with declaration#\", S);\n+                  else\n+                     Error_Msg_N (\"& conflicts with declaration#\", S);\n                   end if;\n \n                   return;\n@@ -6632,8 +6699,9 @@ package body Sem_Ch6 is\n          --  On exit, we know that S is a new entity\n \n          Enter_Overloaded_Entity (S);\n-         Maybe_Primitive_Operation;\n-         Check_Overriding_Indicator (S, Overridden_Subp);\n+         Check_For_Primitive_Subprogram (Is_Primitive_Subp);\n+         Check_Overriding_Indicator\n+           (S, Overridden_Subp, Is_Primitive => Is_Primitive_Subp);\n \n          --  If S is a derived operation for an untagged type then by\n          --  definition it's not a dispatching operation (even if the parent\n@@ -6701,10 +6769,9 @@ package body Sem_Ch6 is\n       --  analyzed. The Ekind is established in a separate loop at the end.\n \n       Param_Spec := First (T);\n-\n       while Present (Param_Spec) loop\n-\n          Formal := Defining_Identifier (Param_Spec);\n+         Set_Never_Set_In_Source (Formal, True);\n          Enter_Name (Formal);\n \n          --  Case of ordinary parameters"}, {"sha": "bbcc7bb9fd69a2215d6550aed5ce660e2726f7ea", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d37ba92f667fc076287b111dd3166b8d48012b8/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=5d37ba92f667fc076287b111dd3166b8d48012b8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,7 @@ package Sem_Ch6 is\n    procedure Analyze_Operator_Symbol                 (N : Node_Id);\n    procedure Analyze_Parameter_Association           (N : Node_Id);\n    procedure Analyze_Procedure_Call                  (N : Node_Id);\n-   procedure Analyze_Return_Statement                (N : Node_Id);\n+   procedure Analyze_Simple_Return_Statement         (N : Node_Id);\n    procedure Analyze_Subprogram_Declaration          (N : Node_Id);\n    procedure Analyze_Subprogram_Body                 (N : Node_Id);\n "}]}