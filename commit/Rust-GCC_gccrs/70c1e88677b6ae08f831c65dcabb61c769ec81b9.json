{"sha": "70c1e88677b6ae08f831c65dcabb61c769ec81b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBjMWU4ODY3N2I2YWUwOGY4MzFjNjVkY2FiYjYxYzc2OWVjODFiOQ==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2016-01-18T12:40:43Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2016-01-18T12:40:43Z"}, "message": "Equate MEM_REFs and ARRAY_REFs in tree-ssa-scopedtables.c\n\nPR target/63679\n\ngcc/:\n\n\t* tree-ssa-scopedtables.c (avail_expr_hash): Hash MEM_REF and ARRAY_REF\n\tusing get_ref_base_and_extent.\n\t(equal_mem_array_ref_p): New.\n\t(hashable_expr_equal_p): Add call to previous.\n\ngcc/testsuite/:\n\n        * gcc.dg/tree-ssa/ssa-dom-cse-5.c: New.\n        * gcc.dg/tree-ssa/ssa-dom-cse-6.c: New.\n        * gcc.dg/tree-ssa/ssa-dom-cse-7.c: New.\n\nFrom-SVN: r232508", "tree": {"sha": "eaea0b92557fe575b8ace8128f18a7c2ea06d16e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaea0b92557fe575b8ace8128f18a7c2ea06d16e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70c1e88677b6ae08f831c65dcabb61c769ec81b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70c1e88677b6ae08f831c65dcabb61c769ec81b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70c1e88677b6ae08f831c65dcabb61c769ec81b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70c1e88677b6ae08f831c65dcabb61c769ec81b9/comments", "author": null, "committer": null, "parents": [{"sha": "d75d9f91e3b35766c80935212f248fc72ae48f58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75d9f91e3b35766c80935212f248fc72ae48f58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75d9f91e3b35766c80935212f248fc72ae48f58"}], "stats": {"total": 141, "additions": 138, "deletions": 3}, "files": [{"sha": "26d7af09aed960bd323199f9ad199e1442bbb184", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70c1e88677b6ae08f831c65dcabb61c769ec81b9", "patch": "@@ -1,3 +1,11 @@\n+2016-01-18  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR target/63679\n+\t* tree-ssa-scopedtables.c (avail_expr_hash): Hash MEM_REF and ARRAY_REF\n+\tusing get_ref_base_and_extent.\n+\t(equal_mem_array_ref_p): New.\n+\t(hashable_expr_equal_p): Add call to previous.\n+\n 2016-01-18  Alan Lawrence  <alan.lawrence@arm.com>\n \n \tPR target/63679"}, {"sha": "81bd301a01ad39323e89c52c0a51853cc21076a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70c1e88677b6ae08f831c65dcabb61c769ec81b9", "patch": "@@ -1,3 +1,10 @@\n+2016-01-18  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR target/63679\n+\t* gcc.dg/tree-ssa/ssa-dom-cse-5.c: New.\n+\t* gcc.dg/tree-ssa/ssa-dom-cse-6.c: New.\n+\t* gcc.dg/tree-ssa/ssa-dom-cse-7.c: New.\n+\n 2016-01-18  Alan Lawrence  <alan.lawrence@arm.com>\n \n \tPR target/63679"}, {"sha": "cd38d3eb537fa2e6b68a91b47478d6b7abbebc83", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-5.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-5.c?ref=70c1e88677b6ae08f831c65dcabb61c769ec81b9", "patch": "@@ -0,0 +1,18 @@\n+/* Test normalization of ARRAY_REF expressions to MEM_REFs in dom.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-dom2\" } */\n+\n+#define N 8\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int a[N];\n+  for (int i = 0; i < N; i++)\n+    a[i] = 2*i + 1;\n+  int *p = &a[0];\n+  __builtin_printf (\"%d\\n\", a[argc]);\n+  return *(++p);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 3;\" 1 \"dom2\"} } */"}, {"sha": "002fd81367dc35abb960014f06e5110f6c5c67ce", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-6.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-6.c?ref=70c1e88677b6ae08f831c65dcabb61c769ec81b9", "patch": "@@ -0,0 +1,20 @@\n+/* Test normalization of ARRAY_REF expressions to MEM_REFs in dom.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-tree-fre -fdump-tree-dom2\" } */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  union {\n+    int a[4];\n+    int b[2];\n+  } u;\n+  u.a[0] = 1;\n+  u.a[1] = 42;\n+  u.a[2] = 3;\n+  u.a[3] = 4;\n+  __builtin_printf (\"%d\\n\", u.a[argc]);\n+  return u.b[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 42;\" 1 \"dom2\" } } */"}, {"sha": "151e5d4e3436aa30247f373bbc77a05311948123", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-7.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-7.c?ref=70c1e88677b6ae08f831c65dcabb61c769ec81b9", "patch": "@@ -0,0 +1,21 @@\n+/* Test normalization of MEM_REF expressions in dom.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-tree-fre -fno-tree-pre -fdump-tree-optimized\" } */\n+\n+typedef struct {\n+  int a[8];\n+} foo;\n+\n+foo f;\n+\n+int\n+test ()\n+{\n+  foo g;\n+  g.a[0] = 1; g.a[1] = 2; g.a[2] = 3; g.a[3] = 4;\n+  g.a[4] = 5; g.a[5] = 6; g.a[6] = 7; g.a[7] = 8;\n+  f=g;\n+  return f.a[2];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 3;\" 1 \"optimized\" } } */"}, {"sha": "af79535cc02718e9c7b7095d44ed7fd37afd9dd8", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70c1e88677b6ae08f831c65dcabb61c769ec81b9/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=70c1e88677b6ae08f831c65dcabb61c769ec81b9", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"tree-eh.h\"\n #include \"internal-fn.h\"\n+#include \"tree-dfa.h\"\n \n static bool hashable_expr_equal_p (const struct hashable_expr *,\n \t\t\t\t   const struct hashable_expr *);\n@@ -209,11 +210,70 @@ avail_expr_hash (class expr_hash_elt *p)\n   const struct hashable_expr *expr = p->expr ();\n   inchash::hash hstate;\n \n+  if (expr->kind == EXPR_SINGLE)\n+    {\n+      /* T could potentially be a switch index or a goto dest.  */\n+      tree t = expr->ops.single.rhs;\n+      if (TREE_CODE (t) == MEM_REF || TREE_CODE (t) == ARRAY_REF)\n+\t{\n+\t  /* Make equivalent statements of both these kinds hash together.\n+\t     Dealing with both MEM_REF and ARRAY_REF allows us not to care\n+\t     about equivalence with other statements not considered here.  */\n+\t  bool reverse;\n+\t  HOST_WIDE_INT offset, size, max_size;\n+\t  tree base = get_ref_base_and_extent (t, &offset, &size, &max_size,\n+\t\t\t\t\t       &reverse);\n+\t  /* Strictly, we could try to normalize variable-sized accesses too,\n+\t    but here we just deal with the common case.  */\n+\t  if (size == max_size)\n+\t    {\n+\t      enum tree_code code = MEM_REF;\n+\t      hstate.add_object (code);\n+\t      inchash::add_expr (base, hstate);\n+\t      hstate.add_object (offset);\n+\t      hstate.add_object (size);\n+\t      return hstate.end ();\n+\t    }\n+\t}\n+    }\n+\n   inchash::add_hashable_expr (expr, hstate);\n \n   return hstate.end ();\n }\n \n+/* Compares trees T0 and T1 to see if they are MEM_REF or ARRAY_REFs equivalent\n+   to each other.  (That is, they return the value of the same bit of memory.)\n+\n+   Return TRUE if the two are so equivalent; FALSE if not (which could still\n+   mean the two are equivalent by other means).  */\n+\n+static bool\n+equal_mem_array_ref_p (tree t0, tree t1)\n+{\n+  if (TREE_CODE (t0) != MEM_REF && TREE_CODE (t0) != ARRAY_REF)\n+    return false;\n+  if (TREE_CODE (t1) != MEM_REF && TREE_CODE (t1) != ARRAY_REF)\n+    return false;\n+\n+  if (!types_compatible_p (TREE_TYPE (t0), TREE_TYPE (t1)))\n+    return false;\n+  bool rev0;\n+  HOST_WIDE_INT off0, sz0, max0;\n+  tree base0 = get_ref_base_and_extent (t0, &off0, &sz0, &max0, &rev0);\n+\n+  bool rev1;\n+  HOST_WIDE_INT off1, sz1, max1;\n+  tree base1 = get_ref_base_and_extent (t1, &off1, &sz1, &max1, &rev1);\n+\n+  /* Types were compatible, so these are sanity checks.  */\n+  gcc_assert (sz0 == sz1);\n+  gcc_assert (max0 == max1);\n+  gcc_assert (rev0 == rev1);\n+\n+  return (off0 == off1) && operand_equal_p (base0, base1, 0);\n+}\n+\n /* Compare two hashable_expr structures for equivalence.  They are\n    considered equivalent when the expressions they denote must\n    necessarily be equal.  The logic is intended to follow that of\n@@ -246,9 +306,10 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n   switch (expr0->kind)\n     {\n     case EXPR_SINGLE:\n-      return operand_equal_p (expr0->ops.single.rhs,\n-                              expr1->ops.single.rhs, 0);\n-\n+      return equal_mem_array_ref_p (expr0->ops.single.rhs,\n+\t\t\t\t    expr1->ops.single.rhs)\n+\t     || operand_equal_p (expr0->ops.single.rhs,\n+\t\t\t\t expr1->ops.single.rhs, 0);\n     case EXPR_UNARY:\n       if (expr0->ops.unary.op != expr1->ops.unary.op)\n         return false;"}]}