{"sha": "1e0424d998298dc3f290309c4c72108c4271de3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUwNDI0ZDk5ODI5OGRjM2YyOTAzMDljNGM3MjEwOGM0MjcxZGUzYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-01-17T18:32:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-01-17T18:32:13Z"}, "message": "re PR debug/78839 (DWARF output different between GCC 5 and 6)\n\n\tPR debug/78839\n\t* dwarf2out.c (field_byte_offset): Restore the\n\tPCC_BITFIELD_TYPE_MATTERS behavior for INTEGER_CST DECL_FIELD_OFFSET\n\tand DECL_FIELD_BIT_OFFSET.  Use fold_build2 instead of build2 + fold.\n\t(analyze_variants_discr, gen_variant_part): Use fold_build2 instead\n\tof build2 + fold.\n\nFrom-SVN: r244545", "tree": {"sha": "170abd4b9d4290fbd2968269f752e237ae875729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/170abd4b9d4290fbd2968269f752e237ae875729"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e0424d998298dc3f290309c4c72108c4271de3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e0424d998298dc3f290309c4c72108c4271de3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e0424d998298dc3f290309c4c72108c4271de3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e0424d998298dc3f290309c4c72108c4271de3c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ddfdbc265cfe0da5b727559d3736876d0198afb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ddfdbc265cfe0da5b727559d3736876d0198afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ddfdbc265cfe0da5b727559d3736876d0198afb"}], "stats": {"total": 54, "additions": 34, "deletions": 20}, "files": [{"sha": "0670beb92271ef33f2765195b1cf2ab103dfcd4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0424d998298dc3f290309c4c72108c4271de3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0424d998298dc3f290309c4c72108c4271de3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e0424d998298dc3f290309c4c72108c4271de3c", "patch": "@@ -1,3 +1,12 @@\n+2017-01-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/78839\n+\t* dwarf2out.c (field_byte_offset): Restore the\n+\tPCC_BITFIELD_TYPE_MATTERS behavior for INTEGER_CST DECL_FIELD_OFFSET\n+\tand DECL_FIELD_BIT_OFFSET.  Use fold_build2 instead of build2 + fold.\n+\t(analyze_variants_discr, gen_variant_part): Use fold_build2 instead\n+\tof build2 + fold.\n+\n 2017-01-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/67205"}, {"sha": "169da86dace18f29cf16dd896ab25bc6b70e2abf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e0424d998298dc3f290309c4c72108c4271de3c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e0424d998298dc3f290309c4c72108c4271de3c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1e0424d998298dc3f290309c4c72108c4271de3c", "patch": "@@ -17980,10 +17980,6 @@ static dw_loc_descr_ref\n field_byte_offset (const_tree decl, struct vlr_context *ctx,\n \t\t   HOST_WIDE_INT *cst_offset)\n {\n-  offset_int object_offset_in_bits;\n-  offset_int object_offset_in_bytes;\n-  offset_int bitpos_int;\n-  bool is_byte_offset_cst, is_bit_offset_cst;\n   tree tree_result;\n   dw_loc_list_ref loc_result;\n \n@@ -17994,20 +17990,21 @@ field_byte_offset (const_tree decl, struct vlr_context *ctx,\n   else\n     gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n-  is_bit_offset_cst = TREE_CODE (DECL_FIELD_BIT_OFFSET (decl)) != INTEGER_CST;\n-  is_byte_offset_cst = TREE_CODE (DECL_FIELD_OFFSET (decl)) != INTEGER_CST;\n-\n   /* We cannot handle variable bit offsets at the moment, so abort if it's the\n      case.  */\n-  if (is_bit_offset_cst)\n+  if (TREE_CODE (DECL_FIELD_BIT_OFFSET (decl)) != INTEGER_CST)\n     return NULL;\n \n #ifdef PCC_BITFIELD_TYPE_MATTERS\n   /* We used to handle only constant offsets in all cases.  Now, we handle\n      properly dynamic byte offsets only when PCC bitfield type doesn't\n      matter.  */\n-  if (PCC_BITFIELD_TYPE_MATTERS && is_byte_offset_cst && is_bit_offset_cst)\n+  if (PCC_BITFIELD_TYPE_MATTERS\n+      && TREE_CODE (DECL_FIELD_OFFSET (decl)) == INTEGER_CST)\n     {\n+      offset_int object_offset_in_bits;\n+      offset_int object_offset_in_bytes;\n+      offset_int bitpos_int;\n       tree type;\n       tree field_size_tree;\n       offset_int deepest_bitpos;\n@@ -18102,13 +18099,23 @@ field_byte_offset (const_tree decl, struct vlr_context *ctx,\n \t  object_offset_in_bits\n \t    = round_up_to_align (object_offset_in_bits, decl_align_in_bits);\n \t}\n+\n+      object_offset_in_bytes\n+\t= wi::lrshift (object_offset_in_bits, LOG2_BITS_PER_UNIT);\n+      if (ctx->variant_part_offset == NULL_TREE)\n+\t{\n+\t  *cst_offset = object_offset_in_bytes.to_shwi ();\n+\t  return NULL;\n+\t}\n+      tree_result = wide_int_to_tree (sizetype, object_offset_in_bytes);\n     }\n+  else\n #endif /* PCC_BITFIELD_TYPE_MATTERS */\n+    tree_result = byte_position (decl);\n \n-  tree_result = byte_position (decl);\n   if (ctx->variant_part_offset != NULL_TREE)\n-    tree_result = fold (build2 (PLUS_EXPR, TREE_TYPE (tree_result),\n-\t\t\t\tctx->variant_part_offset, tree_result));\n+    tree_result = fold_build2 (PLUS_EXPR, TREE_TYPE (tree_result),\n+\t\t\t       ctx->variant_part_offset, tree_result);\n \n   /* If the byte offset is a constant, it's simplier to handle a native\n      constant rather than a DWARF expression.  */\n@@ -23744,14 +23751,12 @@ analyze_variants_discr (tree variant_part_decl,\n \n \t      if (!lower_cst_included)\n \t\tlower_cst\n-\t\t  = fold (build2 (PLUS_EXPR, TREE_TYPE (lower_cst),\n-\t\t\t\t  lower_cst,\n-\t\t\t\t  build_int_cst (TREE_TYPE (lower_cst), 1)));\n+\t\t  = fold_build2 (PLUS_EXPR, TREE_TYPE (lower_cst), lower_cst,\n+\t\t\t\t build_int_cst (TREE_TYPE (lower_cst), 1));\n \t      if (!upper_cst_included)\n \t\tupper_cst\n-\t\t  = fold (build2 (MINUS_EXPR, TREE_TYPE (upper_cst),\n-\t\t\t\t  upper_cst,\n-\t\t\t\t  build_int_cst (TREE_TYPE (upper_cst), 1)));\n+\t\t  = fold_build2 (MINUS_EXPR, TREE_TYPE (upper_cst), upper_cst,\n+\t\t\t\t build_int_cst (TREE_TYPE (upper_cst), 1));\n \n \t      if (!get_discr_value (lower_cst,\n \t\t\t\t    &new_node->dw_discr_lower_bound)\n@@ -23922,8 +23927,8 @@ gen_variant_part (tree variant_part_decl, struct vlr_context *vlr_ctx,\n \t\t we recurse.  */\n \n \t      vlr_sub_ctx.variant_part_offset\n-\t        = fold (build2 (PLUS_EXPR, TREE_TYPE (variant_part_offset),\n-\t\t\t\tvariant_part_offset, byte_position (member)));\n+\t\t= fold_build2 (PLUS_EXPR, TREE_TYPE (variant_part_offset),\n+\t\t\t       variant_part_offset, byte_position (member));\n \t      gen_variant_part (member, &vlr_sub_ctx, variant_die);\n \t    }\n \t  else"}]}