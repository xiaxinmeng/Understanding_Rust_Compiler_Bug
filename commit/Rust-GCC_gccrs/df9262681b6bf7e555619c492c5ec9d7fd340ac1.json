{"sha": "df9262681b6bf7e555619c492c5ec9d7fd340ac1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY5MjYyNjgxYjZiZjdlNTU1NjE5YzQ5MmM1ZWM5ZDdmZDM0MGFjMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-09-02T17:25:15Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T17:25:15Z"}, "message": "algorithm [...]: Update to SGI STL 3.11.\n\n\t* algorithm alloc.h defalloc.h hash_map.h hash_set.h iterator\n\tmemory pthread_alloc pthread_alloc.h rope ropeimpl.h stl_algo.h\n\tstl_algobase.h stl_alloc.h stl_bvector.h stl_config.h\n\tstl_construct.h stl_deque.h stl_function.h stl_hash_fun.h\n\tstl_hash_map.h stl_hash_set.h stl_hashtable.h stl_heap.h\n\tstl_iterator.h stl_list.h stl_map.h stl_multimap.h stl_multiset.h\n\tstl_numeric.h stl_pair.h stl_queue.h stl_raw_storage_iter.h\n\tstl_relops.h stl_rope.h stl_set.h stl_slist.h stl_stack.h\n\tstl_tempbuf.h stl_tree.h stl_uninitialized.h stl_vector.h\n\ttempbuf.h type_traits.h: Update to SGI STL 3.11.\n\nFrom-SVN: r22190", "tree": {"sha": "f1b8986118d98ea46eb8767eba9ca67b12541d4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1b8986118d98ea46eb8767eba9ca67b12541d4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df9262681b6bf7e555619c492c5ec9d7fd340ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df9262681b6bf7e555619c492c5ec9d7fd340ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df9262681b6bf7e555619c492c5ec9d7fd340ac1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df9262681b6bf7e555619c492c5ec9d7fd340ac1/comments", "author": null, "committer": null, "parents": [{"sha": "514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/514a1f18eeb8d9b3da90ae36d5913dfabe8203fd"}], "stats": {"total": 26312, "additions": 15026, "deletions": 11286}, "files": [{"sha": "ad471c3bcd2ae73f68e08abdef5bcc01000a3deb", "filename": "libstdc++/stl/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2FChangeLog?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -1,3 +1,16 @@\n+1998-09-02  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* algorithm alloc.h defalloc.h hash_map.h hash_set.h iterator\n+\tmemory pthread_alloc pthread_alloc.h rope ropeimpl.h stl_algo.h\n+\tstl_algobase.h stl_alloc.h stl_bvector.h stl_config.h\n+\tstl_construct.h stl_deque.h stl_function.h stl_hash_fun.h\n+\tstl_hash_map.h stl_hash_set.h stl_hashtable.h stl_heap.h\n+\tstl_iterator.h stl_list.h stl_map.h stl_multimap.h stl_multiset.h\n+\tstl_numeric.h stl_pair.h stl_queue.h stl_raw_storage_iter.h\n+\tstl_relops.h stl_rope.h stl_set.h stl_slist.h stl_stack.h\n+\tstl_tempbuf.h stl_tree.h stl_uninitialized.h stl_vector.h\n+\ttempbuf.h type_traits.h: Update to SGI STL 3.11.\n+\n Fri Jul 10 15:20:09 1998  Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de>\n \n \t* stl_tempbuf.h (temporary_buffer): Add missing typename."}, {"sha": "1ba584f06d4a54895672d0ab5a19576945f1bbff", "filename": "libstdc++/stl/algorithm", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falgorithm?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -29,6 +29,7 @@\n \n #include <stl_algobase.h>\n #include <stl_construct.h>\n+#include <stl_uninitialized.h>\n #include <stl_tempbuf.h>\n #include <stl_algo.h>\n "}, {"sha": "f99a862316eeb9dd2fb7ea4bcdb1bcc15d1c3c4a", "filename": "libstdc++/stl/alloc.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falloc.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -33,7 +33,9 @@ using __STD::single_client_alloc;\n #ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n using __STD::__malloc_alloc_oom_handler; \n #endif /* __STL_STATIC_TEMPLATE_MEMBER_BUG */\n-\n+#ifdef __STL_USE_STD_ALLOCATORS \n+using __STD::allocator;\n+#endif /* __STL_USE_STD_ALLOCATORS */\n \n #endif /* __STL_USE_NAMESPACES */\n "}, {"sha": "0bfcc2c20a51d42f3e6ba252925c4c14799d1218", "filename": "libstdc++/stl/defalloc.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fdefalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fdefalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fdefalloc.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -15,12 +15,13 @@\n \n // Inclusion of this file is DEPRECATED.  This is the original HP\n // default allocator.  It is provided only for backward compatibility.\n-// \n+// This file WILL BE REMOVED in a future release.\n+//\n // DO NOT USE THIS FILE unless you have an old container implementation\n-// that requires an allocator with the HP-style interface.  SGI STL\n-// uses a different allocator interface.  SGI-style allocators are not\n-// parametrized with respect to the object type; they traffic in void *\n-// pointers.  This file is not included by any other SGI STL header.\n+// that requires an allocator with the HP-style interface.  \n+//\n+// Standard-conforming allocators have a very different interface.  The\n+// standard default allocator is declared in the header <memory>.\n \n #ifndef DEFALLOC_H\n #define DEFALLOC_H"}, {"sha": "f3471627044cf80fd32601ff989d71dc959fd147", "filename": "libstdc++/stl/hash_map.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhash_map.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -31,6 +31,7 @@\n #include <stl_hashtable.h>\n #endif \n \n+#include <algobase.h>\n #include <stl_hash_map.h>\n \n #ifdef __STL_USE_NAMESPACES"}, {"sha": "d3e93c0c26bed5fa5301fdcab5b6f0f1c1731180", "filename": "libstdc++/stl/hash_set.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhash_set.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -31,6 +31,7 @@\n #include <stl_hashtable.h>\n #endif \n \n+#include <algobase.h>\n #include <stl_hash_set.h>\n \n #ifdef __STL_USE_NAMESPACES"}, {"sha": "4ddd208f2755d9ecbb5be006b42daa64bf97d023", "filename": "libstdc++/stl/iterator", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fiterator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fiterator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fiterator?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -29,8 +29,12 @@\n \n #include <stl_config.h>\n #include <stl_relops.h>\n-#include <stddef.h>\n+#include <stddef.h>       /* XXX should use <cstddef> */\n+#if 0                     /* XXX define a flag for this */\n+#include <iostream>\n+#else\n #include <iostream.h>\n+#endif\n #include <stl_iterator.h>\n \n #endif /* __SGI_STL_ITERATOR */"}, {"sha": "168843d5d1f320c166716d801ee066f6a1b17f1b", "filename": "libstdc++/stl/memory", "status": "modified", "additions": 61, "deletions": 42, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fmemory?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -22,64 +22,83 @@\n #include <stl_uninitialized.h>\n #include <stl_raw_storage_iter.h>\n \n-// Note: auto_ptr is commented out in this release because the details\n-//  of the interface are still being discussed by the C++ standardization\n-//  committee.  It will be included once the iterface is finalized.\n \n-#if 0\n-#if defined(_MUTABLE_IS_KEYWORD) && defined(_EXPLICIT_IS_KEYWORD) && \\\n-    defined(__STL_MEMBER_TEMPLATES)\n+#if defined(__STL_MEMBER_TEMPLATES)\n \n __STL_BEGIN_NAMESPACE\n \n-template <class X> class auto_ptr {\n+template <class _Tp> class auto_ptr {\n private:\n-  X* ptr;\n-  mutable bool owns;\n+  _Tp* _M_ptr;\n+\n public:\n-  typedef X element_type;\n-  explicit auto_ptr(X* p = 0) __STL_NOTHROW : ptr(p), owns(p) {}\n-  auto_ptr(const auto_ptr& a) __STL_NOTHROW : ptr(a.ptr), owns(a.owns) {\n-    a.owns = 0;\n+  typedef _Tp element_type;\n+  explicit auto_ptr(_Tp* __p = 0) __STL_NOTHROW : _M_ptr(__p) {}\n+  auto_ptr(auto_ptr& __a) __STL_NOTHROW : _M_ptr(__a.release()) {}\n+  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) __STL_NOTHROW\n+    : _M_ptr(__a.release()) {}\n+  auto_ptr& operator=(auto_ptr& __a) __STL_NOTHROW {\n+    if (&__a != this) {\n+      delete _M_ptr;\n+      _M_ptr = __a.release();\n+    }\n+    return *this;\n   }\n-  template <class T> auto_ptr(const auto_ptr<T>& a) __STL_NOTHROW\n-    : ptr(a.ptr), owns(a.owns) {\n-      a.owns = 0;\n+  template <class _Tp1>\n+  auto_ptr& operator=(auto_ptr<_Tp1>& __a) __STL_NOTHROW {\n+    if (__a.get() != this->get()) {\n+      delete _M_ptr;\n+      _M_ptr = __a.release();\n+    }\n+    return *this;\n   }\n+  ~auto_ptr() __STL_NOTHROW { delete _M_ptr; }\n \n-  auto_ptr& operator=(const auto_ptr& a) __STL_NOTHROW {\n-    if (&a != this) {\n-      if (owns)\n-        delete ptr;\n-      owns = a.owns;\n-      ptr = a.ptr;\n-      a.owns = 0;\n-    }\n+  _Tp& operator*() const __STL_NOTHROW {\n+    return *_M_ptr;\n   }\n-  template <class T> auto_ptr& operator=(const auto_ptr<T>& a) __STL_NOTHROW {\n-    if (&a != this) {\n-      if (owns)\n-        delete ptr;\n-      owns = a.owns;\n-      ptr = a.ptr;\n-      a.owns = 0;\n-    }\n+  _Tp* operator->() const __STL_NOTHROW {\n+    return _M_ptr;\n+  }\n+  _Tp* get() const __STL_NOTHROW {\n+    return _M_ptr;\n+  }\n+  _Tp* release() __STL_NOTHROW {\n+    _Tp* __tmp = _M_ptr;\n+    _M_ptr = 0;\n+    return __tmp;\n   }\n-  ~auto_ptr() {\n-    if (owns)\n-      delete ptr;\n+  void reset(_Tp* __p = 0) __STL_NOTHROW {\n+    delete _M_ptr;\n+    _M_ptr = __p;\n   }\n \n-  X& operator*() const __STL_NOTHROW { return *ptr; }\n-  X* operator->() const __STL_NOTHROW { return ptr; }\n-  X* get() const __STL_NOTHROW { return ptr; }\n-  X* release const __STL_NOTHROW { owns = false; return ptr }\n+  // According to the C++ standard, these conversions are required.  Most\n+  // present-day compilers, however, do not enforce that requirement---and, \n+  // in fact, most present-day compilers do not support the language \n+  // features that these conversions rely on.\n+  \n+#ifdef __SGI_STL_USE_AUTO_PTR_CONVERSIONS\n+\n+private:\n+  template<class _Tp1> struct auto_ptr_ref {\n+    _Tp1* _M_ptr;\n+    auto_ptr_ref(_Tp1* __p) : _M_ptr(__p) {}\n+  };\n+\n+public:\n+  auto_ptr(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW\n+    : _M_ptr(__ref._M_ptr) {}\n+  template <class _Tp1> operator auto_ptr_ref<_Tp1>() __STL_NOTHROW \n+    { return auto_ptr_ref<_Tp>(this.release()); }\n+  template <class _Tp1> operator auto_ptr<_Tp1>() __STL_NOTHROW\n+    { return auto_ptr<_Tp1>(this->release()) }\n+\n+#endif /* __SGI_STL_USE_AUTO_PTR_CONVERSIONS */\n };\n \n __STL_END_NAMESPACE\n-#endif /* mutable && explicit && member templates */\n-#endif /* 0 */\n-\n+#endif /* member templates */\n \n #endif /* __SGI_STL_MEMORY */\n "}, {"sha": "887d8e8a1547a16c913d31a37100ad4cea50782c", "filename": "libstdc++/stl/pthread_alloc", "status": "modified", "additions": 361, "deletions": 229, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fpthread_alloc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fpthread_alloc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fpthread_alloc?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -20,7 +20,7 @@\n // This should be reasonably fast even in the presence of threads.\n // The down side is that storage may not be well-utilized.\n // It is not an error to allocate memory in thread A and deallocate\n-// it n thread B.  But this effectively transfers ownership of the memory,\n+// it in thread B.  But this effectively transfers ownership of the memory,\n // so that it can only be reallocated by thread B.  Thus this can effectively\n // result in a storage leak if it's done on a regular basis.\n // It can also result in frequent sharing of\n@@ -35,308 +35,440 @@\n \n __STL_BEGIN_NAMESPACE\n \n-// Note that this class has nonstatic members.  We instantiate it once\n-// per thread.\n-template <bool dummy>\n-class __pthread_alloc_template {\n-\n-private:\n-  enum {ALIGN = 8};\n-  enum {MAX_BYTES = 128};  // power of 2\n-  enum {NFREELISTS = MAX_BYTES/ALIGN};\n+#define __STL_DATA_ALIGNMENT 8\n+\n+union _Pthread_alloc_obj {\n+    union _Pthread_alloc_obj * __free_list_link;\n+    char __client_data[__STL_DATA_ALIGNMENT];    /* The client sees this.    */\n+};\n+\n+// Pthread allocators don't appear to the client to have meaningful\n+// instances.  We do in fact need to associate some state with each\n+// thread.  That state is represented by\n+// _Pthread_alloc_per_thread_state<_Max_size>.\n+\n+template<size_t _Max_size>\n+struct _Pthread_alloc_per_thread_state {\n+  typedef _Pthread_alloc_obj __obj;\n+  enum { _S_NFREELISTS = _Max_size/__STL_DATA_ALIGNMENT };\n+  _Pthread_alloc_obj* volatile __free_list[_S_NFREELISTS]; \n+  _Pthread_alloc_per_thread_state<_Max_size> * __next; \n+\t// Free list link for list of available per thread structures.\n+  \t// When one of these becomes available for reuse due to thread\n+\t// termination, any objects in its free list remain associated\n+\t// with it.  The whole structure may then be used by a newly\n+\t// created thread.\n+  _Pthread_alloc_per_thread_state() : __next(0)\n+  {\n+    memset((void *)__free_list, 0, _S_NFREELISTS * sizeof(__obj *));\n+  }\n+  // Returns an object of size __n, and possibly adds to size n free list.\n+  void *_M_refill(size_t __n);\n+};\n \n-  union obj {\n-        union obj * free_list_link;\n-        char client_data[ALIGN];    /* The client sees this.        */\n-  };\n+// Pthread-specific allocator.\n+// The argument specifies the largest object size allocated from per-thread\n+// free lists.  Larger objects are allocated using malloc_alloc.\n+// Max_size must be a power of 2.\n+template <size_t _Max_size = 128>\n+class _Pthread_alloc_template {\n \n-  // Per instance state\n-  obj* volatile free_list[NFREELISTS]; \n-  __pthread_alloc_template<dummy>* next; \t// Free list link\n+public: // but only for internal use:\n \n-  static size_t ROUND_UP(size_t bytes) {\n-\treturn (((bytes) + ALIGN-1) & ~(ALIGN - 1));\n-  }\n-  static size_t FREELIST_INDEX(size_t bytes) {\n-\treturn (((bytes) + ALIGN-1)/ALIGN - 1);\n-  }\n+  typedef _Pthread_alloc_obj __obj;\n \n-  // Returns an object of size n, and optionally adds to size n free list.\n-  void *refill(size_t n);\n   // Allocates a chunk for nobjs of size \"size\".  nobjs may be reduced\n   // if it is inconvenient to allocate the requested number.\n-  static char *chunk_alloc(size_t size, int &nobjs);\n+  static char *_S_chunk_alloc(size_t __size, int &__nobjs);\n+\n+  enum {_S_ALIGN = __STL_DATA_ALIGNMENT};\n+\n+  static size_t _S_round_up(size_t __bytes) {\n+        return (((__bytes) + _S_ALIGN-1) & ~(_S_ALIGN - 1));\n+  }\n+  static size_t _S_freelist_index(size_t __bytes) {\n+        return (((__bytes) + _S_ALIGN-1)/_S_ALIGN - 1);\n+  }\n \n+private:\n   // Chunk allocation state. And other shared state.\n-  // Protected by chunk_allocator_lock.\n-  static pthread_mutex_t chunk_allocator_lock;\n-  static char *start_free;\n-  static char *end_free;\n-  static size_t heap_size;\n-  static __pthread_alloc_template<dummy>* free_allocators;\n-  static pthread_key_t key;\n-  static bool key_initialized;\n-\t// Pthread key under which allocator is stored. \n-\t// Allocator instances that are currently unclaimed by any thread.\n-  static void destructor(void *instance);\n-\t// Function to be called on thread exit to reclaim allocator\n-\t// instance.\n-  static __pthread_alloc_template<dummy> *new_allocator();\n-\t// Return a recycled or new allocator instance.\n-  static __pthread_alloc_template<dummy> *get_allocator_instance();\n-\t// ensure that the current thread has an associated\n-\t// allocator instance.\n-  class lock {\n+  // Protected by _S_chunk_allocator_lock.\n+  static pthread_mutex_t _S_chunk_allocator_lock;\n+  static char *_S_start_free;\n+  static char *_S_end_free;\n+  static size_t _S_heap_size;\n+  static _Pthread_alloc_per_thread_state<_Max_size>* _S_free_per_thread_states;\n+  static pthread_key_t _S_key;\n+  static bool _S_key_initialized;\n+        // Pthread key under which per thread state is stored. \n+        // Allocator instances that are currently unclaimed by any thread.\n+  static void _S_destructor(void *instance);\n+        // Function to be called on thread exit to reclaim per thread\n+        // state.\n+  static _Pthread_alloc_per_thread_state<_Max_size> *_S_new_per_thread_state();\n+        // Return a recycled or new per thread state.\n+  static _Pthread_alloc_per_thread_state<_Max_size> *_S_get_per_thread_state();\n+        // ensure that the current thread has an associated\n+        // per thread state.\n+  friend class _M_lock;\n+  class _M_lock {\n       public:\n-\tlock () { pthread_mutex_lock(&chunk_allocator_lock); }\n-\t~lock () { pthread_mutex_unlock(&chunk_allocator_lock); }\n+        _M_lock () { pthread_mutex_lock(&_S_chunk_allocator_lock); }\n+        ~_M_lock () { pthread_mutex_unlock(&_S_chunk_allocator_lock); }\n   };\n-  friend class lock;\n-\n \n public:\n \n-  __pthread_alloc_template() : next(0)\n-  {\n-    memset((void *)free_list, 0, NFREELISTS * sizeof(obj *));\n-  }\n-\n-  /* n must be > 0\t*/\n-  static void * allocate(size_t n)\n+  /* n must be > 0      */\n+  static void * allocate(size_t __n)\n   {\n-    obj * volatile * my_free_list;\n-    obj * __RESTRICT result;\n-    __pthread_alloc_template<dummy>* a;\n+    __obj * volatile * __my_free_list;\n+    __obj * __RESTRICT __result;\n+    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n \n-    if (n > MAX_BYTES) {\n-\treturn(malloc(n));\n+    if (__n > _Max_size) {\n+        return(malloc_alloc::allocate(__n));\n     }\n-    if (!key_initialized ||\n-        !(a = (__pthread_alloc_template<dummy>*)\n-\t\tpthread_getspecific(key))) {\n-\ta = get_allocator_instance();\n+    if (!_S_key_initialized ||\n+        !(__a = (_Pthread_alloc_per_thread_state<_Max_size>*)\n+                                 pthread_getspecific(_S_key))) {\n+        __a = _S_get_per_thread_state();\n     }\n-    my_free_list = a -> free_list + FREELIST_INDEX(n);\n-    result = *my_free_list;\n-    if (result == 0) {\n-    \tvoid *r = a -> refill(ROUND_UP(n));\n-\treturn r;\n+    __my_free_list = __a -> __free_list + _S_freelist_index(__n);\n+    __result = *__my_free_list;\n+    if (__result == 0) {\n+        void *__r = __a -> _M_refill(_S_round_up(__n));\n+        return __r;\n     }\n-    *my_free_list = result -> free_list_link;\n-    return (result);\n+    *__my_free_list = __result -> __free_list_link;\n+    return (__result);\n   };\n \n   /* p may not be 0 */\n-  static void deallocate(void *p, size_t n)\n+  static void deallocate(void *__p, size_t __n)\n   {\n-    obj *q = (obj *)p;\n-    obj * volatile * my_free_list;\n-    __pthread_alloc_template<dummy>* a;\n+    __obj *__q = (__obj *)__p;\n+    __obj * volatile * __my_free_list;\n+    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n \n-    if (n > MAX_BYTES) {\n-\tfree(p);\n-\treturn;\n+    if (__n > _Max_size) {\n+        malloc_alloc::deallocate(__p, __n);\n+        return;\n     }\n-    if (!key_initialized ||\n-        !(a = (__pthread_alloc_template<dummy>*)\n-\t\tpthread_getspecific(key))) {\n-\ta = get_allocator_instance();\n+    if (!_S_key_initialized ||\n+        !(__a = (_Pthread_alloc_per_thread_state<_Max_size> *)\n+                pthread_getspecific(_S_key))) {\n+        __a = _S_get_per_thread_state();\n     }\n-    my_free_list = a->free_list + FREELIST_INDEX(n);\n-    q -> free_list_link = *my_free_list;\n-    *my_free_list = q;\n+    __my_free_list = __a->__free_list + _S_freelist_index(__n);\n+    __q -> __free_list_link = *__my_free_list;\n+    *__my_free_list = __q;\n   }\n \n-  static void * reallocate(void *p, size_t old_sz, size_t new_sz);\n+  static void * reallocate(void *__p, size_t __old_sz, size_t __new_sz);\n \n } ;\n \n-typedef __pthread_alloc_template<false> pthread_alloc;\n+typedef _Pthread_alloc_template<> pthread_alloc;\n \n \n-template <bool dummy>\n-void __pthread_alloc_template<dummy>::destructor(void * instance)\n+template <size_t _Max_size>\n+void _Pthread_alloc_template<_Max_size>::_S_destructor(void * __instance)\n {\n-    __pthread_alloc_template<dummy>* a =\n-\t(__pthread_alloc_template<dummy>*)instance;\n-    a -> next = free_allocators;\n-    free_allocators = a;\n+    _M_lock __lock_instance;\t// Need to acquire lock here.\n+    _Pthread_alloc_per_thread_state<_Max_size>* __s =\n+        (_Pthread_alloc_per_thread_state<_Max_size> *)__instance;\n+    __s -> __next = _S_free_per_thread_states;\n+    _S_free_per_thread_states = __s;\n }\n \n-template <bool dummy>\n-__pthread_alloc_template<dummy>*\n-__pthread_alloc_template<dummy>::new_allocator()\n-{\n-    if (0 != free_allocators) {\n-\t__pthread_alloc_template<dummy>* result = free_allocators;\n-\tfree_allocators = free_allocators -> next;\n-\treturn result;\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_new_per_thread_state()\n+{    \n+    /* lock already held here.\t*/\n+    if (0 != _S_free_per_thread_states) {\n+        _Pthread_alloc_per_thread_state<_Max_size> *__result =\n+\t\t\t\t\t_S_free_per_thread_states;\n+        _S_free_per_thread_states = _S_free_per_thread_states -> __next;\n+        return __result;\n     } else {\n-\treturn new __pthread_alloc_template<dummy>;\n+        return new _Pthread_alloc_per_thread_state<_Max_size>;\n     }\n }\n \n-template <bool dummy>\n-__pthread_alloc_template<dummy>*\n-__pthread_alloc_template<dummy>::get_allocator_instance()\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_get_per_thread_state()\n {\n-    __pthread_alloc_template<dummy>* result;\n-    if (!key_initialized) {\n-    \t/*REFERENCED*/\n-\tlock lock_instance;\n-\tif (!key_initialized) {\n-\t    if (pthread_key_create(&key, destructor)) {\n-\t\tabort();  // failed\n-\t    }\n-\t    key_initialized = true;\n-\t}\n+    /*REFERENCED*/\n+    _M_lock __lock_instance;\t// Need to acquire lock here.\n+    _Pthread_alloc_per_thread_state<_Max_size> * __result;\n+    if (!_S_key_initialized) {\n+        if (pthread_key_create(&_S_key, _S_destructor)) {\n+            abort();  // failed\n+        }\n+        _S_key_initialized = true;\n     }\n-    result = new_allocator();\n-    if (pthread_setspecific(key, result)) abort();\n-    return result;\n+    __result = _S_new_per_thread_state();\n+    if (pthread_setspecific(_S_key, __result)) abort();\n+    return __result;\n }\n \n-/* We allocate memory in large chunks in order to avoid fragmenting\t*/\n-/* the malloc heap too much.\t\t\t\t\t\t*/\n-/* We assume that size is properly aligned.\t\t\t\t*/\n-template <bool dummy>\n-char *__pthread_alloc_template<dummy>\n-::chunk_alloc(size_t size, int &nobjs)\n+/* We allocate memory in large chunks in order to avoid fragmenting     */\n+/* the malloc heap too much.                                            */\n+/* We assume that size is properly aligned.                             */\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_chunk_alloc(size_t __size, int &__nobjs)\n {\n   {\n-    char * result;\n-    size_t total_bytes;\n-    size_t bytes_left;\n+    char * __result;\n+    size_t __total_bytes;\n+    size_t __bytes_left;\n     /*REFERENCED*/\n-    lock lock_instance;\t\t// Acquire lock for this routine\n-\n-    total_bytes = size * nobjs;\n-    bytes_left = end_free - start_free;\n-    if (bytes_left >= total_bytes) {\n-\tresult = start_free;\n-\tstart_free += total_bytes;\n-\treturn(result);\n-    } else if (bytes_left >= size) {\n-\tnobjs = bytes_left/size;\n-\ttotal_bytes = size * nobjs;\n-\tresult = start_free;\n-\tstart_free += total_bytes;\n-\treturn(result);\n+    _M_lock __lock_instance;         // Acquire lock for this routine\n+\n+    __total_bytes = __size * __nobjs;\n+    __bytes_left = _S_end_free - _S_start_free;\n+    if (__bytes_left >= __total_bytes) {\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n+    } else if (__bytes_left >= __size) {\n+        __nobjs = __bytes_left/__size;\n+        __total_bytes = __size * __nobjs;\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n     } else {\n-\tsize_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n-\t// Try to make use of the left-over piece.\n-\tif (bytes_left > 0) {\n-\t    __pthread_alloc_template<dummy>* a = \n-\t\t(__pthread_alloc_template<dummy>*)pthread_getspecific(key);\n-\t    obj * volatile * my_free_list =\n-\t\t\ta->free_list + FREELIST_INDEX(bytes_left);\n-\n-            ((obj *)start_free) -> free_list_link = *my_free_list;\n-            *my_free_list = (obj *)start_free;\n-\t}\n-#\tifdef _SGI_SOURCE\n-\t  // Try to get memory that's aligned on something like a\n-\t  // cache line boundary, so as to avoid parceling out\n-\t  // parts of the same line to different threads and thus\n-\t  // possibly different processors.\n-\t  {\n-\t    const int cache_line_size = 128;  // probable upper bound\n-\t    bytes_to_get &= ~(cache_line_size-1);\n-\t    start_free = (char *)memalign(cache_line_size, bytes_to_get); \n-\t    if (0 == start_free) {\n-\t      start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n-\t    }\n-\t  }\n-#\telse  /* !SGI_SOURCE */\n-\t  start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n+        size_t __bytes_to_get =\n+\t\t2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n+        // Try to make use of the left-over piece.\n+        if (__bytes_left > 0) {\n+            _Pthread_alloc_per_thread_state<_Max_size>* __a = \n+                (_Pthread_alloc_per_thread_state<_Max_size>*)\n+\t\t\tpthread_getspecific(_S_key);\n+            __obj * volatile * __my_free_list =\n+                        __a->__free_list + _S_freelist_index(__bytes_left);\n+\n+            ((__obj *)_S_start_free) -> __free_list_link = *__my_free_list;\n+            *__my_free_list = (__obj *)_S_start_free;\n+        }\n+#       ifdef _SGI_SOURCE\n+          // Try to get memory that's aligned on something like a\n+          // cache line boundary, so as to avoid parceling out\n+          // parts of the same line to different threads and thus\n+          // possibly different processors.\n+          {\n+            const int __cache_line_size = 128;  // probable upper bound\n+            __bytes_to_get &= ~(__cache_line_size-1);\n+            _S_start_free = (char *)memalign(__cache_line_size, __bytes_to_get); \n+            if (0 == _S_start_free) {\n+              _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n+            }\n+          }\n+#       else  /* !SGI_SOURCE */\n+          _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n #       endif\n-\theap_size += bytes_to_get;\n-\tend_free = start_free + bytes_to_get;\n+        _S_heap_size += __bytes_to_get;\n+        _S_end_free = _S_start_free + __bytes_to_get;\n     }\n   }\n   // lock is released here\n-  return(chunk_alloc(size, nobjs));\n+  return(_S_chunk_alloc(__size, __nobjs));\n }\n \n \n /* Returns an object of size n, and optionally adds to size n free list.*/\n-/* We assume that n is properly aligned.\t\t\t\t*/\n-/* We hold the allocation lock.\t\t\t\t\t\t*/\n-template <bool dummy>\n-void *__pthread_alloc_template<dummy>\n-::refill(size_t n)\n+/* We assume that n is properly aligned.                                */\n+/* We hold the allocation lock.                                         */\n+template <size_t _Max_size>\n+void *_Pthread_alloc_per_thread_state<_Max_size>\n+::_M_refill(size_t __n)\n {\n-    int nobjs = 128;\n-    char * chunk = chunk_alloc(n, nobjs);\n-    obj * volatile * my_free_list;\n-    obj * result;\n-    obj * current_obj, * next_obj;\n-    int i;\n-\n-    if (1 == nobjs)  {\n-\treturn(chunk);\n+    int __nobjs = 128;\n+    char * __chunk =\n+\t_Pthread_alloc_template<_Max_size>::_S_chunk_alloc(__n, __nobjs);\n+    __obj * volatile * __my_free_list;\n+    __obj * __result;\n+    __obj * __current_obj, * __next_obj;\n+    int __i;\n+\n+    if (1 == __nobjs)  {\n+        return(__chunk);\n     }\n-    my_free_list = free_list + FREELIST_INDEX(n);\n+    __my_free_list = __free_list\n+\t\t + _Pthread_alloc_template<_Max_size>::_S_freelist_index(__n);\n \n     /* Build free list in chunk */\n-      result = (obj *)chunk;\n-      *my_free_list = next_obj = (obj *)(chunk + n);\n-      for (i = 1; ; i++) {\n-\tcurrent_obj = next_obj;\n-\tnext_obj = (obj *)((char *)next_obj + n);\n-\tif (nobjs - 1 == i) {\n-\t    current_obj -> free_list_link = 0;\n-\t    break;\n-\t} else {\n-\t    current_obj -> free_list_link = next_obj;\n-\t}\n+      __result = (__obj *)__chunk;\n+      *__my_free_list = __next_obj = (__obj *)(__chunk + __n);\n+      for (__i = 1; ; __i++) {\n+        __current_obj = __next_obj;\n+        __next_obj = (__obj *)((char *)__next_obj + __n);\n+        if (__nobjs - 1 == __i) {\n+            __current_obj -> __free_list_link = 0;\n+            break;\n+        } else {\n+            __current_obj -> __free_list_link = __next_obj;\n+        }\n       }\n-    return(result);\n+    return(__result);\n }\n \n-template <bool dummy>\n-void *__pthread_alloc_template<dummy>\n-::reallocate(void *p, size_t old_sz, size_t new_sz)\n+template <size_t _Max_size>\n+void *_Pthread_alloc_template<_Max_size>\n+::reallocate(void *__p, size_t __old_sz, size_t __new_sz)\n {\n-    void * result;\n-    size_t copy_sz;\n+    void * __result;\n+    size_t __copy_sz;\n \n-    if (old_sz > MAX_BYTES && new_sz > MAX_BYTES) {\n-\treturn(realloc(p, new_sz));\n+    if (__old_sz > _Max_size\n+\t&& __new_sz > _Max_size) {\n+        return(realloc(__p, __new_sz));\n     }\n-    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);\n-    result = allocate(new_sz);\n-    copy_sz = new_sz > old_sz? old_sz : new_sz;\n-    memcpy(result, p, copy_sz);\n-    deallocate(p, old_sz);\n-    return(result);\n+    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);\n+    __result = allocate(__new_sz);\n+    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n+    memcpy(__result, __p, __copy_sz);\n+    deallocate(__p, __old_sz);\n+    return(__result);\n }\n \n-template <bool dummy>\n-__pthread_alloc_template<dummy> *\n-__pthread_alloc_template<dummy>::free_allocators = 0;\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_free_per_thread_states = 0;\n \n-template <bool dummy>\n-pthread_key_t __pthread_alloc_template<dummy>::key;\n+template <size_t _Max_size>\n+pthread_key_t _Pthread_alloc_template<_Max_size>::_S_key;\n \n-template <bool dummy>\n-bool __pthread_alloc_template<dummy>::key_initialized = false;\n+template <size_t _Max_size>\n+bool _Pthread_alloc_template<_Max_size>::_S_key_initialized = false;\n \n-template <bool dummy>\n-pthread_mutex_t __pthread_alloc_template<dummy>::chunk_allocator_lock\n+template <size_t _Max_size>\n+pthread_mutex_t _Pthread_alloc_template<_Max_size>::_S_chunk_allocator_lock\n = PTHREAD_MUTEX_INITIALIZER;\n \n-template <bool dummy>\n-char *__pthread_alloc_template<dummy>\n-::start_free = 0;\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_start_free = 0;\n+\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_end_free = 0;\n+\n+template <size_t _Max_size>\n+size_t _Pthread_alloc_template<_Max_size>\n+::_S_heap_size = 0;\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+template <class _Tp>\n+class pthread_allocator {\n+  typedef pthread_alloc _S_Alloc;          // The underlying allocator.\n+public:\n+  typedef size_t     size_type;\n+  typedef ptrdiff_t  difference_type;\n+  typedef _Tp*       pointer;\n+  typedef const _Tp* const_pointer;\n+  typedef _Tp&       reference;\n+  typedef const _Tp& const_reference;\n+  typedef _Tp        value_type;\n+\n+  template <class _U> struct rebind {\n+    typedef pthread_allocator<_U> other;\n+  };\n+\n+  pthread_allocator() __STL_NOTHROW {}\n+  pthread_allocator(const pthread_allocator& a) __STL_NOTHROW {}\n+  template <class _U> pthread_allocator(const pthread_allocator<_U>&)\n+\t\t__STL_NOTHROW {}\n+  ~pthread_allocator() __STL_NOTHROW {}\n+\n+  pointer address(reference __x) const { return &__x; }\n+  const_pointer address(const_reference __x) const { return &__x; }\n+\n+  // __n is permitted to be 0.  The C++ standard says nothing about what\n+  // the return value is when __n == 0.\n+  _Tp* allocate(size_type __n, const void* = 0) {\n+    return __n != 0 ? static_cast<_Tp*>(_S_Alloc::allocate(__n * sizeof(_Tp)))\n+                    : 0;\n+  }\n+\n+  // p is not permitted to be a null pointer.\n+  void deallocate(pointer __p, size_type __n)\n+    { _S_Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n+\n+  size_type max_size() const __STL_NOTHROW \n+    { return size_t(-1) / sizeof(_Tp); }\n+\n+  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+  void destroy(pointer _p) { _p->~_Tp(); }\n+};\n+\n+template<>\n+class pthread_allocator<void> {\n+public:\n+  typedef size_t      size_type;\n+  typedef ptrdiff_t   difference_type;\n+  typedef void*       pointer;\n+  typedef const void* const_pointer;\n+  typedef void        value_type;\n+\n+  template <class _U> struct rebind {\n+    typedef pthread_allocator<_U> other;\n+  };\n+};\n+\n+template <size_t _Max_size>\n+inline bool operator==(const _Pthread_alloc_template<_Max_size>&,\n+                       const _Pthread_alloc_template<_Max_size>&)\n+{\n+  return true;\n+}\n+\n+template <class _T1, class _T2>\n+inline bool operator==(const pthread_allocator<_T1>&,\n+                       const pthread_allocator<_T2>& a2) \n+{\n+  return true;\n+}\n+\n+template <class _T1, class _T2>\n+inline bool operator!=(const pthread_allocator<_T1>&,\n+                       const pthread_allocator<_T2>&)\n+{\n+  return false;\n+}\n+\n+template <class _Tp, size_t _Max_size>\n+struct _Alloc_traits<_Tp, _Pthread_alloc_template<_Max_size> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max_size> > _Alloc_type;\n+  typedef __allocator<_Tp, _Pthread_alloc_template<_Max_size> > \n+          allocator_type;\n+};\n+\n+template <class _Tp, class _U, size_t _Max>\n+struct _Alloc_traits<_Tp, __allocator<_U, _Pthread_alloc_template<_Max> > >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max> > _Alloc_type;\n+  typedef __allocator<_Tp, _Pthread_alloc_template<_Max> > allocator_type;\n+};\n+\n+template <class _Tp, class _U>\n+struct _Alloc_traits<_Tp, pthread_allocator<_U> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<> > _Alloc_type;\n+  typedef pthread_allocator<_Tp> allocator_type;\n+};\n \n-template <bool dummy>\n-char *__pthread_alloc_template<dummy>\n-::end_free = 0;\n \n-template <bool dummy>\n-size_t __pthread_alloc_template<dummy>\n-::heap_size = 0;\n+#endif /* __STL_USE_STD_ALLOCATORS */\n \n __STL_END_NAMESPACE\n "}, {"sha": "774ef04edc828c3cb32a9e240d1552be85d7eee2", "filename": "libstdc++/stl/pthread_alloc.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fpthread_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fpthread_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fpthread_alloc.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -18,8 +18,8 @@\n \n #ifdef __STL_USE_NAMESPACES\n \n-using __STD::__pthread_alloc_template;\n-using __STL::pthread_alloc;\n+using __STD::_Pthread_alloc_template;\n+using __STD::pthread_alloc;\n \n #endif /* __STL_USE_NAMESPACES */\n "}, {"sha": "f861500000b571c6b19d10d1119a2e61446ba661", "filename": "libstdc++/stl/rope", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Frope?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -15,7 +15,7 @@\n #define __SGI_STL_ROPE\n \n #include <stl_algobase.h>\n-#include <tempbuf.h>\n+#include <stl_tempbuf.h>\n #include <stl_algo.h>\n #include <stl_function.h>\n #include <stl_numeric.h>"}, {"sha": "18bb2c9ec9d187f0d017458c2c53e6d2a7c540ae", "filename": "libstdc++/stl/ropeimpl.h", "status": "modified", "additions": 976, "deletions": 963, "changes": 1939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fropeimpl.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -15,8 +15,8 @@\n  *   You should not attempt to use it directly.\n  */\n \n-# include <stdio.h>\n-# include <iostream.h>\n+# include <stdio.h>     /* XXX should use <cstdio> */\n+# include <iostream.h>  /* XXX should use <iostream> */\n \n __STL_BEGIN_NAMESPACE\n \n@@ -25,45 +25,46 @@ __STL_BEGIN_NAMESPACE\n #endif\n \n // Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n-// if necessary.  Assumes path_end[leaf_index] and leaf_pos are correct.\n+// if necessary.  Assumes _M_path_end[leaf_index] and leaf_pos are correct.\n // Results in a valid buf_ptr if the iterator can be legitimately\n // dereferenced.\n-template <class charT, class Alloc>\n-void __rope_iterator_base<charT,Alloc>::setbuf\n-(__rope_iterator_base<charT,Alloc> &x)\n+template <class _CharT, class _Alloc>\n+void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf( \n+  _Rope_iterator_base<_CharT,_Alloc>& __x)\n {\n-    const RopeBase * leaf = x.path_end[x.leaf_index];\n-    size_t leaf_pos = x.leaf_pos;\n-    size_t pos = x.current_pos;\n-\n-    switch(leaf -> tag) {\n-\tcase RopeBase::leaf:\n-\t    x.buf_start = ((__rope_RopeLeaf<charT,Alloc> *)leaf) -> data;\n-\t    x.buf_ptr = x.buf_start + (pos - leaf_pos);\n-\t    x.buf_end = x.buf_start + leaf -> size;\n+    const _RopeRep* __leaf = __x._M_path_end[__x._M_leaf_index];\n+    size_t __leaf_pos = __x._M_leaf_pos;\n+    size_t __pos = __x._M_current_pos;\n+\n+    switch(__leaf->_M_tag) {\n+\tcase _RopeRep::_S_leaf:\n+\t    __x._M_buf_start = \n+\t      ((_Rope_RopeLeaf<_CharT,_Alloc>*)__leaf)->_M_data;\n+\t    __x._M_buf_ptr = __x._M_buf_start + (__pos - __leaf_pos);\n+\t    __x._M_buf_end = __x._M_buf_start + __leaf->_M_size;\n \t    break;\n-\tcase RopeBase::function:\n-\tcase RopeBase::substringfn:\n+\tcase _RopeRep::_S_function:\n+\tcase _RopeRep::_S_substringfn:\n \t    {\n-\t\tsize_t len = iterator_buf_len;\n-\t\tsize_t buf_start_pos = leaf_pos;\n-\t\tsize_t leaf_end = leaf_pos + leaf -> size;\n-\t\tchar_producer<charT> *fn =\n-\t\t\t((__rope_RopeFunction<charT,Alloc> *)leaf) -> fn;\n-\n-\t\tif (buf_start_pos + len <= pos) {\n-\t\t    buf_start_pos = pos - len/4;\n-\t\t    if (buf_start_pos + len > leaf_end) {\n-\t\t\tbuf_start_pos = leaf_end - len;\n+\t\tsize_t __len = _S_iterator_buf_len;\n+\t\tsize_t __buf_start_pos = __leaf_pos;\n+\t\tsize_t __leaf_end = __leaf_pos + __leaf->_M_size;\n+\t\tchar_producer<_CharT>* __fn =\n+\t\t\t((_Rope_RopeFunction<_CharT,_Alloc>*)__leaf)->_M_fn;\n+\n+\t\tif (__buf_start_pos + __len <= __pos) {\n+\t\t    __buf_start_pos = __pos - __len/4;\n+\t\t    if (__buf_start_pos + __len > __leaf_end) {\n+\t\t\t__buf_start_pos = __leaf_end - __len;\n \t\t    }\n \t\t}\n-\t\tif (buf_start_pos + len > leaf_end) {\n-\t\t    len = leaf_end - buf_start_pos;\n+\t\tif (__buf_start_pos + __len > __leaf_end) {\n+\t\t    __len = __leaf_end - __buf_start_pos;\n \t\t}\n-\t\t(*fn)(buf_start_pos - leaf_pos, len, x.tmp_buf);\n-\t\tx.buf_ptr = x.tmp_buf + (pos - buf_start_pos);\n-\t\tx.buf_start = x.tmp_buf;\n-\t\tx.buf_end = x.tmp_buf + len;\n+\t\t(*__fn)(__buf_start_pos - __leaf_pos, __len, __x._M_tmp_buf);\n+\t\t__x._M_buf_ptr = __x._M_tmp_buf + (__pos - __buf_start_pos);\n+\t\t__x._M_buf_start = __x._M_tmp_buf;\n+\t\t__x._M_buf_end = __x._M_tmp_buf + __len;\n \t    }\n \t    break;\n \tdefault:\n@@ -73,830 +74,812 @@ void __rope_iterator_base<charT,Alloc>::setbuf\n \n // Set path and buffer inside a rope iterator.  We assume that \n // pos and root are already set.\n-template <class charT, class Alloc>\n-void __rope_iterator_base<charT,Alloc>::setcache\n-(__rope_iterator_base<charT,Alloc> &x)\n+template <class _CharT, class _Alloc>\n+void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache\n+(_Rope_iterator_base<_CharT,_Alloc>& __x)\n {\n-    const RopeBase * path[RopeBase::max_rope_depth+1];\n-    const RopeBase * curr_rope;\n-    int curr_depth = -1;  /* index into path    */\n-    size_t curr_start_pos = 0;\n-    size_t pos = x.current_pos;\n-    unsigned char dirns = 0;\t// Bit vector indicating right turns in the path\n-\n-    __stl_assert(pos <= x.root -> size);\n-    if (pos >= x.root -> size) {\n-\tx.buf_ptr = 0;\n+    const _RopeRep* __path[_RopeRep::_S_max_rope_depth+1];\n+    const _RopeRep* __curr_rope;\n+    int __curr_depth = -1;  /* index into path    */\n+    size_t __curr_start_pos = 0;\n+    size_t __pos = __x._M_current_pos;\n+    unsigned char __dirns = 0; // Bit vector marking right turns in the path\n+\n+    __stl_assert(__pos <= __x._M_root->_M_size);\n+    if (__pos >= __x._M_root->_M_size) {\n+\t__x._M_buf_ptr = 0;\n \treturn;\n     }\n-    curr_rope = x.root;\n-    if (0 != curr_rope -> c_string) {\n+    __curr_rope = __x._M_root;\n+    if (0 != __curr_rope->_M_c_string) {\n \t/* Treat the root as a leaf. */\n-\tx.buf_start = curr_rope -> c_string;\n-\tx.buf_end = curr_rope -> c_string + curr_rope -> size;\n-\tx.buf_ptr = curr_rope -> c_string + pos;\n-\tx.path_end[0] = curr_rope;\n-\tx.leaf_index = 0;\n-\tx.leaf_pos = 0;\n+\t__x._M_buf_start = __curr_rope->_M_c_string;\n+\t__x._M_buf_end = __curr_rope->_M_c_string + __curr_rope->_M_size;\n+\t__x._M_buf_ptr = __curr_rope->_M_c_string + __pos;\n+\t__x._M_path_end[0] = __curr_rope;\n+\t__x._M_leaf_index = 0;\n+\t__x._M_leaf_pos = 0;\n \treturn;\n     }\n     for(;;) {\n-\t++curr_depth;\n-\t__stl_assert(curr_depth <= RopeBase::max_rope_depth);\n-\tpath[curr_depth] = curr_rope;\n-\tswitch(curr_rope -> tag) {\n-\t  case RopeBase::leaf:\n-\t  case RopeBase::function:\n-\t  case RopeBase::substringfn:\n-\t    x.leaf_pos = curr_start_pos;\n+\t++__curr_depth;\n+\t__stl_assert(__curr_depth <= _RopeRep::_S_max_rope_depth);\n+\t__path[__curr_depth] = __curr_rope;\n+\tswitch(__curr_rope->_M_tag) {\n+\t  case _RopeRep::_S_leaf:\n+\t  case _RopeRep::_S_function:\n+\t  case _RopeRep::_S_substringfn:\n+\t    __x._M_leaf_pos = __curr_start_pos;\n \t    goto done;\n-\t  case RopeBase::concat:\n+\t  case _RopeRep::_S_concat:\n \t    {\n-\t\t__rope_RopeConcatenation<charT,Alloc> *c =\n-\t\t\t(__rope_RopeConcatenation<charT,Alloc> *)curr_rope;\n-\t\tRopeBase * left = c -> left;\n-\t\tsize_t left_len = left -> size;\n+\t\t_Rope_RopeConcatenation<_CharT,_Alloc>* __c =\n+\t\t\t(_Rope_RopeConcatenation<_CharT,_Alloc>*)__curr_rope;\n+\t\t_RopeRep* __left = __c->_M_left;\n+\t\tsize_t __left_len = __left->_M_size;\n \t\t\n-\t\tdirns <<= 1;\n-\t\tif (pos >= curr_start_pos + left_len) {\n-\t\t    dirns |= 1;\n-\t\t    curr_rope = c -> right;\n-\t\t    curr_start_pos += left_len;\n+\t\t__dirns <<= 1;\n+\t\tif (__pos >= __curr_start_pos + __left_len) {\n+\t\t    __dirns |= 1;\n+\t\t    __curr_rope = __c->_M_right;\n+\t\t    __curr_start_pos += __left_len;\n \t\t} else {\n-\t\t    curr_rope = left;\n+\t\t    __curr_rope = __left;\n \t\t}\n \t    }\n \t    break;\n \t}\n     }\n   done:\n-    // Copy last section of path into path_end.\n+    // Copy last section of path into _M_path_end.\n       {\n-\tint i = -1;\n-\tint j = curr_depth  + 1 - path_cache_len;\n+\tint __i = -1;\n+\tint __j = __curr_depth + 1 - _S_path_cache_len;\n \n-\tif (j < 0) j = 0;\n-\twhile (j <= curr_depth) {\n-\t    x.path_end[++i] = path[j++];\n+\tif (__j < 0) __j = 0;\n+\twhile (__j <= __curr_depth) {\n+\t    __x._M_path_end[++__i] = __path[__j++];\n \t}\n-\tx.leaf_index = i;\n+\t__x._M_leaf_index = __i;\n       }\n-      x.path_directions = dirns;\n-    setbuf(x);\n+      __x._M_path_directions = __dirns;\n+      _S_setbuf(__x);\n }\n \n // Specialized version of the above.  Assumes that\n // the path cache is valid for the previous position.\n-template <class charT, class Alloc>\n-void __rope_iterator_base<charT,Alloc>::setcache_for_incr\n-(__rope_iterator_base<charT,Alloc> &x)\n+template <class _CharT, class _Alloc>\n+void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache_for_incr\n+(_Rope_iterator_base<_CharT,_Alloc>& __x)\n {\n-    int current_index = x.leaf_index;\n-    const RopeBase * current_node = x.path_end[current_index];\n-    size_t len = current_node -> size;\n-    size_t node_start_pos = x.leaf_pos;\n-    unsigned char dirns = x.path_directions;\n-    __rope_RopeConcatenation<charT,Alloc> * c;\n-\n-    __stl_assert(x.current_pos <= x.root -> size);\n-    if (x.current_pos - node_start_pos < len) {\n+    int __current_index = __x._M_leaf_index;\n+    const _RopeRep* __current_node = __x._M_path_end[__current_index];\n+    size_t __len = __current_node->_M_size;\n+    size_t __node_start_pos = __x._M_leaf_pos;\n+    unsigned char __dirns = __x._M_path_directions;\n+    _Rope_RopeConcatenation<_CharT,_Alloc>* __c;\n+\n+    __stl_assert(__x._M_current_pos <= __x._M_root->_M_size);\n+    if (__x._M_current_pos - __node_start_pos < __len) {\n \t/* More stuff in this leaf, we just didn't cache it. */\n-\tsetbuf(x);\n+\t_S_setbuf(__x);\n \treturn;\n     }\n-    __stl_assert(node_start_pos + len == x.current_pos);\n+    __stl_assert(__node_start_pos + __len == __x._M_current_pos);\n     //  node_start_pos is starting position of last_node.\n-    while (--current_index >= 0) {\n-\tif (!(dirns & 1) /* Path turned left */) break;\n-\tcurrent_node = x.path_end[current_index];\n-\tc = (__rope_RopeConcatenation<charT,Alloc> *)current_node;\n+    while (--__current_index >= 0) {\n+\tif (!(__dirns & 1) /* Path turned left */) \n+\t  break;\n+\t__current_node = __x._M_path_end[__current_index];\n+\t__c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;\n \t// Otherwise we were in the right child.  Thus we should pop\n \t// the concatenation node.\n-\tnode_start_pos -= c -> left -> size;\n-\tdirns >>= 1;\n+\t__node_start_pos -= __c->_M_left->_M_size;\n+\t__dirns >>= 1;\n     }\n-    if (current_index < 0) {\n+    if (__current_index < 0) {\n \t// We underflowed the cache. Punt.\n-\tsetcache(x);\n+\t_S_setcache(__x);\n \treturn;\n     }\n-    current_node = x.path_end[current_index];\n-    c = (__rope_RopeConcatenation<charT,Alloc> *)current_node;\n+    __current_node = __x._M_path_end[__current_index];\n+    __c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;\n     // current_node is a concatenation node.  We are positioned on the first\n     // character in its right child.\n     // node_start_pos is starting position of current_node.\n-    node_start_pos += c -> left -> size;\n-    current_node = c -> right;\n-    x.path_end[++current_index] = current_node;\n-    dirns |= 1;\n-    while (RopeBase::concat == current_node -> tag) {\n-\t++current_index;\n-\tif (path_cache_len == current_index) {\n-\t    int i;\n-\t    for (i = 0; i < path_cache_len-1; i++) {\n-\t\tx.path_end[i] = x.path_end[i+1];\n+    __node_start_pos += __c->_M_left->_M_size;\n+    __current_node = __c->_M_right;\n+    __x._M_path_end[++__current_index] = __current_node;\n+    __dirns |= 1;\n+    while (_RopeRep::_S_concat == __current_node->_M_tag) {\n+\t++__current_index;\n+\tif (_S_path_cache_len == __current_index) {\n+\t    int __i;\n+\t    for (__i = 0; __i < _S_path_cache_len-1; __i++) {\n+\t\t__x._M_path_end[__i] = __x._M_path_end[__i+1];\n \t    }\n-\t    --current_index;\n+\t    --__current_index;\n \t}\n-\tcurrent_node =\n-\t    ((__rope_RopeConcatenation<charT,Alloc> *)current_node) -> left;\n-\tx.path_end[current_index] = current_node;\n-\tdirns <<= 1;\n+\t__current_node =\n+\t    ((_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node)->_M_left;\n+\t__x._M_path_end[__current_index] = __current_node;\n+\t__dirns <<= 1;\n \t// node_start_pos is unchanged.\n     }\n-    x.leaf_index = current_index;\n-    x.leaf_pos = node_start_pos;\n-    x.path_directions = dirns;\n-    setbuf(x);\n+    __x._M_leaf_index = __current_index;\n+    __x._M_leaf_pos = __node_start_pos;\n+    __x._M_path_directions = __dirns;\n+    _S_setbuf(__x);\n }\n \n-template <class charT, class Alloc>\n-void __rope_iterator_base<charT,Alloc>::incr(size_t n) {\n-    current_pos += n;\n-    if (0 != buf_ptr) {\n-        size_t chars_left = buf_end - buf_ptr;\n-        if (chars_left > n) {\n-            buf_ptr += n;\n-        } else if (chars_left == n) {\n-            buf_ptr += n;\n-            setcache_for_incr(*this);\n+template <class _CharT, class _Alloc>\n+void _Rope_iterator_base<_CharT,_Alloc>::_M_incr(size_t __n) {\n+    _M_current_pos += __n;\n+    if (0 != _M_buf_ptr) {\n+        size_t __chars_left = _M_buf_end - _M_buf_ptr;\n+        if (__chars_left > __n) {\n+            _M_buf_ptr += __n;\n+        } else if (__chars_left == __n) {\n+            _M_buf_ptr += __n;\n+            _S_setcache_for_incr(*this);\n         } else {\n-            buf_ptr = 0;\n+            _M_buf_ptr = 0;\n         }\n     }\n }\n \n-template <class charT, class Alloc>\n-void __rope_iterator_base<charT,Alloc>::decr(size_t n) {\n-    if (0 != buf_ptr) {\n-        size_t chars_left = buf_ptr - buf_start;\n-        if (chars_left >= n) {\n-            buf_ptr -= n;\n+template <class _CharT, class _Alloc>\n+void _Rope_iterator_base<_CharT,_Alloc>::_M_decr(size_t __n) {\n+    if (0 != _M_buf_ptr) {\n+        size_t __chars_left = _M_buf_ptr - _M_buf_start;\n+        if (__chars_left >= __n) {\n+            _M_buf_ptr -= __n;\n         } else {\n-            buf_ptr = 0;\n+            _M_buf_ptr = 0;\n         }\n     }\n-    current_pos -= n;\n+    _M_current_pos -= __n;\n }\n \n-template <class charT, class Alloc>\n-void __rope_iterator<charT,Alloc>::check() {\n-    if (root_rope -> tree_ptr != root) {\n-        // Rope was modified.  Get things fixed up.\n-        RopeBase::unref(root);\n-        root = root_rope -> tree_ptr;\n-        RopeBase::ref(root);\n-        buf_ptr = 0;\n+template <class _CharT, class _Alloc>\n+void _Rope_iterator<_CharT,_Alloc>::_M_check() {\n+    if (_M_root_rope->_M_tree_ptr != _M_root) {\n+        // _Rope was modified.  Get things fixed up.\n+        _RopeRep::_S_unref(_M_root);\n+        _M_root = _M_root_rope->_M_tree_ptr;\n+        _RopeRep::_S_ref(_M_root);\n+        _M_buf_ptr = 0;\n     }\n }\n \n-template <class charT, class Alloc>\n-inline __rope_const_iterator<charT, Alloc>::__rope_const_iterator\n-(const __rope_iterator<charT,Alloc> & x)\n-: __rope_iterator_base<charT,Alloc>(x) { }\n-\n-template <class charT, class Alloc>\n-inline __rope_iterator<charT,Alloc>::__rope_iterator\n-(rope<charT,Alloc>& r, size_t pos)\n-        : __rope_iterator_base<charT,Alloc>(r.tree_ptr, pos), root_rope(&r) {\n-    RopeBase::ref(root);\n-}\n-\n-template <class charT, class Alloc>\n-inline size_t rope<charT,Alloc>::char_ptr_len(const charT *s)\n+template <class _CharT, class _Alloc>\n+inline \n+_Rope_const_iterator<_CharT, _Alloc>::_Rope_const_iterator(\n+  const _Rope_iterator<_CharT,_Alloc>& __x)\n+: _Rope_iterator_base<_CharT,_Alloc>(__x) \n+{ }\n+\n+template <class _CharT, class _Alloc>\n+inline _Rope_iterator<_CharT,_Alloc>::_Rope_iterator(\n+  rope<_CharT,_Alloc>& __r, size_t __pos)\n+: _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos), \n+  _M_root_rope(&__r)\n {\n-    const charT *p = s;\n-\n-    while (!is0(*p)) { ++p; }\n-    return(p - s);\n+    _RopeRep::_S_ref(_M_root);\n }\n \n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeLeaf *\n-rope<charT,Alloc>::RopeLeaf_from_char_ptr(__GC_CONST charT *s, size_t size)\n+template <class _CharT, class _Alloc>\n+inline size_t \n+rope<_CharT,_Alloc>::_S_char_ptr_len(const _CharT* __s)\n {\n-    RopeLeaf *t = LAlloc::allocate();\n+    const _CharT* __p = __s;\n \n-    t -> tag = RopeBase::leaf;\n-    if (__is_basic_char_type((charT *)0)) {\n-\t// already eos terminated.\n-\tt -> c_string = s;\n-    } else {\n-\tt -> c_string = 0;\n-    }\n-    t -> is_balanced = true;\n-    t -> depth = 0;\n-    t -> size = size;\n-    t -> data = s;\n-#   ifndef __GC\n-\tt -> refcount = 1;\n-\tt -> init_refcount_lock();\n-#   endif\n-    return (t);\n+    while (!_S_is0(*__p)) { ++__p; }\n+    return (__p - __s);\n }\n \n-# ifdef __GC\n-template <class charT, class Alloc>\n-void __rope_RopeBase<charT,Alloc>::fn_finalization_proc(void * tree, void *)\n-{\n-    delete ((__rope_RopeFunction<charT,Alloc> *)tree) -> fn;\n-}\n-# endif\n-\n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeFunction *\n-rope<charT,Alloc>::RopeFunction_from_fn\n-(char_producer<charT> *fn, size_t size, bool delete_fn)\n-{\n-    if (0 == size) return 0;\n-    RopeFunction *t = FAlloc::allocate();\n-    t -> tag = RopeBase::function;\n-    t -> c_string = 0;\n-    t -> is_balanced = true;\n-    t -> depth = 0;\n-    t -> size = size;\n-    t -> fn = fn;\n-#   ifdef __GC\n-\tif (delete_fn) {\n-\t    GC_REGISTER_FINALIZER(t, RopeBase::fn_finalization_proc, 0, 0, 0);\n-\t}\n-#   else\n-\tt -> delete_when_done = delete_fn;\n-\tt -> refcount = 1;\n-\tt -> init_refcount_lock();\n-#   endif\n-    return (t);\n-}\n \n #ifndef __GC\n \n-template <class charT, class Alloc>\n-inline void __rope_RopeBase<charT,Alloc>::free_c_string()\n+template <class _CharT, class _Alloc>\n+inline void _Rope_RopeRep<_CharT,_Alloc>::_M_free_c_string()\n {\n-    charT * cstr = c_string;\n-    if (0 != cstr) {\n-\tsize_t sz = size + 1;\n-\tdestroy(cstr, cstr + sz);\n-\tDataAlloc::deallocate(cstr, sz);\n+    _CharT* __cstr = _M_c_string;\n+    if (0 != __cstr) {\n+\tsize_t __size = _M_size + 1;\n+\tdestroy(__cstr, __cstr + __size);\n+\t_Data_deallocate(__cstr, __size);\n     }\n }\n \n-template <class charT, class Alloc>\n-inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)\n+\n+template <class _CharT, class _Alloc>\n+#ifdef __STL_USE_STD_ALLOCATORS\n+  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string(_CharT* __s,\n+\t\t\t\t\t\t\t   size_t __n,\n+\t\t\t\t\t\t           allocator_type __a)\n+#else\n+  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string(_CharT* __s,\n+\t\t\t\t\t\t\t   size_t __n)\n+#endif\n {\n-    if (!__is_basic_char_type((charT *)0)) {\n-\tdestroy(s, s + n);\n+    if (!_S_is_basic_char_type((_CharT*)0)) {\n+\tdestroy(__s, __s + __n);\n     }\n-    DataAlloc::deallocate(s, rounded_up_size(n));\n+//  This has to be a static member, so this gets a bit messy\n+#   ifdef __STL_USE_STD_ALLOCATORS\n+        __a.deallocate(\n+\t    __s, _Rope_RopeLeaf<_CharT,_Alloc>::_S_rounded_up_size(__n));\n+#   else\n+\t_Data_deallocate(\n+\t    __s, _Rope_RopeLeaf<_CharT,_Alloc>::_S_rounded_up_size(__n));\n+#   endif\n }\n \n-template <class charT, class Alloc>\n-void __rope_RopeBase<charT,Alloc>::free_tree()\n+\n+//  There are several reasons for not doing this with virtual destructors\n+//  and a class specific delete operator:\n+//  - A class specific delete operator can't easily get access to\n+//    allocator instances if we need them.\n+//  - Any virtual function would need a 4 or byte vtable pointer;\n+//    this only requires a one byte tag per object.\n+template <class _CharT, class _Alloc>\n+void _Rope_RopeRep<_CharT,_Alloc>::_M_free_tree()\n {\n-    switch(tag) {\n-\tcase leaf:\n+    switch(_M_tag) {\n+\tcase _S_leaf:\n \t    {\n-\t        __rope_RopeLeaf<charT,Alloc> * l =\n-\t\t\t(__rope_RopeLeaf<charT,Alloc> *)this;\n-\t\tcharT * d = l -> data;\n-\t\t\n-\t\tif (d != c_string) {\n-\t\t    free_c_string();\n-\t\t}\n-\t\tfree_string(d, size);\n-\t\tLAlloc::deallocate(l);\n+\t        _Rope_RopeLeaf<_CharT,_Alloc>* __l\n+\t\t\t= (_Rope_RopeLeaf<_CharT,_Alloc>*)this;\n+\t        __l->_Rope_RopeLeaf<_CharT,_Alloc>::~_Rope_RopeLeaf();\n+\t        _L_deallocate(__l, 1);\n+\t        break;\n \t    }\n-\t    break;\n-\tcase concat:\n+\tcase _S_concat:\n \t    {\n-\t\t__rope_RopeConcatenation<charT,Alloc> * c =\n-\t\t\t(__rope_RopeConcatenation<charT,Alloc> *)this;\n-\t\t__rope_RopeBase * left = c -> left;\n-\t\t__rope_RopeBase * right = c -> right;\n-\t\tfree_c_string();\n-\t\tleft -> unref_nonnil();\n-\t\tright -> unref_nonnil();\n-\t\tCAlloc::deallocate(c);\n+\t        _Rope_RopeConcatenation<_CharT,_Alloc>* __c\n+\t\t    = (_Rope_RopeConcatenation<_CharT,_Alloc>*)this;\n+\t        __c->_Rope_RopeConcatenation<_CharT,_Alloc>::\n+\t\t       ~_Rope_RopeConcatenation();\n+\t        _C_deallocate(__c, 1);\n+\t        break;\n \t    }\n-\t    break;\n-\tcase function:\n+\tcase _S_function:\n \t    {\n-\t\t__rope_RopeFunction<charT,Alloc> * fn =\n-\t\t  \t(__rope_RopeFunction<charT,Alloc> *)this;\n-\t        free_c_string();\n-\t        if ( fn -> delete_when_done) {\n-\t\t    delete fn -> fn;\n-\t        }\n-\t        FAlloc::deallocate(fn);\n+\t        _Rope_RopeFunction<_CharT,_Alloc>* __f\n+\t\t    = (_Rope_RopeFunction<_CharT,_Alloc>*)this;\n+\t        __f->_Rope_RopeFunction<_CharT,_Alloc>::~_Rope_RopeFunction();\n+\t        _F_deallocate(__f, 1);\n \t        break;\n \t    }\n-\tcase substringfn:\n+\tcase _S_substringfn:\n \t    {\n-\t        __rope_RopeSubstring<charT,Alloc> * ss =\n-\t\t\t(__rope_RopeSubstring<charT,Alloc> *)this;\n-\t\t__rope_RopeBase *base = ss -> base;\n-\t\tfree_c_string();\n-\t\tbase -> unref_nonnil();\n-\t\tSAlloc::deallocate(ss);\n+\t        _Rope_RopeSubstring<_CharT,_Alloc>* __ss =\n+\t\t\t(_Rope_RopeSubstring<_CharT,_Alloc>*)this;\n+\t\t__ss->_Rope_RopeSubstring<_CharT,_Alloc>::\n+\t\t        ~_Rope_RopeSubstring();\n+\t\t_S_deallocate(__ss, 1);\n \t\tbreak;\n \t    }\n     }\n }\n #else\n \n-template <class charT, class Alloc>\n-inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)\n+template <class _CharT, class _Alloc>\n+#ifdef __STL_USE_STD_ALLOCATORS\n+  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string\n+\t\t(const _CharT*, size_t, allocator_type)\n+#else\n+  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string\n+\t\t(const _CharT*, size_t)\n+#endif\n {}\n \n #endif\n \n \n // Concatenate a C string onto a leaf rope by copying the rope data.\n // Used for short ropes.\n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeLeaf *\n-rope<charT,Alloc>::leaf_concat_char_iter\n-\t\t(RopeLeaf * r, const charT * iter, size_t len)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeLeaf*\n+rope<_CharT,_Alloc>::_S_leaf_concat_char_iter\n+\t\t(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n {\n-    size_t old_len = r -> size;\n-    charT * new_data = (charT *)\n-\tDataAlloc::allocate(rounded_up_size(old_len + len));\n-    RopeLeaf * result;\n+    size_t __old_len = __r->_M_size;\n+    _CharT* __new_data = (_CharT*)\n+\t_Data_allocate(_S_rounded_up_size(__old_len + __len));\n+    _RopeLeaf* __result;\n     \n-    uninitialized_copy_n(r -> data, old_len, new_data);\n-    uninitialized_copy_n(iter, len, new_data + old_len);\n-    __cond_store_eos(new_data[old_len + len]);\n+    uninitialized_copy_n(__r->_M_data, __old_len, __new_data);\n+    uninitialized_copy_n(__iter, __len, __new_data + __old_len);\n+    _S_cond_store_eos(__new_data[__old_len + __len]);\n     __STL_TRY {\n-\tresult = RopeLeaf_from_char_ptr(new_data, old_len + len);\n+\t__result = _S_new_RopeLeaf(__new_data, __old_len + __len,\n+\t\t\t\t   __r->get_allocator());\n     }\n-    __STL_UNWIND(RopeBase::free_string(new_data, old_len + len));\n-    return result;\n+    __STL_UNWIND(_RopeRep::__STL_FREE_STRING(__new_data, __old_len + __len,\n+\t\t\t\t\t     __r->get_allocator()));\n+    return __result;\n }\n \n #ifndef __GC\n // As above, but it's OK to clobber original if refcount is 1\n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeLeaf *\n-rope<charT,Alloc>::destr_leaf_concat_char_iter\n-\t\t(RopeLeaf * r, const charT * iter, size_t len)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeLeaf*\n+rope<_CharT,_Alloc>::_S_destr_leaf_concat_char_iter\n+\t\t(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n {\n-    __stl_assert(r -> refcount >= 1);\n-    if (r -> refcount > 1) return leaf_concat_char_iter(r, iter, len);\n-    size_t old_len = r -> size;\n-    if (allocated_capacity(old_len) >= old_len + len) {\n+    __stl_assert(__r->_M_refcount >= 1);\n+    if (__r->_M_refcount > 1)\n+      return _S_leaf_concat_char_iter(__r, __iter, __len);\n+    size_t __old_len = __r->_M_size;\n+    if (_S_allocated_capacity(__old_len) >= __old_len + __len) {\n \t// The space has been partially initialized for the standard\n \t// character types.  But that doesn't matter for those types.\n-\tuninitialized_copy_n(iter, len, r -> data + old_len);\n-\tif (__is_basic_char_type((charT *)0)) {\n-\t    __cond_store_eos(r -> data[old_len + len]);\n-\t    __stl_assert(r -> c_string == r -> data);\n-\t} else if (r -> c_string != r -> data && 0 != r -> c_string) {\n-\t    r -> free_c_string();\n-\t    r -> c_string = 0;\n+\tuninitialized_copy_n(__iter, __len, __r->_M_data + __old_len);\n+\tif (_S_is_basic_char_type((_CharT*)0)) {\n+\t    _S_cond_store_eos(__r->_M_data[__old_len + __len]);\n+\t    __stl_assert(__r->_M_c_string == __r->_M_data);\n+\t} else if (__r->_M_c_string != __r->_M_data && 0 != __r->_M_c_string) {\n+\t    __r->_M_free_c_string();\n+\t    __r->_M_c_string = 0;\n \t}\n-\tr -> size = old_len + len;\n-\t__stl_assert(r -> refcount == 1);\n-\tr -> refcount = 2;\n-\treturn r;\n+\t__r->_M_size = __old_len + __len;\n+\t__stl_assert(__r->_M_refcount == 1);\n+\t__r->_M_refcount = 2;\n+\treturn __r;\n     } else {\n-\tRopeLeaf * result = leaf_concat_char_iter(r, iter, len);\n-\t__stl_assert(result -> refcount == 1);\n-\treturn result;\n+\t_RopeLeaf* __result = _S_leaf_concat_char_iter(__r, __iter, __len);\n+\t__stl_assert(__result->_M_refcount == 1);\n+\treturn __result;\n     }\n }\n #endif\n \n // Assumes left and right are not 0.\n // Does not increment (nor decrement on exception) child reference counts.\n // Result has ref count 1.\n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeBase *\n-rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeRep*\n+rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)\n {\n-    RopeConcatenation * result = CAlloc::allocate();\n-    unsigned char child_depth = left -> depth;\n-    size_t rsize;\n-\n-    result -> tag = RopeBase::concat;\n-    result -> c_string = 0;\n-    result -> is_balanced = false;\n-    result -> size = rsize = left -> size + right -> size;\n-    if (right -> depth > child_depth) child_depth = right -> depth;\n-    unsigned char depth = (unsigned char)(child_depth + 1);\n-    result -> depth = depth;\n-    result -> left = left;\n-    result -> right = right;\n-#   ifndef __GC\n-\tresult -> refcount = 1;\n-\tresult -> init_refcount_lock();\n+    _RopeConcatenation* __result =\n+      _S_new_RopeConcatenation(__left, __right, __left->get_allocator());\n+    size_t __depth = __result->_M_depth;\n+    \n+#   ifdef __STL_USE_STD_ALLOCATORS\n+      __stl_assert(__left->get_allocator() == __right->get_allocator());\n #   endif\n-    if (depth > 20 && (rsize < 1000 || depth > RopeBase::max_rope_depth)) {\n-\tRopeBase * balanced;\n-\n+    if (__depth > 20 && (__result->_M_size < 1000 ||\n+\t\t\t __depth > _RopeRep::_S_max_rope_depth)) {\n+        _RopeRep* __balanced;\n+      \n \t__STL_TRY {\n-\t   balanced = balance(result);\n+\t   __balanced = _S_balance(__result);\n #          ifndef __GC\n-\t     if (result != balanced) {\n-\t\t__stl_assert(1 == result -> refcount\n-\t\t\t     && 1 == balanced -> refcount);\n+\t     if (__result != __balanced) {\n+\t\t__stl_assert(1 == __result->_M_refcount\n+\t\t\t     && 1 == __balanced->_M_refcount);\n \t     }\n #          endif\n-\t   result -> unref_nonnil();\n+\t   __result->_M_unref_nonnil();\n         }\n-\t__STL_UNWIND(CAlloc::deallocate(result));\n+\t__STL_UNWIND((_C_deallocate(__result,1)));\n \t\t// In case of exception, we need to deallocate\n \t\t// otherwise dangling result node.  But caller\n \t\t// still owns its children.  Thus unref is\n \t\t// inappropriate.\n-\treturn balanced;\n+\treturn __balanced;\n     } else {\n-\treturn result;\n+\treturn __result;\n     }\n }\n \n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter\n-\t\t(RopeBase * r, const charT *s, size_t slen)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n+\t\t(_RopeRep* __r, const _CharT*__s, size_t __slen)\n {\n-    RopeBase *result;\n-    if (0 == slen) {\n-\tref(r);\n-\treturn r;\n+    _RopeRep* __result;\n+    if (0 == __slen) {\n+\t_S_ref(__r);\n+\treturn __r;\n     }\n-    if (0 == r) return RopeLeaf_from_unowned_char_ptr(s, slen);\n-    if (RopeBase::leaf == r -> tag && r -> size + slen <= copy_max) {\n-\tresult = leaf_concat_char_iter((RopeLeaf *)r, s, slen);\n+    if (0 == __r)\n+      return __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n+\t\t\t\t\t      __r->get_allocator());\n+    if (_RopeRep::_S_leaf == __r->_M_tag && \n+          __r->_M_size + __slen <= _S_copy_max) {\n+\t__result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n #       ifndef __GC\n-\t  __stl_assert(1 == result -> refcount);\n+\t  __stl_assert(1 == __result->_M_refcount);\n #       endif\n-\treturn result;\n+\treturn __result;\n     }\n-    if (RopeBase::concat == r -> tag\n-\t&& RopeBase::leaf == ((RopeConcatenation *)r) -> right -> tag) {\n-\tRopeLeaf *right = (RopeLeaf *)(((RopeConcatenation *)r) -> right);\n-\tif (right -> size + slen <= copy_max) {\n-\t  RopeBase * left = ((RopeConcatenation *)r) -> left;\n-\t  RopeBase * nright = leaf_concat_char_iter((RopeLeaf *)right, s, slen);\n-\t  left -> ref_nonnil();\n+    if (_RopeRep::_S_concat == __r->_M_tag\n+\t&& _RopeRep::_S_leaf == ((_RopeConcatenation*)__r)->_M_right->_M_tag) {\n+\t_RopeLeaf* __right = \n+\t  (_RopeLeaf* )(((_RopeConcatenation* )__r)->_M_right);\n+\tif (__right->_M_size + __slen <= _S_copy_max) {\n+\t  _RopeRep* __left = ((_RopeConcatenation*)__r)->_M_left;\n+\t  _RopeRep* __nright = \n+\t    _S_leaf_concat_char_iter((_RopeLeaf*)__right, __s, __slen);\n+\t  __left->_M_ref_nonnil();\n \t  __STL_TRY {\n-\t    result = tree_concat(left, nright);\n+\t    __result = _S_tree_concat(__left, __nright);\n           }\n-\t  __STL_UNWIND(unref(left); unref(nright));\n+\t  __STL_UNWIND(_S_unref(__left); _S_unref(__nright));\n #         ifndef __GC\n-\t    __stl_assert(1 == result -> refcount);\n+\t    __stl_assert(1 == __result->_M_refcount);\n #         endif\n-\t  return result;\n+\t  return __result;\n \t}\n     }\n-    RopeBase * nright = RopeLeaf_from_unowned_char_ptr(s, slen);\n+    _RopeRep* __nright =\n+      __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n     __STL_TRY {\n-      r -> ref_nonnil();\n-      result = tree_concat(r, nright);\n+      __r->_M_ref_nonnil();\n+      __result = _S_tree_concat(__r, __nright);\n     }\n-    __STL_UNWIND(unref(r); unref(nright));\n+    __STL_UNWIND(_S_unref(__r); _S_unref(__nright));\n #   ifndef __GC\n-      __stl_assert(1 == result -> refcount);\n+      __stl_assert(1 == __result->_M_refcount);\n #   endif\n-    return result;\n+    return __result;\n }\n \n #ifndef __GC\n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeBase * rope<charT,Alloc>\n-::destr_concat_char_iter\n-\t\t(RopeBase * r, const charT *s, size_t slen)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeRep* \n+rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n+  _RopeRep* __r, const _CharT* __s, size_t __slen)\n {\n-    RopeBase *result;\n-    if (0 == r) return RopeLeaf_from_unowned_char_ptr(s, slen);\n-    size_t count = r -> refcount;\n-    size_t orig_size = r -> size;\n-    __stl_assert(count >= 1);\n-    if (count > 1) return concat_char_iter(r, s, slen);\n-    if (0 == slen) {\n-\tr -> refcount = 2;      // One more than before\n-\treturn r;\n+    _RopeRep* __result;\n+    if (0 == __r)\n+      return __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n+\t\t\t\t\t      __r->get_allocator());\n+    size_t __count = __r->_M_refcount;\n+    size_t __orig_size = __r->_M_size;\n+    __stl_assert(__count >= 1);\n+    if (__count > 1) return _S_concat_char_iter(__r, __s, __slen);\n+    if (0 == __slen) {\n+\t__r->_M_refcount = 2;      // One more than before\n+\treturn __r;\n     }\n-    if (orig_size + slen <= copy_max && RopeBase::leaf == r -> tag) {\n-\tresult = destr_leaf_concat_char_iter((RopeLeaf *)r, s, slen);\n-\treturn result;\n+    if (__orig_size + __slen <= _S_copy_max && \n+          _RopeRep::_S_leaf == __r->_M_tag) {\n+\t__result = _S_destr_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n+\treturn __result;\n     }\n-    if (RopeBase::concat == r -> tag) {\n-\tRopeLeaf *right = (RopeLeaf *)(((RopeConcatenation *)r) -> right);\n-\tif (RopeBase::leaf == right -> tag\n-\t    && right -> size + slen <= copy_max) {\n-\t  RopeBase * new_right = destr_leaf_concat_char_iter(right, s, slen);\n-\t  if (right == new_right) {\n-\t      __stl_assert(new_right -> refcount == 2);\n-\t      new_right -> refcount = 1;\n+    if (_RopeRep::_S_concat == __r->_M_tag) {\n+\t_RopeLeaf* __right = (_RopeLeaf*)(((_RopeConcatenation*)__r)->_M_right);\n+\tif (_RopeRep::_S_leaf == __right->_M_tag\n+\t    && __right->_M_size + __slen <= _S_copy_max) {\n+\t  _RopeRep* __new_right = \n+\t    _S_destr_leaf_concat_char_iter(__right, __s, __slen);\n+\t  if (__right == __new_right) {\n+\t      __stl_assert(__new_right->_M_refcount == 2);\n+\t      __new_right->_M_refcount = 1;\n \t  } else {\n-\t      __stl_assert(new_right -> refcount >= 1);\n-\t      right -> unref_nonnil();\n+\t      __stl_assert(__new_right->_M_refcount >= 1);\n+\t      __right->_M_unref_nonnil();\n \t  }\n-\t  __stl_assert(r -> refcount == 1);\n-\t  r -> refcount = 2;    // One more than before.\n-\t  ((RopeConcatenation *)r) -> right = new_right;\n-\t  r -> size = orig_size + slen;\n-\t  if (0 != r -> c_string) {\n-\t      r -> free_c_string();\n-\t      r -> c_string = 0;\n+\t  __stl_assert(__r->_M_refcount == 1);\n+\t  __r->_M_refcount = 2;    // One more than before.\n+\t  ((_RopeConcatenation*)__r)->_M_right = __new_right;\n+\t  __r->_M_size = __orig_size + __slen;\n+\t  if (0 != __r->_M_c_string) {\n+\t      __r->_M_free_c_string();\n+\t      __r->_M_c_string = 0;\n \t  }\n-\t  return r;\n+\t  return __r;\n \t}\n     }\n-    RopeBase *right = RopeLeaf_from_unowned_char_ptr(s, slen);\n-    r -> ref_nonnil();\n+    _RopeRep* __right =\n+      __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n+    __r->_M_ref_nonnil();\n     __STL_TRY {\n-      result = tree_concat(r, right);\n+      __result = _S_tree_concat(__r, __right);\n     }\n-    __STL_UNWIND(unref(r); unref(right))\n-    __stl_assert(1 == result -> refcount);\n-    return result;\n+    __STL_UNWIND(_S_unref(__r); _S_unref(__right))\n+    __stl_assert(1 == __result->_M_refcount);\n+    return __result;\n }\n #endif /* !__GC */\n \n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeBase *\n-rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeRep*\n+rope<_CharT,_Alloc>::_S_concat(_RopeRep* __left, _RopeRep* __right)\n {\n-    if (0 == left) {\n-\tref(right);\n-\treturn right;\n+    if (0 == __left) {\n+\t_S_ref(__right);\n+\treturn __right;\n     }\n-    if (0 == right) {\n-\tleft -> ref_nonnil();\n-\treturn left;\n+    if (0 == __right) {\n+\t__left->_M_ref_nonnil();\n+\treturn __left;\n     }\n-    if (RopeBase::leaf == right -> tag) {\n-\tif (RopeBase::leaf == left -> tag) {\n-\t  if (right -> size + left -> size <= copy_max) {\n-\t    return leaf_concat_char_iter((RopeLeaf *)left,\n-\t\t\t\t\t ((RopeLeaf *)right) -> data,\n-\t\t\t\t\t right -> size);\n+    if (_RopeRep::_S_leaf == __right->_M_tag) {\n+\tif (_RopeRep::_S_leaf == __left->_M_tag) {\n+\t  if (__right->_M_size + __left->_M_size <= _S_copy_max) {\n+\t    return _S_leaf_concat_char_iter((_RopeLeaf*)__left,\n+\t\t\t\t\t ((_RopeLeaf*)__right)->_M_data,\n+\t\t\t\t\t __right->_M_size);\n \t  }\n-\t} else if (RopeBase::concat == left -> tag\n-\t\t   && RopeBase::leaf ==\n-\t\t      ((RopeConcatenation *)left) -> right -> tag) {\n-\t  RopeLeaf * leftright =\n-\t\t    (RopeLeaf *)(((RopeConcatenation *)left) -> right); \n-\t  if (leftright -> size + right -> size <= copy_max) {\n-\t    RopeBase * leftleft = ((RopeConcatenation *)left) -> left;\n-\t    RopeBase * rest = leaf_concat_char_iter(leftright,\n-\t\t\t\t\t   ((RopeLeaf *)right) -> data,\n-\t\t\t\t\t   right -> size);\n-\t    leftleft -> ref_nonnil();\n+\t} else if (_RopeRep::_S_concat == __left->_M_tag\n+\t\t   && _RopeRep::_S_leaf ==\n+\t\t      ((_RopeConcatenation*)__left)->_M_right->_M_tag) {\n+\t  _RopeLeaf* __leftright =\n+\t\t    (_RopeLeaf*)(((_RopeConcatenation*)__left)->_M_right); \n+\t  if (__leftright->_M_size + __right->_M_size <= _S_copy_max) {\n+\t    _RopeRep* __leftleft = ((_RopeConcatenation*)__left)->_M_left;\n+\t    _RopeRep* __rest = _S_leaf_concat_char_iter(__leftright,\n+\t\t\t\t\t   ((_RopeLeaf*)__right)->_M_data,\n+\t\t\t\t\t   __right->_M_size);\n+\t    __leftleft->_M_ref_nonnil();\n \t    __STL_TRY {\n-\t      return(tree_concat(leftleft, rest));\n+\t      return(_S_tree_concat(__leftleft, __rest));\n             }\n-\t    __STL_UNWIND(unref(leftleft); unref(rest))\n+\t    __STL_UNWIND(_S_unref(__leftleft); _S_unref(__rest))\n \t  }\n \t}\n     }\n-    left -> ref_nonnil();\n-    right -> ref_nonnil();\n+    __left->_M_ref_nonnil();\n+    __right->_M_ref_nonnil();\n     __STL_TRY {\n-      return(tree_concat(left, right));\n+      return(_S_tree_concat(__left, __right));\n     }\n-    __STL_UNWIND(unref(left); unref(right));\n+    __STL_UNWIND(_S_unref(__left); _S_unref(__right));\n }\n \n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeBase *\n-rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeRep*\n+rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base, \n+                               size_t __start, size_t __endp1)\n {\n-    if (0 == base) return 0;\n-    size_t len = base -> size;\n-    size_t adj_endp1;\n-    const size_t lazy_threshold = 128;\n+    if (0 == __base) return 0;\n+    size_t __len = __base->_M_size;\n+    size_t __adj_endp1;\n+    const size_t __lazy_threshold = 128;\n     \n-    if (endp1 >= len) {\n-\tif (0 == start) {\n-\t    base -> ref_nonnil();\n-\t    return base;\n+    if (__endp1 >= __len) {\n+\tif (0 == __start) {\n+\t    __base->_M_ref_nonnil();\n+\t    return __base;\n \t} else {\n-\t    adj_endp1 = len;\n+\t    __adj_endp1 = __len;\n \t}\n     } else {\n-\tadj_endp1 = endp1;\n+\t__adj_endp1 = __endp1;\n     }\n-    switch(base -> tag) {\n-\tcase RopeBase::concat:\n+    switch(__base->_M_tag) {\n+\tcase _RopeRep::_S_concat:\n \t    {\n-\t\tRopeConcatenation *c = (RopeConcatenation *)base;\n-\t\tRopeBase *left = c -> left;\n-\t\tRopeBase *right = c -> right;\n-\t\tsize_t left_len = left -> size;\n-\t\tRopeBase * result;\n-\n-\t\tif (adj_endp1 <= left_len) {\n-\t\t    return substring(left, start, endp1);\n-\t\t} else if (start >= left_len) {\n-\t\t    return substring(right, start - left_len,\n-\t\t\t\t  adj_endp1 - left_len);\n+\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__base;\n+\t\t_RopeRep* __left = __c->_M_left;\n+\t\t_RopeRep* __right = __c->_M_right;\n+\t\tsize_t __left_len = __left->_M_size;\n+\t\t_RopeRep* __result;\n+\n+\t\tif (__adj_endp1 <= __left_len) {\n+\t\t    return _S_substring(__left, __start, __endp1);\n+\t\t} else if (__start >= __left_len) {\n+\t\t    return _S_substring(__right, __start - __left_len,\n+\t\t\t\t  __adj_endp1 - __left_len);\n \t\t}\n-\t\tself_destruct_ptr left_result(substring(left, start,\n-\t\t\t\t\t\t\tleft_len));\n-\t\tself_destruct_ptr right_result(\n-\t\t\t\tsubstring(right, 0, endp1 - left_len));\n-\t\tresult = concat(left_result, right_result);\n+\t\t_Self_destruct_ptr __left_result(\n+\t\t  _S_substring(__left, __start, __left_len));\n+\t\t_Self_destruct_ptr __right_result(\n+\t\t  _S_substring(__right, 0, __endp1 - __left_len));\n+\t\t__result = _S_concat(__left_result, __right_result);\n #               ifndef __GC\n-\t\t  __stl_assert(1 == result -> refcount);\n+\t\t  __stl_assert(1 == __result->_M_refcount);\n #               endif\n-\t\treturn result;\n+\t\treturn __result;\n \t    }\n-\tcase RopeBase::leaf:\n+\tcase _RopeRep::_S_leaf:\n \t    {\n-\t\tRopeLeaf * l = (RopeLeaf *)base;\n-\t\tRopeLeaf * result;\n-\t\tsize_t result_len;\n-\t\tif (start >= adj_endp1) return 0;\n-\t\tresult_len = adj_endp1 - start;\n-\t\tif (result_len > lazy_threshold) goto lazy;\n+\t\t_RopeLeaf* __l = (_RopeLeaf*)__base;\n+\t\t_RopeLeaf* __result;\n+\t\tsize_t __result_len;\n+\t\tif (__start >= __adj_endp1) return 0;\n+\t\t__result_len = __adj_endp1 - __start;\n+\t\tif (__result_len > __lazy_threshold) goto lazy;\n #               ifdef __GC\n-\t\t    const charT *section = l -> data + start;\n-\t\t    result = RopeLeaf_from_char_ptr(section, result_len);\n-\t\t    result -> c_string = 0;  // Not eos terminated.\n+\t\t    const _CharT* __section = __l->_M_data + __start;\n+\t\t    __result = _S_new_RopeLeaf(__section, __result_len,\n+\t\t\t\t\t  __base->get_allocator());\n+\t\t    __result->_M_c_string = 0;  // Not eos terminated.\n #               else\n \t\t    // We should sometimes create substring node instead.\n-\t\t    result = RopeLeaf_from_unowned_char_ptr(\n-\t\t\t\t\tl -> data + start, result_len);\n+\t\t    __result = __STL_ROPE_FROM_UNOWNED_CHAR_PTR(\n+\t\t\t\t\t__l->_M_data + __start, __result_len,\n+\t\t\t\t\t__base->get_allocator());\n #               endif\n-\t\treturn result;\n+\t\treturn __result;\n \t    }\n-\tcase RopeBase::substringfn:\n-\t    // Avoid introducing mutiple layers of substring nodes.\n+\tcase _RopeRep::_S_substringfn:\n+\t    // Avoid introducing multiple layers of substring nodes.\n \t    {\n-\t\tRopeSubstring *old = (RopeSubstring *)base;\n-\t\tsize_t result_len;\n-\t\tif (start >= adj_endp1) return 0;\n-\t\tresult_len = adj_endp1 - start;\n-\t\tif (result_len > lazy_threshold) {\n-\t\t    RopeSubstring * space = SAlloc::allocate();\n-\t\t    RopeSubstring * result =\n-\t\t\tnew(space) RopeSubstring(old -> base,\n-\t\t\t\t\t\t start + old -> start,\n-\t\t\t\t\t\t adj_endp1 - start);\n-\t\t    return result;\n-\t\t} // else fall through:\n+\t\t_RopeSubstring* __old = (_RopeSubstring*)__base;\n+\t\tsize_t __result_len;\n+\t\tif (__start >= __adj_endp1) return 0;\n+\t\t__result_len = __adj_endp1 - __start;\n+\t\tif (__result_len > __lazy_threshold) {\n+\t\t    _RopeSubstring* __result =\n+\t\t\t_S_new_RopeSubstring(__old->_M_base,\n+\t\t\t\t\t  __start + __old->_M_start,\n+\t\t\t\t\t  __adj_endp1 - __start,\n+\t\t\t\t\t  __base->get_allocator());\n+\t\t    return __result;\n+\n+\t\t} // *** else fall through: ***\n \t    }\n-\tcase RopeBase::function:\n+\tcase _RopeRep::_S_function:\n \t    {\n-\t\tRopeFunction * f = (RopeFunction *)base;\n-\t\tcharT *section;\n-\t\tsize_t result_len;\n-\t\tif (start >= adj_endp1) return 0;\n-\t\tresult_len = adj_endp1 - start;\n-\n-\t\tif (result_len > lazy_threshold) goto lazy;\n-\t\tsection = (charT *)\n-\t\t\tDataAlloc::allocate(rounded_up_size(result_len));\n+\t\t_RopeFunction* __f = (_RopeFunction*)__base;\n+\t\t_CharT* __section;\n+\t\tsize_t __result_len;\n+\t\tif (__start >= __adj_endp1) return 0;\n+\t\t__result_len = __adj_endp1 - __start;\n+\n+\t\tif (__result_len > __lazy_threshold) goto lazy;\n+\t\t__section = (_CharT*)\n+\t\t\t_Data_allocate(_S_rounded_up_size(__result_len));\n \t\t__STL_TRY {\n-\t\t  (*(f -> fn))(start, result_len, section);\n+\t\t  (*(__f->_M_fn))(__start, __result_len, __section);\n                 }\n-\t\t__STL_UNWIND(RopeBase::free_string(section, result_len));\n-\t\t__cond_store_eos(section[result_len]);\n-\t\treturn RopeLeaf_from_char_ptr(section, result_len);\n+\t\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(\n+\t               __section, __result_len, __base->get_allocator()));\n+\t\t_S_cond_store_eos(__section[__result_len]);\n+\t\treturn _S_new_RopeLeaf(__section, __result_len,\n+\t\t\t\t       __base->get_allocator());\n \t    }\n     }\n     /*NOTREACHED*/\n     __stl_assert(false);\n   lazy:\n     {\n \t// Create substring node.\n-\tRopeSubstring * space = SAlloc::allocate();\n-\tRopeSubstring * result = new(space) RopeSubstring(base, start,\n-\t\t\t\t\t\t\t  adj_endp1 - start);\n-\treturn result;\n+\treturn _S_new_RopeSubstring(__base, __start, __adj_endp1 - __start,\n+\t\t\t       __base->get_allocator());\n     }\n }\n \n-template<class charT>\n-class __rope_flatten_char_consumer : public __rope_char_consumer<charT> {\n+template<class _CharT>\n+class _Rope_flatten_char_consumer : public _Rope_char_consumer<_CharT> {\n     private:\n-\tcharT * buf_ptr;\n+\t_CharT* _M_buf_ptr;\n     public:\n-\tcharT * buffer;\n-\t__rope_flatten_char_consumer(charT * buffer) {\n-\t    buf_ptr = buffer;\n+\t//  _CharT* _M_buffer;  // XXX not used\n+\n+\t_Rope_flatten_char_consumer(_CharT* __buffer) {\n+\t    _M_buf_ptr = __buffer;\n \t};\n-\t~__rope_flatten_char_consumer() {}\n-\tbool operator() (const charT* leaf, size_t n) {\n-\t    uninitialized_copy_n(leaf, n, buf_ptr);\n-\t    buf_ptr += n;\n+\t~_Rope_flatten_char_consumer() {}\n+\tbool operator() (const _CharT* __leaf, size_t __n) {\n+\t    uninitialized_copy_n(__leaf, __n, _M_buf_ptr);\n+\t    _M_buf_ptr += __n;\n \t    return true;\n \t}\n };\n \t    \n-template<class charT>\n-class __rope_find_char_char_consumer : public __rope_char_consumer<charT> {\n+template<class _CharT>\n+class _Rope_find_char_char_consumer : public _Rope_char_consumer<_CharT> {\n     private:\n-\tcharT pattern;\n+\t_CharT _M_pattern;\n     public:\n-\tsize_t count;  // Number of nonmatching characters\n-\t__rope_find_char_char_consumer(charT p) : pattern(p), count(0) {}\n-\t~__rope_find_char_char_consumer() {}\n-\tbool operator() (const charT* leaf, size_t n) {\n-\t    size_t i;\n-\t    for (i = 0; i < n; i++) {\n-\t\tif (leaf[i] == pattern) {\n-\t\t    count += i; return false;\n+\tsize_t _M_count;  // Number of nonmatching characters\n+\t_Rope_find_char_char_consumer(_CharT __p) \n+\t  : _M_pattern(__p), _M_count(0) {}\n+\t~_Rope_find_char_char_consumer() {}\n+\tbool operator() (const _CharT* __leaf, size_t __n) {\n+\t    size_t __i;\n+\t    for (__i = 0; __i < __n; __i++) {\n+\t\tif (__leaf[__i] == _M_pattern) {\n+\t\t    _M_count += __i; return false;\n \t\t}\n \t    }\n-\t    count += n; return true;\n+\t    _M_count += __n; return true;\n \t}\n };\n \t    \n-template<class charT>\n-class __rope_insert_char_consumer : public __rope_char_consumer<charT> {\n+template<class _CharT>\n+class _Rope_insert_char_consumer : public _Rope_char_consumer<_CharT> {\n     private:\n-\ttypedef ostream insert_ostream;\n-\tinsert_ostream & o;\n+\ttypedef ostream _Insert_ostream;\n+\t_Insert_ostream& _M_o;\n     public:\n-\tcharT * buffer;\n-\t__rope_insert_char_consumer(insert_ostream & writer) : o(writer) {};\n-\t~__rope_insert_char_consumer() { };\n+\t// _CharT* buffer;    // XXX not used\n+\t_Rope_insert_char_consumer(_Insert_ostream& __writer) \n+\t  : _M_o(__writer) {};\n+\t~_Rope_insert_char_consumer() { };\n \t\t// Caller is presumed to own the ostream\n-\tbool operator() (const charT* leaf, size_t n);\n+\tbool operator() (const _CharT* __leaf, size_t __n);\n \t\t// Returns true to continue traversal.\n };\n \t    \n-template<class charT>\n-bool __rope_insert_char_consumer<charT>::operator()\n-\t\t\t\t\t(const charT * leaf, size_t n)\n+template<class _CharT>\n+bool _Rope_insert_char_consumer<_CharT>::operator()\n+\t\t\t\t\t(const _CharT* __leaf, size_t __n)\n {\n-    size_t i;\n+    size_t __i;\n     //  We assume that formatting is set up correctly for each element.\n-    for (i = 0; i < n; i++) o << leaf[i];\n+    for (__i = 0; __i < __n; __i++) _M_o << __leaf[__i];\n     return true;\n }\n \n-inline bool __rope_insert_char_consumer<char>::operator()\n-\t\t\t\t\t(const char * leaf, size_t n)\n+inline bool _Rope_insert_char_consumer<char>::operator()\n+\t\t\t\t\t(const char* __leaf, size_t __n)\n {\n-    size_t i;\n-    for (i = 0; i < n; i++) o.put(leaf[i]);\n+    size_t __i;\n+    for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n     return true;\n }\n \n-#if !defined(_MSC_VER) && !defined(__BORLANDC__)\n-// I couldn't get this to work with the VC++ version of basic_ostream.\n-inline bool __rope_insert_char_consumer<wchar_t>::operator()\n-\t\t\t\t\t(const wchar_t * leaf, size_t n)\n+#if 0\n+// I couldn't get this to work work with the VC++ version of basic_ostream.\n+// It also doesn't really do the right thing unless o is a wide stream.\n+// Given that wchar_t is often 4 bytes, its not clear to me how useful\n+// this stuff is anyway.\n+inline bool _Rope_insert_char_consumer<wchar_t>::operator()\n+\t\t\t\t\t(const wchar_t* __leaf, size_t __n)\n {\n-    size_t i;\n-    for (i = 0; i < n; i++) o.put(leaf[i]);\n+    size_t __i;\n+    for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n     return true;\n }\n #endif /* !_MSC_VER  && !BORLAND */\n \n-template <class charT, class Alloc>\n-bool rope<charT, Alloc>::apply_to_pieces(\n-\t\t\t\t__rope_char_consumer<charT>& c,\n-\t\t\t\tconst RopeBase * r,\n-\t\t\t\tsize_t begin, size_t end)\n+template <class _CharT, class _Alloc>\n+bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n+\t\t\t\t_Rope_char_consumer<_CharT>& __c,\n+\t\t\t\tconst _RopeRep* __r,\n+\t\t\t\tsize_t __begin, size_t __end)\n {\n-    if (0 == r) return true;\n-    switch(r -> tag) {\n-\tcase RopeBase::concat:\n+    if (0 == __r) return true;\n+    switch(__r->_M_tag) {\n+\tcase _RopeRep::_S_concat:\n \t    {\n-\t\tRopeConcatenation *conc = (RopeConcatenation *)r;\n-\t\tRopeBase *left = conc -> left;\n-\t\tsize_t left_len = left -> size;\n-\t\tif (begin < left_len) {\n-\t\t    size_t left_end = min(left_len, end);\n-\t\t    if (!apply_to_pieces(c, left, begin, left_end)) {\n+\t\t_RopeConcatenation* __conc = (_RopeConcatenation*)__r;\n+\t\t_RopeRep* __left =  __conc->_M_left;\n+\t\tsize_t __left_len = __left->_M_size;\n+\t\tif (__begin < __left_len) {\n+\t\t    size_t __left_end = min(__left_len, __end);\n+\t\t    if (!_S_apply_to_pieces(__c, __left, __begin, __left_end))\n \t\t\treturn false;\n-\t\t    }\n \t\t}\n-\t\tif (end > left_len) {\n-\t\t    RopeBase *right = conc -> right;\n-\t\t    size_t right_start = max(left_len, begin);\n-\t\t    if (!apply_to_pieces(c, right,\n-\t\t\t\t\t right_start - left_len,\n-\t\t\t\t\t end - left_len)) {\n+\t\tif (__end > __left_len) {\n+\t\t    _RopeRep* __right =  __conc->_M_right;\n+\t\t    size_t __right_start = max(__left_len, __begin);\n+\t\t    if (!_S_apply_to_pieces(__c, __right,\n+\t\t\t\t\t __right_start - __left_len,\n+\t\t\t\t\t __end - __left_len)) {\n \t\t\treturn false;\n \t\t    }\n \t\t}\n \t    }\n \t    return true;\n-\tcase RopeBase::leaf:\n+\tcase _RopeRep::_S_leaf:\n \t    {\n-\t\tRopeLeaf * l = (RopeLeaf *)r;\n-\t\treturn c(l -> data + begin, end - begin);\n+\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n+\t\treturn __c(__l->_M_data + __begin, __end - __begin);\n \t    }\n-\tcase RopeBase::function:\n-\tcase RopeBase::substringfn:\n+\tcase _RopeRep::_S_function:\n+\tcase _RopeRep::_S_substringfn:\n \t    {\n-\t\tRopeFunction * f = (RopeFunction *)r;\n-\t\tsize_t len = end - begin;\n-\t\tbool result;\n-\t\tcharT * buffer = DataAlloc::allocate(len);\n+\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n+\t\tsize_t __len = __end - __begin;\n+\t\tbool __result;\n+\t\t_CharT* __buffer =\n+\t\t  (_CharT*)alloc::allocate(__len * sizeof(_CharT));\n \t\t__STL_TRY {\n-\t\t  (*(f -> fn))(begin, end, buffer);\n-\t\t  result = c(buffer, len);\n-                  DataAlloc::deallocate(buffer, len);\n+\t\t  (*(__f->_M_fn))(__begin, __end, __buffer);\n+\t\t  __result = __c(__buffer, __len);\n+                  alloc::deallocate(__buffer, __len * sizeof(_CharT));\n                 }\n-\t\t__STL_UNWIND(DataAlloc::deallocate(buffer, len))\n-\t\treturn result;\n+\t\t__STL_UNWIND((alloc::deallocate(__buffer,\n+\t\t\t\t\t\t__len * sizeof(_CharT))))\n+\t\treturn __result;\n \t    }\n \tdefault:\n \t    __stl_assert(false);\n@@ -905,98 +888,102 @@ bool rope<charT, Alloc>::apply_to_pieces(\n     }\n }\n \n-inline void __rope_fill(ostream& o, size_t n)\n+inline void _Rope_fill(ostream& __o, size_t __n)\n {\n-    char f = o.fill();\n-    size_t i;\n+    char __f = __o.fill();\n+    size_t __i;\n \n-    for (i = 0; i < n; i++) o.put(f);\n+    for (__i = 0; __i < __n; __i++) __o.put(__f);\n }\n     \n \n-template <class charT> inline bool __rope_is_simple(charT *) { return false; }\n-inline bool __rope_is_simple(char *) { return true; }\n-inline bool __rope_is_simple(wchar_t *) { return true; }\n+template <class _CharT> inline bool _Rope_is_simple(_CharT*) { return false; }\n+inline bool _Rope_is_simple(char*) { return true; }\n+inline bool _Rope_is_simple(wchar_t*) { return true; }\n \n \n-template<class charT, class Alloc>\n-ostream& operator<< (ostream& o, const rope<charT, Alloc>& r)\n+template<class _CharT, class _Alloc>\n+ostream& operator<< (ostream& __o, const rope<_CharT, _Alloc>& __r)\n {\n-    size_t w = o.width();\n-    bool left = bool(o.flags() & ios::left);\n-    size_t pad_len;\n-    size_t rope_len = r.size();\n-    __rope_insert_char_consumer<charT> c(o);\n-    bool is_simple = __rope_is_simple((charT *)0);\n+    size_t __w = __o.width();\n+    bool __left = bool(__o.flags() & ios::left);\n+    size_t __pad_len;\n+    size_t __rope_len = __r.size();\n+    _Rope_insert_char_consumer<_CharT> __c(__o);\n+    bool __is_simple = _Rope_is_simple((_CharT*)0);\n     \n-    if (rope_len < w) {\n-\tpad_len = w - rope_len;\n+    if (__rope_len < __w) {\n+\t__pad_len = __w - __rope_len;\n     } else {\n-\tpad_len = 0;\n+\t__pad_len = 0;\n     }\n-    if (!is_simple) o.width(w/rope_len);\n+    if (!__is_simple) __o.width(__w/__rope_len);\n     __STL_TRY {\n-      if (is_simple && !left && pad_len > 0) {\n-\t__rope_fill(o, pad_len);\n+      if (__is_simple && !__left && __pad_len > 0) {\n+\t_Rope_fill(__o, __pad_len);\n       }\n-      r.apply_to_pieces(0, r.size(), c);\n-      if (is_simple && left && pad_len > 0) {\n-\t__rope_fill(o, pad_len);\n+      __r.apply_to_pieces(0, __r.size(), __c);\n+      if (__is_simple && __left && __pad_len > 0) {\n+\t_Rope_fill(__o, __pad_len);\n       }\n-      if (!is_simple)\n-        o.width(w);\n+      if (!__is_simple)\n+        __o.width(__w);\n     }\n-    __STL_UNWIND(if (!is_simple) o.width(w))\n-    return o;\n+    __STL_UNWIND(if (!__is_simple) __o.width(__w))\n+    return __o;\n }\n \n-template <class charT, class Alloc>\n-charT *\n-rope<charT,Alloc>::flatten(RopeBase * r,\n-\t\t\t\t size_t start, size_t len,\n-\t\t\t\t charT * buffer)\n+template <class _CharT, class _Alloc>\n+_CharT*\n+rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r,\n+\t\t\t\t size_t __start, size_t __len,\n+\t\t\t\t _CharT* __buffer)\n {\n-    __rope_flatten_char_consumer<charT> c(buffer);\n-    apply_to_pieces(c, r, start, start + len);\n-    return(buffer + len);\n+    _Rope_flatten_char_consumer<_CharT> __c(__buffer);\n+    _S_apply_to_pieces(__c, __r, __start, __start + __len);\n+    return(__buffer + __len);\n }\n \n-template <class charT, class Alloc>\n+template <class _CharT, class _Alloc>\n size_t\n-rope<charT,Alloc>::find(charT pattern, size_t start) const\n+rope<_CharT,_Alloc>::find(_CharT __pattern, size_t __start) const\n {\n-    __rope_find_char_char_consumer<charT> c(pattern);\n-    apply_to_pieces(c, tree_ptr, start, size());\n-    return start + c.count;\n+    _Rope_find_char_char_consumer<_CharT> __c(__pattern);\n+    _S_apply_to_pieces(__c, _M_tree_ptr, __start, size());\n+    size_type __result_pos = __start + __c._M_count;\n+#   ifndef __STL_OLD_ROPE_SEMANTICS\n+\tif (__result_pos == size()) __result_pos = npos;\n+#   endif\n+    return __result_pos;\n }\n \n-template <class charT, class Alloc>\n-charT *\n-rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)\n+template <class _CharT, class _Alloc>\n+_CharT*\n+rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r, _CharT* __buffer)\n {\n-    if (0 == r) return buffer;\n-    switch(r -> tag) {\n-\tcase RopeBase::concat:\n+    if (0 == __r) return __buffer;\n+    switch(__r->_M_tag) {\n+\tcase _RopeRep::_S_concat:\n \t    {\n-\t\tRopeConcatenation *c = (RopeConcatenation *)r;\n-\t\tRopeBase *left = c -> left;\n-\t\tRopeBase *right = c -> right;\n-\t\tcharT * rest = flatten(left, buffer);\n-\t\treturn flatten(right, rest);\n+\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+\t\t_RopeRep* __left = __c->_M_left;\n+\t\t_RopeRep* __right = __c->_M_right;\n+\t\t_CharT* __rest = _S_flatten(__left, __buffer);\n+\t\treturn _S_flatten(__right, __rest);\n \t    }\n-\tcase RopeBase::leaf:\n+\tcase _RopeRep::_S_leaf:\n \t    {\n-\t\tRopeLeaf * l = (RopeLeaf *)r;\n-\t\treturn copy_n(l -> data, l -> size, buffer).second;\n+\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n+\t\treturn copy_n(__l->_M_data, __l->_M_size, __buffer).second;\n \t    }\n-\tcase RopeBase::function:\n-\tcase RopeBase::substringfn:\n+\tcase _RopeRep::_S_function:\n+\tcase _RopeRep::_S_substringfn:\n \t    // We dont yet do anything with substring nodes.\n \t    // This needs to be fixed before ropefiles will work well.\n \t    {\n-\t\tRopeFunction * f = (RopeFunction *)r;\n-\t\t(*(f -> fn))(0, f -> size, buffer);\n-\t\treturn buffer + f -> size;\n+\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n+\t\t(*(__f->_M_fn))(0, __f->_M_size, __buffer);\n+\t\treturn __buffer + __f->_M_size;\n \t    }\n \tdefault:\n \t    __stl_assert(false);\n@@ -1006,72 +993,75 @@ rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)\n }\n \n \n-// This needs work for charT != char\n-template <class charT, class Alloc>\n+// This needs work for _CharT != char\n+template <class _CharT, class _Alloc>\n void\n-rope<charT,Alloc>::dump(RopeBase * r, int indent)\n+rope<_CharT,_Alloc>::_S_dump(_RopeRep* __r, int __indent)\n {\n-    for (int i = 0; i < indent; i++) putchar(' ');\n-    if (0 == r) {\n+    for (int __i = 0; __i < __indent; __i++) putchar(' ');\n+    if (0 == __r) {\n \tprintf(\"NULL\\n\"); return;\n     }\n-    if (RopeBase::concat == r -> tag) {\n-\tRopeConcatenation *c = (RopeConcatenation *)r;\n-\tRopeBase *left = c -> left;\n-\tRopeBase *right = c -> right;\n+    if (_RopeRep::_S_concat == __r->_M_tag) {\n+\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+\t_RopeRep* __left = __c->_M_left;\n+\t_RopeRep* __right = __c->_M_right;\n \n #       ifdef __GC\n \t  printf(\"Concatenation %p (depth = %d, len = %ld, %s balanced)\\n\",\n-\t\t r, r -> depth, r -> size, r -> is_balanced? \"\" : \"not\");\n+\t    __r, __r->_M_depth, __r->_M_size, __r->_M_is_balanced? \"\" : \"not\");\n #       else\n-\t  printf(\"Concatenation %p (rc = %ld, depth = %d, len = %ld, %s balanced)\\n\",\n-\t\t r, r -> refcount, r -> depth, r -> size,\n-\t\t r -> is_balanced? \"\" : \"not\");\n+\t  printf(\"Concatenation %p (rc = %ld, depth = %d, \"\n+\t           \"len = %ld, %s balanced)\\n\",\n+\t\t __r, __r->_M_refcount, __r->_M_depth, __r->_M_size,\n+\t\t __r->_M_is_balanced? \"\" : \"not\");\n #       endif\n-\tdump(left, indent + 2);\n-\tdump(right, indent + 2);\n+\t_S_dump(__left, __indent + 2);\n+\t_S_dump(__right, __indent + 2);\n \treturn;\n     } else {\n-\tchar * kind;\n+\tchar* __kind;\n \n-\tswitch (r -> tag) {\n-\t    case RopeBase::leaf:\n-\t\tkind = \"Leaf\";\n+\tswitch (__r->_M_tag) {\n+\t    case _RopeRep::_S_leaf:\n+\t\t__kind = \"Leaf\";\n \t\tbreak;\n-\t    case RopeBase::function:\n-\t\tkind = \"Function\";\n+\t    case _RopeRep::_S_function:\n+\t\t__kind = \"Function\";\n \t\tbreak;\n-\t    case RopeBase::substringfn:\n-\t\tkind = \"Function representing substring\";\n+\t    case _RopeRep::_S_substringfn:\n+\t\t__kind = \"Function representing substring\";\n \t\tbreak;\n \t    default:\n-\t\tkind = \"(corrupted kind field!)\";\n+\t\t__kind = \"(corrupted kind field!)\";\n \t}\n #       ifdef __GC\n \t  printf(\"%s %p (depth = %d, len = %ld) \",\n-\t\t kind, r, r -> depth, r -> size);\n+\t\t __kind, __r, __r->_M_depth, __r->_M_size);\n #       else\n \t  printf(\"%s %p (rc = %ld, depth = %d, len = %ld) \",\n-\t\t kind, r, r -> refcount, r -> depth, r -> size);\n+\t\t __kind, __r, __r->_M_refcount, __r->_M_depth, __r->_M_size);\n #       endif\n-\tif (__is_one_byte_char_type((charT *)0)) {\n-\t    const int max_len = 40;\n-\t    self_destruct_ptr prefix(substring(r, 0, max_len));\n-\t    charT buffer[max_len + 1];\n-\t    bool too_big = r -> size > prefix-> size;\n-\n-\t    flatten(prefix, buffer);\n-\t    buffer[prefix -> size] = __eos((charT *)0); \n-\t    printf(\"%s%s\\n\", (char *)buffer, too_big? \"...\\n\" : \"\\n\");\n+\tif (_S_is_one_byte_char_type((_CharT*)0)) {\n+\t    const int __max_len = 40;\n+\t    _Self_destruct_ptr __prefix(_S_substring(__r, 0, __max_len));\n+\t    _CharT __buffer[__max_len + 1];\n+\t    bool __too_big = __r->_M_size > __prefix->_M_size;\n+\n+\t    _S_flatten(__prefix, __buffer);\n+\t    __buffer[__prefix->_M_size] = _S_eos((_CharT*)0); \n+\t    printf(\"%s%s\\n\", \n+\t           (char*)__buffer, __too_big? \"...\\n\" : \"\\n\");\n \t} else {\n \t    printf(\"\\n\");\n \t}\n     }\n }\n \n-template <class charT, class Alloc>\n+template <class _CharT, class _Alloc>\n const unsigned long\n-rope<charT,Alloc>::min_len[__rope_RopeBase<charT,Alloc>::max_rope_depth + 1] = {\n+rope<_CharT,_Alloc>::_S_min_len[\n+  _Rope_RopeRep<_CharT,_Alloc>::_S_max_rope_depth + 1] = {\n /* 0 */1, /* 1 */2, /* 2 */3, /* 3 */5, /* 4 */8, /* 5 */13, /* 6 */21,\n /* 7 */34, /* 8 */55, /* 9 */89, /* 10 */144, /* 11 */233, /* 12 */377,\n /* 13 */610, /* 14 */987, /* 15 */1597, /* 16 */2584, /* 17 */4181,\n@@ -1082,148 +1072,150 @@ rope<charT,Alloc>::min_len[__rope_RopeBase<charT,Alloc>::max_rope_depth + 1] = {\n /* 35 */24157817, /* 36 */39088169, /* 37 */63245986, /* 38 */102334155,\n /* 39 */165580141, /* 40 */267914296, /* 41 */433494437,\n /* 42 */701408733, /* 43 */1134903170, /* 44 */1836311903,\n-/* 45 */2971215073 };\n+/* 45 */2971215073u };\n // These are Fibonacci numbers < 2**32.\n \n-template <class charT, class Alloc>\n-rope<charT,Alloc>::RopeBase *\n-rope<charT,Alloc>::balance(RopeBase *r)\n+template <class _CharT, class _Alloc>\n+rope<_CharT,_Alloc>::_RopeRep*\n+rope<_CharT,_Alloc>::_S_balance(_RopeRep* __r)\n {\n-    RopeBase * forest[RopeBase::max_rope_depth + 1];\n-    RopeBase * result = 0;\n-    int i;\n-    // Inariant:\n-    // The concatenation of forest in descending order is equal to r.\n-    // forest[i].size >= min_len[i]\n-    // forest[i].depth = i\n+    _RopeRep* __forest[_RopeRep::_S_max_rope_depth + 1];\n+    _RopeRep* __result = 0;\n+    int __i;\n+    // Invariant:\n+    // The concatenation of forest in descending order is equal to __r.\n+    // __forest[__i]._M_size >= _S_min_len[__i]\n+    // __forest[__i]._M_depth = __i\n     // References from forest are included in refcount.\n \n-    for (i = 0; i <= RopeBase::max_rope_depth; ++i) forest[i] = 0;\n+    for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n+      __forest[__i] = 0;\n     __STL_TRY {\n-      add_to_forest(r, forest);\n-      for (i = 0; i <= RopeBase::max_rope_depth; ++i) if (0 != forest[i]) {\n+      _S_add_to_forest(__r, __forest);\n+      for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n+        if (0 != __forest[__i]) {\n #\tifndef __GC\n-\t  self_destruct_ptr old(result);\n+\t  _Self_destruct_ptr __old(__result);\n #\tendif\n-\tresult = concat(forest[i], result);\n-\tforest[i] -> unref_nonnil();\n+\t  __result = _S_concat(__forest[__i], __result);\n+\t__forest[__i]->_M_unref_nonnil();\n #\tif !defined(__GC) && defined(__STL_USE_EXCEPTIONS)\n-\t  forest[i] = 0;\n+\t  __forest[__i] = 0;\n #\tendif\n       }\n     }\n-    __STL_UNWIND(for(i = 0; i <= RopeBase::max_rope_depth; i++)\n-\t\t unref(forest[i]))\n-    if (result -> depth > RopeBase::max_rope_depth) abort();\n-    return(result);\n+    __STL_UNWIND(for(__i = 0; __i <= _RopeRep::_S_max_rope_depth; __i++)\n+\t\t _S_unref(__forest[__i]))\n+    if (__result->_M_depth > _RopeRep::_S_max_rope_depth) abort();\n+    return(__result);\n }\n \n \n-template <class charT, class Alloc>\n+template <class _CharT, class _Alloc>\n void\n-rope<charT,Alloc>::add_to_forest(RopeBase *r, RopeBase **forest)\n+rope<_CharT,_Alloc>::_S_add_to_forest(_RopeRep* __r, _RopeRep** __forest)\n {\n-    if (r -> is_balanced) {\n-\tadd_leaf_to_forest(r, forest);\n+    if (__r->_M_is_balanced) {\n+\t_S_add_leaf_to_forest(__r, __forest);\n \treturn;\n     }\n-    __stl_assert(r -> tag == RopeBase::concat);\n+    __stl_assert(__r->_M_tag == _RopeRep::_S_concat);\n     {\n-\tRopeConcatenation *c = (RopeConcatenation *)r;\n+\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \n-\tadd_to_forest(c -> left, forest);\n-\tadd_to_forest(c -> right, forest);\n+\t_S_add_to_forest(__c->_M_left, __forest);\n+\t_S_add_to_forest(__c->_M_right, __forest);\n     }\n }\n \n \n-template <class charT, class Alloc>\n+template <class _CharT, class _Alloc>\n void\n-rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)\n+rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n {\n-    RopeBase * insertee;   \t\t// included in refcount\n-    RopeBase * too_tiny = 0;    \t// included in refcount\n-    int i;  \t\t\t\t// forest[0..i-1] is empty\n-    size_t s = r -> size;\n+    _RopeRep* __insertee;   \t\t// included in refcount\n+    _RopeRep* __too_tiny = 0;    \t// included in refcount\n+    int __i;  \t\t\t\t// forest[0..__i-1] is empty\n+    size_t __s = __r->_M_size;\n \n-    for (i = 0; s >= min_len[i+1]/* not this bucket */; ++i) {\n-\tif (0 != forest[i]) {\n+    for (__i = 0; __s >= _S_min_len[__i+1]/* not this bucket */; ++__i) {\n+\tif (0 != __forest[__i]) {\n #\t    ifndef __GC\n-\t      self_destruct_ptr old(too_tiny);\n+\t      _Self_destruct_ptr __old(__too_tiny);\n #\t    endif\n-\t    too_tiny = concat_and_set_balanced(forest[i], too_tiny);\n-\t    forest[i] -> unref_nonnil();\n-\t    forest[i] = 0;\n+\t    __too_tiny = _S_concat_and_set_balanced(__forest[__i], __too_tiny);\n+\t    __forest[__i]->_M_unref_nonnil();\n+\t    __forest[__i] = 0;\n \t}\n     }\n     {\n #\tifndef __GC\n-\t  self_destruct_ptr old(too_tiny);\n+\t  _Self_destruct_ptr __old(__too_tiny);\n #\tendif\n-\tinsertee = concat_and_set_balanced(too_tiny, r);\n+\t__insertee = _S_concat_and_set_balanced(__too_tiny, __r);\n     }\n     // Too_tiny dead, and no longer included in refcount.\n     // Insertee is live and included.\n-    __stl_assert(is_almost_balanced(insertee));\n-    __stl_assert(insertee -> depth <= r -> depth + 1);\n-    for (;; ++i) {\n-\tif (0 != forest[i]) {\n+    __stl_assert(_S_is_almost_balanced(__insertee));\n+    __stl_assert(__insertee->_M_depth <= __r->_M_depth + 1);\n+    for (;; ++__i) {\n+\tif (0 != __forest[__i]) {\n #\t    ifndef __GC\n-\t      self_destruct_ptr old(insertee);\n+\t      _Self_destruct_ptr __old(__insertee);\n #\t    endif\n-\t    insertee = concat_and_set_balanced(forest[i], insertee);\n-\t    forest[i] -> unref_nonnil();\n-\t    forest[i] = 0;\n-\t    __stl_assert(is_almost_balanced(insertee));\n+\t    __insertee = _S_concat_and_set_balanced(__forest[__i], __insertee);\n+\t    __forest[__i]->_M_unref_nonnil();\n+\t    __forest[__i] = 0;\n+\t    __stl_assert(_S_is_almost_balanced(__insertee));\n \t}\n-\t__stl_assert(min_len[i] <= insertee -> size);\n-\t__stl_assert(forest[i] == 0);\n-\tif (i == RopeBase::max_rope_depth\n-\t    || insertee -> size < min_len[i+1]) {\n-\t    forest[i] = insertee;\n-\t    // refcount is OK since insertee is now dead.\n+\t__stl_assert(_S_min_len[__i] <= __insertee->_M_size);\n+\t__stl_assert(__forest[__i] == 0);\n+\tif (__i == _RopeRep::_S_max_rope_depth || \n+\t      __insertee->_M_size < _S_min_len[__i+1]) {\n+\t    __forest[__i] = __insertee;\n+\t    // refcount is OK since __insertee is now dead.\n \t    return;\n \t}\n     }\n }\n \n-template <class charT, class Alloc>\n-charT\n-rope<charT,Alloc>::fetch(RopeBase *r, size_type i)\n+template <class _CharT, class _Alloc>\n+_CharT\n+rope<_CharT,_Alloc>::_S_fetch(_RopeRep* __r, size_type __i)\n {\n-    __GC_CONST charT * cstr = r -> c_string;\n+    __GC_CONST _CharT* __cstr = __r->_M_c_string;\n \n-    __stl_assert(i < r -> size);\n-    if (0 != cstr) return cstr[i]; \n+    __stl_assert(__i < __r->_M_size);\n+    if (0 != __cstr) return __cstr[__i]; \n     for(;;) {\n-      switch(r -> tag) {\n-\tcase RopeBase::concat:\n+      switch(__r->_M_tag) {\n+\tcase _RopeRep::_S_concat:\n \t    {\n-\t\tRopeConcatenation *c = (RopeConcatenation *)r;\n-\t\tRopeBase *left = c -> left;\n-\t\tsize_t left_len = left -> size;\n+\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+\t\t_RopeRep* __left = __c->_M_left;\n+\t\tsize_t __left_len = __left->_M_size;\n \n-\t\tif (i >= left_len) {\n-\t\t    i -= left_len;\n-\t\t    r = c -> right;\n+\t\tif (__i >= __left_len) {\n+\t\t    __i -= __left_len;\n+\t\t    __r = __c->_M_right;\n \t\t} else {\n-\t\t    r = left;\n+\t\t    __r = __left;\n \t\t}\n \t    }\n \t    break;\n-\tcase RopeBase::leaf:\n+\tcase _RopeRep::_S_leaf:\n \t    {\n-\t\tRopeLeaf * l = (RopeLeaf *)r;\n-\t\treturn l -> data[i];\n+\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n+\t\treturn __l->_M_data[__i];\n \t    }\n-\tcase RopeBase::function:\n-\tcase RopeBase::substringfn:\n+\tcase _RopeRep::_S_function:\n+\tcase _RopeRep::_S_substringfn:\n \t    {\n-\t\tRopeFunction * f = (RopeFunction *)r;\n-\t\tcharT result;\n+\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n+\t\t_CharT __result;\n \n-\t\t(*(f -> fn))(i, 1, &result);\n-\t\treturn result;\n+\t\t(*(__f->_M_fn))(__i, 1, &__result);\n+\t\treturn __result;\n \t    }\n       }\n     }\n@@ -1232,46 +1224,46 @@ rope<charT,Alloc>::fetch(RopeBase *r, size_type i)\n # ifndef __GC\n // Return a uniquely referenced character slot for the given\n // position, or 0 if that's not possible.\n-template <class charT, class Alloc>\n-charT*\n-rope<charT,Alloc>::fetch_ptr(RopeBase *r, size_type i)\n+template <class _CharT, class _Alloc>\n+_CharT*\n+rope<_CharT,_Alloc>::_S_fetch_ptr(_RopeRep* __r, size_type __i)\n {\n-    RopeBase * clrstack[RopeBase::max_rope_depth];\n-    size_t csptr = 0;\n+    _RopeRep* __clrstack[_RopeRep::_S_max_rope_depth];\n+    size_t __csptr = 0;\n \n     for(;;) {\n-      if (r -> refcount > 1) return 0;\n-      switch(r -> tag) {\n-\tcase RopeBase::concat:\n+      if (__r->_M_refcount > 1) return 0;\n+      switch(__r->_M_tag) {\n+\tcase _RopeRep::_S_concat:\n \t    {\n-\t\tRopeConcatenation *c = (RopeConcatenation *)r;\n-\t\tRopeBase *left = c -> left;\n-\t\tsize_t left_len = left -> size;\n-\n-\t\tif (c -> c_string != 0) clrstack[csptr++] = c;\n-\t\tif (i >= left_len) {\n-\t\t    i -= left_len;\n-\t\t    r = c -> right;\n+\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n+\t\t_RopeRep* __left = __c->_M_left;\n+\t\tsize_t __left_len = __left->_M_size;\n+\n+\t\tif (__c->_M_c_string != 0) __clrstack[__csptr++] = __c;\n+\t\tif (__i >= __left_len) {\n+\t\t    __i -= __left_len;\n+\t\t    __r = __c->_M_right;\n \t\t} else {\n-\t\t    r = left;\n+\t\t    __r = __left;\n \t\t}\n \t    }\n \t    break;\n-\tcase RopeBase::leaf:\n+\tcase _RopeRep::_S_leaf:\n \t    {\n-\t\tRopeLeaf * l = (RopeLeaf *)r;\n-\t\tif (l -> c_string != l -> data && l -> c_string != 0)\n-\t\t    clrstack[csptr++] = l;\n-\t\twhile (csptr > 0) {\n-\t\t    -- csptr;\n-\t\t    RopeBase * d = clrstack[csptr];\n-\t\t    d -> free_c_string();\n-\t\t    d -> c_string = 0;\n+\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n+\t\tif (__l->_M_c_string != __l->_M_data && __l->_M_c_string != 0)\n+\t\t    __clrstack[__csptr++] = __l;\n+\t\twhile (__csptr > 0) {\n+\t\t    -- __csptr;\n+\t\t    _RopeRep* __d = __clrstack[__csptr];\n+\t\t    __d->_M_free_c_string();\n+\t\t    __d->_M_c_string = 0;\n \t\t}\n-\t\treturn l -> data + i;\n+\t\treturn __l->_M_data + __i;\n \t    }\n-\tcase RopeBase::function:\n-\tcase RopeBase::substringfn:\n+\tcase _RopeRep::_S_function:\n+\tcase _RopeRep::_S_substringfn:\n \t    return 0;\n       }\n     }\n@@ -1282,233 +1274,253 @@ rope<charT,Alloc>::fetch_ptr(RopeBase *r, size_type i)\n // lexicographical_compare_3way.\n // We do a little more work to avoid dealing with rope iterators for\n // flat strings.\n-template <class charT, class Alloc>\n+template <class _CharT, class _Alloc>\n int\n-rope<charT,Alloc>::compare (const RopeBase *left, const RopeBase *right)\n+rope<_CharT,_Alloc>::_S_compare (const _RopeRep* __left, \n+                                 const _RopeRep* __right)\n {\n-    size_t left_len;\n-    size_t right_len;\n-\n-    if (0 == right) return 0 != left;\n-    if (0 == left) return -1;\n-    left_len = left -> size;\n-    right_len = right -> size;\n-    if (RopeBase::leaf == left -> tag) {\n-\tRopeLeaf *l = (RopeLeaf *) left;\n-\tif (RopeBase::leaf == right -> tag) {\n-\t    RopeLeaf *r = (RopeLeaf *) right;\n+    size_t __left_len;\n+    size_t __right_len;\n+\n+    if (0 == __right) return 0 != __left;\n+    if (0 == __left) return -1;\n+    __left_len = __left->_M_size;\n+    __right_len = __right->_M_size;\n+    if (_RopeRep::_S_leaf == __left->_M_tag) {\n+\t_RopeLeaf* __l = (_RopeLeaf*) __left;\n+\tif (_RopeRep::_S_leaf == __right->_M_tag) {\n+\t    _RopeLeaf* __r = (_RopeLeaf*) __right;\n \t    return lexicographical_compare_3way(\n-\t\t\tl -> data, l -> data + left_len,\n-\t\t\tr -> data, r -> data + right_len);\n+\t\t\t__l->_M_data, __l->_M_data + __left_len,\n+\t\t\t__r->_M_data, __r->_M_data + __right_len);\n \t} else {\n-\t    const_iterator rstart(right, 0);\n-\t    const_iterator rend(right, right_len);\n+\t    const_iterator __rstart(__right, 0);\n+\t    const_iterator __rend(__right, __right_len);\n \t    return lexicographical_compare_3way(\n-\t\t\tl -> data, l -> data + left_len,\n-\t\t\trstart, rend);\n+\t\t\t__l->_M_data, __l->_M_data + __left_len,\n+\t\t\t__rstart, __rend);\n \t}\n     } else {\n-\tconst_iterator lstart(left, 0);\n-\tconst_iterator lend(left, left_len);\n-\tif (RopeBase::leaf == right -> tag) {\n-\t    RopeLeaf *r = (RopeLeaf *) right;\n+\tconst_iterator __lstart(__left, 0);\n+\tconst_iterator __lend(__left, __left_len);\n+\tif (_RopeRep::_S_leaf == __right->_M_tag) {\n+\t    _RopeLeaf* __r = (_RopeLeaf*) __right;\n \t    return lexicographical_compare_3way(\n-\t\t\t\t   lstart, lend,\n-\t\t\t\t   r -> data, r -> data + right_len);\n+\t\t\t\t   __lstart, __lend,\n+\t\t\t\t   __r->_M_data, __r->_M_data + __right_len);\n \t} else {\n-\t    const_iterator rstart(right, 0);\n-\t    const_iterator rend(right, right_len);\n+\t    const_iterator __rstart(__right, 0);\n+\t    const_iterator __rend(__right, __right_len);\n \t    return lexicographical_compare_3way(\n-\t\t\t\t   lstart, lend,\n-\t\t\t\t   rstart, rend);\n+\t\t\t\t   __lstart, __lend,\n+\t\t\t\t   __rstart, __rend);\n \t}\n     }\n }\n \n // Assignment to reference proxies.\n-template <class charT, class Alloc>\n-__rope_charT_ref_proxy<charT, Alloc>&\n-__rope_charT_ref_proxy<charT, Alloc>::operator= (charT c) {\n-    RopeBase * old = root -> tree_ptr;\n+template <class _CharT, class _Alloc>\n+_Rope_char_ref_proxy<_CharT, _Alloc>&\n+_Rope_char_ref_proxy<_CharT, _Alloc>::operator= (_CharT __c) {\n+    _RopeRep* __old = _M_root->_M_tree_ptr;\n #   ifndef __GC\n \t// First check for the case in which everything is uniquely\n \t// referenced.  In that case we can do this destructively.\n-\tcharT * charT_ptr = my_rope::fetch_ptr(old, pos);\n-\tif (0 != charT_ptr) {\n-\t    *charT_ptr = c;\n+\t_CharT* __ptr = _My_rope::_S_fetch_ptr(__old, _M_pos);\n+\tif (0 != __ptr) {\n+\t    *__ptr = __c;\n \t    return *this;\n \t}\n #   endif\n-    self_destruct_ptr left(my_rope::substring(old, 0, pos));\n-    self_destruct_ptr right(my_rope::substring(old, pos+1, old -> size));\n-    self_destruct_ptr result_left(my_rope::destr_concat_char_iter(left, &c, 1));\n+    _Self_destruct_ptr __left(\n+      _My_rope::_S_substring(__old, 0, _M_pos));\n+    _Self_destruct_ptr __right(\n+      _My_rope::_S_substring(__old, _M_pos+1, __old->_M_size));\n+    _Self_destruct_ptr __result_left(\n+      _My_rope::_S_destr_concat_char_iter(__left, &__c, 1));\n+\n #   ifndef __GC\n-      __stl_assert(left == result_left || 1 == result_left -> refcount);\n+      __stl_assert(__left == __result_left || 1 == __result_left->_M_refcount);\n #   endif\n-    RopeBase * result =\n-\t\tmy_rope::concat(result_left, right);\n+    _RopeRep* __result =\n+\t\t_My_rope::_S_concat(__result_left, __right);\n #   ifndef __GC\n-      __stl_assert(1 <= result -> refcount);\n-      RopeBase::unref(old);\n+      __stl_assert(1 <= __result->_M_refcount);\n+      _RopeRep::_S_unref(__old);\n #   endif\n-    root -> tree_ptr = result;\n+    _M_root->_M_tree_ptr = __result;\n     return *this;\n }\n \n-template <class charT, class Alloc>\n-inline __rope_charT_ref_proxy<charT, Alloc>::operator charT () const\n+template <class _CharT, class _Alloc>\n+inline _Rope_char_ref_proxy<_CharT, _Alloc>::operator _CharT () const\n {\n-    if (current_valid) {\n-\treturn current;\n+    if (_M_current_valid) {\n+\treturn _M_current;\n     } else {\n-        return my_rope::fetch(root->tree_ptr, pos);\n+        return _My_rope::_S_fetch(_M_root->_M_tree_ptr, _M_pos);\n     }\n }\n-template <class charT, class Alloc>\n-__rope_charT_ptr_proxy<charT, Alloc>\n-__rope_charT_ref_proxy<charT, Alloc>::operator& () const {\n-    return __rope_charT_ptr_proxy<charT, Alloc>(*this);\n+template <class _CharT, class _Alloc>\n+_Rope_char_ptr_proxy<_CharT, _Alloc>\n+_Rope_char_ref_proxy<_CharT, _Alloc>::operator& () const {\n+    return _Rope_char_ptr_proxy<_CharT, _Alloc>(*this);\n }\n \n-template <class charT, class Alloc>\n-rope<charT, Alloc>::rope(size_t n, charT c)\n+template <class _CharT, class _Alloc>\n+rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n+\t\t\t   const allocator_type& __a)\n+: _Base(__a)\n {\n-    rope result;\n-    const size_t exponentiate_threshold = 32;\n-    size_t exponent;\n-    size_t rest;\n-    charT *rest_buffer;\n-    RopeBase * remainder;\n-    rope remainder_rope;\n-\n-    if (0 == n) { tree_ptr = 0; return; }\n-    exponent = n / exponentiate_threshold;\n-    rest = n % exponentiate_threshold;\n-    if (0 == rest) {\n-\tremainder = 0;\n+    rope<_CharT,_Alloc> __result;\n+    const size_t __exponentiate_threshold = 32;\n+    size_t __exponent;\n+    size_t __rest;\n+    _CharT* __rest_buffer;\n+    _RopeRep* __remainder;\n+    rope<_CharT,_Alloc> __remainder_rope;\n+\n+    if (0 == __n)\n+      return;\n+    \n+    __exponent = __n / __exponentiate_threshold;\n+    __rest = __n % __exponentiate_threshold;\n+    if (0 == __rest) {\n+\t__remainder = 0;\n     } else {\n-\trest_buffer = DataAlloc::allocate(rounded_up_size(rest));\n-\tuninitialized_fill_n(rest_buffer, rest, c);\n-\t__cond_store_eos(rest_buffer[rest]);\n+\t__rest_buffer = _Data_allocate(_S_rounded_up_size(__rest));\n+\tuninitialized_fill_n(__rest_buffer, __rest, __c);\n+\t_S_cond_store_eos(__rest_buffer[__rest]);\n \t__STL_TRY {\n-\t    remainder = RopeLeaf_from_char_ptr(rest_buffer, rest);\n+\t    __remainder = _S_new_RopeLeaf(__rest_buffer, __rest, __a);\n         }\n-\t__STL_UNWIND(RopeBase::free_string(rest_buffer, rest))\n+\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(__rest_buffer, __rest, __a))\n     }\n-    remainder_rope.tree_ptr = remainder;\n-    if (exponent != 0) {\n-\tcharT * base_buffer =\n-\t\tDataAlloc::allocate(rounded_up_size(exponentiate_threshold));\n-\tRopeLeaf * base_leaf;\n-\trope base_rope;\n-\tuninitialized_fill_n(base_buffer, exponentiate_threshold, c);\n-\t__cond_store_eos(base_buffer[exponentiate_threshold]);\n+    __remainder_rope._M_tree_ptr = __remainder;\n+    if (__exponent != 0) {\n+\t_CharT* __base_buffer =\n+\t  _Data_allocate(_S_rounded_up_size(__exponentiate_threshold));\n+\t_RopeLeaf* __base_leaf;\n+\trope __base_rope;\n+\tuninitialized_fill_n(__base_buffer, __exponentiate_threshold, __c);\n+\t_S_cond_store_eos(__base_buffer[__exponentiate_threshold]);\n \t__STL_TRY {\n-          base_leaf = RopeLeaf_from_char_ptr(base_buffer,\n-                                             exponentiate_threshold);\n+          __base_leaf = _S_new_RopeLeaf(__base_buffer,\n+                                        __exponentiate_threshold, __a);\n         }\n-\t__STL_UNWIND(RopeBase::free_string(base_buffer, exponentiate_threshold))\n-\tbase_rope.tree_ptr = base_leaf;\n- \tif (1 == exponent) {\n-\t  result = base_rope;\n+\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(__base_buffer, \n+\t                                         __exponentiate_threshold, __a))\n+\t__base_rope._M_tree_ptr = __base_leaf;\n+ \tif (1 == __exponent) {\n+\t  __result = __base_rope;\n #         ifndef __GC\n-\t    __stl_assert(1 == result -> tree_ptr -> refcount);\n+\t    __stl_assert(2 == __result._M_tree_ptr->_M_refcount);\n+\t\t// One each for base_rope and __result\n #         endif\n \t} else {\n-\t  result = power(base_rope, exponent, concat_fn());\n+\t  // XXX what is power()?\n+\t  __result = power(__base_rope, __exponent, _Concat_fn());\n \t}\n-\tif (0 != remainder) {\n-\t  result += remainder_rope;\n+\tif (0 != __remainder) {\n+\t  __result += __remainder_rope;\n \t}\n     } else {\n-\tresult = remainder_rope;\n+\t__result = __remainder_rope;\n     }\n-    tree_ptr = result.tree_ptr;\n-    tree_ptr -> ref_nonnil();\n+    _M_tree_ptr = __result._M_tree_ptr;\n+    _M_tree_ptr->_M_ref_nonnil();\n }\n \n-template<class charT, class Alloc> charT rope<charT,Alloc>::empty_c_str[1];\n+template<class _CharT, class _Alloc>\n+  _CharT rope<_CharT,_Alloc>::_S_empty_c_str[1];\n \n # ifdef __STL_PTHREADS\n-    template<class charT, class Alloc>\n-    pthread_mutex_t rope<charT,Alloc>::swap_lock = PTHREAD_MUTEX_INITIALIZER;\n+    template<class _CharT, class _Alloc>\n+    pthread_mutex_t \n+    rope<_CharT,_Alloc>::_S_swap_lock = PTHREAD_MUTEX_INITIALIZER;\n # endif\n \n-template<class charT, class Alloc>\n-const charT * rope<charT,Alloc>::c_str() const {\n-    if (0 == tree_ptr) {\n-        empty_c_str[0] = __eos((charT *)0);  // Possibly redundant,\n+template<class _CharT, class _Alloc>\n+const _CharT* rope<_CharT,_Alloc>::c_str() const {\n+    if (0 == _M_tree_ptr) {\n+        _S_empty_c_str[0] = _S_eos((_CharT*)0);  // Possibly redundant,\n \t\t\t\t\t     // but probably fast.\n-        return empty_c_str;\n+        return _S_empty_c_str;\n     }\n-    __GC_CONST charT * old_c_string = tree_ptr -> c_string;\n-    if (0 != old_c_string) return(old_c_string);\n-    size_t s = size();\n-    charT * result = DataAlloc::allocate(s + 1);\n-    flatten(tree_ptr, result);\n-    result[s] = __eos((charT *)0);\n+    __GC_CONST _CharT* __old_c_string = _M_tree_ptr->_M_c_string;\n+    if (0 != __old_c_string) return(__old_c_string);\n+    size_t __s = size();\n+    _CharT* __result = _Data_allocate(__s + 1);\n+    _S_flatten(_M_tree_ptr, __result);\n+    __result[__s] = _S_eos((_CharT*)0);\n #   ifdef __GC\n-\ttree_ptr -> c_string = result;\n+\t_M_tree_ptr->_M_c_string = __result;\n #   else\n-      if ((old_c_string = atomic_swap(&(tree_ptr -> c_string), result)) != 0) {\n+      if ((__old_c_string = \n+             _S_atomic_swap(&(_M_tree_ptr->_M_c_string), __result)) != 0) {\n \t// It must have been added in the interim.  Hence it had to have been\n \t// separately allocated.  Deallocate the old copy, since we just\n \t// replaced it.\n-\tdestroy(old_c_string, old_c_string + s + 1);\n-\tDataAlloc::deallocate(old_c_string, s + 1);\n+\tdestroy(__old_c_string, __old_c_string + __s + 1);\n+\t_Data_deallocate(__old_c_string, __s + 1);\n       }\n #   endif\n-    return(result);\n+    return(__result);\n }\n \n-template<class charT, class Alloc>\n-const charT * rope<charT,Alloc>::replace_with_c_str() {\n-    if (0 == tree_ptr) {\n-        empty_c_str[0] = __eos((charT *)0);\n-        return empty_c_str;\n+template<class _CharT, class _Alloc>\n+const _CharT* rope<_CharT,_Alloc>::replace_with_c_str() {\n+    if (0 == _M_tree_ptr) {\n+        _S_empty_c_str[0] = _S_eos((_CharT*)0);\n+        return _S_empty_c_str;\n     }\n-    __GC_CONST charT * old_c_string = tree_ptr -> c_string;\n-    if (RopeBase::leaf == tree_ptr -> tag && 0 != old_c_string) {\n-\treturn(old_c_string);\n+    __GC_CONST _CharT* __old_c_string = _M_tree_ptr->_M_c_string;\n+    if (_RopeRep::_S_leaf == _M_tree_ptr->_M_tag && 0 != __old_c_string) {\n+\treturn(__old_c_string);\n     }\n-    size_t s = size();\n-    charT * result = DataAlloc::allocate(rounded_up_size(s));\n-    flatten(tree_ptr, result);\n-    result[s] = __eos((charT *)0);\n-    tree_ptr -> unref_nonnil();\n-    tree_ptr = RopeLeaf_from_char_ptr(result, s);\n-    return(result);\n+    size_t __s = size();\n+    _CharT* __result = _Data_allocate(_S_rounded_up_size(__s));\n+    _S_flatten(_M_tree_ptr, __result);\n+    __result[__s] = _S_eos((_CharT*)0);\n+    _M_tree_ptr->_M_unref_nonnil();\n+    _M_tree_ptr = _S_new_RopeLeaf(__result, __s, get_allocator());\n+    return(__result);\n }\n \n // Algorithm specializations.  More should be added.\n \n #ifndef _MSC_VER\n // I couldn't get this to work with VC++\n-template<class charT,class Alloc>\n+template<class _CharT,class _Alloc>\n void\n-__rope_rotate(__rope_iterator<charT,Alloc> first,\n-              __rope_iterator<charT,Alloc> middle,\n-              __rope_iterator<charT,Alloc> last) {\n-    __stl_assert(first.container() == middle.container()\n-                 && middle.container() == last.container());\n-    rope<charT,Alloc>& r(first.container());\n-    rope<charT,Alloc> prefix = r.substr(0, first.index());\n-    rope<charT,Alloc> suffix = r.substr(last.index(), r.size() - last.index());\n-    rope<charT,Alloc> part1 = r.substr(middle.index(),\n-                                       last.index() - middle.index());\n-    rope<charT,Alloc> part2 = r.substr(first.index(),\n-                                       middle.index() - first.index());\n-    r = prefix;\n-    r += part1;\n-    r += part2;\n-    r += suffix;\n+_Rope_rotate(_Rope_iterator<_CharT,_Alloc> __first,\n+              _Rope_iterator<_CharT,_Alloc> __middle,\n+              _Rope_iterator<_CharT,_Alloc> __last)\n+{\n+    __stl_assert(__first.container() == __middle.container()\n+                 && __middle.container() == __last.container());\n+    rope<_CharT,_Alloc>& __r(__first.container());\n+    rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());\n+    rope<_CharT,_Alloc> __suffix = \n+      __r.substr(__last.index(), __r.size() - __last.index());\n+    rope<_CharT,_Alloc> __part1 = \n+      __r.substr(__middle.index(), __last.index() - __middle.index());\n+    rope<_CharT,_Alloc> __part2 = \n+      __r.substr(__first.index(), __middle.index() - __first.index());\n+    __r = __prefix;\n+    __r += __part1;\n+    __r += __part2;\n+    __r += __suffix;\n }\n \n-inline void rotate(__rope_iterator<char,__ALLOC> first,\n-                   __rope_iterator<char,__ALLOC> middle,\n-                   __rope_iterator<char,__ALLOC> last) {\n-    __rope_rotate(first, middle, last);\n+#if !defined(__GNUC__)\n+// Appears to confuse g++\n+inline void rotate(_Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __first,\n+                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n+                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n+    _Rope_rotate(__first, __middle, __last);\n }\n+#endif\n \n # if 0\n // Probably not useful for several reasons:\n@@ -1518,10 +1530,11 @@ inline void rotate(__rope_iterator<char,__ALLOC> first,\n // - wchar_t is 4 bytes wide on most UNIX platforms, making it unattractive\n //   for unicode strings.  Unsigned short may be a better character\n //   type.\n-inline void rotate(__rope_iterator<wchar_t,__ALLOC> first,\n-                   __rope_iterator<wchar_t,__ALLOC> middle,\n-                   __rope_iterator<wchar_t,__ALLOC> last) {\n-    __rope_rotate(first, middle, last);\n+inline void rotate(\n+\t\t_Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __first,\n+                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n+                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n+    _Rope_rotate(__first, __middle, __last);\n }\n # endif\n #endif /* _MSC_VER */"}, {"sha": "57607ba5d49d3cf912b532f92f57e1cc30907574", "filename": "libstdc++/stl/stl_algo.h", "status": "modified", "additions": 2289, "deletions": 2069, "changes": 4358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_algo.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "15e535f483d26385b1f6e133f100a12900989791", "filename": "libstdc++/stl/stl_algobase.h", "status": "modified", "additions": 336, "deletions": 252, "changes": 588, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_algobase.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996-1998\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -58,381 +58,465 @@\n \n __STL_BEGIN_NAMESPACE\n \n-template <class ForwardIterator1, class ForwardIterator2, class T>\n-inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {\n-  T tmp = *a;\n-  *a = *b;\n-  *b = tmp;\n+// swap and iter_swap\n+\n+template <class _ForwardIter1, class _ForwardIter2, class _Tp>\n+inline void __iter_swap(_ForwardIter1 __a, _ForwardIter2 __b, _Tp*) {\n+  _Tp __tmp = *__a;\n+  *__a = *__b;\n+  *__b = __tmp;\n }\n \n-template <class ForwardIterator1, class ForwardIterator2>\n-inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {\n-  __iter_swap(a, b, value_type(a));\n+template <class _ForwardIter1, class _ForwardIter2>\n+inline void iter_swap(_ForwardIter1 __a, _ForwardIter2 __b) {\n+  __iter_swap(__a, __b, __VALUE_TYPE(__a));\n }\n \n-template <class T>\n-inline void swap(T& a, T& b) {\n-  T tmp = a;\n-  a = b;\n-  b = tmp;\n+template <class _Tp>\n+inline void swap(_Tp& __a, _Tp& __b) {\n+  _Tp __tmp = __a;\n+  __a = __b;\n+  __b = __tmp;\n }\n \n+//--------------------------------------------------\n+// min and max\n+\n #ifndef __BORLANDC__\n \n #undef min\n #undef max\n \n-template <class T>\n-inline const T& min(const T& a, const T& b) {\n-  return b < a ? b : a;\n+template <class _Tp>\n+inline const _Tp& min(const _Tp& __a, const _Tp& __b) {\n+  return __b < __a ? __b : __a;\n }\n \n-template <class T>\n-inline const T& max(const T& a, const T& b) {\n-  return  a < b ? b : a;\n+template <class _Tp>\n+inline const _Tp& max(const _Tp& __a, const _Tp& __b) {\n+  return  __a < __b ? __b : __a;\n }\n \n #endif /* __BORLANDC__ */\n \n-template <class T, class Compare>\n-inline const T& min(const T& a, const T& b, Compare comp) {\n-  return comp(b, a) ? b : a;\n+template <class _Tp, class _Compare>\n+inline const _Tp& min(const _Tp& __a, const _Tp& __b, _Compare __comp) {\n+  return __comp(__b, __a) ? __b : __a;\n }\n \n-template <class T, class Compare>\n-inline const T& max(const T& a, const T& b, Compare comp) {\n-  return comp(a, b) ? b : a;\n+template <class _Tp, class _Compare>\n+inline const _Tp& max(const _Tp& __a, const _Tp& __b, _Compare __comp) {\n+  return __comp(__a, __b) ? __b : __a;\n }\n \n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator __copy(InputIterator first, InputIterator last,\n-                             OutputIterator result, input_iterator_tag)\n-{\n-  for ( ; first != last; ++result, ++first)\n-    *result = *first;\n-  return result;\n-}\n+//--------------------------------------------------\n+// copy\n \n-template <class RandomAccessIterator, class OutputIterator, class Distance>\n-inline OutputIterator\n-__copy_d(RandomAccessIterator first, RandomAccessIterator last,\n-         OutputIterator result, Distance*)\n-{\n-  for (Distance n = last - first; n > 0; --n, ++result, ++first) \n-    *result = *first;\n-  return result;\n-}\n+// All of these auxiliary functions serve two purposes.  (1) Replace\n+// calls to copy with memmove whenever possible.  (Memmove, not memcpy,\n+// because the input and output ranges are permitted to overlap.)\n+// (2) If we're using random access iterators, then write the loop as\n+// a for loop with an explicit count.  The auxiliary class __copy_dispatch\n+// is a workaround for compilers that don't support partial ordering of\n+// function templates.\n \n-template <class RandomAccessIterator, class OutputIterator>\n-inline OutputIterator \n-__copy(RandomAccessIterator first, RandomAccessIterator last,\n-       OutputIterator result, random_access_iterator_tag)\n+template <class _InputIter, class _OutputIter, class _Distance>\n+inline _OutputIter __copy(_InputIter __first, _InputIter __last,\n+                          _OutputIter __result,\n+                          input_iterator_tag, _Distance*)\n {\n-  return __copy_d(first, last, result, distance_type(first));\n+  for ( ; __first != __last; ++__result, ++__first)\n+    *__result = *__first;\n+  return __result;\n }\n \n-template <class InputIterator, class OutputIterator>\n-struct __copy_dispatch\n+template <class _RandomAccessIter, class _OutputIter, class _Distance>\n+inline _OutputIter\n+__copy(_RandomAccessIter __first, _RandomAccessIter __last,\n+       _OutputIter __result, random_access_iterator_tag, _Distance*)\n {\n-  OutputIterator operator()(InputIterator first, InputIterator last,\n-                            OutputIterator result) {\n-    return __copy(first, last, result, iterator_category(first));\n+  for (_Distance __n = __last - __first; __n > 0; --__n) {\n+    *__result = *__first;\n+    ++__first;\n+    ++__result;\n   }\n-};\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n-\n-template <class T>\n-inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {\n-  memmove(result, first, sizeof(T) * (last - first));\n-  return result + (last - first);\n+  return __result;\n }\n \n-template <class T>\n-inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {\n-  return __copy_d(first, last, result, (ptrdiff_t*) 0);\n+template <class _Tp>\n+inline _Tp*\n+__copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n+  memmove(__result, __first, sizeof(_Tp) * (__last - __first));\n+  return __result + (__last - __first);\n }\n \n-template <class T>\n-struct __copy_dispatch<T*, T*>\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n+\n+template <class _InputIter, class _OutputIter, class _BoolType>\n+struct __copy_dispatch {\n+  static _OutputIter copy(_InputIter __first, _InputIter __last,\n+                          _OutputIter __result) {\n+    typedef typename iterator_traits<_InputIter>::iterator_category _Category;\n+    typedef typename iterator_traits<_InputIter>::difference_type _Distance;\n+    return __copy(__first, __last, __result, _Category(), (_Distance*) 0);\n+  }\n+};\n+\n+template <class _Tp>\n+struct __copy_dispatch<_Tp*, _Tp*, __true_type>\n {\n-  T* operator()(T* first, T* last, T* result) {\n-    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n-    return __copy_t(first, last, result, t());\n+  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n+    return __copy_trivial(__first, __last, __result);\n   }\n };\n \n-template <class T>\n-struct __copy_dispatch<const T*, T*>\n+template <class _Tp>\n+struct __copy_dispatch<const _Tp*, _Tp*, __true_type>\n {\n-  T* operator()(const T* first, const T* last, T* result) {\n-    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n-    return __copy_t(first, last, result, t());\n+  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n+    return __copy_trivial(__first, __last, __result);\n   }\n };\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+template <class _InputIter, class _OutputIter>\n+inline _OutputIter copy(_InputIter __first, _InputIter __last,\n+                        _OutputIter __result) {\n+  typedef typename iterator_traits<_InputIter>::value_type _Tp;\n+  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator\n+          _Trivial;\n+  return __copy_dispatch<_InputIter, _OutputIter, _Trivial>\n+    ::copy(__first, __last, __result);\n+}\n+\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator copy(InputIterator first, InputIterator last,\n-                           OutputIterator result)\n+template <class _InputIter, class _OutputIter>\n+inline _OutputIter copy(_InputIter __first, _InputIter __last,\n+                        _OutputIter __result)\n {\n-  return __copy_dispatch<InputIterator,OutputIterator>()(first, last, result);\n+  return __copy(__first, __last, __result,\n+                __ITERATOR_CATEGORY(__first),\n+                __DISTANCE_TYPE(__first));\n }\n \n-inline char* copy(const char* first, const char* last, char* result) {\n-  memmove(result, first, last - first);\n-  return result + (last - first);\n+inline char* copy(const char* __first, const char* __last, char* __result) {\n+  memmove(__result, __first, __last - __first);\n+  return __result + (__last - __first);\n }\n \n-inline wchar_t* copy(const wchar_t* first, const wchar_t* last,\n-                     wchar_t* result) {\n-  memmove(result, first, sizeof(wchar_t) * (last - first));\n-  return result + (last - first);\n+inline wchar_t* copy(const wchar_t* __first, const wchar_t* __last,\n+                     wchar_t* __result) {\n+  memmove(__result, __first, sizeof(wchar_t) * (__last - __first));\n+  return __result + (__last - __first);\n }\n \n-template <class BidirectionalIterator1, class BidirectionalIterator2>\n-inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, \n-                                              BidirectionalIterator1 last, \n-                                              BidirectionalIterator2 result) {\n-  while (first != last) *--result = *--last;\n-  return result;\n-}\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n+//--------------------------------------------------\n+// copy_backward\n \n-template <class BidirectionalIterator1, class BidirectionalIterator2>\n-struct __copy_backward_dispatch\n+template <class _BidirectionalIter1, class _BidirectionalIter2, \n+          class _Distance>\n+inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first, \n+                                           _BidirectionalIter1 __last, \n+                                           _BidirectionalIter2 __result,\n+                                           bidirectional_iterator_tag,\n+                                           _Distance*)\n {\n-  BidirectionalIterator2 operator()(BidirectionalIterator1 first, \n-                                    BidirectionalIterator1 last, \n-                                    BidirectionalIterator2 result) {\n-    return __copy_backward(first, last, result);\n-  }\n-};\n+  while (__first != __last)\n+    *--__result = *--__last;\n+  return __result;\n+}\n+\n+template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>\n+inline _BidirectionalIter __copy_backward(_RandomAccessIter __first, \n+                                          _RandomAccessIter __last, \n+                                          _BidirectionalIter __result,\n+                                          random_access_iterator_tag,\n+                                          _Distance*)\n+{\n+  for (_Distance __n = __last - __first; __n > 0; --__n)\n+    *--__result = *--__last;\n+  return __result;\n+}\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n \n-template <class T>\n-inline T* __copy_backward_t(const T* first, const T* last, T* result,\n-                            __true_type) {\n-  const ptrdiff_t N = last - first;\n-  memmove(result - N, first, sizeof(T) * N);\n-  return result - N;\n-}\n+// This dispatch class is a workaround for compilers that do not \n+// have partial ordering of function templates.  All we're doing is\n+// creating a specialization so that we can turn a call to copy_backward\n+// into a memmove whenever possible.\n \n-template <class T>\n-inline T* __copy_backward_t(const T* first, const T* last, T* result,\n-                            __false_type) {\n-  return __copy_backward(first, last, result);\n-}\n+template <class _BidirectionalIter1, class _BidirectionalIter2,\n+          class _BoolType>\n+struct __copy_backward_dispatch\n+{\n+  typedef typename iterator_traits<_BidirectionalIter1>::iterator_category \n+          _Cat;\n+  typedef typename iterator_traits<_BidirectionalIter1>::difference_type\n+          _Distance;\n+\n+  static _BidirectionalIter2 copy(_BidirectionalIter1 __first, \n+                                  _BidirectionalIter1 __last, \n+                                  _BidirectionalIter2 __result) {\n+    return __copy_backward(__first, __last, __result, _Cat(), (_Distance*) 0);\n+  }\n+};\n \n-template <class T>\n-struct __copy_backward_dispatch<T*, T*>\n+template <class _Tp>\n+struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n {\n-  T* operator()(T* first, T* last, T* result) {\n-    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n-    return __copy_backward_t(first, last, result, t());\n+  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n+    const ptrdiff_t _Num = __last - __first;\n+    memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n+    return __result - _Num;\n   }\n };\n \n-template <class T>\n-struct __copy_backward_dispatch<const T*, T*>\n+template <class _Tp>\n+struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>\n {\n-  T* operator()(const T* first, const T* last, T* result) {\n-    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n-    return __copy_backward_t(first, last, result, t());\n+  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n+    return  __copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n+      ::copy(__first, __last, __result);\n   }\n };\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+template <class _BI1, class _BI2>\n+inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {\n+  typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>\n+                        ::has_trivial_assignment_operator\n+          _Trivial;\n+  return __copy_backward_dispatch<_BI1, _BI2, _Trivial>\n+              ::copy(__first, __last, __result);\n+}\n+\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class BidirectionalIterator1, class BidirectionalIterator2>\n-inline BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, \n-                                            BidirectionalIterator1 last, \n-                                            BidirectionalIterator2 result) {\n-  return __copy_backward_dispatch<BidirectionalIterator1, \n-                                  BidirectionalIterator2>()(first, last, \n-                                                            result);\n+template <class _BI1, class _BI2>\n+inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {\n+  return __copy_backward(__first, __last, __result,\n+                         __ITERATOR_CATEGORY(__first),\n+                         __DISTANCE_TYPE(__first));\n }\n \n-template <class InputIterator, class Size, class OutputIterator>\n-pair<InputIterator, OutputIterator> __copy_n(InputIterator first, Size count,\n-                                             OutputIterator result,\n-                                             input_iterator_tag) {\n-  for ( ; count > 0; --count, ++first, ++result)\n-    *result = *first;\n-  return pair<InputIterator, OutputIterator>(first, result);\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+//--------------------------------------------------\n+// copy_n (not part of the C++ standard)\n+\n+template <class _InputIter, class _Size, class _OutputIter>\n+pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,\n+                                       _OutputIter __result,\n+                                       input_iterator_tag) {\n+  for ( ; __count > 0; --__count) {\n+    *__result = *__first;\n+    ++__first;\n+    ++__result;\n+  }\n+  return pair<_InputIter, _OutputIter>(__first, __result);\n }\n \n-template <class RandomAccessIterator, class Size, class OutputIterator>\n-inline pair<RandomAccessIterator, OutputIterator>\n-__copy_n(RandomAccessIterator first, Size count,\n-         OutputIterator result,\n+template <class _RAIter, class _Size, class _OutputIter>\n+inline pair<_RAIter, _OutputIter>\n+__copy_n(_RAIter __first, _Size __count,\n+         _OutputIter __result,\n          random_access_iterator_tag) {\n-  RandomAccessIterator last = first + count;\n-  return pair<RandomAccessIterator, OutputIterator>(last,\n-                                                    copy(first, last, result));\n+  _RAIter __last = __first + __count;\n+  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));\n+}\n+\n+template <class _InputIter, class _Size, class _OutputIter>\n+inline pair<_InputIter, _OutputIter>\n+__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {\n+  return __copy_n(__first, __count, __result,\n+                  __ITERATOR_CATEGORY(__first));\n }\n \n-template <class InputIterator, class Size, class OutputIterator>\n-inline pair<InputIterator, OutputIterator>\n-copy_n(InputIterator first, Size count,\n-       OutputIterator result) {\n-  return __copy_n(first, count, result, iterator_category(first));\n+template <class _InputIter, class _Size, class _OutputIter>\n+inline pair<_InputIter, _OutputIter>\n+copy_n(_InputIter __first, _Size __count, _OutputIter __result) {\n+  return __copy_n(__first, __count, __result);\n }\n \n-template <class ForwardIterator, class T>\n-void fill(ForwardIterator first, ForwardIterator last, const T& value) {\n-  for ( ; first != last; ++first)\n-    *first = value;\n+//--------------------------------------------------\n+// fill and fill_n\n+\n+\n+template <class _ForwardIter, class _Tp>\n+void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value) {\n+  for ( ; __first != __last; ++__first)\n+    *__first = __value;\n }\n \n-template <class OutputIterator, class Size, class T>\n-OutputIterator fill_n(OutputIterator first, Size n, const T& value) {\n-  for ( ; n > 0; --n, ++first)\n-    *first = value;\n-  return first;\n+template <class _OutputIter, class _Size, class _Tp>\n+_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __value) {\n+  for ( ; __n > 0; --__n, ++__first)\n+    *__first = __value;\n+  return __first;\n }\n \n-template <class InputIterator1, class InputIterator2>\n-pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,\n-\t\t\t\t\t      InputIterator1 last1,\n-\t\t\t\t\t      InputIterator2 first2) {\n-  while (first1 != last1 && *first1 == *first2) {\n-    ++first1;\n-    ++first2;\n+//--------------------------------------------------\n+// equal and mismatch\n+\n+template <class _InputIter1, class _InputIter2>\n+pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n+                                        _InputIter1 __last1,\n+                                        _InputIter2 __first2) {\n+  while (__first1 != __last1 && *__first1 == *__first2) {\n+    ++__first1;\n+    ++__first2;\n   }\n-  return pair<InputIterator1, InputIterator2>(first1, first2);\n+  return pair<_InputIter1, _InputIter2>(__first1, __first2);\n }\n \n-template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n-pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,\n-\t\t\t\t\t      InputIterator1 last1,\n-\t\t\t\t\t      InputIterator2 first2,\n-\t\t\t\t\t      BinaryPredicate binary_pred) {\n-  while (first1 != last1 && binary_pred(*first1, *first2)) {\n-    ++first1;\n-    ++first2;\n+template <class _InputIter1, class _InputIter2, class _BinaryPredicate>\n+pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n+                                        _InputIter1 __last1,\n+                                        _InputIter2 __first2,\n+                                        _BinaryPredicate __binary_pred) {\n+  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {\n+    ++__first1;\n+    ++__first2;\n   }\n-  return pair<InputIterator1, InputIterator2>(first1, first2);\n+  return pair<_InputIter1, _InputIter2>(__first1, __first2);\n }\n \n-template <class InputIterator1, class InputIterator2>\n-inline bool equal(InputIterator1 first1, InputIterator1 last1,\n-\t\t  InputIterator2 first2) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    if (*first1 != *first2)\n+template <class _InputIter1, class _InputIter2>\n+inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n+                  _InputIter2 __first2) {\n+  for ( ; __first1 != __last1; ++__first1, ++__first2)\n+    if (*__first1 != *__first2)\n       return false;\n   return true;\n }\n \n-template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n-inline bool equal(InputIterator1 first1, InputIterator1 last1,\n-\t\t  InputIterator2 first2, BinaryPredicate binary_pred) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    if (!binary_pred(*first1, *first2))\n+template <class _InputIter1, class _InputIter2, class _BinaryPredicate>\n+inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n+                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {\n+  for ( ; __first1 != __last1; ++__first1, ++__first2)\n+    if (!__binary_pred(*__first1, *__first2))\n       return false;\n   return true;\n }\n \n-template <class InputIterator1, class InputIterator2>\n-bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n-\t\t\t     InputIterator2 first2, InputIterator2 last2) {\n-  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {\n-    if (*first1 < *first2)\n+//--------------------------------------------------\n+// lexicographical_compare and lexicographical_compare_3way.\n+// (the latter is not part of the C++ standard.)\n+\n+template <class _InputIter1, class _InputIter2>\n+bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n+                             _InputIter2 __first2, _InputIter2 __last2) {\n+  for ( ; __first1 != __last1 && __first2 != __last2\n+        ; ++__first1, ++__first2) {\n+    if (*__first1 < *__first2)\n       return true;\n-    if (*first2 < *first1)\n+    if (*__first2 < *__first1)\n       return false;\n   }\n-  return first1 == last1 && first2 != last2;\n+  return __first1 == __last1 && __first2 != __last2;\n }\n \n-template <class InputIterator1, class InputIterator2, class Compare>\n-bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n-\t\t\t     InputIterator2 first2, InputIterator2 last2,\n-\t\t\t     Compare comp) {\n-  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {\n-    if (comp(*first1, *first2))\n+template <class _InputIter1, class _InputIter2, class _Compare>\n+bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n+                             _InputIter2 __first2, _InputIter2 __last2,\n+                             _Compare __comp) {\n+  for ( ; __first1 != __last1 && __first2 != __last2\n+        ; ++__first1, ++__first2) {\n+    if (__comp(*__first1, *__first2))\n       return true;\n-    if (comp(*first2, *first1))\n+    if (__comp(*__first2, *__first1))\n       return false;\n   }\n-  return first1 == last1 && first2 != last2;\n+  return __first1 == __last1 && __first2 != __last2;\n }\n \n inline bool \n-lexicographical_compare(const unsigned char* first1,\n-                        const unsigned char* last1,\n-                        const unsigned char* first2,\n-                        const unsigned char* last2)\n+lexicographical_compare(const unsigned char* __first1,\n+                        const unsigned char* __last1,\n+                        const unsigned char* __first2,\n+                        const unsigned char* __last2)\n {\n-  const size_t len1 = last1 - first1;\n-  const size_t len2 = last2 - first2;\n-  const int result = memcmp(first1, first2, min(len1, len2));\n-  return result != 0 ? result < 0 : len1 < len2;\n+  const size_t __len1 = __last1 - __first1;\n+  const size_t __len2 = __last2 - __first2;\n+  const int __result = memcmp(__first1, __first2, min(__len1, __len2));\n+  return __result != 0 ? __result < 0 : __len1 < __len2;\n }\n \n-inline bool lexicographical_compare(const char* first1, const char* last1,\n-                                    const char* first2, const char* last2)\n+inline bool lexicographical_compare(const char* __first1, const char* __last1,\n+                                    const char* __first2, const char* __last2)\n {\n #if CHAR_MAX == SCHAR_MAX\n-  return lexicographical_compare((const signed char*) first1,\n-                                 (const signed char*) last1,\n-                                 (const signed char*) first2,\n-                                 (const signed char*) last2);\n-#else\n-  return lexicographical_compare((const unsigned char*) first1,\n-                                 (const unsigned char*) last1,\n-                                 (const unsigned char*) first2,\n-                                 (const unsigned char*) last2);\n-#endif\n-}\n-\n-template <class InputIterator1, class InputIterator2>\n-int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,\n-                                 InputIterator2 first2, InputIterator2 last2)\n+  return lexicographical_compare((const signed char*) __first1,\n+                                 (const signed char*) __last1,\n+                                 (const signed char*) __first2,\n+                                 (const signed char*) __last2);\n+#else /* CHAR_MAX == SCHAR_MAX */\n+  return lexicographical_compare((const unsigned char*) __first1,\n+                                 (const unsigned char*) __last1,\n+                                 (const unsigned char*) __first2,\n+                                 (const unsigned char*) __last2);\n+#endif /* CHAR_MAX == SCHAR_MAX */\n+}\n+\n+template <class _InputIter1, class _InputIter2>\n+int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n+                                   _InputIter2 __first2, _InputIter2 __last2)\n {\n-  while (first1 != last1 && first2 != last2) {\n-    if (*first1 < *first2) return -1;\n-    if (*first2 < *first1) return 1;\n-    ++first1; ++first2;\n+  while (__first1 != __last1 && __first2 != __last2) {\n+    if (*__first1 < *__first2)\n+      return -1;\n+    if (*__first2 < *__first1)\n+      return 1;\n+    ++__first1;\n+    ++__first2;\n+  }\n+  if (__first2 == __last2) {\n+    return !(__first1 == __last1);\n   }\n-  if (first2 == last2) {\n-    return !(first1 == last1);\n-  } else {\n+  else {\n     return -1;\n   }\n }\n \n inline int\n-lexicographical_compare_3way(const unsigned char* first1,\n-                             const unsigned char* last1,\n-                             const unsigned char* first2,\n-                             const unsigned char* last2)\n+__lexicographical_compare_3way(const unsigned char* __first1,\n+                               const unsigned char* __last1,\n+                               const unsigned char* __first2,\n+                               const unsigned char* __last2)\n {\n-  const ptrdiff_t len1 = last1 - first1;\n-  const ptrdiff_t len2 = last2 - first2;\n-  const int result = memcmp(first1, first2, min(len1, len2));\n-  return result != 0 ? result : (len1 == len2 ? 0 : (len1 < len2 ? -1 : 1));\n+  const ptrdiff_t __len1 = __last1 - __first1;\n+  const ptrdiff_t __len2 = __last2 - __first2;\n+  const int __result = memcmp(__first1, __first2, min(__len1, __len2));\n+  return __result != 0 ? __result \n+                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));\n }\n \n-inline int lexicographical_compare_3way(const char* first1, const char* last1,\n-                                        const char* first2, const char* last2)\n+inline int \n+__lexicographical_compare_3way(const char* __first1, const char* __last1,\n+                               const char* __first2, const char* __last2)\n {\n #if CHAR_MAX == SCHAR_MAX\n-  return lexicographical_compare_3way(\n-\t\t\t\t(const signed char*) first1,\n-                                (const signed char*) last1,\n-                                (const signed char*) first2,\n-                                (const signed char*) last2);\n+  return __lexicographical_compare_3way(\n+                                (const signed char*) __first1,\n+                                (const signed char*) __last1,\n+                                (const signed char*) __first2,\n+                                (const signed char*) __last2);\n #else\n-  return lexicographical_compare_3way((const unsigned char*) first1,\n-                                      (const unsigned char*) last1,\n-                                      (const unsigned char*) first2,\n-                                      (const unsigned char*) last2);\n+  return __lexicographical_compare_3way((const unsigned char*) __first1,\n+                                        (const unsigned char*) __last1,\n+                                        (const unsigned char*) __first2,\n+                                        (const unsigned char*) __last2);\n #endif\n }\n \n+template <class _InputIter1, class _InputIter2>\n+int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n+                                 _InputIter2 __first2, _InputIter2 __last2)\n+{\n+  return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);\n+}\n+\n __STL_END_NAMESPACE\n \n #endif /* __SGI_STL_INTERNAL_ALGOBASE_H */"}, {"sha": "3a773b4bbc0c32fa33967e0dddf23591628ad562", "filename": "libstdc++/stl/stl_alloc.h", "status": "modified", "additions": 612, "deletions": 276, "changes": 888, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_alloc.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -40,15 +40,12 @@\n \n #if 0\n #   include <new>\n-#   define __THROW_BAD_ALLOC throw bad_alloc\n+#   define __THROW_BAD_ALLOC throw bad_alloc()\n #elif !defined(__THROW_BAD_ALLOC)\n #   include <iostream.h>\n #   define __THROW_BAD_ALLOC cerr << \"out of memory\" << endl; exit(1)\n #endif\n \n-#ifndef __ALLOC\n-#   define __ALLOC alloc\n-#endif\n #ifdef __STL_WIN32THREADS\n #   include <windows.h>\n #endif\n@@ -72,19 +69,19 @@\n     // lock.   Performance may not be adequate.\n #   include <pthread.h>\n #   define __NODE_ALLOCATOR_LOCK \\\n-        if (threads) pthread_mutex_lock(&__node_allocator_lock)\n+        if (threads) pthread_mutex_lock(&_S_node_allocator_lock)\n #   define __NODE_ALLOCATOR_UNLOCK \\\n-        if (threads) pthread_mutex_unlock(&__node_allocator_lock)\n+        if (threads) pthread_mutex_unlock(&_S_node_allocator_lock)\n #   define __NODE_ALLOCATOR_THREADS true\n #   define __VOLATILE volatile  // Needed at -O3 on SGI\n # endif\n # ifdef __STL_WIN32THREADS\n     // The lock needs to be initialized by constructing an allocator\n     // objects of the right type.  We do that here explicitly for alloc.\n #   define __NODE_ALLOCATOR_LOCK \\\n-        EnterCriticalSection(&__node_allocator_lock)\n+        EnterCriticalSection(&_S_node_allocator_lock)\n #   define __NODE_ALLOCATOR_UNLOCK \\\n-        LeaveCriticalSection(&__node_allocator_lock)\n+        LeaveCriticalSection(&_S_node_allocator_lock)\n #   define __NODE_ALLOCATOR_THREADS true\n #   define __VOLATILE volatile  // may not be needed\n # endif /* WIN32THREADS */\n@@ -100,9 +97,9 @@\n \t// would be cleaner but fails with certain levels of standard\n \t// conformance.\n #   define __NODE_ALLOCATOR_LOCK if (threads && __us_rsthread_malloc) \\\n-                { __lock(&__node_allocator_lock); }\n+                { _S_lock(&_S_node_allocator_lock); }\n #   define __NODE_ALLOCATOR_UNLOCK if (threads && __us_rsthread_malloc) \\\n-                { __unlock(&__node_allocator_lock); }\n+                { _S_unlock(&_S_node_allocator_lock); }\n #   define __NODE_ALLOCATOR_THREADS true\n #   define __VOLATILE volatile  // Needed at -O3 on SGI\n # endif\n@@ -131,142 +128,141 @@ __STL_BEGIN_NAMESPACE\n # endif\n #endif\n \n-template <int inst>\n+template <int __inst>\n class __malloc_alloc_template {\n \n private:\n \n-static void *oom_malloc(size_t);\n-\n-static void *oom_realloc(void *, size_t);\n+  static void* _S_oom_malloc(size_t);\n+  static void* _S_oom_realloc(void*, size_t);\n \n #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-    static void (* __malloc_alloc_oom_handler)();\n+  static void (* __malloc_alloc_oom_handler)();\n #endif\n \n public:\n \n-static void * allocate(size_t n)\n-{\n-    void *result = malloc(n);\n-    if (0 == result) result = oom_malloc(n);\n-    return result;\n-}\n+  static void* allocate(size_t __n)\n+  {\n+    void* __result = malloc(__n);\n+    if (0 == __result) __result = _S_oom_malloc(__n);\n+    return __result;\n+  }\n \n-static void deallocate(void *p, size_t /* n */)\n-{\n-    free(p);\n-}\n+  static void deallocate(void* __p, size_t /* __n */)\n+  {\n+    free(__p);\n+  }\n \n-static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)\n-{\n-    void * result = realloc(p, new_sz);\n-    if (0 == result) result = oom_realloc(p, new_sz);\n-    return result;\n-}\n+  static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)\n+  {\n+    void* __result = realloc(__p, __new_sz);\n+    if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);\n+    return __result;\n+  }\n \n-static void (* set_malloc_handler(void (*f)()))()\n-{\n-    void (* old)() = __malloc_alloc_oom_handler;\n-    __malloc_alloc_oom_handler = f;\n-    return(old);\n-}\n+  static void (* __set_malloc_handler(void (*__f)()))()\n+  {\n+    void (* __old)() = __malloc_alloc_oom_handler;\n+    __malloc_alloc_oom_handler = __f;\n+    return(__old);\n+  }\n \n };\n \n // malloc_alloc out-of-memory handling\n \n #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-template <int inst>\n-void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;\n+template <int __inst>\n+void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;\n #endif\n \n-template <int inst>\n-void * __malloc_alloc_template<inst>::oom_malloc(size_t n)\n+template <int __inst>\n+void*\n+__malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)\n {\n-    void (* my_malloc_handler)();\n-    void *result;\n+    void (* __my_malloc_handler)();\n+    void* __result;\n \n     for (;;) {\n-        my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n-        (*my_malloc_handler)();\n-        result = malloc(n);\n-        if (result) return(result);\n+        __my_malloc_handler = __malloc_alloc_oom_handler;\n+        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }\n+        (*__my_malloc_handler)();\n+        __result = malloc(__n);\n+        if (__result) return(__result);\n     }\n }\n \n-template <int inst>\n-void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)\n+template <int __inst>\n+void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)\n {\n-    void (* my_malloc_handler)();\n-    void *result;\n+    void (* __my_malloc_handler)();\n+    void* __result;\n \n     for (;;) {\n-        my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n-        (*my_malloc_handler)();\n-        result = realloc(p, n);\n-        if (result) return(result);\n+        __my_malloc_handler = __malloc_alloc_oom_handler;\n+        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }\n+        (*__my_malloc_handler)();\n+        __result = realloc(__p, __n);\n+        if (__result) return(__result);\n     }\n }\n \n typedef __malloc_alloc_template<0> malloc_alloc;\n \n-template<class T, class Alloc>\n+template<class _Tp, class _Alloc>\n class simple_alloc {\n \n public:\n-    static T *allocate(size_t n)\n-                { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); }\n-    static T *allocate(void)\n-                { return (T*) Alloc::allocate(sizeof (T)); }\n-    static void deallocate(T *p, size_t n)\n-                { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); }\n-    static void deallocate(T *p)\n-                { Alloc::deallocate(p, sizeof (T)); }\n+    static _Tp* allocate(size_t __n)\n+      { return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); }\n+    static _Tp* allocate(void)\n+      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }\n+    static void deallocate(_Tp* __p, size_t __n)\n+      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }\n+    static void deallocate(_Tp* __p)\n+      { _Alloc::deallocate(__p, sizeof (_Tp)); }\n };\n \n // Allocator adaptor to check size arguments for debugging.\n // Reports errors using assert.  Checking can be disabled with\n // NDEBUG, but it's far better to just use the underlying allocator\n // instead when no checking is desired.\n // There is some evidence that this can confuse Purify.\n-template <class Alloc>\n+template <class _Alloc>\n class debug_alloc {\n \n private:\n \n-enum {extra = 8};       // Size of space used to store size.  Note\n+  enum {_S_extra = 8};  // Size of space used to store size.  Note\n                         // that this must be large enough to preserve\n                         // alignment.\n \n public:\n \n-static void * allocate(size_t n)\n-{\n-    char *result = (char *)Alloc::allocate(n + extra);\n-    *(size_t *)result = n;\n-    return result + extra;\n-}\n-\n-static void deallocate(void *p, size_t n)\n-{\n-    char * real_p = (char *)p - extra;\n-    assert(*(size_t *)real_p == n);\n-    Alloc::deallocate(real_p, n + extra);\n-}\n+  static void* allocate(size_t __n)\n+  {\n+    char* __result = (char*)_Alloc::allocate(__n + _S_extra);\n+    *(size_t*)__result = __n;\n+    return __result + _S_extra;\n+  }\n \n-static void * reallocate(void *p, size_t old_sz, size_t new_sz)\n-{\n-    char * real_p = (char *)p - extra;\n-    assert(*(size_t *)real_p == old_sz);\n-    char * result = (char *)\n-                  Alloc::reallocate(real_p, old_sz + extra, new_sz + extra);\n-    *(size_t *)result = new_sz;\n-    return result + extra;\n-}\n+  static void deallocate(void* __p, size_t __n)\n+  {\n+    char* __real_p = (char*)__p - _S_extra;\n+    assert(*(size_t*)__real_p == __n);\n+    _Alloc::deallocate(__real_p, __n + _S_extra);\n+  }\n \n+  static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz)\n+  {\n+    char* __real_p = (char*)__p - _S_extra;\n+    assert(*(size_t*)__real_p == __old_sz);\n+    char* __result = (char*)\n+      _Alloc::reallocate(__real_p, __old_sz + _S_extra, __new_sz + _S_extra);\n+    *(size_t*)__result = __new_sz;\n+    return __result + _S_extra;\n+  }\n \n };\n \n@@ -286,10 +282,10 @@ typedef malloc_alloc single_client_alloc;\n // DISAPPEAR in the future.  Clients should just use alloc for now.\n //\n // Important implementation properties:\n-// 1. If the client request an object of size > __MAX_BYTES, the resulting\n+// 1. If the client request an object of size > _MAX_BYTES, the resulting\n //    object will be obtained directly from malloc.\n // 2. In all other cases, we allocate an object of size exactly\n-//    ROUND_UP(requested_size).  Thus the client has enough size\n+//    _S_round_up(requested_size).  Thus the client has enough size\n //    information that we can return the object to the proper free list\n //    without permanently losing part of the object.\n //\n@@ -305,9 +301,9 @@ typedef malloc_alloc single_client_alloc;\n // different types, limiting the utility of this approach.\n #ifdef __SUNPRO_CC\n // breaks if we make these template class members:\n-  enum {__ALIGN = 8};\n-  enum {__MAX_BYTES = 128};\n-  enum {__NFREELISTS = __MAX_BYTES/__ALIGN};\n+  enum {_ALIGN = 8};\n+  enum {_MAX_BYTES = 128};\n+  enum {_NFREELISTS = _MAX_BYTES/_ALIGN};\n #endif\n \n template <bool threads, int inst>\n@@ -317,123 +313,124 @@ class __default_alloc_template {\n   // Really we should use static const int x = N\n   // instead of enum { x = N }, but few compilers accept the former.\n # ifndef __SUNPRO_CC\n-    enum {__ALIGN = 8};\n-    enum {__MAX_BYTES = 128};\n-    enum {__NFREELISTS = __MAX_BYTES/__ALIGN};\n+    enum {_ALIGN = 8};\n+    enum {_MAX_BYTES = 128};\n+    enum {_NFREELISTS = _MAX_BYTES/_ALIGN};\n # endif\n-  static size_t ROUND_UP(size_t bytes) {\n-        return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1));\n-  }\n+  static size_t\n+  _S_round_up(size_t __bytes) \n+    { return (((__bytes) + _ALIGN-1) & ~(_ALIGN - 1)); }\n+\n __PRIVATE:\n-  union obj {\n-        union obj * free_list_link;\n-        char client_data[1];    /* The client sees this.        */\n+  union _Obj {\n+        union _Obj* _M_free_list_link;\n+        char _M_client_data[1];    /* The client sees this.        */\n   };\n private:\n # ifdef __SUNPRO_CC\n-    static obj * __VOLATILE free_list[]; \n+    static _Obj* __VOLATILE _S_free_list[]; \n         // Specifying a size results in duplicate def for 4.1\n # else\n-    static obj * __VOLATILE free_list[__NFREELISTS]; \n+    static _Obj* __VOLATILE _S_free_list[_NFREELISTS]; \n # endif\n-  static  size_t FREELIST_INDEX(size_t bytes) {\n-        return (((bytes) + __ALIGN-1)/__ALIGN - 1);\n+  static  size_t _S_freelist_index(size_t __bytes) {\n+        return (((__bytes) + _ALIGN-1)/_ALIGN - 1);\n   }\n \n-  // Returns an object of size n, and optionally adds to size n free list.\n-  static void *refill(size_t n);\n+  // Returns an object of size __n, and optionally adds to size __n free list.\n+  static void* _S_refill(size_t __n);\n   // Allocates a chunk for nobjs of size \"size\".  nobjs may be reduced\n   // if it is inconvenient to allocate the requested number.\n-  static char *chunk_alloc(size_t size, int &nobjs);\n+  static char* _S_chunk_alloc(size_t __size, int& __nobjs);\n \n   // Chunk allocation state.\n-  static char *start_free;\n-  static char *end_free;\n-  static size_t heap_size;\n+  static char* _S_start_free;\n+  static char* _S_end_free;\n+  static size_t _S_heap_size;\n \n # ifdef __STL_SGI_THREADS\n-    static volatile unsigned long __node_allocator_lock;\n-    static void __lock(volatile unsigned long *); \n-    static inline void __unlock(volatile unsigned long *);\n+    static volatile unsigned long _S_node_allocator_lock;\n+    static void _S_lock(volatile unsigned long*); \n+    static inline void _S_unlock(volatile unsigned long*);\n # endif\n \n # ifdef __STL_PTHREADS\n-    static pthread_mutex_t __node_allocator_lock;\n+    static pthread_mutex_t _S_node_allocator_lock;\n # endif\n \n # ifdef __STL_WIN32THREADS\n-    static CRITICAL_SECTION __node_allocator_lock;\n-    static bool __node_allocator_lock_initialized;\n+    static CRITICAL_SECTION _S_node_allocator_lock;\n+    static bool _S_node_allocator_lock_initialized;\n \n   public:\n     __default_alloc_template() {\n \t// This assumes the first constructor is called before threads\n \t// are started.\n-        if (!__node_allocator_lock_initialized) {\n-            InitializeCriticalSection(&__node_allocator_lock);\n-            __node_allocator_lock_initialized = true;\n+        if (!_S_node_allocator_lock_initialized) {\n+            InitializeCriticalSection(&_S_node_allocator_lock);\n+            _S_node_allocator_lock_initialized = true;\n         }\n     }\n   private:\n # endif\n \n-    class lock {\n+    class _Lock {\n         public:\n-            lock() { __NODE_ALLOCATOR_LOCK; }\n-            ~lock() { __NODE_ALLOCATOR_UNLOCK; }\n+            _Lock() { __NODE_ALLOCATOR_LOCK; }\n+            ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }\n     };\n-    friend class lock;\n+    friend class _Lock;\n \n public:\n \n-  /* n must be > 0      */\n-  static void * allocate(size_t n)\n+  /* __n must be > 0      */\n+  static void* allocate(size_t __n)\n   {\n-    obj * __VOLATILE * my_free_list;\n-    obj * __RESTRICT result;\n+    _Obj* __VOLATILE* __my_free_list;\n+    _Obj* __RESTRICT __result;\n \n-    if (n > (size_t) __MAX_BYTES) {\n-        return(malloc_alloc::allocate(n));\n+    if (__n > (size_t) _MAX_BYTES) {\n+        return(malloc_alloc::allocate(__n));\n     }\n-    my_free_list = free_list + FREELIST_INDEX(n);\n+    __my_free_list = _S_free_list + _S_freelist_index(__n);\n     // Acquire the lock here with a constructor call.\n     // This ensures that it is released in exit or during stack\n     // unwinding.\n #       ifndef _NOTHREADS\n         /*REFERENCED*/\n-        lock lock_instance;\n+        _Lock __lock_instance;\n #       endif\n-    result = *my_free_list;\n-    if (result == 0) {\n-        void *r = refill(ROUND_UP(n));\n-        return r;\n+    __result = *__my_free_list;\n+    if (__result == 0) {\n+        void* __r = _S_refill(_S_round_up(__n));\n+        return __r;\n     }\n-    *my_free_list = result -> free_list_link;\n-    return (result);\n+    *__my_free_list = __result -> _M_free_list_link;\n+    return (__result);\n   };\n \n-  /* p may not be 0 */\n-  static void deallocate(void *p, size_t n)\n+  /* __p may not be 0 */\n+  static void deallocate(void* __p, size_t __n)\n   {\n-    obj *q = (obj *)p;\n-    obj * __VOLATILE * my_free_list;\n+    _Obj* __q = (_Obj*)__p;\n+    _Obj* __VOLATILE* __my_free_list;\n \n-    if (n > (size_t) __MAX_BYTES) {\n-        malloc_alloc::deallocate(p, n);\n+    if (__n > (size_t) _MAX_BYTES) {\n+        malloc_alloc::deallocate(__p, __n);\n         return;\n     }\n-    my_free_list = free_list + FREELIST_INDEX(n);\n+    __my_free_list = _S_free_list + _S_freelist_index(__n);\n     // acquire lock\n #       ifndef _NOTHREADS\n         /*REFERENCED*/\n-        lock lock_instance;\n+        _Lock __lock_instance;\n #       endif /* _NOTHREADS */\n-    q -> free_list_link = *my_free_list;\n-    *my_free_list = q;\n+    __q -> _M_free_list_link = *__my_free_list;\n+    *__my_free_list = __q;\n     // lock is released here\n   }\n \n-  static void * reallocate(void *p, size_t old_sz, size_t new_sz);\n+  static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz);\n \n } ;\n \n@@ -446,228 +443,246 @@ typedef __default_alloc_template<false, 0> single_client_alloc;\n /* the malloc heap too much.                                            */\n /* We assume that size is properly aligned.                             */\n /* We hold the allocation lock.                                         */\n-template <bool threads, int inst>\n+template <bool __threads, int __inst>\n char*\n-__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)\n+__default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size, \n+                                                            int& __nobjs)\n {\n-    char * result;\n-    size_t total_bytes = size * nobjs;\n-    size_t bytes_left = end_free - start_free;\n-\n-    if (bytes_left >= total_bytes) {\n-        result = start_free;\n-        start_free += total_bytes;\n-        return(result);\n-    } else if (bytes_left >= size) {\n-        nobjs = bytes_left/size;\n-        total_bytes = size * nobjs;\n-        result = start_free;\n-        start_free += total_bytes;\n-        return(result);\n+    char* __result;\n+    size_t __total_bytes = __size * __nobjs;\n+    size_t __bytes_left = _S_end_free - _S_start_free;\n+\n+    if (__bytes_left >= __total_bytes) {\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n+    } else if (__bytes_left >= __size) {\n+        __nobjs = (int)(__bytes_left/__size);\n+        __total_bytes = __size * __nobjs;\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n     } else {\n-        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n+        size_t __bytes_to_get = \n+\t  2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n         // Try to make use of the left-over piece.\n-        if (bytes_left > 0) {\n-            obj * __VOLATILE * my_free_list =\n-                        free_list + FREELIST_INDEX(bytes_left);\n+        if (__bytes_left > 0) {\n+            _Obj* __VOLATILE* __my_free_list =\n+                        _S_free_list + _S_freelist_index(__bytes_left);\n \n-            ((obj *)start_free) -> free_list_link = *my_free_list;\n-            *my_free_list = (obj *)start_free;\n+            ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n+            *__my_free_list = (_Obj*)_S_start_free;\n         }\n-        start_free = (char *)malloc(bytes_to_get);\n-        if (0 == start_free) {\n-            int i;\n-            obj * __VOLATILE * my_free_list, *p;\n+        _S_start_free = (char*)malloc(__bytes_to_get);\n+        if (0 == _S_start_free) {\n+            size_t __i;\n+            _Obj* __VOLATILE* __my_free_list;\n+\t    _Obj* __p;\n             // Try to make do with what we have.  That can't\n             // hurt.  We do not try smaller requests, since that tends\n             // to result in disaster on multi-process machines.\n-            for (i = size; i <= __MAX_BYTES; i += __ALIGN) {\n-                my_free_list = free_list + FREELIST_INDEX(i);\n-                p = *my_free_list;\n-                if (0 != p) {\n-                    *my_free_list = p -> free_list_link;\n-                    start_free = (char *)p;\n-                    end_free = start_free + i;\n-                    return(chunk_alloc(size, nobjs));\n+            for (__i = __size; __i <= _MAX_BYTES; __i += _ALIGN) {\n+                __my_free_list = _S_free_list + _S_freelist_index(__i);\n+                __p = *__my_free_list;\n+                if (0 != __p) {\n+                    *__my_free_list = __p -> _M_free_list_link;\n+                    _S_start_free = (char*)__p;\n+                    _S_end_free = _S_start_free + __i;\n+                    return(_S_chunk_alloc(__size, __nobjs));\n                     // Any leftover piece will eventually make it to the\n                     // right free list.\n                 }\n             }\n-\t    end_free = 0;\t// In case of exception.\n-            start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n+\t    _S_end_free = 0;\t// In case of exception.\n+            _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get);\n             // This should either throw an\n             // exception or remedy the situation.  Thus we assume it\n             // succeeded.\n         }\n-        heap_size += bytes_to_get;\n-        end_free = start_free + bytes_to_get;\n-        return(chunk_alloc(size, nobjs));\n+        _S_heap_size += __bytes_to_get;\n+        _S_end_free = _S_start_free + __bytes_to_get;\n+        return(_S_chunk_alloc(__size, __nobjs));\n     }\n }\n \n \n-/* Returns an object of size n, and optionally adds to size n free list.*/\n-/* We assume that n is properly aligned.                                */\n+/* Returns an object of size __n, and optionally adds to size __n free list.*/\n+/* We assume that __n is properly aligned.                                */\n /* We hold the allocation lock.                                         */\n-template <bool threads, int inst>\n-void* __default_alloc_template<threads, inst>::refill(size_t n)\n+template <bool __threads, int __inst>\n+void*\n+__default_alloc_template<__threads, __inst>::_S_refill(size_t __n)\n {\n-    int nobjs = 20;\n-    char * chunk = chunk_alloc(n, nobjs);\n-    obj * __VOLATILE * my_free_list;\n-    obj * result;\n-    obj * current_obj, * next_obj;\n-    int i;\n+    int __nobjs = 20;\n+    char* __chunk = _S_chunk_alloc(__n, __nobjs);\n+    _Obj* __VOLATILE* __my_free_list;\n+    _Obj* __result;\n+    _Obj* __current_obj;\n+    _Obj* __next_obj;\n+    int __i;\n \n-    if (1 == nobjs) return(chunk);\n-    my_free_list = free_list + FREELIST_INDEX(n);\n+    if (1 == __nobjs) return(__chunk);\n+    __my_free_list = _S_free_list + _S_freelist_index(__n);\n \n     /* Build free list in chunk */\n-      result = (obj *)chunk;\n-      *my_free_list = next_obj = (obj *)(chunk + n);\n-      for (i = 1; ; i++) {\n-        current_obj = next_obj;\n-        next_obj = (obj *)((char *)next_obj + n);\n-        if (nobjs - 1 == i) {\n-            current_obj -> free_list_link = 0;\n+      __result = (_Obj*)__chunk;\n+      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);\n+      for (__i = 1; ; __i++) {\n+        __current_obj = __next_obj;\n+        __next_obj = (_Obj*)((char*)__next_obj + __n);\n+        if (__nobjs - 1 == __i) {\n+            __current_obj -> _M_free_list_link = 0;\n             break;\n         } else {\n-            current_obj -> free_list_link = next_obj;\n+            __current_obj -> _M_free_list_link = __next_obj;\n         }\n       }\n-    return(result);\n+    return(__result);\n }\n \n template <bool threads, int inst>\n void*\n-__default_alloc_template<threads, inst>::reallocate(void *p,\n-                                                    size_t old_sz,\n-                                                    size_t new_sz)\n+__default_alloc_template<threads, inst>::reallocate(void* __p,\n+                                                    size_t __old_sz,\n+                                                    size_t __new_sz)\n {\n-    void * result;\n-    size_t copy_sz;\n+    void* __result;\n+    size_t __copy_sz;\n \n-    if (old_sz > (size_t) __MAX_BYTES && new_sz > (size_t) __MAX_BYTES) {\n-        return(realloc(p, new_sz));\n+    if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES) {\n+        return(realloc(__p, __new_sz));\n     }\n-    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);\n-    result = allocate(new_sz);\n-    copy_sz = new_sz > old_sz? old_sz : new_sz;\n-    memcpy(result, p, copy_sz);\n-    deallocate(p, old_sz);\n-    return(result);\n+    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);\n+    __result = allocate(__new_sz);\n+    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n+    memcpy(__result, __p, __copy_sz);\n+    deallocate(__p, __old_sz);\n+    return(__result);\n }\n \n #ifdef __STL_PTHREADS\n-    template <bool threads, int inst>\n+    template <bool __threads, int __inst>\n     pthread_mutex_t\n-    __default_alloc_template<threads, inst>::__node_allocator_lock\n+    __default_alloc_template<__threads, __inst>::_S_node_allocator_lock\n         = PTHREAD_MUTEX_INITIALIZER;\n #endif\n \n #ifdef __STL_WIN32THREADS\n-    template <bool threads, int inst> CRITICAL_SECTION\n-    __default_alloc_template<threads, inst>::__node_allocator_lock;\n-\n-    template <bool threads, int inst> bool\n-    __default_alloc_template<threads, inst>::__node_allocator_lock_initialized\n+    template <bool __threads, int __inst>\n+    CRITICAL_SECTION\n+    __default_alloc_template<__threads, __inst>::\n+      _S_node_allocator_lock;\n+\n+    template <bool __threads, int __inst>\n+    bool\n+    __default_alloc_template<__threads, __inst>::\n+      _S_node_allocator_lock_initialized\n \t= false;\n #endif\n \n #ifdef __STL_SGI_THREADS\n __STL_END_NAMESPACE\n #include <mutex.h>\n-#include <time.h>\n+#include <time.h>  /* XXX should use <ctime> */\n __STL_BEGIN_NAMESPACE\n // Somewhat generic lock implementations.  We need only test-and-set\n // and some way to sleep.  These should work with both SGI pthreads\n // and sproc threads.  They may be useful on other systems.\n-template <bool threads, int inst>\n+template <bool __threads, int __inst>\n volatile unsigned long\n-__default_alloc_template<threads, inst>::__node_allocator_lock = 0;\n+__default_alloc_template<__threads, __inst>::_S_node_allocator_lock = 0;\n \n #if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) || defined(__GNUC__)\n #   define __test_and_set(l,v) test_and_set(l,v)\n #endif\n \n-template <bool threads, int inst>\n+template <bool __threads, int __inst>\n void \n-__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)\n+__default_alloc_template<__threads, __inst>::\n+  _S_lock(volatile unsigned long* __lock)\n {\n-    const unsigned low_spin_max = 30;  // spin cycles if we suspect uniprocessor\n-    const unsigned high_spin_max = 1000; // spin cycles for multiprocessor\n-    static unsigned spin_max = low_spin_max;\n-    unsigned my_spin_max;\n-    static unsigned last_spins = 0;\n-    unsigned my_last_spins;\n-    static struct timespec ts = {0, 1000};\n-    unsigned junk;\n-#   define __ALLOC_PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk\n-    int i;\n-\n-    if (!__test_and_set((unsigned long *)lock, 1)) {\n+    const unsigned __low_spin_max = 30;  // spins if we suspect uniprocessor\n+    const unsigned __high_spin_max = 1000; // spins for multiprocessor\n+    static unsigned __spin_max = __low_spin_max;\n+    unsigned __my_spin_max;\n+    static unsigned __last_spins = 0;\n+    unsigned __my_last_spins;\n+    unsigned __junk;\n+#   define __ALLOC_PAUSE \\\n+      __junk *= __junk; __junk *= __junk; __junk *= __junk; __junk *= __junk\n+    int __i;\n+\n+    if (!__test_and_set((unsigned long*)__lock, 1)) {\n         return;\n     }\n-    my_spin_max = spin_max;\n-    my_last_spins = last_spins;\n-    for (i = 0; i < my_spin_max; i++) {\n-        if (i < my_last_spins/2 || *lock) {\n+    __my_spin_max = __spin_max;\n+    __my_last_spins = __last_spins;\n+    for (__i = 0; __i < __my_spin_max; __i++) {\n+        if (__i < __my_last_spins/2 || *__lock) {\n             __ALLOC_PAUSE;\n             continue;\n         }\n-        if (!__test_and_set((unsigned long *)lock, 1)) {\n+        if (!__test_and_set((unsigned long*)__lock, 1)) {\n             // got it!\n             // Spinning worked.  Thus we're probably not being scheduled\n             // against the other process with which we were contending.\n             // Thus it makes sense to spin longer the next time.\n-            last_spins = i;\n-            spin_max = high_spin_max;\n+            __last_spins = __i;\n+            __spin_max = __high_spin_max;\n             return;\n         }\n     }\n     // We are probably being scheduled against the other process.  Sleep.\n-    spin_max = low_spin_max;\n-    for (;;) {\n-        if (!__test_and_set((unsigned long *)lock, 1)) {\n+    __spin_max = __low_spin_max;\n+    for (__i = 0 ;; ++__i) {\n+        struct timespec __ts;\n+        int __log_nsec = __i + 6;\n+\n+        if (!__test_and_set((unsigned long *)__lock, 1)) {\n             return;\n         }\n-        nanosleep(&ts, 0);\n+        if (__log_nsec > 27) __log_nsec = 27;\n+\t\t/* Max sleep is 2**27nsec ~ 60msec      */\n+        __ts.tv_sec = 0;\n+        __ts.tv_nsec = 1 << __log_nsec;\n+        nanosleep(&__ts, 0);\n     }\n }\n \n-template <bool threads, int inst>\n+template <bool __threads, int __inst>\n inline void\n-__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)\n+__default_alloc_template<__threads, __inst>::_S_unlock(\n+  volatile unsigned long* __lock)\n {\n #   if defined(__GNUC__) && __mips >= 3\n         asm(\"sync\");\n-        *lock = 0;\n+        *__lock = 0;\n #   elif __mips >= 3 && (defined (_ABIN32) || defined(_ABI64))\n-        __lock_release(lock);\n+        __lock_release(__lock);\n #   else \n-        *lock = 0;\n+        *__lock = 0;\n         // This is not sufficient on many multiprocessors, since\n         // writes to protected variables and the lock may be reordered.\n #   endif\n }\n #endif\n \n-template <bool threads, int inst>\n-char *__default_alloc_template<threads, inst>::start_free = 0;\n+template <bool __threads, int __inst>\n+char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;\n \n-template <bool threads, int inst>\n-char *__default_alloc_template<threads, inst>::end_free = 0;\n+template <bool __threads, int __inst>\n+char* __default_alloc_template<__threads, __inst>::_S_end_free = 0;\n \n-template <bool threads, int inst>\n-size_t __default_alloc_template<threads, inst>::heap_size = 0;\n+template <bool __threads, int __inst>\n+size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;\n \n-template <bool threads, int inst>\n-__default_alloc_template<threads, inst>::obj * __VOLATILE\n-__default_alloc_template<threads, inst> ::free_list[\n+template <bool __threads, int __inst>\n+__default_alloc_template<__threads, __inst>::_Obj* __VOLATILE\n+__default_alloc_template<__threads, __inst> ::_S_free_list[\n # ifdef __SUNPRO_CC\n-    __NFREELISTS\n+    _NFREELISTS\n # else\n-    __default_alloc_template<threads, inst>::__NFREELISTS\n+    __default_alloc_template<__threads, __inst>::_NFREELISTS\n # endif\n ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n // The 16 zeros are necessary to make version 4.1 of the SunPro\n@@ -683,6 +698,327 @@ __default_alloc_template<threads, inst> ::free_list[\n \n #endif /* ! __USE_MALLOC */\n \n+// This implements allocators as specified in the C++ standard.  \n+//\n+// Note that standard-conforming allocators use many language features\n+// that are not yet widely implemented.  In particular, they rely on\n+// member templates, partial specialization, partial ordering of function\n+// templates, the typename keyword, and the use of the template keyword\n+// to refer to a template member of a dependent type.\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+template <class _Tp>\n+class allocator {\n+  typedef alloc _Alloc;          // The underlying allocator.\n+public:\n+  typedef size_t     size_type;\n+  typedef ptrdiff_t  difference_type;\n+  typedef _Tp*       pointer;\n+  typedef const _Tp* const_pointer;\n+  typedef _Tp&       reference;\n+  typedef const _Tp& const_reference;\n+  typedef _Tp        value_type;\n+\n+  template <class _Tp1> struct rebind {\n+    typedef allocator<_Tp1> other;\n+  };\n+\n+  allocator() __STL_NOTHROW {}\n+  allocator(const allocator&) __STL_NOTHROW {}\n+  template <class _Tp1> allocator(const allocator<_Tp1>&) __STL_NOTHROW {}\n+  ~allocator() __STL_NOTHROW {}\n+\n+  pointer address(reference __x) const { return &__x; }\n+  const_pointer address(const_reference __x) const { return &__x; }\n+\n+  // __n is permitted to be 0.  The C++ standard says nothing about what\n+  // the return value is when __n == 0.\n+  _Tp* allocate(size_type __n, const void* = 0) {\n+    return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) \n+                    : 0;\n+  }\n+\n+  // __p is not permitted to be a null pointer.\n+  void deallocate(pointer __p, size_type __n)\n+    { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n+\n+  size_type max_size() const __STL_NOTHROW \n+    { return size_t(-1) / sizeof(_Tp); }\n+\n+  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+  void destroy(pointer __p) { __p->~_Tp(); }\n+};\n+\n+template<>\n+class allocator<void> {\n+  typedef size_t      size_type;\n+  typedef ptrdiff_t   difference_type;\n+  typedef void*       pointer;\n+  typedef const void* const_pointer;\n+  typedef void        value_type;\n+\n+  template <class _Tp1> struct rebind {\n+    typedef allocator<_Tp1> other;\n+  };\n+};\n+\n+\n+template <class _T1, class _T2>\n+inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) \n+{\n+  return true;\n+}\n+\n+template <class _T1, class _T2>\n+inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&)\n+{\n+  return false;\n+}\n+\n+// Allocator adaptor to turn an SGI-style allocator (e.g. alloc, malloc_alloc)\n+// into a standard-conforming allocator.   Note that this adaptor does\n+// *not* assume that all objects of the underlying alloc class are\n+// identical, nor does it assume that all of the underlying alloc's\n+// member functions are static member functions.  Note, also, that \n+// __allocator<_Tp, alloc> is essentially the same thing as allocator<_Tp>.\n+\n+template <class _Tp, class _Alloc>\n+struct __allocator {\n+  _Alloc __underlying_alloc;\n+\n+  typedef size_t    size_type;\n+  typedef ptrdiff_t difference_type;\n+  typedef _Tp*       pointer;\n+  typedef const _Tp* const_pointer;\n+  typedef _Tp&       reference;\n+  typedef const _Tp& const_reference;\n+  typedef _Tp        value_type;\n+\n+  template <class _Tp1> struct rebind {\n+    typedef __allocator<_Tp1, _Alloc> other;\n+  };\n+\n+  __allocator() __STL_NOTHROW {}\n+  __allocator(const __allocator& __a) __STL_NOTHROW\n+    : __underlying_alloc(__a.__underlying_alloc) {}\n+  template <class _Tp1> \n+  __allocator(const __allocator<_Tp1, _Alloc>& __a) __STL_NOTHROW\n+    : __underlying_alloc(__a.__underlying_alloc) {}\n+  ~__allocator() __STL_NOTHROW {}\n+\n+  pointer address(reference __x) const { return &__x; }\n+  const_pointer address(const_reference __x) const { return &__x; }\n+\n+  // __n is permitted to be 0.\n+  _Tp* allocate(size_type __n, const void* = 0) {\n+    return __n != 0 \n+        ? static_cast<_Tp*>(__underlying_alloc.allocate(__n * sizeof(_Tp))) \n+        : 0;\n+  }\n+\n+  // __p is not permitted to be a null pointer.\n+  void deallocate(pointer __p, size_type __n)\n+    { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n+\n+  size_type max_size() const __STL_NOTHROW \n+    { return size_t(-1) / sizeof(_Tp); }\n+\n+  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+  void destroy(pointer __p) { __p->~_Tp(); }\n+};\n+\n+template <class _Alloc>\n+class __allocator<void, _Alloc> {\n+  typedef size_t      size_type;\n+  typedef ptrdiff_t   difference_type;\n+  typedef void*       pointer;\n+  typedef const void* const_pointer;\n+  typedef void        value_type;\n+\n+  template <class _Tp1> struct rebind {\n+    typedef __allocator<_Tp1, _Alloc> other;\n+  };\n+};\n+\n+template <class _Tp, class _Alloc>\n+inline bool operator==(const __allocator<_Tp, _Alloc>& __a1,\n+                       const __allocator<_Tp, _Alloc>& __a2)\n+{\n+  return __a1.__underlying_alloc == __a2.__underlying_alloc;\n+}\n+\n+#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+template <class _Tp, class _Alloc>\n+inline bool operator!=(const __allocator<_Tp, _Alloc>& __a1,\n+                       const __allocator<_Tp, _Alloc>& __a2)\n+{\n+  return __a1.__underlying_alloc != __a2.__underlying_alloc;\n+}\n+#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+\n+// Comparison operators for all of the predifined SGI-style allocators.\n+// This ensures that __allocator<malloc_alloc> (for example) will\n+// work correctly.\n+\n+template <int inst>\n+inline bool operator==(const __malloc_alloc_template<inst>&,\n+                       const __malloc_alloc_template<inst>&)\n+{\n+  return true;\n+}\n+\n+#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+template <int __inst>\n+inline bool operator!=(const __malloc_alloc_template<__inst>&,\n+                       const __malloc_alloc_template<__inst>&)\n+{\n+  return false;\n+}\n+#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+\n+template <bool __threads, int __inst>\n+inline bool operator==(const __default_alloc_template<__threads, __inst>&,\n+                       const __default_alloc_template<__threads, __inst>&)\n+{\n+  return true;\n+}\n+\n+#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+template <bool __threads, int __inst>\n+inline bool operator!=(const __default_alloc_template<__threads, __inst>&,\n+                       const __default_alloc_template<__threads, __inst>&)\n+{\n+  return false;\n+}\n+#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+\n+template <class _Alloc>\n+inline bool operator==(const debug_alloc<_Alloc>&,\n+                       const debug_alloc<_Alloc>&) {\n+  return true;\n+}\n+\n+#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+template <class _Alloc>\n+inline bool operator!=(const debug_alloc<_Alloc>&,\n+                       const debug_alloc<_Alloc>&) {\n+  return false;\n+}\n+#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+\n+// Another allocator adaptor: _Alloc_traits.  This serves two\n+// purposes.  First, make it possible to write containers that can use\n+// either SGI-style allocators or standard-conforming allocator.\n+// Second, provide a mechanism so that containers can query whether or\n+// not the allocator has distinct instances.  If not, the container\n+// can avoid wasting a word of memory to store an empty object.\n+\n+// This adaptor uses partial specialization.  The general case of\n+// _Alloc_traits<_Tp, _Alloc> assumes that _Alloc is a\n+// standard-conforming allocator, possibly with non-equal instances\n+// and non-static members.  (It still behaves correctly even if _Alloc\n+// has static member and if all instances are equal.  Refinements\n+// affect performance, not correctness.)\n+\n+// There are always two members: allocator_type, which is a standard-\n+// conforming allocator type for allocating objects of type _Tp, and\n+// _S_instanceless, a static const member of type bool.  If\n+// _S_instanceless is true, this means that there is no difference\n+// between any two instances of type allocator_type.  Furthermore, if\n+// _S_instanceless is true, then _Alloc_traits has one additional\n+// member: _Alloc_type.  This type encapsulates allocation and\n+// deallocation of objects of type _Tp through a static interface; it\n+// has two member functions, whose signatures are\n+//    static _Tp* allocate(size_t)\n+//    static void deallocate(_Tp*, size_t)\n+\n+// The fully general version.\n+\n+template <class _Tp, class _Allocator>\n+struct _Alloc_traits\n+{\n+  static const bool _S_instanceless = false;\n+  typedef typename _Allocator::__STL_TEMPLATE rebind<_Tp>::other \n+          allocator_type;\n+};\n+\n+template <class _Tp, class _Allocator>\n+const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;\n+\n+// The version for the default allocator.\n+\n+template <class _Tp, class _Tp1>\n+struct _Alloc_traits<_Tp, allocator<_Tp1> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, alloc> _Alloc_type;\n+  typedef allocator<_Tp> allocator_type;\n+};\n+\n+// Versions for the predefined SGI-style allocators.\n+\n+template <class _Tp, int __inst>\n+struct _Alloc_traits<_Tp, __malloc_alloc_template<__inst> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;\n+  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;\n+};\n+\n+template <class _Tp, bool __threads, int __inst>\n+struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, __default_alloc_template<__threads, __inst> > \n+          _Alloc_type;\n+  typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> > \n+          allocator_type;\n+};\n+\n+template <class _Tp, class _Alloc>\n+struct _Alloc_traits<_Tp, debug_alloc<_Alloc> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, debug_alloc<_Alloc> > _Alloc_type;\n+  typedef __allocator<_Tp, debug_alloc<_Alloc> > allocator_type;\n+};\n+\n+// Versions for the __allocator adaptor used with the predefined\n+// SGI-style allocators.\n+\n+template <class _Tp, class _Tp1, int __inst>\n+struct _Alloc_traits<_Tp, \n+                     __allocator<_Tp1, __malloc_alloc_template<__inst> > >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;\n+  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;\n+};\n+\n+template <class _Tp, class _Tp1, bool __thr, int __inst>\n+struct _Alloc_traits<_Tp, \n+                      __allocator<_Tp1, \n+                                  __default_alloc_template<__thr, __inst> > >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, __default_alloc_template<__thr,__inst> > \n+          _Alloc_type;\n+  typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> > \n+          allocator_type;\n+};\n+\n+template <class _Tp, class _Tp1, class _Alloc>\n+struct _Alloc_traits<_Tp, __allocator<_Tp1, debug_alloc<_Alloc> > >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, debug_alloc<_Alloc> > _Alloc_type;\n+  typedef __allocator<_Tp, debug_alloc<_Alloc> > allocator_type;\n+};\n+\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n #endif"}, {"sha": "0d0cdb6c828fca7badb5955af188949a280177f6", "filename": "libstdc++/stl/stl_bvector.h", "status": "modified", "additions": 559, "deletions": 337, "changes": 896, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_bvector.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -37,212 +37,322 @@ static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n-struct __bit_reference {\n-  unsigned int* p;\n-  unsigned int mask;\n-  __bit_reference(unsigned int* x, unsigned int y) : p(x), mask(y) {}\n+struct _Bit_reference {\n+  unsigned int* _M_p;\n+  unsigned int _M_mask;\n+  _Bit_reference(unsigned int* __x, unsigned int __y) \n+    : _M_p(__x), _M_mask(__y) {}\n \n public:\n-  __bit_reference() : p(0), mask(0) {}\n-  operator bool() const { return !(!(*p & mask)); }\n-  __bit_reference& operator=(bool x) {\n-    if (x)      \n-      *p |= mask;\n-    else \n-      *p &= ~mask;\n+  _Bit_reference() : _M_p(0), _M_mask(0) {}\n+  operator bool() const { return !(!(*_M_p & _M_mask)); }\n+  _Bit_reference& operator=(bool __x)\n+  {\n+    if (__x)  *_M_p |= _M_mask;\n+    else      *_M_p &= ~_M_mask;\n     return *this;\n   }\n-  __bit_reference& operator=(const __bit_reference& x) { return *this = bool(x); }\n-  bool operator==(const __bit_reference& x) const {\n-    return bool(*this) == bool(x);\n+  _Bit_reference& operator=(const _Bit_reference& __x) \n+    { return *this = bool(__x); }\n+  bool operator==(const _Bit_reference& __x) const\n+    { return bool(*this) == bool(__x); }\n+  bool operator<(const _Bit_reference& __x) const {\n+    return !bool(*this) && bool(__x);\n   }\n-  bool operator<(const __bit_reference& x) const {\n-    return bool(*this) < bool(x);\n-  }\n-  void flip() { *p ^= mask; }\n+  void flip() { *_M_p ^= _M_mask; }\n };\n \n-inline void swap(__bit_reference x, __bit_reference y) {\n-  bool tmp = x;\n-  x = y;\n-  y = tmp;\n+inline void swap(_Bit_reference __x, _Bit_reference __y)\n+{\n+  bool __tmp = __x;\n+  __x = __y;\n+  __y = __tmp;\n }\n \n-struct __bit_iterator : public random_access_iterator<bool, ptrdiff_t> {\n-  typedef __bit_reference  reference;\n-  typedef __bit_reference* pointer;\n-  typedef __bit_iterator iterator;\n+struct _Bit_iterator : public random_access_iterator<bool, ptrdiff_t> {\n+  typedef _Bit_reference  reference;\n+  typedef _Bit_reference* pointer;\n+  typedef _Bit_iterator   iterator;\n \n-  unsigned int* p;\n-  unsigned int offset;\n+  unsigned int* _M_p;\n+  unsigned int _M_offset;\n   void bump_up() {\n-    if (offset++ == __WORD_BIT - 1) {\n-      offset = 0;\n-      ++p;\n+    if (_M_offset++ == __WORD_BIT - 1) {\n+      _M_offset = 0;\n+      ++_M_p;\n     }\n   }\n   void bump_down() {\n-    if (offset-- == 0) {\n-      offset = __WORD_BIT - 1;\n-      --p;\n+    if (_M_offset-- == 0) {\n+      _M_offset = __WORD_BIT - 1;\n+      --_M_p;\n     }\n   }\n \n-  __bit_iterator() : p(0), offset(0) {}\n-  __bit_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}\n-  reference operator*() const { return reference(p, 1U << offset); }\n+  _Bit_iterator() : _M_p(0), _M_offset(0) {}\n+  _Bit_iterator(unsigned int* __x, unsigned int __y) \n+    : _M_p(__x), _M_offset(__y) {}\n+  reference operator*() const { return reference(_M_p, 1U << _M_offset); }\n   iterator& operator++() {\n     bump_up();\n     return *this;\n   }\n   iterator operator++(int) {\n-    iterator tmp = *this;\n+    iterator __tmp = *this;\n     bump_up();\n-    return tmp;\n+    return __tmp;\n   }\n   iterator& operator--() {\n     bump_down();\n     return *this;\n   }\n   iterator operator--(int) {\n-    iterator tmp = *this;\n+    iterator __tmp = *this;\n     bump_down();\n-    return tmp;\n-  }\n-  iterator& operator+=(difference_type i) {\n-    difference_type n = i + offset;\n-    p += n / __WORD_BIT;\n-    n = n % __WORD_BIT;\n-    if (n < 0) {\n-      offset = (unsigned int) n + __WORD_BIT;\n-      --p;\n+    return __tmp;\n+  }\n+  iterator& operator+=(difference_type __i) {\n+    difference_type __n = __i + _M_offset;\n+    _M_p += __n / __WORD_BIT;\n+    __n = __n % __WORD_BIT;\n+    if (__n < 0) {\n+      _M_offset = (unsigned int) __n + __WORD_BIT;\n+      --_M_p;\n     } else\n-      offset = (unsigned int) n;\n+      _M_offset = (unsigned int) __n;\n     return *this;\n   }\n-  iterator& operator-=(difference_type i) {\n-    *this += -i;\n+  iterator& operator-=(difference_type __i) {\n+    *this += -__i;\n     return *this;\n   }\n-  iterator operator+(difference_type i) const {\n-    iterator tmp = *this;\n-    return tmp += i;\n+  iterator operator+(difference_type __i) const {\n+    iterator __tmp = *this;\n+    return __tmp += __i;\n   }\n-  iterator operator-(difference_type i) const {\n-    iterator tmp = *this;\n-    return tmp -= i;\n+  iterator operator-(difference_type __i) const {\n+    iterator __tmp = *this;\n+    return __tmp -= __i;\n   }\n-  difference_type operator-(iterator x) const {\n-    return __WORD_BIT * (p - x.p) + offset - x.offset;\n+  difference_type operator-(iterator __x) const {\n+    return __WORD_BIT * (_M_p - __x._M_p) + _M_offset - __x._M_offset;\n   }\n-  reference operator[](difference_type i) { return *(*this + i); }\n-  bool operator==(const iterator& x) const {\n-    return p == x.p && offset == x.offset;\n+  reference operator[](difference_type __i) { return *(*this + __i); }\n+  bool operator==(const iterator& __x) const {\n+    return _M_p == __x._M_p && _M_offset == __x._M_offset;\n   }\n-  bool operator!=(const iterator& x) const {\n-    return p != x.p || offset != x.offset;\n+  bool operator!=(const iterator& __x) const {\n+    return _M_p != __x._M_p || _M_offset != __x._M_offset;\n   }\n-  bool operator<(iterator x) const {\n-    return p < x.p || (p == x.p && offset < x.offset);\n+  bool operator<(iterator __x) const {\n+    return _M_p < __x._M_p || (_M_p == __x._M_p && _M_offset < __x._M_offset);\n   }\n };\n \n-struct __bit_const_iterator\n+struct _Bit_const_iterator\n   : public random_access_iterator<bool, ptrdiff_t>\n {\n   typedef bool                 reference;\n   typedef bool                 const_reference;\n   typedef const bool*          pointer;\n-  typedef __bit_const_iterator const_iterator;\n+  typedef _Bit_const_iterator  const_iterator;\n \n-  unsigned int* p;\n-  unsigned int offset;\n+  unsigned int* _M_p;\n+  unsigned int _M_offset;\n   void bump_up() {\n-    if (offset++ == __WORD_BIT - 1) {\n-      offset = 0;\n-      ++p;\n+    if (_M_offset++ == __WORD_BIT - 1) {\n+      _M_offset = 0;\n+      ++_M_p;\n     }\n   }\n   void bump_down() {\n-    if (offset-- == 0) {\n-      offset = __WORD_BIT - 1;\n-      --p;\n+    if (_M_offset-- == 0) {\n+      _M_offset = __WORD_BIT - 1;\n+      --_M_p;\n     }\n   }\n \n-  __bit_const_iterator() : p(0), offset(0) {}\n-  __bit_const_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}\n-  __bit_const_iterator(const __bit_iterator& x) : p(x.p), offset(x.offset) {}\n+  _Bit_const_iterator() : _M_p(0), _M_offset(0) {}\n+  _Bit_const_iterator(unsigned int* __x, unsigned int __y) \n+    : _M_p(__x), _M_offset(__y) {}\n+  _Bit_const_iterator(const _Bit_iterator& __x) \n+    : _M_p(__x._M_p), _M_offset(__x._M_offset) {}\n   const_reference operator*() const {\n-    return __bit_reference(p, 1U << offset);\n+    return _Bit_reference(_M_p, 1U << _M_offset);\n   }\n   const_iterator& operator++() {\n     bump_up();\n     return *this;\n   }\n   const_iterator operator++(int) {\n-    const_iterator tmp = *this;\n+    const_iterator __tmp = *this;\n     bump_up();\n-    return tmp;\n+    return __tmp;\n   }\n   const_iterator& operator--() {\n     bump_down();\n     return *this;\n   }\n   const_iterator operator--(int) {\n-    const_iterator tmp = *this;\n+    const_iterator __tmp = *this;\n     bump_down();\n-    return tmp;\n-  }\n-  const_iterator& operator+=(difference_type i) {\n-    difference_type n = i + offset;\n-    p += n / __WORD_BIT;\n-    n = n % __WORD_BIT;\n-    if (n < 0) {\n-      offset = (unsigned int) n + __WORD_BIT;\n-      --p;\n+    return __tmp;\n+  }\n+  const_iterator& operator+=(difference_type __i) {\n+    difference_type __n = __i + _M_offset;\n+    _M_p += __n / __WORD_BIT;\n+    __n = __n % __WORD_BIT;\n+    if (__n < 0) {\n+      _M_offset = (unsigned int) __n + __WORD_BIT;\n+      --_M_p;\n     } else\n-      offset = (unsigned int) n;\n+      _M_offset = (unsigned int) __n;\n     return *this;\n   }\n-  const_iterator& operator-=(difference_type i) {\n-    *this += -i;\n+  const_iterator& operator-=(difference_type __i) {\n+    *this += -__i;\n     return *this;\n   }\n-  const_iterator operator+(difference_type i) const {\n-    const_iterator tmp = *this;\n-    return tmp += i;\n+  const_iterator operator+(difference_type __i) const {\n+    const_iterator __tmp = *this;\n+    return __tmp += __i;\n   }\n-  const_iterator operator-(difference_type i) const {\n-    const_iterator tmp = *this;\n-    return tmp -= i;\n+  const_iterator operator-(difference_type __i) const {\n+    const_iterator __tmp = *this;\n+    return __tmp -= __i;\n   }\n-  difference_type operator-(const_iterator x) const {\n-    return __WORD_BIT * (p - x.p) + offset - x.offset;\n+  difference_type operator-(const_iterator __x) const {\n+    return __WORD_BIT * (_M_p - __x._M_p) + _M_offset - __x._M_offset;\n   }\n-  const_reference operator[](difference_type i) { \n-    return *(*this + i); \n+  const_reference operator[](difference_type __i) { \n+    return *(*this + __i); \n   }\n-  bool operator==(const const_iterator& x) const {\n-    return p == x.p && offset == x.offset;\n+  bool operator==(const const_iterator& __x) const {\n+    return _M_p == __x._M_p && _M_offset == __x._M_offset;\n   }\n-  bool operator!=(const const_iterator& x) const {\n-    return p != x.p || offset != x.offset;\n+  bool operator!=(const const_iterator& __x) const {\n+    return _M_p != __x._M_p || _M_offset != __x._M_offset;\n   }\n-  bool operator<(const_iterator x) const {\n-    return p < x.p || (p == x.p && offset < x.offset);\n+  bool operator<(const_iterator __x) const {\n+    return _M_p < __x._M_p || (_M_p == __x._M_p && _M_offset < __x._M_offset);\n   }\n };\n \n+// Bit-vector base class, which encapsulates the difference between\n+//  old SGI-style allocators and standard-conforming allocators.\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+// Base class for ordinary allocators.\n+template <class _Allocator, bool __is_static>\n+class _Bvector_alloc_base {\n+public:\n+  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return _M_data_allocator; }\n+\n+  _Bvector_alloc_base(const allocator_type& __a)\n+    : _M_data_allocator(__a), _M_start(), _M_finish(), _M_end_of_storage(0) {}\n+\n+protected:\n+  unsigned int* _M_bit_alloc(size_t __n) \n+    { return _M_data_allocator.allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n+  void _M_deallocate() {\n+    if (_M_start._M_p)\n+      _M_data_allocator.deallocate(_M_start._M_p, \n+                                   _M_end_of_storage - _M_start._M_p);\n+  }  \n+\n+  typename _Alloc_traits<unsigned int, _Allocator>::allocator_type \n+          _M_data_allocator;\n+  _Bit_iterator _M_start;\n+  _Bit_iterator _M_finish;\n+  unsigned int* _M_end_of_storage;\n+};\n+\n+// Specialization for instanceless allocators.\n+template <class _Allocator>\n+class _Bvector_alloc_base<_Allocator, true> {\n+public:\n+  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+\n+  _Bvector_alloc_base(const allocator_type&)\n+    : _M_start(), _M_finish(), _M_end_of_storage(0) {}\n+\n+protected:\n+  typedef typename _Alloc_traits<unsigned int, _Allocator>::_Alloc_type\n+          _Alloc_type;\n+          \n+  unsigned int* _M_bit_alloc(size_t __n) \n+    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n+  void _M_deallocate() {\n+    if (_M_start._M_p)\n+      _Alloc_type::deallocate(_M_start._M_p,\n+                              _M_end_of_storage - _M_start._M_p);\n+  }  \n+\n+  _Bit_iterator _M_start;\n+  _Bit_iterator _M_finish;\n+  unsigned int* _M_end_of_storage;\n+};  \n+\n+template <class _Alloc>\n+class _Bvector_base\n+  : public _Bvector_alloc_base<_Alloc,\n+                               _Alloc_traits<bool, _Alloc>::_S_instanceless>\n+{\n+  typedef _Bvector_alloc_base<_Alloc,\n+                              _Alloc_traits<bool, _Alloc>::_S_instanceless>\n+          _Base;\n+public:\n+  typedef typename _Base::allocator_type allocator_type;\n+\n+  _Bvector_base(const allocator_type& __a) : _Base(__a) {}\n+  ~_Bvector_base() { _Base::_M_deallocate(); }\n+};\n+\n+#else /* __STL_USE_STD_ALLOCATORS */\n+\n+template <class _Alloc>\n+class _Bvector_base\n+{\n+public:\n+  typedef _Alloc allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+\n+  _Bvector_base(const allocator_type&)\n+    : _M_start(), _M_finish(), _M_end_of_storage(0) {}\n+  ~_Bvector_base() { _M_deallocate(); }\n+\n+protected:\n+  typedef simple_alloc<unsigned int, _Alloc> _Alloc_type;\n+  \n+  unsigned int* _M_bit_alloc(size_t __n) \n+    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n+  void _M_deallocate() {\n+    if (_M_start._M_p)\n+      _Alloc_type::deallocate(_M_start._M_p,\n+                              _M_end_of_storage - _M_start._M_p);\n+  }\n+\n+  _Bit_iterator _M_start;\n+  _Bit_iterator _M_finish;\n+  unsigned int* _M_end_of_storage;  \n+};\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n // The next few lines are confusing.  What we're doing is declaring a\n //  partial specialization of vector<T, Alloc> if we have the necessary\n //  compiler support.  Otherwise, we define a class bit_vector which uses\n-//  the default allocator.  In either case, we typedef \"data_allocator\" \n-//  appropriately.\n+//  the default allocator. \n \n-#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && !defined(__STL_NEED_BOOL)\n+#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && !defined(__STL_NO_BOOL)\n #define __SGI_STL_VECBOOL_TEMPLATE\n #define __BVECTOR vector\n #else\n@@ -254,27 +364,29 @@ struct __bit_const_iterator\n        __STL_END_NAMESPACE\n #      include <stl_vector.h>\n        __STL_BEGIN_NAMESPACE\n-template<class Alloc> class vector<bool, Alloc>\n+template<class _Alloc> class vector<bool,_Alloc>\n+  : public _Bvector_base<_Alloc>\n #      else /* __SGI_STL_VECBOOL_TEMPLATE */\n class bit_vector\n+  : public _Bvector_base<__STL_DEFAULT_ALLOCATOR(bool) >\n #      endif /* __SGI_STL_VECBOOL_TEMPLATE */\n {\n #      ifdef __SGI_STL_VECBOOL_TEMPLATE\n-  typedef simple_alloc<unsigned int, Alloc> data_allocator;\n+  typedef _Bvector_base<_Alloc> _Base;\n #      else /* __SGI_STL_VECBOOL_TEMPLATE */\n-  typedef simple_alloc<unsigned int, alloc> data_allocator;  \n+  typedef _Bvector_base<__STL_DEFAULT_ALLOCATOR(bool) > _Base;\n #      endif /* __SGI_STL_VECBOOL_TEMPLATE */\n public:\n   typedef bool value_type;\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type; \n-  typedef __bit_reference reference;\n+  typedef _Bit_reference reference;\n   typedef bool const_reference;\n-  typedef __bit_reference* pointer;\n+  typedef _Bit_reference* pointer;\n   typedef const bool* const_pointer;\n \n-  typedef __bit_iterator                iterator;\n-  typedef __bit_const_iterator          const_iterator;\n+  typedef _Bit_iterator                iterator;\n+  typedef _Bit_const_iterator          const_iterator;\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n   typedef reverse_iterator<const_iterator> const_reverse_iterator;\n@@ -286,103 +398,105 @@ class bit_vector\n           reverse_iterator;\n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n+  typedef typename _Base::allocator_type allocator_type;\n+  allocator_type get_allocator() const { return _Base::get_allocator(); }\n+\n+protected:\n+#ifdef __STL_USE_NAMESPACES  \n+  using _Base::_M_bit_alloc;\n+  using _Base::_M_deallocate;\n+  using _Base::_M_start;\n+  using _Base::_M_finish;\n+  using _Base::_M_end_of_storage;\n+#endif /* __STL_USE_NAMESPACES */\n+\n protected:\n-  iterator start;\n-  iterator finish;\n-  unsigned int* end_of_storage;\n-  unsigned int* bit_alloc(size_type n) {\n-    return data_allocator::allocate((n + __WORD_BIT - 1)/__WORD_BIT);\n-  }\n-  void deallocate() {\n-    if (start.p)\n-      data_allocator::deallocate(start.p, end_of_storage - start.p);\n-  }\n-  void initialize(size_type n) {\n-    unsigned int* q = bit_alloc(n);\n-    end_of_storage = q + (n + __WORD_BIT - 1)/__WORD_BIT;\n-    start = iterator(q, 0);\n-    finish = start + difference_type(n);\n-  }\n-  void insert_aux(iterator position, bool x) {\n-    if (finish.p != end_of_storage) {\n-      copy_backward(position, finish, finish + 1);\n-      *position = x;\n-      ++finish;\n+  void _M_initialize(size_type __n) {\n+    unsigned int* __q = _M_bit_alloc(__n);\n+    _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n+    _M_start = iterator(__q, 0);\n+    _M_finish = _M_start + difference_type(__n);\n+  }\n+  void _M_insert_aux(iterator __position, bool __x) {\n+    if (_M_finish._M_p != _M_end_of_storage) {\n+      copy_backward(__position, _M_finish, _M_finish + 1);\n+      *__position = __x;\n+      ++_M_finish;\n     }\n     else {\n-      size_type len = size() ? 2 * size() : __WORD_BIT;\n-      unsigned int* q = bit_alloc(len);\n-      iterator i = copy(begin(), position, iterator(q, 0));\n-      *i++ = x;\n-      finish = copy(position, end(), i);\n-      deallocate();\n-      end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-      start = iterator(q, 0);\n+      size_type __len = size() ? 2 * size() : __WORD_BIT;\n+      unsigned int* __q = _M_bit_alloc(__len);\n+      iterator __i = copy(begin(), __position, iterator(__q, 0));\n+      *__i++ = __x;\n+      _M_finish = copy(__position, end(), __i);\n+      _M_deallocate();\n+      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+      _M_start = iterator(__q, 0);\n     }\n   }\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void initialize_range(InputIterator first, InputIterator last,\n-                        input_iterator_tag) {\n-    start = iterator();\n-    finish = iterator();\n-    end_of_storage = 0;\n-    for ( ; first != last; ++first) \n-      push_back(*first);\n-  }\n-\n-  template <class ForwardIterator>\n-  void initialize_range(ForwardIterator first, ForwardIterator last,\n-                        forward_iterator_tag) {\n-    size_type n = 0;\n-    distance(first, last, n);\n-    initialize(n);\n-    copy(first, last, start);\n-  }\n-\n-  template <class InputIterator>\n-  void insert_range(iterator pos,\n-                    InputIterator first, InputIterator last,\n-                    input_iterator_tag) {\n-    for ( ; first != last; ++first) {\n-      pos = insert(pos, *first);\n-      ++pos;\n+  template <class _InputIterator>\n+  void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n+                           input_iterator_tag) {\n+    _M_start = iterator();\n+    _M_finish = iterator();\n+    _M_end_of_storage = 0;\n+    for ( ; __first != __last; ++__first) \n+      push_back(*__first);\n+  }\n+\n+  template <class _ForwardIterator>\n+  void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n+                           forward_iterator_tag) {\n+    size_type __n = 0;\n+    distance(__first, __last, __n);\n+    _M_initialize(__n);\n+    copy(__first, __last, _M_start);\n+  }\n+\n+  template <class _InputIterator>\n+  void _M_insert_range(iterator __pos,\n+                       _InputIterator __first, _InputIterator __last,\n+                       input_iterator_tag) {\n+    for ( ; __first != __last; ++__first) {\n+      __pos = insert(__pos, *__first);\n+      ++__pos;\n     }\n   }\n \n-  template <class ForwardIterator>\n-  void insert_range(iterator position,\n-                    ForwardIterator first, ForwardIterator last,\n-                    forward_iterator_tag) {\n-    if (first != last) {\n-      size_type n = 0;\n-      distance(first, last, n);\n-      if (capacity() - size() >= n) {\n-        copy_backward(position, end(), finish + difference_type(n));\n-        copy(first, last, position);\n-        finish += difference_type(n);\n+  template <class _ForwardIterator>\n+  void _M_insert_range(iterator __position,\n+                       _ForwardIterator __first, _ForwardIterator __last,\n+                       forward_iterator_tag) {\n+    if (__first != __last) {\n+      size_type __n = 0;\n+      distance(__first, __last, __n);\n+      if (capacity() - size() >= __n) {\n+        copy_backward(__position, end(), _M_finish + difference_type(__n));\n+        copy(__first, __last, __position);\n+        _M_finish += difference_type(__n);\n       }\n       else {\n-        size_type len = size() + max(size(), n);\n-        unsigned int* q = bit_alloc(len);\n-        iterator i = copy(begin(), position, iterator(q, 0));\n-        i = copy(first, last, i);\n-        finish = copy(position, end(), i);\n-        deallocate();\n-        end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-        start = iterator(q, 0);\n+        size_type __len = size() + max(size(), __n);\n+        unsigned int* __q = _M_bit_alloc(__len);\n+        iterator __i = copy(begin(), __position, iterator(__q, 0));\n+        __i = copy(__first, __last, __i);\n+        _M_finish = copy(__position, end(), __i);\n+        _M_deallocate();\n+        _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+        _M_start = iterator(__q, 0);\n       }\n     }\n   }      \n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n public:\n-  iterator begin() { return start; }\n-  const_iterator begin() const { return start; }\n-  iterator end() { return finish; }\n-  const_iterator end() const { return finish; }\n+  iterator begin() { return _M_start; }\n+  const_iterator begin() const { return _M_start; }\n+  iterator end() { return _M_finish; }\n+  const_iterator end() const { return _M_finish; }\n \n   reverse_iterator rbegin() { return reverse_iterator(end()); }\n   const_reverse_iterator rbegin() const { \n@@ -396,190 +510,291 @@ class bit_vector\n   size_type size() const { return size_type(end() - begin()); }\n   size_type max_size() const { return size_type(-1); }\n   size_type capacity() const {\n-    return size_type(const_iterator(end_of_storage, 0) - begin());\n+    return size_type(const_iterator(_M_end_of_storage, 0) - begin());\n   }\n   bool empty() const { return begin() == end(); }\n-  reference operator[](size_type n) {\n-    return *(begin() + difference_type(n));\n-  }\n-  const_reference operator[](size_type n) const {\n-    return *(begin() + difference_type(n));\n+  reference operator[](size_type __n) {\n+    return *(begin() + difference_type(__n));\n   }\n-  __BVECTOR() : start(iterator()), finish(iterator()), end_of_storage(0) {}\n-  __BVECTOR(size_type n, bool value) {\n-    initialize(n);\n-    fill(start.p, end_of_storage, value ? ~0 : 0);\n+  const_reference operator[](size_type __n) const {\n+    return *(begin() + difference_type(__n));\n   }\n-  __BVECTOR(int n, bool value) {\n-    initialize(n);\n-    fill(start.p, end_of_storage, value ? ~0 : 0);\n-  }\n-  __BVECTOR(long n, bool value) {\n-    initialize(n);\n-    fill(start.p, end_of_storage, value ? ~0 : 0);\n+\n+  explicit __BVECTOR(const allocator_type& __a = allocator_type())\n+    : _Base(__a) {}\n+\n+  __BVECTOR(size_type __n, bool __value,\n+            const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+  {\n+    _M_initialize(__n);\n+    fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);\n   }\n-  explicit __BVECTOR(size_type n) {\n-    initialize(n);\n-    fill(start.p, end_of_storage, 0);\n+\n+  explicit __BVECTOR(size_type __n)\n+    : _Base(allocator_type())\n+  {\n+    _M_initialize(__n);\n+    fill(_M_start._M_p, _M_end_of_storage, 0);\n   }\n-  __BVECTOR(const __BVECTOR& x) {\n-    initialize(x.size());\n-    copy(x.begin(), x.end(), start);\n+\n+  __BVECTOR(const __BVECTOR& __x) : _Base(__x.get_allocator()) {\n+    _M_initialize(__x.size());\n+    copy(__x.begin(), __x.end(), _M_start);\n   }\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  __BVECTOR(InputIterator first, InputIterator last) {\n-    initialize_range(first, last, iterator_category(first));\n+  // Check whether it's an integral type.  If so, it's not an iterator.\n+  template <class _InputIterator>\n+  __BVECTOR(_InputIterator __first, _InputIterator __last,\n+            const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+  {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_initialize_dispatch(__first, __last, _Integral());\n+  }\n+    \n+  template <class _Integer>\n+  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n+    _M_initialize(__n);\n+    fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+  }\n+    \n+  template <class _InputIterator>\n+  void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+                              __false_type) {\n+    _M_initialize_range(__first, __last, __ITERATOR_CATEGORY(__first));\n   }\n #else /* __STL_MEMBER_TEMPLATES */\n-  __BVECTOR(const_iterator first, const_iterator last) {\n-    size_type n = 0;\n-    distance(first, last, n);\n-    initialize(n);\n-    copy(first, last, start);\n-  }\n-  __BVECTOR(const bool* first, const bool* last) {\n-    size_type n = 0;\n-    distance(first, last, n);\n-    initialize(n);\n-    copy(first, last, start);\n+  __BVECTOR(const_iterator __first, const_iterator __last,\n+            const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+  {\n+    size_type __n = 0;\n+    distance(__first, __last, __n);\n+    _M_initialize(__n);\n+    copy(__first, __last, _M_start);\n+  }\n+  __BVECTOR(const bool* __first, const bool* __last,\n+            const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+  {\n+    size_type __n = 0;\n+    distance(__first, __last, __n);\n+    _M_initialize(__n);\n+    copy(__first, __last, _M_start);\n   }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  ~__BVECTOR() { deallocate(); }\n-  __BVECTOR& operator=(const __BVECTOR& x) {\n-    if (&x == this) return *this;\n-    if (x.size() > capacity()) {\n-      deallocate();\n-      initialize(x.size());\n+  ~__BVECTOR() { }\n+\n+  __BVECTOR& operator=(const __BVECTOR& __x) {\n+    if (&__x == this) return *this;\n+    if (__x.size() > capacity()) {\n+      _M_deallocate();\n+      _M_initialize(__x.size());\n     }\n-    copy(x.begin(), x.end(), begin());\n-    finish = begin() + difference_type(x.size());\n+    copy(__x.begin(), __x.end(), begin());\n+    _M_finish = begin() + difference_type(__x.size());\n     return *this;\n   }\n-  void reserve(size_type n) {\n-    if (capacity() < n) {\n-      unsigned int* q = bit_alloc(n);\n-      finish = copy(begin(), end(), iterator(q, 0));\n-      deallocate();\n-      start = iterator(q, 0);\n-      end_of_storage = q + (n + __WORD_BIT - 1)/__WORD_BIT;\n+\n+  // assign(), a generalized assignment member function.  Two\n+  // versions: one that takes a count, and one that takes a range.\n+  // The range version is a member template, so we dispatch on whether\n+  // or not the type is an integer.\n+\n+  void assign(size_t __n, bool __x) {\n+    if (__n > size()) {\n+      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+      insert(end(), __n - size(), __x);\n+    }\n+    else {\n+      erase(begin() + __n, end());\n+      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n     }\n   }\n+\n+#ifdef __STL_MEMBER_TEMPLATES\n+\n+  template <class _InputIterator>\n+  void assign(_InputIterator __first, _InputIterator __last) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_assign_dispatch(__first, __last, _Integral());\n+  }\n+\n+  template <class _Integer>\n+  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+    { assign((size_t) __n, (bool) __val); }\n+\n+  template <class _InputIter>\n+  void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    { _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first)); }\n+\n+  template <class _InputIterator>\n+  void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+                     input_iterator_tag) {\n+    iterator __cur = begin();\n+    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+      *__cur = *__first;\n+    if (__first == __last)\n+      erase(__cur, end());\n+    else\n+      insert(end(), __first, __last);\n+  }\n+\n+  template <class _ForwardIterator>\n+  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+                     forward_iterator_tag) {\n+    size_type __len = 0;\n+    distance(__first, __last, __len);\n+    if (__len < size())\n+      erase(copy(__first, __last, begin()), end());\n+    else {\n+      _ForwardIterator __mid = __first;\n+      advance(__mid, size());\n+      copy(__first, __mid, begin());\n+      insert(end(), __mid, __last);\n+    }\n+  }    \n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+  void reserve(size_type __n) {\n+    if (capacity() < __n) {\n+      unsigned int* __q = _M_bit_alloc(__n);\n+      _M_finish = copy(begin(), end(), iterator(__q, 0));\n+      _M_deallocate();\n+      _M_start = iterator(__q, 0);\n+      _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n+    }\n+  }\n+\n   reference front() { return *begin(); }\n   const_reference front() const { return *begin(); }\n   reference back() { return *(end() - 1); }\n   const_reference back() const { return *(end() - 1); }\n-  void push_back(bool x) {\n-    if (finish.p != end_of_storage)\n-      *finish++ = x;\n+  void push_back(bool __x) {\n+    if (_M_finish._M_p != _M_end_of_storage)\n+      *_M_finish++ = __x;\n     else\n-      insert_aux(end(), x);\n+      _M_insert_aux(end(), __x);\n   }\n-  void swap(__BVECTOR& x) {\n-    __STD::swap(start, x.start);\n-    __STD::swap(finish, x.finish);\n-    __STD::swap(end_of_storage, x.end_of_storage);\n+  void swap(__BVECTOR& __x) {\n+    __STD::swap(_M_start, __x._M_start);\n+    __STD::swap(_M_finish, __x._M_finish);\n+    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);\n   }\n-  iterator insert(iterator position, bool x = bool()) {\n-    difference_type n = position - begin();\n-    if (finish.p != end_of_storage && position == end())\n-      *finish++ = x;\n+  iterator insert(iterator __position, bool __x = bool()) {\n+    difference_type __n = __position - begin();\n+    if (_M_finish._M_p != _M_end_of_storage && __position == end())\n+      *_M_finish++ = __x;\n     else\n-      insert_aux(position, x);\n-    return begin() + n;\n+      _M_insert_aux(__position, __x);\n+    return begin() + __n;\n   }\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator> void insert(iterator position,\n-                                             InputIterator first,\n-                                             InputIterator last) {\n-    insert_range(position, first, last, iterator_category(first));\n+  // Check whether it's an integral type.  If so, it's not an iterator.\n+  template <class _InputIterator>\n+  void insert(iterator __position,\n+              _InputIterator __first, _InputIterator __last) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_insert_dispatch(__position, __first, __last, _Integral());\n+  }\n+\n+  template <class _Integer>\n+  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+                          __true_type) {\n+    insert(__pos, (size_type) __n, (bool) __x);\n+  }\n+\n+  template <class _InputIterator>\n+  void _M_insert_dispatch(iterator __pos,\n+                          _InputIterator __first, _InputIterator __last,\n+                          __false_type) {\n+    _M_insert_range(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n   }\n #else /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator position, const_iterator first, \n-              const_iterator last) {\n-    if (first == last) return;\n-    size_type n = 0;\n-    distance(first, last, n);\n-    if (capacity() - size() >= n) {\n-      copy_backward(position, end(), finish + n);\n-      copy(first, last, position);\n-      finish += n;\n+  void insert(iterator __position,\n+              const_iterator __first, const_iterator __last) {\n+    if (__first == __last) return;\n+    size_type __n = 0;\n+    distance(__first, __last, __n);\n+    if (capacity() - size() >= __n) {\n+      copy_backward(__position, end(), _M_finish + __n);\n+      copy(__first, __last, __position);\n+      _M_finish += __n;\n     }\n     else {\n-      size_type len = size() + max(size(), n);\n-      unsigned int* q = bit_alloc(len);\n-      iterator i = copy(begin(), position, iterator(q, 0));\n-      i = copy(first, last, i);\n-      finish = copy(position, end(), i);\n-      deallocate();\n-      end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-      start = iterator(q, 0);\n+      size_type __len = size() + max(size(), __n);\n+      unsigned int* __q = _M_bit_alloc(__len);\n+      iterator __i = copy(begin(), __position, iterator(__q, 0));\n+      __i = copy(__first, __last, __i);\n+      _M_finish = copy(__position, end(), __i);\n+      _M_deallocate();\n+      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+      _M_start = iterator(__q, 0);\n     }\n   }\n \n-  void insert(iterator position, const bool* first, const bool* last) {\n-    if (first == last) return;\n-    size_type n = 0;\n-    distance(first, last, n);\n-    if (capacity() - size() >= n) {\n-      copy_backward(position, end(), finish + n);\n-      copy(first, last, position);\n-      finish += n;\n+  void insert(iterator __position, const bool* __first, const bool* __last) {\n+    if (__first == __last) return;\n+    size_type __n = 0;\n+    distance(__first, __last, __n);\n+    if (capacity() - size() >= __n) {\n+      copy_backward(__position, end(), _M_finish + __n);\n+      copy(__first, __last, __position);\n+      _M_finish += __n;\n     }\n     else {\n-      size_type len = size() + max(size(), n);\n-      unsigned int* q = bit_alloc(len);\n-      iterator i = copy(begin(), position, iterator(q, 0));\n-      i = copy(first, last, i);\n-      finish = copy(position, end(), i);\n-      deallocate();\n-      end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-      start = iterator(q, 0);\n+      size_type __len = size() + max(size(), __n);\n+      unsigned int* __q = _M_bit_alloc(__len);\n+      iterator __i = copy(begin(), __position, iterator(__q, 0));\n+      __i = copy(__first, __last, __i);\n+      _M_finish = copy(__position, end(), __i);\n+      _M_deallocate();\n+      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+      _M_start = iterator(__q, 0);\n     }\n   }\n #endif /* __STL_MEMBER_TEMPLATES */\n   \n-  void insert(iterator position, size_type n, bool x) {\n-    if (n == 0) return;\n-    if (capacity() - size() >= n) {\n-      copy_backward(position, end(), finish + difference_type(n));\n-      fill(position, position + difference_type(n), x);\n-      finish += difference_type(n);\n+  void insert(iterator __position, size_type __n, bool __x) {\n+    if (__n == 0) return;\n+    if (capacity() - size() >= __n) {\n+      copy_backward(__position, end(), _M_finish + difference_type(__n));\n+      fill(__position, __position + difference_type(__n), __x);\n+      _M_finish += difference_type(__n);\n     }\n     else {\n-      size_type len = size() + max(size(), n);\n-      unsigned int* q = bit_alloc(len);\n-      iterator i = copy(begin(), position, iterator(q, 0));\n-      fill_n(i, n, x);\n-      finish = copy(position, end(), i + difference_type(n));\n-      deallocate();\n-      end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-      start = iterator(q, 0);\n+      size_type __len = size() + max(size(), __n);\n+      unsigned int* __q = _M_bit_alloc(__len);\n+      iterator __i = copy(begin(), __position, iterator(__q, 0));\n+      fill_n(__i, __n, __x);\n+      _M_finish = copy(__position, end(), __i + difference_type(__n));\n+      _M_deallocate();\n+      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n+      _M_start = iterator(__q, 0);\n     }\n   }\n \n-  void insert(iterator pos, int n, bool x)  { insert(pos, (size_type)n, x); }\n-  void insert(iterator pos, long n, bool x) { insert(pos, (size_type)n, x); }\n-\n-  void pop_back() { --finish; }\n-  iterator erase(iterator position) {\n-    if (position + 1 != end())\n-      copy(position + 1, end(), position);\n-    --finish;\n-    return position;\n+  void pop_back() { --_M_finish; }\n+  iterator erase(iterator __position) {\n+    if (__position + 1 != end())\n+      copy(__position + 1, end(), __position);\n+      --_M_finish;\n+    return __position;\n   }\n-  iterator erase(iterator first, iterator last) {\n-    finish = copy(last, end(), first);\n-    return first;\n+  iterator erase(iterator __first, iterator __last) {\n+    _M_finish = copy(__last, end(), __first);\n+    return __first;\n   }\n-  void resize(size_type new_size, bool x = bool()) {\n-    if (new_size < size()) \n-      erase(begin() + difference_type(new_size), end());\n+  void resize(size_type __new_size, bool __x = bool()) {\n+    if (__new_size < size()) \n+      erase(begin() + difference_type(__new_size), end());\n     else\n-      insert(end(), new_size - size(), x);\n+      insert(end(), __new_size - size(), __x);\n   }\n   void clear() { erase(begin(), end()); }\n };\n@@ -590,12 +805,18 @@ typedef vector<bool, alloc> bit_vector;\n \n #else /* __SGI_STL_VECBOOL_TEMPLATE */\n \n-inline bool operator==(const bit_vector& x, const bit_vector& y) {\n-  return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());\n+inline bool \n+operator==(const bit_vector& __x, const bit_vector& __y)\n+{\n+  return (__x.size() == __y.size() && \n+          equal(__x.begin(), __x.end(), __y.begin()));\n }\n \n-inline bool operator<(const bit_vector& x, const bit_vector& y) {\n-  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n+inline bool \n+operator<(const bit_vector& __x, const bit_vector& __y)\n+{\n+  return lexicographical_compare(__x.begin(), __x.end(), \n+                                 __y.begin(), __y.end());\n }\n \n #endif /* __SGI_STL_VECBOOL_TEMPLATE */\n@@ -605,6 +826,7 @@ inline bool operator<(const bit_vector& x, const bit_vector& y) {\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n \n __STL_END_NAMESPACE "}, {"sha": "b1b5738d3a440b5aec115c6609def809b65fcb9c", "filename": "libstdc++/stl/stl_config.h", "status": "modified", "additions": 140, "deletions": 58, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_config.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -27,57 +27,86 @@\n #ifndef __STL_CONFIG_H\n # define __STL_CONFIG_H\n \n-// What this file does.\n-//  (1)  Defines bool, true, and false if the compiler doesn't do so already.\n-//  (2)  Defines __STL_NO_DRAND48 if the compiler's standard library does\n-//       not support the drand48() function.\n-//  (3)  Defines __STL_STATIC_TEMPLATE_MEMBER_BUG if the compiler can't \n-//       handle static members of template classes.\n-//  (4)  Defines 'typename' as a null macro if the compiler does not support\n-//       the typename keyword.\n-//  (5)  Defines __STL_CLASS_PARTIAL_SPECIALIZATION if the compiler \n-//       supports partial specialization of class templates.\n-//  (6)  Defines __STL_FUNCTION_TMPL_PARTIAL_ORDER if the compiler supports\n-//       partial ordering of function templates (a.k.a partial specialization\n-//       of function templates.\n-//  (7)  Defines __STL_EXPLICIT_FUNCTION_TMPL_ARGS if the compiler\n-//       supports calling a function template by providing its template\n-//       arguments explicitly.\n-//  (8)  Defines __STL_MEMBER_TEMPLATES if the compiler supports\n-//       template members of classes.\n-//  (9)  Defines 'explicit' as a null macro if the compiler does not support\n-//       the explicit keyword.    \n-//  (10) Defines __STL_LIMITED_DEFAULT_TEMPLATES if the compiler is\n-//       unable to handle default template parameters that depend on\n-//       previous template parameters.\n-//  (11) Defines __STL_NON_TYPE_TMPL_PARAM_BUG if the compiler has \n-//       trouble performing function template argument deduction for\n-//       non-type template parameters.\n-//  (12) Defines __SGI_STL_NO_ARROW_OPERATOR if the compiler is unable\n-//       to support the -> operator for iterators.\n-//  (13) Defines __STL_USE_EXCEPTIONS if the compiler (in the current\n-//       compilation mode) supports exceptions.\n-//  (14) Define __STL_USE_NAMESPACES if we're putting the STL into a \n-//       namespace.  \n-//  (15) Defines __STL_SGI_THREADS if this is being compiled on an SGI\n-//       compiler, and if the user hasn't selected pthreads or no threads\n-//       instead.\n-//  (16) Defines __STL_WIN32THREADS if this is being compiled on a \n-//       WIN32 compiler in multithreaded mode.\n-//  (17) Define namespace-related macros (__STD, __STL_BEGIN_NAMESPACE, etc.)\n-//       apropriately.\n-//  (18) Define exception-related macros (__STL_TRY, __STL_UNWIND, etc.)\n-//       appropriately.\n-//  (19) Defines __stl_assert either as a test or as a null macro,\n-//       depending on whether or not __STL_ASSERTIONS is defined.\n+// Flags:\n+// * __STL_NO_BOOL: defined if the compiler doesn't have bool as a builtin\n+//   type.\n+// * __STL_HAS_WCHAR_T: defined if the compier has wchar_t as a builtin type.\n+// * __STL_NO_DRAND48: defined if the compiler doesn't have the drand48 \n+//   function.\n+// * __STL_STATIC_TEMPLATE_MEMBER_BUG: defined if the compiler can't handle\n+//   static members of template classes.\n+// * __STL_CLASS_PARTIAL_SPECIALIZATION: defined if the compiler supports\n+//   partial specialization of template classes.\n+// * __STL_PARTIAL_SPECIALIZATION_SYNTAX: defined if the compiler \n+//   supports partial specialization syntax for full specialization of\n+//   class templates.  (Even if it doesn't actually support partial \n+//   specialization itself.)\n+// * __STL_FUNCTION_TMPL_PARTIAL_ORDER: defined if the compiler supports\n+//   partial ordering of function templates.  (a.k.a partial specialization\n+//   of function templates.)\n+// * __STL_MEMBER_TEMPLATES: defined if the compiler supports template\n+//   member functions of classes.\n+// * __STL_MEMBER_TEMPLATE_CLASSES: defined if the compiler supports \n+//   nested classes that are member templates of other classes.\n+// * __STL_EXPLICIT_FUNCTION_TMPL_ARGS: defined if the compiler \n+//   supports calling a function template by providing its template\n+//   arguments explicitly.\n+// * __STL_LIMITED_DEFAULT_TEMPLATES: defined if the compiler is unable\n+//   to handle default template parameters that depend on previous template\n+//   parameters.\n+// * __STL_NON_TYPE_TMPL_PARAM_BUG: defined if the compiler has trouble with\n+//   function template argument deduction for non-type template parameters.\n+// * __SGI_STL_NO_ARROW_OPERATOR: defined if the compiler is unable\n+//   to support the -> operator for iterators.\n+// * __STL_USE_EXCEPTIONS: defined if the compiler (in the current compilation\n+//   mode) supports exceptions.\n+// * __STL_USE_NAMESPACES: defined if the compiler has the necessary\n+//   support for namespaces.\n+// * __STL_NO_EXCEPTION_HEADER: defined if the compiler does not have a\n+//   standard-conforming header <exception>.\n+// * __STL_SGI_THREADS: defined if this is being compiled for an SGI IRIX\n+//   system in multithreaded mode, using native SGI threads instead of \n+//   pthreads.\n+// * __STL_WIN32THREADS: defined if this is being compiled on a WIN32\n+//   compiler in multithreaded mode.\n+// * __STL_LONG_LONG if the compiler has long long and unsigned long long\n+//   types.  (They're not in the C++ standard, but they are expected to be \n+//   included in the forthcoming C9X standard.)\n+\n+\n+// User-settable macros that control compilation:\n+// * __STL_USE_SGI_ALLOCATORS: if defined, then the STL will use older\n+//   SGI-style allocators, instead of standard-conforming allocators,\n+//   even if the compiler supports all of the language features needed\n+//   for standard-conforming allocators.\n+// * __STL_NO_NAMESPACES: if defined, don't put the library in namespace\n+//   std, even if the compiler supports namespaces.\n+// * __STL_ASSERTIONS: if defined, then enable runtime checking through the\n+//   __stl_assert macro.\n+// * _PTHREADS: if defined, use Posix threads for multithreading support.\n+// * _NOTHREADS: if defined, don't use any multithreading support.  \n+\n+\n+// Other macros defined by this file:\n+\n+// * bool, true, and false, if __STL_NO_BOOL is defined.\n+// * typename, as a null macro if it's not already a keyword.\n+// * explicit, as a null macro if it's not already a keyword.\n+// * namespace-related macros (__STD, __STL_BEGIN_NAMESPACE, etc.)\n+// * exception-related macros (__STL_TRY, __STL_UNWIND, etc.)\n+// * __stl_assert, either as a test or as a null macro, depending on\n+//   whether or not __STL_ASSERTIONS is defined.\n \n #ifdef _PTHREADS\n #   define __STL_PTHREADS\n #endif\n \n # if defined(__sgi) && !defined(__GNUC__)\n #   if !defined(_BOOL)\n-#     define __STL_NEED_BOOL\n+#     define __STL_NO_BOOL\n+#   endif\n+#   if defined(_WCHAR_T_IS_KEYWORD)\n+#     define __STL_HAS_WCHAR_T \n #   endif\n #   if !defined(_TYPENAME_IS_KEYWORD)\n #     define __STL_NEED_TYPENAME\n@@ -87,6 +116,13 @@\n #   endif\n #   ifdef _MEMBER_TEMPLATES\n #     define __STL_MEMBER_TEMPLATES\n+#     define __STL_MEMBER_TEMPLATE_CLASSES\n+#   endif\n+#   if defined(_MEMBER_TEMPLATE_KEYWORD)\n+#     define __STL_MEMBER_TEMPLATE_KEYWORD\n+#   endif\n+#   if (_COMPILER_VERSION >= 730) && defined(_MIPS_SIM) && _MIPS_SIM != _ABIO32\n+#     define __STL_MEMBER_TEMPLATE_KEYWORD\n #   endif\n #   if !defined(_EXPLICIT_IS_KEYWORD)\n #     define __STL_NEED_EXPLICIT\n@@ -95,11 +131,17 @@\n #     define __STL_USE_EXCEPTIONS\n #   endif\n #   if (_COMPILER_VERSION >= 721) && defined(_NAMESPACES)\n-#     define __STL_USE_NAMESPACES\n+#     define __STL_HAS_NAMESPACES\n #   endif \n+#   if (_COMPILER_VERSION < 721)\n+#     define __STL_NO_EXCEPTION_HEADER\n+#   endif\n #   if !defined(_NOTHREADS) && !defined(__STL_PTHREADS)\n #     define __STL_SGI_THREADS\n #   endif\n+#   if defined(_LONGLONG) && defined(_SGIAPI) && _SGIAPI\n+#     define __STL_LONG_LONG\n+#   endif\n # endif\n \n # ifdef __GNUC__\n@@ -113,6 +155,8 @@\n #     define __STL_FUNCTION_TMPL_PARTIAL_ORDER\n #     define __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n #     define __STL_MEMBER_TEMPLATES\n+      //    g++ 2.8.1 supports member template functions, but not member\n+      //    template nested classes.\n #   endif\n     /* glibc pre 2.0 is very buggy. We have to disable thread for it.\n        It should be upgraded to glibc 2.0 or later. */\n@@ -129,29 +173,30 @@\n # endif\n \n # if defined(__SUNPRO_CC) \n-#   define __STL_NEED_BOOL\n+#   define __STL_NO_BOOL\n #   define __STL_NEED_TYPENAME\n #   define __STL_NEED_EXPLICIT\n #   define __STL_USE_EXCEPTIONS\n # endif\n \n # if defined(__COMO__)\n #   define __STL_MEMBER_TEMPLATES\n+#   define __STL_MEMBER_TEMPLATE_CLASSES\n #   define __STL_CLASS_PARTIAL_SPECIALIZATION\n #   define __STL_USE_EXCEPTIONS\n-#   define __STL_USE_NAMESPACES\n+#   define __STL_HAS_NAMESPACES\n # endif\n \n # if defined(_MSC_VER)\n-#   if _MSC_VER > 1000\n-#     include <yvals.h>\n-#   else\n-#     define __STL_NEED_BOOL\n-#   endif\n #   define __STL_NO_DRAND48\n #   define __STL_NEED_TYPENAME\n-#   if _MSC_VER < 1100\n+#   if _MSC_VER < 1100  /* 1000 is version 4.0, 1100 is 5.0, 1200 is 6.0. */\n #     define __STL_NEED_EXPLICIT\n+#     define __STL_NO_BOOL\n+#     if  _MSC_VER > 1000\n+#       include <yvals.h>\n+#       define __STL_DONT_USE_BOOL_TYPEDEF\n+#     endif\n #   endif\n #   define __STL_NON_TYPE_TMPL_PARAM_BUG\n #   define __SGI_STL_NO_ARROW_OPERATOR\n@@ -161,6 +206,11 @@\n #   ifdef _MT\n #     define __STL_WIN32THREADS\n #   endif\n+#   if _MSC_VER >= 1200\n+#     define __STL_PARTIAL_SPECIALIZATION_SYNTAX\n+#     define __STL_HAS_NAMESPACES\n+#     define __STL_NO_NAMESPACES\n+#   endif\n # endif\n \n # if defined(__BORLANDC__)\n@@ -177,8 +227,7 @@\n #   endif\n # endif\n \n-\n-# if defined(__STL_NEED_BOOL)\n+# if defined(__STL_NO_BOOL) && !defined(__STL_DONT_USE_BOOL_TYPEDEF)\n     typedef int bool;\n #   define true 1\n #   define false 0\n@@ -188,6 +237,12 @@\n #   define typename\n # endif\n \n+# ifdef __STL_MEMBER_TEMPLATE_KEYWORD\n+#   define __STL_TEMPLATE template\n+# else\n+#   define __STL_TEMPLATE\n+# endif\n+\n # ifdef __STL_NEED_EXPLICIT\n #   define explicit\n # endif\n@@ -198,22 +253,46 @@\n #   define __STL_NULL_TMPL_ARGS\n # endif\n \n-# ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+# if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \\\n+     || defined (__STL_PARTIAL_SPECIALIZATION_SYNTAX)\n #   define __STL_TEMPLATE_NULL template<>\n # else\n #   define __STL_TEMPLATE_NULL\n # endif\n \n+// Use standard-conforming allocators if we have the necessary language\n+// features.  __STL_USE_SGI_ALLOCATORS is a hook so that users can \n+// disable new-style allocators, and continue to use the same kind of\n+// allocators as before, without having to edit library headers.\n+# if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && \\\n+     defined(__STL_MEMBER_TEMPLATES) && \\\n+     defined(__STL_MEMBER_TEMPLATE_CLASSES) && \\\n+    !defined(__STL_NO_BOOL) && \\\n+    !defined(__STL_NON_TYPE_TMPL_PARAM_BUG) && \\\n+    !defined(__STL_LIMITED_DEFAULT_TEMPLATES) && \\\n+    !defined(__STL_USE_SGI_ALLOCATORS) \n+#   define __STL_USE_STD_ALLOCATORS\n+# endif\n+\n+# ifndef __STL_DEFAULT_ALLOCATOR\n+#   ifdef __STL_USE_STD_ALLOCATORS\n+#     define __STL_DEFAULT_ALLOCATOR(T) allocator<T>\n+#   else\n+#     define __STL_DEFAULT_ALLOCATOR(T) alloc\n+#   endif\n+# endif\n+\n // __STL_NO_NAMESPACES is a hook so that users can disable namespaces\n // without having to edit library headers.\n-# if defined(__STL_USE_NAMESPACES) && !defined(__STL_NO_NAMESPACES)\n+# if defined(__STL_HAS_NAMESPACES) && !defined(__STL_NO_NAMESPACES)\n #   define __STD std\n #   define __STL_BEGIN_NAMESPACE namespace std {\n #   define __STL_END_NAMESPACE }\n-#   define  __STL_USE_NAMESPACE_FOR_RELOPS\n+#   define __STL_USE_NAMESPACE_FOR_RELOPS\n #   define __STL_BEGIN_RELOPS_NAMESPACE namespace std {\n #   define __STL_END_RELOPS_NAMESPACE }\n #   define __STD_RELOPS std\n+#   define __STL_USE_NAMESPACES\n # else\n #   define __STD \n #   define __STL_BEGIN_NAMESPACE \n@@ -222,17 +301,20 @@\n #   define __STL_BEGIN_RELOPS_NAMESPACE \n #   define __STL_END_RELOPS_NAMESPACE \n #   define __STD_RELOPS \n+#   undef  __STL_USE_NAMESPACES\n # endif\n \n # ifdef __STL_USE_EXCEPTIONS\n #   define __STL_TRY try\n #   define __STL_CATCH_ALL catch(...)\n+#   define __STL_THROW(x) throw x\n #   define __STL_RETHROW throw\n #   define __STL_NOTHROW throw()\n #   define __STL_UNWIND(action) catch(...) { action; throw; }\n # else\n #   define __STL_TRY \n #   define __STL_CATCH_ALL if (false)\n+#   define __STL_THROW(x) \n #   define __STL_RETHROW \n #   define __STL_NOTHROW \n #   define __STL_UNWIND(action) "}, {"sha": "0ce544c7eda5bd5763597077b06b56db93c3c816", "filename": "libstdc++/stl/stl_construct.h", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_construct.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -35,35 +35,47 @@\n \n __STL_BEGIN_NAMESPACE\n \n-template <class T>\n-inline void destroy(T* pointer) {\n-    pointer->~T();\n+// construct and destroy.  These functions are not part of the C++ standard,\n+// and are provided for backward compatibility with the HP STL.\n+\n+template <class _Tp>\n+inline void destroy(_Tp* __pointer) {\n+  __pointer->~_Tp();\n+}\n+\n+template <class _T1, class _T2>\n+inline void construct(_T1* __p, const _T2& __value) {\n+  new (__p) _T1(__value);\n }\n \n-template <class T1, class T2>\n-inline void construct(T1* p, const T2& value) {\n-  new (p) T1(value);\n+template <class _T1>\n+inline void construct(_T1* __p) {\n+  new (__p) _T1();\n }\n \n-template <class ForwardIterator>\n+template <class _ForwardIterator>\n inline void\n-__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {\n-  for ( ; first < last; ++first)\n-    destroy(&*first);\n+__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)\n+{\n+  for ( ; __first < __last; ++__first)\n+    destroy(&*__first);\n }\n \n-template <class ForwardIterator> \n-inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}\n+template <class _ForwardIterator> \n+inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {}\n \n-template <class ForwardIterator, class T>\n-inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {\n-  typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;\n-  __destroy_aux(first, last, trivial_destructor());\n+template <class _ForwardIterator, class _Tp>\n+inline void \n+__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)\n+{\n+  typedef typename __type_traits<_Tp>::has_trivial_destructor\n+          _Trivial_destructor;\n+  __destroy_aux(__first, __last, _Trivial_destructor());\n }\n \n-template <class ForwardIterator>\n-inline void destroy(ForwardIterator first, ForwardIterator last) {\n-  __destroy(first, last, value_type(first));\n+template <class _ForwardIterator>\n+inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {\n+  __destroy(__first, __last, __VALUE_TYPE(__first));\n }\n \n inline void destroy(char*, char*) {}"}, {"sha": "48a4c76d55a7f03d3ba7eea0b84b614aa2070741", "filename": "libstdc++/stl/stl_deque.h", "status": "modified", "additions": 1146, "deletions": 783, "changes": 1929, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_deque.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -53,8 +53,8 @@\n  *  [map, map + map_size) is a valid, non-empty range.  \n  *  [start.node, finish.node] is a valid range contained within \n  *    [map, map + map_size).  \n- *  A pointer in the range [map, map + map_size) points to an allocated\n- *    node if and only if the pointer is in the range [start.node, finish.node].\n+ *  A pointer in the range [map, map + map_size) points to an allocated node\n+ *    if and only if the pointer is in the range [start.node, finish.node].\n  */\n \n \n@@ -83,191 +83,417 @@ __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n // Note: this function is simply a kludge to work around several compilers'\n //  bugs in handling constant expressions.\n-inline size_t __deque_buf_size(size_t n, size_t sz)\n+inline size_t\n+__deque_buf_size(size_t __n, size_t __size)\n {\n-  return n != 0 ? n : (sz < 512 ? size_t(512 / sz) : size_t(1));\n+  return __n != 0 ? __n : (__size < 512 ? size_t(512 / __size) : size_t(1));\n }\n \n #ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-template <class T, class Ref, class Ptr, size_t BufSiz>\n-struct __deque_iterator {\n-  typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;\n-  typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;\n-  static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }\n+template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n+struct _Deque_iterator {\n+  typedef _Deque_iterator<_Tp,_Tp&,_Tp*,__bufsiz>             iterator;\n+  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*,__bufsiz> const_iterator;\n+  static size_t \n+    _S_buffer_size() { return __deque_buf_size(__bufsiz, sizeof(_Tp)); }\n #else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-template <class T, class Ref, class Ptr>\n-struct __deque_iterator {\n-  typedef __deque_iterator<T, T&, T*>             iterator;\n-  typedef __deque_iterator<T, const T&, const T*> const_iterator;\n-  static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }\n+template <class _Tp, class _Ref, class _Ptr>\n+struct _Deque_iterator {\n+  typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n+  typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n+  static size_t \n+    _S_buffer_size() { return __deque_buf_size(0, sizeof(_Tp)); }\n #endif\n \n   typedef random_access_iterator_tag iterator_category;\n-  typedef T value_type;\n-  typedef Ptr pointer;\n-  typedef Ref reference;\n+  typedef _Tp value_type;\n+  typedef _Ptr pointer;\n+  typedef _Ref reference;\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type;\n-  typedef T** map_pointer;\n+  typedef _Tp** _Map_pointer;\n \n-  typedef __deque_iterator self;\n+  typedef _Deque_iterator _Self;\n \n-  T* cur;\n-  T* first;\n-  T* last;\n-  map_pointer node;\n+  _Tp* _M_cur;\n+  _Tp* _M_first;\n+  _Tp* _M_last;\n+  _Map_pointer _M_node;\n \n-  __deque_iterator(T* x, map_pointer y) \n-    : cur(x), first(*y), last(*y + buffer_size()), node(y) {}\n-  __deque_iterator() : cur(0), first(0), last(0), node(0) {}\n-  __deque_iterator(const iterator& x)\n-    : cur(x.cur), first(x.first), last(x.last), node(x.node) {}\n+  _Deque_iterator(_Tp* __x, _Map_pointer __y) \n+    : _M_cur(__x), _M_first(*__y),\n+      _M_last(*__y + _S_buffer_size()), _M_node(__y) {}\n+  _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}\n+  _Deque_iterator(const iterator& __x)\n+    : _M_cur(__x._M_cur), _M_first(__x._M_first), \n+      _M_last(__x._M_last), _M_node(__x._M_node) {}\n \n-  reference operator*() const { return *cur; }\n+  reference operator*() const { return *_M_cur; }\n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n+  pointer operator->() const { return _M_cur; }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n-  difference_type operator-(const self& x) const {\n-    return difference_type(buffer_size()) * (node - x.node - 1) +\n-      (cur - first) + (x.last - x.cur);\n+  difference_type operator-(const _Self& __x) const {\n+    return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) +\n+      (_M_cur - _M_first) + (__x._M_last - __x._M_cur);\n   }\n \n-  self& operator++() {\n-    ++cur;\n-    if (cur == last) {\n-      set_node(node + 1);\n-      cur = first;\n+  _Self& operator++() {\n+    ++_M_cur;\n+    if (_M_cur == _M_last) {\n+      _M_set_node(_M_node + 1);\n+      _M_cur = _M_first;\n     }\n     return *this; \n   }\n-  self operator++(int)  {\n-    self tmp = *this;\n+  _Self operator++(int)  {\n+    _Self __tmp = *this;\n     ++*this;\n-    return tmp;\n+    return __tmp;\n   }\n \n-  self& operator--() {\n-    if (cur == first) {\n-      set_node(node - 1);\n-      cur = last;\n+  _Self& operator--() {\n+    if (_M_cur == _M_first) {\n+      _M_set_node(_M_node - 1);\n+      _M_cur = _M_last;\n     }\n-    --cur;\n+    --_M_cur;\n     return *this;\n   }\n-  self operator--(int) {\n-    self tmp = *this;\n+  _Self operator--(int) {\n+    _Self __tmp = *this;\n     --*this;\n-    return tmp;\n+    return __tmp;\n   }\n \n-  self& operator+=(difference_type n) {\n-    difference_type offset = n + (cur - first);\n-    if (offset >= 0 && offset < difference_type(buffer_size()))\n-      cur += n;\n+  _Self& operator+=(difference_type __n)\n+  {\n+    difference_type __offset = __n + (_M_cur - _M_first);\n+    if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))\n+      _M_cur += __n;\n     else {\n-      difference_type node_offset =\n-        offset > 0 ? offset / difference_type(buffer_size())\n-                   : -difference_type((-offset - 1) / buffer_size()) - 1;\n-      set_node(node + node_offset);\n-      cur = first + (offset - node_offset * difference_type(buffer_size()));\n+      difference_type __node_offset =\n+        __offset > 0 ? __offset / difference_type(_S_buffer_size())\n+                   : -difference_type((-__offset - 1) / _S_buffer_size()) - 1;\n+      _M_set_node(_M_node + __node_offset);\n+      _M_cur = _M_first + \n+        (__offset - __node_offset * difference_type(_S_buffer_size()));\n     }\n     return *this;\n   }\n \n-  self operator+(difference_type n) const {\n-    self tmp = *this;\n-    return tmp += n;\n+  _Self operator+(difference_type __n) const\n+  {\n+    _Self __tmp = *this;\n+    return __tmp += __n;\n   }\n \n-  self& operator-=(difference_type n) { return *this += -n; }\n+  _Self& operator-=(difference_type __n) { return *this += -__n; }\n  \n-  self operator-(difference_type n) const {\n-    self tmp = *this;\n-    return tmp -= n;\n+  _Self operator-(difference_type __n) const {\n+    _Self __tmp = *this;\n+    return __tmp -= __n;\n   }\n \n-  reference operator[](difference_type n) const { return *(*this + n); }\n+  reference operator[](difference_type __n) const { return *(*this + __n); }\n \n-  bool operator==(const self& x) const { return cur == x.cur; }\n-  bool operator!=(const self& x) const { return !(*this == x); }\n-  bool operator<(const self& x) const {\n-    return (node == x.node) ? (cur < x.cur) : (node < x.node);\n+  bool operator==(const _Self& __x) const { return _M_cur == __x._M_cur; }\n+  bool operator!=(const _Self& __x) const { return !(*this == __x); }\n+  bool operator<(const _Self& __x) const {\n+    return (_M_node == __x._M_node) ? \n+      (_M_cur < __x._M_cur) : (_M_node < __x._M_node);\n   }\n \n-  void set_node(map_pointer new_node) {\n-    node = new_node;\n-    first = *new_node;\n-    last = first + difference_type(buffer_size());\n+  void _M_set_node(_Map_pointer __new_node) {\n+    _M_node = __new_node;\n+    _M_first = *__new_node;\n+    _M_last = _M_first + difference_type(_S_buffer_size());\n   }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n #ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n \n-template <class T, class Ref, class Ptr, size_t BufSiz>\n+template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n inline random_access_iterator_tag\n-iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n+iterator_category(const _Deque_iterator<_Tp,_Ref,_Ptr,__bufsiz>&) {\n   return random_access_iterator_tag();\n }\n \n-template <class T, class Ref, class Ptr, size_t BufSiz>\n-inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n+template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n+inline _Tp*\n+value_type(const _Deque_iterator<_Tp,_Ref,_Ptr,__bufsiz>&) {\n   return 0;\n }\n \n-template <class T, class Ref, class Ptr, size_t BufSiz>\n-inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n+template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n+inline ptrdiff_t*\n+distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr,__bufsiz>&) {\n   return 0;\n }\n \n #else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n \n-template <class T, class Ref, class Ptr>\n+template <class _Tp, class _Ref, class _Ptr>\n inline random_access_iterator_tag\n-iterator_category(const __deque_iterator<T, Ref, Ptr>&) {\n+iterator_category(const _Deque_iterator<_Tp,_Ref,_Ptr>&)\n+{\n   return random_access_iterator_tag();\n }\n \n-template <class T, class Ref, class Ptr>\n-inline T* value_type(const __deque_iterator<T, Ref, Ptr>&) { return 0; }\n+template <class _Tp, class _Ref, class _Ptr>\n+inline _Tp*\n+value_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) { return 0; }\n \n-template <class T, class Ref, class Ptr>\n-inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr>&) {\n+template <class _Tp, class _Ref, class _Ptr>\n+inline ptrdiff_t*\n+distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) {\n   return 0;\n }\n \n #endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n+// Deque base class.  It has two purposes.  First, its constructor\n+//  and destructor allocate (but don't initialize) storage.  This makes\n+//  exception safety easier.  Second, the base class encapsulates all of\n+//  the differences between SGI-style allocators and standard-conforming\n+//  allocators.\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+// Base class for ordinary allocators.\n+template <class _Tp, class _Alloc, size_t __bufsiz, bool __is_static>\n+class _Deque_alloc_base {\n+public:\n+  typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n+  allocator_type get_allocator() const { return node_allocator; }\n+\n+  _Deque_alloc_base(const allocator_type& __a)\n+    : node_allocator(__a), map_allocator(__a), _M_map(0), _M_map_size(0)\n+  {}\n+  \n+protected:\n+  typedef typename _Alloc_traits<_Tp*, _Alloc>::allocator_type\n+          map_allocator_type;\n+\n+  allocator_type node_allocator;\n+  map_allocator_type map_allocator;\n+\n+  _Tp* _M_allocate_node() {\n+    return node_allocator.allocate(__deque_buf_size(__bufsiz,sizeof(_Tp)));\n+  }\n+  void _M_deallocate_node(_Tp* __p) {\n+    node_allocator.deallocate(__p, __deque_buf_size(__bufsiz,sizeof(_Tp)));\n+  }\n+  _Tp** _M_allocate_map(size_t __n) \n+    { return map_allocator.allocate(__n); }\n+  void _M_deallocate_map(_Tp** __p, size_t __n) \n+    { map_allocator.deallocate(__p, __n); }\n+\n+  _Tp** _M_map;\n+  size_t _M_map_size;\n+};\n+\n+// Specialization for instanceless allocators.\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+class _Deque_alloc_base<_Tp, _Alloc, __bufsiz, true>\n+{\n+public:\n+  typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+\n+  _Deque_alloc_base(const allocator_type&) : _M_map(0), _M_map_size(0) {}\n+  \n+protected:\n+  typedef typename _Alloc_traits<_Tp, _Alloc>::_Alloc_type _Node_alloc_type;\n+  typedef typename _Alloc_traits<_Tp*, _Alloc>::_Alloc_type _Map_alloc_type;\n+\n+  _Tp* _M_allocate_node()\n+    { return _Node_alloc_type::allocate(__deque_buf_size(__bufsiz, \n+                                                         sizeof(_Tp))); }\n+  void _M_deallocate_node(_Tp* __p)\n+    { _Node_alloc_type::deallocate(__p, __deque_buf_size(__bufsiz, \n+                                                         sizeof(_Tp))); }\n+  _Tp** _M_allocate_map(size_t __n) \n+    { return _Map_alloc_type::allocate(__n); }\n+  void _M_deallocate_map(_Tp** __p, size_t __n) \n+    { _Map_alloc_type::deallocate(__p, __n); }\n+\n+  _Tp** _M_map;\n+  size_t _M_map_size;\n+};\n+\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+class _Deque_base\n+  : public _Deque_alloc_base<_Tp,_Alloc,__bufsiz, \n+                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+{\n+public:\n+  typedef _Deque_alloc_base<_Tp,_Alloc,__bufsiz,\n+                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+          _Base;\n+  typedef typename _Base::allocator_type allocator_type;\n+  typedef _Deque_iterator<_Tp,_Tp&,_Tp*,__bufsiz>              iterator;\n+  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp&, __bufsiz> const_iterator;\n+\n+  _Deque_base(const allocator_type& __a, size_t __num_elements)\n+    : _Base(__a), _M_start(), _M_finish()\n+    { _M_initialize_map(__num_elements); }\n+  _Deque_base(const allocator_type& __a) \n+    : _Base(__a), _M_start(), _M_finish() {}\n+  ~_Deque_base();    \n+\n+protected:\n+  void _M_initialize_map(size_t);\n+  void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n+  void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n+  enum { _S_initial_map_size = 8 };\n+\n+protected:\n+  iterator _M_start;\n+  iterator _M_finish;\n+};\n+\n+#else /* __STL_USE_STD_ALLOCATORS */\n+\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+class _Deque_base {\n+public:\n+#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n+  typedef _Deque_iterator<_Tp,_Tp&,_Tp*,__bufsiz>              iterator;\n+  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*, __bufsiz> const_iterator;\n+#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n+  typedef _Deque_iterator<_Tp,_Tp&,_Tp*>                      iterator;\n+  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*>          const_iterator;\n+#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n+\n+  typedef _Alloc allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+\n+  _Deque_base(const allocator_type&, size_t __num_elements)\n+    : _M_map(0), _M_map_size(0),  _M_start(), _M_finish() {\n+    _M_initialize_map(__num_elements);\n+  }\n+  _Deque_base(const allocator_type&)\n+    : _M_map(0), _M_map_size(0),  _M_start(), _M_finish() {}\n+  ~_Deque_base();    \n+\n+protected:\n+  void _M_initialize_map(size_t);\n+  void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n+  void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n+  enum { _S_initial_map_size = 8 };\n+\n+protected:\n+  _Tp** _M_map;\n+  size_t _M_map_size;  \n+  iterator _M_start;\n+  iterator _M_finish;\n+\n+  typedef simple_alloc<_Tp, _Alloc>  _Node_alloc_type;\n+  typedef simple_alloc<_Tp*, _Alloc> _Map_alloc_type;\n+\n+  _Tp* _M_allocate_node()\n+    { return _Node_alloc_type::allocate(__deque_buf_size(__bufsiz, \n+                                                         sizeof(_Tp))); }\n+  void _M_deallocate_node(_Tp* __p)\n+    { _Node_alloc_type::deallocate(__p, __deque_buf_size(__bufsiz, \n+                                                         sizeof(_Tp))); }\n+  _Tp** _M_allocate_map(size_t __n) \n+    { return _Map_alloc_type::allocate(__n); }\n+  void _M_deallocate_map(_Tp** __p, size_t __n) \n+    { _Map_alloc_type::deallocate(__p, __n); }\n+};\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+// Non-inline member functions from _Deque_base.\n+\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+_Deque_base<_Tp,_Alloc,__bufsiz>::~_Deque_base() {\n+  if (_M_map) {\n+    _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);\n+    _M_deallocate_map(_M_map, _M_map_size);\n+  }\n+}\n+\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+void\n+_Deque_base<_Tp,_Alloc,__bufsiz>::_M_initialize_map(size_t __num_elements)\n+{\n+  size_t __num_nodes = \n+    __num_elements / __deque_buf_size(__bufsiz, sizeof(_Tp)) + 1;\n+\n+  _M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2);\n+  _M_map = _M_allocate_map(_M_map_size);\n+\n+  _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2;\n+  _Tp** __nfinish = __nstart + __num_nodes;\n+    \n+  __STL_TRY {\n+    _M_create_nodes(__nstart, __nfinish);\n+  }\n+  __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), \n+                _M_map = 0, _M_map_size = 0));\n+  _M_start._M_set_node(__nstart);\n+  _M_finish._M_set_node(__nfinish - 1);\n+  _M_start._M_cur = _M_start._M_first;\n+  _M_finish._M_cur = _M_finish._M_first +\n+               __num_elements % __deque_buf_size(__bufsiz, sizeof(_Tp));\n+}\n+\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+void\n+_Deque_base<_Tp,_Alloc,__bufsiz>::_M_create_nodes(_Tp** __nstart,\n+                                                  _Tp** __nfinish)\n+{\n+  _Tp** __cur;\n+  __STL_TRY {\n+    for (__cur = __nstart; __cur < __nfinish; ++__cur)\n+      *__cur = _M_allocate_node();\n+  }\n+  __STL_UNWIND(_M_destroy_nodes(__nstart, __cur));\n+}\n+\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+void \n+_Deque_base<_Tp,_Alloc,__bufsiz>::_M_destroy_nodes(_Tp** __nstart,\n+                                                   _Tp** __nfinish)\n+{\n+  for (_Tp** __n = __nstart; __n < __nfinish; ++__n)\n+    _M_deallocate_node(*__n);\n+}\n+\n // See __deque_buf_size().  The only reason that the default value is 0\n //  is as a workaround for bugs in the way that some compilers handle\n //  constant expressions.\n-template <class T, class Alloc = alloc, size_t BufSiz = 0> \n-class deque {\n+template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp), \n+          size_t __bufsiz = 0> \n+class deque : protected _Deque_base<_Tp, _Alloc, __bufsiz> {\n+  typedef _Deque_base<_Tp, _Alloc, __bufsiz> _Base;\n public:                         // Basic types\n-  typedef T value_type;\n+  typedef _Tp value_type;\n   typedef value_type* pointer;\n   typedef const value_type* const_pointer;\n   typedef value_type& reference;\n   typedef const value_type& const_reference;\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type;\n \n+  typedef typename _Base::allocator_type allocator_type;\n+  allocator_type get_allocator() const { return _Base::get_allocator(); }\n+\n public:                         // Iterators\n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;\n-  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;\n-#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-  typedef __deque_iterator<T, T&, T*>                      iterator;\n-  typedef __deque_iterator<T, const T&, const T*>          const_iterator;\n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n+  typedef typename _Base::iterator       iterator;\n+  typedef typename _Base::const_iterator const_iterator;\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n   typedef reverse_iterator<const_iterator> const_reverse_iterator;\n@@ -281,1049 +507,1186 @@ class deque {\n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:                      // Internal typedefs\n-  typedef pointer* map_pointer;\n-  typedef simple_alloc<value_type, Alloc> data_allocator;\n-  typedef simple_alloc<pointer, Alloc> map_allocator;\n+  typedef pointer* _Map_pointer;\n+  static size_t _S_buffer_size()\n+    { return __deque_buf_size(__bufsiz, sizeof(_Tp)); }\n+\n+protected:\n+#ifdef __STL_USE_NAMESPACES\n+  using _Base::_M_initialize_map;\n+  using _Base::_M_create_nodes;\n+  using _Base::_M_destroy_nodes;\n+  using _Base::_M_allocate_node;\n+  using _Base::_M_deallocate_node;\n+  using _Base::_M_allocate_map;\n+  using _Base::_M_deallocate_map;\n+\n+  using _Base::_M_map;\n+  using _Base::_M_map_size;\n+  using _Base::_M_start;\n+  using _Base::_M_finish;\n+#endif /* __STL_USE_NAMESPACES */\n \n-  static size_type buffer_size() {\n-    return __deque_buf_size(BufSiz, sizeof(value_type));\n+public:                         // Basic accessors\n+  iterator begin() { return _M_start; }\n+  iterator end() { return _M_finish; }\n+  const_iterator begin() const { return _M_start; }\n+  const_iterator end() const { return _M_finish; }\n+\n+  reverse_iterator rbegin() { return reverse_iterator(_M_finish); }\n+  reverse_iterator rend() { return reverse_iterator(_M_start); }\n+  const_reverse_iterator rbegin() const \n+    { return const_reverse_iterator(_M_finish); }\n+  const_reverse_iterator rend() const \n+    { return const_reverse_iterator(_M_start); }\n+\n+  reference operator[](size_type __n)\n+    { return _M_start[difference_type(__n)]; }\n+  const_reference operator[](size_type __n) const \n+    { return _M_start[difference_type(__n)]; }\n+\n+  reference front() { return *_M_start; }\n+  reference back() {\n+    iterator __tmp = _M_finish;\n+    --__tmp;\n+    return *__tmp;\n+  }\n+  const_reference front() const { return *_M_start; }\n+  const_reference back() const {\n+    const_iterator __tmp = _M_finish;\n+    --__tmp;\n+    return *__tmp;\n   }\n-  static size_type initial_map_size() { return 8; }\n \n-protected:                      // Data members\n-  iterator start;\n-  iterator finish;\n+  size_type size() const { return _M_finish - _M_start;; }\n+  size_type max_size() const { return size_type(-1); }\n+  bool empty() const { return _M_finish == _M_start; }\n \n-  map_pointer map;\n-  size_type map_size;\n+public:                         // Constructor, destructor.\n+  explicit deque(const allocator_type& __a = allocator_type()) \n+    : _Base(__a, 0) {}\n+  deque(const deque& __x) : _Base(__x.get_allocator(), __x.size()) \n+    { uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n+  deque(size_type __n, const value_type& __value,\n+        const allocator_type& __a = allocator_type()) : _Base(__a, __n)\n+    { _M_fill_initialize(__value); }\n+  explicit deque(size_type __n) : _Base(allocator_type(), __n)\n+    { _M_fill_initialize(value_type()); }\n \n-public:                         // Basic accessors\n-  iterator begin() { return start; }\n-  iterator end() { return finish; }\n-  const_iterator begin() const { return start; }\n-  const_iterator end() const { return finish; }\n+#ifdef __STL_MEMBER_TEMPLATES\n \n-  reverse_iterator rbegin() { return reverse_iterator(finish); }\n-  reverse_iterator rend() { return reverse_iterator(start); }\n-  const_reverse_iterator rbegin() const {\n-    return const_reverse_iterator(finish);\n-  }\n-  const_reverse_iterator rend() const {\n-    return const_reverse_iterator(start);\n+  // Check whether it's an integral type.  If so, it's not an iterator.\n+  template <class _InputIterator>\n+  deque(_InputIterator __first, _InputIterator __last,\n+        const allocator_type& __a = allocator_type()) : _Base(__a) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_initialize_dispatch(__first, __last, _Integral());\n   }\n \n-  reference operator[](size_type n) { return start[difference_type(n)]; }\n-  const_reference operator[](size_type n) const {\n-    return start[difference_type(n)];\n+  template <class _Integer>\n+  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n+    _M_initialize_map(__n);\n+    _M_fill_initialize(__x);\n   }\n \n-  reference front() { return *start; }\n-  reference back() {\n-    iterator tmp = finish;\n-    --tmp;\n-    return *tmp;\n-  }\n-  const_reference front() const { return *start; }\n-  const_reference back() const {\n-    const_iterator tmp = finish;\n-    --tmp;\n-    return *tmp;\n+  template <class _InputIter>\n+  void _M_initialize_dispatch(_InputIter __first, _InputIter __last,\n+                              __false_type) {\n+    _M_range_initialize(__first, __last, __ITERATOR_CATEGORY(__first));\n   }\n \n-  size_type size() const { return finish - start;; }\n-  size_type max_size() const { return size_type(-1); }\n-  bool empty() const { return finish == start; }\n+#else /* __STL_MEMBER_TEMPLATES */\n \n-public:                         // Constructor, destructor.\n-  deque()\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(0);\n-  }\n+  deque(const value_type* __first, const value_type* __last,\n+        const allocator_type& __a = allocator_type()) \n+    : _Base(__a, __last - __first)\n+    { uninitialized_copy(__first, __last, _M_start); }\n+  deque(const_iterator __first, const_iterator __last,\n+        const allocator_type& __a = allocator_type()) \n+    : _Base(__a, __last - __first)\n+    { uninitialized_copy(__first, __last, _M_start); }\n \n-  deque(const deque& x)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(x.size());\n-    __STL_TRY {\n-      uninitialized_copy(x.begin(), x.end(), start);\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+  ~deque() { destroy(_M_start, _M_finish); }\n+\n+  deque& operator= (const deque& __x) {\n+    const size_type __len = size();\n+    if (&__x != this) {\n+      if (__len >= __x.size())\n+        erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);\n+      else {\n+        const_iterator __mid = __x.begin() + difference_type(__len);\n+        copy(__x.begin(), __mid, _M_start);\n+        insert(_M_finish, __mid, __x.end());\n+      }\n     }\n-    __STL_UNWIND(destroy_map_and_nodes());\n-  }\n+    return *this;\n+  }        \n \n-  deque(size_type n, const value_type& value)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    fill_initialize(n, value);\n+  void swap(deque& __x) {\n+    __STD::swap(_M_start, __x._M_start);\n+    __STD::swap(_M_finish, __x._M_finish);\n+    __STD::swap(_M_map, __x._M_map);\n+    __STD::swap(_M_map_size, __x._M_map_size);\n   }\n \n-  deque(int n, const value_type& value)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    fill_initialize(n, value);\n-  }\n- \n-  deque(long n, const value_type& value)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    fill_initialize(n, value);\n-  }\n+public: \n+  // assign(), a generalized assignment member function.  Two\n+  // versions: one that takes a count, and one that takes a range.\n+  // The range version is a member template, so we dispatch on whether\n+  // or not the type is an integer.\n \n-  explicit deque(size_type n)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    fill_initialize(n, value_type());\n+  void assign(size_type __n, const _Tp& __val) {\n+    if (__n > size()) {\n+      fill(begin(), end(), __val);\n+      insert(end(), __n - size(), __val);\n+    }\n+    else {\n+      erase(begin() + __n, end());\n+      fill(begin(), end(), __val);\n+    }\n   }\n \n #ifdef __STL_MEMBER_TEMPLATES\n \n-  template <class InputIterator>\n-  deque(InputIterator first, InputIterator last)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    range_initialize(first, last, iterator_category(first));\n+  template <class _InputIterator>\n+  void assign(_InputIterator __first, _InputIterator __last) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_assign_dispatch(__first, __last, _Integral());\n   }\n \n-#else /* __STL_MEMBER_TEMPLATES */\n+private:                        // helper functions for assign() \n \n-  deque(const value_type* first, const value_type* last)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(last - first);\n-    __STL_TRY {\n-      uninitialized_copy(first, last, start);\n-    }\n-    __STL_UNWIND(destroy_map_and_nodes());\n+  template <class _Integer>\n+  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+    { assign((size_type) __n, (_Tp) __val); }\n+\n+  template <class _InputIterator>\n+  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+                          __false_type) {\n+    _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first));\n   }\n \n-  deque(const_iterator first, const_iterator last)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(last - first);\n-    __STL_TRY {\n-      uninitialized_copy(first, last, start);\n+  template <class _InputIterator>\n+  void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+                     input_iterator_tag);\n+\n+  template <class _ForwardIterator>\n+  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+                     forward_iterator_tag) {\n+    size_type __len = 0;\n+    distance(__first, __last, __len);\n+    if (__len > size()) {\n+      _ForwardIterator __mid = __first;\n+      advance(__mid, size());\n+      copy(__first, __mid, begin());\n+      insert(end(), __mid, __last);\n     }\n-    __STL_UNWIND(destroy_map_and_nodes());\n+    else\n+      erase(copy(__first, __last, begin()), end());\n   }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  ~deque() {\n-    destroy(start, finish);\n-    destroy_map_and_nodes();\n+public:                         // push_* and pop_*\n+  \n+  void push_back(const value_type& __t) {\n+    if (_M_finish._M_cur != _M_finish._M_last - 1) {\n+      construct(_M_finish._M_cur, __t);\n+      ++_M_finish._M_cur;\n+    }\n+    else\n+      _M_push_back_aux(__t);\n   }\n \n-  deque& operator= (const deque& x) {\n-    const size_type len = size();\n-    if (&x != this) {\n-      if (len >= x.size())\n-        erase(copy(x.begin(), x.end(), start), finish);\n-      else {\n-        const_iterator mid = x.begin() + difference_type(len);\n-        copy(x.begin(), mid, start);\n-        insert(finish, mid, x.end());\n-      }\n+  void push_back() {\n+    if (_M_finish._M_cur != _M_finish._M_last - 1) {\n+      construct(_M_finish._M_cur);\n+      ++_M_finish._M_cur;\n     }\n-    return *this;\n-  }        \n-\n-  void swap(deque& x) {\n-    __STD::swap(start, x.start);\n-    __STD::swap(finish, x.finish);\n-    __STD::swap(map, x.map);\n-    __STD::swap(map_size, x.map_size);\n+    else\n+      _M_push_back_aux();\n   }\n \n-public:                         // push_* and pop_*\n-  \n-  void push_back(const value_type& t) {\n-    if (finish.cur != finish.last - 1) {\n-      construct(finish.cur, t);\n-      ++finish.cur;\n+  void push_front(const value_type& __t) {\n+    if (_M_start._M_cur != _M_start._M_first) {\n+      construct(_M_start._M_cur - 1, __t);\n+      --_M_start._M_cur;\n     }\n     else\n-      push_back_aux(t);\n+      _M_push_front_aux(__t);\n   }\n \n-  void push_front(const value_type& t) {\n-    if (start.cur != start.first) {\n-      construct(start.cur - 1, t);\n-      --start.cur;\n+  void push_front() {\n+    if (_M_start._M_cur != _M_start._M_first) {\n+      construct(_M_start._M_cur - 1);\n+      --_M_start._M_cur;\n     }\n     else\n-      push_front_aux(t);\n+      _M_push_front_aux();\n   }\n \n+\n   void pop_back() {\n-    if (finish.cur != finish.first) {\n-      --finish.cur;\n-      destroy(finish.cur);\n+    if (_M_finish._M_cur != _M_finish._M_first) {\n+      --_M_finish._M_cur;\n+      destroy(_M_finish._M_cur);\n     }\n     else\n-      pop_back_aux();\n+      _M_pop_back_aux();\n   }\n \n   void pop_front() {\n-    if (start.cur != start.last - 1) {\n-      destroy(start.cur);\n-      ++start.cur;\n+    if (_M_start._M_cur != _M_start._M_last - 1) {\n+      destroy(_M_start._M_cur);\n+      ++_M_start._M_cur;\n     }\n     else \n-      pop_front_aux();\n+      _M_pop_front_aux();\n   }\n \n public:                         // Insert\n \n-  iterator insert(iterator position, const value_type& x) {\n-    if (position.cur == start.cur) {\n-      push_front(x);\n-      return start;\n+  iterator insert(iterator position, const value_type& __x) {\n+    if (position._M_cur == _M_start._M_cur) {\n+      push_front(__x);\n+      return _M_start;\n     }\n-    else if (position.cur == finish.cur) {\n-      push_back(x);\n-      iterator tmp = finish;\n-      --tmp;\n-      return tmp;\n+    else if (position._M_cur == _M_finish._M_cur) {\n+      push_back(__x);\n+      iterator __tmp = _M_finish;\n+      --__tmp;\n+      return __tmp;\n     }\n     else {\n-      return insert_aux(position, x);\n+      return _M_insert_aux(position, __x);\n     }\n   }\n \n-  iterator insert(iterator position) { return insert(position, value_type()); }\n+  iterator insert(iterator __position)\n+    { return insert(__position, value_type()); }\n \n-  void insert(iterator pos, size_type n, const value_type& x); \n+  void insert(iterator __pos, size_type __n, const value_type& __x); \n \n-  void insert(iterator pos, int n, const value_type& x) {\n-    insert(pos, (size_type) n, x);\n-  }\n-  void insert(iterator pos, long n, const value_type& x) {\n-    insert(pos, (size_type) n, x);\n+#ifdef __STL_MEMBER_TEMPLATES  \n+\n+  // Check whether it's an integral type.  If so, it's not an iterator.\n+  template <class _InputIterator>\n+  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_insert_dispatch(__pos, __first, __last, _Integral());\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n+  template <class _Integer>\n+  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+                          __true_type) {\n+    insert(__pos, (size_type) __n, (value_type) __x);\n+  }\n \n-  template <class InputIterator>\n-  void insert(iterator pos, InputIterator first, InputIterator last) {\n-    insert(pos, first, last, iterator_category(first));\n+  template <class _InputIterator>\n+  void _M_insert_dispatch(iterator __pos,\n+                          _InputIterator __first, _InputIterator __last,\n+                          __false_type) {\n+    insert(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n   }\n \n #else /* __STL_MEMBER_TEMPLATES */\n \n-  void insert(iterator pos, const value_type* first, const value_type* last);\n-  void insert(iterator pos, const_iterator first, const_iterator last);\n+  void insert(iterator __pos,\n+              const value_type* __first, const value_type* __last);\n+  void insert(iterator __pos,\n+              const_iterator __first, const_iterator __last);\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  void resize(size_type new_size, const value_type& x) {\n-    const size_type len = size();\n-    if (new_size < len) \n-      erase(start + new_size, finish);\n+  void resize(size_type __new_size, const value_type& __x) {\n+    const size_type __len = size();\n+    if (__new_size < __len) \n+      erase(_M_start + __new_size, _M_finish);\n     else\n-      insert(finish, new_size - len, x);\n+      insert(_M_finish, __new_size - __len, __x);\n   }\n \n   void resize(size_type new_size) { resize(new_size, value_type()); }\n \n public:                         // Erase\n-  iterator erase(iterator pos) {\n-    iterator next = pos;\n-    ++next;\n-    difference_type index = pos - start;\n-    if (index < (size() >> 1)) {\n-      copy_backward(start, pos, next);\n+  iterator erase(iterator __pos) {\n+    iterator __next = __pos;\n+    ++__next;\n+    difference_type __index = __pos - _M_start;\n+    if (__index < (size() >> 1)) {\n+      copy_backward(_M_start, __pos, __next);\n       pop_front();\n     }\n     else {\n-      copy(next, finish, pos);\n+      copy(__next, _M_finish, __pos);\n       pop_back();\n     }\n-    return start + index;\n+    return _M_start + __index;\n   }\n \n-  iterator erase(iterator first, iterator last);\n+  iterator erase(iterator __first, iterator __last);\n   void clear(); \n \n protected:                        // Internal construction/destruction\n \n-  void create_map_and_nodes(size_type num_elements);\n-  void destroy_map_and_nodes();\n-  void fill_initialize(size_type n, const value_type& value);\n+  void _M_fill_initialize(const value_type& __value);\n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-  template <class InputIterator>\n-  void range_initialize(InputIterator first, InputIterator last,\n+  template <class _InputIterator>\n+  void _M_range_initialize(_InputIterator __first, _InputIterator __last,\n                         input_iterator_tag);\n \n-  template <class ForwardIterator>\n-  void range_initialize(ForwardIterator first, ForwardIterator last,\n+  template <class _ForwardIterator>\n+  void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                         forward_iterator_tag);\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n protected:                        // Internal push_* and pop_*\n \n-  void push_back_aux(const value_type& t);\n-  void push_front_aux(const value_type& t);\n-  void pop_back_aux();\n-  void pop_front_aux();\n+  void _M_push_back_aux(const value_type&);\n+  void _M_push_back_aux();\n+  void _M_push_front_aux(const value_type&);\n+  void _M_push_front_aux();\n+  void _M_pop_back_aux();\n+  void _M_pop_front_aux();\n \n protected:                        // Internal insert functions\n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-  template <class InputIterator>\n-  void insert(iterator pos, InputIterator first, InputIterator last,\n+  template <class _InputIterator>\n+  void insert(iterator __pos, _InputIterator __first, _InputIterator __last,\n               input_iterator_tag);\n \n-  template <class ForwardIterator>\n-  void insert(iterator pos, ForwardIterator first, ForwardIterator last,\n+  template <class _ForwardIterator>\n+  void insert(iterator __pos,\n+              _ForwardIterator __first, _ForwardIterator __last,\n               forward_iterator_tag);\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  iterator insert_aux(iterator pos, const value_type& x);\n-  void insert_aux(iterator pos, size_type n, const value_type& x);\n+  iterator _M_insert_aux(iterator __pos, const value_type& __x);\n+  iterator _M_insert_aux(iterator __pos);\n+  void _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-  template <class ForwardIterator>\n-  void insert_aux(iterator pos, ForwardIterator first, ForwardIterator last,\n-                  size_type n);\n+  template <class _ForwardIterator>\n+  void _M_insert_aux(iterator __pos, \n+                     _ForwardIterator __first, _ForwardIterator __last,\n+                     size_type __n);\n \n #else /* __STL_MEMBER_TEMPLATES */\n   \n-  void insert_aux(iterator pos,\n-                  const value_type* first, const value_type* last,\n-                  size_type n);\n+  void _M_insert_aux(iterator __pos,\n+                     const value_type* __first, const value_type* __last,\n+                     size_type __n);\n \n-  void insert_aux(iterator pos, const_iterator first, const_iterator last,\n-                  size_type n);\n+  void _M_insert_aux(iterator __pos, \n+                     const_iterator __first, const_iterator __last,\n+                     size_type __n);\n  \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  iterator reserve_elements_at_front(size_type n) {\n-    size_type vacancies = start.cur - start.first;\n-    if (n > vacancies) \n-      new_elements_at_front(n - vacancies);\n-    return start - difference_type(n);\n+  iterator _M_reserve_elements_at_front(size_type __n) {\n+    size_type __vacancies = _M_start._M_cur - _M_start._M_first;\n+    if (__n > __vacancies) \n+      _M_new_elements_at_front(__n - __vacancies);\n+    return _M_start - difference_type(__n);\n   }\n \n-  iterator reserve_elements_at_back(size_type n) {\n-    size_type vacancies = (finish.last - finish.cur) - 1;\n-    if (n > vacancies)\n-      new_elements_at_back(n - vacancies);\n-    return finish + difference_type(n);\n+  iterator _M_reserve_elements_at_back(size_type __n) {\n+    size_type __vacancies = (_M_finish._M_last - _M_finish._M_cur) - 1;\n+    if (__n > __vacancies)\n+      _M_new_elements_at_back(__n - __vacancies);\n+    return _M_finish + difference_type(__n);\n   }\n \n-  void new_elements_at_front(size_type new_elements);\n-  void new_elements_at_back(size_type new_elements);\n+  void _M_new_elements_at_front(size_type __new_elements);\n+  void _M_new_elements_at_back(size_type __new_elements);\n \n-  void destroy_nodes_at_front(iterator before_start);\n-  void destroy_nodes_at_back(iterator after_finish);\n+protected:                      // Allocation of _M_map and nodes\n \n-protected:                      // Allocation of map and nodes\n-\n-  // Makes sure the map has space for new nodes.  Does not actually\n-  //  add the nodes.  Can invalidate map pointers.  (And consequently, \n+  // Makes sure the _M_map has space for new nodes.  Does not actually\n+  //  add the nodes.  Can invalidate _M_map pointers.  (And consequently, \n   //  deque iterators.)\n \n-  void reserve_map_at_back (size_type nodes_to_add = 1) {\n-    if (nodes_to_add + 1 > map_size - (finish.node - map))\n-      reallocate_map(nodes_to_add, false);\n-  }\n-\n-  void reserve_map_at_front (size_type nodes_to_add = 1) {\n-    if (nodes_to_add > start.node - map)\n-      reallocate_map(nodes_to_add, true);\n+  void _M_reserve_map_at_back (size_type __nodes_to_add = 1) {\n+    if (__nodes_to_add + 1 > _M_map_size - (_M_finish._M_node - _M_map))\n+      _M_reallocate_map(__nodes_to_add, false);\n   }\n \n-  void reallocate_map(size_type nodes_to_add, bool add_at_front);\n-\n-  pointer allocate_node() { return data_allocator::allocate(buffer_size()); }\n-  void deallocate_node(pointer n) {\n-    data_allocator::deallocate(n, buffer_size());\n+  void _M_reserve_map_at_front (size_type __nodes_to_add = 1) {\n+    if (__nodes_to_add > size_type(_M_start._M_node - _M_map))\n+      _M_reallocate_map(__nodes_to_add, true);\n   }\n \n+  void _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n+ \n #ifdef __STL_NON_TYPE_TMPL_PARAM_BUG\n public:\n-  bool operator==(const deque<T, Alloc, 0>& x) const {\n-    return size() == x.size() && equal(begin(), end(), x.begin());\n+  bool operator==(const deque<_Tp,_Alloc,0>& __x) const {\n+    return size() == __x.size() && equal(begin(), end(), __x.begin());\n   }\n-  bool operator!=(const deque<T, Alloc, 0>& x) const {\n-    return size() != x.size() || !equal(begin(), end(), x.begin());\n+  bool operator!=(const deque<_Tp,_Alloc,0>& __x) const {\n+    return size() != __x.size() || !equal(begin(), end(), __x.begin());\n   }\n-  bool operator<(const deque<T, Alloc, 0>& x) const {\n-    return lexicographical_compare(begin(), end(), x.begin(), x.end());\n+  bool operator<(const deque<_Tp,_Alloc,0>& __x) const {\n+    return lexicographical_compare(begin(), end(), __x.begin(), __x.end());\n   }\n #endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n };\n \n // Non-inline member functions\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      size_type n, const value_type& x) {\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    uninitialized_fill(new_start, start, x);\n-    start = new_start;\n+#ifdef __STL_MEMBER_TEMPLATES\n+\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+template <class _InputIter>\n+void deque<_Tp, _Alloc, __bufsize>\n+  ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n+{\n+  iterator __cur = begin();\n+  for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+    *__cur = *__first;\n+  if (__first == __last)\n+    erase(__cur, end());\n+  else\n+    insert(end(), __first, __last);\n+}\n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp, _Alloc, __bufsize>::insert(iterator __pos,\n+                                      size_type __n, const value_type& __x)\n+{\n+  if (__pos._M_cur == _M_start._M_cur) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n+    uninitialized_fill(__new_start, _M_start, __x);\n+    _M_start = __new_start;\n   }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    uninitialized_fill(finish, new_finish, x);\n-    finish = new_finish;\n+  else if (__pos._M_cur == _M_finish._M_cur) {\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n+    uninitialized_fill(_M_finish, __new_finish, __x);\n+    _M_finish = __new_finish;\n   }\n   else \n-    insert_aux(pos, n, x);\n+    _M_insert_aux(__pos, __n, __x);\n }\n \n #ifndef __STL_MEMBER_TEMPLATES  \n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      const value_type* first,\n-                                      const value_type* last) {\n-  size_type n = last - first;\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void deque<_Tp, _Alloc, __bufsize>::insert(iterator __pos,\n+                                           const value_type* __first,\n+                                           const value_type* __last) {\n+  size_type __n = __last - __first;\n+  if (__pos._M_cur == _M_start._M_cur) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n     __STL_TRY {\n-      uninitialized_copy(first, last, new_start);\n-      start = new_start;\n+      uninitialized_copy(__first, __last, __new_start);\n+      _M_start = __new_start;\n     }\n-    __STL_UNWIND(destroy_nodes_at_front(new_start));\n+    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n   }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n+  else if (__pos._M_cur == _M_finish._M_cur) {\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n     __STL_TRY {\n-      uninitialized_copy(first, last, finish);\n-      finish = new_finish;\n+      uninitialized_copy(__first, __last, _M_finish);\n+      _M_finish = __new_finish;\n     }\n-    __STL_UNWIND(destroy_nodes_at_back(new_finish));\n+    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n+                                  __new_finish._M_node + 1));\n   }\n   else\n-    insert_aux(pos, first, last, n);\n+    _M_insert_aux(__pos, __first, __last, __n);\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      const_iterator first,\n-                                      const_iterator last)\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n+                                         const_iterator __first,\n+                                         const_iterator __last)\n {\n-  size_type n = last - first;\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n+  size_type __n = __last - __first;\n+  if (__pos._M_cur == _M_start._M_cur) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n     __STL_TRY {\n-      uninitialized_copy(first, last, new_start);\n-      start = new_start;\n+      uninitialized_copy(__first, __last, __new_start);\n+      _M_start = __new_start;\n     }\n-    __STL_UNWIND(destroy_nodes_at_front(new_start));\n+    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n   }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n+  else if (__pos._M_cur == _M_finish._M_cur) {\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n     __STL_TRY {\n-      uninitialized_copy(first, last, finish);\n-      finish = new_finish;\n+      uninitialized_copy(__first, __last, _M_finish);\n+      _M_finish = __new_finish;\n     }\n-    __STL_UNWIND(destroy_nodes_at_back(new_finish));\n+    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n+                 __new_finish._M_node + 1));\n   }\n   else\n-    insert_aux(pos, first, last, n);\n+    _M_insert_aux(__pos, __first, __last, __n);\n }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class T, class Alloc, size_t BufSize>\n-deque<T, Alloc, BufSize>::iterator \n-deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {\n-  if (first == start && last == finish) {\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+deque<_Tp,_Alloc,__bufsize>::iterator \n+deque<_Tp,_Alloc,__bufsize>::erase(iterator __first, iterator __last)\n+{\n+  if (__first == _M_start && __last == _M_finish) {\n     clear();\n-    return finish;\n+    return _M_finish;\n   }\n   else {\n-    difference_type n = last - first;\n-    difference_type elems_before = first - start;\n-    if (elems_before < (size() - n) / 2) {\n-      copy_backward(start, first, last);\n-      iterator new_start = start + n;\n-      destroy(start, new_start);\n-      for (map_pointer cur = start.node; cur < new_start.node; ++cur)\n-        data_allocator::deallocate(*cur, buffer_size());\n-      start = new_start;\n+    difference_type __n = __last - __first;\n+    difference_type __elems_before = __first - _M_start;\n+    if (__elems_before < (size() - __n) / 2) {\n+      copy_backward(_M_start, __first, __last);\n+      iterator __new_start = _M_start + __n;\n+      destroy(_M_start, __new_start);\n+      _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+      _M_start = __new_start;\n     }\n     else {\n-      copy(last, finish, first);\n-      iterator new_finish = finish - n;\n-      destroy(new_finish, finish);\n-      for (map_pointer cur = new_finish.node + 1; cur <= finish.node; ++cur)\n-        data_allocator::deallocate(*cur, buffer_size());\n-      finish = new_finish;\n+      copy(__last, _M_finish, __first);\n+      iterator __new_finish = _M_finish - __n;\n+      destroy(__new_finish, _M_finish);\n+      _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);\n+      _M_finish = __new_finish;\n     }\n-    return start + elems_before;\n+    return _M_start + __elems_before;\n   }\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::clear() {\n-  for (map_pointer node = start.node + 1; node < finish.node; ++node) {\n-    destroy(*node, *node + buffer_size());\n-    data_allocator::deallocate(*node, buffer_size());\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void deque<_Tp,_Alloc,__bufsize>::clear()\n+{\n+  for (_Map_pointer __node = _M_start._M_node + 1;\n+       __node < _M_finish._M_node;\n+       ++__node) {\n+    destroy(*__node, *__node + _S_buffer_size());\n+    _M_deallocate_node(*__node);\n   }\n \n-  if (start.node != finish.node) {\n-    destroy(start.cur, start.last);\n-    destroy(finish.first, finish.cur);\n-    data_allocator::deallocate(finish.first, buffer_size());\n+  if (_M_start._M_node != _M_finish._M_node) {\n+    destroy(_M_start._M_cur, _M_start._M_last);\n+    destroy(_M_finish._M_first, _M_finish._M_cur);\n+    _M_deallocate_node(_M_finish._M_first);\n   }\n   else\n-    destroy(start.cur, finish.cur);\n+    destroy(_M_start._M_cur, _M_finish._M_cur);\n \n-  finish = start;\n+  _M_finish = _M_start;\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {\n-  size_type num_nodes = num_elements / buffer_size() + 1;\n-\n-  map_size = max(initial_map_size(), num_nodes + 2);\n-  map = map_allocator::allocate(map_size);\n-\n-  map_pointer nstart = map + (map_size - num_nodes) / 2;\n-  map_pointer nfinish = nstart + num_nodes - 1;\n-    \n-  map_pointer cur;\n+// Precondition: _M_start and _M_finish have already been initialized,\n+// but none of the deque's elements have yet been constructed.\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_fill_initialize(const value_type& __value) {\n+  _Map_pointer __cur;\n   __STL_TRY {\n-    for (cur = nstart; cur <= nfinish; ++cur)\n-      *cur = allocate_node();\n-  }\n-#     ifdef  __STL_USE_EXCEPTIONS \n-  catch(...) {\n-    for (map_pointer n = nstart; n < cur; ++n)\n-      deallocate_node(*n);\n-    map_allocator::deallocate(map, map_size);\n-    throw;\n+    for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n+      uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n+    uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n   }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-\n-  start.set_node(nstart);\n-  finish.set_node(nfinish);\n-  start.cur = start.first;\n-  finish.cur = finish.first + num_elements % buffer_size();\n+  __STL_UNWIND(destroy(_M_start, iterator(*__cur, __cur)));\n }\n \n-// This is only used as a cleanup function in catch clauses.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::destroy_map_and_nodes() {\n-  for (map_pointer cur = start.node; cur <= finish.node; ++cur)\n-    deallocate_node(*cur);\n-  map_allocator::deallocate(map, map_size);\n+#ifdef __STL_MEMBER_TEMPLATES  \n+\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+template <class _InputIterator>\n+void\n+deque<_Tp,_Alloc,__bufsize>::_M_range_initialize(_InputIterator __first,\n+                                                 _InputIterator __last,\n+                                                 input_iterator_tag)\n+{\n+  _M_initialize_map(0);\n+  for ( ; __first != __last; ++__first)\n+    push_back(*__first);\n }\n-  \n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::fill_initialize(size_type n,\n-                                               const value_type& value) {\n-  create_map_and_nodes(n);\n-  map_pointer cur;\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+template <class _ForwardIterator>\n+void\n+deque<_Tp,_Alloc,__bufsize>::_M_range_initialize(_ForwardIterator __first,\n+                                                 _ForwardIterator __last,\n+                                                 forward_iterator_tag)\n+{\n+  size_type __n = 0;\n+  distance(__first, __last, __n);\n+  _M_initialize_map(__n);\n+\n+  _Map_pointer __cur_node;\n   __STL_TRY {\n-    for (cur = start.node; cur < finish.node; ++cur)\n-      uninitialized_fill(*cur, *cur + buffer_size(), value);\n-    uninitialized_fill(finish.first, finish.cur, value);\n-  }\n-#       ifdef __STL_USE_EXCEPTIONS\n-  catch(...) {\n-    for (map_pointer n = start.node; n < cur; ++n)\n-      destroy(*n, *n + buffer_size());\n-    destroy_map_and_nodes();\n-    throw;\n+    for (__cur_node = _M_start._M_node; \n+         __cur_node < _M_finish._M_node; \n+\t ++__cur_node) {\n+      _ForwardIterator __mid = __first;\n+      advance(__mid, _S_buffer_size());\n+      uninitialized_copy(__first, __mid, *__cur_node);\n+      __first = __mid;\n+    }\n+    uninitialized_copy(__first, __last, _M_finish._M_first);\n   }\n-#       endif /* __STL_USE_EXCEPTIONS */\n+  __STL_UNWIND(destroy(_M_start, iterator(*__cur_node, __cur_node)));\n }\n \n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-template <class T, class Alloc, size_t BufSize>\n-template <class InputIterator>\n-void deque<T, Alloc, BufSize>::range_initialize(InputIterator first,\n-                                                InputIterator last,\n-                                                input_iterator_tag) {\n-  create_map_and_nodes(0);\n-  for ( ; first != last; ++first)\n-    push_back(*first);\n-}\n+#endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class T, class Alloc, size_t BufSize>\n-template <class ForwardIterator>\n-void deque<T, Alloc, BufSize>::range_initialize(ForwardIterator first,\n-                                                ForwardIterator last,\n-                                                forward_iterator_tag) {\n-  size_type n = 0;\n-  distance(first, last, n);\n-  create_map_and_nodes(n);\n+// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void\n+deque<_Tp,_Alloc,__bufsize>::_M_push_back_aux(const value_type& __t)\n+{\n+  value_type __t_copy = __t;\n+  _M_reserve_map_at_back();\n+  *(_M_finish._M_node + 1) = _M_allocate_node();\n   __STL_TRY {\n-    uninitialized_copy(first, last, start);\n+    construct(_M_finish._M_cur, __t_copy);\n+    _M_finish._M_set_node(_M_finish._M_node + 1);\n+    _M_finish._M_cur = _M_finish._M_first;\n   }\n-  __STL_UNWIND(destroy_map_and_nodes());\n+  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));\n }\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-// Called only if finish.cur == finish.last - 1.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) {\n-  value_type t_copy = t;\n-  reserve_map_at_back();\n-  *(finish.node + 1) = allocate_node();\n+// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void\n+deque<_Tp,_Alloc,__bufsize>::_M_push_back_aux()\n+{\n+  _M_reserve_map_at_back();\n+  *(_M_finish._M_node + 1) = _M_allocate_node();\n   __STL_TRY {\n-    construct(finish.cur, t_copy);\n-    finish.set_node(finish.node + 1);\n-    finish.cur = finish.first;\n+    construct(_M_finish._M_cur);\n+    _M_finish._M_set_node(_M_finish._M_node + 1);\n+    _M_finish._M_cur = _M_finish._M_first;\n   }\n-  __STL_UNWIND(deallocate_node(*(finish.node + 1)));\n+  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));\n }\n \n-// Called only if start.cur == start.first.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) {\n-  value_type t_copy = t;\n-  reserve_map_at_front();\n-  *(start.node - 1) = allocate_node();\n+// Called only if _M_start._M_cur == _M_start._M_first.\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_push_front_aux(const value_type& __t)\n+{\n+  value_type __t_copy = __t;\n+  _M_reserve_map_at_front();\n+  *(_M_start._M_node - 1) = _M_allocate_node();\n   __STL_TRY {\n-    start.set_node(start.node - 1);\n-    start.cur = start.last - 1;\n-    construct(start.cur, t_copy);\n+    _M_start._M_set_node(_M_start._M_node - 1);\n+    _M_start._M_cur = _M_start._M_last - 1;\n+    construct(_M_start._M_cur, __t_copy);\n   }\n-#     ifdef __STL_USE_EXCEPTIONS\n-  catch(...) {\n-    start.set_node(start.node + 1);\n-    start.cur = start.first;\n-    deallocate_node(*(start.node - 1));\n-    throw;\n+  __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));\n+} \n+\n+// Called only if _M_start._M_cur == _M_start._M_first.\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_push_front_aux()\n+{\n+  _M_reserve_map_at_front();\n+  *(_M_start._M_node - 1) = _M_allocate_node();\n+  __STL_TRY {\n+    _M_start._M_set_node(_M_start._M_node - 1);\n+    _M_start._M_cur = _M_start._M_last - 1;\n+    construct(_M_start._M_cur);\n   }\n-#     endif /* __STL_USE_EXCEPTIONS */\n+  __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));\n } \n \n-// Called only if finish.cur == finish.first.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>:: pop_back_aux() {\n-  deallocate_node(finish.first);\n-  finish.set_node(finish.node - 1);\n-  finish.cur = finish.last - 1;\n-  destroy(finish.cur);\n+// Called only if _M_finish._M_cur == _M_finish._M_first.\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_pop_back_aux()\n+{\n+  _M_deallocate_node(_M_finish._M_first);\n+  _M_finish._M_set_node(_M_finish._M_node - 1);\n+  _M_finish._M_cur = _M_finish._M_last - 1;\n+  destroy(_M_finish._M_cur);\n }\n \n-// Called only if start.cur == start.last - 1.  Note that if the deque\n-//  has at least one element (a necessary precondition for this member\n-//  function), and if start.cur == start.last, then the deque must have\n-//  at least two nodes.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::pop_front_aux() {\n-  destroy(start.cur);\n-  deallocate_node(start.first);\n-  start.set_node(start.node + 1);\n-  start.cur = start.first;\n+// Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n+// if the deque has at least one element (a precondition for this member \n+// function), and if _M_start._M_cur == _M_start._M_last, then the deque \n+// must have at least two nodes.\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_pop_front_aux()\n+{\n+  destroy(_M_start._M_cur);\n+  _M_deallocate_node(_M_start._M_first);\n+  _M_start._M_set_node(_M_start._M_node + 1);\n+  _M_start._M_cur = _M_start._M_first;\n }      \n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-template <class T, class Alloc, size_t BufSize>\n-template <class InputIterator>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      InputIterator first, InputIterator last,\n-                                      input_iterator_tag) {\n-  copy(first, last, inserter(*this, pos));\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+template <class _InputIterator>\n+void \n+deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n+                                    _InputIterator __first,\n+                                    _InputIterator __last,\n+                                    input_iterator_tag)\n+{\n+  copy(__first, __last, inserter(*this, __pos));\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-template <class ForwardIterator>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      ForwardIterator first,\n-                                      ForwardIterator last,\n-                                      forward_iterator_tag) {\n-  size_type n = 0;\n-  distance(first, last, n);\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+template <class _ForwardIterator>\n+void \n+deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n+                                    _ForwardIterator __first,\n+                                    _ForwardIterator __last,\n+                                    forward_iterator_tag) {\n+  size_type __n = 0;\n+  distance(__first, __last, __n);\n+  if (__pos._M_cur == _M_start._M_cur) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n     __STL_TRY {\n-      uninitialized_copy(first, last, new_start);\n-      start = new_start;\n+      uninitialized_copy(__first, __last, __new_start);\n+      _M_start = __new_start;\n     }\n-    __STL_UNWIND(destroy_nodes_at_front(new_start));\n+    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n   }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n+  else if (__pos._M_cur == _M_finish._M_cur) {\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n     __STL_TRY {\n-      uninitialized_copy(first, last, finish);\n-      finish = new_finish;\n+      uninitialized_copy(__first, __last, _M_finish);\n+      _M_finish = __new_finish;\n     }\n-    __STL_UNWIND(destroy_nodes_at_back(new_finish));\n+    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n+                                  __new_finish._M_node + 1));\n   }\n   else\n-    insert_aux(pos, first, last, n);\n+    _M_insert_aux(__pos, __first, __last, __n);\n }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class T, class Alloc, size_t BufSize>\n-typename deque<T, Alloc, BufSize>::iterator\n-deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) {\n-  difference_type index = pos - start;\n-  value_type x_copy = x;\n-  if (index < size() / 2) {\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+typename deque<_Tp, _Alloc, __bufsize>::iterator\n+deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n+                                           const value_type& __x)\n+{\n+  difference_type __index = __pos - _M_start;\n+  value_type __x_copy = __x;\n+  if (__index < size() / 2) {\n+    push_front(front());\n+    iterator __front1 = _M_start;\n+    ++__front1;\n+    iterator __front2 = __front1;\n+    ++__front2;\n+    __pos = _M_start + __index;\n+    iterator __pos1 = __pos;\n+    ++__pos1;\n+    copy(__front2, __pos1, __front1);\n+  }\n+  else {\n+    push_back(back());\n+    iterator __back1 = _M_finish;\n+    --__back1;\n+    iterator __back2 = __back1;\n+    --__back2;\n+    __pos = _M_start + __index;\n+    copy_backward(__pos, __back2, __back1);\n+  }\n+  *__pos = __x_copy;\n+  return __pos;\n+}\n+\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+typename deque<_Tp,_Alloc,__bufsize>::iterator\n+deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos)\n+{\n+  difference_type __index = __pos - _M_start;\n+  if (__index < size() / 2) {\n     push_front(front());\n-    iterator front1 = start;\n-    ++front1;\n-    iterator front2 = front1;\n-    ++front2;\n-    pos = start + index;\n-    iterator pos1 = pos;\n-    ++pos1;\n-    copy(front2, pos1, front1);\n+    iterator __front1 = _M_start;\n+    ++__front1;\n+    iterator __front2 = __front1;\n+    ++__front2;\n+    __pos = _M_start + __index;\n+    iterator __pos1 = __pos;\n+    ++__pos1;\n+    copy(__front2, __pos1, __front1);\n   }\n   else {\n     push_back(back());\n-    iterator back1 = finish;\n-    --back1;\n-    iterator back2 = back1;\n-    --back2;\n-    pos = start + index;\n-    copy_backward(pos, back2, back1);\n-  }\n-  *pos = x_copy;\n-  return pos;\n+    iterator __back1 = _M_finish;\n+    --__back1;\n+    iterator __back2 = __back1;\n+    --__back2;\n+    __pos = _M_start + __index;\n+    copy_backward(__pos, __back2, __back1);\n+  }\n+  *__pos = value_type();\n+  return __pos;\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          size_type n, const value_type& x) {\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  value_type x_copy = x;\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void\n+deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n+                                           size_type __n,\n+                                           const value_type& __x)\n+{\n+  const difference_type __elems_before = __pos - _M_start;\n+  size_type __length = size();\n+  value_type __x_copy = __x;\n+  if (__elems_before < __length / 2) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n+    iterator __old_start = _M_start;\n+    __pos = _M_start + __elems_before;\n     __STL_TRY {\n-      if (elems_before >= difference_type(n)) {\n-        iterator start_n = start + difference_type(n);\n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        fill(pos - difference_type(n), pos, x_copy);\n+      if (__elems_before >= difference_type(__n)) {\n+        iterator __start_n = _M_start + difference_type(__n);\n+        uninitialized_copy(_M_start, __start_n, __new_start);\n+        _M_start = __new_start;\n+        copy(__start_n, __pos, __old_start);\n+        fill(__pos - difference_type(__n), __pos, __x_copy);\n       }\n       else {\n-        __uninitialized_copy_fill(start, pos, new_start, start, x_copy);\n-        start = new_start;\n-        fill(old_start, pos, x_copy);\n+        __uninitialized_copy_fill(_M_start, __pos, __new_start, \n+\t                          _M_start, __x_copy);\n+        _M_start = __new_start;\n+        fill(__old_start, __pos, __x_copy);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_front(new_start));\n+    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n   }\n   else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = difference_type(length) - elems_before;\n-    pos = finish - elems_after;\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n+    iterator __old_finish = _M_finish;\n+    const difference_type __elems_after = \n+      difference_type(__length) - __elems_before;\n+    __pos = _M_finish - __elems_after;\n     __STL_TRY {\n-      if (elems_after > difference_type(n)) {\n-        iterator finish_n = finish - difference_type(n);\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        fill(pos, pos + difference_type(n), x_copy);\n+      if (__elems_after > difference_type(__n)) {\n+        iterator __finish_n = _M_finish - difference_type(__n);\n+        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n+        _M_finish = __new_finish;\n+        copy_backward(__pos, __finish_n, __old_finish);\n+        fill(__pos, __pos + difference_type(__n), __x_copy);\n       }\n       else {\n-        __uninitialized_fill_copy(finish, pos + difference_type(n),\n-                                  x_copy,\n-                                  pos, finish);\n-        finish = new_finish;\n-        fill(pos, old_finish, x_copy);\n+        __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),\n+                                  __x_copy, __pos, _M_finish);\n+        _M_finish = __new_finish;\n+        fill(__pos, __old_finish, __x_copy);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_back(new_finish));\n+    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n+                                  __new_finish._M_node + 1));\n   }\n }\n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-template <class T, class Alloc, size_t BufSize>\n-template <class ForwardIterator>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          ForwardIterator first,\n-                                          ForwardIterator last,\n-                                          size_type n)\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+template <class _ForwardIterator>\n+void\n+deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n+                                           _ForwardIterator __first,\n+                                           _ForwardIterator __last,\n+                                           size_type __n)\n {\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n+  const difference_type __elemsbefore = __pos - _M_start;\n+  size_type __length = size();\n+  if (__elemsbefore < __length / 2) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n+    iterator __old_start = _M_start;\n+    __pos = _M_start + __elemsbefore;\n     __STL_TRY {\n-      if (elems_before >= difference_type(n)) {\n-        iterator start_n = start + difference_type(n); \n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        copy(first, last, pos - difference_type(n));\n+      if (__elemsbefore >= difference_type(__n)) {\n+        iterator __start_n = _M_start + difference_type(__n); \n+        uninitialized_copy(_M_start, __start_n, __new_start);\n+        _M_start = __new_start;\n+        copy(__start_n, __pos, __old_start);\n+        copy(__first, __last, __pos - difference_type(__n));\n       }\n       else {\n-        ForwardIterator mid = first;\n-        advance(mid, difference_type(n) - elems_before);\n-        __uninitialized_copy_copy(start, pos, first, mid, new_start);\n-        start = new_start;\n-        copy(mid, last, old_start);\n+        _ForwardIterator __mid = __first;\n+        advance(__mid, difference_type(__n) - __elemsbefore);\n+        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n+                                  __new_start);\n+        _M_start = __new_start;\n+        copy(__mid, __last, __old_start);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_front(new_start));\n+    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n   }\n   else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = difference_type(length) - elems_before;\n-    pos = finish - elems_after;\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n+    iterator __old_finish = _M_finish;\n+    const difference_type __elemsafter = \n+      difference_type(__length) - __elemsbefore;\n+    __pos = _M_finish - __elemsafter;\n     __STL_TRY {\n-      if (elems_after > difference_type(n)) {\n-        iterator finish_n = finish - difference_type(n);\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        copy(first, last, pos);\n+      if (__elemsafter > difference_type(__n)) {\n+        iterator __finish_n = _M_finish - difference_type(__n);\n+        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n+        _M_finish = __new_finish;\n+        copy_backward(__pos, __finish_n, __old_finish);\n+        copy(__first, __last, __pos);\n       }\n       else {\n-        ForwardIterator mid = first;\n-        advance(mid, elems_after);\n-        __uninitialized_copy_copy(mid, last, pos, finish, finish);\n-        finish = new_finish;\n-        copy(first, mid, pos);\n+        _ForwardIterator __mid = __first;\n+        advance(__mid, __elemsafter);\n+        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);\n+        _M_finish = __new_finish;\n+        copy(__first, __mid, __pos);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_back(new_finish));\n+    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n+                                  __new_finish._M_node + 1));\n   }\n }\n \n #else /* __STL_MEMBER_TEMPLATES */\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          const value_type* first,\n-                                          const value_type* last,\n-                                          size_type n)\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n+                                           const value_type* __first,\n+                                           const value_type* __last,\n+                                           size_type __n)\n {\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n+  const difference_type __elemsbefore = __pos - _M_start;\n+  size_type __length = size();\n+  if (__elemsbefore < __length / 2) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n+    iterator __old_start = _M_start;\n+    __pos = _M_start + __elemsbefore;\n     __STL_TRY {\n-      if (elems_before >= difference_type(n)) {\n-        iterator start_n = start + difference_type(n);\n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        copy(first, last, pos - difference_type(n));\n+      if (__elemsbefore >= difference_type(__n)) {\n+        iterator __start_n = _M_start + difference_type(__n);\n+        uninitialized_copy(_M_start, __start_n, __new_start);\n+        _M_start = __new_start;\n+        copy(__start_n, __pos, __old_start);\n+        copy(__first, __last, __pos - difference_type(__n));\n       }\n       else {\n-        const value_type* mid = first + (difference_type(n) - elems_before);\n-        __uninitialized_copy_copy(start, pos, first, mid, new_start);\n-        start = new_start;\n-        copy(mid, last, old_start);\n+        const value_type* __mid = \n+\t  __first + (difference_type(__n) - __elemsbefore);\n+        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n+                                  __new_start);\n+        _M_start = __new_start;\n+        copy(__mid, __last, __old_start);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_front(new_start));\n+    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n   }\n   else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = difference_type(length) - elems_before;\n-    pos = finish - elems_after;\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n+    iterator __old_finish = _M_finish;\n+    const difference_type __elemsafter = \n+      difference_type(__length) - __elemsbefore;\n+    __pos = _M_finish - __elemsafter;\n     __STL_TRY {\n-      if (elems_after > difference_type(n)) {\n-        iterator finish_n = finish - difference_type(n);\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        copy(first, last, pos);\n+      if (__elemsafter > difference_type(__n)) {\n+        iterator __finish_n = _M_finish - difference_type(__n);\n+        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n+        _M_finish = __new_finish;\n+        copy_backward(__pos, __finish_n, __old_finish);\n+        copy(__first, __last, __pos);\n       }\n       else {\n-        const value_type* mid = first + elems_after;\n-        __uninitialized_copy_copy(mid, last, pos, finish, finish);\n-        finish = new_finish;\n-        copy(first, mid, pos);\n+        const value_type* __mid = __first + __elemsafter;\n+        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);\n+        _M_finish = __new_finish;\n+        copy(__first, __mid, __pos);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_back(new_finish));\n+    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n+                                  __new_finish._M_node + 1));\n   }\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          const_iterator first,\n-                                          const_iterator last,\n-                                          size_type n)\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void\n+deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n+                                           const_iterator __first,\n+                                           const_iterator __last,\n+                                           size_type __n)\n {\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n+  const difference_type __elemsbefore = __pos - _M_start;\n+  size_type __length = size();\n+  if (__elemsbefore < __length / 2) {\n+    iterator __new_start = _M_reserve_elements_at_front(__n);\n+    iterator __old_start = _M_start;\n+    __pos = _M_start + __elemsbefore;\n     __STL_TRY {\n-      if (elems_before >= n) {\n-        iterator start_n = start + n;\n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        copy(first, last, pos - difference_type(n));\n+      if (__elemsbefore >= __n) {\n+        iterator __start_n = _M_start + __n;\n+        uninitialized_copy(_M_start, __start_n, __new_start);\n+        _M_start = __new_start;\n+        copy(__start_n, __pos, __old_start);\n+        copy(__first, __last, __pos - difference_type(__n));\n       }\n       else {\n-        const_iterator mid = first + (n - elems_before);\n-        __uninitialized_copy_copy(start, pos, first, mid, new_start);\n-        start = new_start;\n-        copy(mid, last, old_start);\n+        const_iterator __mid = __first + (__n - __elemsbefore);\n+        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n+                                  __new_start);\n+        _M_start = __new_start;\n+        copy(__mid, __last, __old_start);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_front(new_start));\n+    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n   }\n   else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = length - elems_before;\n-    pos = finish - elems_after;\n+    iterator __new_finish = _M_reserve_elements_at_back(__n);\n+    iterator __old_finish = _M_finish;\n+    const difference_type __elemsafter = __length - __elemsbefore;\n+    __pos = _M_finish - __elemsafter;\n     __STL_TRY {\n-      if (elems_after > n) {\n-        iterator finish_n = finish - difference_type(n);\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        copy(first, last, pos);\n+      if (__elemsafter > __n) {\n+        iterator __finish_n = _M_finish - difference_type(__n);\n+        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n+        _M_finish = __new_finish;\n+        copy_backward(__pos, __finish_n, __old_finish);\n+        copy(__first, __last, __pos);\n       }\n       else {\n-        const_iterator mid = first + elems_after;\n-        __uninitialized_copy_copy(mid, last, pos, finish, finish);\n-        finish = new_finish;\n-        copy(first, mid, pos);\n+        const_iterator __mid = __first + __elemsafter;\n+        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);\n+        _M_finish = __new_finish;\n+        copy(__first, __mid, __pos);\n       }\n     }\n-    __STL_UNWIND(destroy_nodes_at_back(new_finish));\n+    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n+                 __new_finish._M_node + 1));\n   }\n }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::new_elements_at_front(size_type new_elements) {\n-  size_type new_nodes = (new_elements + buffer_size() - 1) / buffer_size();\n-  reserve_map_at_front(new_nodes);\n-  size_type i;\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_new_elements_at_front(size_type __new_elems)\n+{\n+  size_type __new_nodes\n+      = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n+  _M_reserve_map_at_front(__new_nodes);\n+  size_type __i;\n   __STL_TRY {\n-    for (i = 1; i <= new_nodes; ++i)\n-      *(start.node - i) = allocate_node();\n+    for (__i = 1; __i <= __new_nodes; ++__i)\n+      *(_M_start._M_node - __i) = _M_allocate_node();\n   }\n #       ifdef __STL_USE_EXCEPTIONS\n   catch(...) {\n-    for (size_type j = 1; j < i; ++j)\n-      deallocate_node(*(start.node - j));      \n+    for (size_type __j = 1; __j < __i; ++__j)\n+      _M_deallocate_node(*(_M_start._M_node - __j));      \n     throw;\n   }\n #       endif /* __STL_USE_EXCEPTIONS */\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::new_elements_at_back(size_type new_elements) {\n-  size_type new_nodes = (new_elements + buffer_size() - 1) / buffer_size();\n-  reserve_map_at_back(new_nodes);\n-  size_type i;\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_new_elements_at_back(size_type __new_elems)\n+{\n+  size_type __new_nodes\n+      = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n+  _M_reserve_map_at_back(__new_nodes);\n+  size_type __i;\n   __STL_TRY {\n-    for (i = 1; i <= new_nodes; ++i)\n-      *(finish.node + i) = allocate_node();\n+    for (__i = 1; __i <= __new_nodes; ++__i)\n+      *(_M_finish._M_node + __i) = _M_allocate_node();\n   }\n #       ifdef __STL_USE_EXCEPTIONS\n   catch(...) {\n-    for (size_type j = 1; j < i; ++j)\n-      deallocate_node(*(finish.node + j));      \n+    for (size_type __j = 1; __j < __i; ++__j)\n+      _M_deallocate_node(*(_M_finish._M_node + __j));      \n     throw;\n   }\n #       endif /* __STL_USE_EXCEPTIONS */\n }\n \n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::destroy_nodes_at_front(iterator before_start) {\n-  for (map_pointer n = before_start.node; n < start.node; ++n)\n-    deallocate_node(*n);\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::destroy_nodes_at_back(iterator after_finish) {\n-  for (map_pointer n = after_finish.node; n > finish.node; --n)\n-    deallocate_node(*n);\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add,\n-                                              bool add_at_front) {\n-  size_type old_num_nodes = finish.node - start.node + 1;\n-  size_type new_num_nodes = old_num_nodes + nodes_to_add;\n-\n-  map_pointer new_nstart;\n-  if (map_size > 2 * new_num_nodes) {\n-    new_nstart = map + (map_size - new_num_nodes) / 2 \n-                     + (add_at_front ? nodes_to_add : 0);\n-    if (new_nstart < start.node)\n-      copy(start.node, finish.node + 1, new_nstart);\n+template <class _Tp, class _Alloc, size_t __bufsize>\n+void \n+deque<_Tp,_Alloc,__bufsize>::_M_reallocate_map(size_type __nodes_to_add,\n+                                              bool __add_at_front)\n+{\n+  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;\n+  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n+\n+  _Map_pointer __new_nstart;\n+  if (_M_map_size > 2 * __new_num_nodes) {\n+    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 \n+                     + (__add_at_front ? __nodes_to_add : 0);\n+    if (__new_nstart < _M_start._M_node)\n+      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n     else\n-      copy_backward(start.node, finish.node + 1, new_nstart + old_num_nodes);\n+      copy_backward(_M_start._M_node, _M_finish._M_node + 1, \n+                    __new_nstart + __old_num_nodes);\n   }\n   else {\n-    size_type new_map_size = map_size + max(map_size, nodes_to_add) + 2;\n+    size_type __new_map_size = \n+      _M_map_size + max(_M_map_size, __nodes_to_add) + 2;\n \n-    map_pointer new_map = map_allocator::allocate(new_map_size);\n-    new_nstart = new_map + (new_map_size - new_num_nodes) / 2\n-                         + (add_at_front ? nodes_to_add : 0);\n-    copy(start.node, finish.node + 1, new_nstart);\n-    map_allocator::deallocate(map, map_size);\n+    _Map_pointer __new_map = _M_allocate_map(__new_map_size);\n+    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n+                         + (__add_at_front ? __nodes_to_add : 0);\n+    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n+    _M_deallocate_map(_M_map, _M_map_size);\n \n-    map = new_map;\n-    map_size = new_map_size;\n+    _M_map = __new_map;\n+    _M_map_size = __new_map_size;\n   }\n \n-  start.set_node(new_nstart);\n-  finish.set_node(new_nstart + old_num_nodes - 1);\n+  _M_start._M_set_node(__new_nstart);\n+  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n }\n \n \n // Nonmember functions.\n \n #ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n \n-template <class T, class Alloc, size_t BufSiz>\n-bool operator==(const deque<T, Alloc, BufSiz>& x,\n-                const deque<T, Alloc, BufSiz>& y) {\n-  return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+bool operator==(const deque<_Tp, _Alloc, __bufsiz>& __x,\n+                const deque<_Tp, _Alloc, __bufsiz>& __y)\n+{\n+  return __x.size() == __y.size() &&\n+         equal(__x.begin(), __x.end(), __y.begin());\n }\n \n-template <class T, class Alloc, size_t BufSiz>\n-bool operator<(const deque<T, Alloc, BufSiz>& x,\n-               const deque<T, Alloc, BufSiz>& y) {\n-  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+bool operator<(const deque<_Tp, _Alloc, __bufsiz>& __x,\n+               const deque<_Tp, _Alloc, __bufsiz>& __y)\n+{\n+  return lexicographical_compare(__x.begin(), __x.end(), \n+                                 __y.begin(), __y.end());\n }\n \n #endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n \n #if defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER) && \\\n     !defined(__STL_NON_TYPE_TMPL_PARAM_BUG)\n \n-template <class T, class Alloc, size_t BufSiz>\n-inline void swap(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y) {\n-  x.swap(y);\n+template <class _Tp, class _Alloc, size_t __bufsiz>\n+inline void \n+swap(deque<_Tp,_Alloc,__bufsiz>& __x, deque<_Tp,_Alloc,__bufsiz>& __y)\n+{\n+  __x.swap(__y);\n }\n \n #endif\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n           \n __STL_END_NAMESPACE "}, {"sha": "cd07c1c673057ca91a27a3d43b65f01ed8938d3d", "filename": "libstdc++/stl/stl_function.h", "status": "modified", "additions": 413, "deletions": 341, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_function.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996-1998\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -33,372 +33,430 @@\n \n __STL_BEGIN_NAMESPACE\n \n-template <class Arg, class Result>\n+template <class _Arg, class _Result>\n struct unary_function {\n-    typedef Arg argument_type;\n-    typedef Result result_type;\n+  typedef _Arg argument_type;\n+  typedef _Result result_type;\n };\n \n-template <class Arg1, class Arg2, class Result>\n+template <class _Arg1, class _Arg2, class _Result>\n struct binary_function {\n-    typedef Arg1 first_argument_type;\n-    typedef Arg2 second_argument_type;\n-    typedef Result result_type;\n+  typedef _Arg1 first_argument_type;\n+  typedef _Arg2 second_argument_type;\n+  typedef _Result result_type;\n };      \n \n-template <class T>\n-struct plus : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x + y; }\n+template <class _Tp>\n+struct plus : public binary_function<_Tp,_Tp,_Tp> {\n+  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }\n };\n \n-template <class T>\n-struct minus : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x - y; }\n+template <class _Tp>\n+struct minus : public binary_function<_Tp,_Tp,_Tp> {\n+  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }\n };\n \n-template <class T>\n-struct multiplies : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x * y; }\n+template <class _Tp>\n+struct multiplies : public binary_function<_Tp,_Tp,_Tp> {\n+  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }\n };\n \n-template <class T>\n-struct divides : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x / y; }\n+template <class _Tp>\n+struct divides : public binary_function<_Tp,_Tp,_Tp> {\n+  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }\n };\n \n-template <class T> inline T identity_element(plus<T>) { return T(0); }\n+// identity_element (not part of the C++ standard).\n \n-template <class T> inline T identity_element(multiplies<T>) { return T(1); }\n+template <class _Tp> inline _Tp identity_element(plus<_Tp>) {\n+  return _Tp(0);\n+}\n+template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) {\n+  return _Tp(1);\n+}\n \n-template <class T>\n-struct modulus : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x % y; }\n+template <class _Tp>\n+struct modulus : public binary_function<_Tp,_Tp,_Tp> \n+{\n+  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }\n };\n \n-template <class T>\n-struct negate : public unary_function<T, T> {\n-    T operator()(const T& x) const { return -x; }\n+template <class _Tp>\n+struct negate : public unary_function<_Tp,_Tp> \n+{\n+  _Tp operator()(const _Tp& __x) const { return -__x; }\n };\n \n-template <class T>\n-struct equal_to : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x == y; }\n+template <class _Tp>\n+struct equal_to : public binary_function<_Tp,_Tp,bool> \n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }\n };\n \n-template <class T>\n-struct not_equal_to : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x != y; }\n+template <class _Tp>\n+struct not_equal_to : public binary_function<_Tp,_Tp,bool> \n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }\n };\n \n-template <class T>\n-struct greater : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x > y; }\n+template <class _Tp>\n+struct greater : public binary_function<_Tp,_Tp,bool> \n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }\n };\n \n-template <class T>\n-struct less : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x < y; }\n+template <class _Tp>\n+struct less : public binary_function<_Tp,_Tp,bool> \n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }\n };\n \n-template <class T>\n-struct greater_equal : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x >= y; }\n+template <class _Tp>\n+struct greater_equal : public binary_function<_Tp,_Tp,bool>\n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }\n };\n \n-template <class T>\n-struct less_equal : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x <= y; }\n+template <class _Tp>\n+struct less_equal : public binary_function<_Tp,_Tp,bool> \n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }\n };\n \n-template <class T>\n-struct logical_and : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x && y; }\n+template <class _Tp>\n+struct logical_and : public binary_function<_Tp,_Tp,bool>\n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }\n };\n \n-template <class T>\n-struct logical_or : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x || y; }\n+template <class _Tp>\n+struct logical_or : public binary_function<_Tp,_Tp,bool>\n+{\n+  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }\n };\n \n-template <class T>\n-struct logical_not : public unary_function<T, bool> {\n-    bool operator()(const T& x) const { return !x; }\n+template <class _Tp>\n+struct logical_not : public unary_function<_Tp,bool>\n+{\n+  bool operator()(const _Tp& __x) const { return !__x; }\n };\n \n-template <class Predicate>\n+template <class _Predicate>\n class unary_negate\n-  : public unary_function<typename Predicate::argument_type, bool> {\n+  : public unary_function<typename _Predicate::argument_type, bool> {\n protected:\n-  Predicate pred;\n+  _Predicate _M_pred;\n public:\n-  explicit unary_negate(const Predicate& x) : pred(x) {}\n-  bool operator()(const typename Predicate::argument_type& x) const {\n-    return !pred(x);\n+  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}\n+  bool operator()(const typename _Predicate::argument_type& __x) const {\n+    return !_M_pred(__x);\n   }\n };\n \n-template <class Predicate>\n-inline unary_negate<Predicate> not1(const Predicate& pred) {\n-  return unary_negate<Predicate>(pred);\n+template <class _Predicate>\n+inline unary_negate<_Predicate> \n+not1(const _Predicate& __pred)\n+{\n+  return unary_negate<_Predicate>(__pred);\n }\n \n-template <class Predicate> \n+template <class _Predicate> \n class binary_negate \n-  : public binary_function<typename Predicate::first_argument_type,\n-                           typename Predicate::second_argument_type,\n+  : public binary_function<typename _Predicate::first_argument_type,\n+                           typename _Predicate::second_argument_type,\n                            bool> {\n protected:\n-  Predicate pred;\n+  _Predicate _M_pred;\n public:\n-  explicit binary_negate(const Predicate& x) : pred(x) {}\n-  bool operator()(const typename Predicate::first_argument_type& x, \n-                  const typename Predicate::second_argument_type& y) const {\n-    return !pred(x, y); \n+  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}\n+  bool operator()(const typename _Predicate::first_argument_type& __x, \n+                  const typename _Predicate::second_argument_type& __y) const\n+  {\n+    return !_M_pred(__x, __y); \n   }\n };\n \n-template <class Predicate>\n-inline binary_negate<Predicate> not2(const Predicate& pred) {\n-  return binary_negate<Predicate>(pred);\n+template <class _Predicate>\n+inline binary_negate<_Predicate> \n+not2(const _Predicate& __pred)\n+{\n+  return binary_negate<_Predicate>(__pred);\n }\n \n-template <class Operation> \n+template <class _Operation> \n class binder1st\n-  : public unary_function<typename Operation::second_argument_type,\n-                          typename Operation::result_type> {\n+  : public unary_function<typename _Operation::second_argument_type,\n+                          typename _Operation::result_type> {\n protected:\n-  Operation op;\n-  typename Operation::first_argument_type value;\n+  _Operation op;\n+  typename _Operation::first_argument_type value;\n public:\n-  binder1st(const Operation& x,\n-            const typename Operation::first_argument_type& y)\n-      : op(x), value(y) {}\n-  typename Operation::result_type\n-  operator()(const typename Operation::second_argument_type& x) const {\n-    return op(value, x); \n+  binder1st(const _Operation& __x,\n+            const typename _Operation::first_argument_type& __y)\n+      : op(__x), value(__y) {}\n+  typename _Operation::result_type\n+  operator()(const typename _Operation::second_argument_type& __x) const {\n+    return op(value, __x); \n   }\n };\n \n-template <class Operation, class T>\n-inline binder1st<Operation> bind1st(const Operation& op, const T& x) {\n-  typedef typename Operation::first_argument_type arg1_type;\n-  return binder1st<Operation>(op, arg1_type(x));\n+template <class _Operation, class _Tp>\n+inline binder1st<_Operation> \n+bind1st(const _Operation& __opr, const _Tp& __x) \n+{\n+  typedef typename _Operation::first_argument_type _Arg1_type;\n+  return binder1st<_Operation>(__opr, _Arg1_type(__x));\n }\n \n-template <class Operation> \n+template <class _Operation> \n class binder2nd\n-  : public unary_function<typename Operation::first_argument_type,\n-                          typename Operation::result_type> {\n+  : public unary_function<typename _Operation::first_argument_type,\n+                          typename _Operation::result_type> {\n protected:\n-  Operation op;\n-  typename Operation::second_argument_type value;\n+  _Operation op;\n+  typename _Operation::second_argument_type value;\n public:\n-  binder2nd(const Operation& x,\n-            const typename Operation::second_argument_type& y) \n-      : op(x), value(y) {}\n-  typename Operation::result_type\n-  operator()(const typename Operation::first_argument_type& x) const {\n-    return op(x, value); \n+  binder2nd(const _Operation& __x,\n+            const typename _Operation::second_argument_type& __y) \n+      : op(__x), value(__y) {}\n+  typename _Operation::result_type\n+  operator()(const typename _Operation::first_argument_type& __x) const {\n+    return op(__x, value); \n   }\n };\n \n-template <class Operation, class T>\n-inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {\n-  typedef typename Operation::second_argument_type arg2_type;\n-  return binder2nd<Operation>(op, arg2_type(x));\n+template <class _Operation, class _Tp>\n+inline binder2nd<_Operation> \n+bind2nd(const _Operation& __opr, const _Tp& __x) \n+{\n+  typedef typename _Operation::second_argument_type _Arg2_type;\n+  return binder2nd<_Operation>(__opr, _Arg2_type(__x));\n }\n \n-template <class Operation1, class Operation2>\n-class unary_compose : public unary_function<typename Operation2::argument_type,\n-                                            typename Operation1::result_type> {\n+// unary_compose and binary_compose (extensions, not part of the standard).\n+\n+template <class _Operation1, class _Operation2>\n+class unary_compose\n+  : public unary_function<typename _Operation2::argument_type,\n+                          typename _Operation1::result_type> \n+{\n protected:\n-  Operation1 op1;\n-  Operation2 op2;\n+  _Operation1 __op1;\n+  _Operation2 __op2;\n public:\n-  unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}\n-  typename Operation1::result_type\n-  operator()(const typename Operation2::argument_type& x) const {\n-    return op1(op2(x));\n+  unary_compose(const _Operation1& __x, const _Operation2& __y) \n+    : __op1(__x), __op2(__y) {}\n+  typename _Operation1::result_type\n+  operator()(const typename _Operation2::argument_type& __x) const {\n+    return __op1(__op2(__x));\n   }\n };\n \n-template <class Operation1, class Operation2>\n-inline unary_compose<Operation1, Operation2> compose1(const Operation1& op1, \n-                                                      const Operation2& op2) {\n-  return unary_compose<Operation1, Operation2>(op1, op2);\n+template <class _Operation1, class _Operation2>\n+inline unary_compose<_Operation1,_Operation2> \n+compose1(const _Operation1& __op1, const _Operation2& __op2)\n+{\n+  return unary_compose<_Operation1,_Operation2>(__op1, __op2);\n }\n \n-template <class Operation1, class Operation2, class Operation3>\n+template <class _Operation1, class _Operation2, class _Operation3>\n class binary_compose\n-  : public unary_function<typename Operation2::argument_type,\n-                          typename Operation1::result_type> {\n+  : public unary_function<typename _Operation2::argument_type,\n+                          typename _Operation1::result_type> {\n protected:\n-  Operation1 op1;\n-  Operation2 op2;\n-  Operation3 op3;\n+  _Operation1 _M_op1;\n+  _Operation2 _M_op2;\n+  _Operation3 _M_op3;\n public:\n-  binary_compose(const Operation1& x, const Operation2& y, \n-                 const Operation3& z) : op1(x), op2(y), op3(z) { }\n-  typename Operation1::result_type\n-  operator()(const typename Operation2::argument_type& x) const {\n-    return op1(op2(x), op3(x));\n+  binary_compose(const _Operation1& __x, const _Operation2& __y, \n+                 const _Operation3& __z) \n+    : _M_op1(__x), _M_op2(__y), _M_op3(__z) { }\n+  typename _Operation1::result_type\n+  operator()(const typename _Operation2::argument_type& __x) const {\n+    return _M_op1(_M_op2(__x), _M_op3(__x));\n   }\n };\n \n-template <class Operation1, class Operation2, class Operation3>\n-inline binary_compose<Operation1, Operation2, Operation3> \n-compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {\n-  return binary_compose<Operation1, Operation2, Operation3>(op1, op2, op3);\n+template <class _Operation1, class _Operation2, class _Operation3>\n+inline binary_compose<_Operation1, _Operation2, _Operation3> \n+compose2(const _Operation1& __op1, const _Operation2& __op2, \n+         const _Operation3& __op3)\n+{\n+  return binary_compose<_Operation1,_Operation2,_Operation3>\n+    (__op1, __op2, __op3);\n }\n \n-template <class Arg, class Result>\n-class pointer_to_unary_function : public unary_function<Arg, Result> {\n+template <class _Arg, class _Result>\n+class pointer_to_unary_function : public unary_function<_Arg, _Result> {\n protected:\n-  Result (*ptr)(Arg);\n+  _Result (*_M_ptr)(_Arg);\n public:\n   pointer_to_unary_function() {}\n-  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}\n-  Result operator()(Arg x) const { return ptr(x); }\n+  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}\n+  _Result operator()(_Arg __x) const { return _M_ptr(__x); }\n };\n \n-template <class Arg, class Result>\n-inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {\n-  return pointer_to_unary_function<Arg, Result>(x);\n+template <class _Arg, class _Result>\n+inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))\n+{\n+  return pointer_to_unary_function<_Arg, _Result>(__x);\n }\n \n-template <class Arg1, class Arg2, class Result>\n-class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {\n+template <class _Arg1, class _Arg2, class _Result>\n+class pointer_to_binary_function : \n+  public binary_function<_Arg1,_Arg2,_Result> {\n protected:\n-    Result (*ptr)(Arg1, Arg2);\n+    _Result (*_M_ptr)(_Arg1, _Arg2);\n public:\n     pointer_to_binary_function() {}\n-    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}\n-    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }\n+    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) \n+      : _M_ptr(__x) {}\n+    _Result operator()(_Arg1 __x, _Arg2 __y) const {\n+      return _M_ptr(__x, __y);\n+    }\n };\n \n-template <class Arg1, class Arg2, class Result>\n-inline pointer_to_binary_function<Arg1, Arg2, Result> \n-ptr_fun(Result (*x)(Arg1, Arg2)) {\n-  return pointer_to_binary_function<Arg1, Arg2, Result>(x);\n+template <class _Arg1, class _Arg2, class _Result>\n+inline pointer_to_binary_function<_Arg1,_Arg2,_Result> \n+ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {\n+  return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__x);\n }\n \n-template <class T>\n-struct identity : public unary_function<T, T> {\n-  const T& operator()(const T& x) const { return x; }\n+// identity is an extensions: it is not part of the standard.\n+template <class _Tp>\n+struct _Identity : public unary_function<_Tp,_Tp> {\n+  const _Tp& operator()(const _Tp& __x) const { return __x; }\n };\n \n-template <class Pair>\n-struct select1st : public unary_function<Pair, typename Pair::first_type> {\n-  const typename Pair::first_type& operator()(const Pair& x) const\n-  {\n-    return x.first;\n+template <class _Tp> struct identity : public _Identity<_Tp> {};\n+\n+// select1st and select2nd are extensions: they are not part of the standard.\n+template <class _Pair>\n+struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {\n+  const typename _Pair::first_type& operator()(const _Pair& __x) const {\n+    return __x.first;\n   }\n };\n \n-template <class Pair>\n-struct select2nd : public unary_function<Pair, typename Pair::second_type> {\n-  const typename Pair::second_type& operator()(const Pair& x) const\n-  {\n-    return x.second;\n+template <class _Pair>\n+struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>\n+{\n+  const typename _Pair::second_type& operator()(const _Pair& __x) const {\n+    return __x.second;\n   }\n };\n \n-template <class Arg1, class Arg2>\n-struct project1st : public binary_function<Arg1, Arg2, Arg1> {\n-  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }\n+template <class _Pair> struct select1st : public _Select1st<_Pair> {};\n+template <class _Pair> struct select2nd : public _Select2nd<_Pair> {};\n+\n+// project1st and project2nd are extensions: they are not part of the standard\n+template <class _Arg1, class _Arg2>\n+struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {\n+  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }\n };\n \n-template <class Arg1, class Arg2>\n-struct project2nd : public binary_function<Arg1, Arg2, Arg2> {\n-  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }\n+template <class _Arg1, class _Arg2>\n+struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {\n+  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }\n };\n \n-template <class Result>\n+template <class _Arg1, class _Arg2> \n+struct project1st : public _Project1st<_Arg1, _Arg2> {};\n+\n+template <class _Arg1, class _Arg2>\n+struct project2nd : public _Project2nd<_Arg1, _Arg2> {};\n+\n+// constant_void_fun, constant_unary_fun, and constant_binary_fun are\n+// extensions: they are not part of the standard.  (The same, of course,\n+// is true of the helper functions constant0, constant1, and constant2.)\n+template <class _Result>\n struct constant_void_fun\n {\n-  typedef Result result_type;\n-  result_type val;\n-  constant_void_fun(const result_type& v) : val(v) {}\n-  const result_type& operator()() const { return val; }\n+  typedef _Result result_type;\n+  result_type __val;\n+  constant_void_fun(const result_type& __v) : __val(__v) {}\n+  const result_type& operator()() const { return __val; }\n };  \n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Result, class Argument = Result>\n+template <class _Result, class _Argument = _Result>\n #else\n-template <class Result, class Argument>\n+template <class _Result, class _Argument>\n #endif\n-struct constant_unary_fun : public unary_function<Argument, Result> {\n-  Result val;\n-  constant_unary_fun(const Result& v) : val(v) {}\n-  const Result& operator()(const Argument&) const { return val; }\n+struct constant_unary_fun : public unary_function<_Argument, _Result> {\n+  _Result _M_val;\n+  constant_unary_fun(const _Result& __v) : _M_val(__v) {}\n+  const _Result& operator()(const _Argument&) const { return _M_val; }\n };\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Result, class Arg1 = Result, class Arg2 = Arg1>\n+template <class _Result, class _Arg1 = _Result, class _Arg2 = _Arg1>\n #else\n-template <class Result, class Arg1, class Arg2>\n+template <class _Result, class _Arg1, class _Arg2>\n #endif\n-struct constant_binary_fun : public binary_function<Arg1, Arg2, Result> {\n-  Result val;\n-  constant_binary_fun(const Result& v) : val(v) {}\n-  const Result& operator()(const Arg1&, const Arg2&) const {\n-    return val;\n+struct constant_binary_fun : public binary_function<_Arg1, _Arg2, _Result> {\n+  _Result _M_val;\n+  constant_binary_fun(const _Result& __v) : _M_val(__v) {}\n+  const _Result& operator()(const _Arg1&, const _Arg2&) const {\n+    return _M_val;\n   }\n };\n \n-template <class Result>\n-inline constant_void_fun<Result> constant0(const Result& val)\n+template <class _Result>\n+inline constant_void_fun<_Result> constant0(const _Result& __val)\n {\n-  return constant_void_fun<Result>(val);\n+  return constant_void_fun<_Result>(__val);\n }\n \n-template <class Result>\n-inline constant_unary_fun<Result,Result> constant1(const Result& val)\n+template <class _Result>\n+inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)\n {\n-  return constant_unary_fun<Result,Result>(val);\n+  return constant_unary_fun<_Result,_Result>(__val);\n }\n \n-template <class Result>\n-inline constant_binary_fun<Result,Result,Result> constant2(const Result& val)\n+template <class _Result>\n+inline constant_binary_fun<_Result,_Result,_Result> \n+constant2(const _Result& __val)\n {\n-  return constant_binary_fun<Result,Result,Result>(val);\n+  return constant_binary_fun<_Result,_Result,_Result>(__val);\n }\n \n+// subtractive_rng is an extension: it is not part of the standard.\n // Note: this code assumes that int is 32 bits.\n class subtractive_rng : public unary_function<unsigned int, unsigned int> {\n private:\n-  unsigned int table[55];\n-  size_t index1;\n-  size_t index2;\n+  unsigned int _M_table[55];\n+  size_t _M_index1;\n+  size_t _M_index2;\n public:\n-  unsigned int operator()(unsigned int limit) {\n-    index1 = (index1 + 1) % 55;\n-    index2 = (index2 + 1) % 55;\n-    table[index1] = table[index1] - table[index2];\n-    return table[index1] % limit;\n+  unsigned int operator()(unsigned int __limit) {\n+    _M_index1 = (_M_index1 + 1) % 55;\n+    _M_index2 = (_M_index2 + 1) % 55;\n+    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];\n+    return _M_table[_M_index1] % __limit;\n   }\n \n-  void initialize(unsigned int seed)\n+  void _M_initialize(unsigned int __seed)\n   {\n-    unsigned int k = 1;\n-    table[54] = seed;\n-    size_t i;\n-    for (i = 0; i < 54; i++) {\n-        size_t ii = (21 * (i + 1) % 55) - 1;\n-        table[ii] = k;\n-        k = seed - k;\n-        seed = table[ii];\n+    unsigned int __k = 1;\n+    _M_table[54] = __seed;\n+    size_t __i;\n+    for (__i = 0; __i < 54; __i++) {\n+        size_t __ii = (21 * (__i + 1) % 55) - 1;\n+        _M_table[__ii] = __k;\n+        __k = __seed - __k;\n+        __seed = _M_table[__ii];\n     }\n-    for (int loop = 0; loop < 4; loop++) {\n-        for (i = 0; i < 55; i++)\n-            table[i] = table[i] - table[(1 + i + 30) % 55];\n+    for (int __loop = 0; __loop < 4; __loop++) {\n+        for (__i = 0; __i < 55; __i++)\n+            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];\n     }\n-    index1 = 0;\n-    index2 = 31;\n+    _M_index1 = 0;\n+    _M_index2 = 31;\n   }\n \n-  subtractive_rng(unsigned int seed) { initialize(seed); }\n-  subtractive_rng() { initialize(161803398u); }\n+  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }\n+  subtractive_rng() { _M_initialize(161803398u); }\n };\n \n \n@@ -412,212 +470,226 @@ class subtractive_rng : public unary_function<unsigned int, unsigned int> {\n //      non-void return type.\n //  (4) Const vs non-const member function.\n \n-// Note that choice (4) is not present in the 8/97 draft C++ standard, \n-//  which only allows these adaptors to be used with non-const functions.\n-//  This is likely to be recified before the standard becomes final.\n-// Note also that choice (3) is nothing more than a workaround: according\n+// Note that choice (3) is nothing more than a workaround: according\n //  to the draft, compilers should handle void and non-void the same way.\n //  This feature is not yet widely implemented, though.  You can only use\n //  member functions returning void if your compiler supports partial\n //  specialization.\n \n // All of this complexity is in the function objects themselves.  You can\n-//  ignore it by using the helper function mem_fun, mem_fun_ref,\n-//  mem_fun1, and mem_fun1_ref, which create whichever type of adaptor\n-//  is appropriate.\n+//  ignore it by using the helper function mem_fun and mem_fun_ref,\n+//  which create whichever type of adaptor is appropriate.\n+//  (mem_fun1 and mem_fun1_ref are no longer part of the C++ standard,\n+//  but they are provided for backward compatibility.)\n \n \n-template <class S, class T>\n-class mem_fun_t : public unary_function<T*, S> {\n+template <class _Ret, class _Tp>\n+class mem_fun_t : public unary_function<_Tp*,_Ret> {\n public:\n-  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}\n-  S operator()(T* p) const { return (p->*f)(); }\n+  explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}\n+  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }\n private:\n-  S (T::*f)();\n+  _Ret (_Tp::*_M_f)();\n };\n \n-template <class S, class T>\n-class const_mem_fun_t : public unary_function<const T*, S> {\n+template <class _Ret, class _Tp>\n+class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {\n public:\n-  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}\n-  S operator()(const T* p) const { return (p->*f)(); }\n+  explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}\n+  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }\n private:\n-  S (T::*f)() const;\n+  _Ret (_Tp::*_M_f)() const;\n };\n \n \n-template <class S, class T>\n-class mem_fun_ref_t : public unary_function<T, S> {\n+template <class _Ret, class _Tp>\n+class mem_fun_ref_t : public unary_function<_Tp,_Ret> {\n public:\n-  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}\n-  S operator()(T& r) const { return (r.*f)(); }\n+  explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}\n+  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }\n private:\n-  S (T::*f)();\n+  _Ret (_Tp::*_M_f)();\n };\n \n-template <class S, class T>\n-class const_mem_fun_ref_t : public unary_function<T, S> {\n+template <class _Ret, class _Tp>\n+class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {\n public:\n-  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}\n-  S operator()(const T& r) const { return (r.*f)(); }\n+  explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}\n+  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }\n private:\n-  S (T::*f)() const;\n+  _Ret (_Tp::*_M_f)() const;\n };\n \n-template <class S, class T, class A>\n-class mem_fun1_t : public binary_function<T*, A, S> {\n+template <class _Ret, class _Tp, class _Arg>\n+class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {\n public:\n-  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}\n-  S operator()(T* p, A x) const { return (p->*f)(x); }\n+  explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n+  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }\n private:\n-  S (T::*f)(A);\n+  _Ret (_Tp::*_M_f)(_Arg);\n };\n \n-template <class S, class T, class A>\n-class const_mem_fun1_t : public binary_function<const T*, A, S> {\n+template <class _Ret, class _Tp, class _Arg>\n+class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {\n public:\n-  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}\n-  S operator()(const T* p, A x) const { return (p->*f)(x); }\n+  explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n+  _Ret operator()(const _Tp* __p, _Arg __x) const\n+    { return (__p->*_M_f)(__x); }\n private:\n-  S (T::*f)(A) const;\n+  _Ret (_Tp::*_M_f)(_Arg) const;\n };\n \n-template <class S, class T, class A>\n-class mem_fun1_ref_t : public binary_function<T, A, S> {\n+template <class _Ret, class _Tp, class _Arg>\n+class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {\n public:\n-  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}\n-  S operator()(T& r, A x) const { return (r.*f)(x); }\n+  explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n+  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }\n private:\n-  S (T::*f)(A);\n+  _Ret (_Tp::*_M_f)(_Arg);\n };\n \n-template <class S, class T, class A>\n-class const_mem_fun1_ref_t : public binary_function<T, A, S> {\n+template <class _Ret, class _Tp, class _Arg>\n+class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {\n public:\n-  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}\n-  S operator()(const T& r, A x) const { return (r.*f)(x); }\n+  explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n+  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }\n private:\n-  S (T::*f)(A) const;\n+  _Ret (_Tp::*_M_f)(_Arg) const;\n };\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class T>\n-class mem_fun_t<void, T> : public unary_function<T*, void> {\n+template <class _Tp>\n+class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {\n public:\n-  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}\n-  void operator()(T* p) const { (p->*f)(); }\n+  explicit mem_fun_t(void (_Tp::*__pf)()) : _M_f(__pf) {}\n+  void operator()(_Tp* __p) const { (__p->*_M_f)(); }\n private:\n-  void (T::*f)();\n+  void (_Tp::*_M_f)();\n };\n \n-template <class T>\n-class const_mem_fun_t<void, T> : public unary_function<const T*, void> {\n+template <class _Tp>\n+class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*,void> {\n public:\n-  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}\n-  void operator()(const T* p) const { (p->*f)(); }\n+  explicit const_mem_fun_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}\n+  void operator()(const _Tp* __p) const { (__p->*_M_f)(); }\n private:\n-  void (T::*f)() const;\n+  void (_Tp::*_M_f)() const;\n };\n \n-template <class T>\n-class mem_fun_ref_t<void, T> : public unary_function<T, void> {\n+template <class _Tp>\n+class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {\n public:\n-  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}\n-  void operator()(T& r) const { (r.*f)(); }\n+  explicit mem_fun_ref_t(void (_Tp::*__pf)()) : _M_f(__pf) {}\n+  void operator()(_Tp& __r) const { (__r.*_M_f)(); }\n private:\n-  void (T::*f)();\n+  void (_Tp::*_M_f)();\n };\n \n-template <class T>\n-class const_mem_fun_ref_t<void, T> : public unary_function<T, void> {\n+template <class _Tp>\n+class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {\n public:\n-  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}\n-  void operator()(const T& r) const { (r.*f)(); }\n+  explicit const_mem_fun_ref_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}\n+  void operator()(const _Tp& __r) const { (__r.*_M_f)(); }\n private:\n-  void (T::*f)() const;\n+  void (_Tp::*_M_f)() const;\n };\n \n-template <class T, class A>\n-class mem_fun1_t<void, T, A> : public binary_function<T*, A, void> {\n+template <class _Tp, class _Arg>\n+class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*,_Arg,void> {\n public:\n-  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}\n-  void operator()(T* p, A x) const { (p->*f)(x); }\n+  explicit mem_fun1_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n+  void operator()(_Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }\n private:\n-  void (T::*f)(A);\n+  void (_Tp::*_M_f)(_Arg);\n };\n \n-template <class T, class A>\n-class const_mem_fun1_t<void, T, A> : public binary_function<const T*, A, void> {\n+template <class _Tp, class _Arg>\n+class const_mem_fun1_t<void, _Tp, _Arg> \n+  : public binary_function<const _Tp*,_Arg,void> {\n public:\n-  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}\n-  void operator()(const T* p, A x) const { (p->*f)(x); }\n+  explicit const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n+  void operator()(const _Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }\n private:\n-  void (T::*f)(A) const;\n+  void (_Tp::*_M_f)(_Arg) const;\n };\n \n-template <class T, class A>\n-class mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {\n+template <class _Tp, class _Arg>\n+class mem_fun1_ref_t<void, _Tp, _Arg>\n+  : public binary_function<_Tp,_Arg,void> {\n public:\n-  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}\n-  void operator()(T& r, A x) const { (r.*f)(x); }\n+  explicit mem_fun1_ref_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}\n+  void operator()(_Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }\n private:\n-  void (T::*f)(A);\n+  void (_Tp::*_M_f)(_Arg);\n };\n \n-template <class T, class A>\n-class const_mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {\n+template <class _Tp, class _Arg>\n+class const_mem_fun1_ref_t<void, _Tp, _Arg>\n+  : public binary_function<_Tp,_Arg,void> {\n public:\n-  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}\n-  void operator()(const T& r, A x) const { (r.*f)(x); }\n+  explicit const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}\n+  void operator()(const _Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }\n private:\n-  void (T::*f)(A) const;\n+  void (_Tp::*_M_f)(_Arg) const;\n };\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-// Mem_fun adaptor helper functions.  There are only four:\n-//  mem_fun, mem_fun_ref, mem_fun1, mem_fun1_ref.\n+// Mem_fun adaptor helper functions.  There are only two:\n+//  mem_fun and mem_fun_ref.  (mem_fun1 and mem_fun1_ref \n+//  are provided for backward compatibility, but they are no longer\n+//  part of the C++ standard.)\n \n-template <class S, class T>\n-inline mem_fun_t<S,T> mem_fun(S (T::*f)()) { \n-  return mem_fun_t<S,T>(f);\n-}\n+template <class _Ret, class _Tp>\n+inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)())\n+  { return mem_fun_t<_Ret,_Tp>(__f); }\n \n-template <class S, class T>\n-inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const) {\n-  return const_mem_fun_t<S,T>(f);\n-}\n+template <class _Ret, class _Tp>\n+inline const_mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)() const)\n+  { return const_mem_fun_t<_Ret,_Tp>(__f); }\n \n-template <class S, class T>\n-inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)()) { \n-  return mem_fun_ref_t<S,T>(f);\n-}\n+template <class _Ret, class _Tp>\n+inline mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)()) \n+  { return mem_fun_ref_t<_Ret,_Tp>(__f); }\n \n-template <class S, class T>\n-inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const) {\n-  return const_mem_fun_ref_t<S,T>(f);\n-}\n+template <class _Ret, class _Tp>\n+inline const_mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)\n+  { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }\n \n-template <class S, class T, class A>\n-inline mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A)) { \n-  return mem_fun1_t<S,T,A>(f);\n-}\n+template <class _Ret, class _Tp, class _Arg>\n+inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))\n+  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n \n-template <class S, class T, class A>\n-inline const_mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A) const) {\n-  return const_mem_fun1_t<S,T,A>(f);\n-}\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)\n+  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n \n-template <class S, class T, class A>\n-inline mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A)) { \n-  return mem_fun1_ref_t<S,T,A>(f);\n-}\n+template <class _Ret, class _Tp, class _Arg>\n+inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))\n+  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n \n-template <class S, class T, class A>\n-inline const_mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A) const) {\n-  return const_mem_fun1_ref_t<S,T,A>(f);\n-}\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n+mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)\n+  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg))\n+  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg) const)\n+  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun1_ref(_Ret (_Tp::*__f)(_Arg))\n+  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n+mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n+  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n \n __STL_END_NAMESPACE\n "}, {"sha": "44ab9bb567937a6cfe2b2193bc0b9ae25956db38", "filename": "libstdc++/stl/stl_hash_fun.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hash_fun.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1996\n+ * Copyright (c) 1996-1998\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -35,53 +35,53 @@\n \n __STL_BEGIN_NAMESPACE\n \n-template <class Key> struct hash { };\n+template <class _Key> struct hash { };\n \n-inline size_t __stl_hash_string(const char* s)\n+inline size_t __stl_hash_string(const char* __s)\n {\n-  unsigned long h = 0; \n-  for ( ; *s; ++s)\n-    h = 5*h + *s;\n+  unsigned long __h = 0; \n+  for ( ; *__s; ++__s)\n+    __h = 5*__h + *__s;\n   \n-  return size_t(h);\n+  return size_t(__h);\n }\n \n __STL_TEMPLATE_NULL struct hash<char*>\n {\n-  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n+  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n };\n \n __STL_TEMPLATE_NULL struct hash<const char*>\n {\n-  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n+  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n };\n \n __STL_TEMPLATE_NULL struct hash<char> {\n-  size_t operator()(char x) const { return x; }\n+  size_t operator()(char __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<unsigned char> {\n-  size_t operator()(unsigned char x) const { return x; }\n+  size_t operator()(unsigned char __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<signed char> {\n-  size_t operator()(unsigned char x) const { return x; }\n+  size_t operator()(unsigned char __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<short> {\n-  size_t operator()(short x) const { return x; }\n+  size_t operator()(short __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<unsigned short> {\n-  size_t operator()(unsigned short x) const { return x; }\n+  size_t operator()(unsigned short __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<int> {\n-  size_t operator()(int x) const { return x; }\n+  size_t operator()(int __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<unsigned int> {\n-  size_t operator()(unsigned int x) const { return x; }\n+  size_t operator()(unsigned int __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<long> {\n-  size_t operator()(long x) const { return x; }\n+  size_t operator()(long __x) const { return __x; }\n };\n __STL_TEMPLATE_NULL struct hash<unsigned long> {\n-  size_t operator()(unsigned long x) const { return x; }\n+  size_t operator()(unsigned long __x) const { return __x; }\n };\n \n __STL_END_NAMESPACE"}, {"sha": "bf16f60ecad73d610b19a3de4aa833522123ee67", "filename": "libstdc++/stl/stl_hash_map.h", "status": "modified", "additions": 279, "deletions": 221, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hash_map.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -36,317 +36,375 @@ __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class HashFcn = hash<Key>,\n-          class EqualKey = equal_to<Key>,\n-          class Alloc = alloc>\n+template <class _Key, class _Tp, class _HashFcn = hash<_Key>,\n+          class _EqualKey = equal_to<_Key>,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #else\n-template <class Key, class T, class HashFcn, class EqualKey, \n-          class Alloc = alloc>\n+template <class _Key, class _Tp, class _HashFcn, class _EqualKey, \n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #endif\n class hash_map\n {\n private:\n-  typedef hashtable<pair<const Key, T>, Key, HashFcn,\n-                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;\n-  ht rep;\n+  typedef hashtable<pair<const _Key,_Tp>,_Key,_HashFcn,\n+                    _Select1st<pair<const _Key,_Tp> >,_EqualKey,_Alloc> _Ht;\n+  _Ht _M_ht;\n \n public:\n-  typedef typename ht::key_type key_type;\n-  typedef T data_type;\n-  typedef T mapped_type;\n-  typedef typename ht::value_type value_type;\n-  typedef typename ht::hasher hasher;\n-  typedef typename ht::key_equal key_equal;\n-\n-  typedef typename ht::size_type size_type;\n-  typedef typename ht::difference_type difference_type;\n-  typedef typename ht::pointer pointer;\n-  typedef typename ht::const_pointer const_pointer;\n-  typedef typename ht::reference reference;\n-  typedef typename ht::const_reference const_reference;\n-\n-  typedef typename ht::iterator iterator;\n-  typedef typename ht::const_iterator const_iterator;\n-\n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n+  typedef typename _Ht::key_type key_type;\n+  typedef _Tp data_type;\n+  typedef _Tp mapped_type;\n+  typedef typename _Ht::value_type value_type;\n+  typedef typename _Ht::hasher hasher;\n+  typedef typename _Ht::key_equal key_equal;\n+  \n+  typedef typename _Ht::size_type size_type;\n+  typedef typename _Ht::difference_type difference_type;\n+  typedef typename _Ht::pointer pointer;\n+  typedef typename _Ht::const_pointer const_pointer;\n+  typedef typename _Ht::reference reference;\n+  typedef typename _Ht::const_reference const_reference;\n+\n+  typedef typename _Ht::iterator iterator;\n+  typedef typename _Ht::const_iterator const_iterator;\n+\n+  typedef typename _Ht::allocator_type allocator_type;\n+\n+  hasher hash_funct() const { return _M_ht.hash_funct(); }\n+  key_equal key_eq() const { return _M_ht.key_eq(); }\n+  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n \n public:\n-  hash_map() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_map(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n+  hash_map() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+  explicit hash_map(size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+  hash_map(size_type __n, const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+  hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n+  template <class _InputIterator>\n+  hash_map(_InputIterator __f, _InputIterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  template <class _InputIterator>\n+  hash_map(_InputIterator __f, _InputIterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  template <class _InputIterator>\n+  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n+           const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  template <class _InputIterator>\n+  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n+           const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_unique(__f, __l); }\n \n #else\n-  hash_map(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-\n-  hash_map(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n+  hash_map(const value_type* __f, const value_type* __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_map(const value_type* __f, const value_type* __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_map(const value_type* __f, const value_type* __l, size_type __n,\n+           const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_map(const value_type* __f, const value_type* __l, size_type __n,\n+           const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_unique(__f, __l); }\n+\n+  hash_map(const_iterator __f, const_iterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_map(const_iterator __f, const_iterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_map(const_iterator __f, const_iterator __l, size_type __n,\n+           const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_map(const_iterator __f, const_iterator __l, size_type __n,\n+           const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_unique(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n \n public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_map& hs) { rep.swap(hs.rep); }\n+  size_type size() const { return _M_ht.size(); }\n+  size_type max_size() const { return _M_ht.max_size(); }\n+  bool empty() const { return _M_ht.empty(); }\n+  void swap(hash_map& __hs) { _M_ht.swap(__hs._M_ht); }\n   friend bool\n   operator== __STL_NULL_TMPL_ARGS (const hash_map&, const hash_map&);\n \n-  iterator begin() { return rep.begin(); }\n-  iterator end() { return rep.end(); }\n-  const_iterator begin() const { return rep.begin(); }\n-  const_iterator end() const { return rep.end(); }\n+  iterator begin() { return _M_ht.begin(); }\n+  iterator end() { return _M_ht.end(); }\n+  const_iterator begin() const { return _M_ht.begin(); }\n+  const_iterator end() const { return _M_ht.end(); }\n \n public:\n-  pair<iterator, bool> insert(const value_type& obj)\n-    { return rep.insert_unique(obj); }\n+  pair<iterator,bool> insert(const value_type& __obj)\n+    { return _M_ht.insert_unique(__obj); }\n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }\n+  template <class _InputIterator>\n+  void insert(_InputIterator __f, _InputIterator __l)\n+    { _M_ht.insert_unique(__f,__l); }\n #else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_unique(f,l);\n+  void insert(const value_type* __f, const value_type* __l) {\n+    _M_ht.insert_unique(__f,__l);\n   }\n-  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }\n+  void insert(const_iterator __f, const_iterator __l)\n+    { _M_ht.insert_unique(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n-  pair<iterator, bool> insert_noresize(const value_type& obj)\n-    { return rep.insert_unique_noresize(obj); }    \n+  pair<iterator,bool> insert_noresize(const value_type& __obj)\n+    { return _M_ht.insert_unique_noresize(__obj); }    \n \n-  iterator find(const key_type& key) { return rep.find(key); }\n-  const_iterator find(const key_type& key) const { return rep.find(key); }\n+  iterator find(const key_type& __key) { return _M_ht.find(__key); }\n+  const_iterator find(const key_type& __key) const \n+    { return _M_ht.find(__key); }\n \n-  T& operator[](const key_type& key) {\n-    return rep.find_or_insert(value_type(key, T())).second;\n+  _Tp& operator[](const key_type& __key) {\n+    return _M_ht.find_or_insert(value_type(__key, _Tp())).second;\n   }\n \n-  size_type count(const key_type& key) const { return rep.count(key); }\n+  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n   \n-  pair<iterator, iterator> equal_range(const key_type& key)\n-    { return rep.equal_range(key); }\n-  pair<const_iterator, const_iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n-\n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n-\n-public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n+  pair<iterator, iterator> equal_range(const key_type& __key)\n+    { return _M_ht.equal_range(__key); }\n+  pair<const_iterator, const_iterator>\n+  equal_range(const key_type& __key) const\n+    { return _M_ht.equal_range(__key); }\n+\n+  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n+  void erase(iterator __it) { _M_ht.erase(__it); }\n+  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n+  void clear() { _M_ht.clear(); }\n+\n+  void resize(size_type __hint) { _M_ht.resize(__hint); }\n+  size_type bucket_count() const { return _M_ht.bucket_count(); }\n+  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n+  size_type elems_in_bucket(size_type __n) const\n+    { return _M_ht.elems_in_bucket(__n); }\n };\n \n-template <class Key, class T, class HashFcn, class EqualKey, class Alloc>\n-inline bool operator==(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,\n-                       const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2)\n+template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n+inline bool \n+operator==(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n+           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n {\n-  return hm1.rep == hm2.rep;\n+  return __hm1._M_ht == __hm2._M_ht;\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Key, class T, class HashFcn, class EqualKey, class Alloc>\n-inline void swap(hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,\n-                 hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2)\n+template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n+inline void \n+swap(hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n+     hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n {\n-  hm1.swap(hm2);\n+  __hm1.swap(__hm2);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class HashFcn = hash<Key>,\n-          class EqualKey = equal_to<Key>,\n-          class Alloc = alloc>\n+template <class _Key, class _Tp, class _HashFcn = hash<_Key>,\n+          class _EqualKey = equal_to<_Key>,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #else\n-template <class Key, class T, class HashFcn, class EqualKey,\n-          class Alloc = alloc>\n+template <class _Key, class _Tp, class _HashFcn, class _EqualKey,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #endif\n class hash_multimap\n {\n private:\n-  typedef hashtable<pair<const Key, T>, Key, HashFcn,\n-                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;\n-  ht rep;\n+  typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,\n+                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc> \n+          _Ht;\n+  _Ht _M_ht;\n \n public:\n-  typedef typename ht::key_type key_type;\n-  typedef T data_type;\n-  typedef T mapped_type;\n-  typedef typename ht::value_type value_type;\n-  typedef typename ht::hasher hasher;\n-  typedef typename ht::key_equal key_equal;\n-\n-  typedef typename ht::size_type size_type;\n-  typedef typename ht::difference_type difference_type;\n-  typedef typename ht::pointer pointer;\n-  typedef typename ht::const_pointer const_pointer;\n-  typedef typename ht::reference reference;\n-  typedef typename ht::const_reference const_reference;\n-\n-  typedef typename ht::iterator iterator;\n-  typedef typename ht::const_iterator const_iterator;\n-\n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n+  typedef typename _Ht::key_type key_type;\n+  typedef _Tp data_type;\n+  typedef _Tp mapped_type;\n+  typedef typename _Ht::value_type value_type;\n+  typedef typename _Ht::hasher hasher;\n+  typedef typename _Ht::key_equal key_equal;\n+\n+  typedef typename _Ht::size_type size_type;\n+  typedef typename _Ht::difference_type difference_type;\n+  typedef typename _Ht::pointer pointer;\n+  typedef typename _Ht::const_pointer const_pointer;\n+  typedef typename _Ht::reference reference;\n+  typedef typename _Ht::const_reference const_reference;\n+\n+  typedef typename _Ht::iterator iterator;\n+  typedef typename _Ht::const_iterator const_iterator;\n+\n+  typedef typename _Ht::allocator_type allocator_type;\n+\n+  hasher hash_funct() const { return _M_ht.hash_funct(); }\n+  key_equal key_eq() const { return _M_ht.key_eq(); }\n+  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n \n public:\n-  hash_multimap() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n+  hash_multimap() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+  explicit hash_multimap(size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+  hash_multimap(size_type __n, const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+  hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n+  template <class _InputIterator>\n+  hash_multimap(_InputIterator __f, _InputIterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  template <class _InputIterator>\n+  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  template <class _InputIterator>\n+  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n+                const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  template <class _InputIterator>\n+  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n+                const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_equal(__f, __l); }\n \n #else\n-  hash_multimap(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-\n-  hash_multimap(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n+  hash_multimap(const value_type* __f, const value_type* __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multimap(const value_type* __f, const value_type* __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,\n+                const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,\n+                const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_equal(__f, __l); }\n+\n+  hash_multimap(const_iterator __f, const_iterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multimap(const_iterator __f, const_iterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,\n+                const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,\n+                const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_equal(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n \n public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_multimap& hs) { rep.swap(hs.rep); }\n+  size_type size() const { return _M_ht.size(); }\n+  size_type max_size() const { return _M_ht.max_size(); }\n+  bool empty() const { return _M_ht.empty(); }\n+  void swap(hash_multimap& __hs) { _M_ht.swap(__hs._M_ht); }\n   friend bool\n-  operator== __STL_NULL_TMPL_ARGS (const hash_multimap&, const hash_multimap&);\n+  operator== __STL_NULL_TMPL_ARGS (const hash_multimap&,\n+                                   const hash_multimap&);\n \n-  iterator begin() { return rep.begin(); }\n-  iterator end() { return rep.end(); }\n-  const_iterator begin() const { return rep.begin(); }\n-  const_iterator end() const { return rep.end(); }\n+  iterator begin() { return _M_ht.begin(); }\n+  iterator end() { return _M_ht.end(); }\n+  const_iterator begin() const { return _M_ht.begin(); }\n+  const_iterator end() const { return _M_ht.end(); }\n \n public:\n-  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }\n+  iterator insert(const value_type& __obj) \n+    { return _M_ht.insert_equal(__obj); }\n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }\n+  template <class _InputIterator>\n+  void insert(_InputIterator __f, _InputIterator __l) \n+    { _M_ht.insert_equal(__f,__l); }\n #else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_equal(f,l);\n+  void insert(const value_type* __f, const value_type* __l) {\n+    _M_ht.insert_equal(__f,__l);\n   }\n-  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }\n+  void insert(const_iterator __f, const_iterator __l) \n+    { _M_ht.insert_equal(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n-  iterator insert_noresize(const value_type& obj)\n-    { return rep.insert_equal_noresize(obj); }    \n+  iterator insert_noresize(const value_type& __obj)\n+    { return _M_ht.insert_equal_noresize(__obj); }    \n \n-  iterator find(const key_type& key) { return rep.find(key); }\n-  const_iterator find(const key_type& key) const { return rep.find(key); }\n+  iterator find(const key_type& __key) { return _M_ht.find(__key); }\n+  const_iterator find(const key_type& __key) const \n+    { return _M_ht.find(__key); }\n \n-  size_type count(const key_type& key) const { return rep.count(key); }\n+  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n   \n-  pair<iterator, iterator> equal_range(const key_type& key)\n-    { return rep.equal_range(key); }\n-  pair<const_iterator, const_iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n+  pair<iterator, iterator> equal_range(const key_type& __key)\n+    { return _M_ht.equal_range(__key); }\n+  pair<const_iterator, const_iterator>\n+  equal_range(const key_type& __key) const\n+    { return _M_ht.equal_range(__key); }\n \n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n+  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n+  void erase(iterator __it) { _M_ht.erase(__it); }\n+  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n+  void clear() { _M_ht.clear(); }\n \n public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n+  void resize(size_type __hint) { _M_ht.resize(__hint); }\n+  size_type bucket_count() const { return _M_ht.bucket_count(); }\n+  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n+  size_type elems_in_bucket(size_type __n) const\n+    { return _M_ht.elems_in_bucket(__n); }\n };\n \n-template <class Key, class T, class HF, class EqKey, class Alloc>\n-inline bool operator==(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1,\n-                       const hash_multimap<Key, T, HF, EqKey, Alloc>& hm2)\n+template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n+inline bool \n+operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n+           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2)\n {\n-  return hm1.rep == hm2.rep;\n+  return __hm1._M_ht == __hm2._M_ht;\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Key, class T, class HashFcn, class EqualKey, class Alloc>\n-inline void swap(hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm1,\n-                 hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm2)\n+template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n+inline void \n+swap(hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n+     hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n {\n-  hm1.swap(hm2);\n+  __hm1.swap(__hm2);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n \n __STL_END_NAMESPACE"}, {"sha": "b623a642cfc07d17cce4566c5a7b02b0c1ad8e61", "filename": "libstdc++/stl/stl_hash_set.h", "status": "modified", "additions": 254, "deletions": 196, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hash_set.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -35,303 +35,361 @@ __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Value, class HashFcn = hash<Value>,\n-          class EqualKey = equal_to<Value>,\n-          class Alloc = alloc>\n+template <class _Value, class _HashFcn = hash<_Value>,\n+          class _EqualKey = equal_to<_Value>,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) >\n #else\n-template <class Value, class HashFcn, class EqualKey, class Alloc = alloc>\n+template <class _Value, class _HashFcn, class _EqualKey, \n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) >\n #endif\n class hash_set\n {\n private:\n-  typedef hashtable<Value, Value, HashFcn, identity<Value>, \n-                    EqualKey, Alloc> ht;\n-  ht rep;\n+  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n+                    _EqualKey, _Alloc> _Ht;\n+  _Ht _M_ht;\n \n public:\n-  typedef typename ht::key_type key_type;\n-  typedef typename ht::value_type value_type;\n-  typedef typename ht::hasher hasher;\n-  typedef typename ht::key_equal key_equal;\n+  typedef typename _Ht::key_type key_type;\n+  typedef typename _Ht::value_type value_type;\n+  typedef typename _Ht::hasher hasher;\n+  typedef typename _Ht::key_equal key_equal;\n \n-  typedef typename ht::size_type size_type;\n-  typedef typename ht::difference_type difference_type;\n-  typedef typename ht::const_pointer pointer;\n-  typedef typename ht::const_pointer const_pointer;\n-  typedef typename ht::const_reference reference;\n-  typedef typename ht::const_reference const_reference;\n+  typedef typename _Ht::size_type size_type;\n+  typedef typename _Ht::difference_type difference_type;\n+  typedef typename _Ht::const_pointer pointer;\n+  typedef typename _Ht::const_pointer const_pointer;\n+  typedef typename _Ht::const_reference reference;\n+  typedef typename _Ht::const_reference const_reference;\n \n-  typedef typename ht::const_iterator iterator;\n-  typedef typename ht::const_iterator const_iterator;\n+  typedef typename _Ht::const_iterator iterator;\n+  typedef typename _Ht::const_iterator const_iterator;\n \n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n+  typedef typename _Ht::allocator_type allocator_type;\n+\n+  hasher hash_funct() const { return _M_ht.hash_funct(); }\n+  key_equal key_eq() const { return _M_ht.key_eq(); }\n+  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n \n public:\n-  hash_set() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_set(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n+  hash_set()\n+    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+  explicit hash_set(size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+  hash_set(size_type __n, const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+  hash_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n+  template <class _InputIterator>\n+  hash_set(_InputIterator __f, _InputIterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  template <class _InputIterator>\n+  hash_set(_InputIterator __f, _InputIterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  template <class _InputIterator>\n+  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n+           const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  template <class _InputIterator>\n+  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n+           const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_unique(__f, __l); }\n #else\n \n-  hash_set(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-\n-  hash_set(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n+  hash_set(const value_type* __f, const value_type* __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_set(const value_type* __f, const value_type* __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_set(const value_type* __f, const value_type* __l, size_type __n,\n+           const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_set(const value_type* __f, const value_type* __l, size_type __n,\n+           const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_unique(__f, __l); }\n+\n+  hash_set(const_iterator __f, const_iterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_set(const_iterator __f, const_iterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_set(const_iterator __f, const_iterator __l, size_type __n,\n+           const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_unique(__f, __l); }\n+  hash_set(const_iterator __f, const_iterator __l, size_type __n,\n+           const hasher& __hf, const key_equal& __eql,\n+           const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_unique(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n \n public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_set& hs) { rep.swap(hs.rep); }\n+  size_type size() const { return _M_ht.size(); }\n+  size_type max_size() const { return _M_ht.max_size(); }\n+  bool empty() const { return _M_ht.empty(); }\n+  void swap(hash_set& __hs) { _M_ht.swap(__hs._M_ht); }\n   friend bool operator== __STL_NULL_TMPL_ARGS (const hash_set&,\n                                                const hash_set&);\n \n-  iterator begin() const { return rep.begin(); }\n-  iterator end() const { return rep.end(); }\n+  iterator begin() const { return _M_ht.begin(); }\n+  iterator end() const { return _M_ht.end(); }\n \n public:\n-  pair<iterator, bool> insert(const value_type& obj)\n+  pair<iterator, bool> insert(const value_type& __obj)\n     {\n-      pair<typename ht::iterator, bool> p = rep.insert_unique(obj);\n-      return pair<iterator, bool>(p.first, p.second);\n+      pair<typename _Ht::iterator, bool> __p = _M_ht.insert_unique(__obj);\n+      return pair<iterator,bool>(__p.first, __p.second);\n     }\n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }\n+  template <class _InputIterator>\n+  void insert(_InputIterator __f, _InputIterator __l) \n+    { _M_ht.insert_unique(__f,__l); }\n #else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_unique(f,l);\n+  void insert(const value_type* __f, const value_type* __l) {\n+    _M_ht.insert_unique(__f,__l);\n   }\n-  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }\n+  void insert(const_iterator __f, const_iterator __l) \n+    {_M_ht.insert_unique(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n-  pair<iterator, bool> insert_noresize(const value_type& obj)\n+  pair<iterator, bool> insert_noresize(const value_type& __obj)\n   {\n-    pair<typename ht::iterator, bool> p = rep.insert_unique_noresize(obj);\n-    return pair<iterator, bool>(p.first, p.second);\n+    pair<typename _Ht::iterator, bool> __p = \n+      _M_ht.insert_unique_noresize(__obj);\n+    return pair<iterator, bool>(__p.first, __p.second);\n   }\n \n-  iterator find(const key_type& key) const { return rep.find(key); }\n+  iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n \n-  size_type count(const key_type& key) const { return rep.count(key); }\n+  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n   \n-  pair<iterator, iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n+  pair<iterator, iterator> equal_range(const key_type& __key) const\n+    { return _M_ht.equal_range(__key); }\n \n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n+  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n+  void erase(iterator __it) { _M_ht.erase(__it); }\n+  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n+  void clear() { _M_ht.clear(); }\n \n public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n+  void resize(size_type __hint) { _M_ht.resize(__hint); }\n+  size_type bucket_count() const { return _M_ht.bucket_count(); }\n+  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n+  size_type elems_in_bucket(size_type __n) const\n+    { return _M_ht.elems_in_bucket(__n); }\n };\n \n-template <class Value, class HashFcn, class EqualKey, class Alloc>\n-inline bool operator==(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1,\n-                       const hash_set<Value, HashFcn, EqualKey, Alloc>& hs2)\n+template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+inline bool \n+operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n+           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2)\n {\n-  return hs1.rep == hs2.rep;\n+  return __hs1._M_ht == __hs2._M_ht;\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Val, class HashFcn, class EqualKey, class Alloc>\n-inline void swap(hash_set<Val, HashFcn, EqualKey, Alloc>& hs1,\n-                 hash_set<Val, HashFcn, EqualKey, Alloc>& hs2) {\n-  hs1.swap(hs2);\n+template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+inline void \n+swap(hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n+     hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n+{\n+  __hs1.swap(__hs2);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Value, class HashFcn = hash<Value>,\n-          class EqualKey = equal_to<Value>,\n-          class Alloc = alloc>\n+template <class _Value, class _HashFcn = hash<_Value>,\n+          class _EqualKey = equal_to<_Value>,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) >\n #else\n-template <class Value, class HashFcn, class EqualKey, class Alloc = alloc>\n+template <class _Value, class _HashFcn, class _EqualKey, \n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) >\n #endif\n class hash_multiset\n {\n private:\n-  typedef hashtable<Value, Value, HashFcn, identity<Value>, \n-                    EqualKey, Alloc> ht;\n-  ht rep;\n+  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n+                    _EqualKey, _Alloc> _Ht;\n+  _Ht _M_ht;\n \n public:\n-  typedef typename ht::key_type key_type;\n-  typedef typename ht::value_type value_type;\n-  typedef typename ht::hasher hasher;\n-  typedef typename ht::key_equal key_equal;\n+  typedef typename _Ht::key_type key_type;\n+  typedef typename _Ht::value_type value_type;\n+  typedef typename _Ht::hasher hasher;\n+  typedef typename _Ht::key_equal key_equal;\n \n-  typedef typename ht::size_type size_type;\n-  typedef typename ht::difference_type difference_type;\n-  typedef typename ht::const_pointer pointer;\n-  typedef typename ht::const_pointer const_pointer;\n-  typedef typename ht::const_reference reference;\n-  typedef typename ht::const_reference const_reference;\n+  typedef typename _Ht::size_type size_type;\n+  typedef typename _Ht::difference_type difference_type;\n+  typedef typename _Ht::const_pointer pointer;\n+  typedef typename _Ht::const_pointer const_pointer;\n+  typedef typename _Ht::const_reference reference;\n+  typedef typename _Ht::const_reference const_reference;\n \n-  typedef typename ht::const_iterator iterator;\n-  typedef typename ht::const_iterator const_iterator;\n+  typedef typename _Ht::const_iterator iterator;\n+  typedef typename _Ht::const_iterator const_iterator;\n \n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n+  typedef typename _Ht::allocator_type allocator_type;\n+\n+  hasher hash_funct() const { return _M_ht.hash_funct(); }\n+  key_equal key_eq() const { return _M_ht.key_eq(); }\n+  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n \n public:\n-  hash_multiset() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n+  hash_multiset()\n+    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+  explicit hash_multiset(size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+  hash_multiset(size_type __n, const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+  hash_multiset(size_type __n, const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n+  template <class _InputIterator>\n+  hash_multiset(_InputIterator __f, _InputIterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  template <class _InputIterator>\n+  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  template <class _InputIterator>\n+  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n+                const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  template <class _InputIterator>\n+  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n+                const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_equal(__f, __l); }\n #else\n \n-  hash_multiset(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-\n-  hash_multiset(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n+  hash_multiset(const value_type* __f, const value_type* __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multiset(const value_type* __f, const value_type* __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,\n+                const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,\n+                const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_equal(__f, __l); }\n+\n+  hash_multiset(const_iterator __f, const_iterator __l)\n+    : _M_ht(100, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multiset(const_iterator __f, const_iterator __l, size_type __n)\n+    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,\n+                const hasher& __hf)\n+    : _M_ht(__n, __hf, key_equal(), allocator_type())\n+    { _M_ht.insert_equal(__f, __l); }\n+  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,\n+                const hasher& __hf, const key_equal& __eql,\n+                const allocator_type& __a = allocator_type())\n+    : _M_ht(__n, __hf, __eql, __a)\n+    { _M_ht.insert_equal(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n \n public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_multiset& hs) { rep.swap(hs.rep); }\n+  size_type size() const { return _M_ht.size(); }\n+  size_type max_size() const { return _M_ht.max_size(); }\n+  bool empty() const { return _M_ht.empty(); }\n+  void swap(hash_multiset& hs) { _M_ht.swap(hs._M_ht); }\n   friend bool operator== __STL_NULL_TMPL_ARGS (const hash_multiset&,\n                                                const hash_multiset&);\n \n-  iterator begin() const { return rep.begin(); }\n-  iterator end() const { return rep.end(); }\n+  iterator begin() const { return _M_ht.begin(); }\n+  iterator end() const { return _M_ht.end(); }\n \n public:\n-  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }\n+  iterator insert(const value_type& __obj)\n+    { return _M_ht.insert_equal(__obj); }\n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }\n+  template <class _InputIterator>\n+  void insert(_InputIterator __f, _InputIterator __l) \n+    { _M_ht.insert_equal(__f,__l); }\n #else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_equal(f,l);\n+  void insert(const value_type* __f, const value_type* __l) {\n+    _M_ht.insert_equal(__f,__l);\n   }\n-  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }\n+  void insert(const_iterator __f, const_iterator __l) \n+    { _M_ht.insert_equal(__f, __l); }\n #endif /*__STL_MEMBER_TEMPLATES */\n-  iterator insert_noresize(const value_type& obj)\n-    { return rep.insert_equal_noresize(obj); }    \n+  iterator insert_noresize(const value_type& __obj)\n+    { return _M_ht.insert_equal_noresize(__obj); }    \n \n-  iterator find(const key_type& key) const { return rep.find(key); }\n+  iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n \n-  size_type count(const key_type& key) const { return rep.count(key); }\n+  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n   \n-  pair<iterator, iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n+  pair<iterator, iterator> equal_range(const key_type& __key) const\n+    { return _M_ht.equal_range(__key); }\n \n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n+  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n+  void erase(iterator __it) { _M_ht.erase(__it); }\n+  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n+  void clear() { _M_ht.clear(); }\n \n public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n+  void resize(size_type __hint) { _M_ht.resize(__hint); }\n+  size_type bucket_count() const { return _M_ht.bucket_count(); }\n+  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n+  size_type elems_in_bucket(size_type __n) const\n+    { return _M_ht.elems_in_bucket(__n); }\n };\n \n-template <class Val, class HashFcn, class EqualKey, class Alloc>\n-inline bool operator==(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,\n-                       const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs2)\n+template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+inline bool \n+operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n+           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n {\n-  return hs1.rep == hs2.rep;\n+  return __hs1._M_ht == __hs2._M_ht;\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Val, class HashFcn, class EqualKey, class Alloc>\n-inline void swap(hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,\n-                 hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs2)\n-{\n-  hs1.swap(hs2);\n+template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+inline void \n+swap(hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n+     hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n+  __hs1.swap(__hs2);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n \n __STL_END_NAMESPACE"}, {"sha": "78b36c1d5a04ca89a94afa7f7f418b312efe8428", "filename": "libstdc++/stl/stl_hashtable.h", "status": "modified", "additions": 619, "deletions": 528, "changes": 1147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hashtable.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -46,128 +46,150 @@\n \n __STL_BEGIN_NAMESPACE\n \n-template <class Value>\n-struct __hashtable_node\n+template <class _Val>\n+struct _Hashtable_node\n {\n-  __hashtable_node* next;\n-  Value val;\n+  _Hashtable_node* _M_next;\n+  _Val _M_val;\n };  \n \n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc = alloc>\n+template <class _Val, class _Key, class _HashFcn,\n+          class _ExtractKey, class _EqualKey, class _Alloc = alloc>\n class hashtable;\n \n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_iterator;\n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_const_iterator;\n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_iterator {\n-  typedef hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>\n-          hashtable;\n-  typedef __hashtable_iterator<Value, Key, HashFcn, \n-                               ExtractKey, EqualKey, Alloc>\n+template <class _Val, class _Key, class _HashFcn,\n+          class _ExtractKey, class _EqualKey, class _Alloc>\n+struct _Hashtable_iterator;\n+\n+template <class _Val, class _Key, class _HashFcn,\n+          class _ExtractKey, class _EqualKey, class _Alloc>\n+struct _Hashtable_const_iterator;\n+\n+template <class _Val, class _Key, class _HashFcn,\n+          class _ExtractKey, class _EqualKey, class _Alloc>\n+struct _Hashtable_iterator {\n+  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n+          _Hashtable;\n+  typedef _Hashtable_iterator<_Val, _Key, _HashFcn, \n+                              _ExtractKey, _EqualKey, _Alloc>\n           iterator;\n-  typedef __hashtable_const_iterator<Value, Key, HashFcn, \n-                                     ExtractKey, EqualKey, Alloc>\n+  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, \n+                                    _ExtractKey, _EqualKey, _Alloc>\n           const_iterator;\n-  typedef __hashtable_node<Value> node;\n+  typedef _Hashtable_node<_Val> _Node;\n \n   typedef forward_iterator_tag iterator_category;\n-  typedef Value value_type;\n+  typedef _Val value_type;\n   typedef ptrdiff_t difference_type;\n   typedef size_t size_type;\n-  typedef Value& reference;\n-  typedef Value* pointer;\n+  typedef _Val& reference;\n+  typedef _Val* pointer;\n \n-  node* cur;\n-  hashtable* ht;\n+  _Node* _M_cur;\n+  _Hashtable* _M_ht;\n \n-  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}\n-  __hashtable_iterator() {}\n-  reference operator*() const { return cur->val; }\n+  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) \n+    : _M_cur(__n), _M_ht(__tab) {}\n+  _Hashtable_iterator() {}\n+  reference operator*() const { return _M_cur->_M_val; }\n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n   iterator& operator++();\n   iterator operator++(int);\n-  bool operator==(const iterator& it) const { return cur == it.cur; }\n-  bool operator!=(const iterator& it) const { return cur != it.cur; }\n+  bool operator==(const iterator& __it) const\n+    { return _M_cur == __it._M_cur; }\n+  bool operator!=(const iterator& __it) const\n+    { return _M_cur != __it._M_cur; }\n };\n \n \n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_const_iterator {\n-  typedef hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>\n-          hashtable;\n-  typedef __hashtable_iterator<Value, Key, HashFcn, \n-                               ExtractKey, EqualKey, Alloc>\n+template <class _Val, class _Key, class _HashFcn,\n+          class _ExtractKey, class _EqualKey, class _Alloc>\n+struct _Hashtable_const_iterator {\n+  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n+          _Hashtable;\n+  typedef _Hashtable_iterator<_Val,_Key,_HashFcn, \n+                              _ExtractKey,_EqualKey,_Alloc>\n           iterator;\n-  typedef __hashtable_const_iterator<Value, Key, HashFcn, \n-                                     ExtractKey, EqualKey, Alloc>\n+  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, \n+                                    _ExtractKey, _EqualKey, _Alloc>\n           const_iterator;\n-  typedef __hashtable_node<Value> node;\n+  typedef _Hashtable_node<_Val> _Node;\n \n   typedef forward_iterator_tag iterator_category;\n-  typedef Value value_type;\n+  typedef _Val value_type;\n   typedef ptrdiff_t difference_type;\n   typedef size_t size_type;\n-  typedef const Value& reference;\n-  typedef const Value* pointer;\n-\n-  const node* cur;\n-  const hashtable* ht;\n-\n-  __hashtable_const_iterator(const node* n, const hashtable* tab)\n-    : cur(n), ht(tab) {}\n-  __hashtable_const_iterator() {}\n-  __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}\n-  reference operator*() const { return cur->val; }\n+  typedef const _Val& reference;\n+  typedef const _Val* pointer;\n+\n+  const _Node* _M_cur;\n+  const _Hashtable* _M_ht;\n+\n+  _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n+    : _M_cur(__n), _M_ht(__tab) {}\n+  _Hashtable_const_iterator() {}\n+  _Hashtable_const_iterator(const iterator& __it) \n+    : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}\n+  reference operator*() const { return _M_cur->_M_val; }\n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n   const_iterator& operator++();\n   const_iterator operator++(int);\n-  bool operator==(const const_iterator& it) const { return cur == it.cur; }\n-  bool operator!=(const const_iterator& it) const { return cur != it.cur; }\n+  bool operator==(const const_iterator& __it) const \n+    { return _M_cur == __it._M_cur; }\n+  bool operator!=(const const_iterator& __it) const \n+    { return _M_cur != __it._M_cur; }\n };\n \n // Note: assumes long is at least 32 bits.\n static const int __stl_num_primes = 28;\n static const unsigned long __stl_prime_list[__stl_num_primes] =\n {\n-  53,         97,           193,         389,       769,\n-  1543,       3079,         6151,        12289,     24593,\n-  49157,      98317,        196613,      393241,    786433,\n-  1572869,    3145739,      6291469,     12582917,  25165843,\n-  50331653,   100663319,    201326611,   402653189, 805306457, \n-  1610612741, 3221225473ul, 4294967291ul\n+  53ul,         97ul,         193ul,       389ul,       769ul,\n+  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n+  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n+  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n+  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, \n+  1610612741ul, 3221225473ul, 4294967291ul\n };\n \n-inline unsigned long __stl_next_prime(unsigned long n)\n+inline unsigned long __stl_next_prime(unsigned long __n)\n {\n-  const unsigned long* first = __stl_prime_list;\n-  const unsigned long* last = __stl_prime_list + __stl_num_primes;\n-  const unsigned long* pos = lower_bound(first, last, n);\n-  return pos == last ? *(last - 1) : *pos;\n+  const unsigned long* __first = __stl_prime_list;\n+  const unsigned long* __last = __stl_prime_list + __stl_num_primes;\n+  const unsigned long* pos = lower_bound(__first, __last, __n);\n+  return pos == __last ? *(__last - 1) : *pos;\n }\n \n+// Forward declaration of operator==.\n+\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+class hashtable;\n+\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n+                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2);\n \n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey,\n-          class Alloc>\n+\n+// Hashtables handle allocators a bit differently than other containers\n+//  do.  If we're using standard-conforming allocators, then a hashtable\n+//  unconditionally has a member variable to hold its allocator, even if\n+//  it so happens that all instances of the allocator type are identical.\n+// This is because, for hashtables, this extra storage is negligible.  \n+//  Additionally, a base class wouldn't serve any other purposes; it \n+//  wouldn't, for example, simplify the exception-handling code.\n+\n+template <class _Val, class _Key, class _HashFcn,\n+          class _ExtractKey, class _EqualKey, class _Alloc>\n class hashtable {\n public:\n-  typedef Key key_type;\n-  typedef Value value_type;\n-  typedef HashFcn hasher;\n-  typedef EqualKey key_equal;\n+  typedef _Key key_type;\n+  typedef _Val value_type;\n+  typedef _HashFcn hasher;\n+  typedef _EqualKey key_equal;\n \n   typedef size_t            size_type;\n   typedef ptrdiff_t         difference_type;\n@@ -176,100 +198,136 @@ class hashtable {\n   typedef value_type&       reference;\n   typedef const value_type& const_reference;\n \n-  hasher hash_funct() const { return hash; }\n-  key_equal key_eq() const { return equals; }\n+  hasher hash_funct() const { return _M_hash; }\n+  key_equal key_eq() const { return _M_equals; }\n \n private:\n-  hasher hash;\n-  key_equal equals;\n-  ExtractKey get_key;\n+  typedef _Hashtable_node<_Val> _Node;\n \n-  typedef __hashtable_node<Value> node;\n-  typedef simple_alloc<node, Alloc> node_allocator;\n+#ifdef __STL_USE_STD_ALLOCATORS\n+public:\n+  typedef typename _Alloc_traits<_Val,_Alloc>::allocator_type allocator_type;\n+  allocator_type get_allocator() const { return _M_node_allocator; }\n+private:\n+  typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator;\n+  _Node* _M_get_node() { return _M_node_allocator.allocate(1); }\n+  void _M_put_node(_Node* __p) { _M_node_allocator.deallocate(__p, 1); }\n+# define __HASH_ALLOC_INIT(__a) _M_node_allocator(__a), \n+#else /* __STL_USE_STD_ALLOCATORS */\n+public:\n+  typedef _Alloc allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+private:\n+  typedef simple_alloc<_Node, _Alloc> _M_node_allocator_type;\n+  _Node* _M_get_node() { return _M_node_allocator_type::allocate(1); }\n+  void _M_put_node(_Node* __p) { _M_node_allocator_type::deallocate(__p, 1); }\n+# define __HASH_ALLOC_INIT(__a)\n+#endif /* __STL_USE_STD_ALLOCATORS */\n \n-  vector<node*,Alloc> buckets;\n-  size_type num_elements;\n+private:\n+  hasher                _M_hash;\n+  key_equal             _M_equals;\n+  _ExtractKey           _M_get_key;\n+  vector<_Node*,_Alloc> _M_buckets;\n+  size_type             _M_num_elements;\n \n public:\n-  typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, \n-                               Alloc>\n-  iterator;\n-\n-  typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey,\n-                                     Alloc>\n-  const_iterator;\n+  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n+          iterator;\n+  typedef _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,\n+                                    _Alloc>\n+          const_iterator;\n \n   friend struct\n-  __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>;\n+  _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;\n   friend struct\n-  __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>;\n+  _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;\n \n public:\n-  hashtable(size_type n,\n-            const HashFcn&    hf,\n-            const EqualKey&   eql,\n-            const ExtractKey& ext)\n-    : hash(hf), equals(eql), get_key(ext), num_elements(0)\n+  hashtable(size_type __n,\n+            const _HashFcn&    __hf,\n+            const _EqualKey&   __eql,\n+            const _ExtractKey& __ext,\n+            const allocator_type& __a = allocator_type())\n+    : __HASH_ALLOC_INIT(__a)\n+      _M_hash(__hf),\n+      _M_equals(__eql),\n+      _M_get_key(__ext),\n+      _M_buckets(__a),\n+      _M_num_elements(0)\n   {\n-    initialize_buckets(n);\n+    _M_initialize_buckets(__n);\n   }\n \n-  hashtable(size_type n,\n-            const HashFcn&    hf,\n-            const EqualKey&   eql)\n-    : hash(hf), equals(eql), get_key(ExtractKey()), num_elements(0)\n+  hashtable(size_type __n,\n+            const _HashFcn&    __hf,\n+            const _EqualKey&   __eql,\n+            const allocator_type& __a = allocator_type())\n+    : __HASH_ALLOC_INIT(__a)\n+      _M_hash(__hf),\n+      _M_equals(__eql),\n+      _M_get_key(_ExtractKey()),\n+      _M_buckets(__a),\n+      _M_num_elements(0)\n   {\n-    initialize_buckets(n);\n+    _M_initialize_buckets(__n);\n   }\n \n-  hashtable(const hashtable& ht)\n-    : hash(ht.hash), equals(ht.equals), get_key(ht.get_key), num_elements(0)\n+  hashtable(const hashtable& __ht)\n+    : __HASH_ALLOC_INIT(__ht.get_allocator())\n+      _M_hash(__ht._M_hash),\n+      _M_equals(__ht._M_equals),\n+      _M_get_key(__ht._M_get_key),\n+      _M_buckets(__ht.get_allocator()),\n+      _M_num_elements(0)\n   {\n-    copy_from(ht);\n+    _M_copy_from(__ht);\n   }\n \n-  hashtable& operator= (const hashtable& ht)\n+#undef __HASH_ALLOC_INIT\n+\n+  hashtable& operator= (const hashtable& __ht)\n   {\n-    if (&ht != this) {\n+    if (&__ht != this) {\n       clear();\n-      hash = ht.hash;\n-      equals = ht.equals;\n-      get_key = ht.get_key;\n-      copy_from(ht);\n+      _M_hash = __ht._M_hash;\n+      _M_equals = __ht._M_equals;\n+      _M_get_key = __ht._M_get_key;\n+      _M_copy_from(__ht);\n     }\n     return *this;\n   }\n \n   ~hashtable() { clear(); }\n \n-  size_type size() const { return num_elements; }\n+  size_type size() const { return _M_num_elements; }\n   size_type max_size() const { return size_type(-1); }\n   bool empty() const { return size() == 0; }\n \n-  void swap(hashtable& ht)\n+  void swap(hashtable& __ht)\n   {\n-    __STD::swap(hash, ht.hash);\n-    __STD::swap(equals, ht.equals);\n-    __STD::swap(get_key, ht.get_key);\n-    buckets.swap(ht.buckets);\n-    __STD::swap(num_elements, ht.num_elements);\n+    __STD::swap(_M_hash, __ht._M_hash);\n+    __STD::swap(_M_equals, __ht._M_equals);\n+    __STD::swap(_M_get_key, __ht._M_get_key);\n+    _M_buckets.swap(__ht._M_buckets);\n+    __STD::swap(_M_num_elements, __ht._M_num_elements);\n   }\n \n   iterator begin()\n   { \n-    for (size_type n = 0; n < buckets.size(); ++n)\n-      if (buckets[n])\n-        return iterator(buckets[n], this);\n+    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+      if (_M_buckets[__n])\n+        return iterator(_M_buckets[__n], this);\n     return end();\n   }\n \n   iterator end() { return iterator(0, this); }\n \n   const_iterator begin() const\n   {\n-    for (size_type n = 0; n < buckets.size(); ++n)\n-      if (buckets[n])\n-        return const_iterator(buckets[n], this);\n+    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+      if (_M_buckets[__n])\n+        return const_iterator(_M_buckets[__n], this);\n     return end();\n   }\n \n@@ -280,583 +338,611 @@ class hashtable {\n \n public:\n \n-  size_type bucket_count() const { return buckets.size(); }\n+  size_type bucket_count() const { return _M_buckets.size(); }\n \n   size_type max_bucket_count() const\n     { return __stl_prime_list[__stl_num_primes - 1]; } \n \n-  size_type elems_in_bucket(size_type bucket) const\n+  size_type elems_in_bucket(size_type __bucket) const\n   {\n-    size_type result = 0;\n-    for (node* cur = buckets[bucket]; cur; cur = cur->next)\n-      result += 1;\n-    return result;\n+    size_type __result = 0;\n+    for (_Node* __cur = _M_buckets[__bucket]; __cur; __cur = __cur->_M_next)\n+      __result += 1;\n+    return __result;\n   }\n \n-  pair<iterator, bool> insert_unique(const value_type& obj)\n+  pair<iterator, bool> insert_unique(const value_type& __obj)\n   {\n-    resize(num_elements + 1);\n-    return insert_unique_noresize(obj);\n+    resize(_M_num_elements + 1);\n+    return insert_unique_noresize(__obj);\n   }\n \n-  iterator insert_equal(const value_type& obj)\n+  iterator insert_equal(const value_type& __obj)\n   {\n-    resize(num_elements + 1);\n-    return insert_equal_noresize(obj);\n+    resize(_M_num_elements + 1);\n+    return insert_equal_noresize(__obj);\n   }\n \n-  pair<iterator, bool> insert_unique_noresize(const value_type& obj);\n-  iterator insert_equal_noresize(const value_type& obj);\n+  pair<iterator, bool> insert_unique_noresize(const value_type& __obj);\n+  iterator insert_equal_noresize(const value_type& __obj);\n  \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert_unique(InputIterator f, InputIterator l)\n+  template <class _InputIterator>\n+  void insert_unique(_InputIterator __f, _InputIterator __l)\n   {\n-    insert_unique(f, l, iterator_category(f));\n+    insert_unique(__f, __l, __ITERATOR_CATEGORY(__f));\n   }\n \n-  template <class InputIterator>\n-  void insert_equal(InputIterator f, InputIterator l)\n+  template <class _InputIterator>\n+  void insert_equal(_InputIterator __f, _InputIterator __l)\n   {\n-    insert_equal(f, l, iterator_category(f));\n+    insert_equal(__f, __l, __ITERATOR_CATEGORY(__f));\n   }\n \n-  template <class InputIterator>\n-  void insert_unique(InputIterator f, InputIterator l,\n+  template <class _InputIterator>\n+  void insert_unique(_InputIterator __f, _InputIterator __l,\n                      input_iterator_tag)\n   {\n-    for ( ; f != l; ++f)\n-      insert_unique(*f);\n+    for ( ; __f != __l; ++__f)\n+      insert_unique(*__f);\n   }\n \n-  template <class InputIterator>\n-  void insert_equal(InputIterator f, InputIterator l,\n+  template <class _InputIterator>\n+  void insert_equal(_InputIterator __f, _InputIterator __l,\n                     input_iterator_tag)\n   {\n-    for ( ; f != l; ++f)\n-      insert_equal(*f);\n+    for ( ; __f != __l; ++__f)\n+      insert_equal(*__f);\n   }\n \n-  template <class ForwardIterator>\n-  void insert_unique(ForwardIterator f, ForwardIterator l,\n+  template <class _ForwardIterator>\n+  void insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n                      forward_iterator_tag)\n   {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_unique_noresize(*f);\n+    size_type __n = 0;\n+    distance(__f, __l, __n);\n+    resize(_M_num_elements + __n);\n+    for ( ; __n > 0; --__n, ++__f)\n+      insert_unique_noresize(*__f);\n   }\n \n-  template <class ForwardIterator>\n-  void insert_equal(ForwardIterator f, ForwardIterator l,\n+  template <class _ForwardIterator>\n+  void insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n                     forward_iterator_tag)\n   {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_equal_noresize(*f);\n+    size_type __n = 0;\n+    distance(__f, __l, __n);\n+    resize(_M_num_elements + __n);\n+    for ( ; __n > 0; --__n, ++__f)\n+      insert_equal_noresize(*__f);\n   }\n \n #else /* __STL_MEMBER_TEMPLATES */\n-  void insert_unique(const value_type* f, const value_type* l)\n+  void insert_unique(const value_type* __f, const value_type* __l)\n   {\n-    size_type n = l - f;\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_unique_noresize(*f);\n+    size_type __n = __l - __f;\n+    resize(_M_num_elements + __n);\n+    for ( ; __n > 0; --__n, ++__f)\n+      insert_unique_noresize(*__f);\n   }\n \n-  void insert_equal(const value_type* f, const value_type* l)\n+  void insert_equal(const value_type* __f, const value_type* __l)\n   {\n-    size_type n = l - f;\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_equal_noresize(*f);\n+    size_type __n = __l - __f;\n+    resize(_M_num_elements + __n);\n+    for ( ; __n > 0; --__n, ++__f)\n+      insert_equal_noresize(*__f);\n   }\n \n-  void insert_unique(const_iterator f, const_iterator l)\n+  void insert_unique(const_iterator __f, const_iterator __l)\n   {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_unique_noresize(*f);\n+    size_type __n = 0;\n+    distance(__f, __l, __n);\n+    resize(_M_num_elements + __n);\n+    for ( ; __n > 0; --__n, ++__f)\n+      insert_unique_noresize(*__f);\n   }\n \n-  void insert_equal(const_iterator f, const_iterator l)\n+  void insert_equal(const_iterator __f, const_iterator __l)\n   {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_equal_noresize(*f);\n+    size_type __n = 0;\n+    distance(__f, __l, __n);\n+    resize(_M_num_elements + __n);\n+    for ( ; __n > 0; --__n, ++__f)\n+      insert_equal_noresize(*__f);\n   }\n #endif /*__STL_MEMBER_TEMPLATES */\n \n-  reference find_or_insert(const value_type& obj);\n+  reference find_or_insert(const value_type& __obj);\n \n-  iterator find(const key_type& key) \n+  iterator find(const key_type& __key) \n   {\n-    size_type n = bkt_num_key(key);\n-    node* first;\n-    for ( first = buckets[n];\n-          first && !equals(get_key(first->val), key);\n-          first = first->next)\n+    size_type __n = _M_bkt_num_key(__key);\n+    _Node* __first;\n+    for ( __first = _M_buckets[__n];\n+          __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+          __first = __first->_M_next)\n       {}\n-    return iterator(first, this);\n+    return iterator(__first, this);\n   } \n \n-  const_iterator find(const key_type& key) const\n+  const_iterator find(const key_type& __key) const\n   {\n-    size_type n = bkt_num_key(key);\n-    const node* first;\n-    for ( first = buckets[n];\n-          first && !equals(get_key(first->val), key);\n-          first = first->next)\n+    size_type __n = _M_bkt_num_key(__key);\n+    const _Node* __first;\n+    for ( __first = _M_buckets[__n];\n+          __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+          __first = __first->_M_next)\n       {}\n-    return const_iterator(first, this);\n+    return const_iterator(__first, this);\n   } \n \n-  size_type count(const key_type& key) const\n+  size_type count(const key_type& __key) const\n   {\n-    const size_type n = bkt_num_key(key);\n-    size_type result = 0;\n+    const size_type __n = _M_bkt_num_key(__key);\n+    size_type __result = 0;\n \n-    for (const node* cur = buckets[n]; cur; cur = cur->next)\n-      if (equals(get_key(cur->val), key))\n-        ++result;\n-    return result;\n+    for (const _Node* __cur = _M_buckets[__n]; __cur; __cur = __cur->_M_next)\n+      if (_M_equals(_M_get_key(__cur->_M_val), __key))\n+        ++__result;\n+    return __result;\n   }\n \n-  pair<iterator, iterator> equal_range(const key_type& key);\n-  pair<const_iterator, const_iterator> equal_range(const key_type& key) const;\n+  pair<iterator, iterator> \n+  equal_range(const key_type& __key);\n \n-  size_type erase(const key_type& key);\n-  void erase(const iterator& it);\n-  void erase(iterator first, iterator last);\n+  pair<const_iterator, const_iterator> \n+  equal_range(const key_type& __key) const;\n \n-  void erase(const const_iterator& it);\n-  void erase(const_iterator first, const_iterator last);\n+  size_type erase(const key_type& __key);\n+  void erase(const iterator& __it);\n+  void erase(iterator __first, iterator __last);\n \n-  void resize(size_type num_elements_hint);\n+  void erase(const const_iterator& __it);\n+  void erase(const_iterator __first, const_iterator __last);\n+\n+  void resize(size_type __num_elements_hint);\n   void clear();\n \n private:\n-  size_type next_size(size_type n) const { return __stl_next_prime(n); }\n+  size_type _M_next_size(size_type __n) const\n+    { return __stl_next_prime(__n); }\n \n-  void initialize_buckets(size_type n)\n+  void _M_initialize_buckets(size_type __n)\n   {\n-    const size_type n_buckets = next_size(n);\n-    buckets.reserve(n_buckets);\n-    buckets.insert(buckets.end(), n_buckets, (node*) 0);\n-    num_elements = 0;\n+    const size_type __n_buckets = _M_next_size(__n);\n+    _M_buckets.reserve(__n_buckets);\n+    _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n+    _M_num_elements = 0;\n   }\n \n-  size_type bkt_num_key(const key_type& key) const\n+  size_type _M_bkt_num_key(const key_type& __key) const\n   {\n-    return bkt_num_key(key, buckets.size());\n+    return _M_bkt_num_key(__key, _M_buckets.size());\n   }\n \n-  size_type bkt_num(const value_type& obj) const\n+  size_type _M_bkt_num(const value_type& __obj) const\n   {\n-    return bkt_num_key(get_key(obj));\n+    return _M_bkt_num_key(_M_get_key(__obj));\n   }\n \n-  size_type bkt_num_key(const key_type& key, size_t n) const\n+  size_type _M_bkt_num_key(const key_type& __key, size_t __n) const\n   {\n-    return hash(key) % n;\n+    return _M_hash(__key) % __n;\n   }\n \n-  size_type bkt_num(const value_type& obj, size_t n) const\n+  size_type _M_bkt_num(const value_type& __obj, size_t __n) const\n   {\n-    return bkt_num_key(get_key(obj), n);\n+    return _M_bkt_num_key(_M_get_key(__obj), __n);\n   }\n \n-  node* new_node(const value_type& obj)\n+  _Node* _M_new_node(const value_type& __obj)\n   {\n-    node* n = node_allocator::allocate();\n-    n->next = 0;\n+    _Node* __n = _M_get_node();\n+    __n->_M_next = 0;\n     __STL_TRY {\n-      construct(&n->val, obj);\n-      return n;\n+      construct(&__n->_M_val, __obj);\n+      return __n;\n     }\n-    __STL_UNWIND(node_allocator::deallocate(n));\n+    __STL_UNWIND(_M_put_node(__n));\n   }\n   \n-  void delete_node(node* n)\n+  void _M_delete_node(_Node* __n)\n   {\n-    destroy(&n->val);\n-    node_allocator::deallocate(n);\n+    destroy(&__n->_M_val);\n+    _M_put_node(__n);\n   }\n \n-  void erase_bucket(const size_type n, node* first, node* last);\n-  void erase_bucket(const size_type n, node* last);\n+  void _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n+  void _M_erase_bucket(const size_type __n, _Node* __last);\n \n-  void copy_from(const hashtable& ht);\n+  void _M_copy_from(const hashtable& __ht);\n \n };\n \n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-__hashtable_iterator<V, K, HF, ExK, EqK, A>&\n-__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n+_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n {\n-  const node* old = cur;\n-  cur = cur->next;\n-  if (!cur) {\n-    size_type bucket = ht->bkt_num(old->val);\n-    while (!cur && ++bucket < ht->buckets.size())\n-      cur = ht->buckets[bucket];\n+  const _Node* __old = _M_cur;\n+  _M_cur = _M_cur->_M_next;\n+  if (!_M_cur) {\n+    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+      _M_cur = _M_ht->_M_buckets[__bucket];\n   }\n   return *this;\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-inline __hashtable_iterator<V, K, HF, ExK, EqK, A>\n-__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+inline _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n+_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n {\n-  iterator tmp = *this;\n+  iterator __tmp = *this;\n   ++*this;\n-  return tmp;\n+  return __tmp;\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-__hashtable_const_iterator<V, K, HF, ExK, EqK, A>&\n-__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++()\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n+_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n {\n-  const node* old = cur;\n-  cur = cur->next;\n-  if (!cur) {\n-    size_type bucket = ht->bkt_num(old->val);\n-    while (!cur && ++bucket < ht->buckets.size())\n-      cur = ht->buckets[bucket];\n+  const _Node* __old = _M_cur;\n+  _M_cur = _M_cur->_M_next;\n+  if (!_M_cur) {\n+    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+      _M_cur = _M_ht->_M_buckets[__bucket];\n   }\n   return *this;\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-inline __hashtable_const_iterator<V, K, HF, ExK, EqK, A>\n-__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+inline _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n+_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n {\n-  const_iterator tmp = *this;\n+  const_iterator __tmp = *this;\n   ++*this;\n-  return tmp;\n+  return __tmp;\n }\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class V, class K, class HF, class ExK, class EqK, class All>\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n inline forward_iterator_tag\n-iterator_category(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)\n+iterator_category(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n {\n   return forward_iterator_tag();\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline V* value_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+inline _Val* \n+value_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n {\n-  return (V*) 0;\n+  return (_Val*) 0;\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline hashtable<V, K, HF, ExK, EqK, All>::difference_type*\n-distance_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*\n+distance_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n {\n-  return (hashtable<V, K, HF, ExK, EqK, All>::difference_type*) 0;\n+  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class All>\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n inline forward_iterator_tag\n-iterator_category(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)\n+iterator_category(const _Hashtable_const_iterator<_Val,_Key,_HF,\n+                                                  _ExK,_EqK,_All>&)\n {\n   return forward_iterator_tag();\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline V* \n-value_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+inline _Val* \n+value_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n {\n-  return (V*) 0;\n+  return (_Val*) 0;\n }\n \n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline hashtable<V, K, HF, ExK, EqK, All>::difference_type*\n-distance_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)\n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+          class _All>\n+inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*\n+distance_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n {\n-  return (hashtable<V, K, HF, ExK, EqK, All>::difference_type*) 0;\n+  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-bool operator==(const hashtable<V, K, HF, Ex, Eq, A>& ht1,\n-                const hashtable<V, K, HF, Ex, Eq, A>& ht2)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+inline bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n+                       const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2)\n {\n-  typedef typename hashtable<V, K, HF, Ex, Eq, A>::node node;\n-  if (ht1.buckets.size() != ht2.buckets.size())\n+  typedef typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::_Node _Node;\n+  if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n     return false;\n-  for (int n = 0; n < ht1.buckets.size(); ++n) {\n-    node* cur1 = ht1.buckets[n];\n-    node* cur2 = ht2.buckets[n];\n-    for ( ; cur1 && cur2 && cur1->val == cur2->val;\n-          cur1 = cur1->next, cur2 = cur2->next)\n+  for (int __n = 0; __n < __ht1._M_buckets.size(); ++__n) {\n+    _Node* __cur1 = __ht1._M_buckets[__n];\n+    _Node* __cur2 = __ht2._M_buckets[__n];\n+    for ( ; __cur1 && __cur2 && __cur1->_M_val == __cur2->_M_val;\n+          __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n       {}\n-    if (cur1 || cur2)\n+    if (__cur1 || __cur2)\n       return false;\n   }\n   return true;\n }  \n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Val, class Key, class HF, class Extract, class EqKey, class A>\n-inline void swap(hashtable<Val, Key, HF, Extract, EqKey, A>& ht1,\n-                 hashtable<Val, Key, HF, Extract, EqKey, A>& ht2) {\n-  ht1.swap(ht2);\n+template <class _Val, class _Key, class _HF, class _Extract, class _EqKey, \n+          class _All>\n+inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n+                 hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2) {\n+  __ht1.swap(__ht2);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-pair<typename hashtable<V, K, HF, Ex, Eq, A>::iterator, bool> \n-hashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool> \n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::insert_unique_noresize(const value_type& __obj)\n {\n-  const size_type n = bkt_num(obj);\n-  node* first = buckets[n];\n-\n-  for (node* cur = first; cur; cur = cur->next) \n-    if (equals(get_key(cur->val), get_key(obj)))\n-      return pair<iterator, bool>(iterator(cur, this), false);\n-\n-  node* tmp = new_node(obj);\n-  tmp->next = first;\n-  buckets[n] = tmp;\n-  ++num_elements;\n-  return pair<iterator, bool>(iterator(tmp, this), true);\n+  const size_type __n = _M_bkt_num(__obj);\n+  _Node* __first = _M_buckets[__n];\n+\n+  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) \n+    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+      return pair<iterator, bool>(iterator(__cur, this), false);\n+\n+  _Node* __tmp = _M_new_node(__obj);\n+  __tmp->_M_next = __first;\n+  _M_buckets[__n] = __tmp;\n+  ++_M_num_elements;\n+  return pair<iterator, bool>(iterator(__tmp, this), true);\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-typename hashtable<V, K, HF, Ex, Eq, A>::iterator \n-hashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator \n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::insert_equal_noresize(const value_type& __obj)\n {\n-  const size_type n = bkt_num(obj);\n-  node* first = buckets[n];\n-\n-  for (node* cur = first; cur; cur = cur->next) \n-    if (equals(get_key(cur->val), get_key(obj))) {\n-      node* tmp = new_node(obj);\n-      tmp->next = cur->next;\n-      cur->next = tmp;\n-      ++num_elements;\n-      return iterator(tmp, this);\n+  const size_type __n = _M_bkt_num(__obj);\n+  _Node* __first = _M_buckets[__n];\n+\n+  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) \n+    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {\n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __cur->_M_next;\n+      __cur->_M_next = __tmp;\n+      ++_M_num_elements;\n+      return iterator(__tmp, this);\n     }\n \n-  node* tmp = new_node(obj);\n-  tmp->next = first;\n-  buckets[n] = tmp;\n-  ++num_elements;\n-  return iterator(tmp, this);\n+  _Node* __tmp = _M_new_node(__obj);\n+  __tmp->_M_next = __first;\n+  _M_buckets[__n] = __tmp;\n+  ++_M_num_elements;\n+  return iterator(__tmp, this);\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-typename hashtable<V, K, HF, Ex, Eq, A>::reference \n-hashtable<V, K, HF, Ex, Eq, A>::find_or_insert(const value_type& obj)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::reference \n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::find_or_insert(const value_type& __obj)\n {\n-  resize(num_elements + 1);\n+  resize(_M_num_elements + 1);\n \n-  size_type n = bkt_num(obj);\n-  node* first = buckets[n];\n+  size_type __n = _M_bkt_num(__obj);\n+  _Node* __first = _M_buckets[__n];\n \n-  for (node* cur = first; cur; cur = cur->next)\n-    if (equals(get_key(cur->val), get_key(obj)))\n-      return cur->val;\n+  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+      return __cur->_M_val;\n \n-  node* tmp = new_node(obj);\n-  tmp->next = first;\n-  buckets[n] = tmp;\n-  ++num_elements;\n-  return tmp->val;\n+  _Node* __tmp = _M_new_node(__obj);\n+  __tmp->_M_next = __first;\n+  _M_buckets[__n] = __tmp;\n+  ++_M_num_elements;\n+  return __tmp->_M_val;\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-pair<typename hashtable<V, K, HF, Ex, Eq, A>::iterator,\n-     typename hashtable<V, K, HF, Ex, Eq, A>::iterator> \n-hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator,\n+     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator> \n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::equal_range(const key_type& __key)\n {\n-  typedef pair<iterator, iterator> pii;\n-  const size_type n = bkt_num_key(key);\n-\n-  for (node* first = buckets[n]; first; first = first->next) {\n-    if (equals(get_key(first->val), key)) {\n-      for (node* cur = first->next; cur; cur = cur->next)\n-        if (!equals(get_key(cur->val), key))\n-          return pii(iterator(first, this), iterator(cur, this));\n-      for (size_type m = n + 1; m < buckets.size(); ++m)\n-        if (buckets[m])\n-          return pii(iterator(first, this),\n-                     iterator(buckets[m], this));\n-      return pii(iterator(first, this), end());\n+  typedef pair<iterator, iterator> _Pii;\n+  const size_type __n = _M_bkt_num_key(__key);\n+\n+  for (_Node* __first = _M_buckets[__n]; __first; __first = __first->_M_next)\n+    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n+      for (_Node* __cur = __first->_M_next; __cur; __cur = __cur->_M_next)\n+        if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+          return _Pii(iterator(__first, this), iterator(__cur, this));\n+      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+        if (_M_buckets[__m])\n+          return _Pii(iterator(__first, this),\n+                     iterator(_M_buckets[__m], this));\n+      return _Pii(iterator(__first, this), end());\n     }\n-  }\n-  return pii(end(), end());\n+  return _Pii(end(), end());\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-pair<typename hashtable<V, K, HF, Ex, Eq, A>::const_iterator, \n-     typename hashtable<V, K, HF, Ex, Eq, A>::const_iterator> \n-hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key) const\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator, \n+     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator> \n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::equal_range(const key_type& __key) const\n {\n-  typedef pair<const_iterator, const_iterator> pii;\n-  const size_type n = bkt_num_key(key);\n-\n-  for (const node* first = buckets[n] ; first; first = first->next) {\n-    if (equals(get_key(first->val), key)) {\n-      for (const node* cur = first->next; cur; cur = cur->next)\n-        if (!equals(get_key(cur->val), key))\n-          return pii(const_iterator(first, this),\n-                     const_iterator(cur, this));\n-      for (size_type m = n + 1; m < buckets.size(); ++m)\n-        if (buckets[m])\n-          return pii(const_iterator(first, this),\n-                     const_iterator(buckets[m], this));\n-      return pii(const_iterator(first, this), end());\n+  typedef pair<const_iterator, const_iterator> _Pii;\n+  const size_type __n = _M_bkt_num_key(__key);\n+\n+  for (const _Node* __first = _M_buckets[__n] ;\n+       __first; \n+       __first = __first->_M_next) {\n+    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n+      for (const _Node* __cur = __first->_M_next;\n+           __cur;\n+           __cur = __cur->_M_next)\n+        if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+          return _Pii(const_iterator(__first, this),\n+                      const_iterator(__cur, this));\n+      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+        if (_M_buckets[__m])\n+          return _Pii(const_iterator(__first, this),\n+                      const_iterator(_M_buckets[__m], this));\n+      return _Pii(const_iterator(__first, this), end());\n     }\n   }\n-  return pii(end(), end());\n+  return _Pii(end(), end());\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-typename hashtable<V, K, HF, Ex, Eq, A>::size_type \n-hashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type \n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const key_type& __key)\n {\n-  const size_type n = bkt_num_key(key);\n-  node* first = buckets[n];\n-  size_type erased = 0;\n-\n-  if (first) {\n-    node* cur = first;\n-    node* next = cur->next;\n-    while (next) {\n-      if (equals(get_key(next->val), key)) {\n-        cur->next = next->next;\n-        delete_node(next);\n-        next = cur->next;\n-        ++erased;\n-        --num_elements;\n+  const size_type __n = _M_bkt_num_key(__key);\n+  _Node* __first = _M_buckets[__n];\n+  size_type __erased = 0;\n+\n+  if (__first) {\n+    _Node* __cur = __first;\n+    _Node* __next = __cur->_M_next;\n+    while (__next) {\n+      if (_M_equals(_M_get_key(__next->_M_val), __key)) {\n+        __cur->_M_next = __next->_M_next;\n+        _M_delete_node(__next);\n+        __next = __cur->_M_next;\n+        ++__erased;\n+        --_M_num_elements;\n       }\n       else {\n-        cur = next;\n-        next = cur->next;\n+        __cur = __next;\n+        __next = __cur->_M_next;\n       }\n     }\n-    if (equals(get_key(first->val), key)) {\n-      buckets[n] = first->next;\n-      delete_node(first);\n-      ++erased;\n-      --num_elements;\n+    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n+      _M_buckets[__n] = __first->_M_next;\n+      _M_delete_node(__first);\n+      ++__erased;\n+      --_M_num_elements;\n     }\n   }\n-  return erased;\n+  return __erased;\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::erase(const iterator& it)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const iterator& __it)\n {\n-  if (node* const p = it.cur) {\n-    const size_type n = bkt_num(p->val);\n-    node* cur = buckets[n];\n-\n-    if (cur == p) {\n-      buckets[n] = cur->next;\n-      delete_node(cur);\n-      --num_elements;\n+  if (_Node* const __p = __it._M_cur) {\n+    const size_type __n = _M_bkt_num(__p->_M_val);\n+    _Node* __cur = _M_buckets[__n];\n+\n+    if (__cur == __p) {\n+      _M_buckets[__n] = __cur->_M_next;\n+      _M_delete_node(__cur);\n+      --_M_num_elements;\n     }\n     else {\n-      node* next = cur->next;\n-      while (next) {\n-        if (next == p) {\n-          cur->next = next->next;\n-          delete_node(next);\n-          --num_elements;\n+      _Node* __next = __cur->_M_next;\n+      while (__next) {\n+        if (__next == __p) {\n+          __cur->_M_next = __next->_M_next;\n+          _M_delete_node(__next);\n+          --_M_num_elements;\n           break;\n         }\n         else {\n-          cur = next;\n-          next = cur->next;\n+          __cur = __next;\n+          __next = __cur->_M_next;\n         }\n       }\n     }\n   }\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::erase(iterator first, iterator last)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::erase(iterator __first, iterator __last)\n {\n-  size_type f_bucket = first.cur ? bkt_num(first.cur->val) : buckets.size();\n-  size_type l_bucket = last.cur ? bkt_num(last.cur->val) : buckets.size();\n+  size_type __f_bucket = __first._M_cur ? \n+    _M_bkt_num(__first._M_cur->_M_val) : _M_buckets.size();\n+  size_type __l_bucket = __last._M_cur ? \n+    _M_bkt_num(__last._M_cur->_M_val) : _M_buckets.size();\n \n-  if (first.cur == last.cur)\n+  if (__first._M_cur == __last._M_cur)\n     return;\n-  else if (f_bucket == l_bucket)\n-    erase_bucket(f_bucket, first.cur, last.cur);\n+  else if (__f_bucket == __l_bucket)\n+    _M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n   else {\n-    erase_bucket(f_bucket, first.cur, 0);\n-    for (size_type n = f_bucket + 1; n < l_bucket; ++n)\n-      erase_bucket(n, 0);\n-    if (l_bucket != buckets.size())\n-      erase_bucket(l_bucket, last.cur);\n+    _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n+    for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n+      _M_erase_bucket(__n, 0);\n+    if (__l_bucket != _M_buckets.size())\n+      _M_erase_bucket(__l_bucket, __last._M_cur);\n   }\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n inline void\n-hashtable<V, K, HF, Ex, Eq, A>::erase(const_iterator first,\n-                                      const_iterator last)\n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const_iterator __first,\n+                                             const_iterator __last)\n {\n-  erase(iterator(const_cast<node*>(first.cur),\n-                 const_cast<hashtable*>(first.ht)),\n-        iterator(const_cast<node*>(last.cur),\n-                 const_cast<hashtable*>(last.ht)));\n+  erase(iterator(const_cast<_Node*>(__first._M_cur),\n+                 const_cast<hashtable*>(__first._M_ht)),\n+        iterator(const_cast<_Node*>(__last._M_cur),\n+                 const_cast<hashtable*>(__last._M_ht)));\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n inline void\n-hashtable<V, K, HF, Ex, Eq, A>::erase(const const_iterator& it)\n+hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const const_iterator& __it)\n {\n-  erase(iterator(const_cast<node*>(it.cur),\n-                 const_cast<hashtable*>(it.ht)));\n+  erase(iterator(const_cast<_Node*>(__it._M_cur),\n+                 const_cast<hashtable*>(__it._M_ht)));\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::resize(size_type __num_elements_hint)\n {\n-  const size_type old_n = buckets.size();\n-  if (num_elements_hint > old_n) {\n-    const size_type n = next_size(num_elements_hint);\n-    if (n > old_n) {\n-      vector<node*, A> tmp(n, (node*) 0);\n+  const size_type __old_n = _M_buckets.size();\n+  if (__num_elements_hint > __old_n) {\n+    const size_type __n = _M_next_size(__num_elements_hint);\n+    if (__n > __old_n) {\n+      vector<_Node*, _All> __tmp(__n, (_Node*)(0),\n+                                 _M_buckets.get_allocator());\n       __STL_TRY {\n-        for (size_type bucket = 0; bucket < old_n; ++bucket) {\n-          node* first = buckets[bucket];\n-          while (first) {\n-            size_type new_bucket = bkt_num(first->val, n);\n-            buckets[bucket] = first->next;\n-            first->next = tmp[new_bucket];\n-            tmp[new_bucket] = first;\n-            first = buckets[bucket];          \n+        for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {\n+          _Node* __first = _M_buckets[__bucket];\n+          while (__first) {\n+            size_type __new_bucket = _M_bkt_num(__first->_M_val, __n);\n+            _M_buckets[__bucket] = __first->_M_next;\n+            __first->_M_next = __tmp[__new_bucket];\n+            __tmp[__new_bucket] = __first;\n+            __first = _M_buckets[__bucket];          \n           }\n         }\n-        buckets.swap(tmp);\n+        _M_buckets.swap(__tmp);\n       }\n #         ifdef __STL_USE_EXCEPTIONS\n       catch(...) {\n-        for (size_type bucket = 0; bucket < tmp.size(); ++bucket) {\n-          while (tmp[bucket]) {\n-            node* next = tmp[bucket]->next;\n-            delete_node(tmp[bucket]);\n-            tmp[bucket] = next;\n+        for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {\n+          while (__tmp[__bucket]) {\n+            _Node* __next = __tmp[__bucket]->_M_next;\n+            _M_delete_node(__tmp[__bucket]);\n+            __tmp[__bucket] = __next;\n           }\n         }\n         throw;\n@@ -866,75 +952,80 @@ void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)\n   }\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, \n-                                                  node* first, node* last)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::_M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n {\n-  node* cur = buckets[n];\n-  if (cur == first)\n-    erase_bucket(n, last);\n+  _Node* __cur = _M_buckets[__n];\n+  if (__cur == __first)\n+    _M_erase_bucket(__n, __last);\n   else {\n-    node* next;\n-    for (next = cur->next; next != first; cur = next, next = cur->next)\n+    _Node* __next;\n+    for (__next = __cur->_M_next; \n+         __next != __first; \n+         __cur = __next, __next = __cur->_M_next)\n       ;\n-    while (next) {\n-      cur->next = next->next;\n-      delete_node(next);\n-      next = cur->next;\n-      --num_elements;\n+    while (__next) {\n+      __cur->_M_next = __next->_M_next;\n+      _M_delete_node(__next);\n+      __next = __cur->_M_next;\n+      --_M_num_elements;\n     }\n   }\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void \n-hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, node* last)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::_M_erase_bucket(const size_type __n, _Node* __last)\n {\n-  node* cur = buckets[n];\n-  while (cur != last) {\n-    node* next = cur->next;\n-    delete_node(cur);\n-    cur = next;\n-    buckets[n] = cur;\n-    --num_elements;\n+  _Node* __cur = _M_buckets[__n];\n+  while (__cur != __last) {\n+    _Node* __next = __cur->_M_next;\n+    _M_delete_node(__cur);\n+    __cur = __next;\n+    _M_buckets[__n] = __cur;\n+    --_M_num_elements;\n   }\n }\n \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::clear()\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::clear()\n {\n-  for (size_type i = 0; i < buckets.size(); ++i) {\n-    node* cur = buckets[i];\n-    while (cur != 0) {\n-      node* next = cur->next;\n-      delete_node(cur);\n-      cur = next;\n+  for (size_type __i = 0; __i < _M_buckets.size(); ++__i) {\n+    _Node* __cur = _M_buckets[__i];\n+    while (__cur != 0) {\n+      _Node* __next = __cur->_M_next;\n+      _M_delete_node(__cur);\n+      __cur = __next;\n     }\n-    buckets[i] = 0;\n+    _M_buckets[__i] = 0;\n   }\n-  num_elements = 0;\n+  _M_num_elements = 0;\n }\n \n     \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)\n+template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n+  ::_M_copy_from(const hashtable& __ht)\n {\n-  buckets.clear();\n-  buckets.reserve(ht.buckets.size());\n-  buckets.insert(buckets.end(), ht.buckets.size(), (node*) 0);\n+  _M_buckets.clear();\n+  _M_buckets.reserve(__ht._M_buckets.size());\n+  _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n   __STL_TRY {\n-    for (size_type i = 0; i < ht.buckets.size(); ++i) {\n-      if (const node* cur = ht.buckets[i]) {\n-        node* copy = new_node(cur->val);\n-        buckets[i] = copy;\n-\n-        for (node* next = cur->next; next; cur = next, next = cur->next) {\n-          copy->next = new_node(next->val);\n-          copy = copy->next;\n+    for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n+      if (const _Node* __cur = __ht._M_buckets[__i]) {\n+        _Node* __copy = _M_new_node(__cur->_M_val);\n+        _M_buckets[__i] = __copy;\n+\n+        for (_Node* __next = __cur->_M_next; \n+             __next; \n+             __cur = __next, __next = __cur->_M_next) {\n+          __copy->_M_next = _M_new_node(__next->_M_val);\n+          __copy = __copy->_M_next;\n         }\n       }\n     }\n-    num_elements = ht.num_elements;\n+    _M_num_elements = __ht._M_num_elements;\n   }\n   __STL_UNWIND(clear());\n }"}, {"sha": "62f142ec9706da68360f05e0aef412957ffce7a6", "filename": "libstdc++/stl/stl_heap.h", "status": "modified", "additions": 186, "deletions": 131, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_heap.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -36,181 +36,236 @@ __STL_BEGIN_NAMESPACE\n #pragma set woff 1209\n #endif\n \n-template <class RandomAccessIterator, class Distance, class T>\n-void __push_heap(RandomAccessIterator first, Distance holeIndex,\n-                 Distance topIndex, T value) {\n-  Distance parent = (holeIndex - 1) / 2;\n-  while (holeIndex > topIndex && *(first + parent) < value) {\n-    *(first + holeIndex) = *(first + parent);\n-    holeIndex = parent;\n-    parent = (holeIndex - 1) / 2;\n+// Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.\n+\n+template <class _RandomAccessIterator, class _Distance, class _Tp>\n+void \n+__push_heap(_RandomAccessIterator __first,\n+            _Distance __holeIndex, _Distance __topIndex, _Tp __value)\n+{\n+  _Distance __parent = (__holeIndex - 1) / 2;\n+  while (__holeIndex > __topIndex && *(__first + __parent) < __value) {\n+    *(__first + __holeIndex) = *(__first + __parent);\n+    __holeIndex = __parent;\n+    __parent = (__holeIndex - 1) / 2;\n   }    \n-  *(first + holeIndex) = value;\n+  *(__first + __holeIndex) = __value;\n }\n \n-template <class RandomAccessIterator, class Distance, class T>\n-inline void __push_heap_aux(RandomAccessIterator first,\n-                            RandomAccessIterator last, Distance*, T*) {\n-  __push_heap(first, Distance((last - first) - 1), Distance(0), \n-              T(*(last - 1)));\n+template <class _RandomAccessIterator, class _Distance, class _Tp>\n+inline void \n+__push_heap_aux(_RandomAccessIterator __first,\n+                _RandomAccessIterator __last, _Distance*, _Tp*)\n+{\n+  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), \n+              _Tp(*(__last - 1)));\n }\n \n-template <class RandomAccessIterator>\n-inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-  __push_heap_aux(first, last, distance_type(first), value_type(first));\n+template <class _RandomAccessIterator>\n+inline void \n+push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+{\n+  __push_heap_aux(__first, __last,\n+                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));\n }\n \n-template <class RandomAccessIterator, class Distance, class T, class Compare>\n-void __push_heap(RandomAccessIterator first, Distance holeIndex,\n-                 Distance topIndex, T value, Compare comp) {\n-  Distance parent = (holeIndex - 1) / 2;\n-  while (holeIndex > topIndex && comp(*(first + parent), value)) {\n-    *(first + holeIndex) = *(first + parent);\n-    holeIndex = parent;\n-    parent = (holeIndex - 1) / 2;\n+template <class _RandomAccessIterator, class _Distance, class _Tp, \n+          class _Compare>\n+void\n+__push_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n+            _Distance __topIndex, _Tp __value, _Compare __comp)\n+{\n+  _Distance __parent = (__holeIndex - 1) / 2;\n+  while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {\n+    *(__first + __holeIndex) = *(__first + __parent);\n+    __holeIndex = __parent;\n+    __parent = (__holeIndex - 1) / 2;\n   }\n-  *(first + holeIndex) = value;\n-}\n-\n-template <class RandomAccessIterator, class Compare, class Distance, class T>\n-inline void __push_heap_aux(RandomAccessIterator first,\n-                            RandomAccessIterator last, Compare comp,\n-                            Distance*, T*) {\n-  __push_heap(first, Distance((last - first) - 1), Distance(0), \n-              T(*(last - 1)), comp);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,\n-                      Compare comp) {\n-  __push_heap_aux(first, last, comp, distance_type(first), value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class Distance, class T>\n-void __adjust_heap(RandomAccessIterator first, Distance holeIndex,\n-                   Distance len, T value) {\n-  Distance topIndex = holeIndex;\n-  Distance secondChild = 2 * holeIndex + 2;\n-  while (secondChild < len) {\n-    if (*(first + secondChild) < *(first + (secondChild - 1)))\n-      secondChild--;\n-    *(first + holeIndex) = *(first + secondChild);\n-    holeIndex = secondChild;\n-    secondChild = 2 * (secondChild + 1);\n+  *(__first + __holeIndex) = __value;\n+}\n+\n+template <class _RandomAccessIterator, class _Compare,\n+          class _Distance, class _Tp>\n+inline void \n+__push_heap_aux(_RandomAccessIterator __first,\n+                _RandomAccessIterator __last, _Compare __comp,\n+                _Distance*, _Tp*) \n+{\n+  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), \n+              _Tp(*(__last - 1)), __comp);\n+}\n+\n+template <class _RandomAccessIterator, class _Compare>\n+inline void \n+push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+          _Compare __comp)\n+{\n+  __push_heap_aux(__first, __last, __comp,\n+                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));\n+}\n+\n+template <class _RandomAccessIterator, class _Distance, class _Tp>\n+void \n+__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n+              _Distance __len, _Tp __value)\n+{\n+  _Distance __topIndex = __holeIndex;\n+  _Distance __secondChild = 2 * __holeIndex + 2;\n+  while (__secondChild < __len) {\n+    if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))\n+      __secondChild--;\n+    *(__first + __holeIndex) = *(__first + __secondChild);\n+    __holeIndex = __secondChild;\n+    __secondChild = 2 * (__secondChild + 1);\n   }\n-  if (secondChild == len) {\n-    *(first + holeIndex) = *(first + (secondChild - 1));\n-    holeIndex = secondChild - 1;\n+  if (__secondChild == __len) {\n+    *(__first + __holeIndex) = *(__first + (__secondChild - 1));\n+    __holeIndex = __secondChild - 1;\n   }\n-  __push_heap(first, holeIndex, topIndex, value);\n+  __push_heap(__first, __holeIndex, __topIndex, __value);\n }\n \n-template <class RandomAccessIterator, class T, class Distance>\n-inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,\n-                       RandomAccessIterator result, T value, Distance*) {\n-  *result = *first;\n-  __adjust_heap(first, Distance(0), Distance(last - first), value);\n+template <class _RandomAccessIterator, class _Tp, class _Distance>\n+inline void \n+__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+           _RandomAccessIterator __result, _Tp __value, _Distance*)\n+{\n+  *__result = *__first;\n+  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);\n }\n \n-template <class RandomAccessIterator, class T>\n-inline void __pop_heap_aux(RandomAccessIterator first,\n-                           RandomAccessIterator last, T*) {\n-  __pop_heap(first, last - 1, last - 1, T(*(last - 1)), distance_type(first));\n+template <class _RandomAccessIterator, class _Tp>\n+inline void \n+__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+               _Tp*)\n+{\n+  __pop_heap(__first, __last - 1, __last - 1, \n+             _Tp(*(__last - 1)), __DISTANCE_TYPE(__first));\n }\n \n-template <class RandomAccessIterator>\n-inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-  __pop_heap_aux(first, last, value_type(first));\n+template <class _RandomAccessIterator>\n+inline void pop_heap(_RandomAccessIterator __first, \n+                     _RandomAccessIterator __last)\n+{\n+  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));\n }\n \n-template <class RandomAccessIterator, class Distance, class T, class Compare>\n-void __adjust_heap(RandomAccessIterator first, Distance holeIndex,\n-                   Distance len, T value, Compare comp) {\n-  Distance topIndex = holeIndex;\n-  Distance secondChild = 2 * holeIndex + 2;\n-  while (secondChild < len) {\n-    if (comp(*(first + secondChild), *(first + (secondChild - 1))))\n-      secondChild--;\n-    *(first + holeIndex) = *(first + secondChild);\n-    holeIndex = secondChild;\n-    secondChild = 2 * (secondChild + 1);\n+template <class _RandomAccessIterator, class _Distance,\n+          class _Tp, class _Compare>\n+void\n+__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n+              _Distance __len, _Tp __value, _Compare __comp)\n+{\n+  _Distance __topIndex = __holeIndex;\n+  _Distance __secondChild = 2 * __holeIndex + 2;\n+  while (__secondChild < __len) {\n+    if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))\n+      __secondChild--;\n+    *(__first + __holeIndex) = *(__first + __secondChild);\n+    __holeIndex = __secondChild;\n+    __secondChild = 2 * (__secondChild + 1);\n   }\n-  if (secondChild == len) {\n-    *(first + holeIndex) = *(first + (secondChild - 1));\n-    holeIndex = secondChild - 1;\n+  if (__secondChild == __len) {\n+    *(__first + __holeIndex) = *(__first + (__secondChild - 1));\n+    __holeIndex = __secondChild - 1;\n   }\n-  __push_heap(first, holeIndex, topIndex, value, comp);\n+  __push_heap(__first, __holeIndex, __topIndex, __value, __comp);\n }\n \n-template <class RandomAccessIterator, class T, class Compare, class Distance>\n-inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,\n-                       RandomAccessIterator result, T value, Compare comp,\n-                       Distance*) {\n-  *result = *first;\n-  __adjust_heap(first, Distance(0), Distance(last - first), value, comp);\n+template <class _RandomAccessIterator, class _Tp, class _Compare, \n+          class _Distance>\n+inline void \n+__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+           _RandomAccessIterator __result, _Tp __value, _Compare __comp,\n+           _Distance*)\n+{\n+  *__result = *__first;\n+  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), \n+                __value, __comp);\n }\n \n-template <class RandomAccessIterator, class T, class Compare>\n-inline void __pop_heap_aux(RandomAccessIterator first,\n-                           RandomAccessIterator last, T*, Compare comp) {\n-  __pop_heap(first, last - 1, last - 1, T(*(last - 1)), comp,\n-             distance_type(first));\n+template <class _RandomAccessIterator, class _Tp, class _Compare>\n+inline void \n+__pop_heap_aux(_RandomAccessIterator __first,\n+               _RandomAccessIterator __last, _Tp*, _Compare __comp)\n+{\n+  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __comp,\n+             __DISTANCE_TYPE(__first));\n }\n \n-template <class RandomAccessIterator, class Compare>\n-inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,\n-                     Compare comp) {\n-    __pop_heap_aux(first, last, value_type(first), comp);\n+template <class _RandomAccessIterator, class _Compare>\n+inline void \n+pop_heap(_RandomAccessIterator __first,\n+         _RandomAccessIterator __last, _Compare __comp)\n+{\n+    __pop_heap_aux(__first, __last, __VALUE_TYPE(__first), __comp);\n }\n \n-template <class RandomAccessIterator, class T, class Distance>\n-void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,\n-                 Distance*) {\n-  if (last - first < 2) return;\n-  Distance len = last - first;\n-  Distance parent = (len - 2)/2;\n+template <class _RandomAccessIterator, class _Tp, class _Distance>\n+void \n+__make_heap(_RandomAccessIterator __first,\n+            _RandomAccessIterator __last, _Tp*, _Distance*)\n+{\n+  if (__last - __first < 2) return;\n+  _Distance __len = __last - __first;\n+  _Distance __parent = (__len - 2)/2;\n     \n   while (true) {\n-    __adjust_heap(first, parent, len, T(*(first + parent)));\n-    if (parent == 0) return;\n-    parent--;\n+    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));\n+    if (__parent == 0) return;\n+    __parent--;\n   }\n }\n \n-template <class RandomAccessIterator>\n-inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-  __make_heap(first, last, value_type(first), distance_type(first));\n+template <class _RandomAccessIterator>\n+inline void \n+make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+{\n+  __make_heap(__first, __last,\n+              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));\n }\n \n-template <class RandomAccessIterator, class Compare, class T, class Distance>\n-void __make_heap(RandomAccessIterator first, RandomAccessIterator last,\n-                 Compare comp, T*, Distance*) {\n-  if (last - first < 2) return;\n-  Distance len = last - first;\n-  Distance parent = (len - 2)/2;\n+template <class _RandomAccessIterator, class _Compare,\n+          class _Tp, class _Distance>\n+void\n+__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+            _Compare __comp, _Tp*, _Distance*)\n+{\n+  if (__last - __first < 2) return;\n+  _Distance __len = __last - __first;\n+  _Distance __parent = (__len - 2)/2;\n     \n   while (true) {\n-    __adjust_heap(first, parent, len, T(*(first + parent)), comp);\n-    if (parent == 0) return;\n-    parent--;\n+    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)),\n+                  __comp);\n+    if (__parent == 0) return;\n+    __parent--;\n   }\n }\n \n-template <class RandomAccessIterator, class Compare>\n-inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,\n-                      Compare comp) {\n-  __make_heap(first, last, comp, value_type(first), distance_type(first));\n+template <class _RandomAccessIterator, class _Compare>\n+inline void \n+make_heap(_RandomAccessIterator __first, \n+          _RandomAccessIterator __last, _Compare __comp)\n+{\n+  __make_heap(__first, __last, __comp,\n+              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));\n }\n \n-template <class RandomAccessIterator>\n-void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-  while (last - first > 1) pop_heap(first, last--);\n+template <class _RandomAccessIterator>\n+void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+{\n+  while (__last - __first > 1)\n+    pop_heap(__first, __last--);\n }\n \n-template <class RandomAccessIterator, class Compare>\n-void sort_heap(RandomAccessIterator first, RandomAccessIterator last,\n-               Compare comp) {\n-  while (last - first > 1) pop_heap(first, last--, comp);\n+template <class _RandomAccessIterator, class _Compare>\n+void \n+sort_heap(_RandomAccessIterator __first,\n+          _RandomAccessIterator __last, _Compare __comp)\n+{\n+  while (__last - __first > 1)\n+    pop_heap(__first, __last--, __comp);\n }\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)"}, {"sha": "e2bd7149692c05e3f3c5b36cd2707c26f07b4049", "filename": "libstdc++/stl/stl_iterator.h", "status": "modified", "additions": 489, "deletions": 417, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_iterator.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996,1997\n+ * Copyright (c) 1996-1998\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -39,12 +39,17 @@ struct forward_iterator_tag : public input_iterator_tag {};\n struct bidirectional_iterator_tag : public forward_iterator_tag {};\n struct random_access_iterator_tag : public bidirectional_iterator_tag {};\n \n-template <class T, class Distance> struct input_iterator {\n+// The base classes input_iterator, output_iterator, forward_iterator,\n+// bidirectional_iterator, and random_access_iterator are not part of\n+// the C++ standard.  (they have been replaced by struct iterator.)\n+// They are included for backward compatibility with the HP STL.\n+\n+template <class _Tp, class _Distance> struct input_iterator {\n   typedef input_iterator_tag iterator_category;\n-  typedef T                  value_type;\n-  typedef Distance           difference_type;\n-  typedef T*                 pointer;\n-  typedef T&                 reference;\n+  typedef _Tp                value_type;\n+  typedef _Distance          difference_type;\n+  typedef _Tp*               pointer;\n+  typedef _Tp&               reference;\n };\n \n struct output_iterator {\n@@ -55,459 +60,502 @@ struct output_iterator {\n   typedef void                reference;\n };\n \n-template <class T, class Distance> struct forward_iterator {\n+template <class _Tp, class _Distance> struct forward_iterator {\n   typedef forward_iterator_tag iterator_category;\n-  typedef T                    value_type;\n-  typedef Distance             difference_type;\n-  typedef T*                   pointer;\n-  typedef T&                   reference;\n+  typedef _Tp                  value_type;\n+  typedef _Distance            difference_type;\n+  typedef _Tp*                 pointer;\n+  typedef _Tp&                 reference;\n };\n \n \n-template <class T, class Distance> struct bidirectional_iterator {\n+template <class _Tp, class _Distance> struct bidirectional_iterator {\n   typedef bidirectional_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef Distance                   difference_type;\n-  typedef T*                         pointer;\n-  typedef T&                         reference;\n+  typedef _Tp                        value_type;\n+  typedef _Distance                  difference_type;\n+  typedef _Tp*                       pointer;\n+  typedef _Tp&                       reference;\n };\n \n-template <class T, class Distance> struct random_access_iterator {\n+template <class _Tp, class _Distance> struct random_access_iterator {\n   typedef random_access_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef Distance                   difference_type;\n-  typedef T*                         pointer;\n-  typedef T&                         reference;\n+  typedef _Tp                        value_type;\n+  typedef _Distance                  difference_type;\n+  typedef _Tp*                       pointer;\n+  typedef _Tp&                       reference;\n };\n \n #ifdef __STL_USE_NAMESPACES\n-template <class Category, class T, class Distance = ptrdiff_t,\n-          class Pointer = T*, class Reference = T&>\n+template <class _Category, class _Tp, class _Distance = ptrdiff_t,\n+          class _Pointer = _Tp*, class _Reference = _Tp&>\n struct iterator {\n-  typedef Category  iterator_category;\n-  typedef T         value_type;\n-  typedef Distance  difference_type;\n-  typedef Pointer   pointer;\n-  typedef Reference reference;\n+  typedef _Category  iterator_category;\n+  typedef _Tp        value_type;\n+  typedef _Distance  difference_type;\n+  typedef _Pointer   pointer;\n+  typedef _Reference reference;\n };\n #endif /* __STL_USE_NAMESPACES */\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class Iterator>\n+template <class _Iterator>\n struct iterator_traits {\n-  typedef typename Iterator::iterator_category iterator_category;\n-  typedef typename Iterator::value_type        value_type;\n-  typedef typename Iterator::difference_type   difference_type;\n-  typedef typename Iterator::pointer           pointer;\n-  typedef typename Iterator::reference         reference;\n+  typedef typename _Iterator::iterator_category iterator_category;\n+  typedef typename _Iterator::value_type        value_type;\n+  typedef typename _Iterator::difference_type   difference_type;\n+  typedef typename _Iterator::pointer           pointer;\n+  typedef typename _Iterator::reference         reference;\n };\n \n-template <class T>\n-struct iterator_traits<T*> {\n+template <class _Tp>\n+struct iterator_traits<_Tp*> {\n   typedef random_access_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef ptrdiff_t                  difference_type;\n-  typedef T*                         pointer;\n-  typedef T&                         reference;\n+  typedef _Tp                         value_type;\n+  typedef ptrdiff_t                   difference_type;\n+  typedef _Tp*                        pointer;\n+  typedef _Tp&                        reference;\n };\n \n-template <class T>\n-struct iterator_traits<const T*> {\n+template <class _Tp>\n+struct iterator_traits<const _Tp*> {\n   typedef random_access_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef ptrdiff_t                  difference_type;\n-  typedef const T*                   pointer;\n-  typedef const T&                   reference;\n+  typedef _Tp                         value_type;\n+  typedef ptrdiff_t                   difference_type;\n+  typedef const _Tp*                  pointer;\n+  typedef const _Tp&                  reference;\n };\n \n-template <class Iterator>\n-inline typename iterator_traits<Iterator>::iterator_category\n-iterator_category(const Iterator&) {\n-  typedef typename iterator_traits<Iterator>::iterator_category category;\n-  return category();\n+// The overloaded functions iterator_category, distance_type, and\n+// value_type are not part of the C++ standard.  (They have been\n+// replaced by struct iterator_traits.)  They are included for\n+// backward compatibility with the HP STL.\n+\n+// We introduce internal names for these functions.\n+\n+template <class _Iter>\n+inline typename iterator_traits<_Iter>::iterator_category\n+__iterator_category(const _Iter&)\n+{\n+  typedef typename iterator_traits<_Iter>::iterator_category _Category;\n+  return _Category();\n }\n \n-template <class Iterator>\n-inline typename iterator_traits<Iterator>::difference_type*\n-distance_type(const Iterator&) {\n-  return static_cast<typename iterator_traits<Iterator>::difference_type*>(0);\n+template <class _Iter>\n+inline typename iterator_traits<_Iter>::difference_type*\n+__distance_type(const _Iter&)\n+{\n+  return static_cast<typename iterator_traits<_Iter>::difference_type*>(0);\n }\n \n-template <class Iterator>\n-inline typename iterator_traits<Iterator>::value_type*\n-value_type(const Iterator&) {\n-  return static_cast<typename iterator_traits<Iterator>::value_type*>(0);\n+template <class _Iter>\n+inline typename iterator_traits<_Iter>::value_type*\n+__value_type(const _Iter&)\n+{\n+  return static_cast<typename iterator_traits<_Iter>::value_type*>(0);\n }\n \n+template <class _Iter>\n+inline typename iterator_traits<_Iter>::iterator_category\n+iterator_category(const _Iter& __i) { return __iterator_category(__i); }\n+\n+\n+template <class _Iter>\n+inline typename iterator_traits<_Iter>::difference_type*\n+distance_type(const _Iter& __i) { return __distance_type(__i); }\n+\n+template <class _Iter>\n+inline typename iterator_traits<_Iter>::value_type*\n+value_type(const _Iter& __i) { return __value_type(__i); }\n+\n+#define __ITERATOR_CATEGORY(__i) __iterator_category(__i)\n+#define __DISTANCE_TYPE(__i)     __distance_type(__i)\n+#define __VALUE_TYPE(__i)        __value_type(__i)\n+\n #else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class T, class Distance> \n+template <class _Tp, class _Distance> \n inline input_iterator_tag \n-iterator_category(const input_iterator<T, Distance>&) {\n-  return input_iterator_tag();\n-}\n+iterator_category(const input_iterator<_Tp, _Distance>&)\n+  { return input_iterator_tag(); }\n \n-inline output_iterator_tag iterator_category(const output_iterator&) {\n-  return output_iterator_tag();\n-}\n+inline output_iterator_tag iterator_category(const output_iterator&)\n+  { return output_iterator_tag(); }\n \n-template <class T, class Distance> \n+template <class _Tp, class _Distance> \n inline forward_iterator_tag\n-iterator_category(const forward_iterator<T, Distance>&) {\n-  return forward_iterator_tag();\n-}\n+iterator_category(const forward_iterator<_Tp, _Distance>&)\n+  { return forward_iterator_tag(); }\n \n-template <class T, class Distance> \n+template <class _Tp, class _Distance> \n inline bidirectional_iterator_tag\n-iterator_category(const bidirectional_iterator<T, Distance>&) {\n-  return bidirectional_iterator_tag();\n-}\n+iterator_category(const bidirectional_iterator<_Tp, _Distance>&)\n+  { return bidirectional_iterator_tag(); }\n \n-template <class T, class Distance> \n+template <class _Tp, class _Distance> \n inline random_access_iterator_tag\n-iterator_category(const random_access_iterator<T, Distance>&) {\n-  return random_access_iterator_tag();\n-}\n+iterator_category(const random_access_iterator<_Tp, _Distance>&)\n+  { return random_access_iterator_tag(); }\n \n-template <class T>\n-inline random_access_iterator_tag iterator_category(const T*) {\n-  return random_access_iterator_tag();\n-}\n+template <class _Tp>\n+inline random_access_iterator_tag iterator_category(const _Tp*)\n+  { return random_access_iterator_tag(); }\n \n-template <class T, class Distance> \n-inline T* value_type(const input_iterator<T, Distance>&) {\n-  return (T*)(0); \n-}\n+template <class _Tp, class _Distance> \n+inline _Tp* value_type(const input_iterator<_Tp, _Distance>&)\n+  { return (_Tp*)(0); }\n \n-template <class T, class Distance> \n-inline T* value_type(const forward_iterator<T, Distance>&) {\n-  return (T*)(0);\n-}\n+template <class _Tp, class _Distance> \n+inline _Tp* value_type(const forward_iterator<_Tp, _Distance>&)\n+  { return (_Tp*)(0); }\n \n-template <class T, class Distance> \n-inline T* value_type(const bidirectional_iterator<T, Distance>&) {\n-  return (T*)(0);\n-}\n+template <class _Tp, class _Distance> \n+inline _Tp* value_type(const bidirectional_iterator<_Tp, _Distance>&)\n+  { return (_Tp*)(0); }\n \n-template <class T, class Distance> \n-inline T* value_type(const random_access_iterator<T, Distance>&) {\n-  return (T*)(0);\n-}\n+template <class _Tp, class _Distance> \n+inline _Tp* value_type(const random_access_iterator<_Tp, _Distance>&)\n+  { return (_Tp*)(0); }\n \n-template <class T>\n-inline T* value_type(const T*) { return (T*)(0); }\n+template <class _Tp>\n+inline _Tp* value_type(const _Tp*) { return (_Tp*)(0); }\n \n-template <class T, class Distance> \n-inline Distance* distance_type(const input_iterator<T, Distance>&) {\n-  return (Distance*)(0);\n+template <class _Tp, class _Distance> \n+inline _Distance* distance_type(const input_iterator<_Tp, _Distance>&)\n+{\n+  return (_Distance*)(0);\n }\n \n-template <class T, class Distance> \n-inline Distance* distance_type(const forward_iterator<T, Distance>&) {\n-  return (Distance*)(0);\n+template <class _Tp, class _Distance> \n+inline _Distance* distance_type(const forward_iterator<_Tp, _Distance>&)\n+{\n+  return (_Distance*)(0);\n }\n \n-template <class T, class Distance> \n-inline Distance* \n-distance_type(const bidirectional_iterator<T, Distance>&) {\n-  return (Distance*)(0);\n+template <class _Tp, class _Distance> \n+inline _Distance* \n+distance_type(const bidirectional_iterator<_Tp, _Distance>&)\n+{\n+  return (_Distance*)(0);\n }\n \n-template <class T, class Distance> \n-inline Distance* \n-distance_type(const random_access_iterator<T, Distance>&) {\n-  return (Distance*)(0);\n+template <class _Tp, class _Distance> \n+inline _Distance* \n+distance_type(const random_access_iterator<_Tp, _Distance>&)\n+{\n+  return (_Distance*)(0);\n }\n \n-template <class T>\n-inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }\n+template <class _Tp>\n+inline ptrdiff_t* distance_type(const _Tp*) { return (ptrdiff_t*)(0); }\n+\n+// Without partial specialization we can't use iterator_traits, so\n+// we must keep the old iterator query functions around.  \n+\n+#define __ITERATOR_CATEGORY(__i) iterator_category(__i)\n+#define __DISTANCE_TYPE(__i)     distance_type(__i)\n+#define __VALUE_TYPE(__i)        value_type(__i)\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class InputIterator, class Distance>\n-inline void __distance(InputIterator first, InputIterator last, Distance& n, \n-                       input_iterator_tag) {\n-  while (first != last) { ++first; ++n; }\n+template <class _InputIterator, class _Distance>\n+inline void __distance(_InputIterator __first, _InputIterator __last,\n+                       _Distance& __n, input_iterator_tag)\n+{\n+  while (__first != __last) { ++__first; ++__n; }\n }\n \n-template <class RandomAccessIterator, class Distance>\n-inline void __distance(RandomAccessIterator first, RandomAccessIterator last, \n-                       Distance& n, random_access_iterator_tag) {\n-  n += last - first;\n+template <class _RandomAccessIterator, class _Distance>\n+inline void __distance(_RandomAccessIterator __first, \n+                       _RandomAccessIterator __last, \n+                       _Distance& __n, random_access_iterator_tag)\n+{\n+  __n += __last - __first;\n }\n \n-template <class InputIterator, class Distance>\n-inline void distance(InputIterator first, InputIterator last, Distance& n) {\n-  __distance(first, last, n, iterator_category(first));\n+template <class _InputIterator, class _Distance>\n+inline void distance(_InputIterator __first, \n+                     _InputIterator __last, _Distance& __n)\n+{\n+  __distance(__first, __last, __n, iterator_category(__first));\n }\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class InputIterator>\n-inline iterator_traits<InputIterator>::difference_type\n-__distance(InputIterator first, InputIterator last, input_iterator_tag) {\n-  iterator_traits<InputIterator>::difference_type n = 0;\n-  while (first != last) {\n-    ++first; ++n;\n+template <class _InputIterator>\n+inline typename iterator_traits<_InputIterator>::difference_type\n+__distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n+{\n+  typename iterator_traits<_InputIterator>::difference_type __n = 0;\n+  while (__first != __last) {\n+    ++__first; ++__n;\n   }\n-  return n;\n+  return __n;\n }\n \n-template <class RandomAccessIterator>\n-inline iterator_traits<RandomAccessIterator>::difference_type\n-__distance(RandomAccessIterator first, RandomAccessIterator last,\n+template <class _RandomAccessIterator>\n+inline typename iterator_traits<_RandomAccessIterator>::difference_type\n+__distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n            random_access_iterator_tag) {\n-  return last - first;\n+  return __last - __first;\n }\n \n-template <class InputIterator>\n-inline iterator_traits<InputIterator>::difference_type\n-distance(InputIterator first, InputIterator last) {\n-  typedef typename iterator_traits<InputIterator>::iterator_category category;\n-  return __distance(first, last, category());\n+template <class _InputIterator>\n+inline typename iterator_traits<_InputIterator>::difference_type\n+distance(_InputIterator __first, _InputIterator __last) {\n+  typedef typename iterator_traits<_InputIterator>::iterator_category \n+    _Category;\n+  return __distance(__first, __last, _Category());\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class InputIterator, class Distance>\n-inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {\n-  while (n--) ++i;\n+template <class _InputIter, class _Distance>\n+inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag) {\n+  while (__n--) ++__i;\n }\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1183\n #endif\n \n-template <class BidirectionalIterator, class Distance>\n-inline void __advance(BidirectionalIterator& i, Distance n, \n+template <class _BidirectionalIterator, class _Distance>\n+inline void __advance(_BidirectionalIterator& __i, _Distance __n, \n                       bidirectional_iterator_tag) {\n-  if (n >= 0)\n-    while (n--) ++i;\n+  if (__n >= 0)\n+    while (__n--) ++__i;\n   else\n-    while (n++) --i;\n+    while (__n++) --__i;\n }\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1183\n #endif\n \n-template <class RandomAccessIterator, class Distance>\n-inline void __advance(RandomAccessIterator& i, Distance n, \n+template <class _RandomAccessIterator, class _Distance>\n+inline void __advance(_RandomAccessIterator& __i, _Distance __n, \n                       random_access_iterator_tag) {\n-  i += n;\n+  __i += __n;\n }\n \n-template <class InputIterator, class Distance>\n-inline void advance(InputIterator& i, Distance n) {\n-  __advance(i, n, iterator_category(i));\n+template <class _InputIterator, class _Distance>\n+inline void advance(_InputIterator& __i, _Distance __n) {\n+  __advance(__i, __n, iterator_category(__i));\n }\n \n-template <class Container>\n+template <class _Container>\n class back_insert_iterator {\n protected:\n-  Container* container;\n+  _Container* container;\n public:\n+  typedef _Container          container_type;\n   typedef output_iterator_tag iterator_category;\n   typedef void                value_type;\n   typedef void                difference_type;\n   typedef void                pointer;\n   typedef void                reference;\n \n-  explicit back_insert_iterator(Container& x) : container(&x) {}\n-  back_insert_iterator<Container>&\n-  operator=(const typename Container::value_type& value) { \n-    container->push_back(value);\n+  explicit back_insert_iterator(_Container& __x) : container(&__x) {}\n+  back_insert_iterator<_Container>&\n+  operator=(const typename _Container::value_type& __value) { \n+    container->push_back(__value);\n     return *this;\n   }\n-  back_insert_iterator<Container>& operator*() { return *this; }\n-  back_insert_iterator<Container>& operator++() { return *this; }\n-  back_insert_iterator<Container>& operator++(int) { return *this; }\n+  back_insert_iterator<_Container>& operator*() { return *this; }\n+  back_insert_iterator<_Container>& operator++() { return *this; }\n+  back_insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class Container>\n+template <class _Container>\n inline output_iterator_tag\n-iterator_category(const back_insert_iterator<Container>&)\n+iterator_category(const back_insert_iterator<_Container>&)\n {\n   return output_iterator_tag();\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class Container>\n-inline back_insert_iterator<Container> back_inserter(Container& x) {\n-  return back_insert_iterator<Container>(x);\n+template <class _Container>\n+inline back_insert_iterator<_Container> back_inserter(_Container& __x) {\n+  return back_insert_iterator<_Container>(__x);\n }\n \n-template <class Container>\n+template <class _Container>\n class front_insert_iterator {\n protected:\n-  Container* container;\n+  _Container* container;\n public:\n+  typedef _Container          container_type;\n   typedef output_iterator_tag iterator_category;\n   typedef void                value_type;\n   typedef void                difference_type;\n   typedef void                pointer;\n   typedef void                reference;\n \n-  explicit front_insert_iterator(Container& x) : container(&x) {}\n-  front_insert_iterator<Container>&\n-  operator=(const typename Container::value_type& value) { \n-    container->push_front(value);\n+  explicit front_insert_iterator(_Container& __x) : container(&__x) {}\n+  front_insert_iterator<_Container>&\n+  operator=(const typename _Container::value_type& __value) { \n+    container->push_front(__value);\n     return *this;\n   }\n-  front_insert_iterator<Container>& operator*() { return *this; }\n-  front_insert_iterator<Container>& operator++() { return *this; }\n-  front_insert_iterator<Container>& operator++(int) { return *this; }\n+  front_insert_iterator<_Container>& operator*() { return *this; }\n+  front_insert_iterator<_Container>& operator++() { return *this; }\n+  front_insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class Container>\n+template <class _Container>\n inline output_iterator_tag\n-iterator_category(const front_insert_iterator<Container>&)\n+iterator_category(const front_insert_iterator<_Container>&)\n {\n   return output_iterator_tag();\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class Container>\n-inline front_insert_iterator<Container> front_inserter(Container& x) {\n-  return front_insert_iterator<Container>(x);\n+template <class _Container>\n+inline front_insert_iterator<_Container> front_inserter(_Container& __x) {\n+  return front_insert_iterator<_Container>(__x);\n }\n \n-template <class Container>\n+template <class _Container>\n class insert_iterator {\n protected:\n-  Container* container;\n-  typename Container::iterator iter;\n+  _Container* container;\n+  typename _Container::iterator iter;\n public:\n+  typedef _Container          container_type;\n   typedef output_iterator_tag iterator_category;\n   typedef void                value_type;\n   typedef void                difference_type;\n   typedef void                pointer;\n   typedef void                reference;\n \n-  insert_iterator(Container& x, typename Container::iterator i) \n-    : container(&x), iter(i) {}\n-  insert_iterator<Container>&\n-  operator=(const typename Container::value_type& value) { \n-    iter = container->insert(iter, value);\n+  insert_iterator(_Container& __x, typename _Container::iterator __i) \n+    : container(&__x), iter(__i) {}\n+  insert_iterator<_Container>&\n+  operator=(const typename _Container::value_type& __value) { \n+    iter = container->insert(iter, __value);\n     ++iter;\n     return *this;\n   }\n-  insert_iterator<Container>& operator*() { return *this; }\n-  insert_iterator<Container>& operator++() { return *this; }\n-  insert_iterator<Container>& operator++(int) { return *this; }\n+  insert_iterator<_Container>& operator*() { return *this; }\n+  insert_iterator<_Container>& operator++() { return *this; }\n+  insert_iterator<_Container>& operator++(int) { return *this; }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class Container>\n+template <class _Container>\n inline output_iterator_tag\n-iterator_category(const insert_iterator<Container>&)\n+iterator_category(const insert_iterator<_Container>&)\n {\n   return output_iterator_tag();\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class Container, class Iterator>\n-inline insert_iterator<Container> inserter(Container& x, Iterator i) {\n-  typedef typename Container::iterator iter;\n-  return insert_iterator<Container>(x, iter(i));\n+template <class _Container, class _Iterator>\n+inline \n+insert_iterator<_Container> inserter(_Container& __x, _Iterator __i)\n+{\n+  typedef typename _Container::iterator __iter;\n+  return insert_iterator<_Container>(__x, __iter(__i));\n }\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class BidirectionalIterator, class T, class Reference = T&, \n-          class Distance = ptrdiff_t> \n+template <class _BidirectionalIterator, class _Tp, class _Reference = _Tp&, \n+          class _Distance = ptrdiff_t> \n #else\n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance> \n+template <class _BidirectionalIterator, class _Tp, class _Reference, \n+          class _Distance> \n #endif\n class reverse_bidirectional_iterator {\n-  typedef reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,\n-                                         Distance> self;\n+  typedef reverse_bidirectional_iterator<_BidirectionalIterator, _Tp, \n+                                         _Reference, _Distance>  _Self;\n protected:\n-  BidirectionalIterator current;\n+  _BidirectionalIterator current;\n public:\n   typedef bidirectional_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef Distance                   difference_type;\n-  typedef T*                         pointer;\n-  typedef Reference                  reference;\n+  typedef _Tp                        value_type;\n+  typedef _Distance                  difference_type;\n+  typedef _Tp*                       pointer;\n+  typedef _Reference                 reference;\n \n   reverse_bidirectional_iterator() {}\n-  explicit reverse_bidirectional_iterator(BidirectionalIterator x)\n-    : current(x) {}\n-  BidirectionalIterator base() const { return current; }\n-  Reference operator*() const {\n-    BidirectionalIterator tmp = current;\n-    return *--tmp;\n+  explicit reverse_bidirectional_iterator(_BidirectionalIterator __x)\n+    : current(__x) {}\n+  _BidirectionalIterator base() const { return current; }\n+  _Reference operator*() const {\n+    _BidirectionalIterator __tmp = current;\n+    return *--__tmp;\n   }\n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  self& operator++() {\n+  _Self& operator++() {\n     --current;\n     return *this;\n   }\n-  self operator++(int) {\n-    self tmp = *this;\n+  _Self operator++(int) {\n+    _Self __tmp = *this;\n     --current;\n-    return tmp;\n+    return __tmp;\n   }\n-  self& operator--() {\n+  _Self& operator--() {\n     ++current;\n     return *this;\n   }\n-  self operator--(int) {\n-    self tmp = *this;\n+  _Self operator--(int) {\n+    _Self __tmp = *this;\n     ++current;\n-    return tmp;\n+    return __tmp;\n   }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance>\n+template <class _BidirectionalIterator, class _Tp, class _Reference, \n+          class _Distance>\n inline bidirectional_iterator_tag\n-iterator_category(const reverse_bidirectional_iterator<BidirectionalIterator,\n-                                                       T,\n-                                                       Reference, Distance>&) {\n+iterator_category(const reverse_bidirectional_iterator<_BidirectionalIterator,\n+                                                       _Tp, _Reference, \n+                                                       _Distance>&) \n+{\n   return bidirectional_iterator_tag();\n }\n \n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance>\n-inline T*\n-value_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,\n-                                               Reference, Distance>&) {\n-  return (T*) 0;\n+template <class _BidirectionalIterator, class _Tp, class _Reference, \n+          class _Distance>\n+inline _Tp*\n+value_type(const reverse_bidirectional_iterator<_BidirectionalIterator, _Tp,\n+                                               _Reference, _Distance>&)\n+{\n+  return (_Tp*) 0;\n }\n \n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance>\n-inline Distance*\n-distance_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,\n-                                                  Reference, Distance>&) {\n-  return (Distance*) 0;\n+template <class _BidirectionalIterator, class _Tp, class _Reference, \n+          class _Distance>\n+inline _Distance*\n+distance_type(const reverse_bidirectional_iterator<_BidirectionalIterator, \n+                                                   _Tp,\n+                                                   _Reference, _Distance>&)\n+{\n+  return (_Distance*) 0;\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class BidirectionalIterator, class T, class Reference,\n-          class Distance>\n+template <class _BiIter, class _Tp, class _Ref,\n+          class _Distance>\n inline bool operator==(\n-    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,\n-                                         Distance>& x, \n-    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,\n-                                         Distance>& y) {\n-  return x.base() == y.base();\n+    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __x, \n+    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __y)\n+{\n+  return __x.base() == __y.base();\n }\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n@@ -518,105 +566,106 @@ inline bool operator==(\n //  reverse_bidirectional_iterator is no longer part of the draft\n //  standard, but it is retained for backward compatibility.\n \n-template <class Iterator>\n+template <class _Iterator>\n class reverse_iterator \n {\n protected:\n-  Iterator current;\n+  _Iterator current;\n public:\n-  typedef typename iterator_traits<Iterator>::iterator_category\n+  typedef typename iterator_traits<_Iterator>::iterator_category\n           iterator_category;\n-  typedef typename iterator_traits<Iterator>::value_type\n+  typedef typename iterator_traits<_Iterator>::value_type\n           value_type;\n-  typedef typename iterator_traits<Iterator>::difference_type\n+  typedef typename iterator_traits<_Iterator>::difference_type\n           difference_type;\n-  typedef typename iterator_traits<Iterator>::pointer\n+  typedef typename iterator_traits<_Iterator>::pointer\n           pointer;\n-  typedef typename iterator_traits<Iterator>::reference\n+  typedef typename iterator_traits<_Iterator>::reference\n           reference;\n \n-  typedef Iterator iterator_type;\n-  typedef reverse_iterator<Iterator> self;\n+  typedef _Iterator iterator_type;\n+  typedef reverse_iterator<_Iterator> _Self;\n \n public:\n   reverse_iterator() {}\n-  explicit reverse_iterator(iterator_type x) : current(x) {}\n+  explicit reverse_iterator(iterator_type __x) : current(__x) {}\n \n-  reverse_iterator(const self& x) : current(x.current) {}\n+  reverse_iterator(const _Self& __x) : current(__x.current) {}\n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class Iter>\n-  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}\n+  template <class _Iter>\n+  reverse_iterator(const reverse_iterator<_Iter>& __x)\n+    : current(__x.base()) {}\n #endif /* __STL_MEMBER_TEMPLATES */\n     \n   iterator_type base() const { return current; }\n   reference operator*() const {\n-    Iterator tmp = current;\n-    return *--tmp;\n+    _Iterator __tmp = current;\n+    return *--__tmp;\n   }\n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n-  self& operator++() {\n+  _Self& operator++() {\n     --current;\n     return *this;\n   }\n-  self operator++(int) {\n-    self tmp = *this;\n+  _Self operator++(int) {\n+    _Self __tmp = *this;\n     --current;\n-    return tmp;\n+    return __tmp;\n   }\n-  self& operator--() {\n+  _Self& operator--() {\n     ++current;\n     return *this;\n   }\n-  self operator--(int) {\n-    self tmp = *this;\n+  _Self operator--(int) {\n+    _Self __tmp = *this;\n     ++current;\n-    return tmp;\n+    return __tmp;\n   }\n \n-  self operator+(difference_type n) const {\n-    return self(current - n);\n+  _Self operator+(difference_type __n) const {\n+    return _Self(current - __n);\n   }\n-  self& operator+=(difference_type n) {\n-    current -= n;\n+  _Self& operator+=(difference_type __n) {\n+    current -= __n;\n     return *this;\n   }\n-  self operator-(difference_type n) const {\n-    return self(current + n);\n+  _Self operator-(difference_type __n) const {\n+    return _Self(current + __n);\n   }\n-  self& operator-=(difference_type n) {\n-    current += n;\n+  _Self& operator-=(difference_type __n) {\n+    current += __n;\n     return *this;\n   }\n-  reference operator[](difference_type n) const { return *(*this + n); }  \n+  reference operator[](difference_type __n) const { return *(*this + __n); }  \n }; \n  \n-template <class Iterator>\n-inline bool operator==(const reverse_iterator<Iterator>& x, \n-                       const reverse_iterator<Iterator>& y) {\n-  return x.base() == y.base();\n+template <class _Iterator>\n+inline bool operator==(const reverse_iterator<_Iterator>& __x, \n+                       const reverse_iterator<_Iterator>& __y) {\n+  return __x.base() == __y.base();\n }\n \n-template <class Iterator>\n-inline bool operator<(const reverse_iterator<Iterator>& x, \n-                      const reverse_iterator<Iterator>& y) {\n-  return y.base() < x.base();\n+template <class _Iterator>\n+inline bool operator<(const reverse_iterator<_Iterator>& __x, \n+                      const reverse_iterator<_Iterator>& __y) {\n+  return __y.base() < __x.base();\n }\n \n-template <class Iterator>\n-inline typename reverse_iterator<Iterator>::difference_type\n-operator-(const reverse_iterator<Iterator>& x, \n-          const reverse_iterator<Iterator>& y) {\n-  return y.base() - x.base();\n+template <class _Iterator>\n+inline typename reverse_iterator<_Iterator>::difference_type\n+operator-(const reverse_iterator<_Iterator>& __x, \n+          const reverse_iterator<_Iterator>& __y) {\n+  return __y.base() - __x.base();\n }\n \n-template <class Iterator>\n-inline reverse_iterator<Iterator> \n-operator+(reverse_iterator<Iterator>::difference_type n,\n-          const reverse_iterator<Iterator>& x) {\n-  return reverse_iterator<Iterator>(x.base() - n);\n+template <class _Iterator>\n+inline reverse_iterator<_Iterator> \n+operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n+          const reverse_iterator<_Iterator>& __x) {\n+  return reverse_iterator<_Iterator>(__x.base() - __n);\n }\n \n #else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n@@ -625,210 +674,233 @@ operator+(reverse_iterator<Iterator>::difference_type n,\n //  HP STL.  It does not use partial specialization.\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class RandomAccessIterator, class T, class Reference = T&,\n-          class Distance = ptrdiff_t> \n+template <class _RandomAccessIterator, class _Tp, class _Reference = _Tp&,\n+          class _Distance = ptrdiff_t> \n #else\n-template <class RandomAccessIterator, class T, class Reference,\n-          class Distance> \n+template <class _RandomAccessIterator, class _Tp, class _Reference,\n+          class _Distance> \n #endif\n class reverse_iterator {\n-  typedef reverse_iterator<RandomAccessIterator, T, Reference, Distance>\n-        self;\n+  typedef reverse_iterator<_RandomAccessIterator, _Tp, _Reference, _Distance>\n+        _Self;\n protected:\n-  RandomAccessIterator current;\n+  _RandomAccessIterator current;\n public:\n   typedef random_access_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef Distance                   difference_type;\n-  typedef T*                         pointer;\n-  typedef Reference                  reference;\n+  typedef _Tp                        value_type;\n+  typedef _Distance                  difference_type;\n+  typedef _Tp*                       pointer;\n+  typedef _Reference                 reference;\n \n   reverse_iterator() {}\n-  explicit reverse_iterator(RandomAccessIterator x) : current(x) {}\n-  RandomAccessIterator base() const { return current; }\n-  Reference operator*() const { return *(current - 1); }\n+  explicit reverse_iterator(_RandomAccessIterator __x) : current(__x) {}\n+  _RandomAccessIterator base() const { return current; }\n+  _Reference operator*() const { return *(current - 1); }\n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  self& operator++() {\n+  _Self& operator++() {\n     --current;\n     return *this;\n   }\n-  self operator++(int) {\n-    self tmp = *this;\n+  _Self operator++(int) {\n+    _Self __tmp = *this;\n     --current;\n-    return tmp;\n+    return __tmp;\n   }\n-  self& operator--() {\n+  _Self& operator--() {\n     ++current;\n     return *this;\n   }\n-  self operator--(int) {\n-    self tmp = *this;\n+  _Self operator--(int) {\n+    _Self __tmp = *this;\n     ++current;\n-    return tmp;\n+    return __tmp;\n   }\n-  self operator+(Distance n) const {\n-    return self(current - n);\n+  _Self operator+(_Distance __n) const {\n+    return _Self(current - __n);\n   }\n-  self& operator+=(Distance n) {\n-    current -= n;\n+  _Self& operator+=(_Distance __n) {\n+    current -= __n;\n     return *this;\n   }\n-  self operator-(Distance n) const {\n-    return self(current + n);\n+  _Self operator-(_Distance __n) const {\n+    return _Self(current + __n);\n   }\n-  self& operator-=(Distance n) {\n-    current += n;\n+  _Self& operator-=(_Distance __n) {\n+    current += __n;\n     return *this;\n   }\n-  Reference operator[](Distance n) const { return *(*this + n); }\n+  _Reference operator[](_Distance __n) const { return *(*this + __n); }\n };\n \n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n+template <class _RandomAccessIterator, class _Tp, \n+          class _Reference, class _Distance>\n inline random_access_iterator_tag\n-iterator_category(const reverse_iterator<RandomAccessIterator, T,\n-                                         Reference, Distance>&) {\n+iterator_category(const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                         _Reference, _Distance>&)\n+{\n   return random_access_iterator_tag();\n }\n \n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline T* value_type(const reverse_iterator<RandomAccessIterator, T,\n-                                            Reference, Distance>&) {\n-  return (T*) 0;\n+template <class _RandomAccessIterator, class _Tp,\n+          class _Reference, class _Distance>\n+inline _Tp* value_type(const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                              _Reference, _Distance>&)\n+{\n+  return (_Tp*) 0;\n }\n \n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline Distance* distance_type(const reverse_iterator<RandomAccessIterator, T,\n-                                                      Reference, Distance>&) {\n-  return (Distance*) 0;\n+template <class _RandomAccessIterator, class _Tp,\n+          class _Reference, class _Distance>\n+inline _Distance* \n+distance_type(const reverse_iterator<_RandomAccessIterator, \n+                                     _Tp, _Reference, _Distance>&)\n+{\n+  return (_Distance*) 0;\n }\n \n \n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline bool operator==(const reverse_iterator<RandomAccessIterator, T,\n-                                              Reference, Distance>& x, \n-                       const reverse_iterator<RandomAccessIterator, T,\n-                                              Reference, Distance>& y) {\n-  return x.base() == y.base();\n+template <class _RandomAccessIterator, class _Tp,\n+          class _Reference, class _Distance>\n+inline bool \n+operator==(const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                  _Reference, _Distance>& __x, \n+           const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                  _Reference, _Distance>& __y)\n+{\n+  return __x.base() == __y.base();\n }\n \n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline bool operator<(const reverse_iterator<RandomAccessIterator, T,\n-                                             Reference, Distance>& x, \n-                      const reverse_iterator<RandomAccessIterator, T,\n-                                             Reference, Distance>& y) {\n-  return y.base() < x.base();\n+template <class _RandomAccessIterator, class _Tp,\n+          class _Reference, class _Distance>\n+inline bool \n+operator<(const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                 _Reference, _Distance>& __x, \n+          const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                 _Reference, _Distance>& __y)\n+{\n+  return __y.base() < __x.base();\n }\n \n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline Distance operator-(const reverse_iterator<RandomAccessIterator, T,\n-                                                 Reference, Distance>& x, \n-                          const reverse_iterator<RandomAccessIterator, T,\n-                                                 Reference, Distance>& y) {\n-  return y.base() - x.base();\n+template <class _RandomAccessIterator, class _Tp,\n+          class _Reference, class _Distance>\n+inline _Distance \n+operator-(const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                 _Reference, _Distance>& __x, \n+          const reverse_iterator<_RandomAccessIterator, _Tp,\n+                                 _Reference, _Distance>& __y)\n+{\n+  return __y.base() - __x.base();\n }\n \n-template <class RandomAccessIter, class T, class Ref, class Dist>\n-inline reverse_iterator<RandomAccessIter, T, Ref, Dist> \n-operator+(Dist n, const reverse_iterator<RandomAccessIter, T, Ref, Dist>& x) {\n-  return reverse_iterator<RandomAccessIter, T, Ref, Dist>(x.base() - n);\n+template <class _RandAccIter, class _Tp, class _Ref, class _Dist>\n+inline reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist> \n+operator+(_Dist __n,\n+          const reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist>& __x)\n+{\n+  return reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist>(__x.base() - __n);\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class T, class Distance = ptrdiff_t> \n+// When we have templatized iostreams, istream_iterator and ostream_iterator\n+// must be rewritten.\n+\n+template <class _Tp, class _Dist = ptrdiff_t> \n class istream_iterator {\n-  friend bool\n-  operator== __STL_NULL_TMPL_ARGS (const istream_iterator<T, Distance>& x,\n-                                   const istream_iterator<T, Distance>& y);\n+  friend bool operator== __STL_NULL_TMPL_ARGS (const istream_iterator&,\n+                                               const istream_iterator&);\n protected:\n-  istream* stream;\n-  T value;\n-  bool end_marker;\n-  void read() {\n-    end_marker = (*stream) ? true : false;\n-    if (end_marker) *stream >> value;\n-    end_marker = (*stream) ? true : false;\n+  istream* _M_stream;\n+  _Tp _M_value;\n+  bool _M_end_marker;\n+  void _M_read() {\n+    _M_end_marker = (*_M_stream) ? true : false;\n+    if (_M_end_marker) *_M_stream >> _M_value;\n+    _M_end_marker = (*_M_stream) ? true : false;\n   }\n public:\n-  typedef input_iterator_tag iterator_category;\n-  typedef T                  value_type;\n-  typedef Distance           difference_type;\n-  typedef const T*           pointer;\n-  typedef const T&           reference;\n-\n-  istream_iterator() : stream(&cin), end_marker(false) {}\n-  istream_iterator(istream& s) : stream(&s) { read(); }\n-  reference operator*() const { return value; }\n+  typedef input_iterator_tag  iterator_category;\n+  typedef _Tp                 value_type;\n+  typedef _Dist               difference_type;\n+  typedef const _Tp*          pointer;\n+  typedef const _Tp&          reference;\n+\n+  istream_iterator() : _M_stream(&cin), _M_end_marker(false) {}\n+  istream_iterator(istream& __s) : _M_stream(&__s) { _M_read(); }\n+  reference operator*() const { return _M_value; }\n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  istream_iterator<T, Distance>& operator++() { \n-    read(); \n+  istream_iterator<_Tp, _Dist>& operator++() { \n+    _M_read(); \n     return *this;\n   }\n-  istream_iterator<T, Distance> operator++(int)  {\n-    istream_iterator<T, Distance> tmp = *this;\n-    read();\n-    return tmp;\n+  istream_iterator<_Tp, _Dist> operator++(int)  {\n+    istream_iterator<_Tp, _Dist> __tmp = *this;\n+    _M_read();\n+    return __tmp;\n   }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class T, class Distance>\n+template <class _Tp, class _Dist>\n inline input_iterator_tag \n-iterator_category(const istream_iterator<T, Distance>&) {\n+iterator_category(const istream_iterator<_Tp, _Dist>&)\n+{\n   return input_iterator_tag();\n }\n \n-template <class T, class Distance>\n-inline T* value_type(const istream_iterator<T, Distance>&) { return (T*) 0; }\n+template <class _Tp, class _Dist>\n+inline _Tp* \n+value_type(const istream_iterator<_Tp, _Dist>&) { return (_Tp*) 0; }\n \n-template <class T, class Distance>\n-inline Distance* distance_type(const istream_iterator<T, Distance>&) {\n-  return (Distance*) 0;\n-}\n+template <class _Tp, class _Dist>\n+inline _Dist* \n+distance_type(const istream_iterator<_Tp, _Dist>&) { return (_Dist*)0; }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class T, class Distance>\n-inline bool operator==(const istream_iterator<T, Distance>& x,\n-                       const istream_iterator<T, Distance>& y) {\n-  return x.stream == y.stream && x.end_marker == y.end_marker ||\n-         x.end_marker == false && y.end_marker == false;\n+template <class _Tp, class _Distance>\n+inline bool operator==(const istream_iterator<_Tp, _Distance>& __x,\n+                       const istream_iterator<_Tp, _Distance>& __y) {\n+  return (__x._M_stream == __y._M_stream &&\n+          __x._M_end_marker == __y._M_end_marker) ||\n+         __x._M_end_marker == false && __y._M_end_marker == false;\n }\n \n-template <class T>\n+template <class _Tp>\n class ostream_iterator {\n protected:\n-  ostream* stream;\n-  const char* string;\n+  ostream* _M_stream;\n+  const char* _M_string;\n public:\n   typedef output_iterator_tag iterator_category;\n   typedef void                value_type;\n   typedef void                difference_type;\n   typedef void                pointer;\n   typedef void                reference;\n \n-  ostream_iterator(ostream& s) : stream(&s), string(0) {}\n-  ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}\n-  ostream_iterator<T>& operator=(const T& value) { \n-    *stream << value;\n-    if (string) *stream << string;\n+  ostream_iterator(ostream& __s) : _M_stream(&__s), _M_string(0) {}\n+  ostream_iterator(ostream& __s, const char* __c) \n+    : _M_stream(&__s), _M_string(__c)  {}\n+  ostream_iterator<_Tp>& operator=(const _Tp& __value) { \n+    *_M_stream << __value;\n+    if (_M_string) *_M_stream << _M_string;\n     return *this;\n   }\n-  ostream_iterator<T>& operator*() { return *this; }\n-  ostream_iterator<T>& operator++() { return *this; } \n-  ostream_iterator<T>& operator++(int) { return *this; } \n+  ostream_iterator<_Tp>& operator*() { return *this; }\n+  ostream_iterator<_Tp>& operator++() { return *this; } \n+  ostream_iterator<_Tp>& operator++(int) { return *this; } \n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class T>\n+template <class _Tp>\n inline output_iterator_tag \n-iterator_category(const ostream_iterator<T>&) {\n+iterator_category(const ostream_iterator<_Tp>&) {\n   return output_iterator_tag();\n }\n "}, {"sha": "5d95d641e52d16d206e372369f115eb55a3458fc", "filename": "libstdc++/stl/stl_list.h", "status": "modified", "additions": 613, "deletions": 390, "changes": 1003, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_list.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -35,577 +35,800 @@ __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n-template <class T>\n-struct __list_node {\n-  typedef void* void_pointer;\n-  void_pointer next;\n-  void_pointer prev;\n-  T data;\n+template <class _Tp>\n+struct _List_node {\n+  typedef void* _Void_pointer;\n+  _Void_pointer _M_next;\n+  _Void_pointer _M_prev;\n+  _Tp _M_data;\n };\n \n-template<class T, class Ref, class Ptr>\n-struct __list_iterator {\n-  typedef __list_iterator<T, T&, T*>             iterator;\n-  typedef __list_iterator<T, const T&, const T*> const_iterator;\n-  typedef __list_iterator<T, Ref, Ptr>           self;\n+template<class _Tp, class _Ref, class _Ptr>\n+struct _List_iterator {\n+  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+  typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n \n   typedef bidirectional_iterator_tag iterator_category;\n-  typedef T value_type;\n-  typedef Ptr pointer;\n-  typedef Ref reference;\n-  typedef __list_node<T>* link_type;\n+  typedef _Tp value_type;\n+  typedef _Ptr pointer;\n+  typedef _Ref reference;\n+  typedef _List_node<_Tp> _Node;\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type;\n \n-  link_type node;\n+  _Node* _M_node;\n \n-  __list_iterator(link_type x) : node(x) {}\n-  __list_iterator() {}\n-  __list_iterator(const iterator& x) : node(x.node) {}\n+  _List_iterator(_Node* __x) : _M_node(__x) {}\n+  _List_iterator() {}\n+  _List_iterator(const iterator& __x) : _M_node(__x._M_node) {}\n \n-  bool operator==(const self& x) const { return node == x.node; }\n-  bool operator!=(const self& x) const { return node != x.node; }\n-  reference operator*() const { return (*node).data; }\n+  bool operator==(const _Self& __x) const { return _M_node == __x._M_node; }\n+  bool operator!=(const _Self& __x) const { return _M_node != __x._M_node; }\n+  reference operator*() const { return (*_M_node)._M_data; }\n \n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n-  self& operator++() { \n-    node = (link_type)((*node).next);\n+  _Self& operator++() { \n+    _M_node = (_Node*)(_M_node->_M_next);\n     return *this;\n   }\n-  self operator++(int) { \n-    self tmp = *this;\n+  _Self operator++(int) { \n+    _Self __tmp = *this;\n     ++*this;\n-    return tmp;\n+    return __tmp;\n   }\n-  self& operator--() { \n-    node = (link_type)((*node).prev);\n+  _Self& operator--() { \n+    _M_node = (_Node*)(_M_node->_M_prev);\n     return *this;\n   }\n-  self operator--(int) { \n-    self tmp = *this;\n+  _Self operator--(int) { \n+    _Self __tmp = *this;\n     --*this;\n-    return tmp;\n+    return __tmp;\n   }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class T, class Ref, class Ptr>\n+template <class _Tp, class _Ref, class _Ptr>\n inline bidirectional_iterator_tag\n-iterator_category(const __list_iterator<T, Ref, Ptr>&) {\n+iterator_category(const _List_iterator<_Tp, _Ref, _Ptr>&)\n+{\n   return bidirectional_iterator_tag();\n }\n \n-template <class T, class Ref, class Ptr>\n-inline T*\n-value_type(const __list_iterator<T, Ref, Ptr>&) {\n+template <class _Tp, class _Ref, class _Ptr>\n+inline _Tp*\n+value_type(const _List_iterator<_Tp, _Ref, _Ptr>&)\n+{\n   return 0;\n }\n \n-template <class T, class Ref, class Ptr>\n+template <class _Tp, class _Ref, class _Ptr>\n inline ptrdiff_t*\n-distance_type(const __list_iterator<T, Ref, Ptr>&) {\n+distance_type(const _List_iterator<_Tp, _Ref, _Ptr>&)\n+{\n   return 0;\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-template <class T, class Alloc = alloc>\n-class list {\n+\n+// Base class that encapsulates details of allocators.  Three cases:\n+// an ordinary standard-conforming allocator, a standard-conforming\n+// allocator with no non-static data, and an SGI-style allocator.\n+// This complexity is necessary only because we're worrying about backward\n+// compatibility and because we want to avoid wasting storage on an \n+// allocator instance if it isn't necessary.\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+// Base for general standard-conforming allocators.\n+template <class _Tp, class _Allocator, bool _IsStatic>\n+class _List_alloc_base {\n+public:\n+  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return _Node_allocator; }\n+\n+  _List_alloc_base(const allocator_type& __a) : _Node_allocator(__a) {}\n+\n+protected:\n+  _List_node<_Tp>* _M_get_node()\n+   { return _Node_allocator.allocate(1); }\n+  void _M_put_node(_List_node<_Tp>* __p)\n+    { _Node_allocator.deallocate(__p, 1); }\n+\n+protected:\n+  typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n+           _Node_allocator;\n+  _List_node<_Tp>* _M_node;\n+};\n+\n+// Specialization for instanceless allocators.\n+\n+template <class _Tp, class _Allocator>\n+class _List_alloc_base<_Tp, _Allocator, true> {\n+public:\n+  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+          allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+\n+  _List_alloc_base(const allocator_type&) {}\n+\n+protected:\n+  typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n+          _Alloc_type;\n+  _List_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n+  void _M_put_node(_List_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n+\n+protected:\n+  _List_node<_Tp>* _M_node;\n+};\n+\n+template <class _Tp, class _Alloc>\n+class _List_base \n+  : public _List_alloc_base<_Tp, _Alloc,\n+                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+{\n+public:\n+  typedef _List_alloc_base<_Tp, _Alloc,\n+                           _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+          _Base; \n+  typedef typename _Base::allocator_type allocator_type;\n+\n+  _List_base(const allocator_type& __a) : _Base(__a) {\n+    _M_node = _M_get_node();\n+    _M_node->_M_next = _M_node;\n+    _M_node->_M_prev = _M_node;\n+  }\n+  ~_List_base() {\n+    clear();\n+    _M_put_node(_M_node);\n+  }\n+\n+  void clear();\n+};\n+\n+#else /* __STL_USE_STD_ALLOCATORS */\n+\n+template <class _Tp, class _Alloc>\n+class _List_base \n+{\n+public:\n+  typedef _Alloc allocator_type;\n+  allocator_type get_allocator() const { return allocator_type(); }\n+\n+  _List_base(const allocator_type&) {\n+    _M_node = _M_get_node();\n+    _M_node->_M_next = _M_node;\n+    _M_node->_M_prev = _M_node;\n+  }\n+  ~_List_base() {\n+    clear();\n+    _M_put_node(_M_node);\n+  }\n+\n+  void clear();\n+\n+protected:\n+  typedef simple_alloc<_List_node<_Tp>, _Alloc> _Alloc_type;\n+  _List_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n+  void _M_put_node(_List_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); } \n+\n protected:\n-  typedef void* void_pointer;\n-  typedef __list_node<T> list_node;\n-  typedef simple_alloc<list_node, Alloc> list_node_allocator;\n+  _List_node<_Tp>* _M_node;\n+};\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+template <class _Tp, class _Alloc>\n+void \n+_List_base<_Tp,_Alloc>::clear() \n+{\n+  _List_node<_Tp>* __cur = (_List_node<_Tp>*) _M_node->_M_next;\n+  while (__cur != _M_node) {\n+    _List_node<_Tp>* __tmp = __cur;\n+    __cur = (_List_node<_Tp>*) __cur->_M_next;\n+    destroy(&__tmp->_M_data);\n+    _M_put_node(__tmp);\n+  }\n+  _M_node->_M_next = _M_node;\n+  _M_node->_M_prev = _M_node;\n+}\n+\n+template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n+class list : protected _List_base<_Tp, _Alloc> {\n+  typedef _List_base<_Tp, _Alloc> _Base;\n+protected:\n+  typedef void* _Void_pointer;\n+\n public:      \n-  typedef T value_type;\n+  typedef _Tp value_type;\n   typedef value_type* pointer;\n   typedef const value_type* const_pointer;\n   typedef value_type& reference;\n   typedef const value_type& const_reference;\n-  typedef list_node* link_type;\n+  typedef _List_node<_Tp> _Node;\n   typedef size_t size_type;\n   typedef ptrdiff_t difference_type;\n \n+  typedef typename _Base::allocator_type allocator_type;\n+  allocator_type get_allocator() const { return _Base::get_allocator(); }\n+\n public:\n-  typedef __list_iterator<T, T&, T*>             iterator;\n-  typedef __list_iterator<T, const T&, const T*> const_iterator;\n+  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n   typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator> reverse_iterator;\n+  typedef reverse_iterator<iterator>       reverse_iterator;\n #else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_bidirectional_iterator<const_iterator, value_type,\n-  const_reference, difference_type>\n-  const_reverse_iterator;\n-  typedef reverse_bidirectional_iterator<iterator, value_type, reference,\n-  difference_type>\n-  reverse_iterator; \n+  typedef reverse_bidirectional_iterator<const_iterator,value_type,\n+                                         const_reference,difference_type>\n+          const_reverse_iterator;\n+  typedef reverse_bidirectional_iterator<iterator,value_type,reference,\n+                                         difference_type>\n+          reverse_iterator; \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n protected:\n-  link_type get_node() { return list_node_allocator::allocate(); }\n-  void put_node(link_type p) { list_node_allocator::deallocate(p); }\n-\n-  link_type create_node(const T& x) {\n-    link_type p = get_node();\n-    __STL_TRY {\n-      construct(&p->data, x);\n-    }\n-    __STL_UNWIND(put_node(p));\n-    return p;\n-  }\n-  void destroy_node(link_type p) {\n-    destroy(&p->data);\n-    put_node(p);\n-  }\n+#ifdef __STL_HAS_NAMESPACES\n+  using _Base::_M_node;\n+  using _Base::_M_put_node;\n+  using _Base::_M_get_node;\n+#endif /* __STL_HAS_NAMESPACES */\n \n protected:\n-  void empty_initialize() { \n-    node = get_node();\n-    node->next = node;\n-    node->prev = node;\n-  }\n-\n-  void fill_initialize(size_type n, const T& value) {\n-    empty_initialize();\n+  _Node* _M_create_node(const _Tp& __x)\n+  {\n+    _Node* __p = _M_get_node();\n     __STL_TRY {\n-      insert(begin(), n, value);\n+      construct(&__p->_M_data, __x);\n     }\n-    __STL_UNWIND(clear(); put_node(node));\n+    __STL_UNWIND(_M_put_node(__p));\n+    return __p;\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void range_initialize(InputIterator first, InputIterator last) {\n-    empty_initialize();\n-    __STL_TRY {\n-      insert(begin(), first, last);\n-    }\n-    __STL_UNWIND(clear(); put_node(node));\n-  }\n-#else  /* __STL_MEMBER_TEMPLATES */\n-  void range_initialize(const T* first, const T* last) {\n-    empty_initialize();\n-    __STL_TRY {\n-      insert(begin(), first, last);\n-    }\n-    __STL_UNWIND(clear(); put_node(node));\n-  }\n-  void range_initialize(const_iterator first, const_iterator last) {\n-    empty_initialize();\n+  _Node* _M_create_node()\n+  {\n+    _Node* __p = _M_get_node();\n     __STL_TRY {\n-      insert(begin(), first, last);\n+      construct(&__p->_M_data);\n     }\n-    __STL_UNWIND(clear(); put_node(node));\n+    __STL_UNWIND(_M_put_node(__p));\n+    return __p;\n   }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-protected:\n-  link_type node;\n \n public:\n-  list() { empty_initialize(); }\n-\n-  iterator begin() { return (link_type)((*node).next); }\n-  const_iterator begin() const { return (link_type)((*node).next); }\n-  iterator end() { return node; }\n-  const_iterator end() const { return node; }\n-  reverse_iterator rbegin() { return reverse_iterator(end()); }\n-  const_reverse_iterator rbegin() const { \n-    return const_reverse_iterator(end()); \n-  }\n-  reverse_iterator rend() { return reverse_iterator(begin()); }\n-  const_reverse_iterator rend() const { \n-    return const_reverse_iterator(begin());\n-  } \n-  bool empty() const { return node->next == node; }\n+  explicit list(const allocator_type& __a = allocator_type()) : _Base(__a) {}\n+\n+  iterator begin()             { return (_Node*)(_M_node->_M_next); }\n+  const_iterator begin() const { return (_Node*)(_M_node->_M_next); }\n+\n+  iterator end()             { return _M_node; }\n+  const_iterator end() const { return _M_node; }\n+\n+  reverse_iterator rbegin() \n+    { return reverse_iterator(end()); }\n+  const_reverse_iterator rbegin() const \n+    { return const_reverse_iterator(end()); }\n+\n+  reverse_iterator rend()\n+    { return reverse_iterator(begin()); }\n+  const_reverse_iterator rend() const\n+    { return const_reverse_iterator(begin()); }\n+\n+  bool empty() const { return _M_node->_M_next == _M_node; }\n   size_type size() const {\n-    size_type result = 0;\n-    distance(begin(), end(), result);\n-    return result;\n+    size_type __result = 0;\n+    distance(begin(), end(), __result);\n+    return __result;\n   }\n   size_type max_size() const { return size_type(-1); }\n+\n   reference front() { return *begin(); }\n   const_reference front() const { return *begin(); }\n   reference back() { return *(--end()); }\n   const_reference back() const { return *(--end()); }\n-  void swap(list<T, Alloc>& x) { __STD::swap(node, x.node); }\n-  iterator insert(iterator position, const T& x) {\n-    link_type tmp = create_node(x);\n-    tmp->next = position.node;\n-    tmp->prev = position.node->prev;\n-    (link_type(position.node->prev))->next = tmp;\n-    position.node->prev = tmp;\n-    return tmp;\n+\n+  void swap(list<_Tp, _Alloc>& __x) { __STD::swap(_M_node, __x._M_node); }\n+\n+  iterator insert(iterator __position, const _Tp& __x) {\n+    _Node* __tmp = _M_create_node(__x);\n+    __tmp->_M_next = __position._M_node;\n+    __tmp->_M_prev = __position._M_node->_M_prev;\n+    ((_Node*) (__position._M_node->_M_prev))->_M_next = __tmp;\n+    __position._M_node->_M_prev = __tmp;\n+    return __tmp;\n   }\n-  iterator insert(iterator position) { return insert(position, T()); }\n+  iterator insert(iterator __position) { return insert(__position, _Tp()); }\n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(iterator position, InputIterator first, InputIterator last);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator position, const T* first, const T* last);\n-  void insert(iterator position,\n-              const_iterator first, const_iterator last);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator pos, size_type n, const T& x);\n-  void insert(iterator pos, int n, const T& x) {\n-    insert(pos, (size_type)n, x);\n-  }\n-  void insert(iterator pos, long n, const T& x) {\n-    insert(pos, (size_type)n, x);\n+  // Check whether it's an integral type.  If so, it's not an iterator.\n+\n+  template<class _Integer>\n+  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+                          __true_type) {\n+    insert(__pos, (size_type) __n, (_Tp) __x);\n   }\n \n-  void push_front(const T& x) { insert(begin(), x); }\n-  void push_back(const T& x) { insert(end(), x); }\n-  iterator erase(iterator position) {\n-    link_type next_node = link_type(position.node->next);\n-    link_type prev_node = link_type(position.node->prev);\n-    prev_node->next = next_node;\n-    next_node->prev = prev_node;\n-    destroy_node(position.node);\n-    return iterator(next_node);\n+  template <class _InputIterator>\n+  void _M_insert_dispatch(iterator __pos,\n+                          _InputIterator __first, _InputIterator __last,\n+                          __false_type);\n+\n+  template <class _InputIterator>\n+  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_insert_dispatch(__pos, __first, __last, _Integral());\n   }\n-  iterator erase(iterator first, iterator last);\n-  void resize(size_type new_size, const T& x);\n-  void resize(size_type new_size) { resize(new_size, T()); }\n-  void clear();\n+\n+#else /* __STL_MEMBER_TEMPLATES */\n+  void insert(iterator __position, const _Tp* __first, const _Tp* __last);\n+  void insert(iterator __position,\n+              const_iterator __first, const_iterator __last);\n+#endif /* __STL_MEMBER_TEMPLATES */\n+  void insert(iterator __pos, size_type __n, const _Tp& __x);\n+ \n+  void push_front(const _Tp& __x) { insert(begin(), __x); }\n+  void push_front() {insert(begin());}\n+  void push_back(const _Tp& __x) { insert(end(), __x); }\n+  void push_back() {insert(end());}\n+\n+  iterator erase(iterator __position) {\n+    _Node* __next_node = (_Node*) (__position._M_node->_M_next);\n+    _Node* __prev_node = (_Node*) (__position._M_node->_M_prev);\n+    __prev_node->_M_next = __next_node;\n+    __next_node->_M_prev = __prev_node;\n+    destroy(&__position._M_node->_M_data);\n+    _M_put_node(__position._M_node);\n+    return iterator(__next_node);\n+  }\n+  iterator erase(iterator __first, iterator __last);\n+  void clear() { _Base::clear(); }\n+\n+  void resize(size_type __new_size, const _Tp& __x);\n+  void resize(size_type __new_size) { resize(__new_size, _Tp()); }\n \n   void pop_front() { erase(begin()); }\n   void pop_back() { \n-    iterator tmp = end();\n-    erase(--tmp);\n+    iterator __tmp = end();\n+    erase(--__tmp);\n   }\n-  list(size_type n, const T& value) { fill_initialize(n, value); }\n-  list(int n, const T& value) { fill_initialize(n, value); }\n-  list(long n, const T& value) { fill_initialize(n, value); }\n-  explicit list(size_type n) { fill_initialize(n, T()); }\n+  list(size_type __n, const _Tp& __value,\n+       const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+    { insert(begin(), __n, __value); }\n+  explicit list(size_type __n)\n+    : _Base(allocator_type())\n+    { insert(begin(), __n, _Tp()); }\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  list(InputIterator first, InputIterator last) {\n-    range_initialize(first, last);\n-  }\n+\n+  // We don't need any dispatching tricks here, because insert does all of\n+  // that anyway.  \n+  template <class _InputIterator>\n+  list(_InputIterator __first, _InputIterator __last,\n+       const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+    { insert(begin(), __first, __last); }\n \n #else /* __STL_MEMBER_TEMPLATES */\n-  list(const T* first, const T* last) { range_initialize(first, last); }\n-  list(const_iterator first, const_iterator last) {\n-    range_initialize(first, last);\n-  }\n+\n+  list(const _Tp* __first, const _Tp* __last,\n+       const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+    { insert(begin(), __first, __last); }\n+  list(const_iterator __first, const_iterator __last,\n+       const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+    { insert(begin(), __first, __last); }\n+\n #endif /* __STL_MEMBER_TEMPLATES */\n-  list(const list<T, Alloc>& x) {\n-    range_initialize(x.begin(), x.end());\n-  }\n-  ~list() {\n-    clear();\n-    put_node(node);\n+  list(const list<_Tp, _Alloc>& __x) : _Base(__x.get_allocator())\n+    { insert(begin(), __x.begin(), __x.end()); }\n+\n+  ~list() { }\n+\n+  list<_Tp, _Alloc>& operator=(const list<_Tp, _Alloc>& __x);\n+\n+public:\n+  // assign(), a generalized assignment member function.  Two\n+  // versions: one that takes a count, and one that takes a range.\n+  // The range version is a member template, so we dispatch on whether\n+  // or not the type is an integer.\n+\n+  void assign(size_type __n, const _Tp& __val);\n+\n+#ifdef __STL_MEMBER_TEMPLATES\n+\n+  template <class _InputIterator>\n+  void assign(_InputIterator __first, _InputIterator __last) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_assign_dispatch(__first, __last, _Integral());\n   }\n-  list<T, Alloc>& operator=(const list<T, Alloc>& x);\n+\n+  template <class _Integer>\n+  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+    { assign((size_type) __n, (_Tp) __val); }\n+\n+  template <class _InputIterator>\n+  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+                          __false_type);\n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n \n protected:\n-  void transfer(iterator position, iterator first, iterator last) {\n-    if (position != last) {\n-      (*(link_type((*last.node).prev))).next = position.node;\n-      (*(link_type((*first.node).prev))).next = last.node;\n-      (*(link_type((*position.node).prev))).next = first.node;  \n-      link_type tmp = link_type((*position.node).prev);\n-      (*position.node).prev = (*last.node).prev;\n-      (*last.node).prev = (*first.node).prev; \n-      (*first.node).prev = tmp;\n+  void transfer(iterator __position, iterator __first, iterator __last) {\n+    if (__position != __last) {\n+      // Remove [first, last) from its old position.\n+      ((_Node*) (__last._M_node->_M_prev))->_M_next     = __position._M_node;\n+      ((_Node*) (__first._M_node->_M_prev))->_M_next    = __last._M_node;\n+      ((_Node*) (__position._M_node->_M_prev))->_M_next = __first._M_node; \n+\n+      // Splice [first, last) into its new position.\n+      _Node* __tmp = (_Node*) (__position._M_node->_M_prev);\n+      __position._M_node->_M_prev = __last._M_node->_M_prev;\n+      __last._M_node->_M_prev      = __first._M_node->_M_prev; \n+      __first._M_node->_M_prev    = __tmp;\n     }\n   }\n \n public:\n-  void splice(iterator position, list& x) {\n-    if (!x.empty()) \n-      transfer(position, x.begin(), x.end());\n+  void splice(iterator __position, list& __x) {\n+    if (!__x.empty()) \n+      transfer(__position, __x.begin(), __x.end());\n   }\n-  void splice(iterator position, list&, iterator i) {\n-    iterator j = i;\n-    ++j;\n-    if (position == i || position == j) return;\n-    transfer(position, i, j);\n+  void splice(iterator __position, list&, iterator __i) {\n+    iterator __j = __i;\n+    ++__j;\n+    if (__position == __i || __position == __j) return;\n+    transfer(__position, __i, __j);\n   }\n-  void splice(iterator position, list&, iterator first, iterator last) {\n-    if (first != last) \n-      transfer(position, first, last);\n+  void splice(iterator __position, list&, iterator __first, iterator __last) {\n+    if (__first != __last) \n+      transfer(__position, __first, __last);\n   }\n-  void remove(const T& value);\n+  void remove(const _Tp& __value);\n   void unique();\n-  void merge(list& x);\n+  void merge(list& __x);\n   void reverse();\n   void sort();\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class Predicate> void remove_if(Predicate);\n-  template <class BinaryPredicate> void unique(BinaryPredicate);\n-  template <class StrictWeakOrdering> void merge(list&, StrictWeakOrdering);\n-  template <class StrictWeakOrdering> void sort(StrictWeakOrdering);\n+  template <class _Predicate> void remove_if(_Predicate);\n+  template <class _BinaryPredicate> void unique(_BinaryPredicate);\n+  template <class _StrictWeakOrdering> void merge(list&, _StrictWeakOrdering);\n+  template <class _StrictWeakOrdering> void sort(_StrictWeakOrdering);\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  friend bool operator== __STL_NULL_TMPL_ARGS (const list& x, const list& y);\n+  friend bool operator== __STL_NULL_TMPL_ARGS (\n+    const list& __x, const list& __y);\n };\n \n-template <class T, class Alloc>\n-inline bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y) {\n-  typedef typename list<T,Alloc>::link_type link_type;\n-  link_type e1 = x.node;\n-  link_type e2 = y.node;\n-  link_type n1 = (link_type) e1->next;\n-  link_type n2 = (link_type) e2->next;\n-  for ( ; n1 != e1 && n2 != e2 ;\n-          n1 = (link_type) n1->next, n2 = (link_type) n2->next)\n-    if (n1->data != n2->data)\n+template <class _Tp, class _Alloc>\n+inline bool operator==(const list<_Tp,_Alloc>& __x,\n+                       const list<_Tp,_Alloc>& __y)\n+{\n+  typedef typename list<_Tp,_Alloc>::_Node _Node;\n+  _Node* __e1 = __x._M_node;\n+  _Node* __e2 = __y._M_node;\n+  _Node* __n1 = (_Node*) __e1->_M_next;\n+  _Node* __n2 = (_Node*) __e2->_M_next;\n+  for ( ; __n1 != __e1 && __n2 != __e2 ;\n+          __n1 = (_Node*) __n1->_M_next, __n2 = (_Node*) __n2->_M_next)\n+    if (__n1->_M_data != __n2->_M_data)\n       return false;\n-  return n1 == e1 && n2 == e2;\n+  return __n1 == __e1 && __n2 == __e2;\n }\n \n-template <class T, class Alloc>\n-inline bool operator<(const list<T, Alloc>& x, const list<T, Alloc>& y) {\n-  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n+template <class _Tp, class _Alloc>\n+inline bool operator<(const list<_Tp,_Alloc>& __x,\n+                      const list<_Tp,_Alloc>& __y)\n+{\n+  return lexicographical_compare(__x.begin(), __x.end(),\n+                                 __y.begin(), __y.end());\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class T, class Alloc>\n-inline void swap(list<T, Alloc>& x, list<T, Alloc>& y) {\n-  x.swap(y);\n+template <class _Tp, class _Alloc>\n+inline void \n+swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n+{\n+  __x.swap(__y);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n #ifdef __STL_MEMBER_TEMPLATES\n \n-template <class T, class Alloc> template <class InputIterator>\n-void list<T, Alloc>::insert(iterator position,\n-                            InputIterator first, InputIterator last) {\n-  for ( ; first != last; ++first)\n-    insert(position, *first);\n+template <class _Tp, class _Alloc> template <class _InputIter>\n+void \n+list<_Tp, _Alloc>::_M_insert_dispatch(iterator __position,\n+                                      _InputIter __first, _InputIter __last,\n+                                      __false_type)\n+{\n+  for ( ; __first != __last; ++__first)\n+    insert(__position, *__first);\n }\n \n #else /* __STL_MEMBER_TEMPLATES */\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::insert(iterator position, const T* first, const T* last) {\n-  for ( ; first != last; ++first)\n-    insert(position, *first);\n+template <class _Tp, class _Alloc>\n+void \n+list<_Tp, _Alloc>::insert(iterator __position, \n+                          const _Tp* __first, const _Tp* __last)\n+{\n+  for ( ; __first != __last; ++__first)\n+    insert(__position, *__first);\n }\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::insert(iterator position,\n-                            const_iterator first, const_iterator last) {\n-  for ( ; first != last; ++first)\n-    insert(position, *first);\n+template <class _Tp, class _Alloc>\n+void \n+list<_Tp, _Alloc>::insert(iterator __position,\n+                         const_iterator __first, const_iterator __last)\n+{\n+  for ( ; __first != __last; ++__first)\n+    insert(__position, *__first);\n }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::insert(iterator position, size_type n, const T& x) {\n-  for ( ; n > 0; --n)\n-    insert(position, x);\n+template <class _Tp, class _Alloc>\n+void \n+list<_Tp, _Alloc>::insert(iterator __position, size_type __n, const _Tp& __x)\n+{\n+  for ( ; __n > 0; --__n)\n+    insert(__position, __x);\n }\n \n-template <class T, class Alloc>\n-list<T,Alloc>::iterator list<T, Alloc>::erase(iterator first, iterator last) {\n-  while (first != last) erase(first++);\n-  return last;\n+template <class _Tp, class _Alloc>\n+list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::erase(iterator __first, \n+                                                    iterator __last)\n+{\n+  while (__first != __last)\n+    erase(__first++);\n+  return __last;\n }\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::resize(size_type new_size, const T& x)\n+template <class _Tp, class _Alloc>\n+void list<_Tp, _Alloc>::resize(size_type __new_size, const _Tp& __x)\n {\n-  iterator i = begin();\n-  size_type len = 0;\n-  for ( ; i != end() && len < new_size; ++i, ++len)\n+  iterator __i = begin();\n+  size_type __len = 0;\n+  for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n     ;\n-  if (len == new_size)\n-    erase(i, end());\n-  else                          // i == end()\n-    insert(end(), new_size - len, x);\n+  if (__len == __new_size)\n+    erase(__i, end());\n+  else                          // __i == end()\n+    insert(end(), __new_size - __len, __x);\n }\n \n-template <class T, class Alloc> \n-void list<T, Alloc>::clear()\n+template <class _Tp, class _Alloc>\n+list<_Tp, _Alloc>& list<_Tp, _Alloc>::operator=(const list<_Tp, _Alloc>& __x)\n {\n-  link_type cur = (link_type) node->next;\n-  while (cur != node) {\n-    link_type tmp = cur;\n-    cur = (link_type) cur->next;\n-    destroy_node(tmp);\n-  }\n-  node->next = node;\n-  node->prev = node;\n-}\n-\n-template <class T, class Alloc>\n-list<T, Alloc>& list<T, Alloc>::operator=(const list<T, Alloc>& x) {\n-  if (this != &x) {\n-    iterator first1 = begin();\n-    iterator last1 = end();\n-    const_iterator first2 = x.begin();\n-    const_iterator last2 = x.end();\n-    while (first1 != last1 && first2 != last2) *first1++ = *first2++;\n-    if (first2 == last2)\n-      erase(first1, last1);\n+  if (this != &__x) {\n+    iterator __first1 = begin();\n+    iterator __last1 = end();\n+    const_iterator __first2 = __x.begin();\n+    const_iterator __last2 = __x.end();\n+    while (__first1 != __last1 && __first2 != __last2) \n+      *__first1++ = *__first2++;\n+    if (__first2 == __last2)\n+      erase(__first1, __last1);\n     else\n-      insert(last1, first2, last2);\n+      insert(__last1, __first2, __last2);\n   }\n   return *this;\n }\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::remove(const T& value) {\n-  iterator first = begin();\n-  iterator last = end();\n-  while (first != last) {\n-    iterator next = first;\n-    ++next;\n-    if (*first == value) erase(first);\n-    first = next;\n+template <class _Tp, class _Alloc>\n+void list<_Tp, _Alloc>::assign(size_type __n, const _Tp& __val) {\n+  iterator __i = begin();\n+  for ( ; __i != end() && __n > 0; ++__i, --__n)\n+    *__i = __val;\n+  if (__n > 0)\n+    insert(end(), __n, __val);\n+  else\n+    erase(__i, end());\n+}\n+\n+#ifdef __STL_MEMBER_TEMPLATES\n+\n+template <class _Tp, class _Alloc> template <class _InputIter>\n+void\n+list<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first2, _InputIter __last2,\n+                                      __false_type)\n+{\n+  iterator __first1 = begin();\n+  iterator __last1 = end();\n+  for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+    *__first1 = *__first2;\n+  if (__first2 == __last2)\n+    erase(__first1, __last1);\n+  else\n+    insert(__last1, __first2, __last2);\n+}\n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+template <class _Tp, class _Alloc>\n+void list<_Tp, _Alloc>::remove(const _Tp& __value)\n+{\n+  iterator __first = begin();\n+  iterator __last = end();\n+  while (__first != __last) {\n+    iterator __next = __first;\n+    ++__next;\n+    if (*__first == __value) erase(__first);\n+    __first = __next;\n   }\n }\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::unique() {\n-  iterator first = begin();\n-  iterator last = end();\n-  if (first == last) return;\n-  iterator next = first;\n-  while (++next != last) {\n-    if (*first == *next)\n-      erase(next);\n+template <class _Tp, class _Alloc>\n+void list<_Tp, _Alloc>::unique()\n+{\n+  iterator __first = begin();\n+  iterator __last = end();\n+  if (__first == __last) return;\n+  iterator __next = __first;\n+  while (++__next != __last) {\n+    if (*__first == *__next)\n+      erase(__next);\n     else\n-      first = next;\n-    next = first;\n+      __first = __next;\n+    __next = __first;\n   }\n }\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::merge(list<T, Alloc>& x) {\n-  iterator first1 = begin();\n-  iterator last1 = end();\n-  iterator first2 = x.begin();\n-  iterator last2 = x.end();\n-  while (first1 != last1 && first2 != last2)\n-    if (*first2 < *first1) {\n-      iterator next = first2;\n-      transfer(first1, first2, ++next);\n-      first2 = next;\n+template <class _Tp, class _Alloc>\n+void list<_Tp, _Alloc>::merge(list<_Tp, _Alloc>& __x)\n+{\n+  iterator __first1 = begin();\n+  iterator __last1 = end();\n+  iterator __first2 = __x.begin();\n+  iterator __last2 = __x.end();\n+  while (__first1 != __last1 && __first2 != __last2)\n+    if (*__first2 < *__first1) {\n+      iterator __next = __first2;\n+      transfer(__first1, __first2, ++__next);\n+      __first2 = __next;\n     }\n     else\n-      ++first1;\n-  if (first2 != last2) transfer(last1, first2, last2);\n+      ++__first1;\n+  if (__first2 != __last2) transfer(__last1, __first2, __last2);\n }\n \n-template <class T, class Alloc>\n-void list<T, Alloc>::reverse() {\n-  if (node->next == node || link_type(node->next)->next == node) return;\n-  iterator first = begin();\n-  ++first;\n-  while (first != end()) {\n-    iterator old = first;\n-    ++first;\n-    transfer(begin(), old, first);\n+template <class _Tp, class _Alloc>\n+void list<_Tp, _Alloc>::reverse() \n+{\n+  // Do nothing if the list has length 0 or 1.\n+  if (_M_node->_M_next != _M_node &&\n+      ((_Node*) (_M_node->_M_next))->_M_next != _M_node) {\n+    iterator __first = begin();\n+    ++__first;\n+    while (__first != end()) {\n+      iterator __old = __first;\n+      ++__first;\n+      transfer(begin(), __old, __first);\n+    }\n   }\n }    \n \n-template <class T, class Alloc>\n-void list<T, Alloc>::sort() {\n-  if (node->next == node || link_type(node->next)->next == node) return;\n-  list<T, Alloc> carry;\n-  list<T, Alloc> counter[64];\n-  int fill = 0;\n-  while (!empty()) {\n-    carry.splice(carry.begin(), *this, begin());\n-    int i = 0;\n-    while(i < fill && !counter[i].empty()) {\n-      counter[i].merge(carry);\n-      carry.swap(counter[i++]);\n-    }\n-    carry.swap(counter[i]);         \n-    if (i == fill) ++fill;\n-  } \n-\n-  for (int i = 1; i < fill; ++i) counter[i].merge(counter[i-1]);\n-  swap(counter[fill-1]);\n+template <class _Tp, class _Alloc>\n+void list<_Tp, _Alloc>::sort()\n+{\n+  // Do nothing if the list has length 0 or 1.\n+  if (_M_node->_M_next != _M_node &&\n+      ((_Node*) (_M_node->_M_next))->_M_next != _M_node) {\n+    list<_Tp, _Alloc> __carry;\n+    list<_Tp, _Alloc> __counter[64];\n+    int __fill = 0;\n+    while (!empty()) {\n+      __carry.splice(__carry.begin(), *this, begin());\n+      int __i = 0;\n+      while(__i < __fill && !__counter[__i].empty()) {\n+        __counter[__i].merge(__carry);\n+        __carry.swap(__counter[__i++]);\n+      }\n+      __carry.swap(__counter[__i]);         \n+      if (__i == __fill) ++__fill;\n+    } \n+\n+    for (int __i = 1; __i < __fill; ++__i)\n+      __counter[__i].merge(__counter[__i-1]);\n+    swap(__counter[__fill-1]);\n+  }\n }\n \n #ifdef __STL_MEMBER_TEMPLATES\n \n-template <class T, class Alloc> template <class Predicate>\n-void list<T, Alloc>::remove_if(Predicate pred) {\n-  iterator first = begin();\n-  iterator last = end();\n-  while (first != last) {\n-    iterator next = first;\n-    ++next;\n-    if (pred(*first)) erase(first);\n-    first = next;\n+template <class _Tp, class _Alloc> template <class _Predicate>\n+void list<_Tp, _Alloc>::remove_if(_Predicate __pred)\n+{\n+  iterator __first = begin();\n+  iterator __last = end();\n+  while (__first != __last) {\n+    iterator __next = __first;\n+    ++__next;\n+    if (__pred(*__first)) erase(__first);\n+    __first = __next;\n   }\n }\n \n-template <class T, class Alloc> template <class BinaryPredicate>\n-void list<T, Alloc>::unique(BinaryPredicate binary_pred) {\n-  iterator first = begin();\n-  iterator last = end();\n-  if (first == last) return;\n-  iterator next = first;\n-  while (++next != last) {\n-    if (binary_pred(*first, *next))\n-      erase(next);\n+template <class _Tp, class _Alloc> template <class _BinaryPredicate>\n+void list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred)\n+{\n+  iterator __first = begin();\n+  iterator __last = end();\n+  if (__first == __last) return;\n+  iterator __next = __first;\n+  while (++__next != __last) {\n+    if (__binary_pred(*__first, *__next))\n+      erase(__next);\n     else\n-      first = next;\n-    next = first;\n+      __first = __next;\n+    __next = __first;\n   }\n }\n \n-template <class T, class Alloc> template <class StrictWeakOrdering>\n-void list<T, Alloc>::merge(list<T, Alloc>& x, StrictWeakOrdering comp) {\n-  iterator first1 = begin();\n-  iterator last1 = end();\n-  iterator first2 = x.begin();\n-  iterator last2 = x.end();\n-  while (first1 != last1 && first2 != last2)\n-    if (comp(*first2, *first1)) {\n-      iterator next = first2;\n-      transfer(first1, first2, ++next);\n-      first2 = next;\n+template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n+void list<_Tp, _Alloc>::merge(list<_Tp, _Alloc>& __x,\n+                              _StrictWeakOrdering __comp)\n+{\n+  iterator __first1 = begin();\n+  iterator __last1 = end();\n+  iterator __first2 = __x.begin();\n+  iterator __last2 = __x.end();\n+  while (__first1 != __last1 && __first2 != __last2)\n+    if (__comp(*__first2, *__first1)) {\n+      iterator __next = __first2;\n+      transfer(__first1, __first2, ++__next);\n+      __first2 = __next;\n     }\n     else\n-      ++first1;\n-  if (first2 != last2) transfer(last1, first2, last2);\n+      ++__first1;\n+  if (__first2 != __last2) transfer(__last1, __first2, __last2);\n }\n \n-template <class T, class Alloc> template <class StrictWeakOrdering>\n-void list<T, Alloc>::sort(StrictWeakOrdering comp) {\n-  if (node->next == node || link_type(node->next)->next == node) return;\n-  list<T, Alloc> carry;\n-  list<T, Alloc> counter[64];\n-  int fill = 0;\n-  while (!empty()) {\n-    carry.splice(carry.begin(), *this, begin());\n-    int i = 0;\n-    while(i < fill && !counter[i].empty()) {\n-      counter[i].merge(carry, comp);\n-      carry.swap(counter[i++]);\n-    }\n-    carry.swap(counter[i]);         \n-    if (i == fill) ++fill;\n-  } \n-\n-  for (int i = 1; i < fill; ++i) counter[i].merge(counter[i-1], comp);\n-  swap(counter[fill-1]);\n+template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n+void list<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)\n+{\n+  // Do nothing if the list has length 0 or 1.\n+  if (_M_node->_M_next != _M_node &&\n+      ((_Node*) (_M_node->_M_next))->_M_next != _M_node) {\n+    list<_Tp, _Alloc> __carry;\n+    list<_Tp, _Alloc> __counter[64];\n+    int __fill = 0;\n+    while (!empty()) {\n+      __carry.splice(__carry.begin(), *this, begin());\n+      int __i = 0;\n+      while(__i < __fill && !__counter[__i].empty()) {\n+        __counter[__i].merge(__carry, __comp);\n+        __carry.swap(__counter[__i++]);\n+      }\n+      __carry.swap(__counter[__i]);         \n+      if (__i == __fill) ++__fill;\n+    } \n+\n+    for (int __i = 1; __i < __fill; ++__i) \n+      __counter[__i].merge(__counter[__i-1], __comp);\n+    swap(__counter[__fill-1]);\n+  }\n }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n \n __STL_END_NAMESPACE "}, {"sha": "a702e8023efa78237b323cc3d13ff55e60506d1f", "filename": "libstdc++/stl/stl_map.h", "status": "modified", "additions": 127, "deletions": 102, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_map.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -35,177 +35,202 @@ __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class Compare = less<Key>, class Alloc = alloc>\n+template <class _Key, class _Tp, class _Compare = less<_Key>,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #else\n-template <class Key, class T, class Compare, class Alloc = alloc>\n+template <class _Key, class _Tp, class _Compare,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #endif\n class map {\n public:\n \n // typedefs:\n \n-  typedef Key key_type;\n-  typedef T data_type;\n-  typedef T mapped_type;\n-  typedef pair<const Key, T> value_type;\n-  typedef Compare key_compare;\n+  typedef _Key                  key_type;\n+  typedef _Tp                   data_type;\n+  typedef _Tp                   mapped_type;\n+  typedef pair<const _Key, _Tp> value_type;\n+  typedef _Compare              key_compare;\n     \n   class value_compare\n     : public binary_function<value_type, value_type, bool> {\n-  friend class map<Key, T, Compare, Alloc>;\n+  friend class map<_Key,_Tp,_Compare,_Alloc>;\n   protected :\n-    Compare comp;\n-    value_compare(Compare c) : comp(c) {}\n+    _Compare _M_comp;\n+    value_compare(_Compare __c) : _M_comp(__c) {}\n   public:\n-    bool operator()(const value_type& x, const value_type& y) const {\n-      return comp(x.first, y.first);\n+    bool operator()(const value_type& __x, const value_type& __y) const {\n+      return _M_comp(__x.first, __y.first);\n     }\n   };\n \n private:\n-  typedef rb_tree<key_type, value_type, \n-                  select1st<value_type>, key_compare, Alloc> rep_type;\n-  rep_type t;  // red-black tree representing map\n+  typedef _Rb_tree<key_type, value_type, \n+                   _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+  _Rep_type _M_t;  // red-black tree representing map\n public:\n-  typedef typename rep_type::pointer pointer;\n-  typedef typename rep_type::const_pointer const_pointer;\n-  typedef typename rep_type::reference reference;\n-  typedef typename rep_type::const_reference const_reference;\n-  typedef typename rep_type::iterator iterator;\n-  typedef typename rep_type::const_iterator const_iterator;\n-  typedef typename rep_type::reverse_iterator reverse_iterator;\n-  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef typename rep_type::size_type size_type;\n-  typedef typename rep_type::difference_type difference_type;\n+  typedef typename _Rep_type::pointer pointer;\n+  typedef typename _Rep_type::const_pointer const_pointer;\n+  typedef typename _Rep_type::reference reference;\n+  typedef typename _Rep_type::const_reference const_reference;\n+  typedef typename _Rep_type::iterator iterator;\n+  typedef typename _Rep_type::const_iterator const_iterator;\n+  typedef typename _Rep_type::reverse_iterator reverse_iterator;\n+  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+  typedef typename _Rep_type::size_type size_type;\n+  typedef typename _Rep_type::difference_type difference_type;\n+  typedef typename _Rep_type::allocator_type allocator_type;\n \n   // allocation/deallocation\n \n-  map() : t(Compare()) {}\n-  explicit map(const Compare& comp) : t(comp) {}\n+  map() : _M_t(_Compare(), allocator_type()) {}\n+  explicit map(const _Compare& __comp,\n+               const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  map(InputIterator first, InputIterator last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-\n-  template <class InputIterator>\n-  map(InputIterator first, InputIterator last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n+  template <class _InputIterator>\n+  map(_InputIterator __first, _InputIterator __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_unique(__first, __last); }\n+\n+  template <class _InputIterator>\n+  map(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n+      const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n #else\n-  map(const value_type* first, const value_type* last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-  map(const value_type* first, const value_type* last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n-\n-  map(const_iterator first, const_iterator last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-  map(const_iterator first, const_iterator last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n+  map(const value_type* __first, const value_type* __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_unique(__first, __last); }\n+\n+  map(const value_type* __first,\n+      const value_type* __last, const _Compare& __comp,\n+      const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n+\n+  map(const_iterator __first, const_iterator __last)\n+    : _M_t(_Compare(), allocator_type()) \n+    { _M_t.insert_unique(__first, __last); }\n+\n+  map(const_iterator __first, const_iterator __last, const _Compare& __comp,\n+      const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n+\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}\n-  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)\n+  map(const map<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+  map<_Key,_Tp,_Compare,_Alloc>&\n+  operator=(const map<_Key, _Tp, _Compare, _Alloc>& __x)\n   {\n-    t = x.t;\n+    _M_t = __x._M_t;\n     return *this; \n   }\n \n   // accessors:\n \n-  key_compare key_comp() const { return t.key_comp(); }\n-  value_compare value_comp() const { return value_compare(t.key_comp()); }\n-  iterator begin() { return t.begin(); }\n-  const_iterator begin() const { return t.begin(); }\n-  iterator end() { return t.end(); }\n-  const_iterator end() const { return t.end(); }\n-  reverse_iterator rbegin() { return t.rbegin(); }\n-  const_reverse_iterator rbegin() const { return t.rbegin(); }\n-  reverse_iterator rend() { return t.rend(); }\n-  const_reverse_iterator rend() const { return t.rend(); }\n-  bool empty() const { return t.empty(); }\n-  size_type size() const { return t.size(); }\n-  size_type max_size() const { return t.max_size(); }\n-  T& operator[](const key_type& k) {\n-    return (*((insert(value_type(k, T()))).first)).second;\n+  key_compare key_comp() const { return _M_t.key_comp(); }\n+  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }\n+  allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+\n+  iterator begin() { return _M_t.begin(); }\n+  const_iterator begin() const { return _M_t.begin(); }\n+  iterator end() { return _M_t.end(); }\n+  const_iterator end() const { return _M_t.end(); }\n+  reverse_iterator rbegin() { return _M_t.rbegin(); }\n+  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }\n+  reverse_iterator rend() { return _M_t.rend(); }\n+  const_reverse_iterator rend() const { return _M_t.rend(); }\n+  bool empty() const { return _M_t.empty(); }\n+  size_type size() const { return _M_t.size(); }\n+  size_type max_size() const { return _M_t.max_size(); }\n+  _Tp& operator[](const key_type& __k) {\n+    iterator __i = lower_bound(__k);\n+    // __i->first is greater than or equivalent to __k.\n+    if (__i == end() || key_comp()(__k, (*__i).first))\n+      __i = insert(__i, value_type(__k, _Tp()));\n+    return (*__i).second;\n   }\n-  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }\n+  void swap(map<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n \n   // insert/erase\n \n-  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }\n-  iterator insert(iterator position, const value_type& x) {\n-    return t.insert_unique(position, x);\n-  }\n+  pair<iterator,bool> insert(const value_type& __x) \n+    { return _M_t.insert_unique(__x); }\n+  iterator insert(iterator position, const value_type& __x)\n+    { return _M_t.insert_unique(position, __x); }\n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator first, InputIterator last) {\n-    t.insert_unique(first, last);\n+  template <class _InputIterator>\n+  void insert(_InputIterator __first, _InputIterator __last) {\n+    _M_t.insert_unique(__first, __last);\n   }\n #else\n-  void insert(const value_type* first, const value_type* last) {\n-    t.insert_unique(first, last);\n+  void insert(const value_type* __first, const value_type* __last) {\n+    _M_t.insert_unique(__first, __last);\n   }\n-  void insert(const_iterator first, const_iterator last) {\n-    t.insert_unique(first, last);\n+  void insert(const_iterator __first, const_iterator __last) {\n+    _M_t.insert_unique(__first, __last);\n   }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  void erase(iterator position) { t.erase(position); }\n-  size_type erase(const key_type& x) { return t.erase(x); }\n-  void erase(iterator first, iterator last) { t.erase(first, last); }\n-  void clear() { t.clear(); }\n+  void erase(iterator __position) { _M_t.erase(__position); }\n+  size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+  void erase(iterator __first, iterator __last)\n+    { _M_t.erase(__first, __last); }\n+  void clear() { _M_t.clear(); }\n \n   // map operations:\n \n-  iterator find(const key_type& x) { return t.find(x); }\n-  const_iterator find(const key_type& x) const { return t.find(x); }\n-  size_type count(const key_type& x) const { return t.count(x); }\n-  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }\n-  const_iterator lower_bound(const key_type& x) const {\n-    return t.lower_bound(x); \n+  iterator find(const key_type& __x) { return _M_t.find(__x); }\n+  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+  size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+  iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }\n+  const_iterator lower_bound(const key_type& __x) const {\n+    return _M_t.lower_bound(__x); \n   }\n-  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }\n-  const_iterator upper_bound(const key_type& x) const {\n-    return t.upper_bound(x); \n+  iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }\n+  const_iterator upper_bound(const key_type& __x) const {\n+    return _M_t.upper_bound(__x); \n   }\n   \n-  pair<iterator,iterator> equal_range(const key_type& x) {\n-    return t.equal_range(x);\n+  pair<iterator,iterator> equal_range(const key_type& __x) {\n+    return _M_t.equal_range(__x);\n   }\n-  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {\n-    return t.equal_range(x);\n+  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n+    return _M_t.equal_range(__x);\n   }\n   friend bool operator== __STL_NULL_TMPL_ARGS (const map&, const map&);\n   friend bool operator< __STL_NULL_TMPL_ARGS (const map&, const map&);\n };\n \n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator==(const map<Key, T, Compare, Alloc>& x, \n-                       const map<Key, T, Compare, Alloc>& y) {\n-  return x.t == y.t;\n+template <class _Key, class _Tp, class _Compare, class _Alloc>\n+inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n+  return __x._M_t == __y._M_t;\n }\n \n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator<(const map<Key, T, Compare, Alloc>& x, \n-                      const map<Key, T, Compare, Alloc>& y) {\n-  return x.t < y.t;\n+template <class _Key, class _Tp, class _Compare, class _Alloc>\n+inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+                      const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n+  return __x._M_t < __y._M_t;\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Key, class T, class Compare, class Alloc>\n-inline void swap(map<Key, T, Compare, Alloc>& x, \n-                 map<Key, T, Compare, Alloc>& y) {\n-  x.swap(y);\n+template <class _Key, class _Tp, class _Compare, class _Alloc>\n+inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x, \n+                 map<_Key,_Tp,_Compare,_Alloc>& __y) {\n+  __x.swap(__y);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n \n __STL_END_NAMESPACE"}, {"sha": "b7d3b87e52d1da81aa99be488bc0e76efcfffc3b", "filename": "libstdc++/stl/stl_multimap.h", "status": "modified", "additions": 119, "deletions": 101, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_multimap.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -35,174 +35,192 @@ __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class Compare = less<Key>, class Alloc = alloc>\n+template <class _Key, class _Tp, class _Compare = less<_Key>,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #else\n-template <class Key, class T, class Compare, class Alloc = alloc>\n+template <class _Key, class _Tp, class _Compare,\n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n #endif\n class multimap {\n public:\n \n // typedefs:\n \n-  typedef Key key_type;\n-  typedef T data_type;\n-  typedef T mapped_type;\n-  typedef pair<const Key, T> value_type;\n-  typedef Compare key_compare;\n+  typedef _Key                  key_type;\n+  typedef _Tp                   data_type;\n+  typedef _Tp                   mapped_type;\n+  typedef pair<const _Key, _Tp> value_type;\n+  typedef _Compare              key_compare;\n \n   class value_compare : public binary_function<value_type, value_type, bool> {\n-  friend class multimap<Key, T, Compare, Alloc>;\n+  friend class multimap<_Key,_Tp,_Compare,_Alloc>;\n   protected:\n-    Compare comp;\n-    value_compare(Compare c) : comp(c) {}\n+    _Compare _M_comp;\n+    value_compare(_Compare __c) : _M_comp(__c) {}\n   public:\n-    bool operator()(const value_type& x, const value_type& y) const {\n-      return comp(x.first, y.first);\n+    bool operator()(const value_type& __x, const value_type& __y) const {\n+      return _M_comp(__x.first, __y.first);\n     }\n   };\n \n private:\n-  typedef rb_tree<key_type, value_type, \n-                  select1st<value_type>, key_compare, Alloc> rep_type;\n-  rep_type t;  // red-black tree representing multimap\n+  typedef _Rb_tree<key_type, value_type, \n+                  _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+  _Rep_type _M_t;  // red-black tree representing multimap\n public:\n-  typedef typename rep_type::pointer pointer;\n-  typedef typename rep_type::const_pointer const_pointer;\n-  typedef typename rep_type::reference reference;\n-  typedef typename rep_type::const_reference const_reference;\n-  typedef typename rep_type::iterator iterator;\n-  typedef typename rep_type::const_iterator const_iterator; \n-  typedef typename rep_type::reverse_iterator reverse_iterator;\n-  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef typename rep_type::size_type size_type;\n-  typedef typename rep_type::difference_type difference_type;\n+  typedef typename _Rep_type::pointer pointer;\n+  typedef typename _Rep_type::const_pointer const_pointer;\n+  typedef typename _Rep_type::reference reference;\n+  typedef typename _Rep_type::const_reference const_reference;\n+  typedef typename _Rep_type::iterator iterator;\n+  typedef typename _Rep_type::const_iterator const_iterator; \n+  typedef typename _Rep_type::reverse_iterator reverse_iterator;\n+  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+  typedef typename _Rep_type::size_type size_type;\n+  typedef typename _Rep_type::difference_type difference_type;\n+  typedef typename _Rep_type::allocator_type allocator_type;\n \n // allocation/deallocation\n \n-  multimap() : t(Compare()) { }\n-  explicit multimap(const Compare& comp) : t(comp) { }\n+  multimap() : _M_t(_Compare(), allocator_type()) { }\n+  explicit multimap(const _Compare& __comp,\n+                    const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { }\n \n #ifdef __STL_MEMBER_TEMPLATES  \n-  template <class InputIterator>\n-  multimap(InputIterator first, InputIterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-\n-  template <class InputIterator>\n-  multimap(InputIterator first, InputIterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n+  template <class _InputIterator>\n+  multimap(_InputIterator __first, _InputIterator __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_equal(__first, __last); }\n+\n+  template <class _InputIterator>\n+  multimap(_InputIterator __first, _InputIterator __last,\n+           const _Compare& __comp,\n+           const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n #else\n-  multimap(const value_type* first, const value_type* last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multimap(const value_type* first, const value_type* last,\n-           const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-\n-  multimap(const_iterator first, const_iterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multimap(const_iterator first, const_iterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n+  multimap(const value_type* __first, const value_type* __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_equal(__first, __last); }\n+  multimap(const value_type* __first, const value_type* __last,\n+           const _Compare& __comp,\n+           const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n+\n+  multimap(const_iterator __first, const_iterator __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_equal(__first, __last); }\n+  multimap(const_iterator __first, const_iterator __last,\n+           const _Compare& __comp,\n+           const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  multimap(const multimap<Key, T, Compare, Alloc>& x) : t(x.t) { }\n-  multimap<Key, T, Compare, Alloc>&\n-  operator=(const multimap<Key, T, Compare, Alloc>& x) {\n-    t = x.t;\n+  multimap(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) { }\n+  multimap<_Key,_Tp,_Compare,_Alloc>&\n+  operator=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) {\n+    _M_t = __x._M_t;\n     return *this; \n   }\n \n   // accessors:\n \n-  key_compare key_comp() const { return t.key_comp(); }\n-  value_compare value_comp() const { return value_compare(t.key_comp()); }\n-  iterator begin() { return t.begin(); }\n-  const_iterator begin() const { return t.begin(); }\n-  iterator end() { return t.end(); }\n-  const_iterator end() const { return t.end(); }\n-  reverse_iterator rbegin() { return t.rbegin(); }\n-  const_reverse_iterator rbegin() const { return t.rbegin(); }\n-  reverse_iterator rend() { return t.rend(); }\n-  const_reverse_iterator rend() const { return t.rend(); }\n-  bool empty() const { return t.empty(); }\n-  size_type size() const { return t.size(); }\n-  size_type max_size() const { return t.max_size(); }\n-  void swap(multimap<Key, T, Compare, Alloc>& x) { t.swap(x.t); }\n+  key_compare key_comp() const { return _M_t.key_comp(); }\n+  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }\n+  allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+\n+  iterator begin() { return _M_t.begin(); }\n+  const_iterator begin() const { return _M_t.begin(); }\n+  iterator end() { return _M_t.end(); }\n+  const_iterator end() const { return _M_t.end(); }\n+  reverse_iterator rbegin() { return _M_t.rbegin(); }\n+  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }\n+  reverse_iterator rend() { return _M_t.rend(); }\n+  const_reverse_iterator rend() const { return _M_t.rend(); }\n+  bool empty() const { return _M_t.empty(); }\n+  size_type size() const { return _M_t.size(); }\n+  size_type max_size() const { return _M_t.max_size(); }\n+  void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n \n   // insert/erase\n \n-  iterator insert(const value_type& x) { return t.insert_equal(x); }\n-  iterator insert(iterator position, const value_type& x) {\n-    return t.insert_equal(position, x);\n+  iterator insert(const value_type& __x) { return _M_t.insert_equal(__x); }\n+  iterator insert(iterator __position, const value_type& __x) {\n+    return _M_t.insert_equal(__position, __x);\n   }\n #ifdef __STL_MEMBER_TEMPLATES  \n-  template <class InputIterator>\n-  void insert(InputIterator first, InputIterator last) {\n-    t.insert_equal(first, last);\n+  template <class _InputIterator>\n+  void insert(_InputIterator __first, _InputIterator __last) {\n+    _M_t.insert_equal(__first, __last);\n   }\n #else\n-  void insert(const value_type* first, const value_type* last) {\n-    t.insert_equal(first, last);\n+  void insert(const value_type* __first, const value_type* __last) {\n+    _M_t.insert_equal(__first, __last);\n   }\n-  void insert(const_iterator first, const_iterator last) {\n-    t.insert_equal(first, last);\n+  void insert(const_iterator __first, const_iterator __last) {\n+    _M_t.insert_equal(__first, __last);\n   }\n #endif /* __STL_MEMBER_TEMPLATES */\n-  void erase(iterator position) { t.erase(position); }\n-  size_type erase(const key_type& x) { return t.erase(x); }\n-  void erase(iterator first, iterator last) { t.erase(first, last); }\n-  void clear() { t.clear(); }\n+  void erase(iterator __position) { _M_t.erase(__position); }\n+  size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+  void erase(iterator __first, iterator __last)\n+    { _M_t.erase(__first, __last); }\n+  void clear() { _M_t.clear(); }\n \n   // multimap operations:\n \n-  iterator find(const key_type& x) { return t.find(x); }\n-  const_iterator find(const key_type& x) const { return t.find(x); }\n-  size_type count(const key_type& x) const { return t.count(x); }\n-  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }\n-  const_iterator lower_bound(const key_type& x) const {\n-    return t.lower_bound(x); \n+  iterator find(const key_type& __x) { return _M_t.find(__x); }\n+  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+  size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+  iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }\n+  const_iterator lower_bound(const key_type& __x) const {\n+    return _M_t.lower_bound(__x); \n   }\n-  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }\n-  const_iterator upper_bound(const key_type& x) const {\n-    return t.upper_bound(x); \n+  iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }\n+  const_iterator upper_bound(const key_type& __x) const {\n+    return _M_t.upper_bound(__x); \n   }\n-   pair<iterator,iterator> equal_range(const key_type& x) {\n-    return t.equal_range(x);\n+   pair<iterator,iterator> equal_range(const key_type& __x) {\n+    return _M_t.equal_range(__x);\n   }\n-  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {\n-    return t.equal_range(x);\n+  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n+    return _M_t.equal_range(__x);\n   }\n   friend bool operator== __STL_NULL_TMPL_ARGS (const multimap&,\n                                                const multimap&);\n   friend bool operator< __STL_NULL_TMPL_ARGS (const multimap&,\n                                               const multimap&);\n };\n \n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator==(const multimap<Key, T, Compare, Alloc>& x, \n-                       const multimap<Key, T, Compare, Alloc>& y) {\n-  return x.t == y.t;\n+template <class _Key, class _Tp, class _Compare, class _Alloc>\n+inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n+                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n+  return __x._M_t == __y._M_t;\n }\n \n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator<(const multimap<Key, T, Compare, Alloc>& x, \n-                      const multimap<Key, T, Compare, Alloc>& y) {\n-  return x.t < y.t;\n+template <class _Key, class _Tp, class _Compare, class _Alloc>\n+inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n+                      const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n+  return __x._M_t < __y._M_t;\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Key, class T, class Compare, class Alloc>\n-inline void swap(multimap<Key, T, Compare, Alloc>& x, \n-                 multimap<Key, T, Compare, Alloc>& y) {\n-  x.swap(y);\n+template <class _Key, class _Tp, class _Compare, class _Alloc>\n+inline void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n+                 multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n+  __x.swap(__y);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n \n __STL_END_NAMESPACE"}, {"sha": "7378e43f8b360668aa9ebc7229cd328588e81498", "filename": "libstdc++/stl/stl_multiset.h", "status": "modified", "additions": 116, "deletions": 92, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_multiset.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -35,160 +35,184 @@ __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n+#pragma set woff 1375\n #endif\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class Compare = less<Key>, class Alloc = alloc>\n+template <class _Key, class _Compare = less<_Key>, \n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Key) >\n #else\n-template <class Key, class Compare, class Alloc = alloc>\n+template <class _Key, class _Compare, \n+          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Key) >\n #endif\n class multiset {\n public:\n   // typedefs:\n \n-  typedef Key key_type;\n-  typedef Key value_type;\n-  typedef Compare key_compare;\n-  typedef Compare value_compare;\n+  typedef _Key     key_type;\n+  typedef _Key     value_type;\n+  typedef _Compare key_compare;\n+  typedef _Compare value_compare;\n private:\n-  typedef rb_tree<key_type, value_type, \n-                  identity<value_type>, key_compare, Alloc> rep_type;\n-  rep_type t;  // red-black tree representing multiset\n+  typedef _Rb_tree<key_type, value_type, \n+                  _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n+  _Rep_type _M_t;  // red-black tree representing multiset\n public:\n-  typedef typename rep_type::const_pointer pointer;\n-  typedef typename rep_type::const_pointer const_pointer;\n-  typedef typename rep_type::const_reference reference;\n-  typedef typename rep_type::const_reference const_reference;\n-  typedef typename rep_type::const_iterator iterator;\n-  typedef typename rep_type::const_iterator const_iterator;\n-  typedef typename rep_type::const_reverse_iterator reverse_iterator;\n-  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef typename rep_type::size_type size_type;\n-  typedef typename rep_type::difference_type difference_type;\n+  typedef typename _Rep_type::const_pointer pointer;\n+  typedef typename _Rep_type::const_pointer const_pointer;\n+  typedef typename _Rep_type::const_reference reference;\n+  typedef typename _Rep_type::const_reference const_reference;\n+  typedef typename _Rep_type::const_iterator iterator;\n+  typedef typename _Rep_type::const_iterator const_iterator;\n+  typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n+  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+  typedef typename _Rep_type::size_type size_type;\n+  typedef typename _Rep_type::difference_type difference_type;\n+  typedef typename _Rep_type::allocator_type allocator_type;\n \n   // allocation/deallocation\n \n-  multiset() : t(Compare()) {}\n-  explicit multiset(const Compare& comp) : t(comp) {}\n+  multiset() : _M_t(_Compare(), allocator_type()) {}\n+  explicit multiset(const _Compare& __comp,\n+                    const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  multiset(InputIterator first, InputIterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  template <class InputIterator>\n-  multiset(InputIterator first, InputIterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n+\n+  template <class _InputIterator>\n+  multiset(_InputIterator __first, _InputIterator __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_equal(__first, __last); }\n+\n+  template <class _InputIterator>\n+  multiset(_InputIterator __first, _InputIterator __last,\n+           const _Compare& __comp,\n+           const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n+\n #else\n-  multiset(const value_type* first, const value_type* last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multiset(const value_type* first, const value_type* last,\n-           const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-\n-  multiset(const_iterator first, const_iterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multiset(const_iterator first, const_iterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n+\n+  multiset(const value_type* __first, const value_type* __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_equal(__first, __last); }\n+\n+  multiset(const value_type* __first, const value_type* __last,\n+           const _Compare& __comp,\n+           const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n+\n+  multiset(const_iterator __first, const_iterator __last)\n+    : _M_t(_Compare(), allocator_type())\n+    { _M_t.insert_equal(__first, __last); }\n+\n+  multiset(const_iterator __first, const_iterator __last,\n+           const _Compare& __comp,\n+           const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n+   \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}\n-  multiset<Key, Compare, Alloc>&\n-  operator=(const multiset<Key, Compare, Alloc>& x) {\n-    t = x.t; \n+  multiset(const multiset<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+  multiset<_Key,_Compare,_Alloc>&\n+  operator=(const multiset<_Key,_Compare,_Alloc>& __x) {\n+    _M_t = __x._M_t; \n     return *this;\n   }\n \n   // accessors:\n \n-  key_compare key_comp() const { return t.key_comp(); }\n-  value_compare value_comp() const { return t.key_comp(); }\n-  iterator begin() const { return t.begin(); }\n-  iterator end() const { return t.end(); }\n-  reverse_iterator rbegin() const { return t.rbegin(); } \n-  reverse_iterator rend() const { return t.rend(); }\n-  bool empty() const { return t.empty(); }\n-  size_type size() const { return t.size(); }\n-  size_type max_size() const { return t.max_size(); }\n-  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }\n+  key_compare key_comp() const { return _M_t.key_comp(); }\n+  value_compare value_comp() const { return _M_t.key_comp(); }\n+  allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+\n+  iterator begin() const { return _M_t.begin(); }\n+  iterator end() const { return _M_t.end(); }\n+  reverse_iterator rbegin() const { return _M_t.rbegin(); } \n+  reverse_iterator rend() const { return _M_t.rend(); }\n+  bool empty() const { return _M_t.empty(); }\n+  size_type size() const { return _M_t.size(); }\n+  size_type max_size() const { return _M_t.max_size(); }\n+  void swap(multiset<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n \n   // insert/erase\n-  iterator insert(const value_type& x) { \n-    return t.insert_equal(x);\n+  iterator insert(const value_type& __x) { \n+    return _M_t.insert_equal(__x);\n   }\n-  iterator insert(iterator position, const value_type& x) {\n-    typedef typename rep_type::iterator rep_iterator;\n-    return t.insert_equal((rep_iterator&)position, x);\n+  iterator insert(iterator __position, const value_type& __x) {\n+    typedef typename _Rep_type::iterator _Rep_iterator;\n+    return _M_t.insert_equal((_Rep_iterator&)__position, __x);\n   }\n \n #ifdef __STL_MEMBER_TEMPLATES  \n-  template <class InputIterator>\n-  void insert(InputIterator first, InputIterator last) {\n-    t.insert_equal(first, last);\n+  template <class _InputIterator>\n+  void insert(_InputIterator __first, _InputIterator __last) {\n+    _M_t.insert_equal(__first, __last);\n   }\n #else\n-  void insert(const value_type* first, const value_type* last) {\n-    t.insert_equal(first, last);\n+  void insert(const value_type* __first, const value_type* __last) {\n+    _M_t.insert_equal(__first, __last);\n   }\n-  void insert(const_iterator first, const_iterator last) {\n-    t.insert_equal(first, last);\n+  void insert(const_iterator __first, const_iterator __last) {\n+    _M_t.insert_equal(__first, __last);\n   }\n #endif /* __STL_MEMBER_TEMPLATES */\n-  void erase(iterator position) { \n-    typedef typename rep_type::iterator rep_iterator;\n-    t.erase((rep_iterator&)position); \n+  void erase(iterator __position) { \n+    typedef typename _Rep_type::iterator _Rep_iterator;\n+    _M_t.erase((_Rep_iterator&)__position); \n   }\n-  size_type erase(const key_type& x) { \n-    return t.erase(x); \n+  size_type erase(const key_type& __x) { \n+    return _M_t.erase(__x); \n   }\n-  void erase(iterator first, iterator last) { \n-    typedef typename rep_type::iterator rep_iterator;\n-    t.erase((rep_iterator&)first, (rep_iterator&)last); \n+  void erase(iterator __first, iterator __last) { \n+    typedef typename _Rep_type::iterator _Rep_iterator;\n+    _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n   }\n-  void clear() { t.clear(); }\n+  void clear() { _M_t.clear(); }\n \n   // multiset operations:\n \n-  iterator find(const key_type& x) const { return t.find(x); }\n-  size_type count(const key_type& x) const { return t.count(x); }\n-  iterator lower_bound(const key_type& x) const {\n-    return t.lower_bound(x);\n+  iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+  size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+  iterator lower_bound(const key_type& __x) const {\n+    return _M_t.lower_bound(__x);\n   }\n-  iterator upper_bound(const key_type& x) const {\n-    return t.upper_bound(x); \n+  iterator upper_bound(const key_type& __x) const {\n+    return _M_t.upper_bound(__x); \n   }\n-  pair<iterator,iterator> equal_range(const key_type& x) const {\n-    return t.equal_range(x);\n+  pair<iterator,iterator> equal_range(const key_type& __x) const {\n+    return _M_t.equal_range(__x);\n   }\n   friend bool operator== __STL_NULL_TMPL_ARGS (const multiset&,\n                                                const multiset&);\n   friend bool operator< __STL_NULL_TMPL_ARGS (const multiset&,\n                                               const multiset&);\n };\n \n-template <class Key, class Compare, class Alloc>\n-inline bool operator==(const multiset<Key, Compare, Alloc>& x, \n-                       const multiset<Key, Compare, Alloc>& y) {\n-  return x.t == y.t;\n+template <class _Key, class _Compare, class _Alloc>\n+inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n+                       const multiset<_Key,_Compare,_Alloc>& __y) {\n+  return __x._M_t == __y._M_t;\n }\n \n-template <class Key, class Compare, class Alloc>\n-inline bool operator<(const multiset<Key, Compare, Alloc>& x, \n-                      const multiset<Key, Compare, Alloc>& y) {\n-  return x.t < y.t;\n+template <class _Key, class _Compare, class _Alloc>\n+inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n+                      const multiset<_Key,_Compare,_Alloc>& __y) {\n+  return __x._M_t < __y._M_t;\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class Key, class Compare, class Alloc>\n-inline void swap(multiset<Key, Compare, Alloc>& x, \n-                 multiset<Key, Compare, Alloc>& y) {\n-  x.swap(y);\n+template <class _Key, class _Compare, class _Alloc>\n+inline void swap(multiset<_Key,_Compare,_Alloc>& __x, \n+                 multiset<_Key,_Compare,_Alloc>& __y) {\n+  __x.swap(__y);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174\n+#pragma reset woff 1375\n #endif\n \n __STL_END_NAMESPACE"}, {"sha": "da7865498caedf111cab0401c2d661c192cd8b77", "filename": "libstdc++/stl/stl_numeric.h", "status": "modified", "additions": 176, "deletions": 133, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_numeric.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -34,157 +34,200 @@\n \n __STL_BEGIN_NAMESPACE\n \n-template <class InputIterator, class T>\n-T accumulate(InputIterator first, InputIterator last, T init) {\n-  for ( ; first != last; ++first)\n-    init = init + *first;\n-  return init;\n-}\n-\n-template <class InputIterator, class T, class BinaryOperation>\n-T accumulate(InputIterator first, InputIterator last, T init,\n-             BinaryOperation binary_op) {\n-  for ( ; first != last; ++first)\n-    init = binary_op(init, *first);\n-  return init;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class T>\n-T inner_product(InputIterator1 first1, InputIterator1 last1,\n-                InputIterator2 first2, T init) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    init = init + (*first1 * *first2);\n-  return init;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class T,\n-          class BinaryOperation1, class BinaryOperation2>\n-T inner_product(InputIterator1 first1, InputIterator1 last1,\n-                InputIterator2 first2, T init, BinaryOperation1 binary_op1,\n-                BinaryOperation2 binary_op2) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    init = binary_op1(init, binary_op2(*first1, *first2));\n-  return init;\n-}\n-\n-template <class InputIterator, class OutputIterator, class T>\n-OutputIterator __partial_sum(InputIterator first, InputIterator last,\n-                             OutputIterator result, T*) {\n-  T value = *first;\n-  while (++first != last) {\n-    value = value + *first;\n-    *++result = value;\n+template <class _InputIterator, class _Tp>\n+_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n+{\n+  for ( ; __first != __last; ++__first)\n+    __init = __init + *__first;\n+  return __init;\n+}\n+\n+template <class _InputIterator, class _Tp, class _BinaryOperation>\n+_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,\n+               _BinaryOperation __binary_op)\n+{\n+  for ( ; __first != __last; ++__first)\n+    __init = __binary_op(__init, *__first);\n+  return __init;\n+}\n+\n+template <class _InputIterator1, class _InputIterator2, class _Tp>\n+_Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n+                  _InputIterator2 __first2, _Tp __init)\n+{\n+  for ( ; __first1 != __last1; ++__first1, ++__first2)\n+    __init = __init + (*__first1 * *__first2);\n+  return __init;\n+}\n+\n+template <class _InputIterator1, class _InputIterator2, class _Tp,\n+          class _BinaryOperation1, class _BinaryOperation2>\n+_Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n+                  _InputIterator2 __first2, _Tp __init, \n+                  _BinaryOperation1 __binary_op1,\n+                  _BinaryOperation2 __binary_op2)\n+{\n+  for ( ; __first1 != __last1; ++__first1, ++__first2)\n+    __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n+  return __init;\n+}\n+\n+template <class _InputIterator, class _OutputIterator, class _Tp>\n+_OutputIterator \n+__partial_sum(_InputIterator __first, _InputIterator __last,\n+              _OutputIterator __result, _Tp*)\n+{\n+  _Tp __value = *__first;\n+  while (++__first != __last) {\n+    __value = __value + *__first;\n+    *++__result = __value;\n   }\n-  return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-OutputIterator partial_sum(InputIterator first, InputIterator last,\n-                           OutputIterator result) {\n-  if (first == last) return result;\n-  *result = *first;\n-  return __partial_sum(first, last, result, value_type(first));\n-}\n-\n-template <class InputIterator, class OutputIterator, class T,\n-          class BinaryOperation>\n-OutputIterator __partial_sum(InputIterator first, InputIterator last,\n-                             OutputIterator result, T*,\n-                             BinaryOperation binary_op) {\n-  T value = *first;\n-  while (++first != last) {\n-    value = binary_op(value, *first);\n-    *++result = value;\n+  return ++__result;\n+}\n+\n+template <class _InputIterator, class _OutputIterator>\n+_OutputIterator \n+partial_sum(_InputIterator __first, _InputIterator __last,\n+            _OutputIterator __result)\n+{\n+  if (__first == __last) return __result;\n+  *__result = *__first;\n+  return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first));\n+}\n+\n+template <class _InputIterator, class _OutputIterator, class _Tp,\n+          class _BinaryOperation>\n+_OutputIterator \n+__partial_sum(_InputIterator __first, _InputIterator __last, \n+              _OutputIterator __result, _Tp*, _BinaryOperation __binary_op)\n+{\n+  _Tp __value = *__first;\n+  while (++__first != __last) {\n+    __value = __binary_op(__value, *__first);\n+    *++__result = __value;\n   }\n-  return ++result;\n+  return ++__result;\n }\n \n-template <class InputIterator, class OutputIterator, class BinaryOperation>\n-OutputIterator partial_sum(InputIterator first, InputIterator last,\n-                           OutputIterator result, BinaryOperation binary_op) {\n-  if (first == last) return result;\n-  *result = *first;\n-  return __partial_sum(first, last, result, value_type(first), binary_op);\n+template <class _InputIterator, class _OutputIterator, class _BinaryOperation>\n+_OutputIterator \n+partial_sum(_InputIterator __first, _InputIterator __last,\n+            _OutputIterator __result, _BinaryOperation __binary_op)\n+{\n+  if (__first == __last) return __result;\n+  *__result = *__first;\n+  return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first), \n+                       __binary_op);\n }\n \n-template <class InputIterator, class OutputIterator, class T>\n-OutputIterator __adjacent_difference(InputIterator first, InputIterator last, \n-                                     OutputIterator result, T*) {\n-  T value = *first;\n-  while (++first != last) {\n-    T tmp = *first;\n-    *++result = tmp - value;\n-    value = tmp;\n+template <class _InputIterator, class _OutputIterator, class _Tp>\n+_OutputIterator \n+__adjacent_difference(_InputIterator __first, _InputIterator __last,\n+                      _OutputIterator __result, _Tp*)\n+{\n+  _Tp __value = *__first;\n+  while (++__first != __last) {\n+    _Tp __tmp = *__first;\n+    *++__result = __tmp - __value;\n+    __value = __tmp;\n   }\n-  return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-OutputIterator adjacent_difference(InputIterator first, InputIterator last, \n-                                   OutputIterator result) {\n-  if (first == last) return result;\n-  *result = *first;\n-  return __adjacent_difference(first, last, result, value_type(first));\n-}\n-\n-template <class InputIterator, class OutputIterator, class T, \n-          class BinaryOperation>\n-OutputIterator __adjacent_difference(InputIterator first, InputIterator last, \n-                                     OutputIterator result, T*,\n-                                     BinaryOperation binary_op) {\n-  T value = *first;\n-  while (++first != last) {\n-    T tmp = *first;\n-    *++result = binary_op(tmp, value);\n-    value = tmp;\n+  return ++__result;\n+}\n+\n+template <class _InputIterator, class _OutputIterator>\n+_OutputIterator\n+adjacent_difference(_InputIterator __first,\n+                    _InputIterator __last, _OutputIterator __result)\n+{\n+  if (__first == __last) return __result;\n+  *__result = *__first;\n+  return __adjacent_difference(__first, __last, __result,\n+                               __VALUE_TYPE(__first));\n+}\n+\n+template <class _InputIterator, class _OutputIterator, class _Tp, \n+          class _BinaryOperation>\n+_OutputIterator\n+__adjacent_difference(_InputIterator __first, _InputIterator __last, \n+                      _OutputIterator __result, _Tp*,\n+                      _BinaryOperation __binary_op) {\n+  _Tp __value = *__first;\n+  while (++__first != __last) {\n+    _Tp __tmp = *__first;\n+    *++__result = __binary_op(__tmp, __value);\n+    __value = __tmp;\n   }\n-  return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator, class BinaryOperation>\n-OutputIterator adjacent_difference(InputIterator first, InputIterator last,\n-                                   OutputIterator result,\n-                                   BinaryOperation binary_op) {\n-  if (first == last) return result;\n-  *result = *first;\n-  return __adjacent_difference(first, last, result, value_type(first),\n-                               binary_op);\n-}\n-\n-// Returns x ** n, where n >= 0.  Note that \"multiplication\"\n-//  is required to be associative, but not necessarily commutative.\n-    \n-template <class T, class Integer, class MonoidOperation>\n-T power(T x, Integer n, MonoidOperation op) {\n-  if (n == 0)\n-    return identity_element(op);\n+  return ++__result;\n+}\n+\n+template <class _InputIterator, class _OutputIterator, class _BinaryOperation>\n+_OutputIterator \n+adjacent_difference(_InputIterator __first, _InputIterator __last,\n+                    _OutputIterator __result, _BinaryOperation __binary_op)\n+{\n+  if (__first == __last) return __result;\n+  *__result = *__first;\n+  return __adjacent_difference(__first, __last, __result,\n+                               __VALUE_TYPE(__first),\n+                               __binary_op);\n+}\n+\n+// Returns __x ** __n, where __n >= 0.  _Note that \"multiplication\"\n+// is required to be associative, but not necessarily commutative.\n+\n+ \n+template <class _Tp, class _Integer, class _MonoidOperation>\n+_Tp __power(_Tp __x, _Integer __n, _MonoidOperation __opr)\n+{\n+  if (__n == 0)\n+    return identity_element(__opr);\n   else {\n-    while ((n & 1) == 0) {\n-      n >>= 1;\n-      x = op(x, x);\n+    while ((__n & 1) == 0) {\n+      __n >>= 1;\n+      __x = __opr(__x, __x);\n     }\n \n-    T result = x;\n-    n >>= 1;\n-    while (n != 0) {\n-      x = op(x, x);\n-      if ((n & 1) != 0)\n-        result = op(result, x);\n-      n >>= 1;\n+    _Tp __result = __x;\n+    __n >>= 1;\n+    while (__n != 0) {\n+      __x = __opr(__x, __x);\n+      if ((__n & 1) != 0)\n+        __result = __opr(__result, __x);\n+      __n >>= 1;\n     }\n-    return result;\n+    return __result;\n   }\n }\n \n-template <class T, class Integer>\n-inline T power(T x, Integer n) {\n-  return power(x, n, multiplies<T>());\n+template <class _Tp, class _Integer>\n+inline _Tp __power(_Tp __x, _Integer __n)\n+{\n+  return __power(__x, __n, multiplies<_Tp>());\n+}\n+\n+// Alias for the internal name __power.  Note that power is an extension,\n+// not part of the C++ standard.\n+\n+template <class _Tp, class _Integer, class _MonoidOperation>\n+inline _Tp power(_Tp __x, _Integer __n, _MonoidOperation __opr)\n+{\n+  return __power(__x, __n, __opr);\n+}\n+\n+template <class _Tp, class _Integer>\n+inline _Tp power(_Tp __x, _Integer __n)\n+{\n+  return __power(__x, __n);\n }\n \n+// iota is not part of the C++ standard.  It is an extension.\n \n-template <class ForwardIterator, class T>\n-void iota(ForwardIterator first, ForwardIterator last, T value) {\n-  while (first != last) *first++ = value++;\n+template <class _ForwardIterator, class _Tp>\n+void \n+iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)\n+{\n+  while (__first != __last)\n+    *__first++ = __value++;\n }\n \n __STL_END_NAMESPACE"}, {"sha": "3aa290b59edb4f20ccd3c42ff12189c267aa6cd2", "filename": "libstdc++/stl/stl_pair.h", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_pair.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -33,35 +33,39 @@\n \n __STL_BEGIN_NAMESPACE\n \n-template <class T1, class T2>\n+template <class _T1, class _T2>\n struct pair {\n-  typedef T1 first_type;\n-  typedef T2 second_type;\n+  typedef _T1 first_type;\n+  typedef _T2 second_type;\n \n-  T1 first;\n-  T2 second;\n-  pair() : first(T1()), second(T2()) {}\n-  pair(const T1& a, const T2& b) : first(a), second(b) {}\n+  _T1 first;\n+  _T2 second;\n+  pair() : first(_T1()), second(_T2()) {}\n+  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class U1, class U2>\n-  pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}\n+  template <class _U1, class _U2>\n+  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}\n #endif\n };\n \n-template <class T1, class T2>\n-inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { \n-  return x.first == y.first && x.second == y.second; \n+template <class _T1, class _T2>\n+inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+{ \n+  return __x.first == __y.first && __x.second == __y.second; \n }\n \n-template <class T1, class T2>\n-inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { \n-  return x.first < y.first || (!(y.first < x.first) && x.second < y.second); \n+template <class _T1, class _T2>\n+inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+{ \n+  return __x.first < __y.first || \n+         (!(__y.first < __x.first) && __x.second < __y.second); \n }\n \n-template <class T1, class T2>\n-inline pair<T1, T2> make_pair(const T1& x, const T2& y) {\n-  return pair<T1, T2>(x, y);\n+template <class _T1, class _T2>\n+inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)\n+{\n+  return pair<_T1, _T2>(__x, __y);\n }\n \n __STL_END_NAMESPACE"}, {"sha": "489cc4ac442e87c3883c5ebb4b8c5c1d789d966c", "filename": "libstdc++/stl/stl_queue.h", "status": "modified", "additions": 123, "deletions": 55, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_queue.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -34,92 +34,160 @@\n __STL_BEGIN_NAMESPACE\n \n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class T, class Sequence = deque<T> >\n+template <class _Tp, class _Sequence = deque<_Tp> >\n #else\n-template <class T, class Sequence>\n+template <class _Tp, class _Sequence>\n #endif\n class queue {\n-  friend bool operator== __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);\n-  friend bool operator< __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);\n+  friend bool operator== __STL_NULL_TMPL_ARGS (const queue&, const queue&);\n+  friend bool operator< __STL_NULL_TMPL_ARGS (const queue&, const queue&);\n public:\n-  typedef typename Sequence::value_type value_type;\n-  typedef typename Sequence::size_type size_type;\n-  typedef typename Sequence::reference reference;\n-  typedef typename Sequence::const_reference const_reference;\n+  typedef typename _Sequence::value_type      value_type;\n+  typedef typename _Sequence::size_type       size_type;\n+  typedef          _Sequence                  container_type;\n+\n+  typedef typename _Sequence::reference       reference;\n+  typedef typename _Sequence::const_reference const_reference;\n protected:\n-  Sequence c;\n+  _Sequence _M_c;\n public:\n-  bool empty() const { return c.empty(); }\n-  size_type size() const { return c.size(); }\n-  reference front() { return c.front(); }\n-  const_reference front() const { return c.front(); }\n-  reference back() { return c.back(); }\n-  const_reference back() const { return c.back(); }\n-  void push(const value_type& x) { c.push_back(x); }\n-  void pop() { c.pop_front(); }\n+  queue() : _M_c() {}\n+  explicit queue(const _Sequence& __c) : _M_c(__c) {}\n+\n+  bool empty() const { return _M_c.empty(); }\n+  size_type size() const { return _M_c.size(); }\n+  reference front() { return _M_c.front(); }\n+  const_reference front() const { return _M_c.front(); }\n+  reference back() { return _M_c.back(); }\n+  const_reference back() const { return _M_c.back(); }\n+  void push(const value_type& __x) { _M_c.push_back(__x); }\n+  void pop() { _M_c.pop_front(); }\n };\n \n-template <class T, class Sequence>\n-bool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {\n-  return x.c == y.c;\n+template <class _Tp, class _Sequence>\n+bool \n+operator==(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+{\n+  return __x._M_c == __y._M_c;\n+}\n+\n+template <class _Tp, class _Sequence>\n+bool\n+operator<(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+{\n+  return __x._M_c < __y._M_c;\n+}\n+\n+#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+\n+template <class _Tp, class _Sequence>\n+bool\n+operator!=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+{\n+  return !(__x == __y);\n }\n \n-template <class T, class Sequence>\n-bool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {\n-  return x.c < y.c;\n+template <class _Tp, class _Sequence>\n+bool \n+operator>(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+{\n+  return __y < __x;\n }\n \n+template <class _Tp, class _Sequence>\n+bool \n+operator<=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+{\n+  return !(__y < __x);\n+}\n+\n+template <class _Tp, class _Sequence>\n+bool \n+operator>=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+{\n+  return !(__x < __y);\n+}\n+\n+#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+\n #ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class T, class Sequence = vector<T>, \n-          class Compare = less<typename Sequence::value_type> >\n+template <class _Tp, class _Sequence = vector<_Tp>, \n+          class _Compare = less<typename _Sequence::value_type> >\n #else\n-template <class T, class Sequence, class Compare>\n+template <class _Tp, class _Sequence, class _Compare>\n #endif\n class  priority_queue {\n public:\n-  typedef typename Sequence::value_type value_type;\n-  typedef typename Sequence::size_type size_type;\n-  typedef typename Sequence::reference reference;\n-  typedef typename Sequence::const_reference const_reference;\n+  typedef typename _Sequence::value_type      value_type;\n+  typedef typename _Sequence::size_type       size_type;\n+  typedef          _Sequence                  container_type;\n+\n+  typedef typename _Sequence::reference       reference;\n+  typedef typename _Sequence::const_reference const_reference;\n protected:\n-  Sequence c;\n-  Compare comp;\n+  _Sequence _M_c;\n+  _Compare _M_comp;\n public:\n-  priority_queue() : c() {}\n-  explicit priority_queue(const Compare& x) :  c(), comp(x) {}\n+  priority_queue() : _M_c() {}\n+  explicit priority_queue(const _Compare& __x) :  _M_c(), _M_comp(__x) {}\n+  priority_queue(const _Compare& __x, const _Sequence& __s) \n+    : _M_c(__s), _M_comp(__x) \n+    { make_heap(_M_c.begin(), _M_c.end(), _M_comp); }\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  priority_queue(InputIterator first, InputIterator last, const Compare& x)\n-    : c(first, last), comp(x) { make_heap(c.begin(), c.end(), comp); }\n-  template <class InputIterator>\n-  priority_queue(InputIterator first, InputIterator last) \n-    : c(first, last) { make_heap(c.begin(), c.end(), comp); }\n+  template <class _InputIterator>\n+  priority_queue(_InputIterator __first, _InputIterator __last) \n+    : _M_c(__first, __last) { make_heap(_M_c.begin(), _M_c.end(), _M_comp); }\n+\n+  template <class _InputIterator>\n+  priority_queue(_InputIterator __first, \n+                 _InputIterator __last, const _Compare& __x)\n+    : _M_c(__first, __last), _M_comp(__x) \n+    { make_heap(_M_c.begin(), _M_c.end(), _M_comp); }\n+\n+  template <class _InputIterator>\n+  priority_queue(_InputIterator __first, _InputIterator __last,\n+                 const _Compare& __x, const _Sequence& __s)\n+  : _M_c(__s), _M_comp(__x)\n+  { \n+    _M_c.insert(_M_c.end(), __first, __last);\n+    make_heap(_M_c.begin(), _M_c.end(), _M_comp);\n+  }\n+\n #else /* __STL_MEMBER_TEMPLATES */\n-  priority_queue(const value_type* first, const value_type* last, \n-                 const Compare& x) : c(first, last), comp(x) {\n-    make_heap(c.begin(), c.end(), comp);\n+  priority_queue(const value_type* __first, const value_type* __last) \n+    : _M_c(__first, __last) { make_heap(_M_c.begin(), _M_c.end(), _M_comp); }\n+\n+  priority_queue(const value_type* __first, const value_type* __last, \n+                 const _Compare& __x) \n+    : _M_c(__first, __last), _M_comp(__x)\n+    { make_heap(_M_c.begin(), _M_c.end(), _M_comp); }\n+\n+  priority_queue(const value_type* __first, const value_type* __last, \n+                 const _Compare& __x, const _Sequence& __c)\n+    : _M_c(__c), _M_comp(__x) \n+  { \n+    _M_c.insert(_M_c.end(), __first, __last);\n+    make_heap(_M_c.begin(), _M_c.end(), _M_comp);\n   }\n-  priority_queue(const value_type* first, const value_type* last) \n-    : c(first, last) { make_heap(c.begin(), c.end(), comp); }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  bool empty() const { return c.empty(); }\n-  size_type size() const { return c.size(); }\n-  const_reference top() const { return c.front(); }\n-  void push(const value_type& x) {\n+  bool empty() const { return _M_c.empty(); }\n+  size_type size() const { return _M_c.size(); }\n+  const_reference top() const { return _M_c.front(); }\n+  void push(const value_type& __x) {\n     __STL_TRY {\n-      c.push_back(x); \n-      push_heap(c.begin(), c.end(), comp);\n+      _M_c.push_back(__x); \n+      push_heap(_M_c.begin(), _M_c.end(), _M_comp);\n     }\n-    __STL_UNWIND(c.clear());\n+    __STL_UNWIND(_M_c.clear());\n   }\n   void pop() {\n     __STL_TRY {\n-      pop_heap(c.begin(), c.end(), comp);\n-      c.pop_back();\n+      pop_heap(_M_c.begin(), _M_c.end(), _M_comp);\n+      _M_c.pop_back();\n     }\n-    __STL_UNWIND(c.clear());\n+    __STL_UNWIND(_M_c.clear());\n   }\n };\n "}, {"sha": "6f3951cb8af83b43443c3804484e6755415c8c76", "filename": "libstdc++/stl/stl_raw_storage_iter.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_raw_storage_iter.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -25,57 +25,57 @@\n  */\n \n /* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n+ * You should not attempt to use it directly.\n  */\n \n #ifndef __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H\n #define __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H\n \n __STL_BEGIN_NAMESPACE\n \n-template <class ForwardIterator, class T>\n+template <class _ForwardIterator, class _Tp>\n class raw_storage_iterator {\n protected:\n-  ForwardIterator iter;\n+  _ForwardIterator _M_iter;\n public:\n   typedef output_iterator_tag iterator_category;\n   typedef void                value_type;\n   typedef void                difference_type;\n   typedef void                pointer;\n   typedef void                reference;\n \n-  explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}\n-  raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }\n-  raw_storage_iterator<ForwardIterator, T>& operator=(const T& element) {\n-    construct(&*iter, element);\n+  explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}\n+  raw_storage_iterator& operator*() { return *this; }\n+  raw_storage_iterator& operator=(const _Tp& __element) {\n+    construct(&*_M_iter, __element);\n     return *this;\n   }        \n-  raw_storage_iterator<ForwardIterator, T>& operator++() {\n-    ++iter;\n+  raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {\n+    ++_M_iter;\n     return *this;\n   }\n-  raw_storage_iterator<ForwardIterator, T> operator++(int) {\n-    raw_storage_iterator<ForwardIterator, T> tmp = *this;\n-    ++iter;\n-    return tmp;\n+  raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {\n+    raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;\n+    ++_M_iter;\n+    return __tmp;\n   }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class ForwardIterator, class T>\n+template <class _ForwardIterator, class _Tp>\n inline output_iterator_tag\n-iterator_category(const raw_storage_iterator<ForwardIterator, T>&)\n+iterator_category(const raw_storage_iterator<_ForwardIterator, _Tp>&)\n {\n   return output_iterator_tag();\n }\n \n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-#endif /* __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H */\n-\n __STL_END_NAMESPACE\n \n+#endif /* __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H */\n+\n // Local Variables:\n // mode:C++\n // End:"}, {"sha": "16cad1b84e20feed343226f3c00e5b028ba462d1", "filename": "libstdc++/stl/stl_relops.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_relops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_relops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_relops.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1", "patch": "@@ -33,24 +33,24 @@\n \n __STL_BEGIN_RELOPS_NAMESPACE\n \n-template <class T>\n-inline bool operator!=(const T& x, const T& y) {\n-  return !(x == y);\n+template <class _Tp>\n+inline bool operator!=(const _Tp& __x, const _Tp& __y) {\n+  return !(__x == __y);\n }\n \n-template <class T>\n-inline bool operator>(const T& x, const T& y) {\n-  return y < x;\n+template <class _Tp>\n+inline bool operator>(const _Tp& __x, const _Tp& __y) {\n+  return __y < __x;\n }\n \n-template <class T>\n-inline bool operator<=(const T& x, const T& y) {\n-  return !(y < x);\n+template <class _Tp>\n+inline bool operator<=(const _Tp& __x, const _Tp& __y) {\n+  return !(__y < __x);\n }\n \n-template <class T>\n-inline bool operator>=(const T& x, const T& y) {\n-  return !(x < y);\n+template <class _Tp>\n+inline bool operator>=(const _Tp& __x, const _Tp& __y) {\n+  return !(__x < __y);\n }\n \n __STL_END_RELOPS_NAMESPACE"}, {"sha": "44f51aed1ae588290b7a33c51ea2334e136427d2", "filename": "libstdc++/stl/stl_rope.h", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_rope.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "003069cb074bfd508049e69706f9e9cf9dbf9f4b", "filename": "libstdc++/stl/stl_set.h", "status": "modified", "additions": 111, "deletions": 93, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_set.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "6da234d92c2cadf5ac2c7732b5a3d7fb3527aa5f", "filename": "libstdc++/stl/stl_slist.h", "status": "modified", "additions": 641, "deletions": 436, "changes": 1077, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_slist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_slist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_slist.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "2a04b21e5070d3f1a9166b660eb25465cd821eb4", "filename": "libstdc++/stl/stl_stack.h", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_stack.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "e1b2eadafcbf930d9485c1943f00d77304fb30ef", "filename": "libstdc++/stl/stl_tempbuf.h", "status": "modified", "additions": 87, "deletions": 54, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_tempbuf.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "c82943f568abe90bbbf7e2d1ebf5af26ccaa4e96", "filename": "libstdc++/stl/stl_tree.h", "status": "modified", "additions": 924, "deletions": 690, "changes": 1614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_tree.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "3146c82a71c98801d21ecff36a528d1d8f262450", "filename": "libstdc++/stl/stl_uninitialized.h", "status": "modified", "additions": 166, "deletions": 129, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_uninitialized.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "d1149e9af66d4af01fc1043fad4165c964d3e6f8", "filename": "libstdc++/stl/stl_vector.h", "status": "modified", "additions": 636, "deletions": 347, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_vector.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "aa4f289c582bb879f3ac0febb666350f7fc2c20c", "filename": "libstdc++/stl/tempbuf.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Ftempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Ftempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ftempbuf.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}, {"sha": "b6a7dfc6de95f188e15a84d603f086bc1cca6024", "filename": "libstdc++/stl/type_traits.h", "status": "modified", "additions": 149, "deletions": 9, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df9262681b6bf7e555619c492c5ec9d7fd340ac1/libstdc%2B%2B%2Fstl%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ftype_traits.h?ref=df9262681b6bf7e555619c492c5ec9d7fd340ac1"}]}