{"sha": "1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZiMmIwZjY5ZWU4NDkxNDJiNjY5YmExYjgyMjY0Y2U2ZDBmNzVmOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-16T11:35:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-16T11:35:08Z"}, "message": "Move canonicalisation of dr_with_seg_len_pair_ts\n\nThe two users of tree-data-ref's runtime alias checks both canonicalise\nthe order of the dr_with_seg_lens in a pair before passing them to\nprune_runtime_alias_test_list.  It's more convenient for later patches\nif prune_runtime_alias_test_list does that itself.\n\n2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-data-ref.c (prune_runtime_alias_test_list): Sort the\n\ttwo accesses in each dr_with_seg_len_pair_t before trying to\n\tcombine separate dr_with_seg_len_pair_ts.\n\t* tree-loop-distribution.c (compute_alias_check_pairs): Don't do\n\tthat here.\n\t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list): Likewise.\n\nFrom-SVN: r278348", "tree": {"sha": "9ab378262a147835ac52a5a1213e24515fda2c5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ab378262a147835ac52a5a1213e24515fda2c5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37a3662f76d79a1d9ff02a31e5cc0f7e20dfbc60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a3662f76d79a1d9ff02a31e5cc0f7e20dfbc60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a3662f76d79a1d9ff02a31e5cc0f7e20dfbc60"}], "stats": {"total": 56, "additions": 33, "deletions": 23}, "files": [{"sha": "f75f3cb3a56b04003c25a1970c0fcfd665a3def1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "patch": "@@ -1,3 +1,12 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-data-ref.c (prune_runtime_alias_test_list): Sort the\n+\ttwo accesses in each dr_with_seg_len_pair_t before trying to\n+\tcombine separate dr_with_seg_len_pair_ts.\n+\t* tree-loop-distribution.c (compute_alias_check_pairs): Don't do\n+\tthat here.\n+\t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list): Likewise.\n+\n 2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-sve.md"}, {"sha": "b31ed4247dd948a05ee11cffda9fceb1d2b5c9bf", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "patch": "@@ -1486,13 +1486,32 @@ void\n prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t\t\t       poly_uint64)\n {\n+  /* Canonicalize each pair so that the base components are ordered wrt\n+     data_ref_compare_tree.  This allows the loop below to merge more\n+     cases.  */\n+  unsigned int i;\n+  dr_with_seg_len_pair_t *alias_pair;\n+  FOR_EACH_VEC_ELT (*alias_pairs, i, alias_pair)\n+    {\n+      data_reference_p dr_a = alias_pair->first.dr;\n+      data_reference_p dr_b = alias_pair->second.dr;\n+      int comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (dr_a),\n+\t\t\t\t\t    DR_BASE_ADDRESS (dr_b));\n+      if (comp_res == 0)\n+\tcomp_res = data_ref_compare_tree (DR_OFFSET (dr_a), DR_OFFSET (dr_b));\n+      if (comp_res == 0)\n+\tcomp_res = data_ref_compare_tree (DR_INIT (dr_a), DR_INIT (dr_b));\n+      if (comp_res > 0)\n+\tstd::swap (alias_pair->first, alias_pair->second);\n+    }\n+\n   /* Sort the collected data ref pairs so that we can scan them once to\n      combine all possible aliasing checks.  */\n   alias_pairs->qsort (comp_dr_with_seg_len_pair);\n \n   /* Scan the sorted dr pairs and check if we can combine alias checks\n      of two neighboring dr pairs.  */\n-  for (size_t i = 1; i < alias_pairs->length (); ++i)\n+  for (i = 1; i < alias_pairs->length (); ++i)\n     {\n       /* Deal with two ddrs (dr_a1, dr_b1) and (dr_a2, dr_b2).  */\n       dr_with_seg_len *dr_a1 = &(*alias_pairs)[i-1].first,"}, {"sha": "29f8eab59a9e68fb364b03a2d1c9a5cdfd279690", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "patch": "@@ -2456,12 +2456,6 @@ compute_alias_check_pairs (class loop *loop, vec<ddr_p> *alias_ddrs,\n       struct data_reference *dr_a = DDR_A (ddr);\n       struct data_reference *dr_b = DDR_B (ddr);\n       tree seg_length_a, seg_length_b;\n-      int comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (dr_a),\n-\t\t\t\t\t    DR_BASE_ADDRESS (dr_b));\n-\n-      if (comp_res == 0)\n-\tcomp_res = data_ref_compare_tree (DR_OFFSET (dr_a), DR_OFFSET (dr_b));\n-      gcc_assert (comp_res != 0);\n \n       if (latch_dominated_by_data_ref (loop, dr_a))\n \tseg_length_a = data_ref_segment_size (dr_a, niters_plus_one);\n@@ -2484,10 +2478,6 @@ compute_alias_check_pairs (class loop *loop, vec<ddr_p> *alias_ddrs,\n \t(dr_with_seg_len (dr_a, seg_length_a, access_size_a, align_a),\n \t dr_with_seg_len (dr_b, seg_length_b, access_size_b, align_b));\n \n-      /* Canonicalize pairs by sorting the two DR members.  */\n-      if (comp_res > 0)\n-\tstd::swap (dr_with_seg_len_pair.first, dr_with_seg_len_pair.second);\n-\n       comp_alias_pairs->safe_push (dr_with_seg_len_pair);\n     }\n "}, {"sha": "c4d627acb2e5ce1c838e52d4ba111d0466f0979d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb2b0f69ee849142b669ba1b82264ce6d0f75f9/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=1fb2b0f69ee849142b669ba1b82264ce6d0f75f9", "patch": "@@ -3477,7 +3477,6 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   /* First, we collect all data ref pairs for aliasing checks.  */\n   FOR_EACH_VEC_ELT (may_alias_ddrs, i, ddr)\n     {\n-      int comp_res;\n       poly_uint64 lower_bound;\n       tree segment_length_a, segment_length_b;\n       unsigned HOST_WIDE_INT access_size_a, access_size_b;\n@@ -3593,14 +3592,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       align_a = vect_vfa_align (dr_info_a);\n       align_b = vect_vfa_align (dr_info_b);\n \n-      comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (dr_info_a->dr),\n-\t\t\t\t\tDR_BASE_ADDRESS (dr_info_b->dr));\n-      if (comp_res == 0)\n-\tcomp_res = data_ref_compare_tree (DR_OFFSET (dr_info_a->dr),\n-\t\t\t\t\t  DR_OFFSET (dr_info_b->dr));\n-\n       /* See whether the alias is known at compilation time.  */\n-      if (comp_res == 0\n+      if (operand_equal_p (DR_BASE_ADDRESS (dr_info_a->dr),\n+\t\t\t   DR_BASE_ADDRESS (dr_info_b->dr), 0)\n+\t  && operand_equal_p (DR_OFFSET (dr_info_a->dr),\n+\t\t\t      DR_OFFSET (dr_info_b->dr), 0)\n \t  && TREE_CODE (DR_STEP (dr_info_a->dr)) == INTEGER_CST\n \t  && TREE_CODE (DR_STEP (dr_info_b->dr)) == INTEGER_CST\n \t  && poly_int_tree_p (segment_length_a)\n@@ -3639,10 +3635,6 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t dr_with_seg_len (dr_info_b->dr, segment_length_b,\n \t\t\t  access_size_b, align_b));\n \n-      /* Canonicalize pairs by sorting the two DR members.  */\n-      if (comp_res > 0)\n-\tstd::swap (dr_with_seg_len_pair.first, dr_with_seg_len_pair.second);\n-\n       comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n     }\n "}]}