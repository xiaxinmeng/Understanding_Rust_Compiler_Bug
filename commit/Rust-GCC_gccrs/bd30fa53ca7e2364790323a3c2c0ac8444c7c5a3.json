{"sha": "bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQzMGZhNTNjYTdlMjM2NDc5MDMyM2EzYzJjMGFjODQ0NGM3YzVhMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-08-19T22:58:27Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-08-19T22:58:27Z"}, "message": "natThread.cc (class locker): New class.\n\n\t* java/lang/natThread.cc (class locker): New class.\n\t(join): Use a locker around _Jv_CondWait.\n\t(sleep): Likewise.\n\nFrom-SVN: r28770", "tree": {"sha": "c87396f3692c3e01367298321b55286fd66d16db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c87396f3692c3e01367298321b55286fd66d16db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3/comments", "author": null, "committer": null, "parents": [{"sha": "8f985ec4c7de63e524197f1728a2c056f9af6554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f985ec4c7de63e524197f1728a2c056f9af6554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f985ec4c7de63e524197f1728a2c056f9af6554"}], "stats": {"total": 44, "additions": 37, "deletions": 7}, "files": [{"sha": "d307525e17340c9e81823dbb6e62f675e598d930", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3", "patch": "@@ -1,3 +1,9 @@\n+1999-08-19  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/lang/natThread.cc (class locker): New class.\n+\t(join): Use a locker around _Jv_CondWait.\n+\t(sleep): Likewise.\n+\n 1999-08-18  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/lang/ThreadGroup.java: Fixed now-erroneous comment."}, {"sha": "50db5642beff85b4986b8f1df5fb9b1e82d1c4f0", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=bd30fa53ca7e2364790323a3c2c0ac8444c7c5a3", "patch": "@@ -49,6 +49,26 @@ struct natThread\n   struct natThread *next;\n };\n \n+// We use this for its side effects: it lets us lock a mutex directly\n+// and not lose if an exception is thrown.\n+class locker\n+{\n+private:\n+  _Jv_Mutex_t *mutex;\n+\n+public:\n+  locker (_Jv_Mutex_t *m)\n+    : mutex (m)\n+  {\n+    _Jv_MutexLock (mutex);\n+  }\n+\n+  ~locker ()\n+  {\n+    _Jv_MutexUnlock (mutex);\n+  }\n+};\n+\n // This is called from the constructor to initialize the native side\n // of the Thread.\n void\n@@ -153,12 +173,14 @@ java::lang::Thread::join (jlong millis, jint nanos)\n \n \n   // Now wait for: (1) an interrupt, (2) the thread to exit, or (3)\n-  // the timeout to occur.\n-  _Jv_MutexLock (&curr_nt->interrupt_mutex);\n-  _Jv_CondWait (&curr_nt->interrupt_cond,\n+  // the timeout to occur.  Use a `locker' object because _Jv_CondWait\n+  // can throw an exception.\n+  {\n+    locker l (&curr_nt->interrupt_mutex);\n+    _Jv_CondWait (&curr_nt->interrupt_cond,\n \t\t  &curr_nt->interrupt_mutex,\n \t\t  millis, nanos);\n-  _Jv_MutexUnlock (&curr_nt->interrupt_mutex);\n+  }\n \n   // Now the join has completed, one way or another.  Update the\n   // joiners list to account for this.\n@@ -224,10 +246,12 @@ java::lang::Thread::sleep (jlong millis, jint nanos)\n   // We use a condition variable to implement sleeping so that an\n   // interrupt can wake us up.\n   natThread *nt = (natThread *) current->data;\n-  _Jv_MutexLock (&nt->interrupt_mutex);\n-  _Jv_CondWait (&nt->interrupt_cond, &nt->interrupt_mutex,\n+  {\n+    // Use a locker because _Jv_CondWait can throw an exception.\n+    locker l (&nt->interrupt_mutex);\n+    _Jv_CondWait (&nt->interrupt_cond, &nt->interrupt_mutex,\n \t\t  millis, nanos);\n-  _Jv_MutexUnlock (&nt->interrupt_mutex);\n+  }\n \n   if (current->isInterrupted ())\n     _Jv_Throw (new InterruptedException);"}]}