{"sha": "98af4c9ffeba9ea5549c06aa91e074a258cdd493", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThhZjRjOWZmZWJhOWVhNTU0OWMwNmFhOTFlMDc0YTI1OGNkZDQ5Mw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-09-30T21:20:45Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-09-30T21:20:45Z"}, "message": "New pass: loop flattening.\n\n2010-09-09  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* Makefile.in (OBJS-common): Add graphite-flattening.o.\n\t(graphite-flattening.o): New rule.\n\t* common.opt (floop-flatten): New flag.\n\t* doc/invoke.texi (-floop-flatten): Documented.\n\t* graphite-flattening.c: New.\n\t* graphite-poly.c (apply_poly_transforms): Call flatten_all_loops.\n\t* graphite-poly.h (flatten_all_loops): Declared.\n\t(lst_remove_loop_and_inline_stmts_in_loop_father): New.\n\t* tree-ssa-loop.c (gate_graphite_transforms): When flag_loop_flatten\n\tis set, also set flag_graphite.\n\nFrom-SVN: r164804", "tree": {"sha": "77b4af2c50159c96052312846c33a591f9c1a01a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77b4af2c50159c96052312846c33a591f9c1a01a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98af4c9ffeba9ea5549c06aa91e074a258cdd493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98af4c9ffeba9ea5549c06aa91e074a258cdd493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98af4c9ffeba9ea5549c06aa91e074a258cdd493", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98af4c9ffeba9ea5549c06aa91e074a258cdd493/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c498b9b99772f4f810ff2d6cf61c6b8bf194b095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c498b9b99772f4f810ff2d6cf61c6b8bf194b095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c498b9b99772f4f810ff2d6cf61c6b8bf194b095"}], "stats": {"total": 532, "additions": 525, "deletions": 7}, "files": [{"sha": "e0268cf66c6ab323d094185b2ecad927a7e911ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -1,3 +1,16 @@\n+2010-09-30  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* Makefile.in (OBJS-common): Add graphite-flattening.o.\n+\t(graphite-flattening.o): New rule.\n+\t* common.opt (floop-flatten): New flag.\n+\t* doc/invoke.texi (-floop-flatten): Documented.\n+\t* graphite-flattening.c: New.\n+\t* graphite-poly.c (apply_poly_transforms): Call flatten_all_loops.\n+\t* graphite-poly.h (flatten_all_loops): Declared.\n+\t(lst_remove_loop_and_inline_stmts_in_loop_father): New.\n+\t* tree-ssa-loop.c (gate_graphite_transforms): When flag_loop_flatten\n+\tis set, also set flag_graphite.\n+\n 2010-09-30  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-poly.c (cloog_checksum): New."}, {"sha": "7e0e88712695aefc0406a7df79420e89d5c44b81", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -1,3 +1,16 @@\n+2010-09-09  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* Makefile.in (OBJS-common): Add graphite-flattening.o.\n+\t(graphite-flattening.o): New rule.\n+\t* common.opt (floop-flatten): New flag.\n+\t* doc/invoke.texi (-floop-flatten): Documented.\n+\t* graphite-flattening.c: New.\n+\t* graphite-poly.c (apply_poly_transforms): Call flatten_all_loops.\n+\t* graphite-poly.h (flatten_all_loops): Declared.\n+\t(lst_remove_loop_and_inline_stmts_in_loop_father): New.\n+\t* tree-ssa-loop.c (gate_graphite_transforms): When flag_loop_flatten\n+\tis set, also set flag_graphite.\n+\n 2010-09-09  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-poly.c (cloog_checksum): New."}, {"sha": "a4029763f6689468f93bafb535b16d41a1d4c23b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -1244,6 +1244,7 @@ OBJS-common = \\\n \tgraphite-clast-to-gimple.o \\\n \tgraphite-cloog-util.o \\\n \tgraphite-dependences.o \\\n+\tgraphite-flattening.o \\\n \tgraphite-interchange.o \\\n \tgraphite-poly.o \\\n \tgraphite-ppl.o \\\n@@ -2695,6 +2696,12 @@ graphite-dependences.o: graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h domwalk.h \\\n    graphite.h graphite-poly.h graphite-ppl.h graphite-dependences.h\n+graphite-flattening.o: graphite-flattening.c $(CONFIG_H) $(SYSTEM_H)\t\\\n+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) output.h\t\t\\\n+   $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) $(TREE_FLOW_H)\t\t\\\n+   $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H)\t\t\t\\\n+   $(TREE_DATA_REF_H) tree-pass.h domwalk.h value-prof.h graphite.h\t\\\n+   graphite-poly.h graphite-ppl.h\n graphite-interchange.o: graphite-interchange.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) output.h $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\"}, {"sha": "938b76e0c15b9e98de4b81a80c1e2356a7be54c6", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -870,6 +870,10 @@ floop-block\n Common Report Var(flag_loop_block) Optimization\n Enable Loop Blocking transformation\n \n+floop-flatten\n+Common Report Var(flag_loop_flatten) Optimization\n+Enable Loop Flattening transformation\n+\n fstrict-volatile-bitfields\n Common Report Var(flag_strict_volatile_bitfields) Init(-1)\n Force bitfield accesses to match their type width"}, {"sha": "df39e1679389598547df7c7f22d09cdd234abdb9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -352,7 +352,7 @@ Objective-C and Objective-C++ Dialects}.\n -fira-loop-pressure -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n--floop-block -floop-interchange -floop-strip-mine @gol\n+-floop-block -floop-flatten -floop-interchange -floop-strip-mine @gol\n -floop-parallelize-all -flto -flto-compression-level -flto-report @gol\n -fltrans -fltrans-output-list -fmerge-all-constants -fmerge-constants @gol\n -fmodulo-sched -fmodulo-sched-allow-regmoves -fmove-loop-invariants @gol\n@@ -6798,6 +6798,7 @@ Perform linear loop transformations on tree.  This flag can improve cache\n performance and allow further loop optimizations to take place.\n \n @item -floop-interchange\n+@opindex floop-interchange\n Perform loop interchange transformations on loops.  Interchanging two\n nested loops switches the inner and outer loops.  For example, given a\n loop like:\n@@ -6826,6 +6827,7 @@ with @option{--with-ppl} and @option{--with-cloog} to enable the\n Graphite loop transformation infrastructure.\n \n @item -floop-strip-mine\n+@opindex floop-strip-mine\n Perform loop strip mining transformations on loops.  Strip mining\n splits a loop into two nested loops.  The outer loop has strides\n equal to the strip size and the inner loop has strides of the\n@@ -6851,6 +6853,7 @@ be configured with @option{--with-ppl} and @option{--with-cloog} to\n enable the Graphite loop transformation infrastructure.\n \n @item -floop-block\n+@opindex floop-block\n Perform loop blocking transformations on loops.  Blocking strip mines\n each loop in the loop nest such that the memory accesses of the\n element loops fit inside caches.  The strip length can be changed\n@@ -6892,7 +6895,14 @@ GIMPLE -> GRAPHITE -> GIMPLE transformation.  Some minimal optimizations\n are also performed by the code generator CLooG, like index splitting and\n dead code elimination in loops.\n \n+@item -floop-flatten\n+@opindex floop-flatten\n+Removes the loop nesting structure: transforms the loop nest into a\n+single loop.  This transformation can be useful to vectorize all the\n+levels of the loop nest.\n+\n @item -floop-parallelize-all\n+@opindex floop-parallelize-all\n Use the Graphite data dependence analysis to identify loops that can\n be parallelized.  Parallelize all the loops that can be analyzed to\n not contain loop carried dependences without checking that it is"}, {"sha": "0f9833710b0e81fad9046385d902074db1805d1d", "filename": "gcc/graphite-flattening.c", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fgraphite-flattening.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fgraphite-flattening.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-flattening.c?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -0,0 +1,442 @@\n+/* Loop flattening for Graphite.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"params.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"ppl_c.h\"\n+#include \"sese.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+\n+/* The loop flattening pass transforms loop nests into a single loop,\n+   removing the loop nesting structure.  The auto-vectorization can\n+   then apply on the full loop body, without needing the outer-loop\n+   vectorization.\n+\n+   The canonical example is as follows: suppose that we have a loop\n+   nest with known iteration counts\n+\n+   | for (i = 1; i <= 6; i++)\n+   |   for (j = 1; j <= 6; j++)\n+   |     S1(i,j);\n+\n+   The loop flattening is performed by linearizing the iteration space\n+   using the function \"f (x) = 6 * i + j\".  In this case, CLooG would\n+   produce this code:\n+\n+   | for (c1=7;c1<=42;c1++) {\n+   |   i = floord(c1-1,6);\n+   |   S1(i,c1-6*i);\n+   | }\n+\n+   There are several limitations for loop flattening that are linked\n+   to the expressivity of the polyhedral model.  One has to take an\n+   upper bound approximation to deal with the parametric case of loop\n+   flattening.  For example, in the loop nest:\n+\n+   | for (i = 1; i <= N; i++)\n+   |   for (j = 1; j <= M; j++)\n+   |     S1(i,j);\n+\n+   One would like to flatten this loop using a linearization function\n+   like this \"f (x) = M * i + j\".  However CLooG's schedules are not\n+   expressive enough to deal with this case, and so the parameter M\n+   has to be replaced by an integer upper bound approximation.  If we\n+   further know in the context of the scop that \"M <= 6\", then it is\n+   possible to linearize the loop with \"f (x) = 6 * i + j\".  In this\n+   case, CLooG would produce this code:\n+\n+   | for (c1=7;c1<=6*M+N;c1++) {\n+   |   i = ceild(c1-N,6);\n+   |   if (i <= floord(c1-1,6)) {\n+   |     S1(i,c1-6*i);\n+   |   }\n+   | }\n+\n+   For an arbitrarily complex loop nests the algorithm proceeds in two\n+   steps.  First, the LST is flattened by removing the loops structure\n+   and by inserting the statements in the order they appear in\n+   depth-first order.  Then, the scattering of each statement is\n+   transformed such that it\n+\n+   Supposing that the original program is represented by the following\n+   LST:\n+\n+   | (loop_1\n+   |  stmt_1\n+   |  (loop_2 stmt_3\n+   |   (loop_3 stmt_4)\n+   |   (loop_4 stmt_5 stmt_6)\n+   |   stmt_7\n+   |  )\n+   |  stmt_2\n+   | )\n+\n+   Loop flattening traverses the LST in depth-first order, and\n+   flattens pairs of loops successively by projecting the inner loops\n+   in the iteration domain of the outer loops:\n+\n+   lst_project_loop (loop_2, loop_3, stride)\n+\n+   | (loop_1\n+   |  stmt_1\n+   |  (loop_2 stmt_3 stmt_4\n+   |   (loop_4 stmt_5 stmt_6)\n+   |   stmt_7\n+   |  )\n+   |  stmt_2\n+   | )\n+\n+   lst_project_loop (loop_2, loop_4, stride)\n+\n+   | (loop_1\n+   |  stmt_1\n+   |  (loop_2 stmt_3 stmt_4 stmt_5 stmt_6 stmt_7)\n+   |  stmt_2\n+   | )\n+\n+   lst_project_loop (loop_1, loop_2, stride)\n+\n+   | (loop_1\n+   |  stmt_1 stmt_3 stmt_4 stmt_5 stmt_6 stmt_7 stmt_2\n+   | )\n+\n+   At each step, the iteration domain of the outer loop is enlarged to\n+   contain enough points to iterate over the inner loop domain.  */\n+\n+/* Initializes RES to the number of iterations of the linearized loop\n+   LST.  RES is the cardinal of the iteration domain of LST.  */\n+\n+static void\n+lst_linearized_niter (lst_p lst, mpz_t res)\n+{\n+  int i;\n+  lst_p l;\n+  mpz_t n;\n+\n+  mpz_init (n);\n+  mpz_set_si (res, 0);\n+\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n+    if (LST_LOOP_P (l))\n+      {\n+\tlst_linearized_niter (l, n);\n+\tmpz_add (res, res, n);\n+      }\n+\n+  if (LST_LOOP_P (lst))\n+    {\n+      lst_niter_for_loop (lst, n);\n+\n+      if (mpz_cmp_si (res, 0) != 0)\n+\tmpz_mul (res, res, n);\n+      else\n+\tmpz_set (res, n);\n+    }\n+\n+  mpz_clear (n);\n+}\n+\n+/* Applies the translation \"f (x) = x + OFFSET\" to the loop containing\n+   STMT.  */\n+\n+static void\n+lst_offset (lst_p stmt, mpz_t offset)\n+{\n+  lst_p inner = LST_LOOP_FATHER (stmt);\n+  poly_bb_p pbb = LST_PBB (stmt);\n+  ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n+  int inner_depth = lst_depth (inner);\n+  ppl_dimension_type inner_dim = psct_dynamic_dim (pbb, inner_depth);\n+  ppl_Linear_Expression_t expr;\n+  ppl_dimension_type dim;\n+  ppl_Coefficient_t one;\n+  mpz_t x;\n+\n+  mpz_init (x);\n+  mpz_set_si (x, 1);\n+  ppl_new_Coefficient (&one);\n+  ppl_assign_Coefficient_from_mpz_t (one, x);\n+\n+  ppl_Polyhedron_space_dimension (poly, &dim);\n+  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+\n+  ppl_set_coef (expr, inner_dim, 1);\n+  ppl_set_inhomogeneous_gmp (expr, offset);\n+  ppl_Polyhedron_affine_image (poly, inner_dim, expr, one);\n+  ppl_delete_Linear_Expression (expr);\n+  ppl_delete_Coefficient (one);\n+}\n+\n+/* Scale by FACTOR the loop LST containing STMT.  */\n+\n+static void\n+lst_scale (lst_p lst, lst_p stmt, mpz_t factor)\n+{\n+  mpz_t x;\n+  ppl_Coefficient_t one;\n+  int outer_depth = lst_depth (lst);\n+  poly_bb_p pbb = LST_PBB (stmt);\n+  ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n+  ppl_dimension_type outer_dim = psct_dynamic_dim (pbb, outer_depth);\n+  ppl_Linear_Expression_t expr;\n+  ppl_dimension_type dim;\n+\n+  mpz_init (x);\n+  mpz_set_si (x, 1);\n+  ppl_new_Coefficient (&one);\n+  ppl_assign_Coefficient_from_mpz_t (one, x);\n+\n+  ppl_Polyhedron_space_dimension (poly, &dim);\n+  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+\n+  /* outer_dim = factor * outer_dim.  */\n+  ppl_set_coef_gmp (expr, outer_dim, factor);\n+  ppl_Polyhedron_affine_image (poly, outer_dim, expr, one);\n+  ppl_delete_Linear_Expression (expr);\n+\n+  mpz_clear (x);\n+  ppl_delete_Coefficient (one);\n+}\n+\n+/* Project the INNER loop into the iteration domain of the OUTER loop.\n+   STRIDE is the number of iterations between two iterations of the\n+   outer loop.  */\n+\n+static void\n+lst_project_loop (lst_p outer, lst_p inner, mpz_t stride)\n+{\n+  int i;\n+  lst_p stmt;\n+  mpz_t x;\n+  ppl_Coefficient_t one;\n+  int outer_depth = lst_depth (outer);\n+  int inner_depth = lst_depth (inner);\n+\n+  mpz_init (x);\n+  mpz_set_si (x, 1);\n+  ppl_new_Coefficient (&one);\n+  ppl_assign_Coefficient_from_mpz_t (one, x);\n+\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (inner), i, stmt)\n+    {\n+      poly_bb_p pbb = LST_PBB (stmt);\n+      ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n+      ppl_dimension_type outer_dim = psct_dynamic_dim (pbb, outer_depth);\n+      ppl_dimension_type inner_dim = psct_dynamic_dim (pbb, inner_depth);\n+      ppl_Linear_Expression_t expr;\n+      ppl_dimension_type dim;\n+      ppl_dimension_type *ds;\n+\n+      /* There should be no loops under INNER.  */\n+      gcc_assert (!LST_LOOP_P (stmt));\n+      ppl_Polyhedron_space_dimension (poly, &dim);\n+      ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+\n+      /* outer_dim = outer_dim * stride + inner_dim.  */\n+      ppl_set_coef (expr, inner_dim, 1);\n+      ppl_set_coef_gmp (expr, outer_dim, stride);\n+      ppl_Polyhedron_affine_image (poly, outer_dim, expr, one);\n+      ppl_delete_Linear_Expression (expr);\n+\n+      /* Project on inner_dim.  */\n+      ppl_new_Linear_Expression_with_dimension (&expr, dim - 1);\n+      ppl_Polyhedron_affine_image (poly, inner_dim, expr, one);\n+      ppl_delete_Linear_Expression (expr);\n+\n+      /* Remove inner loop and the static schedule of its body.  */\n+      ds = XNEWVEC (ppl_dimension_type, 2);\n+      ds[0] = inner_dim;\n+      ds[1] = inner_dim + 1;\n+      ppl_Polyhedron_remove_space_dimensions (poly, ds, 2);\n+      PBB_NB_SCATTERING_TRANSFORM (pbb) -= 2;\n+      free (ds);\n+    }\n+\n+  mpz_clear (x);\n+  ppl_delete_Coefficient (one);\n+}\n+\n+/* Flattens the loop nest LST.  Return true when something changed.\n+   OFFSET is used to compute the number of iterations of the outermost\n+   loop before the current LST is executed.  */\n+\n+static bool\n+lst_flatten_loop (lst_p lst, mpz_t init_offset)\n+{\n+  int i;\n+  lst_p l;\n+  bool res = false;\n+  mpz_t n, one, offset, stride;\n+\n+  mpz_init (n);\n+  mpz_init (one);\n+  mpz_init (offset);\n+  mpz_init (stride);\n+  mpz_set (offset, init_offset);\n+  mpz_set_si (one, 1);\n+\n+  lst_linearized_niter (lst, stride);\n+  lst_niter_for_loop (lst, n);\n+  mpz_tdiv_q (stride, stride, n);\n+\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n+    if (LST_LOOP_P (l))\n+      {\n+\tres = true;\n+\n+\tlst_flatten_loop (l, offset);\n+\tlst_niter_for_loop (l, n);\n+\n+\tlst_project_loop (lst, l, stride);\n+\n+\t/* The offset is the number of iterations minus 1, as we want\n+\t   to execute the next statements at the same iteration as the\n+\t   last iteration of the loop.  */\n+\tmpz_sub (n, n, one);\n+\tmpz_add (offset, offset, n);\n+      }\n+    else\n+      {\n+\tlst_scale (lst, l, stride);\n+\tif (mpz_cmp_si (offset, 0) != 0)\n+\t  lst_offset (l, offset);\n+      }\n+\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n+    if (LST_LOOP_P (l))\n+      lst_remove_loop_and_inline_stmts_in_loop_father (l);\n+\n+  mpz_clear (n);\n+  mpz_clear (one);\n+  mpz_clear (offset);\n+  mpz_clear (stride);\n+  return res;\n+}\n+\n+/* Remove all but the first 3 dimensions of the scattering:\n+   - dim0: the static schedule for the loop\n+   - dim1: the dynamic schedule of the loop\n+   - dim2: the static schedule for the loop body.  */\n+\n+static void\n+remove_unused_scattering_dimensions (lst_p lst)\n+{\n+  int i;\n+  lst_p stmt;\n+  mpz_t x;\n+  ppl_Coefficient_t one;\n+\n+  mpz_init (x);\n+  mpz_set_si (x, 1);\n+  ppl_new_Coefficient (&one);\n+  ppl_assign_Coefficient_from_mpz_t (one, x);\n+\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, stmt)\n+    {\n+      poly_bb_p pbb = LST_PBB (stmt);\n+      ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n+      int j, nb_dims_to_remove = PBB_NB_SCATTERING_TRANSFORM (pbb) - 3;\n+      ppl_dimension_type *ds;\n+\n+      /* There should be no loops inside LST after flattening.  */\n+      gcc_assert (!LST_LOOP_P (stmt));\n+\n+      if (!nb_dims_to_remove)\n+\tcontinue;\n+\n+      ds = XNEWVEC (ppl_dimension_type, nb_dims_to_remove);\n+      for (j = 0; j < nb_dims_to_remove; j++)\n+\tds[j] = j + 3;\n+\n+      ppl_Polyhedron_remove_space_dimensions (poly, ds, nb_dims_to_remove);\n+      PBB_NB_SCATTERING_TRANSFORM (pbb) -= nb_dims_to_remove;\n+      free (ds);\n+    }\n+\n+  mpz_clear (x);\n+  ppl_delete_Coefficient (one);\n+}\n+\n+/* Flattens all the loop nests of LST.  Return true when something\n+   changed.  */\n+\n+static bool\n+lst_do_flatten (lst_p lst)\n+{\n+  int i;\n+  lst_p l;\n+  bool res = false;\n+  mpz_t zero;\n+\n+  if (!lst\n+      || !LST_LOOP_P (lst))\n+    return false;\n+\n+  mpz_init (zero);\n+  mpz_set_si (zero, 0);\n+\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n+    if (LST_LOOP_P (l))\n+      {\n+\tres |= lst_flatten_loop (l, zero);\n+\tremove_unused_scattering_dimensions (l);\n+      }\n+\n+  lst_update_scattering (lst);\n+  mpz_clear (zero);\n+  return res;\n+}\n+\n+/* Flatten all the loop nests in SCOP.  Returns true when something\n+   changed.  */\n+\n+bool\n+flatten_all_loops (scop_p scop)\n+{\n+  return lst_do_flatten (SCOP_TRANSFORMED_SCHEDULE (scop));\n+}\n+\n+#endif"}, {"sha": "e09b570ab05d3252831324668b6cbe7b9ab1863e", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -783,6 +783,9 @@ apply_poly_transforms (scop_p scop)\n \ttransform_done |= scop_do_interchange (scop);\n     }\n \n+  if (flag_loop_flatten)\n+    transform_done |= flatten_all_loops (scop);\n+\n   /* This feature is only enabled in the Graphite branch.  */\n   if (0)\n     {\n@@ -1688,7 +1691,8 @@ pbb_number_of_iterations_at_time (poly_bb_p pbb,\n       ppl_delete_Constraint_System (cs);\n     }\n \n-  /* Compute the lower bound on the original iteration domain.  */\n+  /* Compute the lower bound on the original iteration domain and add\n+     it to the scattering.  */\n   ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n     (&sctr_lb, PBB_TRANSFORMED_SCATTERING (pbb));\n   for (i = 0; i < (int) domain_dim; i++)"}, {"sha": "8b950a478ffa1da00385905b903ebde62bad00a3", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -414,6 +414,7 @@ extern void debug_iteration_domains (scop_p, int);\n extern bool scop_do_interchange (scop_p);\n extern bool scop_do_strip_mine (scop_p);\n extern bool scop_do_block (scop_p);\n+extern bool flatten_all_loops (scop_p);\n extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);\n extern void pbb_remove_duplicate_pdrs (poly_bb_p);\n \n@@ -944,7 +945,7 @@ find_lst_loop (lst_p stmt, int loop_depth)\n   return loop;\n }\n \n-/* Return the first lst representing a PBB statement in LST.  */\n+/* Return the first LST representing a PBB statement in LST.  */\n \n static inline lst_p\n lst_find_first_pbb (lst_p lst)\n@@ -968,7 +969,7 @@ lst_find_first_pbb (lst_p lst)\n   return NULL;\n }\n \n-/* Returns true when LST is a loop that does not contains\n+/* Returns true when LST is a loop that does not contain\n    statements.  */\n \n static inline bool\n@@ -977,7 +978,7 @@ lst_empty_p (lst_p lst)\n   return !lst_find_first_pbb (lst);\n }\n \n-/* Return the last lst representing a PBB statement in LST.  */\n+/* Return the last LST representing a PBB statement in LST.  */\n \n static inline lst_p\n lst_find_last_pbb (lst_p lst)\n@@ -1061,6 +1062,26 @@ lst_remove_from_sequence (lst_p lst)\n   LST_LOOP_FATHER (lst) = NULL;\n }\n \n+/* Removes the loop LST and inline its body in the father loop.  */\n+\n+static inline void\n+lst_remove_loop_and_inline_stmts_in_loop_father (lst_p lst)\n+{\n+  lst_p l, father = LST_LOOP_FATHER (lst);\n+  int i, dewey = lst_dewey_number (lst);\n+\n+  gcc_assert (lst && father && dewey >= 0);\n+\n+  VEC_ordered_remove (lst_p, LST_SEQ (father), dewey);\n+  LST_LOOP_FATHER (lst) = NULL;\n+\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n+    {\n+      VEC_safe_insert (lst_p, heap, LST_SEQ (father), dewey + i, l);\n+      LST_LOOP_FATHER (l) = father;\n+    }\n+}\n+\n /* Sets NITER to the upper bound approximation of the number of\n    iterations of loop LST.  */\n "}, {"sha": "7aa78f88bf0160d3434b78263f439bd6d6a519b8", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98af4c9ffeba9ea5549c06aa91e074a258cdd493/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=98af4c9ffeba9ea5549c06aa91e074a258cdd493", "patch": "@@ -303,8 +303,12 @@ gate_graphite_transforms (void)\n {\n   /* Enable -fgraphite pass if any one of the graphite optimization flags\n      is turned on.  */\n-  if (flag_loop_block || flag_loop_interchange || flag_loop_strip_mine\n-      || flag_graphite_identity || flag_loop_parallelize_all)\n+  if (flag_loop_block\n+      || flag_loop_interchange\n+      || flag_loop_strip_mine\n+      || flag_graphite_identity\n+      || flag_loop_parallelize_all\n+      || flag_loop_flatten)\n     flag_graphite = 1;\n \n   return flag_graphite != 0;"}]}