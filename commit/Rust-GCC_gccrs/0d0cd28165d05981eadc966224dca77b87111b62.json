{"sha": "0d0cd28165d05981eadc966224dca77b87111b62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQwY2QyODE2NWQwNTk4MWVhZGM5NjYyMjRkY2E3N2I4NzExMWI2Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-25T09:03:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-25T09:03:29Z"}, "message": "[Ada] Support for C99 and C++ standard boolean types\n\nThis change the type Interfaces.C.Extensions.bool to be fully compatible\nwith the C99 and C++ standard boolean types by making it a fully-fledged\nboolean type with convention C.\n\nThe following C+Ada program must compile quietly in LTO mode:\n\nbool b;\n\nstruct S {};\n\nbool foo (struct S *s) { return true; }\n\npragma Ada_2005;\npragma Style_Checks (Off);\n\nwith Interfaces.C; use Interfaces.C;\nwith Interfaces.C.Extensions;\n\npackage t_c is\n\n   b : aliased Extensions.bool;  -- t.c:3\n   pragma Import (C, b, \"b\");\n\n   type S is record\n      null;\n   end record;\n   pragma Convention (C_Pass_By_Copy, S);  -- t.c:5\n\n   function foo (the_s : access S) return Extensions.bool;  -- t.c:7\n   pragma Import (C, foo, \"foo\");\n\nend t_c;\n\nwith t_c; use t_c;\n\nprocedure P_C is\n\n  Dummy : aliased S;\n\nbegin\n  b := foo (Dummy'Access);\nend;\n\n2018-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* freeze.adb (Freeze_Enumeration_Type): Do not give integer size to a\n\tboolean type with convention C.\n\t* libgnat/i-cexten.ads (bool): Change to boolean with convention C.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add new local variable\n\tFOREIGN and use it throughout the function.\n\t<E_Enumeration_Type>: Set precision 1 on boolean types with foreign\n\tconvention.\n\t<E_Enumeration_Subtype>: Likewise for subtypes.\n\t<E_Record_Type>: Force the size of a storage unit on empty classes.\n\t* gcc-interface/utils.c (make_type_from_size) <BOOLEAN_TYPE>: Skip\n\tboolean types with precision 1 if the size is the expected one.\n\nFrom-SVN: r260721", "tree": {"sha": "b393260c4976c48845d0913b4bfd2057209f9bfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b393260c4976c48845d0913b4bfd2057209f9bfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d0cd28165d05981eadc966224dca77b87111b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0cd28165d05981eadc966224dca77b87111b62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0cd28165d05981eadc966224dca77b87111b62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0cd28165d05981eadc966224dca77b87111b62/comments", "author": null, "committer": null, "parents": [{"sha": "28e3372094a60b1d7fb9d076a29b050761e5692a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e3372094a60b1d7fb9d076a29b050761e5692a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e3372094a60b1d7fb9d076a29b050761e5692a"}], "stats": {"total": 73, "additions": 60, "deletions": 13}, "files": [{"sha": "838c445213c7fa068f1d7f30281a2ce4d9aebb4b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d0cd28165d05981eadc966224dca77b87111b62", "patch": "@@ -1,3 +1,17 @@\n+2018-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* freeze.adb (Freeze_Enumeration_Type): Do not give integer size to a\n+\tboolean type with convention C.\n+\t* libgnat/i-cexten.ads (bool): Change to boolean with convention C.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add new local variable\n+\tFOREIGN and use it throughout the function.\n+\t<E_Enumeration_Type>: Set precision 1 on boolean types with foreign\n+\tconvention.\n+\t<E_Enumeration_Subtype>: Likewise for subtypes.\n+\t<E_Record_Type>: Force the size of a storage unit on empty classes.\n+\t* gcc-interface/utils.c (make_type_from_size) <BOOLEAN_TYPE>: Skip\n+\tboolean types with precision 1 if the size is the expected one.\n+\n 2018-05-25  Arnaud Charlet  <charlet@adacore.com>\n \n \t* pprint.adb (Expression_Name): Do not print non ASCII characters."}, {"sha": "72b8f9536b2ad19406ea7f6cadc0da74659c5177", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0d0cd28165d05981eadc966224dca77b87111b62", "patch": "@@ -6877,12 +6877,15 @@ package body Freeze is\n    procedure Freeze_Enumeration_Type (Typ : Entity_Id) is\n    begin\n       --  By default, if no size clause is present, an enumeration type with\n-      --  Convention C is assumed to interface to a C enum, and has integer\n-      --  size. This applies to types. For subtypes, verify that its base\n-      --  type has no size clause either. Treat other foreign conventions\n-      --  in the same way, and also make sure alignment is set right.\n+      --  Convention C is assumed to interface to a C enum and has integer\n+      --  size, except for a boolean type because it is assumed to interface\n+      --  to _Bool introduced in C99. This applies to types. For subtypes,\n+      --  verify that its base type has no size clause either. Treat other\n+      --  foreign conventions in the same way, and also make sure alignment\n+      --  is set right.\n \n       if Has_Foreign_Convention (Typ)\n+        and then not Is_Boolean_Type (Typ)\n         and then not Has_Size_Clause (Typ)\n         and then not Has_Size_Clause (Base_Type (Typ))\n         and then Esize (Typ) < Standard_Integer_Size"}, {"sha": "738211fab5663858b73cd32af1f6d481324f3803", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0d0cd28165d05981eadc966224dca77b87111b62", "patch": "@@ -282,6 +282,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n   /* True if this entity is to be considered as imported.  */\n   const bool imported_p\n     = (Is_Imported (gnat_entity) && No (Address_Clause (gnat_entity)));\n+  /* True if this entity has a foreign convention.  */\n+  const bool foreign = Has_Foreign_Convention (gnat_entity);\n   /* For a type, contains the equivalent GNAT node to be used in gigi.  */\n   Entity_Id gnat_equiv_type = Empty;\n   /* Temporary used to walk the GNAT tree.  */\n@@ -658,8 +660,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  }\n \n \t/* Get the type after elaborating the renamed object.  */\n-\tif (Has_Foreign_Convention (gnat_entity)\n-\t    && Is_Descendant_Of_Address (Underlying_Type (gnat_type)))\n+\tif (foreign && Is_Descendant_Of_Address (Underlying_Type (gnat_type)))\n \t  gnu_type = ptr_type_node;\n \telse\n \t  {\n@@ -1594,6 +1595,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  tree gnu_list = NULL_TREE;\n \t  Entity_Id gnat_literal;\n \n+\t  /* Boolean types with foreign convention have precision 1.  */\n+\t  if (is_boolean && foreign)\n+\t    esize = 1;\n+\n \t  gnu_type = make_node (is_boolean ? BOOLEAN_TYPE : ENUMERAL_TYPE);\n \t  TYPE_PRECISION (gnu_type) = esize;\n \t  TYPE_UNSIGNED (gnu_type) = is_unsigned;\n@@ -1774,6 +1779,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \tesize = UI_To_Int (RM_Size (gnat_entity));\n \n+      /* Boolean types with foreign convention have precision 1.  */\n+      if (Is_Boolean_Type (gnat_entity) && foreign)\n+\t{\n+\t  gnu_type = make_node (BOOLEAN_TYPE);\n+\t  TYPE_PRECISION (gnu_type) = 1;\n+\t  TYPE_UNSIGNED (gnu_type) = 1;\n+\t  set_min_and_max_values_for_integral_type (gnu_type, 1, UNSIGNED);\n+\t  layout_type (gnu_type);\n+\t}\n       /* First subtypes of Character are treated as Character; otherwise\n \t this should be an unsigned type if the base type is unsigned or\n \t if the lower bound is constant and non-negative or if the type\n@@ -1783,7 +1797,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t conversions to it and gives more leeway to the optimizer; but\n \t this means that we will need to explicitly test for this case\n \t when we change the representation based on the RM size.  */\n-      if (kind == E_Enumeration_Subtype\n+      else if (kind == E_Enumeration_Subtype\n \t  && No (First_Literal (Etype (gnat_entity)))\n \t  && Esize (gnat_entity) == RM_Size (gnat_entity)\n \t  && esize == CHAR_TYPE_SIZE\n@@ -1808,8 +1822,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t gnat_entity, \"U\", definition, true,\n \t\t\t\t\t debug_info_p));\n \n-      TYPE_BIASED_REPRESENTATION_P (gnu_type)\n-\t= Has_Biased_Representation (gnat_entity);\n+      if (TREE_CODE (gnu_type) == INTEGER_TYPE)\n+\tTYPE_BIASED_REPRESENTATION_P (gnu_type)\n+\t  = Has_Biased_Representation (gnat_entity);\n \n       /* Do the same processing for Character subtypes as for types.  */\n       if (TYPE_STRING_FLAG (TREE_TYPE (gnu_type)))\n@@ -3300,6 +3315,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t  all_rep ? NULL_TREE : bitsize_zero_node,\n \t\t\t\t  NULL);\n \n+\t    /* Empty classes have the size of a storage unit in C++.  */\n+\t    if (TYPE_SIZE (gnu_type) == bitsize_zero_node\n+\t\t&& Convention (gnat_entity) == Convention_CPP)\n+\t      {\n+\t\tTYPE_SIZE (gnu_type) = bitsize_unit_node;\n+\t\tTYPE_SIZE_UNIT (gnu_type) = size_one_node;\n+\t\tcompute_record_mode (gnu_type);\n+\t      }\n+\n \t    /* If there are entities in the chain corresponding to components\n \t       that we did not elaborate, ensure we elaborate their types if\n \t       they are Itypes.  */\n@@ -3966,8 +3990,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t/* If we should request stack realignment for a foreign convention\n \t   subprogram, do so.  Note that this applies to task entry points\n \t   in particular.  */\n-\tif (FOREIGN_FORCE_REALIGN_STACK\n-\t    && Has_Foreign_Convention (gnat_entity))\n+\tif (FOREIGN_FORCE_REALIGN_STACK && foreign)\n \t  prepend_one_attribute\n \t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t     get_identifier (\"force_align_arg_pointer\"), NULL_TREE,"}, {"sha": "cc25973c2e90b65dffed234d4ddfe9246dd5e8de", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0d0cd28165d05981eadc966224dca77b87111b62", "patch": "@@ -1133,9 +1133,15 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \n   switch (TREE_CODE (type))\n     {\n+    case BOOLEAN_TYPE:\n+      /* Do not mess with boolean types that have foreign convention.  */\n+      if (TYPE_PRECISION (type) == 1 && TYPE_SIZE (type) == size_tree)\n+\tbreak;\n+\n+      /* ... fall through ... */\n+\n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n       biased_p = (TREE_CODE (type) == INTEGER_TYPE\n \t\t  && TYPE_BIASED_REPRESENTATION_P (type));\n "}, {"sha": "d643b95224d7fbc63adb1e8f7a3a62b84d92d545", "filename": "gcc/ada/libgnat/i-cexten.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Flibgnat%2Fi-cexten.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0cd28165d05981eadc966224dca77b87111b62/gcc%2Fada%2Flibgnat%2Fi-cexten.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fi-cexten.ads?ref=0d0cd28165d05981eadc966224dca77b87111b62", "patch": "@@ -56,7 +56,8 @@ package Interfaces.C.Extensions is\n \n    --  C bool\n \n-   subtype bool is plain_char;\n+   type bool is new Boolean;\n+   pragma Convention (C, bool);\n \n    --  64-bit integer types\n "}]}