{"sha": "65b1b4317c419981d35e0f2c7e71236fd105bc96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjViMWI0MzE3YzQxOTk4MWQzNWUwZjJjN2U3MTIzNmZkMTA1YmM5Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-11-15T13:58:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:58:08Z"}, "message": "exp_fixd.adb: Use Universal_Real instead of Long_Long_Float when...\n\n2005-11-14  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_fixd.adb: Use Universal_Real instead of Long_Long_Float when we\n\tneed a high precision float type for the generated code (prevents\n\tgratuitous Vax_Float stuff when pragma Float_Representation (Vax_Float)\n\tused).\n\n\t* exp_imgv.adb: Use Universal_Real instead of Long_Long_Float when we\n\tneed a high precision float type for the generated code (prevents\n\tgratuitous Vax_Float stuff when pragma Float_Representation (Vax_Float)\n\tused).\n\t(Expand_Width_Attribute): In configurable run-time, the attribute is not\n\tallowed on non-static enumeration subtypes. Force a load error to emit\n\tthe correct diagnostic.\n\nFrom-SVN: r106975", "tree": {"sha": "ea170e162f96eb8fe97243c3e4b27a39dbf5ccca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea170e162f96eb8fe97243c3e4b27a39dbf5ccca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65b1b4317c419981d35e0f2c7e71236fd105bc96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b1b4317c419981d35e0f2c7e71236fd105bc96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b1b4317c419981d35e0f2c7e71236fd105bc96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b1b4317c419981d35e0f2c7e71236fd105bc96/comments", "author": null, "committer": null, "parents": [{"sha": "379ecbfacf3272e1c12b5ac930155ea6f5367a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/379ecbfacf3272e1c12b5ac930155ea6f5367a71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/379ecbfacf3272e1c12b5ac930155ea6f5367a71"}], "stats": {"total": 173, "additions": 77, "deletions": 96}, "files": [{"sha": "fa1f8403ac894fafc83f9731cbb552447d030391", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 60, "deletions": 95, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b1b4317c419981d35e0f2c7e71236fd105bc96/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b1b4317c419981d35e0f2c7e71236fd105bc96/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=65b1b4317c419981d35e0f2c7e71236fd105bc96", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -61,8 +61,7 @@ package body Exp_Fixd is\n      (N    : Node_Id;\n       Typ  : Entity_Id;\n       Expr : Node_Id;\n-      Rchk : Boolean := False)\n-      return Node_Id;\n+      Rchk : Boolean := False) return Node_Id;\n    --  Build an expression that converts the expression Expr to type Typ,\n    --  taking the source location from Sloc (N). If the conversions involve\n    --  fixed-point types, then the Conversion_OK flag will be set so that the\n@@ -72,21 +71,19 @@ package body Exp_Fixd is\n \n    function Build_Divide (N : Node_Id; L, R : Node_Id) return Node_Id;\n    --  Builds an N_Op_Divide node from the given left and right operand\n-   --  expressions, using the source location from Sloc (N). The operands\n-   --  are either both Long_Long_Float, in which case Build_Divide differs\n-   --  from Make_Op_Divide only in that the Etype of the resulting node is\n-   --  set (to Long_Long_Float), or they can be integer types. In this case\n-   --  the integer types need not be the same, and Build_Divide converts\n-   --  the operand with the smaller sized type to match the type of the\n-   --  other operand and sets this as the result type. The Rounded_Result\n-   --  flag of the result in this case is set from the Rounded_Result flag\n-   --  of node N. On return, the resulting node is analyzed, and has its\n-   --  Etype set.\n+   --  expressions, using the source location from Sloc (N). The operands are\n+   --  either both Universal_Real, in which case Build_Divide differs from\n+   --  Make_Op_Divide only in that the Etype of the resulting node is set (to\n+   --  Universal_Real), or they can be integer types. In this case the integer\n+   --  types need not be the same, and Build_Divide converts the operand with\n+   --  the smaller sized type to match the type of the other operand and sets\n+   --  this as the result type. The Rounded_Result flag of the result in this\n+   --  case is set from the Rounded_Result flag of node N. On return, the\n+   --  resulting node is analyzed, and has its Etype set.\n \n    function Build_Double_Divide\n      (N       : Node_Id;\n-      X, Y, Z : Node_Id)\n-      return    Node_Id;\n+      X, Y, Z : Node_Id) return Node_Id;\n    --  Returns a node corresponding to the value X/(Y*Z) using the source\n    --  location from Sloc (N). The division is rounded if the Rounded_Result\n    --  flag of N is set. The integer types of X, Y, Z may be different. On\n@@ -100,37 +97,35 @@ package body Exp_Fixd is\n    --  Generates a sequence of code for determining the quotient and remainder\n    --  of the division X/(Y*Z), using the source location from Sloc (N).\n    --  Entities of appropriate types are allocated for the quotient and\n-   --  remainder and returned in Qnn and Rnn. The result is rounded if\n-   --  the Rounded_Result flag of N is set. The Etype fields of Qnn and Rnn\n-   --  are appropriately set on return.\n+   --  remainder and returned in Qnn and Rnn. The result is rounded if the\n+   --  Rounded_Result flag of N is set. The Etype fields of Qnn and Rnn are\n+   --  appropriately set on return.\n \n    function Build_Multiply (N : Node_Id; L, R : Node_Id) return Node_Id;\n    --  Builds an N_Op_Multiply node from the given left and right operand\n-   --  expressions, using the source location from Sloc (N). The operands\n-   --  are either both Long_Long_Float, in which case Build_Divide differs\n-   --  from Make_Op_Multiply only in that the Etype of the resulting node is\n-   --  set (to Long_Long_Float), or they can be integer types. In this case\n-   --  the integer types need not be the same, and Build_Multiply chooses\n-   --  a type long enough to hold the product (i.e. twice the size of the\n-   --  longer of the two operand types), and both operands are converted\n-   --  to this type. The Etype of the result is also set to this value.\n-   --  However, the result can never overflow Integer_64, so this is the\n-   --  largest type that is ever generated. On return, the resulting node\n-   --  is analyzed and has its Etype set.\n+   --  expressions, using the source location from Sloc (N). The operands are\n+   --  either both Universal_Real, in which case Build_Divide differs from\n+   --  Make_Op_Multiply only in that the Etype of the resulting node is set (to\n+   --  Universal_Real), or they can be integer types. In this case the integer\n+   --  types need not be the same, and Build_Multiply chooses a type long\n+   --  enough to hold the product (i.e. twice the size of the longer of the two\n+   --  operand types), and both operands are converted to this type. The Etype\n+   --  of the result is also set to this value. However, the result can never\n+   --  overflow Integer_64, so this is the largest type that is ever generated.\n+   --  On return, the resulting node is analyzed and has its Etype set.\n \n    function Build_Rem (N : Node_Id; L, R : Node_Id) return Node_Id;\n    --  Builds an N_Op_Rem node from the given left and right operand\n-   --  expressions, using the source location from Sloc (N). The operands\n-   --  are both integer types, which need not be the same. Build_Rem\n-   --  converts the operand with the smaller sized type to match the type\n-   --  of the other operand and sets this as the result type. The result\n-   --  is never rounded (rem operations cannot be rounded in any case!)\n-   --  On return, the resulting node is analyzed and has its Etype set.\n+   --  expressions, using the source location from Sloc (N). The operands are\n+   --  both integer types, which need not be the same. Build_Rem converts the\n+   --  operand with the smaller sized type to match the type of the other\n+   --  operand and sets this as the result type. The result is never rounded\n+   --  (rem operations cannot be rounded in any case!) On return, the resulting\n+   --  node is analyzed and has its Etype set.\n \n    function Build_Scaled_Divide\n      (N       : Node_Id;\n-      X, Y, Z : Node_Id)\n-      return    Node_Id;\n+      X, Y, Z : Node_Id) return Node_Id;\n    --  Returns a node corresponding to the value X*Y/Z using the source\n    --  location from Sloc (N). The division is rounded if the Rounded_Result\n    --  flag of N is set. The integer types of X, Y, Z may be different. On\n@@ -183,10 +178,10 @@ package body Exp_Fixd is\n \n    function Fpt_Value (N : Node_Id) return Node_Id;\n    --  Given an operand of fixed-point operation, return an expression that\n-   --  represents the corresponding Long_Long_Float value. The expression\n+   --  represents the corresponding Universal_Real value. The expression\n    --  can be of integer type, floating-point type, or fixed-point type.\n    --  The expression returned is neither analyzed and resolved. The Etype\n-   --  of the result is properly set (to Long_Long_Float).\n+   --  of the result is properly set (to Universal_Real).\n \n    function Integer_Literal (N : Node_Id; V : Uint) return Node_Id;\n    --  Given a non-negative universal integer value, build a typed integer\n@@ -198,8 +193,8 @@ package body Exp_Fixd is\n \n    function Real_Literal (N : Node_Id; V : Ureal) return Node_Id;\n    --  Build a real literal node from the given value, the Etype of the\n-   --  returned node is set to Long_Long_Float, since all floating-point\n-   --  arithmetic operations that we construct use Long_Long_Float\n+   --  returned node is set to Universal_Real, since all floating-point\n+   --  arithmetic operations that we construct use Universal_Real\n \n    function Rounded_Result_Set (N : Node_Id) return Boolean;\n    --  Returns True if N is a node that contains the Rounded_Result flag\n@@ -224,8 +219,7 @@ package body Exp_Fixd is\n      (N    : Node_Id;\n       Typ  : Entity_Id;\n       Expr : Node_Id;\n-      Rchk : Boolean := False)\n-      return Node_Id\n+      Rchk : Boolean := False) return Node_Id\n    is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Result : Node_Id;\n@@ -296,7 +290,6 @@ package body Exp_Fixd is\n \n       Set_Etype (Result, Typ);\n       return Result;\n-\n    end Build_Conversion;\n \n    ------------------\n@@ -314,11 +307,11 @@ package body Exp_Fixd is\n       --  Deal with floating-point case first\n \n       if Is_Floating_Point_Type (Left_Type) then\n-         pragma Assert (Left_Type = Standard_Long_Long_Float);\n-         pragma Assert (Right_Type = Standard_Long_Long_Float);\n+         pragma Assert (Left_Type = Universal_Real);\n+         pragma Assert (Right_Type = Universal_Real);\n \n          Rnode := Make_Op_Divide (Loc, L, R);\n-         Result_Type := Standard_Long_Long_Float;\n+         Result_Type := Universal_Real;\n \n       --  Integer and fixed-point cases\n \n@@ -384,7 +377,6 @@ package body Exp_Fixd is\n       end if;\n \n       return Rnode;\n-\n    end Build_Divide;\n \n    -------------------------\n@@ -393,8 +385,7 @@ package body Exp_Fixd is\n \n    function Build_Double_Divide\n      (N       : Node_Id;\n-      X, Y, Z : Node_Id)\n-      return    Node_Id\n+      X, Y, Z : Node_Id) return Node_Id\n    is\n       Y_Size : constant Int := UI_To_Int (Esize (Etype (Y)));\n       Z_Size : constant Int := UI_To_Int (Esize (Etype (Z)));\n@@ -582,7 +573,6 @@ package body Exp_Fixd is\n                New_Occurrence_Of (Rnn, Loc),\n                New_Occurrence_Of (Rnd, Loc))));\n       end if;\n-\n    end Build_Double_Divide_Code;\n \n    --------------------\n@@ -603,10 +593,10 @@ package body Exp_Fixd is\n       --  Deal with floating-point case first\n \n       if Is_Floating_Point_Type (Left_Type) then\n-         pragma Assert (Left_Type = Standard_Long_Long_Float);\n-         pragma Assert (Right_Type = Standard_Long_Long_Float);\n+         pragma Assert (Left_Type = Universal_Real);\n+         pragma Assert (Right_Type = Universal_Real);\n \n-         Result_Type := Standard_Long_Long_Float;\n+         Result_Type := Universal_Real;\n          Rnode := Make_Op_Multiply (Loc, L, R);\n \n       --  Integer and fixed-point cases\n@@ -782,8 +772,7 @@ package body Exp_Fixd is\n \n    function Build_Scaled_Divide\n      (N       : Node_Id;\n-      X, Y, Z : Node_Id)\n-      return    Node_Id\n+      X, Y, Z : Node_Id) return Node_Id\n    is\n       X_Size : constant Int := UI_To_Int (Esize (Etype (X)));\n       Y_Size : constant Int := UI_To_Int (Esize (Etype (Y)));\n@@ -1060,7 +1049,6 @@ package body Exp_Fixd is\n         Build_Multiply (N,\n           Build_Divide (N, Fpt_Value (Left), Fpt_Value (Right)),\n           Real_Literal (N, Frac)));\n-\n    end Do_Divide_Fixed_Fixed;\n \n    -------------------------------\n@@ -1176,7 +1164,6 @@ package body Exp_Fixd is\n \n       Set_Result (N,\n         Build_Multiply (N, Fpt_Value (Left), Real_Literal (N, Frac)));\n-\n    end Do_Divide_Fixed_Universal;\n \n    -------------------------------\n@@ -1295,7 +1282,6 @@ package body Exp_Fixd is\n \n       Set_Result (N,\n         Build_Divide (N, Real_Literal (N, Frac), Fpt_Value (Right)));\n-\n    end Do_Divide_Universal_Fixed;\n \n    -----------------------------\n@@ -1380,7 +1366,6 @@ package body Exp_Fixd is\n         Build_Multiply (N,\n           Build_Multiply (N, Fpt_Value (Left), Fpt_Value (Right)),\n           Real_Literal (N, Frac)));\n-\n    end Do_Multiply_Fixed_Fixed;\n \n    ---------------------------------\n@@ -1420,7 +1405,7 @@ package body Exp_Fixd is\n    --    If denominator = 1, then for K = 1, the small ratio is an integer, and\n    --    this is clearly the minimum K case, so set\n \n-   --      K = 1, Right_Small = Lit_Value.\n+   --      K = 1, Right_Small = Lit_Value\n \n    --    If denominator > 1, then set K to the numerator of the fraction, so\n    --    that the resulting small ratio is the reciprocal of the integer (the\n@@ -1498,7 +1483,6 @@ package body Exp_Fixd is\n \n       Set_Result (N,\n         Build_Multiply (N, Fpt_Value (Left), Real_Literal (N, Frac)));\n-\n    end Do_Multiply_Fixed_Universal;\n \n    ---------------------------------\n@@ -1553,7 +1537,6 @@ package body Exp_Fixd is\n       Ratio_Den   := Norm_Den (Small_Ratio);\n \n       if Ratio_Den = 1 then\n-\n          if Ratio_Num = 1 then\n             Set_Result (N, Expr);\n             return;\n@@ -1585,7 +1568,6 @@ package body Exp_Fixd is\n           Fpt_Value (Expr),\n           Real_Literal (N, Small_Ratio)),\n         Rng_Check);\n-\n    end Expand_Convert_Fixed_To_Fixed;\n \n    -----------------------------------\n@@ -1594,7 +1576,7 @@ package body Exp_Fixd is\n \n    --  If the small of the fixed type is 1.0, then we simply convert the\n    --  integer value directly to the target floating-point type, otherwise\n-   --  we first have to multiply by the small, in Long_Long_Float, and then\n+   --  we first have to multiply by the small, in Universal_Real, and then\n    --  convert the result to the target floating-point type.\n \n    procedure Expand_Convert_Fixed_To_Float (N : Node_Id) is\n@@ -1679,7 +1661,6 @@ package body Exp_Fixd is\n           Fpt_Value (Expr),\n           Real_Literal (N, Small)),\n         Rng_Check);\n-\n    end Expand_Convert_Fixed_To_Integer;\n \n    -----------------------------------\n@@ -1776,7 +1757,6 @@ package body Exp_Fixd is\n           Fpt_Value (Expr),\n           Real_Literal (N, Ureal_1 / Small)),\n         Rng_Check);\n-\n    end Expand_Convert_Integer_To_Fixed;\n \n    --------------------------------\n@@ -1826,7 +1806,7 @@ package body Exp_Fixd is\n    --  division or multiplication by the appropriate power of 10.\n \n    procedure Expand_Decimal_Divide_Call (N : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n \n       Dividend  : Node_Id := First_Actual (N);\n       Divisor   : Node_Id := Next_Actual (Dividend);\n@@ -1971,7 +1951,6 @@ package body Exp_Fixd is\n               Statements => Stmts)));\n \n       Analyze (N);\n-\n    end Expand_Decimal_Divide_Call;\n \n    -----------------------------------------------\n@@ -1999,14 +1978,13 @@ package body Exp_Fixd is\n       else\n          Do_Divide_Fixed_Fixed (N);\n       end if;\n-\n    end Expand_Divide_Fixed_By_Fixed_Giving_Fixed;\n \n    -----------------------------------------------\n    -- Expand_Divide_Fixed_By_Fixed_Giving_Float --\n    -----------------------------------------------\n \n-   --  The division is done in long_long_float, and the result is multiplied\n+   --  The division is done in Universal_Real, and the result is multiplied\n    --  by the small ratio, which is Small (Right) / Small (Left). Special\n    --  treatment is required for universal operands, which represent their\n    --  own value and do not require conversion.\n@@ -2065,7 +2043,6 @@ package body Exp_Fixd is\n              Real_Literal (N,\n                Small_Value (Left_Type) / Small_Value (Right_Type))));\n       end if;\n-\n    end Expand_Divide_Fixed_By_Fixed_Giving_Float;\n \n    -------------------------------------------------\n@@ -2075,18 +2052,14 @@ package body Exp_Fixd is\n    procedure Expand_Divide_Fixed_By_Fixed_Giving_Integer (N : Node_Id) is\n       Left  : constant Node_Id := Left_Opnd (N);\n       Right : constant Node_Id := Right_Opnd (N);\n-\n    begin\n       if Etype (Left) = Universal_Real then\n          Do_Divide_Universal_Fixed (N);\n-\n       elsif Etype (Right) = Universal_Real then\n          Do_Divide_Fixed_Universal (N);\n-\n       else\n          Do_Divide_Fixed_Fixed (N);\n       end if;\n-\n    end Expand_Divide_Fixed_By_Fixed_Giving_Integer;\n \n    -------------------------------------------------\n@@ -2099,7 +2072,6 @@ package body Exp_Fixd is\n    procedure Expand_Divide_Fixed_By_Integer_Giving_Fixed (N : Node_Id) is\n       Left  : constant Node_Id := Left_Opnd (N);\n       Right : constant Node_Id := Right_Opnd (N);\n-\n    begin\n       Set_Result (N, Build_Divide (N, Left, Right));\n    end Expand_Divide_Fixed_By_Integer_Giving_Fixed;\n@@ -2118,9 +2090,12 @@ package body Exp_Fixd is\n       --  as a fixed * fixed multiplication, and convert the argument to\n       --  the target fixed type.\n \n-      procedure Rewrite_Non_Static_Universal (Opnd : Node_Id) is\n-         Loc   : constant Source_Ptr := Sloc (N);\n+      ----------------------------------\n+      -- Rewrite_Non_Static_Universal --\n+      ----------------------------------\n \n+      procedure Rewrite_Non_Static_Universal (Opnd : Node_Id) is\n+         Loc : constant Source_Ptr := Sloc (N);\n       begin\n          Rewrite (Opnd,\n            Make_Type_Conversion (Loc,\n@@ -2129,6 +2104,8 @@ package body Exp_Fixd is\n          Analyze_And_Resolve (Opnd, Etype (N));\n       end Rewrite_Non_Static_Universal;\n \n+   --  Start of processing for Expand_Multiply_Fixed_By_Fixed_Giving_Fixed\n+\n    begin\n       --  Suppress expansion of a fixed-by-fixed multiplication if the\n       --  operation is supported directly by the target.\n@@ -2158,14 +2135,13 @@ package body Exp_Fixd is\n       else\n          Do_Multiply_Fixed_Fixed (N);\n       end if;\n-\n    end Expand_Multiply_Fixed_By_Fixed_Giving_Fixed;\n \n    -------------------------------------------------\n    -- Expand_Multiply_Fixed_By_Fixed_Giving_Float --\n    -------------------------------------------------\n \n-   --  The multiply is done in long_long_float, and the result is multiplied\n+   --  The multiply is done in Universal_Real, and the result is multiplied\n    --  by the adjustment for the smalls which is Small (Right) * Small (Left).\n    --  Special treatment is required for universal operands.\n \n@@ -2220,7 +2196,6 @@ package body Exp_Fixd is\n              Real_Literal (N,\n                Small_Value (Right_Type) * Small_Value (Left_Type))));\n       end if;\n-\n    end Expand_Multiply_Fixed_By_Fixed_Giving_Float;\n \n    ---------------------------------------------------\n@@ -2230,18 +2205,14 @@ package body Exp_Fixd is\n    procedure Expand_Multiply_Fixed_By_Fixed_Giving_Integer (N : Node_Id) is\n       Left  : constant Node_Id := Left_Opnd (N);\n       Right : constant Node_Id := Right_Opnd (N);\n-\n    begin\n       if Etype (Left) = Universal_Real then\n          Do_Multiply_Fixed_Universal (N, Right, Left);\n-\n       elsif Etype (Right) = Universal_Real then\n          Do_Multiply_Fixed_Universal (N, Left, Right);\n-\n       else\n          Do_Multiply_Fixed_Fixed (N);\n       end if;\n-\n    end Expand_Multiply_Fixed_By_Fixed_Giving_Integer;\n \n    ---------------------------------------------------\n@@ -2281,17 +2252,13 @@ package body Exp_Fixd is\n       if Is_Integer_Type (Typ)\n         or else Is_Floating_Point_Type (Typ)\n       then\n-         return\n-           Build_Conversion\n-             (N, Standard_Long_Long_Float, N);\n+         return Build_Conversion (N, Universal_Real, N);\n \n       --  Fixed-point case, must get integer value first\n \n       else\n-         return\n-           Build_Conversion (N, Standard_Long_Long_Float, N);\n+         return Build_Conversion (N, Universal_Real, N);\n       end if;\n-\n    end Fpt_Value;\n \n    ---------------------\n@@ -2348,7 +2315,7 @@ package body Exp_Fixd is\n \n       --  Set type of result in case used elsewhere (see note at start)\n \n-      Set_Etype (L, Standard_Long_Long_Float);\n+      Set_Etype (L, Universal_Real);\n       return L;\n    end Real_Literal;\n \n@@ -2358,7 +2325,6 @@ package body Exp_Fixd is\n \n    function Rounded_Result_Set (N : Node_Id) return Boolean is\n       K : constant Node_Kind := Nkind (N);\n-\n    begin\n       if (K = N_Type_Conversion or else\n           K = N_Op_Divide       or else\n@@ -2399,7 +2365,6 @@ package body Exp_Fixd is\n \n       Rewrite (N, Cnode);\n       Analyze_And_Resolve (N, Result_Type);\n-\n    end Set_Result;\n \n end Exp_Fixd;"}, {"sha": "1fdbced68140193de6127db076d39e23c8f5ddfc", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b1b4317c419981d35e0f2c7e71236fd105bc96/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b1b4317c419981d35e0f2c7e71236fd105bc96/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=65b1b4317c419981d35e0f2c7e71236fd105bc96", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -831,6 +831,22 @@ package body Exp_Imgv is\n       else\n          pragma Assert (Is_Enumeration_Type (Rtyp));\n \n+         if Discard_Names (Rtyp) then\n+\n+            --  This is a configurable run-time, or else a restriction is in\n+            --  effect. In either case the attribute cannot be supported. Force\n+            --  a load error from Rtsfind to generate an appropriate message,\n+            --  as is done with other ZFP violations.\n+\n+            declare\n+               pragma Warnings (Off); -- since Discard is unreferenced\n+               Discard : constant Entity_Id := RTE (RE_Null);\n+               pragma Warnings (On);\n+            begin\n+               return;\n+            end;\n+         end if;\n+\n          Ttyp := Component_Type (Etype (Lit_Indexes (Rtyp)));\n \n          case Attr is"}]}