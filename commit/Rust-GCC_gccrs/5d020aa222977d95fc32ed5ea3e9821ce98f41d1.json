{"sha": "5d020aa222977d95fc32ed5ea3e9821ce98f41d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwMjBhYTIyMjk3N2Q5NWZjMzJlZDVlYTNlOTgyMWNlOThmNDFkMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-10-25T20:56:43Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-10-25T20:56:43Z"}, "message": "re PR libstdc++/50862 (deadlock in std::condition_variable_any)\n\n\tPR libstdc++/50862\n\t* include/std/condition_variable (condition_variable_any::wait): Fix\n\tdeadlock and ensure _Lock::lock() is called on exit.\n\t(condition_variable_any::native_handle): Remove, as per LWG 1500.\n\t* testsuite/30_threads/condition_variable_any/50862.cc: New.\n\nFrom-SVN: r180446", "tree": {"sha": "201d9eec3a0568d6f71da657a7ffbf00b75b7263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/201d9eec3a0568d6f71da657a7ffbf00b75b7263"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d020aa222977d95fc32ed5ea3e9821ce98f41d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d020aa222977d95fc32ed5ea3e9821ce98f41d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d020aa222977d95fc32ed5ea3e9821ce98f41d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d020aa222977d95fc32ed5ea3e9821ce98f41d1/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c094ab3014900a80fb79f37d4518c85e85f0060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c094ab3014900a80fb79f37d4518c85e85f0060", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c094ab3014900a80fb79f37d4518c85e85f0060"}], "stats": {"total": 104, "additions": 96, "deletions": 8}, "files": [{"sha": "a35ae193f47765e622740941824dde6bd7b9bdb8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d020aa222977d95fc32ed5ea3e9821ce98f41d1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d020aa222977d95fc32ed5ea3e9821ce98f41d1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5d020aa222977d95fc32ed5ea3e9821ce98f41d1", "patch": "@@ -1,3 +1,11 @@\n+2011-10-25  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/50862\n+\t* include/std/condition_variable (condition_variable_any::wait): Fix\n+\tdeadlock and ensure _Lock::lock() is called on exit.\n+\t(condition_variable_any::native_handle): Remove, as per LWG 1500.\n+\t* testsuite/30_threads/condition_variable_any/50862.cc: New.\n+\n 2011-10-25  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/49894"}, {"sha": "e17f326356853cbad0d10352be0c55a5ea9dcb65", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d020aa222977d95fc32ed5ea3e9821ce98f41d1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d020aa222977d95fc32ed5ea3e9821ce98f41d1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=5d020aa222977d95fc32ed5ea3e9821ce98f41d1", "patch": "@@ -203,10 +203,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       wait(_Lock& __lock)\n       {\n-        unique_lock<mutex> __my_lock(_M_mutex);\n-        __lock.unlock();\n-        _M_cond.wait(__my_lock);\n-        __lock.lock();\n+\t// scoped unlock - unlocks in ctor, re-locks in dtor\n+\tstruct _Unlock {\n+\t  explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }\n+\t  ~_Unlock() { _M_lock.lock(); }\n+\t  _Lock& _M_lock;\n+\t};\n+\n+\tunique_lock<mutex> __my_lock(_M_mutex);\n+\t_Unlock __unlock(__lock);\n+\t// _M_mutex must be unlocked before re-locking __lock so move\n+\t// ownership of _M_mutex lock to an object with shorter lifetime.\n+\tunique_lock<mutex> __my_lock2(std::move(__my_lock));\n+\t_M_cond.wait(__my_lock2);\n       }\n       \n \n@@ -254,10 +263,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wait_for(_Lock& __lock,\n \t       const chrono::duration<_Rep, _Period>& __rtime, _Predicate __p)\n       { return wait_until(__lock, __clock_t::now() + __rtime, std::move(__p)); }\n-\n-    native_handle_type\n-    native_handle()\n-    { return _M_cond.native_handle(); }\n   };\n \n   // @} group condition_variables"}, {"sha": "db2a5eb71b282a41aaa33a0e3e0425c0ef3167c7", "filename": "libstdc++-v3/testsuite/30_threads/condition_variable_any/50862.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d020aa222977d95fc32ed5ea3e9821ce98f41d1/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2F50862.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d020aa222977d95fc32ed5ea3e9821ce98f41d1/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2F50862.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2F50862.cc?ref=5d020aa222977d95fc32ed5ea3e9821ce98f41d1", "patch": "@@ -0,0 +1,75 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+ \n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>. \n+\n+#include <condition_variable>\n+#include <thread>\n+#include <mutex>\n+#include <array>\n+#include <sstream>\n+\n+struct scoped_thread\n+{\n+  ~scoped_thread() { if (t.joinable()) t.join(); }\n+  std::thread t;\n+};\n+\n+int main()\n+{\n+  typedef std::unique_lock<std::mutex> Lock;\n+\n+  std::mutex                  m;\n+  std::condition_variable_any cond;\n+  unsigned int                product=0;\n+  const unsigned int          count=10;\n+\n+  // writing to stream causes timing changes which makes deadlock easier\n+  // to reproduce - do not remove\n+  std::ostringstream out;\n+\n+  // create consumers\n+  std::array<scoped_thread, 2> threads;\n+  for(size_t i=0; i<threads.size(); ++i)\n+    threads[i].t = std::thread( [&] {\n+\t  for(unsigned int i=0; i<count; ++i)\n+\t  {\n+\t    std::this_thread::yield();\n+\t    Lock lock(m);\n+\t    while(product==0)\n+\t      cond.wait(lock);\n+\t    out << \"got product \" << std::this_thread::get_id() << ' ' << product << std::endl;\n+\t    --product;\n+\t  }\n+\t} );\n+\n+  // single producer\n+  for(size_t i=0; i<threads.size()*count; ++i)\n+  {\n+    std::this_thread::yield();\n+    Lock lock(m);\n+    ++product;\n+    out << \"setting product \" << std::this_thread::get_id() << ' ' << product << std::endl;\n+    cond.notify_one();\n+  }\n+\n+}"}]}