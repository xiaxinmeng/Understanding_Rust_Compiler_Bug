{"sha": "9b7fe786e1287f830952706fbd9ddb39077d70a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI3ZmU3ODZlMTI4N2Y4MzA5NTI3MDZmYmQ5ZGRiMzkwNzdkNzBhOQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@mckinlay.net.nz", "date": "2003-09-24T05:38:36Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2003-09-24T05:38:36Z"}, "message": "PlainSocketImpl.java (read): Remove declaration.\n\n\t* gnu/java/net/PlainSocketImpl.java (read): Remove declaration.\n\t(write): Likewise.\n\t(SocketInputStream, SocketOutputStream): Declare `read' and `write'\n\tnative. Remove implementations which called back into\n\tPlainSocketImpl.\n\tRemove unneccessary overridden methods.\n\t* gnu/java/net/natPlainSocketImplNoNet.cc (read): Move\n\timplementation\n\tto inner class PlainSocketImpl.SocketInputStream.\n\t(write): Likewise.\n\t* gnu/java/net/natPlainSocketImplPosix.cc: As above.\n\t* gnu/java/net/natPlainSocketImplWin32.cc: As above.\n\t* gnu/java/net/SocketInputStream.java: Remove unused file.\n\t* gnu/java/net/SocketOutputStream.java: Likewise.\n\t* Makefile.am: Build CNI headers for PlainSocketImpl.SocketInputStream\n\tand SocketOutputStream.\n\t* Makefile.in: Rebuilt.\n\nFrom-SVN: r71724", "tree": {"sha": "e590f9d618533504ebc1020d0b891654538a1dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e590f9d618533504ebc1020d0b891654538a1dff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b7fe786e1287f830952706fbd9ddb39077d70a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7fe786e1287f830952706fbd9ddb39077d70a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7fe786e1287f830952706fbd9ddb39077d70a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7fe786e1287f830952706fbd9ddb39077d70a9/comments", "author": null, "committer": null, "parents": [{"sha": "b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae"}], "stats": {"total": 541, "additions": 84, "deletions": 457}, "files": [{"sha": "2e852787a8b49eaf37aa912e589557e9e0637640", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9b7fe786e1287f830952706fbd9ddb39077d70a9", "patch": "@@ -1,3 +1,21 @@\n+2003-09-24  Bryce McKinlay  <bryce@mckinlay.net.nz>\n+\n+\t* gnu/java/net/PlainSocketImpl.java (read): Remove declaration.\n+\t(write): Likewise.\n+\t(SocketInputStream): Declare `read' and `write' methods native.\n+\tRemove implementations which called back into PlainSocketImpl.\n+\tRemove unneccessary overridden methods.\n+\t* gnu/java/net/natPlainSocketImplNoNet.cc (read): Move implementation \n+\tto inner class PlainSocketImpl.SocketInputStream.\n+\t(write): Likewise.\n+\t* gnu/java/net/natPlainSocketImplPosix.cc: As above.\n+\t* gnu/java/net/natPlainSocketImplWin32.cc: As above.\n+\t* gnu/java/net/SocketInputStream.java: Remove unused file.\n+\t* gnu/java/net/SocketOutputStream.java: Likewise.\n+\t* Makefile.am: Build CNI headers for PlainSocketImpl.SocketInputStream\n+\tand SocketOutputStream.\n+\t* Makefile.in: Rebuilt.\n+\n 2003-09-23  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* java/lang/System.java: Add GCJ LOCAL note about encoding aliases."}, {"sha": "c80c3d7ee2882a82783222ef45f6ec6d9bdf98dd", "filename": "libjava/Makefile.am", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=9b7fe786e1287f830952706fbd9ddb39077d70a9", "patch": "@@ -464,7 +464,9 @@ ordinary_nat_headers = $(ordinary_java_source_files:.java=.h) \\\n inner_nat_headers = java/io/ObjectOutputStream$$PutField.h \\\n \tjava/io/ObjectInputStream$$GetField.h \\\n \tjava/lang/reflect/Proxy$$ProxyData.h \\\n-\tjava/lang/reflect/Proxy$$ProxyType.h\n+\tjava/lang/reflect/Proxy$$ProxyType.h \\\n+\tgnu/java/net/PlainSocketImpl$$SocketInputStream.h \\\n+\tgnu/java/net/PlainSocketImpl$$SocketOutputStream.h\n \n nat_headers = $(ordinary_nat_headers) $(inner_nat_headers)\n \n@@ -549,6 +551,14 @@ java/io/ObjectOutputStream$$PutField.h: java/io/ObjectOutputStream.class\n \t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n \t'java/io/ObjectOutputStream$$PutField'\n \n+gnu/java/net/PlainSocketImpl$$SocketInputStream.h: gnu/java/net/PlainSocketImpl.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'gnu/java/net/PlainSocketImpl$$SocketInputStream'\n+\n+gnu/java/net/PlainSocketImpl$$SocketOutputStream.h: gnu/java/net/PlainSocketImpl.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'gnu/java/net/PlainSocketImpl$$SocketOutputStream'\n+\n ## Headers we maintain by hand and which we want to install.\n extra_headers = java/lang/Object.h java/lang/Class.h\n "}, {"sha": "b6a5fbd2ae5ca4915cc09f2ada0d62261da8eca7", "filename": "libjava/Makefile.in", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=9b7fe786e1287f830952706fbd9ddb39077d70a9", "patch": "@@ -444,8 +444,9 @@ ordinary_nat_headers = $(ordinary_java_source_files:.java=.h) \\\n inner_nat_headers = java/io/ObjectOutputStream$$PutField.h \\\n \tjava/io/ObjectInputStream$$GetField.h \\\n \tjava/lang/reflect/Proxy$$ProxyData.h \\\n-\tjava/lang/reflect/Proxy$$ProxyType.h\n-\n+\tjava/lang/reflect/Proxy$$ProxyType.h \\\n+\tgnu/java/net/PlainSocketImpl$$SocketInputStream.h \\\n+\tgnu/java/net/PlainSocketImpl$$SocketOutputStream.h\n \n nat_headers = $(ordinary_nat_headers) $(inner_nat_headers)\n \n@@ -5047,6 +5048,14 @@ java/io/ObjectOutputStream$$PutField.h: java/io/ObjectOutputStream.class\n \t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n \t'java/io/ObjectOutputStream$$PutField'\n \n+gnu/java/net/PlainSocketImpl$$SocketInputStream.h: gnu/java/net/PlainSocketImpl.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'gnu/java/net/PlainSocketImpl$$SocketInputStream'\n+\n+gnu/java/net/PlainSocketImpl$$SocketOutputStream.h: gnu/java/net/PlainSocketImpl.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'gnu/java/net/PlainSocketImpl$$SocketOutputStream'\n+\n $(extra_headers) $(srcdir)/java/lang/Object.h $(srcdir)/java/lang/Class.h:\n \t@:\n "}, {"sha": "3edb9745bed35a0458df0ac2815300a02af29cf6", "filename": "libjava/gnu/java/net/PlainSocketImpl.java", "status": "modified", "additions": 12, "deletions": 66, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=9b7fe786e1287f830952706fbd9ddb39077d70a9", "patch": "@@ -271,32 +271,6 @@ protected void accept (SocketImpl s) throws IOException\n   protected native void sendUrgentData(int data)\n     throws IOException;\n \n-  native int read() throws IOException;\n-\n-  /**\n-   * Internal method used by SocketInputStream for reading data from\n-   * the connection.  Reads up to len bytes of data into the buffer\n-   * buf starting at offset bytes into the buffer.\n-   *\n-   * @return The actual number of bytes read or -1 if end of stream.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  native int read(byte[] buffer, int offset, int count)\n-    throws IOException;\n-\n-  native void write(int c) throws IOException;\n-\n-  /**\n-   * Internal method used by SocketOuputStream for writing data to\n-   * the connection.  Writes up to len bytes of data from the buffer\n-   * buf starting at offset bytes into the buffer.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  native void write(byte[] buffer, int offset, int count)\n-    throws IOException;\n-\n   /**\n    * Returns an InputStream object for reading from this socket.  This will\n    * be an instance of SocketInputStream.\n@@ -334,13 +308,14 @@ protected synchronized OutputStream getOutputStream() throws IOException\n    *\n    * @author Nic Ferrier <nferrier@tapsellferrier.co.uk>\n    */\n-  class SocketInputStream\n+  final class SocketInputStream\n     extends InputStream\n   {\n-    SocketInputStream()\n-    {\n-    }\n-    \n+    public native int read() throws IOException;\n+\n+    public native int read(byte[] buffer, int offset, int length)\n+      throws IOException;\n+\n     public final void close() throws IOException\n     {\n       PlainSocketImpl.this.close();\n@@ -350,52 +325,23 @@ public final int available() throws IOException\n     {\n       return PlainSocketImpl.this.available();\n     }\n-\n-    public final int read() throws IOException\n-    {\n-      return PlainSocketImpl.this.read();\n-    }\n-\n-    public final int read(byte[] buffer, int offset, int length)\n-      throws IOException\n-    {\n-      return PlainSocketImpl.this.read(buffer, offset, length);\n-    }\n-\n-    public final int read(byte[] buffer)\n-      throws IOException\n-    {\n-      return PlainSocketImpl.this.read(buffer, 0, buffer.length);\n-    }\n   }\n \n   /** A stream which writes to the socket implementation.\n    *\n    * @author Nic Ferrier  <nferrier@tapsellferrier.co.uk>\n    */\n-  class SocketOutputStream\n+  final class SocketOutputStream\n     extends OutputStream\n   {\n-    public final void close() throws IOException\n-    {\n-      PlainSocketImpl.this.close();\n-    }\n+    public native void write(int c) throws IOException;\n \n-    public final void write(int c) throws IOException\n-    {\n-      PlainSocketImpl.this.write(c);\n-    }\n+    public native void write(byte[] buffer, int offset, int length)\n+      throws IOException;\n \n-    public final void write(byte[] buffer, int offset, int length)\n-      throws IOException\n+    public void close() throws IOException\n     {\n-      PlainSocketImpl.this.write(buffer, offset, length);\n-    }\n-\n-    public final void write(byte[] buffer)\n-      throws IOException\n-    {\n-      PlainSocketImpl.this.write(buffer, 0, buffer.length);\n+      PlainSocketImpl.this.close();\n     }\n   }\n }"}, {"sha": "90d703bf35c354acf8849532fe9060286a244c50", "filename": "libjava/gnu/java/net/SocketInputStream.java", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae/libjava%2Fgnu%2Fjava%2Fnet%2FSocketInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae/libjava%2Fgnu%2Fjava%2Fnet%2FSocketInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FSocketInputStream.java?ref=b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae", "patch": "@@ -1,204 +0,0 @@\n-/* SocketInputStream.java -- An InputStream for Sockets\n-   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.net;\n-\n-import java.io.InputStream;\n-import java.io.IOException;\n-\n-/**\n-  * This class contains an implementation of <code>InputStream</code> for \n-  * sockets.  It in an internal only class used by <code>PlainSocketImpl</code>.\n-  *\n-  * @author Aaron M. Renn (arenn@urbanophile.com)\n-  */\n-class SocketInputStream extends InputStream\n-{\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * The PlainSocketImpl object this stream is associated with\n-  */\n-private PlainSocketImpl impl;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * Builds an instance of this class from a PlainSocketImpl object\n-  */\n-protected\n-SocketInputStream(PlainSocketImpl impl)\n-{\n-  this.impl = impl;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * Returns the number of bytes available to be read before blocking\n-  */\n-public int\n-available() throws IOException\n-{\n-  return(impl.available());\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Determines if \"mark\" functionality is supported on this stream.  For\n-  * sockets, this is always false.  Note that the superclass default is\n-  * false, but it is overridden out of safety concerns and/or paranoia.\n-  */\n-public boolean\n-markSupported()\n-{\n-  return(false);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Do nothing mark method since we don't support this functionality.  Again,\n-  * overriding out of paranoia.\n-  *\n-  * @param readlimit In theory, the number of bytes we can read before the mark becomes invalid\n-  */\n-public void\n-mark(int readlimit)\n-{\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Since we don't support mark, this method always throws an exception\n-  *\n-  * @exception IOException Everytime since we don't support this functionality\n-  */\n-public void\n-reset() throws IOException\n-{\n-  throw new IOException(\"Socket InputStreams do not support mark/reset\");\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method not only closes the stream, it closes the underlying socket\n-  * (and thus any connection) and invalidates any other Input/Output streams\n-  * for the underlying impl object\n-  */\n-public void\n-close() throws IOException\n-{\n-  impl.close();\n-} \n-\n-/*************************************************************************/\n-\n-/**\n-  * Reads the next byte of data and returns it as an int.  \n-  *\n-  * @return The byte read (as an int) or -1 if end of stream);\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public int\n-read() throws IOException\n-{\n-  byte buf[] = new byte[1];\n-\n-  int bytes_read = read(buf, 0, buf.length);\n- \n-  if (bytes_read != -1)\n-    return(buf[0] & 0xFF);\n-  else\n-    return(-1);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Reads up to buf.length bytes of data into the caller supplied buffer.\n-  *\n-  * @return The actual number of bytes read or -1 if end of stream\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public int\n-read(byte[] buf) throws IOException\n-{\n-  return(read(buf, 0, buf.length));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Reads up to len bytes of data into the caller supplied buffer starting\n-  * at offset bytes from the start of the buffer\n-  *\n-  * @return The number of bytes actually read or -1 if end of stream\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public int\n-read(byte[] buf, int offset, int len) throws IOException\n-{\n-  int bytes_read = impl.read(buf, offset, len);\n-  if (bytes_read == 0)\n-    return(-1);\n-\n-  return(bytes_read);\n-}\n-\n-} // class SocketInputStream\n-"}, {"sha": "4d68e3c7570e4350954d81ccaeb91ed6ef82da82", "filename": "libjava/gnu/java/net/SocketOutputStream.java", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae/libjava%2Fgnu%2Fjava%2Fnet%2FSocketOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae/libjava%2Fgnu%2Fjava%2Fnet%2FSocketOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FSocketOutputStream.java?ref=b9f2972f1ea065c2ceb8bc0d1cab7636dc2406ae", "patch": "@@ -1,166 +0,0 @@\n-/* SocketOutputStream.java -- OutputStream for PlainSocketImpl\n-   Copyright (C) 1998,2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.net;\n-\n-import java.io.OutputStream;\n-import java.io.IOException;\n-\n-/**\n-  * This class is used internally by <code>PlainSocketImpl</code> to be the \n-  * <code>OutputStream</code> subclass returned by its \n-  * <code>getOutputStream method</code>.  It expects only to  be used in that \n-  * context.\n-  *\n-  * @author Aaron M. Renn (arenn@urbanophile.com)\n-  */\n-class SocketOutputStream extends OutputStream\n-{\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * The PlainSocketImpl object this stream is associated with\n-  */\n-private PlainSocketImpl impl;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * Build an instance of this class from a PlainSocketImpl object\n-  */\n-protected\n-SocketOutputStream(PlainSocketImpl impl)\n-{\n-  this.impl = impl;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * This method closes the stream and the underlying socket connection.  This\n-  * action also effectively closes any other InputStream or OutputStream\n-  * object associated with the connection.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-close() throws IOException\n-{\n-  impl.close();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Hmmm, we don't seem to have a flush() method in Socket impl, so just\n-  * return for now, but this might need to be looked at later.\n-  *\n-  * @exception IOException Can't happen\n-  */\n-public void\n-flush() throws IOException\n-{\n-  return;\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Writes a byte (passed in as an int) to the given output stream\n-  * \n-  * @param b The byte to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(int b) throws IOException\n-{\n-  byte buf[] = new byte[1];\n-\n-  Integer i = new Integer(b);\n-  buf[0] = i.byteValue();\n-\n-  write(buf, 0, buf.length);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Write an array of bytes to the output stream\n-  *\n-  * @param buf The array of bytes to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(byte[] buf) throws IOException\n-{\n-  write(buf, 0, buf.length);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Writes len number of bytes from the array buf to the stream starting\n-  * at offset bytes into the buffer.\n-  *\n-  * @param buf The buffer\n-  * @param offset Offset into the buffer to start writing from\n-  * @param len The number of bytes to write\n-  */\n-public void\n-write(byte[] buf, int offset, int len) throws IOException\n-{\n-  impl.write(buf, offset, len);\n-}\n-\n-} // class SocketOutputStream\n-"}, {"sha": "a9138aff49dd2a1d3f54a2f529ec2c0855f5c603", "filename": "libjava/gnu/java/net/natPlainSocketImplNoNet.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplNoNet.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplNoNet.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplNoNet.cc?ref=9b7fe786e1287f830952706fbd9ddb39077d70a9", "patch": "@@ -10,6 +10,8 @@ details.  */\n #include <platform.h>\n \n #include <gnu/java/net/PlainSocketImpl.h>\n+#include <gnu/java/net/PlainSocketImpl$SocketInputStream.h>\n+#include <gnu/java/net/PlainSocketImpl$SocketOutputStream.h>\n #include <java/io/IOException.h>\n #include <java/net/BindException.h>\n #include <java/net/ConnectException.h>\n@@ -65,28 +67,30 @@ gnu::java::net::PlainSocketImpl::getOption (jint)\n }\n \n jint\n-gnu::java::net::PlainSocketImpl::read(void)\n+gnu::java::net::PlainSocketImpl$SocketInputStream::read(void)\n {\n   throw new ::java::net::SocketException (\n     JvNewStringLatin1 (\"SocketImpl.read: unimplemented\"));\n }\n \n jint\n-gnu::java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n+gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer, \n+  jint offset, jint count)\n {\n   throw new ::java::net::SocketException (\n     JvNewStringLatin1 (\"SocketImpl.read: unimplemented\"));\n }\n \n void\n-gnu::java::net::PlainSocketImpl::write(jint b)\n+gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jint b)\n {\n   throw new ::java::net::SocketException (\n     JvNewStringLatin1 (\"SocketImpl.write: unimplemented\"));\n }\n \n void\n-gnu::java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n+gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jbyteArray b, \n+  jint offset, jint len)\n {\n   throw new ::java::net::SocketException (\n     JvNewStringLatin1 (\"SocketImpl.write: unimplemented\"));"}, {"sha": "d73b077a9be5aa072d53804f134cb417ce3a40d1", "filename": "libjava/gnu/java/net/natPlainSocketImplPosix.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc?ref=9b7fe786e1287f830952706fbd9ddb39077d70a9", "patch": "@@ -32,6 +32,8 @@ details.  */\n #include <gcj/cni.h>\n #include <gcj/javaprims.h>\n #include <gnu/java/net/PlainSocketImpl.h>\n+#include <gnu/java/net/PlainSocketImpl$SocketInputStream.h>\n+#include <gnu/java/net/PlainSocketImpl$SocketOutputStream.h>\n #include <java/io/IOException.h>\n #include <java/io/InterruptedIOException.h>\n #include <java/net/BindException.h>\n@@ -310,14 +312,14 @@ gnu::java::net::PlainSocketImpl::close()\n \n // Write a byte to the socket.\n void\n-gnu::java::net::PlainSocketImpl::write(jint b)\n+gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jint b)\n {\n   jbyte d =(jbyte) b;\n   int r = 0;\n \n   while (r != 1)\n     {\n-      r = _Jv_write (fnum, &d, 1);\n+      r = _Jv_write (this$0->fnum, &d, 1);\n       if (r == -1)\n         {\n           if (::java::lang::Thread::interrupted())\n@@ -338,7 +340,7 @@ gnu::java::net::PlainSocketImpl::write(jint b)\n \n // Write some bytes to the socket.\n void\n-gnu::java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n+gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jbyteArray b, jint offset, jint len)\n {\n   if (! b)\n     throw new ::java::lang::NullPointerException;\n@@ -350,7 +352,7 @@ gnu::java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n \n   while (len > 0)\n     {\n-      int r = _Jv_write (fnum, bytes, len);\n+      int r = _Jv_write (this$0->fnum, bytes, len);\n \n       if (r == -1)\n         {\n@@ -383,9 +385,11 @@ gnu::java::net::PlainSocketImpl::sendUrgentData (jint)\n \n // Read a single byte from the socket.\n jint\n-gnu::java::net::PlainSocketImpl::read(void)\n+gnu::java::net::PlainSocketImpl$SocketInputStream::read(void)\n {\n   jbyte b;\n+  jint timeout = this$0->timeout;\n+  jint fnum = this$0->fnum;\n \n   // Do timeouts via select.\n   if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n@@ -438,8 +442,12 @@ gnu::java::net::PlainSocketImpl::read(void)\n \n // Read count bytes into the buffer, starting at offset.\n jint\n-gnu::java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n+gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer, jint offset, \n+  jint count)\n {\n+  jint fnum = this$0->fnum;\n+  jint timeout = this$0->timeout;\n+\n   if (! buffer)\n     throw new ::java::lang::NullPointerException;\n "}, {"sha": "fc93e5713c724fe86ebaadb8090f85054dbc7c3f", "filename": "libjava/gnu/java/net/natPlainSocketImplWin32.cc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7fe786e1287f830952706fbd9ddb39077d70a9/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc?ref=9b7fe786e1287f830952706fbd9ddb39077d70a9", "patch": "@@ -346,14 +346,14 @@ gnu::java::net::PlainSocketImpl::close()\n \n // Write a byte to the socket.\n void\n-gnu::java::net::PlainSocketImpl::write(jint b)\n+gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jint b)\n {\n   jbyte d =(jbyte) b;\n   int r = 0;\n \n   while (r != 1)\n     {\n-      r = ::send (fnum, (char*) &d, 1, 0);\n+      r = ::send (this$0->fnum, (char*) &d, 1, 0);\n       if (r == -1)\n         {\n           DWORD dwErr = WSAGetLastError();\n@@ -376,7 +376,8 @@ gnu::java::net::PlainSocketImpl::write(jint b)\n \n // Write some bytes to the socket.\n void\n-gnu::java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n+gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jbyteArray b, \n+  jint offset, jint len)\n {\n   if (! b)\n     throw new ::java::lang::NullPointerException;\n@@ -387,7 +388,7 @@ gnu::java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n   int written = 0;\n   while (len > 0)\n     {\n-      int r = ::send (fnum, (char*) bytes, len, 0);\n+      int r = ::send (this$0->fnum, (char*) bytes, len, 0);\n \n       if (r == -1)\n         {\n@@ -479,16 +480,17 @@ doRead(int fnum, void* buf, int count, int timeout)\n \n // Read a single byte from the socket.\n jint\n-gnu::java::net::PlainSocketImpl::read(void)\n+gnu::java::net::PlainSocketImpl$SocketInputStream::read(void)\n {\n   jbyte b;\n-  doRead(fnum, &b, 1, timeout);\n+  doRead(this$0->fnum, &b, 1, this$0->timeout);\n   return b & 0xFF;\n }\n \n // Read count bytes into the buffer, starting at offset.\n jint\n-gnu::java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n+gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer,\n+  jint offset, jint count)\n {\n   if (! buffer)\n     throw new ::java::lang::NullPointerException;\n@@ -501,7 +503,7 @@ gnu::java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count\n   jbyte *bytes = elements (buffer) + offset;\n \n   // Read the socket.\n-  return doRead(fnum, bytes, count, timeout);\n+  return doRead(this$0->fnum, bytes, count, this$0->timeout);\n }\n \n // How many bytes are available?"}]}