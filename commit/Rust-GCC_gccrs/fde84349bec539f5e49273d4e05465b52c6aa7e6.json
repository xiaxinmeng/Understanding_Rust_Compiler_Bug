{"sha": "fde84349bec539f5e49273d4e05465b52c6aa7e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRlODQzNDliZWM1MzlmNWU0OTI3M2Q0ZTA1NDY1YjUyYzZhYTdlNg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-06T21:07:41Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-06T21:07:41Z"}, "message": "cpperror.c (print_containing_files): Moved to line-map.c.\n\n\t* cpperror.c (print_containing_files): Moved to line-map.c.\n\t(print_location): line-map.c handles re-listing or otherwise.\n\t* cpphash.h (struct lexer_state): Remove next_bol.\n\t(struct cpp_buffer): Remove include_stack_listed.\n\t* cpplib.c (do_line, cpp_push_buffer, _cpp_pop_buffer):\n\tRemove faked buffer handling.\n\t(_cpp_do_file_change): Tweak.\n\t* cpplib.h (enum cpp_buffer_type): Remove BUF_FAKE.\n\t* cppmain.c (struct printer): Remove filename.\n\t(print_line, cb_file_change): Update accordingly.\n\t* line-map.c: Include intl.h.\n\t(init_line_maps): Initialize last_listed.\n\t(free_line_maps): Sanity check, warn if ENABLED_CHECKING.\n\t(add_line_map): Sanity check inputs, warn if ENABLED_CHECKING.\n\t(print_containing_files): New.\n\t* line-map.h (struct line_maps): New member last_listed.\n\t(print_containing_files, INCLUDED_FROM): New.\n\t* Makefile.in: Update.\n\t* po/POTFILES.in: Add line-map.c.\n\nFrom-SVN: r44670", "tree": {"sha": "31a1005e7788f3f63227ac0f3097f1ff9111a46e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31a1005e7788f3f63227ac0f3097f1ff9111a46e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fde84349bec539f5e49273d4e05465b52c6aa7e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde84349bec539f5e49273d4e05465b52c6aa7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fde84349bec539f5e49273d4e05465b52c6aa7e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde84349bec539f5e49273d4e05465b52c6aa7e6/comments", "author": null, "committer": null, "parents": [{"sha": "df4556a3aaebc1b9e4da76be5ad806c431653eb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4556a3aaebc1b9e4da76be5ad806c431653eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4556a3aaebc1b9e4da76be5ad806c431653eb8"}], "stats": {"total": 349, "additions": 161, "deletions": 188}, "files": [{"sha": "b3cbf8bf87f981d57db311556b855b2a07b0b43b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -1,3 +1,25 @@\n+2001-08-06  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpperror.c (print_containing_files): Moved to line-map.c.\n+\t(print_location): line-map.c handles re-listing or otherwise.\n+\t* cpphash.h (struct lexer_state): Remove next_bol.\n+\t(struct cpp_buffer): Remove include_stack_listed.\n+\t* cpplib.c (do_line, cpp_push_buffer, _cpp_pop_buffer):\n+\tRemove faked buffer handling.\n+\t(_cpp_do_file_change): Tweak.\n+\t* cpplib.h (enum cpp_buffer_type): Remove BUF_FAKE.\n+\t* cppmain.c (struct printer): Remove filename.\n+\t(print_line, cb_file_change): Update accordingly.\n+\t* line-map.c: Include intl.h.\n+\t(init_line_maps): Initialize last_listed.\n+\t(free_line_maps): Sanity check, warn if ENABLED_CHECKING.\n+\t(add_line_map): Sanity check inputs, warn if ENABLED_CHECKING.\n+\t(print_containing_files): New.\n+\t* line-map.h (struct line_maps): New member last_listed.\n+\t(print_containing_files, INCLUDED_FROM): New.\n+\t* Makefile.in: Update.\n+\t* po/POTFILES.in: Add line-map.c.\n+\n 2001-08-06  Richard Henderson  <rth@redhat.com>\n \n \t* except.c (convert_from_eh_region_ranges_1): Never mark"}, {"sha": "eca0b961a2f566d8eb1cbf5ca06da09bde8c2f68", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -1325,7 +1325,7 @@ stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n \n hashtable.o: hashtable.c hashtable.h $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H)\n \n-line-map.o: line-map.c line-map.h $(CONFIG_H) $(SYSTEM_H)\n+line-map.o: line-map.c line-map.h intl.h $(CONFIG_H) $(SYSTEM_H)\n \n ggc-none.o: ggc-none.c $(GCONFIG_H) $(SYSTEM_H) $(GGC_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)"}, {"sha": "167ea9d46a5e69dfcd5b6e48dc308911e9d646aa", "filename": "gcc/cpperror.c", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -29,8 +29,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpphash.h\"\n #include \"intl.h\"\n \n-static void print_containing_files\tPARAMS ((struct line_map *,\n-\t\t\t\t\t\t struct line_map *));\n static void print_location\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const char *,\n \t\t\t\t\t\t const cpp_lexer_pos *));\n@@ -40,49 +38,6 @@ static void print_location\t\tPARAMS ((cpp_reader *,\n #define v_message(msgid, ap) \\\n  do { vfprintf (stderr, _(msgid), ap); putc ('\\n', stderr); } while (0)\n \n-/* Print the file names and line numbers of the #include\n-   commands which led to the current file.  */\n-static void\n-print_containing_files (map_array, map)\n-     struct line_map *map_array;\n-     struct line_map *map;\n-{\n-  int first = 1;\n-\n-  for (;;)\n-    {\n-      if (MAIN_FILE_P (map))\n-\tbreak;\n-      map = &map_array[map->included_from];\n-\n-      if (first)\n-\t{\n-\t  first = 0;\n-\t  /* The current line in each outer source file is now the\n-\t     same as the line of the #include.  */\n-\t  fprintf (stderr,  _(\"In file included from %s:%u\"),\n-\t\t   map->to_file, LAST_SOURCE_LINE (map));\n-\t}\n-      else\n-\t/* Translators note: this message is used in conjunction\n-\t   with \"In file included from %s:%ld\" and some other\n-\t   tricks.  We want something like this:\n-\n-\t   | In file included from sys/select.h:123,\n-\t   |                  from sys/types.h:234,\n-\t   |                  from userfile.c:31:\n-\t   | bits/select.h:45: <error message here>\n-\n-\t   with all the \"from\"s lined up.\n-\t   The trailing comma is at the beginning of this message,\n-\t   and the trailing colon is not translated.  */\n-\tfprintf (stderr, _(\",\\n                 from %s:%u\"),\n-\t\t map->to_file, LAST_SOURCE_LINE (map));\n-    }\n-\n-  fputs (\":\\n\", stderr);\n-}\n-\n static void\n print_location (pfile, filename, pos)\n      cpp_reader *pfile;\n@@ -122,12 +77,7 @@ print_location (pfile, filename, pos)\n \t  if (col == 0)\n \t    col = 1;\n \n-\t  /* Don't repeat the include stack unnecessarily.  */\n-\t  if (buffer->prev && ! buffer->include_stack_listed)\n-\t    {\n-\t      buffer->include_stack_listed = 1;\n-\t      print_containing_files (pfile->line_maps.maps, map);\n-\t    }\n+\t  print_containing_files (&pfile->line_maps, map);\n \t}\n \n       if (filename == 0)"}, {"sha": "5409e070569808be0a8c3c5c6fc7090d5ff68f55", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -131,9 +131,6 @@ struct lexer_state\n      all directives apart from #define.  */\n   unsigned char save_comments;\n \n-  /* If nonzero the next token is at the beginning of the line.  */\n-  unsigned char next_bol;\n-\n   /* Nonzero if we're mid-comment.  */\n   unsigned char lexing_comment;\n \n@@ -219,10 +216,6 @@ struct cpp_buffer\n   /* 1 = system header file, 2 = C system header file used for C++.  */\n   unsigned char sysp;\n \n-  /* Nonzero means we have printed (while error reporting) a list of\n-     containing files that matches the current status.  */\n-  unsigned char include_stack_listed;\n-\n   /* Nonzero means that the directory to start searching for \"\"\n      include files has been calculated and stored in \"dir\" below.  */\n   unsigned char search_cached;"}, {"sha": "4710beb6ced3f4dc4a7b309850d8a42480543f3a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 44, "deletions": 111, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -736,19 +736,19 @@ do_line (pfile)\n   cpp_get_token (pfile, &token);\n   if (token.type == CPP_STRING)\n     {\n-      const char *fname = (const char *) token.val.str.text;\n+      buffer->nominal_fname = (const char *) token.val.str.text;\n \n       /* Only accept flags for the # 55 form.  */\n-      if (! pfile->state.line_extension)\n-\tcheck_eol (pfile);\n-      else\n+      if (pfile->state.line_extension)\n \t{\n \t  int flag = 0, sysp = 0;\n \n \t  flag = read_flag (pfile, flag);\n \t  if (flag == 1)\n \t    {\n \t      reason = LC_ENTER;\n+\t      /* Fake an include for cpp_included ().  */\n+\t      _cpp_fake_include (pfile, buffer->nominal_fname);\n \t      flag = read_flag (pfile, flag);\n \t    }\n \t  else if (flag == 2)\n@@ -761,43 +761,11 @@ do_line (pfile)\n \t      sysp = 1;\n \t      flag = read_flag (pfile, flag);\n \t      if (flag == 4)\n-\t\tsysp = 2, read_flag (pfile, flag);\n-\t    }\n-\n-\t  if (reason == LC_ENTER)\n-\t    {\n-\t      /* Fake a buffer stack for diagnostics.  */\n-\t      cpp_push_buffer (pfile, 0, 0, BUF_FAKE, fname, 0);\n-\t      /* Fake an include for cpp_included.  */\n-\t      _cpp_fake_include (pfile, fname);\n-\t      buffer = pfile->buffer;\n-\t    }\n-\t  else if (reason == LC_LEAVE)\n-\t    {\n-\t      if (buffer->type != BUF_FAKE)\n-\t\t{\n-\t\t  cpp_warning (pfile, \"file \\\"%s\\\" left but not entered\",\n-\t\t\t       buffer->nominal_fname);\n-\t\t  reason = LC_RENAME;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  _cpp_pop_buffer (pfile);\n-\t\t  pfile->lexer_pos.output_line++;\n-\t\t  buffer = pfile->buffer;\n-#ifdef ENABLE_CHECKING\n-\t\t  if (strcmp (buffer->nominal_fname, fname))\n-\t\t    cpp_warning (pfile, \"expected to return to file \\\"%s\\\"\",\n-\t\t\t\t buffer->nominal_fname);\n-\t\t  if (buffer->sysp != sysp)\n-\t\t    cpp_warning (pfile, \"header flags for \\\"%s\\\" have changed\",\n-\t\t\t\t buffer->nominal_fname);\n-#endif\n-\t\t}\n+\t\tsysp = 2;\n \t    }\n \t  buffer->sysp = sysp;\n \t}\n-      buffer->nominal_fname = fname;\n+      check_eol (pfile);\n     }\n   else if (token.type != CPP_EOF)\n     {\n@@ -818,9 +786,8 @@ _cpp_do_file_change (pfile, reason, file_line)\n      enum lc_reason reason;\n      unsigned int file_line;\n {\n-  cpp_buffer *buffer;\n-\n-  buffer = pfile->buffer;\n+  cpp_buffer *buffer = pfile->buffer;\n+  \n   pfile->map = add_line_map (&pfile->line_maps, reason,\n \t\t\t     pfile->line, buffer->nominal_fname, file_line);\n \n@@ -1785,36 +1752,27 @@ cpp_push_buffer (pfile, buffer, len, type, filename, return_at_eof)\n {\n   cpp_buffer *new = xobnew (&pfile->buffer_ob, cpp_buffer);\n \n-  if (type == BUF_FAKE)\n-    {\n-      /* A copy of the current buffer, just with a new name and type.  */\n-      memcpy (new, pfile->buffer, sizeof (cpp_buffer));\n-      new->type = BUF_FAKE;\n-    }\n-  else\n-    {\n-      if (type == BUF_BUILTIN)\n-\tfilename = _(\"<builtin>\");\n-      else if (type == BUF_CL_OPTION)\n-\tfilename = _(\"<command line>\");\n-      else if (type == BUF_PRAGMA)\n-\tfilename = \"<_Pragma>\";\n-\n-      /* Clears, amongst other things, if_stack and mi_cmacro.  */\n-      memset (new, 0, sizeof (cpp_buffer));\n-\n-      new->line_base = new->buf = new->cur = buffer;\n-      new->rlimit = buffer + len;\n-      new->sysp = 0;\n-\n-      /* No read ahead or extra char initially.  */\n-      new->read_ahead = EOF;\n-      new->extra_char = EOF;\n-\n-      /* Preprocessed files, builtins, _Pragma and command line\n-\t options don't do trigraph and escaped newline processing.  */\n-      new->from_stage3 = type != BUF_FILE || CPP_OPTION (pfile, preprocessed);\n-    }\n+  if (type == BUF_BUILTIN)\n+    filename = _(\"<builtin>\");\n+  else if (type == BUF_CL_OPTION)\n+    filename = _(\"<command line>\");\n+  else if (type == BUF_PRAGMA)\n+    filename = \"<_Pragma>\";\n+\n+  /* Clears, amongst other things, if_stack and mi_cmacro.  */\n+  memset (new, 0, sizeof (cpp_buffer));\n+\n+  new->line_base = new->buf = new->cur = buffer;\n+  new->rlimit = buffer + len;\n+  new->sysp = 0;\n+\n+  /* No read ahead or extra char initially.  */\n+  new->read_ahead = EOF;\n+  new->extra_char = EOF;\n+\n+  /* Preprocessed files, builtins, _Pragma and command line\n+     options don't do trigraph and escaped newline processing.  */\n+  new->from_stage3 = type != BUF_FILE || CPP_OPTION (pfile, preprocessed);\n \n   if (*filename == '\\0')\n     new->nominal_fname = _(\"<stdin>\");\n@@ -1823,10 +1781,8 @@ cpp_push_buffer (pfile, buffer, len, type, filename, return_at_eof)\n   new->type = type;\n   new->prev = pfile->buffer;\n   new->pfile = pfile;\n-  new->include_stack_listed = 0;\n   new->return_at_eof = return_at_eof;\n \n-  pfile->state.next_bol = 1;\n   pfile->buffer_stack_depth++;\n   pfile->buffer = new;\n \n@@ -1840,49 +1796,26 @@ void\n _cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer;\n+  cpp_buffer *buffer = pfile->buffer;\n   struct if_stack *ifs;\n \n-  for (;;)\n-    {\n-      buffer = pfile->buffer;\n-      /* Walk back up the conditional stack till we reach its level at\n-\t entry to this file, issuing error messages.  */\n-      for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n-\tcpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n-\t\t\t     \"unterminated #%s\", dtable[ifs->type].name);\n-\n-      if (buffer->type == BUF_FAKE)\n-\t{\n-\t  buffer->prev->cur = buffer->cur;\n-\t  buffer->prev->line_base = buffer->line_base;\n-\t  buffer->prev->read_ahead = buffer->read_ahead;\n-\t}\n-      else if (buffer->type == BUF_FILE)\n-\t_cpp_pop_file_buffer (pfile, buffer);\n-\n-      pfile->buffer = buffer->prev;\n-      pfile->buffer_stack_depth--;\n-\n-      /* Callbacks only generated for faked or real files.  */\n-      if (buffer->type != BUF_FILE && buffer->type != BUF_FAKE)\n-\tbreak;\n-\t  \n-      /* No callback for EOF of last file.  */\n-      if (!pfile->buffer)\n-\tbreak;\n+  /* Walk back up the conditional stack till we reach its level at\n+     entry to this file, issuing error messages.  */\n+  for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n+    cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n-      /* do_line does its own call backs.  */\n-      pfile->buffer->include_stack_listed = 0;\n-      if (pfile->directive == &dtable[T_LINE])\n-\tbreak;\n+  /* Update the reader's buffer before _cpp_do_file_change.  */\n+  pfile->buffer = buffer->prev;\n+  pfile->buffer_stack_depth--;\n \n-      _cpp_do_file_change (pfile, LC_LEAVE, pfile->buffer->return_to_line);\n-      if (pfile->buffer->type == BUF_FILE)\n-\tbreak;\n+  if (buffer->type == BUF_FILE)\n+    {\n+      /* Callbacks are not generated for popping the main file.  */\n+      if (buffer->prev)\n+\t_cpp_do_file_change (pfile, LC_LEAVE, buffer->prev->return_to_line);\n \n-      cpp_warning (pfile, \"file \\\"%s\\\" entered but not left\",\n-\t\t   buffer->nominal_fname);\n+      _cpp_pop_file_buffer (pfile, buffer);\n     }\n \n   obstack_free (&pfile->buffer_ob, buffer);"}, {"sha": "29f20d7cb65c734b8493ff9a59dac3736f9b8334", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -416,10 +416,9 @@ struct cpp_callbacks\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n-/* Where does this buffer come from?  A faked include, a source file,\n-   a builtin macro, a command-line option, or a _Pragma operator.  */\n-enum cpp_buffer_type {BUF_FAKE, BUF_FILE, BUF_BUILTIN,\n-\t\t      BUF_CL_OPTION, BUF_PRAGMA};\n+/* Where does this buffer come from?  A source file, a builtin macro,\n+   a command-line option, or a _Pragma operator.  */\n+enum cpp_buffer_type {BUF_FILE, BUF_BUILTIN, BUF_CL_OPTION, BUF_PRAGMA};\n \n /* The structure of a node in the hash table.  The hash table has\n    entries for all identifiers: either macros defined by #define"}, {"sha": "978c6447b57b9668d3156d14377d8c738c06bb43", "filename": "gcc/cppmain.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -31,7 +31,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n struct printer\n {\n   FILE *outf;\t\t\t/* Stream to write to.  */\n-  const char *filename;\t\t/* Name of current file.  */\n   const char *syshdr_flags;\t/* System header flags, if any.  */\n   unsigned int line;\t\t/* Line currently being written.  */\n   unsigned char printed;\t/* Nonzero if something output at line.  */\n@@ -81,8 +80,7 @@ main (argc, argv)\n   \n   do_preprocessing (argc, argv);\n \n-  /* Call to cpp_destroy () omitted for performance reasons.  */\n-  if (cpp_errors (pfile))\n+  if (cpp_destroy (pfile))\n     return FATAL_EXIT_CODE;\n \n   return SUCCESS_EXIT_CODE;\n@@ -328,7 +326,7 @@ print_line (line, special_flags)\n   if (! options->no_line_commands)\n     fprintf (print.outf, \"# %u \\\"%s\\\"%s%s\\n\",\n \t     SOURCE_LINE (print.map, print.line),\n-\t     print.filename, special_flags, print.syshdr_flags);\n+\t     print.map->to_file, special_flags, print.syshdr_flags);\n }\n \n /* Callbacks.  */\n@@ -400,7 +398,6 @@ cb_file_change (pfile, fc)\n     maybe_print_line (fc->line - 1);\n \n   print.map = fc->map;\n-  print.filename = fc->map->to_file;\n   if (fc->externc)\n     print.syshdr_flags = \" 3 4\";\n   else if (fc->sysp)"}, {"sha": "1cd1bfdfc0f10cd567ecdec704d4b697a09bf299", "filename": "gcc/line-map.c", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.c?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -23,6 +23,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"config.h\"\n #include \"system.h\"\n #include \"line-map.h\"\n+#include \"intl.h\"\n \n /* Initialize a line map set.  */\n \n@@ -33,15 +34,27 @@ init_line_maps (set)\n   set->maps = 0;\n   set->allocated = 0;\n   set->used = 0;\n+  set->last_listed = -1;\n }\n \n /* Free a line map set.  */\n \n-void free_line_maps (set)\n+void\n+free_line_maps (set)\n      struct line_maps *set;\n {\n   if (set->maps)\n-    free (set->maps);\n+    {\n+#ifdef ENABLE_CHECKING\n+      struct line_map *map;\n+\n+      for (map = CURRENT_LINE_MAP (set); ! MAIN_FILE_P (map);\n+\t   map = INCLUDED_FROM (set, map))\n+\tfprintf (stderr, \"line-map.c: file \\\"%s\\\" entered but not left\\n\",\n+\t\t map->to_file);\n+#endif\n+      free (set->maps);\n+    }\n }\n \n /* Add a mapping of logical source line to physical source file and\n@@ -76,18 +89,29 @@ add_line_map (set, reason, from_line, to_file, to_line)\n   map->to_file = to_file;\n   map->to_line = to_line;\n \n+  /* If we don't keep our line maps consistent, we can easily\n+     segfault.  Don't rely on the client to do it for us.  */\n   if (set->used == 0)\n-    map->included_from = -1;\n-  else if (reason == LC_ENTER)\n+    reason = LC_ENTER;\n+  else if (reason == LC_LEAVE)\n+    {\n+      if (MAIN_FILE_P (map - 1)\n+\t  || strcmp (INCLUDED_FROM (set, map - 1)->to_file, to_file))\n+\t{\n+#ifdef ENABLE_CHECKING\n+\t  fprintf (stderr, \"line-map.c: file \\\"%s\\\" left but not entered\\n\",\n+\t\t   to_file);\n+#endif\n+\t  reason = LC_RENAME;\n+\t}\n+    }\n+\n+  if (reason == LC_ENTER)\n     map->included_from = set->used - 1;\n   else if (reason == LC_RENAME)\n     map->included_from = map[-1].included_from;\n   else if (reason == LC_LEAVE)\n-    {\n-      if (map[-1].included_from < 0)\n-\tabort ();\n-      map->included_from = set->maps[map[-1].included_from].included_from;\n-    }\n+    map->included_from = INCLUDED_FROM (set, map - 1)->included_from;\n \n   set->used++;\n   return map;\n@@ -119,3 +143,43 @@ lookup_line (set, line)\n \n   return &set->maps[mn];\n }\n+\n+/* Print the file names and line numbers of the #include commands\n+   which led to the map MAP, if any, to stderr.  Nothing is output if\n+   the most recently listed stack is the same as the current one.  */\n+\n+void\n+print_containing_files (set, map)\n+     struct line_maps *set;\n+     struct line_map *map;\n+{\n+  if (MAIN_FILE_P (map) || set->last_listed == map->included_from)\n+    return;\n+\n+  set->last_listed = map->included_from;\n+  map = INCLUDED_FROM (set, map);\n+\n+  fprintf (stderr,  _(\"In file included from %s:%u\"),\n+\t   map->to_file, LAST_SOURCE_LINE (map));\n+\n+  while (! MAIN_FILE_P (map))\n+    {\n+      map = INCLUDED_FROM (set, map);\n+      /* Translators note: this message is used in conjunction\n+\t with \"In file included from %s:%ld\" and some other\n+\t tricks.  We want something like this:\n+\n+\t | In file included from sys/select.h:123,\n+\t |                  from sys/types.h:234,\n+\t |                  from userfile.c:31:\n+\t | bits/select.h:45: <error message here>\n+\n+\t with all the \"from\"s lined up.\n+\t The trailing comma is at the beginning of this message,\n+\t and the trailing colon is not translated.  */\n+      fprintf (stderr, _(\",\\n                 from %s:%u\"),\n+\t       map->to_file, LAST_SOURCE_LINE (map));\n+    }\n+\n+  fputs (\":\\n\", stderr);\n+}"}, {"sha": "d5705c7561485300cdb577ae560cf2fe933fcace", "filename": "gcc/line-map.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -42,6 +42,11 @@ struct line_maps\n   struct line_map *maps;\n   unsigned int allocated;\n   unsigned int used;\n+\n+  /* The most recently listed include stack, if any, starts with\n+     LAST_LISTED as the topmost including file.  -1 indicates nothing\n+     has been listed yet.  */\n+  int last_listed;\n };\n \n /* Reason for adding a line change with add_line_map ().  LC_ENTER is\n@@ -74,13 +79,22 @@ extern struct line_map *add_line_map\n extern struct line_map *lookup_line\n   PARAMS ((struct line_maps *, unsigned int));\n \n+/* Print the file names and line numbers of the #include commands\n+   which led to the map MAP, if any, to stderr.  Nothing is output if\n+   the most recently listed stack is the same as the current one.  */\n+extern void print_containing_files\n+  PARAMS ((struct line_maps *, struct line_map *));\n+\n /* Converts a map and logical line to source line.  */\n #define SOURCE_LINE(MAP, LINE) ((LINE) + (MAP)->to_line - (MAP)->from_line)\n \n /* Returns the last source line within a map.  This is the (last) line\n    of the #include, or other directive, that caused a map change.  */\n #define LAST_SOURCE_LINE(MAP) SOURCE_LINE ((MAP), (MAP)[1].from_line - 1)\n \n+/* Returns the map a given map was included from.  */\n+#define INCLUDED_FROM(SET, MAP) (&(SET)->maps[(MAP)->included_from])\n+\n /* Non-zero if the map is at the bottom of the include stack.  */\n #define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n "}, {"sha": "67a53801a56cf52f6fb62b0a6315db4a95642728", "filename": "gcc/po/POTFILES.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fpo%2FPOTFILES.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde84349bec539f5e49273d4e05465b52c6aa7e6/gcc%2Fpo%2FPOTFILES.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FPOTFILES.in?ref=fde84349bec539f5e49273d4e05465b52c6aa7e6", "patch": "@@ -941,6 +941,7 @@ lcm.c\n #libgcc2.h is part of the GCC library\n #limitx.h is part of the GCC library\n #limity.h is part of the GCC library\n+line-map.c\n lists.c\n local-alloc.c\n #longlong.h is part of the GCC library"}]}