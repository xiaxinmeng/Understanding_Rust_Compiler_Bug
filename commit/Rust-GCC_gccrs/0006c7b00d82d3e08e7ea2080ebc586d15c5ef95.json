{"sha": "0006c7b00d82d3e08e7ea2080ebc586d15c5ef95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwNmM3YjAwZDgyZDNlMDhlN2VhMjA4MGViYzU4NmQxNWM1ZWY5NQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-01-10T19:21:46Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-01-10T19:21:46Z"}, "message": "re PR libgcj/18868 (Interface containing anonymous class breaks gij)\n\n\tPR libgcj/18868:\n\t* include/jvm.h (_Jv_Linker::find_field): Declare.\n\t(_Jv_Linker::find_field_helper): Likewise.\n\t* link.cc (find_field_helper): New method.\n\t(find_field): Likewise.\n\t(resolve_pool_entry): Use it.  Throw NoSuchFieldError when field\n\tnot found.\n\t(link_symbol_table): Use find_field.\n\nFrom-SVN: r93151", "tree": {"sha": "63bb017144567983b5a4c2149963792d88f6d90d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63bb017144567983b5a4c2149963792d88f6d90d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95/comments", "author": null, "committer": null, "parents": [{"sha": "8a7f33c709536358ef22e939da5c9a7d18a938ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7f33c709536358ef22e939da5c9a7d18a938ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a7f33c709536358ef22e939da5c9a7d18a938ee"}], "stats": {"total": 288, "additions": 134, "deletions": 154}, "files": [{"sha": "17f4d64cf2242e8f3f7caf672f8987bdfa14e913", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0006c7b00d82d3e08e7ea2080ebc586d15c5ef95", "patch": "@@ -1,3 +1,14 @@\n+2005-01-10  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/18868:\n+\t* include/jvm.h (_Jv_Linker::find_field): Declare.\n+\t(_Jv_Linker::find_field_helper): Likewise.\n+\t* link.cc (find_field_helper): New method.\n+\t(find_field): Likewise.\n+\t(resolve_pool_entry): Use it.  Throw NoSuchFieldError when field\n+\tnot found.\n+\t(link_symbol_table): Use find_field.\n+\n 2005-01-10  Michael Koch  <konqueror@gmx.de>\n \n \tPR libgcj/18014"}, {"sha": "52471bfac9a75bb5bb6bc583c9d678a33d0aecf1", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=0006c7b00d82d3e08e7ea2080ebc586d15c5ef95", "patch": "@@ -1,6 +1,6 @@\n // jvm.h - Header file for private implementation information. -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -250,6 +250,9 @@ namespace gcj\n class _Jv_Linker\n {\n private:\n+  static _Jv_Field *find_field_helper(jclass, _Jv_Utf8Const *, jclass *);\n+  static _Jv_Field *find_field(jclass, jclass, _Jv_Utf8Const *,\n+\t\t\t       _Jv_Utf8Const *);\n   static void prepare_constant_time_tables(jclass);\n   static jshort get_interfaces(jclass, _Jv_ifaces *);\n   static void link_symbol_table(jclass);"}, {"sha": "b0559c4fc00dd162367d181d8b01fb2a173dfb15", "filename": "libjava/link.cc", "status": "modified", "additions": 119, "deletions": 153, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0006c7b00d82d3e08e7ea2080ebc586d15c5ef95/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=0006c7b00d82d3e08e7ea2080ebc586d15c5ef95", "patch": "@@ -1,6 +1,6 @@\n // link.cc - Code for linking and resolving classes and pool entries.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -94,6 +94,109 @@ _Jv_Linker::resolve_field (_Jv_Field *field, java::lang::ClassLoader *loader)\n     }\n }\n \n+// A helper for find_field that knows how to recursively search\n+// superclasses and interfaces.\n+_Jv_Field *\n+_Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n+\t\t\t       jclass *declarer)\n+{\n+  while (search)\n+    {\n+      // From 5.4.3.2.  First search class itself.\n+      for (int i = 0; i < search->field_count; ++i)\n+\t{\n+\t  _Jv_Field *field = &search->fields[i];\n+\t  if (_Jv_equalUtf8Consts (field->name, name))\n+\t    {\n+\t      *declarer = search;\n+\t      return field;\n+\t    }\n+\t}\n+\n+      // Next search direct interfaces.\n+      for (int i = 0; i < search->interface_count; ++i)\n+\t{\n+\t  _Jv_Field *result = find_field_helper (search->interfaces[i], name,\n+\t\t\t\t\t\t declarer);\n+\t  if (result)\n+\t    return result;\n+\t}\n+\n+      // Now search superclass.\n+      search = search->superclass;\n+    }\n+\n+  return NULL;\n+}\n+\n+// Find a field.\n+// KLASS is the class that is requesting the field.\n+// OWNER is the class in which the field should be found.\n+// FIELD_TYPE_NAME is the type descriptor for the field.\n+// This function does the class loader type checks, and\n+// also access checks.  Returns the field, or throws an\n+// exception on error.\n+_Jv_Field *\n+_Jv_Linker::find_field (jclass klass, jclass owner,\n+\t\t\t_Jv_Utf8Const *field_name,\n+\t\t\t_Jv_Utf8Const *field_type_name)\n+{\n+  jclass field_type = 0;\n+\n+  if (owner->loader != klass->loader)\n+    {\n+      // FIXME: The implementation of this function\n+      // (_Jv_FindClassFromSignature) will generate an instance of\n+      // _Jv_Utf8Const for each call if the field type is a class name\n+      // (Lxx.yy.Z;).  This may be too expensive to do for each and\n+      // every fieldref being resolved.  For now, we fix the problem\n+      // by only doing it when we have a loader different from the\n+      // class declaring the field.\n+      field_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n+\t\t\t\t\t       klass->loader);\n+    }\n+\n+  jclass found_class = 0;\n+  _Jv_Field *the_field = find_field_helper (owner, field_name, &found_class);\n+\n+  if (the_field == 0)\n+    {\n+      java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n+      sb->append(JvNewStringLatin1(\"field \"));\n+      sb->append(owner->getName());\n+      sb->append(JvNewStringLatin1(\".\"));\n+      sb->append(_Jv_NewStringUTF(field_name->chars()));\n+      sb->append(JvNewStringLatin1(\" was not found.\"));\n+      throw new java::lang::NoSuchFieldError (sb->toString());\n+    }\n+\n+  if (_Jv_CheckAccess (klass, found_class, the_field->flags))\n+    {\n+      // Resolve the field using the class' own loader if necessary.\n+\n+      if (!the_field->isResolved ())\n+\tresolve_field (the_field, found_class->loader);\n+\n+      if (field_type != 0 && the_field->type != field_type)\n+\tthrow new java::lang::LinkageError\n+\t  (JvNewStringLatin1 \n+\t   (\"field type mismatch with different loaders\"));\n+    }\n+  else\n+    {\n+      java::lang::StringBuffer *sb\n+\t= new java::lang::StringBuffer ();\n+      sb->append(klass->getName());\n+      sb->append(JvNewStringLatin1(\": \"));\n+      sb->append(found_class->getName());\n+      sb->append(JvNewStringLatin1(\".\"));\n+      sb->append(_Jv_NewStringUtf8Const (field_name));\n+      throw new java::lang::IllegalAccessError(sb->toString());\n+    }\n+\n+  return the_field;\n+}\n+\n _Jv_word\n _Jv_Linker::resolve_pool_entry (jclass klass, int index)\n {\n@@ -173,72 +276,8 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index)\n \t_Jv_Utf8Const *field_name = pool->data[name_index].utf8;\n \t_Jv_Utf8Const *field_type_name = pool->data[type_index].utf8;\n \n-\t// FIXME: The implementation of this function\n-\t// (_Jv_FindClassFromSignature) will generate an instance of\n-\t// _Jv_Utf8Const for each call if the field type is a class name\n-\t// (Lxx.yy.Z;).  This may be too expensive to do for each and\n-\t// every fieldref being resolved.  For now, we fix the problem by\n-\t// only doing it when we have a loader different from the class\n-\t// declaring the field.\n-\n-\tjclass field_type = 0;\n-\n-\tif (owner->loader != klass->loader)\n-\t  field_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n-\t\t\t\t\t\t   klass->loader);\n-      \n-\t_Jv_Field* the_field = 0;\n-\n-\tfor (jclass cls = owner; cls != 0; cls = cls->getSuperclass ())\n-\t  {\n-\t    for (int i = 0;  i < cls->field_count;  i++)\n-\t      {\n-\t\t_Jv_Field *field = &cls->fields[i];\n-\t\tif (! _Jv_equalUtf8Consts (field->name, field_name))\n-\t\t  continue;\n-\n-\t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n-\t\t  {\n-\t\t    // Resolve the field using the class' own loader if\n-\t\t    // necessary.\n-\n-\t\t    if (!field->isResolved ())\n-\t\t      resolve_field (field, cls->loader);\n-\n-\t\t    if (field_type != 0 && field->type != field_type)\n-\t\t      throw new java::lang::LinkageError\n-\t\t\t(JvNewStringLatin1 \n-\t\t\t (\"field type mismatch with different loaders\"));\n-\n-\t\t    the_field = field;\n-\t\t    goto end_of_field_search;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    java::lang::StringBuffer *sb\n-\t\t      = new java::lang::StringBuffer ();\n-\t\t    sb->append(klass->getName());\n-\t\t    sb->append(JvNewStringLatin1(\": \"));\n-\t\t    sb->append(cls->getName());\n-\t\t    sb->append(JvNewStringLatin1(\".\"));\n-\t\t    sb->append(_Jv_NewStringUtf8Const (field_name));\n-\t\t    throw new java::lang::IllegalAccessError(sb->toString());\n-\t\t  }\n-\t      }\n-\t  }\n-\n-      end_of_field_search:\n-\tif (the_field == 0)\n-\t  {\n-\t    java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n-\t    sb->append(JvNewStringLatin1(\"field \"));\n-\t    sb->append(owner->getName());\n-\t    sb->append(JvNewStringLatin1(\".\"));\n-\t    sb->append(_Jv_NewStringUTF(field_name->chars()));\n-\t    sb->append(JvNewStringLatin1(\" was not found.\"));\n-\t    throw\n-\t      new java::lang::IncompatibleClassChangeError (sb->toString());\n-\t  }\n+\t_Jv_Field *the_field = find_field (klass, owner, field_name,\n+\t\t\t\t\t   field_type_name);\n \n \tpool->data[index].field = the_field;\n \tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n@@ -296,7 +335,7 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index)\n \t    ifaces.list = (jclass *) _Jv_Malloc (ifaces.len\n \t\t\t\t\t\t * sizeof (jclass *));\n \n-\t    get_interfaces (owner, &ifaces);\t  \n+\t    get_interfaces (owner, &ifaces);\n \n \t    for (int i = 0; i < ifaces.count; i++)\n \t      {\n@@ -885,55 +924,15 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t  continue;\n \t}\n \n-      // try fields\n+      // Try fields.\n       {\n-\t_Jv_Field *the_field = NULL;\n-\n \twait_for_state(target_class, JV_STATE_PREPARED);\n-\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n-\t  {\n-\t    for (int i = 0; i < cls->field_count; i++)\n-\t      {\n-\t\t_Jv_Field *field = &cls->fields[i];\n-\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n-\t\t  continue;\n-\n-\t\t// FIXME: What access checks should we perform here?\n-// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n-// \t\t  {\n-\n-\t\tif (!field->isResolved ())\n-\t\t  resolve_field (field, cls->loader);\n-\n-// \t\tif (field_type != 0 && field->type != field_type)\n-// \t\t  throw new java::lang::LinkageError\n-// \t\t    (JvNewStringLatin1 \n-// \t\t     (\"field type mismatch with different loaders\"));\n-\n-\t\tthe_field = field;\n-\t\tif (debug_link)\n-\t\t  fprintf (stderr, \"  offsets[%d] = %d (class %s@%p : %s)\\n\",\n-\t\t\t   (int)index,\n-\t\t\t   (int)field->u.boffset,\n-\t\t\t   (const char*)cls->name->chars(),\n-\t\t\t   cls,\n-\t\t\t   (const char*)field->name->chars());\n-\t\tgoto end_of_field_search;\n-\t      }\n-\t  }\n-      end_of_field_search:\n-\tif (the_field != NULL)\n-\t  {\n-\t    if ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n-\t      throw new java::lang::IncompatibleClassChangeError;\n-\t    else\n-\t      klass->otable->offsets[index] = the_field->u.boffset;\n-\t  }\n+\t_Jv_Field *the_field = find_field (klass, target_class,\n+\t\t\t\t\t   sym.name, sym.signature);\n+\tif ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n+\t  throw new java::lang::IncompatibleClassChangeError;\n \telse\n-\t  {\n-\t    throw new java::lang::NoSuchFieldError\n-\t      (_Jv_NewStringUtf8Const (sym.name));\n-\t  }\n+\t  klass->otable->offsets[index] = the_field->u.boffset;\n       }\n     }\n \n@@ -1005,48 +1004,15 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t  continue;\n \t}\n \n-      // try fields\n+      // Try fields.\n       {\n-\t_Jv_Field *the_field = NULL;\n-\n \twait_for_state(target_class, JV_STATE_PREPARED);\n-\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n-\t  {\n-\t    for (int i = 0; i < cls->field_count; i++)\n-\t      {\n-\t\t_Jv_Field *field = &cls->fields[i];\n-\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n-\t\t  continue;\n-\n-\t\t// FIXME: What access checks should we perform here?\n-// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n-// \t\t  {\n-\n-\t\tif (!field->isResolved ())\n-\t\t  resolve_field (field, cls->loader);\n-\n-// \t\tif (field_type != 0 && field->type != field_type)\n-// \t\t  throw new java::lang::LinkageError\n-// \t\t    (JvNewStringLatin1 \n-// \t\t     (\"field type mismatch with different loaders\"));\n-\n-\t\tthe_field = field;\n-\t\tgoto end_of_static_field_search;\n-\t      }\n-\t  }\n-      end_of_static_field_search:\n-\tif (the_field != NULL)\n-\t  {\n-\t    if ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n-\t      klass->atable->addresses[index] = the_field->u.addr;\n-\t    else\n-\t      throw new java::lang::IncompatibleClassChangeError;\n-\t  }\n+\t_Jv_Field *the_field = find_field (klass, target_class,\n+\t\t\t\t\t   sym.name, sym.signature);\n+\tif ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n+\t  klass->atable->addresses[index] = the_field->u.addr;\n \telse\n-\t  {\n-\t    throw new java::lang::NoSuchFieldError\n-\t      (_Jv_NewStringUtf8Const (sym.name));\n-\t  }\n+\t  throw new java::lang::IncompatibleClassChangeError;\n       }\n     }\n "}]}