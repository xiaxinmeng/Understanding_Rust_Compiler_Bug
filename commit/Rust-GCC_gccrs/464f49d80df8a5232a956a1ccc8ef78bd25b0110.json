{"sha": "464f49d80df8a5232a956a1ccc8ef78bd25b0110", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY0ZjQ5ZDgwZGY4YTUyMzJhOTU2YTFjY2M4ZWY3OGJkMjViMDExMA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-11-01T18:08:02Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-11-01T18:08:02Z"}, "message": "Fix PR tree-optimization/17672 Fix PR tree-optimization/18168\n\n2004-10-16  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/17672\n\tFix PR tree-optimization/18168\n\n\t* lambda-code.c (lambda_lattice_compute_base): Fix reversed\n\tassert test.\n\t(gcc_tree_to_linear_expression): Add extra to existing constant.\n\t(depth_of_nest): Factor out function used in various places.\n\t(gcc_loop_to_lambda_loop): Clean up code a little bit. No\n\tfunctional changes.\n\t(find_induction_var_from_exit_cond): Stop guessing, and just\n\tget the right answer :).\n\t(gcc_loopnest_to_lambda_loopnest): Remove useless pre-allocation.\n\tPrint out message about result of attempt to create perfect nest.\n\t(lbv_to_gcc_expression): Add type argument, use it to do math\n\tand induction variable creation.\n\t(lle_to_gcc_expression): Ditto.\n\t(lambda_loopnest_to_gcc_loopnest): Create new iv with same type as\n\toldiv. Pass type argument to lle_to_gcc_expression and\n\tlbv_to_gcc_expression.\n\tReset number of iterations after transformation.\n\t(perfect_nestify): Remove useless pre-allocation, and cleanup\n\ta small amount.\n\n\t* tree-data-ref.c (build_classic_dist_vector): Return false for\n\tdependences completely outside of the loop nest we asked about.\n\t(build_classic_dir_vector): Ditto.\n\t(compute_data_dependences_for_loop): Only add dependence relations\n\tinside the loop we asked about.\n\n\t* tree-loop-linear.c (linear_transform_loops): Use DDR_SIZE_VECT.\n\tCompute immediate uses.\n\n\t* tree-optimize.c: Move linear_transform_loops to before ivcanon.\n\nFrom-SVN: r89945", "tree": {"sha": "13c080b6513fecb915f215d79235d8f610719b6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13c080b6513fecb915f215d79235d8f610719b6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/464f49d80df8a5232a956a1ccc8ef78bd25b0110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464f49d80df8a5232a956a1ccc8ef78bd25b0110", "html_url": "https://github.com/Rust-GCC/gccrs/commit/464f49d80df8a5232a956a1ccc8ef78bd25b0110", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464f49d80df8a5232a956a1ccc8ef78bd25b0110/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d68e653fae9b7747fcbdcd4b0722bf62aee2214e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68e653fae9b7747fcbdcd4b0722bf62aee2214e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d68e653fae9b7747fcbdcd4b0722bf62aee2214e"}], "stats": {"total": 561, "additions": 380, "deletions": 181}, "files": [{"sha": "bfae47a04d3aab1417f9c39b62668920114d64b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -1,3 +1,39 @@\n+2004-10-16  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/17672\n+\tFix PR tree-optimization/18168\n+\t\n+\t* lambda-code.c (lambda_lattice_compute_base): Fix reversed\n+\tassert test.\n+\t(gcc_tree_to_linear_expression): Add extra to existing constant.\n+\t(depth_of_nest): Factor out function used in various places.\n+\t(gcc_loop_to_lambda_loop): Clean up code a little bit. No\n+\tfunctional changes.\n+\t(find_induction_var_from_exit_cond): Stop guessing, and just\n+\tget the right answer :).\n+\t(gcc_loopnest_to_lambda_loopnest): Remove useless pre-allocation.\n+\tPrint out message about result of attempt to create perfect nest.\n+\t(lbv_to_gcc_expression): Add type argument, use it to do math\n+\tand induction variable creation.\n+\t(lle_to_gcc_expression): Ditto.\n+\t(lambda_loopnest_to_gcc_loopnest): Create new iv with same type as\n+\toldiv. Pass type argument to lle_to_gcc_expression and \n+\tlbv_to_gcc_expression.\n+\tReset number of iterations after transformation.\n+\t(perfect_nestify): Remove useless pre-allocation, and cleanup\n+\ta small amount.\n+\n+\t* tree-data-ref.c (build_classic_dist_vector): Return false for\n+\tdependences completely outside of the loop nest we asked about.\n+\t(build_classic_dir_vector): Ditto.\n+\t(compute_data_dependences_for_loop): Only add dependence relations\n+\tinside the loop we asked about.\n+\t\n+\t* tree-loop-linear.c (linear_transform_loops): Use DDR_SIZE_VECT.\n+\tCompute immediate uses.\n+\t\n+\t* tree-optimize.c: Move linear_transform_loops to before ivcanon.\n+\t\n 2004-11-01  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-cfg.c (thread_jumps): Fix a comment typo."}, {"sha": "d564f431ea4c8371bbd330f0f47a163835d9deb8", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 176, "deletions": 147, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -51,7 +51,7 @@\n  Keshav Pingali for formal proofs that the various statements below are\n  correct. \n \n- A loop iteration space are the points traversed by the loop.  A point in the\n+ A loop iteration space represents the points traversed by the loop.  A point in the\n  iteration space can be represented by a vector of size <loop depth>.  You can\n  therefore represent the iteration space as a integral combinations of a set\n  of basis vectors. \n@@ -116,7 +116,6 @@\n  of the lattice.  */\n \n \n-\n DEF_VEC_GC_P(int);\n \n static bool perfect_nestify (struct loops *, \n@@ -416,7 +415,7 @@ lambda_lattice_compute_base (lambda_loopnest nest)\n \t  /* Otherwise, we need the lower bound expression (which must\n \t     be an affine function)  to determine the base.  */\n \t  expression = LL_LOWER_BOUND (loop);\n-\t  gcc_assert (expression && LLE_NEXT (expression) \n+\t  gcc_assert (expression && !LLE_NEXT (expression) \n \t\t      && LLE_DENOMINATOR (expression) == 1);\n \n \t  /* The lower triangular portion of the base is going to be the\n@@ -491,7 +490,7 @@ lcm (int a, int b)\n \n /* Perform Fourier-Motzkin elimination to calculate the bounds of the\n    auxillary nest.\n-   Fourier-Motzkin is a way of reducing systems of linear inequality so that\n+   Fourier-Motzkin is a way of reducing systems of linear inequalities so that\n    it is easy to calculate the answer and bounds.\n    A sketch of how it works:\n    Given a system of linear inequalities, ai * xj >= bk, you can always\n@@ -1150,7 +1149,7 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n \tlle = lambda_linear_expression_new (depth, 2 * depth);\n \tLLE_CONSTANT (lle) = TREE_INT_CST_LOW (expr);\n \tif (extra != 0)\n-\t  LLE_CONSTANT (lle) = extra;\n+\t  LLE_CONSTANT (lle) += extra;\n \n \tLLE_DENOMINATOR (lle) = 1;\n       }\n@@ -1193,6 +1192,21 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n   return lle;\n }\n \n+/* Return the depth of the loopnest NEST */\n+\n+static int \n+depth_of_nest (struct loop *nest)\n+{\n+  size_t depth = 0;\n+  while (nest)\n+    {\n+      depth++;\n+      nest = nest->inner;\n+    }\n+  return depth;\n+}\n+\n+\n /* Return true if OP is invariant in LOOP and all outer loops.  */\n \n static bool\n@@ -1236,7 +1250,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   tree test;\n   int stepint;\n   int extra = 0;\n-  tree lboundvar, uboundvar;\n+  tree lboundvar, uboundvar, uboundresult;\n   use_optype uses;\n \n   /* Find out induction var and exit condition.  */\n@@ -1291,16 +1305,17 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t}\n \n     }\n+\n   /* The induction variable name/version we want to put in the array is the\n      result of the induction variable phi node.  */\n   *ourinductionvar = PHI_RESULT (phi);\n   access_fn = instantiate_parameters\n     (loop, analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n-  if (!access_fn)\n+  if (access_fn == chrec_dont_know)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Access function for induction variable phi is NULL\\n\");\n+\t\t \"Unable to convert loop: Access function for induction variable phi is unknown\\n\");\n \n       return NULL;\n     }\n@@ -1402,19 +1417,19 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n     extra = -1 * stepint;\n   else if (TREE_CODE (test) == GT_EXPR)\n     extra = -1 * stepint;\n-\n-  ubound = gcc_tree_to_linear_expression (depth,\n-\t\t\t\t\t  uboundvar,\n+  else if (TREE_CODE (test) == EQ_EXPR)\n+    extra = 1 * stepint;\n+  \n+  ubound = gcc_tree_to_linear_expression (depth, uboundvar,\n \t\t\t\t\t  outerinductionvars,\n \t\t\t\t\t  *invariants, extra);\n-  VEC_safe_push (tree, *uboundvars, build (PLUS_EXPR, integer_type_node,\n-\t\t\t\t\tuboundvar,\n-\t\t\t\t\tbuild_int_cst (integer_type_node, extra)));\n+  uboundresult = build (PLUS_EXPR, TREE_TYPE (uboundvar), uboundvar,\n+\t\t\tbuild_int_cst (TREE_TYPE (uboundvar), extra));\n+  VEC_safe_push (tree, *uboundvars, uboundresult);\n   VEC_safe_push (tree, *lboundvars, lboundvar);\n   VEC_safe_push (int, *steps, stepint);\n   if (!ubound)\n     {\n-\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"Unable to convert loop: Cannot convert upper bound to linear expression\\n\");\n@@ -1444,26 +1459,17 @@ find_induction_var_from_exit_cond (struct loop *loop)\n   test = TREE_OPERAND (expr, 0);\n   if (!COMPARISON_CLASS_P (test))\n     return NULL_TREE;\n-  /* This is a guess.  We say that for a <,!=,<= b, a is the induction\n-     variable.\n-     For >, >=, we guess b is the induction variable.\n-     If we are wrong, it'll fail the rest of the induction variable tests, and\n-     everything will be fine anyway.  */\n-  switch (TREE_CODE (test))\n-    {\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case NE_EXPR:\n-      ivarop = TREE_OPERAND (test, 0);\n-      break;      \n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n+\n+  /* Find the side that is invariant in this loop. The ivar must be the other\n+     side.  */\n+  \n+  if (expr_invariant_in_loop_p (loop, TREE_OPERAND (test, 0)))\n       ivarop = TREE_OPERAND (test, 1);\n-      break;\n-    default:\n-      gcc_unreachable();\n-    }\n+  else if (expr_invariant_in_loop_p (loop, TREE_OPERAND (test, 1)))\n+      ivarop = TREE_OPERAND (test, 0);\n+  else\n+    return NULL_TREE;\n+\n   if (TREE_CODE (ivarop) != SSA_NAME)\n     return NULL_TREE;\n   return ivarop;\n@@ -1488,25 +1494,14 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n   struct loop *temp;\n   int depth = 0;\n   size_t i;\n-  VEC (lambda_loop) *loops;\n-  VEC (tree) *uboundvars;\n-  VEC (tree) *lboundvars;\n-  VEC (int) *steps;\n+  VEC (lambda_loop) *loops = NULL;\n+  VEC (tree) *uboundvars = NULL;\n+  VEC (tree) *lboundvars  = NULL;\n+  VEC (int) *steps = NULL;\n   lambda_loop newloop;\n   tree inductionvar = NULL;\n-\n-  temp = loop_nest;\n-  while (temp)\n-    {\n-      depth++;\n-      temp = temp->inner;\n-    }\n-  loops = VEC_alloc (lambda_loop, 1);\n-  *inductionvars = VEC_alloc (tree, 1);\n-  *invariants = VEC_alloc (tree, 1);\n-  lboundvars = VEC_alloc (tree, 1);\n-  uboundvars = VEC_alloc (tree, 1);\n-  steps = VEC_alloc (int, 1);\n+  \n+  depth = depth_of_nest (loop_nest);\n   temp = loop_nest;\n   while (temp)\n     {\n@@ -1520,13 +1515,19 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n       VEC_safe_push (lambda_loop, loops, newloop);\n       temp = temp->inner;\n     }\n-  if (need_perfect_nest \n-      && !perfect_nestify (currloops, loop_nest, \n-\t\t\t   lboundvars, uboundvars, steps, *inductionvars))\n+  if (need_perfect_nest)\n     {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Not a perfect nest and couldn't convert to one.\\n\");    \n-      return NULL;\n+      if (!perfect_nestify (currloops, loop_nest, \n+\t\t\t    lboundvars, uboundvars, steps, *inductionvars))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not a perfect loop nest and couldn't convert to one.\\n\");    \n+\t  return NULL;\n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \"Successfully converted loop nest to perfect loop nest.\\n\");\n+\n+      \n     }\n   ret = lambda_loopnest_new (depth, 2 * depth);\n   for (i = 0; VEC_iterate (lambda_loop, loops, i, newloop); i++)\n@@ -1536,22 +1537,26 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \n }\n \n+\n /* Convert a lambda body vector LBV to a gcc tree, and return the new tree. \n    STMTS_TO_INSERT is a pointer to a tree where the statements we need to be\n    inserted for us are stored.  INDUCTION_VARS is the array of induction\n-   variables for the loop this LBV is from.  */\n+   variables for the loop this LBV is from.  TYPE is the tree type to use for\n+   the variables and trees involved.  */\n \n static tree\n-lbv_to_gcc_expression (lambda_body_vector lbv,\n-\t\t       VEC (tree) *induction_vars, tree * stmts_to_insert)\n+lbv_to_gcc_expression (lambda_body_vector lbv, \n+\t\t       tree type, VEC (tree) *induction_vars, \n+\t\t       tree * stmts_to_insert)\n {\n   tree stmts, stmt, resvar, name;\n+  tree iv;\n   size_t i;\n   tree_stmt_iterator tsi;\n \n   /* Create a statement list and a linear expression temporary.  */\n   stmts = alloc_stmt_list ();\n-  resvar = create_tmp_var (integer_type_node, \"lbvtmp\");\n+  resvar = create_tmp_var (type, \"lbvtmp\");\n   add_referenced_tmp_var (resvar);\n \n   /* Start at 0.  */\n@@ -1561,41 +1566,45 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n   tsi = tsi_last (stmts);\n   tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n-  for (i = 0; i < VEC_length (tree ,induction_vars) ; i++)\n+  for (i = 0; VEC_iterate (tree, induction_vars, i, iv); i++)\n     {\n       if (LBV_COEFFICIENTS (lbv)[i] != 0)\n \t{\n \t  tree newname;\n-\n+\t  tree coeffmult;\n+\t  \n \t  /* newname = coefficient * induction_variable */\n+\t  coeffmult = build_int_cst (type, LBV_COEFFICIENTS (lbv)[i]);\n \t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tfold (build (MULT_EXPR, integer_type_node,\n-\t\t\t\t     VEC_index (tree, induction_vars, i),\n-\t\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t\t    LBV_COEFFICIENTS (lbv)[i]))));\n+\t\t\tfold (build (MULT_EXPR, type, iv, coeffmult)));\n+\n \t  newname = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = newname;\n+\t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\n \t  /* name = name + newname */\n \t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tbuild (PLUS_EXPR, integer_type_node, name, newname));\n+\t\t\tbuild (PLUS_EXPR, type, name, newname));\n \t  name = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = name;\n+\t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\n \t}\n     }\n \n   /* Handle any denominator that occurs.  */\n   if (LBV_DENOMINATOR (lbv) != 1)\n     {\n+      tree denominator = build_int_cst (type, LBV_DENOMINATOR (lbv));\n       stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t    build (CEIL_DIV_EXPR, integer_type_node,\n-\t\t\t   name, build_int_cst (integer_type_node,\n-\t\t\t\t\t\tLBV_DENOMINATOR (lbv))));\n+\t\t    build (CEIL_DIV_EXPR, type, name, denominator));\n       name = make_ssa_name (resvar, stmt);\n       TREE_OPERAND (stmt, 0) = name;\n+      fold_stmt (&stmt);\n       tsi = tsi_last (stmts);\n       tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n     }\n@@ -1608,6 +1617,7 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n    Return the tree that represents the final value of the expression.\n    LLE is the linear expression to convert.\n    OFFSET is the linear offset to apply to the expression.\n+   TYPE is the tree type to use for the variables and math. \n    INDUCTION_VARS is a vector of induction variables for the loops.\n    INVARIANTS is a vector of the loop nest invariants.\n    WRAP specifies what tree code to wrap the results in, if there is more than\n@@ -1618,21 +1628,22 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n static tree\n lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t       lambda_linear_expression offset,\n+\t\t       tree type,\n \t\t       VEC(tree) *induction_vars,\n \t\t       VEC(tree) *invariants,\n \t\t       enum tree_code wrap, tree * stmts_to_insert)\n {\n   tree stmts, stmt, resvar, name;\n   size_t i;\n   tree_stmt_iterator tsi;\n-  VEC(tree) *results;\n+  tree iv, invar;\n+  VEC(tree) *results = NULL;\n \n   name = NULL_TREE;\n   /* Create a statement list and a linear expression temporary.  */\n   stmts = alloc_stmt_list ();\n-  resvar = create_tmp_var (integer_type_node, \"lletmp\");\n+  resvar = create_tmp_var (type, \"lletmp\");\n   add_referenced_tmp_var (resvar);\n-  results = VEC_alloc (tree, 1);\n \n   /* Build up the linear expressions, and put the variable representing the\n      result in the results array.  */\n@@ -1642,13 +1653,14 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       stmt = build (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n       name = make_ssa_name (resvar, stmt);\n       TREE_OPERAND (stmt, 0) = name;\n+      fold_stmt (&stmt);\n       tsi = tsi_last (stmts);\n       tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n       /* First do the induction variables.  \n          at the end, name = name + all the induction variables added\n          together.  */\n-      for (i = 0; i < VEC_length (tree ,induction_vars); i++)\n+      for (i = 0; VEC_iterate (tree, induction_vars, i, iv); i++)\n \t{\n \t  if (LLE_COEFFICIENTS (lle)[i] != 0)\n \t    {\n@@ -1663,26 +1675,25 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t}\n \t      else\n \t\t{\n-\t\t  coeff = build_int_cst (integer_type_node,\n+\t\t  coeff = build_int_cst (type,\n \t\t\t\t\t LLE_COEFFICIENTS (lle)[i]);\n-\t\t  mult = fold (build (MULT_EXPR, integer_type_node,\n-\t\t\t\t      VEC_index (tree, induction_vars, i),\n-\t\t\t\t      coeff));\n+\t\t  mult = fold (build (MULT_EXPR, type, iv, coeff));\n \t\t}\n \n \t      /* newname = mult */\n \t      stmt = build (MODIFY_EXPR, void_type_node, resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = newname;\n+\t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n \t      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t    build (PLUS_EXPR, integer_type_node,\n-\t\t\t\t   name, newname));\n+\t\t\t    build (PLUS_EXPR, type, name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = name;\n+\t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \t    }\n@@ -1691,41 +1702,39 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       /* Handle our invariants.\n          At the end, we have name = name + result of adding all multiplied\n          invariants.  */\n-      for (i = 0; i < VEC_length (tree, invariants); i++)\n+      for (i = 0; VEC_iterate (tree, invariants, i, invar); i++)\n \t{\n \t  if (LLE_INVARIANT_COEFFICIENTS (lle)[i] != 0)\n \t    {\n \t      tree newname;\n \t      tree mult;\n \t      tree coeff;\n-\n+\t      int invcoeff = LLE_INVARIANT_COEFFICIENTS (lle)[i];\n \t      /* mult = invariant * coefficient  */\n-\t      if (LLE_INVARIANT_COEFFICIENTS (lle)[i] == 1)\n+\t      if (invcoeff == 1)\n \t\t{\n-\t\t  mult = VEC_index (tree, invariants, i);\n+\t\t  mult = invar;\n \t\t}\n \t      else\n \t\t{\n-\t\t  coeff = build_int_cst (integer_type_node,\n-\t\t\t\t\t LLE_INVARIANT_COEFFICIENTS (lle)[i]);\n-\t\t  mult = fold (build (MULT_EXPR, integer_type_node,\n-\t\t\t\t      VEC_index (tree, invariants, i),\n-\t\t\t\t      coeff));\n+\t\t  coeff = build_int_cst (type, invcoeff);\n+\t\t  mult = fold (build (MULT_EXPR, type, invar, coeff));\n \t\t}\n \n \t      /* newname = mult */\n \t      stmt = build (MODIFY_EXPR, void_type_node, resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = newname;\n+\t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n \t      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t    build (PLUS_EXPR, integer_type_node,\n-\t\t\t\t   name, newname));\n+\t\t\t    build (PLUS_EXPR, type, name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = name;\n+\t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \t    }\n@@ -1736,11 +1745,11 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       if (LLE_CONSTANT (lle) != 0)\n \t{\n \t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tbuild (PLUS_EXPR, integer_type_node,\n-\t\t\t       name, build_int_cst (integer_type_node,\n-\t\t\t\t\t\t    LLE_CONSTANT (lle))));\n+\t\t\tbuild (PLUS_EXPR, type, name, \n+\t\t\t       build_int_cst (type, LLE_CONSTANT (lle))));\n \t  name = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = name;\n+\t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \t}\n@@ -1750,11 +1759,11 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       if (LLE_CONSTANT (offset) != 0)\n \t{\n \t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tbuild (PLUS_EXPR, integer_type_node,\n-\t\t\t       name, build_int_cst (integer_type_node,\n-\t\t\t\t\t\t    LLE_CONSTANT (offset))));\n+\t\t\tbuild (PLUS_EXPR, type, name, \n+\t\t\t       build_int_cst (type, LLE_CONSTANT (offset))));\n \t  name = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = name;\n+\t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \t}\n@@ -1764,14 +1773,12 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t{\n \t  if (wrap == MAX_EXPR)\n \t    stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t  build (CEIL_DIV_EXPR, integer_type_node,\n-\t\t\t\t name, build_int_cst (integer_type_node,\n-\t\t\t\t\t\t      LLE_DENOMINATOR (lle))));\n+\t\t\t  build (CEIL_DIV_EXPR, type, name, \n+\t\t\t\t build_int_cst (type, LLE_DENOMINATOR (lle))));\n \t  else if (wrap == MIN_EXPR)\n \t    stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t  build (FLOOR_DIV_EXPR, integer_type_node,\n-\t\t\t\t name, build_int_cst (integer_type_node,\n-\t\t\t\t\t\t      LLE_DENOMINATOR (lle))));\n+\t\t\t  build (FLOOR_DIV_EXPR, type, name, \n+\t\t\t\t build_int_cst (type, LLE_DENOMINATOR (lle))));\n \t  else\n \t    gcc_unreachable();\n \n@@ -1794,7 +1801,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       tree op1 = VEC_index (tree, results, 0);\n       tree op2 = VEC_index (tree, results, 1);\n       stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t    build (wrap, integer_type_node, op1, op2));\n+\t\t    build (wrap, type, op1, op2));\n       name = make_ssa_name (resvar, stmt);\n       TREE_OPERAND (stmt, 0) = name;\n       tsi = tsi_last (stmts);\n@@ -1816,6 +1823,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n    NEW_LOOPNEST is the new lambda loopnest to replace OLD_LOOPNEST with.\n    TRANSFORM is the matrix transform that was applied to OLD_LOOPNEST to get \n    NEW_LOOPNEST.  */\n+\n void\n lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t\t\t VEC(tree) *old_ivs,\n@@ -1827,7 +1835,9 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n   struct loop *temp;\n   size_t i = 0;\n   size_t depth = 0;\n-  VEC(tree) *new_ivs;\n+  VEC(tree) *new_ivs = NULL;\n+  tree oldiv;\n+  \n   block_stmt_iterator bsi;\n \n   if (dump_file)\n@@ -1836,13 +1846,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       fprintf (dump_file, \"Inverse of transformation matrix:\\n\");\n       print_lambda_trans_matrix (dump_file, transform);\n     }\n-  temp = old_loopnest;\n-  new_ivs = VEC_alloc (tree, 1);\n-  while (temp)\n-    {\n-      temp = temp->inner;\n-      depth++;\n-    }\n+  depth = depth_of_nest (old_loopnest);\n   temp = old_loopnest;\n \n   while (temp)\n@@ -1853,9 +1857,14 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       enum tree_code testtype;\n       tree newupperbound, newlowerbound;\n       lambda_linear_expression offset;\n+      tree type;\n+\n+      oldiv = VEC_index (tree, old_ivs, i);\n+      type = TREE_TYPE (oldiv);\n+\n       /* First, build the new induction variable temporary  */\n \n-      ivvar = create_tmp_var (integer_type_node, \"lnivtmp\");\n+      ivvar = create_tmp_var (type, \"lnivtmp\");\n       add_referenced_tmp_var (ivvar);\n \n       VEC_safe_push (tree, new_ivs, ivvar);\n@@ -1865,14 +1874,15 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       /* Linear offset is a bit tricky to handle.  Punt on the unhandled\n          cases for now.  */\n       offset = LL_LINEAR_OFFSET (newloop);\n-\n+      \n       gcc_assert (LLE_DENOMINATOR (offset) == 1 &&\n \t\t  lambda_vector_zerop (LLE_COEFFICIENTS (offset), depth));\n-      \n+\t    \n       /* Now build the  new lower bounds, and insert the statements\n          necessary to generate it on the loop preheader.  */\n       newlowerbound = lle_to_gcc_expression (LL_LOWER_BOUND (newloop),\n \t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n+\t\t\t\t\t     type,\n \t\t\t\t\t     new_ivs,\n \t\t\t\t\t     invariants, MAX_EXPR, &stmts);\n       bsi_insert_on_edge (loop_preheader_edge (temp), stmts);\n@@ -1881,6 +1891,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n          basic block of the exit condition */\n       newupperbound = lle_to_gcc_expression (LL_UPPER_BOUND (newloop),\n \t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n+\t\t\t\t\t     type,\n \t\t\t\t\t     new_ivs,\n \t\t\t\t\t     invariants, MIN_EXPR, &stmts);\n       exitcond = get_loop_exit_condition (temp);\n@@ -1894,49 +1905,62 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       bb = EDGE_PRED (temp->latch, 0)->src;\n       bsi = bsi_last (bb);\n       create_iv (newlowerbound,\n-\t\t build_int_cst (integer_type_node, LL_STEP (newloop)),\n+\t\t build_int_cst (type, LL_STEP (newloop)),\n \t\t ivvar, temp, &bsi, false, &ivvar,\n \t\t &ivvarinced);\n \n       /* Replace the exit condition with the new upper bound\n          comparison.  */\n+      \n       testtype = LL_STEP (newloop) >= 0 ? LE_EXPR : GE_EXPR;\n+      \n+      /* Since we don't know which cond_expr part currently points to each\n+\t edge, check which one is invariant and make sure we reverse the\n+\t comparison if we are trying to replace a <= 50 with 50 >= newiv.\n+\t This ensures that we still canonicalize to <invariant> <test>\n+\t <induction variable>.  */\n+      if (!expr_invariant_in_loop_p (temp, TREE_OPERAND (exitcond, 0)))\n+\ttesttype = swap_tree_comparison (testtype);\n+\t\n       COND_EXPR_COND (exitcond) = build (testtype,\n \t\t\t\t\t boolean_type_node,\n-\t\t\t\t\t ivvarinced, newupperbound);\n+\t\t\t\t\t newupperbound, ivvarinced);\n       modify_stmt (exitcond);\n       VEC_replace (tree, new_ivs, i, ivvar);\n \n       i++;\n       temp = temp->inner;\n     }\n-  \n+\n   /* Rewrite uses of the old ivs so that they are now specified in terms of\n      the new ivs.  */\n-  temp = old_loopnest;\n-  for (i = 0; i < VEC_length (tree, old_ivs); i++)\n+\n+  for (i = 0; VEC_iterate (tree, old_ivs, i, oldiv); i++)\n     {\n       int j;\n-      tree oldiv = VEC_index (tree, old_ivs, i);\n       dataflow_t imm = get_immediate_uses (SSA_NAME_DEF_STMT (oldiv));\n       for (j = 0; j < num_immediate_uses (imm); j++)\n \t{\n \t  tree stmt = immediate_use (imm, j);\n \t  use_operand_p use_p;\n \t  ssa_op_iter iter;\n+\t  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n \t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \t    {\n \t      if (USE_FROM_PTR (use_p) == oldiv)\n \t\t{\n \t\t  tree newiv, stmts;\n-\t\t  lambda_body_vector lbv;\n+\t\t  lambda_body_vector lbv, newlbv;\n \t\t  /* Compute the new expression for the induction\n \t\t     variable.  */\n \t\t  depth = VEC_length (tree, new_ivs);\n \t\t  lbv = lambda_body_vector_new (depth);\n \t\t  LBV_COEFFICIENTS (lbv)[i] = 1;\n-\t\t  lbv = lambda_body_vector_compute_new (transform, lbv);\n-\t\t  newiv = lbv_to_gcc_expression (lbv, new_ivs, &stmts);\n+\t\t  \n+\t\t  newlbv = lambda_body_vector_compute_new (transform, lbv);\n+\n+\t\t  newiv = lbv_to_gcc_expression (newlbv, TREE_TYPE (oldiv),\n+\t\t\t\t\t\t new_ivs, &stmts);\n \t\t  bsi = bsi_for_stmt (stmt);\n \t\t  /* Insert the statements to build that\n \t\t     expression.  */\n@@ -2048,6 +2072,8 @@ stmt_is_bumper_for_loop (struct loop *loop, tree stmt)\n     }\n   return false;\n }\n+\n+\n /* Return true if LOOP is a perfect loop nest.\n    Perfect loop nests are those loop nests where all code occurs in the\n    innermost loop body.\n@@ -2250,14 +2276,12 @@ perfect_nestify (struct loops *loops,\n   tree phi;\n   tree uboundvar;\n   tree stmt;\n-  tree ivvar, ivvarinced;\n-  VEC (tree) *phis;\n+  tree oldivvar, ivvar, ivvarinced;\n+  VEC (tree) *phis = NULL;\n \n   if (!can_convert_to_perfect_nest (loop, loopivs))\n     return false;\n \n-  phis = VEC_alloc (tree, 1);\n-  \n   /* Create the new loop */\n \n   olddest = loop->single_exit->dest;\n@@ -2278,21 +2302,24 @@ perfect_nestify (struct loops *loops,\n       mark_for_rewrite (PHI_RESULT (phi));\n     }\n   e = redirect_edge_and_branch (EDGE_SUCC (preheaderbb, 0), headerbb);\n-  unmark_all_for_rewrite ();\n-  bb_ann (olddest)->phi_nodes = NULL;\n-  /* Add back the old exit phis.  */\n+\n+  /* Remove the exit phis from the old basic block.  */\n+  while (phi_nodes (olddest) != NULL)\n+    remove_phi_node (phi_nodes (olddest), NULL, olddest);\n+\n+  /* and add them to the new basic block.  */\n   while (VEC_length (tree, phis) != 0)\n     {\n       tree def;\n       tree phiname;\n       def = VEC_pop (tree, phis);\n-      phiname = VEC_pop (tree, phis);\n-      \n+      phiname = VEC_pop (tree, phis);      \n       phi = create_phi_node (phiname, preheaderbb);\n       add_phi_arg (&phi, def, EDGE_PRED (preheaderbb, 0));\n-    } \n-      \n+    }       \n   flush_pending_stmts (e);\n+  unmark_all_for_rewrite ();\n+\n   bodybb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   latchbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   make_edge (headerbb, bodybb, EDGE_FALLTHRU); \n@@ -2329,8 +2356,7 @@ perfect_nestify (struct loops *loops,\n   add_referenced_tmp_var (ivvar);\n   bsi = bsi_last (EDGE_PRED (newloop->latch, 0)->src);\n   create_iv (VEC_index (tree, lbounds, 0),\n-\t     build_int_cst (integer_type_node, \n-\t\t\t    VEC_index (int, steps, 0)),\n+\t     build_int_cst (integer_type_node, VEC_index (int, steps, 0)),\n \t     ivvar, newloop, &bsi, false, &ivvar, &ivvarinced);\t     \n \n   /* Create the new upper bound.  This may be not just a variable, so we copy\n@@ -2344,14 +2370,15 @@ perfect_nestify (struct loops *loops,\n   uboundvar = make_ssa_name (uboundvar, stmt);\n   TREE_OPERAND (stmt, 0) = uboundvar;\n   bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n-  COND_EXPR_COND (exit_condition) = build (LE_EXPR, \n+  COND_EXPR_COND (exit_condition) = build (GE_EXPR, \n \t\t\t\t\t   boolean_type_node,\n-\t\t\t\t\t   ivvarinced, \n-\t\t\t\t\t   uboundvar);\n+\t\t\t\t\t   uboundvar,\n+\t\t\t\t\t   ivvarinced);\n \n   bbs = get_loop_body (loop); \n   /* Now replace the induction variable in the moved statements with the\n      correct loop induction variable.  */\n+  oldivvar = VEC_index (tree, loopivs, 0);\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       block_stmt_iterator tobsi = bsi_last (bodybb);\n@@ -2370,9 +2397,7 @@ perfect_nestify (struct loops *loops,\n \t\t  bsi_next (&bsi);\n \t\t  continue;\n \t\t}\n-\t      replace_uses_of_x_with_y (stmt, \n-\t\t\t\t\tVEC_index (tree, loopivs, 0),\n-\t\t\t\t\tivvar);\n+\t      replace_uses_of_x_with_y (stmt, oldivvar, ivvar);\n \t      bsi_move_before (&bsi, &tobsi);\n \t    }\n \t}\n@@ -2425,19 +2450,23 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n     {\n       ddr = (struct data_dependence_relation *) \n-\tVARRAY_GENERIC_PTR (dependence_relations, i);\n-\n-     \n+\tVARRAY_GENERIC_PTR (dependence_relations, i);     \n \n       /* Don't care about relations for which we know that there is no\n \t dependence, nor about read-read (aka. output-dependences):\n \t these data accesses can happen in any order.  */\n       if (DDR_ARE_DEPENDENT (ddr) == chrec_known\n \t  || (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr))))\n \tcontinue;\n+\n       /* Conservatively answer: \"this transformation is not valid\".  */\n       if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n \treturn false;\n+\t  \n+      /* If the dependence could not be captured by a distance vector,\n+\t conservatively answer that the transform is not valid.  */\n+      if (DDR_DIST_VECT (ddr) == NULL)\n+\treturn false;\n \n       /* Compute trans.dist_vect */\n       lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops, "}, {"sha": "bbeef87b61ef1938950b64d305984f3d4463966c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+\n+double u[1782225];\n+int foo(int N, int *res)\n+{\n+  int i, j;\n+  double sum = 0.0;\n+  /* This loop should be converted to a perfect nest and\n+     interchanged. */\n+  for (i = 0; i < N; i++)\n+    {\n+      for (j = 0; j < N; j++)\n+\tsum = sum + u[i + 1335 * j];\n+      \n+      u[1336 * i] *= 2;\n+    }\n+  *res = sum + N;\n+}\n+/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect\n+   loop nest\" 1 \"ltrans\"} } */ \n+/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ "}, {"sha": "7ab3e6c68974623037a49af1df82e09c0c490d22", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-2.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+\n+double u[1782225];\n+int foo(int N, int *res)\n+{\n+  unsigned int i, j;\n+  double sum = 0;\n+  \n+  /* This loop should be converted to a perfect nest and\n+     interchanged.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      for (j = 0; j < N; j++)\n+\t{\n+\t  sum = sum + u[i + 1335 * j];\n+\t  if (j == N - 1)\n+\t    u[1336 * i] *= 2;\n+\t}\n+    }\n+  *res = sum + N;\n+}\n+/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} {\n+   xfail *-*-*} } */ "}, {"sha": "81c347c7aa66297a205c40dea28ceafddc1120dd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-3.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+\n+double u[1782225];\n+int foo(int N, int *res)\n+{\n+  unsigned int i, j;\n+  double sum = 0;\n+      for (i = 0; i < N; i++)\n+\t{\n+\t  for (j = 0; j < N; j++)\n+\t    {\n+\t      sum = sum + u[i + 1335 * j];\n+\t    }\n+\t}\n+      *res = sum + N;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ "}, {"sha": "5f43da17d23b0f742bdebaa7b1b8ab214060e822", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O20 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+\n+double u[1782225];\n+int foo(int N, int *res)\n+{\n+  int i, j;\n+  double sum = 0;\n+  for (i = 0; i < N; i++)\t\n+    for (j = 0; j < N; j++)\n+      sum = sum + u[i + 1335 * j];\n+  \n+  for (i = 0; i < N; i++)\n+    u[1336 * i] *= 2;\n+  *res = sum + N;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ "}, {"sha": "43a20119d42f6e6c258cf856f18dcdd17976bef4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-5.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-5.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+typedef struct rtx_\n+{\n+} *rtx;\n+static rtx regno_save_mem[53][16 / 4 + 1];\n+extern set_mem_alias_set (rtx, rtx);\n+int main(void)\n+{\n+  int i, j;\n+  for (i = 0; i < 53; i++)\n+    for (j = (16 / (0 ? 8 : 4)); j > 0; j--)\n+      if (regno_save_mem[i][j] != 0)\n+        set_mem_alias_set (regno_save_mem[i][j], 0);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Linear expression:  constant: 1   invariants:   denominator: 1\" 1 \"ltrans\" } } */\n+/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ "}, {"sha": "9a0126c3317b1c9031fdbbe7fff2d9bdfdee1988", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -1772,9 +1772,12 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n    DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n    FIRST_LOOP is the loop->num of the first loop in the analyzed \n-   loop nest.  */\n+   loop nest.  \n+   Return FALSE if the dependence relation is outside of the loop nest\n+   starting with FIRST_LOOP. \n+   Return TRUE otherwise.  */\n \n-static void\n+static bool\n build_classic_dist_vector (struct data_dependence_relation *ddr, \n \t\t\t   int nb_loops, unsigned int first_loop)\n {\n@@ -1787,7 +1790,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n   lambda_vector_clear (init_v, nb_loops);\n   \n   if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n-    return;\n+    return true;\n   \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n@@ -1797,7 +1800,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n       if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t{\n \t  non_affine_dependence_relation (ddr);\n-\t  return;\n+\t  return true;\n \t}\n \n       access_fn_a = DR_ACCESS_FN (DDR_A (ddr), i);\n@@ -1811,6 +1814,15 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n \t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n \t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n+\t  struct loop *loop_first = current_loops->parray[first_loop];\n+\n+\t  /* If the loops for both variables are at a lower depth than \n+\t     the first_loop's depth, then they can't possibly have a\n+\t     dependency at this level of the loop.  */\n+\t     \n+\t  if (loop_a->depth < loop_first->depth\n+\t      && loop_b->depth < loop_first->depth)\n+\t    return false;\n \n \t  if (loop_nb_a != loop_nb_b\n \t      && !flow_loop_nested_p (loop_a, loop_b)\n@@ -1828,7 +1840,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t\t the dependence relation cannot be captured by the\n \t\t distance abstraction.  */\n \t      non_affine_dependence_relation (ddr);\n-\t      return;\n+\t      return true;\n \t    }\n \n \t  /* The dependence is carried by the outermost loop.  Example:\n@@ -1850,7 +1862,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t    {\n \t      non_affine_dependence_relation (ddr);\n-\t      return;\n+\t      return true;\n \t    }\n \t  \n \t  dist = int_cst_value (SUB_DISTANCE (subscript));\n@@ -1865,7 +1877,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t      && dist_v[loop_nb] != dist)\n \t    {\n \t      finalize_ddr_dependent (ddr, chrec_known);\n-\t      return;\n+\t      return true;\n \t    }\n \n \t  dist_v[loop_nb] = dist;\n@@ -1928,16 +1940,20 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n   \n   DDR_DIST_VECT (ddr) = dist_v;\n   DDR_SIZE_VECT (ddr) = nb_loops;\n+  return true;\n }\n \n /* Compute the classic per loop direction vector.  \n \n    DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n    FIRST_LOOP is the loop->num of the first loop in the analyzed \n-   loop nest.  */\n+   loop nest.\n+   Return FALSE if the dependence relation is outside of the loop nest\n+   starting with FIRST_LOOP. \n+   Return TRUE otherwise.  */\n \n-static void\n+static bool\n build_classic_dir_vector (struct data_dependence_relation *ddr, \n \t\t\t  int nb_loops, unsigned int first_loop)\n {\n@@ -1950,7 +1966,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n   lambda_vector_clear (init_v, nb_loops);\n   \n   if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n-    return;\n+    return true;\n   \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n@@ -1960,7 +1976,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n       if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t{\n \t  non_affine_dependence_relation (ddr);\n-\t  return;\n+\t  return true;\n \t}\n \n       access_fn_a = DR_ACCESS_FN (DDR_A (ddr), i);\n@@ -1974,6 +1990,14 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n \t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n \t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n+\t  struct loop *loop_first = current_loops->parray[first_loop];\n+ \n+\t  /* If the loops for both variables are at a lower depth than \n+\t     the first_loop's depth, then they can't possibly matter */\n+\t     \n+\t  if (loop_a->depth < loop_first->depth\n+\t      && loop_b->depth < loop_first->depth)\n+\t    return false;\n \n \t  if (loop_nb_a != loop_nb_b\n \t      && !flow_loop_nested_p (loop_a, loop_b)\n@@ -1991,7 +2015,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t\t the dependence relation cannot be captured by the\n \t\t distance abstraction.  */\n \t      non_affine_dependence_relation (ddr);\n-\t      return;\n+\t      return true;\n \t    }\n \n \t  /* The dependence is carried by the outermost loop.  Example:\n@@ -2014,7 +2038,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t    {\n \t      non_affine_dependence_relation (ddr);\n-\t      return;\n+\t      return true;\n \t    }\n \n \t  dist = int_cst_value (SUB_DISTANCE (subscript));\n@@ -2038,7 +2062,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t      && (enum data_dependence_direction) dir_v[loop_nb] != dir_star)\n \t    {\n \t      finalize_ddr_dependent (ddr, chrec_known);\n-\t      return;\n+\t      return true;\n \t    }\n \t  \n \t  dir_v[loop_nb] = dir;\n@@ -2099,6 +2123,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n   \n   DDR_DIR_VECT (ddr) = dir_v;\n   DDR_SIZE_VECT (ddr) = nb_loops;\n+  return true;\n }\n \n /* Returns true when all the access functions of A are affine or\n@@ -2195,10 +2220,8 @@ compute_all_dependences (varray_type datarefs,\n    DATAREFS.  Returns chrec_dont_know when failing to analyze a\n    difficult case, returns NULL_TREE otherwise.\n    \n-   FIXME: This is a \"dumb\" walker over all the trees in the loop body.\n-   Find another technique that avoids this costly walk.  This is\n-   acceptable for the moment, since this function is used only for\n-   debugging purposes.  */\n+   TODO: This function should be made smarter so that it can handle address\n+   arithmetic as if they were array accesses, etc.  */\n \n tree \n find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n@@ -2226,7 +2249,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t      && !V_MUST_DEF_OPS (ann)\n \t      && !V_MAY_DEF_OPS (ann))\n \t    continue;\n-\n+\t  \n \t  /* In the GIMPLE representation, a modify expression\n   \t     contains a single load or store to memory.  */\n \t  if (TREE_CODE (TREE_OPERAND (stmt, 0)) == ARRAY_REF)\n@@ -2238,7 +2261,6 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t    VARRAY_PUSH_GENERIC_PTR \n \t\t    (*datarefs, analyze_array (stmt, TREE_OPERAND (stmt, 1), \n \t\t\t\t\t       true));\n-\n   \t  else\n \t    {\n \t      if (dont_know_node_not_inserted)\n@@ -2251,7 +2273,6 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t  DR_BASE_NAME (res) = NULL;\n \t\t  DR_IS_READ (res) = false;\n \t\t  VARRAY_PUSH_GENERIC_PTR (*datarefs, res);\n-\n \t\t  dont_know_node_not_inserted = false;\n \t\t}\n \t    }\n@@ -2286,6 +2307,7 @@ compute_data_dependences_for_loop (unsigned nb_loops,\n \t\t\t\t   varray_type *dependence_relations)\n {\n   unsigned int i;\n+  varray_type allrelations;\n \n   /* If one of the data references is not computable, give up without\n      spending time to compute other dependences.  */\n@@ -2302,14 +2324,18 @@ compute_data_dependences_for_loop (unsigned nb_loops,\n       return;\n     }\n \n-  compute_all_dependences (*datarefs, dependence_relations);\n+  VARRAY_GENERIC_PTR_INIT (allrelations, 1, \"Data dependence relations\");\n+  compute_all_dependences (*datarefs, &allrelations);\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (*dependence_relations); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (allrelations); i++)\n     {\n       struct data_dependence_relation *ddr;\n-      ddr = VARRAY_GENERIC_PTR (*dependence_relations, i);\n-      build_classic_dist_vector (ddr, nb_loops, loop->num);\n-      build_classic_dir_vector (ddr, nb_loops, loop->num);    \n+      ddr = VARRAY_GENERIC_PTR (allrelations, i);\n+      if (build_classic_dist_vector (ddr, nb_loops, loop->num))\n+\t{\n+\t  VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n+\t  build_classic_dir_vector (ddr, nb_loops, loop->num);\n+\t}\n     }\n }\n "}, {"sha": "07afe5dabb09033d8c28c9c9411c45545439e731", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -127,7 +127,6 @@ gather_interchange_stats (varray_type dependence_relations,\n \t  (*dependence_steps) += 0;\n \t  continue;\n \t}\n-\n       dist = DDR_DIST_VECT (ddr)[loop_number];\n       if (dist == 0)\n \t(*nb_deps_not_carried_by_loop) += 1;\n@@ -240,15 +239,16 @@ linear_transform_loops (struct loops *loops)\n {\n   unsigned int i;\n \n+  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, NULL);\n   for (i = 1; i < loops->num; i++)\n     {\n       unsigned int depth = 0;\n       varray_type datarefs;\n       varray_type dependence_relations;\n       struct loop *loop_nest = loops->parray[i];\n       struct loop *temp;\n-      VEC (tree) *oldivs;\n-      VEC (tree) *invariants;\n+      VEC (tree) *oldivs = NULL;\n+      VEC (tree) *invariants = NULL;\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n       bool problem = false;\n@@ -306,11 +306,11 @@ linear_transform_loops (struct loops *loops)\n \t\t{\n \t\t  fprintf (dump_file, \"DISTANCE_V (\");\n \t\t  print_lambda_vector (dump_file, DDR_DIST_VECT (ddr), \n-\t\t\t\t       loops->num);\n+\t\t\t\t       DDR_SIZE_VECT (ddr));\n \t\t  fprintf (dump_file, \")\\n\");\n \t\t  fprintf (dump_file, \"DIRECTION_V (\");\n \t\t  print_lambda_vector (dump_file, DDR_DIR_VECT (ddr), \n-\t\t\t\t       loops->num);\n+\t\t\t\t       DDR_SIZE_VECT (ddr));\n \t\t  fprintf (dump_file, \")\\n\");\n \t\t}\n \t    }\n@@ -319,6 +319,7 @@ linear_transform_loops (struct loops *loops)\n       /* Build the transformation matrix.  */\n       trans = lambda_trans_matrix_new (depth, depth);\n       lambda_matrix_id (LTM_MATRIX (trans), depth);\n+\n       trans = try_interchange_loops (trans, depth, dependence_relations,\n \t\t\t\t     datarefs, loop_nest->num);\n \n@@ -359,11 +360,17 @@ linear_transform_loops (struct loops *loops)\n \t}\n       lambda_loopnest_to_gcc_loopnest (loop_nest, oldivs, invariants,\n \t\t\t\t       after, trans);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Successfully transformed loop.\\n\");\n       oldivs = NULL;\n       invariants = NULL;\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }\n-  rewrite_into_loop_closed_ssa ();\n   free_df ();\n+  scev_reset ();\n+  rewrite_into_loop_closed_ssa ();\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa ();\n+#endif\n }"}, {"sha": "7089c2705d8cc1b2de2c03cd7fe99567a1fdff2d", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464f49d80df8a5232a956a1ccc8ef78bd25b0110/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=464f49d80df8a5232a956a1ccc8ef78bd25b0110", "patch": "@@ -392,11 +392,11 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_loop_init);\n   NEXT_PASS (pass_lim);\n   NEXT_PASS (pass_unswitch);\n-  NEXT_PASS (pass_iv_canon);\n   NEXT_PASS (pass_record_bounds);\n+  NEXT_PASS (pass_linear_transform);\n+  NEXT_PASS (pass_iv_canon);\n   NEXT_PASS (pass_if_conversion);\n   NEXT_PASS (pass_vectorize);\n-  NEXT_PASS (pass_linear_transform);\n   NEXT_PASS (pass_complete_unroll);\n   NEXT_PASS (pass_iv_optimize);\n   NEXT_PASS (pass_loop_done);"}]}