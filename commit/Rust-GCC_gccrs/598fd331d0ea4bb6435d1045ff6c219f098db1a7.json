{"sha": "598fd331d0ea4bb6435d1045ff6c219f098db1a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4ZmQzMzFkMGVhNGJiNjQzNWQxMDQ1ZmY2YzIxOWYwOThkYjFhNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-07T01:21:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-07T01:21:57Z"}, "message": "libgo: Remove debug/proc, os.Error.\n\nFrom-SVN: r182074", "tree": {"sha": "78e893215557c1af49f5bbe39f154c3bf0dbc004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78e893215557c1af49f5bbe39f154c3bf0dbc004"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/598fd331d0ea4bb6435d1045ff6c219f098db1a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598fd331d0ea4bb6435d1045ff6c219f098db1a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598fd331d0ea4bb6435d1045ff6c219f098db1a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598fd331d0ea4bb6435d1045ff6c219f098db1a7/comments", "author": null, "committer": null, "parents": [{"sha": "9c63abc9a1d127f95162756467284cf76b47aff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c63abc9a1d127f95162756467284cf76b47aff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c63abc9a1d127f95162756467284cf76b47aff8"}], "stats": {"total": 398, "additions": 3, "deletions": 395}, "files": [{"sha": "02c083911eb4fad811bda10465bdbbcf24dce52f", "filename": "libgo/go/debug/proc/proc_irix.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_irix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_irix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_irix.go?ref=9c63abc9a1d127f95162756467284cf76b47aff8", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc\n-\n-import \"os\"\n-\n-// Process tracing is not supported on IRIX yet.\n-\n-func Attach(pid int) (Process, os.Error) {\n-\treturn nil, os.NewError(\"debug/proc not implemented on IRIX\")\n-}\n-\n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n-\treturn Attach(0)\n-}"}, {"sha": "5311a63ba20cdb3dfc5dcee665c880e7ceb9c178", "filename": "libgo/go/debug/proc/proc_rtems.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_rtems.go?ref=9c63abc9a1d127f95162756467284cf76b47aff8", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc\n-\n-import \"os\"\n-\n-// Process tracing is not supported on RTEMS yet.\n-\n-func Attach(pid int) (Process, os.Error) {\n-\treturn nil, os.NewError(\"debug/proc not implemented on RTEMS\")\n-}\n-\n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n-\treturn Attach(0)\n-}"}, {"sha": "a72c592379511c1423d19434eda5669e3a2aea40", "filename": "libgo/go/debug/proc/proc_solaris.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_solaris.go?ref=9c63abc9a1d127f95162756467284cf76b47aff8", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc\n-\n-import \"os\"\n-\n-// Process tracing is not supported on Solaris yet.\n-\n-func Attach(pid int) (Process, os.Error) {\n-\treturn nil, os.NewError(\"debug/proc not implemented on Solaris\")\n-}\n-\n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n-\treturn Attach(0)\n-}"}, {"sha": "62cbf7700352fc93a8c3951ec52b9aa19c9674ae", "filename": "libgo/go/debug/proc/ptrace-nptl.txt", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fptrace-nptl.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fptrace-nptl.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fptrace-nptl.txt?ref=9c63abc9a1d127f95162756467284cf76b47aff8", "patch": "@@ -1,132 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-ptrace and NTPL, the missing manpage\n-\n-== Signals ==\n-\n-A signal sent to a ptrace'd process or thread causes only the thread\n-that receives it to stop and report to the attached process.\n-\n-Use tgkill to target a signal (for example, SIGSTOP) at a particular\n-thread.  If you use kill, the signal could be delivered to another\n-thread in the same process.\n-\n-Note that SIGSTOP differs from its usual behavior when a process is\n-being traced.  Usually, a SIGSTOP sent to any thread in a thread group\n-will stop all threads in the thread group.  When a thread is traced,\n-however, a SIGSTOP affects only the receiving thread (and any other\n-threads in the thread group that are not traced).\n-\n-SIGKILL behaves like it does for non-traced processes.  It affects all\n-threads in the process and terminates them without the WSTOPSIG event\n-generated by other signals.  However, if PTRACE_O_TRACEEXIT is set,\n-the attached process will still receive PTRACE_EVENT_EXIT events\n-before receiving WIFSIGNALED events.\n-\n-See \"Following thread death\" for a caveat regarding signal delivery to\n-zombie threads.\n-\n-== Waiting on threads ==\n-\n-Cloned threads in ptrace'd processes are treated similarly to cloned\n-threads in your own process.  Thus, you must use the __WALL option in\n-order to receive notifications from threads created by the child\n-process.  Similarly, the __WCLONE option will wait only on\n-notifications from threads created by the child process and *not* on\n-notifications from the initial child thread.\n-\n-Even when waiting on a specific thread's PID using waitpid or similar,\n-__WALL or __WCLONE is necessary or waitpid will return ECHILD.\n-\n-== Attaching to existing threads ==\n-\n-libthread_db (which gdb uses), attaches to existing threads by pulling\n-the pthread data structures out of the traced process.  The much\n-easier way is to traverse the /proc/PID/task directory, though it's\n-unclear how the semantics of these two approaches differ.\n-\n-Unfortunately, if the main thread has exited (but the overall process\n-has not), it sticks around as a zombie process.  This zombie will\n-appear in the /proc/PID/task directory, but trying to attach to it\n-will yield EPERM.  In this case, the third field of the\n-/proc/PID/task/PID/stat file will be \"Z\".  Attempting to open the stat\n-file is also a convenient way to detect races between listing the task\n-directory and the thread exiting.  Coincidentally, gdb will simply\n-fail to attach to a process whose main thread is a zombie.\n-\n-Because new threads may be created while the debugger is in the\n-process of attaching to existing threads, the debugger must repeatedly\n-re-list the task directory until it has attached to (and thus stopped)\n-every thread listed.\n-\n-In order to follow new threads created by existing threads,\n-PTRACE_O_TRACECLONE must be set on each thread attached to.\n-\n-== Following new threads ==\n-\n-With the child process stopped, use PTRACE_SETOPTIONS to set the\n-PTRACE_O_TRACECLONE option.  This option is per-thread, and thus must\n-be set on each existing thread individually.  When an existing thread\n-with PTRACE_O_TRACECLONE set spawns a new thread, the existing thread\n-will stop with (SIGTRAP | PTRACE_EVENT_CLONE << 8) and the PID of the\n-new thread can be retrieved with PTRACE_GETEVENTMSG on the creating\n-thread.  At this time, the new thread will exist, but will initially\n-be stopped with a SIGSTOP.  The new thread will automatically be\n-traced and will inherit the PTRACE_O_TRACECLONE option from its\n-parent.  The attached process should wait on the new thread to receive\n-the SIGSTOP notification.\n-\n-When using waitpid(-1, ...), don't rely on the parent thread reporting\n-a SIGTRAP before receiving the SIGSTOP from the new child thread.\n-\n-Without PTRACE_O_TRACECLONE, newly cloned threads will not be\n-ptrace'd.  As a result, signals received by new threads will be\n-handled in the usual way, which may affect the parent and in turn\n-appear to the attached process, but attributed to the parent (possibly\n-in unexpected ways).\n-\n-== Following thread death ==\n-\n-If any thread with the PTRACE_O_TRACEEXIT option set exits (either by\n-returning or pthread_exit'ing), the tracing process will receive an\n-immediate PTRACE_EVENT_EXIT.  At this point, the thread will still\n-exist.  The exit status, encoded as for wait, can be queried using\n-PTRACE_GETEVENTMSG on the exiting thread's PID.  The thread should be\n-continued so it can actually exit, after which its wait behavior is\n-the same as for a thread without the PTRACE_O_TRACEEXIT option.\n-\n-If a non-main thread exits (either by returning or pthread_exit'ing),\n-its corresponding process will also exit, producing a WIFEXITED event\n-(after the process is continued from a possible PTRACE_EVENT_EXIT\n-event).  It is *not* necessary for another thread to ptrace_join for\n-this to happen.\n-\n-If the main thread exits by returning, then all threads will exit,\n-first generating a PTRACE_EVENT_EXIT event for each thread if\n-appropriate, then producing a WIFEXITED event for each thread.\n-\n-If the main thread exits using pthread_exit, then it enters a\n-non-waitable zombie state.  It will still produce an immediate\n-PTRACE_O_TRACEEXIT event, but the WIFEXITED event will be delayed\n-until the entire process exits.  This state exists so that shells\n-don't think the process is done until all of the threads have exited.\n-Unfortunately, signals cannot be delivered to non-waitable zombies.\n-Most notably, SIGSTOP cannot be delivered; as a result, when you\n-broadcast SIGSTOP to all of the threads, you must not wait for\n-non-waitable zombies to stop.  Furthermore, any ptrace command on a\n-non-waitable zombie, including PTRACE_DETACH, will return ESRCH.\n-\n-== Multi-threaded debuggers ==\n-\n-If the debugger itself is multi-threaded, ptrace calls must come from\n-the same thread that originally attached to the remote thread.  The\n-kernel simply compares the PID of the caller of ptrace against the\n-tracer PID of the process passed to ptrace.  Because each debugger\n-thread has a different PID, calling ptrace from a different thread\n-might as well be calling it from a different process and the kernel\n-will return ESRCH.\n-\n-wait, on the other hand, does not have this restriction.  Any debugger\n-thread can wait on any thread in the attached process."}, {"sha": "3c9f8d85f17ea7facaf675412f5288537d4ef223", "filename": "libgo/go/debug/proc/regs_linux_alpha.go", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_alpha.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c63abc9a1d127f95162756467284cf76b47aff8/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_alpha.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fregs_linux_alpha.go?ref=9c63abc9a1d127f95162756467284cf76b47aff8", "patch": "@@ -1,209 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package proc\n-\n-import (\n-\t\"os\"\n-\t\"strconv\"\n-\t\"syscall\"\n-)\n-\n-type alphaRegs struct {\n-\tsyscall.PtraceRegs\n-\tsetter func(*syscall.PtraceRegs) os.Error\n-}\n-\n-var names = [...]string{\n-\t\"r0\",\n-\t\"r1\",\n-\t\"r2\",\n-\t\"r3\",\n-\t\"r4\",\n-\t\"r5\",\n-\t\"r6\",\n-\t\"r7\",\n-\t\"r8\",\n-\t\"r19\",\n-\t\"r20\",\n-\t\"r21\",\n-\t\"r22\",\n-\t\"r23\",\n-\t\"r24\",\n-\t\"r25\",\n-\t\"r26\",\n-\t\"r27\",\n-\t\"r28\",\n-\t\"hae\",\n-\t\"trap_a0\",\n-\t\"trap_a1\",\n-\t\"trap_a2\",\n-\t\"ps\",\n-\t\"pc\",\n-\t\"gp\",\n-\t\"r16\",\n-\t\"r17\",\n-\t\"r18\",\n-}\n-\n-func (r *alphaRegs) PC() Word { return Word(r.Pc) }\n-\n-func (r *alphaRegs) SetPC(val Word) os.Error {\n-\tr.Pc = uint64(val)\n-\treturn r.setter(&r.PtraceRegs)\n-}\n-\n-func (r *alphaRegs) Link() Word {\n-\tpanic(\"No link register\")\n-}\n-\n-func (r *alphaRegs) SetLink(val Word) os.Error {\n-\tpanic(\"No link register\")\n-}\n-\n-func (r *alphaRegs) SP() Word { return Word(r.Ps) }\n-\n-func (r *alphaRegs) SetSP(val Word) os.Error {\n-\tr.Ps = uint64(val)\n-\treturn r.setter(&r.PtraceRegs)\n-}\n-\n-func (r *alphaRegs) Names() []string { return names[0:] }\n-\n-func (r *alphaRegs) Get(i int) Word {\n-\tswitch i {\n-\tcase 0:\n-\t\treturn Word(r.R0)\n-\tcase 1:\n-\t\treturn Word(r.R1)\n-\tcase 2:\n-\t\treturn Word(r.R2)\n-\tcase 3:\n-\t\treturn Word(r.R3)\n-\tcase 4:\n-\t\treturn Word(r.R4)\n-\tcase 5:\n-\t\treturn Word(r.R5)\n-\tcase 6:\n-\t\treturn Word(r.R6)\n-\tcase 7:\n-\t\treturn Word(r.R7)\n-\tcase 8:\n-\t\treturn Word(r.R8)\n-\tcase 9:\n-\t\treturn Word(r.R19)\n-\tcase 10:\n-\t\treturn Word(r.R20)\n-\tcase 11:\n-\t\treturn Word(r.R21)\n-\tcase 12:\n-\t\treturn Word(r.R22)\n-\tcase 13:\n-\t\treturn Word(r.R23)\n-\tcase 14:\n-\t\treturn Word(r.R24)\n-\tcase 15:\n-\t\treturn Word(r.R25)\n-\tcase 16:\n-\t\treturn Word(r.R26)\n-\tcase 17:\n-\t\treturn Word(r.R27)\n-\tcase 18:\n-\t\treturn Word(r.R28)\n-\tcase 19:\n-\t\treturn Word(r.Hae)\n-\tcase 20:\n-\t\treturn Word(r.Trap_a0)\n-\tcase 21:\n-\t\treturn Word(r.Trap_a1)\n-\tcase 22:\n-\t\treturn Word(r.Trap_a2)\n-\tcase 23:\n-\t\treturn Word(r.Ps)\n-\tcase 24:\n-\t\treturn Word(r.Pc)\n-\tcase 25:\n-\t\treturn Word(r.Gp)\n-\tcase 26:\n-\t\treturn Word(r.R16)\n-\tcase 27:\n-\t\treturn Word(r.R17)\n-\tcase 28:\n-\t\treturn Word(r.R18)\n-\t}\n-\tpanic(\"invalid register index \" + strconv.Itoa(i))\n-}\n-\n-func (r *alphaRegs) Set(i int, val Word) os.Error {\n-\tswitch i {\n-\tcase 0:\n-\t\tr.R0 = uint64(val)\n-\tcase 1:\n-\t\tr.R1 = uint64(val)\n-\tcase 2:\n-\t\tr.R2 = uint64(val)\n-\tcase 3:\n-\t\tr.R3 = uint64(val)\n-\tcase 4:\n-\t\tr.R4 = uint64(val)\n-\tcase 5:\n-\t\tr.R5 = uint64(val)\n-\tcase 6:\n-\t\tr.R6 = uint64(val)\n-\tcase 7:\n-\t\tr.R7 = uint64(val)\n-\tcase 8:\n-\t\tr.R8 = uint64(val)\n-\tcase 9:\n-\t\tr.R19 = uint64(val)\n-\tcase 10:\n-\t\tr.R20 = uint64(val)\n-\tcase 11:\n-\t\tr.R21 = uint64(val)\n-\tcase 12:\n-\t\tr.R22 = uint64(val)\n-\tcase 13:\n-\t\tr.R23 = uint64(val)\n-\tcase 14:\n-\t\tr.R24 = uint64(val)\n-\tcase 15:\n-\t\tr.R25 = uint64(val)\n-\tcase 16:\n-\t\tr.R26 = uint64(val)\n-\tcase 17:\n-\t\tr.R27 = uint64(val)\n-\tcase 18:\n-\t\tr.R28 = uint64(val)\n-\tcase 19:\n-\t\tr.Hae = uint64(val)\n-\tcase 20:\n-\t\tr.Trap_a0 = uint64(val)\n-\tcase 21:\n-\t\tr.Trap_a1 = uint64(val)\n-\tcase 22:\n-\t\tr.Trap_a2 = uint64(val)\n-\tcase 23:\n-\t\tr.Ps = uint64(val)\n-\tcase 24:\n-\t\tr.Pc = uint64(val)\n-\tcase 25:\n-\t\tr.Gp = uint64(val)\n-\tcase 26:\n-\t\tr.R16 = uint64(val)\n-\tcase 27:\n-\t\tr.R17 = uint64(val)\n-\tcase 28:\n-\t\tr.R18 = uint64(val)\n-\tdefault:\n-\t\tpanic(\"invalid register index \" + strconv.Itoa(i))\n-\t}\n-\treturn r.setter(&r.PtraceRegs)\n-}\n-\n-func newRegs(regs *syscall.PtraceRegs, setter func(*syscall.PtraceRegs) os.Error) Regs {\n-\tres := alphaRegs{}\n-\tres.PtraceRegs = *regs\n-\tres.setter = setter\n-\treturn &res\n-}"}, {"sha": "410f9321d3156b5bcb4d94ef07c0e3821f81c7a7", "filename": "libgo/go/net/newpollserver_rtems.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598fd331d0ea4bb6435d1045ff6c219f098db1a7/libgo%2Fgo%2Fnet%2Fnewpollserver_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598fd331d0ea4bb6435d1045ff6c219f098db1a7/libgo%2Fgo%2Fnet%2Fnewpollserver_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnewpollserver_rtems.go?ref=598fd331d0ea4bb6435d1045ff6c219f098db1a7", "patch": "@@ -9,7 +9,7 @@ import (\n \t\"syscall\"\n )\n \n-func selfConnectedTCPSocket() (pr, pw *os.File, err os.Error) {\n+func selfConnectedTCPSocket() (pr, pw *os.File, err error) {\n \t// See ../syscall/exec.go for description of ForkLock.\n \tsyscall.ForkLock.RLock()\n \tsockfd, e := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0)\n@@ -49,7 +49,7 @@ func selfConnectedTCPSocket() (pr, pw *os.File, err os.Error) {\n \treturn fd, fd, nil\n }\n \n-func newPollServer() (s *pollServer, err os.Error) {\n+func newPollServer() (s *pollServer, err error) {\n \ts = new(pollServer)\n \ts.cr = make(chan *netFD, 1)\n \ts.cw = make(chan *netFD, 1)"}, {"sha": "53a84b148814986d67591d2f5970db9b7b1ad946", "filename": "libgo/go/os/dir.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598fd331d0ea4bb6435d1045ff6c219f098db1a7/libgo%2Fgo%2Fos%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598fd331d0ea4bb6435d1045ff6c219f098db1a7/libgo%2Fgo%2Fos%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir.go?ref=598fd331d0ea4bb6435d1045ff6c219f098db1a7", "patch": "@@ -37,7 +37,7 @@ var elen int;\n // If n <= 0, Readdirnames returns all the names from the directory in\n // a single slice. In this case, if Readdirnames succeeds (reads all\n // the way to the end of the directory), it returns the slice and a\n-// nil os.Error. If it encounters an error before the end of the\n+// nil error. If it encounters an error before the end of the\n // directory, Readdirnames returns the names read until that point and\n // a non-nil error.\n func (file *File) Readdirnames(n int) (names []string, err error) {"}]}