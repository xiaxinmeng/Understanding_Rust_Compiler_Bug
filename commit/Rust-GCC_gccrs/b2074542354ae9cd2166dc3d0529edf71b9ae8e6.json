{"sha": "b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwNzQ1NDIzNTRhZTljZDIxNjZkYzNkMDUyOWVkZjcxYjlhZThlNg==", "commit": {"author": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2015-08-06T16:08:39Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2015-08-06T16:08:39Z"}, "message": "[AArch64] Improve TLS Descriptor pattern to release RTL loop IV opt\n\nThe instruction sequences for preparing argument for TLS descriptor\nruntime resolver and the later function call to resolver can actually be\nhoisted out of the loop.\n\nCurrently we can't because we have exposed the hard register X0 as\ndestination of \"set\".  While GCC's RTL data flow infrastructure will\nskip or do very conservative assumption when hard register involved in\nand thus some loop IV opportunities are missed.\n\nThis patch add another \"tlsdesc_small_pseudo_<mode>\" pattern, and avoid\nexpose x0 to gcc generic code.\n\nGenerally, we define a new register class FIXED_R0 which only contains register\n0, so the instruction sequences generated from the new add pattern is the same\nas tlsdesc_small_<mode>, while the operand 0 is wrapped as pseudo register that\nRTL IV opt can handle it.\n\nIdeally, we should allow operand 0 to be any pseudo register, but then\nwe can't model the override of x0 caused by the function call which is\nhidded by the UNSPEC.\n\nSo here, we restricting operand 0 to be x0, the override of x0 can be\nreflected to the gcc.\n\n2015-08-06    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\t      Jiong Wang  <jiong.wang@arm.com>\ngcc/\n  * config/aarch64/aarch64.d (tlsdesc_small_pseudo_<mode>): New pattern.\n  * config/aarch64/aarch64.h (reg_class): New enumeration FIXED_REG0.\n  (REG_CLASS_NAMES): Likewise.\n  (REG_CLASS_CONTENTS): Likewise.\n  * config/aarch64/aarch64.c (aarch64_class_max_nregs): Likewise.\n  (aarch64_register_move_cost): Likewise.\n  (aarch64_load_symref_appropriately): Invoke the new added pattern if\n  possible.\n  * config/aarch64/constraints.md (Uc0): New constraint.\n\ngcc/testsuite/\n  * gcc.target/aarch64/tlsdesc_hoist.c: New testcase.\n\nFrom-SVN: r226683", "tree": {"sha": "85b92d1dc9bfcdf08b06afb7e66e63116496e627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85b92d1dc9bfcdf08b06afb7e66e63116496e627"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/comments", "author": null, "committer": null, "parents": [{"sha": "201fa0b3a0a4aaf53ec0bcd154f40e2f63a8d960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201fa0b3a0a4aaf53ec0bcd154f40e2f63a8d960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/201fa0b3a0a4aaf53ec0bcd154f40e2f63a8d960"}], "stats": {"total": 80, "additions": 75, "deletions": 5}, "files": [{"sha": "ffcd947a7d6f84561ac231d0d8442826960cce20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "patch": "@@ -1,3 +1,16 @@\n+2015-08-06    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\t      Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.d (tlsdesc_small_pseudo_<mode>): New pattern.\n+\t* config/aarch64/aarch64.h (reg_class): New enumeration FIXED_REG0.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_class_max_nregs): Likewise.\n+\t(aarch64_register_move_cost): Likewise.\n+\t(aarch64_load_symref_appropriately): Invoke the new added pattern if\n+\tpossible.\n+\t* config/aarch64/constraints.md (Uc0): New constraint.\n+\n 2015-08-06  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/constraints.md (Usf): Add the test of"}, {"sha": "6da7245a8534ef2e5e3a51b996913e4b13c7b8ce", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "patch": "@@ -1048,12 +1048,26 @@ aarch64_load_symref_appropriately (rtx dest, rtx imm,\n \n \tgcc_assert (mode == Pmode || mode == ptr_mode);\n \n-\t/* In ILP32, the got entry is always of SImode size.  Unlike\n-\t   small GOT, the dest is fixed at reg 0.  */\n-\tif (TARGET_ILP32)\n-\t  emit_insn (gen_tlsdesc_small_si (imm));\n+\tif (can_create_pseudo_p ())\n+\t  {\n+\t    rtx reg = gen_reg_rtx (mode);\n+\n+\t    if (TARGET_ILP32)\n+\t      emit_insn (gen_tlsdesc_small_pseudo_si (imm, reg));\n+\t    else\n+\t      emit_insn (gen_tlsdesc_small_pseudo_di (imm, reg));\n+\n+\t    emit_use (reg);\n+\t  }\n \telse\n-\t  emit_insn (gen_tlsdesc_small_di (imm));\n+\t  {\n+\t    /* In ILP32, the got entry is always of SImode size.  Unlike\n+\t       small GOT, the dest is fixed at reg 0.  */\n+\t    if (TARGET_ILP32)\n+\t      emit_insn (gen_tlsdesc_small_si (imm));\n+\t    else\n+\t      emit_insn (gen_tlsdesc_small_di (imm));\n+\t  }\n \ttp = aarch64_load_tp (NULL);\n \n \tif (mode != Pmode)"}, {"sha": "5e8f210af03dfd631b5aba205407fc1591b282f1", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "patch": "@@ -4549,6 +4549,23 @@\n   [(set_attr \"type\" \"call\")\n    (set_attr \"length\" \"16\")])\n \n+;; The same as tlsdesc_small_<mode> except that we don't expose hard register X0\n+;; as the destination of set as it will cause trouble for RTL loop iv.\n+;; RTL loop iv will abort ongoing optimization once it finds there is hard reg\n+;; as destination of set.  This pattern thus could help these tlsdesc\n+;; instruction sequences hoisted out of loop.\n+(define_insn \"tlsdesc_small_pseudo_<mode>\"\n+  [(set (match_operand:PTR 1 \"register_operand\" \"=r\")\n+        (unspec:PTR [(match_operand 0 \"aarch64_valid_symref\" \"S\")]\n+\t\t   UNSPEC_TLSDESC))\n+   (clobber (reg:DI R0_REGNUM))\n+   (clobber (reg:DI LR_REGNUM))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_TLS_DESC\"\n+  \"adrp\\\\tx0, %A0\\;ldr\\\\t%<w>1, [x0, #%L0]\\;add\\\\t<w>0, <w>0, %L0\\;.tlsdesccall\\\\t%0\\;blr\\\\t%1\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"16\")])\n+\n (define_insn \"stack_tie\"\n   [(set (mem:BLK (scratch))\n \t(unspec:BLK [(match_operand:DI 0 \"register_operand\" \"rk\")"}, {"sha": "0d4937c3b54fe87fbc6af083ca432702220d6aec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "patch": "@@ -1,3 +1,7 @@\n+2015-08-06  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* gcc.target/aarch64/tlsdesc_hoist.c: New testcase.\n+\n 2015-08-06  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.target/aarch64/noplt_3.c: New testcase."}, {"sha": "a1fd3b0f09f77fa6fbc4d6e404c2945150ea3813", "filename": "gcc/testsuite/gcc.target/aarch64/tlsdesc_hoist.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftlsdesc_hoist.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2074542354ae9cd2166dc3d0529edf71b9ae8e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftlsdesc_hoist.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftlsdesc_hoist.c?ref=b2074542354ae9cd2166dc3d0529edf71b9ae8e6", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls_native } */\n+/* { dg-options \"-O2 -fpic -fdump-rtl-loop2_invariant\" } */\n+/* { dg-skip-if \"-mcmodel=large, no support for -fpic\" { aarch64-*-* }  { \"-mcmodel=large\" } { \"\" } } */\n+\n+int cal (int, int);\n+__thread int tls_data;\n+\n+int\n+foo (int bound)\n+{\n+  int i = 0;\n+  int sum = 0;\n+\n+  for (i; i < bound; i++)\n+    sum = cal (sum, tls_data);\n+\n+  return sum;\n+}\n+\n+/* Insn sequences for TLS descriptor should be hoisted out of the loop.  */\n+/* { dg-final { scan-rtl-dump \"Decided\" \"loop2_invariant\" } } */"}]}