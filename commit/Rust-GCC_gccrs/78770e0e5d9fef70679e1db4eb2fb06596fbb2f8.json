{"sha": "78770e0e5d9fef70679e1db4eb2fb06596fbb2f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg3NzBlMGU1ZDlmZWY3MDY3OWUxZGI0ZWIyZmIwNjU5NmZiYjJmOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-08-03T12:00:45Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-08-03T12:00:45Z"}, "message": "aarch64: Add gather_load_xNN_cost tuning fields\n\nThis patch adds tuning fields for the total cost of a gather load\ninstruction.  Until now, we've costed them as one scalar load\nper element instead.  Those scalar_load-based values are also\nwhat the patch uses to fill in the new fields for existing\ncost structures.\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (sve_vec_cost):\n\tAdd gather_load_x32_cost and gather_load_x64_cost.\n\t* config/aarch64/aarch64.c (generic_sve_vector_cost)\n\t(a64fx_sve_vector_cost, neoversev1_sve_vector_cost): Update\n\taccordingly, using the values given by the scalar_load * number\n\tof elements calculation that we used previously.\n\t(aarch64_detect_vector_stmt_subtype): Use the new fields.", "tree": {"sha": "3ec61a5010e46ce53296a6c27a57de74492971a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ec61a5010e46ce53296a6c27a57de74492971a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b585f0112f293ace8fadc0c7ace59230140b7472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b585f0112f293ace8fadc0c7ace59230140b7472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b585f0112f293ace8fadc0c7ace59230140b7472"}], "stats": {"total": 28, "additions": 28, "deletions": 0}, "files": [{"sha": "b91eeeba1012ef830f8bb3535c7c81c29afccc17", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=78770e0e5d9fef70679e1db4eb2fb06596fbb2f8", "patch": "@@ -259,12 +259,16 @@ struct sve_vec_cost : simd_vec_cost\n \t\t\t  unsigned int fadda_f16_cost,\n \t\t\t  unsigned int fadda_f32_cost,\n \t\t\t  unsigned int fadda_f64_cost,\n+\t\t\t  unsigned int gather_load_x32_cost,\n+\t\t\t  unsigned int gather_load_x64_cost,\n \t\t\t  unsigned int scatter_store_elt_cost)\n     : simd_vec_cost (base),\n       clast_cost (clast_cost),\n       fadda_f16_cost (fadda_f16_cost),\n       fadda_f32_cost (fadda_f32_cost),\n       fadda_f64_cost (fadda_f64_cost),\n+      gather_load_x32_cost (gather_load_x32_cost),\n+      gather_load_x64_cost (gather_load_x64_cost),\n       scatter_store_elt_cost (scatter_store_elt_cost)\n   {}\n \n@@ -279,6 +283,11 @@ struct sve_vec_cost : simd_vec_cost\n   const int fadda_f32_cost;\n   const int fadda_f64_cost;\n \n+  /* The cost of a gather load instruction.  The x32 value is for loads\n+     of 32-bit elements and the x64 value is for loads of 64-bit elements.  */\n+  const int gather_load_x32_cost;\n+  const int gather_load_x64_cost;\n+\n   /* The per-element cost of a scatter store.  */\n   const int scatter_store_elt_cost;\n };"}, {"sha": "36f1180891637fa531655f60cdd8750a1ece867d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78770e0e5d9fef70679e1db4eb2fb06596fbb2f8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=78770e0e5d9fef70679e1db4eb2fb06596fbb2f8", "patch": "@@ -675,6 +675,8 @@ static const sve_vec_cost generic_sve_vector_cost =\n   2, /* fadda_f16_cost  */\n   2, /* fadda_f32_cost  */\n   2, /* fadda_f64_cost  */\n+  4, /* gather_load_x32_cost  */\n+  2, /* gather_load_x64_cost  */\n   1 /* scatter_store_elt_cost  */\n };\n \n@@ -744,6 +746,8 @@ static const sve_vec_cost a64fx_sve_vector_cost =\n   13, /* fadda_f16_cost  */\n   13, /* fadda_f32_cost  */\n   13, /* fadda_f64_cost  */\n+  64, /* gather_load_x32_cost  */\n+  32, /* gather_load_x64_cost  */\n   1 /* scatter_store_elt_cost  */\n };\n \n@@ -1739,6 +1743,8 @@ static const sve_vec_cost neoversev1_sve_vector_cost =\n   19, /* fadda_f16_cost  */\n   11, /* fadda_f32_cost  */\n   8, /* fadda_f64_cost  */\n+  32, /* gather_load_x32_cost  */\n+  16, /* gather_load_x64_cost  */\n   3 /* scatter_store_elt_cost  */\n };\n \n@@ -14958,6 +14964,19 @@ aarch64_detect_vector_stmt_subtype (vec_info *vinfo, vect_cost_for_stmt kind,\n       && DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info)))\n     return simd_costs->store_elt_extra_cost;\n \n+  /* Detect SVE gather loads, which are costed as a single scalar_load\n+     for each element.  We therefore need to divide the full-instruction\n+     cost by the number of elements in the vector.  */\n+  if (kind == scalar_load\n+      && sve_costs\n+      && STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) == VMAT_GATHER_SCATTER)\n+    {\n+      unsigned int nunits = vect_nunits_for_cost (vectype);\n+      if (GET_MODE_UNIT_BITSIZE (TYPE_MODE (vectype)) == 64)\n+\treturn { sve_costs->gather_load_x64_cost, nunits };\n+      return { sve_costs->gather_load_x32_cost, nunits };\n+    }\n+\n   /* Detect cases in which a scalar_store is really storing one element\n      in a scatter operation.  */\n   if (kind == scalar_store"}]}