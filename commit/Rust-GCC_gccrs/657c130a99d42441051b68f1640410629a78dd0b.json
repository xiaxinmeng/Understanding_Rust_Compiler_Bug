{"sha": "657c130a99d42441051b68f1640410629a78dd0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU3YzEzMGE5OWQ0MjQ0MTA1MWI2OGYxNjQwNDEwNjI5YTc4ZGQwYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-08T17:34:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-08T17:34:33Z"}, "message": "invoke.texi: Remove documentation for -fsquangle and -fname-mangling-version.\n\n\t* invoke.texi: Remove documentation for -fsquangle and\n\t-fname-mangling-version.\n\n\tRemove old ABI mangling code.\n\t* cp-tree.h (cp_tree_index): Remove CPTI_TINFO_DECL_ID and\n\tCPTI_TINFO_VAR_ID.\n\t(tinfo_decl_id): Remove.\n\t(tinfo_var_id): Likewise.\n\t(name_mangling_version): Likewise.\n\t(flag_do_squangling): Likewise.\n\t(get_vtt_name): Likewise.\n\t(init_method): Likewise.\n\t(build_overload_name): Likewise.\n\t(build_static_name): Likewise.\n\t(build_decl_overload_real): Likewise.\n\t(build_overload_with_type): Likewise.\n\t(build_destructor_name): Likewise.\n\t(get_id_2): Likewise.\n\t(get_ctor_vtbl_name): Likewise.\n\t(mangle_typeinfo_fn_for_type): New function.\n\t(mangle_java_reflection_var_for_type): Likewise.\n\t* call.c (build_new_method_call): Use mangle_vtt_for_type.\n\t* class.c (get_vtable_name): Remove.\n\t(get_vtt_name): Remove.\n\t(get_vtable_decl): Use mangle_vtbl_for_type.\n\t(build_vtt): Likewise.\n\t(build_ctor_vtbl_group): Remove old ABI mangling support.\n\t* decl.c (pushtag): Likewise.\n\t(maybe_commonize_var): Use set_mangled_name_for_decl.\n\t(grokfndecl): Remove old ABI mangling support.\n\t(grokvardecl): Likewise.\n\t(grokdeclarator): Likewise.\n\t(grok_op_properties): Adjust use of DEF_OPERATOR.\n\t* decl2.c (name_mangling_version): Remove.\n\t(lang_f_options): Remove squangle.\n\t(unsupported_options): Add squangle.\n\t(lang_decode_options): Don't set flag_do_squangling.  Issue a\n\twarning for -fname-mangling-version.\n\t(grokclassfn): Remove old ABI mangling support.\n\t(finish_static_data_member_decl): Likewise.\n\t(grokfield): Likewise.\n\t(grokoptypename): Likewise.\n\t(get_sentry): Likewise.\n\t* init.c (build_java_class_ref): Use\n\tmangle_java_reflection_var_for_type.\n\t* lex.c (init_operators): Adjust use of DEF_OPERATOR.\n\t(init_parse): Call init_mangle, not init_method.\n\t* mangle.c (write_special_name_constructor): Handle\n\tmaybe-in-charge constructors.\n\t(write_special_name_destructor): Handle\n\tmaybe-in-charge destructors.\n\t(write_expression): Tweak code to handle non-type template\n\targuments with reference type.\n\t(mangle_typeinfo_fn_for_type): New function.\n\t(mangle_java_reflection_var_for_type): Likewise.\n\t(mangle_conv_op_name_for_type): Don't use a name that the user\n\tcould type.\n\t* method.c (enum mangling_flags): Remove.\n\t(mangling_flags): Likewise.\n\t(obstack_chunk_alloc): Likewise.\n\t(obstack_chunk_free): Likewise.\n\t(OB_INIT): Likewise.\n\t(OB_PUTC): Likewise.\n\t(OB_PUTC2): Likewise.\n\t(OB_PUTS): Likewise.\n\t(OB_PUTID): Likewise.\n\t(OB_PUTCP): Likewise.\n\t(OB_FINISH): Likewise.\n\t(OB_LAST): Likewise.\n\t(btypelist): Likewise.\n\t(ktypelist): Likewise.\n\t(maxbtype): Likewise.\n\t(maxktype): Likewise.\n\t(typevec): Likewise.\n\t(maxtype): Likewise.\n\t(init_method): Likewise.\n\t(digit_buffer): Likewise.\n\t(nofold): Likewise.\n\t(start_squangling): Likewise.\n\t(end_squangling): Likewise.\n\t(icat): Likewise.\n\t(dicat): Likewise.\n\t(old_backref_index): Likewise.\n\t(flush_repeats): Likewise.\n\t(is_back_referenceable_type): Likewise.\n\t(issue_nrepeats): Likewise.\n\t(check_ktype): Likewise.\n\t(issue_ktype): Likewise.\n\t(build_overload_nested_name): Likewise.\n\t(build_underscore_int): Likewise.\n\t(build_overload_scope_ref): Likewise.\n\t(mangle_expression): Likewise.\n\t(build_overload_int): Likewise.\n\t(mangled_C9x_name): Likewise.\n\t(build_overload_value): Likewise.\n\t(build_template_template_parm_names): Likewise.\n\t(build_template_parm_names): Likewise.\n\t(build_overload_identifier): Likewise.\n\t(build_qualified_name): Likewise.\n\t(build_mangled_name_for_type_with_Gcode): Likewise.\n\t(build_mangled_name_for_type): Likewise.\n\t(build_overload_name): Likewise.\n\t(build_mangled_name): Likewise.\n\t(process_modifiers): Likewise.\n\t(check_btype): Likewise.\n\t(process_overload_item): Likewise.\n\t(build_static_name): Likewise.\n\t(build_decl_overload_real): Likewise.\n\t(set_mangled_name_for_decl): Remove old ABI mangling support.\n\t(build_typename_overload): Remove.\n\t(build_overload_with_type): Remove.\n\t(get_id_2): Remove.\n\t(get_ctor_vtbl_name): Remove.\n\t(build_destructor_name): Likewise.\n\t(set_mangled_name_for_decl): Likewise.\n\t(make_thunk): Remove old ABI mangling support.\n\t* operators.def: Likewise.\n\t* pt.c (check_explicit_specialization): Don't call\n\tset_mangled_name_for_template_decl.\n\t(lookup_template_class): Remove old ABI mangling support.\n\t(tsubst_friend_function): Update comment.\n\t(tsubst_decl): Remove old ABI mangling support.\n\t(tsubst_copy): Likewise.\n\t(set_mangled_name_for_template_decl): Remove.\n\t* rtti.c (init_rtti_processing): Use std_identifier.  Don't set\n\ttinfo_decl_id or tinfo_var_id.\n\t(get_tinfo_var): Use mangle_typeinfo_for_type.\n\t(tinfo_name): Remove old ABI mangling support.\n\t(get_tinfo_decl): Likewise.\n\t(tinfo_base_init): Likewise.\n\t(create_real_tinfo_var): Use a name that the user can't type.\n\n\t* tinfo2.cc (BUILTIN): Adjust to use new mangling.\n\nFrom-SVN: r34458", "tree": {"sha": "05fb2eb51daae6893a4a0ff5e95026d9f771681c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05fb2eb51daae6893a4a0ff5e95026d9f771681c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/657c130a99d42441051b68f1640410629a78dd0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/657c130a99d42441051b68f1640410629a78dd0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/657c130a99d42441051b68f1640410629a78dd0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/657c130a99d42441051b68f1640410629a78dd0b/comments", "author": null, "committer": null, "parents": [{"sha": "21217bd0046bac65c93395d55186771c2633af04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21217bd0046bac65c93395d55186771c2633af04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21217bd0046bac65c93395d55186771c2633af04"}], "stats": {"total": 2654, "additions": 338, "deletions": 2316}, "files": [{"sha": "c3fb268a20c34be0502a2b135d370f663d867415", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -1,3 +1,8 @@\n+2000-06-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* invoke.texi: Remove documentation for -fsquangle and\n+\t-fname-mangling-version.\n+\n 2000-06-08  James E. Wilson  <wilson@cygnus.com>\n \n \t* dwarf2out.c (ASM_OUTPUT_DWARF_DATA8): Add new macro that uses"}, {"sha": "d280f9ce6ee20357854845fcdb03559f0a669e0c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -1,3 +1,136 @@\n+2000-06-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRemove old ABI mangling code.\n+\t* cp-tree.h (cp_tree_index): Remove CPTI_TINFO_DECL_ID and\n+\tCPTI_TINFO_VAR_ID.\n+\t(tinfo_decl_id): Remove.\n+\t(tinfo_var_id): Likewise.\n+\t(name_mangling_version): Likewise.\n+\t(flag_do_squangling): Likewise.\n+\t(get_vtt_name): Likewise.\n+\t(init_method): Likewise.\n+\t(build_overload_name): Likewise.\n+\t(build_static_name): Likewise.\n+\t(build_decl_overload_real): Likewise.\n+\t(build_overload_with_type): Likewise.\n+\t(build_destructor_name): Likewise.\n+\t(get_id_2): Likewise.\n+\t(get_ctor_vtbl_name): Likewise.\n+\t(mangle_typeinfo_fn_for_type): New function.\n+\t(mangle_java_reflection_var_for_type): Likewise.\n+\t* call.c (build_new_method_call): Use mangle_vtt_for_type.\n+\t* class.c (get_vtable_name): Remove.\n+\t(get_vtt_name): Remove.\n+\t(get_vtable_decl): Use mangle_vtbl_for_type.\n+\t(build_vtt): Likewise.\n+\t(build_ctor_vtbl_group): Remove old ABI mangling support.\n+\t* decl.c (pushtag): Likewise.\n+\t(maybe_commonize_var): Use set_mangled_name_for_decl.\n+\t(grokfndecl): Remove old ABI mangling support.\n+\t(grokvardecl): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(grok_op_properties): Adjust use of DEF_OPERATOR.\n+\t* decl2.c (name_mangling_version): Remove.\n+\t(lang_f_options): Remove squangle.\n+\t(unsupported_options): Add squangle.\n+\t(lang_decode_options): Don't set flag_do_squangling.  Issue a\n+\twarning for -fname-mangling-version.\n+\t(grokclassfn): Remove old ABI mangling support.\n+\t(finish_static_data_member_decl): Likewise.\n+\t(grokfield): Likewise.\n+\t(grokoptypename): Likewise.\n+\t(get_sentry): Likewise.\n+\t* init.c (build_java_class_ref): Use\n+\tmangle_java_reflection_var_for_type.\n+\t* lex.c (init_operators): Adjust use of DEF_OPERATOR.\n+\t(init_parse): Call init_mangle, not init_method.\n+\t* mangle.c (write_special_name_constructor): Handle\n+\tmaybe-in-charge constructors.\n+\t(write_special_name_destructor): Handle\n+\tmaybe-in-charge destructors.\n+\t(write_expression): Tweak code to handle non-type template\n+\targuments with reference type.\n+\t(mangle_typeinfo_fn_for_type): New function.\n+\t(mangle_java_reflection_var_for_type): Likewise.\n+\t(mangle_conv_op_name_for_type): Don't use a name that the user\n+\tcould type.\n+\t* method.c (enum mangling_flags): Remove.\n+\t(mangling_flags): Likewise.\n+\t(obstack_chunk_alloc): Likewise.\n+\t(obstack_chunk_free): Likewise.\n+\t(OB_INIT): Likewise.\n+\t(OB_PUTC): Likewise.\n+\t(OB_PUTC2): Likewise.\n+\t(OB_PUTS): Likewise.\n+\t(OB_PUTID): Likewise.\n+\t(OB_PUTCP): Likewise.\n+\t(OB_FINISH): Likewise.\n+\t(OB_LAST): Likewise.\n+\t(btypelist): Likewise.\n+\t(ktypelist): Likewise.\n+\t(maxbtype): Likewise.\n+\t(maxktype): Likewise.\n+\t(typevec): Likewise.\n+\t(maxtype): Likewise.\n+\t(init_method): Likewise.\n+\t(digit_buffer): Likewise.\n+\t(nofold): Likewise.\n+\t(start_squangling): Likewise.\n+\t(end_squangling): Likewise.\n+\t(icat): Likewise.\n+\t(dicat): Likewise.\n+\t(old_backref_index): Likewise.\n+\t(flush_repeats): Likewise.\n+\t(is_back_referenceable_type): Likewise.\n+\t(issue_nrepeats): Likewise.\n+\t(check_ktype): Likewise.\n+\t(issue_ktype): Likewise.\n+\t(build_overload_nested_name): Likewise.\n+\t(build_underscore_int): Likewise.\n+\t(build_overload_scope_ref): Likewise.\n+\t(mangle_expression): Likewise.\n+\t(build_overload_int): Likewise.\n+\t(mangled_C9x_name): Likewise.\n+\t(build_overload_value): Likewise.\n+\t(build_template_template_parm_names): Likewise.\n+\t(build_template_parm_names): Likewise.\n+\t(build_overload_identifier): Likewise.\n+\t(build_qualified_name): Likewise.\n+\t(build_mangled_name_for_type_with_Gcode): Likewise.\n+\t(build_mangled_name_for_type): Likewise.\n+\t(build_overload_name): Likewise.\n+\t(build_mangled_name): Likewise.\n+\t(process_modifiers): Likewise.\n+\t(check_btype): Likewise.\n+\t(process_overload_item): Likewise.\n+\t(build_static_name): Likewise.\n+\t(build_decl_overload_real): Likewise.\n+\t(set_mangled_name_for_decl): Remove old ABI mangling support.\n+\t(build_typename_overload): Remove.\n+\t(build_overload_with_type): Remove.\n+\t(get_id_2): Remove.\n+\t(get_ctor_vtbl_name): Remove.\n+\t(build_destructor_name): Likewise.\n+\t(set_mangled_name_for_decl): Likewise.\n+\t(make_thunk): Remove old ABI mangling support.\n+\t* operators.def: Likewise.\n+\t* pt.c (check_explicit_specialization): Don't call\n+\tset_mangled_name_for_template_decl.\n+\t(lookup_template_class): Remove old ABI mangling support.\n+\t(tsubst_friend_function): Update comment.\n+\t(tsubst_decl): Remove old ABI mangling support.\n+\t(tsubst_copy): Likewise.\n+\t(set_mangled_name_for_template_decl): Remove.\n+\t* rtti.c (init_rtti_processing): Use std_identifier.  Don't set\n+\ttinfo_decl_id or tinfo_var_id.\n+\t(get_tinfo_var): Use mangle_typeinfo_for_type.\n+\t(tinfo_name): Remove old ABI mangling support.\n+\t(get_tinfo_decl): Likewise.\n+\t(tinfo_base_init): Likewise.\n+\t(create_real_tinfo_var): Use a name that the user can't type.\n+\n+\t* tinfo2.cc (BUILTIN): Adjust to use new mangling.\n+\t\n 2000-06-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* method.c (make_thunk): Clear DECL_VTT_PARM in thunk."}, {"sha": "27f012d35df71e06da541ebe710537f53c3337a2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -4332,7 +4332,8 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  /* If the current function is a complete object constructor\n \t     or destructor, then we fetch the VTT directly.\n \t     Otherwise, we look it up using the VTT we were given.  */\n-\t  vtt = IDENTIFIER_GLOBAL_VALUE (get_vtt_name (current_class_type));\n+\t  vtt = IDENTIFIER_GLOBAL_VALUE (mangle_vtt_for_type\n+\t\t\t\t\t (current_class_type));\n \t  vtt = build_unary_op (ADDR_EXPR, vtt, /*noconvert=*/1);\n \t  vtt = build (COND_EXPR, TREE_TYPE (vtt), \n \t\t       DECL_USE_VTT_PARM (current_function_decl),"}, {"sha": "922c2e6a754c9052015d3e6005f97cd6fb3ad678", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -91,7 +91,6 @@ static tree get_vfield_name PARAMS ((tree));\n static void finish_struct_anon PARAMS ((tree));\n static tree build_vbase_pointer PARAMS ((tree, tree));\n static tree build_vtable_entry PARAMS ((tree, tree, tree));\n-static tree get_vtable_name PARAMS ((tree));\n static tree get_derived_offset PARAMS ((tree, tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n@@ -628,34 +627,6 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n   return build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n }\n \n-/* Return the name of the virtual function table (as an IDENTIFIER_NODE)\n-   for the given TYPE.  */\n-\n-static tree\n-get_vtable_name (type)\n-     tree type;\n-{\n-  if (flag_new_abi)\n-    return mangle_vtbl_for_type (type);\n-  else\n-    return build_overload_with_type (get_identifier (VTABLE_NAME_PREFIX),\n-\t\t\t\t     type);\n-}\n-\n-/* Return an IDENTIFIER_NODE for the name of the virtual table table\n-   for TYPE.  */\n-\n-tree\n-get_vtt_name (type)\n-     tree type;\n-{\n-  if (flag_new_abi)\n-    return mangle_vtt_for_type (type);\n-  else\n-    return build_overload_with_type (get_identifier (VTT_NAME_PREFIX),\n-\t\t\t\t     type);\n-}\n-\n /* Return the offset to the main vtable for a given base BINFO.  */\n \n tree\n@@ -732,7 +703,7 @@ get_vtable_decl (type, complete)\n      tree type;\n      int complete;\n {\n-  tree name = get_vtable_name (type);\n+  tree name = mangle_vtbl_for_type (type);\n   tree decl = IDENTIFIER_GLOBAL_VALUE (name);\n   \n   if (decl)\n@@ -6587,7 +6558,7 @@ build_vtt (t)\n   type = build_cplus_array_type (const_ptr_type_node, type);\n \t\t\t\t \n   /* Now, build the VTT object itself.  */\n-  vtt = build_vtable (t, get_vtt_name (t), type);\n+  vtt = build_vtable (t, mangle_vtt_for_type (t), type);\n   pushdecl_top_level (vtt);\n   initialize_array (vtt, inits);\n }\n@@ -6771,10 +6742,7 @@ build_ctor_vtbl_group (binfo, t)\n   tree id;\n \n   /* See if we've already create this construction vtable group.  */\n-  if (flag_new_abi)\n-    id = mangle_ctor_vtbl_for_type (t, binfo);\n-  else\n-    id = get_ctor_vtbl_name (t, binfo);\n+  id = mangle_ctor_vtbl_for_type (t, binfo);\n   if (IDENTIFIER_GLOBAL_VALUE (id))\n     return;\n "}, {"sha": "108c441cab76d7ec8a0986ae0cf89c623f648eb2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -555,9 +555,7 @@ enum cp_tree_index\n     CPTI_STD,\n     CPTI_ABI,\n     CPTI_TYPE_INFO_TYPE,\n-    CPTI_TINFO_DECL_ID,\n     CPTI_TINFO_DECL_TYPE,\n-    CPTI_TINFO_VAR_ID,\n     CPTI_ABORT_FNDECL,\n     CPTI_GLOBAL_DELETE_FNDECL,\n \n@@ -649,9 +647,7 @@ extern tree cp_global_trees[CPTI_MAX];\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n #define abi_node                        cp_global_trees[CPTI_ABI]\n #define type_info_type_node\t\tcp_global_trees[CPTI_TYPE_INFO_TYPE]\n-#define tinfo_decl_id\t\t\tcp_global_trees[CPTI_TINFO_DECL_ID]\n #define tinfo_decl_type\t\t\tcp_global_trees[CPTI_TINFO_DECL_TYPE]\n-#define tinfo_var_id                    cp_global_trees[CPTI_TINFO_VAR_ID]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n \n@@ -1177,19 +1173,10 @@ extern int flag_ansi;\n \n extern int flag_default_inline;\n \n-/* The name-mangling scheme to use.  Versions of gcc before 2.8 use\n-   version 0.  */\n-extern int name_mangling_version;\n-\n /* Nonzero if wchar_t should be `unsigned short' instead of whatever it\n    would normally be, for use with WINE.  */\n extern int flag_short_wchar;\n \n-/* Nonzero if squashed mangling is to be performed. \n-   This uses the B and K codes to reference previously seen class types \n-   and class qualifiers.       */\n-extern int flag_do_squangling;\n-\n /* Nonzero means generate separate instantiation control files and juggle\n    them at link time.  */\n extern int flag_use_repository;\n@@ -3925,7 +3912,6 @@ extern void maybe_note_name_used_in_class       PARAMS ((tree, tree));\n extern void note_name_declared_in_class         PARAMS ((tree, tree));\n extern tree get_vtbl_decl_for_binfo             PARAMS ((tree));\n extern tree in_charge_arg_for_name              PARAMS ((tree));\n-extern tree get_vtt_name                        PARAMS ((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));\n@@ -4292,23 +4278,14 @@ extern void yyhook\t\t\t\tPARAMS ((int));\n extern int cp_type_qual_from_rid                PARAMS ((tree));\n \n /* in method.c */\n-extern void init_method\t\t\t\tPARAMS ((void));\n-extern char *build_overload_name\t\tPARAMS ((tree, int, int));\n-extern tree build_static_name\t\t\tPARAMS ((tree, tree));\n-extern tree build_decl_overload_real            PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t       tree, int)); \n extern void set_mangled_name_for_decl           PARAMS ((tree));\n extern tree build_typename_overload\t\tPARAMS ((tree));\n-extern tree build_overload_with_type\t\tPARAMS ((tree, tree));\n-extern tree build_destructor_name\t\tPARAMS ((tree));\n extern tree build_opfncall\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPARAMS ((tree, tree));\n extern tree make_thunk\t\t\t\tPARAMS ((tree, int, int));\n extern void emit_thunk\t\t\t\tPARAMS ((tree));\n extern void synthesize_method\t\t\tPARAMS ((tree));\n-extern tree get_id_2\t\t\t\tPARAMS ((const char *, tree));\n extern tree implicitly_declare_fn               PARAMS ((special_function_kind, tree, int));\n-extern tree get_ctor_vtbl_name                  PARAMS ((tree, tree));\n \n /* In optimize.c */\n extern void optimize_function                   PARAMS ((tree));\n@@ -4747,6 +4724,8 @@ extern tree mangle_ctor_vtbl_for_type           PARAMS ((tree, tree));\n extern tree mangle_thunk                        PARAMS ((tree, int, int)); \n extern tree mangle_conv_op_name_for_type        PARAMS ((tree));\n extern tree mangle_guard_variable               PARAMS ((tree));\n+extern tree mangle_typeinfo_fn_for_type         PARAMS ((tree));\n+extern tree mangle_java_reflection_var_for_type PARAMS ((tree));\n \n /* -- end of C++ */\n "}, {"sha": "22bdb9ddd2dfd0661e359f4501581590025f88a8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 57, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -254,9 +254,7 @@ tree error_mark_list;\n \ttree global_delete_fndecl;\n \n    Used by RTTI\n-\ttree type_info_type_node, tinfo_decl_id, tinfo_decl_type;\n-\ttree tinfo_var_id;\n-\n+\ttree type_info_type_node, tinfo_decl_type;\n */\n \n tree cp_global_trees[CPTI_MAX];\n@@ -2892,13 +2890,7 @@ pushtag (name, type, globalize)\n \t    VARRAY_PUSH_TREE (local_classes, type);\n \n \t  if (!uses_template_parms (type)) \n-\t    {\n-\t      if (flag_new_abi)\n-\t\tDECL_ASSEMBLER_NAME (d) = mangle_type (type);\n-\t      else\n-\t\tDECL_ASSEMBLER_NAME (d)\n-\t\t  = get_identifier (build_overload_name (type, 1, 1));\n-\t    }\n+\t    DECL_ASSEMBLER_NAME (d) = mangle_type (type);\n         }\n       if (b->parm_flag == 2)\n \t{\n@@ -7626,8 +7618,7 @@ maybe_commonize_var (decl)\n \t     which we can't if it has been initialized.  */\n \n \t  if (TREE_PUBLIC (decl))\n-\t    DECL_ASSEMBLER_NAME (decl)\n-\t      = build_static_name (current_function_decl, DECL_NAME (decl));\n+\t    set_mangled_name_for_decl (decl);\n \t  else\n \t    {\n \t      cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n@@ -8977,9 +8968,9 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n     add_defarg_fn (decl);\n \n   /* Plain overloading: will not be grok'd by grokclassfn.  */\n-  if (! ctype && ! processing_template_decl\n+  if (! ctype && ! processing_template_decl \n       && !DECL_EXTERN_C_P (decl)\n-      && (! DECL_USE_TEMPLATE (decl) || name_mangling_version < 1))\n+      && !DECL_USE_TEMPLATE (decl))\n     set_mangled_name_for_decl (decl);\n \n   if (funcdef_flag)\n@@ -9094,13 +9085,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       /* DECL_ASSEMBLER_NAME is needed only for full-instantiated\n \t templates.  */\n       if (!uses_template_parms (decl))\n-\t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype,\n-\t\t\t\t\t\t\t    declarator);\n-\t}\n+\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n     }\n   else\n     {\n@@ -9125,13 +9110,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \n       context = DECL_CONTEXT (decl);\n       if (declarator && context && current_lang_name != lang_name_c) \n-\t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (decl) \n-\t      = build_static_name (context, declarator);\n-\t}\n+\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n     }\n \n   if (in_namespace)\n@@ -11166,24 +11145,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    DECL_NAME (CLASSTYPE_TI_TEMPLATE (type))\n \t      = TYPE_IDENTIFIER (type);\n \n-\t  if (flag_new_abi) \n-\t    DECL_ASSEMBLER_NAME (decl) = mangle_type (type);\n-\t  else\n-\t    {\n-\t      /* XXX Temporarily set the scope.\n-\t\t When returning, start_decl expects it as NULL_TREE,\n-\t\t and will then then set it using pushdecl. */\n-\t      my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 980404);\n-\t      if (current_class_type)\n-\t\tDECL_CONTEXT (decl) = current_class_type;\n-\t      else\n-\t\tDECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n-\t      \n-\t      DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n-\t      DECL_ASSEMBLER_NAME (decl)\n-\t\t= get_identifier (build_overload_name (type, 1, 1));\n-\t      DECL_CONTEXT (decl) = NULL_TREE;\n-\t    }\n+\t  DECL_ASSEMBLER_NAME (decl) = mangle_type (type);\n \n \t  /* FIXME remangle member functions; member functions of a\n \t     type with external linkage have external linkage.  */\n@@ -12336,17 +12298,17 @@ grok_op_properties (decl, virtualp, friendp)\n   else\n     do\n       {\n-#define DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGING, ARITY, ASSN_P)  \\\n-\tif (ansi_opname (CODE) == name)\t\t\t\t\t    \\\n-\t  {\t\t\t\t\t\t\t\t    \\\n-\t    operator_code = CODE;\t\t\t\t\t    \\\n-\t    break;\t\t\t\t\t\t\t    \\\n-\t  }\t\t\t\t\t\t\t\t    \\\n-\telse if (ansi_assopname (CODE) == name)\t\t\t\t    \\\n-\t  {\t\t\t\t\t\t\t\t    \\\n-\t    operator_code = CODE;\t\t\t\t\t    \\\n-\t    DECL_ASSIGNMENT_OPERATOR_P (decl) = 1;\t\t\t    \\\n-\t    break;\t\t\t\t\t\t\t    \\\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, ASSN_P)\t\\\n+\tif (ansi_opname (CODE) == name)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    operator_code = CODE;\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\telse if (ansi_assopname (CODE) == name)\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    operator_code = CODE;\t\t\t\t\\\n+\t    DECL_ASSIGNMENT_OPERATOR_P (decl) = 1;\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n \t  }\n \n #include \"operators.def\""}, {"sha": "872290d1a15e972f9d4c2bdaf093c86d26ca7cee", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 13, "deletions": 42, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -466,11 +466,6 @@ int flag_inline_trees = 0;\n \n int max_tinst_depth = 17;\n \n-/* The name-mangling scheme to use.  Must be 1 or greater to support\n-   template functions with identical types, but different template\n-   arguments.  */\n-int name_mangling_version = 2;\n-\n /* Nonzero if wchar_t should be `unsigned short' instead of whatever it\n    would normally be, for use with WINE.  */\n int flag_short_wchar;\n@@ -552,7 +547,6 @@ lang_f_options[] =\n   {\"permissive\", &flag_permissive, 1},\n   {\"repo\", &flag_use_repository, 1},\n   {\"rtti\", &flag_rtti, 1},\n-  {\"squangle\", &flag_do_squangling, 1},\n   {\"stats\", &flag_detailed_statistics, 1},\n   {\"strict-prototype\", &flag_strict_prototype, 1},\n   {\"use-cxa-atexit\", &flag_use_cxa_atexit, 1},\n@@ -570,7 +564,8 @@ static const char * const unsupported_options[] = {\n   \"enum-int-equiv\",\n   \"guiding-decls\",\n   \"nonnull-objects\",\n-  \"this-is-variable\",\n+  \"squangle\",\n+  \"this-is-variable\"\n };\n \n /* Compare two option strings, pointed two by P1 and P2, for use with\n@@ -665,22 +660,20 @@ lang_decode_option (argc, argv)\n       else if (!strcmp (p, \"new-abi\"))\n \t{\n \t  flag_new_abi = 1;\n-\t  flag_do_squangling = 1;\n \t  flag_vtable_thunks = 1;\n \t}\n       else if (!strcmp (p, \"no-new-abi\"))\n-\t{\n-\t  flag_new_abi = 0;\n-\t  flag_do_squangling = 0;\n-\t}\n+\tflag_new_abi = 0;\n       else if ((option_value\n                 = skip_leading_substring (p, \"template-depth-\")))\n \tmax_tinst_depth\n \t  = read_integral_parameter (option_value, p - 2, max_tinst_depth);\n       else if ((option_value\n                 = skip_leading_substring (p, \"name-mangling-version-\")))\n-\tname_mangling_version \n-\t  = read_integral_parameter (option_value, p - 2, name_mangling_version);\n+\t{\n+\t  warning (\"-f%s is no longer supported\", p);\n+\t  return 1;\n+\t}\n       else if ((option_value\n                 = skip_leading_substring (p, \"dump-translation-unit-\")))\n \t{\n@@ -1104,16 +1097,10 @@ grokclassfn (ctype, function, flags, quals)\n   if (flags == DTOR_FLAG)\n     {\n       DECL_DESTRUCTOR_P (function) = 1;\n-\n-      if (flag_new_abi) \n-\tset_mangled_name_for_decl (function);\n-      else\n-\tDECL_ASSEMBLER_NAME (function) = build_destructor_name (ctype);\n-\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n-  else\n-    set_mangled_name_for_decl (function);\n+\n+  set_mangled_name_for_decl (function);\n }\n \n /* Work on the expr used by alignof (this is only called by the parser).  */\n@@ -1580,11 +1567,7 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n   if (!asmspec && current_class_type)\n     {\n       DECL_INITIAL (decl) = error_mark_node;\n-      if (flag_new_abi)\n-\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-      else\n-\tDECL_ASSEMBLER_NAME (decl) \n-\t  = build_static_name (current_class_type, DECL_NAME (decl));\n+      DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n     }\n   if (! processing_template_decl)\n     {\n@@ -1715,13 +1698,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t name for this TYPE_DECL.  */\n       DECL_ASSEMBLER_NAME (value) = DECL_NAME (value);\n       if (!uses_template_parms (value)) \n-\t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (value) = mangle_type (TREE_TYPE (value));\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (value) =\n-\t      get_identifier (build_overload_name (TREE_TYPE (value), 1, 1));\n-\t}\n+\tDECL_ASSEMBLER_NAME (value) = mangle_type (TREE_TYPE (value));\n \n       if (processing_template_decl)\n \tvalue = push_template_decl (value);\n@@ -1907,10 +1884,7 @@ grokoptypename (declspecs, declarator)\n      tree declspecs, declarator;\n {\n   tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL_TREE);\n-  if (flag_new_abi)\n-    return mangle_conv_op_name_for_type (t);\n-  else\n-    return build_typename_overload (t);\n+  return mangle_conv_op_name_for_type (t);\n }\n \n /* When a function is declared with an initializer,\n@@ -2871,10 +2845,7 @@ get_sentry (decl)\n   tree sname;\n   tree sentry;\n \n-  if (!flag_new_abi)\n-    sname = get_id_2 (\"__sn\", DECL_ASSEMBLER_NAME (decl));\n-  else\n-    sname = mangle_guard_variable (decl);\n+  sname = mangle_guard_variable (decl);\n \n   /* For struct X foo __attribute__((weak)), there is a counter\n      __snfoo. Since base is already an assembler name, sname should"}, {"sha": "02f9ac9c7c60c7e90f4922853853ae25a76dd74f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -2138,17 +2138,14 @@ build_java_class_ref (type)\n      tree type;\n {\n   tree name, class_decl;\n-  static tree CL_prefix = NULL_TREE;\n-  if (CL_prefix == NULL_TREE)\n-    CL_prefix = get_identifier(\"_CL_\");\n   if (jclass_node == NULL_TREE)\n     {\n       jclass_node = IDENTIFIER_GLOBAL_VALUE (get_identifier(\"jclass\"));\n       if (jclass_node == NULL_TREE)\n \tfatal(\"call to Java constructor, while `jclass' undefined\");\n       jclass_node = TREE_TYPE (jclass_node);\n     }\n-  name = build_overload_with_type (CL_prefix, type);\n+  name = mangle_java_reflection_var_for_type (type);\n   class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n   if (class_decl == NULL_TREE)\n     {"}, {"sha": "d5f8cd4d059354fda83c55f7ec678b56fa56515f", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -466,7 +466,7 @@ init_operators ()\n   char buffer[256];\n   struct operator_name_info_t *oni;\n   \n-#define DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY, ASSN_P) \\\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, ASSN_P) \\\n   my_friendly_assert ((strlen (\"operator \") + strlen (NAME) + 1\t\t    \\\n \t\t       <= 256),\t\t\t\t\t\t    \\\n \t\t      20000526);\t\t\t\t\t    \\\n@@ -479,7 +479,7 @@ init_operators ()\n \t : &operator_name_info[(int) CODE]);\t\t\t\t    \\\n   oni->identifier = identifier;\t\t\t\t\t\t    \\\n   oni->name = NAME;\t\t\t\t\t\t\t    \\\n-  oni->mangled_name = flag_new_abi ? NEW_MANGLING : OLD_MANGLING;\n+  oni->mangled_name = MANGLING;\n \n #include \"operators.def\"\n #undef DEF_OPERATOR\n@@ -592,7 +592,7 @@ init_parse (filename)\n \t  (LAST_CPLUS_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (char *));\n \n   init_operators ();\n-  init_method ();\n+  init_mangle ();\n   init_error ();\n   gcc_obstack_init (&inline_text_obstack);\n   inline_text_firstobj = (char *) obstack_alloc (&inline_text_obstack, 0);"}, {"sha": "ed4692945a56fe48d77f79a5b0b82197d492a158", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -998,8 +998,10 @@ write_special_name_constructor (ctor)\n     write_string (\"C1\");\n   else if (DECL_BASE_CONSTRUCTOR_P (ctor))\n     write_string (\"C2\");\n-  else\n+  else if (flag_new_abi)\n     write_string (\"C*INTERNAL*\");\n+  else\n+    write_string (\"C1\");\n }\n \n /* Handle destructor productions of non-terminal <special-name>.\n@@ -1023,9 +1025,10 @@ write_special_name_destructor (dtor)\n     write_string (\"D1\");\n   else if (DECL_BASE_DESTRUCTOR_P (dtor))\n     write_string (\"D2\");\n-  else\n-    /* Old-ABI destructor.   */\n+  else if (flag_new_abi)\n     write_string (\"D*INTERNAL*\");\n+  else\n+    write_string (\"D0\");\n }\n \n /* Return the discriminator for ENTITY appearing inside\n@@ -1564,8 +1567,17 @@ write_expression (expr)\n       if (TREE_CODE (expr) == ADDR_EXPR\n \t  && TREE_TYPE (expr)\n \t  && TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE)\n-\texpr = TREE_OPERAND (expr, 0);\n+\t{\n+\t  expr = TREE_OPERAND (expr, 0);\n+\t  if (DECL_P (expr))\n+\t    {\n+\t      write_expression (expr);\n+\t      return;\n+\t    }\n \n+\t  code = TREE_CODE (expr);\n+\t}\n+      \n       /* If it wasn't any of those, recursively expand the expression.  */\n       write_string (operator_name_info[(int) code].mangled_name);\n \n@@ -1969,6 +1981,27 @@ mangle_typeinfo_for_type (type)\n   return mangle_special_for_type (type, \"TI\");\n }\n \n+/* Return the mangled name of the function that returns the typeinfo\n+   for TYPE.  */\n+\n+tree\n+mangle_typeinfo_fn_for_type (type)\n+     tree type;\n+{\n+  my_friendly_assert (!new_abi_rtti_p (), 20000608);\n+  return mangle_special_for_type (type, \"TF\");\n+}\n+\n+/* Return the name of the variable that represents TYPE at runtime in\n+   Java.  */\n+\n+tree\n+mangle_java_reflection_var_for_type (type)\n+     tree type;\n+{\n+  return mangle_special_for_type (type, \"TJ\");\n+}\n+\n /* Create an identifier for the mangled name of the NTBS containing\n    the mangled name of TYPE.  */\n \n@@ -2085,15 +2118,7 @@ mangle_thunk (fn_decl, offset, vcall_offset)\n \n /* Return an identifier for the mangled unqualified name for a\n    conversion operator to TYPE.  This mangling is not specified by the\n-   ABI spec; it is only used internally.\n-\n-   For compatibility with existing conversion operator mechanisms,\n-   the mangled form is `__op<type>' where <type> is the mangled\n-   representation of TYPE.  \n-\n-   FIXME: Though identifiers with starting with __op are reserved for\n-   the implementation, it would eventually be nice to use inaccessible\n-   names for these operators.  */\n+   ABI spec; it is only used internally.  */\n \n tree\n mangle_conv_op_name_for_type (type)\n@@ -2104,11 +2129,10 @@ mangle_conv_op_name_for_type (type)\n   /* Build the mangling for TYPE.  */\n   const char *mangled_type = mangle_type_string (type);\n   /* Allocate a temporary buffer for the complete name.  */\n-  char *op_name = (char *) xmalloc (strlen (OPERATOR_TYPENAME_FORMAT) \n+  char *op_name = (char *) xmalloc (strlen (\"operator \") \n \t\t\t\t    + strlen (mangled_type) + 1);\n   /* Assemble the mangling.  */\n-  strcpy (op_name, OPERATOR_TYPENAME_FORMAT);\n-  strcat (op_name, mangled_type);\n+  sprintf (op_name, \"operator %s\", mangled_type);\n   /* Find or create an identifier.  */\n   identifier = get_identifier (op_name);\n   /* Done with the temporary buffer.  */"}, {"sha": "349ed75887865c69bc0c02add7536a24aa62c439", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 1830, "changes": 1838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -37,1825 +37,26 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"tm_p.h\"\n \n-/* Various flags to control the mangling process.  */\n-\n-enum mangling_flags\n-{\n-  /* No flags.  */\n-  mf_none = 0,\n-  /* The thing we are presently mangling is part of a template type,\n-     rather than a fully instantiated type.  Therefore, we may see\n-     complex expressions where we would normally expect to see a\n-     simple integer constant.  */\n-  mf_maybe_uninstantiated = 1,\n-  /* When mangling a numeric value, use the form `_XX_' (instead of\n-     just `XX') if the value has more than one digit.  */\n-  mf_use_underscores_around_value = 2,\n-};\n-\n-typedef enum mangling_flags mangling_flags;\n-\n-/* TREE_LIST of the current inline functions that need to be\n-   processed.  */\n-struct pending_inline *pending_inlines;\n-\n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n-\n-/* Obstack where we build text strings for overloading, etc.  */\n-static struct obstack scratch_obstack;\n-static char *scratch_firstobj;\n-\n-static void icat PARAMS ((HOST_WIDE_INT));\n-static void dicat PARAMS ((HOST_WIDE_INT, HOST_WIDE_INT));\n-static int old_backref_index PARAMS ((tree));\n-static int flush_repeats PARAMS ((int, tree));\n-static void build_overload_identifier PARAMS ((tree));\n-static void build_overload_nested_name PARAMS ((tree));\n-static void mangle_expression PARAMS ((tree));\n-static void build_overload_int PARAMS ((tree, mangling_flags));\n-static void build_overload_identifier PARAMS ((tree));\n-static void build_qualified_name PARAMS ((tree));\n-static void build_overload_value PARAMS ((tree, tree, mangling_flags));\n-static void issue_nrepeats PARAMS ((int, tree));\n-static char *build_mangled_name PARAMS ((tree,int,int));\n-static void process_modifiers PARAMS ((tree));\n-static void process_overload_item PARAMS ((tree,int));\n-static void do_build_assign_ref PARAMS ((tree));\n-static void do_build_copy_constructor PARAMS ((tree));\n-static void build_template_template_parm_names PARAMS ((tree));\n-static void build_template_parm_names PARAMS ((tree, tree));\n-static void build_underscore_int PARAMS ((int));\n-static void start_squangling PARAMS ((void));\n-static void end_squangling PARAMS ((void));\n-static int check_ktype PARAMS ((tree, int));\n-static int issue_ktype PARAMS ((tree));\n-static void build_overload_scope_ref PARAMS ((tree));\n-static void build_mangled_template_parm_index PARAMS ((const char *, tree));\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-static void build_mangled_C9x_name PARAMS ((int));\n-#endif\n-static int is_back_referenceable_type PARAMS ((tree));\n-static int check_btype PARAMS ((tree));\n-static void build_mangled_name_for_type PARAMS ((tree));\n-static void build_mangled_name_for_type_with_Gcode PARAMS ((tree, int));\n-\n-# define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n-# define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n-# define OB_PUTC2(C1,C2)\t\\\n-  (obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))\n-# define OB_PUTS(S) (obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))\n-# define OB_PUTID(ID)  \\\n-  (obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),\t\\\n-\t\t IDENTIFIER_LENGTH (ID)))\n-# define OB_PUTCP(S) (obstack_grow (&scratch_obstack, (S), strlen (S)))\n-# define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n-# define OB_LAST() (obstack_next_free (&scratch_obstack)[-1])\n-\n-/* type tables for K and B type compression */\n-static varray_type btypelist;\n-static varray_type ktypelist;\n-\n-/* number of each type seen */\n-static size_t maxbtype;\n-static size_t maxktype;\n-\n-/* Array of types seen so far in top-level call to `build_mangled_name'.\n-   Allocated and deallocated by caller.  */\n-static varray_type typevec;\n-\n-/* Number of types interned by `build_mangled_name' so far.  */\n-static size_t maxtype;\n-\n-/* Called once to initialize method.c.  */\n-\n-void\n-init_method ()\n-{\n-  gcc_obstack_init (&scratch_obstack);\n-  scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n-  ggc_add_tree_varray_root (&btypelist, 1);\n-  ggc_add_tree_varray_root (&ktypelist, 1);\n-  ggc_add_tree_varray_root (&typevec, 1);\n-  if (flag_new_abi)\n-    init_mangle ();\n-}\n-\n-/* This must be large enough to hold any printed integer or floating-point\n-   value.  */\n-static char digit_buffer[128];\n-\n-\f\n-/* Here is where overload code starts.  */\n-\n-/* Nonzero if we should not try folding parameter types.  */\n-static int nofold;\n-\n-/* Nonzero if an underscore is required before adding a digit to the\n-   mangled name currently being built.  */\n-static int numeric_output_need_bar;\n-\n-static inline void\n-start_squangling ()\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200005222);\n-\n-  if (flag_do_squangling)\n-    {\n-      nofold = 0;\n-      maxbtype = 0;\n-      maxktype = 0;\n-      VARRAY_TREE_INIT (btypelist, 50, \"btypelist\");\n-      VARRAY_TREE_INIT (ktypelist, 50, \"ktypelist\");\n-    }\n-}\n-\n-static inline void\n-end_squangling ()\n-{\n-  if (flag_do_squangling)\n-    {\n-      VARRAY_FREE (ktypelist);\n-      VARRAY_FREE (btypelist);\n-      maxbtype = 0;\n-      maxktype = 0;\n-    }\n-}\n-\n-/* Code to concatenate an asciified integer to a string.  */\n-\n-static inline void\n-icat (i)\n-     HOST_WIDE_INT i;\n-{\n-  unsigned HOST_WIDE_INT ui;\n-\n-  /* Handle this case first, to go really quickly.  For many common values,\n-     the result of ui/10 below is 1.  */\n-  if (i == 1)\n-    {\n-      OB_PUTC ('1');\n-      return;\n-    }\n-\n-  if (i >= 0)\n-    ui = i;\n-  else\n-    {\n-      OB_PUTC ('m');\n-      ui = -i;\n-    }\n-\n-  if (ui >= 10)\n-    icat (ui / 10);\n-\n-  OB_PUTC ('0' + (ui % 10));\n-}\n-\n-static void\n-dicat (lo, hi)\n-     HOST_WIDE_INT lo, hi;\n-{\n-  unsigned HOST_WIDE_INT ulo, uhi, qlo, qhi;\n-\n-  if (hi >= 0)\n-    {\n-      uhi = hi;\n-      ulo = lo;\n-    }\n-  else\n-    {\n-      uhi = (lo == 0 ? -hi : -hi-1);\n-      ulo = -lo;\n-    }\n-  if (uhi == 0\n-      && ulo < ((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)))\n-    {\n-      icat (ulo);\n-      return;\n-    }\n-  /* Divide 2^HOST_WIDE_INT*uhi+ulo by 10. */\n-  qhi = uhi / 10;\n-  uhi = uhi % 10;\n-  qlo = uhi * (((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)) / 5);\n-  qlo += ulo / 10;\n-  ulo = ulo % 10;\n-  ulo += uhi * (((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)) % 5)\n-\t * 2;\n-  qlo += ulo / 10;\n-  ulo = ulo % 10;\n-  /* Quotient is 2^HOST_WIDE_INT*qhi+qlo, remainder is ulo. */\n-  dicat (qlo, qhi);\n-  OB_PUTC ('0' + ulo);\n-}\n-\n-/* Returns the index of TYPE in the typevec, or -1 if it's not there.  */\n-\n-static inline int\n-old_backref_index (type)\n-     tree type;\n-{\n-  size_t tindex;\n-\n-  if (! is_back_referenceable_type (type))\n-    return -1;\n-\n-  /* The entry for this parm is at maxtype-1, so don't look there for\n-     something to repeat.  */\n-  for (tindex = 0; tindex < maxtype - 1; ++tindex)\n-    if (same_type_p (VARRAY_TREE (typevec, tindex), type))\n-      break;\n-\n-  if (tindex == maxtype - 1)\n-    return -1;\n-\n-  return tindex;\n-}\n-\n-/* Old mangling style:  If TYPE has already been used in the parameter list,\n-   emit a backward reference and return non-zero; otherwise, return 0.\n-\n-   NREPEATS is the number of repeats we've recorded of this type, or 0 if\n-   this is the first time we've seen it and we're just looking to see if\n-   it had been used before.  */\n-\n-static inline int\n-flush_repeats (nrepeats, type)\n-     int nrepeats;\n-     tree type;\n-{\n-  int tindex = old_backref_index (type);\n-\n-  if (tindex == -1)\n-    {\n-      my_friendly_assert (nrepeats == 0, 990316);\n-      return 0;\n-    }\n-\n-  if (nrepeats > 1)\n-    {\n-      OB_PUTC ('N');\n-      icat (nrepeats);\n-      if (nrepeats > 9)\n-\tOB_PUTC ('_');\n-    }\n-  else\n-    OB_PUTC ('T');\n-  icat (tindex);\n-  if (tindex > 9)\n-    OB_PUTC ('_');\n-\n-  return 1;\n-}\n-\n-/* Returns nonzero iff this is a type to which we will want to make\n-   back-references (using the `B' code).  */\n-\n-static int\n-is_back_referenceable_type (type)\n-     tree type;\n-{\n-  /* For some reason, the Java folks don't want back refs on these.  */\n-  if (TYPE_FOR_JAVA (type))\n-    return 0;\n-\n-  switch (TREE_CODE (type)) \n-    {\n-    case BOOLEAN_TYPE:\n-      if (!flag_do_squangling)\n-\t/* Even though the mangling of this is just `b', we did\n-\t   historically generate back-references for it.  */\n-\treturn 1;\n-      /* Fall through.  */\n-      \n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case VOID_TYPE:\n-      /* These types have single-character manglings, so there's no\n-\t point in generating back-references.  */\n-      return 0;         \n-\n-    case TEMPLATE_TYPE_PARM:\n-      /* It would be a bit complex to demangle signatures correctly if\n-\t we generated back-references to these, and the manglings of\n-\t type parameters are short.  */\n-      return 0;\n-\n-    default:\n-      return 1;\n-    }\n-}\n-\n-/* Issue the squangling code indicating NREPEATS repetitions of TYPE,\n-   which was the last parameter type output.  */\n-\n-static void\n-issue_nrepeats (nrepeats, type)\n-     int nrepeats;\n-     tree type;\n-{\n-  if (nrepeats == 1 && !is_back_referenceable_type (type))\n-    /* For types whose manglings are short, don't bother using the\n-       repetition code if there's only one repetition, since the\n-       repetition code will be about as long as the ordinary mangling.  */ \n-    build_mangled_name_for_type (type);\n-  else\n-    {\n-      OB_PUTC ('n');\n-      icat (nrepeats);\n-      if (nrepeats > 9)\n-\tOB_PUTC ('_');\n-    }\n-}\n-\n-/* Check to see if a tree node has been entered into the Kcode typelist.\n-   If not, add it.  Returns -1 if it isn't found, otherwise returns the\n-   index.  */\n-\n-static int\n-check_ktype (node, add)\n-     tree node;\n-     int add;\n-{\n-  size_t x;\n-  tree localnode = node;\n-\n-  if (ktypelist == NULL)\n-    return -1;\n-\n-  if (TREE_CODE (node) == TYPE_DECL)\n-    localnode = TREE_TYPE (node);\n-\n-  for (x = 0; x < maxktype; x++)\n-    {\n-      if (same_type_p (localnode, VARRAY_TREE (ktypelist, x)))\n-        return x;\n-    }\n-  /* Didn't find it, so add it here.  */\n-  if (add)\n-    {\n-      if (VARRAY_SIZE (ktypelist) <= maxktype)\n-\tVARRAY_GROW (ktypelist, \n-\t\t     VARRAY_SIZE (ktypelist) * 3 / 2);\n-      VARRAY_TREE (ktypelist, maxktype) = localnode;\n-      maxktype++;\n-    }\n-  return -1;\n-}\n-\n-\n-static inline int\n-issue_ktype (decl)\n-     tree decl;\n-{\n-  int kindex;\n-  kindex = check_ktype (decl, FALSE);\n-  if (kindex != -1)\n-    {\n-      OB_PUTC ('K');\n-      icat (kindex);\n-      if (kindex > 9)\n-        OB_PUTC ('_');\n-      return TRUE;\n-    }\n-  return FALSE;\n-}\n-  \n-/* Build a representation for DECL, which may be an entity not at\n-   global scope.  If so, a marker indicating that the name is\n-   qualified has already been output, but the qualifying context has\n-   not.  */\n-\n-static void\n-build_overload_nested_name (decl)\n-     tree decl;\n-{\n-  tree context;\n-\n-  if (ktypelist && issue_ktype (decl))\n-      return;\n-\n-  if (decl == global_namespace)\n-    return;\n-\n-  context = CP_DECL_CONTEXT (decl);\n-\n-  /* try to issue a K type, and if we can't continue the normal path */\n-  if (!(ktypelist && issue_ktype (context)))\n-  {\n-    /* For a template type parameter, we want to output an 'Xn'\n-       rather than 'T' or some such. */\n-    if (TREE_CODE (context) == TEMPLATE_TYPE_PARM\n-        || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n-      build_mangled_name_for_type (context);\n-    else\n-    {\n-      if (TYPE_P (context))\n-        context = TYPE_NAME (context);\n-      build_overload_nested_name (context);\n-    }\n-  }\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      static int static_labelno;\n-\n-      tree name = DECL_ASSEMBLER_NAME (decl);\n-      char *label;\n-\n-      ASM_FORMAT_PRIVATE_NAME (label, IDENTIFIER_POINTER (name), static_labelno);\n-      static_labelno++;\n-\n-      if (numeric_output_need_bar)\n-\tOB_PUTC ('_');\n-      icat (strlen (label));\n-      OB_PUTCP (label);\n-      numeric_output_need_bar = 1;\n-    }\n-  else if (TREE_CODE (decl) == NAMESPACE_DECL)\n-    build_overload_identifier (DECL_NAME (decl));\n-  else\t\t\t\t/* TYPE_DECL */\n-    build_overload_identifier (decl);\n-}\n-\n-/* Output the decimal representation of I.  If I > 9, the decimal\n-   representation is preceeded and followed by an underscore.  */\n-\n-static void\n-build_underscore_int (i)\n-     int i;\n-{\n-  if (i > 9)\n-    OB_PUTC ('_');\n-  icat (i);\n-  if (i > 9)\n-    OB_PUTC ('_');\n-}\n-\n-static void\n-build_overload_scope_ref (value)\n-     tree value;\n-{\n-  OB_PUTC2 ('Q', '2');\n-  numeric_output_need_bar = 0;\n-  build_mangled_name_for_type (TREE_OPERAND (value, 0));\n-  build_overload_identifier (TREE_OPERAND (value, 1));\n-}\n-\n-/* VALUE is a complex expression.  Produce an appropriate mangling.\n-   (We are forced to mangle complex expressions when dealing with\n-   templates, and an expression involving template parameters appears\n-   in the type of a function parameter.)  */\n-\n-static void\n-mangle_expression (value)\n-     tree value;\n-{\n-  if (TREE_CODE (value) == SCOPE_REF)\n-    {\n-      build_overload_scope_ref (value);\n-      return;\n-    }\n-\n-  OB_PUTC ('E');\n-  numeric_output_need_bar = 0;\n-\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (value))))\n-    {\n-      int i;\n-      int operands = TREE_CODE_LENGTH (TREE_CODE (value));\n-      const char *name;\n-\n-      name = operator_name_info[TREE_CODE (value)].mangled_name;\n-      if (name == NULL)\n-\t/* On some erroneous inputs, we can get here with VALUE a\n-\t   LOOKUP_EXPR. We must survive this routine in order to issue\n-\t   a sensible error message, so we fall through to the case\n-\t   below.  */\n-\tgoto bad_value;\n-\n-      for (i = 0; i < operands; ++i)\n-\t{\n-\t  tree operand;\n-\t  enum tree_code tc;\n-\n-\t  /* We just outputted either the `E' or the name of the\n-\t     operator.  */\n-\t  numeric_output_need_bar = 0;\n-\n-\t  if (i != 0)\n-\t    /* Skip the leading underscores.  */\n-\t    OB_PUTCP (name + 2);\n-\n-\t  operand = TREE_OPERAND (value, i);\n-\t  tc = TREE_CODE (operand);\n-\n-\t  if (TREE_CODE_CLASS (tc) == 't')\n-\t    /* We can get here with sizeof, e.g.:\n-\t\t     \n-\t       template <class T> void f(A<sizeof(T)>);  */\n-\t    build_mangled_name_for_type (operand);\n-\t  else\n-\t    build_overload_value (TREE_TYPE (operand),\n-\t\t\t\t  operand,\n-\t\t\t\t  mf_maybe_uninstantiated);\n-\t}\n-    }\n-  else\n-    {\n-      /* We don't ever want this output, but it's\n-\t inconvenient not to be able to build the string.\n-\t This should cause assembler errors we'll notice.  */\n-\t    \n-      static int n;\n-    bad_value:\n-      sprintf (digit_buffer, \" *%d\", n++);\n-      OB_PUTCP (digit_buffer);\n-    }\n-\n-  OB_PUTC ('W');\n-  numeric_output_need_bar = 0;\n-}\n-\n-/* Encoding for an INTEGER_CST value.  */\n-\n-static void\n-build_overload_int (value, flags)\n-     tree value;\n-     mangling_flags flags;\n-{\n-  int multiple_words_p = 0;\n-  int multiple_digits_p = 0;\n-\n-  if ((flags & mf_maybe_uninstantiated) && TREE_CODE (value) != INTEGER_CST)\n-    {\n-      mangle_expression (value);\n-      return;\n-    }\n-\n-  /* Unless we were looking at an uninstantiated template, integers\n-     should always be represented by constants.  */\n-  my_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n-\n-  /* If value doesn't fit in a single HOST_WIDE_INT, we must use a\n-     special output routine that can deal with this.  */\n-  if (! host_integerp (value, 0))\n-    {\n-      multiple_words_p = 1;\n-      /* And there is certainly going to be more than one digit.  */\n-      multiple_digits_p = 1;\n-    }\n-  else \n-    multiple_digits_p = ((HOST_WIDE_INT) TREE_INT_CST_LOW (value) > 9\n-\t\t\t || (HOST_WIDE_INT) TREE_INT_CST_LOW (value) < -9);\n-\n-  /* If necessary, add a leading underscore.  */\n-  if (multiple_digits_p && (flags & mf_use_underscores_around_value))\n-    OB_PUTC ('_');\n-\n-  /* Output the number itself.  */\n-  if (multiple_words_p)\n-    dicat (TREE_INT_CST_LOW (value), TREE_INT_CST_HIGH (value));\n-  else\n-    icat (TREE_INT_CST_LOW (value));\n-\n-  if (flags & mf_use_underscores_around_value)\n-    {\n-      if (multiple_digits_p)\n-\tOB_PUTC ('_');\n-      /* Whether or not there were multiple digits, we don't need an\n-\t underscore.  We've either terminated the number with an\n-\t underscore, or else it only had one digit.  */\n-      numeric_output_need_bar = 0;\n-    }\n-  else\n-    /* We just output a numeric value.  */\n-    numeric_output_need_bar = 1;\n-}\n-\n-\n-/* Output S followed by a representation of the TEMPLATE_PARM_INDEX\n-   supplied in INDEX.  */\n-\n-static void \n-build_mangled_template_parm_index (s, index)\n-     const char *s;\n-     tree index;\n-{\n-  OB_PUTCP (s);\n-  build_underscore_int (TEMPLATE_PARM_IDX (index));\n-  /* We use the LEVEL, not the ORIG_LEVEL, because the mangling is a\n-     representation of the function from the point of view of its\n-     type.  */\n-  build_underscore_int (TEMPLATE_PARM_LEVEL (index));\n-}\n-\n-\n-/* Mangling for C9X integer types (and Cygnus extensions for 128-bit\n-   and other types) is based on the letter \"I\" followed by the hex\n-   representations of the bitsize for the type in question. For\n-   encodings that result in larger than two digits, a leading and\n-   trailing underscore is added.\n-\n-   Thus:\n-   int1_t   = 001 = I01\n-   int8_t   = 008 = I08 \n-   int16_t  = 010 = I10\n-   int24_t  = 018 = I18\n-   int32_t  = 020 = I20\n-   int64_t  = 040 = I40\n-   int80_t  = 050 = I50\n-   int128_t = 080 = I80\n-   int256_t = 100 = I_100_\n-   int512_t = 200 = I_200_\n-\n-   Given an integer in decimal format, mangle according to this scheme. */\n-\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-static void\n-build_mangled_C9x_name (bits)\n-     int bits;\n-{\n-  char mangled[10] = \"\";\n-\n-  if (bits > 255)\n-    sprintf (mangled, \"I_%x_\", bits);\n-  else\n-    sprintf (mangled, \"I%.2x\", bits);\n-\n-  OB_PUTCP (mangled);\n-}\n-#endif\n-\n-static void\n-build_overload_value (type, value, flags)\n-     tree type, value;\n-     mangling_flags flags;\n-{\n-  my_friendly_assert (TYPE_P (type), 0);\n-\n-  while (TREE_CODE (value) == NON_LVALUE_EXPR\n-\t || TREE_CODE (value) == NOP_EXPR)\n-    value = TREE_OPERAND (value, 0);\n-\n-  if (numeric_output_need_bar)\n-    {\n-      OB_PUTC ('_');\n-      numeric_output_need_bar = 0;\n-    }\n-\n-  if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n-    {\n-      build_mangled_template_parm_index (\"Y\", value);\n-      return;\n-    }\n-\n-  if (TYPE_PTRMEM_P (type))\n-    {\n-      if (TREE_CODE (value) != PTRMEM_CST)\n-\t/* We should have already rejected this pointer to member,\n-\t   since it is not a constant.  */\n-\tmy_friendly_abort (0);\n-\n-      /* Get the actual FIELD_DECL.  */\n-      value = PTRMEM_CST_MEMBER (value);\n-      my_friendly_assert (TREE_CODE (value) == FIELD_DECL, 0);\n-\n-      /* Output the name of the field.  */\n-      build_overload_identifier (DECL_NAME (value));\n-      return;\n-    }\n-  else if (INTEGRAL_TYPE_P (type))\n-    {\n-      build_overload_int (value, flags);\n-      return;\n-    }\n-\n-  /* The only case where we use the extra underscores here is when\n-     forming the mangling for an integral non-type template argument.\n-     If that didn't happen, stop now.  */\n-  flags &= ~mf_use_underscores_around_value;\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case REAL_TYPE:\n-      {\n-\tREAL_VALUE_TYPE val;\n-\tchar *bufp = digit_buffer;\n-\n-\t/* We must handle non-constants in templates.  */\n-\tif (TREE_CODE (value) != REAL_CST)\n-\t  {\n-\t    mangle_expression (value);\n-\t    break;\n-\t  }\n-\n-\tval = TREE_REAL_CST (value);\n-\tif (REAL_VALUE_ISNAN (val))\n-\t  {\n-\t    sprintf (bufp, \"NaN\");\n-\t  }\n-\telse\n-\t  {\n-\t    if (REAL_VALUE_NEGATIVE (val))\n-\t      {\n-\t\tval = REAL_VALUE_NEGATE (val);\n-\t\t*bufp++ = 'm';\n-\t      }\n-\t    if (REAL_VALUE_ISINF (val))\n-\t      {\n-\t\tsprintf (bufp, \"Infinity\");\n-\t      }\n-\t    else\n-\t      {\n-\t\tREAL_VALUE_TO_DECIMAL (val, \"%.20e\", bufp);\n-\t\tbufp = (char *) index (bufp, 'e');\n-\t\tif (!bufp)\n-\t\t  strcat (digit_buffer, \"e0\");\n-\t\telse\n-\t\t  {\n-\t\t    char *p;\n-\t\t    bufp++;\n-\t\t    if (*bufp == '-')\n-\t\t      {\n-\t\t\t*bufp++ = 'm';\n-\t\t      }\n-\t\t    p = bufp;\n-\t\t    if (*p == '+')\n-\t\t      p++;\n-\t\t    while (*p == '0')\n-\t\t      p++;\n-\t\t    if (*p == 0)\n-\t\t      {\n-\t\t\t*bufp++ = '0';\n-\t\t\t*bufp = 0;\n-\t\t      }\n-\t\t    else if (p != bufp)\n-\t\t      {\n-\t\t\twhile (*p)\n-\t\t\t  *bufp++ = *p++;\n-\t\t\t*bufp = 0;\n-\t\t      }\n-\t\t  }\n-#ifdef NO_DOT_IN_LABEL\n-\t\tbufp = (char *) index (bufp, '.');\n-\t\tif (bufp)\n-\t\t  *bufp = '_';\n-#endif\n-\t      }\n-\t  }\n-\tOB_PUTCP (digit_buffer);\n-\tnumeric_output_need_bar = 1;\n-\treturn;\n-      }\n-    case POINTER_TYPE:\n-      if (TREE_CODE (value) == INTEGER_CST)\n-\t{\n-\t  build_overload_int (value, flags);\n-\t  return;\n-\t}\n-      else if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n-\t{\n-\t  build_mangled_template_parm_index (\"\", value);\n-\t  numeric_output_need_bar = 1;\n-\t  return;\n-\t}\n-\n-      value = TREE_OPERAND (value, 0);\n-\n-      /* Fall through.  */\n-\n-    case REFERENCE_TYPE:\n-      if (TREE_CODE (value) == ADDR_EXPR)\n-\tvalue = TREE_OPERAND (value, 0);\n-\n-      if (TREE_CODE (value) == VAR_DECL)\n-\t{\n-\t  my_friendly_assert (DECL_NAME (value) != 0, 245);\n-\t  build_overload_identifier (DECL_ASSEMBLER_NAME (value));\n-\t  return;\n-\t}\n-      else if (TREE_CODE (value) == FUNCTION_DECL)\n-\t{\n-\t  my_friendly_assert (DECL_NAME (value) != 0, 246);\n-\t  build_overload_identifier (DECL_ASSEMBLER_NAME (value));\n-\t  return;\n-\t}\n-      else if (TREE_CODE (value) == SCOPE_REF)\n-\tbuild_overload_scope_ref (value);\n-      else\n-\tmy_friendly_abort (71);\n-      break; /* not really needed */\n-\n-    case RECORD_TYPE:\n-      {\n-\ttree delta;\n-\ttree idx;\n-\ttree pfn;\n-\ttree delta2;\n-\ttree fn;\n-\n-\tmy_friendly_assert (TYPE_PTRMEMFUNC_P (type), 0);\n-\n-\t/* We'll get a ADDR_EXPR of a SCOPE_REF here if we're\n-\t   mangling, an instantiation of something like:\n-\n-\t     template <class T, void (T::*fp)()> class C {};\n-\t     template <class T> C<T, &T::f> x();  \n-\t\n-\t   We mangle the return type of the function, and that\n-\t   contains template parameters.  */\n-\tif (TREE_CODE (value) == ADDR_EXPR\n-\t    && TREE_CODE (TREE_OPERAND (value, 0)) == SCOPE_REF)\n-\t  {\n-\t    build_overload_scope_ref (TREE_OPERAND (value, 0));\n-\t    break;\n-\t  }\n-\n-\tmy_friendly_assert (TREE_CODE (value) == PTRMEM_CST, 0);\n-\n-\texpand_ptrmemfunc_cst (value, &delta, &idx, &pfn, &delta2);\n-\tfn = PTRMEM_CST_MEMBER (value);\n-\tbuild_overload_int (delta, flags);\n-\tOB_PUTC ('_');\n-\tif (!flag_new_abi)\n-\t  {\n-\t    build_overload_int (idx, flags);\n-\t    OB_PUTC ('_');\n-\t  }\n-\telse if (DECL_VIRTUAL_P (fn))\n-\t  {\n-\t    build_overload_int (DECL_VINDEX (fn), flags);\n-\t    OB_PUTC ('_');\n-\t  }\n-\n-\tif (!DECL_VIRTUAL_P (fn))\n-\t  {\n-\t    numeric_output_need_bar = 0;\n-\t    build_overload_identifier (DECL_ASSEMBLER_NAME (fn));\n-\t  }\n-\telse if (!flag_new_abi)\n-\t  {\n-\t    OB_PUTC ('i');\n-\t    build_overload_int (delta2, flags);\n-\t  }\n-      }\n-      break;\n-      \n-    default:\n-      sorry (\"conversion of %s as template parameter\",\n-\t     tree_code_name [(int) TREE_CODE (type)]);\n-      my_friendly_abort (72);\n-    }\n-}\n-\n-\n-/* Add encodings for the declaration of template template parameters.\n-   PARMLIST must be a TREE_VEC.  */\n-\n-static void\n-build_template_template_parm_names (parmlist)\n-     tree parmlist;\n-{\n-  int i, nparms;\n-\n-  my_friendly_assert (TREE_CODE (parmlist) == TREE_VEC, 246.5);\n-  nparms = TREE_VEC_LENGTH (parmlist);\n-  icat (nparms);\n-  for (i = 0; i < nparms; i++)\n-    {\n-      tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n-      if (TREE_CODE (parm) == TYPE_DECL)\n-\t{\n-\t  /* This parameter is a type.  */\n-\t  OB_PUTC ('Z');\n-\t}\n-      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n-\t{\n-\t  /* This parameter is a template. */\n-\t  OB_PUTC ('z');\n-\t  build_template_template_parm_names (DECL_INNERMOST_TEMPLATE_PARMS (parm));\n-\t}\n-      else\n-\t/* It's a PARM_DECL.  */\n-\tbuild_mangled_name_for_type (TREE_TYPE (parm));\n-    }\n-}\n-\n-\n-/* Add encodings for the vector of template parameters in PARMLIST,\n-   given the vector of arguments to be substituted in ARGLIST.  */\n-\n-static void\n-build_template_parm_names (parmlist, arglist)\n-     tree parmlist;\n-     tree arglist;\n-{\n-  int i, nparms;\n-  tree inner_args = INNERMOST_TEMPLATE_ARGS (arglist);\n-\n-  nparms = TREE_VEC_LENGTH (parmlist);\n-  icat (nparms);\n-  for (i = 0; i < nparms; i++)\n-    {\n-      tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n-      tree arg = TREE_VEC_ELT (inner_args, i);\n-      if (TREE_CODE (parm) == TYPE_DECL)\n-\t{\n-\t  /* This parameter is a type.  */\n-\t  OB_PUTC ('Z');\n-\t  build_mangled_name_for_type (arg);\n-\t}\n-      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n-\t{\n-\t  /* This parameter is a template.  */\n-\t  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-\t    /* Output parameter declaration, argument index and level.  */\n-\t    build_mangled_name_for_type (arg);\n-\t  else\n-\t    {\n-\t      /* A TEMPLATE_DECL node, output the parameter declaration \n-\t\t and template name */\n-\n-\t      OB_PUTC ('z');\n-\t      build_template_template_parm_names\n-\t\t(DECL_INNERMOST_TEMPLATE_PARMS (parm));\n-\t      icat (IDENTIFIER_LENGTH (DECL_NAME (arg)));\n-\t      OB_PUTID (DECL_NAME (arg));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  parm = tsubst (parm, arglist, /*complain=*/1, NULL_TREE);\n-\t  /* It's a PARM_DECL.  */\n-\t  build_mangled_name_for_type (TREE_TYPE (parm));\n-\t  build_overload_value (TREE_TYPE (parm), arg, \n-\t\t\t\t((mf_maybe_uninstantiated \n-\t\t\t\t  * uses_template_parms (arglist))\n-\t\t\t\t | mf_use_underscores_around_value));\n-\t}\n-    }\n- }\n-\n-/* Output the representation for NAME, which is either a TYPE_DECL or\n-   an IDENTIFIER.  */\n-\n-static void\n-build_overload_identifier (name)\n-     tree name;\n-{\n-  if (TREE_CODE (name) == TYPE_DECL\n-      && CLASS_TYPE_P (TREE_TYPE (name))\n-      && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name))\n-      && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name)))\n-\t  || (TREE_CODE (CP_DECL_CONTEXT (CLASSTYPE_TI_TEMPLATE \n-\t\t\t\t\t  (TREE_TYPE (name))))\n-\t      == FUNCTION_DECL)))\n-    {\n-      /* NAME is the TYPE_DECL for a template specialization.  */\n-      tree template, parmlist, arglist, tname;\n-      template = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name));\n-      arglist = CLASSTYPE_TI_ARGS (TREE_TYPE (name));\n-      tname = DECL_NAME (template);\n-      parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n-      OB_PUTC ('t');\n-      icat (IDENTIFIER_LENGTH (tname));\n-      OB_PUTID (tname);\n-      build_template_parm_names (parmlist, arglist);\n-    }\n-  else\n-    {\n-      if (TREE_CODE (name) == TYPE_DECL)\n-\tname = DECL_NAME (name);\n-      if (numeric_output_need_bar)\n-\t{\n-\t  OB_PUTC ('_');\n-\t  numeric_output_need_bar = 0;\n-\t}\n-      icat (IDENTIFIER_LENGTH (name));\n-      OB_PUTID (name);\n-    }\n-}\n-\n-/* Given DECL, either a class TYPE, TYPE_DECL or FUNCTION_DECL, produce\n-   the mangling for it.  Used by build_mangled_name and build_static_name.  */\n-\n-static void\n-build_qualified_name (decl)\n-     tree decl;\n-{\n-  tree context;\n-  int i = 1;\n-\n-  if (TYPE_P (decl))\n-    decl = TYPE_NAME (decl);\n-\n-  /* If DECL_ASSEMBLER_NAME has been set properly, use it.  */\n-  if (TREE_CODE (decl) == TYPE_DECL\n-      && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl) && !flag_do_squangling)\n-    {\n-      tree id = DECL_ASSEMBLER_NAME (decl);\n-      OB_PUTID (id);\n-      if (ISDIGIT (IDENTIFIER_POINTER (id) [IDENTIFIER_LENGTH (id) - 1]))\n-\tnumeric_output_need_bar = 1;\n-      return;\n-    }\n-\n-  context = decl;\n-  /* If we can't find a Ktype, do it the hard way.  */\n-  if (check_ktype (context, FALSE) == -1)\n-    {\n-      /* Count type and namespace scopes.  */\n-      while (1)\n-\t{\n-\t  context = CP_DECL_CONTEXT (context);\n-\t  if (context == global_namespace)\n-\t    break;\n-\t  i += 1;\n-\t  if (check_ktype (context, FALSE) != -1)\n-\t    /* Found one!  */\n-\t    break;\n-\t  if (TYPE_P (context))\n-\t    context = TYPE_NAME (context);\n-\t}\n-    }\n-\n-  if (i > 1)\n-    {\n-      OB_PUTC ('Q');\n-      build_underscore_int (i);\n-      numeric_output_need_bar = 0;\n-    }\n-  build_overload_nested_name (decl);\n-}\n-\n-/* Output the mangled representation for TYPE.  If EXTRA_GCODE is\n-   non-zero, mangled names for structure/union types are intentionally\n-   mangled differently from the method described in the ARM.  */\n-\n-static void \n-build_mangled_name_for_type_with_Gcode (type, extra_Gcode)\n-     tree type;\n-     int extra_Gcode;\n-{\n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  process_modifiers (type);\n-  process_overload_item (type, extra_Gcode);\n-}\n-\n-/* Like build_mangled_name_for_type_with_Gcode, but never outputs the\n-   `G'.  */\n-\n-static void\n-build_mangled_name_for_type (type)\n-     tree type;\n-{\n-  build_mangled_name_for_type_with_Gcode (type, 0);\n-}\n-\n-/* Given a list of parameters in PARMTYPES, create an unambiguous\n-   overload string. Should distinguish any type that C (or C++) can\n-   distinguish. I.e., pointers to functions are treated correctly.\n-\n-   Caller must deal with whether a final `e' goes on the end or not.\n-\n-   Any default conversions must take place before this function\n-   is called.\n-\n-   BEGIN and END control initialization and finalization of the\n-   obstack where we build the string.  */\n-\n-char *\n-build_overload_name (parmtypes, begin, end)\n-     tree parmtypes;\n-     int begin, end;\n-{\n-  char *ret;\n-\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200005221);\n-\n-  start_squangling ();\n-  ret = build_mangled_name (parmtypes, begin, end);\n-  end_squangling ();\n-  return ret ;\n-}\n-\n-/* Output the mangled representation for PARMTYPES.  If PARMTYPES is a\n-   TREE_LIST, then it is a list of parameter types.  Otherwise,\n-   PARMTYPES must be a single type.  */\n-\n-static char *\n-build_mangled_name (parmtypes, begin, end)\n-     tree parmtypes;\n-     int begin, end;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004105);\n-\n-  if (begin) \n-    OB_INIT ();\n-\n-  if (TREE_CODE (parmtypes) != TREE_LIST)  \n-    /* There is only one type.  */\n-    build_mangled_name_for_type (parmtypes);\n-  else  \n-    {\n-      /* There are several types in a parameter list.  */\n-      int nrepeats = 0;\n-      int old_style_repeats = !flag_do_squangling && !nofold && typevec;\n-      tree last_type = NULL_TREE;\n-\n-      for (; parmtypes && parmtypes != void_list_node;\n-\t   parmtypes = TREE_CHAIN (parmtypes))\n-\t{\n-\t  /* We used to call canonical_type_variant here, but that isn't\n-\t     good enough; it doesn't handle pointers to typedef types.  So\n-\t     we can't just set TREE_USED to say we've seen a type already;\n-\t     we have to check each of the earlier types with same_type_p.  */\n-\t  tree parmtype = TREE_VALUE (parmtypes);\n-\n-\t  if (old_style_repeats)\n-\t    {\n-\t      /* Every argument gets counted.  */\n-\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n-\t      VARRAY_TREE (typevec, maxtype) = parmtype;\n-\t      maxtype++;\n-\t    }\n-\n-\t  if (last_type && same_type_p (parmtype, last_type))\n-\t    {\n-\t      if (flag_do_squangling \n-\t\t  || (old_style_repeats\n-\t\t      && is_back_referenceable_type (parmtype)))\n-\t\t{\n-\t\t  /* The next type is the same as this one.  Keep\n-\t\t     track of the repetition, and output the repeat\n-\t\t     count later.  */\n-\t\t  nrepeats++;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  else if (nrepeats != 0)\n-\t    {\n-\t      /* Indicate how many times the previous parameter was\n-\t\t repeated.  */\n-\t      if (old_style_repeats)\n-\t\tflush_repeats (nrepeats, last_type);\n-\t      else\n-\t\tissue_nrepeats (nrepeats, last_type);\n-\t      nrepeats = 0;\n-\t    }\n-\t  \n-\t  last_type = parmtype;\n-\n-\t  /* Note that for bug-compatibility with 2.7.2, we can't build up\n-\t     repeats of types other than the most recent one.  So we call\n-\t     flush_repeats every round, if we get this far.  */\n-\t  if (old_style_repeats && flush_repeats (0, parmtype))\n-\t    continue;\n-\n-\t  /* Output the PARMTYPE.  */\n-\t  build_mangled_name_for_type_with_Gcode (parmtype, 1);\n-\t}\n-\n-      /* Output the repeat count for the last parameter, if\n-\t necessary.  */\n-      if (nrepeats != 0)\n-\t{\n-\t  if (old_style_repeats)\n-\t    flush_repeats (nrepeats, last_type);\n-\t  else\n-\t    issue_nrepeats (nrepeats, last_type);\n-\t  nrepeats = 0;\n-\t}\n-\n-      if (!parmtypes)\n-\t/* The parameter list ends in an ellipsis.  */\n-\tOB_PUTC ('e');\n-    }\n-\n-  if (end) \n-    OB_FINISH ();\n-  return (char *) obstack_base (&scratch_obstack);\n-}\n-\n-/* Emit modifiers such as constant, read-only, and volatile.  */\n-\n-static void \n-process_modifiers (parmtype) \n-     tree parmtype;\n-{\n-  /* Note that here we do not use CP_TYPE_CONST_P and friends because\n-     we describe types recursively; we will get the `const' in \n-     `const int ()[10]' when processing the `const int' part.  */\n-  if (TYPE_READONLY (parmtype))\n-    OB_PUTC ('C');\n-  if (TREE_CODE (parmtype) == INTEGER_TYPE\n-      && parmtype != char_type_node\n-      && parmtype != wchar_type_node\n-      && (TYPE_MAIN_VARIANT (parmtype)\n-\t  == unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n-      && ! TYPE_FOR_JAVA (parmtype))\n-    OB_PUTC ('U');\n-  if (TYPE_VOLATILE (parmtype))\n-    OB_PUTC ('V');\n-  /* It would be better to use `R' for `restrict', but that's already\n-     used for reference types.  And `r' is used for `long double'.  */\n-  if (TYPE_RESTRICT (parmtype))\n-    OB_PUTC ('u');\n-}\n-\n-/* Check to see if TYPE has been entered into the Bcode typelist.  If\n-   so, return 1 and emit a backreference to TYPE.  Otherwise, add TYPE\n-   to the list of back-referenceable types and return 0.  */\n-\n-static int \n-check_btype (type) \n-     tree type;\n-{\n-  size_t x;\n-\n-  if (btypelist == NULL)\n-    return 0;\n-\n-  if (!is_back_referenceable_type (type))\n-    return 0;\n-\n-  for (x = 0; x < maxbtype; x++) \n-    if (same_type_p (type, VARRAY_TREE (btypelist, x)))\n-      {\n-\tOB_PUTC ('B');\n-\ticat (x);\n-\tif (x > 9)\n-\t  OB_PUTC ('_');\n-\treturn 1 ;\n-      }\n-\n-  if (VARRAY_SIZE (btypelist) <= maxbtype) \n-    /* Enlarge the table.  */\n-    VARRAY_GROW (btypelist,\n-\t\t VARRAY_SIZE (btypelist) * 3 / 2);\n-\n-  /* Register the TYPE.  */\n-  VARRAY_TREE (btypelist, maxbtype) = type;\n-  maxbtype++;\n-\n-  return 0;\n-}\n-\n-/* Emit the correct code for various node types.  */\n-\n-static void \n-process_overload_item (parmtype, extra_Gcode) \n-  tree parmtype;\n-  int extra_Gcode;\n-{\n-  numeric_output_need_bar = 0;\n-\n-  /* Our caller should have already handed any qualifiers, so pull out the\n-     TYPE_MAIN_VARIANT to avoid typedef confusion.  Except we can't do that\n-     for arrays, because they are transparent to qualifiers.  Sigh.  */\n-  if (TREE_CODE (parmtype) == ARRAY_TYPE)\n-    parmtype = canonical_type_variant (parmtype);\n-  else\n-    parmtype = TYPE_MAIN_VARIANT (parmtype);\n-\n-  /* These tree types are considered modifiers for B code squangling,\n-     and therefore should not get entries in the Btypelist.  They are,\n-     however, repeatable types.  */\n-\n-  switch (TREE_CODE (parmtype))\n-    {\n-    case REFERENCE_TYPE:\n-      OB_PUTC ('R');\n-      goto more;\n-\n-    case ARRAY_TYPE:\n-      {\n-        OB_PUTC ('A');\n-        if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n-\t  OB_PUTC ('_');\n-        else\n-\t  {\n-\t    tree length = array_type_nelts (parmtype);\n-\t    if (TREE_CODE (length) != INTEGER_CST || flag_do_squangling)\n-\t      {\n-\t\tlength = fold (build (PLUS_EXPR, TREE_TYPE (length),\n-\t\t\t\t      length, integer_one_node));\n-\t\tSTRIP_NOPS (length);\n-\t      }\n-\t    build_overload_value (sizetype, length, 1);\n-\t  }\n-\tif (numeric_output_need_bar && ! flag_do_squangling)\n-\t  OB_PUTC ('_');\n-        goto more;\n-      }\n-\n-    case POINTER_TYPE:\n-      OB_PUTC ('P');\n-    more:\n-      build_mangled_name_for_type (TREE_TYPE (parmtype));\n-      return;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  \n-  if (flag_do_squangling && check_btype (parmtype)) \n-    /* If PARMTYPE is already in the list of back-referenceable types,\n-       then check_btype will output the appropriate reference, and\n-       there's nothing more to do.  */\n-    return;\n-\n-  switch (TREE_CODE (parmtype))\n-    {\n-    case OFFSET_TYPE:\n-      OB_PUTC ('O');\n-      build_mangled_name_for_type (TYPE_OFFSET_BASETYPE (parmtype));\n-      OB_PUTC ('_');\n-      build_mangled_name_for_type (TREE_TYPE (parmtype));\n-      break;\n-\n-    case FUNCTION_TYPE:\n-    case METHOD_TYPE:\n-      {\n-        tree parms = TYPE_ARG_TYPES (parmtype);\n-\n-\t/* Rather than implementing a reentrant TYPEVEC, we turn off\n-\t   repeat codes here, unless we're squangling.  Squangling\n-\t   doesn't make use of the TYPEVEC, so there's no reentrancy\n-\t   problem.  */\n-\tint old_nofold = nofold;\n-\tif (!flag_do_squangling)\n-\t  nofold = 1;\n-\n-\tif (TREE_CODE (parmtype) == METHOD_TYPE)\n-\t  {\n-\t    /* Mark this as a method.  */\n-            OB_PUTC ('M');\n-\t    /* Output the class of which this method is a member.  */\n-            build_mangled_name_for_type (TYPE_METHOD_BASETYPE (parmtype));\n-\t    /* Output any qualifiers for the `this' parameter.  */\n-\t    process_modifiers (TREE_TYPE (TREE_VALUE (parms)));\n-\t  }\n-\n-\t/* Output the parameter types.  */\n-\tOB_PUTC ('F');\n-\tif (parms == NULL_TREE)\n-\t  OB_PUTC ('e');\n-\telse if (parms == void_list_node)\n-\t  OB_PUTC ('v');\n-\telse\n-\t  build_mangled_name (parms, 0, 0);\n-\n-        /* Output the return type.  */\n-        OB_PUTC ('_');\n-        build_mangled_name_for_type (TREE_TYPE (parmtype));\n-\n-        nofold = old_nofold;\n-        break;\n-      }\n-\n-    case INTEGER_TYPE:\n-      if (parmtype == integer_type_node\n-          || parmtype == unsigned_type_node\n-\t  || parmtype == java_int_type_node)\n-        OB_PUTC ('i');\n-      else if (parmtype == long_integer_type_node\n-               || parmtype == long_unsigned_type_node)\n-        OB_PUTC ('l');\n-      else if (parmtype == short_integer_type_node\n-               || parmtype == short_unsigned_type_node\n-\t       || parmtype == java_short_type_node)\n-        OB_PUTC ('s');\n-      else if (parmtype == signed_char_type_node)\n-        {\n-          OB_PUTC ('S');\n-          OB_PUTC ('c');\n-        }\n-      else if (parmtype == char_type_node\n-               || parmtype == unsigned_char_type_node\n-\t       || parmtype == java_byte_type_node)\n-        OB_PUTC ('c');\n-      else if (parmtype == wchar_type_node\n-\t       || parmtype == java_char_type_node)\n-        OB_PUTC ('w');\n-      else if (parmtype == long_long_integer_type_node\n-\t       || parmtype == long_long_unsigned_type_node\n-\t       || parmtype == java_long_type_node)\n-        OB_PUTC ('x');\n-      else if (parmtype == java_boolean_type_node)\n-\tOB_PUTC ('b');\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-      else\n-\t{\n-\t  int bits = TREE_INT_CST_LOW (TYPE_SIZE (parmtype));\n-\t  build_mangled_C9x_name (bits);\n-\t}\n-#else\n-      else\n-\tmy_friendly_abort (73);\n-#endif\n-      break;\n-\n-    case BOOLEAN_TYPE:\n-      OB_PUTC ('b');\n-      break;\n-\n-    case REAL_TYPE:\n-      if (parmtype == long_double_type_node)\n-        OB_PUTC ('r');\n-      else if (parmtype == double_type_node\n-\t       || parmtype == java_double_type_node)\n-        OB_PUTC ('d');\n-      else if (parmtype == float_type_node\n-\t       || parmtype == java_float_type_node)\n-        OB_PUTC ('f');\n-      else my_friendly_abort (74);\n-      break;\n-\n-    case COMPLEX_TYPE:\n-      OB_PUTC ('J');\n-      build_mangled_name_for_type (TREE_TYPE (parmtype));\n-      break;\n-\n-    case VOID_TYPE:\n-      OB_PUTC ('v');\n-      break;\n-\n-    case ERROR_MARK:\t/* not right, but nothing is anyway */\n-      break;\n-\n-      /* have to do these */\n-    case UNION_TYPE:\n-    case RECORD_TYPE:\n-      {   \n-        if (extra_Gcode)\n-          OB_PUTC ('G');       /* make it look incompatible with AT&T */\n-        /* drop through into next case */\n-      }\n-    case ENUMERAL_TYPE:\n-      {\n-        tree name = TYPE_NAME (parmtype);\n-\n-        my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 248);\n-\n-        build_qualified_name (name);\n-        break;\n-      }\n-\n-    case UNKNOWN_TYPE:\n-      /* This will take some work.  */\n-      OB_PUTC ('?');\n-      break;\n-\n-    case TEMPLATE_TEMPLATE_PARM:\n-      /* Find and output the original template parameter \n-         declaration. */\n-      if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parmtype))\n-        {\n-\t  build_mangled_template_parm_index (\"tzX\",\n-\t\t\t\t\t     TEMPLATE_TYPE_PARM_INDEX \n-\t\t\t\t\t     (parmtype));\n-          build_template_parm_names\n-            (DECL_INNERMOST_TEMPLATE_PARMS (TYPE_TI_TEMPLATE (parmtype)),\n-\t     TYPE_TI_ARGS (parmtype));\n-        }\n-      else\n-        {\n-\t  build_mangled_template_parm_index (\"ZzX\",\n-\t\t\t\t\t     TEMPLATE_TYPE_PARM_INDEX \n-\t\t\t\t\t     (parmtype));\n-          build_template_template_parm_names\n-            (DECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n-        }\n-      break;\n-\n-    case TEMPLATE_TYPE_PARM:\n-      build_mangled_template_parm_index (\"X\", \n-\t\t\t\t\t TEMPLATE_TYPE_PARM_INDEX\n-\t\t\t\t\t (parmtype));\n-      break;\n-        \n-    case TYPENAME_TYPE:\n-      /* When mangling the type of a function template whose\n-         declaration looks like:\n-\n-         template <class T> void foo(typename T::U)\n-         \n-         we have to mangle these.  */\n-      build_qualified_name (parmtype);\n-      break;\n-\n-    default:\n-      my_friendly_abort (75);\n-    }\n-\n-}\n-\n-/* Produce the mangling for a variable named NAME in CONTEXT, which can\n-   be either a class TYPE or a FUNCTION_DECL.  */\n+/* TREE_LIST of the current inline functions that need to be\n+   processed.  */\n+struct pending_inline *pending_inlines;\n \n-tree\n-build_static_name (context, name)\n-     tree context, name;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004106);\n-\n-  OB_INIT ();\n-  numeric_output_need_bar = 0;\n-  start_squangling ();\n-#ifdef JOINER\n-  OB_PUTC ('_');\n-  build_qualified_name (context);\n-  OB_PUTC (JOINER);\n-#else\n-  OB_PUTS (\"__static_\");\n-  build_qualified_name (context);\n-  OB_PUTC ('_');\n-#endif\n-  OB_PUTID (name);\n-  OB_FINISH ();\n-  end_squangling ();\n+static void do_build_assign_ref PARAMS ((tree));\n+static void do_build_copy_constructor PARAMS ((tree));\n \n-  return get_identifier ((char *)obstack_base (&scratch_obstack));\n-}\n \f\n-/* FOR_METHOD should be 1 if the declaration in question is for a member\n-   of a class (including a static member) and 2 if the declaration is\n-   for a constructor.  */\n-tree \n-build_decl_overload_real (decl, parms, ret_type, tparms, targs,\n-\t\t\t  for_method) \n-     tree decl;\n-     tree parms;\n-     tree ret_type;\n-     tree tparms;\n-     tree targs;\n-     int for_method;\n-{\n-  const char *name;\n-  enum tree_code operator_code;\n-\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 20000410);\n-\n-  operator_code = DECL_OVERLOADED_OPERATOR_P (decl);\n-  if (!DECL_CONV_FN_P (decl) && operator_code)\n-    {\n-      /* member operators new and delete look like methods at this\n-         point.  */\n-      if (! for_method && CP_DECL_CONTEXT (decl) == global_namespace\n-\t  && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST\n-\t  && TREE_CHAIN (parms) == void_list_node)\n-\tswitch (operator_code)\n-\t  {\n-\t  case DELETE_EXPR:\n-\t    return get_identifier (\"__builtin_delete\");\n-\t  case VEC_DELETE_EXPR:\n-\t    return get_identifier (\"__builtin_vec_delete\");\n-\t  case NEW_EXPR:\n-\t    return get_identifier (\"__builtin_new\");\n-\t  case VEC_NEW_EXPR:\n-\t    return get_identifier (\"__builtin_vec_new\");\n-\t  default:\n-\t    break;\n-\t  }\n-\n-      if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n-\tname = assignment_operator_name_info[(int) operator_code].mangled_name;\n-      else\n-\tname = operator_name_info[(int) operator_code].mangled_name;\n-    }\n-  else\n-    name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-\n-  start_squangling ();\n-  OB_INIT ();\n-  if (for_method != 2)\n-    OB_PUTCP (name);\n-  /* Otherwise, we can divine that this is a constructor,\n-     and figure out its name without any extra encoding.  */\n-\n-  OB_PUTC2 ('_', '_');\n-  numeric_output_need_bar = 0;\n-\n-  if (tparms)\n-    {\n-      OB_PUTC ('H');\n-      build_template_parm_names (tparms, targs);\n-      OB_PUTC ('_');\n-    }\n-  else if (!for_method && CP_DECL_CONTEXT (decl) == global_namespace)\n-    OB_PUTC ('F');\n-\n-  if (!for_method && CP_DECL_CONTEXT (decl) != global_namespace)\n-    /* qualify with namespace */\n-    build_qualified_name (CP_DECL_CONTEXT (decl));\n-\n-  if (parms == NULL_TREE)\n-    OB_PUTC ('e');\n-  else if (parms == void_list_node)\n-    OB_PUTC ('v');\n-  else\n-    {\n-      if (!flag_do_squangling)\n-        {\n-\t  /* Allocate typevec array.  */\n-\t  size_t typevec_size = list_length (parms);\n-          maxtype = 0;\n-\t  if (!for_method && CP_DECL_CONTEXT (decl) != global_namespace)\n-\t    /* The namespace of a global function needs one slot.  */\n-\t    typevec_size++;\n-\t  VARRAY_TREE_INIT (typevec, typevec_size, \"typevec\");\n-        }\n-      nofold = 0;\n-\n-      if (for_method)\n-\t{\n-\t  tree this_type = TREE_TYPE (TREE_VALUE (parms));\n-\n-\t  build_mangled_name_for_type (this_type);\n-\n-          if (!flag_do_squangling) \n-\t    {\n-\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n-\t      VARRAY_TREE (typevec, maxtype) = this_type;\n-\t      maxtype++;\n-\t    }\n-\n-\t  if (TREE_CHAIN (parms))\n-\t    build_mangled_name (TREE_CHAIN (parms), 0, 0);\n-\t  else\n-\t    OB_PUTC ('e');\n-\t}\n-      else\n-\t{\n-\t  /* the namespace qualifier for a global function \n-\t     will count as type */\n-\t  if (CP_DECL_CONTEXT (decl) != global_namespace\n-\t      && !flag_do_squangling)\n-\t    {\n-\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n-\t      VARRAY_TREE (typevec, maxtype) = CP_DECL_CONTEXT (decl);\n-\t      maxtype++;\n-\t    }\n-\t  build_mangled_name (parms, 0, 0);\n-\t}\n-\n-      if (!flag_do_squangling)\n-\t/* Deallocate typevec array.  */\n-\tVARRAY_FREE (typevec);\n-    }\n-\n-  if (ret_type != NULL_TREE && for_method != 2)\n-    {\n-      /* Add the return type. */\n-      OB_PUTC ('_');\n-      build_mangled_name_for_type (ret_type);\n-    }\n-\n-  OB_FINISH ();\n-  end_squangling ();\n-  {\n-    tree n = get_identifier (obstack_base (&scratch_obstack));\n-    return n;\n-  }\n-}\n-\n /* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */\n \n void\n set_mangled_name_for_decl (decl)\n      tree decl;\n {\n-  tree parm_types;\n-\n   if (processing_template_decl)\n     /* There's no need to mangle the name of a template function.  */\n     return;\n \n-  if (flag_new_abi)\n-    {\n-      DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-      return;\n-    }\n-\n-  parm_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\n-  if (DECL_STATIC_FUNCTION_P (decl))\n-    parm_types = \n-      hash_tree_chain (build_pointer_type (DECL_CONTEXT (decl)),\n-\t\t\t\t\t   parm_types);\n-  else\n-    /* The only member functions whose type is a FUNCTION_TYPE, rather\n-       than a METHOD_TYPE, should be static members.  */\n-    my_friendly_assert (!DECL_CONTEXT (decl)\n-\t\t\t|| !IS_AGGR_TYPE_CODE (TREE_CODE (DECL_CONTEXT (decl)))\n-\t\t\t|| TREE_CODE (TREE_TYPE (decl)) != FUNCTION_TYPE,\n-\t\t\t0);\n-\n-  DECL_ASSEMBLER_NAME (decl)\n-    = build_decl_overload_real (decl, parm_types, NULL_TREE,\n-\t\t\t\tNULL_TREE, NULL_TREE,\n-\t\t\t\tDECL_FUNCTION_MEMBER_P (decl)\n-\t\t\t\t+ DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n-}\n-\n-/* Build an overload name for the type expression TYPE.  */\n-\n-tree\n-build_typename_overload (type)\n-     tree type;\n-{\n-  tree id;\n-\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004108);\n-\n-  OB_INIT ();\n-  OB_PUTS (OPERATOR_TYPENAME_FORMAT);\n-  nofold = 1;\n-  start_squangling ();\n-  build_mangled_name (type, 0, 1);\n-  id = get_identifier (obstack_base (&scratch_obstack));\n-  IDENTIFIER_OPNAME_P (id) = 1;\n-  IDENTIFIER_TYPENAME_P (id) = 1;\n-  TREE_TYPE (id) = type;\n-  end_squangling ();\n-  return id;\n-}\n-\n-tree\n-build_overload_with_type (name, type)\n-     tree name, type;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200004109);\n-\n-  OB_INIT ();\n-  OB_PUTID (name);\n-  nofold = 1;\n-\n-  start_squangling ();\n-  build_mangled_name (type, 0, 1);\n-  end_squangling ();\n-  return get_identifier (obstack_base (&scratch_obstack));\n-}\n-\n-tree\n-get_id_2 (name, name2)\n-     const char *name;\n-     tree name2;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 20000411);\n-\n-  OB_INIT ();\n-  OB_PUTCP (name);\n-  OB_PUTID (name2);\n-  OB_FINISH ();\n-  return get_identifier (obstack_base (&scratch_obstack));\n-}\n-\n-/* Returns the name of a construction vtable group.  TYPE is the most\n-   derived class in the hierarhcy.  BINFO is the most derived class in\n-   the construction vtable group.  */\n-\n-tree\n-get_ctor_vtbl_name (type, binfo)\n-     tree type;\n-     tree binfo;\n-{\n-  /* This function is obsoleted by the new ABI.  */\n-  my_friendly_assert (!flag_new_abi, 200005220);\n-\n-  start_squangling ();\n-  OB_INIT ();\n-  OB_PUTCP (CTOR_VTBL_NAME_PREFIX);\n-  build_mangled_name (type, 0, 0);\n-  OB_PUTC ('_');\n-  build_mangled_name (BINFO_TYPE (binfo), 0, 0);\n-  OB_PUTC ('_');\n-  build_overload_int (BINFO_OFFSET (binfo), mf_none);\n-  OB_FINISH ();\n-  end_squangling ();\n-  return get_identifier (obstack_base (&scratch_obstack));\n-}\n-\n-/* Returns a DECL_ASSEMBLER_NAME for the destructor of type TYPE.  */\n-\n-tree\n-build_destructor_name (type)\n-     tree type;\n-{\n-  return build_overload_with_type (get_identifier (DESTRUCTOR_DECL_PREFIX),\n-\t\t\t\t   type);\n+  DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+  return;\n }\n \f\n /* Given a tree_code CODE, and some arguments (at least one),\n@@ -2080,30 +281,7 @@ make_thunk (function, delta, vcall_index)\n   if (TREE_CODE (func_decl) != FUNCTION_DECL)\n     abort ();\n \n-  if (flag_new_abi) \n-    thunk_id = mangle_thunk (TREE_OPERAND (function, 0),  delta, vcall_offset);\n-  else\n-    {\n-      OB_INIT ();\n-      OB_PUTS (\"__thunk_\");\n-      if (delta > 0)\n-\t{\n-\t  OB_PUTC ('n');\n-\t  icat (delta);\n-\t}\n-      else\n-\ticat (-delta);\n-      OB_PUTC ('_');\n-      if (vcall_index)\n-\t{\n-\t  icat (vcall_index);\n-\t  OB_PUTC ('_');\n-\t}\n-      OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n-      OB_FINISH ();\n-      thunk_id = get_identifier (obstack_base (&scratch_obstack));\n-    }\n-\n+  thunk_id = mangle_thunk (TREE_OPERAND (function, 0),  delta, vcall_offset);\n   thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n   if (thunk && !DECL_THUNK_P (thunk))\n     {"}, {"sha": "588e2c53618520dba3812e4b4e22af0dac4a4b87", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 60, "deletions": 64, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -40,16 +40,12 @@ Boston, MA 02111-1307, USA.  */\n      assignment operators, the same tree-codes are reused; i.e.,\n      `operator +' will also have PLUS_EXPR as its CODE.\n \n-   NEW_MANGLING\n+   MANGLING\n \n      The mangling prefix for the operator, as a C string, and as\n      mangled under the new ABI.  For `operator +', for example, this\n      would be \"pl\".\n \n-   OLD_MANGLING\n-\n-     Analagous, but for the old ABI.\n-\n    ARITY\n    \n      The arity of the operator, or -1 if any arity is allowed.  (As\n@@ -71,84 +67,84 @@ Boston, MA 02111-1307, USA.  */\n    arguments are as for DEF_OPERATOR, but there is no need to provide\n    an ASSIGNMENT_P argument; it is always zero.  */\n \n-#define DEF_SIMPLE_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY) \\\n-  DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY, 0)\n+#define DEF_SIMPLE_OPERATOR(NAME, CODE, MANGLING, ARITY) \\\n+  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, 0)\n \n /* Use DEF_ASSN_OPERATOR to define an assignment operator.  Its\n    arguments are as for DEF_OPERATOR, but there is no need to provide\n    an ASSIGNMENT_P argument; it is always one.  */\n \n-#define DEF_ASSN_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY) \\\n-  DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY, 1)\n+#define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING, ARITY) \\\n+  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, 1)\n \n /* Memory allocation operators.  */\n-DEF_SIMPLE_OPERATOR (\"new\", NEW_EXPR, \"nw\", \"__nw\", -1)\n-DEF_SIMPLE_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\", \"__vn\", -1)\n-DEF_SIMPLE_OPERATOR (\"delete\", DELETE_EXPR, \"dl\", \"__dl\", -1)\n-DEF_SIMPLE_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\", \"__vd\", -1)\n+DEF_SIMPLE_OPERATOR (\"new\", NEW_EXPR, \"nw\", -1)\n+DEF_SIMPLE_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\", -1)\n+DEF_SIMPLE_OPERATOR (\"delete\", DELETE_EXPR, \"dl\", -1)\n+DEF_SIMPLE_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\", -1)\n \n /* Unary operators.  */\n-DEF_SIMPLE_OPERATOR (\"+\", CONVERT_EXPR, \"ps\", \"__pl\", 1)\n-DEF_SIMPLE_OPERATOR (\"-\", NEGATE_EXPR, \"ng\", \"__mi\", 1)\n-DEF_SIMPLE_OPERATOR (\"&\", ADDR_EXPR, \"ad\", \"__ad\", 1)\n-DEF_SIMPLE_OPERATOR (\"*\", INDIRECT_REF, \"de\", \"__ml\", 1)\n-DEF_SIMPLE_OPERATOR (\"~\", BIT_NOT_EXPR, \"co\", \"__co\", 1)\n-DEF_SIMPLE_OPERATOR (\"!\", TRUTH_NOT_EXPR, \"nt\", \"__nt\", 1)\n-DEF_SIMPLE_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", \"__pp\", 1)\n-DEF_SIMPLE_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", \"__mm\", 1)\n-DEF_SIMPLE_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", \"__sz\", 1)\n+DEF_SIMPLE_OPERATOR (\"+\", CONVERT_EXPR, \"ps\", 1)\n+DEF_SIMPLE_OPERATOR (\"-\", NEGATE_EXPR, \"ng\", 1)\n+DEF_SIMPLE_OPERATOR (\"&\", ADDR_EXPR, \"ad\", 1)\n+DEF_SIMPLE_OPERATOR (\"*\", INDIRECT_REF, \"de\", 1)\n+DEF_SIMPLE_OPERATOR (\"~\", BIT_NOT_EXPR, \"co\", 1)\n+DEF_SIMPLE_OPERATOR (\"!\", TRUTH_NOT_EXPR, \"nt\", 1)\n+DEF_SIMPLE_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", 1)\n+DEF_SIMPLE_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", 1)\n+DEF_SIMPLE_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", 1)\n /* This is an extension.  */\n-DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"vx7alignof\", \"__al\", 1)\n+DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"vx7alignof\", 1)\n \n /* The cast operator.  */\n-DEF_SIMPLE_OPERATOR (\"\", TYPE_EXPR, \"cv\", OPERATOR_TYPENAME_FORMAT, 1)\n+DEF_SIMPLE_OPERATOR (\"\", TYPE_EXPR, \"cv\", 1)\n \n /* Binary operators.  */\n-DEF_SIMPLE_OPERATOR (\"+\", PLUS_EXPR, \"pl\", \"__pl\", 2)\n-DEF_SIMPLE_OPERATOR (\"-\", MINUS_EXPR, \"mi\", \"__mi\", 2)\n-DEF_SIMPLE_OPERATOR (\"*\", MULT_EXPR, \"ml\", \"__ml\", 2)\n-DEF_SIMPLE_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", \"__dv\", 2)\n-DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"rm\", \"__md\", 2)\n-DEF_SIMPLE_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", \"__ad\", 2)\n-DEF_SIMPLE_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", \"__or\", 2)\n-DEF_SIMPLE_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", \"__er\", 2)\n-DEF_SIMPLE_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", \"__ls\", 2)\n-DEF_SIMPLE_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", \"__rs\", 2)\n-DEF_SIMPLE_OPERATOR (\"==\", EQ_EXPR, \"eq\", \"__eq\", 2)\n-DEF_SIMPLE_OPERATOR (\"!=\", NE_EXPR, \"ne\", \"__ne\", 2)\n-DEF_SIMPLE_OPERATOR (\"<\", LT_EXPR, \"lt\", \"__lt\", 2)\n-DEF_SIMPLE_OPERATOR (\">\", GT_EXPR, \"gt\", \"__gt\", 2)\n-DEF_SIMPLE_OPERATOR (\"<=\", LE_EXPR, \"le\", \"__le\", 2)\n-DEF_SIMPLE_OPERATOR (\">=\", GE_EXPR, \"ge\", \"__ge\", 2)\n-DEF_SIMPLE_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", \"__aa\", 2)\n-DEF_SIMPLE_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", \"__oo\", 2)\n-DEF_SIMPLE_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", \"__cm\", 2)\n-DEF_SIMPLE_OPERATOR (\"->*\", MEMBER_REF, \"pm\", \"__rm\", 2)\n-DEF_SIMPLE_OPERATOR (\"->\", COMPONENT_REF, \"pt\", \"__rf\", 2)\n-DEF_SIMPLE_OPERATOR (\"[]\", ARRAY_REF, \"ix\", \"__vc\", 2)\n-DEF_SIMPLE_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", \"__pp\", 2)\n-DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", \"__mm\", 2)\n+DEF_SIMPLE_OPERATOR (\"+\", PLUS_EXPR, \"pl\", 2)\n+DEF_SIMPLE_OPERATOR (\"-\", MINUS_EXPR, \"mi\", 2)\n+DEF_SIMPLE_OPERATOR (\"*\", MULT_EXPR, \"ml\", 2)\n+DEF_SIMPLE_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", 2)\n+DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"rm\", 2)\n+DEF_SIMPLE_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", 2)\n+DEF_SIMPLE_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", 2)\n+DEF_SIMPLE_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", 2)\n+DEF_SIMPLE_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", 2)\n+DEF_SIMPLE_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", 2)\n+DEF_SIMPLE_OPERATOR (\"==\", EQ_EXPR, \"eq\", 2)\n+DEF_SIMPLE_OPERATOR (\"!=\", NE_EXPR, \"ne\", 2)\n+DEF_SIMPLE_OPERATOR (\"<\", LT_EXPR, \"lt\", 2)\n+DEF_SIMPLE_OPERATOR (\">\", GT_EXPR, \"gt\", 2)\n+DEF_SIMPLE_OPERATOR (\"<=\", LE_EXPR, \"le\", 2)\n+DEF_SIMPLE_OPERATOR (\">=\", GE_EXPR, \"ge\", 2)\n+DEF_SIMPLE_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", 2)\n+DEF_SIMPLE_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", 2)\n+DEF_SIMPLE_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", 2)\n+DEF_SIMPLE_OPERATOR (\"->*\", MEMBER_REF, \"pm\", 2)\n+DEF_SIMPLE_OPERATOR (\"->\", COMPONENT_REF, \"pt\", 2)\n+DEF_SIMPLE_OPERATOR (\"[]\", ARRAY_REF, \"ix\", 2)\n+DEF_SIMPLE_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", 2)\n+DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", 2)\n /* These are extensions.  */\n-DEF_SIMPLE_OPERATOR (\"<?\", MIN_EXPR, \"vx3min\", \"__mn\", 2)\n-DEF_SIMPLE_OPERATOR (\">?\", MAX_EXPR, \"vx3max\", \"__mx\", 2)\n+DEF_SIMPLE_OPERATOR (\"<?\", MIN_EXPR, \"vx3min\", 2)\n+DEF_SIMPLE_OPERATOR (\">?\", MAX_EXPR, \"vx3max\", 2)\n /* This one is needed for mangling.  */\n-DEF_SIMPLE_OPERATOR (\"::\", SCOPE_REF, \"sr\", NULL, 2);\n+DEF_SIMPLE_OPERATOR (\"::\", SCOPE_REF, \"sr\", 2);\n \n /* Assignment operators.  */\n-DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", \"__as\", 2)\n-DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\", \"__apl\", 2)\n-DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\", \"__ami\", 2)\n-DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\", \"__aml\", 2)\n-DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\", \"__adv\", 2)\n-DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"rM\", \"__amd\", 2)\n-DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\", \"__aad\", 2)\n-DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", \"__aor\", 2)\n-DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", \"__aer\", 2)\n-DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", \"__als\", 2)\n-DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", \"__ars\", 2)\n+DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", 2)\n+DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\", 2)\n+DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\", 2)\n+DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\", 2)\n+DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\", 2)\n+DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"rM\", 2)\n+DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\", 2)\n+DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", 2)\n+DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", 2)\n+DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", 2)\n+DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", 2)\n \n /* Ternary operators.  */\n-DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", \"__cn\", 3)\n+DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", 3)\n \n /* Miscellaneous.  */\n-DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", \"__cl\", -1)\n+DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", -1)"}, {"sha": "ae8bc88709ea58f7f10a6c19421a2141cb2a4f55", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 144, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -143,7 +143,6 @@ static tree tsubst_template_parms PARAMS ((tree, tree, int));\n static void regenerate_decl_from_template PARAMS ((tree, tree));\n static tree most_specialized PARAMS ((tree, tree, tree));\n static tree most_specialized_class PARAMS ((tree, tree));\n-static void set_mangled_name_for_template_decl PARAMS ((tree));\n static int template_class_depth_real PARAMS ((tree, int));\n static tree tsubst_aggr_type PARAMS ((tree, tree, int, tree, int));\n static tree tsubst_decl PARAMS ((tree, tree, tree, tree));\n@@ -1557,9 +1556,8 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t     treatment.  We do this here so that the ordinary,\n \t     non-template, name-mangling algorithm will not be used\n \t     later.  */\n-\t  if ((is_member_template (tmpl) || ctype == NULL_TREE)\n-\t      && name_mangling_version >= 1)\n-\t    set_mangled_name_for_template_decl (decl);\n+\t  if (is_member_template (tmpl) || ctype == NULL_TREE)\n+\t    set_mangled_name_for_decl (decl);\n \n \t  if (is_friend && !have_def)\n \t    /* This is not really a declaration of a specialization.\n@@ -4079,11 +4077,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n       if (!is_partial_instantiation)\n \t{\n-\t  if (flag_new_abi)\n-\t    DECL_ASSEMBLER_NAME (type_decl) = mangle_decl (type_decl);\n-\t  else\n-\t    DECL_ASSEMBLER_NAME (type_decl)\n-\t      = get_identifier (build_overload_name (t, 1, 1));\n+\t  DECL_ASSEMBLER_NAME (type_decl) = mangle_decl (type_decl);\n \n \t  /* For backwards compatibility; code that uses\n \t     -fexternal-templates expects looking up a template to\n@@ -4509,11 +4503,10 @@ tsubst_friend_function (decl, args)\n     DECL_USE_TEMPLATE (DECL_TEMPLATE_RESULT (new_friend)) = 0;\n \n   /* The mangled name for the NEW_FRIEND is incorrect.  The call to\n-     tsubst will have resulted in a call to\n-     set_mangled_name_for_template_decl.  But, the function is not a\n-     template instantiation and should not be mangled like one.\n-     Therefore, we remangle the function name.  We don't have to do\n-     this if the NEW_FRIEND is a template since\n+     tsubst will have resulted in a call to set_mangled_name_for_decl.\n+     But, the function is not a template instantiation and should not\n+     be mangled like one.  Therefore, we remangle the function name.\n+     We don't have to do this if the NEW_FRIEND is a template since\n      set_mangled_name_for_template_decl doesn't do anything if the\n      function declaration still uses template arguments.  */\n   if (TREE_CODE (new_friend) != TEMPLATE_DECL)\n@@ -5704,14 +5697,9 @@ tsubst_decl (t, args, type, in_decl)\n \t\t\t      /*entering_scope=*/1);\n \n \tif (member && DECL_CONV_FN_P (r)) \n-\t  {\n-\t    /* Type-conversion operator.  Reconstruct the name, in\n-\t       case it's the name of one of the template's parameters.  */\n-\t    if (flag_new_abi)\n-\t      DECL_NAME (r) = mangle_conv_op_name_for_type (TREE_TYPE (type));\n-\t    else\n-\t      DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n-\t  }\n+\t  /* Type-conversion operator.  Reconstruct the name, in\n+\t     case it's the name of one of the template's parameters.  */\n+\t  DECL_NAME (r) = mangle_conv_op_name_for_type (TREE_TYPE (type));\n \n \tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args,\n \t\t\t\t     /*complain=*/1, t);\n@@ -5745,30 +5733,7 @@ tsubst_decl (t, args, type, in_decl)\n \t    register_specialization (r, gen_tmpl, argvec);\n \n \t    /* Set the mangled name for R.  */\n-\t    if (DECL_DESTRUCTOR_P (t)) \n-\t      {\n-\t\tif (flag_new_abi)\n-\t\t  set_mangled_name_for_decl (r);\n-\t\telse\n-\t\t  DECL_ASSEMBLER_NAME (r) = build_destructor_name (ctx);\n-\t      }\n-\t    else \n-\t      {\n-\t\t/* Instantiations of template functions must be mangled\n-\t\t   specially, in order to conform to 14.5.5.1\n-\t\t   [temp.over.link].  */\n-\t\ttree tmpl = DECL_TI_TEMPLATE (t);\n-\t\t\n-\t\t/* TMPL will be NULL if this is a specialization of a\n-\t\t   member function of a template class.  */\n-\t\tif (name_mangling_version < 1\n-\t\t    || tmpl == NULL_TREE\n-\t\t    || (member && !is_member_template (tmpl)\n-\t\t\t&& !DECL_TEMPLATE_INFO (tmpl)))\n-\t\t  set_mangled_name_for_decl (r);\n-\t\telse\n-\t\t  set_mangled_name_for_template_decl (r);\n-\t      }\n+\t    set_mangled_name_for_decl (r);\n \t    \n \t    DECL_RTL (r) = 0;\n \t    make_decl_rtl (r, NULL_PTR, 1);\n@@ -7085,10 +7050,7 @@ tsubst_copy (t, args, complain, in_decl)\n       if (IDENTIFIER_TYPENAME_P (t))\n \t{\n \t  tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\t  if (flag_new_abi)\n-\t    return mangle_conv_op_name_for_type (new_type);\n-\t  else\n-\t    return (build_typename_overload (new_type));\n+\t  return mangle_conv_op_name_for_type (new_type);\n \t}\n       else\n \treturn t;\n@@ -10000,97 +9962,3 @@ get_mostly_instantiated_function_type (decl, contextp, tparmsp)\n \n   return fn_type;\n }\n-\n-/* Set the DECL_ASSEMBLER_NAME for DECL, which is a FUNCTION_DECL that\n-   is either an instantiation or specialization of a template\n-   function.  */\n-\n-static void\n-set_mangled_name_for_template_decl (decl)\n-     tree decl;\n-{\n-  tree context = NULL_TREE;\n-  tree fn_type;\n-  tree ret_type;\n-  tree parm_types;\n-  tree tparms;\n-  tree targs;\n-\n-  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL, 0);\n-  my_friendly_assert (DECL_TEMPLATE_INFO (decl) != NULL_TREE, 0);\n-\n-  /* Under the new ABI, we don't need special machinery.  */\n-  if (flag_new_abi)\n-    {\n-      set_mangled_name_for_decl (decl);\n-      return;\n-    }\n-\n-  /* The names of template functions must be mangled so as to indicate\n-     what template is being specialized with what template arguments.\n-     For example, each of the following three functions must get\n-     different mangled names:\n-\n-       void f(int);                  \n-       template <> void f<7>(int);\n-       template <> void f<8>(int);  */\n-\n-  targs = DECL_TI_ARGS (decl);\n-  if (uses_template_parms (targs))\n-    /* This DECL is for a partial instantiation.  There's no need to\n-       mangle the name of such an entity.  */\n-    return;\n-\n-  /* We now compute the PARMS and RET_TYPE to give to\n-     build_decl_overload_real.  The PARMS and RET_TYPE are the\n-     parameter and return types of the template, after all but the\n-     innermost template arguments have been substituted, not the\n-     parameter and return types of the function DECL.  For example,\n-     given:\n-\n-       template <class T> T f(T);\n-\n-     both PARMS and RET_TYPE should be `T' even if DECL is `int f(int)'.  \n-     A more subtle example is:\n-\n-       template <class T> struct S { template <class U> void f(T, U); }\n-\n-     Here, if DECL is `void S<int>::f(int, double)', PARMS should be\n-     {int, U}.  Thus, the args that we want to subsitute into the\n-     return and parameter type for the function are those in TARGS,\n-     with the innermost level omitted.  */\n-  fn_type = get_mostly_instantiated_function_type (decl, &context, &tparms);\n-\n-  /* Now, get the innermost parameters and arguments, and figure out\n-     the parameter and return types.  */\n-  tparms = INNERMOST_TEMPLATE_PARMS (tparms);\n-  targs = INNERMOST_TEMPLATE_ARGS (targs);\n-  ret_type = TREE_TYPE (fn_type);\n-  parm_types = TYPE_ARG_TYPES (fn_type);\n-\n-  /* For a static member function, we generate a fake `this' pointer,\n-     for the purposes of mangling.  This indicates of which class the\n-     function is a member.  Because of:\n-\n-       [class.static] \n-\n-       There shall not be a static and a nonstatic member function\n-       with the same name and the same parameter types\n-\n-     we don't have to worry that this will result in a clash with a\n-     non-static member function.  */\n-  if (DECL_STATIC_FUNCTION_P (decl))\n-    parm_types = hash_tree_chain (build_pointer_type (context), parm_types);\n-\n-  /* There should be the same number of template parameters as\n-     template arguments.  */\n-  my_friendly_assert (TREE_VEC_LENGTH (tparms) == TREE_VEC_LENGTH (targs),\n-\t\t      0);\n-\n-  /* Actually set the DECL_ASSEMBLER_NAME.  */\n-  DECL_ASSEMBLER_NAME (decl)\n-    = build_decl_overload_real (decl, parm_types, ret_type,\n-\t\t\t\ttparms, targs, \n-\t\t\t\tDECL_FUNCTION_MEMBER_P (decl) \n-\t\t\t        + DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n-}"}, {"sha": "9696d3217a28e262537eeec59e44b51a1b8b90eb", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -83,29 +83,22 @@ void\n init_rtti_processing ()\n {\n   if (flag_honor_std)\n-    push_namespace (get_identifier (\"std\"));\n+    push_namespace (std_identifier);\n   type_info_type_node = xref_tag\n     (class_type_node, get_identifier (\"type_info\"), 1);\n   if (flag_honor_std)\n     pop_namespace ();\n   if (!new_abi_rtti_p ())\n     {\n-      tinfo_decl_id = get_identifier (\"__tf\");\n       tinfo_decl_type = build_function_type\n         (build_reference_type\n           (build_qualified_type\n             (type_info_type_node, TYPE_QUAL_CONST)),\n          void_list_node);\n-      tinfo_var_id = get_identifier (\"__ti\");\n     }\n   else\n-    {\n-      /* FIXME: These identifier prefixes are not set in stone yet.  */\n-      tinfo_decl_id = get_identifier (\"__ti\");\n-      tinfo_var_id = get_identifier (\"__tn\");\n-      tinfo_decl_type = build_qualified_type\n-                          (type_info_type_node, TYPE_QUAL_CONST);\n-    }\n+    tinfo_decl_type = build_qualified_type\n+      (type_info_type_node, TYPE_QUAL_CONST);\n }\n \n /* Given a pointer to an object with at least one virtual table\n@@ -333,11 +326,12 @@ static tree\n get_tinfo_var (type)\n      tree type;\n {\n-  tree tname = build_overload_with_type (tinfo_var_id, type);\n+  tree tname;\n   tree arrtype;\n   int size;\n \n   my_friendly_assert (!new_abi_rtti_p (), 20000118);\n+  tname = mangle_typeinfo_for_type (type);\n   if (IDENTIFIER_GLOBAL_VALUE (tname))\n     return IDENTIFIER_GLOBAL_VALUE (tname);\n     \n@@ -373,17 +367,15 @@ get_tinfo_var (type)\n }\n \n /* Generate the NTBS name of a type.  */\n+\n static tree\n tinfo_name (type)\n      tree type;\n {\n   const char *name;\n   tree name_string;\n \n-  if (flag_new_abi)\n-    name = mangle_type_string (type);\n-  else\n-    name = build_overload_name (type, 1, 1);\n+  name = mangle_type_string (type);\n   name_string = combine_strings (build_string (strlen (name) + 1, name));\n   return name_string;\n }\n@@ -409,11 +401,10 @@ get_tinfo_decl (type)\n     type = build_function_type (TREE_TYPE (type),\n \t\t\t\tTREE_CHAIN (TYPE_ARG_TYPES (type)));\n \n-  if (flag_new_abi)\n+  if (new_abi_rtti_p ())\n     name = mangle_typeinfo_for_type (type);\n   else\n-    name = build_overload_with_type (tinfo_decl_id, type);\n-\n+    name = mangle_typeinfo_fn_for_type (type);\n   d = IDENTIFIER_GLOBAL_VALUE (name);\n   if (d)\n     /* OK */;\n@@ -1315,10 +1306,7 @@ tinfo_base_init (desc, target)\n                      NULL_TREE);\n     tree name_string = tinfo_name (target);\n \n-    if (flag_new_abi)\n-      name_name = mangle_typeinfo_for_type (target);\n-    else\n-      name_name = build_overload_with_type (tinfo_var_id, target);\n+    name_name = mangle_typeinfo_for_type (target);\n     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);\n     \n     DECL_ARTIFICIAL (name_decl) = 1;\n@@ -1327,13 +1315,8 @@ tinfo_base_init (desc, target)\n     DECL_EXTERNAL (name_decl) = 0;\n     TREE_PUBLIC (name_decl) = 1;\n     comdat_linkage (name_decl);\n-    if (flag_new_abi)\n-      /* The new ABI specifies the external name of the string\n-\t containing the type's name.  */\n-      DECL_ASSEMBLER_NAME (name_decl) \n-\t= mangle_typeinfo_string_for_type (target);\n-    else\n-      DECL_ASSEMBLER_NAME (name_decl) = DECL_NAME (name_decl);\n+    DECL_ASSEMBLER_NAME (name_decl) \n+      = mangle_typeinfo_string_for_type (target);\n     DECL_INITIAL (name_decl) = name_string;\n     cp_finish_decl (name_decl, name_string, NULL_TREE, 0);\n   }\n@@ -1699,9 +1682,7 @@ create_real_tinfo_var (name, type, init, non_public)\n   tree hidden_name;\n   char hidden[30];\n   \n-  sprintf (hidden, \"%.*s_%d\",\n-           IDENTIFIER_LENGTH (tinfo_decl_id), IDENTIFIER_POINTER (tinfo_decl_id),\n-           count++);\n+  sprintf (hidden, \"tinfo var %d\", count++);\n   hidden_name = get_identifier (hidden);\n   \n   decl = build_lang_decl (VAR_DECL, hidden_name,"}, {"sha": "f89980a3ad35bcaac2389f39601e00550b536ba4", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -434,17 +434,17 @@ __dynamic_cast_2 (const type_info& (*from)(void), const type_info& (*to)(void),\n // must match the mangling in gcc/cp/rtti.c.\n \n #define BUILTIN(mangled)\t\t\t\t\t\\\n-unsigned char __ti##mangled [sizeof (__builtin_type_info)]\t\\\n+unsigned char _ZTI##mangled [sizeof (__builtin_type_info)]\t\\\n   __attribute__ ((aligned (__alignof__ (void *))));\t\t\\\n-extern \"C\" const type_info &__tf##mangled (void) {\t\t\\\n-  if ((*(void **) __ti##mangled) == 0)\t\t\t\t\\\n-    new (__ti##mangled) __builtin_type_info (#mangled);\t\t\\\n-  return *(type_info *)__ti##mangled;\t\t\t\t\\\n+extern \"C\" const type_info &_ZTF##mangled (void) {\t\t\\\n+  if ((*(void **) _ZTI##mangled) == 0)\t\t\t\t\\\n+    new (_ZTI##mangled) __builtin_type_info (#mangled);\t\t\\\n+  return *(type_info *)_ZTI##mangled;\t\t\t\t\\\n }\n \n BUILTIN (v); BUILTIN (x); BUILTIN (l); BUILTIN (i); BUILTIN (s); BUILTIN (b);\n-BUILTIN (c); BUILTIN (w); BUILTIN (r); BUILTIN (d); BUILTIN (f);\n-BUILTIN (Ui); BUILTIN (Ul); BUILTIN (Ux); BUILTIN (Us); BUILTIN (Uc);\n-BUILTIN (Sc);\n+BUILTIN (c); BUILTIN (w); BUILTIN (e); BUILTIN (d); BUILTIN (f);\n+BUILTIN (j); BUILTIN (m); BUILTIN (y); BUILTIN (t); BUILTIN (h);\n+BUILTIN (a);\n \n #endif"}, {"sha": "82720d395dbe0f5510510195ba256d49d261291c", "filename": "gcc/invoke.texi", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -111,7 +111,7 @@ in the following sections.\n -fhuge-objects -fno-implicit-templates -finit-priority\n -fno-implement-inlines -fname-mangling-version-@var{n}\n -fno-default-inline -fno-operator-names -fno-optional-diags -fpermissive\n--frepo -fstrict-prototype -fsquangle -ftemplate-depth-@var{n}\n+-frepo -fstrict-prototype -ftemplate-depth-@var{n}\n -fuse-cxa-atexit -fvtable-thunks -nostdinc++ -Wctor-dtor-privacy\n -Wno-deprecated -Weffc++ -Wno-non-template-friend -Wnon-virtual-dtor\n -Wold-style-cast -Woverloaded-virtual -Wno-pmf-conversions -Wreorder\n@@ -1155,20 +1155,6 @@ errors if these functions are not inlined everywhere they are called.\n Disable pedwarns about constructs used in MFC, such as implicit int and\n getting a pointer to member function via non-standard syntax.\n \n-@item -fname-mangling-version-@var{n}\n-Control the way in which names are mangled.  Version 0 is compatible\n-with versions of g++ before 2.8.  Version 1 is the default.  Version 1\n-will allow correct mangling of function templates.  For example, \n-version 0 mangling does not mangle foo<int, double> and foo<int, char>\n-given this declaration:\n-\n-@example\n-template <class T, class U> void foo(T t);\n-@end example\n-\n-Like all options that change the ABI, all C++ code, @emph{including\n-libgcc} must be built with the same setting of this option.\n-\n @item -fno-operator-names\n Do not treat the operator name keywords @code{and}, @code{bitand},\n @code{bitor}, @code{compl}, @code{not}, @code{or} and @code{xor} as\n@@ -1211,18 +1197,6 @@ functions.\n \n This flag no longer affects declarations with C++ linkage.\n \n-@item -fsquangle\n-@itemx -fno-squangle\n-@samp{-fsquangle} will enable a compressed form of name mangling for\n-identifiers. In particular, it helps to shorten very long names by recognizing\n-types and class names which occur more than once, replacing them with special\n-short ID codes.  This option also requires any C++ libraries being used to\n-be compiled with this option as well.  The compiler has this disabled (the\n-equivalent of @samp{-fno-squangle}) by default.\n-\n-Like all options that change the ABI, all C++ code, @emph{including\n-libgcc.a} must be built with the same setting of this option.\n-\n @item -ftemplate-depth-@var{n}\n Set the maximum instantiation depth for template classes to @var{n}.\n A limit on the template instantiation depth is needed to detect"}, {"sha": "d3e8f100a444319c94751d19b5e0325cd3e84811", "filename": "gcc/testsuite/g++.old-deja/g++.ext/pretty2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 21 Nov 1999 <nathan@acm.org>\n \n // make sure __FUNCTION__ and __PRETTY_FUNCTION__ work in member functions\n@@ -67,7 +67,7 @@ X::operator int ()\n   printf (\"__FUNCTION__ %s\\n\", function);\n   printf (\"__PRETTY_FUNCTION__ %s\\n\", pretty);\n   \n-  if (strcmp (function, \"__opi\"))\n+  if (strcmp (function, \"operator i\"))\n     bad = true;\n   if (strcmp (pretty, \"X::operator int ()\"))\n     bad = true;"}, {"sha": "a66a8489b0e6348b1eab40545fe3c27bb1ecd9cb", "filename": "gcc/testsuite/g++.old-deja/g++.other/decl4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl4.C?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -4,4 +4,4 @@\n // Simplified for testsuite by Alexandre Oliva\n \n struct foo { operator long double(); };\n-int bar(int __opr); // gets bogus error - XFAIL *-*-*\n+int bar(int __opr); // gets bogus error"}, {"sha": "537d73227ff5ae3aa92f6219a8e4b4d43d861a97", "filename": "gcc/testsuite/g++.old-deja/g++.other/mangle1.C", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -1,11 +1,4 @@\n // Test for proper mangling by setting up name clashes.\n-// Special g++ Options: -fno-squangle\n-\n-#if (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n-#define NAME(OLD, NEW) OLD\n-#else\n-#define NAME(OLD, NEW) NEW\n-#endif /* (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100) */\n \n class A { };\n typedef A A2;\n@@ -14,41 +7,41 @@ typedef void V;\n typedef I I2;\n \n void f (const A2&, int, const A2&, const A&) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0T0, _Z1fRK1AiS1_S1_) = 0; // ERROR - name clash\n+int _Z1fRK1AiS1_S1_ = 0; // ERROR - name clash\n \n void f (int, long, int, I) { } // ERROR - name clash\n-int NAME (f__Filii, _Z1filii) = 0; // ERROR - name clash\n+int _Z1filii = 0; // ERROR - name clash\n \n void f (I, float, I, I2) { } // ERROR - name clash\n-int NAME (f__Fifii, _Z1fifii) = 0; // ERROR - name clash\n+int _Z1fifii = 0; // ERROR - name clash\n \n void f (void*, float, void*, V*) { } // ERROR - name clash\n-int NAME (f__FPvfT0T0, _Z1fPvfS_S_) = 0; // ERROR - name clash\n+int _Z1fPvfS_S_ = 0; // ERROR - name clash\n \n void f (wchar_t) { } // ERROR - name clash\n-int NAME (f__Fw, _Z1fw) = 0; // ERROR - name clash\n+int _Z1fw = 0; // ERROR - name clash\n \n void f(int, A, A2, A) { } // ERROR - name clash\n-int NAME (f__FiG1AN21, _Z1fi1AS_S_) = 0; // ERROR - name clash\n+int _Z1fi1AS_S_ = 0; // ERROR - name clash\n \n void f(const A2&, const A2&, const A2&, const A2&,\n        int&) { } // ERROR - name clash\n-int NAME (f__FRC1AN30Ri, _Z1fRK1AS1_S1_S1_Ri) = 0; // ERROR - name clash\n+int _Z1fRK1AS1_S1_S1_Ri = 0; // ERROR - name clash\n \n void f(const A2&, int, const A2&, const A2&, const A2&,\n        int&) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0N20Ri, _Z1fRK1AiS1_S1_S1_Ri) = 0; // ERROR - name clash\n+int _Z1fRK1AiS1_S1_S1_Ri = 0; // ERROR - name clash\n \n void f(const A2&, int, const A2&, const A2&, const A2&, int&, int&,\n        int&) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0N20RiN25, _Z1fRK1AiS1_S1_S1_RiS2_S2_) = 0; // ERROR - name clash\n+int _Z1fRK1AiS1_S1_S1_RiS2_S2_ = 0; // ERROR - name clash\n \n void f(const A2&, int, const A2&, const A2&, const A2&, int, int,\n        int) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0N20iii, _Z1fRK1AiS1_S1_S1_iii) = 0; // ERROR - name clash\n+int _Z1fRK1AiS1_S1_S1_iii = 0; // ERROR - name clash\n \n void f(bool, bool) {} // ERROR - name clash\n-int NAME (f__FbT0, _Z1fbb) = 0; // ERROR - name clash\n+int _Z1fbb = 0; // ERROR - name clash\n \n int\n main ()"}, {"sha": "deabc088d91c990aab9b11effa5643cfa505c5ed", "filename": "gcc/testsuite/g++.old-deja/g++.other/static8.C", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -1,13 +1,6 @@\n // Build don't link:\n-// Special g++ Options: -fno-squangle\n // Origin: Mark Mitchell <mark@codesourcery.com>\n \n-#if (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n-#define NAME(OLD, NEW) OLD\n-#else\n-#define NAME(OLD, NEW) NEW\n-#endif /* (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100) */\n-\n static unsigned int strlen (const char*) {} // ERROR - previous declaration\n \n-int NAME (strlen__FPCc, _Z6strlenPKc) = 0; // ERROR - duplicate declaration\n+int _Z6strlenPKc = 0; // ERROR - duplicate declaration"}, {"sha": "b9f7d1906c30b73464a833e8f5310fc4d6921422", "filename": "gcc/testsuite/g++.old-deja/g++.pt/local7.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flocal7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/657c130a99d42441051b68f1640410629a78dd0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flocal7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flocal7.C?ref=657c130a99d42441051b68f1640410629a78dd0b", "patch": "@@ -1,5 +1,4 @@\n // Build don't link:\n-// Special g++ Options: -fsquangle\n \n template <class STRUCT, class MEMBER> inline STRUCT *\n setback(MEMBER *bp, MEMBER STRUCT::*offset)"}]}