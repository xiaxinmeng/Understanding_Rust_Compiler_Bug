{"sha": "9418d3d41f581edd9acfdc4f359d37f948c1671e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxOGQzZDQxZjU4MWVkZDlhY2ZkYzRmMzU5ZDM3Zjk0OGMxNjcxZQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-03-30T11:15:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-21T10:45:14Z"}, "message": "[Ada] Improve efficiency of small slice assignments of packed arrays\n\ngcc/ada/\n\n\t* rtsfind.ads, libgnat/s-bitfie.ads, libgnat/s-bituti.adb,\n\tlibgnat/s-bituti.ads (Fast_Copy_Bitfield): New run-time library\n\tfunction to copy bit fields faster than Copy_Bitfield. Cannot be\n\tcalled with zero-size bit fields.  Remove obsolete ??? comments\n\tfrom s-bituti.adb; we already do \"avoid calling this if\n\tForwards_OK is False\".\n\t* exp_ch5.adb (Expand_Assign_Array_Loop_Or_Bitfield,\n\tExpand_Assign_Array_Bitfield_Fast): Generate calls to\n\tFast_Copy_Bitfield when appropriate.\n\t* sem_util.adb, sem_util.ads (Get_Index_Bounds): Two new\n\tfunctions for getting the index bounds. These are more\n\tconvenient than the procedure of the same name, because they can\n\tbe used to initialize constants.", "tree": {"sha": "482346fcb7b87707e2e6f69fc1c235601292a911", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/482346fcb7b87707e2e6f69fc1c235601292a911"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9418d3d41f581edd9acfdc4f359d37f948c1671e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9418d3d41f581edd9acfdc4f359d37f948c1671e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9418d3d41f581edd9acfdc4f359d37f948c1671e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9418d3d41f581edd9acfdc4f359d37f948c1671e/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3681eba728a487f042de72e90c29b1cfca4e2e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3681eba728a487f042de72e90c29b1cfca4e2e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3681eba728a487f042de72e90c29b1cfca4e2e7"}], "stats": {"total": 311, "additions": 271, "deletions": 40}, "files": [{"sha": "39e2e0cb71c3bb63b8742b7b7ee2879d0dc4454c", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 182, "deletions": 21, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=9418d3d41f581edd9acfdc4f359d37f948c1671e", "patch": "@@ -64,6 +64,7 @@ with Snames;         use Snames;\n with Stand;          use Stand;\n with Stringt;        use Stringt;\n with Tbuild;         use Tbuild;\n+with Ttypes;         use Ttypes;\n with Uintp;          use Uintp;\n with Validsw;        use Validsw;\n \n@@ -127,8 +128,16 @@ package body Exp_Ch5 is\n       R_Type : Entity_Id;\n       Rev    : Boolean) return Node_Id;\n    --  Alternative to Expand_Assign_Array_Loop for packed bitfields. Generates\n-   --  a call to the System.Bitfields.Copy_Bitfield, which is more efficient\n-   --  than copying component-by-component.\n+   --  a call to System.Bitfields.Copy_Bitfield, which is more efficient than\n+   --  copying component-by-component.\n+\n+   function Expand_Assign_Array_Bitfield_Fast\n+     (N      : Node_Id;\n+      Larray : Entity_Id;\n+      Rarray : Entity_Id) return Node_Id;\n+   --  Alternative to Expand_Assign_Array_Bitfield. Generates a call to\n+   --  System.Bitfields.Fast_Copy_Bitfield, which is more efficient than\n+   --  Copy_Bitfield, but only works in restricted situations.\n \n    function Expand_Assign_Array_Loop_Or_Bitfield\n      (N      : Node_Id;\n@@ -138,8 +147,8 @@ package body Exp_Ch5 is\n       R_Type : Entity_Id;\n       Ndim   : Pos;\n       Rev    : Boolean) return Node_Id;\n-   --  Calls either Expand_Assign_Array_Loop or Expand_Assign_Array_Bitfield as\n-   --  appropriate.\n+   --  Calls either Expand_Assign_Array_Loop, Expand_Assign_Array_Bitfield, or\n+   --  Expand_Assign_Array_Bitfield_Fast as appropriate.\n \n    procedure Expand_Assign_Record (N : Node_Id);\n    --  N is an assignment of an untagged record value. This routine handles\n@@ -1440,6 +1449,84 @@ package body Exp_Ch5 is\n           R_Addr, R_Bit, L_Addr, L_Bit, Size));\n    end Expand_Assign_Array_Bitfield;\n \n+   ---------------------------------------\n+   -- Expand_Assign_Array_Bitfield_Fast --\n+   ---------------------------------------\n+\n+   function Expand_Assign_Array_Bitfield_Fast\n+     (N      : Node_Id;\n+      Larray : Entity_Id;\n+      Rarray : Entity_Id) return Node_Id\n+   is\n+      pragma Assert (not Change_Of_Representation (N));\n+      --  This won't work, for example, to copy a packed array to an unpacked\n+      --  array.\n+\n+      --  For L (A .. B) := R (C .. D), we generate:\n+      --\n+      --     L := Fast_Copy_Bitfield (R, <offset of R(C)>, L, <offset of L(A)>,\n+      --                              L (A .. B)'Length * L'Component_Size);\n+      --\n+      --  with L and R suitably uncheckedly converted to/from Val_2.\n+      --  The offsets are from the start of L and R.\n+\n+      Loc  : constant Source_Ptr := Sloc (N);\n+\n+      L_Val : constant Node_Id :=\n+        Unchecked_Convert_To (RTE (RE_Val_2), Larray);\n+      R_Val : constant Node_Id :=\n+        Unchecked_Convert_To (RTE (RE_Val_2), Rarray);\n+      --  Converted values of left- and right-hand sides\n+\n+      C_Size : constant Uint := Component_Size (Etype (Larray));\n+      pragma Assert (C_Size >= 1);\n+      pragma Assert (C_Size = Component_Size (Etype (Rarray)));\n+\n+      Larray_Bounds : constant Range_Values :=\n+        Get_Index_Bounds (First_Index (Etype (Larray)));\n+      L_Bounds : constant Range_Values :=\n+        (if Nkind (Name (N)) = N_Slice\n+         then Get_Index_Bounds (Discrete_Range (Name (N)))\n+         else Larray_Bounds);\n+      --  If the left-hand side is A (L..H), Larray_Bounds is A'Range, and\n+      --  L_Bounds is L..H. If it's not a slice, we treat it like a slice\n+      --  starting at A'First.\n+\n+      L_Bit : constant Node_Id :=\n+        Make_Integer_Literal (Loc, (L_Bounds.L - Larray_Bounds.L) * C_Size);\n+\n+      Rarray_Bounds : constant Range_Values :=\n+        Get_Index_Bounds (First_Index (Etype (Rarray)));\n+      R_Bounds : constant Range_Values :=\n+        (if Nkind (Expression (N)) = N_Slice\n+         then Get_Index_Bounds (Discrete_Range (Expression (N)))\n+         else Rarray_Bounds);\n+\n+      R_Bit : constant Node_Id :=\n+        Make_Integer_Literal (Loc, (R_Bounds.L - Rarray_Bounds.L) * C_Size);\n+\n+      Size : constant Node_Id :=\n+        Make_Op_Multiply (Loc,\n+          Make_Attribute_Reference (Loc,\n+            Prefix =>\n+              Duplicate_Subexpr (Name (N), True),\n+            Attribute_Name => Name_Length),\n+          Make_Attribute_Reference (Loc,\n+            Prefix =>\n+              Duplicate_Subexpr (Larray, True),\n+            Attribute_Name => Name_Component_Size));\n+\n+      Call : constant Node_Id := Make_Function_Call (Loc,\n+        Name => New_Occurrence_Of (RTE (RE_Fast_Copy_Bitfield), Loc),\n+        Parameter_Associations => New_List (\n+          R_Val, R_Bit, L_Val, L_Bit, Size));\n+\n+   begin\n+      return Make_Assignment_Statement (Loc,\n+        Name => Duplicate_Subexpr (Larray, True),\n+        Expression => Unchecked_Convert_To (Etype (Larray), Call));\n+   end Expand_Assign_Array_Bitfield_Fast;\n+\n    ------------------------------------------\n    -- Expand_Assign_Array_Loop_Or_Bitfield --\n    ------------------------------------------\n@@ -1453,6 +1540,7 @@ package body Exp_Ch5 is\n       Ndim   : Pos;\n       Rev    : Boolean) return Node_Id\n    is\n+\n       Slices : constant Boolean :=\n         Nkind (Name (N)) = N_Slice or else Nkind (Expression (N)) = N_Slice;\n       L_Prefix_Comp : constant Boolean :=\n@@ -1467,38 +1555,111 @@ package body Exp_Ch5 is\n                      N_Selected_Component | N_Indexed_Component | N_Slice;\n \n    begin\n-      --  Determine whether Copy_Bitfield is appropriate (will work, and will\n-      --  be more efficient than component-by-component copy). Copy_Bitfield\n-      --  doesn't work for reversed storage orders. It is efficient for slices\n-      --  of bit-packed arrays. Copy_Bitfield can read and write bits that are\n-      --  not part of the objects being copied, so we don't want to use it if\n-      --  there are volatile or independent components. If the Prefix of the\n-      --  slice is a component or slice, then it might be a part of an object\n-      --  with some other volatile or independent components, so we disable the\n-      --  optimization in that case as well. We could complicate this code by\n-      --  actually looking for such volatile and independent components.\n+      --  Determine whether Copy_Bitfield or Fast_Copy_Bitfield is appropriate\n+      --  (will work, and will be more efficient than component-by-component\n+      --  copy). Copy_Bitfield doesn't work for reversed storage orders. It is\n+      --  efficient for slices of bit-packed arrays. Copy_Bitfield can read and\n+      --  write bits that are not part of the objects being copied, so we don't\n+      --  want to use it if there are volatile or independent components. If\n+      --  the Prefix of the slice is a component or slice, then it might be a\n+      --  part of an object with some other volatile or independent components,\n+      --  so we disable the optimization in that case as well. We could\n+      --  complicate this code by actually looking for such volatile and\n+      --  independent components.\n \n       if Is_Bit_Packed_Array (L_Type)\n         and then Is_Bit_Packed_Array (R_Type)\n         and then not Reverse_Storage_Order (L_Type)\n         and then not Reverse_Storage_Order (R_Type)\n         and then Ndim = 1\n-        and then not Rev\n         and then Slices\n         and then not Has_Volatile_Component (L_Type)\n         and then not Has_Volatile_Component (R_Type)\n         and then not Has_Independent_Components (L_Type)\n         and then not Has_Independent_Components (R_Type)\n         and then not L_Prefix_Comp\n         and then not R_Prefix_Comp\n-        and then RTE_Available (RE_Copy_Bitfield)\n       then\n-         return Expand_Assign_Array_Bitfield\n-           (N, Larray, Rarray, L_Type, R_Type, Rev);\n-      else\n-         return Expand_Assign_Array_Loop\n-           (N, Larray, Rarray, L_Type, R_Type, Ndim, Rev);\n+         --  Here if Copy_Bitfield can work (except for the Rev test below).\n+         --  Determine whether to call Fast_Copy_Bitfield instead. If we\n+         --  are assigning slices, and all the relevant bounds are known at\n+         --  compile time, and the maximum object size is no greater than\n+         --  System.Bitfields.Val_Bits (i.e. Long_Long_Integer'Size / 2), and\n+         --  we don't have enumeration representation clauses, we can use\n+         --  Fast_Copy_Bitfield. The max size test is to ensure that the slices\n+         --  cannot overlap boundaries not supported by Fast_Copy_Bitfield.\n+\n+         pragma Assert (Known_Component_Size (Base_Type (L_Type)));\n+         pragma Assert (Known_Component_Size (Base_Type (R_Type)));\n+\n+         --  Note that L_Type and R_Type do not necessarily have the same base\n+         --  type, because of array type conversions. Hence the need to check\n+         --  various properties of both.\n+\n+         if Compile_Time_Known_Bounds (Base_Type (L_Type))\n+           and then Compile_Time_Known_Bounds (Base_Type (R_Type))\n+         then\n+            declare\n+               Left_Base_Index : constant Entity_Id :=\n+                 First_Index (Base_Type (L_Type));\n+               Left_Base_Range : constant Range_Values :=\n+                 Get_Index_Bounds (Left_Base_Index);\n+\n+               Right_Base_Index : constant Entity_Id :=\n+                 First_Index (Base_Type (R_Type));\n+               Right_Base_Range : constant Range_Values :=\n+                 Get_Index_Bounds (Right_Base_Index);\n+\n+               Known_Left_Slice_Low : constant Boolean :=\n+                 (if Nkind (Name (N)) = N_Slice\n+                    then Compile_Time_Known_Value\n+                      (Get_Index_Bounds (Discrete_Range (Name (N))).L));\n+               Known_Right_Slice_Low : constant Boolean :=\n+                 (if Nkind (Expression (N)) = N_Slice\n+                    then Compile_Time_Known_Value\n+                      (Get_Index_Bounds (Discrete_Range (Expression (N))).H));\n+\n+               Val_Bits : constant Pos := Standard_Long_Long_Integer_Size / 2;\n+\n+            begin\n+               if Left_Base_Range.H - Left_Base_Range.L < Val_Bits\n+                 and then Right_Base_Range.H - Right_Base_Range.L < Val_Bits\n+                 and then Known_Esize (L_Type)\n+                 and then Known_Esize (R_Type)\n+                 and then Known_Left_Slice_Low\n+                 and then Known_Right_Slice_Low\n+                 and then Compile_Time_Known_Value\n+                   (Get_Index_Bounds (First_Index (Etype (Larray))).L)\n+                 and then Compile_Time_Known_Value\n+                   (Get_Index_Bounds (First_Index (Etype (Rarray))).L)\n+                 and then\n+                   not (Is_Enumeration_Type (Etype (Left_Base_Index))\n+                          and then Has_Enumeration_Rep_Clause\n+                            (Etype (Left_Base_Index)))\n+                 and then RTE_Available (RE_Fast_Copy_Bitfield)\n+               then\n+                  pragma Assert (Esize (L_Type) /= 0);\n+                  pragma Assert (Esize (R_Type) /= 0);\n+\n+                  return Expand_Assign_Array_Bitfield_Fast (N, Larray, Rarray);\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Fast_Copy_Bitfield can work if Rev is True, because the data is\n+         --  passed and returned by copy. Copy_Bitfield cannot.\n+\n+         if not Rev and then RTE_Available (RE_Copy_Bitfield) then\n+            return Expand_Assign_Array_Bitfield\n+              (N, Larray, Rarray, L_Type, R_Type, Rev);\n+         end if;\n       end if;\n+\n+      --  Here if we did not return above, with Fast_Copy_Bitfield or\n+      --  Copy_Bitfield.\n+\n+      return Expand_Assign_Array_Loop\n+        (N, Larray, Rarray, L_Type, R_Type, Ndim, Rev);\n    end Expand_Assign_Array_Loop_Or_Bitfield;\n \n    --------------------------"}, {"sha": "f081d55fe5fc3a4f89ab4df2804d9d75660c7591", "filename": "gcc/ada/libgnat/s-bitfie.ads", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Flibgnat%2Fs-bitfie.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Flibgnat%2Fs-bitfie.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bitfie.ads?ref=9418d3d41f581edd9acfdc4f359d37f948c1671e", "patch": "@@ -47,10 +47,9 @@ package System.Bitfields is\n    pragma Provide_Shift_Operators (Val_2);\n    type Val is mod 2**Val_Bits with Alignment => Val_Bytes;\n \n-   --  ??? It turns out that enabling checks on the instantiation of\n-   --  System.Bitfield_Utils.G makes a latent visibility bug appear on strict\n-   --  alignment platforms related to alignment checks. Work around it by\n-   --  suppressing these checks explicitly.\n+   --  Enabling checks on the instantiation of System.Bitfield_Utils.G makes a\n+   --  latent visibility bug appear on strict alignment platforms related to\n+   --  alignment checks. Work around it by suppressing these checks explicitly.\n \n    pragma Suppress (Alignment_Check);\n    package Utils is new System.Bitfield_Utils.G (Val, Val_2);\n@@ -63,4 +62,12 @@ package System.Bitfields is\n       Size         : Utils.Bit_Size)\n      renames Utils.Copy_Bitfield;\n \n+   function Fast_Copy_Bitfield\n+     (Src         : Val_2;\n+      Src_Offset  : Utils.Bit_Offset;\n+      Dest        : Val_2;\n+      Dest_Offset : Utils.Bit_Offset;\n+      Size        : Utils.Small_Size)\n+     return Val_2 renames Utils.Fast_Copy_Bitfield;\n+\n end System.Bitfields;"}, {"sha": "d571f544bb6979680cb84d16715aa31bdb501aa6", "filename": "gcc/ada/libgnat/s-bituti.adb", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Flibgnat%2Fs-bituti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Flibgnat%2Fs-bituti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bituti.adb?ref=9418d3d41f581edd9acfdc4f359d37f948c1671e", "patch": "@@ -31,14 +31,6 @@\n \n package body System.Bitfield_Utils is\n \n-   --  ???\n-   --\n-   --  This code does not yet work for overlapping bit fields. We need to copy\n-   --  backwards in some cases (i.e. from higher to lower bit addresses).\n-   --  Alternatively, we could avoid calling this if Forwards_OK is False.\n-   --\n-   --  ???\n-\n    package body G is\n \n       Val_Bytes : constant Address := Address (Val'Size / Storage_Unit);\n@@ -77,7 +69,7 @@ package body System.Bitfield_Utils is\n \n       function Get_Bitfield\n         (Src : Val_2; Src_Offset : Bit_Offset; Size : Small_Size)\n-         return Val;\n+         return Val with Inline;\n       --  Returns the bit field in Src starting at Src_Offset, of the given\n       --  Size. If Size < Small_Size'Last, then high order bits are zero.\n \n@@ -86,7 +78,7 @@ package body System.Bitfield_Utils is\n          Dest : Val_2;\n          Dest_Offset : Bit_Offset;\n          Size : Small_Size)\n-        return Val_2;\n+        return Val_2 with Inline;\n       --  The bit field in Dest starting at Dest_Offset, of the given Size, is\n       --  set to Src_Value. Src_Value must have high order bits (Size and\n       --  above) zero. The result is returned as the function result.\n@@ -426,6 +418,22 @@ package body System.Bitfield_Utils is\n          end if;\n       end Copy_Bitfield;\n \n+      function Fast_Copy_Bitfield\n+        (Src         : Val_2;\n+         Src_Offset  : Bit_Offset;\n+         Dest        : Val_2;\n+         Dest_Offset : Bit_Offset;\n+         Size        : Small_Size)\n+        return Val_2 is\n+         Result : constant Val_2 := Set_Bitfield\n+           (Get_Bitfield (Src, Src_Offset, Size), Dest, Dest_Offset, Size);\n+      begin\n+         --  No need to explicitly do nothing for zero size case, because Size\n+         --  cannot be zero.\n+\n+         return Result;\n+      end Fast_Copy_Bitfield;\n+\n    end G;\n \n end System.Bitfield_Utils;"}, {"sha": "8afee248d65bc41b022122ed4346a10025f1c589", "filename": "gcc/ada/libgnat/s-bituti.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Flibgnat%2Fs-bituti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Flibgnat%2Fs-bituti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bituti.ads?ref=9418d3d41f581edd9acfdc4f359d37f948c1671e", "patch": "@@ -54,7 +54,7 @@ package System.Bitfield_Utils is\n    --  generic formal, or on a type derived from a generic formal, so they have\n    --  to be passed in.\n    --\n-   --  Endian indicates whether we're on little-endian or big-endian machine.\n+   --  Endian indicates whether we're on a little- or big-endian machine.\n \n    pragma Elaborate_Body;\n \n@@ -127,6 +127,20 @@ package System.Bitfield_Utils is\n       --        D (D_First)'Address, D (D_First)'Bit,\n       --        Size);\n \n+      function Fast_Copy_Bitfield\n+        (Src         : Val_2;\n+         Src_Offset  : Bit_Offset;\n+         Dest        : Val_2;\n+         Dest_Offset : Bit_Offset;\n+         Size        : Small_Size)\n+        return Val_2 with Inline;\n+      --  Faster version of Copy_Bitfield, with a different calling convention.\n+      --  In particular, we pass by copy rather than passing Addresses. The bit\n+      --  field must fit in Val_Bits. Src and Dest must be properly aligned.\n+      --  The result is supposed to be assigned back into Dest, as in:\n+      --\n+      --     Dest := Fast_Copy_Bitfield (Src, ..., Dest, ..., ...);\n+\n    end G;\n \n end System.Bitfield_Utils;"}, {"sha": "36e0440c868f735f521a5f4e8c718ecc5d2a8f89", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=9418d3d41f581edd9acfdc4f359d37f948c1671e", "patch": "@@ -838,7 +838,9 @@ package Rtsfind is\n      RE_To_Bignum,                       -- System.Bignums\n      RE_From_Bignum,                     -- System.Bignums\n \n+     RE_Val_2,                           -- System.Bitfields\n      RE_Copy_Bitfield,                   -- System.Bitfields\n+     RE_Fast_Copy_Bitfield,              -- System.Bitfields\n \n      RE_Bit_And,                         -- System.Bit_Ops\n      RE_Bit_Eq,                          -- System.Bit_Ops\n@@ -2518,7 +2520,9 @@ package Rtsfind is\n      RE_To_Bignum                        => System_Bignums,\n      RE_From_Bignum                      => System_Bignums,\n \n+     RE_Val_2                            => System_Bitfields,\n      RE_Copy_Bitfield                    => System_Bitfields,\n+     RE_Fast_Copy_Bitfield               => System_Bitfields,\n \n      RE_Bit_And                          => System_Bit_Ops,\n      RE_Bit_Eq                           => System_Bit_Ops,"}, {"sha": "479bb146b61a6f10ff4c9ee137d9b6eac217582f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9418d3d41f581edd9acfdc4f359d37f948c1671e", "patch": "@@ -10943,6 +10943,23 @@ package body Sem_Util is\n       end if;\n    end Get_Index_Bounds;\n \n+   function Get_Index_Bounds\n+     (N             : Node_Id;\n+      Use_Full_View : Boolean := False) return Range_Nodes is\n+      Result : Range_Nodes;\n+   begin\n+      Get_Index_Bounds (N, Result.L, Result.H, Use_Full_View);\n+      return Result;\n+   end Get_Index_Bounds;\n+\n+   function Get_Index_Bounds\n+     (N             : Node_Id;\n+      Use_Full_View : Boolean := False) return Range_Values is\n+      Nodes : constant Range_Nodes := Get_Index_Bounds (N, Use_Full_View);\n+   begin\n+      return (Expr_Value (Nodes.L), Expr_Value (Nodes.H));\n+   end Get_Index_Bounds;\n+\n    -----------------------------\n    -- Get_Interfacing_Aspects --\n    -----------------------------\n@@ -26984,7 +27001,7 @@ package body Sem_Util is\n    is\n    begin\n       --  The only entities for which we track constant values are variables\n-      --  which are not renamings, constants and formal parameters, so check\n+      --  that are not renamings, constants and formal parameters, so check\n       --  if we have this case.\n \n       --  Note: it may seem odd to track constant values for constants, but in"}, {"sha": "a1ed43cba43d5acac1012eb896a106ea8f9237c3", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9418d3d41f581edd9acfdc4f359d37f948c1671e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=9418d3d41f581edd9acfdc4f359d37f948c1671e", "patch": "@@ -1167,6 +1167,26 @@ package Sem_Util is\n    --  the index type turns out to be a partial view; this case should not\n    --  arise during normal compilation of semantically correct programs.\n \n+   type Range_Nodes is record\n+      L, H : Node_Id; -- First and Last nodes of a discrete_range\n+   end record;\n+\n+   type Range_Values is record\n+      L, H : Uint; -- First and Last values of a discrete_range\n+   end record;\n+\n+   function Get_Index_Bounds\n+     (N             : Node_Id;\n+      Use_Full_View : Boolean := False) return Range_Nodes;\n+   --  Same as the above procedure, but returns the result as a record.\n+   --  ???This should probably replace the procedure.\n+\n+   function Get_Index_Bounds\n+     (N             : Node_Id;\n+      Use_Full_View : Boolean := False) return Range_Values;\n+   --  Same as the above function, but returns the values, which must be known\n+   --  at compile time.\n+\n    procedure Get_Interfacing_Aspects\n      (Iface_Asp : Node_Id;\n       Conv_Asp  : out Node_Id;\n@@ -2960,9 +2980,9 @@ package Sem_Util is\n    --  the value is valid) for the given entity Ent. This value can only be\n    --  captured if sequential execution semantics can be properly guaranteed so\n    --  that a subsequent reference will indeed be sure that this current value\n-   --  indication is correct. The node N is the construct which resulted in\n-   --  the possible capture of the value (this is used to check if we are in\n-   --  a conditional).\n+   --  indication is correct. The node N is the construct that resulted in the\n+   --  possible capture of the value (this is used to check if we are in a\n+   --  conditional).\n    --\n    --  Cond is used to skip the test for being inside a conditional. It is used\n    --  in the case of capturing values from if/while tests, which already do a"}]}