{"sha": "ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "node_id": "C_kwDOANBUbNoAKGViYjEyN2YyYWVkMzJmMjFhMzdiMzFlOGE1MzMwZGVmYzZiZmU1ZTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-08-31T09:47:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T09:47:45Z"}, "message": "Merge #1408 #1503 #1511\n\n1408: Experiment: add optional error codes to diagnostics r=CohenArthur a=davidmalcolm\n\nrustc has error codes to identify specific errors, with URLs documenting each error.\r\n\r\nIn GCC 13 I've extended GCC's diagnostic subsystem so that a diagnostic can be associated with zero or more `diagnostic_metadata::rule` instances, which have a textual description and a URL.  I meant this for rules in coding standards and specifications, but it struck me that potentially gccrs could reuse the same error codes as rustc.\r\n\r\nThe following pull request implements an experimental form of this; I picked a single error at random: [E0054](https://doc.rust-lang.org/error-index.html#E0054).  \r\n\r\nWith this patch, gccrs emits e.g.:\r\n\r\n```\r\nbad_as_bool_char.rs:8:19: error: invalid cast [u8] to [bool] [E0054]\r\n    8 |   let nb = 0u8 as bool;\r\n      |            ~      ^\r\n\r\n```\r\nwhere the trailing [E0054] is colorized, and, in a suitably capable terminal is a clickable URL to https://doc.rust-lang.org/error-index.html#E0054.\r\n\r\nThe error code is after the diagnostic message, whereas rustc puts it after the word \"error\".  I could change that in gcc's diagnostic.cc, perhaps.\r\n\r\nI'm not sure if this is a good idea (e.g. is it OK and maintainable to share error codes with rustc?), but thought it was worth sharing.\r\n\n\n1503: Add overflow traps r=CohenArthur a=CohenArthur\n\nOpening as a draft since the code is really ugly and some tests still fail. I am looking for feedback on the implementation and my approximative use of functions like `temporary_variable` which I feel I might be using the wrong way.\r\n\r\nI'll open up an issue of what still needs to be done, namely:\r\n- [x] Properly handle sub and mul operations\r\n- [ ] Disable the check in `release` mode (`-frust-disable-overflow-checks`)\r\n- [ ] Handle specific rust overflow attribute (needs checkup on the name)\r\n\r\nI'll open up some PRs to clean up some parts of the backend as well.\n\n1511: lint: Do not emit unused warnings for public items r=CohenArthur a=CohenArthur\n\nThis fixes the overzealous warnings on public items from the unused pass\n\nCo-authored-by: David Malcolm <dmalcolm@redhat.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "9b0e09403fd4d39353bcd87ac2ee1364d8720ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b0e09403fd4d39353bcd87ac2ee1364d8720ac0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDy5BCRBK7hj4Ov3rIwAApcwIAIVxsEZlqW9sXPLTVToApBTH\no+kcfTFFVIUiv+/SeHMeVdZelHloVcyyyyC36E4uAUFsEDV2/Zaf5CZMmknvQTJe\nlHX3nWinXxW53hmhMSsxTAusK1ds/AfIpwe6P1kaPPGtt63NxgIUs9/whxV43fqU\nHbsZqiWtE4X7lC+2IM8fSJjr/l+CRlxwsLWjiI446dAc49Xs71cV+xV8Y7UoR62o\ngqoIcdKS04eBdsocMIgFMCZrAnIp80ZkRttex67hJFcWtL5ZzV141CHaMiybMrvC\nLHgQr2stx6PxhNnhCx3ZVwBq4A+LE7pMrEBVDa8AZS/6aigHjboyk5G1zkFZRuk=\n=x+ry\n-----END PGP SIGNATURE-----\n", "payload": "tree 9b0e09403fd4d39353bcd87ac2ee1364d8720ac0\nparent 45f80a2d86c3cb6210f00547eee3e9af59a62fdf\nparent 2a607410e5911638747c1f472d92c563115b410c\nparent fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c\nparent 702bb4bb01b93bb7c0f070883baf547ffdbebd17\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1661939265 +0000\ncommitter GitHub <noreply@github.com> 1661939265 +0000\n\nMerge #1408 #1503 #1511\n\n1408: Experiment: add optional error codes to diagnostics r=CohenArthur a=davidmalcolm\n\nrustc has error codes to identify specific errors, with URLs documenting each error.\r\n\r\nIn GCC 13 I've extended GCC's diagnostic subsystem so that a diagnostic can be associated with zero or more `diagnostic_metadata::rule` instances, which have a textual description and a URL.  I meant this for rules in coding standards and specifications, but it struck me that potentially gccrs could reuse the same error codes as rustc.\r\n\r\nThe following pull request implements an experimental form of this; I picked a single error at random: [E0054](https://doc.rust-lang.org/error-index.html#E0054).  \r\n\r\nWith this patch, gccrs emits e.g.:\r\n\r\n```\r\nbad_as_bool_char.rs:8:19: error: invalid cast [u8] to [bool] [E0054]\r\n    8 |   let nb = 0u8 as bool;\r\n      |            ~      ^\r\n\r\n```\r\nwhere the trailing [E0054] is colorized, and, in a suitably capable terminal is a clickable URL to https://doc.rust-lang.org/error-index.html#E0054.\r\n\r\nThe error code is after the diagnostic message, whereas rustc puts it after the word \"error\".  I could change that in gcc's diagnostic.cc, perhaps.\r\n\r\nI'm not sure if this is a good idea (e.g. is it OK and maintainable to share error codes with rustc?), but thought it was worth sharing.\r\n\n\n1503: Add overflow traps r=CohenArthur a=CohenArthur\n\nOpening as a draft since the code is really ugly and some tests still fail. I am looking for feedback on the implementation and my approximative use of functions like `temporary_variable` which I feel I might be using the wrong way.\r\n\r\nI'll open up an issue of what still needs to be done, namely:\r\n- [x] Properly handle sub and mul operations\r\n- [ ] Disable the check in `release` mode (`-frust-disable-overflow-checks`)\r\n- [ ] Handle specific rust overflow attribute (needs checkup on the name)\r\n\r\nI'll open up some PRs to clean up some parts of the backend as well.\n\n1511: lint: Do not emit unused warnings for public items r=CohenArthur a=CohenArthur\n\nThis fixes the overzealous warnings on public items from the unused pass\n\nCo-authored-by: David Malcolm <dmalcolm@redhat.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45f80a2d86c3cb6210f00547eee3e9af59a62fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f80a2d86c3cb6210f00547eee3e9af59a62fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f80a2d86c3cb6210f00547eee3e9af59a62fdf"}, {"sha": "2a607410e5911638747c1f472d92c563115b410c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a607410e5911638747c1f472d92c563115b410c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a607410e5911638747c1f472d92c563115b410c"}, {"sha": "fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c"}, {"sha": "702bb4bb01b93bb7c0f070883baf547ffdbebd17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/702bb4bb01b93bb7c0f070883baf547ffdbebd17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/702bb4bb01b93bb7c0f070883baf547ffdbebd17"}], "stats": {"total": 519, "additions": 420, "deletions": 99}, "files": [{"sha": "3cc5ae0788bcca71d132e297203e1f48c33f1326", "filename": ".github/bors_log_expected_warnings", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/.github%2Fbors_log_expected_warnings", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/.github%2Fbors_log_expected_warnings", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fbors_log_expected_warnings?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -84,7 +84,7 @@\n ../../gcc/config/i386/i386.cc:2565:8: warning: too many arguments for format [-Wformat-extra-args]\n ../../gcc/config/i386/i386.cc:2565:8: warning: unknown conversion type character \u2018{\u2019 in format [-Wformat=]\n ../../gcc/config/i386/i386.cc:2565:8: warning: unknown conversion type character \u2018}\u2019 in format [-Wformat=]\n-../../gcc/diagnostic.cc:2191:52: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/diagnostic.cc:2206:52: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/doc/sourcebuild.texi:1452: warning: node `Add Options' is next for `Effective-Target Keywords' in menu but not in sectioning\n ../../gcc/doc/sourcebuild.texi:2946: warning: node `Effective-Target Keywords' is prev for `Add Options' in menu but not in sectioning\n ../../gcc/fold-const.cc:314:42: warning: format not a string literal and no format arguments [-Wformat-security]"}, {"sha": "ff74994a62e87315cabe88ad88f1ed9f81e920d7", "filename": "gcc/diagnostic-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Fdiagnostic-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Fdiagnostic-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-core.h?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -92,6 +92,9 @@ extern void error_n (location_t, unsigned HOST_WIDE_INT, const char *,\n extern void error_at (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void error_at (rich_location *, const char *, ...)\n   ATTRIBUTE_GCC_DIAG(2,3);\n+extern void error_meta (rich_location *, const diagnostic_metadata &,\n+\t\t\tconst char *, ...)\n+  ATTRIBUTE_GCC_DIAG(3,4);\n extern void fatal_error (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3)\n      ATTRIBUTE_NORETURN;\n /* Pass one of the OPT_W* from options.h as the second parameter.  */"}, {"sha": "0461b325efb23719744ea960841a5a63c50ab676", "filename": "gcc/diagnostic.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Fdiagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Fdiagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -2050,6 +2050,21 @@ error_at (rich_location *richloc, const char *gmsgid, ...)\n   va_end (ap);\n }\n \n+/* Same as above, but with metadata.  */\n+\n+void\n+error_meta (rich_location *richloc, const diagnostic_metadata &metadata,\n+\t    const char *gmsgid, ...)\n+{\n+  gcc_assert (richloc);\n+\n+  auto_diagnostic_group d;\n+  va_list ap;\n+  va_start (ap, gmsgid);\n+  diagnostic_impl (richloc, &metadata, -1, gmsgid, &ap, DK_ERROR);\n+  va_end (ap);\n+}\n+\n /* \"Sorry, not implemented.\"  Use for a language feature which is\n    required by the relevant specification but not implemented by GCC.\n    An object file will not be produced.  */"}, {"sha": "5cd840107231c654412142a99cca88e7e8ceb71e", "filename": "gcc/rust/backend/rust-builtins.h", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.h?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -18,8 +18,9 @@\n #define RUST_BUILTINS_H\n \n #include \"rust-system.h\"\n-#include \"tree.h\"\n+#include \"rust-tree.h\"\n #include \"langhooks.h\"\n+#include \"tree.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -99,16 +100,34 @@ class BuiltinsContext\n \n   BuiltinsContext () { setup (); }\n \n-  void setup ()\n+  void setup_overflow_fns ()\n+  {\n+    tree overflow_type\n+      = build_varargs_function_type_list (boolean_type_node, NULL_TREE);\n+\n+    define_builtin (\"add_overflow\", BUILT_IN_ADD_OVERFLOW,\n+\t\t    \"__builtin_add_overflow\", \"add_overflow\", overflow_type, 0);\n+    define_builtin (\"sub_overflow\", BUILT_IN_SUB_OVERFLOW,\n+\t\t    \"__builtin_sub_overflow\", \"sub_overflow\", overflow_type, 0);\n+    define_builtin (\"mul_overflow\", BUILT_IN_MUL_OVERFLOW,\n+\t\t    \"__builtin_mul_overflow\", \"mul_overflow\", overflow_type, 0);\n+  }\n+\n+  void setup_math_fns ()\n   {\n     tree math_function_type_f32\n       = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n \n     define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n \t\t    math_function_type_f32, builtin_const);\n-\n     define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n \t\t    math_function_type_f32, builtin_const);\n+  }\n+\n+  void setup ()\n+  {\n+    setup_math_fns ();\n+    setup_overflow_fns ();\n \n     define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE,\n \t\t    \"__builtin_unreachable\", NULL,\n@@ -132,6 +151,16 @@ class BuiltinsContext\n       0);\n   }\n \n+  static void handle_flags (tree decl, int flags)\n+  {\n+    if (flags & builtin_const)\n+      TREE_READONLY (decl) = 1;\n+    if (flags & builtin_noreturn)\n+      TREE_READONLY (decl) = 1;\n+    if (flags & builtin_novops)\n+      DECL_IS_NOVOPS (decl) = 1;\n+  }\n+\n   // Define a builtin function.  BCODE is the builtin function code\n   // defined by builtins.def.  NAME is the name of the builtin function.\n   // LIBNAME is the name of the corresponding library function, and is\n@@ -144,24 +173,16 @@ class BuiltinsContext\n   {\n     tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n \t\t\t\t      libname, NULL_TREE);\n-    if ((flags & builtin_const) != 0)\n-      TREE_READONLY (decl) = 1;\n-    if ((flags & builtin_noreturn) != 0)\n-      TREE_THIS_VOLATILE (decl) = 1;\n-    if ((flags & builtin_novops) != 0)\n-      DECL_IS_NOVOPS (decl) = 1;\n+    handle_flags (decl, flags);\n     set_builtin_decl (bcode, decl, true);\n+\n     this->builtin_functions_[name] = decl;\n     if (libname != NULL)\n       {\n \tdecl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n \t\t\t\t     NULL, NULL_TREE);\n-\tif ((flags & builtin_const) != 0)\n-\t  TREE_READONLY (decl) = 1;\n-\tif ((flags & builtin_noreturn) != 0)\n-\t  TREE_THIS_VOLATILE (decl) = 1;\n-\tif ((flags & builtin_novops) != 0)\n-\t  DECL_IS_NOVOPS (decl) = 1;\n+\thandle_flags (decl, flags);\n+\n \tthis->builtin_functions_[libname] = decl;\n       }\n "}, {"sha": "e13c08caae49e867c5289cc455420d4f35fbe317", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-compile-block.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-constexpr.h\"\n+#include \"rust-gcc.h\"\n \n #include \"fold-const.h\"\n #include \"realmpfr.h\"\n@@ -146,9 +147,26 @@ CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n       return;\n     }\n \n-  translated\n-    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t     expr.get_locus ());\n+  if (ctx->in_fn () && !ctx->const_context_p ())\n+    {\n+      auto receiver_tmp = NULL_TREE;\n+      auto receiver\n+\t= ctx->get_backend ()->temporary_variable (ctx->peek_fn ().fndecl,\n+\t\t\t\t\t\t   NULL_TREE, TREE_TYPE (lhs),\n+\t\t\t\t\t\t   lhs, true, expr.get_locus (),\n+\t\t\t\t\t\t   &receiver_tmp);\n+      auto check\n+\t= ctx->get_backend ()->arithmetic_or_logical_expression_checked (\n+\t  op, lhs, rhs, expr.get_locus (), receiver);\n+\n+      ctx->add_statement (check);\n+      translated = receiver->get_tree (expr.get_locus ());\n+    }\n+  else\n+    {\n+      translated = ctx->get_backend ()->arithmetic_or_logical_expression (\n+\top, lhs, rhs, expr.get_locus ());\n+    }\n }\n \n void\n@@ -176,13 +194,27 @@ CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n       return;\n     }\n \n-  auto operator_expr\n-    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t     expr.get_locus ());\n-  tree assignment\n-    = ctx->get_backend ()->assignment_statement (lhs, operator_expr,\n-\t\t\t\t\t\t expr.get_locus ());\n-  ctx->add_statement (assignment);\n+  if (ctx->in_fn () && !ctx->const_context_p ())\n+    {\n+      auto tmp = NULL_TREE;\n+      auto receiver\n+\t= ctx->get_backend ()->temporary_variable (ctx->peek_fn ().fndecl,\n+\t\t\t\t\t\t   NULL_TREE, TREE_TYPE (lhs),\n+\t\t\t\t\t\t   lhs, true, expr.get_locus (),\n+\t\t\t\t\t\t   &tmp);\n+      auto check\n+\t= ctx->get_backend ()->arithmetic_or_logical_expression_checked (\n+\t  op, lhs, rhs, expr.get_locus (), receiver);\n+      ctx->add_statement (check);\n+\n+      translated = ctx->get_backend ()->assignment_statement (\n+\tlhs, receiver->get_tree (expr.get_locus ()), expr.get_locus ());\n+    }\n+  else\n+    {\n+      translated = ctx->get_backend ()->arithmetic_or_logical_expression (\n+\top, lhs, rhs, expr.get_locus ());\n+    }\n }\n \n void\n@@ -2378,7 +2410,10 @@ CompileExpr::array_copied_expr (Location expr_locus,\n       return error_mark_node;\n     }\n \n+  ctx->push_const_context ();\n   tree capacity_expr = CompileExpr::Compile (elems.get_num_copies_expr (), ctx);\n+  ctx->pop_const_context ();\n+\n   if (!TREE_CONSTANT (capacity_expr))\n     {\n       rust_error_at (expr_locus, \"non const num copies %qT\", array_type);"}, {"sha": "96c4e7fcf6119286fa21f1e5ac31b2a26d6d6a27", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -160,6 +160,9 @@ CompileItem::visit (HIR::Function &function)\n     function.get_mappings ().get_nodeid (), &canonical_path);\n   rust_assert (ok);\n \n+  if (function.get_qualifiers ().is_const ())\n+    ctx->push_const_context ();\n+\n   tree fndecl\n     = compile_function (ctx, function.get_function_name (),\n \t\t\tfunction.get_self_param (),\n@@ -169,6 +172,9 @@ CompileItem::visit (HIR::Function &function)\n \t\t\tfunction.get_definition ().get (), canonical_path,\n \t\t\tfntype, function.has_function_return_type ());\n   reference = address_expression (fndecl, ref_locus);\n+\n+  if (function.get_qualifiers ().is_const ())\n+    ctx->pop_const_context ();\n }\n \n void"}, {"sha": "77d84748eb5a52b87e69d6b1389625234464d72d", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -370,7 +370,11 @@ TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n {\n   tree element_type\n     = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+\n+  ctx->push_const_context ();\n   tree capacity_expr = CompileExpr::Compile (&type.get_capacity_expr (), ctx);\n+  ctx->pop_const_context ();\n+\n   tree folded_capacity_expr = fold_expr (capacity_expr);\n \n   translated"}, {"sha": "3e1df391d27f498395188141173cf2830f3b632d", "filename": "gcc/rust/checks/lints/rust-lint-scan-deadcode.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-scan-deadcode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-scan-deadcode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Flints%2Frust-lint-scan-deadcode.h?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -53,7 +53,7 @@ class ScanDeadcode : public MarkLiveBase\n   void visit (HIR::Function &function) override\n   {\n     HirId hirId = function.get_mappings ().get_hirid ();\n-    if (should_warn (hirId))\n+    if (should_warn (hirId) && !function.get_visibility ().is_public ())\n       {\n \tif (mappings->is_impl_item (hirId))\n \t  {\n@@ -78,7 +78,7 @@ class ScanDeadcode : public MarkLiveBase\n   void visit (HIR::StructStruct &stct) override\n   {\n     HirId hirId = stct.get_mappings ().get_hirid ();\n-    if (should_warn (hirId))\n+    if (should_warn (hirId) && !stct.get_visibility ().is_public ())\n       {\n \tbool name_starts_underscore = stct.get_identifier ().at (0) == '_';\n \tif (!name_starts_underscore)\n@@ -92,7 +92,8 @@ class ScanDeadcode : public MarkLiveBase\n \tfor (auto &field : stct.get_fields ())\n \t  {\n \t    HirId field_hir_id = field.get_mappings ().get_hirid ();\n-\t    if (should_warn (field_hir_id))\n+\t    if (should_warn (field_hir_id)\n+\t\t&& !field.get_visibility ().is_public ())\n \t      {\n \t\trust_warning_at (field.get_locus (), 0,\n \t\t\t\t \"field is never read: %<%s%>\",\n@@ -106,7 +107,7 @@ class ScanDeadcode : public MarkLiveBase\n   {\n     // only warn tuple struct unconstructed, and ignoring unused field\n     HirId hirId = stct.get_mappings ().get_hirid ();\n-    if (should_warn (hirId))\n+    if (should_warn (hirId) && !stct.get_visibility ().is_public ())\n       {\n \trust_warning_at (stct.get_locus (), 0,\n \t\t\t \"struct is never constructed: %<%s%>\","}, {"sha": "cda264233b187aed0cd85ebb8f98b97434d25ee0", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -235,13 +235,24 @@ class Backend\n   // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n   virtual tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n \t\t\t\t\t\t tree left, tree right,\n-\t\t\t\t\t\t Location)\n+\t\t\t\t\t\t Location loc)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n+  // This function adds overflow checking and returns a list of statements to\n+  // add to the current function context. The `receiver` variable refers to the\n+  // variable which will contain the result of that operation.\n+  virtual tree\n+  arithmetic_or_logical_expression_checked (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t    tree left, tree right, Location loc,\n+\t\t\t\t\t    Bvariable *receiver)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ComparisonOperator.\n   virtual tree comparison_expression (ComparisonOperator op, tree left,\n-\t\t\t\t      tree right, Location)\n+\t\t\t\t      tree right, Location loc)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n@@ -416,8 +427,8 @@ class Backend\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n-  virtual Bvariable *temporary_variable (tree, tree, tree, tree init,\n-\t\t\t\t\t bool address_is_taken,\n+  virtual Bvariable *temporary_variable (tree fndecl, tree bind_tree, tree type,\n+\t\t\t\t\t tree init, bool address_is_taken,\n \t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n "}, {"sha": "79daf6b163c9fcacae33ef6d975c93ad3cbf828d", "filename": "gcc/rust/rust-diagnostics.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -166,6 +166,17 @@ rust_error_at (const Location location, const char *fmt, ...)\n   va_end (ap);\n }\n \n+void\n+rust_error_at (const RichLocation &location, const ErrorCode code,\n+\t       const char *fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  rust_be_error_at (location, code, expand_message (fmt, ap));\n+  va_end (ap);\n+}\n+\n void\n rust_warning_at (const Location location, int opt, const char *fmt, ...)\n {"}, {"sha": "35a1727f6a3823ee9d8b3907a5d442469b01fa10", "filename": "gcc/rust/rust-diagnostics.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.h?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -50,6 +50,18 @@\n \n // clang-format off\n // simple location\n+\n+struct ErrorCode\n+{\n+  explicit ErrorCode (const char *str) : m_str (str)\n+  {\n+    gcc_assert (str);\n+    gcc_assert (str[0] == 'E');\n+  }\n+\n+  const char *m_str;\n+};\n+\n extern void\n rust_internal_error_at (const Location, const char *fmt, ...)\n   RUST_ATTRIBUTE_GCC_DIAG (2, 3)\n@@ -72,6 +84,9 @@ rust_inform (const Location, const char *fmt, ...)\n extern void\n rust_error_at (const RichLocation &, const char *fmt, ...)\n   RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n+extern void\n+rust_error_at (const RichLocation &, const ErrorCode, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (3, 4);\n // clang-format on\n \n // These interfaces provide a way for the front end to ask for\n@@ -97,6 +112,9 @@ rust_be_error_at (const Location, const std::string &errmsg);\n extern void\n rust_be_error_at (const RichLocation &, const std::string &errmsg);\n extern void\n+rust_be_error_at (const RichLocation &, const ErrorCode,\n+\t\t  const std::string &errmsg);\n+extern void\n rust_be_warning_at (const Location, int opt, const std::string &warningmsg);\n extern void\n rust_be_fatal_error (const Location, const std::string &errmsg)"}, {"sha": "98e2af7308d763ee844cdd264241fc7ca5327294", "filename": "gcc/rust/rust-gcc-diagnostics.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-gcc-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-gcc-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc-diagnostics.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-diagnostics.h\"\n \n #include \"options.h\"\n+#include \"diagnostic-metadata.h\"\n \n void\n rust_be_internal_error_at (const Location location, const std::string &errmsg)\n@@ -70,6 +71,38 @@ rust_be_error_at (const RichLocation &location, const std::string &errmsg)\n   error_at (&gcc_loc, \"%s\", errmsg.c_str ());\n }\n \n+class rust_error_code_rule : public diagnostic_metadata::rule\n+{\n+public:\n+  rust_error_code_rule (const ErrorCode code) : m_code (code) {}\n+\n+  char *make_description () const final override\n+  {\n+    return xstrdup (m_code.m_str);\n+  }\n+\n+  char *make_url () const final override\n+  {\n+    return concat (\"https://doc.rust-lang.org/error-index.html#\", m_code.m_str,\n+\t\t   NULL);\n+  }\n+\n+private:\n+  const ErrorCode m_code;\n+};\n+\n+void\n+rust_be_error_at (const RichLocation &location, const ErrorCode code,\n+\t\t  const std::string &errmsg)\n+{\n+  /* TODO: 'error_at' would like a non-'const' 'rich_location *'.  */\n+  rich_location &gcc_loc = const_cast<rich_location &> (location.get ());\n+  diagnostic_metadata m;\n+  rust_error_code_rule rule (code);\n+  m.add_rule (rule);\n+  error_meta (&gcc_loc, m, \"%s\", errmsg.c_str ());\n+}\n+\n void\n rust_be_get_quotechars (const char **open_qu, const char **close_qu)\n {"}, {"sha": "e5dc6dacc76fa22a8b3a0b5527577eca7fc10882", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 127, "deletions": 43, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -50,37 +50,10 @@\n #include \"rust-linemap.h\"\n #include \"rust-backend.h\"\n #include \"rust-object-export.h\"\n+#include \"rust-gcc.h\"\n \n #include \"backend/rust-tree.h\"\n-\n-// TODO: this will have to be significantly modified to work with Rust\n-\n-// Bvariable is a bit more complicated, because of zero-sized types.\n-// The GNU linker does not permit dynamic variables with zero size.\n-// When we see such a variable, we generate a version of the type with\n-// non-zero size.  However, when referring to the global variable, we\n-// want an expression of zero size; otherwise, if, say, the global\n-// variable is passed to a function, we will be passing a\n-// non-zero-sized value to a zero-sized value, which can lead to a\n-// miscompilation.\n-\n-class Bvariable\n-{\n-public:\n-  Bvariable (tree t) : t_ (t), orig_type_ (NULL) {}\n-\n-  Bvariable (tree t, tree orig_type) : t_ (t), orig_type_ (orig_type) {}\n-\n-  // Get the tree for use as an expression.\n-  tree get_tree (Location) const;\n-\n-  // Get the actual decl;\n-  tree get_decl () const { return this->t_; }\n-\n-private:\n-  tree t_;\n-  tree orig_type_;\n-};\n+#include \"backend/rust-builtins.h\"\n \n // Get the tree of a variable for use as an expression.  If this is a\n // zero-sized global, create an expression that refers to the decl but\n@@ -234,6 +207,10 @@ class Gcc_backend : public Backend\n   tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n \t\t\t\t\t tree left, tree right, Location);\n \n+  tree arithmetic_or_logical_expression_checked (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t\t tree left, tree right,\n+\t\t\t\t\t\t Location, Bvariable *receiver);\n+\n   tree comparison_expression (ComparisonOperator op, tree left, tree right,\n \t\t\t      Location);\n \n@@ -1408,25 +1385,26 @@ Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n   return new_tree;\n }\n \n-// Return an expression for the arithmetic or logical operation LEFT OP RIGHT.\n tree\n Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t       tree left_tree, tree right_tree,\n+\t\t\t\t\t       tree left, tree right,\n \t\t\t\t\t       Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+  if (left == error_mark_node || right == error_mark_node)\n     return error_mark_node;\n \n   /* We need to determine if we're doing floating point arithmetics of integer\n      arithmetics. */\n-  bool floating_point = is_floating_point (left_tree);\n+  bool floating_point = is_floating_point (left);\n+  auto ret = NULL_TREE;\n \n   /* For arithmetic or logical operators, the resulting type should be the same\n      as the lhs operand. */\n-  auto tree_type = TREE_TYPE (left_tree);\n+  auto tree_type = TREE_TYPE (left);\n   auto original_type = tree_type;\n+  auto loc = location.gcc_location ();\n   auto tree_code = operator_to_tree_code (op, floating_point);\n \n   /* For floating point operations we may need to extend the precision of type.\n@@ -1437,21 +1415,127 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n       extended_type = excess_precision_type (tree_type);\n       if (extended_type != NULL_TREE)\n \t{\n-\t  left_tree = convert (extended_type, left_tree);\n-\t  right_tree = convert (extended_type, right_tree);\n+\t  left = convert (extended_type, left);\n+\t  right = convert (extended_type, right);\n \t  tree_type = extended_type;\n \t}\n     }\n \n-  /* Construct a new tree and build an expression from it. */\n-  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n-\t\t\t\t   tree_type, left_tree, right_tree);\n-  TREE_CONSTANT (new_tree)\n-    = TREE_CONSTANT (left_tree) && TREE_CONSTANT (right_tree);\n+  ret = fold_build2_loc (loc, tree_code, tree_type, left, right);\n+  TREE_CONSTANT (ret) = TREE_CONSTANT (left) & TREE_CONSTANT (right);\n \n+  // TODO: How do we handle floating point?\n   if (floating_point && extended_type != NULL_TREE)\n-    new_tree = convert (original_type, new_tree);\n-  return new_tree;\n+    ret = convert (original_type, ret);\n+\n+  return ret;\n+}\n+\n+static bool\n+is_overflowing_expr (ArithmeticOrLogicalOperator op)\n+{\n+  switch (op)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+static std::pair<tree, tree>\n+fetch_overflow_builtins (ArithmeticOrLogicalOperator op)\n+{\n+  auto builtin_ctx = Rust::Compile::BuiltinsContext::get ();\n+\n+  auto builtin = NULL_TREE;\n+  auto abort = NULL_TREE;\n+\n+  switch (op)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+      builtin_ctx.lookup_simple_builtin (\"add_overflow\", &builtin);\n+      break;\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      builtin_ctx.lookup_simple_builtin (\"sub_overflow\", &builtin);\n+      break;\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      builtin_ctx.lookup_simple_builtin (\"mul_overflow\", &builtin);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    };\n+\n+  builtin_ctx.lookup_simple_builtin (\"abort\", &abort);\n+\n+  rust_assert (abort);\n+  rust_assert (builtin);\n+\n+  // FIXME: ARTHUR: This is really ugly. The builtin context should take care of\n+  // that\n+  TREE_SIDE_EFFECTS (abort) = 1;\n+  TREE_READONLY (abort) = 0;\n+\n+  // FIXME: ARTHUR: Same here. Remove these!\n+  TREE_SIDE_EFFECTS (builtin) = 1;\n+  TREE_READONLY (builtin) = 0;\n+\n+  return {abort, builtin};\n+}\n+\n+// Return an expression for the arithmetic or logical operation LEFT OP RIGHT\n+// with overflow checking when possible\n+tree\n+Gcc_backend::arithmetic_or_logical_expression_checked (\n+  ArithmeticOrLogicalOperator op, tree left, tree right, Location location,\n+  Bvariable *receiver_var)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  if (left == error_mark_node || right == error_mark_node)\n+    return error_mark_node;\n+\n+  auto loc = location.gcc_location ();\n+\n+  // FIXME: Add `if (!debug_mode)`\n+  // No overflow checks for floating point operations or divisions. In that\n+  // case, simply assign the result of the operation to the receiver variable\n+  if (is_floating_point (left) || !is_overflowing_expr (op))\n+    return assignment_statement (\n+      receiver_var->get_tree (location),\n+      arithmetic_or_logical_expression (op, left, right, location), location);\n+\n+  auto receiver = receiver_var->get_tree (location);\n+  TREE_ADDRESSABLE (receiver) = 1;\n+  auto result_ref = build_fold_addr_expr_loc (loc, receiver);\n+\n+  auto builtins = fetch_overflow_builtins (op);\n+  auto abort = builtins.first;\n+  auto builtin = builtins.second;\n+\n+  auto abort_call = build_call_expr_loc (loc, abort, 0);\n+\n+  // FIXME: ARTHUR: Is that needed?\n+  TREE_SIDE_EFFECTS (abort_call) = 1;\n+  TREE_READONLY (abort_call) = 0;\n+\n+  auto builtin_call\n+    = build_call_expr_loc (loc, builtin, 3, left, right, result_ref);\n+  auto overflow_check\n+    = build2_loc (loc, EQ_EXPR, boolean_type_node, builtin_call,\n+\t\t  boolean_constant_expression (true));\n+\n+  auto if_block = build3_loc (loc, COND_EXPR, void_type_node, overflow_check,\n+\t\t\t      abort_call, NULL_TREE);\n+\n+  // FIXME: ARTHUR: Needed?\n+  TREE_SIDE_EFFECTS (if_block) = 1;\n+  TREE_READONLY (if_block) = 0;\n+\n+  return if_block;\n }\n \n // Return an expression for the comparison operation LEFT OP RIGHT."}, {"sha": "085c16d0f3bb1a69be46c95e538a23c07547ccee", "filename": "gcc/rust/rust-gcc.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-gcc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Frust-gcc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.h?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -0,0 +1,58 @@\n+// rust-gcc.cc -- Rust frontend to gcc IR.\n+// Copyright (C) 2011-2022 Free Software Foundation, Inc.\n+// Contributed by Ian Lance Taylor, Google.\n+// forked from gccgo\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+\n+// This has to be included outside of extern \"C\", so we have to\n+// include it here before tree.h includes it later.\n+#include <gmp.h>\n+\n+#include \"tree.h\"\n+#include \"rust-location.h\"\n+\n+// TODO: this will have to be significantly modified to work with Rust\n+\n+// Bvariable is a bit more complicated, because of zero-sized types.\n+// The GNU linker does not permit dynamic variables with zero size.\n+// When we see such a variable, we generate a version of the type with\n+// non-zero size.  However, when referring to the global variable, we\n+// want an expression of zero size; otherwise, if, say, the global\n+// variable is passed to a function, we will be passing a\n+// non-zero-sized value to a zero-sized value, which can lead to a\n+// miscompilation.\n+\n+class Bvariable\n+{\n+public:\n+  Bvariable (tree t) : t_ (t), orig_type_ (NULL) {}\n+\n+  Bvariable (tree t, tree orig_type) : t_ (t), orig_type_ (orig_type) {}\n+\n+  // Get the tree for use as an expression.\n+  tree get_tree (Location) const;\n+\n+  // Get the actual decl;\n+  tree get_decl () const { return this->t_; }\n+\n+private:\n+  tree t_;\n+  tree orig_type_;\n+};"}, {"sha": "708880e0019f042fb504405cf475e3eddf4bdef3", "filename": "gcc/rust/typecheck/rust-casts.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Ftypecheck%2Frust-casts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Frust%2Ftypecheck%2Frust-casts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-casts.cc?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -283,7 +283,7 @@ TypeCastRules::emit_cast_error () const\n   RichLocation r (locus);\n   r.add_range (from.get_locus ());\n   r.add_range (to.get_locus ());\n-  rust_error_at (r, \"invalid cast %<%s%> to %<%s%>\",\n+  rust_error_at (r, ErrorCode (\"E0054\"), \"invalid cast %<%s%> to %<%s%>\",\n \t\t from.get_ty ()->get_name ().c_str (),\n \t\t to.get_ty ()->get_name ().c_str ());\n }"}, {"sha": "9652915fe1170e10add8b4b12234afd15efa256a", "filename": "gcc/testsuite/rust/compile/bad_as_bool_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_as_bool_char.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_as_bool_char.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_as_bool_char.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -5,13 +5,13 @@ pub fn main ()\n   let fone = t as f32;   // { dg-error \"invalid cast\" }\n   let fzero = f as f64;  // { dg-error \"invalid cast\" }\n \n-  let nb = 0u8 as bool;  // { dg-error \"invalid cast\" }\n+  let nb = 0u8 as bool;  // { dg-error \"invalid cast .u8. to .bool. \\\\\\[E0054\\\\\\]\" }\n   let nc = true as char; // { dg-error \"invalid cast\" }\n \n   let a = 'a';\n   let b = 'b';\n   let fa = a as f32;     // { dg-error \"invalid cast\" }\n-  let bb = b as bool;    // { dg-error \"invalid cast\" }\n+  let bb = b as bool;    // { dg-error \"invalid cast .char. to .bool. \\\\\\[E0054\\\\\\]\" }\n \n   let t32: u32 = 33;\n   let ab = t32 as char;  // { dg-error \"invalid cast\" }"}, {"sha": "5ba8f7a267b22fbbb44c880fbc2b282cbcb55faa", "filename": "gcc/testsuite/rust/compile/issue-1031.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1031.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1031.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1031.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -6,12 +6,10 @@ extern \"rust-intrinsic\" {\n #[lang = \"const_ptr\"]\n impl<T> *const T {\n     pub const unsafe fn offset(self, count: isize) -> *const T {\n-        // { dg-warning \"associated function is never used\" \"\" { target *-*-* } .-1 }\n         unsafe { offset(self, count) }\n     }\n \n     pub const unsafe fn add(self, count: usize) -> Self {\n-        // { dg-warning \"associated function is never used\" \"\" { target *-*-* } .-1 }\n         unsafe { self.offset(count as isize) }\n     }\n }"}, {"sha": "eb41af0a75b7bb7f1ccd76dd57f8503892c85a64", "filename": "gcc/testsuite/rust/compile/issue-1289.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1289.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1289.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1289.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -23,12 +23,10 @@ impl<T> *mut T {\n #[lang = \"const_ptr\"]\n impl<T> *const T {\n     pub const unsafe fn offset(self, count: isize) -> *mut T {\n-        // { dg-warning \"associated function is never used\" \"\" { target *-*-* } .-1 }\n         unsafe { intrinsics::offset(self, count) as *mut T }\n     }\n \n     pub const unsafe fn add(self, count: usize) -> Self {\n-        // { dg-warning \"associated function is never used\" \"\" { target *-*-* } .-1 }\n         unsafe { self.offset(count as isize) }\n     }\n }"}, {"sha": "00fa0ef8f11c74fa69465eb93bcfa6ec655b2462", "filename": "gcc/testsuite/rust/compile/privacy7.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy7.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -0,0 +1,9 @@\n+pub struct Foo(i8);\n+struct Bar(pub i8); // { dg-warning \"struct is never constructed: .Bar.\" }\n+pub struct Baz {\n+    a: i32, // { dg-warning \"field is never read: .a.\" }\n+    pub b: i32,\n+}\n+\n+pub fn foo() {}\n+fn bar() {} // { dg-warning \"function is never used: .bar.\" }"}, {"sha": "6e9c19b3fa4ad461ff68ec42f0c62679cc92a589", "filename": "gcc/testsuite/rust/compile/test_mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftest_mod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftest_mod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftest_mod.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -3,4 +3,3 @@\n //! foo bar baz cake pizza carbs\n \n pub struct Test(pub i32);\n-// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }"}, {"sha": "7e6cd916244462c640da4d16ab8e1404c17d2eda", "filename": "gcc/testsuite/rust/compile/torture/raw_identifiers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fraw_identifiers.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fraw_identifiers.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fraw_identifiers.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -1,3 +1,3 @@\n-pub fn square(num: i32) -> i32 { /* { dg-warning \"used\" } */\n+pub fn square(num: i32) -> i32 {\n     r#num * num\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3a15223631fff26701703c20afbc469786c01eb9", "filename": "gcc/testsuite/rust/compile/torture/raw_identifiers_keywords.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fraw_identifiers_keywords.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fraw_identifiers_keywords.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fraw_identifiers_keywords.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -1,3 +1,3 @@\n-pub fn plus(r#break: i32, r#unsafe: i32) -> i32 { /* { dg-warning \"used\" } */\n+pub fn plus(r#break: i32, r#unsafe: i32) -> i32 {\n     r#break + r#unsafe\n-}\n\\ No newline at end of file\n+}"}, {"sha": "4e02906a1958235dcdd94f085d121c6759cbb081", "filename": "gcc/testsuite/rust/debug/win64-abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fdebug%2Fwin64-abi.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fdebug%2Fwin64-abi.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fdebug%2Fwin64-abi.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -1,11 +1,11 @@\n // { dg-do compile { target { x86_64-*-* } } }\n // { dg-options \"-gdwarf-5 -dA -w -O1 -m64\" }\n-pub extern \"win64\" fn square(num: i32) -> i32 {\n-    num * num\n+pub extern \"win64\" fn id(num: i32) -> i32 {\n+    num\n }\n \n fn main() {\n     // MS ABI dictates that the first argument is ecx instead of edi from the sysv world\n-    // { dg-final { scan-assembler \"%ecx, %ecx\" } }\n-    square(1);\n+    // { dg-final { scan-assembler \"%ecx, %eax\" } }\n+    id(1);\n }"}, {"sha": "4fb6a29c8c1bf0a474ed3d3484a4be6b19dcdfc8", "filename": "gcc/testsuite/rust/execute/torture/macro-issue1426.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacro-issue1426.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacro-issue1426.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacro-issue1426.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -1,5 +1,3 @@\n-// { dg-additional-options -fdump-tree-ccp1-raw }\n-\n macro_rules! stmt {\n     ($s:stmt) => {\n         $s\n@@ -22,11 +20,10 @@ pub fn test() -> i32 {\n         let e = 5,\n         let f = b + c + d + e\n     );\n+\n     f\n-    // { dg-final { scan-tree-dump-times {gimple_return <14>} 1 ccp1 { target __OPTIMIZE__ } } }\n }\n \n-fn main() {\n-    let _ = test();\n+fn main() -> i32 {\n+    test() - 14\n }\n-", "previous_filename": "gcc/testsuite/rust/compile/torture/macro-issue1426.rs"}, {"sha": "57a0824ce0aa27343fe3ba1da7fae118ea8532ce", "filename": "gcc/testsuite/rust/execute/torture/overflow1.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foverflow1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb127f2aed32f21a37b31e8a5330defc6bfe5e7/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foverflow1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foverflow1.rs?ref=ebb127f2aed32f21a37b31e8a5330defc6bfe5e7", "patch": "@@ -0,0 +1,20 @@\n+// { dg-shouldfail \"i8 overflow\" }\n+// { dg-options \"-fdump-tree-original\" }\n+\n+fn five() -> i8 {\n+    5\n+}\n+\n+extern \"C\" {\n+    fn printf(fmt: *const i8, ...);\n+}\n+\n+fn main() {\n+    let a = 127i8;\n+    let b = five();\n+\n+    // { dg-final { scan-tree-dump ADD_OVERFLOW original } }\n+    let c = a + b;\n+\n+    unsafe { printf(\"%d\\n\\0\" as *const str as *const i8, c) }\n+}"}]}