{"sha": "db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI5NjJkMGFkNDUwMWYyZjY3M2ZjM2ZhZGQ0YWM1NzJlZjlhMTc3ZQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:04:30Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:04:30Z"}, "message": "[arm] Allow the summation result of signed add-with-overflow to be discarded.\n\nThis patch matches the signed add-with-overflow patterns when the\nsummation itself is dropped.  In this case we can use CMN (or CMP with\nsome immediates).  There are a small number of constants in thumb2\nwhere this can result in less dense code (as we lack 16-bit CMN with\nimmediate patterns).  To handle this we use peepholes to try these\nalternatives when either a scratch is available (0 <= i <= 7) or the\noriginal register is dead (0 <= i <= 255).  We don't use a scratch in\nthe pattern as if those conditions are not satisfied then the 32-bit\nform is preferable to forcing a reload.\n\n\t* config/arm/arm.md (addsi3_compareV_reg_nosum): New insn.\n\t(addsi3_compareV_imm_nosum): New insn.  Also add peephole2 patterns\n\tto transform this back into the summation version when that leads\n\tto smaller code.\n\nFrom-SVN: r277185", "tree": {"sha": "a05d2a014c9ad429bbdef51155c9ff57d92fab77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a05d2a014c9ad429bbdef51155c9ff57d92fab77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db962d0ad4501f2f673fc3fadd4ac572ef9a177e/comments", "author": null, "committer": null, "parents": [{"sha": "dbba8a1707ffe25375282e0a075e7dff8d41ef90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbba8a1707ffe25375282e0a075e7dff8d41ef90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbba8a1707ffe25375282e0a075e7dff8d41ef90"}], "stats": {"total": 85, "additions": 85, "deletions": 0}, "files": [{"sha": "4a5a139f7ffb6f9a26afb2e26cc3fa68c20b4646", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db962d0ad4501f2f673fc3fadd4ac572ef9a177e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db962d0ad4501f2f673fc3fadd4ac572ef9a177e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "patch": "@@ -1,3 +1,10 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.md (addsi3_compareV_reg_nosum): New insn.\n+\t(addsi3_compareV_imm_nosum): New insn.  Also add peephole2 patterns\n+\tto transform this back into the summation version when that leads\n+\tto smaller code.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (addv<mode>4): Delete."}, {"sha": "be002f7738258ad8f7c9abd6db02b1e4443af676", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db962d0ad4501f2f673fc3fadd4ac572ef9a177e/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db962d0ad4501f2f673fc3fadd4ac572ef9a177e/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "patch": "@@ -803,6 +803,21 @@\n    (set_attr \"type\" \"alus_sreg\")]\n )\n \n+(define_insn \"*addsi3_compareV_reg_nosum\"\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t  (plus:DI\n+\t    (sign_extend:DI (match_operand:SI 0 \"register_operand\" \"%l,r\"))\n+\t    (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"l,r\")))\n+\t  (sign_extend:DI (plus:SI (match_dup 0) (match_dup 1)))))]\n+  \"TARGET_32BIT\"\n+  \"cmn%?\\\\t%0, %1\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"arch\" \"t2,*\")\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"type\" \"alus_sreg\")]\n+)\n+\n (define_insn \"addsi3_compareV_imm\"\n   [(set (reg:CC_V CC_REGNUM)\n \t(compare:CC_V\n@@ -828,6 +843,69 @@\n    (set_attr \"type\" \"alus_imm\")]\n )\n \n+(define_insn \"addsi3_compareV_imm_nosum\"\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t  (plus:DI\n+\t    (sign_extend:DI\n+\t     (match_operand:SI 0 \"register_operand\" \"l,r,r\"))\n+\t    (match_operand 1 \"arm_addimm_operand\" \"Pw,I,L\"))\n+\t  (sign_extend:DI (plus:SI (match_dup 0) (match_dup 1)))))]\n+  \"TARGET_32BIT\n+   && INTVAL (operands[1]) == ARM_SIGN_EXTEND (INTVAL (operands[1]))\"\n+  \"@\n+   cmp%?\\\\t%0, #%n1\n+   cmn%?\\\\t%0, %1\n+   cmp%?\\\\t%0, #%n1\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"arch\" \"t2,*,*\")\n+   (set_attr \"length\" \"2,4,4\")\n+   (set_attr \"type\" \"alus_imm\")]\n+)\n+\n+;; We can handle more constants efficently if we can clobber either a scratch\n+;; or the other source operand.  We deliberately leave this late as in\n+;; high register pressure situations it's not worth forcing any reloads.\n+(define_peephole2\n+  [(match_scratch:SI 2 \"l\")\n+   (set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t  (plus:DI\n+\t    (sign_extend:DI\n+\t     (match_operand:SI 0 \"low_register_operand\"))\n+\t    (match_operand 1 \"const_int_operand\"))\n+\t  (sign_extend:DI (plus:SI (match_dup 0) (match_dup 1)))))]\n+  \"TARGET_THUMB2\n+   && satisfies_constraint_Pd (operands[1])\"\n+  [(parallel[\n+    (set (reg:CC_V CC_REGNUM)\n+\t (compare:CC_V\n+\t  (plus:DI (sign_extend:DI (match_dup 0))\n+\t\t   (sign_extend:DI (match_dup 1)))\n+\t  (sign_extend:DI (plus:SI (match_dup 0) (match_dup 1)))))\n+    (set (match_dup 2) (plus:SI (match_dup 0) (match_dup 1)))])]\n+)\n+\n+(define_peephole2\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t  (plus:DI\n+\t    (sign_extend:DI\n+\t     (match_operand:SI 0 \"low_register_operand\"))\n+\t    (match_operand 1 \"const_int_operand\"))\n+\t  (sign_extend:DI (plus:SI (match_dup 0) (match_dup 1)))))]\n+  \"TARGET_THUMB2\n+   && dead_or_set_p (peep2_next_insn (0), operands[0])\n+   && satisfies_constraint_Py (operands[1])\"\n+  [(parallel[\n+    (set (reg:CC_V CC_REGNUM)\n+\t (compare:CC_V\n+\t  (plus:DI (sign_extend:DI (match_dup 0))\n+\t\t   (sign_extend:DI (match_dup 1)))\n+\t  (sign_extend:DI (plus:SI (match_dup 0) (match_dup 1)))))\n+    (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))])]\n+)\n+\n (define_insn \"addsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV"}]}