{"sha": "208fbc779c713715da1465a1a2c6710c084c9b05", "node_id": "C_kwDOANBUbNoAKDIwOGZiYzc3OWM3MTM3MTVkYTE0NjVhMWEyYzY3MTBjMDg0YzliMDU", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-07-06T17:45:28Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-07-06T17:51:38Z"}, "message": "d: Merge upstream dmd 56589f0f4, druntime 651389b5, phobos 1516ecad9.\n\nD front-end changes:\n\n    - Import latest bug fixes to mainline.\n\nD runtime changes:\n\n    - Import latest bug fixes to mainline.\n\nPhobos changes:\n\n    - Import latest bug fixes to mainline.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 56589f0f4.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 651389b5.\n\t* src/MERGE: Merge upstream phobos 1516ecad9.", "tree": {"sha": "f8698626e4c2fd65701eddf36918ebf4f2cc6763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8698626e4c2fd65701eddf36918ebf4f2cc6763"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/208fbc779c713715da1465a1a2c6710c084c9b05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208fbc779c713715da1465a1a2c6710c084c9b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/208fbc779c713715da1465a1a2c6710c084c9b05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208fbc779c713715da1465a1a2c6710c084c9b05/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c785204735b2cace9a676969de0967105a06438d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c785204735b2cace9a676969de0967105a06438d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c785204735b2cace9a676969de0967105a06438d"}], "stats": {"total": 1604, "additions": 1115, "deletions": 489}, "files": [{"sha": "8324c1cc88c280a523337b2549760aaceb9fa908", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1,4 +1,4 @@\n-529110f66d7d301d62d943a4e4482edaddeb46ea\n+56589f0f4d724c1c8022c57509a243f16a04228a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "a3bebb7365a0a94d346e29b79246e4ad6c965b87", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 107, "deletions": 11, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1619,6 +1619,12 @@ final class CParser(AST) : Parser!AST\n             return;\n         }\n \n+        if (token.value == TOK.__pragma)\n+        {\n+            uupragmaDirective(scanloc);\n+            return;\n+        }\n+\n         if (token.value == TOK._import) // import declaration extension\n         {\n             auto a = parseImport();\n@@ -2322,6 +2328,14 @@ final class CParser(AST) : Parser!AST\n                     break;\n                 }\n \n+                case TOK.__declspec:\n+                {\n+                    /* Microsoft extension\n+                     */\n+                    cparseDeclspec(specifier);\n+                    break;\n+                }\n+\n                 case TOK.typeof_:\n                 {\n                     nextToken();\n@@ -3042,9 +3056,13 @@ final class CParser(AST) : Parser!AST\n      * extended-decl-modifier:\n      *    dllimport\n      *    dllexport\n+     *    noreturn\n+     * Params:\n+     *  specifier = filled in with the attribute(s)\n      */\n-    private void cparseDeclspec()\n+    private void cparseDeclspec(ref Specifier specifier)\n     {\n+        //printf(\"cparseDeclspec()\\n\");\n         /* Check for dllexport, dllimport\n          * Ignore the rest\n          */\n@@ -3073,6 +3091,11 @@ final class CParser(AST) : Parser!AST\n                     dllexport = true;\n                     nextToken();\n                 }\n+                else if (token.ident == Id.noreturn)\n+                {\n+                    specifier.noreturn = true;\n+                    nextToken();\n+                }\n                 else\n                 {\n                     nextToken();\n@@ -3083,8 +3106,8 @@ final class CParser(AST) : Parser!AST\n             else\n             {\n                 error(\"extended-decl-modifier expected\");\n+                break;\n             }\n-            break;\n         }\n     }\n \n@@ -4789,6 +4812,8 @@ final class CParser(AST) : Parser!AST\n         // type function itself.\n         if (auto tf = t.isTypeFunction())\n             tf.next = tf.next.addSTC(STC.const_);\n+        else if (auto tt = t.isTypeTag())\n+            tt.mod |= MODFlags.const_;\n         else\n             t = t.addSTC(STC.const_);\n         return t;\n@@ -4961,10 +4986,40 @@ final class CParser(AST) : Parser!AST\n                 return true;\n             }\n         }\n-        error(\"C preprocessor directive `#%s` is not supported\", n.toChars());\n+        if (n.ident != Id.undef)\n+            error(\"C preprocessor directive `#%s` is not supported\", n.toChars());\n         return false;\n     }\n \n+    /*********************************************\n+     * VC __pragma\n+     * https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=msvc-170\n+     * Scanner is on the `__pragma`\n+     * Params:\n+     *  startloc = location to use for error messages\n+     */\n+    private void uupragmaDirective(const ref Loc startloc)\n+    {\n+        const loc = startloc;\n+        nextToken();\n+        if (token.value != TOK.leftParenthesis)\n+        {\n+            error(loc, \"left parenthesis expected to follow `__pragma`\");\n+            return;\n+        }\n+        nextToken();\n+        if (token.value == TOK.identifier && token.ident == Id.pack)\n+            pragmaPack(startloc, false);\n+        else\n+            error(loc, \"unrecognized __pragma\");\n+        if (token.value != TOK.rightParenthesis)\n+        {\n+            error(loc, \"right parenthesis expected to close `__pragma(...)`\");\n+            return;\n+        }\n+        nextToken();\n+    }\n+\n     /*********************************************\n      * C11 6.10.6 Pragma directive\n      * # pragma pp-tokens(opt) new-line\n@@ -4977,7 +5032,7 @@ final class CParser(AST) : Parser!AST\n         Token n;\n         scan(&n);\n         if (n.value == TOK.identifier && n.ident == Id.pack)\n-            return pragmaPack(loc);\n+            return pragmaPack(loc, true);\n         if (n.value != TOK.endOfLine)\n             skipToNextLine();\n     }\n@@ -4989,10 +5044,27 @@ final class CParser(AST) : Parser!AST\n      * Scanner is on the `pack`\n      * Params:\n      *  startloc = location to use for error messages\n+     *  useScan = use scan() to retrieve next token, instead of nextToken()\n      */\n-    private void pragmaPack(const ref Loc startloc)\n+    private void pragmaPack(const ref Loc startloc, bool useScan)\n     {\n         const loc = startloc;\n+\n+        /* Pull tokens from scan() or nextToken()\n+         */\n+        void scan(Token* t)\n+        {\n+            if (useScan)\n+            {\n+                Lexer.scan(t);\n+            }\n+            else\n+            {\n+                nextToken();\n+                *t = token;\n+            }\n+        }\n+\n         Token n;\n         scan(&n);\n         if (n.value != TOK.leftParenthesis)\n@@ -5155,13 +5227,35 @@ final class CParser(AST) : Parser!AST\n     {\n         if (!defines || defines.length < 10)  // minimum length of a #define line\n             return;\n-        const length = defines.length;\n-        defines.writeByte(0);\n-        auto slice = defines.peekChars()[0 .. length];\n+        OutBuffer* buf = defines;\n+        defines = null;                 // prevent skipToNextLine() and parseSpecialTokenSequence()\n+                                        // from appending to slice[]\n+        const length = buf.length;\n+        buf.writeByte(0);\n+        auto slice = buf.peekChars()[0 .. length];\n         resetDefineLines(slice);                // reset lexer\n \n         const(char)* endp = &slice[length - 7];\n \n+        size_t[void*] defineTab;    // hash table of #define's turned into Symbol's\n+                                    // indexed by Identifier, returns index into symbols[]\n+                                    // The memory for this is leaked\n+\n+        void addVar(AST.VarDeclaration v)\n+        {\n+            /* If it's already defined, replace the earlier\n+             * definition\n+             */\n+            if (size_t* pd = cast(void*)v.ident in defineTab)\n+            {\n+                //printf(\"replacing %s\\n\", v.toChars());\n+                (*symbols)[*pd] = v;\n+                return;\n+            }\n+            defineTab[cast(void*)v.ident] = symbols.length;\n+            symbols.push(v);\n+        }\n+\n         Token n;\n \n         while (p < endp)\n@@ -5200,7 +5294,7 @@ final class CParser(AST) : Parser!AST\n                                  */\n                                 AST.Expression e = new AST.IntegerExp(scanloc, intvalue, t);\n                                 auto v = new AST.VarDeclaration(scanloc, t, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n-                                symbols.push(v);\n+                                addVar(v);\n                                 nextDefineLine();\n                                 continue;\n                             }\n@@ -5223,7 +5317,7 @@ final class CParser(AST) : Parser!AST\n                                  */\n                                 AST.Expression e = new AST.RealExp(scanloc, floatvalue, t);\n                                 auto v = new AST.VarDeclaration(scanloc, t, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n-                                symbols.push(v);\n+                                addVar(v);\n                                 nextDefineLine();\n                                 continue;\n                             }\n@@ -5241,7 +5335,7 @@ final class CParser(AST) : Parser!AST\n                                  */\n                                 AST.Expression e = new AST.StringExp(scanloc, str[0 .. len], len, 1, postfix);\n                                 auto v = new AST.VarDeclaration(scanloc, null, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n-                                symbols.push(v);\n+                                addVar(v);\n                                 nextDefineLine();\n                                 continue;\n                             }\n@@ -5263,6 +5357,8 @@ final class CParser(AST) : Parser!AST\n             }\n             nextDefineLine();\n         }\n+\n+        defines = buf;\n     }\n \n     //}"}, {"sha": "0be938ffdf594120b930366b0ad211e5c857ae2f", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -680,7 +680,7 @@ extern (C++) final class Module : Package\n             FileName.equalsExt(srcfile.toString(), c_ext) &&\n             FileName.exists(srcfile.toString()))\n         {\n-            filename = global.preprocess(srcfile, loc, global.params.cppswitches, ifile, &defines);  // run C preprocessor\n+            filename = global.preprocess(srcfile, loc, ifile, &defines);  // run C preprocessor\n         }\n \n         if (auto result = global.fileManager.lookup(filename))"}, {"sha": "35ba5fa83ed28133594cedda0e7df3f846a1bdfa", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -11689,6 +11689,14 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         case Terror:\n             return setError();\n \n+        case Tarray, Tsarray:\n+            result = exp.incompatibleTypes();\n+            exp.errorSupplemental(\"`in` is only allowed on associative arrays\");\n+            const(char)* slice = (t2b.ty == Tsarray) ? \"[]\" : \"\";\n+            exp.errorSupplemental(\"perhaps use `std.algorithm.find(%s, %s%s)` instead\",\n+                exp.e1.toChars(), exp.e2.toChars(), slice);\n+            return;\n+\n         default:\n             result = exp.incompatibleTypes();\n             return;"}, {"sha": "05886f96f44e27496dbf64c64a036752fe782bf7", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -299,7 +299,7 @@ extern (C++) struct Global\n \n     enum recursionLimit = 500; /// number of recursive template expansions before abort\n \n-    extern (C++) FileName function(FileName, ref const Loc, ref Array!(const(char)*) cppswitches, out bool, OutBuffer* defines) preprocess;\n+    extern (C++) FileName function(FileName, ref const Loc, out bool, OutBuffer*) preprocess;\n \n   nothrow:\n "}, {"sha": "41472b2734837967a5ba1323bb5a01e2b4c52ea0", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -272,7 +272,7 @@ struct Global\n \n     FileManager* fileManager;\n \n-    FileName (*preprocess)(FileName, const Loc&, Array<const char *>& cppswitches, bool&, OutBuffer&);\n+    FileName (*preprocess)(FileName, const Loc&, bool&, OutBuffer&);\n \n     /* Start gagging. Return the current number of gagged errors\n      */"}, {"sha": "680d9c82a9655d910cf2647f7d44f2dd5bdd0c21", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1449,7 +1449,20 @@ public:\n             buf.writestring(\" = \");\n             if (stcToBuffer(buf, d.storage_class))\n                 buf.writeByte(' ');\n-            d.aliassym.accept(this);\n+            /*\n+                https://issues.dlang.org/show_bug.cgi?id=23223\n+                https://issues.dlang.org/show_bug.cgi?id=23222\n+                This special case (initially just for modules) avoids some segfaults\n+                and nicer -vcg-ast output.\n+            */\n+            if (d.aliassym.isModule())\n+            {\n+                buf.writestring(d.aliassym.ident.toString());\n+            }\n+            else\n+            {\n+                d.aliassym.accept(this);\n+            }\n         }\n         else if (d.type.ty == Tfunction)\n         {\n@@ -3916,6 +3929,8 @@ private void typeToBufferx(Type t, OutBuffer* buf, HdrGenState* hgs)\n \n     void visitTag(TypeTag t)\n     {\n+        if (t.mod & MODFlags.const_)\n+            buf.writestring(\"const \");\n         buf.writestring(Token.toChars(t.tok));\n         buf.writeByte(' ');\n         if (t.id)"}, {"sha": "860cfa9d611bd6402822fac34f64bafd1c1504e7", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -4437,15 +4437,7 @@ extern (C++) final class TypeFunction : TypeNext\n             // Check escaping through `this`\n             if (tthis && tthis.isMutable())\n             {\n-                auto tb = tthis.toBasetype();\n-                AggregateDeclaration ad;\n-                if (auto tc = tb.isTypeClass())\n-                    ad = tc.sym;\n-                else if (auto ts = tb.isTypeStruct())\n-                    ad = ts.sym;\n-                else\n-                    assert(0);\n-                foreach (VarDeclaration v; ad.fields)\n+                foreach (VarDeclaration v; isAggregate(tthis).fields)\n                 {\n                     if (v.hasPointers())\n                         return stc;\n@@ -6655,16 +6647,18 @@ extern (C++) final class TypeTag : Type\n     Type resolved;          /// type after semantic() in case there are more others\n                             /// pointing to this instance, which can happen with\n                             ///   struct S { int a; } s1, *s2;\n+    MOD mod;                /// modifiers to apply after type is resolved (only MODFlags.const_ at the moment)\n \n     extern (D) this(const ref Loc loc, TOK tok, Identifier id, Type base, Dsymbols* members)\n     {\n-        //printf(\"TypeTag %p\\n\", this);\n+        //printf(\"TypeTag ctor %s %p\\n\", id ? id.toChars() : \"null\".ptr, this);\n         super(Ttag);\n         this.loc = loc;\n         this.tok = tok;\n         this.id = id;\n         this.base = base;\n         this.members = members;\n+        this.mod = 0;\n     }\n \n     override const(char)* kind() const\n@@ -6674,6 +6668,7 @@ extern (C++) final class TypeTag : Type\n \n     override TypeTag syntaxCopy()\n     {\n+        //printf(\"TypeTag syntaxCopy()\\n\");\n         // No semantic analysis done, no need to copy\n         return this;\n     }"}, {"sha": "86abedf76605b2e60244c1280e6c5536612f5bdd", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -273,6 +273,7 @@ enum TOK : ubyte\n     __cdecl,\n     __declspec,\n     __stdcall,\n+    __pragma,\n     __attribute__,\n }\n \n@@ -582,6 +583,7 @@ private immutable TOK[] keywords =\n     TOK.__cdecl,\n     TOK.__declspec,\n     TOK.__stdcall,\n+    TOK.__pragma,\n     TOK.__attribute__,\n ];\n \n@@ -610,7 +612,7 @@ static immutable TOK[TOK.max + 1] Ckeywords =\n                        restrict, return_, int16, signed, sizeof_, static_, struct_, switch_, typedef_,\n                        union_, unsigned, void_, volatile, while_, asm_, typeof_,\n                        _Alignas, _Alignof, _Atomic, _Bool, _Complex, _Generic, _Imaginary, _Noreturn,\n-                       _Static_assert, _Thread_local, _import, __cdecl, __declspec, __stdcall, __attribute__ ];\n+                       _Static_assert, _Thread_local, _import, __cdecl, __declspec, __stdcall, __pragma, __attribute__ ];\n \n         foreach (kw; Ckwds)\n             tab[kw] = cast(TOK) kw;\n@@ -880,6 +882,7 @@ extern (C++) struct Token\n         TOK.__cdecl        : \"__cdecl\",\n         TOK.__declspec     : \"__declspec\",\n         TOK.__stdcall      : \"__stdcall\",\n+        TOK.__pragma       : \"__pragma\",\n         TOK.__attribute__  : \"__attribute__\",\n     ];\n "}, {"sha": "35fd68b0ba5f286318d973cb189cab4c1daeb016", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -282,6 +282,7 @@ enum class TOK : unsigned char\n     cdecl_,\n     declspec,\n     stdcall,\n+    pragma,\n     attribute__,\n \n     MAX,"}, {"sha": "0469b9273169cfd688636806cb8f781cb307b698", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1778,8 +1778,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n         {\n             /* struct S s, *p;\n              */\n-            //printf(\"already resolved\\n\");\n-            return mtype.resolved;\n+            return mtype.resolved.addSTC(mtype.mod);\n         }\n \n         /* Find the current scope by skipping tag scopes.\n@@ -1850,7 +1849,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n         {\n             mtype.id = Identifier.generateId(\"__tag\"[]);\n             declareTag();\n-            return mtype.resolved;\n+            return mtype.resolved.addSTC(mtype.mod);\n         }\n \n         /* look for pre-existing declaration\n@@ -1863,7 +1862,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             if (mtype.tok == TOK.enum_ && !mtype.members)\n                 .error(mtype.loc, \"`enum %s` is incomplete without members\", mtype.id.toChars()); // C11 6.7.2.3-3\n             declareTag();\n-            return mtype.resolved;\n+            return mtype.resolved.addSTC(mtype.mod);\n         }\n \n         /* A redeclaration only happens if both declarations are in\n@@ -1963,7 +1962,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 declareTag();\n             }\n         }\n-        return mtype.resolved;\n+        return mtype.resolved.addSTC(mtype.mod);\n     }\n \n     switch (type.ty)"}, {"sha": "23ec46f2905596b12f1104bfee15517341e439cc", "filename": "gcc/testsuite/gdc.test/compilable/test3004.d", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest3004.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest3004.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest3004.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1,15 +1,13 @@\n // https://issues.dlang.org/show_bug.cgi?id=3004\n /*\n REQUIRED_ARGS: -ignore -v\n-TRANSFORM_OUTPUT: remove_lines(\"^(predefs|binary|version|config|DFLAG|parse|import|semantic|entry|library|function  object|\\s*$)\")\n+TRANSFORM_OUTPUT: remove_lines(\"^(predefs|binary|version|config|DFLAG|parse|import|semantic|entry|library|function  object|function  core|\\s*$)\")\n TEST_OUTPUT:\n ---\n pragma    GNU_attribute (__error)\n pragma    GNU_attribute (__error)\n code      test3004\n function  test3004.test\n-function  core.internal.array.appending._d_arrayappendcTXImpl!(char[], char)._d_arrayappendcTX\n-function  core.internal.array.utils._d_HookTraceImpl!(char[], _d_arrayappendcTX, \"Cannot append to array if compiling without support for runtime type information!\")._d_HookTraceImpl\n ---\n */\n "}, {"sha": "4a7b8bc33c489e3ef9d88a451ef83500caead81c", "filename": "gcc/testsuite/gdc.test/compilable/vcg-ast.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvcg-ast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvcg-ast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvcg-ast.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -7,6 +7,9 @@ TEST_OUTPUT_FILE: extra-files/vcg-ast.d.cg\n \n module vcg;\n \n+alias xyz = __traits(parent, {});\n+alias named = vcg;\n+\n template Seq(A...)\n {\n     alias Seq = A;"}, {"sha": "f869b32856cc86ccc1f8d46ea9e69dd6cfd71cd3", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag_in_array.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_in_array.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_in_array.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_in_array.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -0,0 +1,20 @@\n+/**\n+TEST_OUTPUT:\n+---\n+fail_compilation/diag_in_array.d(17): Error: incompatible types for `(3) in (a)`: `int` and `int[4]`\n+fail_compilation/diag_in_array.d(17):        `in` is only allowed on associative arrays\n+fail_compilation/diag_in_array.d(17):        perhaps use `std.algorithm.find(3, a[])` instead\n+fail_compilation/diag_in_array.d(19): Error: incompatible types for `(\"s\") in (b)`: `string` and `string[]`\n+fail_compilation/diag_in_array.d(19):        `in` is only allowed on associative arrays\n+fail_compilation/diag_in_array.d(19):        perhaps use `std.algorithm.find(\"s\", b)` instead\n+---\n+*/\n+\n+void main()\n+{\n+    int[4] a;\n+    string[] b;\n+    if (3 in a)\n+        return;\n+    auto c = \"s\" in b;\n+}"}, {"sha": "6e25a9d6f92f62606e0f5439d1f0857b0626d700", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1,4 +1,4 @@\n-148608b7935c3f9a4ea3a26f74cb90cd07efc91c\n+651389b52243dcadb338dd0c14dd27e7850cda8d\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "ed6251f758b156eb4f750c758f8882a6d93c6401", "filename": "libphobos/libdruntime/core/internal/parseoptions.d", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fparseoptions.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fparseoptions.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fparseoptions.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -168,6 +168,7 @@ inout(char)[] find(alias pred)(inout(char)[] str)\n }\n \n bool parse(T : size_t)(const(char)[] optname, ref inout(char)[] str, ref T res, const(char)[] errName, bool mayHaveSuffix = false)\n+if (is(T == size_t))\n in { assert(str.length); }\n do\n {\n@@ -242,6 +243,22 @@ do\n     if (v > res.max)\n         return parseError(\"a number \" ~ T.max.stringof ~ \" or below\", optname, str[0 .. i], errName);\n     str = str[i .. $];\n+    res = v;\n+    return true;\n+}\n+\n+bool parse(T : size_t)(const(char)[] optname, ref inout(char)[] str, ref T res, const(char)[] errName, bool mayHaveSuffix = false)\n+if (!is(T == size_t))\n+in { assert(str.length); }\n+do\n+{\n+    const oldStr = str;\n+    size_t v;\n+    if (!parse!size_t(optname, str, v, errName, mayHaveSuffix))\n+        return false;\n+\n+    if (v > res.max)\n+        return parseError(\"a number \" ~ T.max.stringof ~ \" or below\", optname, oldStr[0 .. $-str.length], errName);\n     res = cast(T) v;\n     return true;\n }"}, {"sha": "415430c80e11e92cef828c1ace1f764bd5f5511a", "filename": "libphobos/libdruntime/core/thread/osthread.d", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -2130,6 +2130,15 @@ extern (C) void thread_init() @nogc nothrow\n     }\n     else version (Posix)\n     {\n+        version (OpenBSD)\n+        {\n+            // OpenBSD does not support SIGRTMIN or SIGRTMAX\n+            // Use SIGUSR1 for SIGRTMIN, SIGUSR2 for SIGRTMIN + 1\n+            // And use 32 for SIGRTMAX (32 is the max signal number on OpenBSD)\n+            enum SIGRTMIN = SIGUSR1;\n+            enum SIGRTMAX = 32;\n+        }\n+\n         if ( suspendSignalNumber == 0 )\n         {\n             suspendSignalNumber = SIGRTMIN;"}, {"sha": "5d5ddb34740b691e8687687d61b50a1090fadb6d", "filename": "libphobos/libdruntime/rt/aApply.d", "status": "modified", "additions": 81, "deletions": 27, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2FaApply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2FaApply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2FaApply.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1,7 +1,5 @@\n /**\n- * This code handles decoding UTF strings for foreach loops.  There are 6\n- * combinations of conversions between char, wchar, and dchar, and 2 of each\n- * of those.\n+ * This code handles decoding UTF strings for foreach loops.\n  *\n  * Copyright: Copyright Digital Mars 2004 - 2010.\n  * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n@@ -15,9 +13,64 @@ import core.internal.utf : decode, toUTF8;\n /**********************************************/\n /* 1 argument versions */\n \n-// dg is D, but _aApplycd() is C\n-extern (D) alias int delegate(void *) dg_t;\n+/**\n+Delegate type corresponding to transformed loop body\n+\n+The parameter is a pointer to the current `char`, `wchar` or `dchar`\n+\n+Returns: non-zero when a `break` statement is hit\n+*/\n+extern (D) alias dg_t = int delegate(void* c);\n+\n+// Note: dg is extern(D), but _aApplycd() is extern(C)\n+\n+/**\n+Loop over a string while changing the UTF encoding\n+\n+There are 6 combinations of conversions between `char`, `wchar`, and `dchar`,\n+and 2 of each of those.\n+\n+The naming convention is as follows:\n+\n+_aApply{c,d,w}{c,d,w}{1,2}\n \n+The first letter corresponds to the input string encoding, and the second letter corresponds to the target character type.\n+\n+- c = `char`\n+- w = `wchar`\n+- d = `dchar`\n+\n+The `1` variant only produces the character, the `2` variant also produces a loop index.\n+\n+Examples:\n+---\n+void main()\n+{\n+    string str;\n+    wtring wstr;\n+    dstring dstr;\n+\n+    foreach (dchar c; str) {}\n+    // _aApplycd1\n+\n+    foreach (wchar c; dstr) {}\n+    // _aApplydw1\n+\n+    foreach (i, wchar c; str) {}\n+    // _aApplycw2\n+\n+    foreach (wchar w; wstr) {}\n+    // no conversion\n+}\n+---\n+\n+Params:\n+    aa = input string\n+    dg = foreach body transformed into a delegate, similar to `opApply`\n+\n+Returns:\n+    non-zero when the loop was exited through a `break`\n+*/\n extern (C) int _aApplycd1(in char[] aa, dg_t dg)\n {\n     int result;\n@@ -78,8 +131,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplywd1(in wchar[] aa, dg_t dg)\n {\n     int result;\n@@ -140,8 +192,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplycw1(in char[] aa, dg_t dg)\n {\n     int result;\n@@ -215,8 +266,7 @@ unittest\n     assert(i == 5);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplywc1(in wchar[] aa, dg_t dg)\n {\n     int result;\n@@ -296,8 +346,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplydc1(in dchar[] aa, dg_t dg)\n {\n     int result;\n@@ -373,8 +422,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplydw1(in dchar[] aa, dg_t dg)\n {\n     int result;\n@@ -446,9 +494,20 @@ unittest\n /****************************************************************************/\n /* 2 argument versions */\n \n-// dg is D, but _aApplycd2() is C\n-extern (D) alias int delegate(void *, void *) dg2_t;\n+/**\n+Delegate type corresponding to transformed loop body\n+\n+Parameters are pointers to a `size_t` loop index, and the current `char`, `wchar` or `dchar`.\n \n+Returns: non-zero when a `break` statement is hit\n+*/\n+extern (D) alias dg2_t = int delegate(void* i, void* c);\n+\n+// Note: dg is extern(D), but _aApplycd2() is extern(C)\n+\n+/**\n+Variants of _aApplyXXX that include a loop index.\n+*/\n extern (C) int _aApplycd2(in char[] aa, dg2_t dg)\n {\n     int result;\n@@ -516,8 +575,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplywd2(in wchar[] aa, dg2_t dg)\n {\n     int result;\n@@ -585,8 +643,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplycw2(in char[] aa, dg2_t dg)\n {\n     int result;\n@@ -665,8 +722,7 @@ unittest\n     assert(i == 5);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplywc2(in wchar[] aa, dg2_t dg)\n {\n     int result;\n@@ -751,8 +807,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplydc2(in dchar[] aa, dg2_t dg)\n {\n     int result;\n@@ -832,8 +887,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplydw2(in dchar[] aa, dg2_t dg)\n {   int result;\n "}, {"sha": "ce3bb9eaf705c0f264c497f213559a15309fb04d", "filename": "libphobos/libdruntime/rt/aApplyR.d", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2FaApplyR.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2FaApplyR.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2FaApplyR.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1,7 +1,5 @@\n /**\n- * This code handles decoding UTF strings for foreach_reverse loops.  There are\n- * 6 combinations of conversions between char, wchar, and dchar, and 2 of each\n- * of those.\n+ * This code handles decoding UTF strings for `foreach_reverse` loops.\n  *\n  * Copyright: Copyright Digital Mars 2004 - 2010.\n  * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n@@ -15,9 +13,27 @@ import core.internal.utf;\n /**********************************************/\n /* 1 argument versions */\n \n-// dg is D, but _aApplyRcd() is C\n-extern (D) alias int delegate(void *) dg_t;\n+// Note: dg is extern(D), but _aApplyRcd() is extern(C)\n \n+/**\n+Delegate type corresponding to transformed loop body\n+\n+The parameter is a pointer to the current `char`, `wchar` or `dchar`\n+\n+Returns: non-zero when a `break` statement is hit\n+*/\n+extern (D) alias dg_t = int delegate(void* c);\n+\n+/**\n+Same as `_aApplyXXX` functions, but for `foreach_reverse`\n+\n+Params:\n+    aa = input string\n+    dg = foreach body transformed into a delegate, similar to `opApply`\n+\n+Returns:\n+    non-zero when the loop was exited through a `break`\n+*/\n extern (C) int _aApplyRcd1(in char[] aa, dg_t dg)\n {   int result;\n \n@@ -90,8 +106,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRwd1(in wchar[] aa, dg_t dg)\n {   int result;\n \n@@ -154,8 +169,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRcw1(in char[] aa, dg_t dg)\n {   int result;\n \n@@ -241,8 +255,7 @@ unittest\n     assert(i == 5);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRwc1(in wchar[] aa, dg_t dg)\n {   int result;\n \n@@ -326,8 +339,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRdc1(in dchar[] aa, dg_t dg)\n {   int result;\n \n@@ -405,8 +417,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRdw1(in dchar[] aa, dg_t dg)\n {   int result;\n \n@@ -477,9 +488,20 @@ unittest\n /****************************************************************************/\n /* 2 argument versions */\n \n-// dg is D, but _aApplyRcd2() is C\n-extern (D) alias int delegate(void *, void *) dg2_t;\n+/**\n+Delegate type corresponding to transformed loop body\n+\n+Parameters are pointers to a `size_t` loop index, and the current `char`, `wchar` or `dchar`.\n \n+Returns: non-zero when a `break` statement is hit\n+*/\n+extern (D) alias dg2_t = int delegate(void* i, void* c);\n+\n+// Note: dg is extern(D), but _aApplyRcd2() is extern(C)\n+\n+/**\n+Variants of _aApplyRXXX that include a loop index.\n+*/\n extern (C) int _aApplyRcd2(in char[] aa, dg2_t dg)\n {   int result;\n     size_t i;\n@@ -555,8 +577,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRwd2(in wchar[] aa, dg2_t dg)\n {   int result;\n \n@@ -621,8 +642,7 @@ unittest\n     assert(i == 4);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRcw2(in char[] aa, dg2_t dg)\n {   int result;\n \n@@ -710,8 +730,7 @@ unittest\n     assert(i == 5);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRwc2(in wchar[] aa, dg2_t dg)\n {   int result;\n \n@@ -797,8 +816,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRdc2(in dchar[] aa, dg2_t dg)\n {   int result;\n \n@@ -877,8 +895,7 @@ unittest\n     assert(i == 9);\n }\n \n-/*****************************/\n-\n+/// ditto\n extern (C) int _aApplyRdw2(in dchar[] aa, dg2_t dg)\n {   int result;\n "}, {"sha": "f264b014789b93951502a71f321c7b1bc0201a96", "filename": "libphobos/libdruntime/rt/aaA.d", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2FaaA.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2FaaA.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2FaaA.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -50,7 +50,7 @@ struct AA\n private struct Impl\n {\n private:\n-    this(scope const TypeInfo_AssociativeArray ti, size_t sz = INIT_NUM_BUCKETS)\n+    this(scope const TypeInfo_AssociativeArray ti, size_t sz = INIT_NUM_BUCKETS) nothrow\n     {\n         keysz = cast(uint) ti.key.tsize;\n         valsz = cast(uint) ti.value.tsize;\n@@ -125,7 +125,7 @@ private:\n         }\n     }\n \n-    void grow(scope const TypeInfo keyti)\n+    void grow(scope const TypeInfo keyti) pure nothrow\n     {\n         // If there are so many deleted entries, that growing would push us\n         // below the shrink threshold, we just purge deleted entries instead.\n@@ -135,7 +135,7 @@ private:\n             resize(GROW_FAC * dim);\n     }\n \n-    void shrink(scope const TypeInfo keyti)\n+    void shrink(scope const TypeInfo keyti) pure nothrow\n     {\n         if (dim > INIT_NUM_BUCKETS)\n             resize(dim / GROW_FAC);\n@@ -233,7 +233,7 @@ package void entryDtor(void* p, const TypeInfo_Struct sti)\n     extra[1].destroy(p + talign(extra[0].tsize, extra[1].talign));\n }\n \n-private bool hasDtor(const TypeInfo ti)\n+private bool hasDtor(const TypeInfo ti) pure nothrow\n {\n     import rt.lifetime : unqualify;\n \n@@ -246,15 +246,15 @@ private bool hasDtor(const TypeInfo ti)\n     return false;\n }\n \n-private immutable(void)* getRTInfo(const TypeInfo ti)\n+private immutable(void)* getRTInfo(const TypeInfo ti) pure nothrow\n {\n     // classes are references\n     const isNoClass = ti && typeid(ti) !is typeid(TypeInfo_Class);\n     return isNoClass ? ti.rtInfo() : rtinfoHasPointers;\n }\n \n // build type info for Entry with additional key and value fields\n-TypeInfo_Struct fakeEntryTI(ref Impl aa, const TypeInfo keyti, const TypeInfo valti)\n+TypeInfo_Struct fakeEntryTI(ref Impl aa, const TypeInfo keyti, const TypeInfo valti) nothrow\n {\n     import rt.lifetime : unqualify;\n \n@@ -319,7 +319,8 @@ TypeInfo_Struct fakeEntryTI(ref Impl aa, const TypeInfo keyti, const TypeInfo va\n }\n \n // build appropriate RTInfo at runtime\n-immutable(void)* rtinfoEntry(ref Impl aa, immutable(size_t)* keyinfo, immutable(size_t)* valinfo, size_t* rtinfoData, size_t rtinfoSize)\n+immutable(void)* rtinfoEntry(ref Impl aa, immutable(size_t)* keyinfo,\n+    immutable(size_t)* valinfo, size_t* rtinfoData, size_t rtinfoSize) pure nothrow\n {\n     enum bitsPerWord = 8 * size_t.sizeof;\n \n@@ -456,7 +457,7 @@ private size_t mix(size_t h) @safe pure nothrow @nogc\n     return h;\n }\n \n-private size_t calcHash(scope const void* pkey, scope const TypeInfo keyti)\n+private size_t calcHash(scope const void* pkey, scope const TypeInfo keyti) nothrow\n {\n     immutable hash = keyti.getHash(pkey);\n     // highest bit is set to distinguish empty/deleted from filled buckets\n@@ -485,6 +486,18 @@ pure nothrow @nogc unittest\n // API Implementation\n //------------------------------------------------------------------------------\n \n+/** Allocate associative array data.\n+ * Called for `new SomeAA` expression.\n+ * Params:\n+ *      ti = TypeInfo for the associative array\n+ * Returns:\n+ *      A new associative array.\n+ */\n+extern (C) Impl* _aaNew(const TypeInfo_AssociativeArray ti)\n+{\n+    return new Impl(ti);\n+}\n+\n /// Determine number of entries in associative array.\n extern (C) size_t _aaLen(scope const AA aa) pure nothrow @nogc\n {\n@@ -736,7 +749,15 @@ extern (C) int _aaApply2(AA aa, const size_t keysz, dg2_t dg)\n     return 0;\n }\n \n-/// Construct an associative array of type ti from keys and value\n+/** Construct an associative array of type ti from corresponding keys and values.\n+ * Called for an AA literal `[k1:v1, k2:v2]`.\n+ * Params:\n+ *      ti = TypeInfo for the associative array\n+ *      keys = array of keys\n+ *      vals = array of values\n+ * Returns:\n+ *      A new associative array opaque pointer, or null if `keys` is empty.\n+ */\n extern (C) Impl* _d_assocarrayliteralTX(const TypeInfo_AssociativeArray ti, void[] keys,\n     void[] vals)\n {"}, {"sha": "c9db2fc2c898b976c223ddc62cefb1c5ab3c92fa", "filename": "libphobos/libdruntime/rt/arrayassign.d", "status": "modified", "additions": 59, "deletions": 24, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Farrayassign.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -19,8 +19,10 @@ private\n     debug(PRINTF) import core.stdc.stdio;\n }\n \n-/**\n- * Keep for backward binary compatibility. This function can be removed in the future.\n+/*\n+ * Superseded array assignment hook. Does not take into account destructors:\n+ * https://issues.dlang.org/show_bug.cgi?id=13661\n+ * Kept for backward binary compatibility. This function can be removed in the future.\n  */\n extern (C) void[] _d_arrayassign(TypeInfo ti, void[] from, void[] to)\n {\n@@ -40,15 +42,44 @@ extern (C) void[] _d_arrayassign(TypeInfo ti, void[] from, void[] to)\n }\n \n /**\n- * Does array assignment (not construction) from another\n- * lvalue array of the same element type.\n- * Handles overlapping copies.\n- * Input:\n- *      ti      TypeInfo of the element type.\n- *      dst     Points target memory. Its .length is equal to the element count, not byte length.\n- *      src     Points source memory. Its .length is equal to the element count, not byte length.\n- *      ptmp    Temporary memory for element swapping.\n- */\n+Does array assignment (not construction) from another array of the same\n+element type.\n+\n+Handles overlapping copies.\n+\n+The `_d_arrayassign_l` variant assumes the right hand side is an lvalue,\n+while `_d_arrayassign_r` assumes it's an rvalue, which means it doesn't have to call copy constructors.\n+\n+Used for static array assignment with non-POD element types:\n+---\n+struct S\n+{\n+    ~this() {} // destructor, so not Plain Old Data\n+}\n+\n+void main()\n+{\n+    S[3] arr;\n+    S[3] lvalue;\n+\n+    arr = lvalue;\n+    // Generates:\n+    // S _tmp;\n+    // _d_arrayassign_l(typeid(S), (cast(void*) lvalue.ptr)[0..lvalue.length], (cast(void*) arr.ptr)[0..arr.length], &_tmp);\n+\n+    S[3] getRvalue() {return lvalue;}\n+    arr = getRvalue();\n+    // Similar, but `_d_arrayassign_r`\n+}\n+---\n+\n+Params:\n+    ti = `TypeInfo` of the array element type.\n+    dst = target memory. Its `.length` is equal to the element count, not byte length.\n+    src = source memory. Its `.length` is equal to the element count, not byte length.\n+    ptmp =  Temporary memory for element swapping, must have capacity of `ti.tsize` bytes.\n+Returns: `dst`\n+*/\n extern (C) void[] _d_arrayassign_l(TypeInfo ti, void[] src, void[] dst, void* ptmp)\n {\n     debug(PRINTF) printf(\"_d_arrayassign_l(src = %p,%d, dst = %p,%d) size = %d\\n\", src.ptr, src.length, dst.ptr, dst.length, ti.tsize);\n@@ -131,16 +162,7 @@ unittest    // Bugzilla 14024\n     assert(op == \"YzXy\", op);\n }\n \n-/**\n- * Does array assignment (not construction) from another\n- * rvalue array of the same element type.\n- * Input:\n- *      ti      TypeInfo of the element type.\n- *      dst     Points target memory. Its .length is equal to the element count, not byte length.\n- *      src     Points source memory. Its .length is equal to the element count, not byte length.\n- *              It is always allocated on stack and never overlapping with dst.\n- *      ptmp    Temporary memory for element swapping.\n- */\n+/// ditto\n extern (C) void[] _d_arrayassign_r(TypeInfo ti, void[] src, void[] dst, void* ptmp)\n {\n     debug(PRINTF) printf(\"_d_arrayassign_r(src = %p,%d, dst = %p,%d) size = %d\\n\", src.ptr, src.length, dst.ptr, dst.length, ti.tsize);\n@@ -163,9 +185,22 @@ extern (C) void[] _d_arrayassign_r(TypeInfo ti, void[] src, void[] dst, void* pt\n }\n \n /**\n- * Do assignment to an array.\n- *      p[0 .. count] = value;\n- */\n+Set all elements of an array to a single value.\n+\n+---\n+p[0 .. count] = value;\n+---\n+\n+Takes into account postblits and destructors, for Plain Old Data elements,\n+`rt/memset.d` is used.\n+\n+Params:\n+    p = pointer to start of array\n+    value = bytes of the element to set. Size is derived from `ti`.\n+    count = amount of array elements to set\n+    ti = type info of the array element type / `value`\n+Returns: `p`\n+*/\n extern (C) void* _d_arraysetassign(void* p, void* value, int count, TypeInfo ti)\n {\n     void* pstart = p;"}, {"sha": "026001f5ad7082e51fc879f63873b4af185d2766", "filename": "libphobos/libdruntime/rt/lifetime.d", "status": "modified", "additions": 279, "deletions": 99, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Flifetime.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -48,16 +48,39 @@ deprecated extern (C) void lifetime_init()\n }\n \n /**\n- *\n- */\n+Allocate memory using the garbage collector\n+\n+DMD uses this to allocate closures:\n+---\n+void f(byte[24] x)\n+{\n+    return () => x; // `x` is on stack, must be moved to heap to keep it alive\n+}\n+---\n+\n+Params:\n+    sz = number of bytes to allocate\n+\n+Returns: pointer to `sz` bytes of free, uninitialized memory, managed by the GC.\n+*/\n extern (C) void* _d_allocmemory(size_t sz) @weak\n {\n     return GC.malloc(sz);\n }\n \n /**\n- *\n- */\n+Create a new class instance.\n+\n+Allocates memory and sets fields to their initial value, but does not call a constructor.\n+\n+---\n+new Object() // _d_newclass(typeid(Object))\n+---\n+Params:\n+    ci = `TypeInfo_Class` object, to provide instance size and initial bytes to copy\n+\n+Returns: newly created object\n+*/\n extern (C) Object _d_newclass(const ClassInfo ci) @weak\n {\n     import core.stdc.stdlib;\n@@ -352,7 +375,7 @@ bool __setArrayAllocLength(ref BlkInfo info, size_t newlength, bool isshared, co\n /**\n   get the allocation size of the array for the given block (without padding or type info)\n   */\n-size_t __arrayAllocLength(ref BlkInfo info, const TypeInfo tinext) pure nothrow\n+private size_t __arrayAllocLength(ref BlkInfo info, const TypeInfo tinext) pure nothrow\n {\n     if (info.size <= 256)\n         return *cast(ubyte *)(info.base + info.size - structTypeInfoSize(tinext) - SMALLPAD);\n@@ -366,7 +389,7 @@ size_t __arrayAllocLength(ref BlkInfo info, const TypeInfo tinext) pure nothrow\n /**\n   get the start of the array for the given block\n   */\n-void *__arrayStart(return scope BlkInfo info) nothrow pure\n+private void *__arrayStart(return scope BlkInfo info) nothrow pure\n {\n     return info.base + ((info.size & BIGLENGTHMASK) ? LARGEPREFIX : 0);\n }\n@@ -376,7 +399,7 @@ void *__arrayStart(return scope BlkInfo info) nothrow pure\n   NOT included in the passed in size.  Therefore, do NOT call this function\n   with the size of an allocated block.\n   */\n-size_t __arrayPad(size_t size, const TypeInfo tinext) nothrow pure @trusted\n+private size_t __arrayPad(size_t size, const TypeInfo tinext) nothrow pure @trusted\n {\n     return size > MAXMEDSIZE ? LARGEPAD : ((size > MAXSMALLSIZE ? MEDPAD : SMALLPAD) + structTypeInfoSize(tinext));\n }\n@@ -401,7 +424,7 @@ private void __arrayClearPad(ref BlkInfo info, size_t arrsize, size_t padsize) n\n   allocate an array memory block by applying the proper padding and\n   assigning block attributes if not inherited from the existing block\n   */\n-BlkInfo __arrayAlloc(size_t arrsize, const scope TypeInfo ti, const TypeInfo tinext) nothrow pure\n+private BlkInfo __arrayAlloc(size_t arrsize, const scope TypeInfo ti, const TypeInfo tinext) nothrow pure\n {\n     import core.checkedint;\n \n@@ -423,7 +446,7 @@ BlkInfo __arrayAlloc(size_t arrsize, const scope TypeInfo ti, const TypeInfo tin\n     return bi;\n }\n \n-BlkInfo __arrayAlloc(size_t arrsize, ref BlkInfo info, const scope TypeInfo ti, const TypeInfo tinext)\n+private BlkInfo __arrayAlloc(size_t arrsize, ref BlkInfo info, const scope TypeInfo ti, const TypeInfo tinext)\n {\n     import core.checkedint;\n \n@@ -446,7 +469,7 @@ BlkInfo __arrayAlloc(size_t arrsize, ref BlkInfo info, const scope TypeInfo ti,\n /**\n   cache for the lookup of the block info\n   */\n-enum N_CACHE_BLOCKS=8;\n+private enum N_CACHE_BLOCKS=8;\n \n // note this is TLS, so no need to sync.\n BlkInfo *__blkcache_storage;\n@@ -644,10 +667,15 @@ void __insertBlkInfoCache(BlkInfo bi, BlkInfo *curpos) nothrow\n }\n \n /**\n- * Shrink the \"allocated\" length of an array to be the exact size of the array.\n- * It doesn't matter what the current allocated length of the array is, the\n- * user is telling the runtime that he knows what he is doing.\n- */\n+Shrink the \"allocated\" length of an array to be the exact size of the array.\n+\n+It doesn't matter what the current allocated length of the array is, the\n+user is telling the runtime that he knows what he is doing.\n+\n+Params:\n+    ti = `TypeInfo` of array type\n+    arr = array to shrink. Its `.length` is element length, not byte length, despite `void` type\n+*/\n extern(C) void _d_arrayshrinkfit(const TypeInfo ti, void[] arr) /+nothrow+/\n {\n     // note, we do not care about shared.  We are setting the length no matter\n@@ -690,7 +718,7 @@ extern(C) void _d_arrayshrinkfit(const TypeInfo ti, void[] arr) /+nothrow+/\n     }\n }\n \n-package bool hasPostblit(in TypeInfo ti)\n+package bool hasPostblit(in TypeInfo ti) nothrow pure\n {\n     return (&ti.postblit).funcptr !is &TypeInfo.postblit;\n }\n@@ -726,12 +754,21 @@ void __doPostblit(void *ptr, size_t len, const TypeInfo ti)\n \n \n /**\n- * set the array capacity.  If the array capacity isn't currently large enough\n- * to hold the requested capacity (in number of elements), then the array is\n- * resized/reallocated to the appropriate size.  Pass in a requested capacity\n- * of 0 to get the current capacity.  Returns the number of elements that can\n- * actually be stored once the resizing is done.\n- */\n+Set the array capacity.\n+\n+If the array capacity isn't currently large enough\n+to hold the requested capacity (in number of elements), then the array is\n+resized/reallocated to the appropriate size.\n+\n+Pass in a requested capacity of 0 to get the current capacity.\n+\n+Params:\n+    ti = type info of element type\n+    newcapacity = requested new capacity\n+    p = pointer to array to set. Its `length` is left unchanged.\n+\n+Returns: the number of elements that can actually be stored once the resizing is done\n+*/\n extern(C) size_t _d_arraysetcapacity(const TypeInfo ti, size_t newcapacity, void[]* p) @weak\n in\n {\n@@ -902,9 +939,18 @@ Lcontinue:\n }\n \n /**\n- * Allocate a new uninitialized array of length elements.\n- * ti is the type of the resulting array, or pointer to element.\n- */\n+Allocate an array with the garbage collector.\n+\n+Has three variants:\n+- `_d_newarrayU` leave elements uninitialized\n+- `_d_newarrayT` initializes to 0 (e.g `new int[]`)\n+- `_d_newarrayiT` initializes based on initializer retrieved from TypeInfo (e.g `new float[]`)\n+\n+Params:\n+    ti = the type of the resulting array, (may also be the corresponding `array.ptr` type)\n+    length = `.length` of resulting array\n+Returns: newly allocated array\n+*/\n extern (C) void[] _d_newarrayU(const scope TypeInfo ti, size_t length) pure nothrow @weak\n {\n     import core.exception : onOutOfMemoryError;\n@@ -961,11 +1007,7 @@ Lcontinue:\n     return arrstart[0..length];\n }\n \n-/**\n- * Allocate a new array of length elements.\n- * ti is the type of the resulting array, or pointer to element.\n- * (For when the array is initialized to 0)\n- */\n+/// ditto\n extern (C) void[] _d_newarrayT(const TypeInfo ti, size_t length) pure nothrow @weak\n {\n     import core.stdc.string;\n@@ -978,9 +1020,7 @@ extern (C) void[] _d_newarrayT(const TypeInfo ti, size_t length) pure nothrow @w\n     return result;\n }\n \n-/**\n- * For when the array has a non-zero initializer.\n- */\n+/// ditto\n extern (C) void[] _d_newarrayiT(const TypeInfo ti, size_t length) pure nothrow @weak\n {\n     import core.internal.traits : AliasSeq;\n@@ -1016,10 +1056,10 @@ extern (C) void[] _d_newarrayiT(const TypeInfo ti, size_t length) pure nothrow @\n }\n \n \n-/**\n- *\n+/*\n+ * Helper for creating multi-dimensional arrays\n  */\n-void[] _d_newarrayOpT(alias op)(const TypeInfo ti, size_t[] dims)\n+private void[] _d_newarrayOpT(alias op)(const TypeInfo ti, size_t[] dims)\n {\n     debug(PRINTF) printf(\"_d_newarrayOpT(ndims = %d)\\n\", dims.length);\n     if (dims.length == 0)\n@@ -1058,8 +1098,30 @@ void[] _d_newarrayOpT(alias op)(const TypeInfo ti, size_t[] dims)\n \n \n /**\n- *\n- */\n+Create a new multi-dimensional array\n+\n+Has two variants:\n+- `_d_newarraymTX` which initializes to 0\n+- `_d_newarraymiTX` which initializes elements based on `TypeInfo`\n+\n+---\n+void main()\n+{\n+    new int[][](10, 20);\n+    // _d_newarraymTX(typeid(float), [10, 20]);\n+\n+    new float[][][](10, 20, 30);\n+    // _d_newarraymiTX(typeid(float), [10, 20, 30]);\n+}\n+---\n+\n+Params:\n+    ti = `TypeInfo` of the array type\n+    dims = array length values for each dimension\n+\n+Returns:\n+    newly allocated array\n+*/\n extern (C) void[] _d_newarraymTX(const TypeInfo ti, size_t[] dims) @weak\n {\n     debug(PRINTF) printf(\"_d_newarraymT(dims.length = %d)\\n\", dims.length);\n@@ -1072,10 +1134,7 @@ extern (C) void[] _d_newarraymTX(const TypeInfo ti, size_t[] dims) @weak\n     }\n }\n \n-\n-/**\n- *\n- */\n+/// ditto\n extern (C) void[] _d_newarraymiTX(const TypeInfo ti, size_t[] dims) @weak\n {\n     debug(PRINTF) printf(\"_d_newarraymiT(dims.length = %d)\\n\", dims.length);\n@@ -1089,9 +1148,31 @@ extern (C) void[] _d_newarraymiTX(const TypeInfo ti, size_t[] dims) @weak\n }\n \n /**\n- * Allocate an uninitialized non-array item.\n- * This is an optimization to avoid things needed for arrays like the __arrayPad(size).\n- */\n+Allocate an uninitialized non-array item.\n+\n+This is an optimization to avoid things needed for arrays like the __arrayPad(size).\n+\n+- `_d_newitemU` leaves the item uninitialized\n+- `_d_newitemT` zero initializes the item\n+- `_d_newitemiT` uses a non-zero initializer from `TypeInfo`\n+\n+Used to allocate struct instances on the heap.\n+---\n+struct Sz {int x = 0;}\n+struct Si {int x = 3;}\n+\n+void main()\n+{\n+    new Sz(); // _d_newitemT(typeid(Sz))\n+    new Si(); // _d_newitemiT(typeid(Si))\n+}\n+---\n+\n+Params:\n+    _ti = `TypeInfo` of item to allocate\n+Returns:\n+    newly allocated item\n+*/\n extern (C) void* _d_newitemU(scope const TypeInfo _ti) pure nothrow @weak\n {\n     auto ti = unqualify(_ti);\n@@ -1115,7 +1196,7 @@ extern (C) void* _d_newitemU(scope const TypeInfo _ti) pure nothrow @weak\n     return p;\n }\n \n-/// Same as above, zero initializes the item.\n+/// ditto\n extern (C) void* _d_newitemT(in TypeInfo _ti) pure nothrow @weak\n {\n     import core.stdc.string;\n@@ -1135,15 +1216,6 @@ extern (C) void* _d_newitemiT(in TypeInfo _ti) pure nothrow @weak\n     return p;\n }\n \n-/**\n- *\n- */\n-struct Array\n-{\n-    size_t length;\n-    byte*  data;\n-}\n-\n debug(PRINTF)\n {\n     extern(C) void printArrayCache()\n@@ -1426,6 +1498,7 @@ extern (C) void rt_finalize2(void* p, bool det = true, bool resetMemory = true)\n     }\n }\n \n+/// Backwards compatibility\n extern (C) void rt_finalize(void* p, bool det = true) nothrow\n {\n     rt_finalize2(p, det, true);\n@@ -1444,8 +1517,29 @@ extern (C) void rt_finalizeFromGC(void* p, size_t size, uint attr) nothrow\n \n \n /**\n- * Resize dynamic arrays with 0 initializers.\n- */\n+Resize a dynamic array by setting the `.length` property\n+\n+Newly created elements are initialized to their default value.\n+\n+Has two variants:\n+- `_d_arraysetlengthT` for arrays with elements that initialize to 0\n+- `_d_arraysetlengthiT` for non-zero initializers retrieved from `TypeInfo`\n+\n+---\n+void main()\n+{\n+    int[] a = [1, 2];\n+    a.length = 3; // gets lowered to `_d_arraysetlengthT(typeid(int[]), 3, &a)`\n+}\n+---\n+\n+Params:\n+    ti = `TypeInfo` of array\n+    newlength = new value for the array's `.length`\n+    p = pointer to array to update the `.length` of.\n+        While it's cast to `void[]`, its `.length` is still treated as element length.\n+Returns: `*p` after being updated\n+*/\n extern (C) void[] _d_arraysetlengthT(const TypeInfo ti, size_t newlength, void[]* p) @weak\n in\n {\n@@ -1639,15 +1733,7 @@ do\n     return *p;\n }\n \n-\n-/**\n- * Resize arrays for non-zero initializers.\n- *      p               pointer to array lvalue to be updated\n- *      newlength       new .length property of array\n- *      sizeelem        size of each element of array\n- *      initsize        size of initializer\n- *      ...             initializer\n- */\n+/// ditto\n extern (C) void[] _d_arraysetlengthiT(const TypeInfo ti, size_t newlength, void[]* p) @weak\n in\n {\n@@ -1859,8 +1945,31 @@ do\n \n \n /**\n- *\n- */\n+Given an array of length `size` that needs to be expanded to `newlength`,\n+compute a new capacity.\n+\n+Better version by Dave Fladebo:\n+This uses an inverse logorithmic algorithm to pre-allocate a bit more\n+space for larger arrays.\n+- Arrays smaller than PAGESIZE bytes are left as-is, so for the most\n+common cases, memory allocation is 1 to 1. The small overhead added\n+doesn't affect small array perf. (it's virtually the same as\n+current).\n+- Larger arrays have some space pre-allocated.\n+- As the arrays grow, the relative pre-allocated space shrinks.\n+- The logorithmic algorithm allocates relatively more space for\n+mid-size arrays, making it very fast for medium arrays (for\n+mid-to-large arrays, this turns out to be quite a bit faster than the\n+equivalent realloc() code in C, on Linux at least. Small arrays are\n+just as fast as GCC).\n+- Perhaps most importantly, overall memory usage and stress on the GC\n+is decreased significantly for demanding environments.\n+\n+Params:\n+    newlength = new `.length`\n+    size = old `.length`\n+Returns: new capacity for array\n+*/\n size_t newCapacity(size_t newlength, size_t size)\n {\n     version (none)\n@@ -1869,24 +1978,6 @@ size_t newCapacity(size_t newlength, size_t size)\n     }\n     else\n     {\n-        /*\n-         * Better version by Dave Fladebo:\n-         * This uses an inverse logorithmic algorithm to pre-allocate a bit more\n-         * space for larger arrays.\n-         * - Arrays smaller than PAGESIZE bytes are left as-is, so for the most\n-         * common cases, memory allocation is 1 to 1. The small overhead added\n-         * doesn't affect small array perf. (it's virtually the same as\n-         * current).\n-         * - Larger arrays have some space pre-allocated.\n-         * - As the arrays grow, the relative pre-allocated space shrinks.\n-         * - The logorithmic algorithm allocates relatively more space for\n-         * mid-size arrays, making it very fast for medium arrays (for\n-         * mid-to-large arrays, this turns out to be quite a bit faster than the\n-         * equivalent realloc() code in C, on Linux at least. Small arrays are\n-         * just as fast as GCC).\n-         * - Perhaps most importantly, overall memory usage and stress on the GC\n-         * is decreased significantly for demanding environments.\n-         */\n         size_t newcap = newlength * size;\n         size_t newext = 0;\n \n@@ -1940,10 +2031,17 @@ size_t newCapacity(size_t newlength, size_t size)\n }\n \n \n-/**************************************\n- * Extend an array by n elements.\n- * Caller must initialize those elements.\n- */\n+/**\n+Extend an array by n elements.\n+\n+Caller must initialize those elements.\n+\n+Params:\n+    ti = type info of array type (not element type)\n+    px = array to append to, cast to `byte[]` while keeping the same `.length`. Will be updated.\n+    n = number of elements to append\n+Returns: `px` after being appended to\n+*/\n extern (C)\n byte[] _d_arrayappendcTX(const TypeInfo ti, return scope ref byte[] px, size_t n) @weak\n {\n@@ -2047,8 +2145,21 @@ byte[] _d_arrayappendcTX(const TypeInfo ti, return scope ref byte[] px, size_t n\n \n \n /**\n- * Append dchar to char[]\n- */\n+Append `dchar` to `char[]`, converting UTF-32 to UTF-8\n+\n+---\n+void main()\n+{\n+    char[] s;\n+    s ~= '\u03b1';\n+}\n+---\n+\n+Params:\n+    x = array to append to cast to `byte[]`. Will be modified.\n+    c = `dchar` to append\n+Returns: updated `x` cast to `void[]`\n+*/\n extern (C) void[] _d_arrayappendcd(ref byte[] x, dchar c) @weak\n {\n     // c could encode into from 1 to 4 characters\n@@ -2129,8 +2240,23 @@ unittest\n \n \n /**\n- * Append dchar to wchar[]\n- */\n+Append `dchar` to `wchar[]`, converting UTF-32 to UTF-16\n+\n+---\n+void main()\n+{\n+    dchar x;\n+    wchar[] s;\n+    s ~= '\u03b1';\n+}\n+---\n+\n+Params:\n+    x = array to append to cast to `byte[]`. Will be modified.\n+    c = `dchar` to append\n+\n+Returns: updated `x` cast to `void[]`\n+*/\n extern (C) void[] _d_arrayappendwd(ref byte[] x, dchar c) @weak\n {\n     // c could encode into from 1 to 2 w characters\n@@ -2162,8 +2288,24 @@ extern (C) void[] _d_arrayappendwd(ref byte[] x, dchar c) @weak\n \n \n /**\n- *\n- */\n+Concatenate two arrays into a new array\n+\n+---\n+void main()\n+{\n+    int[] x = [10, 20, 30];\n+    int[] y = [40, 50];\n+    int[] c = x ~ y; // _d_arraycatT(typeid(int[]), (cast(byte*) x)[0..x.length], (cast(byte*) y)[0..y.length]);\n+}\n+---\n+\n+Params:\n+    ti = type that the two arrays share\n+    x = left hand side array casted to `byte[]`. Despite this cast, its `.length` is original element length, not byte length\n+    y = right hand side array casted to `byte[]`. Despite this cast, its `.length` is original element length, not byte length\n+Returns:\n+    resulting concatenated array, with `.length` equal to new element length despite `byte` type\n+*/\n extern (C) byte[] _d_arraycatT(const TypeInfo ti, byte[] x, byte[] y) @weak\n out (result)\n {\n@@ -2228,8 +2370,27 @@ do\n \n \n /**\n- *\n- */\n+Concatenate multiple arrays at once\n+\n+This is more efficient than repeatedly concatenating pairs of arrays because the total size is known in advance.\n+\n+```\n+void main()\n+{\n+    int[] a, b, c;\n+    int[] res = a ~ b ~ c;\n+    // _d_arraycatnTX(typeid(int[]),\n+    //    [(cast(byte*)a.ptr)[0..a.length], (cast(byte*)b.ptr)[0..b.length], (cast(byte*)c.ptr)[0..c.length]]);\n+}\n+```\n+\n+Params:\n+    ti = type of arrays to concatenate and resulting array\n+    arrs = array of arrays to concatenate, cast to `byte[]` while keeping `.length` the same\n+\n+Returns:\n+    newly created concatenated array, `.length` equal to the total element length despite `void` type\n+*/\n extern (C) void[] _d_arraycatnTX(const TypeInfo ti, scope byte[][] arrs) @weak\n {\n     import core.stdc.string;\n@@ -2268,8 +2429,27 @@ extern (C) void[] _d_arraycatnTX(const TypeInfo ti, scope byte[][] arrs) @weak\n \n \n /**\n- * Allocate the array, rely on the caller to do the initialization of the array.\n- */\n+Allocate an array literal\n+\n+Rely on the caller to do the initialization of the array.\n+\n+---\n+int[] getArr()\n+{\n+    return [10, 20];\n+    // auto res = cast(int*) _d_arrayliteralTX(typeid(int[]), 2);\n+    // res[0] = 10;\n+    // res[1] = 20;\n+    // return res[0..2];\n+}\n+---\n+\n+Params:\n+    ti = `TypeInfo` of resulting array type\n+    length = `.length` of array literal\n+\n+Returns: pointer to allocated array\n+*/\n extern (C)\n void* _d_arrayliteralTX(const TypeInfo ti, size_t length) @weak\n {"}, {"sha": "744e5ad5e781431f83182468938660fef024eb9b", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1,4 +1,4 @@\n-a4a18d21c4ea7930f80309f85e38c571c5f6d4b8\n+1516ecad932d88a1618163384e6f69009d125391\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "5a155387adcc77048f9edeea2a39906bb0559b18", "filename": "libphobos/src/std/complex.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcomplex.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -1695,9 +1695,9 @@ Complex!T log(T)(Complex!T x) @safe pure nothrow @nogc\n  */\n Complex!T log10(T)(Complex!T x) @safe pure nothrow @nogc\n {\n-    static import std.math;\n+    import std.math.constants : LN10;\n \n-    return log(x) / Complex!T(std.math.log(10.0));\n+    return log(x) / Complex!T(LN10);\n }\n \n ///"}, {"sha": "b8b4a8ce6c617ced0e163704b8d5329054338a03", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -176,9 +176,9 @@ class FileException : Exception\n     private this(scope const(char)[] name, scope const(char)[] msg, string file, size_t line, uint errno) @safe pure\n     {\n         if (msg.empty)\n-            super(name.idup, file, line);\n+            super(name is null ? \"(null)\" : name.idup, file, line);\n         else\n-            super(text(name, \": \", msg), file, line);\n+            super(text(name is null ? \"(null)\" : name, \": \", msg), file, line);\n \n         this.errno = errno;\n     }\n@@ -1067,11 +1067,38 @@ private void removeImpl(scope const(char)[] name, scope const(FSChar)* namez) @t\n         if (!name)\n         {\n             import core.stdc.string : strlen;\n-            auto len = strlen(namez);\n+\n+            auto len = namez ? strlen(namez) : 0;\n             name = namez[0 .. len];\n         }\n         cenforce(core.stdc.stdio.remove(namez) == 0,\n-            \"Failed to remove file \" ~ name);\n+            \"Failed to remove file \" ~ (name is null ? \"(null)\" : name));\n+    }\n+}\n+\n+@safe unittest\n+{\n+    import std.exception : collectExceptionMsg, assertThrown;\n+\n+    string filename = null; // e.g. as returned by File.tmpfile.name\n+\n+    version (linux)\n+    {\n+        // exact exception message is OS-dependent\n+        auto msg = filename.remove.collectExceptionMsg!FileException;\n+        assert(\"Failed to remove file (null): Bad address\" == msg, msg);\n+    }\n+    else version (Windows)\n+    {\n+        import std.algorithm.searching : startsWith;\n+\n+        // don't test exact message on windows, it's language dependent\n+        auto msg = filename.remove.collectExceptionMsg!FileException;\n+        assert(msg.startsWith(\"(null):\"), msg);\n+    }\n+    else\n+    {\n+        assertThrown!FileException(filename.remove);\n     }\n }\n "}, {"sha": "e32330fd932845e3f111fb3e15bb6e31dd927179", "filename": "libphobos/src/std/math/exponential.d", "status": "modified", "additions": 388, "deletions": 260, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2Fstd%2Fmath%2Fexponential.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208fbc779c713715da1465a1a2c6710c084c9b05/libphobos%2Fsrc%2Fstd%2Fmath%2Fexponential.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmath%2Fexponential.d?ref=208fbc779c713715da1465a1a2c6710c084c9b05", "patch": "@@ -2862,14 +2862,16 @@ float ldexp(float n, int exp)   @safe pure nothrow @nogc { return core.math.ldex\n \n private\n {\n-    import std.math : floatTraits, RealFormat;\n-\n-    version (INLINE_YL2X) {} else\n+    // Coefficients shared across log(), log2(), log10().\n+    template LogCoeffs(T)\n     {\n-        static if (floatTraits!real.realFormat == RealFormat.ieeeQuadruple)\n+        import std.math : floatTraits, RealFormat;\n+\n+        static if (floatTraits!T.realFormat == RealFormat.ieeeQuadruple)\n         {\n-            // Coefficients for log(1 + x) = x - x**2/2 + x**3 P(x)/Q(x)\n-            static immutable real[13] logCoeffsP = [\n+            // Coefficients for log(1 + x) = x - x^^2/2 + x^^3 P(x)/Q(x)\n+            // Theoretical peak relative error = 5.3e-37\n+            static immutable real[13] logP = [\n                 1.313572404063446165910279910527789794488E4L,\n                 7.771154681358524243729929227226708890930E4L,\n                 2.014652742082537582487669938141683759923E5L,\n@@ -2884,7 +2886,7 @@ private\n                 4.998469661968096229986658302195402690910E-1L,\n                 1.538612243596254322971797716843006400388E-6L\n             ];\n-            static immutable real[13] logCoeffsQ = [\n+            static immutable real[13] logQ = [\n                 3.940717212190338497730839731583397586124E4L,\n                 2.626900195321832660448791748036714883242E5L,\n                 7.777690340007566932935753241556479363645E5L,\n@@ -2900,17 +2902,26 @@ private\n                 1.0\n             ];\n \n-            // Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2)\n+            // log2 uses the same coefficients as log.\n+            alias log2P = logP;\n+            alias log2Q = logQ;\n+\n+            // log10 uses the same coefficients as log.\n+            alias log10P = logP;\n+            alias log10Q = logQ;\n+\n+            // Coefficients for log(x) = z + z^^3 P(z^^2)/Q(z^^2)\n             // where z = 2(x-1)/(x+1)\n-            static immutable real[6] logCoeffsR = [\n+            // Theoretical peak relative error = 1.1e-35\n+            static immutable real[6] logR = [\n                 1.418134209872192732479751274970992665513E5L,\n                 -8.977257995689735303686582344659576526998E4L,\n                 2.048819892795278657810231591630928516206E4L,\n                 -2.024301798136027039250415126250455056397E3L,\n                 8.057002716646055371965756206836056074715E1L,\n                 -8.828896441624934385266096344596648080902E-1L\n             ];\n-            static immutable real[7] logCoeffsS = [\n+            static immutable real[7] logS = [\n                 1.701761051846631278975701529965589676574E6L,\n                 -1.332535117259762928288745111081235577029E6L,\n                 4.001557694070773974936904547424676279307E5L,\n@@ -2922,8 +2933,9 @@ private\n         }\n         else\n         {\n-            // Coefficients for log(1 + x) = x - x**2/2 + x**3 P(x)/Q(x)\n-            static immutable real[7] logCoeffsP = [\n+            // Coefficients for log(1 + x) = x - x^^2/2 + x^^3 P(x)/Q(x)\n+            // Theoretical peak relative error = 2.32e-20\n+            static immutable real[7] logP = [\n                 2.0039553499201281259648E1L,\n                 5.7112963590585538103336E1L,\n                 6.0949667980987787057556E1L,\n@@ -2932,7 +2944,7 @@ private\n                 4.9854102823193375972212E-1L,\n                 4.5270000862445199635215E-5L,\n             ];\n-            static immutable real[7] logCoeffsQ = [\n+            static immutable real[7] logQ = [\n                 6.0118660497603843919306E1L,\n                 2.1642788614495947685003E2L,\n                 3.0909872225312059774938E2L,\n@@ -2942,15 +2954,42 @@ private\n                 1.0000000000000000000000E0L,\n             ];\n \n-            // Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2)\n+            // Coefficients for log(1 + x) = x - x^^2/2 + x^^3 P(x)/Q(x)\n+            // Theoretical peak relative error = 6.2e-22\n+            static immutable real[7] log2P = [\n+                1.0747524399916215149070E2L,\n+                3.4258224542413922935104E2L,\n+                4.2401812743503691187826E2L,\n+                2.5620629828144409632571E2L,\n+                7.7671073698359539859595E1L,\n+                1.0767376367209449010438E1L,\n+                4.9962495940332550844739E-1L,\n+            ];\n+            static immutable real[8] log2Q = [\n+                3.2242573199748645407652E2L,\n+                1.2695660352705325274404E3L,\n+                2.0307734695595183428202E3L,\n+                1.6911722418503949084863E3L,\n+                7.7952888181207260646090E2L,\n+                1.9444210022760132894510E2L,\n+                2.3479774160285863271658E1L,\n+                1.0000000000000000000000E0,\n+            ];\n+\n+            // log10 uses the same coefficients as log2.\n+            alias log10P = log2P;\n+            alias log10Q = log2Q;\n+\n+            // Coefficients for log(x) = z + z^^3 P(z^^2)/Q(z^^2)\n             // where z = 2(x-1)/(x+1)\n-            static immutable real[4] logCoeffsR = [\n+            // Theoretical peak relative error = 6.16e-22\n+            static immutable real[4] logR = [\n                -3.5717684488096787370998E1L,\n                 1.0777257190312272158094E1L,\n                -7.1990767473014147232598E-1L,\n                 1.9757429581415468984296E-3L,\n             ];\n-            static immutable real[4] logCoeffsS = [\n+            static immutable real[4] logS = [\n                -4.2861221385716144629696E2L,\n                 1.9361891836232102174846E2L,\n                -2.6201045551331104417768E1L,\n@@ -2972,92 +3011,100 @@ private\n  */\n real log(real x) @safe pure nothrow @nogc\n {\n-    import std.math.constants : LN2, LOG2, SQRT1_2;\n-    import std.math.traits : isInfinity, isNaN, signbit;\n-    import std.math.algebraic : poly;\n-\n     version (INLINE_YL2X)\n+    {\n+        import std.math.constants : LN2;\n         return core.math.yl2x(x, LN2);\n+    }\n     else\n-    {\n-        // C1 + C2 = LN2.\n-        enum real C1 = 6.93145751953125E-1L;\n-        enum real C2 = 1.428606820309417232121458176568075500134E-6L;\n+        return logImpl(x);\n+}\n \n-        // Special cases.\n-        if (isNaN(x))\n-            return x;\n-        if (isInfinity(x) && !signbit(x))\n-            return x;\n-        if (x == 0.0)\n-            return -real.infinity;\n-        if (x < 0.0)\n-            return real.nan;\n+///\n+@safe pure nothrow @nogc unittest\n+{\n+    import std.math.operations : feqrel;\n+    import std.math.constants : E;\n \n-        // Separate mantissa from exponent.\n-        // Note, frexp is used so that denormal numbers will be handled properly.\n-        real y, z;\n-        int exp;\n+    assert(feqrel(log(E), 1) >= real.mant_dig - 1);\n+}\n \n-        x = frexp(x, exp);\n+private T logImpl(T)(T x) @safe pure nothrow @nogc\n+{\n+    import std.math.constants : SQRT1_2;\n+    import std.math.algebraic : poly;\n+    import std.math.traits : isInfinity, isNaN, signbit;\n \n-        // Logarithm using log(x) = z + z^^3 R(z) / S(z),\n-        // where z = 2(x - 1)/(x + 1)\n-        if ((exp > 2) || (exp < -2))\n-        {\n-            if (x < SQRT1_2)\n-            {   // 2(2x - 1)/(2x + 1)\n-                exp -= 1;\n-                z = x - 0.5;\n-                y = 0.5 * z + 0.5;\n-            }\n-            else\n-            {   // 2(x - 1)/(x + 1)\n-                z = x - 0.5;\n-                z -= 0.5;\n-                y = 0.5 * x  + 0.5;\n-            }\n-            x = z / y;\n-            z = x * x;\n-            z = x * (z * poly(z, logCoeffsR) / poly(z, logCoeffsS));\n-            z += exp * C2;\n-            z += x;\n-            z += exp * C1;\n+    alias coeffs = LogCoeffs!T;\n \n-            return z;\n-        }\n+    // C1 + C2 = LN2.\n+    enum T C1 = 6.93145751953125E-1L;\n+    enum T C2 = 1.428606820309417232121458176568075500134E-6L;\n \n-        // Logarithm using log(1 + x) = x - .5x^^2 + x^^3 P(x) / Q(x)\n+    // Special cases.\n+    if (isNaN(x))\n+        return x;\n+    if (isInfinity(x) && !signbit(x))\n+        return x;\n+    if (x == 0.0)\n+        return -T.infinity;\n+    if (x < 0.0)\n+        return T.nan;\n+\n+    // Separate mantissa from exponent.\n+    // Note, frexp is used so that denormal numbers will be handled properly.\n+    T y, z;\n+    int exp;\n+\n+    x = frexp(x, exp);\n+\n+    // Logarithm using log(x) = z + z^^3 R(z) / S(z),\n+    // where z = 2(x - 1)/(x + 1)\n+    if ((exp > 2) || (exp < -2))\n+    {\n         if (x < SQRT1_2)\n-        {\n+        {   // 2(2x - 1)/(2x + 1)\n             exp -= 1;\n-            x = 2.0 * x - 1.0;\n+            z = x - 0.5;\n+            y = 0.5 * z + 0.5;\n         }\n         else\n-        {\n-            x = x - 1.0;\n+        {   // 2(x - 1)/(x + 1)\n+            z = x - 0.5;\n+            z -= 0.5;\n+            y = 0.5 * x  + 0.5;\n         }\n+        x = z / y;\n         z = x * x;\n-        y = x * (z * poly(x, logCoeffsP) / poly(x, logCoeffsQ));\n-        y += exp * C2;\n-        z = y - 0.5 * z;\n-\n-        // Note, the sum of above terms does not exceed x/4,\n-        // so it contributes at most about 1/4 lsb to the error.\n+        z = x * (z * poly(z, coeffs.logR) / poly(z, coeffs.logS));\n+        z += exp * C2;\n         z += x;\n         z += exp * C1;\n \n         return z;\n     }\n-}\n \n-///\n-@safe pure nothrow @nogc unittest\n-{\n-    import std.math.operations : feqrel;\n-    import std.math.constants : E;\n+    // Logarithm using log(1 + x) = x - .5x^^2 + x^^3 P(x) / Q(x)\n+    if (x < SQRT1_2)\n+    {\n+        exp -= 1;\n+        x = 2.0 * x - 1.0;\n+    }\n+    else\n+    {\n+        x = x - 1.0;\n+    }\n+    z = x * x;\n+    y = x * (z * poly(x, coeffs.logP) / poly(x, coeffs.logQ));\n+    y += exp * C2;\n+    z = y - 0.5 * z;\n \n-    assert(feqrel(log(E), 1) >= real.mant_dig - 1);\n+    // Note, the sum of above terms does not exceed x/4,\n+    // so it contributes at most about 1/4 lsb to the error.\n+    z += x;\n+    z += exp * C1;\n+\n+    return z;\n }\n \n /**************************************\n@@ -3072,95 +3119,103 @@ real log(real x) @safe pure nothrow @nogc\n  */\n real log10(real x) @safe pure nothrow @nogc\n {\n-    import std.math.constants : LOG2, LN2, SQRT1_2;\n-    import std.math.algebraic : poly;\n-    import std.math.traits : isNaN, isInfinity, signbit;\n-\n     version (INLINE_YL2X)\n+    {\n+        import std.math.constants : LOG2;\n         return core.math.yl2x(x, LOG2);\n+    }\n     else\n-    {\n-        // log10(2) split into two parts.\n-        enum real L102A =  0.3125L;\n-        enum real L102B = -1.14700043360188047862611052755069732318101185E-2L;\n+        return log10Impl(x);\n+}\n \n-        // log10(e) split into two parts.\n-        enum real L10EA =  0.5L;\n-        enum real L10EB = -6.570551809674817234887108108339491770560299E-2L;\n+///\n+@safe pure nothrow @nogc unittest\n+{\n+    import std.math.algebraic : fabs;\n \n-        // Special cases are the same as for log.\n-        if (isNaN(x))\n-            return x;\n-        if (isInfinity(x) && !signbit(x))\n-            return x;\n-        if (x == 0.0)\n-            return -real.infinity;\n-        if (x < 0.0)\n-            return real.nan;\n+    assert(fabs(log10(1000) - 3) < .000001);\n+}\n \n-        // Separate mantissa from exponent.\n-        // Note, frexp is used so that denormal numbers will be handled properly.\n-        real y, z;\n-        int exp;\n+private T log10Impl(T)(T x) @safe pure nothrow @nogc\n+{\n+    import std.math.constants : SQRT1_2;\n+    import std.math.algebraic : poly;\n+    import std.math.traits : isNaN, isInfinity, signbit;\n \n-        x = frexp(x, exp);\n+    alias coeffs = LogCoeffs!T;\n \n-        // Logarithm using log(x) = z + z^^3 R(z) / S(z),\n-        // where z = 2(x - 1)/(x + 1)\n-        if ((exp > 2) || (exp < -2))\n-        {\n-            if (x < SQRT1_2)\n-            {   // 2(2x - 1)/(2x + 1)\n-                exp -= 1;\n-                z = x - 0.5;\n-                y = 0.5 * z + 0.5;\n-            }\n-            else\n-            {   // 2(x - 1)/(x + 1)\n-                z = x - 0.5;\n-                z -= 0.5;\n-                y = 0.5 * x  + 0.5;\n-            }\n-            x = z / y;\n-            z = x * x;\n-            y = x * (z * poly(z, logCoeffsR) / poly(z, logCoeffsS));\n-            goto Ldone;\n-        }\n+    // log10(2) split into two parts.\n+    enum T L102A =  0.3125L;\n+    enum T L102B = -1.14700043360188047862611052755069732318101185E-2L;\n+\n+    // log10(e) split into two parts.\n+    enum T L10EA =  0.5L;\n+    enum T L10EB = -6.570551809674817234887108108339491770560299E-2L;\n+\n+    // Special cases are the same as for log.\n+    if (isNaN(x))\n+        return x;\n+    if (isInfinity(x) && !signbit(x))\n+        return x;\n+    if (x == 0.0)\n+        return -T.infinity;\n+    if (x < 0.0)\n+        return T.nan;\n+\n+    // Separate mantissa from exponent.\n+    // Note, frexp is used so that denormal numbers will be handled properly.\n+    T y, z;\n+    int exp;\n+\n+    x = frexp(x, exp);\n \n-        // Logarithm using log(1 + x) = x - .5x^^2 + x^^3 P(x) / Q(x)\n+    // Logarithm using log(x) = z + z^^3 R(z) / S(z),\n+    // where z = 2(x - 1)/(x + 1)\n+    if ((exp > 2) || (exp < -2))\n+    {\n         if (x < SQRT1_2)\n-        {\n+        {   // 2(2x - 1)/(2x + 1)\n             exp -= 1;\n-            x = 2.0 * x - 1.0;\n+            z = x - 0.5;\n+            y = 0.5 * z + 0.5;\n         }\n         else\n-            x = x - 1.0;\n-\n+        {   // 2(x - 1)/(x + 1)\n+            z = x - 0.5;\n+            z -= 0.5;\n+            y = 0.5 * x  + 0.5;\n+        }\n+        x = z / y;\n         z = x * x;\n-        y = x * (z * poly(x, logCoeffsP) / poly(x, logCoeffsQ));\n-        y = y - 0.5 * z;\n-\n-        // Multiply log of fraction by log10(e) and base 2 exponent by log10(2).\n-        // This sequence of operations is critical and it may be horribly\n-        // defeated by some compiler optimizers.\n-    Ldone:\n-        z = y * L10EB;\n-        z += x * L10EB;\n-        z += exp * L102B;\n-        z += y * L10EA;\n-        z += x * L10EA;\n-        z += exp * L102A;\n+        y = x * (z * poly(z, coeffs.logR) / poly(z, coeffs.logS));\n+        goto Ldone;\n+    }\n \n-        return z;\n+    // Logarithm using log(1 + x) = x - .5x^^2 + x^^3 P(x) / Q(x)\n+    if (x < SQRT1_2)\n+    {\n+        exp -= 1;\n+        x = 2.0 * x - 1.0;\n     }\n-}\n+    else\n+        x = x - 1.0;\n \n-///\n-@safe pure nothrow @nogc unittest\n-{\n-    import std.math.algebraic : fabs;\n+    z = x * x;\n+    y = x * (z * poly(x, coeffs.log10P) / poly(x, coeffs.log10Q));\n+    y = y - 0.5 * z;\n \n-    assert(fabs(log10(1000) - 3) < .000001);\n+    // Multiply log of fraction by log10(e) and base 2 exponent by log10(2).\n+    // This sequence of operations is critical and it may be horribly\n+    // defeated by some compiler optimizers.\n+Ldone:\n+    z = y * L10EB;\n+    z += x * L10EB;\n+    z += exp * L102B;\n+    z += y * L10EA;\n+    z += x * L10EA;\n+    z += exp * L102A;\n+\n+    return z;\n }\n \n /**\n@@ -3179,29 +3234,15 @@ real log10(real x) @safe pure nothrow @nogc\n  */\n real log1p(real x) @safe pure nothrow @nogc\n {\n-    import std.math.traits : isNaN, isInfinity, signbit;\n-    import std.math.constants : LN2;\n-\n     version (INLINE_YL2X)\n     {\n         // On x87, yl2xp1 is valid if and only if -0.5 <= lg(x) <= 0.5,\n         //    ie if -0.29 <= x <= 0.414\n+        import std.math.constants : LN2;\n         return (core.math.fabs(x) <= 0.25)  ? core.math.yl2xp1(x, LN2) : core.math.yl2x(x+1, LN2);\n     }\n     else\n-    {\n-        // Special cases.\n-        if (isNaN(x) || x == 0.0)\n-            return x;\n-        if (isInfinity(x) && !signbit(x))\n-            return x;\n-        if (x == -1.0)\n-            return -real.infinity;\n-        if (x < -1.0)\n-            return real.nan;\n-\n-        return log(x + 1.0);\n-    }\n+        return log1pImpl(x);\n }\n \n ///\n@@ -3220,6 +3261,23 @@ real log1p(real x) @safe pure nothrow @nogc\n     assert(log1p(real.infinity) == real.infinity);\n }\n \n+private T log1pImpl(T)(T x) @safe pure nothrow @nogc\n+{\n+    import std.math.traits : isNaN, isInfinity, signbit;\n+\n+    // Special cases.\n+    if (isNaN(x) || x == 0.0)\n+        return x;\n+    if (isInfinity(x) && !signbit(x))\n+        return x;\n+    if (x == -1.0)\n+        return -T.infinity;\n+    if (x < -1.0)\n+        return T.nan;\n+\n+    return logImpl(x + 1.0);\n+}\n+\n /***************************************\n  * Calculates the base-2 logarithm of x:\n  * $(SUB log, 2)x\n@@ -3233,78 +3291,10 @@ real log1p(real x) @safe pure nothrow @nogc\n  */\n real log2(real x) @safe pure nothrow @nogc\n {\n-    import std.math.traits : isNaN, isInfinity, signbit;\n-    import std.math.constants : SQRT1_2, LOG2E;\n-    import std.math.algebraic : poly;\n-\n     version (INLINE_YL2X)\n         return core.math.yl2x(x, 1.0L);\n     else\n-    {\n-        // Special cases are the same as for log.\n-        if (isNaN(x))\n-            return x;\n-        if (isInfinity(x) && !signbit(x))\n-            return x;\n-        if (x == 0.0)\n-            return -real.infinity;\n-        if (x < 0.0)\n-            return real.nan;\n-\n-        // Separate mantissa from exponent.\n-        // Note, frexp is used so that denormal numbers will be handled properly.\n-        real y, z;\n-        int exp;\n-\n-        x = frexp(x, exp);\n-\n-        // Logarithm using log(x) = z + z^^3 R(z) / S(z),\n-        // where z = 2(x - 1)/(x + 1)\n-        if ((exp > 2) || (exp < -2))\n-        {\n-            if (x < SQRT1_2)\n-            {   // 2(2x - 1)/(2x + 1)\n-                exp -= 1;\n-                z = x - 0.5;\n-                y = 0.5 * z + 0.5;\n-            }\n-            else\n-            {   // 2(x - 1)/(x + 1)\n-                z = x - 0.5;\n-                z -= 0.5;\n-                y = 0.5 * x  + 0.5;\n-            }\n-            x = z / y;\n-            z = x * x;\n-            y = x * (z * poly(z, logCoeffsR) / poly(z, logCoeffsS));\n-            goto Ldone;\n-        }\n-\n-        // Logarithm using log(1 + x) = x - .5x^^2 + x^^3 P(x) / Q(x)\n-        if (x < SQRT1_2)\n-        {\n-            exp -= 1;\n-            x = 2.0 * x - 1.0;\n-        }\n-        else\n-            x = x - 1.0;\n-\n-        z = x * x;\n-        y = x * (z * poly(x, logCoeffsP) / poly(x, logCoeffsQ));\n-        y = y - 0.5 * z;\n-\n-        // Multiply log of fraction by log10(e) and base 2 exponent by log10(2).\n-        // This sequence of operations is critical and it may be horribly\n-        // defeated by some compiler optimizers.\n-    Ldone:\n-        z = y * (LOG2E - 1.0);\n-        z += x * (LOG2E - 1.0);\n-        z += y;\n-        z += x;\n-        z += exp;\n-\n-        return z;\n-    }\n+        return log2Impl(x);\n }\n \n ///\n@@ -3323,6 +3313,79 @@ real log2(real x) @safe pure nothrow @nogc\n     assert(isClose(log2(1024.0L), 10, 1e-18));\n }\n \n+private T log2Impl(T)(T x) @safe pure nothrow @nogc\n+{\n+    import std.math.traits : isNaN, isInfinity, signbit;\n+    import std.math.constants : SQRT1_2, LOG2E;\n+    import std.math.algebraic : poly;\n+\n+    alias coeffs = LogCoeffs!T;\n+\n+    // Special cases are the same as for log.\n+    if (isNaN(x))\n+        return x;\n+    if (isInfinity(x) && !signbit(x))\n+        return x;\n+    if (x == 0.0)\n+        return -T.infinity;\n+    if (x < 0.0)\n+        return T.nan;\n+\n+    // Separate mantissa from exponent.\n+    // Note, frexp is used so that denormal numbers will be handled properly.\n+    T y, z;\n+    int exp;\n+\n+    x = frexp(x, exp);\n+\n+    // Logarithm using log(x) = z + z^^3 R(z) / S(z),\n+    // where z = 2(x - 1)/(x + 1)\n+    if ((exp > 2) || (exp < -2))\n+    {\n+        if (x < SQRT1_2)\n+        {   // 2(2x - 1)/(2x + 1)\n+            exp -= 1;\n+            z = x - 0.5;\n+            y = 0.5 * z + 0.5;\n+        }\n+        else\n+        {   // 2(x - 1)/(x + 1)\n+            z = x - 0.5;\n+            z -= 0.5;\n+            y = 0.5 * x  + 0.5;\n+        }\n+        x = z / y;\n+        z = x * x;\n+        y = x * (z * poly(z, coeffs.logR) / poly(z, coeffs.logS));\n+        goto Ldone;\n+    }\n+\n+    // Logarithm using log(1 + x) = x - .5x^^2 + x^^3 P(x) / Q(x)\n+    if (x < SQRT1_2)\n+    {\n+        exp -= 1;\n+        x = 2.0 * x - 1.0;\n+    }\n+    else\n+        x = x - 1.0;\n+\n+    z = x * x;\n+    y = x * (z * poly(x, coeffs.log2P) / poly(x, coeffs.log2Q));\n+    y = y - 0.5 * z;\n+\n+    // Multiply log of fraction by log10(e) and base 2 exponent by log10(2).\n+    // This sequence of operations is critical and it may be horribly\n+    // defeated by some compiler optimizers.\n+Ldone:\n+    z = y * (LOG2E - 1.0);\n+    z += x * (LOG2E - 1.0);\n+    z += y;\n+    z += x;\n+    z += exp;\n+\n+    return z;\n+}\n+\n /*****************************************\n  * Extracts the exponent of x as a signed integral value.\n  *\n@@ -3337,35 +3400,23 @@ real log2(real x) @safe pure nothrow @nogc\n  *      $(TR $(TD $(PLUSMN)0.0)      $(TD -$(INFIN)) $(TD yes) )\n  *      )\n  */\n-real logb(real x) @trusted nothrow @nogc\n+pragma(inline, true)\n+real logb(real x) @trusted pure nothrow @nogc\n {\n     version (InlineAsm_X87_MSVC)\n-    {\n-        version (X86_64)\n-        {\n-            asm pure nothrow @nogc\n-            {\n-                naked                       ;\n-                fld     real ptr [RCX]      ;\n-                fxtract                     ;\n-                fstp    ST(0)               ;\n-                ret                         ;\n-            }\n-        }\n-        else\n-        {\n-            asm pure nothrow @nogc\n-            {\n-                fld     x                   ;\n-                fxtract                     ;\n-                fstp    ST(0)               ;\n-            }\n-        }\n-    }\n+        return logbAsm(x);\n     else\n-        return core.stdc.math.logbl(x);\n+        return logbImpl(x);\n }\n \n+/// ditto\n+pragma(inline, true)\n+double logb(double x) @trusted pure nothrow @nogc { return logbImpl(x); }\n+\n+/// ditto\n+pragma(inline, true)\n+float logb(float x) @trusted pure nothrow @nogc { return logbImpl(x); }\n+\n ///\n @safe @nogc nothrow unittest\n {\n@@ -3377,6 +3428,83 @@ real logb(real x) @trusted nothrow @nogc\n     assert(logb(-real.infinity) == real.infinity);\n }\n \n+@safe @nogc nothrow unittest\n+{\n+    import std.meta : AliasSeq;\n+    import std.typecons : Tuple;\n+    import std.math.traits : isNaN;\n+    static foreach (F; AliasSeq!(float, double, real))\n+    {{\n+        alias T = Tuple!(F, F);\n+        T[17] vals =   // x, logb(x)\n+        [\n+            T(1.0          , 0          ),\n+            T(100.0        , 6          ),\n+            T(0.0          , -F.infinity),\n+            T(-0.0         , -F.infinity),\n+            T(1024         , 10         ),\n+            T(-2000        , 10         ),\n+            T(0x0.1p-127   , -131       ),\n+            T(0x0.01p-127  , -135       ),\n+            T(0x0.011p-127 , -135       ),\n+            T(F.nan        , F.nan      ),\n+            T(-F.nan       , F.nan      ),\n+            T(F.infinity   , F.infinity ),\n+            T(-F.infinity  , F.infinity ),\n+            T(F.min_normal , F.min_exp-1),\n+            T(-F.min_normal, F.min_exp-1),\n+            T(F.max        , F.max_exp-1),\n+            T(-F.max       , F.max_exp-1),\n+        ];\n+\n+        foreach (elem; vals)\n+        {\n+            if (isNaN(elem[1]))\n+                assert(isNaN(logb(elem[1])));\n+            else\n+                assert(logb(elem[0]) == elem[1]);\n+        }\n+    }}\n+}\n+\n+version (InlineAsm_X87_MSVC)\n+private T logbAsm(T)(T x) @trusted pure nothrow @nogc\n+{\n+    version (X86_64)\n+    {\n+        asm pure nothrow @nogc\n+        {\n+            naked                       ;\n+            fld     real ptr [RCX]      ;\n+            fxtract                     ;\n+            fstp    ST(0)               ;\n+            ret                         ;\n+        }\n+    }\n+    else\n+    {\n+        asm pure nothrow @nogc\n+        {\n+            fld     x                   ;\n+            fxtract                     ;\n+            fstp    ST(0)               ;\n+        }\n+    }\n+}\n+\n+private T logbImpl(T)(T x) @trusted pure nothrow @nogc\n+{\n+    import std.math.traits : isFinite;\n+\n+    // Handle special cases.\n+    if (!isFinite(x))\n+        return x * x;\n+    if (x == 0)\n+        return -1 / (x * x);\n+\n+    return ilogb(x);\n+}\n+\n /*************************************\n  * Efficiently calculates x * 2$(SUPERSCRIPT n).\n  *"}]}