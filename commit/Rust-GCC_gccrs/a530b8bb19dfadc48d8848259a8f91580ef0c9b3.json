{"sha": "a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUzMGI4YmIxOWRmYWRjNDhkODg0ODI1OWE4ZjkxNTgwZWYwYzliMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T07:50:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T07:50:46Z"}, "message": "[multiple changes]\n\n2013-07-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Attribute_Renaming): Treat 'Img as an attribute\n\tthat can be renamed as a function.\n\n2013-07-08  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.ads: Document target dependency: FIONBIO may or may not\n\tbe inherited from listening socket by accepted socket.\n\n2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Apply_Accessibility_Check): Do not deallocate the object\n\ton targets that can't deallocate.\n\nFrom-SVN: r200758", "tree": {"sha": "381b3fddc46c387a4c01910a629fef8c6e0a0ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381b3fddc46c387a4c01910a629fef8c6e0a0ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/comments", "author": null, "committer": null, "parents": [{"sha": "a35017dc7c9a53c40a1ee4bf1db269228e0faebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35017dc7c9a53c40a1ee4bf1db269228e0faebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a35017dc7c9a53c40a1ee4bf1db269228e0faebf"}], "stats": {"total": 143, "additions": 95, "deletions": 48}, "files": [{"sha": "9f72a459e925a062a588bf159686fffe83d39894", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "patch": "@@ -1,3 +1,18 @@\n+2013-07-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Attribute_Renaming): Treat 'Img as an attribute\n+\tthat can be renamed as a function.\n+\n+2013-07-08  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.ads: Document target dependency: FIONBIO may or may not\n+\tbe inherited from listening socket by accepted socket.\n+\n+2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Apply_Accessibility_Check): Do not deallocate the object\n+\ton targets that can't deallocate.\n+\n 2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch3.adb (Freeze_Type): Generate a"}, {"sha": "f9c6fd81f7b12cae84bbcf26d3b729a2dded1745", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "patch": "@@ -751,47 +751,66 @@ package body Exp_Ch4 is\n \n             Stmts := New_List;\n \n-            --  Create an explicit free statement to clean up the allocated\n-            --  object in case the accessibility check fails. Generate:\n-\n-            --    Free (Obj_Ref);\n-\n-            Free_Stmt := Make_Free_Statement (Loc, New_Copy (Obj_Ref));\n-            Set_Storage_Pool (Free_Stmt, Pool_Id);\n-\n-            Append_To (Stmts, Free_Stmt);\n-\n-            --  Finalize the object (if applicable), but wrap the call inside\n-            --  a block to ensure that the object would still be deallocated in\n-            --  case the finalization fails. Generate:\n-\n-            --    begin\n-            --       [Deep_]Finalize (Obj_Ref.all);\n-            --    exception\n-            --       when others =>\n-            --          Free (Obj_Ref);\n-            --          raise;\n-            --    end;\n-\n-            if Needs_Finalization (DesigT) then\n-               Prepend_To (Stmts,\n-                 Make_Block_Statement (Loc,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => New_List (\n-                         Make_Final_Call (\n-                           Obj_Ref =>\n-                             Make_Explicit_Dereference (Loc,\n-                               Prefix => New_Copy (Obj_Ref)),\n-                           Typ     => DesigT)),\n-\n-                     Exception_Handlers => New_List (\n-                       Make_Exception_Handler (Loc,\n-                         Exception_Choices => New_List (\n-                           Make_Others_Choice (Loc)),\n-                         Statements        => New_List (\n-                           New_Copy_Tree (Free_Stmt),\n-                           Make_Raise_Statement (Loc)))))));\n+            --  If the target does not support allocation/deallocation, simply\n+            --  finalize the object (if applicable). Generate:\n+\n+            --    [Deep_]Finalize (Obj_Ref.all);\n+\n+            if Restriction_Active (No_Implicit_Heap_Allocations) then\n+               if Needs_Finalization (DesigT) then\n+                  Append_To (Stmts,\n+                    Make_Final_Call (\n+                      Obj_Ref =>\n+                        Make_Explicit_Dereference (Loc, New_Copy (Obj_Ref)),\n+                      Typ     => DesigT));\n+               end if;\n+\n+            --  Finalize (if applicable) and deallocate the object in case the\n+            --  accessibility check fails.\n+\n+            else\n+               --  Create an explicit free statement to clean up the allocated\n+               --  object in case the accessibility check fails. Generate:\n+\n+               --    Free (Obj_Ref);\n+\n+               Free_Stmt := Make_Free_Statement (Loc, New_Copy (Obj_Ref));\n+               Set_Storage_Pool (Free_Stmt, Pool_Id);\n+\n+               Append_To (Stmts, Free_Stmt);\n+\n+               --  Finalize the object (if applicable), but wrap the call\n+               --  inside a block to ensure that the object would still be\n+               --  deallocated in case the finalization fails. Generate:\n+\n+               --    begin\n+               --       [Deep_]Finalize (Obj_Ref.all);\n+               --    exception\n+               --       when others =>\n+               --          Free (Obj_Ref);\n+               --          raise;\n+               --    end;\n+\n+               if Needs_Finalization (DesigT) then\n+                  Prepend_To (Stmts,\n+                    Make_Block_Statement (Loc,\n+                      Handled_Statement_Sequence =>\n+                        Make_Handled_Sequence_Of_Statements (Loc,\n+                          Statements => New_List (\n+                            Make_Final_Call (\n+                              Obj_Ref =>\n+                                Make_Explicit_Dereference (Loc,\n+                                  Prefix => New_Copy (Obj_Ref)),\n+                              Typ     => DesigT)),\n+\n+                        Exception_Handlers => New_List (\n+                          Make_Exception_Handler (Loc,\n+                            Exception_Choices => New_List (\n+                              Make_Others_Choice (Loc)),\n+                            Statements        => New_List (\n+                              New_Copy_Tree (Free_Stmt),\n+                              Make_Raise_Statement (Loc)))))));\n+               end if;\n             end if;\n \n             --  Signal the accessibility failure through a Program_Error"}, {"sha": "06add2c63a9f5305c447e9acb5abb9cfeb3744c0", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "patch": "@@ -816,7 +816,8 @@ package GNAT.Sockets is\n    --  connections, creates a new connected socket with mostly the same\n    --  properties as Server, and allocates a new socket. The returned Address\n    --  is filled in with the address of the connection. Raises Socket_Error on\n-   --  error.\n+   --  error. Note: if Server is a non-blocking socket, whether or not this\n+   --  aspect is inherited by Socket is platform-dependent.\n \n    procedure Accept_Socket\n      (Server   : Socket_Type;"}, {"sha": "ef9da8254ee8256c58d09ef7dc61d9e76761ccae", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a530b8bb19dfadc48d8848259a8f91580ef0c9b3/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "patch": "@@ -3318,12 +3318,14 @@ package body Sem_Ch8 is\n \n       --  This procedure is called in the context of subprogram renaming, and\n       --  thus the attribute must be one that is a subprogram. All of those\n-      --  have at least one formal parameter, with the singular exception of\n-      --  AST_Entry (which is a real oddity, it is odd that this can be renamed\n-      --  at all!)\n+      --  have at least one formal parameter, with the exceptions of AST_Entry\n+      --  (which is a real oddity, it is odd that this can be renamed at all!)\n+      --  and the GNAT attribute 'Img, which GNAT treats as renameable.\n \n       if not Is_Non_Empty_List (Parameter_Specifications (Spec)) then\n-         if Aname /= Name_AST_Entry then\n+         if Aname /= Name_AST_Entry\n+           and then Aname /= Name_Img\n+         then\n             Error_Msg_N\n               (\"subprogram renaming an attribute must have formals\", N);\n             return;\n@@ -3493,10 +3495,20 @@ package body Sem_Ch8 is\n         and then Etype (Nam) /= RTE (RE_AST_Handler)\n       then\n          declare\n-            P : constant Entity_Id := Prefix (Nam);\n+            P : constant Node_Id := Prefix (Nam);\n \n          begin\n-            Find_Type (P);\n+            --  The prefix of 'Img is an object that is evaluated for\n+            --  each call of the function that renames it.\n+\n+            if Aname = Name_Img then\n+               Preanalyze_And_Resolve (P);\n+\n+            --  For all other attribute renamings, the prefix is a subtype.\n+\n+            else\n+               Find_Type (P);\n+            end if;\n \n             if Is_Tagged_Type (Etype (P)) then\n                Ensure_Freeze_Node (Etype (P));"}]}