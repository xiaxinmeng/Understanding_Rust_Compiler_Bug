{"sha": "adcfa68154e6e0bd4ebb0787871a38425628a2ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRjZmE2ODE1NGU2ZTBiZDRlYmIwNzg3ODcxYTM4NDI1NjI4YTJlZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-30T12:27:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-30T12:27:50Z"}, "message": "(handle_directive, do_line, skip_if_group): Use the phrase `preprocessing directive' consistently.\n\n(handle_directive, do_line, skip_if_group): Use the phrase `preprocessing\ndirective' consistently.\n(output_line_directive): Renamed from output_line_command.\n(no_line_directives): Renamed from no_line_commands.\n\nFrom-SVN: r9258", "tree": {"sha": "6808e3c18c5d68f0311578b53bdd6b7951b0f8e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6808e3c18c5d68f0311578b53bdd6b7951b0f8e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adcfa68154e6e0bd4ebb0787871a38425628a2ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adcfa68154e6e0bd4ebb0787871a38425628a2ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adcfa68154e6e0bd4ebb0787871a38425628a2ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adcfa68154e6e0bd4ebb0787871a38425628a2ef/comments", "author": null, "committer": null, "parents": [{"sha": "3be5fb2398c72907ddf4ad7df062694c8d08b65c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3be5fb2398c72907ddf4ad7df062694c8d08b65c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3be5fb2398c72907ddf4ad7df062694c8d08b65c"}], "stats": {"total": 196, "additions": 96, "deletions": 100}, "files": [{"sha": "54f2cd1b9cb451550c355f8e4d46f769a34fa47f", "filename": "gcc/cccp.c", "status": "modified", "additions": 96, "deletions": 100, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adcfa68154e6e0bd4ebb0787871a38425628a2ef/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adcfa68154e6e0bd4ebb0787871a38425628a2ef/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=adcfa68154e6e0bd4ebb0787871a38425628a2ef", "patch": "@@ -305,9 +305,9 @@ static void macroexpand ();\n static void dump_all_macros ();\n static void conditional_skip ();\n static void skip_if_group ();\n-static void output_line_command ();\n+static void output_line_directive ();\n \n-/* Last arg to output_line_command.  */\n+/* Last arg to output_line_directive.  */\n enum file_change_code {same_file, enter_file, leave_file};\n \n static int grow_outbuf ();\n@@ -390,7 +390,7 @@ static int print_include_names = 0;\n \n /* Nonzero means don't output line number information.  */\n \n-static int no_line_commands;\n+static int no_line_directives;\n \n /* Nonzero means output the text in failing conditionals,\n    inside #failed ... #endfailed.  */\n@@ -504,7 +504,7 @@ static int multiline_string_line = 0;\n #define INPUT_STACK_MAX 400\n static struct file_buf {\n   char *fname;\n-  /* Filename specified with #line command.  */\n+  /* Filename specified with #line directive.  */\n   char *nominal_fname;\n   /* Record where in the search path this file was found.\n      For #include_next.  */\n@@ -763,7 +763,7 @@ static char rest_extension[] = \"...\";\n #define REST_EXTENSION_LENGTH\t(sizeof (rest_extension) - 1)\n \n /* The structure of a node in the hash table.  The hash table\n-   has entries for all tokens defined by #define commands (type T_MACRO),\n+   has entries for all tokens defined by #define directives (type T_MACRO),\n    plus some special tokens like __LINE__ (these each have their own\n    type, and the appropriate code is run when that type of node is seen.\n    It does not contain control words like \"#define\", which are recognized\n@@ -1179,7 +1179,7 @@ main (argc, argv)\n   initialize_char_syntax ();\n   dollars_in_ident = DOLLARS_IN_IDENTIFIERS > 0;\n \n-  no_line_commands = 0;\n+  no_line_directives = 0;\n   no_trigraphs = 1;\n   dump_macros = dump_none;\n   no_output = 0;\n@@ -1570,7 +1570,7 @@ main (argc, argv)\n \tbreak;\n \n       case 'P':\n-\tno_line_commands = 1;\n+\tno_line_directives = 1;\n \tbreak;\n \n       case '$':\t\t\t/* Don't include $ in identifiers.  */\n@@ -1692,7 +1692,7 @@ main (argc, argv)\n \tif (*p != 0)\n \t  *p++= 0;\n \tif (debug_output)\n-\t  output_line_command (fp, &outbuf, 0, same_file);\n+\t  output_line_directive (fp, &outbuf, 0, same_file);\n \tmake_definition (q, &outbuf);\n \twhile (*p == ' ' || *p == '\\t')\n \t  p++;\n@@ -1752,12 +1752,12 @@ main (argc, argv)\n   for (i = 1; i < argc; i++) {\n     if (pend_undefs[i]) {\n       if (debug_output)\n-        output_line_command (fp, &outbuf, 0, same_file);\n+        output_line_directive (fp, &outbuf, 0, same_file);\n       make_undef (pend_undefs[i], &outbuf);\n     }\n     if (pend_defs[i]) {\n       if (debug_output)\n-        output_line_command (fp, &outbuf, 0, same_file);\n+        output_line_directive (fp, &outbuf, 0, same_file);\n       make_definition (pend_defs[i], &outbuf);\n     }\n     if (pend_assertions[i])\n@@ -2102,7 +2102,7 @@ main (argc, argv)\n   else if (! freopen (out_fname, \"w\", stdout))\n     pfatal_with_name (out_fname);\n \n-  output_line_command (fp, &outbuf, 0, same_file);\n+  output_line_directive (fp, &outbuf, 0, same_file);\n \n   /* Scan the -include files before the main input.  */\n \n@@ -2613,7 +2613,7 @@ do { ip = &instack[indepth];\t\t\\\n       }\n \n       /* If this is expanding a macro definition, don't recognize\n-\t preprocessor directives.  */\n+\t preprocessing directives.  */\n       if (ip->macro != 0)\n \tgoto randomchar;\n       /* If this is expand_into_temp_buffer,\n@@ -2891,7 +2891,7 @@ do { ip = &instack[indepth];\t\t\\\n \t     this branch.  We need #line because the #pragma's newline always\n \t     messes up the line count.  */\n \t  op->bufp = obp;\n-\t  output_line_command (ip, op, 0, same_file);\n+\t  output_line_directive (ip, op, 0, same_file);\n \t  check_expand (op, limit - ibp + 2);\n \t  obp = op->bufp;\n \t  *(obp++) = '/';\n@@ -3071,7 +3071,7 @@ do { ip = &instack[indepth];\t\t\\\n       ++op->lineno;\n       if (ip->lineno != op->lineno) {\n \top->bufp = obp;\n-\toutput_line_command (ip, op, 1, same_file);\n+\toutput_line_directive (ip, op, 1, same_file);\n \tcheck_expand (op, limit - ibp);\n \tobp = op->bufp;\n       }\n@@ -3474,12 +3474,12 @@ expand_to_temp_buffer (buf, limit, output_marks, assertions)\n \f\n /*\n  * Process a # directive.  Expects IP->bufp to point after the '#', as in\n- * `#define foo bar'.  Passes to the command handler\n+ * `#define foo bar'.  Passes to the directive handler\n  * (do_define, do_include, etc.): the addresses of the 1st and\n- * last chars of the command (starting immediately after the #\n- * keyword), plus op and the keyword table pointer.  If the command\n+ * last chars of the directive (starting immediately after the #\n+ * keyword), plus op and the keyword table pointer.  If the directive\n  * contains comments it is copied into a temporary buffer sans comments\n- * and the temporary buffer is passed to the command handler instead.\n+ * and the temporary buffer is passed to the directive handler instead.\n  * Likewise for backslash-newlines.\n  *\n  * Returns nonzero if this was a known # directive.\n@@ -3495,9 +3495,9 @@ handle_directive (ip, op)\n   register int ident_length;\n   U_CHAR *resume_p;\n \n-  /* Nonzero means we must copy the entire command\n+  /* Nonzero means we must copy the entire directive\n      to get rid of comments or backslash-newlines.  */\n-  int copy_command = 0;\n+  int copy_directive = 0;\n \n   U_CHAR *ident, *after_ident;\n \n@@ -3573,13 +3573,13 @@ handle_directive (ip, op)\n       while (*p == '#' || is_hor_space[*p]) p++;\n       if (*p == '\\n') {\n \tif (pedantic && !lang_asm)\n-\t  warning (\"invalid preprocessor directive\");\n+\t  warning (\"invalid preprocessing directive\");\n \treturn 0;\n       }\n     }\n \n     if (!lang_asm)\n-      error (\"invalid preprocessor directive name\");\n+      error (\"invalid preprocessing directive name\");\n \n     return 0;\n   }\n@@ -3610,9 +3610,9 @@ handle_directive (ip, op)\n       if (kt->type == T_IMPORT && !(objc || lookup (\"__NeXT__\", -1, -1)))\n \tbreak;\n \n-      /* Find the end of this command (first newline not backslashed\n+      /* Find the end of this directive (first newline not backslashed\n \t and not in a string or comment).\n-\t Set COPY_COMMAND if the command must be copied\n+\t Set COPY_DIRECTIVE if the directive must be copied\n \t (it contains a backslash-newline or a comment).  */\n \n       buf = bp = after_ident;\n@@ -3623,7 +3623,7 @@ handle_directive (ip, op)\n \t  if (bp < limit) {\n \t    if (*bp == '\\n') {\n \t      ip->lineno++;\n-\t      copy_command = 1;\n+\t      copy_directive = 1;\n \t      bp++;\n \t    } else if (traditional)\n \t      bp++;\n@@ -3632,7 +3632,7 @@ handle_directive (ip, op)\n \n \tcase '\\'':\n \tcase '\\\"':\n-\t  bp = skip_quoted_string (bp - 1, limit, ip->lineno, &ip->lineno, &copy_command, &unterminated);\n+\t  bp = skip_quoted_string (bp - 1, limit, ip->lineno, &ip->lineno, &copy_directive, &unterminated);\n \t  /* Don't bother calling the directive if we already got an error\n \t     message due to unterminated string.  Skip everything and pretend\n \t     we called the directive.  */\n@@ -3654,7 +3654,7 @@ handle_directive (ip, op)\n \t  while (bp < limit && *bp != '>' && *bp != '\\n') {\n \t    if (*bp == '\\\\' && bp[1] == '\\n') {\n \t      ip->lineno++;\n-\t      copy_command = 1;\n+\t      copy_directive = 1;\n \t      bp++;\n \t    }\n \t    bp++;\n@@ -3670,15 +3670,15 @@ handle_directive (ip, op)\n \t    ip->bufp = bp + 1;\n \t    skip_to_end_of_comment (ip, &ip->lineno, 0);\n \t    bp = ip->bufp;\n-\t    /* No need to copy the command because of a comment at the end;\n+\t    /* No need to copy the directive because of a comment at the end;\n \t       just don't include the comment in the directive.  */\n \t    if (bp == limit || *bp == '\\n') {\n \t      bp = obp;\n \t      goto endloop1;\n \t    }\n \t    /* Don't remove the comments if -traditional.  */\n \t    if (! keep_comments)\n-\t      copy_command++;\n+\t      copy_directive++;\n \t  }\n \t  break;\n \n@@ -3732,11 +3732,11 @@ handle_directive (ip, op)\n \talready_output = &junk;\n       }\t\t\t\t/* Don't we need a newline or #line? */\n \n-      if (copy_command) {\n+      if (copy_directive) {\n \tregister U_CHAR *xp = buf;\n-\t/* Need to copy entire command into temp buffer before dispatching */\n+\t/* Need to copy entire directive into temp buffer before dispatching */\n \n-\tcp = (U_CHAR *) alloca (bp - buf + 5); /* room for cmd plus\n+\tcp = (U_CHAR *) alloca (bp - buf + 5); /* room for directive plus\n \t\t\t\t\t\t  some slop */\n \tbuf = cp;\n \n@@ -3803,7 +3803,7 @@ handle_directive (ip, op)\n \t    if (*xp == '*'\n \t\t|| (cplusplus_comments && *xp == '/')) {\n \t      ip->bufp = xp + 1;\n-\t      /* If we already copied the command through,\n+\t      /* If we already copied the directive through,\n \t\t already_output != 0 prevents outputting comment now.  */\n \t      skip_to_end_of_comment (ip, already_output, 0);\n \t      if (keep_comments)\n@@ -3864,11 +3864,11 @@ handle_directive (ip, op)\n \t}\n       }\t\t\t\t/* Don't we need a newline or #line? */\n \n-      /* Call the appropriate command handler.  buf now points to\n+      /* Call the appropriate directive handler.  buf now points to\n \t either the appropriate place in the input buffer, or to\n \t the temp buffer if it was necessary to make one.  cp\n \t points to the first char after the contents of the (possibly\n-\t copied) command, in either case. */\n+\t copied) directive, in either case. */\n       (*kt->func) (buf, cp, op, kt);\n       check_expand (op, ip->length - (ip->bufp - ip->buf));\n \n@@ -4893,7 +4893,7 @@ finclude (f, fname, op, system_header_p, dirptr)\n   if (!no_trigraphs)\n     trigraph_pcp (fp);\n \n-  output_line_command (fp, op, 0, enter_file);\n+  output_line_directive (fp, op, 0, enter_file);\n   rescan (op, 0);\n \n   if (missing_newline)\n@@ -4904,7 +4904,7 @@ finclude (f, fname, op, system_header_p, dirptr)\n \n   indepth--;\n   input_file_stack_tick++;\n-  output_line_command (&instack[indepth], op, 0, leave_file);\n+  output_line_directive (&instack[indepth], op, 0, leave_file);\n   free (fp->buf);\n   return;\n \n@@ -5267,10 +5267,10 @@ pcfinclude (buf, limit, name, op)\n \t  str->writeflag = 1;\n       }\n   }\n-  /* This output_line_command serves to switch us back to the current\n+  /* This output_line_directive serves to switch us back to the current\n      input file in case some of these strings get output (which will \n-     result in line commands for the header file being output). */\n-  output_line_command (&instack[indepth], op, 0, enter_file);\n+     result in line directives for the header file being output). */\n+  output_line_directive (&instack[indepth], op, 0, enter_file);\n }\n \n /* Called from rescan when it hits a key for strings.  Mark them all */\n@@ -5293,8 +5293,8 @@ write_output ()\n {\n   STRINGDEF *next_string;\n   U_CHAR *cur_buf_loc;\n-  int line_command_len = 80;\n-  char *line_command = xmalloc (line_command_len);\n+  int line_directive_len = 80;\n+  char *line_directive = xmalloc (line_directive_len);\n   int len;\n \n   /* In each run through the loop, either cur_buf_loc == */\n@@ -5309,14 +5309,14 @@ write_output ()\n \t&& cur_buf_loc - outbuf.buf == next_string->output_mark) {\n       if (next_string->writeflag) {\n \tlen = 4 * strlen (next_string->filename) + 32;\n-\twhile (len > line_command_len)\n-\t  line_command = xrealloc (line_command, \n-\t\t\t\t   line_command_len *= 2);\n-\tsprintf (line_command, \"\\n# %d \", next_string->lineno);\n-\tstrcpy (quote_string (line_command + strlen (line_command),\n+\twhile (len > line_directive_len)\n+\t  line_directive = xrealloc (line_directive, \n+\t\t\t\t     line_directive_len *= 2);\n+\tsprintf (line_directive, \"\\n# %d \", next_string->lineno);\n+\tstrcpy (quote_string (line_directive + strlen (line_directive),\n \t\t              next_string->filename),\n \t\t\"\\n\");\n-\tsafe_write (fileno (stdout), line_command, strlen (line_command));\n+\tsafe_write (fileno (stdout), line_directive, strlen (line_directive));\n \tsafe_write (fileno (stdout), next_string->contents, next_string->len);\n       }\t      \n       next_string = next_string->chain;\n@@ -5331,7 +5331,7 @@ write_output ()\n       cur_buf_loc += len;\n     }\n   }\n-  free (line_command);\n+  free (line_directive);\n }\n \n /* Pass a directive through to the output file.\n@@ -5559,8 +5559,8 @@ create_definition (buf, limit, op)\n   return mdef;\n }\n  \n-/* Process a #define command.\n-BUF points to the contents of the #define command, as a contiguous string.\n+/* Process a #define directive.\n+BUF points to the contents of the #define directive, as a contiguous string.\n LIMIT points to the first character past the end of the definition.\n KEYWORD is the keyword-table entry for #define.  */\n \n@@ -5573,7 +5573,7 @@ do_define (buf, limit, op, keyword)\n   int hashcode;\n   MACRODEF mdef;\n \n-  /* If this is a precompiler run (with -pcp) pass thru #define commands.  */\n+  /* If this is a precompiler run (with -pcp) pass thru #define directives.  */\n   if (pcp_outfile && op)\n     pass_thru_directive (buf, limit, op, keyword);\n \n@@ -6458,7 +6458,7 @@ delete_assertion (hp)\n }\n \f\n /*\n- * interpret #line command.  Remembers previously seen fnames\n+ * interpret #line directive.  Remembers previously seen fnames\n  * in its very own hash table.\n  */\n #define FNAME_HASHSIZE 37\n@@ -6483,7 +6483,7 @@ do_line (buf, limit, op, keyword)\n   SKIP_WHITE_SPACE (bp);\n \n   if (!isdigit (*bp)) {\n-    error (\"invalid format `#line' command\");\n+    error (\"invalid format `#line' directive\");\n     return 0;\n   }\n \n@@ -6494,15 +6494,15 @@ do_line (buf, limit, op, keyword)\n \n   /* NEW_LINENO is one less than the actual line number here.  */\n   if (pedantic && new_lineno < 0)\n-    pedwarn (\"line number out of range in `#line' command\");\n+    pedwarn (\"line number out of range in `#line' directive\");\n \n   /* skip over the line number.  */\n   while (isdigit (*bp))\n     bp++;\n \n #if 0 /* #line 10\"foo.c\" is supposed to be allowed.  */\n   if (*bp && !is_space[*bp]) {\n-    error (\"invalid format `#line' command\");\n+    error (\"invalid format `#line' directive\");\n     return;\n   }\n #endif\n@@ -6523,7 +6523,7 @@ do_line (buf, limit, op, keyword)\n     for (;;)\n       switch ((*p++ = *bp++)) {\n       case '\\0':\n-\terror (\"invalid format `#line' command\");\n+\terror (\"invalid format `#line' directive\");\n \treturn 0;\n \n       case '\\\\':\n@@ -6548,7 +6548,7 @@ do_line (buf, limit, op, keyword)\n     SKIP_WHITE_SPACE (bp);\n     if (*bp) {\n       if (pedantic)\n-\tpedwarn (\"garbage at end of `#line' command\");\n+\tpedwarn (\"garbage at end of `#line' directive\");\n       if (*bp == '1')\n \tfile_change = enter_file;\n       else if (*bp == '2')\n@@ -6558,7 +6558,7 @@ do_line (buf, limit, op, keyword)\n       else if (*bp == '4')\n \tip->system_header_p = 2;\n       else {\n-\terror (\"invalid format `#line' command\");\n+\terror (\"invalid format `#line' directive\");\n \treturn 0;\n       }\n \n@@ -6575,7 +6575,7 @@ do_line (buf, limit, op, keyword)\n \tSKIP_WHITE_SPACE (bp);\n       }\n       if (*bp) {\n-\terror (\"invalid format `#line' command\");\n+\terror (\"invalid format `#line' directive\");\n \treturn 0;\n       }\n     }\n@@ -6599,12 +6599,12 @@ do_line (buf, limit, op, keyword)\n       bcopy (fname, hp->value.cpval, fname_length);\n     }\n   } else if (*bp) {\n-    error (\"invalid format `#line' command\");\n+    error (\"invalid format `#line' directive\");\n     return 0;\n   }\n \n   ip->lineno = new_lineno;\n-  output_line_command (ip, op, 0, file_change);\n+  output_line_directive (ip, op, 0, file_change);\n   check_expand (op, ip->length - (ip->bufp - ip->buf));\n   return 0;\n }\n@@ -6625,7 +6625,7 @@ do_undef (buf, limit, op, keyword)\n   HASHNODE *hp;\n   U_CHAR *orig_buf = buf;\n \n-  /* If this is a precompiler run (with -pcp) pass thru #undef commands.  */\n+  /* If this is a precompiler run (with -pcp) pass thru #undef directives.  */\n   if (pcp_outfile && op)\n     pass_thru_directive (buf, limit, op, keyword);\n \n@@ -6634,7 +6634,7 @@ do_undef (buf, limit, op, keyword)\n \n   while ((hp = lookup (buf, sym_length, -1)) != NULL) {\n     /* If we are generating additional info for debugging (with -g) we\n-       need to pass through all effective #undef commands.  */\n+       need to pass through all effective #undef directives.  */\n     if (debug_output && op)\n       pass_thru_directive (orig_buf, limit, op, keyword);\n     if (hp->type != T_MACRO)\n@@ -6835,11 +6835,11 @@ do_sccs ()\n }\n \f\n /*\n- * handle #if command by\n+ * handle #if directive by\n  *   1) inserting special `defined' keyword into the hash table\n  *\tthat gets turned into 0 or 1 by special_symbol (thus,\n  *\tif the luser has a symbol called `defined' already, it won't\n- *      work inside the #if command)\n+ *      work inside the #if directive)\n  *   2) rescan the input into a temporary output buffer\n  *   3) pass the output buffer to the yacc parser and collect a value\n  *   4) clean up the mess left from steps 1 and 2.\n@@ -6898,7 +6898,7 @@ do_elif (buf, limit, op, keyword)\n       skip_if_group (ip, 0, op);\n     else {\n       ++if_stack->if_succeeded;\t/* continue processing input */\n-      output_line_command (ip, op, 1, same_file);\n+      output_line_directive (ip, op, 1, same_file);\n     }\n   }\n   return 0;\n@@ -7054,7 +7054,7 @@ conditional_skip (ip, skip, type, control_macro, op)\n     return;\n   } else {\n     ++if_stack->if_succeeded;\n-    output_line_command (ip, &outbuf, 1, same_file);\n+    output_line_directive (ip, &outbuf, 1, same_file);\n   }\n }\n \n@@ -7093,7 +7093,7 @@ skip_if_group (ip, any, op)\n     bcopy (ptr, (char *) op->bufp, len);\n     op->bufp += len;\n     op->lineno++;\n-    output_line_command (ip, op, 1, 0);\n+    output_line_directive (ip, op, 1, 0);\n   }\n \n   while (bp < endb) {\n@@ -7248,13 +7248,13 @@ skip_if_group (ip, any, op)\n \t  while (*p == '#' || is_hor_space[*p]) p++;\n \t  if (*p == '\\n') {\n \t    if (pedantic && !lang_asm)\n-\t      pedwarn (\"invalid preprocessor directive\");\n+\t      pedwarn (\"invalid preprocessing directive\");\n \t    continue;\n \t  }\n \t}\n \n \tif (!lang_asm && pedantic)\n-\t  pedwarn (\"invalid preprocessor directive name\");\n+\t  pedwarn (\"invalid preprocessing directive name\");\n \tcontinue;\n       }\n \n@@ -7306,7 +7306,7 @@ skip_if_group (ip, any, op)\n       }\n       /* Don't let erroneous code go by.  */\n       if (kt->length < 0 && !lang_asm && pedantic)\n-\tpedwarn (\"invalid preprocessor directive name\");\n+\tpedwarn (\"invalid preprocessing directive name\");\n     }\n   }\n \n@@ -7380,13 +7380,13 @@ do_else (buf, limit, op, keyword)\n     skip_if_group (ip, 0, op);\n   else {\n     ++if_stack->if_succeeded;\t/* continue processing input */\n-    output_line_command (ip, op, 1, same_file);\n+    output_line_directive (ip, op, 1, same_file);\n   }\n   return 0;\n }\n \n /*\n- * unstack after #endif command\n+ * unstack after #endif directive\n  */\n \n static int\n@@ -7442,14 +7442,14 @@ do_endif (buf, limit, op, keyword)\n     fail: ;\n     }\n     free (temp);\n-    output_line_command (&instack[indepth], op, 1, same_file);\n+    output_line_directive (&instack[indepth], op, 1, same_file);\n   }\n   return 0;\n }\n \n /* When an #else or #endif is found while skipping failed conditional,\n    if -pedantic was specified, this is called to warn about text after\n-   the command name.  P points to the first char after the command name.  */\n+   the directive name.  P points to the first char after the directive name.  */\n \n static void\n validate_else (p)\n@@ -7758,23 +7758,23 @@ skip_paren_group (ip)\n }\n \f\n /*\n- * write out a #line command, for instance, after an #include file.\n+ * write out a #line directive, for instance, after an #include file.\n  * If CONDITIONAL is nonzero, we can omit the #line if it would\n  * appear to be a no-op, and we can output a few newlines instead\n  * if we want to increase the line number by a small amount.\n  * FILE_CHANGE says whether we are entering a file, leaving, or neither.\n  */\n \n static void\n-output_line_command (ip, op, conditional, file_change)\n+output_line_directive (ip, op, conditional, file_change)\n      FILE_BUF *ip, *op;\n      int conditional;\n      enum file_change_code file_change;\n {\n   int len;\n-  char *line_cmd_buf, *line_end;\n+  char *line_directive_buf, *line_end;\n \n-  if (no_line_commands\n+  if (no_line_directives\n       || ip->fname == NULL\n       || no_output) {\n     op->lineno = ip->lineno;\n@@ -7786,7 +7786,7 @@ output_line_command (ip, op, conditional, file_change)\n       return;\n \n     /* If the inherited line number is a little too small,\n-       output some newlines instead of a #line command.  */\n+       output some newlines instead of a #line directive.  */\n     if (ip->lineno > op->lineno && ip->lineno < op->lineno + 8) {\n       check_expand (op, 10);\n       while (ip->lineno > op->lineno) {\n@@ -7804,13 +7804,9 @@ output_line_command (ip, op, conditional, file_change)\n     ip->bufp++;\n   }\n \n-  line_cmd_buf = (char *) alloca (4 * strlen (ip->nominal_fname) + 100);\n-#ifdef OUTPUT_LINE_COMMANDS\n-  sprintf (line_cmd_buf, \"#line %d \", ip->lineno);\n-#else\n-  sprintf (line_cmd_buf, \"# %d \", ip->lineno);\n-#endif\n-  line_end = quote_string (line_cmd_buf + strlen (line_cmd_buf),\n+  line_directive_buf = (char *) alloca (4 * strlen (ip->nominal_fname) + 100);\n+  sprintf (line_directive_buf, \"# %d \", ip->lineno);\n+  line_end = quote_string (line_directive_buf + strlen (line_directive_buf),\n \t\t\t   ip->nominal_fname);\n   if (file_change != same_file) {\n     *line_end++ = ' ';\n@@ -7829,11 +7825,11 @@ output_line_command (ip, op, conditional, file_change)\n   }\n #endif\n   *line_end++ = '\\n';\n-  len = line_end - line_cmd_buf;\n+  len = line_end - line_directive_buf;\n   check_expand (op, len + 1);\n   if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n     *op->bufp++ = '\\n';\n-  bcopy ((char *) line_cmd_buf, (char *) op->bufp, len);\n+  bcopy ((char *) line_directive_buf, (char *) op->bufp, len);\n   op->bufp += len;\n   op->lineno = ip->lineno;\n }\n@@ -8874,7 +8870,7 @@ pedwarn_with_file_and_line (file, line, msg, arg1, arg2, arg3)\n }\n \f\n /* Print the file names and line numbers of the #include\n-   commands which led to the current file.  */\n+   directives which led to the current file.  */\n \n static void\n print_containing_files ()\n@@ -9382,51 +9378,51 @@ initialize_builtins (inp, outp)\n \n       sprintf (directive, \" __BASE_FILE__ \\\"%s\\\"\\n\",\n \t       instack[0].nominal_fname);\n-      output_line_command (inp, outp, 0, same_file);\n+      output_line_directive (inp, outp, 0, same_file);\n       pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n \n       sprintf (directive, \" __VERSION__ \\\"%s\\\"\\n\", version_string);\n-      output_line_command (inp, outp, 0, same_file);\n+      output_line_directive (inp, outp, 0, same_file);\n       pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n \n #ifndef NO_BUILTIN_SIZE_TYPE\n       sprintf (directive, \" __SIZE_TYPE__ %s\\n\", SIZE_TYPE);\n-      output_line_command (inp, outp, 0, same_file);\n+      output_line_directive (inp, outp, 0, same_file);\n       pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n #endif\n \n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n       sprintf (directive, \" __PTRDIFF_TYPE__ %s\\n\", PTRDIFF_TYPE);\n-      output_line_command (inp, outp, 0, same_file);\n+      output_line_directive (inp, outp, 0, same_file);\n       pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n #endif\n \n       sprintf (directive, \" __WCHAR_TYPE__ %s\\n\", wchar_type);\n-      output_line_command (inp, outp, 0, same_file);\n+      output_line_directive (inp, outp, 0, same_file);\n       pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n \n       sprintf (directive, \" __DATE__ \\\"%s %2d %4d\\\"\\n\",\n \t       monthnames[timebuf->tm_mon],\n \t       timebuf->tm_mday, timebuf->tm_year + 1900);\n-      output_line_command (inp, outp, 0, same_file);\n+      output_line_directive (inp, outp, 0, same_file);\n       pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n \n       sprintf (directive, \" __TIME__ \\\"%02d:%02d:%02d\\\"\\n\",\n \t       timebuf->tm_hour, timebuf->tm_min, timebuf->tm_sec);\n-      output_line_command (inp, outp, 0, same_file);\n+      output_line_directive (inp, outp, 0, same_file);\n       pass_thru_directive (directive, &directive[strlen (directive)], outp, dp);\n \n       if (!traditional)\n \t{\n           sprintf (directive, \" __STDC__ 1\");\n-          output_line_command (inp, outp, 0, same_file);\n+          output_line_directive (inp, outp, 0, same_file);\n           pass_thru_directive (directive, &directive[strlen (directive)],\n \t\t\t       outp, dp);\n \t}\n       if (objc)\n \t{\n           sprintf (directive, \" __OBJC__ 1\");\n-          output_line_command (inp, outp, 0, same_file);\n+          output_line_directive (inp, outp, 0, same_file);\n           pass_thru_directive (directive, &directive[strlen (directive)],\n \t\t\t       outp, dp);\n \t}"}]}