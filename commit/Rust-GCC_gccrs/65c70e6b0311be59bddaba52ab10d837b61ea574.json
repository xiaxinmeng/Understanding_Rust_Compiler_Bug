{"sha": "65c70e6b0311be59bddaba52ab10d837b61ea574", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVjNzBlNmIwMzExYmU1OWJkZGFiYTUyYWIxMGQ4MzdiNjFlYTU3NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-16T12:04:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-16T12:04:17Z"}, "message": "cgraph.h (FOR_EACH_VARIABLE, [...]): New macros.\n\n\t* cgraph.h (FOR_EACH_VARIABLE, FOR_EACH_VARIABLE, FOR_EACH_FUNCTION):\n\tNew macros.\n\t* lto-symtab.c (lto_symtab_merge_cgraph_nodes): Use FOR_EACH\n\twalkers to walk cgraph and varpool.\n\t* cgraph.c (cgraph_node_for_asm): Likewise.\n\t(dump_cgraph): Likewise.\n\t* value-prof.c (init_node_map): Likewise.\n\t* tree.c (free_lang_data_in_cgraph): Likewise.\n\t* tree-emutls.c: (ipa_lower_emutls): Likewise.\n\t* ipa-reference.c (generate_summary, propagate): Likewise.\n\t* cgraphunit.c (verify_cgraph, cgraph_process_same_body_aliases,\n\tcgraph_mark_functions_to_output, cgraph_output_in_order,\n\toutput_weakrefs, cgraph_materialize_all_clones,\n\tcgraph_optimize): Likewise.\n\t* lto-cgraph.c (merge_profile_summaries): Likewise.\n\t(input_cgraph): Likewise.\n\t* ipa-pure-const.c (generate_summary): Likewise.\n\t(propagate): Likwise.\n\t* ipa-utils.c (ipa_reduced_postorder): Likewise.\n\t(ipa_free_postorder_info): Likewise.\n\t(ipa_reverse_postorder): Likewise.\n\t* ipa-inline.c (ipa_inline): Likewise.\n\t* matrix-reorg.c (find_matrices_decl): Likewise.\n\t(matrix_reorg): Likewise.\n\t* tree-vectorizer.c (increase_alignment): Likewise.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Likewise.\n\t(function_and_variable_visibility): Likewise.\n\t(whole_program_function_and_variable_visibility): Likewise.\n\t(ipa_cdtor_merge): Likewise.\n\t* trans-mem.c (ipa_tm_execute): Likewise.\n\t* ipa-inline-analysis.c (dump_inline_summaries): Likewise.\n\t* ipa-prop.c (ipa_print_all_jump_functions): Likewise.\n\t(ipa_print_all_params): Likewise.\n\t(ipa_update_after_lto_read): Likewise.\n\t* tree-profie.c (tree_profiling): Likewise.\n\t* tree-ssa-structalias.c (ipa_pta_execute): Likewise.\n\t* passes.c (dump_passes): Likewise.\n\t(do_per_function): Likewise.\n\t(ipa_write_summaries): Likewise.\n\t* varpool.c (dump_varpool): Likewise.\n\t(varpool_node_for_asm): Likewise.\n\t(varpool_assemble_pending_decls): Likewise.\n\n\n\t* decl2.c (collect_candidates_for_java_method_alias): Use FOR_EACH\n        walkers to walk cgraph and varpool.\n\n\t* lto.c (read_cgraph_and_symbols): Use FOR_EACH\n        walkers to walk cgraph and varpool.\n\t(materialize_cgraph): Likewise.\n\t* lto-partition.c (lto_1_to_1_map): Likewise.\n\t(lto_balanced_map): Likewise.\n\t(lto_promote_cross_file_statics): Likewise.\n\nFrom-SVN: r186492", "tree": {"sha": "011c878ee2a5ec6071bdb8be9c3d3d3fc62db1a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/011c878ee2a5ec6071bdb8be9c3d3d3fc62db1a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65c70e6b0311be59bddaba52ab10d837b61ea574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65c70e6b0311be59bddaba52ab10d837b61ea574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65c70e6b0311be59bddaba52ab10d837b61ea574", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65c70e6b0311be59bddaba52ab10d837b61ea574/comments", "author": null, "committer": null, "parents": [{"sha": "8b7db2596e34866f3143938e017e97fb903b3279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7db2596e34866f3143938e017e97fb903b3279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b7db2596e34866f3143938e017e97fb903b3279"}], "stats": {"total": 464, "additions": 257, "deletions": 207}, "files": [{"sha": "bb23d465365cfe092f078fbb1d3137c83dccc957", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1,3 +1,48 @@\n+2012-04-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (FOR_EACH_VARIABLE, FOR_EACH_VARIABLE, FOR_EACH_FUNCTION):\n+\tNew macros.\n+\t* lto-symtab.c (lto_symtab_merge_cgraph_nodes): Use FOR_EACH\n+\twalkers to walk cgraph and varpool.\n+\t* cgraph.c (cgraph_node_for_asm): Likewise.\n+\t(dump_cgraph): Likewise.\n+\t* value-prof.c (init_node_map): Likewise.\n+\t* tree.c (free_lang_data_in_cgraph): Likewise.\n+\t* tree-emutls.c: (ipa_lower_emutls): Likewise.\n+\t* ipa-reference.c (generate_summary, propagate): Likewise.\n+\t* cgraphunit.c (verify_cgraph, cgraph_process_same_body_aliases,\n+\tcgraph_mark_functions_to_output, cgraph_output_in_order,\n+\toutput_weakrefs, cgraph_materialize_all_clones,\n+\tcgraph_optimize): Likewise.\n+\t* lto-cgraph.c (merge_profile_summaries): Likewise.\n+\t(input_cgraph): Likewise.\n+\t* ipa-pure-const.c (generate_summary): Likewise.\n+\t(propagate): Likwise.\n+\t* ipa-utils.c (ipa_reduced_postorder): Likewise.\n+\t(ipa_free_postorder_info): Likewise.\n+\t(ipa_reverse_postorder): Likewise.\n+\t* ipa-inline.c (ipa_inline): Likewise.\n+\t* matrix-reorg.c (find_matrices_decl): Likewise.\n+\t(matrix_reorg): Likewise.\n+\t* tree-vectorizer.c (increase_alignment): Likewise.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Likewise.\n+\t(function_and_variable_visibility): Likewise.\n+\t(whole_program_function_and_variable_visibility): Likewise.\n+\t(ipa_cdtor_merge): Likewise.\n+\t* trans-mem.c (ipa_tm_execute): Likewise.\n+\t* ipa-inline-analysis.c (dump_inline_summaries): Likewise.\n+\t* ipa-prop.c (ipa_print_all_jump_functions): Likewise.\n+\t(ipa_print_all_params): Likewise.\n+\t(ipa_update_after_lto_read): Likewise.\n+\t* tree-profie.c (tree_profiling): Likewise.\n+\t* tree-ssa-structalias.c (ipa_pta_execute): Likewise.\n+\t* passes.c (dump_passes): Likewise.\n+\t(do_per_function): Likewise.\n+\t(ipa_write_summaries): Likewise.\n+\t* varpool.c (dump_varpool): Likewise.\n+\t(varpool_node_for_asm): Likewise.\n+\t(varpool_assemble_pending_decls): Likewise.\n+\n 2012-04-16  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/52975"}, {"sha": "4f5a9dae52d5afb718823345424186d30e412342", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -711,7 +711,7 @@ cgraph_node_for_asm (tree asmname)\n       assembler_name_hash =\n \thtab_create_ggc (10, hash_node_by_assembler_name, eq_assembler_name,\n \t\t\t NULL);\n-      for (node = cgraph_nodes; node; node = node->next)\n+      FOR_EACH_FUNCTION (node)\n         if (!node->global.inlined_to)\n \t  {\n \t    tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n@@ -1962,7 +1962,7 @@ dump_cgraph (FILE *f)\n   struct cgraph_node *node;\n \n   fprintf (f, \"callgraph:\\n\\n\");\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     dump_cgraph_node (f, node);\n }\n "}, {"sha": "e4c7b2a613cf92030a3125704a052b26531352bd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -773,6 +773,12 @@ varpool_next_static_initializer (struct varpool_node *node)\n #define FOR_EACH_STATIC_INITIALIZER(node) \\\n    for ((node) = varpool_first_static_initializer (); (node); \\\n         (node) = varpool_next_static_initializer (node))\n+/* Walk all variables.  */\n+#define FOR_EACH_VARIABLE(node) \\\n+   for ((node) = varpool_nodes; (node); (node) = (node)->next)\n+/* Walk all variables with definitions in current unit.  */\n+#define FOR_EACH_DEFINED_VARIABLE(node) \\\n+   for ((node) = varpool_nodes_queue; (node); (node) = (node)->next_needed)\n \n /* Return first function with body defined.  */\n static inline struct cgraph_node *\n@@ -803,7 +809,9 @@ cgraph_next_defined_function (struct cgraph_node *node)\n #define FOR_EACH_DEFINED_FUNCTION(node) \\\n    for ((node) = cgraph_first_defined_function (); (node); \\\n         (node) = cgraph_next_defined_function (node))\n-\n+/* Walk all functions.  */\n+#define FOR_EACH_FUNCTION(node) \\\n+   for ((node) = cgraph_nodes; (node); (node) = (node)->next)\n \n /* Return true when NODE is a function with Gimple body defined\n    in current unit.  Functions can also be define externally or they"}, {"sha": "abe90120129e7767fc50b7cfbf9b044ed504c329", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -890,7 +890,7 @@ verify_cgraph (void)\n   if (seen_error ())\n     return;\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     verify_cgraph_node (node);\n }\n \n@@ -1026,7 +1026,7 @@ void\n cgraph_process_same_body_aliases (void)\n {\n   struct cgraph_node *node;\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     if (node->same_body_alias\n \t&& !VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n       {\n@@ -1398,11 +1398,11 @@ cgraph_mark_functions_to_output (void)\n #ifdef ENABLE_CHECKING\n   bool check_same_comdat_groups = false;\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     gcc_assert (!node->process);\n #endif\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       tree decl = node->symbol.decl;\n       struct cgraph_edge *e;\n@@ -1472,7 +1472,7 @@ cgraph_mark_functions_to_output (void)\n     }\n #ifdef ENABLE_CHECKING\n   if (check_same_comdat_groups)\n-    for (node = cgraph_nodes; node; node = node->next)\n+    FOR_EACH_FUNCTION (node)\n       if (node->symbol.same_comdat_group && !node->process)\n \t{\n \t  tree decl = node->symbol.decl;\n@@ -2081,7 +2081,7 @@ cgraph_output_in_order (void)\n \n   varpool_analyze_pending_decls ();\n \n-  for (pf = cgraph_nodes; pf; pf = pf->next)\n+  FOR_EACH_DEFINED_FUNCTION (pf)\n     {\n       if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n \t{\n@@ -2092,7 +2092,7 @@ cgraph_output_in_order (void)\n \t}\n     }\n \n-  for (pv = varpool_nodes_queue; pv; pv = pv->next_needed)\n+  FOR_EACH_DEFINED_VARIABLE (pv)\n     {\n       i = pv->symbol.order;\n       gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n@@ -2246,14 +2246,14 @@ output_weakrefs (void)\n {\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     if (node->alias && DECL_EXTERNAL (node->symbol.decl)\n         && !TREE_ASM_WRITTEN (node->symbol.decl)\n \t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n       assemble_alias (node->symbol.decl,\n \t\t      node->thunk.alias ? DECL_ASSEMBLER_NAME (node->thunk.alias)\n \t\t      : get_alias_symbol (node->symbol.decl));\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     if (vnode->alias && DECL_EXTERNAL (vnode->symbol.decl)\n         && !TREE_ASM_WRITTEN (vnode->symbol.decl)\n \t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n@@ -2320,7 +2320,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n    new_version->analyzed = old_version->analyzed;\n    new_version->local = old_version->local;\n    new_version->symbol.externally_visible = false;\n-   new_version->local.local = true;\n+   new_version->local.local = old_version->analyzed;\n    new_version->global = old_version->global;\n    new_version->rtl = old_version->rtl;\n    new_version->reachable = true;\n@@ -2578,7 +2578,7 @@ cgraph_materialize_all_clones (void)\n   while (!stabilized)\n     {\n       stabilized = true;\n-      for (node = cgraph_nodes; node; node = node->next)\n+      FOR_EACH_FUNCTION (node)\n         {\n \t  if (node->clone_of && node->symbol.decl != node->clone_of->symbol.decl\n \t      && !gimple_has_body_p (node->symbol.decl))\n@@ -2628,7 +2628,7 @@ cgraph_materialize_all_clones (void)\n \t    }\n \t}\n     }\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     if (!node->analyzed && node->callees)\n       cgraph_node_remove_callees (node);\n   if (cgraph_dump_file)\n@@ -2745,10 +2745,9 @@ cgraph_optimize (void)\n       struct cgraph_node *node;\n       bool error_found = false;\n \n-      for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->analyzed\n-\t    && (node->global.inlined_to\n-\t\t|| gimple_has_body_p (node->symbol.decl)))\n+      FOR_EACH_DEFINED_FUNCTION (node)\n+\tif (node->global.inlined_to\n+\t    || gimple_has_body_p (node->symbol.decl))\n \t  {\n \t    error_found = true;\n \t    dump_cgraph_node (stderr, node);"}, {"sha": "c511a1287500ad49ecd79f554fbb6974ac8d137c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1,3 +1,8 @@\n+2012-04-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (collect_candidates_for_java_method_alias): Use FOR_EACH\n+        walkers to walk cgraph and varpool.\n+\n 2012-04-15  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/47220"}, {"sha": "90498ea294109ca4086c6ff9cea58edad56cb6c3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -3489,7 +3489,7 @@ collect_candidates_for_java_method_aliases (void)\n   return candidates;\n #endif\n \n-  for (node = cgraph_nodes; node ; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       tree fndecl = node->symbol.decl;\n \n@@ -3523,7 +3523,7 @@ build_java_method_aliases (struct pointer_set_t *candidates)\n   return;\n #endif\n \n-  for (node = cgraph_nodes; node ; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       tree fndecl = node->symbol.decl;\n "}, {"sha": "dd01d33740f5d2a07acf957950e5186f20dd68e7", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1226,8 +1226,8 @@ dump_inline_summaries (FILE *f)\n {\n   struct cgraph_node *node;\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed && !node->global.inlined_to)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (!node->global.inlined_to)\n       dump_inline_summary (f, node);\n }\n "}, {"sha": "ebee1f97e99c389064e60b82092d4bcae3a976b1", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1685,7 +1685,7 @@ ipa_inline (void)\n \n   nnodes = ipa_reverse_postorder (order);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     node->symbol.aux = 0;\n \n   if (dump_file)\n@@ -1742,7 +1742,7 @@ ipa_inline (void)\n \t to be hot.  */\n       for (cold = 0; cold <= 1; cold ++)\n \t{\n-\t  for (node = cgraph_nodes; node; node = node->next)\n+\t  FOR_EACH_DEFINED_FUNCTION (node)\n \t    {\n \t      if (want_inline_function_called_once_p (node)\n \t\t  && (cold"}, {"sha": "97a6a5cb0cf95f931527973692fe5f6362a4c4f4", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -260,7 +260,7 @@ ipa_print_all_jump_functions (FILE *f)\n   struct cgraph_node *node;\n \n   fprintf (f, \"\\nJump functions:\\n\");\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       ipa_print_node_jump_functions (f, node);\n     }\n@@ -2209,7 +2209,7 @@ ipa_print_all_params (FILE * f)\n   struct cgraph_node *node;\n \n   fprintf (f, \"\\nFunction parameters:\\n\");\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     ipa_print_node_params (f, node);\n }\n \n@@ -3087,7 +3087,7 @@ ipa_update_after_lto_read (void)\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->analyzed)\n       ipa_initialize_node_params (node);\n }"}, {"sha": "29b4c177b28d59332702174442e79f2831e67364", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -924,7 +924,7 @@ generate_summary (void)\n      by default, but the info can be used at LTO with -fwhole-program or\n      when function got cloned and the clone is AVAILABLE.  */\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       set_function_state (node, analyze_function (node, true));\n \n@@ -1475,7 +1475,7 @@ propagate (void)\n   propagate_pure_const ();\n \n   /* Cleanup. */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (has_function_state (node))\n       free (get_function_state (node));\n   VEC_free (funct_state, heap, funct_state_vec);"}, {"sha": "d8fd796ea2581d8d75a18a489e2d058b8605dfa1", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -530,9 +530,8 @@ generate_summary (void)\n   bm_temp = BITMAP_ALLOC (&local_info_obstack);\n \n   /* Process all of the functions next.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      analyze_function (node);\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    analyze_function (node);\n \n   if (dump_file)\n     EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n@@ -544,7 +543,7 @@ generate_summary (void)\n   BITMAP_FREE(bm_temp);\n \n   if (dump_file)\n-    for (node = cgraph_nodes; node; node = node->next)\n+    FOR_EACH_DEFINED_FUNCTION (node)\n       if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n \t{\n \t  ipa_reference_local_vars_info_t l;\n@@ -884,13 +883,13 @@ propagate (void)\n     }\n \n   /* Cleanup. */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       ipa_reference_vars_info_t node_info;\n       ipa_reference_global_vars_info_t node_g;\n       ipa_reference_optimization_summary_t opt;\n \n-      if (!node->analyzed || node->alias)\n+      if (node->alias)\n         continue;\n \n       node_info = get_reference_vars_info (node);"}, {"sha": "db0784db550623ea063eafebb702fb490312759c", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -178,7 +178,7 @@ ipa_reduced_postorder (struct cgraph_node **order,\n   env.reduce = reduce;\n   env.allow_overwritable = allow_overwritable;\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       enum availability avail = cgraph_function_body_availability (node);\n \n@@ -222,7 +222,7 @@ void\n ipa_free_postorder_info (void)\n {\n   struct cgraph_node *node;\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       /* Get rid of the aux information.  */\n       if (node->symbol.aux)\n@@ -261,10 +261,10 @@ ipa_reverse_postorder (struct cgraph_node **order)\n      output algorithm.  Ignore the fact that some functions won't need\n      to be output and put them into order as well, so we get dependencies\n      right through inline functions.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     node->symbol.aux = NULL;\n   for (pass = 0; pass < 2; pass++)\n-    for (node = cgraph_nodes; node; node = node->next)\n+    FOR_EACH_FUNCTION (node)\n       if (!node->symbol.aux\n \t  && (pass\n \t      || (!node->symbol.address_taken\n@@ -317,7 +317,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t    }\n \t}\n   free (stack);\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     node->symbol.aux = NULL;\n   return order_pos;\n }"}, {"sha": "7c35346fcbf3ee92144d1c3a76ccefb1f108ab69", "filename": "gcc/ipa.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -181,17 +181,17 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   if (file)\n     fprintf (file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     gcc_assert (!node->symbol.aux);\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     gcc_assert (!vnode->symbol.aux);\n #endif\n   varpool_reset_queue ();\n   /* Mark functions whose bodies are obviously needed.\n      This is mostly when they can be referenced externally.  Inline clones\n      are special since their declarations are shared with master clone and thus\n      cgraph_can_remove_if_no_direct_calls_and_refs_p should not be called on them.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     if (node->analyzed && !node->global.inlined_to\n \t&& (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n \t    /* Keep around virtual functions for possible devirtualization.  */\n@@ -210,7 +210,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       }\n \n   /* Mark variables that are obviously needed.  */\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     {\n       vnode->next_needed = NULL;\n       vnode->prev_needed = NULL;\n@@ -405,7 +405,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    }\n \t}\n     }\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       /* Inline clones might be kept around so their materializing allows further\n          cloning.  If the function the clone is inlined into is removed, we need\n@@ -441,7 +441,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n   if (file)\n     fprintf (file, \"\\nClearing address taken flags:\");\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->symbol.address_taken\n \t&& !node->symbol.used_from_other_partition)\n       {\n@@ -492,7 +492,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n   struct varpool_node *vnode;\n   if (dump_file)\n     fprintf (dump_file, \"Clearing variable flags:\");\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     if (vnode->finalized && varpool_all_refs_explicit_p (vnode)\n \t&& (TREE_ADDRESSABLE (vnode->symbol.decl)\n \t    || !TREE_READONLY (vnode->symbol.decl)))\n@@ -797,7 +797,7 @@ function_and_variable_visibility (bool whole_program)\n        fprintf (dump_file, \"\\n\");\n     }\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       int flags = flags_from_decl_or_type (node->symbol.decl);\n \n@@ -889,9 +889,9 @@ function_and_variable_visibility (bool whole_program)\n \t    DECL_EXTERNAL (node->symbol.decl) = 1;\n \t}\n     }\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     node->local.local = cgraph_local_node_p (node);\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     {\n       /* weak flag makes no sense on local variables.  */\n       gcc_assert (!DECL_WEAK (vnode->symbol.decl)\n@@ -921,7 +921,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->symbol.decl))))))\n \tDECL_COMMON (vnode->symbol.decl) = 0;\n     }\n-  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n       if (!vnode->finalized)\n         continue;\n@@ -946,17 +946,17 @@ function_and_variable_visibility (bool whole_program)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nMarking local functions:\");\n-      for (node = cgraph_nodes; node; node = node->next)\n+      FOR_EACH_DEFINED_FUNCTION (node)\n \tif (node->local.local)\n \t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible functions:\");\n-      for (node = cgraph_nodes; node; node = node->next)\n+      FOR_EACH_DEFINED_FUNCTION (node)\n \tif (node->symbol.externally_visible)\n \t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible variables:\");\n-      for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+      FOR_EACH_DEFINED_VARIABLE (vnode)\n \tif (vnode->symbol.externally_visible)\n \t  fprintf (dump_file, \" %s\", varpool_node_name (vnode));\n       fprintf (dump_file, \"\\n\\n\");\n@@ -1012,17 +1012,17 @@ whole_program_function_and_variable_visibility (void)\n \n   function_and_variable_visibility (flag_whole_program);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if ((node->symbol.externally_visible && !DECL_COMDAT (node->symbol.decl))\n         && node->local.finalized)\n       cgraph_mark_needed_node (node);\n-  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n     if (vnode->symbol.externally_visible && !DECL_COMDAT (vnode->symbol.decl))\n       varpool_mark_needed_node (vnode);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nNeeded variables:\");\n-      for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+      FOR_EACH_DEFINED_VARIABLE (vnode)\n \tif (vnode->needed)\n \t  fprintf (dump_file, \" %s\", varpool_node_name (vnode));\n       fprintf (dump_file, \"\\n\\n\");\n@@ -1405,10 +1405,9 @@ static unsigned int\n ipa_cdtor_merge (void)\n {\n   struct cgraph_node *node;\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed\n-\t&& (DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n-\t    || DECL_STATIC_DESTRUCTOR (node->symbol.decl)))\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n+\t|| DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n        record_cdtor_fn (node);\n   build_cdtor_fns ();\n   VEC_free (tree, heap, static_ctors);"}, {"sha": "421f62bc8754421d5937a275b0baa5656dc55449", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1422,7 +1422,7 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n   /* Now compute count_materialization_scale of each node.\n      During LTRANS we already have values of count_materialization_scale\n      computed, so just update them.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     if (node->symbol.lto_file_data\n \t&& node->symbol.lto_file_data->profile_info.runs)\n       {\n@@ -1501,7 +1501,7 @@ input_cgraph (void)\n \n   /* Clear out the aux field that was used to store enough state to\n      tell which nodes should be overwritten.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       /* Some nodes may have been created by cgraph_node.  This\n \t happens when the callgraph contains nested functions.  If the"}, {"sha": "406bc239471b14a5c12e5fad3d8a202a7f03d474", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -761,11 +761,11 @@ lto_symtab_merge_cgraph_nodes (void)\n   lto_symtab_maybe_init_hash_table ();\n   htab_traverse (lto_symtab_identifiers, lto_symtab_merge_cgraph_nodes_1, NULL);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     if ((node->thunk.thunk_p || node->alias)\n \t&& node->thunk.alias)\n       node->thunk.alias = lto_symtab_prevailing_decl (node->thunk.alias);\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     if (vnode->alias_of)\n       vnode->alias_of = lto_symtab_prevailing_decl (vnode->alias_of);\n }"}, {"sha": "bab0a77420d7aeb67fccc0acf5406bf2246ab6cc", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1,3 +1,12 @@\n+2012-04-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (read_cgraph_and_symbols): Use FOR_EACH\n+        walkers to walk cgraph and varpool.\n+\t(materialize_cgraph): Likewise.\n+\t* lto-partition.c (lto_1_to_1_map): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\t(lto_promote_cross_file_statics): Likewise.\n+\n 2012-04-14  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c: Update field referenced for new cgraph/varpool layout."}, {"sha": "1e6046218a4f36dd0110635e7e2da32266931f8f", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -313,7 +313,7 @@ lto_1_to_1_map (void)\n \n   pmap = pointer_map_create ();\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       if (!partition_cgraph_node_p (node)\n \t  || node->symbol.aux)\n@@ -348,7 +348,7 @@ lto_1_to_1_map (void)\n       add_cgraph_node_to_partition (partition, node);\n     }\n \n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     {\n       if (!partition_varpool_node_p (vnode)\n \t  || vnode->symbol.aux)\n@@ -367,9 +367,9 @@ lto_1_to_1_map (void)\n \n       add_varpool_node_to_partition (partition, vnode);\n     }\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     node->symbol.aux = NULL;\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     vnode->symbol.aux = NULL;\n \n   /* If the cgraph is empty, create one cgraph node set so that there is still\n@@ -463,7 +463,7 @@ lto_balanced_map (void)\n   int npartitions;\n   int current_order = -1;\n \n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     gcc_assert (!vnode->symbol.aux);\n   /* Until we have better ordering facility, use toplogical order.\n      Include only nodes we will partition and compute estimate of program\n@@ -487,13 +487,13 @@ lto_balanced_map (void)\n     {\n       qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n \n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+      FOR_EACH_VARIABLE (vnode)\n \tif (partition_varpool_node_p (vnode))\n \t  n_varpool_nodes++;\n       varpool_order = XNEWVEC (struct varpool_node *, n_varpool_nodes);\n \n       n_varpool_nodes = 0;\n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+      FOR_EACH_VARIABLE (vnode)\n \tif (partition_varpool_node_p (vnode))\n \t  varpool_order[n_varpool_nodes++] = vnode;\n       qsort (varpool_order, n_varpool_nodes, sizeof (struct varpool_node *),\n@@ -742,7 +742,7 @@ lto_balanced_map (void)\n   /* Varables that are not reachable from the code go into last partition.  */\n   if (flag_toplevel_reorder)\n     {\n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+      FOR_EACH_VARIABLE (vnode)\n         if (partition_varpool_node_p (vnode) && !vnode->symbol.aux)\n \t  add_varpool_node_to_partition (partition, vnode);\n     }\n@@ -858,7 +858,7 @@ lto_promote_cross_file_statics (void)\n \t referenced from all initializers of read-only vars referenced\n \t from this partition that are not in this partition.  This needs\n \t to be done recursively.  */\n-      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+      FOR_EACH_VARIABLE (vnode)\n \tif (const_value_known_p (vnode->symbol.decl)\n \t    && DECL_INITIAL (vnode->symbol.decl)\n \t    && !varpool_node_in_set_p (vnode, vset)"}, {"sha": "fb374ff0c9f9e2a85e4ef5f2ee2e90a8e537557d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1868,18 +1868,15 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   lto_symtab_merge_cgraph_nodes ();\n   ggc_collect ();\n \n+  /* FIXME: ipa_transforms_to_apply holds list of passes that have optimization\n+     summaries computed and needs to apply changes.  At the moment WHOPR only\n+     supports inlining, so we can push it here by hand.  In future we need to stream\n+     this field into ltrans compilation.  */\n   if (flag_ltrans)\n-    for (node = cgraph_nodes; node; node = node->next)\n-      {\n-\t/* FIXME: ipa_transforms_to_apply holds list of passes that have optimization\n-\t   summaries computed and needs to apply changes.  At the moment WHOPR only\n-\t   supports inlining, so we can push it here by hand.  In future we need to stream\n-\t   this field into ltrans compilation.  */\n-\tif (node->analyzed)\n-\t  VEC_safe_push (ipa_opt_pass, heap,\n-\t\t\t node->ipa_transforms_to_apply,\n-\t\t\t (ipa_opt_pass)&pass_ipa_inline);\n-      }\n+    FOR_EACH_DEFINED_FUNCTION (node)\n+      VEC_safe_push (ipa_opt_pass, heap,\n+\t\t     node->ipa_transforms_to_apply,\n+\t\t     (ipa_opt_pass)&pass_ipa_inline);\n   lto_symtab_free ();\n \n   timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n@@ -1923,7 +1920,7 @@ materialize_cgraph (void)\n      nodes and read the functions if we are not running in WPA mode.  */\n   timevar_push (TV_IPA_LTO_GIMPLE_IN);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     {\n       if (node->symbol.lto_file_data)\n \t{"}, {"sha": "31e9a8e67d68b18101f756974e1226e337469eb1", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -548,7 +548,7 @@ find_matrices_decl (void)\n \n   /* For every global variable in the program:\n      Check to see if it's of a candidate type and record it.  */\n-  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n       tree var_decl = vnode->symbol.decl;\n \n@@ -2266,100 +2266,98 @@ matrix_reorg (void)\n   else\n     check_transpose_p = false;\n   /* If there are hand written vectors, we skip this optimization.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     if (!may_flatten_matrices (node))\n       return 0;\n   matrices_to_reorg = htab_create (37, mtt_info_hash, mtt_info_eq, mat_free);\n   /* Find and record all potential matrices in the program.  */\n   find_matrices_decl ();\n   /* Analyze the accesses of the matrices (escaping analysis).  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      {\n-\ttree temp_fn;\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      tree temp_fn;\n \n-\ttemp_fn = current_function_decl;\n-\tcurrent_function_decl = node->symbol.decl;\n-\tpush_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n-\tbitmap_obstack_initialize (NULL);\n-\tgimple_register_cfg_hooks ();\n+      temp_fn = current_function_decl;\n+      current_function_decl = node->symbol.decl;\n+      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      bitmap_obstack_initialize (NULL);\n+      gimple_register_cfg_hooks ();\n \n-\tif (!gimple_in_ssa_p (cfun))\n-\t  {\n-\t    free_dominance_info (CDI_DOMINATORS);\n-\t    free_dominance_info (CDI_POST_DOMINATORS);\n-\t    pop_cfun ();\n-\t    current_function_decl = temp_fn;\n-\t    bitmap_obstack_release (NULL);\n+      if (!gimple_in_ssa_p (cfun))\n+\t{\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  free_dominance_info (CDI_POST_DOMINATORS);\n+\t  pop_cfun ();\n+\t  current_function_decl = temp_fn;\n+\t  bitmap_obstack_release (NULL);\n \n-\t    return 0;\n-\t  }\n+\t  return 0;\n+\t}\n \n #ifdef ENABLE_CHECKING\n-\tverify_flow_info ();\n+      verify_flow_info ();\n #endif\n \n-\tif (!matrices_to_reorg)\n-\t  {\n-\t    free_dominance_info (CDI_DOMINATORS);\n-\t    free_dominance_info (CDI_POST_DOMINATORS);\n-\t    pop_cfun ();\n-\t    current_function_decl = temp_fn;\n-\t    bitmap_obstack_release (NULL);\n+      if (!matrices_to_reorg)\n+\t{\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  free_dominance_info (CDI_POST_DOMINATORS);\n+\t  pop_cfun ();\n+\t  current_function_decl = temp_fn;\n+\t  bitmap_obstack_release (NULL);\n \n-\t    return 0;\n-\t  }\n+\t  return 0;\n+\t}\n \n-\t/* Create htap for phi nodes.  */\n-\thtab_mat_acc_phi_nodes = htab_create (37, mat_acc_phi_hash,\n-\t\t\t\t\t      mat_acc_phi_eq, free);\n-\tif (!check_transpose_p)\n-\t  find_sites_in_func (false);\n-\telse\n-\t  {\n-\t    find_sites_in_func (true);\n-\t    loop_optimizer_init (LOOPS_NORMAL);\n-\t    if (current_loops)\n-\t      scev_initialize ();\n-\t    htab_traverse (matrices_to_reorg, analyze_transpose, NULL);\n-\t    if (current_loops)\n-\t      {\n-\t\tscev_finalize ();\n-\t\tloop_optimizer_finalize ();\n-\t\tcurrent_loops = NULL;\n-\t      }\n-\t  }\n-\t/* If the current function is the allocation function for any of\n-\t   the matrices we check its allocation and the escaping level.  */\n-\thtab_traverse (matrices_to_reorg, check_allocation_function, NULL);\n-\tfree_dominance_info (CDI_DOMINATORS);\n-\tfree_dominance_info (CDI_POST_DOMINATORS);\n-\tpop_cfun ();\n-\tcurrent_function_decl = temp_fn;\n-\tbitmap_obstack_release (NULL);\n-      }\n+      /* Create htap for phi nodes.  */\n+      htab_mat_acc_phi_nodes = htab_create (37, mat_acc_phi_hash,\n+\t\t\t\t\t    mat_acc_phi_eq, free);\n+      if (!check_transpose_p)\n+\tfind_sites_in_func (false);\n+      else\n+\t{\n+\t  find_sites_in_func (true);\n+\t  loop_optimizer_init (LOOPS_NORMAL);\n+\t  if (current_loops)\n+\t    scev_initialize ();\n+\t  htab_traverse (matrices_to_reorg, analyze_transpose, NULL);\n+\t  if (current_loops)\n+\t    {\n+\t      scev_finalize ();\n+\t      loop_optimizer_finalize ();\n+\t      current_loops = NULL;\n+\t    }\n+\t}\n+      /* If the current function is the allocation function for any of\n+\t the matrices we check its allocation and the escaping level.  */\n+      htab_traverse (matrices_to_reorg, check_allocation_function, NULL);\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      pop_cfun ();\n+      current_function_decl = temp_fn;\n+      bitmap_obstack_release (NULL);\n+    }\n   htab_traverse (matrices_to_reorg, transform_allocation_sites, NULL);\n   /* Now transform the accesses.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      {\n-\t/* Remember that allocation sites have been handled.  */\n-\ttree temp_fn;\n-\n-\ttemp_fn = current_function_decl;\n-\tcurrent_function_decl = node->symbol.decl;\n-\tpush_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n-\tbitmap_obstack_initialize (NULL);\n-\tgimple_register_cfg_hooks ();\n-\trecord_all_accesses_in_func ();\n-\thtab_traverse (matrices_to_reorg, transform_access_sites, NULL);\n-        cgraph_rebuild_references ();\n-\tfree_dominance_info (CDI_DOMINATORS);\n-\tfree_dominance_info (CDI_POST_DOMINATORS);\n-\tpop_cfun ();\n-\tcurrent_function_decl = temp_fn;\n-\tbitmap_obstack_release (NULL);\n-      }\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      /* Remember that allocation sites have been handled.  */\n+      tree temp_fn;\n+\n+      temp_fn = current_function_decl;\n+      current_function_decl = node->symbol.decl;\n+      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      bitmap_obstack_initialize (NULL);\n+      gimple_register_cfg_hooks ();\n+      record_all_accesses_in_func ();\n+      htab_traverse (matrices_to_reorg, transform_access_sites, NULL);\n+      cgraph_rebuild_references ();\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      pop_cfun ();\n+      current_function_decl = temp_fn;\n+      bitmap_obstack_release (NULL);\n+    }\n   htab_traverse (matrices_to_reorg, dump_matrix_reorg_analysis, NULL);\n \n   current_function_decl = NULL;"}, {"sha": "c012a1290ee3f7e72cfdb1079323e6be7e4c1885", "filename": "gcc/passes.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -703,16 +703,12 @@ dump_passes (void)\n \n   create_pass_tab();\n \n-  n = cgraph_nodes;\n-  while (n)\n-    {\n-      if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n-        {\n-          node = n;\n-          break;\n-        }\n-      n = n->next;\n-    }\n+  FOR_EACH_DEFINED_FUNCTION (n)\n+    if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n+      {\n+\tnode = n;\n+\tbreak;\n+      }\n \n   if (!node)\n     return;\n@@ -1662,8 +1658,8 @@ do_per_function (void (*callback) (void *data), void *data)\n   else\n     {\n       struct cgraph_node *node;\n-      for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->analyzed && gimple_has_body_p (node->symbol.decl)\n+      FOR_EACH_DEFINED_FUNCTION (node)\n+\tif (gimple_has_body_p (node->symbol.decl)\n \t    && (!node->clone_of || node->symbol.decl != node->clone_of->symbol.decl))\n \t  {\n \t    push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n@@ -2346,7 +2342,7 @@ ipa_write_summaries (void)\n     }\n   vset = varpool_node_set_new ();\n \n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+  FOR_EACH_VARIABLE (vnode)\n     if (vnode->needed && (!vnode->alias || vnode->alias_of))\n       varpool_node_set_add (vset, vnode);\n "}, {"sha": "97b4b3bbe51eaa1d9b082f0780e2e100bd996591", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -4769,7 +4769,7 @@ ipa_tm_execute (void)\n   bitmap_obstack_initialize (&tm_obstack);\n \n   /* For all local functions marked tm_callable, queue them.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (is_tm_callable (node->symbol.decl)\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n@@ -4778,7 +4778,7 @@ ipa_tm_execute (void)\n       }\n \n   /* For all local reachable functions...  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->reachable && node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n@@ -4946,7 +4946,7 @@ ipa_tm_execute (void)\n \n   /* Now validate all tm_safe functions, and all atomic regions in\n      other functions.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->reachable && node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n@@ -4994,7 +4994,7 @@ ipa_tm_execute (void)\n \t    ipa_tm_transform_clone (node);\n \t}\n     }\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->reachable && node->lowered\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n@@ -5008,7 +5008,7 @@ ipa_tm_execute (void)\n   VEC_free (cgraph_node_p, heap, irr_worklist);\n   bitmap_obstack_release (&tm_obstack);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_FUNCTION (node)\n     node->symbol.aux = NULL;\n \n #ifdef ENABLE_CHECKING"}, {"sha": "185d9f7728b88dc8a03c4274a27c84759fdc5cb9", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -741,7 +741,7 @@ ipa_lower_emutls (void)\n   tls_vars = varpool_node_set_new ();\n \n   /* Examine all global variables for TLS variables.  */\n-  for (var = varpool_nodes; var ; var = var->next)\n+  FOR_EACH_VARIABLE (var)\n     if (DECL_THREAD_LOCAL_P (var->symbol.decl))\n       {\n \tgcc_checking_assert (TREE_STATIC (var->symbol.decl)\n@@ -790,7 +790,7 @@ ipa_lower_emutls (void)\n     }\n \n   /* Adjust all uses of TLS variables within the function bodies.  */\n-  for (func = cgraph_nodes; func; func = func->next)\n+  FOR_EACH_DEFINED_FUNCTION (func)\n     if (func->reachable && func->lowered)\n       lower_emutls_function_body (func);\n "}, {"sha": "52d953ceb18f435bd40333b55269f2a4733faf7b", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -479,10 +479,9 @@ tree_profiling (void)\n \n   init_node_map();\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      if (!node->analyzed\n-\t  || !gimple_has_body_p (node->symbol.decl))\n+      if (!gimple_has_body_p (node->symbol.decl))\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n@@ -520,10 +519,9 @@ tree_profiling (void)\n     }\n \n   /* Drop pure/const flags from instrumented functions.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      if (!node->analyzed\n-\t  || !gimple_has_body_p (node->symbol.decl)\n+      if (!gimple_has_body_p (node->symbol.decl)\n \t  || !(!node->clone_of\n \t  || node->symbol.decl != node->clone_of->symbol.decl))\n \tcontinue;\n@@ -538,12 +536,11 @@ tree_profiling (void)\n     }\n \n   /* Update call statements and rebuild the cgraph.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       basic_block bb;\n \n-      if (!node->analyzed\n-\t  || !gimple_has_body_p (node->symbol.decl)\n+      if (!gimple_has_body_p (node->symbol.decl)\n \t  || !(!node->clone_of\n \t  || node->symbol.decl != node->clone_of->symbol.decl))\n \tcontinue;"}, {"sha": "3601bc37ec525f1b508f8e25c861702b40f98c85", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -6862,7 +6862,7 @@ ipa_pta_execute (void)\n     }\n \n   /* Build the constraints.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       varinfo_t vi;\n       /* Nodes without a body are not interesting.  Especially do not\n@@ -6879,7 +6879,7 @@ ipa_pta_execute (void)\n     }\n \n   /* Create constraints for global variables and their initializers.  */\n-  for (var = varpool_nodes; var; var = var->next)\n+  FOR_EACH_VARIABLE (var)\n     {\n       if (var->alias)\n \tcontinue;\n@@ -6896,7 +6896,7 @@ ipa_pta_execute (void)\n     }\n   from = VEC_length (constraint_t, constraints);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       struct function *func;\n       basic_block bb;\n@@ -7004,7 +7004,7 @@ ipa_pta_execute (void)\n   ipa_escaped_pt.ipa_escaped = 0;\n \n   /* Assign the points-to sets to the SSA names in the unit.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       tree ptr;\n       struct function *fn;"}, {"sha": "7df31f7c9d2c229cca4c059009ad5813ca852d7d", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -320,9 +320,7 @@ increase_alignment (void)\n   struct varpool_node *vnode;\n \n   /* Increase the alignment of all global arrays for vectorization.  */\n-  for (vnode = varpool_nodes_queue;\n-       vnode;\n-       vnode = vnode->next_needed)\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n       tree vectype, decl = vnode->symbol.decl;\n       tree t;"}, {"sha": "fcefaab01a6df68fa28f2d61fa74a91400c6ee96", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -5176,14 +5176,14 @@ free_lang_data_in_cgraph (void)\n   fld.types = VEC_alloc (tree, heap, 100);\n \n   /* Find decls and types in the body of every function in the callgraph.  */\n-  for (n = cgraph_nodes; n; n = n->next)\n+  FOR_EACH_FUNCTION (n)\n     find_decls_types_in_node (n, &fld);\n \n   FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     find_decls_types (p->decl, &fld);\n \n   /* Find decls and types in every varpool symbol.  */\n-  for (v = varpool_nodes; v; v = v->next)\n+  FOR_EACH_VARIABLE (v)\n     find_decls_types_in_var (v, &fld);\n \n   /* Set the assembler name on every decl found.  We need to do this"}, {"sha": "10a5319d3ecb84b688afadd2fcb69c5a7d2c2eed", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -1073,7 +1073,7 @@ init_node_map (void)\n     VEC_safe_grow_cleared (cgraph_node_ptr, heap,\n                            cgraph_node_map, get_last_funcdef_no ());\n \n-  for (n = cgraph_nodes; n; n = n->next)\n+  FOR_EACH_FUNCTION (n)\n     {\n       if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n         VEC_replace (cgraph_node_ptr, cgraph_node_map,"}, {"sha": "42acc58be609ce1a61ec0946537adb178b484d36", "filename": "gcc/varpool.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65c70e6b0311be59bddaba52ab10d837b61ea574/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=65c70e6b0311be59bddaba52ab10d837b61ea574", "patch": "@@ -254,7 +254,7 @@ dump_varpool (FILE *f)\n   struct varpool_node *node;\n \n   fprintf (f, \"variable pool:\\n\\n\");\n-  for (node = varpool_nodes; node; node = node->next)\n+  FOR_EACH_VARIABLE (node)\n     dump_varpool_node (f, node);\n }\n \n@@ -272,7 +272,7 @@ varpool_node_for_asm (tree asmname)\n {\n   struct varpool_node *node;\n \n-  for (node = varpool_nodes; node ; node = node->next)\n+  FOR_EACH_VARIABLE (node)\n     if (decl_assembler_name_equal (node->symbol.decl, asmname))\n       return node;\n \n@@ -652,7 +652,7 @@ varpool_assemble_pending_decls (void)\n      elsewhere.  */\n   varpool_analyze_pending_decls ();\n \n-  for (node = varpool_nodes_queue; node; node = node->next_needed)\n+  FOR_EACH_DEFINED_VARIABLE (node)\n     varpool_finalize_named_section_flags (node);\n \n   while (varpool_nodes_queue)"}]}