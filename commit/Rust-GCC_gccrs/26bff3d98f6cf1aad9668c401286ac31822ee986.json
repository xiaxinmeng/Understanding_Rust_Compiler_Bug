{"sha": "26bff3d98f6cf1aad9668c401286ac31822ee986", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZiZmYzZDk4ZjZjZjFhYWQ5NjY4YzQwMTI4NmFjMzE4MjJlZTk4Ng==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-06-06T10:25:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:25:12Z"}, "message": "exp_ch4.adb (Complete_Coextension_Finalization): Add machinery to handle the creation of finalization lists and calls for nested...\n\n2007-04-20  Javier Miranda  <miranda@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\n\t* exp_ch4.adb (Complete_Coextension_Finalization): Add machinery to\n\thandle the creation of finalization lists and calls for nested\n\tcoextensions when the root of the chains is part of a return statement.\n\t(Inside_A_Return_Statement): New function inside Complete_Coextension_\n\tFinalization.\n\t(Expand_Record_Equality): Skip components that are interface types.\n\t(Displace_Allocator_Pointer): Add missing support for interface subtypes\n\t(Expand_N_Allocator): Replace invocation of Is_Local_Access_Discriminant\n\twith Rewrite_Coextension. Change the condition for detecting coextension\n\troot nodes.\n\t(Is_Local_Access_Discriminant): Removed.\n\t(Rewrite_Coextension): New routine which rewrites a static coextension\n\tas a temporary and uses its unrestricted access in the construction of\n\tthe outer object.\n\t(Complete_Coextension_Finalization): New routine. Generate finalization\n\tattachment calls to all delayed coextensions.\n\t(Expand_N_Allocator): Call Complete_Coextension_Finalization whenever\n\tthe allocator is not a coextension itself and has delayed coextensions.\n\tIf the current allocator is controlled, but also a coextension, delay\n\tthe generation of the finalization attachment call.\n\tRename local variable \"Node\" to \"Nod\" in order to avoid confusion with\n\t\"Elists.Node\".\n\t(Expand_Allocator_Expression): Call Adjust for initialized allocators of\n\tlimited types that are not inherently limited. Such an allocator is\n\tillegal, but is generated by the expander for a return statement, to\n\tcopy the result onto the secondary stack. This is the only case where a\n\tlimited object can be copied. Generate code to displace the pointer\n\tto the object if the qualified expression is a class-wide interface\n\tobject. Such displacement was missing and hence the copy of the object\n\twas wrong.\n\t(Apply_Accessibility_Check): Handle allocated objects initialized in\n\tplace.\n\t(Displace_Allocator_Pointer): Subsidiary procedure to Expand_N_Allocator\n\tand Expand_Allocator_Expression. Allocating class-wide interface objects\n\tthis routine displaces the pointer to the allocated object to reference\n\tthe component referencing the corresponding secondary dispatch table.\n\tExpand_Allocator_Expression): Add missing support to allocate class-wide\n\tinterface objects initialized with a qualified expression.\n\t(Get_Allocator_Final_List): Test for an anonymous access type that is a\n\tfunction result type, and use the finalization list associated with the\n\tfunction scope in that case (such an anonymous type should not be\n\ttreated like an access parameter's type).\n\nFrom-SVN: r125397", "tree": {"sha": "0c76464805daab8a9c58a8ebb74de1e00f092c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c76464805daab8a9c58a8ebb74de1e00f092c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26bff3d98f6cf1aad9668c401286ac31822ee986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26bff3d98f6cf1aad9668c401286ac31822ee986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26bff3d98f6cf1aad9668c401286ac31822ee986", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26bff3d98f6cf1aad9668c401286ac31822ee986/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47cc8d6bfdf64ccaaa6df4bdd02fcf732583ca71"}], "stats": {"total": 1401, "additions": 941, "deletions": 460}, "files": [{"sha": "1c2908e897f87f8886fdd90caf0e800bdbfb8925", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 941, "deletions": 460, "changes": 1401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bff3d98f6cf1aad9668c401286ac31822ee986/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bff3d98f6cf1aad9668c401286ac31822ee986/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=26bff3d98f6cf1aad9668c401286ac31822ee986", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,8 +42,8 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Exp_VFpt; use Exp_VFpt;\n with Freeze;   use Freeze;\n-with Hostparm; use Hostparm;\n with Inline;   use Inline;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -53,6 +53,7 @@ with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -86,6 +87,12 @@ package body Exp_Ch4 is\n    --  If an boolean array assignment can be done in place, build call to\n    --  corresponding library procedure.\n \n+   procedure Displace_Allocator_Pointer (N : Node_Id);\n+   --  Ada 2005 (AI-251): Subsidiary procedure to Expand_N_Allocator and\n+   --  Expand_Allocator_Expression. Allocating class-wide interface objects\n+   --  this routine displaces the pointer to the allocated object to reference\n+   --  the component referencing the corresponding secondary dispatch table.\n+\n    procedure Expand_Allocator_Expression (N : Node_Id);\n    --  Subsidiary to Expand_N_Allocator, for the case when the expression\n    --  is a qualified expression or an aggregate.\n@@ -364,20 +371,189 @@ package body Exp_Ch4 is\n          return;\n    end Build_Boolean_Array_Proc_Call;\n \n+   --------------------------------\n+   -- Displace_Allocator_Pointer --\n+   --------------------------------\n+\n+   procedure Displace_Allocator_Pointer (N : Node_Id) is\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Orig_Node : constant Node_Id := Original_Node (N);\n+      Dtyp      : Entity_Id;\n+      Etyp      : Entity_Id;\n+      PtrT      : Entity_Id;\n+\n+   begin\n+      pragma Assert (Nkind (N) = N_Identifier\n+        and then Nkind (Orig_Node) = N_Allocator);\n+\n+      PtrT := Etype (Orig_Node);\n+      Dtyp := Designated_Type (PtrT);\n+      Etyp := Etype (Expression (Orig_Node));\n+\n+      if Is_Class_Wide_Type (Dtyp)\n+        and then Is_Interface (Dtyp)\n+      then\n+         --  If the type of the allocator expression is not an interface type\n+         --  we can generate code to reference the record component containing\n+         --  the pointer to the secondary dispatch table.\n+\n+         if not Is_Interface (Etyp) then\n+            declare\n+               Saved_Typ : constant Entity_Id := Etype (Orig_Node);\n+\n+            begin\n+               --  1) Get access to the allocated object\n+\n+               Rewrite (N,\n+                 Make_Explicit_Dereference (Loc,\n+                   Relocate_Node (N)));\n+               Set_Etype (N, Etyp);\n+               Set_Analyzed (N);\n+\n+               --  2) Add the conversion to displace the pointer to reference\n+               --     the secondary dispatch table.\n+\n+               Rewrite (N, Convert_To (Dtyp, Relocate_Node (N)));\n+               Analyze_And_Resolve (N, Dtyp);\n+\n+               --  3) The 'access to the secondary dispatch table will be used\n+               --     as the value returned by the allocator.\n+\n+               Rewrite (N,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => Relocate_Node (N),\n+                   Attribute_Name => Name_Access));\n+               Set_Etype (N, Saved_Typ);\n+               Set_Analyzed (N);\n+            end;\n+\n+         --  If the type of the allocator expression is an interface type we\n+         --  generate a run-time call to displace \"this\" to reference the\n+         --  component containing the pointer to the secondary dispatch table\n+         --  or else raise Constraint_Error if the actual object does not\n+         --  implement the target interface. This case corresponds with the\n+         --  following example:\n+\n+         --   function Op (Obj : Iface_1'Class) return access Ifac_2e'Class is\n+         --   begin\n+         --      return new Iface_2'Class'(Obj);\n+         --   end Op;\n+\n+         else\n+            Rewrite (N,\n+              Unchecked_Convert_To (PtrT,\n+                Make_Function_Call (Loc,\n+                  Name => New_Reference_To (RTE (RE_Displace), Loc),\n+                  Parameter_Associations => New_List (\n+                    Unchecked_Convert_To (RTE (RE_Address),\n+                      Relocate_Node (N)),\n+\n+                    New_Occurrence_Of\n+                      (Elists.Node\n+                        (First_Elmt\n+                          (Access_Disp_Table (Etype (Base_Type (Dtyp))))),\n+                       Loc)))));\n+            Analyze_And_Resolve (N, PtrT);\n+         end if;\n+      end if;\n+   end Displace_Allocator_Pointer;\n+\n    ---------------------------------\n    -- Expand_Allocator_Expression --\n    ---------------------------------\n \n    procedure Expand_Allocator_Expression (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Exp    : constant Node_Id    := Expression (Expression (N));\n-      Indic  : constant Node_Id    := Subtype_Mark (Expression (N));\n       PtrT   : constant Entity_Id  := Etype (N);\n       DesigT : constant Entity_Id  := Designated_Type (PtrT);\n-      T      : constant Entity_Id  := Entity (Indic);\n-      Flist  : Node_Id;\n-      Node   : Node_Id;\n-      Temp   : Entity_Id;\n+\n+      procedure Apply_Accessibility_Check\n+        (Ref            : Node_Id;\n+         Built_In_Place : Boolean := False);\n+      --  Ada 2005 (AI-344): For an allocator with a class-wide designated\n+      --  type, generate an accessibility check to verify that the level of\n+      --  the type of the created object is not deeper than the level of the\n+      --  access type. If the type of the qualified expression is class-\n+      --  wide, then always generate the check (except in the case where it\n+      --  is known to be unnecessary, see comment below). Otherwise, only\n+      --  generate the check if the level of the qualified expression type\n+      --  is statically deeper than the access type. Although the static\n+      --  accessibility will generally have been performed as a legality\n+      --  check, it won't have been done in cases where the allocator\n+      --  appears in generic body, so a run-time check is needed in general.\n+      --  One special case is when the access type is declared in the same\n+      --  scope as the class-wide allocator, in which case the check can\n+      --  never fail, so it need not be generated. As an open issue, there\n+      --  seem to be cases where the static level associated with the\n+      --  class-wide object's underlying type is not sufficient to perform\n+      --  the proper accessibility check, such as for allocators in nested\n+      --  subprograms or accept statements initialized by class-wide formals\n+      --  when the actual originates outside at a deeper static level. The\n+      --  nested subprogram case might require passing accessibility levels\n+      --  along with class-wide parameters, and the task case seems to be\n+      --  an actual gap in the language rules that needs to be fixed by the\n+      --  ARG. ???\n+\n+      -------------------------------\n+      -- Apply_Accessibility_Check --\n+      -------------------------------\n+\n+      procedure Apply_Accessibility_Check\n+        (Ref            : Node_Id;\n+         Built_In_Place : Boolean := False)\n+      is\n+         Ref_Node : Node_Id;\n+\n+      begin\n+         --  Note: we skip the accessibility check for the VM case, since\n+         --  there does not seem to be any practical way of implementing it.\n+\n+         if Ada_Version >= Ada_05\n+           and then VM_Target = No_VM\n+           and then Is_Class_Wide_Type (DesigT)\n+           and then not Scope_Suppress (Accessibility_Check)\n+           and then\n+             (Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT)\n+               or else\n+                 (Is_Class_Wide_Type (Etype (Exp))\n+                   and then Scope (PtrT) /= Current_Scope))\n+         then\n+            --  If the allocator was built in place Ref is already a reference\n+            --  to the access object initialized to the result of the allocator\n+            --  (see Exp_Ch6.Make_Build_In_Place_Call_In_Allocator). Otherwise\n+            --  it is the entity associated with the object containing the\n+            --  address of the allocated object.\n+\n+            if Built_In_Place then\n+               Ref_Node := New_Copy (Ref);\n+            else\n+               Ref_Node := New_Reference_To (Ref, Loc);\n+            end if;\n+\n+            Insert_Action (N,\n+               Make_Raise_Program_Error (Loc,\n+                 Condition =>\n+                   Make_Op_Gt (Loc,\n+                     Left_Opnd  =>\n+                       Build_Get_Access_Level (Loc,\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix => Ref_Node,\n+                           Attribute_Name => Name_Tag)),\n+                     Right_Opnd =>\n+                       Make_Integer_Literal (Loc,\n+                         Type_Access_Level (PtrT))),\n+                 Reason => PE_Accessibility_Check_Failed));\n+         end if;\n+      end Apply_Accessibility_Check;\n+\n+      --  Local variables\n+\n+      Indic : constant Node_Id   := Subtype_Mark (Expression (N));\n+      T     : constant Entity_Id := Entity (Indic);\n+      Flist : Node_Id;\n+      Node  : Node_Id;\n+      Temp  : Entity_Id;\n \n       TagT : Entity_Id := Empty;\n       --  Type used as source for tag assignment\n@@ -387,11 +563,11 @@ package body Exp_Ch4 is\n \n       Aggr_In_Place : constant Boolean := Is_Delayed_Aggregate (Exp);\n \n-      Call_In_Place : Boolean := False;\n-\n       Tag_Assign : Node_Id;\n       Tmp_Node   : Node_Id;\n \n+   --  Start of processing for Expand_Allocator_Expression\n+\n    begin\n       if Is_Tagged_Type (T) or else Controlled_Type (T) then\n \n@@ -406,7 +582,8 @@ package body Exp_Ch4 is\n            and then Is_Build_In_Place_Function_Call (Exp)\n          then\n             Make_Build_In_Place_Call_In_Allocator (N, Exp);\n-            Call_In_Place := True;\n+            Apply_Accessibility_Check (N, Built_In_Place => True);\n+            return;\n          end if;\n \n          --    Actions inserted before:\n@@ -423,7 +600,7 @@ package body Exp_Ch4 is\n          --  that could lead to a duplication of the call, which was already\n          --  substituted for the allocator.\n \n-         if not Aggr_In_Place and then not Call_In_Place then\n+         if not Aggr_In_Place then\n             Remove_Side_Effects (Exp);\n          end if;\n \n@@ -439,100 +616,182 @@ package body Exp_Ch4 is\n          if Is_Class_Wide_Type (T) then\n             Expand_Subtype_From_Expr (Empty, T, Indic, Exp);\n \n-            Set_Expression (Expression (N),\n-              Unchecked_Convert_To (Entity (Indic), Exp));\n+            --  Ada 2005 (AI-251): If the expression is a class-wide interface\n+            --  object we generate code to move up \"this\" to reference the\n+            --  base of the object before allocating the new object.\n+\n+            --  Note that Exp'Address is recursively expanded into a call\n+            --  to Base_Address (Exp.Tag)\n+\n+            if Is_Class_Wide_Type (Etype (Exp))\n+              and then Is_Interface (Etype (Exp))\n+            then\n+               Set_Expression\n+                 (Expression (N),\n+                  Unchecked_Convert_To (Entity (Indic),\n+                    Make_Explicit_Dereference (Loc,\n+                      Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix         => Exp,\n+                          Attribute_Name => Name_Address)))));\n+\n+            else\n+               Set_Expression\n+                 (Expression (N),\n+                  Unchecked_Convert_To (Entity (Indic), Exp));\n+            end if;\n \n             Analyze_And_Resolve (Expression (N), Entity (Indic));\n          end if;\n \n-         if Aggr_In_Place then\n-            Tmp_Node :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp,\n-                Object_Definition   => New_Reference_To (PtrT, Loc),\n-                Expression          =>\n-                  Make_Allocator (Loc,\n-                    New_Reference_To (Etype (Exp), Loc)));\n+         --  Keep separate the management of allocators returning interfaces\n \n-            Set_Comes_From_Source\n-              (Expression (Tmp_Node), Comes_From_Source (N));\n+         if not Is_Interface (Directly_Designated_Type (PtrT)) then\n+            if Aggr_In_Place then\n+               Tmp_Node :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition   => New_Reference_To (PtrT, Loc),\n+                   Expression          =>\n+                     Make_Allocator (Loc,\n+                       New_Reference_To (Etype (Exp), Loc)));\n \n-            Set_No_Initialization (Expression (Tmp_Node));\n-            Insert_Action (N, Tmp_Node);\n+               Set_Comes_From_Source\n+                 (Expression (Tmp_Node), Comes_From_Source (N));\n \n-            if Controlled_Type (T)\n-              and then Ekind (PtrT) = E_Anonymous_Access_Type\n-            then\n-               --  Create local finalization list for access parameter\n+               Set_No_Initialization (Expression (Tmp_Node));\n+               Insert_Action (N, Tmp_Node);\n \n-               Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n+               if Controlled_Type (T)\n+                 and then Ekind (PtrT) = E_Anonymous_Access_Type\n+               then\n+                  --  Create local finalization list for access parameter\n+\n+                  Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n+               end if;\n+\n+               Convert_Aggr_In_Allocator (Tmp_Node, Exp);\n+            else\n+               Node := Relocate_Node (N);\n+               Set_Analyzed (Node);\n+               Insert_Action (N,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Reference_To (PtrT, Loc),\n+                   Expression          => Node));\n             end if;\n \n-            Convert_Aggr_In_Allocator (Tmp_Node, Exp);\n+         --  Ada 2005 (AI-251): Handle allocators whose designated type is an\n+         --  interface type. In this case we use the type of the qualified\n+         --  expression to allocate the object.\n+\n          else\n-            Node := Relocate_Node (N);\n-            Set_Analyzed (Node);\n-            Insert_Action (N,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Reference_To (PtrT, Loc),\n-                Expression          => Node));\n-         end if;\n+            declare\n+               Def_Id   : constant Entity_Id :=\n+                            Make_Defining_Identifier (Loc,\n+                              New_Internal_Name ('T'));\n+               New_Decl : Node_Id;\n \n-         --  Ada 2005 (AI-344): For an allocator with a class-wide designated\n-         --  type, generate an accessibility check to verify that the level of\n-         --  the type of the created object is not deeper than the level of the\n-         --  access type. If the type of the qualified expression is class-\n-         --  wide, then always generate the check (except in the case where it\n-         --  is known to be unnecessary, see comment below). Otherwise, only\n-         --  generate the check if the level of the qualified expression type\n-         --  is statically deeper than the access type. Although the static\n-         --  accessibility will generally have been performed as a legality\n-         --  check, it won't have been done in cases where the allocator\n-         --  appears in generic body, so a run-time check is needed in general.\n-         --  One special case is when the access type is declared in the same\n-         --  scope as the class-wide allocator, in which case the check can\n-         --  never fail, so it need not be generated. As an open issue, there\n-         --  seem to be cases where the static level associated with the\n-         --  class-wide object's underlying type is not sufficient to perform\n-         --  the proper accessibility check, such as for allocators in nested\n-         --  subprograms or accept statements initialized by class-wide formals\n-         --  when the actual originates outside at a deeper static level. The\n-         --  nested subprogram case might require passing accessibility levels\n-         --  along with class-wide parameters, and the task case seems to be\n-         --  an actual gap in the language rules that needs to be fixed by the\n-         --  ARG. ???\n+            begin\n+               New_Decl :=\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Def_Id,\n+                   Type_Definition =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       All_Present            => True,\n+                       Null_Exclusion_Present => False,\n+                       Constant_Present       => False,\n+                       Subtype_Indication     =>\n+                         New_Reference_To (Etype (Exp), Loc)));\n+\n+               Insert_Action (N, New_Decl);\n+\n+               --  Inherit the final chain to ensure that the expansion of the\n+               --  aggregate is correct in case of controlled types\n+\n+               if Controlled_Type (Directly_Designated_Type (PtrT)) then\n+                  Set_Associated_Final_Chain (Def_Id,\n+                    Associated_Final_Chain (PtrT));\n+               end if;\n \n-         if Ada_Version >= Ada_05\n-           and then Is_Class_Wide_Type (DesigT)\n-           and then not Scope_Suppress (Accessibility_Check)\n-           and then\n-             (Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT)\n-               or else\n-                 (Is_Class_Wide_Type (Etype (Exp))\n-                   and then Scope (PtrT) /= Current_Scope))\n-         then\n-            Insert_Action (N,\n-               Make_Raise_Program_Error (Loc,\n-                 Condition =>\n-                   Make_Op_Gt (Loc,\n-                     Left_Opnd  =>\n-                       Build_Get_Access_Level (Loc,\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix => New_Reference_To (Temp, Loc),\n-                           Attribute_Name => Name_Tag)),\n-                     Right_Opnd =>\n-                       Make_Integer_Literal (Loc,\n-                         Type_Access_Level (PtrT))),\n-                 Reason => PE_Accessibility_Check_Failed));\n+               --  Declare the object using the previous type declaration\n+\n+               if Aggr_In_Place then\n+                  Tmp_Node :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Temp,\n+                      Object_Definition   => New_Reference_To (Def_Id, Loc),\n+                      Expression          =>\n+                        Make_Allocator (Loc,\n+                          New_Reference_To (Etype (Exp), Loc)));\n+\n+                  Set_Comes_From_Source\n+                    (Expression (Tmp_Node), Comes_From_Source (N));\n+\n+                  Set_No_Initialization (Expression (Tmp_Node));\n+                  Insert_Action (N, Tmp_Node);\n+\n+                  if Controlled_Type (T)\n+                    and then Ekind (PtrT) = E_Anonymous_Access_Type\n+                  then\n+                     --  Create local finalization list for access parameter\n+\n+                     Flist :=\n+                       Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n+                  end if;\n+\n+                  Convert_Aggr_In_Allocator (Tmp_Node, Exp);\n+               else\n+                  Node := Relocate_Node (N);\n+                  Set_Analyzed (Node);\n+                  Insert_Action (N,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Temp,\n+                      Constant_Present    => True,\n+                      Object_Definition   => New_Reference_To (Def_Id, Loc),\n+                      Expression          => Node));\n+               end if;\n+\n+               --  Generate an additional object containing the address of the\n+               --  returned object. The type of this second object declaration\n+               --  is the correct type required for the common proceessing\n+               --  that is still performed by this subprogram. The displacement\n+               --  of this pointer to reference the component associated with\n+               --  the interface type will be done at the end of the common\n+               --  processing.\n+\n+               New_Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Make_Defining_Identifier (Loc,\n+                                             New_Internal_Name ('P')),\n+                   Object_Definition   => New_Reference_To (PtrT, Loc),\n+                   Expression          => Unchecked_Convert_To (PtrT,\n+                                            New_Reference_To (Temp, Loc)));\n+\n+               Insert_Action (N, New_Decl);\n+\n+               Tmp_Node := New_Decl;\n+               Temp     := Defining_Identifier (New_Decl);\n+            end;\n          end if;\n \n-         if Java_VM then\n+         Apply_Accessibility_Check (Temp);\n+\n+         --  Generate the tag assignment\n+\n+         --  Suppress the tag assignment when VM_Target because VM tags are\n+         --  represented implicitly in objects.\n+\n+         if VM_Target /= No_VM then\n+            null;\n \n-            --  Suppress the tag assignment when Java_VM because JVM tags are\n-            --  represented implicitly in objects.\n+         --  Ada 2005 (AI-251): Suppress the tag assignment with class-wide\n+         --  interface objects because in this case the tag does not change.\n \n+         elsif Is_Interface (Directly_Designated_Type (Etype (N))) then\n+            pragma Assert (Is_Class_Wide_Type\n+                            (Directly_Designated_Type (Etype (N))));\n             null;\n \n          elsif Is_Tagged_Type (T) and then not Is_Class_Wide_Type (T) then\n@@ -617,7 +876,18 @@ package body Exp_Ch4 is\n                   Attach :=  Make_Integer_Literal (Loc, 2);\n                end if;\n \n-               if not Aggr_In_Place then\n+               --  Generate an Adjust call if the object will be moved. In Ada\n+               --  2005, the object may be inherently limited, in which case\n+               --  there is no Adjust procedure, and the object is built in\n+               --  place. In Ada 95, the object can be limited but not\n+               --  inherently limited if this allocator came from a return\n+               --  statement (we're allocating the result on the secondary\n+               --  stack). In that case, the object will be moved, so we _do_\n+               --  want to Adjust.\n+\n+               if not Aggr_In_Place\n+                 and then not Is_Inherently_Limited_Type (T)\n+               then\n                   Insert_Actions (N,\n                     Make_Adjust_Call (\n                       Ref          =>\n@@ -642,6 +912,14 @@ package body Exp_Ch4 is\n          Rewrite (N, New_Reference_To (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n+         --  Ada 2005 (AI-251): Displace the pointer to reference the\n+         --  record component containing the secondary dispatch table\n+         --  of the interface type.\n+\n+         if Is_Interface (Directly_Designated_Type (PtrT)) then\n+            Displace_Allocator_Pointer (N);\n+         end if;\n+\n       elsif Aggr_In_Place then\n          Temp :=\n            Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n@@ -832,12 +1110,12 @@ package body Exp_Ch4 is\n    begin\n       --  Deal first with unpacked case, where we can call a runtime routine\n       --  except that we avoid this for targets for which are not addressable\n-      --  by bytes, and for the JVM, since the JVM does not support direct\n+      --  by bytes, and for the JVM/CIL, since they do not support direct\n       --  addressing of array components.\n \n       if not Is_Bit_Packed_Array (Typ1)\n         and then Byte_Addressable\n-        and then not Java_VM\n+        and then VM_Target = No_VM\n       then\n          --  The call we generate is:\n \n@@ -2500,71 +2778,235 @@ package body Exp_Ch4 is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Desig : Entity_Id;\n       Temp  : Entity_Id;\n-      Node  : Node_Id;\n+      Nod   : Node_Id;\n \n-      function Is_Local_Access_Discriminant (N : Node_Id) return Boolean;\n-      --  If the allocator is for an access discriminant of a stack-allocated\n-      --  object, the discriminant can be allocated locally as well, to ensure\n-      --  that its lifetime does not exceed that of the enclosing object.\n-      --  This is an optimization mandated / suggested by Ada 2005 AI-162.\n+      procedure Complete_Coextension_Finalization;\n+      --  Generate finalization calls for all nested coextensions of N. This\n+      --  routine may allocate list controllers if necessary.\n \n-      ----------------------------------\n-      -- Is_Local_Access_Discriminant --\n-      ----------------------------------\n+      procedure Rewrite_Coextension (N : Node_Id);\n+      --  Static coextensions have the same lifetime as the entity they\n+      --  constrain. Such occurences can be rewritten as aliased objects\n+      --  and their unrestricted access used instead of the coextension.\n \n-      function Is_Local_Access_Discriminant (N : Node_Id) return Boolean is\n-         Decl : Node_Id;\n-         Temp : Entity_Id;\n+      ---------------------------------------\n+      -- Complete_Coextension_Finalization --\n+      ---------------------------------------\n \n-      begin\n-         if Nkind (Parent (N)) = N_Index_Or_Discriminant_Constraint\n-           and then not Is_Coextension (N)\n-           and then not Is_Record_Type (Current_Scope)\n-         then\n-            Temp :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_Internal_Name ('T'));\n+      procedure Complete_Coextension_Finalization is\n+         Coext      : Node_Id;\n+         Coext_Elmt : Elmt_Id;\n+         Flist      : Node_Id;\n+         Ref        : Node_Id;\n \n-            Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp,\n-                Aliased_Present     => True,\n-                Object_Definition   => New_Occurrence_Of (Etyp, Loc));\n+         function Inside_A_Return_Statement (N : Node_Id) return Boolean;\n+         --  Determine whether node N is part of a return statement\n+\n+         function Needs_Initialization_Call (N : Node_Id) return Boolean;\n+         --  Determine whether node N is a subtype indicator allocator which\n+         --  asts a coextension. Such coextensions need initialization.\n+\n+         -------------------------------\n+         -- Inside_A_Return_Statement --\n+         -------------------------------\n+\n+         function Inside_A_Return_Statement (N : Node_Id) return Boolean is\n+            P : Node_Id;\n+\n+         begin\n+            P := Parent (N);\n+            while Present (P) loop\n+               if Nkind (P) = N_Extended_Return_Statement\n+                 or else Nkind (P) = N_Return_Statement\n+               then\n+                  return True;\n+\n+               --  Stop the traversal when we reach a subprogram body\n+\n+               elsif Nkind (P) = N_Subprogram_Body then\n+                  return False;\n+               end if;\n+\n+               P := Parent (P);\n+            end loop;\n+\n+            return False;\n+         end Inside_A_Return_Statement;\n+\n+         -------------------------------\n+         -- Needs_Initialization_Call --\n+         -------------------------------\n+\n+         function Needs_Initialization_Call (N : Node_Id) return Boolean is\n+            Obj_Decl : Node_Id;\n+\n+         begin\n+            if Nkind (N) = N_Explicit_Dereference\n+              and then Nkind (Prefix (N)) = N_Identifier\n+              and then Nkind (Parent (Entity (Prefix (N)))) =\n+                         N_Object_Declaration\n+            then\n+               Obj_Decl := Parent (Entity (Prefix (N)));\n \n-            if Nkind (Expression (N)) = N_Qualified_Expression then\n-               Set_Expression (Decl, Expression (Expression (N)));\n+               return\n+                 Present (Expression (Obj_Decl))\n+                   and then Nkind (Expression (Obj_Decl)) = N_Allocator\n+                   and then Nkind (Expression (Expression (Obj_Decl))) /=\n+                              N_Qualified_Expression;\n             end if;\n \n+            return False;\n+         end Needs_Initialization_Call;\n+\n+      --  Start of processing for Complete_Coextension_Finalization\n+\n+      begin\n+         --  When a coextension root is inside a return statement, we need to\n+         --  use the finalization chain of the function's scope. This does not\n+         --  apply for controlled named access types because in those cases we\n+         --  can use the finalization chain of the type itself.\n+\n+         if Inside_A_Return_Statement (N)\n+           and then\n+             (Ekind (PtrT) = E_Anonymous_Access_Type\n+                or else\n+                  (Ekind (PtrT) = E_Access_Type\n+                     and then No (Associated_Final_Chain (PtrT))))\n+         then\n             declare\n-               Nod : Node_Id;\n+               Decl    : Node_Id;\n+               Outer_S : Entity_Id;\n+               S       : Entity_Id := Current_Scope;\n \n             begin\n-               Nod := Parent (N);\n-               while Present (Nod) loop\n-                  exit when\n-                      Nkind (Nod) in N_Statement_Other_Than_Procedure_Call\n-                    or else Nkind (Nod) = N_Procedure_Call_Statement\n-                    or else Nkind (Nod) in N_Declaration;\n-                  Nod := Parent (Nod);\n+               while Present (S) and then S /= Standard_Standard loop\n+                  if Ekind (S) = E_Function then\n+                     Outer_S := Scope (S);\n+\n+                     --  Retrieve the declaration of the body\n+\n+                     Decl := Parent (Parent (\n+                               Corresponding_Body (Parent (Parent (S)))));\n+                     exit;\n+                  end if;\n+\n+                  S := Scope (S);\n                end loop;\n \n-               Insert_Before (Nod, Decl);\n-               Analyze (Decl);\n+               --  Push the scope of the function body since we are inserting\n+               --  the list before the body, but we are currently in the body\n+               --  itself. Override the finalization list of PtrT since the\n+               --  finalization context is now different.\n+\n+               Push_Scope (Outer_S);\n+               Build_Final_List (Decl, PtrT);\n+               Pop_Scope;\n             end;\n \n-            Rewrite (N,\n-              Make_Attribute_Reference (Loc,\n-                Prefix => New_Occurrence_Of (Temp, Loc),\n-                Attribute_Name => Name_Unrestricted_Access));\n+         --  The root allocator may not be controlled, but it still needs a\n+         --  finalization list for all nested coextensions.\n \n-            Analyze_And_Resolve (N, PtrT);\n+         elsif No (Associated_Final_Chain (PtrT)) then\n+            Build_Final_List (N, PtrT);\n+         end if;\n \n-            return True;\n+         Flist :=\n+           Make_Selected_Component (Loc,\n+             Prefix =>\n+               New_Reference_To (Associated_Final_Chain (PtrT), Loc),\n+             Selector_Name =>\n+               Make_Identifier (Loc, Name_F));\n+\n+         Coext_Elmt := First_Elmt (Coextensions (N));\n+         while Present (Coext_Elmt) loop\n+            Coext := Node (Coext_Elmt);\n+\n+            --  Generate:\n+            --    typ! (coext.all)\n+\n+            if Nkind (Coext) = N_Identifier then\n+               Ref := Make_Unchecked_Type_Conversion (Loc,\n+                        Subtype_Mark =>\n+                          New_Reference_To (Etype (Coext), Loc),\n+                        Expression =>\n+                          Make_Explicit_Dereference (Loc,\n+                            New_Copy_Tree (Coext)));\n+            else\n+               Ref := New_Copy_Tree (Coext);\n+            end if;\n \n-         else\n-            return False;\n+            --  Generate:\n+            --    initialize (Ref)\n+            --    attach_to_final_list (Ref, Flist, 2)\n+\n+            if Needs_Initialization_Call (Coext) then\n+               Insert_Actions (N,\n+                 Make_Init_Call (\n+                   Ref         => Ref,\n+                   Typ         => Etype (Coext),\n+                   Flist_Ref   => Flist,\n+                   With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n+\n+            --  Generate:\n+            --    attach_to_final_list (Ref, Flist, 2)\n+\n+            else\n+               Insert_Action (N,\n+                 Make_Attach_Call (\n+                   Obj_Ref     => Ref,\n+                   Flist_Ref   => New_Copy_Tree (Flist),\n+                   With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n+            end if;\n+\n+            Next_Elmt (Coext_Elmt);\n+         end loop;\n+      end Complete_Coextension_Finalization;\n+\n+      -------------------------\n+      -- Rewrite_Coextension --\n+      -------------------------\n+\n+      procedure Rewrite_Coextension (N : Node_Id) is\n+         Temp : constant Node_Id :=\n+                  Make_Defining_Identifier (Loc,\n+                    New_Internal_Name ('C'));\n+\n+         --  Generate:\n+         --    Cnn : aliased Etyp;\n+\n+         Decl : constant Node_Id :=\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => Temp,\n+                    Aliased_Present     => True,\n+                    Object_Definition   =>\n+                      New_Occurrence_Of (Etyp, Loc));\n+         Nod  : Node_Id;\n+\n+      begin\n+         if Nkind (Expression (N)) = N_Qualified_Expression then\n+            Set_Expression (Decl, Expression (Expression (N)));\n          end if;\n-      end Is_Local_Access_Discriminant;\n+\n+         --  Find the proper insertion node for the declaration\n+\n+         Nod := Parent (N);\n+         while Present (Nod) loop\n+            exit when Nkind (Nod) in N_Statement_Other_Than_Procedure_Call\n+              or else Nkind (Nod) = N_Procedure_Call_Statement\n+              or else Nkind (Nod) in N_Declaration;\n+            Nod := Parent (Nod);\n+         end loop;\n+\n+         Insert_Before (Nod, Decl);\n+         Analyze (Decl);\n+\n+         Rewrite (N,\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Occurrence_Of (Temp, Loc),\n+             Attribute_Name => Name_Unrestricted_Access));\n+\n+         Analyze_And_Resolve (N, PtrT);\n+      end Rewrite_Coextension;\n \n    --  Start of processing for Expand_N_Allocator\n \n@@ -2582,7 +3024,7 @@ package body Exp_Ch4 is\n \n       if Present (Storage_Pool (N)) then\n          if Is_RTE (Storage_Pool (N), RE_SS_Pool) then\n-            if not Java_VM then\n+            if VM_Target = No_VM then\n                Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n             end if;\n \n@@ -2664,324 +3106,349 @@ package body Exp_Ch4 is\n       --  instead of an allocator we create a local value and constrain the\n       --  the enclosing object with the corresponding access attribute.\n \n-      if Is_Local_Access_Discriminant (N) then\n+      if Is_Static_Coextension (N) then\n+         Rewrite_Coextension (N);\n          return;\n       end if;\n \n+      --  The current allocator creates an object which may contain nested\n+      --  coextensions. Use the current allocator's finalization list to\n+      --  generate finalization call for all nested coextensions.\n+\n+      if Is_Coextension_Root (N) then\n+         Complete_Coextension_Finalization;\n+      end if;\n+\n       --  Handle case of qualified expression (other than optimization above)\n \n       if Nkind (Expression (N)) = N_Qualified_Expression then\n          Expand_Allocator_Expression (N);\n+         return;\n+      end if;\n \n-         --  If the allocator is for a type which requires initialization, and\n-         --  there is no initial value (i.e. operand is a subtype indication\n-         --  rather than a qualifed expression), then we must generate a call\n-         --  to the initialization routine. This is done using an expression\n-         --  actions node:\n-         --\n-         --     [Pnnn : constant ptr_T := new (T); Init (Pnnn.all,...); Pnnn]\n-         --\n-         --  Here ptr_T is the pointer type for the allocator, and T is the\n-         --  subtype of the allocator. A special case arises if the designated\n-         --  type of the access type is a task or contains tasks. In this case\n-         --  the call to Init (Temp.all ...) is replaced by code that ensures\n-         --  that tasks get activated (see Exp_Ch9.Build_Task_Allocate_Block\n-         --  for details). In addition, if the type T is a task T, then the\n-         --  first argument to Init must be converted to the task record type.\n+      --  If the allocator is for a type which requires initialization, and\n+      --  there is no initial value (i.e. operand is a subtype indication\n+      --  rather than a qualifed expression), then we must generate a call\n+      --  to the initialization routine. This is done using an expression\n+      --  actions node:\n \n-      else\n-         declare\n-            T            : constant Entity_Id  := Entity (Expression (N));\n-            Init         : Entity_Id;\n-            Arg1         : Node_Id;\n-            Args         : List_Id;\n-            Decls        : List_Id;\n-            Decl         : Node_Id;\n-            Discr        : Elmt_Id;\n-            Flist        : Node_Id;\n-            Temp_Decl    : Node_Id;\n-            Temp_Type    : Entity_Id;\n-            Attach_Level : Uint;\n+      --     [Pnnn : constant ptr_T := new (T); Init (Pnnn.all,...); Pnnn]\n \n-         begin\n-            if No_Initialization (N) then\n-               null;\n+      --  Here ptr_T is the pointer type for the allocator, and T is the\n+      --  subtype of the allocator. A special case arises if the designated\n+      --  type of the access type is a task or contains tasks. In this case\n+      --  the call to Init (Temp.all ...) is replaced by code that ensures\n+      --  that tasks get activated (see Exp_Ch9.Build_Task_Allocate_Block\n+      --  for details). In addition, if the type T is a task T, then the\n+      --  first argument to Init must be converted to the task record type.\n \n-            --  Case of no initialization procedure present\n+      declare\n+         T            : constant Entity_Id := Entity (Expression (N));\n+         Init         : Entity_Id;\n+         Arg1         : Node_Id;\n+         Args         : List_Id;\n+         Decls        : List_Id;\n+         Decl         : Node_Id;\n+         Discr        : Elmt_Id;\n+         Flist        : Node_Id;\n+         Temp_Decl    : Node_Id;\n+         Temp_Type    : Entity_Id;\n+         Attach_Level : Uint;\n \n-            elsif not Has_Non_Null_Base_Init_Proc (T) then\n+      begin\n+         if No_Initialization (N) then\n+            null;\n \n-               --  Case of simple initialization required\n+         --  Case of no initialization procedure present\n \n-               if Needs_Simple_Initialization (T) then\n-                  Rewrite (Expression (N),\n-                    Make_Qualified_Expression (Loc,\n-                      Subtype_Mark => New_Occurrence_Of (T, Loc),\n-                      Expression   => Get_Simple_Init_Val (T, Loc)));\n+         elsif not Has_Non_Null_Base_Init_Proc (T) then\n \n-                  Analyze_And_Resolve (Expression (Expression (N)), T);\n-                  Analyze_And_Resolve (Expression (N), T);\n-                  Set_Paren_Count (Expression (Expression (N)), 1);\n-                  Expand_N_Allocator (N);\n+            --  Case of simple initialization required\n \n-               --  No initialization required\n+            if Needs_Simple_Initialization (T) then\n+               Rewrite (Expression (N),\n+                 Make_Qualified_Expression (Loc,\n+                   Subtype_Mark => New_Occurrence_Of (T, Loc),\n+                   Expression   => Get_Simple_Init_Val (T, Loc)));\n \n-               else\n-                  null;\n-               end if;\n+               Analyze_And_Resolve (Expression (Expression (N)), T);\n+               Analyze_And_Resolve (Expression (N), T);\n+               Set_Paren_Count     (Expression (Expression (N)), 1);\n+               Expand_N_Allocator  (N);\n \n-            --  Case of initialization procedure present, must be called\n+            --  No initialization required\n \n             else\n-               Init := Base_Init_Proc (T);\n-               Node := N;\n-               Temp :=\n-                 Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n+               null;\n+            end if;\n \n-               --  Construct argument list for the initialization routine call\n-               --  The CPP constructor needs the address directly\n+         --  Case of initialization procedure present, must be called\n \n-               if Is_CPP_Class (T) then\n-                  Arg1 := New_Reference_To (Temp, Loc);\n-                  Temp_Type := T;\n+         else\n+            Init := Base_Init_Proc (T);\n+            Nod  := N;\n+            Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n \n-               else\n-                  Arg1 :=\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix => New_Reference_To (Temp, Loc));\n-                  Set_Assignment_OK (Arg1);\n-                  Temp_Type := PtrT;\n+            --  Construct argument list for the initialization routine call.\n+            --  The CPP constructor needs the address directly\n \n-                  --  The initialization procedure expects a specific type. if\n-                  --  the context is access to class wide, indicate that the\n-                  --  object being allocated has the right specific type.\n+            if Is_CPP_Class (T) then\n+               Arg1 := New_Reference_To (Temp, Loc);\n+               Temp_Type := T;\n \n-                  if Is_Class_Wide_Type (Dtyp) then\n-                     Arg1 := Unchecked_Convert_To (T, Arg1);\n-                  end if;\n-               end if;\n+            else\n+               Arg1 := Make_Explicit_Dereference (Loc,\n+                         Prefix => New_Reference_To (Temp, Loc));\n+               Set_Assignment_OK (Arg1);\n+               Temp_Type := PtrT;\n \n-               --  If designated type is a concurrent type or if it is private\n-               --  type whose definition is a concurrent type, the first\n-               --  argument in the Init routine has to be unchecked conversion\n-               --  to the corresponding record type. If the designated type is\n-               --  a derived type, we also convert the argument to its root\n-               --  type.\n+               --  The initialization procedure expects a specific type. if\n+               --  the context is access to class wide, indicate that the\n+               --  object being allocated has the right specific type.\n \n-               if Is_Concurrent_Type (T) then\n-                  Arg1 :=\n-                    Unchecked_Convert_To (Corresponding_Record_Type (T), Arg1);\n+               if Is_Class_Wide_Type (Dtyp) then\n+                  Arg1 := Unchecked_Convert_To (T, Arg1);\n+               end if;\n+            end if;\n \n-               elsif Is_Private_Type (T)\n-                 and then Present (Full_View (T))\n-                 and then Is_Concurrent_Type (Full_View (T))\n-               then\n-                  Arg1 :=\n-                    Unchecked_Convert_To\n-                      (Corresponding_Record_Type (Full_View (T)), Arg1);\n+            --  If designated type is a concurrent type or if it is private\n+            --  type whose definition is a concurrent type, the first argument\n+            --  in the Init routine has to be unchecked conversion to the\n+            --  corresponding record type. If the designated type is a derived\n+            --  type, we also convert the argument to its root type.\n \n-               elsif Etype (First_Formal (Init)) /= Base_Type (T) then\n+            if Is_Concurrent_Type (T) then\n+               Arg1 :=\n+                 Unchecked_Convert_To (Corresponding_Record_Type (T), Arg1);\n \n-                  declare\n-                     Ftyp : constant Entity_Id := Etype (First_Formal (Init));\n+            elsif Is_Private_Type (T)\n+              and then Present (Full_View (T))\n+              and then Is_Concurrent_Type (Full_View (T))\n+            then\n+               Arg1 :=\n+                 Unchecked_Convert_To\n+                   (Corresponding_Record_Type (Full_View (T)), Arg1);\n \n-                  begin\n-                     Arg1 := OK_Convert_To (Etype (Ftyp), Arg1);\n-                     Set_Etype (Arg1, Ftyp);\n-                  end;\n-               end if;\n+            elsif Etype (First_Formal (Init)) /= Base_Type (T) then\n+               declare\n+                  Ftyp : constant Entity_Id := Etype (First_Formal (Init));\n+\n+               begin\n+                  Arg1 := OK_Convert_To (Etype (Ftyp), Arg1);\n+                  Set_Etype (Arg1, Ftyp);\n+               end;\n+            end if;\n \n-               Args := New_List (Arg1);\n+            Args := New_List (Arg1);\n \n-               --  For the task case, pass the Master_Id of the access type as\n-               --  the value of the _Master parameter, and _Chain as the value\n-               --  of the _Chain parameter (_Chain will be defined as part of\n-               --  the generated code for the allocator).\n+            --  For the task case, pass the Master_Id of the access type as\n+            --  the value of the _Master parameter, and _Chain as the value\n+            --  of the _Chain parameter (_Chain will be defined as part of\n+            --  the generated code for the allocator).\n \n-               --  In Ada 2005, the context may be a function that returns an\n-               --  anonymous access type. In that case the Master_Id has been\n-               --  created when expanding the function declaration.\n+            --  In Ada 2005, the context may be a function that returns an\n+            --  anonymous access type. In that case the Master_Id has been\n+            --  created when expanding the function declaration.\n \n-               if Has_Task (T) then\n-                  if No (Master_Id (Base_Type (PtrT))) then\n+            if Has_Task (T) then\n+               if No (Master_Id (Base_Type (PtrT))) then\n \n-                     --  The designated type was an incomplete type, and the\n-                     --  access type did not get expanded. Salvage it now.\n+                  --  If we have a non-library level task with the restriction\n+                  --  No_Task_Hierarchy set, then no point in expanding.\n \n-                     pragma Assert (Present (Parent (Base_Type (PtrT))));\n-                     Expand_N_Full_Type_Declaration\n-                       (Parent (Base_Type (PtrT)));\n+                  if not Is_Library_Level_Entity (T)\n+                    and then Restriction_Active (No_Task_Hierarchy)\n+                  then\n+                     return;\n                   end if;\n \n-                  --  If the context of the allocator is a declaration or an\n-                  --  assignment, we can generate a meaningful image for it,\n-                  --  even though subsequent assignments might remove the\n-                  --  connection between task and entity. We build this image\n-                  --  when the left-hand side is a simple variable, a simple\n-                  --  indexed assignment or a simple selected component.\n-\n-                  if Nkind (Parent (N)) = N_Assignment_Statement then\n-                     declare\n-                        Nam : constant Node_Id := Name (Parent (N));\n-\n-                     begin\n-                        if Is_Entity_Name (Nam) then\n-                           Decls :=\n-                             Build_Task_Image_Decls (\n-                               Loc,\n-                                 New_Occurrence_Of\n-                                   (Entity (Nam), Sloc (Nam)), T);\n-\n-                        elsif (Nkind (Nam) = N_Indexed_Component\n-                                or else Nkind (Nam) = N_Selected_Component)\n-                          and then Is_Entity_Name (Prefix (Nam))\n-                        then\n-                           Decls :=\n-                             Build_Task_Image_Decls\n-                               (Loc, Nam, Etype (Prefix (Nam)));\n-                        else\n-                           Decls := Build_Task_Image_Decls (Loc, T, T);\n-                        end if;\n-                     end;\n+                  --  The designated type was an incomplete type, and the\n+                  --  access type did not get expanded. Salvage it now.\n \n-                  elsif Nkind (Parent (N)) = N_Object_Declaration then\n-                     Decls :=\n-                       Build_Task_Image_Decls (\n-                          Loc, Defining_Identifier (Parent (N)), T);\n+                  pragma Assert (Present (Parent (Base_Type (PtrT))));\n+                  Expand_N_Full_Type_Declaration (Parent (Base_Type (PtrT)));\n+               end if;\n \n-                  else\n-                     Decls := Build_Task_Image_Decls (Loc, T, T);\n-                  end if;\n+               --  If the context of the allocator is a declaration or an\n+               --  assignment, we can generate a meaningful image for it,\n+               --  even though subsequent assignments might remove the\n+               --  connection between task and entity. We build this image\n+               --  when the left-hand side is a simple variable, a simple\n+               --  indexed assignment or a simple selected component.\n \n-                  Append_To (Args,\n-                    New_Reference_To\n-                      (Master_Id (Base_Type (Root_Type (PtrT))), Loc));\n-                  Append_To (Args, Make_Identifier (Loc, Name_uChain));\n+               if Nkind (Parent (N)) = N_Assignment_Statement then\n+                  declare\n+                     Nam : constant Node_Id := Name (Parent (N));\n \n-                  Decl := Last (Decls);\n-                  Append_To (Args,\n-                    New_Occurrence_Of (Defining_Identifier (Decl), Loc));\n+                  begin\n+                     if Is_Entity_Name (Nam) then\n+                        Decls :=\n+                          Build_Task_Image_Decls (\n+                            Loc,\n+                              New_Occurrence_Of\n+                                (Entity (Nam), Sloc (Nam)), T);\n+\n+                     elsif (Nkind (Nam) = N_Indexed_Component\n+                             or else Nkind (Nam) = N_Selected_Component)\n+                       and then Is_Entity_Name (Prefix (Nam))\n+                     then\n+                        Decls :=\n+                          Build_Task_Image_Decls\n+                            (Loc, Nam, Etype (Prefix (Nam)));\n+                     else\n+                        Decls := Build_Task_Image_Decls (Loc, T, T);\n+                     end if;\n+                  end;\n \n-               --  Has_Task is false, Decls not used\n+               elsif Nkind (Parent (N)) = N_Object_Declaration then\n+                  Decls :=\n+                    Build_Task_Image_Decls (\n+                       Loc, Defining_Identifier (Parent (N)), T);\n \n                else\n-                  Decls := No_List;\n+                  Decls := Build_Task_Image_Decls (Loc, T, T);\n                end if;\n \n-               --  Add discriminants if discriminated type\n+               Append_To (Args,\n+                 New_Reference_To\n+                   (Master_Id (Base_Type (Root_Type (PtrT))), Loc));\n+               Append_To (Args, Make_Identifier (Loc, Name_uChain));\n \n-               declare\n-                  Dis : Boolean := False;\n-                  Typ : Entity_Id;\n+               Decl := Last (Decls);\n+               Append_To (Args,\n+                 New_Occurrence_Of (Defining_Identifier (Decl), Loc));\n \n-               begin\n-                  if Has_Discriminants (T) then\n-                     Dis := True;\n-                     Typ := T;\n+            --  Has_Task is false, Decls not used\n \n-                  elsif Is_Private_Type (T)\n-                    and then Present (Full_View (T))\n-                    and then Has_Discriminants (Full_View (T))\n+            else\n+               Decls := No_List;\n+            end if;\n+\n+            --  Add discriminants if discriminated type\n+\n+            declare\n+               Dis : Boolean := False;\n+               Typ : Entity_Id;\n+\n+            begin\n+               if Has_Discriminants (T) then\n+                  Dis := True;\n+                  Typ := T;\n+\n+               elsif Is_Private_Type (T)\n+                 and then Present (Full_View (T))\n+                 and then Has_Discriminants (Full_View (T))\n+               then\n+                  Dis := True;\n+                  Typ := Full_View (T);\n+               end if;\n+\n+               if Dis then\n+                  --  If the allocated object will be constrained by the\n+                  --  default values for discriminants, then build a\n+                  --  subtype with those defaults, and change the allocated\n+                  --  subtype to that. Note that this happens in fewer\n+                  --  cases in Ada 2005 (AI-363).\n+\n+                  if not Is_Constrained (Typ)\n+                    and then Present (Discriminant_Default_Value\n+                                       (First_Discriminant (Typ)))\n+                    and then (Ada_Version < Ada_05\n+                               or else not Has_Constrained_Partial_View (Typ))\n                   then\n-                     Dis := True;\n-                     Typ := Full_View (T);\n+                     Typ := Build_Default_Subtype (Typ, N);\n+                     Set_Expression (N, New_Reference_To (Typ, Loc));\n                   end if;\n \n-                  if Dis then\n-                     --  If the allocated object will be constrained by the\n-                     --  default values for discriminants, then build a\n-                     --  subtype with those defaults, and change the allocated\n-                     --  subtype to that. Note that this happens in fewer\n-                     --  cases in Ada 2005 (AI-363).\n-\n-                     if not Is_Constrained (Typ)\n-                       and then Present (Discriminant_Default_Value\n-                                         (First_Discriminant (Typ)))\n-                       and then (Ada_Version < Ada_05\n-                                or else not Has_Constrained_Partial_View (Typ))\n+                  Discr := First_Elmt (Discriminant_Constraint (Typ));\n+                  while Present (Discr) loop\n+                     Nod := Node (Discr);\n+                     Append (New_Copy_Tree (Node (Discr)), Args);\n+\n+                     --  AI-416: when the discriminant constraint is an\n+                     --  anonymous access type make sure an accessibility\n+                     --  check is inserted if necessary (3.10.2(22.q/2))\n+\n+                     if Ada_Version >= Ada_05\n+                       and then Ekind (Etype (Nod)) = E_Anonymous_Access_Type\n                      then\n-                        Typ := Build_Default_Subtype (Typ, N);\n-                        Set_Expression (N, New_Reference_To (Typ, Loc));\n+                        Apply_Accessibility_Check (Nod, Typ);\n                      end if;\n \n-                     Discr := First_Elmt (Discriminant_Constraint (Typ));\n-                     while Present (Discr) loop\n-                        Node := Elists.Node (Discr);\n-                        Append (New_Copy_Tree (Elists.Node (Discr)), Args);\n+                     Next_Elmt (Discr);\n+                  end loop;\n+               end if;\n+            end;\n \n-                        --  AI-416: when the discriminant constraint is an\n-                        --  anonymous access type make sure an accessibility\n-                        --  check is inserted if necessary (3.10.2(22.q/2))\n+            --  We set the allocator as analyzed so that when we analyze the\n+            --  expression actions node, we do not get an unwanted recursive\n+            --  expansion of the allocator expression.\n \n-                        if Ada_Version >= Ada_05\n-                          and then\n-                            Ekind (Etype (Node)) = E_Anonymous_Access_Type\n-                        then\n-                           Apply_Accessibility_Check (Node, Typ);\n-                        end if;\n+            Set_Analyzed (N, True);\n+            Nod := Relocate_Node (N);\n \n-                        Next_Elmt (Discr);\n-                     end loop;\n-                  end if;\n-               end;\n+            --  Here is the transformation:\n+            --    input:  new T\n+            --    output: Temp : constant ptr_T := new T;\n+            --            Init (Temp.all, ...);\n+            --    <CTRL>  Attach_To_Final_List (Finalizable (Temp.all));\n+            --    <CTRL>  Initialize (Finalizable (Temp.all));\n \n-               --  We set the allocator as analyzed so that when we analyze the\n-               --  expression actions node, we do not get an unwanted recursive\n-               --  expansion of the allocator expression.\n+            --  Here ptr_T is the pointer type for the allocator, and is the\n+            --  subtype of the allocator.\n \n-               Set_Analyzed (N, True);\n-               Node := Relocate_Node (N);\n+            Temp_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (Temp_Type, Loc),\n+                Expression          => Nod);\n \n-               --  Here is the transformation:\n-               --    input:  new T\n-               --    output: Temp : constant ptr_T := new T;\n-               --            Init (Temp.all, ...);\n-               --    <CTRL>  Attach_To_Final_List (Finalizable (Temp.all));\n-               --    <CTRL>  Initialize (Finalizable (Temp.all));\n+            Set_Assignment_OK (Temp_Decl);\n \n-               --  Here ptr_T is the pointer type for the allocator, and is the\n-               --  subtype of the allocator.\n+            if Is_CPP_Class (T) then\n+               Set_Aliased_Present (Temp_Decl);\n+            end if;\n \n-               Temp_Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Constant_Present    => True,\n-                   Object_Definition   => New_Reference_To (Temp_Type, Loc),\n-                   Expression          => Node);\n+            Insert_Action (N, Temp_Decl, Suppress => All_Checks);\n \n-               Set_Assignment_OK (Temp_Decl);\n+            --  If the designated type is a task type or contains tasks,\n+            --  create block to activate created tasks, and insert\n+            --  declaration for Task_Image variable ahead of call.\n \n-               if Is_CPP_Class (T) then\n-                  Set_Aliased_Present (Temp_Decl);\n-               end if;\n+            if Has_Task (T) then\n+               declare\n+                  L   : constant List_Id := New_List;\n+                  Blk : Node_Id;\n \n-               Insert_Action (N, Temp_Decl, Suppress => All_Checks);\n+               begin\n+                  Build_Task_Allocate_Block (L, Nod, Args);\n+                  Blk := Last (L);\n \n-               --  If the designated type is a task type or contains tasks,\n-               --  create block to activate created tasks, and insert\n-               --  declaration for Task_Image variable ahead of call.\n+                  Insert_List_Before (First (Declarations (Blk)), Decls);\n+                  Insert_Actions (N, L);\n+               end;\n \n-               if Has_Task (T) then\n-                  declare\n-                     L   : constant List_Id := New_List;\n-                     Blk : Node_Id;\n+            else\n+               Insert_Action (N,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (Init, Loc),\n+                   Parameter_Associations => Args));\n+            end if;\n \n-                  begin\n-                     Build_Task_Allocate_Block (L, Node, Args);\n-                     Blk := Last (L);\n+            if Controlled_Type (T) then\n \n-                     Insert_List_Before (First (Declarations (Blk)), Decls);\n-                     Insert_Actions (N, L);\n-                  end;\n+               --  Postpone the generation of a finalization call for the\n+               --  current allocator if it acts as a coextension.\n \n-               else\n-                  Insert_Action (N,\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name => New_Reference_To (Init, Loc),\n-                      Parameter_Associations => Args));\n-               end if;\n+               if Is_Coextension (N) then\n+                  if No (Coextensions (N)) then\n+                     Set_Coextensions (N, New_Elmt_List);\n+                  end if;\n+\n+                  Append_Elmt (New_Copy_Tree (Arg1), Coextensions (N));\n \n-               if Controlled_Type (T) then\n+               else\n                   Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n \n                   --  Anonymous access types created for access parameters\n@@ -2994,9 +3461,9 @@ package body Exp_Ch4 is\n                   --  Work needed for access discriminants in Ada 2005 ???\n \n                   if Ekind (PtrT) = E_Anonymous_Access_Type\n-                      and then\n-                        Nkind (Associated_Node_For_Itype (PtrT))\n-                          not in N_Subprogram_Specification\n+                       and then\n+                         Nkind (Associated_Node_For_Itype (PtrT))\n+                           not in N_Subprogram_Specification\n                   then\n                      Attach_Level := Uint_1;\n                   else\n@@ -3008,60 +3475,32 @@ package body Exp_Ch4 is\n                       Ref          => New_Copy_Tree (Arg1),\n                       Typ          => T,\n                       Flist_Ref    => Flist,\n-                      With_Attach  => Make_Integer_Literal (Loc,\n-                        Attach_Level)));\n-               end if;\n-\n-               if Is_CPP_Class (T) then\n-                  Rewrite (N,\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix => New_Reference_To (Temp, Loc),\n-                      Attribute_Name => Name_Unchecked_Access));\n-               else\n-                  Rewrite (N, New_Reference_To (Temp, Loc));\n+                      With_Attach  => Make_Integer_Literal\n+                                        (Loc, Attach_Level)));\n                end if;\n+            end if;\n \n-               Analyze_And_Resolve (N, PtrT);\n+            if Is_CPP_Class (T) then\n+               Rewrite (N,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => New_Reference_To (Temp, Loc),\n+                   Attribute_Name => Name_Unchecked_Access));\n+            else\n+               Rewrite (N, New_Reference_To (Temp, Loc));\n             end if;\n-         end;\n-      end if;\n \n-      --  Ada 2005 (AI-251): If the allocated object is accessed through an\n-      --  access to class-wide interface we force the displacement of the\n-      --  pointer to the allocated object to reference the corresponding\n-      --  secondary dispatch table.\n+            Analyze_And_Resolve (N, PtrT);\n+         end if;\n+      end;\n \n-      if Is_Class_Wide_Type (Dtyp)\n+      --  Ada 2005 (AI-251): If the allocator is for a class-wide interface\n+      --  object that has been rewritten as a reference, we displace \"this\"\n+      --  to reference properly its secondary dispatch table.\n+\n+      if Nkind (N) = N_Identifier\n         and then Is_Interface (Dtyp)\n       then\n-         declare\n-            Saved_Typ : constant Entity_Id := Etype (N);\n-\n-         begin\n-            --  1) Get access to the allocated object\n-\n-            Rewrite (N,\n-              Make_Explicit_Dereference (Loc,\n-                Relocate_Node (N)));\n-            Set_Etype (N, Etyp);\n-            Set_Analyzed (N);\n-\n-            --  2) Add the conversion to displace the pointer to reference\n-            --     the secondary dispatch table.\n-\n-            Rewrite (N, Convert_To (Dtyp, Relocate_Node (N)));\n-            Analyze_And_Resolve (N, Dtyp);\n-\n-            --  3) The 'access to the secondary dispatch table will be used as\n-            --     the value returned by the allocator.\n-\n-            Rewrite (N,\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => Relocate_Node (N),\n-                Attribute_Name => Name_Access));\n-            Set_Etype (N, Saved_Typ);\n-            Set_Analyzed (N);\n-         end;\n+         Displace_Allocator_Pointer (N);\n       end if;\n \n    exception\n@@ -3303,6 +3742,7 @@ package body Exp_Ch4 is\n         and then Nkind (Rop) in N_Has_Entity\n         and then Etype (Lop) = Entity (Rop)\n         and then Comes_From_Source (N)\n+        and then VM_Target = No_VM\n       then\n          Substitute_Valid_Check;\n          return;\n@@ -3341,6 +3781,7 @@ package body Exp_Ch4 is\n               and then Nkind (Prefix (Hi_Orig)) in N_Has_Entity\n               and then Entity (Prefix (Hi_Orig)) = Etype (Lop)\n               and then Comes_From_Source (N)\n+              and then VM_Target = No_VM\n             then\n                Substitute_Valid_Check;\n                return;\n@@ -3416,12 +3857,12 @@ package body Exp_Ch4 is\n \n             if Is_Tagged_Type (Typ) then\n \n-               --  No expansion will be performed when Java_VM, as the JVM back\n-               --  end will handle the membership tests directly (tags are not\n-               --  explicitly represented in Java objects, so the normal tagged\n-               --  membership expansion is not what we want).\n+               --  No expansion will be performed when VM_Target, as the VM\n+               --  back-ends will handle the membership tests directly (tags\n+               --  are not explicitly represented in Java objects, so the\n+               --  normal tagged membership expansion is not what we want).\n \n-               if not Java_VM then\n+               if VM_Target = No_VM then\n                   Rewrite (N, Tagged_Membership (N));\n                   Analyze_And_Resolve (N, Rtyp);\n                end if;\n@@ -3791,7 +4232,7 @@ package body Exp_Ch4 is\n       Agg : Node_Id;\n \n    begin\n-      if Ekind (Typ) = E_Access_Protected_Subprogram_Type then\n+      if Is_Access_Protected_Subprogram_Type (Typ) then\n          Agg :=\n            Make_Aggregate (Loc,\n              Expressions => New_List (\n@@ -3961,19 +4402,37 @@ package body Exp_Ch4 is\n       --  Initialize global variables showing run-time status\n \n       if Max_Available_String_Operands < 1 then\n-         if not RTE_Available (RE_Str_Concat) then\n+\n+         --  In No_Run_Time mode, consider that no entities are available\n+\n+         --  This seems wrong, RTE_Available should return False for any entity\n+         --  that is not in the special No_Run_Time list of allowed entities???\n+\n+         if No_Run_Time_Mode then\n+            Max_Available_String_Operands := 0;\n+\n+         --  Otherwise see what routines are available and set max operand\n+         --  count according to the highest count available in the run-time.\n+\n+         elsif not RTE_Available (RE_Str_Concat) then\n             Max_Available_String_Operands := 0;\n+\n          elsif not RTE_Available (RE_Str_Concat_3) then\n             Max_Available_String_Operands := 2;\n+\n          elsif not RTE_Available (RE_Str_Concat_4) then\n             Max_Available_String_Operands := 3;\n+\n          elsif not RTE_Available (RE_Str_Concat_5) then\n             Max_Available_String_Operands := 4;\n+\n          else\n             Max_Available_String_Operands := 5;\n          end if;\n \n          Char_Concat_Available :=\n+           not No_Run_Time_Mode\n+             and then\n            RTE_Available (RE_Str_Concat_CC)\n              and then\n            RTE_Available (RE_Str_Concat_CS)\n@@ -6537,12 +6996,14 @@ package body Exp_Ch4 is\n          --  already loaded to avoid the addition of an undesired dependence\n          --  on such run-time unit.\n \n-        and then not\n-          (RTU_Loaded (Ada_Tags)\n-            and then Nkind (Prefix (N)) = N_Selected_Component\n-            and then Present (Entity (Selector_Name (Prefix (N))))\n-            and then Entity (Selector_Name (Prefix (N))) =\n-                                         RTE_Record_Component (RE_Prims_Ptr))\n+        and then\n+          (VM_Target /= No_VM\n+            or else not\n+             (RTU_Loaded (Ada_Tags)\n+               and then Nkind (Prefix (N)) = N_Selected_Component\n+               and then Present (Entity (Selector_Name (Prefix (N))))\n+               and then Entity (Selector_Name (Prefix (N))) =\n+                                  RTE_Record_Component (RE_Prims_Ptr)))\n       then\n          Enable_Range_Check (Discrete_Range (N));\n       end if;\n@@ -7549,6 +8010,9 @@ package body Exp_Ch4 is\n          then\n             return Suitable_Element (Next_Entity (C));\n \n+         elsif Is_Interface (Etype (C)) then\n+            return Suitable_Element (Next_Entity (C));\n+\n          else\n             return C;\n          end if;\n@@ -7661,22 +8125,28 @@ package body Exp_Ch4 is\n       Loc : constant Source_Ptr := Sloc (N);\n \n       Owner : Entity_Id := PtrT;\n-      --  The entity whose finalisation list must be used to attach the\n+      --  The entity whose finalization list must be used to attach the\n       --  allocated object.\n \n    begin\n       if Ekind (PtrT) = E_Anonymous_Access_Type then\n+\n+         --  If the context is an access parameter, we need to create a\n+         --  non-anonymous access type in order to have a usable final list,\n+         --  because there is otherwise no pool to which the allocated object\n+         --  can belong. We create both the type and the finalization chain\n+         --  here, because freezing an internal type does not create such a\n+         --  chain. The Final_Chain that is thus created is shared by the\n+         --  access parameter. The access type is tested against the result\n+         --  type of the function to exclude allocators whose type is an\n+         --  anonymous access result type.\n+\n          if Nkind (Associated_Node_For_Itype (PtrT))\n               in N_Subprogram_Specification\n+           and then\n+             PtrT /=\n+               Etype (Defining_Unit_Name (Associated_Node_For_Itype (PtrT)))\n          then\n-            --  If the context is an access parameter, we need to create\n-            --  a non-anonymous access type in order to have a usable\n-            --  final list, because there is otherwise no pool to which\n-            --  the allocated object can belong. We create both the type\n-            --  and the finalization chain here, because freezing an\n-            --  internal type does not create such a chain. The Final_Chain\n-            --  that is thus created is shared by the access parameter.\n-\n             Owner := Make_Defining_Identifier (Loc, New_Internal_Name ('J'));\n             Insert_Action (N,\n               Make_Full_Type_Declaration (Loc,\n@@ -7689,11 +8159,22 @@ package body Exp_Ch4 is\n             Build_Final_List (N, Owner);\n             Set_Associated_Final_Chain (PtrT, Associated_Final_Chain (Owner));\n \n-         else\n-            --  Case of an access discriminant, or (Ada 2005) of\n-            --  an anonymous access component: find the final list\n-            --  associated with the scope of the type.\n+         --  Ada 2005 (AI-318-02): If the context is a return object\n+         --  declaration, then the anonymous return subtype is defined to have\n+         --  the same accessibility level as that of the function's result\n+         --  subtype, which means that we want the scope where the function is\n+         --  declared.\n+\n+         elsif Nkind (Associated_Node_For_Itype (PtrT)) = N_Object_Declaration\n+           and then Ekind (Scope (PtrT)) = E_Return_Statement\n+         then\n+            Owner := Scope (Return_Applies_To (Scope (PtrT)));\n+\n+         --  Case of an access discriminant, or (Ada 2005), of an anonymous\n+         --  access component or anonymous access function result: find the\n+         --  final list associated with the scope of the type.\n \n+         else\n             Owner := Scope (PtrT);\n          end if;\n       end if;\n@@ -8430,9 +8911,9 @@ package body Exp_Ch4 is\n       if Component_Size (Etype (Lhs)) /= System_Storage_Unit then\n          return False;\n \n-      --  Cannot do in place stuff on Java_VM since cannot pass addresses\n+      --  Cannot do in place stuff on VM_Target since cannot pass addresses\n \n-      elsif Java_VM then\n+      elsif VM_Target /= No_VM then\n          return False;\n \n       --  Cannot do in place stuff if non-standard Boolean representation"}]}