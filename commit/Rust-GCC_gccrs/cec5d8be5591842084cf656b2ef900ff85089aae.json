{"sha": "cec5d8be5591842084cf656b2ef900ff85089aae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VjNWQ4YmU1NTkxODQyMDg0Y2Y2NTZiMmVmOTAwZmY4NTA4OWFhZQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2014-10-06T15:27:32Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2014-10-06T15:27:32Z"}, "message": "rs6000.c (analyze_swaps commentary): Add discussion of permutes and why we don't handle them.\n\n2014-10-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (analyze_swaps commentary): Add\n\tdiscussion of permutes and why we don't handle them.\n\nFrom-SVN: r215951", "tree": {"sha": "ffd14bfdb460ec5093d708d3a41bc7b2d65053fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffd14bfdb460ec5093d708d3a41bc7b2d65053fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cec5d8be5591842084cf656b2ef900ff85089aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec5d8be5591842084cf656b2ef900ff85089aae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cec5d8be5591842084cf656b2ef900ff85089aae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec5d8be5591842084cf656b2ef900ff85089aae/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63b9f71bb35359333efbc5a57073abea111eb496", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b9f71bb35359333efbc5a57073abea111eb496", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b9f71bb35359333efbc5a57073abea111eb496"}], "stats": {"total": 52, "additions": 52, "deletions": 0}, "files": [{"sha": "13ac914d14bcf7c8e0c8c2933988723d2dfb87bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec5d8be5591842084cf656b2ef900ff85089aae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec5d8be5591842084cf656b2ef900ff85089aae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cec5d8be5591842084cf656b2ef900ff85089aae", "patch": "@@ -1,3 +1,8 @@\n+2014-10-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (analyze_swaps commentary): Add\n+\tdiscussion of permutes and why we don't handle them.\n+\n 2014-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/predicates.md (int_register_operand): Delete."}, {"sha": "8b35a0416d14c8fa3e3794d5a49fd66d0ee3a255", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec5d8be5591842084cf656b2ef900ff85089aae/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec5d8be5591842084cf656b2ef900ff85089aae/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cec5d8be5591842084cf656b2ef900ff85089aae", "patch": "@@ -33431,6 +33431,53 @@ emit_fusion_gpr_load (rtx target, rtx mem)\n    than deleting a swap, we convert the load/store into a permuting\n    load/store (which effectively removes the swap).  */\n \n+/* Notes on Permutes\n+\n+   We do not currently handle computations that contain permutes.  There\n+   is a general transformation that can be performed correctly, but it\n+   may introduce more expensive code than it replaces.  To handle these\n+   would require a cost model to determine when to perform the optimization.\n+   This commentary records how this could be done if desired.\n+\n+   The most general permute is something like this (example for V16QI):\n+\n+   (vec_select:V16QI (vec_concat:V32QI (op1:V16QI) (op2:V16QI))\n+                     (parallel [(const_int a0) (const_int a1)\n+                                 ...\n+                                (const_int a14) (const_int a15)]))\n+\n+   where a0,...,a15 are in [0,31] and select elements from op1 and op2\n+   to produce in the result.\n+\n+   Regardless of mode, we can convert the PARALLEL to a mask of 16\n+   byte-element selectors.  Let's call this M, with M[i] representing\n+   the ith byte-element selector value.  Then if we swap doublewords\n+   throughout the computation, we can get correct behavior by replacing\n+   M with M' as follows:\n+\n+            { M[i+8]+8 : i < 8, M[i+8] in [0,7] U [16,23]\n+    M'[i] = { M[i+8]-8 : i < 8, M[i+8] in [8,15] U [24,31]\n+            { M[i-8]+8 : i >= 8, M[i-8] in [0,7] U [16,23]\n+            { M[i-8]-8 : i >= 8, M[i-8] in [8,15] U [24,31]\n+\n+   This seems promising at first, since we are just replacing one mask\n+   with another.  But certain masks are preferable to others.  If M\n+   is a mask that matches a vmrghh pattern, for example, M' certainly\n+   will not.  Instead of a single vmrghh, we would generate a load of\n+   M' and a vperm.  So we would need to know how many xxswapd's we can\n+   remove as a result of this transformation to determine if it's\n+   profitable; and preferably the logic would need to be aware of all\n+   the special preferable masks.\n+\n+   Another form of permute is an UNSPEC_VPERM, in which the mask is\n+   already in a register.  In some cases, this mask may be a constant\n+   that we can discover with ud-chains, in which case the above\n+   transformation is ok.  However, the common usage here is for the\n+   mask to be produced by an UNSPEC_LVSL, in which case the mask \n+   cannot be known at compile time.  In such a case we would have to\n+   generate several instructions to compute M' as above at run time,\n+   and a cost model is needed again.  */\n+\n /* This is based on the union-find logic in web.c.  web_entry_base is\n    defined in df.h.  */\n class swap_web_entry : public web_entry_base"}]}