{"sha": "7d6979197274a662da7bdc564314afe8415865c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q2OTc5MTk3Mjc0YTY2MmRhN2JkYzU2NDMxNGFmZTg0MTU4NjVjMQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-13T02:45:20Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-07-05T19:44:14Z"}, "message": "Port most of the A CMP 0 ? A : -A to match\n\nTo improve phiopt and be able to remove abs_replacement, this ports\nmost of \"A CMP 0 ? A : -A\" from fold_cond_expr_with_comparison to\nmatch.pd.  There is a few extra changes that are needed to remove\nthe \"A CMP 0 ? A : -A\" part from fold_cond_expr_with_comparison:\n   * Need to handle (A - B) case\n   * Need to handle UN* comparisons.\n\nI will handle those in a different patch.\n\nNote phi-opt-15.c test needed to be updated as we get ABSU now\ninstead of not getting ABS.  When ABSU was added phiopt was not\nupdated even to use ABSU instead of not creating ABS.\n\nOK? Bootstrapped and tested on x86_64-linux-gnu with no regressions.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/101039\n\t* match.pd (A CMP 0 ? A : -A): New patterns.\n\t* tree-ssa-phiopt.c (abs_replacement): Delete function.\n\t(tree_ssa_phiopt_worker): Don't call abs_replacement.\n\tUpdate comment about abs_replacement.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/101039\n\t* gcc.dg/tree-ssa/phi-opt-15.c: Update test to expect\n\tABSU and still not expect ABS_EXPR.\n\t* gcc.dg/tree-ssa/phi-opt-23.c: New test.\n\t* gcc.dg/tree-ssa/phi-opt-24.c: New test.", "tree": {"sha": "428f19f5ff32baafb5b7994f6ac8473a61659928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/428f19f5ff32baafb5b7994f6ac8473a61659928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d6979197274a662da7bdc564314afe8415865c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d6979197274a662da7bdc564314afe8415865c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d6979197274a662da7bdc564314afe8415865c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d6979197274a662da7bdc564314afe8415865c1/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a50cecb20a10a729b3f5f157b154d28f9937a652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50cecb20a10a729b3f5f157b154d28f9937a652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a50cecb20a10a729b3f5f157b154d28f9937a652"}], "stats": {"total": 286, "additions": 152, "deletions": 134}, "files": [{"sha": "72860fbd4480931c57e2fdebcffa74d29402cbd1", "filename": "gcc/match.pd", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=7d6979197274a662da7bdc564314afe8415865c1", "patch": "@@ -3976,6 +3976,66 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (cnd (logical_inverted_value truth_valued_p@0) @1 @2)\n   (cnd @0 @2 @1)))\n \n+/* abs/negative simplifications moved from fold_cond_expr_with_comparison,\n+   Need to handle (A - B) case as fold_cond_expr_with_comparison does.\n+   Need to handle UN* comparisons.\n+\n+   None of these transformations work for modes with signed\n+   zeros.  If A is +/-0, the first two transformations will\n+   change the sign of the result (from +0 to -0, or vice\n+   versa).  The last four will fix the sign of the result,\n+   even though the original expressions could be positive or\n+   negative, depending on the sign of A.\n+\n+   Note that all these transformations are correct if A is\n+   NaN, since the two alternatives (A and -A) are also NaNs.  */\n+\n+(for cnd (cond vec_cond)\n+ /* A == 0 ? A : -A    same as -A */\n+ (for cmp (eq uneq)\n+  (simplify\n+   (cnd (cmp @0 zerop) @0 (negate@1 @0))\n+    (if (!HONOR_SIGNED_ZEROS (type))\n+     @1))\n+  (simplify\n+   (cnd (cmp @0 zerop) integer_zerop (negate@1 @0))\n+    (if (!HONOR_SIGNED_ZEROS (type))\n+     @1))\n+ )\n+ /* A != 0 ? A : -A    same as A */\n+ (for cmp (ne ltgt)\n+  (simplify\n+   (cnd (cmp @0 zerop) @0 (negate @0))\n+    (if (!HONOR_SIGNED_ZEROS (type))\n+     @0))\n+  (simplify\n+   (cnd (cmp @0 zerop) @0 integer_zerop)\n+    (if (!HONOR_SIGNED_ZEROS (type))\n+     @0))\n+ )\n+ /* A >=/> 0 ? A : -A    same as abs (A) */\n+ (for cmp (ge gt)\n+  (simplify\n+   (cnd (cmp @0 zerop) @0 (negate @0))\n+    (if (!HONOR_SIGNED_ZEROS (type)\n+\t && !TYPE_UNSIGNED (type))\n+     (abs @0))))\n+ /* A <=/< 0 ? A : -A    same as -abs (A) */\n+ (for cmp (le lt)\n+  (simplify\n+   (cnd (cmp @0 zerop) @0 (negate @0))\n+    (if (!HONOR_SIGNED_ZEROS (type)\n+\t && !TYPE_UNSIGNED (type))\n+     (if (ANY_INTEGRAL_TYPE_P (type)\n+\t  && !TYPE_OVERFLOW_WRAPS (type))\n+      (with {\n+\ttree utype = unsigned_type_for (type);\n+       }\n+       (convert (negate (absu:utype @0))))\n+       (negate (abs @0)))))\n+ )\n+)\n+\n /* -(type)!A -> (type)A - 1.  */\n (simplify\n  (negate (convert?:s (logical_inverted_value:s @0)))"}, {"sha": "6aec68961cf531f0e8dde7ec842f37d527db3734", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-15.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-15.c?ref=7d6979197274a662da7bdc564314afe8415865c1", "patch": "@@ -9,4 +9,6 @@ foo (int i)\n   return i;\n }\n \n-/* { dg-final { scan-tree-dump-not \"ABS\" \"optimized\" } } */\n+/* We should not have ABS_EXPR but ABSU_EXPR instead. */\n+/* { dg-final { scan-tree-dump-not \"ABS_EXPR\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"ABSU\" \"optimized\" } } */"}, {"sha": "ff658cd16a7917e566e74946b9cf502322de6306", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-23.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-23.c?ref=7d6979197274a662da7bdc564314afe8415865c1", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-options \"-O2 -fdump-tree-phiopt\" } */\n+\n+int f0(int A)\n+{\n+//     A == 0? A : -A    same as -A\n+  if (A == 0)  return A;\n+  return -A;\n+}\n+\n+int f1(int A)\n+{\n+//     A != 0? A : -A    same as A\n+  if (A != 0)  return A;\n+  return -A;\n+}\n+int f2(int A)\n+{\n+//     A >= 0? A : -A    same as abs (A)\n+  if (A >= 0)  return A;\n+  return -A;\n+}\n+int f3(int A)\n+{\n+//     A > 0?  A : -A    same as abs (A)\n+  if (A > 0)  return A;\n+  return -A;\n+}\n+int f4(int A)\n+{\n+//     A <= 0? A : -A    same as -abs (A)\n+  if (A <= 0)  return A;\n+  return -A;\n+}\n+int f5(int A)\n+{\n+//     A < 0?  A : -A    same as -abs (A)\n+  if (A < 0)  return A;\n+  return -A;\n+}\n+\n+/* These should be optimized in phiopt1 but is confused by predicts. */\n+/* { dg-final { scan-tree-dump-not \"if\" \"phiopt1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-not \"if\" \"phiopt2\" } } */\n+"}, {"sha": "eb89decb4bf70413aa3608d449306719775c84e8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-24.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-24.c?ref=7d6979197274a662da7bdc564314afe8415865c1", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-options \"-O2 -fno-signed-zeros -fdump-tree-phiopt\" } */\n+\n+float f0(float A)\n+{\n+//     A == 0? A : -A    same as -A\n+  if (A == 0)  return A;\n+  return -A;\n+}\n+\n+float f1(float A)\n+{\n+//     A != 0? A : -A    same as A\n+  if (A != 0)  return A;\n+  return -A;\n+}\n+float f2(float A)\n+{\n+//     A >= 0? A : -A    same as abs (A)\n+  if (A >= 0)  return A;\n+  return -A;\n+}\n+float f3(float A)\n+{\n+//     A > 0?  A : -A    same as abs (A)\n+  if (A > 0)  return A;\n+  return -A;\n+}\n+float f4(float A)\n+{\n+//     A <= 0? A : -A    same as -abs (A)\n+  if (A <= 0)  return A;\n+  return -A;\n+}\n+float f5(float A)\n+{\n+//     A < 0?  A : -A    same as -abs (A)\n+  if (A < 0)  return A;\n+  return -A;\n+}\n+\n+/* These should be optimized in phiopt1 but is confused by predicts. */\n+/* { dg-final { scan-tree-dump-not \"if\" \"phiopt1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-not \"if\" \"phiopt2\" } } */\n+"}, {"sha": "ab63bf699e3084b97ee5a214a955554ebc0a3713", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 133, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d6979197274a662da7bdc564314afe8415865c1/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=7d6979197274a662da7bdc564314afe8415865c1", "patch": "@@ -63,8 +63,6 @@ static int value_replacement (basic_block, basic_block,\n \t\t\t      edge, edge, gphi *, tree, tree);\n static bool minmax_replacement (basic_block, basic_block,\n \t\t\t\tedge, edge, gphi *, tree, tree);\n-static bool abs_replacement (basic_block, basic_block,\n-\t\t\t     edge, edge, gphi *, tree, tree);\n static bool spaceship_replacement (basic_block, basic_block,\n \t\t\t\t   edge, edge, gphi *, tree, tree);\n static bool cond_removal_in_popcount_clz_ctz_pattern (basic_block, basic_block,\n@@ -350,8 +348,6 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t\t\t\t\t       arg0, arg1,\n \t\t\t\t\t       early_p))\n \t    cfgchanged = true;\n-\t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\t    cfgchanged = true;\n \t  else if (!early_p\n \t\t   && cond_removal_in_popcount_clz_ctz_pattern (bb, bb1, e1,\n \t\t\t\t\t\t\t\te2, phi, arg0,\n@@ -2606,134 +2602,6 @@ cond_removal_in_popcount_clz_ctz_pattern (basic_block cond_bb,\n   return true;\n }\n \n-/*  The function absolute_replacement does the main work of doing the absolute\n-    replacement.  Return true if the replacement is done.  Otherwise return\n-    false.\n-    bb is the basic block where the replacement is going to be done on.  arg0\n-    is argument 0 from the phi.  Likewise for arg1.  */\n-\n-static bool\n-abs_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t edge e0 ATTRIBUTE_UNUSED, edge e1,\n-\t\t gphi *phi, tree arg0, tree arg1)\n-{\n-  tree result;\n-  gassign *new_stmt;\n-  gimple *cond;\n-  gimple_stmt_iterator gsi;\n-  edge true_edge, false_edge;\n-  gimple *assign;\n-  edge e;\n-  tree rhs, lhs;\n-  bool negate;\n-  enum tree_code cond_code;\n-\n-  /* If the type says honor signed zeros we cannot do this\n-     optimization.  */\n-  if (HONOR_SIGNED_ZEROS (arg1))\n-    return false;\n-\n-  /* OTHER_BLOCK must have only one executable statement which must have the\n-     form arg0 = -arg1 or arg1 = -arg0.  */\n-\n-  assign = last_and_only_stmt (middle_bb);\n-  /* If we did not find the proper negation assignment, then we cannot\n-     optimize.  */\n-  if (assign == NULL)\n-    return false;\n-\n-  /* If we got here, then we have found the only executable statement\n-     in OTHER_BLOCK.  If it is anything other than arg = -arg1 or\n-     arg1 = -arg0, then we cannot optimize.  */\n-  if (gimple_code (assign) != GIMPLE_ASSIGN)\n-    return false;\n-\n-  lhs = gimple_assign_lhs (assign);\n-\n-  if (gimple_assign_rhs_code (assign) != NEGATE_EXPR)\n-    return false;\n-\n-  rhs = gimple_assign_rhs1 (assign);\n-\n-  /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n-  if (!(lhs == arg0 && rhs == arg1)\n-      && !(lhs == arg1 && rhs == arg0))\n-    return false;\n-\n-  cond = last_stmt (cond_bb);\n-  result = PHI_RESULT (phi);\n-\n-  /* Only relationals comparing arg[01] against zero are interesting.  */\n-  cond_code = gimple_cond_code (cond);\n-  if (cond_code != GT_EXPR && cond_code != GE_EXPR\n-      && cond_code != LT_EXPR && cond_code != LE_EXPR)\n-    return false;\n-\n-  /* Make sure the conditional is arg[01] OP y.  */\n-  if (gimple_cond_lhs (cond) != rhs)\n-    return false;\n-\n-  if (FLOAT_TYPE_P (TREE_TYPE (gimple_cond_rhs (cond)))\n-\t       ? real_zerop (gimple_cond_rhs (cond))\n-\t       : integer_zerop (gimple_cond_rhs (cond)))\n-    ;\n-  else\n-    return false;\n-\n-  /* We need to know which is the true edge and which is the false\n-     edge so that we know if have abs or negative abs.  */\n-  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n-\n-  /* For GT_EXPR/GE_EXPR, if the true edge goes to OTHER_BLOCK, then we\n-     will need to negate the result.  Similarly for LT_EXPR/LE_EXPR if\n-     the false edge goes to OTHER_BLOCK.  */\n-  if (cond_code == GT_EXPR || cond_code == GE_EXPR)\n-    e = true_edge;\n-  else\n-    e = false_edge;\n-\n-  if (e->dest == middle_bb)\n-    negate = true;\n-  else\n-    negate = false;\n-\n-  /* If the code negates only iff positive then make sure to not\n-     introduce undefined behavior when negating or computing the absolute.\n-     ???  We could use range info if present to check for arg1 == INT_MIN.  */\n-  if (negate\n-      && (ANY_INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t  && ! TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1))))\n-    return false;\n-\n-  result = duplicate_ssa_name (result, NULL);\n-\n-  if (negate)\n-    lhs = make_ssa_name (TREE_TYPE (result));\n-  else\n-    lhs = result;\n-\n-  /* Build the modify expression with abs expression.  */\n-  new_stmt = gimple_build_assign (lhs, ABS_EXPR, rhs);\n-\n-  gsi = gsi_last_bb (cond_bb);\n-  gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n-\n-  if (negate)\n-    {\n-      /* Get the right GSI.  We want to insert after the recently\n-\t added ABS_EXPR statement (which we know is the first statement\n-\t in the block.  */\n-      new_stmt = gimple_build_assign (result, NEGATE_EXPR, lhs);\n-\n-      gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n-    }\n-\n-  replace_phi_edge_with_variable (cond_bb, e1, phi, result);\n-\n-  /* Note that we optimized this PHI.  */\n-  return true;\n-}\n-\n /* Auxiliary functions to determine the set of memory accesses which\n    can't trap because they are preceded by accesses to the same memory\n    portion.  We do that for MEM_REFs, so we only need to track\n@@ -3670,7 +3538,7 @@ gate_hoist_loads (void)\n    ABS Replacement\n    ---------------\n \n-   This transformation, implemented in abs_replacement, replaces\n+   This transformation, implemented in match_simplify_replacement, replaces\n \n      bb0:\n        if (a >= 0) goto bb2; else goto bb1;"}]}