{"sha": "f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhlMmExZWQzYjc0Njk1MWE1ZDA3ZTAzZjkxZDFmODIwOWViZTc3NQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2008-09-11T17:03:23Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2008-09-11T17:03:23Z"}, "message": "ipa-prop.h (struct ipa_param_flags): Removed.\n\n2008-09-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (struct ipa_param_flags): Removed.\n\t(struct ipa_param_descriptor): New structure.\n\t(struct ipa_node_params): ipcp_lattices, param_decls and\n\tparam_flags moved to ipa_param_description.\n\t(ipa_get_ith_param): Renamed to ipa_get_param, changed to access\n\tdescriptors.  Renamed all users.\n\t(ipa_is_ith_param_modified): Renamed to ipa_is_param_modified,\n\tchanged to access descriptors.  Renamed all users.\n\t(ipa_is_ith_param_called): Renamed to ipa_is_param_called, changed\n\tto access descriptors. Renamed all users.\n\t* ipa-cp.c (ipcp_init_cloned_node): Call\n\tipa_initialize_node_params instead of ipa_count_formal_params and\n\tipa_create_param_decls_array.\n\t(ipcp_analyze_node): Likewise.\n\t(ipcp_get_ith_lattice): Renamed to ipcp_get_lattice, changed to access\n\tdescriptors.  Renamed all users.\n\t(ipcp_initialize_node_lattices): Remove allocation.\n\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n\tipa_initialize_node_params instead of ipa_count_formal_params and\n\tipa_create_param_decls_array.\n\t* ipa-prop.c (ipa_create_param_decls_array): Renamed to\n\tipa_populate_param_decls, made static, added parameter info,\n\trenamed mt to node, removed allocation, changed to use\n\tdescriptors.\n\t(ipa_count_formal_params): Made static, added parameter info,\n\trenamed mt to node.\n\t(ipa_initialize_node_params): New function.\n\t(ipa_check_stmt_modifications): Changed to use descriptors.\n\t(ipa_detect_param_modifications): Removed allocation, changed to\n\tuse descriptors.\n\t(ipa_note_param_call): Changed to use descriptors.\n\t(ipa_analyze_params_uses): Removed allocation.\n\t(ipa_free_node_params_substructures): Changed to use descriptors.\n\t(ipa_edge_duplication_hook): Use the unused attribute.\n\t(ipa_node_duplication_hook): Use the unused attribute, changed to\n\tuse descriptors, changed to duplicate descriptors.\n\n\t* ipa-inline.c (cgraph_mark_inline_edge): New parameter new_edges,\n\tchanged all callers.  Call ipa_propagate_indirect_call_infos if doing\n\tindirect inlining.  Made static.\n        (cgraph_decide_inlining): Freeing ipa-prop structures after inlining\n\tfunctions called only once.\n\t(cgraph_decide_recursive_inlining): Don't call\n\tipa_propagate_indirect_call_infos, pass new_edges to\n\tcgraph_mark_inline_edge instead.\n\t(cgraph_decide_inlining_of_small_functions): Don't call\n\tipa_propagate_indirect_call_infos, pass new_edges to\n\tcgraph_mark_inline_edge instead.\n\t(cgraph_decide_inlining): Don't call\n\tipa_propagate_indirect_call_infos.\n\t* ipa-prop.c: Check that vectors are allocated.\n\n\t* ipa-inline.c (cgraph_mark_inline_edge): Returns boolean, true\n\tiff a new cgraph edges have been created.\n\t(cgraph_decide_inlining): New variable redo_always_inline.\n\tFlattening and always_inlining loop until callgraph stabilizes.\n\t* ipa-prop.c (update_call_notes_after_inlining): Returns boolean,\n\ttrue iff new cgraph edges have been created.\n\t(propagate_info_to_inlined_callees): Likewise.\n\t(ipa_propagate_indirect_call_infos): Likewise.\n\nFrom-SVN: r140293", "tree": {"sha": "73228742f0647af60cdfe7e96540801e3f8ad3ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73228742f0647af60cdfe7e96540801e3f8ad3ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "420da8caae151d84ef45e31cf058e9832d856b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/420da8caae151d84ef45e31cf058e9832d856b9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/420da8caae151d84ef45e31cf058e9832d856b9e"}], "stats": {"total": 451, "additions": 264, "deletions": 187}, "files": [{"sha": "aaec4d73a8b7f5abc565fb259cdbff1000461b0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "patch": "@@ -1,3 +1,66 @@\n+2008-09-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (struct ipa_param_flags): Removed.\n+\t(struct ipa_param_descriptor): New structure.\n+\t(struct ipa_node_params): ipcp_lattices, param_decls and\n+\tparam_flags moved to ipa_param_description.\n+\t(ipa_get_ith_param): Renamed to ipa_get_param, changed to access\n+\tdescriptors.  Renamed all users.\n+\t(ipa_is_ith_param_modified): Renamed to ipa_is_param_modified,\n+\tchanged to access descriptors.  Renamed all users.\n+\t(ipa_is_ith_param_called): Renamed to ipa_is_param_called, changed\n+\tto access descriptors. Renamed all users.\n+\t* ipa-cp.c (ipcp_init_cloned_node): Call\n+\tipa_initialize_node_params instead of ipa_count_formal_params and\n+\tipa_create_param_decls_array.\n+\t(ipcp_analyze_node): Likewise.\n+\t(ipcp_get_ith_lattice): Renamed to ipcp_get_lattice, changed to access\n+\tdescriptors.  Renamed all users.\n+\t(ipcp_initialize_node_lattices): Remove allocation.\n+\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n+\tipa_initialize_node_params instead of ipa_count_formal_params and\n+\tipa_create_param_decls_array.\n+\t* ipa-prop.c (ipa_create_param_decls_array): Renamed to\n+\tipa_populate_param_decls, made static, added parameter info,\n+\trenamed mt to node, removed allocation, changed to use\n+\tdescriptors.\n+\t(ipa_count_formal_params): Made static, added parameter info,\n+\trenamed mt to node.\n+\t(ipa_initialize_node_params): New function.\n+\t(ipa_check_stmt_modifications): Changed to use descriptors.\n+\t(ipa_detect_param_modifications): Removed allocation, changed to\n+\tuse descriptors.\n+\t(ipa_note_param_call): Changed to use descriptors.\n+\t(ipa_analyze_params_uses): Removed allocation.\n+\t(ipa_free_node_params_substructures): Changed to use descriptors.\n+\t(ipa_edge_duplication_hook): Use the unused attribute.\n+\t(ipa_node_duplication_hook): Use the unused attribute, changed to\n+\tuse descriptors, changed to duplicate descriptors.\n+\n+\t* ipa-inline.c (cgraph_mark_inline_edge): New parameter new_edges,\n+\tchanged all callers.  Call ipa_propagate_indirect_call_infos if doing\n+\tindirect inlining.  Made static.\n+        (cgraph_decide_inlining): Freeing ipa-prop structures after inlining\n+\tfunctions called only once.\n+\t(cgraph_decide_recursive_inlining): Don't call\n+\tipa_propagate_indirect_call_infos, pass new_edges to\n+\tcgraph_mark_inline_edge instead.\n+\t(cgraph_decide_inlining_of_small_functions): Don't call\n+\tipa_propagate_indirect_call_infos, pass new_edges to\n+\tcgraph_mark_inline_edge instead.\n+\t(cgraph_decide_inlining): Don't call\n+\tipa_propagate_indirect_call_infos.\n+\t* ipa-prop.c: Check that vectors are allocated.\n+\n+\t* ipa-inline.c (cgraph_mark_inline_edge): Returns boolean, true\n+\tiff a new cgraph edges have been created.\n+\t(cgraph_decide_inlining): New variable redo_always_inline.\n+\tFlattening and always_inlining loop until callgraph stabilizes.\n+\t* ipa-prop.c (update_call_notes_after_inlining): Returns boolean,\n+\ttrue iff new cgraph edges have been created.\n+\t(propagate_info_to_inlined_callees): Likewise.\n+\t(ipa_propagate_indirect_call_infos): Likewise.\n+\n 2008-09-11  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vectorizer.c (slpeel_add_loop_guard): Fix types."}, {"sha": "a6018dc89101ecfc3d5a70aaf8121e2cdff680e4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "patch": "@@ -452,7 +452,6 @@ varpool_next_static_initializer (struct varpool_node *node)\n \n /* In ipa-inline.c  */\n void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool, bool);\n-void cgraph_mark_inline_edge (struct cgraph_edge *, bool);\n bool cgraph_default_inline_p (struct cgraph_node *, const char **);\n unsigned int compute_inline_parameters (struct cgraph_node *);\n "}, {"sha": "8dbc9f87f99b27d9523c26f2d33ea9ab6066eb2c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "patch": "@@ -171,9 +171,8 @@ ipcp_init_cloned_node (struct cgraph_node *orig_node,\n \t\t       struct cgraph_node *new_node)\n {\n   ipa_check_create_node_params ();\n+  ipa_initialize_node_params (new_node);\n   IPA_NODE_REF (new_node)->ipcp_orig_node = orig_node;\n-  ipa_count_formal_params (new_node);\n-  ipa_create_param_decls_array (new_node);\n }\n \n /* Perform intraprocedrual analysis needed for ipcp.  */\n@@ -183,8 +182,7 @@ ipcp_analyze_node (struct cgraph_node *node)\n   /* Unreachable nodes should have been eliminated before ipcp.  */\n   gcc_assert (node->needed || node->reachable);\n \n-  ipa_count_formal_params (node);\n-  ipa_create_param_decls_array (node);\n+  ipa_initialize_node_params (node);\n   ipa_detect_param_modifications (node);\n }\n \n@@ -300,9 +298,9 @@ ipa_lattice_meet (struct ipcp_lattice *res, struct ipcp_lattice *lat1,\n /* Return the lattice corresponding to the Ith formal parameter of the function\n    described by INFO.  */\n static inline struct ipcp_lattice *\n-ipcp_get_ith_lattice (struct ipa_node_params *info, int i)\n+ipcp_get_lattice (struct ipa_node_params *info, int i)\n {\n-  return &(info->ipcp_lattices[i]);\n+  return &(info->params[i].ipcp_lattice);\n }\n \n /* Given the jump function JFUNC, compute the lattice LAT that describes the\n@@ -321,7 +319,7 @@ ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n     {\n       struct ipcp_lattice *caller_lat;\n \n-      caller_lat = ipcp_get_ith_lattice (info, jfunc->value.formal_id);\n+      caller_lat = ipcp_get_lattice (info, jfunc->value.formal_id);\n       lat->type = caller_lat->type;\n       lat->constant = caller_lat->constant;\n     }\n@@ -364,7 +362,7 @@ ipcp_print_all_lattices (FILE * f)\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n \n \t  fprintf (f, \"    param [%d]: \", i);\n \t  if (lat->type == IPA_CONST_VALUE)\n@@ -485,9 +483,6 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   enum ipa_lattice_type type;\n \n-  info->ipcp_lattices = XCNEWVEC (struct ipcp_lattice,\n-\t\t\t\t  ipa_get_param_count (info));\n-  \n   if (ipa_is_called_with_var_arguments (info))\n     type = IPA_BOTTOM;\n   else if (!node->needed)\n@@ -500,7 +495,7 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n     type = IPA_BOTTOM;\n \n   for (i = 0; i < ipa_get_param_count (info) ; i++)\n-    ipcp_get_ith_lattice (info, i)->type = type;\n+    ipcp_get_lattice (info, i)->type = type;\n }\n \n /* build INTEGER_CST tree with type TREE_TYPE and value according to LAT.\n@@ -596,14 +591,14 @@ ipcp_change_tops_to_bottom (void)\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n \t  if (lat->type == IPA_TOP)\n \t    {\n \t      prop_again = true;\n \t      if (dump_file)\n \t\t{\n \t\t  fprintf (dump_file, \"Forcing param \");\n-\t\t  print_generic_expr (dump_file, ipa_get_ith_param (info, i), 0);\n+\t\t  print_generic_expr (dump_file, ipa_get_param (info, i), 0);\n \t\t  fprintf (dump_file, \" of node %s to bottom.\\n\",\n \t\t\t   cgraph_node_name (node));\n \t\t}\n@@ -651,7 +646,7 @@ ipcp_propagate_stage (void)\n \t    {\n \t      jump_func = ipa_get_ith_jump_func (args, i);\n \t      ipcp_lattice_from_jfunc (info, &inc_lat, jump_func);\n-\t      dest_lat = ipcp_get_ith_lattice (callee_info, i);\n+\t      dest_lat = ipcp_get_lattice (callee_info, i);\n \t      ipa_lattice_meet (&new_lat, &inc_lat, dest_lat);\n \t      if (ipcp_lattice_changed (&new_lat, dest_lat))\n \t\t{\n@@ -917,7 +912,7 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n   count = ipa_get_param_count (orig_callee_info);\n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_lattice *lat = ipcp_get_ith_lattice (orig_callee_info, i);\n+      struct ipcp_lattice *lat = ipcp_get_lattice (orig_callee_info, i);\n       if (ipcp_lat_is_const (lat))\n \t{\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n@@ -946,8 +941,8 @@ ipcp_update_callgraph (void)\n \n \tfor (i = 0; i < count; i++)\n \t  {\n-\t    struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t    tree parm_tree = ipa_get_ith_param (info, i);\n+\t    struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\t    tree parm_tree = ipa_get_param (info, i);\n \n \t    /* We can proactively remove obviously unused arguments.  */\n \t    if (is_gimple_reg (parm_tree)\n@@ -1069,8 +1064,8 @@ ipcp_estimate_growth (struct cgraph_node *node)\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-      tree parm_tree = ipa_get_ith_param (info, i);\n+      struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+      tree parm_tree = ipa_get_param (info, i);\n \n       /* We can proactively remove obviously unused arguments.  */\n       if (is_gimple_reg (parm_tree)\n@@ -1142,8 +1137,8 @@ ipcp_const_param_count (struct cgraph_node *node)\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-      tree parm_tree = ipa_get_ith_param (info, i);\n+      struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+      tree parm_tree = ipa_get_param (info, i);\n       if (ipcp_lat_is_insertable (lat)\n \t  /* Do not count obviously unused arguments.  */\n \t  && (!is_gimple_reg (parm_tree)\n@@ -1242,8 +1237,8 @@ ipcp_insert_stage (void)\n       args_to_skip = BITMAP_ALLOC (NULL);\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t  parm_tree = ipa_get_ith_param (info, i);\n+\t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\t  parm_tree = ipa_get_param (info, i);\n \n \t  /* We can proactively remove obviously unused arguments.  */\n \t  if (is_gimple_reg (parm_tree)"}, {"sha": "662cff60b507ea0a30edd9e026083c3b1dae6552", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 75, "deletions": 65, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "patch": "@@ -243,15 +243,19 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n       cgraph_clone_inlined_nodes (e, duplicate, update_original);\n }\n \n-/* Mark edge E as inlined and update callgraph accordingly. \n-   UPDATE_ORIGINAL specify whether profile of original function should be\n-   updated. */\n+/* Mark edge E as inlined and update callgraph accordingly.  UPDATE_ORIGINAL\n+   specify whether profile of original function should be updated.  If any new\n+   indirect edges are discovered in the process, add them to NEW_EDGES, unless\n+   it is NULL.  Return true iff any new callgraph edges were discovered as a\n+   result of inlining.  */\n \n-void\n-cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original)\n+static bool\n+cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n+\t\t\t VEC (cgraph_edge_p, heap) **new_edges)\n {\n   int old_insns = 0, new_insns = 0;\n   struct cgraph_node *to = NULL, *what;\n+  struct cgraph_edge *curr = e;\n \n   if (e->callee->inline_decl)\n     cgraph_redirect_edge_callee (e, cgraph_node (e->callee->inline_decl));\n@@ -281,6 +285,11 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original)\n   if (new_insns > old_insns)\n     overall_insns += new_insns - old_insns;\n   ncalls_inlined++;\n+\n+  if (flag_indirect_inlining)\n+    return ipa_propagate_indirect_call_infos (curr, new_edges);\n+  else\n+    return false;\n }\n \n /* Mark all calls of EDGE->CALLEE inlined into EDGE->CALLER.\n@@ -302,7 +311,7 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n       next = e->next_caller;\n       if (e->caller == to && e->inline_failed)\n \t{\n-          cgraph_mark_inline_edge (e, true);\n+          cgraph_mark_inline_edge (e, true, NULL);\n \t  if (e == edge)\n \t    edge = next;\n \t}\n@@ -747,9 +756,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n \t  fprintf (dump_file, \"\\n\");\n \t}\n       cgraph_redirect_edge_callee (curr, master_clone);\n-      cgraph_mark_inline_edge (curr, false);\n-      if (flag_indirect_inlining)\n-\tipa_propagate_indirect_call_infos (curr, new_edges);\n+      cgraph_mark_inline_edge (curr, false, new_edges);\n       lookup_recursive_calls (node, curr->callee, heap);\n       n++;\n     }\n@@ -1002,12 +1009,10 @@ cgraph_decide_inlining_of_small_functions (void)\n \t      continue;\n \t    }\n \t  callee = edge->callee;\n-\t  cgraph_mark_inline_edge (edge, true);\n+\t  cgraph_mark_inline_edge (edge, true, &new_indirect_edges);\n \t  if (flag_indirect_inlining)\n-\t    {\n-\t      ipa_propagate_indirect_call_infos (edge, &new_indirect_edges);\n-\t      add_new_edges_to_heap (heap, new_indirect_edges);\n-\t    }\n+\t    add_new_edges_to_heap (heap, new_indirect_edges);\n+\n \t  update_callee_keys (heap, callee, updated_nodes);\n \t}\n       where = edge->caller;\n@@ -1070,6 +1075,7 @@ cgraph_decide_inlining (void)\n   int old_insns = 0;\n   int i;\n   int initial_insns = 0;\n+  bool redo_always_inline = true;\n \n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n \n@@ -1103,69 +1109,70 @@ cgraph_decide_inlining (void)\n \n   /* In the first pass mark all always_inline edges.  Do this with a priority\n      so none of our later choices will make this impossible.  */\n-  for (i = nnodes - 1; i >= 0; i--)\n+  while (redo_always_inline)\n     {\n-      struct cgraph_edge *e, *next;\n+      redo_always_inline = false;\n+      for (i = nnodes - 1; i >= 0; i--)\n+\t{\n+\t  struct cgraph_edge *e, *next;\n \n-      node = order[i];\n+\t  node = order[i];\n \n-      /* Handle nodes to be flattened, but don't update overall unit size.  */\n-      if (lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n-        {\n-  \t  if (dump_file)\n-    \t    fprintf (dump_file,\n-\t     \t     \"Flattening %s\\n\", cgraph_node_name (node));\n-\t  cgraph_decide_inlining_incrementally (node, INLINE_ALL, 0);\n-        }\n+\t  /* Handle nodes to be flattened, but don't update overall unit\n+\t     size.  */\n+\t  if (lookup_attribute (\"flatten\",\n+\t\t\t\tDECL_ATTRIBUTES (node->decl)) != NULL)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Flattening %s\\n\", cgraph_node_name (node));\n+\t      cgraph_decide_inlining_incrementally (node, INLINE_ALL, 0);\n+\t    }\n \n-      if (!node->local.disregard_inline_limits)\n-\tcontinue;\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"\\nConsidering %s %i insns (always inline)\\n\",\n-\t\t cgraph_node_name (node), node->global.insns);\n-      old_insns = overall_insns;\n-      for (e = node->callers; e; e = next)\n-\t{\n-\t  next = e->next_caller;\n-\t  if (!e->inline_failed || gimple_call_cannot_inline_p (e->call_stmt))\n+\t  if (!node->local.disregard_inline_limits)\n \t    continue;\n-\t  if (cgraph_recursive_inlining_p (e->caller, e->callee,\n-\t\t\t\t  \t   &e->inline_failed))\n-\t    continue;\n-\t  if (!tree_can_inline_p (e->caller->decl, e->callee->decl))\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"\\nConsidering %s %i insns (always inline)\\n\",\n+\t\t     cgraph_node_name (node), node->global.insns);\n+\t  old_insns = overall_insns;\n+\t  for (e = node->callers; e; e = next)\n \t    {\n-\t      gimple_call_set_cannot_inline (e->call_stmt, true);\n-\t      continue;\n+\t      next = e->next_caller;\n+\t      if (!e->inline_failed\n+\t\t  || gimple_call_cannot_inline_p (e->call_stmt))\n+\t\tcontinue;\n+\t      if (cgraph_recursive_inlining_p (e->caller, e->callee,\n+\t\t\t\t\t       &e->inline_failed))\n+\t\tcontinue;\n+\t      if (!tree_can_inline_p (e->caller->decl, e->callee->decl))\n+\t\t{\n+\t\t  gimple_call_set_cannot_inline (e->call_stmt, true);\n+\t\t  continue;\n+\t\t}\n+\t      if (cgraph_mark_inline_edge (e, true, NULL))\n+\t\tredo_always_inline = true;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \" Inlined into %s which now has %i insns.\\n\",\n+\t\t\t cgraph_node_name (e->caller),\n+\t\t\t e->caller->global.insns);\n \t    }\n-\t  cgraph_mark_inline_edge (e, true);\n-\t  if (flag_indirect_inlining)\n-\t    ipa_propagate_indirect_call_infos (e, NULL);\n+\t  /* Inlining self recursive function might introduce new calls to\n+\t     themselves we didn't see in the loop above.  Fill in the proper\n+\t     reason why inline failed.  */\n+\t  for (e = node->callers; e; e = e->next_caller)\n+\t    if (e->inline_failed)\n+\t      e->inline_failed = N_(\"recursive inlining\");\n \t  if (dump_file)\n \t    fprintf (dump_file, \n-\t\t     \" Inlined into %s which now has %i insns.\\n\",\n-\t\t     cgraph_node_name (e->caller),\n-\t\t     e->caller->global.insns);\n+\t\t     \" Inlined for a net change of %+i insns.\\n\",\n+\t\t     overall_insns - old_insns);\n \t}\n-      /* Inlining self recursive function might introduce new calls to\n-\t themselves we didn't see in the loop above.  Fill in the proper\n-\t reason why inline failed.  */\n-      for (e = node->callers; e; e = e->next_caller)\n-\tif (e->inline_failed)\n-\t  e->inline_failed = N_(\"recursive inlining\");\n-      if (dump_file)\n-\tfprintf (dump_file, \n-\t\t \" Inlined for a net change of %+i insns.\\n\",\n-\t\t overall_insns - old_insns);\n     }\n \n   cgraph_decide_inlining_of_small_functions ();\n \n-  /* After this point, any edge discovery performed by indirect inlining is no\n-     good so let's give up. */\n-  if (flag_indirect_inlining)\n-    free_all_ipa_structures_after_iinln ();\n-\n   if (flag_inline_functions_called_once)\n     {\n       if (dump_file)\n@@ -1220,6 +1227,10 @@ cgraph_decide_inlining (void)\n \t}\n     }\n \n+  /* Free ipa-prop structures if they are no longer needed.  */\n+  if (flag_indirect_inlining)\n+    free_all_ipa_structures_after_iinln ();\n+\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\nInlined %i calls, eliminated %i functions, \"\n@@ -1635,8 +1646,7 @@ inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n \n   if (!flag_ipa_cp)\n     {\n-      ipa_count_formal_params (node);\n-      ipa_create_param_decls_array (node);\n+      ipa_initialize_node_params (node);\n       ipa_detect_param_modifications (node);\n     }\n   ipa_analyze_params_uses (node);"}, {"sha": "90b0333e7836db412ae150c838b2efd0dfc328d7", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 72, "deletions": 63, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "patch": "@@ -102,52 +102,67 @@ ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n \n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n-    if (ipa_get_ith_param(info, i) == ptree)\n+    if (ipa_get_param(info, i) == ptree)\n       return i;\n \n   return -1;\n }\n \n-/* Insert the formal trees to the param_decls array in function MT.  */\n-void\n-ipa_create_param_decls_array (struct cgraph_node *mt)\n+/* Populate the param_decl field in parameter descriptors of INFO that\n+   corresponds to NODE.  */\n+static void\n+ipa_populate_param_decls (struct cgraph_node *node,\n+\t\t\t  struct ipa_node_params *info)\n {\n   tree fndecl;\n   tree fnargs;\n   tree parm;\n   int param_num;\n-  struct ipa_node_params *info = IPA_NODE_REF (mt);\n-\n-  if (info->param_decls)\n-    return;\n \n-  info->param_decls = XCNEWVEC (tree, ipa_get_param_count (info));\n-  fndecl = mt->decl;\n+  fndecl = node->decl;\n   fnargs = DECL_ARGUMENTS (fndecl);\n   param_num = 0;\n   for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n     {\n-      info->param_decls[param_num] = parm;\n+      info->params[param_num].decl = parm;\n       param_num++;\n     }\n }\n \n-/* Count number of formals in MT. Insert the result to the \n-   ipa_node_params.  */\n-void\n-ipa_count_formal_params (struct cgraph_node *mt)\n+/* Count number of formal parameters in NOTE. Store the result to the\n+   appropriate field of INFO.  */\n+static void\n+ipa_count_formal_params (struct cgraph_node *node,\n+\t\t\t struct ipa_node_params *info)\n {\n   tree fndecl;\n   tree fnargs;\n   tree parm;\n   int param_num;\n \n-  fndecl = mt->decl;\n+  fndecl = node->decl;\n   fnargs = DECL_ARGUMENTS (fndecl);\n   param_num = 0;\n   for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n     param_num++;\n-  ipa_set_param_count (IPA_NODE_REF (mt), param_num);\n+  ipa_set_param_count (info, param_num);\n+}\n+\n+/* Initialize the ipa_node_params structure associated with NODE by counting\n+   the function parameters, creating the descriptors and populating their\n+   param_decls.  */\n+void\n+ipa_initialize_node_params (struct cgraph_node *node)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+\n+  if (!info->params)\n+    {\n+      ipa_count_formal_params (node, info);\n+      info->params = XCNEWVEC (struct ipa_param_descriptor,\n+\t\t\t\t    ipa_get_param_count (info));\n+      ipa_populate_param_decls (node, info);\n+    }\n }\n \n /* Check STMT to detect whether a formal parameter is directly modified within\n@@ -173,13 +188,13 @@ ipa_check_stmt_modifications (struct ipa_node_params *info, gimple stmt)\n \tlhs = SSA_NAME_VAR (lhs);\n       index = ipa_get_param_decl_index (info, lhs);\n       if (index >= 0)\n-\tinfo->param_flags[index].modified = true;\n+\tinfo->params[index].modified = true;\n       break;\n \n     case GIMPLE_ASM:\n       /* Asm code could modify any of the parameters.  */\n       for (j = 0; j < ipa_get_param_count (info); j++)\n-\tinfo->param_flags[j].modified = true;\n+\tinfo->params[j].modified = true;\n       break;\n \n     default:\n@@ -205,10 +220,6 @@ ipa_detect_param_modifications (struct cgraph_node *node)\n   if (ipa_get_param_count (info) == 0 || info->modification_analysis_done)\n     return;\n \n-  if (!info->param_flags)\n-    info->param_flags = XCNEWVEC (struct ipa_param_flags,\n-\t\t\t\t  ipa_get_param_count (info));\n-\n   func = DECL_STRUCT_FUNCTION (decl);\n   FOR_EACH_BB_FN (bb, func)\n     {\n@@ -221,8 +232,8 @@ ipa_detect_param_modifications (struct cgraph_node *node)\n \n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n-    if (TREE_ADDRESSABLE (ipa_get_ith_param (info, i)))\n-      info->param_flags[i].modified = true;\n+    if (TREE_ADDRESSABLE (ipa_get_param (info, i)))\n+      info->params[i].modified = true;\n \n   info->modification_analysis_done = 1;\n }\n@@ -402,7 +413,7 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t      int index = ipa_get_param_decl_index (info, arg);\n \n \t      gcc_assert (index >=0);\n-\t      if (!ipa_is_ith_param_modified (info, index))\n+\t      if (!ipa_is_param_modified (info, index))\n \t\t{\n \t\t  functions[num].type = IPA_PASS_THROUGH;\n \t\t  functions[num].value.formal_id = index;\n@@ -613,7 +624,7 @@ ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n   struct ipa_param_call_note *note;\n   basic_block bb = gimple_bb (stmt);\n \n-  info->param_flags[formal_id].called = 1;\n+  info->params[formal_id].called = 1;\n \n   note = XCNEW (struct ipa_param_call_note);\n   note->formal_id = formal_id;\n@@ -788,7 +799,7 @@ ipa_analyze_call_uses (struct ipa_node_params *info, gimple call)\n     return;\n \n   index = ipa_get_param_decl_index (info, rec);\n-  if (index >= 0 && !ipa_is_ith_param_modified (info, index))\n+  if (index >= 0 && !ipa_is_param_modified (info, index))\n     ipa_note_param_call (info, index, call);\n \n   return;\n@@ -818,9 +829,6 @@ ipa_analyze_params_uses (struct cgraph_node *node)\n \n   if (ipa_get_param_count (info) == 0 || info->uses_analysis_done)\n     return;\n-  if (!info->param_flags)\n-    info->param_flags = XCNEWVEC (struct ipa_param_flags,\n-\t\t\t\t  ipa_get_param_count (info));\n \n   func = DECL_STRUCT_FUNCTION (decl);\n   FOR_EACH_BB_FN (bb, func)\n@@ -891,15 +899,16 @@ print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n    assuming NODE is (potentially indirectly) inlined into CS->callee.\n    Moreover, if the callee is discovered to be constant, create a new cgraph\n    edge for it.  Newly discovered indirect edges will be added to *NEW_EDGES,\n-   unless NEW_EDGES is NULL.  */\n-static void\n+   unless NEW_EDGES is NULL.  Return true iff a new edge(s) were created.  */\n+static bool\n update_call_notes_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t  struct cgraph_node *node,\n \t\t\t\t  VEC (cgraph_edge_p, heap) **new_edges)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   struct ipa_edge_args *top = IPA_EDGE_REF (cs);\n   struct ipa_param_call_note *nt;\n+  bool res = false;\n \n   for (nt = info->param_calls; nt; nt = nt->next)\n     {\n@@ -940,6 +949,7 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n \t  if (!callee || !callee->local.inlinable)\n \t    continue;\n \n+\t  res = true;\n \t  if (dump_file)\n \t    print_edge_addition_message (dump_file, nt, jfunc, node);\n \n@@ -953,39 +963,51 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n \t  top = IPA_EDGE_REF (cs);\n \t}\n     }\n+  return res;\n }\n \n /* Recursively traverse subtree of NODE (including node) made of inlined\n    cgraph_edges when CS has been inlined and invoke\n    update_call_notes_after_inlining on all nodes and\n    update_jump_functions_after_inlining on all non-inlined edges that lead out\n    of this subtree.  Newly discovered indirect edges will be added to\n-   *NEW_EDGES, unless NEW_EDGES is NULL.  */\n-static void\n+   *NEW_EDGES, unless NEW_EDGES is NULL.  Return true iff a new edge(s) were\n+   created.  */\n+static bool\n propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n \t\t\t\t   struct cgraph_node *node,\n \t\t\t\t   VEC (cgraph_edge_p, heap) **new_edges)\n {\n   struct cgraph_edge *e;\n+  bool res;\n \n-  update_call_notes_after_inlining (cs, node, new_edges);\n+  res = update_call_notes_after_inlining (cs, node, new_edges);\n \n   for (e = node->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n-      propagate_info_to_inlined_callees (cs, e->callee, new_edges);\n+      res |= propagate_info_to_inlined_callees (cs, e->callee, new_edges);\n     else\n       update_jump_functions_after_inlining (cs, e);\n+\n+  return res;\n }\n \n /* Update jump functions and call note functions on inlining the call site CS.\n    CS is expected to lead to a node already cloned by\n    cgraph_clone_inline_nodes.  Newly discovered indirect edges will be added to\n-   *NEW_EDGES, unless NEW_EDGES is NULL.  */\n-void\n+   *NEW_EDGES, unless NEW_EDGES is NULL.  Return true iff a new edge(s) were +\n+   created.  */\n+bool\n ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t   VEC (cgraph_edge_p, heap) **new_edges)\n {\n-  propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n+  /* Do nothing if the preparation phase has not been carried out yet\n+     (i.e. during early inlining).  */\n+  if (!ipa_node_params_vector)\n+    return false;\n+  gcc_assert (ipa_edge_args_vector);\n+\n+  return propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n }\n \n /* Frees all dynamically allocated structures that the argument info points\n@@ -1020,12 +1042,8 @@ ipa_free_all_edge_args (void)\n void\n ipa_free_node_params_substructures (struct ipa_node_params *info)\n {\n-  if (info->ipcp_lattices)\n-    free (info->ipcp_lattices);\n-  if (info->param_decls)\n-    free (info->param_decls);\n-  if (info->param_flags)\n-    free (info->param_flags);\n+  if (info->params)\n+    free (info->params);\n \n   while (info->param_calls)\n     {\n@@ -1091,7 +1109,7 @@ duplicate_array (void *src, size_t n)\n /* Hook that is called by cgraph.c when a node is duplicated.  */\n static void\n ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n-\t\t\t   void *data)\n+\t\t\t   __attribute__((unused)) void *data)\n {\n   struct ipa_edge_args *old_args, *new_args;\n   int arg_count;\n@@ -1106,13 +1124,12 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n   new_args->jump_functions = (struct ipa_jump_func *)\n     duplicate_array (old_args->jump_functions,\n \t\t     sizeof (struct ipa_jump_func) * arg_count);\n-  data = data; \t\t\t/* Suppressing compiler warning.  */\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n static void\n ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n-\t\t\t   void *data)\n+\t\t\t   __attribute__((unused)) void *data)\n {\n   struct ipa_node_params *old_info, *new_info;\n   struct ipa_param_call_note *note;\n@@ -1124,15 +1141,9 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n   param_count = ipa_get_param_count (old_info);\n \n   ipa_set_param_count (new_info, param_count);\n-  new_info->ipcp_lattices = (struct ipcp_lattice *)\n-    duplicate_array (old_info->ipcp_lattices,\n-\t\t     sizeof (struct ipcp_lattice) * param_count);\n-  new_info->param_decls = (tree *)\n-    duplicate_array (old_info->param_decls, sizeof (tree) * param_count);\n-  new_info->param_flags = (struct ipa_param_flags *)\n-    duplicate_array (old_info->param_flags,\n-\t\t     sizeof (struct ipa_param_flags) * param_count);\n-\n+  new_info->params = (struct ipa_param_descriptor *)\n+    duplicate_array (old_info->params,\n+\t\t     sizeof (struct ipa_param_descriptor) * param_count);\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n   new_info->count_scale = old_info->count_scale;\n \n@@ -1146,8 +1157,6 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n       nn->next = new_info->param_calls;\n       new_info->param_calls = nn;\n     }\n-\n-  data = data; \t\t\t/* Suppressing compiler warning.  */\n }\n \n /* Register our cgraph hooks if they are not already there.  */\n@@ -1221,13 +1230,13 @@ ipa_print_node_params (FILE * f, struct cgraph_node *node)\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n-      temp = ipa_get_ith_param (info, i);\n+      temp = ipa_get_param (info, i);\n       if (TREE_CODE (temp) == PARM_DECL)\n \tfprintf (f, \"    param %d : %s\", i,\n \t\t (*lang_hooks.decl_printable_name) (temp, 2));\n-      if (ipa_is_ith_param_modified (info, i))\n+      if (ipa_is_param_modified (info, i))\n \tfprintf (f, \" modified\");\n-      if (ipa_is_ith_param_called (info, i))\n+      if (ipa_is_param_called (info, i))\n \tfprintf (f, \" called\");\n       fprintf (f, \"\\n\");\n     }"}, {"sha": "47010e1ab5930bd8c9d51b5cb39cc77e7d707c39", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e2a1ed3b746951a5d07e03f91d1f8209ebe775/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=f8e2a1ed3b746951a5d07e03f91d1f8209ebe775", "patch": "@@ -110,16 +110,6 @@ struct ipa_replace_map\n   bool ref_p;\n };\n \n-/* ipa_param_flags contains various flags that describe how the associated\n-   parameter is treated within a function. */\n-struct ipa_param_flags\n-{\n-  /* Whether the value parameter has been modified within the function.  */\n-  unsigned modified : 1;\n-  /* Whether the parameter has been used as a call destination. */\n-  unsigned called : 1;\n-};\n-\n /* Each instance of the following  structure describes a statement that calls a\n    function parameter.  Those referring  to statements within the same function\n    are linked in a list.  */\n@@ -144,6 +134,19 @@ struct ipa_param_call_note\n   bool processed;\n };\n \n+/* Structure describing a single formal parameter.  */\n+struct ipa_param_descriptor\n+{\n+  /* IPA-CP lattice.  */\n+  struct ipcp_lattice ipcp_lattice;\n+  /* PARAM_DECL of this parameter.  */\n+  tree decl;\n+  /* Whether the value parameter has been modified within the function.  */\n+  unsigned modified : 1;\n+  /* Whether the parameter has been used as a call destination. */\n+  unsigned called : 1;\n+};\n+\n /* ipa_node_params stores information related to formal parameters of functions\n    and some other information for interprocedural passes that operate on\n    parameters (such as ipa-cp).  */\n@@ -153,12 +156,9 @@ struct ipa_node_params\n      this function's parameters would not be analyzed by the different\n      stages of IPA CP.  */\n   int param_count;\n-  /* Array of lattices.  */\n-  struct ipcp_lattice *ipcp_lattices;\n-  /* Mapping each parameter to its PARM_DECL tree.  */\n-  tree *param_decls;\n-  /* Various flags describing individual parameters.  */\n-  struct ipa_param_flags *param_flags;\n+  /* Pointer to an array of structures describing individual formal\n+     parameters.  */\n+  struct ipa_param_descriptor *params;\n   /* List of structures enumerating calls to a formal parameter.  */\n   struct ipa_param_call_note *param_calls;\n   /* Only for versioned nodes this field would not be NULL,\n@@ -197,31 +197,33 @@ ipa_get_param_count (struct ipa_node_params *info)\n   return info->param_count;\n }\n \n-/* Returns the declaration of ith param of the corresponding node.  Note there\n-   is no setter function as this array is built just once using\n-   ipa_create_param_decls_array. */\n+/* Return the declaration of Ith formal parameter of the function corresponding\n+   to INFO.  Note there is no setter function as this array is built just once\n+   using ipa_initialize_node_params. */\n static inline tree\n-ipa_get_ith_param (struct ipa_node_params *info, int i)\n+ipa_get_param (struct ipa_node_params *info, int i)\n {\n-  return info->param_decls[i];\n+  return info->params[i].decl;\n }\n \n-/* Returns the modification flag corresponding to the ith parameter.  Note\n-   there is no setter method as the goal is to set all flags when building the\n-   array in ipa_detect_param_modifications.  */\n+/* Return the modification flag corresponding to the Ith formal parameter of\n+   the function associated with INFO.  Note that there is no setter method as\n+   the goal is to set all flags when building the array in\n+   ipa_detect_param_modifications.  */\n static inline bool\n-ipa_is_ith_param_modified (struct ipa_node_params *info, int i)\n+ipa_is_param_modified (struct ipa_node_params *info, int i)\n {\n-  return info->param_flags[i].modified;\n+  return info->params[i].modified;\n }\n \n-/* Returns the called flag corresponding o the ith paramterer.  Note there is\n-   no setter method as the goal is to set all flags when building the array in\n+/* Return the called flag corresponding to the Ith formal parameter of the\n+   function associated with INFO.  Note that there is no setter method as the\n+   goal is to set all flags when building the array in\n    ipa_detect_called_params.  */\n static inline bool\n-ipa_is_ith_param_called (struct ipa_node_params *info, int i)\n+ipa_is_param_called (struct ipa_node_params *info, int i)\n {\n-  return info->param_flags[i].called;\n+  return info->params[i].called;\n }\n \n /* Flag this node as having callers with variable number of arguments.  */\n@@ -372,12 +374,11 @@ struct cgraph_node *ipa_pop_func_from_list (struct ipa_func_list **);\n void ipa_compute_jump_functions (struct cgraph_edge *);\n void ipa_count_arguments (struct cgraph_edge *);\n \n-/* Function parameters related computations.  */\n-void ipa_count_formal_params (struct cgraph_node *);\n-void ipa_create_param_decls_array (struct cgraph_node *);\n+/* Function formal parameters related computations.  */\n+void ipa_initialize_node_params (struct cgraph_node *node);\n void ipa_detect_param_modifications (struct cgraph_node *);\n void ipa_analyze_params_uses (struct cgraph_node *);\n-void ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n+bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t\tVEC (cgraph_edge_p, heap) **new_edges);\n \n /* Debugging interface.  */"}]}