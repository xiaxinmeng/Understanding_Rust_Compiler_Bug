{"sha": "80096613015952f3090df0821a8a7d18be93f8ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwOTY2MTMwMTU5NTJmMzA5MGRmMDgyMWE4YTdkMThiZTkzZjhhYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-05-06T10:51:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-06T10:51:37Z"}, "message": "trans.c (Loop_Statement_to_gnu): Also handle invariant conditions with only one bound.\n\n\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Also handle invariant\n\tconditions with only one bound.\n\t(Raise_Error_to_gnu): Likewise. \u00a0New function extracted from...\n\t(gnat_to_gnu) <N_Raise_Constraint_Error>: ...here. \u00a0Call above function\n\tin regular mode only.\n\nFrom-SVN: r187208", "tree": {"sha": "345b95ed0fb536f8c5e13f0ab85a186a804b2c71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/345b95ed0fb536f8c5e13f0ab85a186a804b2c71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80096613015952f3090df0821a8a7d18be93f8ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80096613015952f3090df0821a8a7d18be93f8ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80096613015952f3090df0821a8a7d18be93f8ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80096613015952f3090df0821a8a7d18be93f8ac/comments", "author": null, "committer": null, "parents": [{"sha": "1a5b6cd2af58039fc40ae410ad8fb272b4002ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5b6cd2af58039fc40ae410ad8fb272b4002ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5b6cd2af58039fc40ae410ad8fb272b4002ca8"}], "stats": {"total": 267, "additions": 157, "deletions": 110}, "files": [{"sha": "803e97be8695c80a3d09ae9a2bc1f46ff6e26536", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80096613015952f3090df0821a8a7d18be93f8ac/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80096613015952f3090df0821a8a7d18be93f8ac/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=80096613015952f3090df0821a8a7d18be93f8ac", "patch": "@@ -1,3 +1,11 @@\n+2012-05-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Also handle invariant\n+\tconditions with only one bound.\n+\t(Raise_Error_to_gnu): Likewise. \ufffdNew function extracted from...\n+\t(gnat_to_gnu) <N_Raise_Constraint_Error>: ...here. \ufffdCall above function\n+\tin regular mode only.\n+\n 2012-05-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c (gnat_post_options): Disable caret by default."}, {"sha": "c4b9a7e2e319e4f6a505ea0fe1ac2e6f928b1125", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 149, "deletions": 110, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80096613015952f3090df0821a8a7d18be93f8ac/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80096613015952f3090df0821a8a7d18be93f8ac/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=80096613015952f3090df0821a8a7d18be93f8ac", "patch": "@@ -2563,13 +2563,19 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t     i++)\n \t  {\n \t    tree low_ok\n-\t      = build_binary_op (GE_EXPR, boolean_type_node,\n-\t\t\t\t convert (rci->type, gnu_low),\n-\t\t\t\t rci->low_bound);\n+\t      = rci->low_bound\n+\t        ? build_binary_op (GE_EXPR, boolean_type_node,\n+\t\t\t\t   convert (rci->type, gnu_low),\n+\t\t\t\t   rci->low_bound)\n+\t\t: boolean_true_node;\n+\n \t    tree high_ok\n-\t      = build_binary_op (LE_EXPR, boolean_type_node,\n-\t\t\t\t convert (rci->type, gnu_high),\n-\t\t\t\t rci->high_bound);\n+\t      = rci->high_bound\n+\t        ? build_binary_op (LE_EXPR, boolean_type_node,\n+\t\t\t\t   convert (rci->type, gnu_high),\n+\t\t\t\t   rci->high_bound)\n+\t\t: boolean_true_node;\n+\n \t    tree range_ok\n \t      = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n \t\t\t\t low_ok, high_ok);\n@@ -2794,7 +2800,7 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n       tree ret_val = TREE_OPERAND (TREE_OPERAND (t, 0), 1), init_expr;\n \n       /* If this is the temporary created for a return value with variable\n-\t size in call_to_gnu, we replace the RHS with the init expression.  */\n+\t size in Call_to_gnu, we replace the RHS with the init expression.  */\n       if (TREE_CODE (ret_val) == COMPOUND_EXPR\n \t  && TREE_CODE (TREE_OPERAND (ret_val, 0)) == INIT_EXPR\n \t  && TREE_OPERAND (TREE_OPERAND (ret_val, 0), 0)\n@@ -3122,7 +3128,7 @@ build_return_expr (tree ret_obj, tree ret_val)\n \t  && aggregate_value_p (operation_type, current_function_decl))\n \t{\n \t  /* Recognize the temporary created for a return value with variable\n-\t     size in call_to_gnu.  We want to eliminate it if possible.  */\n+\t     size in Call_to_gnu.  We want to eliminate it if possible.  */\n \t  if (TREE_CODE (ret_val) == COMPOUND_EXPR\n \t      && TREE_CODE (TREE_OPERAND (ret_val, 0)) == INIT_EXPR\n \t      && TREE_OPERAND (TREE_OPERAND (ret_val, 0), 0)\n@@ -3583,7 +3589,7 @@ create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n    requires atomic synchronization.  */\n \n static tree\n-call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n+Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t     bool atomic_sync)\n {\n   const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n@@ -4751,6 +4757,134 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   invalidate_global_renaming_pointers ();\n }\n \f\n+/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Raise_xxx_Error,\n+   to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to where\n+   we should place the result type.  LABEL_P is true if there is a label to\n+   branch to for the exception.  */\n+\n+static tree\n+Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n+{\n+  const Node_Kind kind = Nkind (gnat_node);\n+  const int reason = UI_To_Int (Reason (gnat_node));\n+  const Node_Id gnat_cond = Condition (gnat_node);\n+  const bool with_extra_info\n+    = Exception_Extra_Info\n+      && !No_Exception_Handlers_Set ()\n+      && !get_exception_label (kind);\n+  tree gnu_result = NULL_TREE, gnu_cond = NULL_TREE;\n+\n+  *gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n+\n+  switch (reason)\n+    {\n+    case CE_Access_Check_Failed:\n+      if (with_extra_info)\n+\tgnu_result = build_call_raise_column (reason, gnat_node);\n+      break;\n+\n+    case CE_Index_Check_Failed:\n+    case CE_Range_Check_Failed:\n+    case CE_Invalid_Data:\n+      if (Present (gnat_cond) && Nkind (gnat_cond) == N_Op_Not)\n+\t{\n+\t  Node_Id gnat_range, gnat_index, gnat_type;\n+\t  tree gnu_index, gnu_low_bound, gnu_high_bound;\n+\t  struct range_check_info_d *rci;\n+\n+\t  switch (Nkind (Right_Opnd (gnat_cond)))\n+\t    {\n+\t    case N_In:\n+\t      gnat_range = Right_Opnd (Right_Opnd (gnat_cond));\n+\t      gcc_assert (Nkind (gnat_range) == N_Range);\n+\t      gnu_low_bound = gnat_to_gnu (Low_Bound (gnat_range));\n+\t      gnu_high_bound = gnat_to_gnu (High_Bound (gnat_range));\n+\t      break;\n+\n+\t    case N_Op_Ge:\n+\t      gnu_low_bound = gnat_to_gnu (Right_Opnd (Right_Opnd (gnat_cond)));\n+\t      gnu_high_bound = NULL_TREE;\n+\t      break;\n+\n+\t    case N_Op_Le:\n+\t      gnu_low_bound = NULL_TREE;\n+\t      gnu_high_bound = gnat_to_gnu (Right_Opnd (Right_Opnd (gnat_cond)));\n+\t      break;\n+\n+\t    default:\n+\t      goto common;\n+\t    }\n+\n+\t  gnat_index = Left_Opnd (Right_Opnd (gnat_cond));\n+\t  gnat_type = Etype (gnat_index);\n+\t  gnu_index = gnat_to_gnu (gnat_index);\n+\n+\t  if (with_extra_info\n+\t      && gnu_low_bound\n+\t      && gnu_high_bound\n+\t      && Known_Esize (gnat_type)\n+\t      && UI_To_Int (Esize (gnat_type)) <= 32)\n+\t    gnu_result\n+\t      = build_call_raise_range (reason, gnat_node, gnu_index,\n+\t\t\t\t\tgnu_low_bound, gnu_high_bound);\n+\n+\t  /* If loop unswitching is enabled, we try to compute invariant\n+\t     conditions for checks applied to iteration variables, i.e.\n+\t     conditions that are both independent of the variable and\n+\t     necessary in order for the check to fail in the course of\n+\t     some iteration, and prepend them to the original condition\n+\t     of the checks.  This will make it possible later for the\n+\t     loop unswitching pass to replace the loop with two loops,\n+\t     one of which has the checks eliminated and the other has\n+\t     the original checks reinstated, and a run time selection.\n+\t     The former loop will be suitable for vectorization.  */\n+\t  if (flag_unswitch_loops\n+\t      && (!gnu_low_bound\n+\t\t  || (gnu_low_bound = gnat_invariant_expr (gnu_low_bound)))\n+\t      && (!gnu_high_bound\n+\t\t  || (gnu_high_bound = gnat_invariant_expr (gnu_high_bound)))\n+\t      && (rci = push_range_check_info (gnu_index)))\n+\t    {\n+\t      rci->low_bound = gnu_low_bound;\n+\t      rci->high_bound = gnu_high_bound;\n+\t      rci->type = gnat_to_gnu_type (gnat_type);\n+\t      rci->invariant_cond = build1 (SAVE_EXPR, boolean_type_node,\n+\t\t\t\t\t    boolean_true_node);\n+\t      gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,\n+\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  rci->invariant_cond,\n+\t\t\t\t\t  gnat_to_gnu (gnat_cond));\n+\t    }\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+common:\n+  if (!gnu_result)\n+    gnu_result = build_call_raise (reason, gnat_node, kind);\n+  set_expr_location_from_node (gnu_result, gnat_node);\n+\n+  /* If the type is VOID, this is a statement, so we need to generate the code\n+     for the call.  Handle a condition, if there is one.  */\n+  if (VOID_TYPE_P (*gnu_result_type_p))\n+    {\n+      if (Present (gnat_cond))\n+\t{\n+\t  if (!gnu_cond)\n+\t    gnu_cond = gnat_to_gnu (gnat_cond);\n+\t  gnu_result = build3 (COND_EXPR, void_type_node, gnu_cond, gnu_result,\n+\t\t\t       alloc_stmt_list ());\n+\t}\n+    }\n+  else\n+    gnu_result = build1 (NULL_EXPR, *gnu_result_type_p, gnu_result);\n+\n+  return gnu_result;\n+}\n+\f\n /* Return true if GNAT_NODE is on the LHS of an assignment or an actual\n    parameter of a call.  */\n \n@@ -5949,7 +6083,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t       N_Raise_Storage_Error);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call)\n \tgnu_result\n-\t  = call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n+\t  = Call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n \t\t\t atomic_sync_required_p (Name (gnat_node)));\n       else\n \t{\n@@ -6238,7 +6372,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n-      gnu_result = call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE, false);\n+      gnu_result = Call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE, false);\n       break;\n \n     /************************/\n@@ -6661,105 +6795,10 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Raise_Constraint_Error:\n     case N_Raise_Program_Error:\n     case N_Raise_Storage_Error:\n-      {\n-\tconst int reason = UI_To_Int (Reason (gnat_node));\n-\tconst Node_Id gnat_cond = Condition (gnat_node);\n-\tconst bool with_extra_info = Exception_Extra_Info\n-\t\t\t\t     && !No_Exception_Handlers_Set ()\n-\t\t\t\t     && !get_exception_label (kind);\n-\ttree gnu_cond = NULL_TREE;\n-\n-\tif (type_annotate_only)\n-\t  {\n-\t    gnu_result = alloc_stmt_list ();\n-\t    break;\n-\t  }\n-\n-        gnu_result_type = get_unpadded_type (Etype (gnat_node));\n-\n-\tswitch (reason)\n-\t  {\n-\t  case CE_Access_Check_Failed:\n-\t    if (with_extra_info)\n-\t      gnu_result = build_call_raise_column (reason, gnat_node);\n-\t    break;\n-\n-\t  case CE_Index_Check_Failed:\n-\t  case CE_Range_Check_Failed:\n-\t  case CE_Invalid_Data:\n-\t    if (Present (gnat_cond)\n-\t\t&& Nkind (gnat_cond) == N_Op_Not\n-\t\t&& Nkind (Right_Opnd (gnat_cond)) == N_In\n-\t\t&& Nkind (Right_Opnd (Right_Opnd (gnat_cond))) == N_Range)\n-\t      {\n-\t\tNode_Id gnat_index = Left_Opnd (Right_Opnd (gnat_cond));\n-\t\tNode_Id gnat_type = Etype (gnat_index);\n-\t\tNode_Id gnat_range = Right_Opnd (Right_Opnd (gnat_cond));\n-\t\ttree gnu_index = gnat_to_gnu (gnat_index);\n-\t\ttree gnu_low_bound = gnat_to_gnu (Low_Bound (gnat_range));\n-\t\ttree gnu_high_bound = gnat_to_gnu (High_Bound (gnat_range));\n-\t\tstruct range_check_info_d *rci;\n-\n-\t\tif (with_extra_info\n-\t\t    && Known_Esize (gnat_type)\n-\t\t    && UI_To_Int (Esize (gnat_type)) <= 32)\n-\t\t  gnu_result\n-\t\t    = build_call_raise_range (reason, gnat_node, gnu_index,\n-\t\t\t\t\t      gnu_low_bound, gnu_high_bound);\n-\n-\t\t/* If loop unswitching is enabled, we try to compute invariant\n-\t\t   conditions for checks applied to iteration variables, i.e.\n-\t\t   conditions that are both independent of the variable and\n-\t\t   necessary in order for the check to fail in the course of\n-\t\t   some iteration, and prepend them to the original condition\n-\t\t   of the checks.  This will make it possible later for the\n-\t\t   loop unswitching pass to replace the loop with two loops,\n-\t\t   one of which has the checks eliminated and the other has\n-\t\t   the original checks reinstated, and a run time selection.\n-\t\t   The former loop will be suitable for vectorization.  */\n-\t\tif (flag_unswitch_loops\n-\t\t    && (gnu_low_bound = gnat_invariant_expr (gnu_low_bound))\n-\t\t    && (gnu_high_bound = gnat_invariant_expr (gnu_high_bound))\n-\t\t    && (rci = push_range_check_info (gnu_index)))\n-\t\t  {\n-\t\t    rci->low_bound = gnu_low_bound;\n-\t\t    rci->high_bound = gnu_high_bound;\n-\t\t    rci->type = gnat_to_gnu_type (gnat_type);\n-\t\t    rci->invariant_cond = build1 (SAVE_EXPR, boolean_type_node,\n-\t\t\t\t\t\t  boolean_true_node);\n-\t\t    gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,\n-\t\t\t\t\t\tboolean_type_node,\n-\t\t\t\t\t\trci->invariant_cond,\n-\t\t\t\t\t\tgnat_to_gnu (gnat_cond));\n-\t\t  }\n-\t      }\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-\n-\tif (gnu_result == error_mark_node)\n-\t  gnu_result = build_call_raise (reason, gnat_node, kind);\n-\n-\tset_expr_location_from_node (gnu_result, gnat_node);\n-\n-\t/* If the type is VOID, this is a statement, so we need to generate\n-\t   the code for the call.  Handle a condition, if there is one.  */\n-\tif (VOID_TYPE_P (gnu_result_type))\n-\t  {\n-\t    if (Present (gnat_cond))\n-\t      {\n-\t\tif (!gnu_cond)\n-\t\t  gnu_cond = gnat_to_gnu (gnat_cond);\n-\t\tgnu_result\n-\t\t  = build3 (COND_EXPR, void_type_node, gnu_cond, gnu_result,\n-\t\t\t    alloc_stmt_list ());\n-\t      }\n-\t  }\n-\telse\n-\t  gnu_result = build1 (NULL_EXPR, gnu_result_type, gnu_result);\n-      }\n+      if (type_annotate_only)\n+\tgnu_result = alloc_stmt_list ();\n+      else\n+\tgnu_result = Raise_Error_to_gnu (gnat_node, &gnu_result_type);\n       break;\n \n     case N_Validate_Unchecked_Conversion:"}]}