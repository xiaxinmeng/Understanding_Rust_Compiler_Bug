{"sha": "db97b3b018921112adad38c5a7a4726fb4262e8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI5N2IzYjAxODkyMTExMmFkYWQzOGM1YTdhNDcyNmZiNDI2MmU4Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-12-03T12:00:02Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-12-03T12:00:02Z"}, "message": "hashtable.h: Fix whitespace and simplify function definitions with trailing return types.\n\n\t* include/bits/hashtable.h: Fix whitespace and simplify function\n\tdefinitions with trailing return types.\n\nFrom-SVN: r218309", "tree": {"sha": "9d73ad73b36648786ae1fb2d2ff6c51f9574e8d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d73ad73b36648786ae1fb2d2ff6c51f9574e8d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db97b3b018921112adad38c5a7a4726fb4262e8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db97b3b018921112adad38c5a7a4726fb4262e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db97b3b018921112adad38c5a7a4726fb4262e8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db97b3b018921112adad38c5a7a4726fb4262e8b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e18c1d66efcd143dff3ee5c1f1e0e5ef2bb8d2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18c1d66efcd143dff3ee5c1f1e0e5ef2bb8d2b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e18c1d66efcd143dff3ee5c1f1e0e5ef2bb8d2b8"}], "stats": {"total": 289, "additions": 131, "deletions": 158}, "files": [{"sha": "35cfa804e958fed73c17a976ad5c0db8024fb592", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db97b3b018921112adad38c5a7a4726fb4262e8b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db97b3b018921112adad38c5a7a4726fb4262e8b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=db97b3b018921112adad38c5a7a4726fb4262e8b", "patch": "@@ -1,3 +1,8 @@\n+2014-12-03  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/hashtable.h: Fix whitespace and simplify function\n+\tdefinitions with trailing return types.\n+\n 2014-12-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/64161"}, {"sha": "369737e508a1a95a223015ef400d1772f6527e87", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 126, "deletions": 158, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db97b3b018921112adad38c5a7a4726fb4262e8b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db97b3b018921112adad38c5a7a4726fb4262e8b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=db97b3b018921112adad38c5a7a4726fb4262e8b", "patch": "@@ -696,8 +696,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Insert with hint, not used when keys are unique.\n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n-\t_M_insert(const_iterator, _Arg&& __arg, const _NodeGenerator& __node_gen,\n-\t\t  std::true_type __uk)\n+\t_M_insert(const_iterator, _Arg&& __arg,\n+\t\t  const _NodeGenerator& __node_gen, std::true_type __uk)\n \t{\n \t  return\n \t    _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;\n@@ -706,7 +706,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Insert with hint when keys are not unique.\n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n-\t_M_insert(const_iterator, _Arg&&, const _NodeGenerator&, std::false_type);\n+\t_M_insert(const_iterator, _Arg&&,\n+\t\t  const _NodeGenerator&, std::false_type);\n \n       size_type\n       _M_erase(std::true_type, const key_type&);\n@@ -777,12 +778,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::__node_type*\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_bucket_begin(size_type __bkt) const\n+    -> __node_type*\n     {\n       __node_base* __n = _M_buckets[__bkt];\n       return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;\n@@ -851,95 +851,94 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>&\n-    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::operator=(\n-\t\tconst _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>& __ht)\n-      {\n-\tif (&__ht == this)\n-\t  return *this;\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    operator=(const _Hashtable& __ht)\n+    -> _Hashtable&\n+    {\n+      if (&__ht == this)\n+\treturn *this;\n \n-\tif (__node_alloc_traits::_S_propagate_on_copy_assign())\n-\t  {\n-\t    auto& __this_alloc = this->_M_node_allocator();\n-\t    auto& __that_alloc = __ht._M_node_allocator();\n-\t    if (!__node_alloc_traits::_S_always_equal()\n-\t\t&& __this_alloc != __that_alloc)\n-\t      {\n-\t\t// Replacement allocator cannot free existing storage.\n-\t\tthis->_M_deallocate_nodes(_M_begin());\n-\t\t_M_before_begin._M_nxt = nullptr;\n-\t\t_M_deallocate_buckets();\n-\t\t_M_buckets = nullptr;\n-\t\tstd::__alloc_on_copy(__this_alloc, __that_alloc);\n-\t\t__hashtable_base::operator=(__ht);\n-\t\t_M_bucket_count = __ht._M_bucket_count;\n-\t\t_M_element_count = __ht._M_element_count;\n-\t\t_M_rehash_policy = __ht._M_rehash_policy;\n-\t\t__try\n-\t\t  {\n-\t\t    _M_assign(__ht,\n-\t\t\t      [this](const __node_type* __n)\n-\t\t\t      { return this->_M_allocate_node(__n->_M_v()); });\n-\t\t  }\n-\t\t__catch(...)\n-\t\t  {\n-\t\t    // _M_assign took care of deallocating all memory. Now we\n-\t\t    // must make sure this instance remains in a usable state.\n-\t\t    _M_reset();\n-\t\t    __throw_exception_again;\n-\t\t  }\n-\t\treturn *this;\n-\t      }\n-\t    std::__alloc_on_copy(__this_alloc, __that_alloc);\n-\t  }\n+      if (__node_alloc_traits::_S_propagate_on_copy_assign())\n+\t{\n+\t  auto& __this_alloc = this->_M_node_allocator();\n+\t  auto& __that_alloc = __ht._M_node_allocator();\n+\t  if (!__node_alloc_traits::_S_always_equal()\n+\t      && __this_alloc != __that_alloc)\n+\t    {\n+\t      // Replacement allocator cannot free existing storage.\n+\t      this->_M_deallocate_nodes(_M_begin());\n+\t      _M_before_begin._M_nxt = nullptr;\n+\t      _M_deallocate_buckets();\n+\t      _M_buckets = nullptr;\n+\t      std::__alloc_on_copy(__this_alloc, __that_alloc);\n+\t      __hashtable_base::operator=(__ht);\n+\t      _M_bucket_count = __ht._M_bucket_count;\n+\t      _M_element_count = __ht._M_element_count;\n+\t      _M_rehash_policy = __ht._M_rehash_policy;\n+\t      __try\n+\t\t{\n+\t\t  _M_assign(__ht,\n+\t\t\t    [this](const __node_type* __n)\n+\t\t\t    { return this->_M_allocate_node(__n->_M_v()); });\n+\t\t}\n+\t      __catch(...)\n+\t\t{\n+\t\t  // _M_assign took care of deallocating all memory. Now we\n+\t\t  // must make sure this instance remains in a usable state.\n+\t\t  _M_reset();\n+\t\t  __throw_exception_again;\n+\t\t}\n+\t      return *this;\n+\t    }\n+\t  std::__alloc_on_copy(__this_alloc, __that_alloc);\n+\t}\n \n-\t// Reuse allocated buckets and nodes.\n-\t__bucket_type* __former_buckets = nullptr;\n-\tstd::size_t __former_bucket_count = _M_bucket_count;\n-\tconst __rehash_state& __former_state = _M_rehash_policy._M_state();\n-\t\n-\tif (_M_bucket_count != __ht._M_bucket_count)\n-\t  {\n-\t    __former_buckets = _M_buckets;\n-\t    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n-\t    _M_bucket_count = __ht._M_bucket_count;\n-\t  }\n-\telse\n+      // Reuse allocated buckets and nodes.\n+      __bucket_type* __former_buckets = nullptr;\n+      std::size_t __former_bucket_count = _M_bucket_count;\n+      const __rehash_state& __former_state = _M_rehash_policy._M_state();\n+\n+      if (_M_bucket_count != __ht._M_bucket_count)\n+\t{\n+\t  __former_buckets = _M_buckets;\n+\t  _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n+\t  _M_bucket_count = __ht._M_bucket_count;\n+\t}\n+      else\n+\t__builtin_memset(_M_buckets, 0,\n+\t\t\t _M_bucket_count * sizeof(__bucket_type));\n+\n+      __try\n+\t{\n+\t  __hashtable_base::operator=(__ht);\n+\t  _M_element_count = __ht._M_element_count;\n+\t  _M_rehash_policy = __ht._M_rehash_policy;\n+\t  __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n+\t  _M_before_begin._M_nxt = nullptr;\n+\t  _M_assign(__ht,\n+\t\t    [&__roan](const __node_type* __n)\n+\t\t    { return __roan(__n->_M_v()); });\n+\t  if (__former_buckets)\n+\t    _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n+\t}\n+      __catch(...)\n+\t{\n+\t  if (__former_buckets)\n+\t    {\n+\t      // Restore previous buckets.\n+\t      _M_deallocate_buckets();\n+\t      _M_rehash_policy._M_reset(__former_state);\n+\t      _M_buckets = __former_buckets;\n+\t      _M_bucket_count = __former_bucket_count;\n+\t    }\n \t  __builtin_memset(_M_buckets, 0,\n \t\t\t   _M_bucket_count * sizeof(__bucket_type));\n-\n-\t__try\n-\t  {\n-\t    __hashtable_base::operator=(__ht);\n-\t    _M_element_count = __ht._M_element_count;\n-\t    _M_rehash_policy = __ht._M_rehash_policy;\n-\t    __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n-\t    _M_before_begin._M_nxt = nullptr;\n-\t    _M_assign(__ht, \n-\t\t      [&__roan](const __node_type* __n)\n-\t\t      { return __roan(__n->_M_v()); });\n-\t    if (__former_buckets)\n-\t      _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    if (__former_buckets)\n-\t      {\n-\t\t// Restore previous buckets.\n-\t\t_M_deallocate_buckets();\n-\t\t_M_rehash_policy._M_reset(__former_state);\n-\t\t_M_buckets = __former_buckets;\n-\t\t_M_bucket_count = __former_bucket_count;\n-\t      }\n-\t    __builtin_memset(_M_buckets, 0,\n-\t\t\t     _M_bucket_count * sizeof(__bucket_type));\n-\t    __throw_exception_again;\n-\t  }\n-\treturn *this;\n-      }\n+\t  __throw_exception_again;\n+\t}\n+      return *this;\n+    }\n \n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n@@ -1297,12 +1296,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::iterator\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k)\n+    -> iterator\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n@@ -1314,12 +1312,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::const_iterator\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k) const\n+    -> const_iterator\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n@@ -1331,12 +1328,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::size_type\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     count(const key_type& __k) const\n+    -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n@@ -1364,17 +1360,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  _Traits>::iterator,\n-\t      typename _Hashtable<_Key, _Value, _Alloc,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  _Traits>::iterator>\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k)\n+    -> pair<iterator, iterator>\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n@@ -1397,17 +1387,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  _Traits>::const_iterator,\n-\t      typename _Hashtable<_Key, _Value, _Alloc,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  _Traits>::const_iterator>\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k) const\n+    -> pair<const_iterator, const_iterator>\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n@@ -1432,13 +1416,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::__node_base*\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_find_before_node(size_type __n, const key_type& __k,\n \t\t\t__hash_code __code) const\n+    -> __node_base*\n     {\n       __node_base* __prev_p = _M_buckets[__n];\n       if (!__prev_p)\n@@ -1516,12 +1499,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::__node_base*\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_get_previous_node(size_type __bkt, __node_base* __n)\n+    -> __node_base*\n     {\n       __node_base* __prev_n = _M_buckets[__bkt];\n       while (__prev_n->_M_nxt != __n)\n@@ -1534,13 +1516,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n     template<typename... _Args>\n-      std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n-\t\t\t\t    _ExtractKey, _Equal, _H1,\n-\t\t\t\t    _H2, _Hash, _RehashPolicy,\n-\t\t\t\t    _Traits>::iterator, bool>\n+      auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_emplace(std::true_type, _Args&&... __args)\n+      -> pair<iterator, bool>\n       {\n \t// First build the node to get access to the hash code\n \t__node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);\n@@ -1574,12 +1554,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n     template<typename... _Args>\n-      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t  _Traits>::iterator\n+      auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)\n+      -> iterator\n       {\n \t// First build the node to get its hash code.\n \t__node_type* __node =\n@@ -1603,13 +1582,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::iterator\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_insert_unique_node(size_type __bkt, __hash_code __code,\n \t\t\t  __node_type* __node)\n+    -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       std::pair<bool, std::size_t> __do_rehash\n@@ -1643,13 +1621,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::iterator\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_insert_multi_node(__node_type* __hint, __hash_code __code,\n \t\t\t __node_type* __node)\n+    -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       std::pair<bool, std::size_t> __do_rehash\n@@ -1709,13 +1686,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n     template<typename _Arg, typename _NodeGenerator>\n-      std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n-\t\t\t\t    _ExtractKey, _Equal, _H1,\n-\t\t\t\t    _H2, _Hash, _RehashPolicy,\n-\t\t\t\t    _Traits>::iterator, bool>\n+      auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, std::true_type)\n+      -> pair<iterator, bool>\n       {\n \tconst key_type& __k = this->_M_extract()(__v);\n \t__hash_code __code = this->_M_hash_code(__k);\n@@ -1735,14 +1710,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n     template<typename _Arg, typename _NodeGenerator>\n-      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t  _Traits>::iterator\n+      auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_insert(const_iterator __hint, _Arg&& __v,\n-\t\tconst _NodeGenerator& __node_gen,\n-\t\tstd::false_type)\n+\t\tconst _NodeGenerator& __node_gen, std::false_type)\n+      -> iterator\n       {\n \t// First compute the hash code so that we don't do anything if it\n \t// throws.\n@@ -1758,12 +1731,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::iterator\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     erase(const_iterator __it)\n+    -> iterator\n     {\n       __node_type* __n = __it._M_cur;\n       std::size_t __bkt = _M_bucket_index(__n);\n@@ -1779,12 +1751,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::iterator\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)\n+    -> iterator\n     {\n       if (__prev_n == _M_buckets[__bkt])\n \t_M_remove_bucket_begin(__bkt, __n->_M_next(),\n@@ -1808,12 +1779,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::size_type\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_erase(std::true_type, const key_type& __k)\n+    -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__k, __code);\n@@ -1833,12 +1803,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::size_type\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_erase(std::false_type, const key_type& __k)\n+    -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__k, __code);\n@@ -1890,12 +1859,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t_Traits>::iterator\n+    auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     erase(const_iterator __first, const_iterator __last)\n+    -> iterator\n     {\n       __node_type* __n = __first._M_cur;\n       __node_type* __last_n = __last._M_cur;"}]}