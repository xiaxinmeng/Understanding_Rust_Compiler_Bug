{"sha": "d93817c435983e82d29ca34a18c2e0e0781f9a7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkzODE3YzQzNTk4M2U4MmQyOWNhMzRhMThjMmUwZTA3ODFmOWE3YQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-01-26T19:33:04Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-26T19:33:04Z"}, "message": "tree-data-ref.c (dump_subscript): Use dump_conflict_function.\n\n\t* tree-data-ref.c (dump_subscript): Use dump_conflict_function.\n\t(compute_subscript_distance, initialize_data_dependence_relation,\n\tfinalize_ddr_dependent, analyze_ziv_subscript,\n\tanalyze_siv_subscript_cst_affine,\n\tcompute_overlap_steps_for_affine_univar,\n\tcompute_overlap_steps_for_affine_1_2, analyze_subscript_affine_affine,\n\tanalyze_siv_subscript, analyze_miv_subscript,\n\tanalyze_overlapping_iterations, subscript_dependence_tester_1,\n\tcompute_self_dependence, free_dependence_relation): Work\n\twith affine_fn instead of chrecs.\n\t(dump_affine_function, dump_conflict_function, affine_function_equal_p,\n\tcommon_affine_function, affine_function_base,\n\taffine_function_constant_p, affine_fn_op, affine_fn_plus,\n\taffine_fn_minus, affine_fn_free, conflict_fn_not_known,\n\tconflict_fn_no_dependence, free_conflict_function, free_subscripts,\n\tconflict_fn, affine_fn_cst, affine_fn_univar): New functions.\n\t(all_chrecs_equal_p): Removed.\n\t* tree-data-ref.h (affine_fn, conflict_function): New types.\n\t(struct subscript): Change type of conflicting_iterations_in_a\n\tand conflicting_iterations_in_b.\n\nFrom-SVN: r121212", "tree": {"sha": "882484094ab53b168223d0aa692902de4af38b59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/882484094ab53b168223d0aa692902de4af38b59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d93817c435983e82d29ca34a18c2e0e0781f9a7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93817c435983e82d29ca34a18c2e0e0781f9a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d93817c435983e82d29ca34a18c2e0e0781f9a7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93817c435983e82d29ca34a18c2e0e0781f9a7a/comments", "author": null, "committer": null, "parents": [{"sha": "dfcb2b5145d2e16ccd171a2cf7b35b4103ef8977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfcb2b5145d2e16ccd171a2cf7b35b4103ef8977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfcb2b5145d2e16ccd171a2cf7b35b4103ef8977"}], "stats": {"total": 763, "additions": 522, "deletions": 241}, "files": [{"sha": "19e183db6f1436c01b3c3ebc782e882b8ff11088", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93817c435983e82d29ca34a18c2e0e0781f9a7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93817c435983e82d29ca34a18c2e0e0781f9a7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d93817c435983e82d29ca34a18c2e0e0781f9a7a", "patch": "@@ -1,3 +1,26 @@\n+2007-01-26  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-data-ref.c (dump_subscript): Use dump_conflict_function.\n+\t(compute_subscript_distance, initialize_data_dependence_relation,\n+\tfinalize_ddr_dependent, analyze_ziv_subscript,\n+\tanalyze_siv_subscript_cst_affine,\n+\tcompute_overlap_steps_for_affine_univar,\n+\tcompute_overlap_steps_for_affine_1_2, analyze_subscript_affine_affine,\n+\tanalyze_siv_subscript, analyze_miv_subscript,\n+\tanalyze_overlapping_iterations, subscript_dependence_tester_1,\n+\tcompute_self_dependence, free_dependence_relation): Work\n+\twith affine_fn instead of chrecs.\n+\t(dump_affine_function, dump_conflict_function, affine_function_equal_p,\n+\tcommon_affine_function, affine_function_base,\n+\taffine_function_constant_p, affine_fn_op, affine_fn_plus,\n+\taffine_fn_minus, affine_fn_free, conflict_fn_not_known,\n+\tconflict_fn_no_dependence, free_conflict_function, free_subscripts,\n+\tconflict_fn, affine_fn_cst, affine_fn_univar): New functions.\n+\t(all_chrecs_equal_p): Removed.\n+\t* tree-data-ref.h (affine_fn, conflict_function): New types.\n+\t(struct subscript): Change type of conflicting_iterations_in_a\n+\tand conflicting_iterations_in_b.\n+\n 2007-01-26  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR other/30182"}, {"sha": "2da59db43ff14f7e535402a410cbe92f75f8a959", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 474, "deletions": 239, "changes": 713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93817c435983e82d29ca34a18c2e0e0781f9a7a/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93817c435983e82d29ca34a18c2e0e0781f9a7a/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=d93817c435983e82d29ca34a18c2e0e0781f9a7a", "patch": "@@ -626,35 +626,66 @@ dump_data_reference (FILE *outf,\n   fprintf (outf, \")\\n\");\n }\n \n+/* Dumps the affine function described by FN to the file OUTF.  */\n+\n+static void\n+dump_affine_function (FILE *outf, affine_fn fn)\n+{\n+  unsigned i;\n+  tree coef;\n+\n+  print_generic_expr (outf, VEC_index (tree, fn, 0), TDF_SLIM);\n+  for (i = 1; VEC_iterate (tree, fn, i, coef); i++)\n+    {\n+      fprintf (outf, \" + \");\n+      print_generic_expr (outf, coef, TDF_SLIM);\n+      fprintf (outf, \" * x_%u\", i);\n+    }\n+}\n+\n+/* Dumps the conflict function CF to the file OUTF.  */\n+\n+static void\n+dump_conflict_function (FILE *outf, conflict_function *cf)\n+{\n+  unsigned i;\n+\n+  if (cf->n == NO_DEPENDENCE)\n+    fprintf (outf, \"no dependence\\n\");\n+  else if (cf->n == NOT_KNOWN)\n+    fprintf (outf, \"not known\\n\");\n+  else\n+    {\n+      for (i = 0; i < cf->n; i++)\n+\t{\n+\t  fprintf (outf, \"[\");\n+\t  dump_affine_function (outf, cf->fns[i]);\n+\t  fprintf (outf, \"]\\n\");\n+\t}\n+    }\n+}\n+\n /* Dump function for a SUBSCRIPT structure.  */\n \n void \n dump_subscript (FILE *outf, struct subscript *subscript)\n {\n-  tree chrec = SUB_CONFLICTS_IN_A (subscript);\n+  conflict_function *cf = SUB_CONFLICTS_IN_A (subscript);\n \n   fprintf (outf, \"\\n (subscript \\n\");\n   fprintf (outf, \"  iterations_that_access_an_element_twice_in_A: \");\n-  print_generic_stmt (outf, chrec, 0);\n-  if (chrec == chrec_known)\n-    fprintf (outf, \"    (no dependence)\\n\");\n-  else if (chrec_contains_undetermined (chrec))\n-    fprintf (outf, \"    (don't know)\\n\");\n-  else\n+  dump_conflict_function (outf, cf);\n+  if (CF_NONTRIVIAL_P (cf))\n     {\n       tree last_iteration = SUB_LAST_CONFLICT (subscript);\n       fprintf (outf, \"  last_conflict: \");\n       print_generic_stmt (outf, last_iteration, 0);\n     }\n \t  \n-  chrec = SUB_CONFLICTS_IN_B (subscript);\n+  cf = SUB_CONFLICTS_IN_B (subscript);\n   fprintf (outf, \"  iterations_that_access_an_element_twice_in_B: \");\n-  print_generic_stmt (outf, chrec, 0);\n-  if (chrec == chrec_known)\n-    fprintf (outf, \"    (no dependence)\\n\");\n-  else if (chrec_contains_undetermined (chrec))\n-    fprintf (outf, \"    (don't know)\\n\");\n-  else\n+  dump_conflict_function (outf, cf);\n+  if (CF_NONTRIVIAL_P (cf))\n     {\n       tree last_iteration = SUB_LAST_CONFLICT (subscript);\n       fprintf (outf, \"  last_conflict: \");\n@@ -2003,80 +2034,193 @@ create_data_ref (tree memref, tree stmt, bool is_read)\n   return dr;  \n }\n \n+/* Returns true if FNA == FNB.  */\n+\n+static bool\n+affine_function_equal_p (affine_fn fna, affine_fn fnb)\n+{\n+  unsigned i, n = VEC_length (tree, fna);\n \n-/* Returns true when all the functions of a tree_vec CHREC are the\n-   same.  */\n+  gcc_assert (n == VEC_length (tree, fnb));\n \n-static bool \n-all_chrecs_equal_p (tree chrec)\n+  for (i = 0; i < n; i++)\n+    if (!operand_equal_p (VEC_index (tree, fna, i),\n+\t\t\t  VEC_index (tree, fnb, i), 0))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* If all the functions in CF are the same, returns one of them,\n+   otherwise returns NULL.  */\n+\n+static affine_fn\n+common_affine_function (conflict_function *cf)\n {\n-  int j;\n+  unsigned i;\n+  affine_fn comm;\n+\n+  if (!CF_NONTRIVIAL_P (cf))\n+    return NULL;\n+\n+  comm = cf->fns[0];\n+\n+  for (i = 1; i < cf->n; i++)\n+    if (!affine_function_equal_p (comm, cf->fns[i]))\n+      return NULL;\n+\n+  return comm;\n+}\n \n-  for (j = 0; j < TREE_VEC_LENGTH (chrec) - 1; j++)\n-    if (!eq_evolutions_p (TREE_VEC_ELT (chrec, j),\n-\t\t\t  TREE_VEC_ELT (chrec, j + 1)))\n+/* Returns the base of the affine function FN.  */\n+\n+static tree\n+affine_function_base (affine_fn fn)\n+{\n+  return VEC_index (tree, fn, 0);\n+}\n+\n+/* Returns true if FN is a constant.  */\n+\n+static bool\n+affine_function_constant_p (affine_fn fn)\n+{\n+  unsigned i;\n+  tree coef;\n+\n+  for (i = 1; VEC_iterate (tree, fn, i, coef); i++)\n+    if (!integer_zerop (coef))\n       return false;\n \n   return true;\n }\n \n+/* Applies operation OP on affine functions FNA and FNB, and returns the\n+   result.  */\n+\n+static affine_fn\n+affine_fn_op (enum tree_code op, affine_fn fna, affine_fn fnb)\n+{\n+  unsigned i, n, m;\n+  affine_fn ret;\n+  tree coef;\n+\n+  if (VEC_length (tree, fnb) > VEC_length (tree, fna))\n+    {\n+      n = VEC_length (tree, fna);\n+      m = VEC_length (tree, fnb);\n+    }\n+  else\n+    {\n+      n = VEC_length (tree, fnb);\n+      m = VEC_length (tree, fna);\n+    }\n+\n+  ret = VEC_alloc (tree, heap, m);\n+  for (i = 0; i < n; i++)\n+    VEC_quick_push (tree, ret,\n+\t\t    fold_build2 (op, integer_type_node,\n+\t\t\t\t VEC_index (tree, fna, i), \n+\t\t\t\t VEC_index (tree, fnb, i)));\n+\n+  for (; VEC_iterate (tree, fna, i, coef); i++)\n+    VEC_quick_push (tree, ret,\n+\t\t    fold_build2 (op, integer_type_node,\n+\t\t\t\t coef, integer_zero_node));\n+  for (; VEC_iterate (tree, fnb, i, coef); i++)\n+    VEC_quick_push (tree, ret,\n+\t\t    fold_build2 (op, integer_type_node,\n+\t\t\t\t integer_zero_node, coef));\n+\n+  return ret;\n+}\n+\n+/* Returns the sum of affine functions FNA and FNB.  */\n+\n+static affine_fn\n+affine_fn_plus (affine_fn fna, affine_fn fnb)\n+{\n+  return affine_fn_op (PLUS_EXPR, fna, fnb);\n+}\n+\n+/* Returns the difference of affine functions FNA and FNB.  */\n+\n+static affine_fn\n+affine_fn_minus (affine_fn fna, affine_fn fnb)\n+{\n+  return affine_fn_op (MINUS_EXPR, fna, fnb);\n+}\n+\n+/* Frees affine function FN.  */\n+\n+static void\n+affine_fn_free (affine_fn fn)\n+{\n+  VEC_free (tree, heap, fn);\n+}\n+\n /* Determine for each subscript in the data dependence relation DDR\n    the distance.  */\n \n static void\n compute_subscript_distance (struct data_dependence_relation *ddr)\n {\n+  conflict_function *cf_a, *cf_b;\n+  affine_fn fn_a, fn_b, diff;\n+\n   if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n       unsigned int i;\n       \n       for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n  \t{\n- \t  tree conflicts_a, conflicts_b, difference;\n  \t  struct subscript *subscript;\n  \t  \n  \t  subscript = DDR_SUBSCRIPT (ddr, i);\n- \t  conflicts_a = SUB_CONFLICTS_IN_A (subscript);\n- \t  conflicts_b = SUB_CONFLICTS_IN_B (subscript);\n+ \t  cf_a = SUB_CONFLICTS_IN_A (subscript);\n+ \t  cf_b = SUB_CONFLICTS_IN_B (subscript);\n \n-\t  if (TREE_CODE (conflicts_a) == TREE_VEC)\n+\t  fn_a = common_affine_function (cf_a);\n+\t  fn_b = common_affine_function (cf_b);\n+\t  if (!fn_a || !fn_b)\n \t    {\n-\t      if (!all_chrecs_equal_p (conflicts_a))\n-\t\t{\n-\t\t  SUB_DISTANCE (subscript) = chrec_dont_know;\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\tconflicts_a = TREE_VEC_ELT (conflicts_a, 0);\n-\t    }\n-\n-\t  if (TREE_CODE (conflicts_b) == TREE_VEC)\n-\t    {\n-\t      if (!all_chrecs_equal_p (conflicts_b))\n-\t\t{\n-\t\t  SUB_DISTANCE (subscript) = chrec_dont_know;\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\tconflicts_b = TREE_VEC_ELT (conflicts_b, 0);\n+\t      SUB_DISTANCE (subscript) = chrec_dont_know;\n+\t      return;\n \t    }\n-\n-\t  conflicts_b = chrec_convert (integer_type_node, conflicts_b,\n-\t\t\t\t       NULL_TREE);\n-\t  conflicts_a = chrec_convert (integer_type_node, conflicts_a,\n-\t\t\t\t       NULL_TREE);\n-\t  difference = chrec_fold_minus \n-\t    (integer_type_node, conflicts_b, conflicts_a);\n- \t  \n- \t  if (evolution_function_is_constant_p (difference))\n- \t    SUB_DISTANCE (subscript) = difference;\n+\t  diff = affine_fn_minus (fn_a, fn_b);\n  \t  \n+ \t  if (affine_function_constant_p (diff))\n+ \t    SUB_DISTANCE (subscript) = affine_function_base (diff);\n  \t  else\n  \t    SUB_DISTANCE (subscript) = chrec_dont_know;\n+\n+\t  affine_fn_free (diff);\n  \t}\n     }\n }\n \n+/* Returns the conflict function for \"unknown\".  */\n+\n+static conflict_function *\n+conflict_fn_not_known (void)\n+{\n+  conflict_function *fn = XCNEW (conflict_function);\n+  fn->n = NOT_KNOWN;\n+\n+  return fn;\n+}\n+\n+/* Returns the conflict function for \"independent\".  */\n+\n+static conflict_function *\n+conflict_fn_no_dependence (void)\n+{\n+  conflict_function *fn = XCNEW (conflict_function);\n+  fn->n = NO_DEPENDENCE;\n+\n+  return fn;\n+}\n+\n /* Initialize a data dependence relation between data accesses A and\n    B.  NB_LOOPS is the number of loops surrounding the references: the\n    size of the classic distance/direction vectors.  */\n@@ -2141,8 +2285,8 @@ initialize_data_dependence_relation (struct data_reference *a,\n       struct subscript *subscript;\n \t  \n       subscript = XNEW (struct subscript);\n-      SUB_CONFLICTS_IN_A (subscript) = chrec_dont_know;\n-      SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n+      SUB_CONFLICTS_IN_A (subscript) = conflict_fn_not_known ();\n+      SUB_CONFLICTS_IN_B (subscript) = conflict_fn_not_known ();\n       SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n       SUB_DISTANCE (subscript) = chrec_dont_know;\n       VEC_safe_push (subscript_p, heap, DDR_SUBSCRIPTS (res), subscript);\n@@ -2151,6 +2295,37 @@ initialize_data_dependence_relation (struct data_reference *a,\n   return res;\n }\n \n+/* Frees memory used by the conflict function F.  */\n+\n+static void\n+free_conflict_function (conflict_function *f)\n+{\n+  unsigned i;\n+\n+  if (CF_NONTRIVIAL_P (f))\n+    {\n+      for (i = 0; i < f->n; i++)\n+\taffine_fn_free (f->fns[i]);\n+    }\n+  free (f);\n+}\n+\n+/* Frees memory used by SUBSCRIPTS.  */\n+\n+static void\n+free_subscripts (VEC (subscript_p, heap) *subscripts)\n+{\n+  unsigned i;\n+  subscript_p s;\n+\n+  for (i = 0; VEC_iterate (subscript_p, subscripts, i, s); i++)\n+    {\n+      free_conflict_function (s->conflicting_iterations_in_a);\n+      free_conflict_function (s->conflicting_iterations_in_b);\n+    }\n+  VEC_free (subscript_p, heap, subscripts);\n+}\n+\n /* Set DDR_ARE_DEPENDENT to CHREC and finalize the subscript overlap\n    description.  */\n \n@@ -2166,7 +2341,7 @@ finalize_ddr_dependent (struct data_dependence_relation *ddr,\n     }\n \n   DDR_ARE_DEPENDENT (ddr) = chrec;  \n-  VEC_free (subscript_p, heap, DDR_SUBSCRIPTS (ddr));\n+  free_subscripts (DDR_SUBSCRIPTS (ddr));\n }\n \n /* The dependence relation DDR cannot be represented by a distance\n@@ -2233,6 +2408,52 @@ siv_subscript_p (tree chrec_a,\n   return false;\n }\n \n+/* Creates a conflict function with N dimensions.  The affine functions\n+   in each dimension follow.  */\n+\n+static conflict_function *\n+conflict_fn (unsigned n, ...)\n+{\n+  unsigned i;\n+  conflict_function *ret = XCNEW (conflict_function);\n+  va_list ap;\n+\n+  va_start(ap, n);\n+\t\t       \n+  ret->n = n;\n+  for (i = 0; i < n; i++)\n+    ret->fns[i] = va_arg (ap, affine_fn);\n+  va_end(ap);\n+\n+  return ret;\n+}\n+\n+/* Returns constant affine function with value CST.  */\n+\n+static affine_fn\n+affine_fn_cst (tree cst)\n+{\n+  affine_fn fn = VEC_alloc (tree, heap, 1);\n+  VEC_quick_push (tree, fn, cst);\n+  return fn;\n+}\n+\n+/* Returns affine function with single variable, CST + COEF * x_DIM.  */\n+\n+static affine_fn\n+affine_fn_univar (tree cst, unsigned dim, tree coef)\n+{\n+  affine_fn fn = VEC_alloc (tree, heap, dim + 1);\n+  unsigned i;\n+\n+  gcc_assert (dim > 0);\n+  VEC_quick_push (tree, fn, cst);\n+  for (i = 1; i < dim; i++)\n+    VEC_quick_push (tree, fn, integer_zero_node);\n+  VEC_quick_push (tree, fn, coef);\n+  return fn;\n+}\n+\n /* Analyze a ZIV (Zero Index Variable) subscript.  *OVERLAPS_A and\n    *OVERLAPS_B are initialized to the functions that describe the\n    relation between the elements accessed twice by CHREC_A and\n@@ -2243,8 +2464,8 @@ siv_subscript_p (tree chrec_a,\n static void \n analyze_ziv_subscript (tree chrec_a, \n \t\t       tree chrec_b, \n-\t\t       tree *overlaps_a,\n-\t\t       tree *overlaps_b, \n+\t\t       conflict_function **overlaps_a,\n+\t\t       conflict_function **overlaps_b, \n \t\t       tree *last_conflicts)\n {\n   tree difference;\n@@ -2264,16 +2485,16 @@ analyze_ziv_subscript (tree chrec_a,\n \t{\n \t  /* The difference is equal to zero: the accessed index\n \t     overlaps for each iteration in the loop.  */\n-\t  *overlaps_a = integer_zero_node;\n-\t  *overlaps_b = integer_zero_node;\n+\t  *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+\t  *overlaps_b = conflict_fn (1, affine_fn_cst (integer_zero_node));\n \t  *last_conflicts = chrec_dont_know;\n \t  dependence_stats.num_ziv_dependent++;\n \t}\n       else\n \t{\n \t  /* The accesses do not overlap.  */\n-\t  *overlaps_a = chrec_known;\n-\t  *overlaps_b = chrec_known;\n+\t  *overlaps_a = conflict_fn_no_dependence ();\n+\t  *overlaps_b = conflict_fn_no_dependence ();\n \t  *last_conflicts = integer_zero_node;\n \t  dependence_stats.num_ziv_independent++;\n \t}\n@@ -2285,8 +2506,8 @@ analyze_ziv_subscript (tree chrec_a,\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"ziv test failed: difference is non-integer.\\n\");\n \n-      *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n       *last_conflicts = chrec_dont_know;\n       dependence_stats.num_ziv_unimplemented++;\n       break;\n@@ -2330,12 +2551,12 @@ get_number_of_iters_for_loop (int loopnum)\n static void\n analyze_siv_subscript_cst_affine (tree chrec_a, \n \t\t\t\t  tree chrec_b,\n-\t\t\t\t  tree *overlaps_a, \n-\t\t\t\t  tree *overlaps_b, \n+\t\t\t\t  conflict_function **overlaps_a, \n+\t\t\t\t  conflict_function **overlaps_b, \n \t\t\t\t  tree *last_conflicts)\n {\n   bool value0, value1, value2;\n-  tree difference;\n+  tree difference, tmp;\n \n   chrec_a = chrec_convert (integer_type_node, chrec_a, NULL_TREE);\n   chrec_b = chrec_convert (integer_type_node, chrec_b, NULL_TREE);\n@@ -2348,8 +2569,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \tfprintf (dump_file, \"siv test failed: chrec is not positive.\\n\"); \n \n       dependence_stats.num_siv_unimplemented++;\n-      *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n       *last_conflicts = chrec_dont_know;\n       return;\n     }\n@@ -2362,8 +2583,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"siv test failed: chrec not positive.\\n\");\n \n-\t      *overlaps_a = chrec_dont_know;\n-\t      *overlaps_b = chrec_dont_know;      \n+\t      *overlaps_a = conflict_fn_not_known ();\n+\t      *overlaps_b = conflict_fn_not_known ();      \n \t      *last_conflicts = chrec_dont_know;\n \t      dependence_stats.num_siv_unimplemented++;\n \t      return;\n@@ -2382,12 +2603,13 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      tree numiter;\n \t\t      int loopnum = CHREC_VARIABLE (chrec_b);\n \n-\t\t      *overlaps_a = integer_zero_node;\n-\t\t      *overlaps_b = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n-\t\t\t\t\t\t fold_build1 (ABS_EXPR,\n-\t\t\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t\t\t      difference),\n-\t\t\t\t\t\t CHREC_RIGHT (chrec_b));\n+\t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+\t\t      tmp = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n+\t\t\t\t\t fold_build1 (ABS_EXPR,\n+\t\t\t\t\t\t      integer_type_node,\n+\t\t\t\t\t\t      difference),\n+\t\t\t\t\t CHREC_RIGHT (chrec_b));\n+\t\t      *overlaps_b = conflict_fn (1, affine_fn_cst (tmp));\n \t\t      *last_conflicts = integer_one_node;\n \t\t      \n \n@@ -2396,11 +2618,13 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      numiter = get_number_of_iters_for_loop (loopnum);\n \n \t\t      if (numiter != NULL_TREE\n-\t\t\t  && TREE_CODE (*overlaps_b) == INTEGER_CST\n-\t\t\t  && tree_int_cst_lt (numiter, *overlaps_b))\n+\t\t\t  && TREE_CODE (tmp) == INTEGER_CST\n+\t\t\t  && tree_int_cst_lt (numiter, tmp))\n \t\t\t{\n-\t\t\t  *overlaps_a = chrec_known;\n-\t\t\t  *overlaps_b = chrec_known;\n+\t\t\t  free_conflict_function (*overlaps_a);\n+\t\t\t  free_conflict_function (*overlaps_b);\n+\t\t\t  *overlaps_a = conflict_fn_no_dependence ();\n+\t\t\t  *overlaps_b = conflict_fn_no_dependence ();\n \t\t\t  *last_conflicts = integer_zero_node;\n \t\t\t  dependence_stats.num_siv_independent++;\n \t\t\t  return;\n@@ -2413,8 +2637,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     no overlaps.  */\n \t\t  else\n \t\t    {\n-\t\t      *overlaps_a = chrec_known;\n-\t\t      *overlaps_b = chrec_known;      \n+\t\t      *overlaps_a = conflict_fn_no_dependence ();\n+\t\t      *overlaps_b = conflict_fn_no_dependence ();      \n \t\t      *last_conflicts = integer_zero_node;\n \t\t      dependence_stats.num_siv_independent++;\n \t\t      return;\n@@ -2428,8 +2652,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     chrec_b = {10, +, -1}\n \t\t     \n \t\t     In this case, chrec_a will not overlap with chrec_b.  */\n-\t\t  *overlaps_a = chrec_known;\n-\t\t  *overlaps_b = chrec_known;\n+\t\t  *overlaps_a = conflict_fn_no_dependence ();\n+\t\t  *overlaps_b = conflict_fn_no_dependence ();\n \t\t  *last_conflicts = integer_zero_node;\n \t\t  dependence_stats.num_siv_independent++;\n \t\t  return;\n@@ -2443,8 +2667,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"siv test failed: chrec not positive.\\n\");\n \n-\t      *overlaps_a = chrec_dont_know;\n-\t      *overlaps_b = chrec_dont_know;      \n+\t      *overlaps_a = conflict_fn_not_known ();\n+\t      *overlaps_b = conflict_fn_not_known ();      \n \t      *last_conflicts = chrec_dont_know;\n \t      dependence_stats.num_siv_unimplemented++;\n \t      return;\n@@ -2462,22 +2686,25 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      tree numiter;\n \t\t      int loopnum = CHREC_VARIABLE (chrec_b);\n \n-\t\t      *overlaps_a = integer_zero_node;\n-\t\t      *overlaps_b = fold_build2 (EXACT_DIV_EXPR,\n-\t\t\t\t      \t\t integer_type_node, difference, \n-\t\t\t\t\t\t CHREC_RIGHT (chrec_b));\n+\t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+\t\t      tmp = fold_build2 (EXACT_DIV_EXPR,\n+\t\t\t\t\t integer_type_node, difference, \n+\t\t\t\t\t CHREC_RIGHT (chrec_b));\n+\t\t      *overlaps_b = conflict_fn (1, affine_fn_cst (tmp));\n \t\t      *last_conflicts = integer_one_node;\n \n \t\t      /* Perform weak-zero siv test to see if overlap is\n \t\t\t outside the loop bounds.  */\n \t\t      numiter = get_number_of_iters_for_loop (loopnum);\n \n \t\t      if (numiter != NULL_TREE\n-\t\t\t  && TREE_CODE (*overlaps_b) == INTEGER_CST\n-\t\t\t  && tree_int_cst_lt (numiter, *overlaps_b))\n+\t\t\t  && TREE_CODE (tmp) == INTEGER_CST\n+\t\t\t  && tree_int_cst_lt (numiter, tmp))\n \t\t\t{\n-\t\t\t  *overlaps_a = chrec_known;\n-\t\t\t  *overlaps_b = chrec_known;\n+\t\t\t  free_conflict_function (*overlaps_a);\n+\t\t\t  free_conflict_function (*overlaps_b);\n+\t\t\t  *overlaps_a = conflict_fn_no_dependence ();\n+\t\t\t  *overlaps_b = conflict_fn_no_dependence ();\n \t\t\t  *last_conflicts = integer_zero_node;\n \t\t\t  dependence_stats.num_siv_independent++;\n \t\t\t  return;\n@@ -2490,8 +2717,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     are no overlaps.  */\n \t\t  else\n \t\t    {\n-\t\t      *overlaps_a = chrec_known;\n-\t\t      *overlaps_b = chrec_known;      \n+\t\t      *overlaps_a = conflict_fn_no_dependence ();\n+\t\t      *overlaps_b = conflict_fn_no_dependence ();      \n \t\t      *last_conflicts = integer_zero_node;\n \t\t      dependence_stats.num_siv_independent++;\n \t\t      return;\n@@ -2504,8 +2731,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t     chrec_b = {4, +, 1}\n \t\t \n \t\t     In this case, chrec_a will not overlap with chrec_b.  */\n-\t\t  *overlaps_a = chrec_known;\n-\t\t  *overlaps_b = chrec_known;\n+\t\t  *overlaps_a = conflict_fn_no_dependence ();\n+\t\t  *overlaps_b = conflict_fn_no_dependence ();\n \t\t  *last_conflicts = integer_zero_node;\n \t\t  dependence_stats.num_siv_independent++;\n \t\t  return;\n@@ -2541,7 +2768,8 @@ initialize_matrix_A (lambda_matrix A, tree chrec, unsigned index, int mult)\n \n static void\n compute_overlap_steps_for_affine_univar (int niter, int step_a, int step_b, \n-\t\t\t\t\t tree *overlaps_a, tree *overlaps_b, \n+\t\t\t\t\t affine_fn *overlaps_a,\n+\t\t\t\t\t affine_fn *overlaps_b, \n \t\t\t\t\t tree *last_conflicts, int dim)\n {\n   if (((step_a > 0 && step_b > 0)\n@@ -2558,24 +2786,23 @@ compute_overlap_steps_for_affine_univar (int niter, int step_a, int step_b,\n       tau2 = MIN (tau2, FLOOR_DIV (niter, step_overlaps_b));\n       last_conflict = tau2;\n \n-      *overlaps_a = build_polynomial_chrec\n-\t(dim, integer_zero_node,\n-\t build_int_cst (NULL_TREE, step_overlaps_a));\n-      *overlaps_b = build_polynomial_chrec\n-\t(dim, integer_zero_node,\n-\t build_int_cst (NULL_TREE, step_overlaps_b));\n+      *overlaps_a = affine_fn_univar (integer_zero_node, dim, \n+\t\t\t\t      build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t     step_overlaps_a));\n+      *overlaps_b = affine_fn_univar (integer_zero_node, dim, \n+\t\t\t\t      build_int_cst (NULL_TREE, \n+\t\t\t\t\t\t     step_overlaps_b));\n       *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n     }\n \n   else\n     {\n-      *overlaps_a = integer_zero_node;\n-      *overlaps_b = integer_zero_node;\n+      *overlaps_a = affine_fn_cst (integer_zero_node);\n+      *overlaps_b = affine_fn_cst (integer_zero_node);\n       *last_conflicts = integer_zero_node;\n     }\n }\n \n-\n /* Solves the special case of a Diophantine equation where CHREC_A is\n    an affine bivariate function, and CHREC_B is an affine univariate\n    function.  For example, \n@@ -2593,16 +2820,19 @@ compute_overlap_steps_for_affine_univar (int niter, int step_a, int step_b,\n \n static void\n compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b, \n-\t\t\t\t      tree *overlaps_a, tree *overlaps_b, \n+\t\t\t\t      conflict_function **overlaps_a,\n+\t\t\t\t      conflict_function **overlaps_b, \n \t\t\t\t      tree *last_conflicts)\n {\n   bool xz_p, yz_p, xyz_p;\n   int step_x, step_y, step_z;\n   int niter_x, niter_y, niter_z, niter;\n   tree numiter_x, numiter_y, numiter_z;\n-  tree overlaps_a_xz, overlaps_b_xz, last_conflicts_xz;\n-  tree overlaps_a_yz, overlaps_b_yz, last_conflicts_yz;\n-  tree overlaps_a_xyz, overlaps_b_xyz, last_conflicts_xyz;\n+  affine_fn overlaps_a_xz, overlaps_b_xz;\n+  affine_fn overlaps_a_yz, overlaps_b_yz;\n+  affine_fn overlaps_a_xyz, overlaps_b_xyz;\n+  affine_fn ova1, ova2, ovb;\n+  tree last_conflicts_xz, last_conflicts_yz, last_conflicts_xyz;\n \n   step_x = int_cst_value (CHREC_RIGHT (CHREC_LEFT (chrec_a)));\n   step_y = int_cst_value (CHREC_RIGHT (chrec_a));\n@@ -2618,8 +2848,8 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"overlap steps test failed: no iteration counts.\\n\");\n \t   \n-      *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n       *last_conflicts = chrec_dont_know;\n       return;\n     }\n@@ -2651,67 +2881,61 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n \n   if (xz_p || yz_p || xyz_p)\n     {\n-      *overlaps_a = make_tree_vec (2);\n-      TREE_VEC_ELT (*overlaps_a, 0) = integer_zero_node;\n-      TREE_VEC_ELT (*overlaps_a, 1) = integer_zero_node;\n-      *overlaps_b = integer_zero_node;\n+      ova1 = affine_fn_cst (integer_zero_node);\n+      ova2 = affine_fn_cst (integer_zero_node);\n+      ovb = affine_fn_cst (integer_zero_node);\n       if (xz_p)\n \t{\n-\t  tree t0 = chrec_convert (integer_type_node, \n-\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 0), NULL_TREE);\n-\t  tree t1 = chrec_convert (integer_type_node, overlaps_a_xz,\n-\t\t\t\t   NULL_TREE);\n-\t  tree t2 = chrec_convert (integer_type_node, *overlaps_b,\n-\t\t\t\t   NULL_TREE);\n-\t  tree t3 = chrec_convert (integer_type_node, overlaps_b_xz,\n-\t\t\t\t   NULL_TREE);\n-\n-\t  TREE_VEC_ELT (*overlaps_a, 0) = chrec_fold_plus (integer_type_node,\n-\t\t\t\t\t\t\t   t0, t1);\n-\t  *overlaps_b = chrec_fold_plus (integer_type_node, t2, t3);\n+\t  affine_fn t0 = ova1;\n+\t  affine_fn t2 = ovb;\n+\n+\t  ova1 = affine_fn_plus (ova1, overlaps_a_xz);\n+\t  ovb = affine_fn_plus (ovb, overlaps_b_xz);\n+\t  affine_fn_free (t0);\n+\t  affine_fn_free (t2);\n \t  *last_conflicts = last_conflicts_xz;\n \t}\n       if (yz_p)\n \t{\n-\t  tree t0 = chrec_convert (integer_type_node,\n-\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 1), NULL_TREE);\n-\t  tree t1 = chrec_convert (integer_type_node, overlaps_a_yz, NULL_TREE);\n-\t  tree t2 = chrec_convert (integer_type_node, *overlaps_b, NULL_TREE);\n-\t  tree t3 = chrec_convert (integer_type_node, overlaps_b_yz, NULL_TREE);\n-\n-\t  TREE_VEC_ELT (*overlaps_a, 1) = chrec_fold_plus (integer_type_node,\n-\t\t\t\t\t\t\t   t0, t1);\n-\t  *overlaps_b = chrec_fold_plus (integer_type_node, t2, t3);\n+\t  affine_fn t0 = ova2;\n+\t  affine_fn t2 = ovb;\n+\n+\t  ova2 = affine_fn_plus (ova2, overlaps_a_yz);\n+\t  ovb = affine_fn_plus (ovb, overlaps_b_yz);\n+\t  affine_fn_free (t0);\n+\t  affine_fn_free (t2);\n \t  *last_conflicts = last_conflicts_yz;\n \t}\n       if (xyz_p)\n \t{\n-\t  tree t0 = chrec_convert (integer_type_node,\n-\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 0), NULL_TREE);\n-\t  tree t1 = chrec_convert (integer_type_node, overlaps_a_xyz,\n-\t\t\t\t   NULL_TREE);\n-\t  tree t2 = chrec_convert (integer_type_node,\n-\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 1), NULL_TREE);\n-\t  tree t3 = chrec_convert (integer_type_node, overlaps_a_xyz,\n-\t\t\t\t   NULL_TREE);\n-\t  tree t4 = chrec_convert (integer_type_node, *overlaps_b, NULL_TREE);\n-\t  tree t5 = chrec_convert (integer_type_node, overlaps_b_xyz,\n-\t\t\t\t   NULL_TREE);\n-\n-\t  TREE_VEC_ELT (*overlaps_a, 0) = chrec_fold_plus (integer_type_node,\n-\t\t\t\t\t\t\t   t0, t1);\n-\t  TREE_VEC_ELT (*overlaps_a, 1) = chrec_fold_plus (integer_type_node,\n-\t\t\t\t\t\t\t   t2, t3);\n-\t  *overlaps_b = chrec_fold_plus (integer_type_node, t4, t5);\n+\t  affine_fn t0 = ova1;\n+\t  affine_fn t2 = ova2;\n+\t  affine_fn t4 = ovb;\n+\n+\t  ova1 = affine_fn_plus (ova1, overlaps_a_xyz);\n+\t  ova2 = affine_fn_plus (ova2, overlaps_a_xyz);\n+\t  ovb = affine_fn_plus (ovb, overlaps_b_xyz);\n+\t  affine_fn_free (t0);\n+\t  affine_fn_free (t2);\n+\t  affine_fn_free (t4);\n \t  *last_conflicts = last_conflicts_xyz;\n \t}\n+      *overlaps_a = conflict_fn (2, ova1, ova2);\n+      *overlaps_b = conflict_fn (1, ovb);\n     }\n   else\n     {\n-      *overlaps_a = integer_zero_node;\n-      *overlaps_b = integer_zero_node;\n+      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+      *overlaps_b = conflict_fn (1, affine_fn_cst (integer_zero_node));\n       *last_conflicts = integer_zero_node;\n     }\n+\n+  affine_fn_free (overlaps_a_xz);\n+  affine_fn_free (overlaps_b_xz);\n+  affine_fn_free (overlaps_a_yz);\n+  affine_fn_free (overlaps_b_yz);\n+  affine_fn_free (overlaps_a_xyz);\n+  affine_fn_free (overlaps_b_xyz);\n }\n \n /* Determines the overlapping elements due to accesses CHREC_A and\n@@ -2722,8 +2946,8 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n static void\n analyze_subscript_affine_affine (tree chrec_a, \n \t\t\t\t tree chrec_b,\n-\t\t\t\t tree *overlaps_a, \n-\t\t\t\t tree *overlaps_b, \n+\t\t\t\t conflict_function **overlaps_a, \n+\t\t\t\t conflict_function **overlaps_b, \n \t\t\t\t tree *last_conflicts)\n {\n   unsigned nb_vars_a, nb_vars_b, dim;\n@@ -2735,8 +2959,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n     {\n       /* The accessed index overlaps for each iteration in the\n \t loop.  */\n-      *overlaps_a = integer_zero_node;\n-      *overlaps_b = integer_zero_node;\n+      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+      *overlaps_b = conflict_fn (1, affine_fn_cst (integer_zero_node));\n       *last_conflicts = chrec_dont_know;\n       return;\n     }\n@@ -2781,15 +3005,16 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  int step_a, step_b;\n \t  int niter, niter_a, niter_b;\n \t  tree numiter_a, numiter_b;\n+\t  affine_fn ova, ovb;\n \n \t  numiter_a = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n \t  numiter_b = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n \t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n-\t      *overlaps_a = chrec_dont_know;\n-\t      *overlaps_b = chrec_dont_know;\n+\t      *overlaps_a = conflict_fn_not_known ();\n+\t      *overlaps_b = conflict_fn_not_known ();\n \t      *last_conflicts = chrec_dont_know;\n \t      goto end_analyze_subs_aa;\n \t    }\n@@ -2802,8 +3027,10 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  step_b = int_cst_value (CHREC_RIGHT (chrec_b));\n \n \t  compute_overlap_steps_for_affine_univar (niter, step_a, step_b, \n-\t\t\t\t\t\t   overlaps_a, overlaps_b, \n+\t\t\t\t\t\t   &ova, &ovb, \n \t\t\t\t\t\t   last_conflicts, 1);\n+\t  *overlaps_a = conflict_fn (1, ova);\n+\t  *overlaps_b = conflict_fn (1, ovb);\n \t}\n \n       else if (nb_vars_a == 2 && nb_vars_b == 1)\n@@ -2818,8 +3045,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"affine-affine test failed: too many variables.\\n\");\n-\t  *overlaps_a = chrec_dont_know;\n-\t  *overlaps_b = chrec_dont_know;\n+\t  *overlaps_a = conflict_fn_not_known ();\n+\t  *overlaps_b = conflict_fn_not_known ();\n \t  *last_conflicts = chrec_dont_know;\n \t}\n       goto end_analyze_subs_aa;\n@@ -2840,8 +3067,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n      don't know.  */\n   if (gcd_alpha_beta == 0)\n     {\n-      *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n       *last_conflicts = chrec_dont_know;\n       goto end_analyze_subs_aa;\n     }\n@@ -2851,8 +3078,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n     {\n       /* The \"gcd-test\" has determined that there is no integer\n \t solution, i.e. there is no dependence.  */\n-      *overlaps_a = chrec_known;\n-      *overlaps_b = chrec_known;\n+      *overlaps_a = conflict_fn_no_dependence ();\n+      *overlaps_b = conflict_fn_no_dependence ();\n       *last_conflicts = integer_zero_node;\n     }\n \n@@ -2896,8 +3123,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n-\t      *overlaps_a = chrec_dont_know;\n-\t      *overlaps_b = chrec_dont_know;\n+\t      *overlaps_a = conflict_fn_not_known ();\n+\t      *overlaps_b = conflict_fn_not_known ();\n \t      *last_conflicts = chrec_dont_know;\n \t      goto end_analyze_subs_aa;\n \t    }\n@@ -2918,8 +3145,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t FIXME: The case \"i0 > nb_iterations, j0 > nb_iterations\" \n \t\t falls in here, but for the moment we don't look at the \n \t\t upper bound of the iteration domain.  */\n-\t      *overlaps_a = chrec_known;\n-\t      *overlaps_b = chrec_known;\n+\t      *overlaps_a = conflict_fn_no_dependence ();\n+\t      *overlaps_b = conflict_fn_no_dependence ();\n \t      *last_conflicts = integer_zero_node;\n \t    }\n \n@@ -2954,20 +3181,22 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t\t loop, there is no dependence.  */\n \t\t      if (x0 > niter || y0  > niter)\n \t\t\t{\n-\t\t\t  *overlaps_a = chrec_known;\n-\t\t\t  *overlaps_b = chrec_known;\n+\t\t\t  *overlaps_a = conflict_fn_no_dependence ();\n+\t\t\t  *overlaps_b = conflict_fn_no_dependence ();\n \t\t\t  *last_conflicts = integer_zero_node;\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  *overlaps_a = build_polynomial_chrec\n-\t\t\t    (1,\n-\t\t\t     build_int_cst (NULL_TREE, x0),\n-\t\t\t     build_int_cst (NULL_TREE, i1));\n-\t\t\t  *overlaps_b = build_polynomial_chrec\n-\t\t\t    (1,\n-\t\t\t     build_int_cst (NULL_TREE, y0),\n-\t\t\t     build_int_cst (NULL_TREE, j1));\n+\t\t\t  *overlaps_a\n+\t\t\t    = conflict_fn (1,\n+\t\t\t\taffine_fn_univar (build_int_cst (NULL_TREE, x0),\n+\t\t\t\t\t\t  1,\n+\t\t\t\t\t\t  build_int_cst (NULL_TREE, i1)));\n+\t\t\t  *overlaps_b\n+\t\t\t    = conflict_fn (1,\n+\t\t\t\taffine_fn_univar (build_int_cst (NULL_TREE, y0),\n+\t\t\t\t\t\t  1,\n+\t\t\t\t\t\t  build_int_cst (NULL_TREE, j1)));\n \t\t\t  *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n \t\t\t}\n \t\t    }\n@@ -2977,8 +3206,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t\t iteration domain for j is not checked.  */\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\tfprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n-\t\t      *overlaps_a = chrec_dont_know;\n-\t\t      *overlaps_b = chrec_dont_know;\n+\t\t      *overlaps_a = conflict_fn_not_known ();\n+\t\t      *overlaps_b = conflict_fn_not_known ();\n \t\t      *last_conflicts = chrec_dont_know;\n \t\t    }\n \t\t}\n@@ -2989,8 +3218,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t     iteration domain for i is not checked.  */\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n-\t\t  *overlaps_a = chrec_dont_know;\n-\t\t  *overlaps_b = chrec_dont_know;\n+\t\t  *overlaps_a = conflict_fn_not_known ();\n+\t\t  *overlaps_b = conflict_fn_not_known ();\n \t\t  *last_conflicts = chrec_dont_know;\n \t\t}\n \t    }\n@@ -2999,8 +3228,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n-\t  *overlaps_a = chrec_dont_know;\n-\t  *overlaps_b = chrec_dont_know;\n+\t  *overlaps_a = conflict_fn_not_known ();\n+\t  *overlaps_b = conflict_fn_not_known ();\n \t  *last_conflicts = chrec_dont_know;\n \t}\n     }\n@@ -3009,18 +3238,18 @@ analyze_subscript_affine_affine (tree chrec_a,\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"affine-affine test failed: unimplemented.\\n\");\n-      *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n       *last_conflicts = chrec_dont_know;\n     }\n \n end_analyze_subs_aa:  \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"  (overlaps_a = \");\n-      print_generic_expr (dump_file, *overlaps_a, 0);\n+      dump_conflict_function (dump_file, *overlaps_a);\n       fprintf (dump_file, \")\\n  (overlaps_b = \");\n-      print_generic_expr (dump_file, *overlaps_b, 0);\n+      dump_conflict_function (dump_file, *overlaps_b);\n       fprintf (dump_file, \")\\n\");\n       fprintf (dump_file, \")\\n\");\n     }\n@@ -3080,8 +3309,8 @@ can_use_analyze_subscript_affine_affine (tree *chrec_a, tree *chrec_b)\n static void\n analyze_siv_subscript (tree chrec_a, \n \t\t       tree chrec_b,\n-\t\t       tree *overlaps_a, \n-\t\t       tree *overlaps_b, \n+\t\t       conflict_function **overlaps_a, \n+\t\t       conflict_function **overlaps_b, \n \t\t       tree *last_conflicts)\n {\n   dependence_stats.num_siv++;\n@@ -3109,11 +3338,11 @@ analyze_siv_subscript (tree chrec_a,\n \t\t\t\t\t   overlaps_a, overlaps_b, \n \t\t\t\t\t   last_conflicts);\n \n-\t  if (*overlaps_a == chrec_dont_know\n-\t      || *overlaps_b == chrec_dont_know)\n+\t  if (CF_NOT_KNOWN_P (*overlaps_a)\n+\t      || CF_NOT_KNOWN_P (*overlaps_b))\n \t    dependence_stats.num_siv_unimplemented++;\n-\t  else if (*overlaps_a == chrec_known\n-\t\t   || *overlaps_b == chrec_known)\n+\t  else if (CF_NO_DEPENDENCE_P (*overlaps_a)\n+\t\t   || CF_NO_DEPENDENCE_P (*overlaps_b))\n \t    dependence_stats.num_siv_independent++;\n \t  else\n \t    dependence_stats.num_siv_dependent++;\n@@ -3128,11 +3357,11 @@ analyze_siv_subscript (tree chrec_a,\n \t     Compute it properly.  */\n \t  *last_conflicts = chrec_dont_know;\n \n-\t  if (*overlaps_a == chrec_dont_know\n-\t      || *overlaps_b == chrec_dont_know)\n+\t  if (CF_NOT_KNOWN_P (*overlaps_a)\n+\t      || CF_NOT_KNOWN_P (*overlaps_b))\n \t    dependence_stats.num_siv_unimplemented++;\n-\t  else if (*overlaps_a == chrec_known\n-\t\t   || *overlaps_b == chrec_known)\n+\t  else if (CF_NO_DEPENDENCE_P (*overlaps_a)\n+\t\t   || CF_NO_DEPENDENCE_P (*overlaps_b))\n \t    dependence_stats.num_siv_independent++;\n \t  else\n \t    dependence_stats.num_siv_dependent++;\n@@ -3146,8 +3375,8 @@ analyze_siv_subscript (tree chrec_a,\n     siv_subscript_dontknow:;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"siv test failed: unimplemented.\\n\");\n-      *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n       *last_conflicts = chrec_dont_know;\n       dependence_stats.num_siv_unimplemented++;\n     }\n@@ -3198,8 +3427,8 @@ chrec_steps_divide_constant_p (tree chrec,\n static void\n analyze_miv_subscript (tree chrec_a, \n \t\t       tree chrec_b, \n-\t\t       tree *overlaps_a, \n-\t\t       tree *overlaps_b, \n+\t\t       conflict_function **overlaps_a, \n+\t\t       conflict_function **overlaps_b, \n \t\t       tree *last_conflicts)\n {\n   /* FIXME:  This is a MIV subscript, not yet handled.\n@@ -3224,8 +3453,8 @@ analyze_miv_subscript (tree chrec_a,\n     {\n       /* Access functions are the same: all the elements are accessed\n \t in the same order.  */\n-      *overlaps_a = integer_zero_node;\n-      *overlaps_b = integer_zero_node;\n+      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+      *overlaps_b = conflict_fn (1, affine_fn_cst (integer_zero_node));\n       *last_conflicts = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n       dependence_stats.num_miv_dependent++;\n     }\n@@ -3241,8 +3470,8 @@ analyze_miv_subscript (tree chrec_a,\n \t \n \t The difference is 1, and the evolution steps are equal to 2,\n \t consequently there are no overlapping elements.  */\n-      *overlaps_a = chrec_known;\n-      *overlaps_b = chrec_known;\n+      *overlaps_a = conflict_fn_no_dependence ();\n+      *overlaps_b = conflict_fn_no_dependence ();\n       *last_conflicts = integer_zero_node;\n       dependence_stats.num_miv_independent++;\n     }\n@@ -3269,11 +3498,11 @@ analyze_miv_subscript (tree chrec_a,\n       analyze_subscript_affine_affine (chrec_a, chrec_b, \n \t\t\t\t       overlaps_a, overlaps_b, last_conflicts);\n \n-      if (*overlaps_a == chrec_dont_know\n-\t  || *overlaps_b == chrec_dont_know)\n+      if (CF_NOT_KNOWN_P (*overlaps_a)\n+ \t  || CF_NOT_KNOWN_P (*overlaps_b))\n \tdependence_stats.num_miv_unimplemented++;\n-      else if (*overlaps_a == chrec_known\n-\t       || *overlaps_b == chrec_known)\n+      else if (CF_NO_DEPENDENCE_P (*overlaps_a)\n+\t       || CF_NO_DEPENDENCE_P (*overlaps_b))\n \tdependence_stats.num_miv_independent++;\n       else\n \tdependence_stats.num_miv_dependent++;\n@@ -3285,8 +3514,8 @@ analyze_miv_subscript (tree chrec_a,\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"analyze_miv_subscript test failed: unimplemented.\\n\");\n \n-      *overlaps_a = chrec_dont_know;\n-      *overlaps_b = chrec_dont_know;\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n       *last_conflicts = chrec_dont_know;\n       dependence_stats.num_miv_unimplemented++;\n     }\n@@ -3308,8 +3537,8 @@ analyze_miv_subscript (tree chrec_a,\n static void \n analyze_overlapping_iterations (tree chrec_a, \n \t\t\t\ttree chrec_b, \n-\t\t\t\ttree *overlap_iterations_a, \n-\t\t\t\ttree *overlap_iterations_b, \n+\t\t\t\tconflict_function **overlap_iterations_a, \n+\t\t\t\tconflict_function **overlap_iterations_b, \n \t\t\t\ttree *last_conflicts)\n {\n   dependence_stats.num_subscript_tests++;\n@@ -3331,8 +3560,8 @@ analyze_overlapping_iterations (tree chrec_a,\n     {\n       dependence_stats.num_subscript_undetermined++;\n       \n-      *overlap_iterations_a = chrec_dont_know;\n-      *overlap_iterations_b = chrec_dont_know;\n+      *overlap_iterations_a = conflict_fn_not_known ();\n+      *overlap_iterations_b = conflict_fn_not_known ();\n     }\n \n   /* If they are the same chrec, and are affine, they overlap \n@@ -3341,8 +3570,8 @@ analyze_overlapping_iterations (tree chrec_a,\n \t   && evolution_function_is_affine_multivariate_p (chrec_a))\n     {\n       dependence_stats.num_same_subscript_function++;\n-      *overlap_iterations_a = integer_zero_node;\n-      *overlap_iterations_b = integer_zero_node;\n+      *overlap_iterations_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+      *overlap_iterations_b = conflict_fn (1, affine_fn_cst (integer_zero_node));\n       *last_conflicts = chrec_dont_know;\n     }\n \n@@ -3354,8 +3583,8 @@ analyze_overlapping_iterations (tree chrec_a,\n \t       || !evolution_function_is_affine_multivariate_p (chrec_b)))\n     {\n       dependence_stats.num_subscript_undetermined++;\n-      *overlap_iterations_a = chrec_dont_know;\n-      *overlap_iterations_b = chrec_dont_know;\n+      *overlap_iterations_a = conflict_fn_not_known ();\n+      *overlap_iterations_b = conflict_fn_not_known ();\n     }\n \n   else if (ziv_subscript_p (chrec_a, chrec_b))\n@@ -3376,9 +3605,9 @@ analyze_overlapping_iterations (tree chrec_a,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"  (overlap_iterations_a = \");\n-      print_generic_expr (dump_file, *overlap_iterations_a, 0);\n+      dump_conflict_function (dump_file, *overlap_iterations_a);\n       fprintf (dump_file, \")\\n  (overlap_iterations_b = \");\n-      print_generic_expr (dump_file, *overlap_iterations_b, 0);\n+      dump_conflict_function (dump_file, *overlap_iterations_b);\n       fprintf (dump_file, \")\\n\");\n       fprintf (dump_file, \")\\n\");\n     }\n@@ -3808,26 +4037,30 @@ subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n   for (i = 0; VEC_iterate (subscript_p, DDR_SUBSCRIPTS (ddr), i, subscript);\n        i++)\n     {\n-      tree overlaps_a, overlaps_b;\n+      conflict_function *overlaps_a, *overlaps_b;\n \n       analyze_overlapping_iterations (DR_ACCESS_FN (dra, i), \n \t\t\t\t      DR_ACCESS_FN (drb, i),\n \t\t\t\t      &overlaps_a, &overlaps_b, \n \t\t\t\t      &last_conflicts);\n \n-      if (chrec_contains_undetermined (overlaps_a)\n- \t  || chrec_contains_undetermined (overlaps_b))\n+      if (CF_NOT_KNOWN_P (overlaps_a)\n+ \t  || CF_NOT_KNOWN_P (overlaps_b))\n  \t{\n  \t  finalize_ddr_dependent (ddr, chrec_dont_know);\n \t  dependence_stats.num_dependence_undetermined++;\n+\t  free_conflict_function (overlaps_a);\n+\t  free_conflict_function (overlaps_b);\n \t  return false;\n  \t}\n \n-      else if (overlaps_a == chrec_known\n- \t       || overlaps_b == chrec_known)\n+      else if (CF_NO_DEPENDENCE_P (overlaps_a)\n+ \t       || CF_NO_DEPENDENCE_P (overlaps_b))\n  \t{\n  \t  finalize_ddr_dependent (ddr, chrec_known);\n \t  dependence_stats.num_dependence_independent++;\n+\t  free_conflict_function (overlaps_a);\n+\t  free_conflict_function (overlaps_b);\n \t  return false;\n  \t}\n \n@@ -3950,8 +4183,10 @@ compute_self_dependence (struct data_dependence_relation *ddr)\n        i++)\n     {\n       /* The accessed index overlaps for each iteration.  */\n-      SUB_CONFLICTS_IN_A (subscript) = integer_zero_node;\n-      SUB_CONFLICTS_IN_B (subscript) = integer_zero_node;\n+      SUB_CONFLICTS_IN_A (subscript)\n+\t      = conflict_fn (1, affine_fn_cst (integer_zero_node));\n+      SUB_CONFLICTS_IN_B (subscript)\n+\t      = conflict_fn (1, affine_fn_cst (integer_zero_node));\n       SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n     }\n \n@@ -4367,7 +4602,7 @@ free_dependence_relation (struct data_dependence_relation *ddr)\n     return;\n \n   if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE && DDR_SUBSCRIPTS (ddr))\n-    VEC_free (subscript_p, heap, DDR_SUBSCRIPTS (ddr));\n+    free_subscripts (DDR_SUBSCRIPTS (ddr));\n \n   free (ddr);\n }"}, {"sha": "ba4717447677b9691c75373ee9ad0bf8097682a4", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93817c435983e82d29ca34a18c2e0e0781f9a7a/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93817c435983e82d29ca34a18c2e0e0781f9a7a/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=d93817c435983e82d29ca34a18c2e0e0781f9a7a", "patch": "@@ -190,6 +190,29 @@ enum data_dependence_direction {\n   dir_independent\n };\n \n+/* The description of the grid of iterations that overlap.  At most\n+   two loops are considered at the same time just now, hence at most\n+   two functions are needed.  For each of the functions, we store\n+   the vector of coefficients, f[0] + x * f[1] + y * f[2] + ...,\n+   where x, y, ... are variables.  */\n+\n+#define MAX_DIM 2\n+\n+/* Special values of N.  */\n+#define NO_DEPENDENCE 0\n+#define NOT_KNOWN (MAX_DIM + 1)\n+#define CF_NONTRIVIAL_P(CF) ((CF)->n != NO_DEPENDENCE && (CF)->n != NOT_KNOWN)\n+#define CF_NOT_KNOWN_P(CF) ((CF)->n == NOT_KNOWN)\n+#define CF_NO_DEPENDENCE_P(CF) ((CF)->n == NO_DEPENDENCE)\n+\n+typedef VEC (tree, heap) *affine_fn;\n+\n+typedef struct\n+{\n+  unsigned n;\n+  affine_fn fns[MAX_DIM];\n+} conflict_function;\n+\n /* What is a subscript?  Given two array accesses a subscript is the\n    tuple composed of the access functions for a given dimension.\n    Example: Given A[f1][f2][f3] and B[g1][g2][g3], there are three\n@@ -201,8 +224,8 @@ struct subscript\n {\n   /* A description of the iterations for which the elements are\n      accessed twice.  */\n-  tree conflicting_iterations_in_a;\n-  tree conflicting_iterations_in_b;\n+  conflict_function *conflicting_iterations_in_a;\n+  conflict_function *conflicting_iterations_in_b;\n   \n   /* This field stores the information about the iteration domain\n      validity of the dependence relation.  */"}]}