{"sha": "cfc20f00b63a9371784f0de6b70b4598adbca7de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjMjBmMDBiNjNhOTM3MTc4NGYwZGU2YjcwYjQ1OThhZGJjYTdkZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-09-02T09:11:15Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-02T09:11:15Z"}, "message": "i386.md (nonmemory_operand): New mode attribute.\n\n\t* config/i386/i386.md (nonmemory_operand): New mode attribute.\n\t(push memory peephole2): Macroize peepholes using SWI mode iterator.\n\t(move immediate to memory peephole2): Macroize peepholes using\n\tSWI124 mode iterator.\n\t(non-pairable NOT peephole2): Macroize peepholes using SWI124\n\tmode iterator.\n\t(simple lea add peephole2): Macroize peepholes using SWI48\n\tmode iterator.\n\t(simple lea mult peephole2): Ditto.\n\t(imul by 3,5,9 to lea peephole2): Ditto.\n\t(mov $-1, reg peephole2): Macroize peepholes using SWI248\n\tmode iterator.\n\t(imul $32bit_imm,mem,reg peephole2): Ditto.\n\t(imul $8/16bit_imm,regmem,reg peephole2): Ditto.\n\nFrom-SVN: r163766", "tree": {"sha": "30b192a192ecfd276b8efa01cdfcbd5e63709182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30b192a192ecfd276b8efa01cdfcbd5e63709182"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfc20f00b63a9371784f0de6b70b4598adbca7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc20f00b63a9371784f0de6b70b4598adbca7de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfc20f00b63a9371784f0de6b70b4598adbca7de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc20f00b63a9371784f0de6b70b4598adbca7de/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "999a9cc54f876bdf4b53387d62517e58826d2bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999a9cc54f876bdf4b53387d62517e58826d2bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/999a9cc54f876bdf4b53387d62517e58826d2bec"}], "stats": {"total": 435, "additions": 118, "deletions": 317}, "files": [{"sha": "41ceb7b79b1854828d0b74c8997a7fa6185bc74d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc20f00b63a9371784f0de6b70b4598adbca7de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc20f00b63a9371784f0de6b70b4598adbca7de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfc20f00b63a9371784f0de6b70b4598adbca7de", "patch": "@@ -1,3 +1,20 @@\n+2010-09-02  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (nonmemory_operand): New mode attribute.\n+\t(push memory peephole2): Macroize peepholes using SWI mode iterator.\n+\t(move immediate to memory peephole2): Macroize peepholes using\n+\tSWI124 mode iterator.\n+\t(non-pairable NOT peephole2): Macroize peepholes using SWI124\n+\tmode iterator.\n+\t(simple lea add peephole2): Macroize peepholes using SWI48\n+\tmode iterator.\n+\t(simple lea mult peephole2): Ditto.\n+\t(imul by 3,5,9 to lea peephole2): Ditto.\n+\t(mov $-1, reg peephole2): Macroize peepholes using SWI248\n+\tmode iterator.\n+\t(imul $32bit_imm,mem,reg peephole2): Ditto.\n+\t(imul $8/16bit_imm,regmem,reg peephole2): Ditto.\n+\n 2010-09-02  Ian Bolton  <ian.bolton@arm.com>\n \n \t* tree-ssa-loop-prefetch.c: Fix comment at head of file."}, {"sha": "5e073bf617640f5746da46af50ec5ec61c68ecb5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 101, "deletions": 317, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc20f00b63a9371784f0de6b70b4598adbca7de/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc20f00b63a9371784f0de6b70b4598adbca7de/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cfc20f00b63a9371784f0de6b70b4598adbca7de", "patch": "@@ -858,6 +858,13 @@\n \t (SI \"immediate_operand\")\n \t (DI \"x86_64_immediate_operand\")])\n \n+;; Nonmemory operand predicate for integer modes.\n+(define_mode_attr nonmemory_operand\n+\t[(QI \"nonmemory_operand\")\n+\t (HI \"nonmemory_operand\")\n+\t (SI \"nonmemory_operand\")\n+\t (DI \"x86_64_nonmemory_operand\")])\n+\n ;; Operand predicate for shifts.\n (define_mode_attr shift_operand\n \t[(QI \"nonimmediate_operand\")\n@@ -1659,8 +1666,7 @@\n   \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n    && !x86_64_immediate_operand (operands[1], DImode)\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n+   (set (match_dup 0) (match_dup 2))])\n \n ;; We need to define this as both peepholer and splitter for case\n ;; peephole2 pass is not run.\n@@ -2027,8 +2033,7 @@\n   \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n    && !x86_64_immediate_operand (operands[1], DImode)\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n+   (set (match_dup 0) (match_dup 2))])\n \n ;; We need to define this as both peepholer and splitter for case\n ;; peephole2 pass is not run.\n@@ -4598,8 +4603,7 @@\n   \"TARGET_SHORTEN_X87_SSE\n    && !(TARGET_AVOID_VECTOR_DECODE && optimize_insn_for_speed_p ())\n    && peep2_reg_dead_p (2, operands[0])\"\n-  [(set (match_dup 2) (fix:SSEMODEI24 (match_dup 1)))]\n-  \"\")\n+  [(set (match_dup 2) (fix:SSEMODEI24 (match_dup 1)))])\n \n ;; Avoid vector decoded forms of the instruction.\n (define_peephole2\n@@ -4608,17 +4612,15 @@\n \t(fix:SSEMODEI24 (match_operand:DF 1 \"memory_operand\" \"\")))]\n   \"TARGET_AVOID_VECTOR_DECODE && optimize_insn_for_speed_p ()\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (fix:SSEMODEI24 (match_dup 2)))]\n-  \"\")\n+   (set (match_dup 0) (fix:SSEMODEI24 (match_dup 2)))])\n \n (define_peephole2\n   [(match_scratch:SF 2 \"x\")\n    (set (match_operand:SSEMODEI24 0 \"register_operand\" \"\")\n \t(fix:SSEMODEI24 (match_operand:SF 1 \"memory_operand\" \"\")))]\n   \"TARGET_AVOID_VECTOR_DECODE && optimize_insn_for_speed_p ()\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (fix:SSEMODEI24 (match_dup 2)))]\n-  \"\")\n+   (set (match_dup 0) (fix:SSEMODEI24 (match_dup 2)))])\n \n (define_insn_and_split \"fix_trunc<mode>_fisttp_i387_1\"\n   [(set (match_operand:X87MODEI 0 \"nonimmediate_operand\" \"\")\n@@ -15829,8 +15831,7 @@\n      (use (match_dup 3))\n      (clobber (match_dup 0))\n      (clobber (match_dup 1))\n-     (clobber (match_dup 2))])]\n-  \"\")\n+     (clobber (match_dup 2))])])\n \n ;; ...and this one handles cmpstrn*_1.\n (define_peephole2\n@@ -15865,10 +15866,7 @@\n      (use (reg:CC FLAGS_REG))\n      (clobber (match_dup 0))\n      (clobber (match_dup 1))\n-     (clobber (match_dup 2))])]\n-  \"\")\n-\n-\n+     (clobber (match_dup 2))])])\n \f\n ;; Conditional move instructions.\n \n@@ -16184,11 +16182,13 @@\n   ;; The % modifier is not operational anymore in peephole2's, so we have to\n   ;; swap the operands manually in the case of addition and multiplication.\n   \"if (COMMUTATIVE_ARITH_P (operands[2]))\n-     operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[2]), GET_MODE (operands[2]),\n-\t\t\t\t operands[0], operands[1]);\n+     operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[2]),\n+\t\t\t\t   GET_MODE (operands[2]),\n+\t\t\t\t   operands[0], operands[1]);\n    else\n-     operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[2]), GET_MODE (operands[2]),\n-\t\t\t\t operands[1], operands[0]);\")\n+     operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[2]),\n+\t\t\t\t   GET_MODE (operands[2]),\n+\t\t\t\t   operands[1], operands[0]);\")\n \n ;; Conditional addition patterns\n (define_expand \"add<mode>cc\"\n@@ -16198,7 +16198,6 @@\n    (match_operand:SWI 3 \"const_int_operand\" \"\")]\n   \"\"\n   \"if (ix86_expand_int_addcc (operands)) DONE; else FAIL;\")\n-\n \f\n ;; Misc patterns (?)\n \n@@ -16529,26 +16528,15 @@\n \n ;; Don't push memory operands\n (define_peephole2\n-  [(set (match_operand:SI 0 \"push_operand\" \"\")\n-\t(match_operand:SI 1 \"memory_operand\" \"\"))\n-   (match_scratch:SI 2 \"r\")]\n+  [(set (match_operand:SWI 0 \"push_operand\" \"\")\n+\t(match_operand:SWI 1 \"memory_operand\" \"\"))\n+   (match_scratch:SWI 2 \"<r>\")]\n   \"optimize_insn_for_speed_p () && !TARGET_PUSH_MEMORY\n    && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n+   (set (match_dup 0) (match_dup 2))])\n \n-(define_peephole2\n-  [(set (match_operand:DI 0 \"push_operand\" \"\")\n-\t(match_operand:DI 1 \"memory_operand\" \"\"))\n-   (match_scratch:DI 2 \"r\")]\n-  \"optimize_insn_for_speed_p () && !TARGET_PUSH_MEMORY\n-   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n-\n-;; We need to handle SFmode only, because DFmode and XFmode is split to\n+;; We need to handle SFmode only, because DFmode and XFmode are split to\n ;; SImode pushes.\n (define_peephole2\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n@@ -16557,51 +16545,16 @@\n   \"optimize_insn_for_speed_p () && !TARGET_PUSH_MEMORY\n    && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (match_operand:HI 0 \"push_operand\" \"\")\n-\t(match_operand:HI 1 \"memory_operand\" \"\"))\n-   (match_scratch:HI 2 \"r\")]\n-  \"optimize_insn_for_speed_p () && !TARGET_PUSH_MEMORY\n-   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (match_operand:QI 0 \"push_operand\" \"\")\n-\t(match_operand:QI 1 \"memory_operand\" \"\"))\n-   (match_scratch:QI 2 \"q\")]\n-  \"optimize_insn_for_speed_p () && !TARGET_PUSH_MEMORY\n-   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n+   (set (match_dup 0) (match_dup 2))])\n \n ;; Don't move an immediate directly to memory when the instruction\n ;; gets too big.\n (define_peephole2\n-  [(match_scratch:SI 1 \"r\")\n-   (set (match_operand:SI 0 \"memory_operand\" \"\")\n+  [(match_scratch:SWI124 1 \"<r>\")\n+   (set (match_operand:SWI124 0 \"memory_operand\" \"\")\n         (const_int 0))]\n   \"optimize_insn_for_speed_p ()\n-   && ! TARGET_USE_MOV0\n-   && TARGET_SPLIT_LONG_MOVES\n-   && get_attr_length (insn) >= ix86_cur_cost ()->large_insn\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 1) (const_int 0))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (set (match_dup 0) (match_dup 1))]\n-  \"\")\n-\n-(define_peephole2\n-  [(match_scratch:HI 1 \"r\")\n-   (set (match_operand:HI 0 \"memory_operand\" \"\")\n-        (const_int 0))]\n-  \"optimize_insn_for_speed_p ()\n-   && ! TARGET_USE_MOV0\n+   && !TARGET_USE_MOV0\n    && TARGET_SPLIT_LONG_MOVES\n    && get_attr_length (insn) >= ix86_cur_cost ()->large_insn\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n@@ -16611,51 +16564,14 @@\n   \"operands[2] = gen_lowpart (SImode, operands[1]);\")\n \n (define_peephole2\n-  [(match_scratch:QI 1 \"q\")\n-   (set (match_operand:QI 0 \"memory_operand\" \"\")\n-        (const_int 0))]\n-  \"optimize_insn_for_speed_p ()\n-   && ! TARGET_USE_MOV0\n-   && TARGET_SPLIT_LONG_MOVES\n-   && get_attr_length (insn) >= ix86_cur_cost ()->large_insn\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 2) (const_int 0))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (set (match_dup 0) (match_dup 1))]\n-  \"operands[2] = gen_lowpart (SImode, operands[1]);\")\n-\n-(define_peephole2\n-  [(match_scratch:SI 2 \"r\")\n-   (set (match_operand:SI 0 \"memory_operand\" \"\")\n-        (match_operand:SI 1 \"immediate_operand\" \"\"))]\n+  [(match_scratch:SWI124 2 \"<r>\")\n+   (set (match_operand:SWI124 0 \"memory_operand\" \"\")\n+        (match_operand:SWI124 1 \"immediate_operand\" \"\"))]\n   \"optimize_insn_for_speed_p ()\n    && TARGET_SPLIT_LONG_MOVES\n    && get_attr_length (insn) >= ix86_cur_cost ()->large_insn\"\n   [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n-\n-(define_peephole2\n-  [(match_scratch:HI 2 \"r\")\n-   (set (match_operand:HI 0 \"memory_operand\" \"\")\n-        (match_operand:HI 1 \"immediate_operand\" \"\"))]\n-  \"optimize_insn_for_speed_p ()\n-   && TARGET_SPLIT_LONG_MOVES\n-   && get_attr_length (insn) >= ix86_cur_cost ()->large_insn\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n-\n-(define_peephole2\n-  [(match_scratch:QI 2 \"q\")\n-   (set (match_operand:QI 0 \"memory_operand\" \"\")\n-        (match_operand:QI 1 \"immediate_operand\" \"\"))]\n-  \"optimize_insn_for_speed_p ()\n-   && TARGET_SPLIT_LONG_MOVES\n-   && get_attr_length (insn) >= ix86_cur_cost ()->large_insn\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n+   (set (match_dup 0) (match_dup 2))])\n \n ;; Don't compare memory with zero, load and use a test instead.\n (define_peephole2\n@@ -16666,8 +16582,7 @@\n    (match_scratch:SI 3 \"r\")]\n   \"optimize_insn_for_speed_p () && ix86_match_ccmode (insn, CCNOmode)\"\n   [(set (match_dup 3) (match_dup 2))\n-   (set (match_dup 0) (match_op_dup 1 [(match_dup 3) (const_int 0)]))]\n-  \"\")\n+   (set (match_dup 0) (match_op_dup 1 [(match_dup 3) (const_int 0)]))])\n \n ;; NOT is not pairable on Pentium, while XOR is, but one byte longer.\n ;; Don't split NOTs with a displacement operand, because resulting XOR\n@@ -16681,46 +16596,18 @@\n ;; lifetime information then.\n \n (define_peephole2\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n+  [(set (match_operand:SWI124 0 \"nonimmediate_operand\" \"\")\n+\t(not:SWI124 (match_operand:SWI124 1 \"nonimmediate_operand\" \"\")))]\n   \"optimize_insn_for_speed_p ()\n    && ((TARGET_NOT_UNPAIRABLE\n-        && (!MEM_P (operands[0])\n-            || !memory_displacement_operand (operands[0], SImode)))\n-       || (TARGET_NOT_VECTORMODE && long_memory_operand (operands[0], SImode)))\n+\t&& (!MEM_P (operands[0])\n+\t    || !memory_displacement_operand (operands[0], <MODE>mode)))\n+       || (TARGET_NOT_VECTORMODE\n+\t   && long_memory_operand (operands[0], <MODE>mode)))\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (xor:SI (match_dup 1) (const_int -1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n-  \"optimize_insn_for_speed_p ()\n-   && ((TARGET_NOT_UNPAIRABLE\n-        && (!MEM_P (operands[0])\n-            || !memory_displacement_operand (operands[0], HImode)))\n-       || (TARGET_NOT_VECTORMODE && long_memory_operand (operands[0], HImode)))\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (xor:HI (match_dup 1) (const_int -1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"optimize_insn_for_speed_p ()\n-   && ((TARGET_NOT_UNPAIRABLE\n-        && (!MEM_P (operands[0])\n-            || !memory_displacement_operand (operands[0], QImode)))\n-       || (TARGET_NOT_VECTORMODE && long_memory_operand (operands[0], QImode)))\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (xor:QI (match_dup 1) (const_int -1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n+\t\t   (xor:SWI124 (match_dup 1) (const_int -1)))\n+\t      (clobber (reg:CC FLAGS_REG))])])\n \n ;; Non pairable \"test imm, reg\" instructions can be translated to\n ;; \"and imm, reg\" if reg dies.  The \"and\" form is also shorter (one\n@@ -16744,8 +16631,7 @@\n \t   (match_op_dup 1 [(and:SI (match_dup 2) (match_dup 3))\n \t\t            (const_int 0)]))\n       (set (match_dup 2)\n-\t   (and:SI (match_dup 2) (match_dup 3)))])]\n-  \"\")\n+\t   (and:SI (match_dup 2) (match_dup 3)))])])\n \n ;; We don't need to handle HImode case, because it will be promoted to SImode\n ;; on ! TARGET_PARTIAL_REG_STALL\n@@ -16765,8 +16651,7 @@\n \t   (match_op_dup 1 [(and:QI (match_dup 2) (match_dup 3))\n \t\t            (const_int 0)]))\n       (set (match_dup 2)\n-\t   (and:QI (match_dup 2) (match_dup 3)))])]\n-  \"\")\n+\t   (and:QI (match_dup 2) (match_dup 3)))])])\n \n (define_peephole2\n   [(set (match_operand 0 \"flags_reg_operand\" \"\")\n@@ -16799,8 +16684,7 @@\n \t\t       (match_dup 2)\n \t\t       (const_int 8)\n \t\t       (const_int 8))\n-\t\t     (match_dup 3)))])]\n-  \"\")\n+\t\t     (match_dup 3)))])])\n \n ;; Don't do logical operations with memory inputs.\n (define_peephole2\n@@ -16814,8 +16698,7 @@\n   [(set (match_dup 2) (match_dup 1))\n    (parallel [(set (match_dup 0)\n                    (match_op_dup 3 [(match_dup 0) (match_dup 2)]))\n-              (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n+              (clobber (reg:CC FLAGS_REG))])])\n \n (define_peephole2\n   [(match_scratch:SI 2 \"r\")\n@@ -16828,8 +16711,7 @@\n   [(set (match_dup 2) (match_dup 1))\n    (parallel [(set (match_dup 0)\n                    (match_op_dup 3 [(match_dup 2) (match_dup 0)]))\n-              (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n+              (clobber (reg:CC FLAGS_REG))])])\n \n ;; Prefer Load+RegOp to Mov+MemOp.  Watch out for cases when the memory address\n ;; refers to the destination of the load!\n@@ -16863,8 +16745,7 @@\n        || (SSE_REG_P (operands[0]) && SSE_REG_P (operands[1])))\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0)\n-        (match_op_dup 3 [(match_dup 0) (match_dup 1)]))]\n-  \"\")\n+        (match_op_dup 3 [(match_dup 0) (match_dup 1)]))])\n \n ; Don't do logical operations with memory outputs\n ;\n@@ -16886,8 +16767,7 @@\n    (parallel [(set (match_dup 2)\n                    (match_op_dup 3 [(match_dup 2) (match_dup 1)]))\n               (clobber (reg:CC FLAGS_REG))])\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n+   (set (match_dup 0) (match_dup 2))])\n \n (define_peephole2\n   [(match_scratch:SI 2 \"r\")\n@@ -16903,8 +16783,7 @@\n    (parallel [(set (match_dup 2)\n                    (match_op_dup 3 [(match_dup 1) (match_dup 2)]))\n               (clobber (reg:CC FLAGS_REG))])\n-   (set (match_dup 0) (match_dup 2))]\n-  \"\")\n+   (set (match_dup 0) (match_dup 2))])\n \n ;; Attempt to always use XOR for zeroing registers.\n (define_peephole2\n@@ -16916,9 +16795,7 @@\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int 0))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  operands[0] = gen_lowpart (word_mode, operands[0]);\n-})\n+  \"operands[0] = gen_lowpart (word_mode, operands[0]);\")\n \n (define_peephole2\n   [(set (strict_low_part (match_operand 0 \"register_operand\" \"\"))\n@@ -16930,74 +16807,57 @@\n   [(parallel [(set (strict_low_part (match_dup 0)) (const_int 0))\n \t      (clobber (reg:CC FLAGS_REG))])])\n \n-;; For HI and SI modes, or $-1,reg is smaller than mov $-1,reg.\n+;; For HI, SI and DI modes, or $-1,reg is smaller than mov $-1,reg.\n (define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n+  [(set (match_operand:SWI248 0 \"register_operand\" \"\")\n \t(const_int -1))]\n-  \"(GET_MODE (operands[0]) == HImode\n-    || GET_MODE (operands[0]) == SImode\n-    || (GET_MODE (operands[0]) == DImode && TARGET_64BIT))\n-   && (optimize_insn_for_size_p () || TARGET_MOVE_M1_VIA_OR)\n+  \"(optimize_insn_for_size_p () || TARGET_MOVE_M1_VIA_OR)\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int -1))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[0] = gen_lowpart (GET_MODE (operands[0]) == DImode ? DImode : SImode,\n-\t\t\t      operands[0]);\")\n+{\n+  if (GET_MODE_SIZE (<MODE>mode) < GET_MODE_SIZE (SImode))\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+;; Attempt to convert simple lea to add/shift.\n+;; These can be created by move expanders.\n \n-;; Attempt to convert simple leas to adds. These can be created by\n-;; move expanders.\n (define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-  \t(plus:SI (match_dup 0)\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"\")\n+  \t(plus:SWI48 (match_dup 0)\n+\t\t    (match_operand:SWI48 1 \"<nonmemory_operand>\" \"\")))]\n   \"peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n+  [(parallel [(set (match_dup 0) (plus:SWI48 (match_dup 0) (match_dup 1)))\n+\t      (clobber (reg:CC FLAGS_REG))])])\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n   \t(subreg:SI (plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t\t    (match_operand:DI 2 \"nonmemory_operand\" \"\")) 0))]\n-  \"peep2_regno_dead_p (0, FLAGS_REG) && REGNO (operands[0]) == REGNO (operands[1])\"\n+  \"TARGET_64BIT\n+   && peep2_regno_dead_p (0, FLAGS_REG)\n+   && REGNO (operands[0]) == REGNO (operands[1])\"\n   [(parallel [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"operands[2] = gen_lowpart (SImode, operands[2]);\")\n \n (define_peephole2\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-  \t(plus:DI (match_dup 0)\n-\t\t (match_operand:DI 1 \"x86_64_general_operand\" \"\")))]\n-  \"peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0) (plus:DI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-  \t(mult:SI (match_dup 0)\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))]\n-  \"exact_log2 (INTVAL (operands[1])) >= 0\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")\n-\n-(define_peephole2\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-  \t(mult:DI (match_dup 0)\n-\t\t (match_operand:DI 1 \"const_int_operand\" \"\")))]\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"\")\n+  \t(mult:SWI48 (match_dup 0)\n+\t\t    (match_operand:SWI48 1 \"const_int_operand\" \"\")))]\n   \"exact_log2 (INTVAL (operands[1])) >= 0\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0) (ashift:DI (match_dup 0) (match_dup 2)))\n+  [(parallel [(set (match_dup 0) (ashift:SWI48 (match_dup 0) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n   \t(subreg:SI (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t   (match_operand:DI 2 \"const_int_operand\" \"\")) 0))]\n-  \"exact_log2 (INTVAL (operands[2])) >= 0\n+  \"TARGET_64BIT\n+   && exact_log2 (INTVAL (operands[2])) >= 0\n    && REGNO (operands[0]) == REGNO (operands[1])\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n@@ -17171,93 +17031,47 @@\n ;; Convert imul by three, five and nine into lea\n (define_peephole2\n   [(parallel\n-    [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t  (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"\")))\n+    [(set (match_operand:SWI48 0 \"register_operand\" \"\")\n+\t  (mult:SWI48 (match_operand:SWI48 1 \"register_operand\" \"\")\n+\t\t      (match_operand:SWI48 2 \"const_int_operand\" \"\")))\n      (clobber (reg:CC FLAGS_REG))])]\n   \"INTVAL (operands[2]) == 3\n    || INTVAL (operands[2]) == 5\n    || INTVAL (operands[2]) == 9\"\n   [(set (match_dup 0)\n-        (plus:SI (mult:SI (match_dup 1) (match_dup 2))\n-                 (match_dup 1)))]\n+\t(plus:SWI48 (mult:SWI48 (match_dup 1) (match_dup 2))\n+\t\t    (match_dup 1)))]\n   \"operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\")\n \n (define_peephole2\n   [(parallel\n-    [(set (match_operand:SI 0 \"register_operand\" \"\")\n-          (mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-                   (match_operand:SI 2 \"const_int_operand\" \"\")))\n+    [(set (match_operand:SWI48 0 \"register_operand\" \"\")\n+\t  (mult:SWI48 (match_operand:SWI48 1 \"nonimmediate_operand\" \"\")\n+\t\t      (match_operand:SWI48 2 \"const_int_operand\" \"\")))\n      (clobber (reg:CC FLAGS_REG))])]\n   \"optimize_insn_for_speed_p ()\n    && (INTVAL (operands[2]) == 3\n        || INTVAL (operands[2]) == 5\n        || INTVAL (operands[2]) == 9)\"\n   [(set (match_dup 0) (match_dup 1))\n    (set (match_dup 0)\n-        (plus:SI (mult:SI (match_dup 0) (match_dup 2))\n-                 (match_dup 0)))]\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\")\n-\n-(define_peephole2\n-  [(parallel\n-    [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t  (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:DI 2 \"const_int_operand\" \"\")))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_64BIT\n-   && (INTVAL (operands[2]) == 3\n-       || INTVAL (operands[2]) == 5\n-       || INTVAL (operands[2]) == 9)\"\n-  [(set (match_dup 0)\n-        (plus:DI (mult:DI (match_dup 1) (match_dup 2))\n-                 (match_dup 1)))]\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\")\n-\n-(define_peephole2\n-  [(parallel\n-    [(set (match_operand:DI 0 \"register_operand\" \"\")\n-          (mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n-                   (match_operand:DI 2 \"const_int_operand\" \"\")))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_64BIT\n-   && optimize_insn_for_speed_p ()\n-   && (INTVAL (operands[2]) == 3\n-       || INTVAL (operands[2]) == 5\n-       || INTVAL (operands[2]) == 9)\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0)\n-        (plus:DI (mult:DI (match_dup 0) (match_dup 2))\n-                 (match_dup 0)))]\n+\t(plus:SWI48 (mult:SWI48 (match_dup 0) (match_dup 2))\n+\t\t    (match_dup 0)))]\n   \"operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\")\n \n-;; Imul $32bit_imm, mem, reg is vector decoded, while\n+;; imul $32bit_imm, mem, reg is vector decoded, while\n ;; imul $32bit_imm, reg, reg is direct decoded.\n (define_peephole2\n-  [(match_scratch:DI 3 \"r\")\n-   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (mult:DI (match_operand:DI 1 \"memory_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"immediate_operand\" \"\")))\n+  [(match_scratch:SWI48 3 \"r\")\n+   (parallel [(set (match_operand:SWI48 0 \"register_operand\" \"\")\n+\t\t   (mult:SWI48 (match_operand:SWI48 1 \"memory_operand\" \"\")\n+\t\t\t       (match_operand:SWI48 2 \"immediate_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"TARGET_SLOW_IMUL_IMM32_MEM && optimize_insn_for_speed_p ()\n    && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n-   (parallel [(set (match_dup 0) (mult:DI (match_dup 3) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(match_scratch:SI 3 \"r\")\n-   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (mult:SI (match_operand:SI 1 \"memory_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"immediate_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_SLOW_IMUL_IMM32_MEM && optimize_insn_for_speed_p ()\n-   && !satisfies_constraint_K (operands[2])\"\n-  [(set (match_dup 3) (match_dup 1))\n-   (parallel [(set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n+   (parallel [(set (match_dup 0) (mult:SWI48 (match_dup 3) (match_dup 2)))\n+\t      (clobber (reg:CC FLAGS_REG))])])\n \n (define_peephole2\n   [(match_scratch:SI 3 \"r\")\n@@ -17266,59 +17080,29 @@\n \t\t     (mult:SI (match_operand:SI 1 \"memory_operand\" \"\")\n \t\t\t      (match_operand:SI 2 \"immediate_operand\" \"\"))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_SLOW_IMUL_IMM32_MEM && optimize_insn_for_speed_p ()\n+  \"TARGET_64BIT\n+   && TARGET_SLOW_IMUL_IMM32_MEM && optimize_insn_for_speed_p ()\n    && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (match_dup 0)\n \t\t   (zero_extend:DI (mult:SI (match_dup 3) (match_dup 2))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n+\t      (clobber (reg:CC FLAGS_REG))])])\n \n ;; imul $8/16bit_imm, regmem, reg is vector decoded.\n ;; Convert it into imul reg, reg\n ;; It would be better to force assembler to encode instruction using long\n ;; immediate, but there is apparently no way to do so.\n (define_peephole2\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (match_scratch:DI 3 \"r\")]\n-  \"TARGET_SLOW_IMUL_IMM8 && optimize_insn_for_speed_p ()\n-   && satisfies_constraint_K (operands[2])\"\n-  [(set (match_dup 3) (match_dup 2))\n-   (parallel [(set (match_dup 0) (mult:DI (match_dup 0) (match_dup 3)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  if (!rtx_equal_p (operands[0], operands[1]))\n-    emit_move_insn (operands[0], operands[1]);\n-})\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\")))\n+  [(parallel [(set (match_operand:SWI248 0 \"register_operand\" \"\")\n+\t\t   (mult:SWI248\n+\t\t    (match_operand:SWI248 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:SWI248 2 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n-   (match_scratch:SI 3 \"r\")]\n+   (match_scratch:SWI248 3 \"r\")]\n   \"TARGET_SLOW_IMUL_IMM8 && optimize_insn_for_speed_p ()\n    && satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 2))\n-   (parallel [(set (match_dup 0) (mult:SI (match_dup 0) (match_dup 3)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  if (!rtx_equal_p (operands[0], operands[1]))\n-    emit_move_insn (operands[0], operands[1]);\n-})\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t   (mult:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:HI 2 \"immediate_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (match_scratch:HI 3 \"r\")]\n-  \"TARGET_SLOW_IMUL_IMM8 && optimize_insn_for_speed_p ()\"\n-  [(set (match_dup 3) (match_dup 2))\n-   (parallel [(set (match_dup 0) (mult:HI (match_dup 0) (match_dup 3)))\n+   (parallel [(set (match_dup 0) (mult:SWI248 (match_dup 0) (match_dup 3)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n {\n   if (!rtx_equal_p (operands[0], operands[1]))"}]}