{"sha": "12753674ec3e75275eca8b704c36d6dc3762ade6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI3NTM2NzRlYzNlNzUyNzVlY2E4YjcwNGMzNmQ2ZGMzNzYyYWRlNg==", "commit": {"author": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2007-06-11T15:40:55Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2007-06-11T15:40:55Z"}, "message": "really remove signed(_or_unsigned)?_type langhooks\n\nFrom-SVN: r125621", "tree": {"sha": "09e966f66888827cc56e0e29aacd33c5d45e7819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09e966f66888827cc56e0e29aacd33c5d45e7819"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12753674ec3e75275eca8b704c36d6dc3762ade6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12753674ec3e75275eca8b704c36d6dc3762ade6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12753674ec3e75275eca8b704c36d6dc3762ade6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12753674ec3e75275eca8b704c36d6dc3762ade6/comments", "author": null, "committer": null, "parents": [{"sha": "73fd4ad6cd12dbb4ba0fbcf4e7fa11d22fd05ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73fd4ad6cd12dbb4ba0fbcf4e7fa11d22fd05ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73fd4ad6cd12dbb4ba0fbcf4e7fa11d22fd05ea3"}], "stats": {"total": 197, "additions": 52, "deletions": 145}, "files": [{"sha": "ece8553c149317b4e82bd58b1efcfcde3c0a6f3a", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -157,8 +157,6 @@ static tree gnat_type_max_size\t\t(tree);\n #define LANG_HOOKS_TYPE_FOR_MODE\tgnat_type_for_mode\n #undef  LANG_HOOKS_TYPE_FOR_SIZE\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgnat_type_for_size\n-#undef  LANG_HOOKS_SIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_TYPE\t\tgnat_signed_type\n #undef  LANG_HOOKS_ATTRIBUTE_TABLE\n #define LANG_HOOKS_ATTRIBUTE_TABLE\tgnat_internal_attribute_table\n #undef  LANG_HOOKS_BUILTIN_FUNCTION"}, {"sha": "082ecd12661bed61aa4352cebab8f99ad82ac034", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -1092,7 +1092,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t      }\n \n \t    gnu_compute_type\n-\t      = get_signed_or_unsigned_type (0,\n+\t      = signed_or_unsigned_type_for (0,\n \t\t\t\t\t     get_base_type (gnu_result_type));\n \n \t    gnu_result"}, {"sha": "ccbc479fdee7413b48d4ba477766792d3f79b7c4", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -1342,7 +1342,7 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n           else\n             conversion_warning (type, expr);\n         }\n-      else if (!int_fits_type_p (expr, unsigned_type_for (type))) \n+      else if (!int_fits_type_p (expr, c_common_unsigned_type (type))) \n \twarning (OPT_Woverflow,\n \t\t \"overflow in implicit constant conversion\");\n       /* No warning for converting 0x80000000 to int.  */\n@@ -2037,37 +2037,17 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n   return 0;\n }\n \n+tree\n+c_common_unsigned_type (tree type)\n+{\n+  return c_common_signed_or_unsigned_type (1, type);\n+}\n+\n /* Return a signed type the same as TYPE in other respects.  */\n \n tree\n c_common_signed_type (tree type)\n {\n-  tree type1 = TYPE_MAIN_VARIANT (type);\n-  if (type1 == unsigned_char_type_node || type1 == char_type_node)\n-    return signed_char_type_node;\n-  if (type1 == unsigned_type_node)\n-    return integer_type_node;\n-  if (type1 == short_unsigned_type_node)\n-    return short_integer_type_node;\n-  if (type1 == long_unsigned_type_node)\n-    return long_integer_type_node;\n-  if (type1 == long_long_unsigned_type_node)\n-    return long_long_integer_type_node;\n-  if (type1 == widest_unsigned_literal_type_node)\n-    return widest_integer_literal_type_node;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  if (type1 == unsigned_intTI_type_node)\n-    return intTI_type_node;\n-#endif\n-  if (type1 == unsigned_intDI_type_node)\n-    return intDI_type_node;\n-  if (type1 == unsigned_intSI_type_node)\n-    return intSI_type_node;\n-  if (type1 == unsigned_intHI_type_node)\n-    return intHI_type_node;\n-  if (type1 == unsigned_intQI_type_node)\n-    return intQI_type_node;\n-\n   return c_common_signed_or_unsigned_type (0, type);\n }\n \n@@ -2514,8 +2494,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t      default:\n \t\tbreak;\n \t      }\n-\t  /* unsigned_type_for doesn't support C bit fields */\n-\t  type = c_common_signed_or_unsigned_type (1, type);\n+\t  type = c_common_unsigned_type (type);\n \t}\n \n       if (TREE_CODE (primop0) != INTEGER_CST)\n@@ -3685,7 +3664,7 @@ c_common_nodes_and_builtins (void)\n   else\n     {\n       signed_wchar_type_node = c_common_signed_type (wchar_type_node);\n-      unsigned_wchar_type_node = unsigned_type_for (wchar_type_node);\n+      unsigned_wchar_type_node = c_common_unsigned_type (wchar_type_node);\n     }\n \n   /* This is for wide string constants.  */\n@@ -3703,7 +3682,7 @@ c_common_nodes_and_builtins (void)\n   default_function_type = build_function_type (integer_type_node, NULL_TREE);\n   ptrdiff_type_node\n     = TREE_TYPE (identifier_global_value (get_identifier (PTRDIFF_TYPE)));\n-  unsigned_ptrdiff_type_node = unsigned_type_for (ptrdiff_type_node);\n+  unsigned_ptrdiff_type_node = c_common_unsigned_type (ptrdiff_type_node);\n \n   lang_hooks.decls.pushdecl\n     (build_decl (TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n@@ -6918,8 +6897,8 @@ same_scalar_type_ignoring_signedness (tree t1, tree t2)\n \n   /* Equality works here because c_common_signed_type uses\n      TYPE_MAIN_VARIANT.  */\n-  return lang_hooks.types.signed_type (t1)\n-    == lang_hooks.types.signed_type (t2);\n+  return c_common_signed_type (t1)\n+    == c_common_signed_type (t2);\n }\n \n /* Check for missing format attributes on function pointers.  LTYPE is"}, {"sha": "1a9a3e5790083a5492f06ca7242ae8eeb47f64ee", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -675,6 +675,7 @@ extern int c_common_handle_option (size_t code, const char *arg, int value);\n extern bool c_common_missing_argument (const char *opt, size_t code);\n extern tree c_common_type_for_mode (enum machine_mode, int);\n extern tree c_common_type_for_size (unsigned int, int);\n+extern tree c_common_unsigned_type (tree);\n extern tree c_common_signed_type (tree);\n extern tree c_common_signed_or_unsigned_type (int, tree);\n extern tree c_build_bitfield_integer_type (unsigned HOST_WIDE_INT, int);"}, {"sha": "bde95aa025219b764cb59474ac8c80e379097475", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -4078,7 +4078,7 @@ grokdeclarator (const struct c_declarator *declarator,\n      \"signed\".  */\n   if (bitfield && !flag_signed_bitfields && !declspecs->explicit_signed_p\n       && TREE_CODE (type) == INTEGER_TYPE)\n-    type = unsigned_type_for (type);\n+    type = c_common_unsigned_type (type);\n \n   /* Figure out the type qualifiers for the declaration.  There are\n      two ways a declaration can become qualified.  One is something"}, {"sha": "a64e30984eec631f73c703b4a68645deb50ea965", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -2249,7 +2249,7 @@ check_format_types (format_wanted_type *types, const char *format_start,\n \t  && TREE_CODE (cur_type) == INTEGER_TYPE\n \t  && (!pedantic || i == 0 || (i == 1 && char_type_flag))\n \t  && (TYPE_UNSIGNED (wanted_type)\n-\t      ? wanted_type == unsigned_type_for (cur_type)\n+\t      ? wanted_type == c_common_unsigned_type (cur_type)\n \t      : wanted_type == c_common_signed_type (cur_type)))\n \tcontinue;\n       /* Likewise, \"signed char\", \"unsigned char\" and \"char\" are"}, {"sha": "e6a82efd4aef8a172d8acc06d4066ef7dfdb0fb8", "filename": "gcc/c-objc-common.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -102,10 +102,6 @@ extern void c_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_TYPE_FOR_MODE c_common_type_for_mode\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #define LANG_HOOKS_TYPE_FOR_SIZE c_common_type_for_size\n-#undef LANG_HOOKS_SIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_TYPE c_common_signed_type\n-#undef LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE c_common_signed_or_unsigned_type\n #undef LANG_HOOKS_INCOMPLETE_TYPE_ERROR\n #define LANG_HOOKS_INCOMPLETE_TYPE_ERROR c_incomplete_type_error\n #undef LANG_HOOKS_TYPE_PROMOTES_TO"}, {"sha": "aff4a63823450fa8006f6f37033fb7e64a815e90", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -4098,8 +4098,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n \t  || (target_cmp = comp_target_types (type, rhstype))\n \t  || is_opaque_pointer\n-\t  || (unsigned_type_for (mvl)\n-\t      == unsigned_type_for (mvr)))\n+\t  || (c_common_unsigned_type (mvl)\n+\t      == c_common_unsigned_type (mvr)))\n \t{\n \t  if (pedantic\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)"}, {"sha": "0c7c1086a9b8fe1b1a81a9733ca7dd4456af16e1", "filename": "gcc/convert.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -658,7 +658,7 @@ convert_to_integer (tree type, tree expr)\n \t\t\t\t|| ex_form == MINUS_EXPR)))\n \t\t      typex = unsigned_type_for (typex);\n \t\t    else\n-\t\t      typex = lang_hooks.types.signed_type (typex);\n+\t\t      typex = signed_type_for (typex);\n \t\t    return convert (type,\n \t\t\t\t    fold_build2 (ex_form, typex,\n \t\t\t\t\t\t convert (typex, arg0),\n@@ -680,7 +680,7 @@ convert_to_integer (tree type, tree expr)\n \t    if (TYPE_UNSIGNED (TREE_TYPE (expr)))\n \t      typex = unsigned_type_for (type);\n \t    else\n-\t      typex = lang_hooks.types.signed_type (type);\n+\t      typex = signed_type_for (type);\n \t    return convert (type,\n \t\t\t    fold_build1 (ex_form, typex,\n \t\t\t\t\t convert (typex,"}, {"sha": "ee320119929f9461762ba8693508c4f4b6064e1a", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -134,10 +134,6 @@ extern tree objcp_tsubst_copy_and_build (tree, tree, tsubst_flags_t,\n #define LANG_HOOKS_TYPE_FOR_MODE c_common_type_for_mode\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #define LANG_HOOKS_TYPE_FOR_SIZE c_common_type_for_size\n-#undef LANG_HOOKS_SIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_TYPE c_common_signed_type\n-#undef LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE c_common_signed_or_unsigned_type\n #undef LANG_HOOKS_INCOMPLETE_TYPE_ERROR\n #define LANG_HOOKS_INCOMPLETE_TYPE_ERROR cxx_incomplete_type_error\n #undef LANG_HOOKS_TYPE_PROMOTES_TO"}, {"sha": "b3709b02e5a683c63fd337e2e03f9a49e7f8cc89", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -5050,14 +5050,14 @@ make_tree (tree type, rtx x)\n \t\t\t\t    \t make_tree (type, XEXP (x, 1))));\n \n     case ASHIFTRT:\n-      t = lang_hooks.types.signed_type (type);\n+      t = signed_type_for (type);\n       return fold_convert (type, build2 (RSHIFT_EXPR, t,\n \t\t\t\t\t make_tree (t, XEXP (x, 0)),\n \t\t\t\t    \t make_tree (type, XEXP (x, 1))));\n \n     case DIV:\n       if (TREE_CODE (type) != REAL_TYPE)\n-\tt = lang_hooks.types.signed_type (type);\n+\tt = signed_type_for (type);\n       else\n \tt = type;\n "}, {"sha": "8ce9b49e847034a194fccf23c39663a52c3d6930", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -4435,7 +4435,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t      /* Some types, e.g. Fortran's logical*4, won't have a signed\n \t\t version, so use the mode instead.  */\n \t      tree ntype\n-\t\t= (get_signed_or_unsigned_type\n+\t\t= (signed_or_unsigned_type_for\n \t\t   (SUBREG_PROMOTED_UNSIGNED_P (target), TREE_TYPE (exp)));\n \t      if (ntype == NULL)\n \t\tntype = lang_hooks.types.type_for_mode"}, {"sha": "d2dd8cb2fbc0e62f972441ee84b53e6cded3b229", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -1410,7 +1410,7 @@ fold_negate_expr (tree t)\n \t\t == TREE_INT_CST_LOW (op1))\n \t    {\n \t      tree ntype = TYPE_UNSIGNED (type)\n-\t\t\t   ? lang_hooks.types.signed_type (type)\n+\t\t\t   ? signed_type_for (type)\n \t\t\t   : unsigned_type_for (type);\n \t      tree temp = fold_convert (ntype, TREE_OPERAND (t, 0));\n \t      temp = fold_build2 (RSHIFT_EXPR, ntype, temp, op1);\n@@ -2028,7 +2028,7 @@ size_diffop (tree arg0, tree arg1)\n   else if (type == bitsizetype)\n     ctype = sbitsizetype;\n   else\n-    ctype = lang_hooks.types.signed_type (type);\n+    ctype = signed_type_for (type);\n \n   /* If either operand is not a constant, do the conversions to the signed\n      type and subtract.  The hardware will do the right thing with any\n@@ -3045,7 +3045,7 @@ operand_equal_for_comparison_p (tree arg0, tree arg1, tree other)\n \n       /* Make sure shorter operand is extended the right way\n \t to match the longer operand.  */\n-      primarg1 = fold_convert (get_signed_or_unsigned_type\n+      primarg1 = fold_convert (signed_or_unsigned_type_for\n \t\t\t       (unsignedp1, TREE_TYPE (primarg1)), primarg1);\n \n       if (operand_equal_p (arg0, fold_convert (type, primarg1), 0))\n@@ -3828,7 +3828,7 @@ all_ones_mask_p (tree mask, int size)\n   unsigned int precision = TYPE_PRECISION (type);\n   tree tmask;\n \n-  tmask = build_int_cst_type (lang_hooks.types.signed_type (type), -1);\n+  tmask = build_int_cst_type (signed_type_for (type), -1);\n \n   return\n     tree_int_cst_equal (mask,\n@@ -4382,7 +4382,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t{\n \t  if (TYPE_UNSIGNED (etype))\n \t    {\n-\t      etype = lang_hooks.types.signed_type (etype);\n+\t      etype = signed_type_for (etype);\n \t      exp = fold_convert (etype, exp);\n \t    }\n \t  return fold_build2 (GT_EXPR, type, exp,\n@@ -4756,7 +4756,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n       case GE_EXPR:\n       case GT_EXPR:\n \tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t  arg1 = fold_convert (lang_hooks.types.signed_type\n+\t  arg1 = fold_convert (signed_type_for\n \t\t\t       (TREE_TYPE (arg1)), arg1);\n \ttem = fold_build1 (ABS_EXPR, TREE_TYPE (arg1), arg1);\n \treturn pedantic_non_lvalue (fold_convert (type, tem));\n@@ -4767,7 +4767,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n       case LE_EXPR:\n       case LT_EXPR:\n \tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t  arg1 = fold_convert (lang_hooks.types.signed_type\n+\t  arg1 = fold_convert (signed_type_for\n \t\t\t       (TREE_TYPE (arg1)), arg1);\n \ttem = fold_build1 (ABS_EXPR, TREE_TYPE (arg1), arg1);\n \treturn negate_expr (fold_convert (type, tem));\n@@ -5075,7 +5075,7 @@ unextend (tree c, int p, int unsignedp, tree mask)\n      zero or one, and the conversion to a signed type can never overflow.\n      We could get an overflow if this conversion is done anywhere else.  */\n   if (TYPE_UNSIGNED (type))\n-    temp = fold_convert (lang_hooks.types.signed_type (type), temp);\n+    temp = fold_convert (signed_type_for (type), temp);\n \n   temp = const_binop (LSHIFT_EXPR, temp, size_int (modesize - 1), 0);\n   temp = const_binop (RSHIFT_EXPR, temp, size_int (modesize - p - 1), 0);\n@@ -5747,7 +5747,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n          must avoid building ABS_EXPR itself as unsigned.  */\n       if (TYPE_UNSIGNED (ctype) && !TYPE_UNSIGNED (type))\n         {\n-          tree cstype = (*lang_hooks.types.signed_type) (ctype);\n+          tree cstype = (*signed_type_for) (ctype);\n           if ((t1 = extract_muldiv (op0, c, code, cstype, strict_overflow_p))\n \t      != 0)\n             {\n@@ -6558,7 +6558,7 @@ fold_single_bit_test_into_sign_test (enum tree_code code, tree arg0, tree arg1,\n \t  && TYPE_PRECISION (TREE_TYPE (arg00))\n \t     == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg00))))\n \t{\n-\t  tree stype = lang_hooks.types.signed_type (TREE_TYPE (arg00));\n+\t  tree stype = signed_type_for (TREE_TYPE (arg00));\n \t  return fold_build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n \t\t\t      result_type, fold_convert (stype, arg00),\n \t\t\t      build_int_cst (stype, 0));\n@@ -11414,7 +11414,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    {\n \t      if (TYPE_UNSIGNED (itype))\n \t\t{\n-\t\t  itype = lang_hooks.types.signed_type (itype);\n+\t\t  itype = signed_type_for (itype);\n \t\t  arg00 = fold_convert (itype, arg00);\n \t\t}\n \t      return fold_build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n@@ -11967,7 +11967,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\tif (code == LE_EXPR || code == GT_EXPR)\n \t\t  {\n \t\t    tree st;\n-\t\t    st = lang_hooks.types.signed_type (TREE_TYPE (arg1));\n+\t\t    st = signed_type_for (TREE_TYPE (arg1));\n \t\t    return fold_build2 (code == LE_EXPR ? GE_EXPR : LT_EXPR,\n \t\t\t\t\ttype, fold_convert (st, arg0),\n \t\t\t\t\tbuild_int_cst (st, 0));\n@@ -12357,7 +12357,7 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n \t      if ((TREE_INT_CST_HIGH (arg1) & mask_hi) == mask_hi\n \t\t  && (TREE_INT_CST_LOW (arg1) & mask_lo) == mask_lo)\n \t\t{\n-\t\t  tem_type = lang_hooks.types.signed_type (TREE_TYPE (tem));\n+\t\t  tem_type = signed_type_for (TREE_TYPE (tem));\n \t\t  tem = fold_convert (tem_type, tem);\n \t\t}\n \t      else if ((TREE_INT_CST_HIGH (arg1) & mask_hi) == 0"}, {"sha": "558ba0c680b63ba84a43f5c954e45b4f0399974e", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -113,7 +113,6 @@ static HOST_WIDE_INT gfc_get_alias_set (tree);\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n-#undef LANG_HOOKS_SIGNED_TYPE\n #undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n #undef LANG_HOOKS_CLEAR_BINDING_STACK\n #undef LANG_HOOKS_GET_ALIAS_SET\n@@ -137,7 +136,6 @@ static HOST_WIDE_INT gfc_get_alias_set (tree);\n #define LANG_HOOKS_MARK_ADDRESSABLE        gfc_mark_addressable\n #define LANG_HOOKS_TYPE_FOR_MODE           gfc_type_for_mode\n #define LANG_HOOKS_TYPE_FOR_SIZE           gfc_type_for_size\n-#define LANG_HOOKS_SIGNED_TYPE             gfc_signed_type\n #define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION gfc_expand_function\n #define LANG_HOOKS_CLEAR_BINDING_STACK     gfc_clear_binding_stack\n #define LANG_HOOKS_GET_ALIAS_SET\t   gfc_get_alias_set"}, {"sha": "897b4ca18d89a0629da537a3c1ab36602c9e722d", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -1848,12 +1848,4 @@ gfc_type_for_mode (enum machine_mode mode, int unsignedp)\n   return NULL_TREE;\n }\n \n-/* Return a signed type the same as TYPE in other respects.  */\n-\n-tree\n-gfc_signed_type (tree type)\n-{\n-  return get_signed_or_unsigned_type (0, type);\n-}\n-\n #include \"gt-fortran-trans-types.h\""}, {"sha": "8e4cf86a34e050a19ef7be1d4ed8db76cc77d339", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -82,7 +82,6 @@ tree gfc_get_function_type (gfc_symbol *);\n \n tree gfc_type_for_size (unsigned, int);\n tree gfc_type_for_mode (enum machine_mode, int);\n-tree gfc_signed_type (tree);\n \n tree gfc_get_element_type (tree);\n tree gfc_get_array_type_bounds (tree, int, tree *, tree *, int);"}, {"sha": "10418d3186a2965d0b5ddd55cdb044942bc8b30c", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -1099,7 +1099,6 @@ extern void java_parse_file (int);\n extern bool java_mark_addressable (tree);\n extern tree java_type_for_mode (enum machine_mode, int);\n extern tree java_type_for_size (unsigned int, int);\n-extern tree java_signed_type (tree);\n extern tree java_truthvalue_conversion (tree);\n extern void add_assume_compiled (const char *, int);\n extern void add_enable_assert (const char *, int);"}, {"sha": "7fd6fcdb98ff4d61ca654f44e9c0b6924af5d997", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -182,8 +182,6 @@ struct language_function GTY(())\n #define LANG_HOOKS_TYPE_FOR_MODE java_type_for_mode\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #define LANG_HOOKS_TYPE_FOR_SIZE java_type_for_size\n-#undef LANG_HOOKS_SIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_TYPE java_signed_type\n \n #undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN java_dump_tree"}, {"sha": "4177fd1dd36621de5870dc772c9fb830a1c7bad6", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -195,14 +195,6 @@ java_type_for_size (unsigned bits, int unsignedp)\n   return 0;\n }\n \n-/* Return a signed type the same as TYPE in other respects.  */\n-\n-tree\n-java_signed_type (tree type)\n-{\n-  return get_signed_or_unsigned_type (0, type);\n-}\n-\n /* Mark EXP saying that we need to be able to take the\n    address of it; it should not be allocated in a register.\n    Value is true if successful.  */"}, {"sha": "28b35bb89b17dd39a6d2d6486de6d1c3bf2bdfa4", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -120,7 +120,6 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n #define LANG_HOOKS_TREE_SIZE\t\tlhd_tree_size\n #define LANG_HOOKS_TYPES_COMPATIBLE_P\tlhd_types_compatible_p\n #define LANG_HOOKS_BUILTIN_FUNCTION\tlhd_builtin_function\n-#define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\tlhd_signed_or_unsigned_type\n #define LANG_HOOKS_EXPR_TO_DECL\t\tlhd_expr_to_decl\n #define LANG_HOOKS_TO_TARGET_CHARSET\tlhd_to_target_charset\n #define LANG_HOOKS_INIT_TS\t\tlhd_do_nothing\n@@ -207,8 +206,6 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_MAKE_TYPE, \\\n   LANG_HOOKS_TYPE_FOR_MODE, \\\n   LANG_HOOKS_TYPE_FOR_SIZE, \\\n-  LANG_HOOKS_SIGNED_TYPE, \\\n-  LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE, \\\n   LANG_HOOKS_GENERIC_TYPE_P, \\\n   LANG_HOOKS_TYPE_PROMOTES_TO, \\\n   LANG_HOOKS_REGISTER_BUILTIN_TYPE, \\"}, {"sha": "5d4d63c70664ef67183538c8586b11d0c38fb7ed", "filename": "gcc/langhooks.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -570,24 +570,3 @@ lhd_builtin_function (tree decl)\n   lang_hooks.decls.pushdecl (decl);\n   return decl;\n }\n-\n-/* If TYPE is an integral type, return an equivalent type which is\n-    unsigned iff UNSIGNEDP is true.  If TYPE is not an integral type,\n-    return TYPE itself.  */\n-\n-tree\n-get_signed_or_unsigned_type (int unsignedp, tree type)\n-{\n-  return lang_hooks.types.signed_or_unsigned_type(unsignedp, type);\n-}\n-\n-/* Default implementation of the signed_or_unsigned_type language hook */\n-\n-tree\n-lhd_signed_or_unsigned_type (int unsignedp, tree type)\n-{\n-  if (!INTEGRAL_TYPE_P (type) || TYPE_UNSIGNED (type) == unsignedp)\n-    return type;\n-\n-  return lang_hooks.types.type_for_size (TYPE_PRECISION (type), unsignedp);\n-}"}, {"sha": "e48c0bca81c54280d998f6bfbc69d980d1c1bffb", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -103,14 +103,6 @@ struct lang_hooks_for_types\n      integer type with at least that precision.  */\n   tree (*type_for_size) (unsigned, int);\n \n-  /* Given an integer type T, return a type like T but signed.\n-     If T is signed, the value is T.  */\n-  tree (*signed_type) (tree);\n-\n-  /* Return a type the same as TYPE except unsigned or signed\n-     according to UNSIGNEDP.  */\n-  tree (*signed_or_unsigned_type) (int, tree);\n-\n   /* True if the type is an instantiation of a generic type,\n      e.g. C++ template implicit specializations.  */\n   bool (*generic_p) (tree);\n@@ -445,6 +437,5 @@ extern tree add_builtin_function (const char *name, tree type,\n \t\t\t\t  int function_code, enum built_in_class cl,\n \t\t\t\t  const char *library_name,\n \t\t\t\t  tree attrs);\n-extern tree lhd_signed_or_unsigned_type (int unsignedp, tree type);\n \n #endif /* GCC_LANG_HOOKS_H */"}, {"sha": "2560c8f72a47001314648a5f1a68380ce9e071b3", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -7730,33 +7730,37 @@ int_cst_value (tree x)\n   return val;\n }\n \n+/* If TYPE is an integral type, return an equivalent type which is\n+    unsigned iff UNSIGNEDP is true.  If TYPE is not an integral type,\n+    return TYPE itself.  */\n \n-/* Return an unsigned type the same as TYPE in other respects.  */\n-\n-static tree\n-get_unsigned_type (tree type)\n+tree\n+signed_or_unsigned_type_for (int unsignedp, tree type)\n {\n-  return get_signed_or_unsigned_type (1, type);\n+  tree t = type;\n+  if (POINTER_TYPE_P (type))\n+    t = size_type_node;\n+\n+  if (!INTEGRAL_TYPE_P (t) || TYPE_UNSIGNED (t) == unsignedp)\n+    return t;\n+  \n+  return lang_hooks.types.type_for_size (TYPE_PRECISION (t), unsignedp);\n }\n \n /* Returns unsigned variant of TYPE.  */\n \n tree\n unsigned_type_for (tree type)\n {\n-  if (POINTER_TYPE_P (type))\n-    return get_unsigned_type (size_type_node);\n-  return get_unsigned_type (type);\n+  return signed_or_unsigned_type_for (1, type);\n }\n \n /* Returns signed variant of TYPE.  */\n \n tree\n signed_type_for (tree type)\n {\n-  if (POINTER_TYPE_P (type))\n-    return lang_hooks.types.signed_type (size_type_node);\n-  return lang_hooks.types.signed_type (type);\n+  return signed_or_unsigned_type_for (0, type);\n }\n \n /* Returns the largest value obtainable by casting something in INNER type to"}, {"sha": "1023b86424e9544481a2b92c54bb02867dd3e789", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -3776,6 +3776,7 @@ extern tree build_call_array (tree, tree, int, tree*);\n \n extern tree make_signed_type (int);\n extern tree make_unsigned_type (int);\n+extern tree signed_or_unsigned_type_for (int, tree);\n extern tree signed_type_for (tree);\n extern tree unsigned_type_for (tree);\n extern void initialize_sizetypes (bool);\n@@ -3820,8 +3821,6 @@ extern bool tree_expr_nonnegative_warnv_p (tree, bool *);\n extern bool may_negate_without_overflow_p (tree);\n extern tree get_inner_array_type (tree);\n \n-extern tree get_signed_or_unsigned_type (int unsignedp, tree type);\n-\n /* From expmed.c.  Since rtl.h is included after tree.h, we can't\n    put the prototype here.  Rtl.h does declare the prototype if\n    tree.h had been included.  */"}, {"sha": "477c1967e9a2f5b9ece54d201a454f08c11b9272", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12753674ec3e75275eca8b704c36d6dc3762ade6/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=12753674ec3e75275eca8b704c36d6dc3762ade6", "patch": "@@ -127,7 +127,6 @@ struct language_function GTY(())\n static bool tree_mark_addressable (tree exp);\n static tree tree_lang_type_for_size (unsigned precision, int unsignedp);\n static tree tree_lang_type_for_mode (enum machine_mode mode, int unsignedp);\n-static tree tree_lang_signed_type (tree type_node);\n \n /* Functions to keep track of the current scope.  */\n static void pushlevel (int ignore);\n@@ -150,8 +149,6 @@ static void treelang_expand_function (tree fndecl);\n \n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE tree_mark_addressable\n-#undef LANG_HOOKS_SIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_TYPE tree_lang_signed_type\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #define LANG_HOOKS_TYPE_FOR_MODE tree_lang_type_for_mode\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n@@ -862,14 +859,6 @@ tree_lang_type_for_mode (enum machine_mode mode, int unsignedp)\n     return NULL_TREE;\n }\n \n-/* Return the signed version of a TYPE_NODE, a scalar type.  */\n-\n-static tree\n-tree_lang_signed_type (tree type_node)\n-{\n-  return tree_lang_type_for_size (TYPE_PRECISION (type_node), 0);\n-}\n-\n \f\n /* These functions and variables deal with binding contours.  We only\n    need these functions for the list of PARM_DECLs, but we leave the"}]}