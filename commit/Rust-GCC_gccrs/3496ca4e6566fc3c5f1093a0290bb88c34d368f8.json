{"sha": "3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "node_id": "C_kwDOANBUbNoAKDM0OTZjYTRlNjU2NmZjM2M1ZjEwOTNhMDI5MGJiODhjMzRkMzY4Zjg", "commit": {"author": {"name": "zhongjuzhe", "email": "juzhe.zhong@rivai.ai", "date": "2022-08-17T07:19:50Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-08-18T04:10:57Z"}, "message": "RISC-V: Add runtime invariant support\n\nRISC-V 'V' Extension support scalable vector like ARM SVE.\nTo support RVV, we need to introduce runtime invariant.\n\n- For zve32*, the runtime invariant uses 32-bit chunk.\n- For zve64*, the runtime invariant uses 64-bit chunk.\n\n[1] https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#sec-vector-extensions\n\nThis patch is preparing patch for RVV support.\nBecause we didn't introduce vector machine_mode yet, it safe to just change HOST_WIDE_INT into poly_int.\nAlso it safe to use \"to_constant()\" function for scalar operation.\nThis patch has been tested by full dejagnu regression.\n\ngcc/ChangeLog:\n\n\t* config/riscv/predicates.md: Adjust runtime invariant.\n\t* config/riscv/riscv-modes.def (MAX_BITSIZE_MODE_ANY_MODE): New.\n\t(NUM_POLY_INT_COEFFS): New.\n\t* config/riscv/riscv-protos.h (riscv_initial_elimination_offset):Adjust\n\truntime invariant.\n\t* config/riscv/riscv-sr.cc (riscv_remove_unneeded_save_restore_calls):\n\tAdjust runtime invariant.\n\t* config/riscv/riscv.cc (struct riscv_frame_info): Adjust runtime\n\tinvariant.\n\t(enum riscv_microarchitecture_type): Ditto.\n\t(riscv_valid_offset_p): Ditto.\n\t(riscv_valid_lo_sum_p): Ditto.\n\t(riscv_address_insns): Ditto.\n\t(riscv_load_store_insns): Ditto.\n\t(riscv_legitimize_move): Ditto.\n\t(riscv_binary_cost): Ditto.\n\t(riscv_rtx_costs): Ditto.\n\t(riscv_output_move): Ditto.\n\t(riscv_extend_comparands): Ditto.\n\t(riscv_flatten_aggregate_field): Ditto.\n\t(riscv_get_arg_info): Ditto.\n\t(riscv_pass_by_reference): Ditto.\n\t(riscv_elf_select_rtx_section): Ditto.\n\t(riscv_stack_align): Ditto.\n\t(riscv_compute_frame_info): Ditto.\n\t(riscv_initial_elimination_offset): Ditto.\n\t(riscv_set_return_address): Ditto.\n\t(riscv_for_each_saved_reg): Ditto.\n\t(riscv_first_stack_step): Ditto.\n\t(riscv_expand_prologue): Ditto.\n\t(riscv_expand_epilogue): Ditto.\n\t(riscv_can_use_return_insn): Ditto.\n\t(riscv_secondary_memory_needed): Ditto.\n\t(riscv_hard_regno_nregs): Ditto.\n\t(riscv_convert_vector_bits): New.\n\t(riscv_option_override): Adjust runtime invariant.\n\t(riscv_promote_function_mode): Ditto.\n\t* config/riscv/riscv.h (POLY_SMALL_OPERAND_P): New.\n\t(BITS_PER_RISCV_VECTOR): New.\n\t(BYTES_PER_RISCV_VECTOR): New.\n\t* config/riscv/riscv.md: Adjust runtime invariant.", "tree": {"sha": "456abf757c66b11f847b057f81e7cf3c50d69f3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/456abf757c66b11f847b057f81e7cf3c50d69f3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7d62c551f34bbb6b519160b98d73e1bc5484719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d62c551f34bbb6b519160b98d73e1bc5484719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d62c551f34bbb6b519160b98d73e1bc5484719"}], "stats": {"total": 210, "additions": 142, "deletions": 68}, "files": [{"sha": "79e0c1d5589ddc51905ea038ce580d7356fd7360", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "patch": "@@ -71,7 +71,7 @@\n {\n   /* Don't handle multi-word moves this way; we don't want to introduce\n      the individual word-mode moves until after reload.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+  if (GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD)\n     return false;\n \n   /* Check whether the constant can be loaded in a single"}, {"sha": "6e30c1a55954fe771ebca3d754de603435db251b", "filename": "gcc/config/riscv/riscv-modes.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-modes.def?ref=3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "patch": "@@ -21,3 +21,16 @@ along with GCC; see the file COPYING3.  If not see\n \n FLOAT_MODE (HF, 2, ieee_half_format);\n FLOAT_MODE (TF, 16, ieee_quad_format);\n+\n+/* TODO: According to RISC-V 'V' ISA spec, the maximun vector length can\n+   be 65536 for a single vector register which means the vector mode in\n+   GCC can be maximum = 65536 * 8 bits (LMUL=8).\n+   However, 'GET_MODE_SIZE' is using poly_uint16/unsigned short which will\n+   overflow if we specify vector-length = 65536. To support this feature,\n+   we need to change the codes outside the RISC-V port. We will support it in\n+   the future.  */\n+#define MAX_BITSIZE_MODE_ANY_MODE (4096 * 8)\n+\n+/* Coefficient 1 is multiplied by the number of 64-bit/32-bit chunks in a vector\n+   minus one.  */\n+#define NUM_POLY_INT_COEFFS 2"}, {"sha": "2bc0ef06f93ad7d1bfad6f7dc479e77ef557b527", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "patch": "@@ -64,7 +64,7 @@ extern rtx riscv_legitimize_call_address (rtx);\n extern void riscv_set_return_address (rtx, rtx);\n extern bool riscv_expand_block_move (rtx, rtx, rtx);\n extern rtx riscv_return_addr (int, rtx);\n-extern HOST_WIDE_INT riscv_initial_elimination_offset (int, int);\n+extern poly_int64 riscv_initial_elimination_offset (int, int);\n extern void riscv_expand_prologue (void);\n extern void riscv_expand_epilogue (int);\n extern bool riscv_epilogue_uses (unsigned int);"}, {"sha": "7248f04d68f38ec210bda7945d1297f9602aab51", "filename": "gcc/config/riscv/riscv-sr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv-sr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv-sr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-sr.cc?ref=3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "patch": "@@ -247,7 +247,7 @@ riscv_remove_unneeded_save_restore_calls (void)\n   /* We'll adjust stack size after this optimization, that require update every\n      sp use site, which could be unsafe, so we decide to turn off this\n      optimization if there are any arguments put on stack.  */\n-  if (crtl->args.size != 0)\n+  if (known_ne (crtl->args.size, 0))\n     return;\n \n   /* Will point to the first instruction of the function body, after the"}, {"sha": "7c120eaa8e33279f48493d31e2294fe2ef49ad86", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 116, "deletions": 64, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "patch": "@@ -100,7 +100,7 @@ enum riscv_address_type {\n /* Information about a function's frame layout.  */\n struct GTY(())  riscv_frame_info {\n   /* The size of the frame in bytes.  */\n-  HOST_WIDE_INT total_size;\n+  poly_int64 total_size;\n \n   /* Bit X is set if the function saves or restores GPR X.  */\n   unsigned int mask;\n@@ -112,17 +112,17 @@ struct GTY(())  riscv_frame_info {\n   unsigned save_libcall_adjustment;\n \n   /* Offsets of fixed-point and floating-point save areas from frame bottom */\n-  HOST_WIDE_INT gp_sp_offset;\n-  HOST_WIDE_INT fp_sp_offset;\n+  poly_int64 gp_sp_offset;\n+  poly_int64 fp_sp_offset;\n \n   /* Offset of virtual frame pointer from stack pointer/frame bottom */\n-  HOST_WIDE_INT frame_pointer_offset;\n+  poly_int64 frame_pointer_offset;\n \n   /* Offset of hard frame pointer from stack pointer/frame bottom */\n-  HOST_WIDE_INT hard_frame_pointer_offset;\n+  poly_int64 hard_frame_pointer_offset;\n \n   /* The offset of arg_pointer_rtx from the bottom of the frame.  */\n-  HOST_WIDE_INT arg_pointer_offset;\n+  poly_int64 arg_pointer_offset;\n };\n \n enum riscv_privilege_levels {\n@@ -255,6 +255,12 @@ static const struct riscv_tune_param *tune_param;\n /* Which automaton to use for tuning.  */\n enum riscv_microarchitecture_type riscv_microarchitecture;\n \n+/* The number of chunks in a single vector register.  */\n+poly_uint16 riscv_vector_chunks;\n+\n+/* The number of bytes in a vector chunk.  */\n+unsigned riscv_bytes_per_vector_chunk;\n+\n /* Index R is the smallest register class that contains register R.  */\n const enum reg_class riscv_regno_to_class[FIRST_PSEUDO_REGISTER] = {\n   GR_REGS,\tGR_REGS,\tGR_REGS,\tGR_REGS,\n@@ -807,8 +813,8 @@ riscv_valid_offset_p (rtx x, machine_mode mode)\n \n   /* We may need to split multiword moves, so make sure that every word\n      is accessible.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && !SMALL_OPERAND (INTVAL (x) + GET_MODE_SIZE (mode) - UNITS_PER_WORD))\n+  if (GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD\n+      && !SMALL_OPERAND (INTVAL (x) + GET_MODE_SIZE (mode).to_constant () - UNITS_PER_WORD))\n     return false;\n \n   return true;\n@@ -872,7 +878,7 @@ riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, machine_mode mode,\n   else\n     {\n       align = GET_MODE_ALIGNMENT (mode);\n-      size = GET_MODE_BITSIZE (mode);\n+      size = GET_MODE_BITSIZE (mode).to_constant ();\n     }\n \n   /* We may need to split multiword moves, so make sure that each word\n@@ -1013,7 +1019,7 @@ riscv_address_insns (rtx x, machine_mode mode, bool might_split_p)\n   /* BLKmode is used for single unaligned loads and stores and should\n      not count as a multiword mode. */\n   if (mode != BLKmode && might_split_p)\n-    n += (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+    n += (GET_MODE_SIZE (mode).to_constant () + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n   if (addr.type == ADDRESS_LO_SUM)\n     n += riscv_symbol_insns (addr.symbol_type) - 1;\n@@ -1106,9 +1112,9 @@ riscv_load_store_insns (rtx mem, rtx_insn *insn)\n \n   /* Try to prove that INSN does not need to be split.  */\n   might_split_p = true;\n-  if (GET_MODE_BITSIZE (mode) <= 32)\n+  if (GET_MODE_BITSIZE (mode).to_constant () <= 32)\n     might_split_p = false;\n-  else if (GET_MODE_BITSIZE (mode) == 64)\n+  else if (GET_MODE_BITSIZE (mode).to_constant () == 64)\n     {\n       set = single_set (insn);\n       if (set && !riscv_split_64bit_move_p (SET_DEST (set), SET_SRC (set)))\n@@ -1625,7 +1631,7 @@ riscv_legitimize_move (machine_mode mode, rtx dest, rtx src)\n        (set (reg:QI target) (subreg:QI (reg:DI temp) 0))\n      with auto-sign/zero extend.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n-      && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n+      && GET_MODE_SIZE (mode).to_constant () < UNITS_PER_WORD\n       && can_create_pseudo_p ()\n       && MEM_P (src))\n     {\n@@ -1650,7 +1656,7 @@ riscv_legitimize_move (machine_mode mode, rtx dest, rtx src)\n \t     improve cse.  */\n \t  machine_mode promoted_mode = mode;\n \t  if (GET_MODE_CLASS (mode) == MODE_INT\n-\t      && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\t      && GET_MODE_SIZE (mode).to_constant () < UNITS_PER_WORD)\n \t    promoted_mode = word_mode;\n \n \t  if (splittable_const_int_operand (src, mode))\n@@ -1748,7 +1754,7 @@ riscv_immediate_operand_p (int code, HOST_WIDE_INT x)\n static int\n riscv_binary_cost (rtx x, int single_insns, int double_insns)\n {\n-  if (GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD * 2)\n+  if (GET_MODE_SIZE (GET_MODE (x)).to_constant () == UNITS_PER_WORD * 2)\n     return COSTS_N_INSNS (double_insns);\n   return COSTS_N_INSNS (single_insns);\n }\n@@ -1881,7 +1887,7 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN\n       return false;\n \n     case NOT:\n-      *total = COSTS_N_INSNS (GET_MODE_SIZE (mode) > UNITS_PER_WORD ? 2 : 1);\n+      *total = COSTS_N_INSNS (GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD ? 2 : 1);\n       return false;\n \n     case AND:\n@@ -2128,7 +2134,7 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN\n       if (float_mode_p)\n \t*total = tune_param->fp_add[mode == DFmode];\n       else\n-\t*total = COSTS_N_INSNS (GET_MODE_SIZE (mode) > UNITS_PER_WORD ? 4 : 1);\n+\t*total = COSTS_N_INSNS (GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD ? 4 : 1);\n       return false;\n \n     case MULT:\n@@ -2137,7 +2143,7 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN\n       else if (!TARGET_MUL)\n \t/* Estimate the cost of a library call.  */\n \t*total = COSTS_N_INSNS (speed ? 32 : 6);\n-      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+      else if (GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD)\n \t*total = 3 * tune_param->int_mul[0] + COSTS_N_INSNS (2);\n       else if (!speed)\n \t*total = COSTS_N_INSNS (1);\n@@ -2301,8 +2307,8 @@ riscv_output_move (rtx dest, rtx src)\n   dest_code = GET_CODE (dest);\n   src_code = GET_CODE (src);\n   mode = GET_MODE (dest);\n-  dbl_p = (GET_MODE_SIZE (mode) == 8);\n-  width = GET_MODE_SIZE (mode);\n+  dbl_p = (GET_MODE_SIZE (mode).to_constant () == 8);\n+  width = GET_MODE_SIZE (mode).to_constant ();\n \n   if (dbl_p && riscv_split_64bit_move_p (dest, src))\n     return \"#\";\n@@ -2578,7 +2584,7 @@ static void\n riscv_extend_comparands (rtx_code code, rtx *op0, rtx *op1)\n {\n   /* Comparisons consider all XLEN bits, so extend sub-XLEN values.  */\n-  if (GET_MODE_SIZE (word_mode) > GET_MODE_SIZE (GET_MODE (*op0)))\n+  if (GET_MODE_SIZE (word_mode) > GET_MODE_SIZE (GET_MODE (*op0)).to_constant ())\n     {\n       /* It is more profitable to zero-extend QImode values.  But not if the\n \t first operand has already been sign-extended, and the second one is\n@@ -2941,7 +2947,7 @@ riscv_flatten_aggregate_field (const_tree type,\n \tif (n != 0)\n \t  return -1;\n \n-\tHOST_WIDE_INT elt_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (type)));\n+\tHOST_WIDE_INT elt_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (type))).to_constant ();\n \n \tif (elt_size <= UNITS_PER_FP_ARG)\n \t  {\n@@ -2959,9 +2965,9 @@ riscv_flatten_aggregate_field (const_tree type,\n     default:\n       if (n < 2\n \t  && ((SCALAR_FLOAT_TYPE_P (type)\n-\t       && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_FP_ARG)\n+\t       && GET_MODE_SIZE (TYPE_MODE (type)).to_constant () <= UNITS_PER_FP_ARG)\n \t      || (INTEGRAL_TYPE_P (type)\n-\t\t  && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_WORD)))\n+\t\t  && GET_MODE_SIZE (TYPE_MODE (type)).to_constant () <= UNITS_PER_WORD)))\n \t{\n \t  fields[n].type = type;\n \t  fields[n].offset = offset;\n@@ -3197,7 +3203,7 @@ riscv_get_arg_info (struct riscv_arg_info *info, const CUMULATIVE_ARGS *cum,\n     }\n \n   /* Work out the size of the argument.  */\n-  num_bytes = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  num_bytes = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode).to_constant ();\n   num_words = (num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n   /* Doubleword-aligned varargs start on an even register boundary.  */\n@@ -3291,7 +3297,7 @@ riscv_function_value (const_tree type, const_tree func, machine_mode mode)\n static bool\n riscv_pass_by_reference (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n-  HOST_WIDE_INT size = arg.type_size_in_bytes ();\n+  HOST_WIDE_INT size = arg.type_size_in_bytes ().to_constant ();;\n   struct riscv_arg_info info;\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n@@ -3920,7 +3926,7 @@ riscv_elf_select_rtx_section (machine_mode mode, rtx x,\n {\n   section *s = default_elf_select_rtx_section (mode, x, align);\n \n-  if (riscv_size_ok_for_small_data_p (GET_MODE_SIZE (mode)))\n+  if (riscv_size_ok_for_small_data_p (GET_MODE_SIZE (mode).to_constant ()))\n     {\n       if (startswith (s->named.name, \".rodata.cst\"))\n \t{\n@@ -4072,11 +4078,24 @@ riscv_save_libcall_count (unsigned mask)\n \n static HOST_WIDE_INT riscv_first_stack_step (struct riscv_frame_info *frame);\n \n+/* Handle stack align for poly_int.  */\n+static poly_int64\n+riscv_stack_align (poly_int64 value)\n+{\n+  return aligned_upper_bound (value, PREFERRED_STACK_BOUNDARY / 8);\n+}\n+\n+static HOST_WIDE_INT\n+riscv_stack_align (HOST_WIDE_INT value)\n+{\n+  return RISCV_STACK_ALIGN (value);\n+}\n+\n static void\n riscv_compute_frame_info (void)\n {\n   struct riscv_frame_info *frame;\n-  HOST_WIDE_INT offset;\n+  poly_int64 offset;\n   bool interrupt_save_prologue_temp = false;\n   unsigned int regno, i, num_x_saved = 0, num_f_saved = 0;\n \n@@ -4087,7 +4106,7 @@ riscv_compute_frame_info (void)\n   if (cfun->machine->interrupt_handler_p)\n     {\n       HOST_WIDE_INT step1 = riscv_first_stack_step (frame);\n-      if (! SMALL_OPERAND (frame->total_size - step1))\n+      if (! POLY_SMALL_OPERAND_P ((frame->total_size - step1)))\n \tinterrupt_save_prologue_temp = true;\n     }\n \n@@ -4117,23 +4136,23 @@ riscv_compute_frame_info (void)\n     }\n \n   /* At the bottom of the frame are any outgoing stack arguments. */\n-  offset = RISCV_STACK_ALIGN (crtl->outgoing_args_size);\n+  offset = riscv_stack_align (crtl->outgoing_args_size);\n   /* Next are local stack variables. */\n-  offset += RISCV_STACK_ALIGN (get_frame_size ());\n+  offset += riscv_stack_align (get_frame_size ());\n   /* The virtual frame pointer points above the local variables. */\n   frame->frame_pointer_offset = offset;\n   /* Next are the callee-saved FPRs. */\n   if (frame->fmask)\n-    offset += RISCV_STACK_ALIGN (num_f_saved * UNITS_PER_FP_REG);\n+    offset += riscv_stack_align (num_f_saved * UNITS_PER_FP_REG);\n   frame->fp_sp_offset = offset - UNITS_PER_FP_REG;\n   /* Next are the callee-saved GPRs. */\n   if (frame->mask)\n     {\n-      unsigned x_save_size = RISCV_STACK_ALIGN (num_x_saved * UNITS_PER_WORD);\n+      unsigned x_save_size = riscv_stack_align (num_x_saved * UNITS_PER_WORD);\n       unsigned num_save_restore = 1 + riscv_save_libcall_count (frame->mask);\n \n       /* Only use save/restore routines if they don't alter the stack size.  */\n-      if (RISCV_STACK_ALIGN (num_save_restore * UNITS_PER_WORD) == x_save_size)\n+      if (riscv_stack_align (num_save_restore * UNITS_PER_WORD) == x_save_size)\n \t{\n \t  /* Libcall saves/restores 3 registers at once, so we need to\n \t     allocate 12 bytes for callee-saved register.  */\n@@ -4149,17 +4168,17 @@ riscv_compute_frame_info (void)\n   /* The hard frame pointer points above the callee-saved GPRs. */\n   frame->hard_frame_pointer_offset = offset;\n   /* Above the hard frame pointer is the callee-allocated varags save area. */\n-  offset += RISCV_STACK_ALIGN (cfun->machine->varargs_size);\n+  offset += riscv_stack_align (cfun->machine->varargs_size);\n   /* Next is the callee-allocated area for pretend stack arguments.  */\n-  offset += RISCV_STACK_ALIGN (crtl->args.pretend_args_size);\n+  offset += riscv_stack_align (crtl->args.pretend_args_size);\n   /* Arg pointer must be below pretend args, but must be above alignment\n      padding.  */\n   frame->arg_pointer_offset = offset - crtl->args.pretend_args_size;\n   frame->total_size = offset;\n   /* Next points the incoming stack pointer and any incoming arguments. */\n \n   /* Only use save/restore routines when the GPRs are atop the frame.  */\n-  if (frame->hard_frame_pointer_offset != frame->total_size)\n+  if (known_ne (frame->hard_frame_pointer_offset, frame->total_size))\n     frame->save_libcall_adjustment = 0;\n }\n \n@@ -4176,10 +4195,10 @@ riscv_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n    or argument pointer.  TO is either the stack pointer or hard frame\n    pointer.  */\n \n-HOST_WIDE_INT\n+poly_int64\n riscv_initial_elimination_offset (int from, int to)\n {\n-  HOST_WIDE_INT src, dest;\n+  poly_int64 src, dest;\n \n   riscv_compute_frame_info ();\n \n@@ -4223,7 +4242,7 @@ riscv_set_return_address (rtx address, rtx scratch)\n \n   gcc_assert (BITSET_P (cfun->machine->frame.mask, RETURN_ADDR_REGNUM));\n   slot_address = riscv_add_offset (scratch, stack_pointer_rtx,\n-\t\t\t\t  cfun->machine->frame.gp_sp_offset);\n+\t\t\t\t  cfun->machine->frame.gp_sp_offset.to_constant());\n   riscv_emit_move (gen_frame_mem (GET_MODE (address), slot_address), address);\n }\n \n@@ -4250,13 +4269,13 @@ riscv_save_restore_reg (machine_mode mode, int regno,\n    of the frame.  */\n \n static void\n-riscv_for_each_saved_reg (HOST_WIDE_INT sp_offset, riscv_save_restore_fn fn,\n+riscv_for_each_saved_reg (poly_int64 sp_offset, riscv_save_restore_fn fn,\n \t\t\t  bool epilogue, bool maybe_eh_return)\n {\n   HOST_WIDE_INT offset;\n \n   /* Save the link register and s-registers. */\n-  offset = cfun->machine->frame.gp_sp_offset - sp_offset;\n+  offset = (cfun->machine->frame.gp_sp_offset - sp_offset).to_constant ();\n   for (unsigned int regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n     if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))\n       {\n@@ -4287,14 +4306,14 @@ riscv_for_each_saved_reg (HOST_WIDE_INT sp_offset, riscv_save_restore_fn fn,\n \n   /* This loop must iterate over the same space as its companion in\n      riscv_compute_frame_info.  */\n-  offset = cfun->machine->frame.fp_sp_offset - sp_offset;\n+  offset = (cfun->machine->frame.fp_sp_offset - sp_offset).to_constant ();\n   for (unsigned int regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n     if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n       {\n \tmachine_mode mode = TARGET_DOUBLE_FLOAT ? DFmode : SFmode;\n \n \triscv_save_restore_reg (mode, regno, offset, fn);\n-\toffset -= GET_MODE_SIZE (mode);\n+\toffset -= GET_MODE_SIZE (mode).to_constant ();\n       }\n }\n \n@@ -4336,21 +4355,21 @@ riscv_restore_reg (rtx reg, rtx mem)\n static HOST_WIDE_INT\n riscv_first_stack_step (struct riscv_frame_info *frame)\n {\n-  if (SMALL_OPERAND (frame->total_size))\n-    return frame->total_size;\n+  if (SMALL_OPERAND (frame->total_size.to_constant()))\n+    return frame->total_size.to_constant();\n \n   HOST_WIDE_INT min_first_step =\n-    RISCV_STACK_ALIGN (frame->total_size - frame->fp_sp_offset);\n+    RISCV_STACK_ALIGN ((frame->total_size - frame->fp_sp_offset).to_constant());\n   HOST_WIDE_INT max_first_step = IMM_REACH / 2 - PREFERRED_STACK_BOUNDARY / 8;\n-  HOST_WIDE_INT min_second_step = frame->total_size - max_first_step;\n+  HOST_WIDE_INT min_second_step = frame->total_size.to_constant() - max_first_step;\n   gcc_assert (min_first_step <= max_first_step);\n \n   /* As an optimization, use the least-significant bits of the total frame\n      size, so that the second adjustment step is just LUI + ADD.  */\n   if (!SMALL_OPERAND (min_second_step)\n-      && frame->total_size % IMM_REACH < IMM_REACH / 2\n-      && frame->total_size % IMM_REACH >= min_first_step)\n-    return frame->total_size % IMM_REACH;\n+      && frame->total_size.to_constant() % IMM_REACH < IMM_REACH / 2\n+      && frame->total_size.to_constant() % IMM_REACH >= min_first_step)\n+    return frame->total_size.to_constant() % IMM_REACH;\n \n   if (TARGET_RVC)\n     {\n@@ -4423,7 +4442,7 @@ void\n riscv_expand_prologue (void)\n {\n   struct riscv_frame_info *frame = &cfun->machine->frame;\n-  HOST_WIDE_INT size = frame->total_size;\n+  HOST_WIDE_INT size = frame->total_size.to_constant ();\n   unsigned mask = frame->mask;\n   rtx insn;\n \n@@ -4466,7 +4485,7 @@ riscv_expand_prologue (void)\n   if (frame_pointer_needed)\n     {\n       insn = gen_add3_insn (hard_frame_pointer_rtx, stack_pointer_rtx,\n-\t\t\t    GEN_INT (frame->hard_frame_pointer_offset - size));\n+\t\t\t    GEN_INT ((frame->hard_frame_pointer_offset - size).to_constant ()));\n       RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n \n       riscv_emit_stack_tie ();\n@@ -4532,16 +4551,16 @@ riscv_expand_epilogue (int style)\n      Start off by assuming that no registers need to be restored.  */\n   struct riscv_frame_info *frame = &cfun->machine->frame;\n   unsigned mask = frame->mask;\n-  HOST_WIDE_INT step1 = frame->total_size;\n+  HOST_WIDE_INT step1 = frame->total_size.to_constant ();\n   HOST_WIDE_INT step2 = 0;\n   bool use_restore_libcall = ((style == NORMAL_RETURN)\n \t\t\t      && riscv_use_save_libcall (frame));\n   rtx ra = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n   rtx insn;\n \n   /* We need to add memory barrier to prevent read from deallocated stack.  */\n-  bool need_barrier_p = (get_frame_size ()\n-\t\t\t + cfun->machine->frame.arg_pointer_offset) != 0;\n+  bool need_barrier_p\n+    = known_ne (get_frame_size (), cfun->machine->frame.arg_pointer_offset);\n \n   if (cfun->machine->naked_p)\n     {\n@@ -4568,7 +4587,7 @@ riscv_expand_epilogue (int style)\n       riscv_emit_stack_tie ();\n       need_barrier_p = false;\n \n-      rtx adjust = GEN_INT (-frame->hard_frame_pointer_offset);\n+      rtx adjust = GEN_INT (-frame->hard_frame_pointer_offset.to_constant ());\n       if (!SMALL_OPERAND (INTVAL (adjust)))\n \t{\n \t  riscv_emit_move (RISCV_PROLOGUE_TEMP (Pmode), adjust);\n@@ -4582,7 +4601,7 @@ riscv_expand_epilogue (int style)\n       rtx dwarf = NULL_RTX;\n       rtx cfa_adjust_value = gen_rtx_PLUS (\n \t\t\t       Pmode, hard_frame_pointer_rtx,\n-\t\t\t       GEN_INT (-frame->hard_frame_pointer_offset));\n+\t\t\t       GEN_INT (-frame->hard_frame_pointer_offset.to_constant ()));\n       rtx cfa_adjust_rtx = gen_rtx_SET (stack_pointer_rtx, cfa_adjust_value);\n       dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, cfa_adjust_rtx, dwarf);\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -4599,7 +4618,7 @@ riscv_expand_epilogue (int style)\n     }\n \n   /* Set TARGET to BASE + STEP1.  */\n-  if (step1 > 0)\n+  if (known_gt (step1, 0))\n     {\n       /* Emit a barrier to prevent loads from a deallocated stack.  */\n       riscv_emit_stack_tie ();\n@@ -4725,7 +4744,7 @@ riscv_epilogue_uses (unsigned int regno)\n bool\n riscv_can_use_return_insn (void)\n {\n-  return (reload_completed && cfun->machine->frame.total_size == 0\n+  return (reload_completed && known_eq (cfun->machine->frame.total_size, 0)\n \t  && ! cfun->machine->interrupt_handler_p);\n }\n \n@@ -4825,7 +4844,7 @@ static bool\n riscv_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n \t\t\t       reg_class_t class2)\n {\n-  return (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+  return (GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD\n \t  && (class1 == FP_REGS) != (class2 == FP_REGS));\n }\n \n@@ -4848,10 +4867,10 @@ static unsigned int\n riscv_hard_regno_nregs (unsigned int regno, machine_mode mode)\n {\n   if (FP_REG_P (regno))\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_FP_REG - 1) / UNITS_PER_FP_REG;\n+    return (GET_MODE_SIZE (mode).to_constant () + UNITS_PER_FP_REG - 1) / UNITS_PER_FP_REG;\n \n   /* All other registers are word-sized.  */\n-  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  return (GET_MODE_SIZE (mode).to_constant () + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n@@ -5058,6 +5077,37 @@ riscv_init_machine_status (void)\n   return ggc_cleared_alloc<machine_function> ();\n }\n \n+/* Return the VLEN value associated with -march.\n+   TODO: So far we only support length-agnostic value. */\n+static poly_uint16\n+riscv_convert_vector_bits (void)\n+{\n+  /* The runtime invariant is only meaningful when vector is enabled. */\n+  if (!TARGET_VECTOR)\n+    return 0;\n+\n+  if (TARGET_VECTOR_ELEN_64 || TARGET_VECTOR_ELEN_FP_64)\n+    {\n+      /* When targetting Zve64* (ELEN = 64) extensions, we should use 64-bit\n+\t chunk size. Runtime invariant: The single indeterminate represent the\n+\t number of 64-bit chunks in a vector beyond minimum length of 64 bits.\n+\t Thus the number of bytes in a vector is 8 + 8 * x1 which is\n+\t riscv_vector_chunks * 8 = poly_int (8, 8). */\n+      riscv_bytes_per_vector_chunk = 8;\n+    }\n+  else\n+    {\n+      /* When targetting Zve32* (ELEN = 32) extensions, we should use 32-bit\n+\t chunk size. Runtime invariant: The single indeterminate represent the\n+\t number of 32-bit chunks in a vector beyond minimum length of 32 bits.\n+\t Thus the number of bytes in a vector is 4 + 4 * x1 which is\n+\t riscv_vector_chunks * 4 = poly_int (4, 4).  */\n+      riscv_bytes_per_vector_chunk = 4;\n+    }\n+\n+  return poly_uint16 (1, 1);\n+}\n+\n /* Implement TARGET_OPTION_OVERRIDE.  */\n \n static void\n@@ -5204,6 +5254,8 @@ riscv_option_override (void)\n       riscv_stack_protector_guard_offset = offs;\n     }\n \n+  /* Convert -march to a chunks count.  */\n+  riscv_vector_chunks = riscv_convert_vector_bits ();\n }\n \n /* Implement TARGET_CONDITIONAL_REGISTER_USAGE.  */\n@@ -5561,7 +5613,7 @@ riscv_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n     return promote_mode (type, mode, punsignedp);\n \n   unsignedp = *punsignedp;\n-  PROMOTE_MODE (mode, unsignedp, type);\n+  PROMOTE_MODE (as_a <scalar_mode> (mode), unsignedp, type);\n   *punsignedp = unsignedp;\n   return mode;\n }"}, {"sha": "4b07c5487c6e6409cb82d5d6bb605ac68bc6fb94", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "patch": "@@ -522,6 +522,10 @@ enum reg_class\n #define SMALL_OPERAND(VALUE) \\\n   ((unsigned HOST_WIDE_INT) (VALUE) + IMM_REACH/2 < IMM_REACH)\n \n+#define POLY_SMALL_OPERAND_P(POLY_VALUE)\t\t\\\n+  (POLY_VALUE.is_constant () ?\t\t\t\t\\\n+     SMALL_OPERAND (POLY_VALUE.to_constant ()) : false)\n+     \n /* True if VALUE can be loaded into a register using LUI.  */\n \n #define LUI_OPERAND(VALUE)\t\t\t\t\t\t\\\n@@ -952,6 +956,11 @@ while (0)\n extern const enum reg_class riscv_regno_to_class[];\n extern bool riscv_slow_unaligned_access_p;\n extern unsigned riscv_stack_boundary;\n+extern unsigned riscv_bytes_per_vector_chunk;\n+extern poly_uint16 riscv_vector_chunks;\n+/* The number of bits and bytes in a RVV vector.  */\n+#define BITS_PER_RISCV_VECTOR (poly_uint16 (riscv_vector_chunks * riscv_bytes_per_vector_chunk * 8))\n+#define BYTES_PER_RISCV_VECTOR (poly_uint16 (riscv_vector_chunks * riscv_bytes_per_vector_chunk))\n #endif\n \n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) \\"}, {"sha": "c517ae0d0f7226391ae157d61fe6a1be80f38c3e", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3496ca4e6566fc3c5f1093a0290bb88c34d368f8/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=3496ca4e6566fc3c5f1093a0290bb88c34d368f8", "patch": "@@ -2162,7 +2162,7 @@\n        (lshiftrt:GPR (match_dup 3) (match_dup 2)))]\n {\n   /* Op2 is a VOIDmode constant, so get the mode size from op1.  */\n-  operands[2] = GEN_INT (GET_MODE_BITSIZE (GET_MODE (operands[1]))\n+  operands[2] = GEN_INT (GET_MODE_BITSIZE (GET_MODE (operands[1])).to_constant ()\n \t\t\t - exact_log2 (INTVAL (operands[2]) + 1));\n })\n "}]}