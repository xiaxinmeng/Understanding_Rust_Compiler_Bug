{"sha": "93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "node_id": "C_kwDOANBUbNoAKDkzZTc1OWZjMThhMWE0MjA4YWUyODk4NjEwYzU1ZWJkOGM5ZTI1ZDg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-28T21:15:44Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-02T14:52:58Z"}, "message": "analyzer: implement bit_range_region\n\nGCC 12 has gained -Wanalyzer-use-of-uninitialized-value, and I'm\nseeing various false positives from it due to region_model::get_lvalue\nnot properly handling BIT_FIELD_REF, and falling back to\nusing an UNKNOWN_REGION for them.\n\nThis patch fixes these false positives by implementing a new\nbit_range_region region subclass for handling BIT_FIELD_REF.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (class bit_range_region): New forward decl.\n\t* region-model-manager.cc (region_model_manager::get_bit_range):\n\tNew.\n\t(region_model_manager::log_stats): Handle m_bit_range_regions.\n\t* region-model.cc (region_model::get_lvalue_1): Handle\n\tBIT_FIELD_REF.\n\t* region-model.h (region_model_manager::get_bit_range): New decl.\n\t(region_model_manager::m_bit_range_regions): New field.\n\t* region.cc (region::get_base_region): Handle RK_BIT_RANGE.\n\t(region::base_region_p): Likewise.\n\t(region::calc_offset): Likewise.\n\t(bit_range_region::dump_to_pp): New.\n\t(bit_range_region::get_byte_size): New.\n\t(bit_range_region::get_bit_size): New.\n\t(bit_range_region::get_byte_size_sval): New.\n\t(bit_range_region::get_relative_concrete_offset): New.\n\t* region.h (enum region_kind): Add RK_BIT_RANGE.\n\t(region::dyn_cast_bit_range_region): New vfunc.\n\t(class bit_range_region): New.\n\t(is_a_helper <const bit_range_region *>::test): New.\n\t(default_hash_traits<bit_range_region::key_t>): New.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/torture/uninit-bit-field-ref.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "2749173a8a7299f75335c20705bbbbb8a8a8dccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2749173a8a7299f75335c20705bbbbb8a8a8dccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b4eee5fd158c4ee75d1f1000debbf5082fb9b56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b4eee5fd158c4ee75d1f1000debbf5082fb9b56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b4eee5fd158c4ee75d1f1000debbf5082fb9b56"}], "stats": {"total": 243, "additions": 243, "deletions": 0}, "files": [{"sha": "7e58bcd5d704582862f6d3221085af4ec36200fe", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "patch": "@@ -67,6 +67,7 @@ class region;\n   class cast_region;\n   class field_region;\n   class string_region;\n+  class bit_range_region;\n class region_model_manager;\n struct model_merger;\n class store_manager;"}, {"sha": "010ad07884939221473e5aec6814d48ee61f8b22", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "patch": "@@ -1494,6 +1494,25 @@ region_model_manager::get_region_for_string (tree string_cst)\n   return reg;\n }\n \n+/* Return the region that describes accessing BITS within PARENT as TYPE,\n+   creating it if necessary.  */\n+\n+const region *\n+region_model_manager::get_bit_range (const region *parent, tree type,\n+\t\t\t\t     const bit_range &bits)\n+{\n+  gcc_assert (parent);\n+\n+  bit_range_region::key_t key (parent, type, bits);\n+  if (bit_range_region *reg = m_bit_range_regions.get (key))\n+    return reg;\n+\n+  bit_range_region *bit_range_reg\n+    = new bit_range_region (alloc_region_id (), parent, type, bits);\n+  m_bit_range_regions.put (key, bit_range_reg);\n+  return bit_range_reg;\n+}\n+\n /* If we see a tree code we don't know how to handle, rather than\n    ICE or generate bogus results, create a dummy region, and notify\n    CTXT so that it can mark the new state as being not properly\n@@ -1663,6 +1682,7 @@ region_model_manager::log_stats (logger *logger, bool show_objs) const\n   log_uniq_map (logger, show_objs, \"frame_region\", m_frame_regions);\n   log_uniq_map (logger, show_objs, \"symbolic_region\", m_symbolic_regions);\n   log_uniq_map (logger, show_objs, \"string_region\", m_string_map);\n+  log_uniq_map (logger, show_objs, \"bit_range_region\", m_bit_range_regions);\n   logger->log (\"  # managed dynamic regions: %i\",\n \t       m_managed_dynamic_regions.length ());\n   m_store_mgr.log_stats (logger, show_objs);"}, {"sha": "58c7028fc9c154c3edb2ca661b77b1750fa6f217", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "patch": "@@ -1707,6 +1707,20 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt) const\n       }\n       break;\n \n+    case BIT_FIELD_REF:\n+      {\n+\ttree inner_expr = TREE_OPERAND (expr, 0);\n+\tconst region *inner_reg = get_lvalue (inner_expr, ctxt);\n+\ttree num_bits = TREE_OPERAND (expr, 1);\n+\ttree first_bit_offset = TREE_OPERAND (expr, 2);\n+\tgcc_assert (TREE_CODE (num_bits) == INTEGER_CST);\n+\tgcc_assert (TREE_CODE (first_bit_offset) == INTEGER_CST);\n+\tbit_range bits (TREE_INT_CST_LOW (first_bit_offset),\n+\t\t\tTREE_INT_CST_LOW (num_bits));\n+\treturn m_mgr->get_bit_range (inner_reg, TREE_TYPE (expr), bits);\n+      }\n+      break;\n+\n     case MEM_REF:\n       {\n \ttree ptr = TREE_OPERAND (expr, 0);"}, {"sha": "3fa090d771ed3d61c30cf3bee021bb15914fb204", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "patch": "@@ -318,6 +318,8 @@ class region_model_manager\n \t\t\t\t\tfunction *fun);\n   const region *get_symbolic_region (const svalue *sval);\n   const string_region *get_region_for_string (tree string_cst);\n+  const region *get_bit_range (const region *parent, tree type,\n+\t\t\t       const bit_range &bits);\n \n   const region *\n   get_region_for_unexpected_tree_code (region_model_context *ctxt,\n@@ -471,6 +473,8 @@ class region_model_manager\n   typedef hash_map<tree, string_region *> string_map_t;\n   string_map_t m_string_map;\n \n+  consolidation_map<bit_range_region> m_bit_range_regions;\n+\n   store_manager m_store_mgr;\n \n   bounded_ranges_manager *m_range_mgr;"}, {"sha": "9d8fdb22271a2496406b1f216d31b10c17255f19", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "patch": "@@ -99,6 +99,7 @@ region::get_base_region () const\n \tcase RK_ELEMENT:\n \tcase RK_OFFSET:\n \tcase RK_SIZED:\n+\tcase RK_BIT_RANGE:\n \t  iter = iter->get_parent_region ();\n \t  continue;\n \tcase RK_CAST:\n@@ -124,6 +125,7 @@ region::base_region_p () const\n     case RK_OFFSET:\n     case RK_SIZED:\n     case RK_CAST:\n+    case RK_BIT_RANGE:\n       return false;\n \n     default:\n@@ -547,6 +549,19 @@ region::calc_offset () const\n \t  }\n \t  continue;\n \n+\tcase RK_BIT_RANGE:\n+\t  {\n+\t    const bit_range_region *bit_range_reg\n+\t      = (const bit_range_region *)iter_region;\n+\t    iter_region = iter_region->get_parent_region ();\n+\n+\t    bit_offset_t rel_bit_offset;\n+\t    if (!bit_range_reg->get_relative_concrete_offset (&rel_bit_offset))\n+\t      return region_offset::make_symbolic (iter_region);\n+\t    accum_bit_offset += rel_bit_offset;\n+\t  }\n+\t  continue;\n+\n \tdefault:\n \t  return region_offset::make_concrete (iter_region, accum_bit_offset);\n \t}\n@@ -1446,6 +1461,75 @@ string_region::dump_to_pp (pretty_printer *pp, bool simple) const\n     }\n }\n \n+/* class bit_range_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for bit_range_region.  */\n+\n+void\n+bit_range_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"BIT_RANGE_REG(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      m_bits.dump_to_pp (pp);\n+      pp_string (pp, \")\");\n+    }\n+  else\n+    {\n+      pp_string (pp, \"bit_range_region(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      m_bits.dump_to_pp (pp);\n+      pp_printf (pp, \")\");\n+    }\n+}\n+\n+/* Implementation of region::get_byte_size vfunc for bit_range_region.  */\n+\n+bool\n+bit_range_region::get_byte_size (byte_size_t *out) const\n+{\n+  if (m_bits.m_size_in_bits % BITS_PER_UNIT == 0)\n+    {\n+      *out = m_bits.m_size_in_bits / BITS_PER_UNIT;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Implementation of region::get_bit_size vfunc for bit_range_region.  */\n+\n+bool\n+bit_range_region::get_bit_size (bit_size_t *out) const\n+{\n+  *out = m_bits.m_size_in_bits;\n+  return true;\n+}\n+\n+/* Implementation of region::get_byte_size_sval vfunc for bit_range_region.  */\n+\n+const svalue *\n+bit_range_region::get_byte_size_sval (region_model_manager *mgr) const\n+{\n+  if (m_bits.m_size_in_bits % BITS_PER_UNIT != 0)\n+    return mgr->get_or_create_unknown_svalue (size_type_node);\n+\n+  HOST_WIDE_INT num_bytes = m_bits.m_size_in_bits.to_shwi () / BITS_PER_UNIT;\n+  return mgr->get_or_create_int_cst (size_type_node, num_bytes);\n+}\n+\n+/* Implementation of region::get_relative_concrete_offset vfunc for\n+   bit_range_region.  */\n+\n+bool\n+bit_range_region::get_relative_concrete_offset (bit_offset_t *out) const\n+{\n+  *out = m_bits.get_start_bit_offset ();\n+  return true;\n+}\n+\n /* class unknown_region : public region.  */\n \n /* Implementation of region::dump_to_pp vfunc for unknown_region.  */"}, {"sha": "206b157e9082027124ae979206197a0d41759306", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "patch": "@@ -60,6 +60,7 @@ enum region_kind\n   RK_HEAP_ALLOCATED,\n   RK_ALLOCA,\n   RK_STRING,\n+  RK_BIT_RANGE,\n   RK_UNKNOWN\n };\n \n@@ -88,6 +89,7 @@ enum region_kind\n      heap_allocated_region (RK_HEAP_ALLOCATED)\n      alloca_region (RK_ALLOCA)\n      string_region (RK_STRING)\n+     bit_range_region (RK_BIT_RANGE)\n      unknown_region (RK_UNKNOWN).  */\n \n /* Abstract base class for representing ways of accessing chunks of memory.\n@@ -127,6 +129,8 @@ class region\n   dyn_cast_cast_region () const { return NULL; }\n   virtual const string_region *\n   dyn_cast_string_region () const { return NULL; }\n+  virtual const bit_range_region *\n+  dyn_cast_bit_range_region () const { return NULL; }\n \n   virtual void accept (visitor *v) const;\n \n@@ -1133,6 +1137,91 @@ is_a_helper <const string_region *>::test (const region *reg)\n \n namespace ana {\n \n+/* A region for a specific range of bits within another region.  */\n+\n+class bit_range_region : public region\n+{\n+public:\n+  /* A support class for uniquifying instances of bit_range_region.  */\n+  struct key_t\n+  {\n+    key_t (const region *parent, tree type, const bit_range &bits)\n+    : m_parent (parent), m_type (type), m_bits (bits)\n+    {\n+      gcc_assert (parent);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_parent);\n+      hstate.add_ptr (m_type);\n+      hstate.add (&m_bits, sizeof (m_bits));\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_parent == other.m_parent\n+\t      && m_type == other.m_type\n+\t      && m_bits == other.m_bits);\n+    }\n+\n+    void mark_deleted () { m_parent = reinterpret_cast<const region *> (1); }\n+    void mark_empty () { m_parent = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_parent == reinterpret_cast<const region *> (1);\n+    }\n+    bool is_empty () const { return m_parent == NULL; }\n+\n+    const region *m_parent;\n+    tree m_type;\n+    bit_range m_bits;\n+  };\n+\n+  bit_range_region (unsigned id, const region *parent, tree type,\n+\t\t    const bit_range &bits)\n+  : region (complexity (parent), id, parent, type),\n+    m_bits (bits)\n+  {}\n+\n+  const bit_range_region *\n+  dyn_cast_bit_range_region () const FINAL OVERRIDE { return this; }\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_BIT_RANGE; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const bit_range &get_bits () const { return m_bits; }\n+\n+  bool get_byte_size (byte_size_t *out) const FINAL OVERRIDE;\n+  bool get_bit_size (bit_size_t *out) const FINAL OVERRIDE;\n+  const svalue *get_byte_size_sval (region_model_manager *mgr) const FINAL OVERRIDE;\n+  bool get_relative_concrete_offset (bit_offset_t *out) const FINAL OVERRIDE;\n+\n+private:\n+  bit_range m_bits;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const bit_range_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_BIT_RANGE;\n+}\n+\n+template <> struct default_hash_traits<bit_range_region::key_t>\n+: public member_function_hash_traits<bit_range_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n /* An unknown region, for handling unimplemented tree codes.  */\n \n class unknown_region : public region"}, {"sha": "e2f91380a71f4d2dbfa6350e148ff9bf0ff6226f", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/uninit-bit-field-ref.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Funinit-bit-field-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e759fc18a1a4208ae2898610c55ebd8c9e25d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Funinit-bit-field-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Funinit-bit-field-ref.c?ref=93e759fc18a1a4208ae2898610c55ebd8c9e25d8", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-Wno-psabi\" } */\n+\n+typedef __INT32_TYPE__   int32_t;\n+typedef int32_t vnx4si __attribute__((vector_size (32)));\n+\n+extern void check_for_uninit (vnx4si v);\n+\n+void test_1a (vnx4si *out, int a, int b)\n+{\n+  vnx4si v = (vnx4si) { 1, 2, 3, 4, 5, 6, a, b };\n+  check_for_uninit (v);\n+}\n+\n+void test_1b (vnx4si *out, int a, int b)\n+{\n+  check_for_uninit ((vnx4si) { 1, 2, 3, 4, 5, 6, a, b });\n+}\n+\n+static __attribute__((noipa)) void\n+called_by_test_2 (vnx4si *out, int a, int b)\n+{\n+  *out = (vnx4si) { 1, 2, 3, 4, 5, 6, a, b };\n+}\n+\n+void test_2 (vnx4si *out, int a, int b)\n+{\n+  vnx4si v;\n+  called_by_test_2 (&v, a, b);\n+  check_for_uninit (v);\n+}"}]}