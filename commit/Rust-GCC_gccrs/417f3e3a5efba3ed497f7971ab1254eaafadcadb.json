{"sha": "417f3e3a5efba3ed497f7971ab1254eaafadcadb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3ZjNlM2E1ZWZiYTNlZDQ5N2Y3OTcxYWIxMjU0ZWFhZmFkY2FkYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-11T23:20:53Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-11T23:20:53Z"}, "message": "[multiple changes]\n\n2000-07-11  Zack Weinberg  <zack@wolery.cumb.org>\n\n\t* cpplex.c (parse_name): No longer inline (premature optimization).\n\t(do_pop_context): Fold into pop_context.\n\t(pop_context): Returns int.\n\t(lex_next): Hoist test for end of directive into pop_context.\n\t(push_macro_context): Returns int; takes just reader and token.\n\tHoist test for excessive nesting to caller.\n\t(push_arg_context): Returns void; takes just reader and token.\n\tDo not call stringify_arg or get_raw_token.\n\t(get_raw_token): Convert tail recursion through\tpush_arg_context\n\tto a loop at this level.  Call stringify_arg here if appropriate.\n\t(maybe_paste_with_next): Convert tail recursion to a while loop.\n\tHoist test of paste_level to caller.\n\n\t(stringify_arg): Push arg context at beginning.\n\t(cpp_get_token): Split out core into _cpp_get_token.  Call\n\tprocess_directive here.  Throw away CPP_PLACEMARKER tokens.\n\t(_cpp_get_token): Convert tail recursion through\n\tpush_macro_context to a loop at this level.\n\t(_cpp_glue_header_name, is_macro_disabled, stringify_arg,\n\t_cpp_get_raw_token): Use _cpp_get_token.\n\t(_cpp_skip_rest_of_line): Drop the context stack directly; do\n\tnot call pop_context.\n\t(_cpp_run_directive): Call lex_next directly.\n\n\t* cpphash.h: Prototype _cpp_get_token.\n\t* cppexp.c (lex): Use it.\n\t* cpphash.c (parse_define): Use it.\n\t* cpplib.c (get_define_node, do_undef, parse_include,\n\tread_line_number, do_line, do_ident, do_pragma, do_pragma_gcc,\n\tdo_pragma_implementation, do_pragma_poison, do_pragma_dependency,\n\tparse_ifdef, validate_else): Use it.\n\t(cpp_push_buffer): Tweak error message; abort if anyone tries\n\tto push a buffer while macro expansions are stacked.\n\n2000-07-11  Donn Terry  <donnte@microsoft.com>\n\n\t* cpplex.c (free_macro_args, save_token): Cast arg of free\n\tand/or xrealloc to PTR.\n\t(_cpp_init_input_buffer): Clear all fields of the base context.\n\nFrom-SVN: r34972", "tree": {"sha": "976249a00737110d95a5b5c760a60c97bb68595a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/976249a00737110d95a5b5c760a60c97bb68595a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/417f3e3a5efba3ed497f7971ab1254eaafadcadb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417f3e3a5efba3ed497f7971ab1254eaafadcadb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/417f3e3a5efba3ed497f7971ab1254eaafadcadb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417f3e3a5efba3ed497f7971ab1254eaafadcadb/comments", "author": null, "committer": null, "parents": [{"sha": "268afb999d5d67e4083d42c64d32d49df28dee0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268afb999d5d67e4083d42c64d32d49df28dee0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268afb999d5d67e4083d42c64d32d49df28dee0e"}], "stats": {"total": 523, "additions": 304, "deletions": 219}, "files": [{"sha": "45501819136b4198f51aa502864e0cb2a15890c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=417f3e3a5efba3ed497f7971ab1254eaafadcadb", "patch": "@@ -1,3 +1,45 @@\n+2000-07-11  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplex.c (parse_name): No longer inline (premature optimization).\n+\t(do_pop_context): Fold into pop_context.\n+\t(pop_context): Returns int.\n+\t(lex_next): Hoist test for end of directive into pop_context.\n+\t(push_macro_context): Returns int; takes just reader and token.\n+\tHoist test for excessive nesting to caller.\n+\t(push_arg_context): Returns void; takes just reader and token.\n+\tDo not call stringify_arg or get_raw_token.\n+\t(get_raw_token): Convert tail recursion through\tpush_arg_context\n+\tto a loop at this level.  Call stringify_arg here if appropriate.\n+\t(maybe_paste_with_next): Convert tail recursion to a while loop.\n+\tHoist test of paste_level to caller.\n+\n+\t(stringify_arg): Push arg context at beginning.\n+\t(cpp_get_token): Split out core into _cpp_get_token.  Call\n+\tprocess_directive here.  Throw away CPP_PLACEMARKER tokens.\n+\t(_cpp_get_token): Convert tail recursion through\n+\tpush_macro_context to a loop at this level.\n+\t(_cpp_glue_header_name, is_macro_disabled, stringify_arg,\n+\t_cpp_get_raw_token): Use _cpp_get_token.\n+\t(_cpp_skip_rest_of_line): Drop the context stack directly; do\n+\tnot call pop_context.\n+\t(_cpp_run_directive): Call lex_next directly.\n+\n+\t* cpphash.h: Prototype _cpp_get_token.\n+\t* cppexp.c (lex): Use it.\n+\t* cpphash.c (parse_define): Use it.\n+\t* cpplib.c (get_define_node, do_undef, parse_include,\n+\tread_line_number, do_line, do_ident, do_pragma, do_pragma_gcc,\n+\tdo_pragma_implementation, do_pragma_poison, do_pragma_dependency,\n+\tparse_ifdef, validate_else): Use it.\n+\t(cpp_push_buffer): Tweak error message; abort if anyone tries\n+\tto push a buffer while macro expansions are stacked.\n+\n+2000-07-11  Donn Terry  <donnte@microsoft.com>\n+\n+\t* cpplex.c (free_macro_args, save_token): Cast arg of free\n+\tand/or xrealloc to PTR.\n+\t(_cpp_init_input_buffer): Clear all fields of the base context.\n+\n Tue Jul 11 15:28:21 CDT 2000  Clinton Popetz  <cpopetz@cygnus.com>\n \n \t* gensupport.c (process_rtx): Make rtl checking stop"}, {"sha": "e8ee20e978e9389c735723628a173e76d229c26a", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=417f3e3a5efba3ed497f7971ab1254eaafadcadb", "patch": "@@ -392,7 +392,7 @@ lex (pfile, skip_evaluation)\n   const cpp_token *tok;\n \n  retry:\n-  tok = cpp_get_token (pfile);\n+  tok = _cpp_get_token (pfile);\n \n   switch (tok->type)\n     {"}, {"sha": "1f37898d621ba63c734fcc46a7336734f77eac51", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=417f3e3a5efba3ed497f7971ab1254eaafadcadb", "patch": "@@ -354,7 +354,7 @@ parse_define (pfile)\n   int prev_white = 0;\n \n   /* The first token after the macro's name.  */\n-  token = cpp_get_token (pfile);\n+  token = _cpp_get_token (pfile);\n \n   /* Constraint 6.10.3.5  */\n   if (is__va_args__ (pfile, token - 1))"}, {"sha": "e90f0e41dceb65936dc8557c1e6127ab7e822c15", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=417f3e3a5efba3ed497f7971ab1254eaafadcadb", "patch": "@@ -256,6 +256,7 @@ extern void _cpp_run_directive\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const char *, size_t));\n extern unsigned int _cpp_get_line\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t unsigned int *));\n+extern const cpp_token *_cpp_get_token PARAMS ((cpp_reader *));\n extern const cpp_token *_cpp_get_raw_token PARAMS ((cpp_reader *));\n extern void _cpp_push_token PARAMS ((cpp_reader *, const cpp_token*));\n extern const cpp_token *_cpp_glue_header_name PARAMS ((cpp_reader *));"}, {"sha": "a1e1ad2e95adc6effed4dbf58089f02a886f01a3", "filename": "gcc/cpplex.c", "status": "modified", "additions": 235, "deletions": 198, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=417f3e3a5efba3ed497f7971ab1254eaafadcadb", "patch": "@@ -417,7 +417,7 @@ _cpp_glue_header_name (pfile)\n \n   for (;;)\n     {\n-      t = cpp_get_token (pfile);\n+      t = _cpp_get_token (pfile);\n       if (t->type == CPP_GREATER || t->type == CPP_EOF)\n \tbreak;\n \n@@ -947,7 +947,7 @@ skip_whitespace (pfile, in_directive)\n }\n \n /* Parse (append) an identifier.  */\n-static inline const U_CHAR *\n+static const U_CHAR *\n parse_name (pfile, tok, cur, rlimit)\n      cpp_reader *pfile;\n      cpp_token *tok;\n@@ -1960,7 +1960,7 @@ struct cpp_context\n     const cpp_token **arg;\t/* Used for arg contexts only.  */\n   } u;\n \n-  /* Pushed token to be returned by next call to cpp_get_token.  */\n+  /* Pushed token to be returned by next call to get_raw_token.  */\n   const cpp_token *pushed_token;\n \n   struct macro_args *args;\t/* 0 for arguments and object-like macros.  */\n@@ -1985,13 +1985,9 @@ static const cpp_token *parse_arg PARAMS ((cpp_reader *, int, unsigned int,\n \t\t\t\t\t   macro_args *, unsigned int *));\n static int parse_args PARAMS ((cpp_reader *, cpp_hashnode *, macro_args *));\n static void save_token PARAMS ((macro_args *, const cpp_token *));\n-static const cpp_token *push_arg_context PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t  const cpp_token *));\n-static int do_pop_context PARAMS ((cpp_reader *));\n-static const cpp_token *pop_context PARAMS ((cpp_reader *));\n-static const cpp_token *push_macro_context PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t    cpp_hashnode *,\n-\t\t\t\t\t\t    const cpp_token *));\n+static int pop_context PARAMS ((cpp_reader *));\n+static int push_macro_context PARAMS ((cpp_reader *, const cpp_token *));\n+static void push_arg_context PARAMS ((cpp_reader *, const cpp_token *));\n static void free_macro_args PARAMS ((macro_args *));\n \n /* Free the storage allocated for macro arguments.  */\n@@ -2000,7 +1996,7 @@ free_macro_args (args)\n      macro_args *args;\n {\n   if (args->tokens)\n-    free (args->tokens);\n+    free ((PTR) args->tokens);\n   free (args->ends);\n   free (args);\n }\n@@ -2069,7 +2065,7 @@ is_macro_disabled (pfile, expansion, token)\n \n       prev_nme = pfile->no_expand_level;\n       pfile->no_expand_level = context - pfile->contexts;\n-      next = cpp_get_token (pfile);\n+      next = _cpp_get_token (pfile);\n       restore_macro_expansion (pfile, prev_nme);\n       if (next->type != CPP_OPEN_PAREN)\n \t{\n@@ -2096,7 +2092,8 @@ save_token (args, token)\n     {\n       args->capacity += args->capacity + 100;\n       args->tokens = (const cpp_token **)\n-\txrealloc (args->tokens, args->capacity * sizeof (const cpp_token *));\n+\txrealloc ((PTR) args->tokens,\n+\t\t  args->capacity * sizeof (const cpp_token *));\n     }\n   args->tokens[args->used++] = token;\n }\n@@ -2117,7 +2114,7 @@ parse_arg (pfile, var_args, paren_context, args, pcount)\n   \n   for (count = 0;; count++)\n     {\n-      token = cpp_get_token (pfile);\n+      token = _cpp_get_token (pfile);\n \n       switch (token->type)\n \t{\n@@ -2511,97 +2508,100 @@ maybe_paste_with_next (pfile, token)\n   cpp_context *context = CURRENT_CONTEXT (pfile);\n \n   /* Is this token on the LHS of ## ? */\n-  if (!((context->flags & CONTEXT_PASTEL) && context->posn == context->count)\n-      && !(token->flags & PASTE_LEFT))\n-    return token;\n \n-  /* Prevent recursion, and possibly pushing back more than one token.  */\n-  if (pfile->paste_level)\n-    return token;\n-  \n-  /* Suppress macro expansion for next token, but don't conflict with\n-     the other method of suppression.  If it is an argument, macro\n-     expansion within the argument will still occur.  */\n-  pfile->paste_level = pfile->cur_context;\n-  second = cpp_get_token (pfile);\n-  pfile->paste_level = 0;\n-\n-  /* Ignore placemarker argument tokens (cannot be from an empty macro\n-     since macros are not expanded).  */\n-  if (token->type == CPP_PLACEMARKER)\n-     pasted = duplicate_token (pfile, second);\n-  else if (second->type == CPP_PLACEMARKER)\n+  while ((token->flags & PASTE_LEFT)\n+\t || ((context->flags & CONTEXT_PASTEL)\n+\t     && context->posn == context->count))\n     {\n-      cpp_context *mac_context = CURRENT_CONTEXT (pfile) - 1;\n-      /* GCC has special extended semantics for a ## b where b is a\n-\t varargs parameter: a disappears if b consists of no tokens.\n-\t This extension is deprecated.  */\n-      if ((mac_context->u.list->flags & GNU_REST_ARGS)\n-\t  && (mac_context->u.list->tokens[mac_context->posn - 1].val.aux + 1\n-\t      == (unsigned) mac_context->u.list->paramc))\n+      /* Suppress macro expansion for next token, but don't conflict\n+\t with the other method of suppression.  If it is an argument,\n+\t macro expansion within the argument will still occur.  */\n+      pfile->paste_level = pfile->cur_context;\n+      second = _cpp_get_token (pfile);\n+      pfile->paste_level = 0;\n+\n+      /* Ignore placemarker argument tokens (cannot be from an empty\n+\t macro since macros are not expanded).  */\n+      if (token->type == CPP_PLACEMARKER)\n+\tpasted = duplicate_token (pfile, second);\n+      else if (second->type == CPP_PLACEMARKER)\n \t{\n-\t  cpp_warning (pfile, \"deprecated GNU ## extension used\");\n-\t  pasted = duplicate_token (pfile, second);\n+\t  cpp_context *mac_context = CURRENT_CONTEXT (pfile) - 1;\n+\t  /* GCC has special extended semantics for a ## b where b is\n+\t     a varargs parameter: a disappears if b consists of no\n+\t     tokens.  This extension is deprecated.  */\n+\t  if ((mac_context->u.list->flags & GNU_REST_ARGS)\n+\t      && (mac_context->u.list->tokens[mac_context->posn-1].val.aux + 1\n+\t\t  == (unsigned) mac_context->u.list->paramc))\n+\t    {\n+\t      cpp_warning (pfile, \"deprecated GNU ## extension used\");\n+\t      pasted = duplicate_token (pfile, second);\n+\t    }\n+\t  else\n+\t    pasted = duplicate_token (pfile, token);\n \t}\n       else\n-\tpasted = duplicate_token (pfile, token);\n-    }\n-  else\n-    {\n-      int digraph = 0;\n-      enum cpp_ttype type = can_paste (pfile, token, second, &digraph);\n-\n-      if (type == CPP_EOF)\n \t{\n-\t  if (CPP_OPTION (pfile, warn_paste))\n-\t    cpp_warning (pfile,\n-\t\t\t \"pasting would not give a valid preprocessing token\");\n-\t  _cpp_push_token (pfile, second);\n-\t  return token;\n-\t}\n+\t  int digraph = 0;\n+\t  enum cpp_ttype type = can_paste (pfile, token, second, &digraph);\n \n-      if (type == CPP_NAME || type == CPP_NUMBER)\n-\t{\n-\t  /* Join spellings.  */\n-\t  U_CHAR *buf, *end;\n+\t  if (type == CPP_EOF)\n+\t    {\n+\t      if (CPP_OPTION (pfile, warn_paste))\n+\t\tcpp_warning (pfile,\n+\t\t\t\"pasting would not give a valid preprocessing token\");\n+\t      _cpp_push_token (pfile, second);\n+\t      return token;\n+\t    }\n \n-\t  pasted = get_temp_token (pfile);\n-\t  buf = (U_CHAR *) alloca (TOKEN_LEN (token) + TOKEN_LEN (second));\n-\t  end = spell_token (pfile, token, buf);\n-\t  end = spell_token (pfile, second, end);\n-\t  *end = '\\0';\n+\t  if (type == CPP_NAME || type == CPP_NUMBER)\n+\t    {\n+\t      /* Join spellings.  */\n+\t      U_CHAR *buf, *end;\n+\n+\t      pasted = get_temp_token (pfile);\n+\t      buf = (U_CHAR *) alloca (TOKEN_LEN (token) + TOKEN_LEN (second));\n+\t      end = spell_token (pfile, token, buf);\n+\t      end = spell_token (pfile, second, end);\n+\t      *end = '\\0';\n \n-\t  if (type == CPP_NAME)\n-\t    pasted->val.node = cpp_lookup (pfile, buf, end - buf);\n+\t      if (type == CPP_NAME)\n+\t\tpasted->val.node = cpp_lookup (pfile, buf, end - buf);\n+\t      else\n+\t\t{\n+\t\t  pasted->val.str.text = uxstrdup (buf);\n+\t\t  pasted->val.str.len = end - buf;\n+\t\t}\n+\t    }\n+\t  else if (type == CPP_WCHAR || type == CPP_WSTRING)\n+\t    pasted = duplicate_token (pfile, second);\n \t  else\n \t    {\n-\t      pasted->val.str.text = uxstrdup (buf);\n-\t      pasted->val.str.len = end - buf;\n+\t      pasted = get_temp_token (pfile);\n+\t      pasted->val.integer = 0;\n \t    }\n-\t}\n-      else if (type == CPP_WCHAR || type == CPP_WSTRING)\n-\tpasted = duplicate_token (pfile, second);\n-      else\n-\t{\n-\t  pasted = get_temp_token (pfile);\n-\t  pasted->val.integer = 0;\n+\n+\t  pasted->type = type;\n+\t  pasted->flags = digraph ? DIGRAPH : 0;\n \t}\n \n-      pasted->type = type;\n-      pasted->flags = digraph ? DIGRAPH : 0;\n+      /* The pasted token gets the whitespace flags and position of the\n+\t first token, the PASTE_LEFT flag of the second token, plus the\n+\t PASTED flag to indicate it is the result of a paste.  However, we\n+\t want to preserve the DIGRAPH flag.  */\n+      pasted->flags &= ~(PREV_WHITE | BOL | PASTE_LEFT);\n+      pasted->flags |= ((token->flags & (PREV_WHITE | BOL))\n+\t\t\t| (second->flags & PASTE_LEFT) | PASTED);\n+      pasted->col = token->col;\n+      pasted->line = token->line;\n+\n+      /* See if there is another token to be pasted onto the one we just\n+\t constructed.  */\n+      token = pasted;\n+      context = CURRENT_CONTEXT (pfile);\n+      /* and loop */\n     }\n-\n-  /* The pasted token gets the whitespace flags and position of the\n-     first token, the PASTE_LEFT flag of the second token, plus the\n-     PASTED flag to indicate it is the result of a paste.  However, we\n-     want to preserve the DIGRAPH flag.  */\n-  pasted->flags &= ~(PREV_WHITE | BOL | PASTE_LEFT);\n-  pasted->flags |= ((token->flags & (PREV_WHITE | BOL))\n-\t\t    | (second->flags & PASTE_LEFT) | PASTED);\n-  pasted->col = token->col;\n-  pasted->line = token->line;\n-\n-  return maybe_paste_with_next (pfile, pasted);\n+  return token;\n }\n \n /* Convert a token sequence to a single string token according to the\n@@ -2617,13 +2617,14 @@ stringify_arg (pfile, token)\n   unsigned int prev_value, backslash_count = 0;\n   unsigned int buf_used = 0, whitespace = 0, buf_cap = INIT_SIZE;\n \n+  push_arg_context (pfile, token);\n   prev_value  = prevent_macro_expansion (pfile);\n   main_buf = (unsigned char *) xmalloc (buf_cap);\n \n   result = get_temp_token (pfile);\n   ASSIGN_FLAGS_AND_POS (result, token);\n \n-  for (; (token = cpp_get_token (pfile))->type != CPP_EOF; )\n+  for (; (token = _cpp_get_token (pfile))->type != CPP_EOF; )\n     {\n       int escape;\n       unsigned char *buf;\n@@ -2690,21 +2691,15 @@ expand_context_stack (pfile)\n \n /* Push the context of macro NODE onto the context stack.  TOKEN is\n    the CPP_NAME token invoking the macro.  */\n-static const cpp_token *\n-push_macro_context (pfile, node, token)\n+static int\n+push_macro_context (pfile, token)\n      cpp_reader *pfile;\n-     cpp_hashnode *node;\n      const cpp_token *token;\n {\n   unsigned char orig_flags;\n   macro_args *args;\n   cpp_context *context;\n-\n-  if (pfile->cur_context > CPP_STACK_MAX)\n-    {\n-      cpp_error (pfile, \"infinite macro recursion invoking '%s'\", node->name);\n-      return token;\n-    }\n+  cpp_hashnode *node = token->val.node;\n \n   /* Token's flags may change when parsing args containing a nested\n      invocation of this macro.  */\n@@ -2731,7 +2726,7 @@ push_macro_context (pfile, node, token)\n       if (error)\n \t{\n \t  free_macro_args (args);\n-\t  return token;\n+\t  return 1;\n \t}\n     }\n \n@@ -2753,12 +2748,12 @@ push_macro_context (pfile, node, token)\n      be one, empty macros are a single placemarker token.  */\n   MODIFY_FLAGS_AND_POS (&context->u.list->tokens[0], token, orig_flags);\n \n-  return cpp_get_token (pfile);\n+  return 0;\n }\n \n /* Push an argument to the current macro onto the context stack.\n    TOKEN is the MACRO_ARG token representing the argument expansion.  */\n-static const cpp_token *\n+static void\n push_arg_context (pfile, token)\n      cpp_reader *pfile;\n      const cpp_token *token;\n@@ -2792,15 +2787,10 @@ push_arg_context (pfile, token)\n \t\t\t  token->flags & (PREV_WHITE | BOL));\n   }\n \n-  if (token->flags & STRINGIFY_ARG)\n-    return stringify_arg (pfile, token);\n-\n   if (token->flags & PASTE_LEFT)\n     context->flags |= CONTEXT_PASTEL;\n   if (pfile->paste_level)\n     context->flags |= CONTEXT_PASTER;\n-\n-  return get_raw_token (pfile);\n }\n \n /* \"Unget\" a token.  It is effectively inserted in the token queue and\n@@ -2859,58 +2849,92 @@ cpp_get_token (pfile)\n      cpp_reader *pfile;\n {\n   const cpp_token *token;\n-  cpp_hashnode *node;\n-\n-  /* Loop till we hit a non-directive, non-skipped, non-placemarker token.  */\n+  /* Loop till we hit a non-directive, non-placemarker token.  */\n   for (;;)\n     {\n-      token = get_raw_token (pfile);\n-      if (token->flags & BOL && token->type == CPP_HASH\n+      token = _cpp_get_token (pfile);\n+\n+      if (token->type == CPP_PLACEMARKER)\n+\tcontinue;\n+\n+      if (token->type == CPP_HASH && token->flags & BOL\n \t  && pfile->token_list.directive)\n \t{\n \t  process_directive (pfile, token);\n \t  continue;\n \t}\n \n+      return token;\n+    }\n+}\n+\n+/* The internal interface to return the next token.  There are two\n+   differences between the internal and external interfaces: the\n+   internal interface may return a PLACEMARKER token, and it does not\n+   process directives.  */\n+const cpp_token *\n+_cpp_get_token (pfile)\n+     cpp_reader *pfile;\n+{\n+  const cpp_token *token;\n+  cpp_hashnode *node;\n+\n+  /* Loop until we hit a non-macro token.  */\n+  for (;;)\n+    {\n+      token = get_raw_token (pfile);\n+\n       /* Short circuit EOF. */\n       if (token->type == CPP_EOF)\n \treturn token;\n-      \n-      if (pfile->skipping && ! pfile->token_list.directive)\n+\n+      /* If we are skipping... */\n+      if (pfile->skipping)\n \t{\n+\t  /* we still have to process directives,  */\n+\t  if (pfile->token_list.directive)\n+\t    return token;\n+\n+\t  /* but everything else is ignored.  */\n \t  _cpp_skip_rest_of_line (pfile);\n \t  continue;\n \t}\n-      break;\n-    }\n \n-  /* If there's a potential control macro and we get here, then that\n-     #ifndef didn't cover the entire file and its argument shouldn't\n-     be taken as a control macro.  */\n-  pfile->potential_control_macro = 0;\n+      /* If there's a potential control macro and we get here, then that\n+\t #ifndef didn't cover the entire file and its argument shouldn't\n+\t be taken as a control macro.  */\n+      pfile->potential_control_macro = 0;\n \n-  token = maybe_paste_with_next (pfile, token);\n+      /* See if there's a token to paste with this one.  */\n+      if (!pfile->paste_level)\n+\ttoken = maybe_paste_with_next (pfile, token);\n \n-  if (token->type != CPP_NAME)\n-    return token;\n+      /* If it isn't a macro, return it now.  */\n+      if (token->type != CPP_NAME\n+\t  || token->val.node->type == T_VOID)\n+\treturn token;\n \n-  /* Is macro expansion disabled in general?  */\n-  if (pfile->no_expand_level == pfile->cur_context || pfile->paste_level)\n-    return token;\n+      /* Is macro expansion disabled in general?  */\n+      if (pfile->no_expand_level == pfile->cur_context || pfile->paste_level)\n+\treturn token;\n  \n-  node = token->val.node;\n-  if (node->type == T_VOID)\n-    return token;\n+      node = token->val.node;\n+      if (node->type != T_MACRO)\n+\treturn special_symbol (pfile, node, token);\n \n-  if (node->type == T_MACRO)\n-    {\n       if (is_macro_disabled (pfile, node->value.expansion, token))\n \treturn token;\n \n-      return push_macro_context (pfile, node, token);\n+      if (pfile->cur_context > CPP_STACK_MAX)\n+\t{\n+\t  cpp_error (pfile, \"macros nested too deep invoking '%s'\", node->name);\n+\t  return token;\n+\t}\n+\n+      if (push_macro_context (pfile, token))\n+\treturn token;\n+      /* else loop */\n     }\n-  else\n-    return special_symbol (pfile, node, token);\n }\n \n /* Returns the next raw token, i.e. without performing macro\n@@ -2920,33 +2944,45 @@ get_raw_token (pfile)\n      cpp_reader *pfile;\n {\n   const cpp_token *result;\n-  cpp_context *context = CURRENT_CONTEXT (pfile);\n+  cpp_context *context;\n \n-  if (context->pushed_token)\n-    {\n-      result = context->pushed_token;\n-      context->pushed_token = 0;\n-    }\n-  else if (context->posn == context->count)\n-    result = pop_context (pfile);\n-  else\n+  for (;;)\n     {\n-      if (IS_ARG_CONTEXT (context))\n+      context = CURRENT_CONTEXT (pfile);\n+      if (context->pushed_token)\n \t{\n-\t  result = context->u.arg[context->posn++];\n-\t  if (result == 0)\n+\t  result = context->pushed_token;\n+\t  context->pushed_token = 0;\n+\t}\n+      else if (context->posn == context->count)\n+\t{\n+\t  if (pop_context (pfile))\n+\t    return &eof_token;\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  if (IS_ARG_CONTEXT (context))\n \t    {\n-\t      context->flags ^= CONTEXT_RAW;\n \t      result = context->u.arg[context->posn++];\n+\t      if (result == 0)\n+\t\t{\n+\t\t  context->flags ^= CONTEXT_RAW;\n+\t\t  result = context->u.arg[context->posn++];\n+\t\t}\n+\t      return result;\t/* Cannot be a CPP_MACRO_ARG */\n \t    }\n-\t  return result;\t/* Cannot be a CPP_MACRO_ARG */\n+\t  result = &context->u.list->tokens[context->posn++];\n \t}\n-      result = &context->u.list->tokens[context->posn++];\n-    }\n \n-  if (result->type == CPP_MACRO_ARG)\n-    result = push_arg_context (pfile, result);\n-  return result;\n+      if (result->type != CPP_MACRO_ARG)\n+\treturn result;\n+\n+      if (result->flags & STRINGIFY_ARG)\n+\treturn stringify_arg (pfile, result);\n+\n+      push_arg_context (pfile, result);\n+    }\n }\n \n /* Internal interface to get the token without macro expanding.  */\n@@ -2955,7 +2991,7 @@ _cpp_get_raw_token (pfile)\n      cpp_reader *pfile;\n {\n   int prev_nme = prevent_macro_expansion (pfile);\n-  const cpp_token *result = cpp_get_token (pfile);\n+  const cpp_token *result = _cpp_get_token (pfile);\n   restore_macro_expansion (pfile, prev_nme);\n   return result;\n }\n@@ -2973,16 +3009,6 @@ lex_next (pfile, clear)\n   const cpp_token *old_list = list->tokens;\n   unsigned int old_used = list->tokens_used;\n \n-  /* If we are currently processing a directive, do not advance.  6.10\n-     paragraph 2: A new-line character ends the directive even if it\n-     occurs within what would otherwise be an invocation of a\n-     function-like macro.\n-\n-     It is possible that clear == 1 too; e.g. \"#if funlike_macro (\"\n-     since parse_args swallowed the directive's EOF.  */\n-  if (list->directive)\n-    return 1;\n-\n   if (clear)\n     {\n       /* Release all temporary tokens.  */\n@@ -3034,18 +3060,27 @@ lex_next (pfile, clear)\n   return 0;\n }\n \n-/* Pops a context of the context stack.  If we're at the bottom, lexes\n-   the next logical line.  Returns 1 if we're at the end of the\n+/* Pops a context off the context stack.  If we're at the bottom, lexes\n+   the next logical line.  Returns EOF if we're at the end of the\n    argument list to the # operator, or if it is illegal to \"overflow\"\n    into the rest of the file (e.g. 6.10.3.1.1).  */\n static int\n-do_pop_context (pfile)\n+pop_context (pfile)\n      cpp_reader *pfile;\n {\n   cpp_context *context;\n \n   if (pfile->cur_context == 0)\n-    return lex_next (pfile, pfile->no_expand_level == UINT_MAX);\n+    {\n+      /* If we are currently processing a directive, do not advance.  6.10\n+\t paragraph 2: A new-line character ends the directive even if it\n+\t occurs within what would otherwise be an invocation of a\n+\t function-like macro.  */\n+      if (pfile->token_list.directive)\n+\treturn 1;\n+\n+      return lex_next (pfile, pfile->no_expand_level == UINT_MAX);\n+    }\n \n   /* Argument contexts, when parsing args or handling # operator\n      return CPP_EOF at the end.  */\n@@ -3064,16 +3099,6 @@ do_pop_context (pfile)\n   return 0;\n }\n \n-/* Move down the context stack, and return the next raw token.  */\n-static const cpp_token *\n-pop_context (pfile)\n-     cpp_reader *pfile;\n-{\n-  if (do_pop_context (pfile))\n-    return &eof_token;\n-  return get_raw_token (pfile);\n-}\n-\n /* Turn off macro expansion at the current context level.  */\n static unsigned int\n prevent_macro_expansion (pfile)\n@@ -3286,18 +3311,26 @@ void\n _cpp_init_input_buffer (pfile)\n      cpp_reader *pfile;\n {\n+  cpp_context *base;\n+\n   init_trigraph_map ();\n+  _cpp_init_toklist (&pfile->token_list, DUMMY_TOKEN);\n+  pfile->no_expand_level = UINT_MAX;\n   pfile->context_cap = 20;\n-  pfile->contexts = (cpp_context *)\n-    xmalloc (pfile->context_cap * sizeof (cpp_context));\n   pfile->cur_context = 0;\n-  pfile->contexts[0].u.list = &pfile->token_list;\n \n-  pfile->contexts[0].posn = 0;\n-  pfile->contexts[0].count = 0;\n-  pfile->no_expand_level = UINT_MAX;\n+  pfile->contexts = (cpp_context *)\n+    xmalloc (pfile->context_cap * sizeof (cpp_context));\n \n-  _cpp_init_toklist (&pfile->token_list, DUMMY_TOKEN);\n+  /* Clear the base context.  */\n+  base = &pfile->contexts[0];\n+  base->u.list = &pfile->token_list;\n+  base->posn = 0;\n+  base->count = 0;\n+  base->args = 0;\n+  base->level = 0;\n+  base->flags = 0;\n+  base->pushed_token = 0;\n }\n \n /* Moves to the end of the directive line, popping contexts as\n@@ -3306,17 +3339,20 @@ void\n _cpp_skip_rest_of_line (pfile)\n      cpp_reader *pfile;\n {\n-  /* Get to base context.  Clear parsing args and each contexts flags,\n-     since these can cause pop_context to return without popping.  */\n-  pfile->no_expand_level = UINT_MAX;\n-  while (pfile->cur_context != 0)\n-    {\n-      pfile->contexts[pfile->cur_context].flags = 0;\n-      do_pop_context (pfile);\n-    }\n+  /* Discard all stacked contexts.  */\n+  int i;\n+  for (i = pfile->cur_context; i > 0; i--)\n+    if (pfile->contexts[i].args)\n+      free_macro_args (pfile->contexts[i].args);\n+\n+  if (pfile->no_expand_level <= pfile->cur_context)\n+    pfile->no_expand_level = 0;\n+  pfile->cur_context = 0;\n \n-  pfile->contexts[pfile->cur_context].count = 0;\n-  pfile->contexts[pfile->cur_context].posn = 0;\n+  /* Clear the base context, and clear the directive pointer so that\n+     get_raw_token will advance to the next line.  */\n+  pfile->contexts[0].count = 0;\n+  pfile->contexts[0].posn = 0;\n   pfile->token_list.directive = 0;\n }\n \n@@ -3332,8 +3368,9 @@ _cpp_run_directive (pfile, dir, buf, count)\n   if (cpp_push_buffer (pfile, (const U_CHAR *)buf, count) != NULL)\n     {\n       unsigned int prev_lvl = 0;\n-      /* scan the line now, else prevent_macro_expansion won't work */\n-      do_pop_context (pfile);\n+\n+      /* Scan the line now, else prevent_macro_expansion won't work.  */\n+      lex_next (pfile, 1);\n       if (! (dir->flags & EXPAND))\n \tprev_lvl = prevent_macro_expansion (pfile);\n "}, {"sha": "71859d76ca04665f00afece63cda0bee5403793a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417f3e3a5efba3ed497f7971ab1254eaafadcadb/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=417f3e3a5efba3ed497f7971ab1254eaafadcadb", "patch": "@@ -250,7 +250,7 @@ get_define_node (pfile)\n   const cpp_token *token;\n \n   /* Skip any -C comments.  */\n-  while ((token = cpp_get_token (pfile))->type == CPP_COMMENT)\n+  while ((token = _cpp_get_token (pfile))->type == CPP_COMMENT)\n     ;\n \n   if (token->type != CPP_NAME)\n@@ -307,7 +307,7 @@ do_undef (pfile)\n {\n   cpp_hashnode *node = get_define_node (pfile);  \n \n-  if (cpp_get_token (pfile)->type != CPP_EOF)\n+  if (_cpp_get_token (pfile)->type != CPP_EOF)\n     cpp_pedwarn (pfile, \"junk on line after #undef\");\n \n   /* 6.10.3.5 paragraph 2: [#undef] is ignored if the specified identifier\n@@ -343,7 +343,7 @@ parse_include (pfile, dir, trail, strp, lenp, abp)\n      unsigned int *lenp;\n      int *abp;\n {\n-  const cpp_token *name = cpp_get_token (pfile);\n+  const cpp_token *name = _cpp_get_token (pfile);\n \n   if (name->type != CPP_STRING && name->type != CPP_HEADER_NAME)\n     {\n@@ -361,7 +361,7 @@ parse_include (pfile, dir, trail, strp, lenp, abp)\n       return 1;\n     }\n \n-  if (!trail && cpp_get_token (pfile)->type != CPP_EOF)\n+  if (!trail && _cpp_get_token (pfile)->type != CPP_EOF)\n     cpp_error (pfile, \"junk at end of #%s\", dir);\n \n   *lenp = name->val.str.len;\n@@ -459,7 +459,7 @@ read_line_number (pfile, num)\n      cpp_reader *pfile;\n      int *num;\n {\n-  const cpp_token *tok = cpp_get_token (pfile);\n+  const cpp_token *tok = _cpp_get_token (pfile);\n   enum cpp_ttype type = tok->type;\n   const U_CHAR *p = tok->val.str.text;\n   unsigned int len = tok->val.str.len;\n@@ -519,7 +519,7 @@ do_line (pfile)\n   unsigned int len;\n   const cpp_token *tok;\n \n-  tok = cpp_get_token (pfile);\n+  tok = _cpp_get_token (pfile);\n   type = tok->type;\n   str = tok->val.str.text;\n   len = tok->val.str.len;\n@@ -535,7 +535,7 @@ do_line (pfile)\n \n   old_lineno = ip->lineno;\n   ip->lineno = new_lineno;\n-  tok = cpp_get_token (pfile);\n+  tok = _cpp_get_token (pfile);\n   type = tok->type;\n   str = tok->val.str.text;\n   len = tok->val.str.len;\n@@ -645,9 +645,9 @@ do_ident (pfile)\n      cpp_reader *pfile;\n {\n   /* Next token should be a string constant.  */\n-  if (cpp_get_token (pfile)->type == CPP_STRING)\n+  if (_cpp_get_token (pfile)->type == CPP_STRING)\n     /* And then a newline.  */\n-    if (cpp_get_token (pfile)->type == CPP_EOF)\n+    if (_cpp_get_token (pfile)->type == CPP_EOF)\n       {\n \t/* Good - ship it.  */\n \tpass_thru_directive (pfile);\n@@ -725,7 +725,7 @@ do_pragma (pfile)\n   const cpp_token *tok;\n   int pop;\n \n-  tok = cpp_get_token (pfile);\n+  tok = _cpp_get_token (pfile);\n   if (tok->type == CPP_EOF)\n     return 0;\n   else if (tok->type != CPP_NAME)\n@@ -746,7 +746,7 @@ do_pragma_gcc (pfile)\n {\n   const cpp_token *tok;\n \n-  tok = cpp_get_token (pfile);\n+  tok = _cpp_get_token (pfile);\n   if (tok->type == CPP_EOF)\n     return 1;\n   else if (tok->type != CPP_NAME)\n@@ -780,13 +780,13 @@ do_pragma_implementation (pfile)\n {\n   /* Be quiet about `#pragma implementation' for a file only if it hasn't\n      been included yet.  */\n-  const cpp_token *tok = cpp_get_token (pfile);\n+  const cpp_token *tok = _cpp_get_token (pfile);\n   char *copy;\n \n   if (tok->type == CPP_EOF)\n     return 0;\n   else if (tok->type != CPP_STRING\n-\t   || cpp_get_token (pfile)->type != CPP_EOF)\n+\t   || _cpp_get_token (pfile)->type != CPP_EOF)\n     {\n       cpp_error (pfile, \"malformed #pragma implementation\");\n       return 1;\n@@ -822,7 +822,7 @@ do_pragma_poison (pfile)\n \n   for (;;)\n     {\n-      tok = cpp_get_token (pfile);\n+      tok = _cpp_get_token (pfile);\n       if (tok->type == CPP_EOF)\n \tbreak;\n       if (tok->type != CPP_NAME)\n@@ -887,7 +887,7 @@ do_pragma_dependency (pfile)\n     cpp_warning (pfile, \"cannot find source %c%s%c\", left, name, right);\n   else if (ordering > 0)\n     {\n-      const cpp_token *msg = cpp_get_token (pfile);\n+      const cpp_token *msg = _cpp_get_token (pfile);\n       \n       cpp_warning (pfile, \"current file is older than %c%s%c\",\n \t\t   left, name, right);\n@@ -974,7 +974,7 @@ parse_ifdef (pfile, name)\n   enum cpp_ttype type;\n   const cpp_hashnode *node = 0;\n \n-  const cpp_token *token = cpp_get_token (pfile);\n+  const cpp_token *token = _cpp_get_token (pfile);\n   type = token->type;\n \n   if (!CPP_TRADITIONAL (pfile))\n@@ -983,7 +983,7 @@ parse_ifdef (pfile, name)\n \tcpp_pedwarn (pfile, \"#%s with no argument\", name);\n       else if (type != CPP_NAME)\n \tcpp_pedwarn (pfile, \"#%s with invalid argument\", name);\n-      else if (cpp_get_token (pfile)->type != CPP_EOF)\n+      else if (_cpp_get_token (pfile)->type != CPP_EOF)\n \tcpp_pedwarn (pfile, \"garbage at end of #%s\", name);\n     }\n \n@@ -1186,7 +1186,7 @@ validate_else (pfile, directive)\n      cpp_reader *pfile;\n      const U_CHAR *directive;\n {\n-  if (CPP_PEDANTIC (pfile) && cpp_get_token (pfile)->type != CPP_EOF)\n+  if (CPP_PEDANTIC (pfile) && _cpp_get_token (pfile)->type != CPP_EOF)\n     cpp_pedwarn (pfile, \"ISO C forbids text after #%s\", directive);\n }\n \n@@ -1515,9 +1515,14 @@ cpp_push_buffer (pfile, buffer, length)\n   cpp_buffer *new;\n   if (++pfile->buffer_stack_depth == CPP_STACK_MAX)\n     {\n-      cpp_fatal (pfile, \"#include recursion too deep\");\n+      cpp_fatal (pfile, \"#include nested too deep\");\n       return NULL;\n     }\n+  if (pfile->cur_context > 0)\n+    {\n+      cpp_ice (pfile, \"buffer pushed with contexts stacked\");\n+      _cpp_skip_rest_of_line (pfile);\n+    }\n \n   new = xobnew (pfile->buffer_ob, cpp_buffer);\n   memset (new, 0, sizeof (cpp_buffer));"}]}