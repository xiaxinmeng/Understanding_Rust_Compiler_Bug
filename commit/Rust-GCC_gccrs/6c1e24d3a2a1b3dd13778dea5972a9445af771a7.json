{"sha": "6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMxZTI0ZDNhMmExYjNkZDEzNzc4ZGVhNTk3MmE5NDQ1YWY3NzFhNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-24T14:27:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-24T14:27:57Z"}, "message": "[multiple changes]\n\n2003-11-24  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* Makefile.in:\n\tUse 5zintman.ads for VxWorks targets. This file avoid confusion between\n\tsignals and interrupts.\n\n\t* 5zintman.ads: New File.\n\n\t* 5zintman.adb: Replace Exception_Interrupts by Exception_Signals, and\n\tadd exception signals to the set of unmasked signals.\n\n\t* 5ztaprop.adb:\n\tUse Abort_Task_Signal instead of Abort_Task_Interrupt to avoid confusion\n\tbetween signals and interrupts.\n\tAdd to Unblocked_Signal_Mask the set of signals that are in\n\tKeep_Unmasked.\n\n\t* 7sinmaop.adb:\n\tAdding a check to see whether the Interrupt_ID we want to unmask is in\n\tthe range of Keep_Unmasked (in procedure Interrupt_Self_Process). The\n\treason is that the index type of the Keep_Unmasked array is not always\n\tInterrupt_ID; it may be a subtype of Interrupt_ID.\n\n2003-11-24  Gary Dismukes  <dismukes@gnat.com>\n\n\t* exp_util.adb:\n\t(Remove_Side_Effects): Condition constantness of object created for a\n\t an unchecked type conversion on the constantness of the expression\n\t to ensure the correct value for 'Constrained when passing components\n\t of view-converted class-wide objects.\n\n2003-11-24  Robert Dewar  <dewar@gnat.com>\n\n\t* par-load.adb (Load): Improve handling of misspelled and missing units\n\tRemoves several cases of compilation abandoned messages\n\n\t* lib.adb: (Remove_Unit): New procedure\n\n\t* lib.ads: (Remove_Unit): New procedure\n\n\t* lib-load.adb: Minor reformatting\n\n2003-11-24  Vincent Celier  <celier@gnat.com>\n\n\t* make.adb:\n\t(Gnatmake, Initialize): Call Usage instead of Makeusg directly\n\t(Marking_Label): Label to mark processed source files. Incremented for\n\teach executable.\n\t(Gnatmake): Increase Marking_Labet for each executable\n\t(Is_Marked): Compare against marking label\n\t(Mark): Mark with marking label\n\n2003-11-24  Jerome Guitton  <guitton@act-europe.fr>\n\n\t* s-thread.ads:\n\tMove the declaration of the TSD for System.Threads to System.Soft_Links.\n\tAdd some comments.\n\n\t* Makefile.in: Added target pair for s-thread.adb for cert runtime.\n\t(rts-cert): build a single relocatable object for the run-time lib.\n\tFix perms.\n\n2003-11-24  Vasiliy Fofanov  <fofanov@act-europe.fr>\n\n\t* Make-lang.in:\n\tUse gnatls rather than gcc to obtain the location of GNAT RTL for\n\tcrosstools build.\n\n2003-11-24  Sergey Rybin  <rybin@act-europe.fr>\n\n\t* opt.adb (Tree_Write): Gnat_Version_String is now a function, so we\n\tcan not use it as before (that is, as a variable) when dumping it into\n\tthe tree file. Add a local variable to store the result of this\n\tfunction and to be used as the string to be written into the tree.\n\n\t* scn.adb (Initialize_Scanner): Add comments explaining the recent\n\tchanges.\n\n\t* sinput.adb (Source_First, Source_Last): In case of\n\tInternal_Source_File, replace returning attributes of\n\tInternal_Source_Ptr (which is wrong) with returning attributes of\n\tInternal_Source.\n\n2003-11-24  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch3.adb:\n\t(New_Concatenation_Op): Proper name for New_Binary_Operator, only\n\tused for implicit concatenation operators.\n\tCode cleanup.\n\n\t* sem_elab.adb:\n\t(Check_Elab_Call): Set No_Elaboration_Check appropriately on calls in\n\ttask bodies that are in the scope of a Suppress pragma.\n\t(Check_A Call): Use the flag to prevent spurious elaboration checks.\n\n\t* sinfo.ads, sinfo.adb:\n\tNew flag No_Elaboration_Check on function/procedure calls, to properly\n\tsuppress checks on calls in task bodies that are within a local suppress\n\tpragma.\n\n\t* exp_ch4.adb:\n\t(Expand_Concatenate_Other): Use the proper integer type for the\n\texpression for the upper bound, to avoid universal_integer computations\n\twhen possible.\n\nFrom-SVN: r73874", "tree": {"sha": "0a12ec5ac120be7136240c0da374db97ce907515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a12ec5ac120be7136240c0da374db97ce907515"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/comments", "author": null, "committer": null, "parents": [{"sha": "8653a1eda8c17ed13c49bdcadec52705e93a9432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8653a1eda8c17ed13c49bdcadec52705e93a9432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8653a1eda8c17ed13c49bdcadec52705e93a9432"}], "stats": {"total": 694, "additions": 554, "deletions": 140}, "files": [{"sha": "fd9b86f242b1373f95738f0d0d2e684ed3db562d", "filename": "gcc/ada/5zintman.adb", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F5zintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F5zintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zintman.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,22 +62,27 @@ package body System.Interrupt_Management is\n    use System.OS_Interface;\n    use type Interfaces.C.int;\n \n-   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n-   Exception_Interrupts : constant Interrupt_List (1 .. 4) :=\n-     (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n+   type Signal_List is array (Signal_ID range <>) of Signal_ID;\n+   Exception_Signals : constant Signal_List (1 .. 4) :=\n+                         (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n \n-   --  Keep these variables global so that they are initialized only once.\n+   --  Keep these variables global so that they are initialized only once\n+   --  What are \"these variables\" ???, I see only one\n \n    Exception_Action : aliased struct_sigaction;\n \n-   ----------------------\n-   -- Notify_Exception --\n-   ----------------------\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n \n    procedure Notify_Exception (signo : Signal);\n    --  Identify the Ada exception to be raised using\n    --  the information when the system received a synchronous signal.\n \n+   ----------------------\n+   -- Notify_Exception --\n+   ----------------------\n+\n    procedure Notify_Exception (signo : Signal) is\n       Mask   : aliased sigset_t;\n       Result : int;\n@@ -126,10 +131,10 @@ package body System.Interrupt_Management is\n       old_act : aliased struct_sigaction;\n \n    begin\n-      for J in Exception_Interrupts'Range loop\n+      for J in Exception_Signals'Range loop\n          Result :=\n            sigaction\n-             (Signal (Exception_Interrupts (J)), Exception_Action'Access,\n+             (Signal (Exception_Signals (J)), Exception_Action'Access,\n               old_act'Unchecked_Access);\n          pragma Assert (Result = 0);\n       end loop;\n@@ -160,15 +165,15 @@ begin\n       --  Change this if you want to use another signal for task abort.\n       --  SIGTERM might be a good one.\n \n-      Abort_Task_Interrupt := SIGABRT;\n+      Abort_Task_Signal := SIGABRT;\n \n       Exception_Action.sa_handler := Notify_Exception'Address;\n       Exception_Action.sa_flags := SA_ONSTACK;\n       Result := sigemptyset (mask'Access);\n       pragma Assert (Result = 0);\n \n-      for J in Exception_Interrupts'Range loop\n-         Result := sigaddset (mask'Access, Signal (Exception_Interrupts (J)));\n+      for J in Exception_Signals'Range loop\n+         Result := sigaddset (mask'Access, Signal (Exception_Signals (J)));\n          pragma Assert (Result = 0);\n       end loop;\n \n@@ -185,5 +190,15 @@ begin\n             Reserve (J) := True;\n          end if;\n       end loop;\n+\n+      --  Add exception signals to the set of unmasked signals\n+\n+      for J in Exception_Signals'Range loop\n+         Keep_Unmasked (Exception_Signals (J)) := True;\n+      end loop;\n+\n+      --  The abort signal must also be unmasked\n+\n+      Keep_Unmasked (Abort_Task_Signal) := True;\n    end;\n end System.Interrupt_Management;"}, {"sha": "b0a4c3c5bdaa98cbe7c23d20b8f038141f88fb11", "filename": "gcc/ada/5zintman.ads", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F5zintman.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F5zintman.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zintman.ads?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -0,0 +1,123 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--            S Y S T E M . I N T E R R U P T _ M A N A G E M E N T         --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the VxWorks version of this package.\n+\n+--  This package encapsulates and centralizes information about all\n+--  uses of interrupts (or signals), including the target-dependent\n+--  mapping of interrupts (or signals) to exceptions.\n+\n+--  Unlike the original design, System.Interrupt_Management can only\n+--  be used for tasking systems.\n+\n+--  PLEASE DO NOT remove the Elaborate_Body pragma from this package.\n+--  Elaboration of this package should happen early, as most other\n+--  initializations depend on it. Forcing immediate elaboration of\n+--  the body also helps to enforce the design assumption that this\n+--  is a second-level package, just one level above System.OS_Interface\n+--  with no cross-dependencies.\n+\n+--  PLEASE DO NOT put any subprogram declarations with arguments of\n+--  type Interrupt_ID into the visible part of this package. The type\n+--  Interrupt_ID is used to derive the type in Ada.Interrupts, and\n+--  adding more operations to that type would be illegal according\n+--  to the Ada Reference Manual. This is the reason why the signals\n+--  sets are implemeneted using visible arrays rather than functions.\n+\n+with System.OS_Interface;\n+--  used for sigset_t\n+\n+with Interfaces.C;\n+--  used for int\n+\n+package System.Interrupt_Management is\n+\n+   pragma Elaborate_Body;\n+\n+   type Interrupt_Mask is limited private;\n+\n+   type Interrupt_ID is new Interfaces.C.int\n+     range 0 .. System.OS_Interface.Max_Interrupt;\n+\n+   type Interrupt_Set is array (Interrupt_ID) of Boolean;\n+\n+   subtype Signal_ID is Interrupt_ID\n+     range 0 .. Interfaces.C.\"-\" (System.OS_Interface.NSIG, 1);\n+\n+   type Signal_Set is array (Signal_ID) of Boolean;\n+\n+   --  The following objects serve as constants, but are initialized\n+   --  in the body to aid portability.  This permits us to use more\n+   --  portable names for interrupts, where distinct names may map to\n+   --  the same interrupt ID value.\n+   --\n+   --  For example, suppose SIGRARE is a signal that is not defined on\n+   --  all systems, but is always reserved when it is defined. If we\n+   --  have the convention that ID zero is not used for any \"real\"\n+   --  signals, and SIGRARE = 0 when SIGRARE is not one of the locally\n+   --  supported signals, we can write\n+   --     Reserved (SIGRARE) := true;\n+   --  and the initialization code will be portable.\n+\n+   Abort_Task_Signal : Signal_ID;\n+   --  The signal that is used to implement task abortion if\n+   --  an interrupt is used for that purpose. This is one of the\n+   --  reserved signals.\n+\n+   Keep_Unmasked : Signal_Set := (others => False);\n+   --  Keep_Unmasked (I) is true iff the signal I is one that must\n+   --  that must be kept unmasked at all times, except (perhaps) for\n+   --  short critical sections. This includes signals that are\n+   --  mapped to exceptions, but may also include interrupts\n+   --  (e.g. timer) that need to be kept unmasked for other\n+   --  reasons. Where signal masking is per-task, the signal should be\n+   --  unmasked in ALL TASKS.\n+\n+   Reserve : Interrupt_Set := (others => False);\n+   --  Reserve (I) is true iff the interrupt I is one that cannot be\n+   --  permitted to be attached to a user handler. The possible reasons\n+   --  are many. For example, it may be mapped to an exception used to\n+   --  implement task abortion, or used to implement time delays.\n+\n+   procedure Initialize_Interrupts;\n+   --  On systems where there is no signal inheritance between tasks (e.g\n+   --  VxWorks, GNU/LinuxThreads), this procedure is used to initialize\n+   --  interrupts handling in each task. Otherwise this function should\n+   --  only be called by initialize in this package body.\n+\n+private\n+   type Interrupt_Mask is new System.OS_Interface.sigset_t;\n+   --  In some implementation Interrupt_Mask can be represented\n+   --  as a linked list.\n+\n+end System.Interrupt_Management;"}, {"sha": "6ee3f80fdcf53d8f1a9aadc4c3d4a92647578302", "filename": "gcc/ada/5ztaprop.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F5ztaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F5ztaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ztaprop.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -45,8 +45,8 @@ with System.Tasking.Debug;\n \n with System.Interrupt_Management;\n --  used for Keep_Unmasked\n---           Abort_Task_Interrupt\n---           Interrupt_ID\n+--           Abort_Task_Signal\n+--           Signal_ID\n --           Initialize_Interrupts\n \n with System.Soft_Links;\n@@ -262,7 +262,7 @@ package body System.Task_Primitives.Operations is\n \n       Result :=\n         sigaction\n-          (Signal (Interrupt_Management.Abort_Task_Interrupt),\n+          (Signal (Interrupt_Management.Abort_Task_Signal),\n            act'Unchecked_Access,\n            old_act'Unchecked_Access);\n       pragma Assert (Result = 0);\n@@ -1008,7 +1008,7 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       Result := kill (T.Common.LL.Thread,\n-        Signal (Interrupt_Management.Abort_Task_Interrupt));\n+        Signal (Interrupt_Management.Abort_Task_Signal));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -1126,6 +1126,13 @@ package body System.Task_Primitives.Operations is\n       Result := sigemptyset (Unblocked_Signal_Mask'Access);\n       pragma Assert (Result = 0);\n \n+      for J in Interrupt_Management.Signal_ID loop\n+         if System.Interrupt_Management.Keep_Unmasked (J) then\n+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n       Environment_Task_ID := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs."}, {"sha": "8fe6b3a89bde9d2d318af436c8c279fc4bd041a2", "filename": "gcc/ada/7sinmaop.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F7sinmaop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2F7sinmaop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7sinmaop.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -325,11 +325,16 @@ begin\n         Storage_Elements.To_Address\n           (Storage_Elements.Integer_Address (SIG_IGN));\n \n-      for I in Interrupt_ID loop\n-         if Keep_Unmasked (I) then\n-            Result := sigaddset (mask'Access, Signal (I));\n+      for J in Interrupt_ID loop\n+\n+         --  We need to check whether J is in Keep_Unmasked because\n+         --  the index type of the Keep_Unmasked array is not always\n+         --  Interrupt_ID; it may be a subtype of Interrupt_ID.\n+\n+         if J in Keep_Unmasked'Range and then Keep_Unmasked (J) then\n+            Result := sigaddset (mask'Access, Signal (J));\n             pragma Assert (Result = 0);\n-            Result := sigdelset (allmask'Access, Signal (I));\n+            Result := sigdelset (allmask'Access, Signal (J));\n             pragma Assert (Result = 0);\n          end if;\n       end loop;"}, {"sha": "e40866c66153e9a74ebd1e7e2b12d4e382382228", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -1,3 +1,108 @@\n+2003-11-24  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* Makefile.in: \n+\tUse 5zintman.ads for VxWorks targets. This file avoid confusion between\n+\tsignals and interrupts.\n+\n+\t* 5zintman.ads: New File.\n+\n+\t* 5zintman.adb: Replace Exception_Interrupts by Exception_Signals, and\n+\tadd exception signals to the set of unmasked signals.\n+\n+\t* 5ztaprop.adb: \n+\tUse Abort_Task_Signal instead of Abort_Task_Interrupt to avoid confusion\n+\tbetween signals and interrupts.\n+\tAdd to Unblocked_Signal_Mask the set of signals that are in\n+\tKeep_Unmasked.\n+\n+\t* 7sinmaop.adb: \n+\tAdding a check to see whether the Interrupt_ID we want to unmask is in\n+\tthe range of Keep_Unmasked (in procedure Interrupt_Self_Process). The\n+\treason is that the index type of the Keep_Unmasked array is not always\n+\tInterrupt_ID; it may be a subtype of Interrupt_ID.\n+\n+2003-11-24  Gary Dismukes  <dismukes@gnat.com>\n+\n+\t* exp_util.adb: \n+\t(Remove_Side_Effects): Condition constantness of object created for a\n+\t an unchecked type conversion on the constantness of the expression\n+\t to ensure the correct value for 'Constrained when passing components\n+\t of view-converted class-wide objects.\n+\n+2003-11-24  Robert Dewar  <dewar@gnat.com>\n+\n+\t* par-load.adb (Load): Improve handling of misspelled and missing units\n+\tRemoves several cases of compilation abandoned messages\n+\n+\t* lib.adb: (Remove_Unit): New procedure\n+\n+\t* lib.ads: (Remove_Unit): New procedure\n+\n+\t* lib-load.adb: Minor reformatting\n+\n+2003-11-24  Vincent Celier  <celier@gnat.com>\n+\n+\t* make.adb: \n+\t(Gnatmake, Initialize): Call Usage instead of Makeusg directly\n+\t(Marking_Label): Label to mark processed source files. Incremented for\n+\teach executable.\n+\t(Gnatmake): Increase Marking_Labet for each executable\n+\t(Is_Marked): Compare against marking label\n+\t(Mark): Mark with marking label\n+\n+2003-11-24  Jerome Guitton  <guitton@act-europe.fr>\n+\n+\t* s-thread.ads: \n+\tMove the declaration of the TSD for System.Threads to System.Soft_Links.\n+\tAdd some comments.\n+\n+\t* Makefile.in: Added target pair for s-thread.adb for cert runtime.\n+\t(rts-cert): build a single relocatable object for the run-time lib.\n+\tFix perms.\n+\n+2003-11-24  Vasiliy Fofanov  <fofanov@act-europe.fr>\n+\n+\t* Make-lang.in: \n+\tUse gnatls rather than gcc to obtain the location of GNAT RTL for\n+\tcrosstools build.\n+\n+2003-11-24  Sergey Rybin  <rybin@act-europe.fr>\n+\n+\t* opt.adb (Tree_Write): Gnat_Version_String is now a function, so we\n+\tcan not use it as before (that is, as a variable) when dumping it into\n+\tthe tree file. Add a local variable to store the result of this\n+\tfunction and to be used as the string to be written into the tree.\n+\n+\t* scn.adb (Initialize_Scanner): Add comments explaining the recent\n+\tchanges.\n+\n+\t* sinput.adb (Source_First, Source_Last): In case of\n+\tInternal_Source_File, replace returning attributes of\n+\tInternal_Source_Ptr (which is wrong) with returning attributes of\n+\tInternal_Source.\n+\n+2003-11-24  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch3.adb: \n+\t(New_Concatenation_Op): Proper name for New_Binary_Operator, only\n+\tused for implicit concatenation operators.\n+\tCode cleanup.\n+\n+\t* sem_elab.adb: \n+\t(Check_Elab_Call): Set No_Elaboration_Check appropriately on calls in\n+\ttask bodies that are in the scope of a Suppress pragma.\n+\t(Check_A Call): Use the flag to prevent spurious elaboration checks.\n+\n+\t* sinfo.ads, sinfo.adb: \n+\tNew flag No_Elaboration_Check on function/procedure calls, to properly\n+\tsuppress checks on calls in task bodies that are within a local suppress\n+\tpragma.\n+\n+\t* exp_ch4.adb: \n+\t(Expand_Concatenate_Other): Use the proper integer type for the\n+\texpression for the upper bound, to avoid universal_integer computations\n+\twhen possible.\n+\n 2003-11-21  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* .cvsignore: Delete."}, {"sha": "c3e7d18d62d42fd10534e2f51f0ea0412ab99bd4", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -290,10 +290,10 @@ regnattools:\n # use host-gcc host-gnatmake host-gnatbind host-gnatlink\n # put the host RTS dir first in the PATH to hide the default runtime\n # files that are among the sources\n-RTS_DIR:=$(dir $(subst \\,/,$(shell $(CC) -print-libgcc-file-name)))\n+RTS_DIR:=$(strip $(subst \\,/,$(shell gnatls -v | grep adalib )))\n cross-gnattools: force\n \t$(MAKE)  -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS)\\\n-\t   ADA_INCLUDES=\"-I$(RTS_DIR)adainclude -I$(RTS_DIR)adalib\" \\\n+\t   ADA_INCLUDES=\"-I$(RTS_DIR)../adainclude -I$(RTS_DIR)\" \\\n \t   GNATMAKE=\"gnatmake\" \\\n \t   GNATBIND=\"gnatbind\" \\\n \t   GNATLINK=\"gnatlink\" \\"}, {"sha": "6b4960740ffbde05cbf49fd8fb0ef7c51f869198", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -461,6 +461,7 @@ ifeq ($(strip $(filter-out alpha% dec vx%,$(targ))),)\n   a-numaux.ads<4znumaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-interr.adb<5zinterr.adb \\\n+  s-intman.ads<5zintman.ads \\\n   s-intman.adb<5zintman.adb \\\n   s-osinte.adb<5zosinte.adb \\\n   s-osinte.ads<5zosinte.ads \\\n@@ -487,6 +488,7 @@ ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n   a-numaux.ads<4znumaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-interr.adb<5zinterr.adb \\\n+  s-intman.ads<5zintman.ads \\\n   s-intman.adb<5zintman.adb \\\n   s-osinte.adb<5zosinte.adb \\\n   s-osinte.ads<5zosinte.ads \\\n@@ -524,6 +526,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   a-numaux.ads<4znumaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-interr.adb<5zinterr.adb \\\n+  s-intman.ads<5zintman.ads \\\n   s-intman.adb<5zintman.adb \\\n   s-osinte.adb<5zosinte.adb \\\n   s-osinte.ads<5zosinte.ads \\\n@@ -593,6 +596,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   s-soflin.ads<2ssoflin.ads \\\n   s-stalib.adb<1sstalib.adb \\\n   s-stalib.ads<1sstalib.ads \\\n+  s-thread.adb<5zthread.adb \\\n   s-thrini.ads<2sthrini.ads \\\n   s-thrini.adb<5zthrini.adb \\\n   s-tiitho.adb<5ztiitho.adb \\\n@@ -619,6 +623,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n   a-numaux.ads<4znumaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-interr.adb<5zinterr.adb \\\n+  s-intman.ads<5zintman.ads \\\n   s-intman.adb<5zintman.adb \\\n   s-osinte.adb<5zosinte.adb \\\n   s-osinte.ads<5zosinte.ads \\\n@@ -692,7 +697,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n   s-soflin.ads<2ssoflin.ads \\\n   s-stalib.adb<1sstalib.adb \\\n   s-stalib.ads<1sstalib.ads \\\n-  s-thrini.adb<5zthrini.adb \\\n+  s-thread.adb<5zthread.adb \\\n   s-thrini.ads<2sthrini.ads \\\n   s-thrini.adb<5zthrini.adb \\\n   s-tiitho.adb<5ytiitho.adb \\\n@@ -736,6 +741,7 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   a-numaux.ads<4znumaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-interr.adb<5zinterr.adb \\\n+  s-intman.ads<5zintman.ads \\\n   s-intman.adb<5zintman.adb \\\n   s-osinte.adb<5zosinte.adb \\\n   s-osinte.ads<5zosinte.ads \\\n@@ -764,6 +770,7 @@ ifeq ($(strip $(filter-out xscale% coff wrs vx%,$(targ))),)\n   a-numaux.ads<4znumaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-interr.adb<5zinterr.adb \\\n+  s-intman.ads<5zintman.ads \\\n   s-intman.adb<5zintman.adb \\\n   s-osinte.adb<5zosinte.adb \\\n   s-osinte.ads<5zosinte.ads \\\n@@ -792,6 +799,7 @@ ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n   a-numaux.ads<4znumaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-interr.adb<5zinterr.adb \\\n+  s-intman.ads<5zintman.ads \\\n   s-intman.adb<5zintman.adb \\\n   s-osinte.adb<5zosinte.adb \\\n   s-osinte.ads<5zosinte.ads \\\n@@ -2055,8 +2063,10 @@ rts-cert: force\n \t../../../$(GCC_FOR_TARGET) -B../../../ $(TARGET_LIBGCC2_CFLAGS) \\\n \t$(ALL_CFLAGS) $(GNATLIBCFLAGS_FOR_C) -c ../adainclude/$(f).c \\\n \t-I../adainclude $(INCLUDES_FOR_SUBDIR) -I../../../ ;) \\\n-\t$(AR) $(AR_FLAGS) libgnat$(arext) \\\n-\t   $(addsuffix .o,$(CERT_LEVEL_B_C_FILES))\n+\t../../../xgcc -B../../../ *.o -o libgnat ; \\\n+\t$(CHMOD) a-wx *.ali ; \\\n+\t$(RM) *.o ; \\\n+\t$(MV) libgnat libgnat.o\n \n rts-none: force\n \t$(MAKE) $(FLAGS_TO_PASS) prepare-rts \\"}, {"sha": "85de43395e35caccb4fdfbd08f3e656c606b01c2", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -1472,7 +1472,7 @@ package body Exp_Ch4 is\n    --  their base type, Ind_Typ their index type, and Arr_Typ the original\n    --  array type to which the concatenantion operator applies, then the\n    --  following subprogram is constructed:\n-   --\n+\n    --  [function Cnn (S1 : Base_Typ; ...; Sn : Base_Typ) return Base_Typ is\n    --      L : Ind_Typ;\n    --   begin\n@@ -1489,7 +1489,7 @@ package body Exp_Ch4 is\n    --      else\n    --         return Sn;\n    --      end if;\n-   --\n+\n    --      declare\n    --         P : Ind_Typ;\n    --         H : Ind_Typ :=\n@@ -1516,9 +1516,9 @@ package body Exp_Ch4 is\n    --               P := Ind_Typ'Succ (P);\n    --            end loop;\n    --         end if;\n-   --\n+\n    --         ...\n-   --\n+\n    --         if Sn'Length /= 0 then\n    --            P := Sn'First;\n    --            loop\n@@ -1528,7 +1528,7 @@ package body Exp_Ch4 is\n    --               P := Ind_Typ'Succ (P);\n    --            end loop;\n    --         end if;\n-   --\n+\n    --         return R;\n    --      end;\n    --   end Cnn;]\n@@ -1598,7 +1598,9 @@ package body Exp_Ch4 is\n       --  Builds reference to identifier L.\n \n       function L_Pos return Node_Id;\n-      --  Builds expression Ind_Typ'Pos (L).\n+      --  Builds expression Integer_Type'(Ind_Typ'Pos (L)).\n+      --  We qualify the expression to avoid universal_integer computations\n+      --  whenever possible, in the expression for the upper bound H.\n \n       function L_Succ return Node_Id;\n       --  Builds expression Ind_Typ'Succ (L).\n@@ -1743,12 +1745,31 @@ package body Exp_Ch4 is\n       -----------\n \n       function L_Pos return Node_Id is\n+         Target_Type : Entity_Id;\n+\n       begin\n+         --  If the index type is an enumeration type, the computation\n+         --  can be done in standard integer. Otherwise, choose a large\n+         --  enough integer type.\n+\n+         if Is_Enumeration_Type (Ind_Typ)\n+           or else Root_Type (Ind_Typ) = Standard_Integer\n+           or else Root_Type (Ind_Typ) = Standard_Short_Integer\n+           or else Root_Type (Ind_Typ) = Standard_Short_Short_Integer\n+         then\n+            Target_Type := Standard_Integer;\n+         else\n+            Target_Type := Root_Type (Ind_Typ);\n+         end if;\n+\n          return\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Reference_To (Ind_Typ, Loc),\n-             Attribute_Name => Name_Pos,\n-             Expressions    => New_List (L));\n+           Make_Qualified_Expression (Loc,\n+              Subtype_Mark => New_Reference_To (Target_Type, Loc),\n+              Expression   =>\n+                Make_Attribute_Reference (Loc,\n+                  Prefix         => New_Reference_To (Ind_Typ, Loc),\n+                  Attribute_Name => Name_Pos,\n+                  Expressions    => New_List (L)));\n       end L_Pos;\n \n       ------------"}, {"sha": "6c3911c740d0f864e2d16fe538cc97bc1dbc6fd8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -3510,7 +3510,7 @@ package body Exp_Util is\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Def_Id,\n                 Object_Definition   => New_Reference_To (Exp_Type, Loc),\n-                Constant_Present    => True,\n+                Constant_Present    => not Is_Variable (Exp),\n                 Expression          => Relocate_Node (Exp));\n \n             Set_Assignment_OK (E);"}, {"sha": "fbb50af08003eccc08d1ae30aeeefb8b6afd94a6", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -688,14 +688,11 @@ package body Lib.Load is\n \n    procedure Make_Instance_Unit (N : Node_Id) is\n       Sind : constant Source_File_Index := Source_Index (Main_Unit);\n-\n    begin\n       Units.Increment_Last;\n-\n       Units.Table (Units.Last)               := Units.Table (Main_Unit);\n       Units.Table (Units.Last).Cunit         := Library_Unit (N);\n       Units.Table (Units.Last).Generate_Code := True;\n-\n       Units.Table (Main_Unit).Cunit          := N;\n       Units.Table (Main_Unit).Unit_Name      :=\n         Get_Body_Name (Unit_Name (Get_Cunit_Unit_Number (Library_Unit (N))));\n@@ -713,7 +710,6 @@ package body Lib.Load is\n    is\n       Sunit : constant Node_Id := Cunit (Spec_Unit);\n       Bunit : constant Node_Id := Cunit (Body_Unit);\n-\n    begin\n       --  The spec is irrelevant if the body is a subprogram body, and the\n       --  spec is other than a subprogram spec or generic subprogram spec.\n@@ -725,7 +721,6 @@ package body Lib.Load is\n          Nkind (Unit (Bunit)) = N_Subprogram_Body\n            and then Nkind (Unit (Sunit)) /= N_Subprogram_Declaration\n            and then Nkind (Unit (Sunit)) /= N_Generic_Subprogram_Declaration;\n-\n    end Spec_Is_Irrelevant;\n \n    --------------------\n@@ -735,9 +730,7 @@ package body Lib.Load is\n    procedure Version_Update (U : Node_Id; From : Node_Id) is\n       Unum  : constant Unit_Number_Type := Get_Cunit_Unit_Number (U);\n       Fnum  : constant Unit_Number_Type := Get_Cunit_Unit_Number (From);\n-\n    begin\n-\n       if Source_Index (Fnum) /= No_Source_File then\n          Units.Table (Unum).Version :=\n            Units.Table (Unum).Version"}, {"sha": "5e9093072649806b2037e284eabbb0d47d7a500b", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -870,6 +870,17 @@ package body Lib is\n       return Int (Units.Last) - Int (Main_Unit) + 1;\n    end Num_Units;\n \n+   -----------------\n+   -- Remove_Unit --\n+   -----------------\n+\n+   procedure Remove_Unit (U : Unit_Number_Type) is\n+   begin\n+      if U = Units.Last then\n+         Units.Decrement_Last;\n+      end if;\n+   end Remove_Unit;\n+\n    ----------------------------------\n    -- Replace_Linker_Option_String --\n    ----------------------------------"}, {"sha": "4fe2ff4b7f3528aabdf32224ab3cbc7677036d40", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -417,6 +417,10 @@ package Lib is\n    function Num_Units return Nat;\n    --  Number of units currently in unit table\n \n+   procedure Remove_Unit (U : Unit_Number_Type);\n+   --  Remove unit U from unit table. Currently this is effective only\n+   --  if U is the last unit currently stored in the unit table.\n+\n    function Entity_Is_In_Main_Unit (E : Entity_Id) return Boolean;\n    --  Returns True if the entity E is declared in the main unit, or, in\n    --  its corresponding spec, or one of its subunits. Entities declared"}, {"sha": "1a58a82a1ae2de37875df1a09ff73ee5d7ee4215", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -24,12 +24,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Exceptions;   use Ada.Exceptions;\n-with Ada.Command_Line; use Ada.Command_Line;\n-\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.Case_Util;            use GNAT.Case_Util;\n-\n with ALI;      use ALI;\n with ALI.Util; use ALI.Util;\n with Csets;\n@@ -65,6 +59,12 @@ with System.HTable;\n with Targparm;\n with Tempdir;\n \n+with Ada.Exceptions;   use Ada.Exceptions;\n+with Ada.Command_Line; use Ada.Command_Line;\n+\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.Case_Util;            use GNAT.Case_Util;\n+\n package body Make is\n \n    use ASCII;\n@@ -480,6 +480,9 @@ package body Make is\n    -- Marking Routines --\n    ----------------------\n \n+   Marking_Label : Byte := 1;\n+   --  Value to mark the source files\n+\n    procedure Mark (Source_File : File_Name_Type);\n    --  Mark Source_File. Marking is used to signal that Source_File has\n    --  already been inserted in the Q.\n@@ -2233,7 +2236,9 @@ package body Make is\n       -------------\n \n       function Compile\n-        (S : Name_Id; L : Name_Id; Args : Argument_List) return Process_Id\n+        (S    : Name_Id;\n+         L    : Name_Id;\n+         Args : Argument_List) return Process_Id\n       is\n          Comp_Args : Argument_List (Args'First .. Args'Last + 8);\n          Comp_Next : Integer := Args'First;\n@@ -3692,7 +3697,7 @@ package body Make is\n          else\n             --  Output usage information if no files to compile\n \n-            Makeusg;\n+            Usage;\n             Exit_Program (E_Fatal);\n          end if;\n       end if;\n@@ -4228,6 +4233,18 @@ package body Make is\n \n       Multiple_Main_Loop : for N_File in 1 .. Osint.Number_Of_Files loop\n \n+         --  Increase the marking label to be sure to check sources\n+         --  for all executables.\n+\n+         Marking_Label := Marking_Label + 1;\n+\n+         --  Make sure it is not 0, which is the default value for\n+         --  a file that has never been marked.\n+\n+         if Marking_Label = 0 then\n+            Marking_Label := 1;\n+         end if;\n+\n          --  First, find the executable name and path\n \n          Executable          := No_File;\n@@ -5573,7 +5590,7 @@ package body Make is\n       end loop Scan_Args;\n \n       if Usage_Requested then\n-         Makeusg;\n+         Usage;\n       end if;\n \n       --  Test for trailing -P switch\n@@ -5695,6 +5712,10 @@ package body Make is\n                Make_Failed (Exception_Message (Err));\n          end;\n       end if;\n+\n+      --  Set the marking label to a value that is not zero\n+\n+      Marking_Label := 1;\n    end Initialize;\n \n    -----------------------------------\n@@ -5707,10 +5728,11 @@ package body Make is\n       Into_Q       : Boolean)\n    is\n       Put_In_Q : Boolean := Into_Q;\n-      Unit  : Com.Unit_Data;\n-      Sfile : Name_Id;\n+      Unit     : Com.Unit_Data;\n+      Sfile    : Name_Id;\n+\n       Extending : constant Boolean :=\n-        Projects.Table (The_Project).Extends /= No_Project;\n+                    Projects.Table (The_Project).Extends /= No_Project;\n \n       function Check_Project (P : Project_Id) return Boolean;\n       --  Returns True if P is The_Project or a project extended by\n@@ -6044,7 +6066,7 @@ package body Make is\n \n    function Is_Marked (Source_File : File_Name_Type) return Boolean is\n    begin\n-      return Get_Name_Table_Byte (Source_File) /= 0;\n+      return Get_Name_Table_Byte (Source_File) = Marking_Label;\n    end Is_Marked;\n \n    ----------\n@@ -6228,7 +6250,7 @@ package body Make is\n \n    procedure Mark (Source_File : File_Name_Type) is\n    begin\n-      Set_Name_Table_Byte (Source_File, 1);\n+      Set_Name_Table_Byte (Source_File, Marking_Label);\n    end Mark;\n \n    --------------------"}, {"sha": "be1eca67bcd96b74a6bb93393147e3228672b10b", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -186,6 +186,7 @@ package body Opt is\n    ----------------\n \n    procedure Tree_Write is\n+      Version_String : String := Gnat_Version_String;\n    begin\n       Tree_Write_Int  (ASIS_Version_Number);\n       Tree_Write_Bool (Brief_Output);\n@@ -202,9 +203,9 @@ package body Opt is\n       Tree_Write_Bool (Assertions_Enabled);\n       Tree_Write_Bool (Enable_Overflow_Checks);\n       Tree_Write_Bool (Full_List);\n-      Tree_Write_Int  (Int (Gnat_Version_String'Length));\n-      Tree_Write_Data (Gnat_Version_String'Address,\n-                       Gnat_Version_String'Length);\n+      Tree_Write_Int  (Int (Version_String'Length));\n+      Tree_Write_Data (Version_String'Address,\n+                       Version_String'Length);\n       Tree_Write_Data (Distribution_Stub_Mode'Address,\n                        Distribution_Stub_Mode_Type'Object_Size / Storage_Unit);\n       Tree_Write_Bool (Immediate_Errors);"}, {"sha": "163fb0b13e83b022b321cbbf72e266efb49379ce", "filename": "gcc/ada/par-load.adb", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,6 +42,8 @@ with Sinput.L; use Sinput.L;\n with Stylesw;  use Stylesw;\n with Validsw;  use Validsw;\n \n+with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n+\n separate (Par)\n procedure Load is\n \n@@ -188,26 +190,45 @@ begin\n                     or else\n                   Name_Buffer (1) = 'g')\n       then\n-         --  In the predefined file case, we know the user did not construct\n-         --  their own package, but we got the wrong one. This means that the\n-         --  name supplied by the user crunched to something we recognized,\n-         --  but then the file did not contain the unit expected. Most likely\n-         --  this is due to a misspelling, e.g.\n-\n-         --    with Ada.Calender;\n-\n-         --  This crunches to a-calend, which indeed contains the unit\n-         --  Ada.Calendar, and we can diagnose the misspelling. This is\n-         --  a simple heuristic, but it catches many common cases of\n-         --  misspelling of predefined unit names without needing a full\n-         --  list of them.\n-\n-         Error_Msg_Name_1 := Expected_Unit (Cur_Unum);\n-         Error_Msg (\"% is not a predefined library unit!\", Loc);\n-         Error_Msg_Name_1 := Unit_Name (Cur_Unum);\n-         Error_Msg (\"possible misspelling of %!\", Loc);\n+         declare\n+            Expect_Name : constant Name_Id := Expected_Unit (Cur_Unum);\n+            Actual_Name : constant Name_Id := Unit_Name (Cur_Unum);\n+\n+         begin\n+            Error_Msg_Name_1 := Expect_Name;\n+            Error_Msg (\"% is not a predefined library unit!\", Loc);\n+\n+            --  In the predefined file case, we know the user did not\n+            --  construct their own package, but we got the wrong one.\n+            --  This means that the name supplied by the user crunched\n+            --  to something we recognized, but then the file did not\n+            --  contain the unit expected. Most likely this is due to\n+            --  a misspelling, e.g.\n+\n+            --    with Ada.Calender;\n+\n+            --  This crunches to a-calend, which indeed contains the unit\n+            --  Ada.Calendar, and we can diagnose the misspelling. This\n+            --  is a simple heuristic, but it catches many common cases\n+            --  of misspelling of predefined unit names without needing\n+            --  a full list of them.\n+\n+            --  Before actually issinying the message, we will check that the\n+            --  unit name is indeed a plausible misspelling of the one we got.\n+\n+            if Is_Bad_Spelling_Of\n+              (Found  => Get_Name_String (Expect_Name),\n+               Expect => Get_Name_String (Actual_Name))\n+            then\n+               Error_Msg_Name_1 := Actual_Name;\n+               Error_Msg (\"possible misspelling of %!\", Loc);\n+            end if;\n+         end;\n \n-      --  Non-predefined file name case\n+      --  Non-predefined file name case. In this case we generate a message\n+      --  and then we quit, because we are in big trouble, and if we try\n+      --  to continue compilation, we get into some nasty situations\n+      --  (for example in some subunit cases).\n \n       else\n          Error_Msg (\"file { does not contain expected unit!\", Loc);\n@@ -217,7 +238,10 @@ begin\n          Error_Msg (\"found unit $!\", Loc);\n       end if;\n \n-      raise Unrecoverable_Error;\n+      --  In both cases, remove the unit if it is the last unit (which it\n+      --  normally (always?) will be) so that it is out of the way later.\n+\n+      Remove_Unit (Cur_Unum);\n    end if;\n \n    --  If current unit is a body, load its corresponding spec"}, {"sha": "f1606f1b808396f9552d17baafdf9766351e2013", "filename": "gcc/ada/s-thread.ads", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fs-thread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fs-thread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.ads?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -38,6 +38,10 @@\n --  VxWorks AE653 with the restricted / cert runtime\n \n with Ada.Exceptions;\n+--  used for Exception_Occurrence\n+\n+with System.Soft_Links;\n+--  used for TSD\n \n package System.Threads is\n \n@@ -137,27 +141,6 @@ package System.Threads is\n \n private\n \n-   ------------------------\n-   -- Task Specific Data --\n-   ------------------------\n-\n-   type ATSD is limited record\n-      Jmpbuf_Address : Address := Null_Address;\n-      --  Address of jump buffer used to store the address of the\n-      --  current longjmp/setjmp buffer for exception management.\n-      --  These buffers are threaded into a stack, and the address\n-      --  here is the top of the stack. A null address means that\n-      --  no exception handler is currently active.\n-\n-      Sec_Stack_Addr : Address := Null_Address;\n-      --  Address of currently allocated secondary stack\n-\n-      Current_Excep : aliased EO;\n-      --  Exception occurrence that contains the information for the\n-      --  current exception. Note that any exception in the same task\n-      --  destroys this information, so the data in this variable must\n-      --  be copied out before another exception can occur.\n-\n-   end record;\n+   type ATSD is new System.Soft_Links.TSD;\n \n end System.Threads;"}, {"sha": "ff0792c2cf03a4ad41c6646d6ac666e00465e6e7", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -261,7 +261,9 @@ package body Scn is\n    begin\n       Scanner.Initialize_Scanner (Unit, Index);\n \n-      --  Set default for Comes_From_Source. All nodes built now until we\n+      --  Set default for Comes_From_Source (except if we are going to process\n+      --  an artificial string internally created within the compiler and\n+      --  placed into internal source duffer). All nodes built now until we\n       --  reenter the analyzer will have Comes_From_Source set to True\n \n       if Index /= Internal_Source_File then\n@@ -280,6 +282,16 @@ package body Scn is\n       --  call Scan. Scan initial token (note this initializes Prev_Token,\n       --  Prev_Token_Ptr).\n \n+      --  There are two reasons not to do the Scan step in case if we\n+      --  initialize the scanner for the internal source buffer:\n+\n+      --  - The artificial string may not be created by the compiler in this\n+      --    buffer when we call Initialize_Scanner\n+\n+      --  - For these artificial strings a special way of scanning is used, so\n+      --    the standard step of the scanner may just break the algorithm of\n+      --    processing these strings.\n+\n       if Index /= Internal_Source_File then\n          Scan;\n       end if;"}, {"sha": "b798fd51538f214dc307e3eb1c137f4f7f52d41c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -548,9 +548,9 @@ package body Sem_Ch3 is\n    --  Create new modular type. Verify that modulus is in  bounds and is\n    --  a power of two (implementation restriction).\n \n-   procedure New_Binary_Operator (Op_Name : Name_Id; Typ : Entity_Id);\n+   procedure New_Concatenation_Op (Typ : Entity_Id);\n    --  Create an abbreviated declaration for an operator in order to\n-   --  materialize minimally operators on derived types.\n+   --  materialize concatenation on array types.\n \n    procedure Ordinary_Fixed_Point_Type_Declaration\n      (T   : Entity_Id;\n@@ -2865,7 +2865,7 @@ package body Sem_Ch3 is\n       if Number_Dimensions (T) = 1\n          and then not Is_Packed_Array_Type (T)\n       then\n-         New_Binary_Operator (Name_Op_Concat, T);\n+         New_Concatenation_Op (T);\n       end if;\n \n       --  In the case of an unconstrained array the parser has already\n@@ -3068,7 +3068,7 @@ package body Sem_Ch3 is\n         and then not Is_Derived_Type (Parent_Type)\n         and then not Is_Package (Scope (Base_Type (Parent_Type)))\n       then\n-         New_Binary_Operator (Name_Op_Concat, Derived_Type);\n+         New_Concatenation_Op (Derived_Type);\n       end if;\n    end Build_Derived_Array_Type;\n \n@@ -10945,11 +10945,11 @@ package body Sem_Ch3 is\n \n    end Modular_Type_Declaration;\n \n-   -------------------------\n-   -- New_Binary_Operator --\n-   -------------------------\n+   --------------------------\n+   -- New_Concatenation_Op --\n+   --------------------------\n \n-   procedure New_Binary_Operator (Op_Name : Name_Id; Typ : Entity_Id) is\n+   procedure New_Concatenation_Op (Typ : Entity_Id) is\n       Loc : constant Source_Ptr := Sloc (Typ);\n       Op  : Entity_Id;\n \n@@ -10971,26 +10971,26 @@ package body Sem_Ch3 is\n          return Formal;\n       end Make_Op_Formal;\n \n-   --  Start of processing for New_Binary_Operator\n+   --  Start of processing for New_Concatenation_Op\n \n    begin\n-      Op := Make_Defining_Operator_Symbol (Loc, Op_Name);\n+      Op := Make_Defining_Operator_Symbol (Loc, Name_Op_Concat);\n \n       Set_Ekind                   (Op, E_Operator);\n       Set_Scope                   (Op, Current_Scope);\n       Set_Etype                   (Op, Typ);\n-      Set_Homonym                 (Op, Get_Name_Entity_Id (Op_Name));\n+      Set_Homonym                 (Op, Get_Name_Entity_Id (Name_Op_Concat));\n       Set_Is_Immediately_Visible  (Op);\n       Set_Is_Intrinsic_Subprogram (Op);\n       Set_Has_Completion          (Op);\n       Append_Entity               (Op, Current_Scope);\n \n-      Set_Name_Entity_Id (Op_Name, Op);\n+      Set_Name_Entity_Id (Name_Op_Concat, Op);\n \n       Append_Entity (Make_Op_Formal (Typ, Op), Op);\n       Append_Entity (Make_Op_Formal (Typ, Op), Op);\n \n-   end New_Binary_Operator;\n+   end New_Concatenation_Op;\n \n    -------------------------------------------\n    -- Ordinary_Fixed_Point_Type_Declaration --"}, {"sha": "f189fe127db9989358e8083659f3c6e7074c53f4", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -325,6 +325,16 @@ package body Sem_Elab is\n       --  we ignore this flag.\n \n    begin\n+      --  If the call is known to be within a local Suppress Elaboration\n+      --  pragma, nothing to check. This can happen in task bodies.\n+\n+      if (Nkind (N) = N_Function_Call\n+           or else Nkind (N) = N_Procedure_Call_Statement)\n+        and then  No_Elaboration_Check (N)\n+      then\n+         return;\n+      end if;\n+\n       --  Go to parent for derived subprogram, or to original subprogram\n       --  in the case of a renaming (Alias covers both these cases)\n \n@@ -826,10 +836,41 @@ package body Sem_Elab is\n      (N           : Node_Id;\n       Outer_Scope : Entity_Id := Empty)\n    is\n-      Nam : Node_Id;\n       Ent : Entity_Id;\n       P   : Node_Id;\n \n+      function Get_Called_Ent return Entity_Id;\n+      --  Retrieve called entity. If this is a call to a protected subprogram,\n+      --  entity is a selected component. The callable entity may be absent,\n+      --  in which case there is no check to perform.  This happens with\n+      --  non-analyzed calls in nested generics.\n+\n+      --------------------\n+      -- Get_Called_Ent --\n+      --------------------\n+\n+      function Get_Called_Ent return Entity_Id is\n+         Nam : Node_Id;\n+\n+      begin\n+         Nam := Name (N);\n+\n+         if No (Nam) then\n+            return Empty;\n+\n+         elsif Nkind (Nam) = N_Selected_Component then\n+            return Entity (Selector_Name (Nam));\n+\n+         elsif not Is_Entity_Name (Nam) then\n+            return Empty;\n+\n+         else\n+            return Entity (Nam);\n+         end if;\n+      end Get_Called_Ent;\n+\n+   --  Start of processing for Check_Elab_Call\n+\n    begin\n       --  For an entry call, check relevant restriction\n \n@@ -1014,6 +1055,26 @@ package body Sem_Elab is\n \n                         exit;\n \n+                     elsif Nkind (P) = N_Task_Body then\n+\n+                        --  The check is deferred until Check_Task_Activation\n+                        --  but we need to capture local suppress pragmas\n+                        --  that may inhibit checks on this call.\n+\n+                        Ent := Get_Called_Ent;\n+\n+                        if No (Ent) then\n+                           return;\n+\n+                        elsif Elaboration_Checks_Suppressed (Current_Scope)\n+                          or else Elaboration_Checks_Suppressed (Ent)\n+                          or else Elaboration_Checks_Suppressed (Scope (Ent))\n+                        then\n+                           Set_No_Elaboration_Check (N);\n+                        end if;\n+\n+                        return;\n+\n                      --  Static model, call is not in elaboration code, we\n                      --  never need to worry, because in the static model\n                      --  the top level caller always takes care of things.\n@@ -1027,25 +1088,7 @@ package body Sem_Elab is\n          end if;\n       end if;\n \n-      --  Retrieve called entity. If this is a call to a protected subprogram,\n-      --  the entity is a selected component.\n-      --  The callable entity may be absent, in which case there is nothing\n-      --  to do. This happens with non-analyzed calls in nested generics.\n-\n-      Nam := Name (N);\n-\n-      if No (Nam) then\n-         return;\n-\n-      elsif Nkind (Nam) = N_Selected_Component then\n-         Ent := Entity (Selector_Name (Nam));\n-\n-      elsif not Is_Entity_Name (Nam) then\n-         return;\n-\n-      else\n-         Ent := Entity (Nam);\n-      end if;\n+      Ent := Get_Called_Ent;\n \n       if No (Ent) then\n          return;"}, {"sha": "f8d22784d0cafdddf2f893fb8fa161bea672f71d", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -1764,6 +1764,15 @@ package body Sinfo is\n       return Flag7 (N);\n    end No_Ctrl_Actions;\n \n+   function No_Elaboration_Check\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Function_Call\n+        or else NT (N).Nkind = N_Procedure_Call_Statement);\n+      return Flag14 (N);\n+   end No_Elaboration_Check;\n+\n    function No_Entities_Ref_In_Spec\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4187,6 +4196,15 @@ package body Sinfo is\n       Set_Flag7 (N, Val);\n    end Set_No_Ctrl_Actions;\n \n+   procedure Set_No_Elaboration_Check\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Function_Call\n+        or else NT (N).Nkind = N_Procedure_Call_Statement);\n+      Set_Flag14 (N, Val);\n+   end Set_No_Elaboration_Check;\n+\n    procedure Set_No_Entities_Ref_In_Spec\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "f1764943a847155b04a5d081e851c637648b8f46", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -1266,6 +1266,13 @@ package Sinfo is\n    --    where the generated assignments are more initialisations than real\n    --    assignments.\n \n+   --  No_Elaboration_Check (Flag14-Sem)\n+   --    Present in N_Function_Call and N_Procedure_Call_Statement. Indicates\n+   --    that no elaboration check is needed on the call, because it appears\n+   --    in the context of a local Suppress pragma. This is used on calls\n+   --    within task bodies, where the actual elaboration checks are applied\n+   --    after analysis, when the local scope stack is not present.\n+\n    --  No_Entities_Ref_In_Spec (Flag8-Sem)\n    --    Present in N_With_Clause nodes. Set if the with clause is on the\n    --    package or subprogram spec where the main unit is the corresponding\n@@ -4043,6 +4050,7 @@ package Sinfo is\n       --  First_Named_Actual (Node4-Sem)\n       --  Controlling_Argument (Node1-Sem) (set to Empty if not dispatching)\n       --  Do_Tag_Check (Flag13-Sem)\n+      --  No_Elaboration_Check (Flag14-Sem)\n       --  Parameter_List_Truncated (Flag17-Sem)\n       --  ABE_Is_Certain (Flag18-Sem)\n       --  plus fields for expression\n@@ -4073,6 +4081,7 @@ package Sinfo is\n       --  First_Named_Actual (Node4-Sem)\n       --  Controlling_Argument (Node1-Sem) (set to Empty if not dispatching)\n       --  Do_Tag_Check (Flag13-Sem)\n+      --  No_Elaboration_Check (Flag14-Sem)\n       --  Parameter_List_Truncated (Flag17-Sem)\n       --  ABE_Is_Certain (Flag18-Sem)\n       --  plus fields for expression\n@@ -7391,6 +7400,9 @@ package Sinfo is\n    function No_Ctrl_Actions\n      (N : Node_Id) return Boolean;    -- Flag7\n \n+   function No_Elaboration_Check\n+     (N : Node_Id) return Boolean;    -- Flag14\n+\n    function No_Entities_Ref_In_Spec\n      (N : Node_Id) return Boolean;    -- Flag8\n \n@@ -8165,6 +8177,9 @@ package Sinfo is\n    procedure Set_No_Ctrl_Actions\n      (N : Node_Id; Val : Boolean := True);    -- Flag7\n \n+   procedure Set_No_Elaboration_Check\n+     (N : Node_Id; Val : Boolean := True);    -- Flag14\n+\n    procedure Set_No_Entities_Ref_In_Spec\n      (N : Node_Id; Val : Boolean := True);    -- Flag8\n \n@@ -8600,6 +8615,7 @@ package Sinfo is\n    pragma Inline (Next_Rep_Item);\n    pragma Inline (Next_Use_Clause);\n    pragma Inline (No_Ctrl_Actions);\n+   pragma Inline (No_Elaboration_Check);\n    pragma Inline (No_Entities_Ref_In_Spec);\n    pragma Inline (No_Initialization);\n    pragma Inline (No_Truncation);\n@@ -8854,6 +8870,7 @@ package Sinfo is\n    pragma Inline (Set_Next_Named_Actual);\n    pragma Inline (Set_Next_Use_Clause);\n    pragma Inline (Set_No_Ctrl_Actions);\n+   pragma Inline (Set_No_Elaboration_Check);\n    pragma Inline (Set_No_Entities_Ref_In_Spec);\n    pragma Inline (Set_No_Initialization);\n    pragma Inline (Set_No_Truncation);"}, {"sha": "3ab47c7106aea17b6054ef445704e09945f7b461", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1e24d3a2a1b3dd13778dea5972a9445af771a7/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=6c1e24d3a2a1b3dd13778dea5972a9445af771a7", "patch": "@@ -1111,7 +1111,7 @@ package body Sinput is\n    function Source_First (S : SFI) return Source_Ptr is\n    begin\n       if S = Internal_Source_File then\n-         return Internal_Source_Ptr'First;\n+         return Internal_Source'First;\n       else\n          return Source_File.Table (S).Source_First;\n       end if;\n@@ -1120,7 +1120,7 @@ package body Sinput is\n    function Source_Last (S : SFI) return Source_Ptr is\n    begin\n       if S = Internal_Source_File then\n-         return Internal_Source_Ptr'Last;\n+         return Internal_Source'Last;\n       else\n          return Source_File.Table (S).Source_Last;\n       end if;"}]}