{"sha": "2b99b2b8d2300ae0f11c53920ae854873acdcf16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI5OWIyYjhkMjMwMGFlMGYxMWM1MzkyMGFlODU0ODczYWNkY2YxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-03-24T17:23:18Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-03-24T17:23:18Z"}, "message": "re PR rtl-optimization/48263 (build fails for cris-elf in libgfortran)\n\ngcc/\n\tPR rtl-optimization/48263\n\t* optabs.c (expand_binop_directly): Reinstate convert_modes code\n\tand original commutative_p handling.  Use maybe_gen_insn.\n\nFrom-SVN: r171418", "tree": {"sha": "1b8f59638c3b837c02c39ef781ff7d28edb5799c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b8f59638c3b837c02c39ef781ff7d28edb5799c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b99b2b8d2300ae0f11c53920ae854873acdcf16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b99b2b8d2300ae0f11c53920ae854873acdcf16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b99b2b8d2300ae0f11c53920ae854873acdcf16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b99b2b8d2300ae0f11c53920ae854873acdcf16/comments", "author": null, "committer": null, "parents": [{"sha": "1e2c3ec4411f7f51cafcafedad83e32049fb9686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2c3ec4411f7f51cafcafedad83e32049fb9686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2c3ec4411f7f51cafcafedad83e32049fb9686"}], "stats": {"total": 86, "additions": 54, "deletions": 32}, "files": [{"sha": "a0b54d125747d5d9d7c25409bb65a2f6d310cf17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b99b2b8d2300ae0f11c53920ae854873acdcf16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b99b2b8d2300ae0f11c53920ae854873acdcf16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b99b2b8d2300ae0f11c53920ae854873acdcf16", "patch": "@@ -1,3 +1,9 @@\n+2011-03-24  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR rtl-optimization/48263\n+\t* optabs.c (expand_binop_directly): Reinstate convert_modes code\n+\tand original commutative_p handling.  Use maybe_gen_insn.\n+\n 2011-03-24  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* reload.c (find_reloads_subreg_address): Add address_reloaded"}, {"sha": "a133596b381fc25b8eb9050bc869f28089b31106", "filename": "gcc/optabs.c", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b99b2b8d2300ae0f11c53920ae854873acdcf16/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b99b2b8d2300ae0f11c53920ae854873acdcf16/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2b99b2b8d2300ae0f11c53920ae854873acdcf16", "patch": "@@ -1269,6 +1269,38 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n   if (!shift_optab_p (binoptab))\n     xop1 = avoid_expensive_constant (mode1, binoptab, xop1, unsignedp);\n \n+  /* In case the insn wants input operands in modes different from\n+     those of the actual operands, convert the operands.  It would\n+     seem that we don't need to convert CONST_INTs, but we do, so\n+     that they're properly zero-extended, sign-extended or truncated\n+     for their mode.  */\n+\n+  if (GET_MODE (xop0) != mode0 && mode0 != VOIDmode)\n+    xop0 = convert_modes (mode0,\n+\t\t\t  GET_MODE (xop0) != VOIDmode\n+\t\t\t  ? GET_MODE (xop0)\n+\t\t\t  : mode,\n+\t\t\t  xop0, unsignedp);\n+\n+  if (GET_MODE (xop1) != mode1 && mode1 != VOIDmode)\n+    xop1 = convert_modes (mode1,\n+\t\t\t  GET_MODE (xop1) != VOIDmode\n+\t\t\t  ? GET_MODE (xop1)\n+\t\t\t  : mode,\n+\t\t\t  xop1, unsignedp);\n+\n+  /* If operation is commutative,\n+     try to make the first operand a register.\n+     Even better, try to make it the same as the target.\n+     Also try to make the last operand a constant.  */\n+  if (commutative_p\n+      && swap_commutative_operands_with_target (target, xop0, xop1))\n+    {\n+      swap = xop1;\n+      xop1 = xop0;\n+      xop0 = swap;\n+    }\n+\n   /* Now, if insn's predicates don't allow our operands, put them into\n      pseudo regs.  */\n \n@@ -1291,41 +1323,25 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n     tmp_mode = mode;\n \n   create_output_operand (&ops[0], target, tmp_mode);\n-  create_convert_operand_from (&ops[1], xop0, mode, unsignedp);\n-  create_convert_operand_from (&ops[2], xop1, mode, unsignedp);\n-  if (maybe_legitimize_operands (icode, 0, 3, ops))\n-    {\n-      /* If operation is commutative,\n-\t try to make the first operand a register.\n-\t Even better, try to make it the same as the target.\n-\t Also try to make the last operand a constant.  */\n-      if (commutative_p\n-\t  && swap_commutative_operands_with_target (ops[0].value, ops[1].value,\n-\t\t\t\t\t\t    ops[2].value))\n+  create_input_operand (&ops[1], xop0, mode0);\n+  create_input_operand (&ops[2], xop1, mode1);\n+  pat = maybe_gen_insn (icode, 3, ops);\n+  if (pat)\n+    {\n+      /* If PAT is composed of more than one insn, try to add an appropriate\n+\t REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n+\t operand, call expand_binop again, this time without a target.  */\n+      if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n+\t  && ! add_equal_note (pat, ops[0].value, binoptab->code,\n+\t\t\t       ops[1].value, ops[2].value))\n \t{\n-\t  swap = ops[2].value;\n-\t  ops[2].value = ops[1].value;\n-\t  ops[1].value = swap;\n+\t  delete_insns_since (last);\n+\t  return expand_binop (mode, binoptab, op0, op1, NULL_RTX,\n+\t\t\t       unsignedp, methods);\n \t}\n \n-      pat = GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value);\n-      if (pat)\n-\t{\n-\t  /* If PAT is composed of more than one insn, try to add an appropriate\n-\t     REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n-\t     operand, call expand_binop again, this time without a target.  */\n-\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t      && ! add_equal_note (pat, ops[0].value, binoptab->code,\n-\t\t\t\t   ops[1].value, ops[2].value))\n-\t    {\n-\t      delete_insns_since (last);\n-\t      return expand_binop (mode, binoptab, op0, op1, NULL_RTX,\n-\t\t\t\t   unsignedp, methods);\n-\t    }\n-\n-\t  emit_insn (pat);\n-\t  return ops[0].value;\n-\t}\n+      emit_insn (pat);\n+      return ops[0].value;\n     }\n   delete_insns_since (last);\n   return NULL_RTX;"}]}