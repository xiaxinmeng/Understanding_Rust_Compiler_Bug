{"sha": "4792ac86164fcb5aac8029e5208546944228d7a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc5MmFjODYxNjRmY2I1YWFjODAyOWU1MjA4NTQ2OTQ0MjI4ZDdhMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-12T03:30:32Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-12T03:30:32Z"}, "message": "Initial revision\n\nFrom-SVN: r179", "tree": {"sha": "a9464322e275fcb655e909cc9bce23fce587b862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9464322e275fcb655e909cc9bce23fce587b862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4792ac86164fcb5aac8029e5208546944228d7a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4792ac86164fcb5aac8029e5208546944228d7a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4792ac86164fcb5aac8029e5208546944228d7a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4792ac86164fcb5aac8029e5208546944228d7a2/comments", "author": null, "committer": null, "parents": [{"sha": "30affc8c171e993b445bf18d866b51a6d595d0a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30affc8c171e993b445bf18d866b51a6d595d0a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30affc8c171e993b445bf18d866b51a6d595d0a3"}], "stats": {"total": 349, "additions": 349, "deletions": 0}, "files": [{"sha": "59eb370370610c49a12853945cd24b8a0ccd7c8d", "filename": "gcc/config/m68k/sgs.h", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4792ac86164fcb5aac8029e5208546944228d7a2/gcc%2Fconfig%2Fm68k%2Fsgs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4792ac86164fcb5aac8029e5208546944228d7a2/gcc%2Fconfig%2Fm68k%2Fsgs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsgs.h?ref=4792ac86164fcb5aac8029e5208546944228d7a2", "patch": "@@ -0,0 +1,349 @@\n+/* Definitions of target machine for GNU compiler for m68k targets using\n+   assemblers derived from AT&T \"SGS\" releases.\n+\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Fred Fish (fnf@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Control assembler-syntax conditionals in m68k.md and conditionals in\n+   m68k.h.  Note that some systems may also require SGS_SWAP_W and/or\n+   SGS_SWITCH_TABLES to be defined as well.  */\n+\n+#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n+#define SGS\t\t\t/* Uses SGS assembler */\n+#define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n+\n+#include \"m68k.h\"\n+\n+/* SGS specific assembler pseudo ops. */\n+\n+#define\tBYTE_ASM_OP\t\t\"\\t.byte\"\n+#define WORD_ASM_OP\t\t\"\\t.short\"\n+#define LONG_ASM_OP\t\t\"\\t.long\"\n+#define SPACE_ASM_OP\t\t\"\\t.space\"\n+#define ALIGN_ASM_OP\t\t\"\\t.align\"\n+#define GLOBAL_ASM_OP\t\t\"\\t.global\"\n+#define SWBEG_ASM_OP\t\t\"\\t.swbeg\"\n+#define SET_ASM_OP\t\t\"\\t.set\"\n+\n+#define UNALIGNED_SHORT_ASM_OP\t\"\\t.short\"\t/* Used in dwarfout.c */\n+#define UNALIGNED_INT_ASM_OP\t\"\\t.long\"\t/* Used in dwarfout.c */\n+\n+#define ASM_PN_FORMAT\t\t\"%s_%d\"\t\t/* Format for private names */\n+\n+/* Here are four prefixes that are used by asm_fprintf to\n+   facilitate customization for alternate assembler syntaxes.\n+   Machines with no likelihood of an alternate syntax need not\n+   define these and need not use asm_fprintf.  */\n+\n+/* The prefix for register names.  Note that REGISTER_NAMES\n+   is supposed to include this prefix. Also note that this is NOT an\n+   fprintf format string, it is a literal string */\n+\n+#undef REGISTER_PREFIX\n+#define REGISTER_PREFIX \"%\"\n+\n+/* The prefix for local (compiler generated) labels.\n+   These labels will not appear in the symbol table. */\n+\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+/* The prefix to add to user-visible assembler symbols. */\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+\n+/* The prefix for immediate operands.  */\n+\n+#undef IMMEDIATE_PREFIX\n+#define IMMEDIATE_PREFIX \"&\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number.\n+   Motorola format uses different register names than defined in m68k.h.\n+   We also take this chance to convert 'a6' to 'fp' */\n+\n+#undef REGISTER_NAMES\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+#define REGISTER_NAMES \\\n+{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n+ \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t     \\\n+ \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\" }\n+\n+#else /* SUPPORTED_SUN_FPA */\n+\n+#define REGISTER_NAMES \\\n+{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n+ \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t     \\\n+ \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\",\t     \\\n+ \"%fpa0\", \"%fpa1\", \"%fpa2\", \"%fpa3\", \"%fpa4\", \"%fpa5\", \"%fpa6\",\"%fpa7\",\t     \\\n+ \"%fpa8\", \"%fpa9\", \"%fpa10\",\"%fpa11\",\"%fpa12\",\"%fpa13\",\"%fpa14\",\"%fpa15\",    \\\n+ \"%fpa16\",\"%fpa17\",\"%fpa18\",\"%fpa19\",\"%fpa20\",\"%fpa21\",\"%fpa22\",\"%fpa23\",    \\\n+ \"%fpa24\",\"%fpa25\",\"%fpa26\",\"%fpa27\",\"%fpa28\",\"%fpa29\",\"%fpa30\",\"%fpa31\" }\n+\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+/* When using an SGS assembler, modify the name of the artificial label which\n+   identifies this file as having been compiled with gcc, and the macro that\n+   emits such a label in the assembly output, to use '%' rather than '.' */\n+\n+#define ASM_IDENTIFY_GCC(FILE)\t\t\t\t\\\n+ { fprintf ((FILE), \"%s:\\n\", \"gcc2_compiled%\"); }\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+/* The SGS assembler doesn't understand \".word\". */\n+\n+#undef ASM_OUTPUT_SHORT\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)\t\t\t\\\n+( fprintf ((FILE), \"%s \", WORD_ASM_OP),\t\t\t\\\n+  output_addr_const ((FILE), (VALUE)),\t\t\t\\\n+  fprintf ((FILE), \"\\n\"))\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n+do { union { double d; long l[2]; } tem;\t\t\\\n+     tem.d = (VALUE);\t\t\t\t\t\\\n+     fprintf((FILE), \"%s 0x%x,0x%x\\n\", LONG_ASM_OP,\t\\\n+\t     tem.l[0], tem.l[1]);\t\t\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n+do { union { float f; long l;} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf ((FILE), \"%s 0x%x\\n\", LONG_ASM_OP, tem.l); \\\n+   } while (0)\n+\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\t\\\n+  if ((LOG) > 0)\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s \\t%u\\n\", ALIGN_ASM_OP, 1 << (LOG));\t\\\n+  else if ((LOG) > 31)\t\t\t\t\t\t\\\n+    abort ();\n+\n+/* The routine used to output null terminated string literals.  We cannot\n+   use the \".string\" pseudo op, because it silently truncates strings to\n+   1023 bytes.  There is no \"partial string op\" which works like \".string\"\n+   but doesn't append a null byte, so we can't chop the input string up\n+   into small pieces and use that.  Our only remaining alternative is to\n+   output the string one byte at a time. */\n+\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  register int sp = 0, lp = 0, ch;\t\t\t\t\\\n+  fprintf ((FILE), \"%s \", BYTE_ASM_OP);\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    ch = (PTR)[sp];\t\t\t\t\t\t\\\n+    if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"'%c\", ch);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"0x%x\", ch);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (++sp < (LEN))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tif ((sp % 10) == 0)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf ((FILE), \"\\n%s \", BYTE_ASM_OP);\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    putc (',', (FILE));\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (sp < (LEN));\t\t\t\t\t\t\\\n+  putc ('\\n', (FILE));\t\t\t\t\t\t\\\n+}\n+\n+\n+/* SGS based assemblers don't understand #NO_APP and #APP, so just don't\n+   bother emitting them. */\n+\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \"\"\n+\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF \"\"\n+\n+/* When using SGS derived assemblers, change the \"MIT\" or \"MOTOROLA\"\n+   to \"SGS/AT&T\"  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (68k, SGS/AT&T syntax)\");\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"%s \", GLOBAL_ASM_OP);\t\t\t\\\n+\tassemble_name ((FILE), NAME);\t\t\t\t\\\n+\tfputs (\"\\n\", FILE);\t\t\t\t\t\\\n+    } while (0)\n+\n+#undef PRINT_OPERAND_PRINT_FLOAT\n+#define PRINT_OPERAND_PRINT_FLOAT(CODE,FILE)\t\t\t\\\n+\tasm_fprintf ((FILE), \"%I0x%x\", u1.i);\n+\n+#undef ASM_OUTPUT_DOUBLE_OPERAND\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\\\n+\tasm_fprintf ((FILE),\"%I0x%x%08x\", u.i[0], u.i[1]);\n+\n+/* How to output a block of SIZE zero bytes.  Note that the `space' pseudo,\n+   when used in the text segment, causes SGS assemblers to output nop insns\n+   rather than 0s, so we set ASM_NO_SKIP_IN_TEXT to prevent this. */\n+\n+#define ASM_NO_SKIP_IN_TEXT 1\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"%s %u\\n\", SPACE_ASM_OP, (SIZE))\n+\n+/* Translate Motorola opcodes such as `jbeq' into SGS opcodes such\n+   as `beq.w'.\n+   Delete the `e' in `move...' and `fmove'.\n+   Change `ftst' to `ftest'.\n+   Change `fbne' to `fbneq'\n+   Change `fsne' to `fsneq'\n+   Change `divsl' to `tdivs' (32/32 -> 32r:32q)\n+   Change `divul' to `tdivu' (32/32 -> 32r:32q)\n+   */\n+\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  extern int flag_pic;\t\t\t\t\t\\\n+  if (!strncmp ((PTR), \"jbsr\", 4)) {\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\\\n+      fprintf ((FILE), \"bsr\");\t\t\t\t\\\n+    else\t\t\t\t\t\t\\\n+      fprintf ((FILE),\"jsr\");\t\t\t\t\\\n+    (PTR) += 4;\t\t\t\t\t\t\\\n+  } else if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\\\n+    { ++(PTR);\t\t\t\t\t\t\\\n+      while (*(PTR) != ' ')\t\t\t\t\\\n+\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n+      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n+/* FMOVE ==> FMOV, (and F%& F%$ translations) */\t\\\n+  else if ((PTR)[0] == 'f')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!strncmp ((PTR), \"fmove\", 5))\t\t\t\\\n+\t{ fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\\\n+      else if (!strncmp ((PTR), \"ftst\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"ftest\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"fbne\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"fbneq\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"fsne\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"fsneq\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"f%$move\", 7))\t\t\\\n+\t{ (PTR) += 7;\t\t\t\t\t\\\n+\t  if (TARGET_68040_ONLY)\t\t\t\\\n+\t    fprintf ((FILE), \"fsmov\");\t\t\t\\\n+\t  else fprintf ((FILE), \"fmov\"); }\t\t\\\n+      else if (!strncmp ((PTR), \"f%&move\", 7))\t\t\\\n+\t{ (PTR) += 7;\t\t\t\t\t\\\n+\t  if (TARGET_68040_ONLY)\t\t\t\\\n+\t    fprintf ((FILE), \"fdmov\");\t\t\t\\\n+\t  else fprintf ((FILE), \"fmov\"); }\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+/* MOVE, MOVEA, MOVEQ, MOVEC ==> MOV\t*/\t\t\\\n+  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n+    { fprintf ((FILE), \"mov\"); (PTR) += 4;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'a' ||\t\\\n+\t   (PTR)[0] == 'c') (PTR)++; }\t\t\t\\\n+/* SUB, SUBQ, SUBA, SUBI ==> SUB */\t\t\t\\\n+  else if ((PTR)[0] == 's' && (PTR)[1] == 'u' \t\t\\\n+\t   && (PTR)[2] == 'b')\t\t\t\t\\\n+    { fprintf ((FILE), \"sub\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'i' || \t\\\n+\t   (PTR)[0] == 'a') (PTR)++; }\t\t\t\\\n+/* CMP, CMPA, CMPI, CMPM ==> CMP\t*/\t\t\\\n+  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n+\t   && (PTR)[2] == 'p')\t\t\t\t\\\n+    { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'a' || (PTR)[0] == 'i' || \t\\\n+\t   (PTR)[0] == 'm') (PTR)++; }\t\t\t\\\n+/* DIVSL ==> TDIVS */\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 's'\t\\\n+\t   && (PTR)[4] == 'l')\t\t\t\t\\\n+    { fprintf ((FILE), \"tdivs\"); (PTR) += 5; }\t\t\\\n+/* DIVUL ==> TDIVU */\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'u'\t\\\n+\t   && (PTR)[4] == 'l')\t\t\t\t\\\n+    { fprintf ((FILE), \"tdivu\"); (PTR) += 5; }\t\t\\\n+}\n+\n+/* This macro outputs the label at the start of a switch table.  The\n+   \".swbeg <N>\" is an assembler directive that causes the switch table\n+   size to be inserted into the object code so that disassemblers, for\n+   example, can identify that it is the start of a switch table. */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n+    fprintf ((FILE), \"%s &%d\\n\", SWBEG_ASM_OP, XVECLEN (PATTERN (TABLE), 1)); \\\n+    ASM_OUTPUT_INTERNAL_LABEL((FILE),(PREFIX),(NUM));\n+\n+/* At end of a switch table, define LDnnn iff the symbol LInnn was defined.\n+   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n+   fails to assemble.  Luckily \"Lnnn(pc,d0.l*2)\" produces the results\n+   we want.  This difference can be accommodated by using an assembler\n+   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n+   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n+   macro. */\n+\n+#undef ASM_OUTPUT_CASE_END\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\\\n+  if (RTX_INTEGRATED_P (TABLE))\t\t\t\t\\\n+    asm_fprintf (FILE, \"%s %LLD%d,%LL%d-%LLI%d-2.b\\n\",\t\\\n+\t\t SET_ASM_OP, (NUM), (NUM), (NUM))\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+  asm_fprintf (FILE, \"%s %LL%d-%LL%d\\n\", WORD_ASM_OP, VALUE, REL)\n+\n+/* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to\n+   keep switch tables in the text section. */\n+   \n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), ASM_PN_FORMAT, (NAME), (LABELNO)))\n+"}]}