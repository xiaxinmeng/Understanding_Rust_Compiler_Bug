{"sha": "dac975d3d9c4d3eb1795075106e82debb39ec9d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFjOTc1ZDNkOWM0ZDNlYjE3OTUwNzUxMDZlODJkZWJiMzllYzlkMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-05-11T01:03:45Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-05-11T01:03:45Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (awt_java_source_files): Added Polygon.java.\n\t* java/awt/Polygon.java: New file.\n\n\t* java/awt/geom/AffineTransform.java\n\t(setToRotation(double,double,double)): New method.\n\t(AffineTransform): Set type to TYPE_GENERAL_TRANSFORM.\n\t(setToShear): Likewise.\n\nFrom-SVN: r41954", "tree": {"sha": "d7496f1d63531dbeea11abc5f433bec0dc4c90b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7496f1d63531dbeea11abc5f433bec0dc4c90b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dac975d3d9c4d3eb1795075106e82debb39ec9d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac975d3d9c4d3eb1795075106e82debb39ec9d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dac975d3d9c4d3eb1795075106e82debb39ec9d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac975d3d9c4d3eb1795075106e82debb39ec9d0/comments", "author": null, "committer": null, "parents": [{"sha": "d466c016c50efecf196da2fa2580b3766f3002ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d466c016c50efecf196da2fa2580b3766f3002ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d466c016c50efecf196da2fa2580b3766f3002ae"}], "stats": {"total": 453, "additions": 450, "deletions": 3}, "files": [{"sha": "bb2250185d095b5c414f5c20197d122c41442000", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac975d3d9c4d3eb1795075106e82debb39ec9d0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac975d3d9c4d3eb1795075106e82debb39ec9d0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=dac975d3d9c4d3eb1795075106e82debb39ec9d0", "patch": "@@ -1,3 +1,14 @@\n+2001-05-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (awt_java_source_files): Added Polygon.java.\n+\t* java/awt/Polygon.java: New file.\n+\n+\t* java/awt/geom/AffineTransform.java\n+\t(setToRotation(double,double,double)): New method.\n+\t(AffineTransform): Set type to TYPE_GENERAL_TRANSFORM.\n+\t(setToShear): Likewise.\n+\n 2001-05-10  Tom Tromey  <tromey@redhat.com>\n \n \t* java/util/GregorianCalendar.java: Imported from Classpath."}, {"sha": "ad4df2c47a0202594de17a8e5d1db27c7fcc6fe5", "filename": "libjava/java/awt/Polygon.java", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac975d3d9c4d3eb1795075106e82debb39ec9d0/libjava%2Fjava%2Fawt%2FPolygon.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac975d3d9c4d3eb1795075106e82debb39ec9d0/libjava%2Fjava%2Fawt%2FPolygon.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPolygon.java?ref=dac975d3d9c4d3eb1795075106e82debb39ec9d0", "patch": "@@ -0,0 +1,422 @@\n+/* Copyright (C) 2001  Free Software Foundation\n+\n+   This file is part of libjava.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libjava License.  Please consult the file \"LIBJAVA_LICENSE\" for\n+details.  */\n+\n+package java.awt;\n+\n+import java.awt.geom.*;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/**\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @date May 10, 2001\n+ */\n+\n+/** The Polygon class represents a closed region whose boundary is\n+    made of line segments.  The Polygon is defined by its vertices.  */\n+public class Polygon implements Shape, Serializable\n+{\n+  /** The bounds of the polygon.  This is null until the bounds have\n+   *  been computed for the first time; then it is correctly\n+   *  maintained whenever it is modified.  */\n+  protected Rectangle bounds;\n+\n+  /** The number of points in the polygon.  */\n+  public int npoints;\n+\n+  /** The x coordinates of the points.  */\n+  public int[] xpoints;\n+\n+  /** The y coordinates of the points.  */\n+  public int[] ypoints;\n+\n+  /** Create a new, empty Polygon.  */\n+  public Polygon ()\n+  {\n+    this.xpoints = new int[0];\n+    this.ypoints = new int[0];\n+    this.npoints = 0;\n+  }\n+\n+  /** Create a new Polygon from the given vertices.\n+   * @param xpoints The x coordinates\n+   * @param ypoints The y coordinates\n+   * @param npoints The number of points\n+   */\n+  public Polygon (int[] xpoints, int[] ypoints, int npoints)\n+  {\n+    // We make explicit copies instead of relying on clone so that we\n+    // ensure the new arrays are the same size.\n+    this.xpoints = new int[npoints];\n+    this.ypoints = new int[npoints];\n+    System.arraycopy (xpoints, 0, this.xpoints, 0, npoints);\n+    System.arraycopy (ypoints, 0, this.ypoints, 0, npoints);\n+  }\n+\n+  /** Append the specified point to this Polygon.\n+   * @param x The x coordinate\n+   * @param y The y coordinate\n+   */\n+  public void addPoint (int x, int y)\n+  {\n+    int[] newx = new int[npoints + 1];\n+    System.arraycopy (xpoints, 0, newx, 0, npoints);\n+    int[] newy = new int[npoints + 1];\n+    System.arraycopy (ypoints, 0, newy, 0, npoints);\n+    newx[npoints] = x;\n+    newy[npoints] = y;\n+    ++npoints;\n+    xpoints = newx;\n+    ypoints = newy;\n+\n+    // It is simpler to just recompute.\n+    if (bounds != null)\n+      computeBoundingBox ();\n+  }\n+\n+  /** Return true if the indicated point is inside this Polygon.\n+   * This uses an even-odd rule to determine insideness.\n+   * @param x The x coordinate\n+   * @param y The y coordinate\n+   * @returns true if the point is contained by this Polygon.\n+   */\n+  public boolean contains (double x, double y)\n+  {\n+    // What we do is look at each line segment.  If the line segment\n+    // crosses the \"scan line\" at y at a point x' < x, then we\n+    // increment our counter.  At the end, an even number means the\n+    // point is outside the polygon.  Instead of a number, though, we\n+    // use a boolean.\n+    boolean inside = false;\n+    for (int i = 0; i < npoints; ++i)\n+      {\n+\t// Handle the wrap case.\n+\tint x2 = (i == npoints) ? xpoints[0] : xpoints[i + 1];\n+\tint y2 = (i == npoints) ? ypoints[0] : ypoints[i + 1];\n+\n+\tif (ypoints[i] == y2)\n+\t  {\n+\t    // We ignore horizontal lines.  This might give weird\n+\t    // results in some situations -- ?\n+\t    continue;\n+\t  }\n+\n+\tdouble t = (y - ypoints[i]) / (double) (y2 - ypoints[i]);\n+\tdouble x3 = xpoints[i] + t * (x2 - xpoints[i]);\n+\tif (x3 < x)\n+\t  inside = ! inside;\n+      }\n+\n+    return inside;\n+  }\n+\n+  /** Return true if the indicated rectangle is entirely inside this\n+   * Polygon.\n+   * This uses an even-odd rule to determine insideness.\n+   * @param x The x coordinate\n+   * @param y The y coordinate\n+   * @param w The width\n+   * @param h The height\n+   * @returns true if the rectangle is contained by this Polygon.\n+   */\n+  public boolean contains (double x, double y, double w, double h)\n+  {\n+    return intersectOrContains (x, y, w, h, false);\n+  }\n+\n+  /** Return true if the indicated point is inside this Polygon.\n+   * This uses an even-odd rule to determine insideness.\n+   * @param x The x coordinate\n+   * @param y The y coordinate\n+   * @returns true if the point is contained by this Polygon.\n+   */\n+  public boolean contains (int x, int y)\n+  {\n+    return contains ((double) x, (double) y);\n+  }\n+\n+  /** Return true if the indicated point is inside this Polygon.\n+   * This uses an even-odd rule to determine insideness.\n+   * @param p The point\n+   * @returns true if the point is contained by this Polygon.\n+   */\n+  public boolean contains (Point p)\n+  {\n+    return contains (p.x, p.y);\n+  }\n+\n+  /** Return true if the indicated point is inside this Polygon.\n+   * This uses an even-odd rule to determine insideness.\n+   * @param p The point\n+   * @returns true if the point is contained by this Polygon.\n+   */\n+  public boolean contains (Point2D p)\n+  {\n+    return contains (p.getX (), p.getY ());\n+  }\n+\n+  /** Return true if the indicated rectangle is entirely inside this\n+   * Polygon.  This uses an even-odd rule to determine insideness.\n+   * @param r The rectangle\n+   * @returns true if the rectangle is contained by this Polygon.\n+   */\n+  public boolean contains (Rectangle2D r)\n+  {\n+    return contains (r.getX (), r.getY (), r.getWidth (), r.getHeight ());\n+  }\n+\n+  /** Returns the bounds of this Polygon.\n+   * @deprecated Use getBounds() instead.\n+   */\n+  public Rectangle getBoundingBox ()\n+  {\n+    if (bounds == null)\n+      computeBoundingBox ();\n+    return bounds;\n+  }\n+\n+  /** Returns the bounds of this Polygon.  */\n+  public Rectangle getBounds ()\n+  {\n+    if (bounds == null)\n+      computeBoundingBox ();\n+    return bounds;\n+  }\n+\n+  /** Returns the bounds of this Polygon.  */\n+  public Rectangle2D getBounds2D ()\n+  {\n+    if (bounds == null)\n+      computeBoundingBox ();\n+    return bounds;\t\t// Why not?\n+  }\n+\n+  /** Return an iterator for the boundary of this Polygon.\n+   * @param at A transform to apply to the coordinates.\n+   * @returns A path iterator for the Polygon's boundary.\n+   */\n+  public PathIterator getPathIterator (AffineTransform at)\n+  {\n+    return new Iterator (at);\n+  }\n+\n+  /** Return an iterator for the boundary of this Polygon.\n+   * @param at A transform to apply to the coordinates.\n+   * @param flatness The flatness of the result; it is ignored by\n+   *                 this class.\n+   * @returns A path iterator for the Polygon's boundary.\n+   */\n+  public PathIterator getPathIterator (AffineTransform at, double flatness)\n+  {\n+    // We ignore the flatness.\n+    return new Iterator (at);\n+  }\n+\n+  /** @deprecated use contains(int,int).  */\n+  public boolean inside (int x, int y)\n+  {\n+    return contains (x, y);\n+  }\n+\n+  /** Return true if this Polygon's interior intersects the given\n+   * rectangle's interior.\n+   * @param x The x coordinate\n+   * @param y The y coordinate\n+   * @param w The width\n+   * @param h The height\n+   */\n+  public boolean intersects (double x, double y, double w, double h)\n+  {\n+    return intersectOrContains (x, y, w, h, true);\n+  }\n+\n+  /** Return true if this Polygon's interior intersects the given\n+   * rectangle's interior.\n+   * @param r The rectangle\n+   */\n+  public boolean intersects (Rectangle2D r)\n+  {\n+    return intersects (r.getX (), r.getY (), r.getWidth (), r.getHeight ());\n+  }\n+\n+  // This tests for intersection with or containment of a rectangle,\n+  // depending on the INTERSECT argument.\n+  private boolean intersectOrContains (double x, double y, double w, double h,\n+\t\t\t\t       boolean intersect)\n+  {\n+    // First compute the rectangle of possible intersection points.\n+    Rectangle r = getBounds ();\n+    int minx = Math.max (r.x, (int) x);\n+    int maxx = Math.min (r.x + r.width, (int) (x + w));\n+    int miny = Math.max (r.y, (int) y);\n+    int maxy = Math.min (r.y + r.height, (int) (y + h));\n+\n+    if (miny > maxy)\n+      return false;\n+\n+    double[] crosses = new double[npoints + 1];\n+\n+    for (; miny < maxy; ++miny)\n+      {\n+\t// First compute every place where the polygon might intersect\n+\t// the scan line at Y.\n+\tint ins = 0;\n+\tfor (int i = 0; i < npoints; ++i)\n+\t  {\n+\t    // Handle the wrap case.\n+\t    int x2 = (i == npoints) ? xpoints[0] : xpoints[i + 1];\n+\t    int y2 = (i == npoints) ? ypoints[0] : ypoints[i + 1];\n+\n+\t    if (ypoints[i] == y2)\n+\t      {\n+\t\t// We ignore horizontal lines.  This might give weird\n+\t\t// results in some situations -- ?\n+\t\tcontinue;\n+\t      }\n+\n+\t    double t = (((double) miny - ypoints[i])\n+\t\t\t/ (double) (y2 - ypoints[i]));\n+\t    double x3 = xpoints[i] + t * (x2 - xpoints[i]);\n+\t    crosses[ins++] = x3;\n+\t  }\n+\n+\t// Now we can sort into increasing order and look to see if\n+\t// any point in the rectangle is in the polygon.  We examine\n+\t// every other pair due to our even-odd rule.\n+\tArrays.sort (crosses, 0, ins);\n+\tint i = intersect ? 0 : 1;\n+\tfor (; i < ins - 1; i += 2)\n+\t  {\n+\t    // Pathological case.\n+\t    if (crosses[i] == crosses[i + 1])\n+\t      continue;\n+\n+\t    // Found a point on the inside.\n+\t    if ((crosses[i] >= x && crosses[i] < x + w)\n+\t\t|| (crosses[i + 1] >= x && crosses[i + 1] < x + w))\n+\t      {\n+\t\t// If we're checking containment then we just lost.\n+\t\t// But if we're checking intersection then we just\n+\t\t// won.\n+\t\treturn intersect;\n+\t      }\n+\t  }\n+      }\n+\n+    return false;\n+  }\n+\n+  /** Translates all the vertices of the polygon via a given vector.\n+   * @param deltaX The X offset\n+   * @param deltaY The Y offset\n+   */\n+  public void translate (int deltaX, int deltaY)\n+  {\n+    for (int i = 0; i < npoints; ++i)\n+      {\n+\txpoints[i] += deltaX;\n+\typoints[i] += deltaY;\n+      }\n+\n+    if (bounds != null)\n+      {\n+\tbounds.x += deltaX;\n+\tbounds.y += deltaY;\n+      }\n+  }\n+\n+  // This computes the bounding box if required.\n+  private void computeBoundingBox ()\n+  {\n+    if (npoints == 0)\n+      {\n+\t// This is wrong if the user adds a new point, but we\n+\t// account for that in addPoint().\n+\tbounds = new Rectangle (0, 0, 0, 0);\n+      }\n+    else\n+      {\n+\tint maxx = xpoints[0];\n+\tint minx = xpoints[0];\n+\tint maxy = ypoints[0];\n+\tint miny = ypoints[0];\n+\n+\tfor (int i = 1; i < npoints; ++i)\n+\t  {\n+\t    maxx = Math.max (maxx, xpoints[i]);\n+\t    minx = Math.min (minx, xpoints[i]);\n+\t    maxy = Math.max (maxy, ypoints[i]);\n+\t    miny = Math.min (miny, ypoints[i]);\n+\t  }\n+\n+\tbounds = new Rectangle (minx, miny, maxx - minx, maxy - miny);\n+      }\n+  }\n+\n+  private class Iterator implements PathIterator\n+  {\n+    public AffineTransform xform;\n+    public int where;\n+\n+    public Iterator (AffineTransform xform)\n+    {\n+      this.xform = xform;\n+      where = 0;\n+    }\n+\n+    public int currentSegment (double[] coords)\n+    {\n+      int r;\n+\n+      if (where < npoints)\n+\t{\n+\t  coords[0] = xpoints[where];\n+\t  coords[1] = ypoints[where];\n+\t  r = (where == 0) ? SEG_MOVETO : SEG_LINETO;\n+\t  xform.transform (coords, 0, coords, 0, 1);\n+\t  ++where;\n+\t}\n+      else\n+\tr = SEG_CLOSE;\n+\n+      return r;\n+    }\n+\n+    public int currentSegment (float[] coords)\n+    {\n+      int r;\n+\n+      if (where < npoints)\n+\t{\n+\t  coords[0] = xpoints[where];\n+\t  coords[1] = ypoints[where];\n+\t  r = (where == 0) ? SEG_MOVETO : SEG_LINETO;\n+\t  xform.transform (coords, 0, coords, 0, 1);\n+\t}\n+      else\n+\tr = SEG_CLOSE;\n+\n+      return r;\n+    }\n+\n+    public int getWindingRule ()\n+    {\n+      return WIND_EVEN_ODD;\n+    }\n+\n+    public boolean isDone ()\n+    {\n+      return where == npoints + 1;\n+    }\n+\n+    public void next ()\n+    {\n+      ++where;\n+    }\n+  }\n+}"}, {"sha": "8e9b8f04cfce20a211deaa543cc7d03035fff35b", "filename": "libjava/java/awt/geom/AffineTransform.java", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac975d3d9c4d3eb1795075106e82debb39ec9d0/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac975d3d9c4d3eb1795075106e82debb39ec9d0/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java?ref=dac975d3d9c4d3eb1795075106e82debb39ec9d0", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000  Free Software Foundation\n+/* Copyright (C) 2000, 2001  Free Software Foundation\n \n    This file is part of libjava.\n \n@@ -51,7 +51,7 @@ public AffineTransform (float m00, float m10,\n     this.m11 = m11;\n     this.m02 = m02;\n     this.m12 = m12;\n-    this.type = 0; // fixme;\n+    this.type = TYPE_GENERAL_TRANSFORM;\n   }\n \n   public AffineTransform (float[] flatmatrix)\n@@ -260,6 +260,20 @@ public void setToRotation (double theta)\n     type = TYPE_GENERAL_ROTATION;\n   }\n \n+  public void setToRotation (double theta, double x, double y)\n+  {\n+    double c = Math.cos (theta);\n+    double s = Math.sin (theta);\n+\n+    m00 = c;\n+    m01 = -s;\n+    m02 = x - x * c + y * s;\n+    m10 = s;\n+    m11 = c;\n+    m12 = y - x * s - y * c;\n+    type = TYPE_GENERAL_TRANSFORM;\n+  }\n+\n   public void setToScale (double sx, double sy)\n   {\n     m00 = sx;\n@@ -274,7 +288,7 @@ public void setToShear (double shx, double shy)\n     m01 = shx;\n     m10 = shy;\n     m02 = m12 = 0;\n-    type = 0;\t\t\t// FIXME\n+    type = TYPE_GENERAL_TRANSFORM;\n   }\n \n   public void setTransform (AffineTransform tx)"}]}