{"sha": "a99d95a270cabbbf43024c32ac6225da13e4aad1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk5ZDk1YTI3MGNhYmJiZjQzMDI0YzMyYWM2MjI1ZGExM2U0YWFkMQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-01-30T06:56:10Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-01-30T06:56:10Z"}, "message": "re PR fortran/34975 (Bogus error with USEing modules)\n\n2008-01-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34975\n\t* symbol.c (gfc_delete_symtree, gfc_undo_symbols): Rename\n\tdelete_symtree to gfc_delete_symtree.\n\t* gfortran.h : Add prototype for gfc_delete_symtree.\n\t* module.c (load_generic_interfaces): Transfer symbol to a\n\tunique symtree and delete old symtree, instead of renaming.\n\t(read_module): The rsym and the found symbol are the same, so\n\tthe found symtree can be deleted.\n\n\tPR fortran/34429\n\t* decl.c (match_char_spec): Remove the constraint on deferred\n\tmatching of functions and free the length expression.\n\tdelete_symtree to gfc_delete_symtree.\n\t(gfc_match_type_spec): Whitespace.\n\t(gfc_match_function_decl): Defer characteristic association for\n\tall types except BT_UNKNOWN.\n\t* parse.c (decode_specification_statement): Only derived type\n\tfunction matching is delayed to the end of specification.\n\n2008-01-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34975\n\t* gfortran.dg/use_only_3.f90: New test.\n\t* gfortran.dg/use_only_3.inc: Modules for new test.\n\n\tPR fortran/34429\n\t* gfortran.dg/function_charlen_2.f90: New test.\n\nFrom-SVN: r131956", "tree": {"sha": "0114132c0dd451283cabb7a4b589fc60b10dae25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0114132c0dd451283cabb7a4b589fc60b10dae25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a99d95a270cabbbf43024c32ac6225da13e4aad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a99d95a270cabbbf43024c32ac6225da13e4aad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a99d95a270cabbbf43024c32ac6225da13e4aad1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a99d95a270cabbbf43024c32ac6225da13e4aad1/comments", "author": null, "committer": null, "parents": [{"sha": "7ae252ab69e5498454d5ef1592eabd503353d17e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ae252ab69e5498454d5ef1592eabd503353d17e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ae252ab69e5498454d5ef1592eabd503353d17e"}], "stats": {"total": 1163, "additions": 1128, "deletions": 35}, "files": [{"sha": "640681b6ed8f7fab310f1071f704c2da87bc9b78", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -1,3 +1,24 @@\n+2008-01-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34975\n+\t* symbol.c (gfc_delete_symtree, gfc_undo_symbols): Rename\n+\tdelete_symtree to gfc_delete_symtree.\n+\t* gfortran.h : Add prototype for gfc_delete_symtree.\n+\t* module.c (load_generic_interfaces): Transfer symbol to a\n+\tunique symtree and delete old symtree, instead of renaming.\n+\t(read_module): The rsym and the found symbol are the same, so\n+\tthe found symtree can be deleted.\n+\n+\tPR fortran/34429\n+\t* decl.c (match_char_spec): Remove the constraint on deferred\n+\tmatching of functions and free the length expression.\n+\tdelete_symtree to gfc_delete_symtree.\n+\t(gfc_match_type_spec): Whitespace.\n+\t(gfc_match_function_decl): Defer characteristic association for\n+\tall types except BT_UNKNOWN.\n+\t* parse.c (decode_specification_statement): Only derived type\n+\tfunction matching is delayed to the end of specification.\n+\n 2008-01-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR libfortran/34980"}, {"sha": "06c1df3c4fa6e30efef785a84ecb7de6f125ef09", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -2151,13 +2151,10 @@ match_char_spec (gfc_typespec *ts)\n   return m;\n \n done:\n-  /* Except in the case of the length being a function, where symbol\n-     association looks after itself, deal with character functions\n-     after the specification statements.  */\n-  if (gfc_matching_function\n-\t&& !(len && len->expr_type != EXPR_VARIABLE\n-\t\t && len->expr_type != EXPR_OP))\n+  /* Deal with character functions after USE and IMPORT statements.  */\n+  if (gfc_matching_function)\n     {\n+      gfc_free_expr (len);\n       gfc_undo_symbols ();\n       return MATCH_YES;\n     }\n@@ -2222,8 +2219,8 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n   /* A belt and braces check that the typespec is correctly being treated\n      as a deferred characteristic association.  */\n   seen_deferred_kind = (gfc_current_state () == COMP_FUNCTION)\n-\t\t\t\t\t&& (gfc_current_block ()->result->ts.kind == -1)\n-\t\t\t\t\t&& (ts->kind == -1);\n+\t\t\t  && (gfc_current_block ()->result->ts.kind == -1)\n+\t\t\t  && (ts->kind == -1);\n   gfc_clear_ts (ts);\n   if (seen_deferred_kind)\n     ts->kind = -1;\n@@ -4358,21 +4355,13 @@ gfc_match_function_decl (void)\n \t  goto cleanup;\n \t}\n \n-      /* Except in the case of a function valued character length,\n-\t delay matching the function characteristics until after the\n+      /* Delay matching the function characteristics until after the\n \t specification block by signalling kind=-1.  */\n-      if (!(current_ts.type == BT_CHARACTER\n-\t      && current_ts.cl\n-\t      && current_ts.cl->length\n-\t      && current_ts.cl->length->expr_type != EXPR_OP\n-\t      && current_ts.cl->length->expr_type != EXPR_VARIABLE))\n-\t{\n-\t  sym->declared_at = old_loc;\n-\t  if (current_ts.type != BT_UNKNOWN)\n-\t    current_ts.kind = -1;\n-\t  else\n-\t    current_ts.kind = 0;\n-\t}\n+      sym->declared_at = old_loc;\n+      if (current_ts.type != BT_UNKNOWN)\n+\tcurrent_ts.kind = -1;\n+      else\n+\tcurrent_ts.kind = 0;\n \n       if (result == NULL)\n \t{"}, {"sha": "5cd99c415f9cf6ae1b7438ba82d464b741c8f1d0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -2113,6 +2113,7 @@ gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);\n gfc_namespace *gfc_get_namespace (gfc_namespace *, int);\n gfc_symtree *gfc_new_symtree (gfc_symtree **, const char *);\n gfc_symtree *gfc_find_symtree (gfc_symtree *, const char *);\n+void gfc_delete_symtree (gfc_symtree **, const char *);\n gfc_symtree *gfc_get_unique_symtree (gfc_namespace *);\n gfc_user_op *gfc_get_uop (const char *);\n gfc_user_op *gfc_find_uop (const char *, gfc_namespace *);"}, {"sha": "b478d3eda9166e0eaef17485f1a24ba11fe5c533", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -3308,13 +3308,19 @@ load_generic_interfaces (void)\n \n \t  if (!sym)\n \t    {\n-\t      /* Make symtree inaccessible by renaming if the symbol has\n-\t\t been added by a USE statement without an ONLY(11.3.2).  */\n+\t      /* Make the symbol inaccessible if it has been added by a USE\n+\t\t statement without an ONLY(11.3.2).  */\n \t      if (st && only_flag\n \t\t     && !st->n.sym->attr.use_only\n \t\t     && !st->n.sym->attr.use_rename\n \t\t     && strcmp (st->n.sym->module, module_name) == 0)\n-\t\tst->name = gfc_get_string (\"hidden.%s\", name);\n+\t\t{\n+\t\t  sym = st->n.sym;\n+\t\t  gfc_delete_symtree (&gfc_current_ns->sym_root, name);\n+\t\t  st = gfc_get_unique_symtree (gfc_current_ns);\n+\t\t  st->n.sym = sym;\n+\t\t  sym = NULL;\n+\t\t}\n \t      else if (st)\n \t\t{\n \t\t  sym = st->n.sym;\n@@ -3733,21 +3739,21 @@ read_module (void)\n \t    {\n \t      st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n \n-\t      /* Make symtree inaccessible by renaming if the symbol has\n-\t\t been added by a USE statement without an ONLY(11.3.2).  */\n+\t      /* Delete the symtree if the symbol has been added by a USE\n+\t\t statement without an ONLY(11.3.2). Remember that the rsym\n+\t\t will be the same as the symbol found in the symtree, for\n+\t\t this case.*/\n \t      if (st && (only_flag || info->u.rsym.renamed)\n \t\t     && !st->n.sym->attr.use_only\n \t\t     && !st->n.sym->attr.use_rename\n-\t\t     && st->n.sym->module\n-\t\t     && strcmp (st->n.sym->module, module_name) == 0)\n-\t\tst->name = gfc_get_string (\"hidden.%s\", name);\n+\t\t     && info->u.rsym.sym == st->n.sym)\n+\t\tgfc_delete_symtree (&gfc_current_ns->sym_root, name);\n \n \t      /* Create a symtree node in the current namespace for this\n \t\t symbol.  */\n \t      st = check_unique_name (p)\n \t\t   ? gfc_get_unique_symtree (gfc_current_ns)\n \t\t   : gfc_new_symtree (&gfc_current_ns->sym_root, p);\n-\n \t      st->ambiguous = ambiguous;\n \n \t      sym = info->u.rsym.sym;"}, {"sha": "8d30beeca11377bbf6dc9168e539606988870ce7", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -110,7 +110,7 @@ decode_specification_statement (void)\n   match (\"import\", gfc_match_import, ST_IMPORT);\n   match (\"use\", gfc_match_use, ST_USE);\n \n-  if (gfc_numeric_ts (&gfc_current_block ()->ts))\n+  if (gfc_current_block ()->ts.type != BT_DERIVED)\n     goto end_of_block;\n \n   match (NULL, gfc_match_st_function, ST_STATEMENT_FUNCTION);"}, {"sha": "e97684fc1ccd97527be2ae41d7e6dc392a126c29", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -2153,8 +2153,8 @@ gfc_new_symtree (gfc_symtree **root, const char *name)\n \n /* Delete a symbol from the tree.  Does not free the symbol itself!  */\n \n-static void\n-delete_symtree (gfc_symtree **root, const char *name)\n+void\n+gfc_delete_symtree (gfc_symtree **root, const char *name)\n {\n   gfc_symtree st, *st0;\n \n@@ -2609,7 +2609,7 @@ gfc_undo_symbols (void)\n \t\t}\n \t    }\n \n-\t  delete_symtree (&p->ns->sym_root, p->name);\n+\t  gfc_delete_symtree (&p->ns->sym_root, p->name);\n \n \t  p->refs--;\n \t  if (p->refs < 0)"}, {"sha": "9c218875da701da618441be4f7e77351223f078d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -1,3 +1,12 @@\n+2008-01-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34975\n+\t* gfortran.dg/use_only_3.f90: New test.\n+\t* gfortran.dg/use_only_3.inc: Modules for new test.\n+\n+\tPR fortran/34429\n+\t* gfortran.dg/function_charlen_2.f90: New test.\n+\n 2008-01-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/34969"}, {"sha": "84d3d7e953ac0f4496d648fcda8ff71fb9214dc3", "filename": "gcc/testsuite/gfortran.dg/function_charlen_2.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_charlen_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_charlen_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_charlen_2.f90?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+! Tests the fix for PR34429 in which function charlens that were\n+! USE associated would cause an error.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module m\n+  integer, parameter :: l = 2\n+  character(2) :: cl\n+end module m\n+\n+program test\n+  implicit none\n+  integer, parameter :: l = 5\n+  character(len = 10) :: c\n+  character(4) :: cl\n+  c = f ()\n+  if (g () /= \"2\") call abort\n+contains\n+  character(len = l) function f ()\n+    use m\n+    if (len (f) /= 2) call abort\n+    f = \"a\"\n+  end function f\n+  character(len = len (cl)) function g ()\n+    use m\n+    g = \"4\"\n+    if (len (g) == 2) g= \"2\"\n+  end function g\n+end program test\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "509752a7ba48e55d7f21fafc16001fe82a1cc997", "filename": "gcc/testsuite/gfortran.dg/use_only_3.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_3.f90?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! This tests the patch for PR34975, in which 'n', 'ipol', and 'i' would be\n+! determined to have 'no IMPLICIT type'.  It turned out to be fiendishly\n+! difficult to write a testcase for this PR because even the smallest changes\n+! would make the bug disappear.  This is the testcase provided in the PR, except\n+! that all the modules are put in 'use_only_3.inc' in the same order as the\n+! makefile.  Even this has an effect; only 'n' is now determined to be\n+! improperly typed.  All this is due to the richness of the symtree and the\n+! way in which the renaming inserted new symtree entries.  Unless somenody can\n+! come up with a reduced version, this relatively large file will have to be added\n+! to the testsuite.  Fortunately, it only has to be comiled once:)\n+!  \n+! Reported by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+include 'use_only_3.inc'\n+subroutine dforceb(c0, i, betae, ipol, bec0, ctabin, gqq, gqqm, qmat, dq2, df)\n+  use gvecs\n+  use gvecw, only: ngw\n+  use parameters\n+  use electrons_base, only: nx => nbspx, n => nbsp, nspin, f\n+  use constants\n+  use cvan\n+  use ions_base\n+  use ions_base, only : nas => nax\n+  implicit none\n+\n+  integer ipol, i, ctabin\n+  complex c0(n), betae, df,&\n+       &   gqq,gqqm,&\n+       &   qmat\n+  real bec0,&\n+       &   dq2,  gmes\n+\n+ end subroutine dforceb\n+! { dg-final { cleanup-modules \"cell_base cvan gvecs kinds\" } }\n+! { dg-final { cleanup-modules \"constants electrons_base gvecw parameters\" } }\n+! { dg-final { cleanup-modules \"control_flags electrons_nose ions_base\" } }\n+"}, {"sha": "7b860096b32d787a2712b980e7758ed0d21f5e5d", "filename": "gcc/testsuite/gfortran.dg/use_only_3.inc", "status": "added", "additions": 998, "deletions": 0, "changes": 998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_3.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99d95a270cabbbf43024c32ac6225da13e4aad1/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_3.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_3.inc?ref=a99d95a270cabbbf43024c32ac6225da13e4aad1", "patch": "@@ -0,0 +1,998 @@\n+    MODULE kinds\n+      INTEGER, PARAMETER :: DP = selected_real_kind(14,200)\n+      PRIVATE\n+      PUBLIC :: DP\n+    END MODULE kinds\n+\n+MODULE constants\n+  USE kinds, ONLY : DP\n+  IMPLICIT NONE\n+  SAVE\n+  REAL(DP), PARAMETER :: pi = 3.14159265358979323846_DP\n+  REAL(DP), PARAMETER :: tpi= 2.0_DP * pi\n+  REAL(DP), PARAMETER :: fpi= 4.0_DP * pi\n+  REAL(DP), PARAMETER :: sqrtpi = 1.77245385090551602729_DP \n+  REAL(DP), PARAMETER :: sqrtpm1= 1.0_DP / sqrtpi\n+  REAL(DP), PARAMETER :: sqrt2  = 1.41421356237309504880_DP\n+  REAL(DP), PARAMETER :: H_PLANCK_SI      = 6.6260693D-34    ! J s\n+  REAL(DP), PARAMETER :: K_BOLTZMANN_SI   = 1.3806505D-23    ! J K^-1 \n+  REAL(DP), PARAMETER :: ELECTRON_SI      = 1.60217653D-19   ! C\n+  REAL(DP), PARAMETER :: ELECTRONVOLT_SI  = 1.60217653D-19   ! J  \n+  REAL(DP), PARAMETER :: ELECTRONMASS_SI  = 9.1093826D-31    ! Kg\n+  REAL(DP), PARAMETER :: HARTREE_SI       = 4.35974417D-18   ! J\n+  REAL(DP), PARAMETER :: RYDBERG_SI       = HARTREE_SI/2.0_DP! J\n+  REAL(DP), PARAMETER :: BOHR_RADIUS_SI   = 0.5291772108D-10 ! m\n+  REAL(DP), PARAMETER :: AMU_SI           = 1.66053886D-27   ! Kg\n+  REAL(DP), PARAMETER :: K_BOLTZMANN_AU   = K_BOLTZMANN_SI / HARTREE_SI\n+  REAL(DP), PARAMETER :: K_BOLTZMANN_RY   = K_BOLTZMANN_SI / RYDBERG_SI\n+  REAL(DP), PARAMETER :: AUTOEV           = HARTREE_SI / ELECTRONVOLT_SI\n+  REAL(DP), PARAMETER :: RYTOEV           = AUTOEV / 2.0_DP\n+  REAL(DP), PARAMETER :: AMU_AU           = AMU_SI / ELECTRONMASS_SI\n+  REAL(DP), PARAMETER :: AMU_RY           = AMU_AU / 2.0_DP\n+  REAL(DP), PARAMETER :: AU_SEC           = H_PLANCK_SI/tpi/HARTREE_SI\n+  REAL(DP), PARAMETER :: AU_PS            = AU_SEC * 1.0D+12\n+  REAL(DP), PARAMETER :: AU_GPA           = HARTREE_SI / BOHR_RADIUS_SI ** 3 &\n+                                            / 1.0D+9 \n+  REAL(DP), PARAMETER :: RY_KBAR          = 10.0_dp * AU_GPA / 2.0_dp\n+  !\n+  REAL(DP), PARAMETER :: DEBYE_SI         = 3.3356409519 * 1.0D-30 ! C*m \n+  REAL(DP), PARAMETER :: AU_DEBYE         = ELECTRON_SI * BOHR_RADIUS_SI / &\n+                                            DEBYE_SI\n+  REAL(DP), PARAMETER :: eV_to_kelvin = ELECTRONVOLT_SI / K_BOLTZMANN_SI\n+  REAL(DP), PARAMETER :: ry_to_kelvin = RYDBERG_SI / K_BOLTZMANN_SI\n+  REAL(DP), PARAMETER :: eps4  = 1.0D-4\n+  REAL(DP), PARAMETER :: eps6  = 1.0D-6\n+  REAL(DP), PARAMETER :: eps8  = 1.0D-8\n+  REAL(DP), PARAMETER :: eps14 = 1.0D-14\n+  REAL(DP), PARAMETER :: eps16 = 1.0D-16\n+  REAL(DP), PARAMETER :: eps32 = 1.0D-32\n+  REAL(DP), PARAMETER :: gsmall = 1.0d-12\n+  REAL(DP), PARAMETER :: e2 = 2.D0      ! the square of the electron charge\n+  REAL(DP), PARAMETER :: degspin = 2.D0 ! the number of spins per level\n+  REAL(DP), PARAMETER :: amconv = AMU_RY\n+  REAL(DP), PARAMETER :: uakbar = RY_KBAR\n+  REAL(DP), PARAMETER :: bohr_radius_cm = bohr_radius_si * 100.0\n+  REAL(DP), PARAMETER :: BOHR_RADIUS_ANGS = bohr_radius_cm * 1.0D8\n+  REAL(DP), PARAMETER :: ANGSTROM_AU = 1.0/BOHR_RADIUS_ANGS\n+  REAL(DP), PARAMETER :: DIP_DEBYE = AU_DEBYE\n+  REAL(DP), PARAMETER :: AU_TERAHERTZ  = AU_PS\n+  REAL(DP), PARAMETER :: AU_TO_OHMCMM1 = 46000.0D0 ! (ohm cm)^-1\n+  !\n+\n+END MODULE constants\n+\n+!\n+! Copyright (C) 2001-2005 Quantum-ESPRESSO group\n+! This file is distributed under the terms of the\n+! GNU General Public License. See the file `License'\n+! in the root directory of the present distribution,\n+! or http://www.gnu.org/copyleft/gpl.txt .\n+!\n+!\n+!---------------------------------------------------------------------------\n+MODULE parameters\n+  !---------------------------------------------------------------------------\n+  !\n+  IMPLICIT NONE\n+  SAVE\n+  !\n+  INTEGER, PARAMETER :: &\n+       ntypx  = 10,     &! max number of different types of atom\n+       npsx   = ntypx,  &! max number of different PPs (obsolete)\n+       npk    = 40000,  &! max number of k-points               \n+       lmaxx  = 3,      &! max non local angular momentum (l=0 to lmaxx)      \n+       nchix  = 6,      &! max number of atomic wavefunctions per atom\n+       ndmx   = 2000     ! max number of points in the atomic radial mesh\n+  !\n+  INTEGER, PARAMETER :: &\n+       nbrx = 14,          &! max number of beta functions\n+       lqmax= 2*lmaxx+1,   &! max number of angular momenta of Q\n+       nqfx = 8             ! max number of coefficients in Q smoothing\n+  !\n+  INTEGER, PARAMETER :: nacx    = 10         ! max number of averaged \n+                                             ! quantities saved to the restart\n+  INTEGER, PARAMETER :: nsx     = ntypx      ! max number of species\n+  INTEGER, PARAMETER :: natx    = 5000       ! max number of atoms\n+  INTEGER, PARAMETER :: npkx    = npk        ! max number of K points\n+  INTEGER, PARAMETER :: ncnsx   = 101        ! max number of constraints\n+  INTEGER, PARAMETER :: nspinx  = 2          ! max number of spinors\n+  !\n+  INTEGER, PARAMETER :: nhclm   = 4  ! max number NH chain length, nhclm can be\n+                                     ! easily increased since the restart file \n+                                     ! should be able to handle it, perhaps\n+                                     ! better to align nhclm by 4\n+  !\n+  INTEGER, PARAMETER :: max_nconstr = 100\n+  !\n+  INTEGER, PARAMETER  ::  maxcpu = 2**17  ! Maximum number of CPU\n+  INTEGER, PARAMETER  ::  maxgrp = 128    ! Maximum number of task-groups\n+  !\n+END MODULE parameters\n+\n+MODULE control_flags\n+  USE kinds\n+  USE parameters\n+  IMPLICIT NONE\n+  SAVE\n+  TYPE convergence_criteria\n+     !\n+     LOGICAL  :: active\n+     INTEGER  :: nstep\n+     REAL(DP) :: ekin\n+     REAL(DP) :: derho\n+     REAL(DP) :: force\n+     !\n+  END TYPE convergence_criteria\n+  !\n+  TYPE ionic_conjugate_gradient\n+     !\n+     LOGICAL  :: active\n+     INTEGER  :: nstepix\n+     INTEGER  :: nstepex\n+     REAL(DP) :: ionthr\n+     REAL(DP) :: elethr\n+     !\n+  END TYPE ionic_conjugate_gradient\n+  !\n+  CHARACTER(LEN=4) :: program_name = ' '  !  used to control execution flow inside module\n+  !\n+  LOGICAL :: tvlocw    = .FALSE. ! write potential to unit 46 (only cp, seldom used)\n+  LOGICAL :: trhor     = .FALSE. ! read rho from      unit 47 (only cp, seldom used)\n+  LOGICAL :: trhow     = .FALSE. ! CP code, write rho to restart dir\n+  !\n+  LOGICAL :: tsde          = .FALSE. ! electronic steepest descent\n+  LOGICAL :: tzeroe        = .FALSE. ! set to zero the electronic velocities\n+  LOGICAL :: tfor          = .FALSE. ! move the ions ( calculate forces )\n+  LOGICAL :: tsdp          = .FALSE. ! ionic steepest descent\n+  LOGICAL :: tzerop        = .FALSE. ! set to zero the ionic velocities\n+  LOGICAL :: tprnfor       = .FALSE. ! print forces to standard output\n+  LOGICAL :: taurdr        = .FALSE. ! read ionic position from standard input\n+  LOGICAL :: tv0rd         = .FALSE. ! read ionic velocities from standard input\n+  LOGICAL :: tpre          = .FALSE. ! calculate stress, and (in fpmd) variable cell dynamic\n+  LOGICAL :: thdyn         = .FALSE. ! variable-cell dynamics (only cp)\n+  LOGICAL :: tsdc          = .FALSE. ! cell geometry steepest descent\n+  LOGICAL :: tzeroc        = .FALSE. ! set to zero the cell geometry velocities\n+  LOGICAL :: tstress       = .FALSE. ! print stress to standard output\n+  LOGICAL :: tortho        = .FALSE. ! use iterative orthogonalization \n+  LOGICAL :: tconjgrad     = .FALSE. ! use conjugate gradient electronic minimization\n+  LOGICAL :: timing        = .FALSE. ! print out timing information\n+  LOGICAL :: memchk        = .FALSE. ! check for memory leakage\n+  LOGICAL :: tprnsfac      = .FALSE. ! print out structure factor \n+  LOGICAL :: toptical      = .FALSE. ! print out optical properties\n+  LOGICAL :: tcarpar       = .FALSE. ! tcarpar is set TRUE for a \"pure\" Car Parrinello simulation\n+  LOGICAL :: tdamp         = .FALSE. ! Use damped dinamics for electrons\n+  LOGICAL :: tdampions     = .FALSE. ! Use damped dinamics for electrons\n+  LOGICAL :: tatomicwfc    = .FALSE. ! Use atomic wavefunctions as starting guess for ch. density\n+  LOGICAL :: tscreen       = .FALSE. ! Use screened coulomb potentials for cluster calculations\n+  LOGICAL :: twfcollect    = .FALSE. ! Collect wave function in the restart file at the end of run.\n+  LOGICAL :: tuspp         = .FALSE. ! Ultra-soft pseudopotential are being used\n+  INTEGER :: printwfc      = -1      ! Print wave functions, temporarely used only by ensemble-dft\n+  LOGICAL :: force_pairing = .FALSE. ! ...   Force pairing\n+  LOGICAL :: tchi2         = .FALSE. ! Compute Chi^2\n+  !\n+  TYPE (convergence_criteria) :: tconvthrs\n+                              !  thresholds used to check GS convergence \n+  !\n+  ! ... Ionic vs Electronic step frequency\n+  ! ... When \"ion_nstep > 1\" and \"electron_dynamics = 'md' | 'sd' \", ions are \n+  ! ... propagated every \"ion_nstep\" electronic step only if the electronic \n+  ! ... \"ekin\" is lower than \"ekin_conv_thr\"\n+  !\n+  LOGICAL :: tionstep = .FALSE.\n+  INTEGER :: nstepe   = 1  \n+                            !  parameters to control how many electronic steps \n+                            !  between ions move\n+\n+  LOGICAL :: tsteepdesc = .FALSE.\n+                            !  parameters for electronic steepest desceent\n+\n+  TYPE (ionic_conjugate_gradient) :: tconjgrad_ion\n+                            !  conjugate gradient for ionic minimization\n+\n+  INTEGER :: nbeg   = 0 ! internal code for initialization ( -1, 0, 1, 2, .. )\n+  INTEGER :: ndw    = 0 !\n+  INTEGER :: ndr    = 0 !\n+  INTEGER :: nomore = 0 !\n+  INTEGER :: iprint = 0 ! print output every iprint step\n+  INTEGER :: isave  = 0 ! write restart to ndr unit every isave step\n+  INTEGER :: nv0rd  = 0 !\n+  INTEGER :: iprsta = 0 ! output verbosity (increasing from 0 to infinity)\n+  !\n+  ! ... .TRUE. if only gamma point is used\n+  !\n+  LOGICAL :: gamma_only = .TRUE.\n+  !\n+  LOGICAL :: tnewnfi = .FALSE.\n+  INTEGER :: newnfi  = 0\n+  !\n+  ! This variable is used whenever a timestep change is requested\n+  !\n+  REAL(DP) :: dt_old = -1.0D0\n+  !\n+  ! ... Wave function randomization\n+  !\n+  LOGICAL  :: trane = .FALSE.\n+  REAL(DP) :: ampre = 0.D0\n+  !\n+  ! ... Ionic position randomization\n+  !\n+  LOGICAL  :: tranp(nsx) = .FALSE.\n+  REAL(DP) :: amprp(nsx) = 0.D0\n+  !\n+  ! ... Read the cell from standard input\n+  !\n+  LOGICAL :: tbeg = .FALSE.\n+  !\n+  ! ... This flags control the calculation of the Dipole Moments\n+  !\n+  LOGICAL :: tdipole = .FALSE.\n+  !\n+  ! ... Flags that controls DIIS electronic minimization\n+  !\n+  LOGICAL :: t_diis        = .FALSE.\n+  LOGICAL :: t_diis_simple = .FALSE.\n+  LOGICAL :: t_diis_rot    = .FALSE.\n+  !\n+  ! ... Flag controlling the Nose thermostat for electrons\n+  !\n+  LOGICAL :: tnosee = .FALSE.\n+  !\n+  ! ... Flag controlling the Nose thermostat for the cell\n+  !\n+  LOGICAL :: tnoseh = .FALSE.\n+  !\n+  ! ... Flag controlling the Nose thermostat for ions\n+  !\n+  LOGICAL  :: tnosep = .FALSE.\n+  LOGICAL  :: tcap   = .FALSE.\n+  LOGICAL  :: tcp    = .FALSE.\n+  REAL(DP) :: tolp   = 0.D0   !  tolerance for temperature variation\n+  !\n+  REAL(DP), PUBLIC :: &\n+       ekin_conv_thr = 0.D0, &!  conv. threshold for fictitious e. kinetic energy\n+       etot_conv_thr = 0.D0, &!  conv. threshold for DFT energy\n+       forc_conv_thr = 0.D0   !  conv. threshold for atomic forces\n+  INTEGER, PUBLIC :: &\n+       ekin_maxiter = 100,   &!  max number of iter. for ekin convergence\n+       etot_maxiter = 100,   &!  max number of iter. for etot convergence\n+       forc_maxiter = 100     !  max number of iter. for atomic forces conv.\n+  !\n+  ! ... Several variables controlling the run ( used mainly in PW calculations )\n+  !\n+  ! ... logical flags controlling the execution\n+  !\n+  LOGICAL, PUBLIC :: &\n+    lfixatom,           &! if .TRUE. some atom is kept fixed\n+    lscf,               &! if .TRUE. the calc. is selfconsistent\n+    lbfgs,              &! if .TRUE. the calc. is a relaxation based on new BFGS scheme\n+    lmd,                &! if .TRUE. the calc. is a dynamics\n+    lmetadyn,           &! if .TRUE. the calc. is a meta-dynamics\n+    lpath,              &! if .TRUE. the calc. is a path optimizations\n+    lneb,               &! if .TRUE. the calc. is NEB dynamics\n+    lsmd,               &! if .TRUE. the calc. is string dynamics\n+    lwf,                &! if .TRUE. the calc. is with wannier functions\n+    lphonon,            &! if .TRUE. the calc. is phonon\n+    lbands,             &! if .TRUE. the calc. is band structure\n+    lconstrain,         &! if .TRUE. the calc. is constraint\n+    ldamped,            &! if .TRUE. the calc. is a damped dynamics\n+    lrescale_t,         &! if .TRUE. the ionic temperature is rescaled\n+    langevin_rescaling, &! if .TRUE. the ionic dynamics is overdamped Langevin\n+    lcoarsegrained,     &! if .TRUE. a coarse-grained phase-space is used\n+    restart              ! if .TRUE. restart from results of a preceding run\n+  !\n+  LOGICAL, PUBLIC :: &\n+    remove_rigid_rot     ! if .TRUE. the total torque acting on the atoms is\n+                         ! removed\n+  !\n+  ! ... pw self-consistency\n+  !\n+  INTEGER, PUBLIC :: &\n+    ngm0,             &! used in mix_rho\n+    niter,            &! the maximum number of iteration\n+    nmix,             &! the number of iteration kept in the history\n+    imix               ! the type of mixing (0=plain,1=TF,2=local-TF)\n+  REAL(DP), PUBLIC  :: &\n+    mixing_beta,      &! the mixing parameter\n+    tr2                ! the convergence threshold for potential\n+  LOGICAL, PUBLIC :: &\n+    conv_elec          ! if .TRUE. electron convergence has been reached\n+  !\n+  ! ... pw diagonalization\n+  !\n+  REAL(DP), PUBLIC  :: &\n+    ethr               ! the convergence threshold for eigenvalues  \n+  INTEGER, PUBLIC :: &\n+    david,            &! used on Davidson diagonalization\n+    isolve,           &! Davidson or CG or DIIS diagonalization\n+    max_cg_iter,      &! maximum number of iterations in a CG di\n+    diis_buff,        &! dimension of the buffer in diis\n+    diis_ndim          ! dimension of reduced basis in DIIS\n+  LOGICAL, PUBLIC :: &\n+    diago_full_acc     ! if true all the empty eigenvalues have the same\n+                       ! accuracy of the occupied ones\n+  !\n+  ! ... wfc and rho extrapolation\n+  !\n+  REAL(DP), PUBLIC  :: &\n+    alpha0,           &! the mixing parameters for the extrapolation\n+    beta0              ! of the starting potential\n+  INTEGER, PUBLIC :: &\n+    history,          &! number of old steps available for potential updating\n+    pot_order,        &! type of potential updating ( see update_pot )\n+    wfc_order          ! type of wavefunctions updating ( see update_pot )\n+  !\n+  ! ... ionic dynamics\n+  !\n+  INTEGER, PUBLIC :: &\n+    nstep,            &! number of ionic steps\n+    istep = 0          ! current ionic step  \n+  LOGICAL, PUBLIC :: &\n+    conv_ions          ! if .TRUE. ionic convergence has been reached\n+  REAL(DP), PUBLIC  :: &\n+    upscale            ! maximum reduction of convergence threshold\n+  !\n+  ! ... system's symmetries\n+  !\n+  LOGICAL, PUBLIC :: &\n+    nosym,            &! if .TRUE. no symmetry is used\n+    noinv = .FALSE.    ! if .TRUE. eliminates inversion symmetry\n+  !\n+  ! ... phonon calculation\n+  !\n+  INTEGER, PUBLIC :: &\n+    modenum            ! for single mode phonon calculation\n+  !\n+  ! ... printout control\n+  !\n+  LOGICAL, PUBLIC :: &\n+    reduce_io          ! if .TRUE. reduce the I/O to the strict minimum\n+  INTEGER, PUBLIC :: &\n+    iverbosity         ! type of printing ( 0 few, 1 all )\n+  LOGICAL, PUBLIC :: &\n+    use_para_diago = .FALSE.  ! if .TRUE. a parallel Householder algorithm \n+  INTEGER, PUBLIC :: &\n+    para_diago_dim = 0        ! minimum matrix dimension above which a parallel\n+  INTEGER  :: ortho_max = 0    ! maximum number of iterations in routine ortho\n+  REAL(DP) :: ortho_eps = 0.D0 ! threshold for convergence in routine ortho\n+  LOGICAL, PUBLIC :: &\n+    use_task_groups = .FALSE.  ! if TRUE task groups parallelization is used\n+  INTEGER, PUBLIC :: iesr = 1\n+  LOGICAL,          PUBLIC :: tvhmean = .FALSE.  \n+  REAL(DP),         PUBLIC :: vhrmin = 0.0d0\n+  REAL(DP),         PUBLIC :: vhrmax = 1.0d0\n+  CHARACTER(LEN=1), PUBLIC :: vhasse = 'Z'\n+  LOGICAL,          PUBLIC :: tprojwfc = .FALSE.\n+  CONTAINS\n+    SUBROUTINE fix_dependencies()\n+    END SUBROUTINE fix_dependencies\n+    SUBROUTINE check_flags()\n+    END SUBROUTINE check_flags\n+END MODULE control_flags\n+\n+!\n+! Copyright (C) 2002 FPMD group\n+! This file is distributed under the terms of the\n+! GNU General Public License. See the file `License'\n+! in the root directory of the present distribution,\n+! or http://www.gnu.org/copyleft/gpl.txt .\n+!\n+\n+!=----------------------------------------------------------------------------=!\n+   MODULE gvecw\n+!=----------------------------------------------------------------------------=!\n+     USE kinds, ONLY: DP\n+\n+     IMPLICIT NONE\n+     SAVE\n+\n+     ! ...   G vectors less than the wave function cut-off ( ecutwfc )\n+     INTEGER :: ngw  = 0  ! local number of G vectors\n+     INTEGER :: ngwt = 0  ! in parallel execution global number of G vectors,\n+                       ! in serial execution this is equal to ngw\n+     INTEGER :: ngwl = 0  ! number of G-vector shells up to ngw\n+     INTEGER :: ngwx = 0  ! maximum local number of G vectors\n+     INTEGER :: ng0  = 0  ! first G-vector with nonzero modulus\n+                       ! needed in the parallel case (G=0 is on one node only!)\n+\n+     REAL(DP) :: ecutw = 0.0d0\n+     REAL(DP) :: gcutw = 0.0d0\n+\n+     !   values for costant cut-off computations\n+\n+     REAL(DP) :: ecfix = 0.0d0     ! value of the constant cut-off\n+     REAL(DP) :: ecutz = 0.0d0     ! height of the penalty function (above ecfix)\n+     REAL(DP) :: ecsig = 0.0d0     ! spread of the penalty function around ecfix\n+     LOGICAL   :: tecfix = .FALSE.  ! .TRUE. if constant cut-off is in use\n+\n+     ! augmented cut-off for k-point calculation\n+\n+     REAL(DP) :: ekcut = 0.0d0  \n+     REAL(DP) :: gkcut = 0.0d0\n+    \n+     ! array of G vectors module plus penalty function for constant cut-off \n+     ! simulation.\n+     !\n+     ! ggp = g + ( agg / tpiba**2 ) * ( 1 + erf( ( tpiba2 * g - e0gg ) / sgg ) )\n+\n+     REAL(DP), ALLOCATABLE, TARGET :: ggp(:)\n+\n+   CONTAINS\n+\n+     SUBROUTINE deallocate_gvecw\n+       IF( ALLOCATED( ggp ) ) DEALLOCATE( ggp )\n+     END SUBROUTINE deallocate_gvecw\n+\n+!=----------------------------------------------------------------------------=!\n+   END MODULE gvecw\n+!=----------------------------------------------------------------------------=!\n+\n+!=----------------------------------------------------------------------------=!\n+   MODULE gvecs\n+!=----------------------------------------------------------------------------=!\n+     USE kinds, ONLY: DP\n+\n+     IMPLICIT NONE\n+     SAVE\n+\n+     ! ...   G vectors less than the smooth grid cut-off ( ? )\n+     INTEGER :: ngs  = 0  ! local number of G vectors\n+     INTEGER :: ngst = 0  ! in parallel execution global number of G vectors,\n+                       ! in serial execution this is equal to ngw\n+     INTEGER :: ngsl = 0  ! number of G-vector shells up to ngw\n+     INTEGER :: ngsx = 0  ! maximum local number of G vectors\n+\n+     INTEGER, ALLOCATABLE :: nps(:), nms(:)\n+\n+     REAL(DP) :: ecuts = 0.0d0\n+     REAL(DP) :: gcuts = 0.0d0\n+\n+     REAL(DP) :: dual = 0.0d0\n+     LOGICAL   :: doublegrid = .FALSE.\n+\n+   CONTAINS\n+\n+     SUBROUTINE deallocate_gvecs()\n+       IF( ALLOCATED( nps ) ) DEALLOCATE( nps )\n+       IF( ALLOCATED( nms ) ) DEALLOCATE( nms )\n+     END SUBROUTINE deallocate_gvecs\n+\n+!=----------------------------------------------------------------------------=!\n+   END MODULE gvecs\n+!=----------------------------------------------------------------------------=!\n+\n+  MODULE electrons_base\n+      USE kinds, ONLY: DP\n+      IMPLICIT NONE\n+      SAVE\n+\n+      INTEGER :: nbnd       = 0    !  number electronic bands, each band contains\n+                                   !  two spin states\n+      INTEGER :: nbndx      = 0    !  array dimension nbndx >= nbnd\n+      INTEGER :: nspin      = 0    !  nspin = number of spins (1=no spin, 2=LSDA)\n+      INTEGER :: nel(2)     = 0    !  number of electrons (up, down)\n+      INTEGER :: nelt       = 0    !  total number of electrons ( up + down )\n+      INTEGER :: nupdwn(2)  = 0    !  number of states with spin up (1) and down (2)\n+      INTEGER :: iupdwn(2)  = 0    !  first state with spin (1) and down (2)\n+      INTEGER :: nudx       = 0    !  max (nupdw(1),nupdw(2))\n+      INTEGER :: nbsp       = 0    !  total number of electronic states \n+                                   !  (nupdwn(1)+nupdwn(2))\n+      INTEGER :: nbspx      = 0    !  array dimension nbspx >= nbsp\n+\n+      LOGICAL :: telectrons_base_initval = .FALSE.\n+      LOGICAL :: keep_occ = .FALSE.  ! if .true. when reading restart file keep \n+                                     ! the occupations calculated in initval\n+\n+      REAL(DP), ALLOCATABLE :: f(:)   ! occupation numbers ( at gamma )\n+      REAL(DP) :: qbac = 0.0d0        ! background neutralizing charge\n+      INTEGER, ALLOCATABLE :: ispin(:) ! spin of each state\n+!\n+!------------------------------------------------------------------------------!\n+  CONTAINS\n+!------------------------------------------------------------------------------!\n+\n+\n+    SUBROUTINE electrons_base_initval( zv_ , na_ , nsp_ , nelec_ , nelup_ , neldw_ , nbnd_ , &\n+               nspin_ , occupations_ , f_inp, tot_charge_, multiplicity_, tot_magnetization_ )\n+      REAL(DP),         INTENT(IN) :: zv_ (:), tot_charge_\n+      REAL(DP),         INTENT(IN) :: nelec_ , nelup_ , neldw_\n+      REAL(DP),         INTENT(IN) :: f_inp(:,:)\n+      INTEGER,          INTENT(IN) :: na_ (:) , nsp_, multiplicity_, tot_magnetization_\n+      INTEGER,          INTENT(IN) :: nbnd_ , nspin_\n+      CHARACTER(LEN=*), INTENT(IN) :: occupations_\n+    END SUBROUTINE electrons_base_initval\n+\n+\n+    subroutine set_nelup_neldw ( nelec_, nelup_, neldw_, tot_magnetization_, &\n+         multiplicity_)\n+      !\n+      REAL (KIND=DP), intent(IN)    :: nelec_\n+      REAL (KIND=DP), intent(INOUT) :: nelup_, neldw_\n+      INTEGER,        intent(IN)    :: tot_magnetization_, multiplicity_\n+    end subroutine set_nelup_neldw\n+\n+!----------------------------------------------------------------------------\n+\n+\n+    SUBROUTINE deallocate_elct()\n+      IF( ALLOCATED( f ) ) DEALLOCATE( f )\n+      IF( ALLOCATED( ispin ) ) DEALLOCATE( ispin )\n+      telectrons_base_initval = .FALSE.\n+      RETURN\n+    END SUBROUTINE deallocate_elct\n+\n+\n+!------------------------------------------------------------------------------!\n+  END MODULE electrons_base\n+!------------------------------------------------------------------------------!\n+\n+\n+\n+!------------------------------------------------------------------------------!\n+  MODULE electrons_nose\n+!------------------------------------------------------------------------------!\n+\n+      USE kinds, ONLY: DP\n+!\n+      IMPLICIT NONE\n+      SAVE\n+\n+      REAL(DP) :: fnosee   = 0.0d0   !  frequency of the thermostat ( in THz )\n+      REAL(DP) :: qne      = 0.0d0   !  mass of teh termostat\n+      REAL(DP) :: ekincw   = 0.0d0   !  kinetic energy to be kept constant\n+\n+      REAL(DP) :: xnhe0   = 0.0d0   \n+      REAL(DP) :: xnhep   = 0.0d0   \n+      REAL(DP) :: xnhem   = 0.0d0   \n+      REAL(DP) :: vnhe    = 0.0d0\n+  CONTAINS\n+  subroutine electrons_nose_init( ekincw_ , fnosee_ )\n+     REAL(DP), INTENT(IN) :: ekincw_, fnosee_\n+  end subroutine electrons_nose_init\n+\n+\n+  function electrons_nose_nrg( xnhe0, vnhe, qne, ekincw )\n+    real(8) :: electrons_nose_nrg\n+    real(8), intent(in) :: xnhe0, vnhe, qne, ekincw\n+    electrons_nose_nrg = 0.0\n+  end function electrons_nose_nrg\n+\n+  subroutine electrons_nose_shiftvar( xnhep, xnhe0, xnhem )\n+    implicit none\n+    real(8), intent(out) :: xnhem\n+    real(8), intent(inout) :: xnhe0\n+    real(8), intent(in) :: xnhep\n+  end subroutine electrons_nose_shiftvar\n+\n+  subroutine electrons_nosevel( vnhe, xnhe0, xnhem, delt )\n+    implicit none\n+    real(8), intent(inout) :: vnhe\n+    real(8), intent(in) :: xnhe0, xnhem, delt \n+  end subroutine electrons_nosevel\n+\n+  subroutine electrons_noseupd( xnhep, xnhe0, xnhem, delt, qne, ekinc, ekincw, vnhe )\n+    implicit none\n+    real(8), intent(out) :: xnhep, vnhe\n+    real(8), intent(in) :: xnhe0, xnhem, delt, qne, ekinc, ekincw\n+  end subroutine electrons_noseupd\n+\n+\n+  SUBROUTINE electrons_nose_info()\n+  END SUBROUTINE electrons_nose_info\n+  END MODULE electrons_nose\n+\n+module cvan\n+  use parameters, only: nsx\n+  implicit none\n+  save\n+  integer nvb, ish(nsx)\n+  integer, allocatable:: indlm(:,:)\n+contains\n+  subroutine allocate_cvan( nind, ns )\n+    integer, intent(in) :: nind, ns\n+  end subroutine allocate_cvan\n+\n+  subroutine deallocate_cvan( )\n+  end subroutine deallocate_cvan\n+\n+end module cvan\n+\n+  MODULE cell_base\n+      USE kinds, ONLY : DP\n+      IMPLICIT NONE\n+      SAVE\n+        REAL(DP) :: alat = 0.0d0\n+        REAL(DP) :: celldm(6) = (/ 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0 /)\n+        REAL(DP) :: a1(3) = (/ 0.0d0, 0.0d0, 0.0d0 /)\n+        REAL(DP) :: a2(3) = (/ 0.0d0, 0.0d0, 0.0d0 /)\n+        REAL(DP) :: a3(3) = (/ 0.0d0, 0.0d0, 0.0d0 /)\n+        REAL(DP) :: b1(3) = (/ 0.0d0, 0.0d0, 0.0d0 /)\n+        REAL(DP) :: b2(3) = (/ 0.0d0, 0.0d0, 0.0d0 /)\n+        REAL(DP) :: b3(3) = (/ 0.0d0, 0.0d0, 0.0d0 /)\n+        REAL(DP) :: ainv(3,3) = 0.0d0\n+        REAl(DP) :: omega = 0.0d0  !  volume of the simulation cell\n+        REAL(DP) :: tpiba  = 0.0d0   !  = 2 PI / alat\n+        REAL(DP) :: tpiba2 = 0.0d0   !  = ( 2 PI / alat ) ** 2\n+        REAL(DP) :: at(3,3) = RESHAPE( (/ 0.0d0 /), (/ 3, 3 /), (/ 0.0d0 /) )\n+        REAL(DP) :: bg(3,3) = RESHAPE( (/ 0.0d0 /), (/ 3, 3 /), (/ 0.0d0 /) )\n+        INTEGER          :: ibrav      ! index of the bravais lattice\n+        CHARACTER(len=9) :: symm_type  ! 'cubic' or 'hexagonal' when ibrav=0\n+        REAL(DP) :: h(3,3)    = 0.0d0 ! simulation cell at time t \n+        REAL(DP) :: hold(3,3) = 0.0d0 ! simulation cell at time t-delt\n+        REAL(DP) :: hnew(3,3) = 0.0d0 ! simulation cell at time t+delt\n+        REAL(DP) :: velh(3,3) = 0.0d0 ! simulation cell velocity\n+        REAL(DP) :: deth      = 0.0d0 ! determinant of h ( cell volume )\n+        INTEGER   :: iforceh(3,3) = 1  ! if iforceh( i, j ) = 0 then h( i, j ) \n+        LOGICAL   :: thdiag = .FALSE.  ! True if only cell diagonal elements \n+        REAL(DP) :: wmass = 0.0d0     ! cell fictitious mass\n+        REAL(DP) :: press = 0.0d0     ! external pressure \n+        REAL(DP) :: frich  = 0.0d0    ! firction parameter for cell damped dynamics\n+        REAL(DP) :: greash = 1.0d0    ! greas parameter for damped dynamics\n+        LOGICAL :: tcell_base_init = .FALSE.\n+  CONTAINS\n+        SUBROUTINE updatecell(box_tm1, box_t0, box_tp1)\n+          integer :: box_tm1, box_t0, box_tp1\n+        END SUBROUTINE updatecell\n+        SUBROUTINE dgcell( gcdot, box_tm1, box_t0, delt )\n+          REAL(DP), INTENT(OUT) :: GCDOT(3,3)\n+          REAL(DP), INTENT(IN) :: delt\n+          integer, intent(in) :: box_tm1, box_t0\n+        END SUBROUTINE dgcell\n+\n+        SUBROUTINE cell_init_ht( box, ht )\n+          integer :: box\n+          REAL(DP) :: ht(3,3)\n+        END SUBROUTINE cell_init_ht\n+\n+        SUBROUTINE cell_init_a( box, a1, a2, a3 )\n+          integer :: box\n+          REAL(DP) :: a1(3), a2(3), a3(3)\n+        END SUBROUTINE cell_init_a\n+\n+        SUBROUTINE r_to_s1 (r,s,box)\n+          REAL(DP), intent(out) ::  S(3)\n+          REAL(DP), intent(in) :: R(3)\n+          integer, intent(in) :: box\n+        END SUBROUTINE r_to_s1\n+\n+        SUBROUTINE r_to_s3 ( r, s, na, nsp, hinv )\n+          REAL(DP), intent(out) ::  S(:,:)\n+          INTEGER, intent(in) ::  na(:), nsp\n+          REAL(DP), intent(in) :: R(:,:)\n+          REAL(DP), intent(in) :: hinv(:,:)    ! hinv = TRANSPOSE( box%m1 )\n+          integer :: i, j, ia, is, isa\n+          isa = 0\n+          DO is = 1, nsp\n+            DO ia = 1, na(is)\n+              isa = isa + 1\n+              DO I=1,3\n+                S(I,isa) = 0.D0\n+                DO J=1,3\n+                  S(I,isa) = S(I,isa) + R(J,isa)*hinv(i,j)\n+                END DO\n+              END DO\n+            END DO\n+          END DO\n+          RETURN\n+        END SUBROUTINE r_to_s3\n+\n+!------------------------------------------------------------------------------!\n+\n+        SUBROUTINE r_to_s1b ( r, s, hinv )\n+          REAL(DP), intent(out) ::  S(:)\n+          REAL(DP), intent(in) :: R(:)\n+          REAL(DP), intent(in) :: hinv(:,:)    ! hinv = TRANSPOSE( box%m1 )\n+          integer :: i, j\n+          DO I=1,3\n+            S(I) = 0.D0\n+            DO J=1,3\n+              S(I) = S(I) + R(J)*hinv(i,j)\n+            END DO\n+          END DO\n+          RETURN\n+        END SUBROUTINE r_to_s1b\n+\n+\n+        SUBROUTINE s_to_r1 (S,R,box)\n+          REAL(DP), intent(in) ::  S(3)\n+          REAL(DP), intent(out) :: R(3)\n+          integer, intent(in) :: box\n+        END SUBROUTINE s_to_r1\n+\n+        SUBROUTINE s_to_r1b (S,R,h)\n+          REAL(DP), intent(in) ::  S(3)\n+          REAL(DP), intent(out) :: R(3)\n+          REAL(DP), intent(in) :: h(:,:)    ! h = TRANSPOSE( box%a )\n+        END SUBROUTINE s_to_r1b\n+\n+        SUBROUTINE s_to_r3 ( S, R, na, nsp, h )\n+          REAL(DP), intent(in) ::  S(:,:)\n+          INTEGER, intent(in) ::  na(:), nsp\n+          REAL(DP), intent(out) :: R(:,:)\n+          REAL(DP), intent(in) :: h(:,:)    ! h = TRANSPOSE( box%a )\n+        END SUBROUTINE s_to_r3\n+\n+      SUBROUTINE gethinv(box)\n+        IMPLICIT NONE\n+        integer, INTENT (INOUT) :: box\n+      END SUBROUTINE gethinv\n+\n+\n+      FUNCTION get_volume( hmat )\n+         IMPLICIT NONE\n+         REAL(DP) :: get_volume\n+         REAL(DP) :: hmat( 3, 3 )\n+          get_volume = 4.4\n+      END FUNCTION get_volume\n+\n+      FUNCTION pbc(rin,box,nl) RESULT (rout)\n+        IMPLICIT NONE\n+        integer :: box\n+        REAL (DP) :: rin(3)\n+        REAL (DP) :: rout(3), s(3)\n+        INTEGER, OPTIONAL :: nl(3)\n+        rout = 4.4\n+      END FUNCTION pbc\n+\n+          SUBROUTINE get_cell_param(box,cell,ang)\n+          IMPLICIT NONE\n+          integer, INTENT(in) :: box\n+          REAL(DP), INTENT(out), DIMENSION(3) :: cell\n+          REAL(DP), INTENT(out), DIMENSION(3), OPTIONAL :: ang\n+          END SUBROUTINE get_cell_param\n+\n+      SUBROUTINE pbcs_components(x1, y1, z1, x2, y2, z2, m)\n+        USE kinds\n+        INTEGER, INTENT(IN)  :: M\n+        REAL(DP),  INTENT(IN)  :: X1,Y1,Z1\n+        REAL(DP),  INTENT(OUT) :: X2,Y2,Z2\n+        REAL(DP) MIC\n+      END SUBROUTINE pbcs_components\n+\n+      SUBROUTINE pbcs_vectors(v, w, m)\n+        USE kinds\n+        INTEGER, INTENT(IN)  :: m\n+        REAL(DP),  INTENT(IN)  :: v(3)\n+        REAL(DP),  INTENT(OUT) :: w(3)\n+        REAL(DP) :: MIC\n+      END SUBROUTINE pbcs_vectors\n+\n+  SUBROUTINE cell_base_init( ibrav_ , celldm_ , trd_ht, cell_symmetry, rd_ht, cell_units, &\n+               a_ , b_ , c_ , cosab, cosac, cosbc, wc_ , total_ions_mass , press_ ,  &\n+               frich_ , greash_ , cell_dofree )\n+\n+    IMPLICIT NONE\n+    INTEGER, INTENT(IN) :: ibrav_\n+    REAL(DP), INTENT(IN) :: celldm_ (6)\n+    LOGICAL, INTENT(IN) :: trd_ht\n+    CHARACTER(LEN=*), INTENT(IN) :: cell_symmetry\n+    REAL(DP), INTENT(IN) :: rd_ht (3,3)\n+    CHARACTER(LEN=*), INTENT(IN) :: cell_units\n+    REAL(DP), INTENT(IN) :: a_ , b_ , c_ , cosab, cosac, cosbc\n+    CHARACTER(LEN=*), INTENT(IN) :: cell_dofree\n+    REAL(DP),  INTENT(IN) :: wc_ , frich_ , greash_ , total_ions_mass\n+    REAL(DP),  INTENT(IN) :: press_  ! external pressure from imput ( GPa )\n+  END SUBROUTINE cell_base_init\n+\n+\n+  SUBROUTINE cell_base_reinit( ht )\n+    REAL(DP), INTENT(IN) :: ht (3,3)\n+  END SUBROUTINE cell_base_reinit\n+\n+  SUBROUTINE cell_steepest( hnew, h, delt, iforceh, fcell )\n+    REAL(DP), INTENT(OUT) :: hnew(3,3)\n+    REAL(DP), INTENT(IN) :: h(3,3), fcell(3,3)\n+    INTEGER,      INTENT(IN) :: iforceh(3,3)\n+    REAL(DP), INTENT(IN) :: delt\n+  END SUBROUTINE cell_steepest\n+\n+  SUBROUTINE cell_verlet( hnew, h, hold, delt, iforceh, fcell, frich, tnoseh, hnos )\n+    REAL(DP), INTENT(OUT) :: hnew(3,3)\n+    REAL(DP), INTENT(IN) :: h(3,3), hold(3,3), hnos(3,3), fcell(3,3)\n+    INTEGER,      INTENT(IN) :: iforceh(3,3)\n+    REAL(DP), INTENT(IN) :: frich, delt\n+    LOGICAL,      INTENT(IN) :: tnoseh\n+  END SUBROUTINE cell_verlet\n+\n+  subroutine cell_hmove( h, hold, delt, iforceh, fcell )\n+    REAL(DP), intent(out) :: h(3,3)\n+    REAL(DP), intent(in) :: hold(3,3), fcell(3,3)\n+    REAL(DP), intent(in) :: delt\n+    integer, intent(in) :: iforceh(3,3)\n+  end subroutine cell_hmove\n+\n+  subroutine cell_force( fcell, ainv, stress, omega, press, wmass )\n+    REAL(DP), intent(out) :: fcell(3,3)\n+    REAL(DP), intent(in) :: stress(3,3), ainv(3,3)\n+    REAL(DP), intent(in) :: omega, press, wmass\n+  end subroutine cell_force\n+\n+  subroutine cell_move( hnew, h, hold, delt, iforceh, fcell, frich, tnoseh, vnhh, velh, tsdc )\n+    REAL(DP), intent(out) :: hnew(3,3)\n+    REAL(DP), intent(in) :: h(3,3), hold(3,3), fcell(3,3)\n+    REAL(DP), intent(in) :: vnhh(3,3), velh(3,3)\n+    integer,      intent(in) :: iforceh(3,3)\n+    REAL(DP), intent(in) :: frich, delt\n+    logical,      intent(in) :: tnoseh, tsdc\n+  end subroutine cell_move\n+\n+  subroutine cell_gamma( hgamma, ainv, h, velh )\n+    REAL(DP) :: hgamma(3,3)\n+    REAL(DP), intent(in) :: ainv(3,3), h(3,3), velh(3,3)\n+  end subroutine cell_gamma\n+\n+  subroutine cell_kinene( ekinh, temphh, velh )\n+    REAL(DP), intent(out) :: ekinh, temphh(3,3)\n+    REAL(DP), intent(in)  :: velh(3,3)\n+  end subroutine cell_kinene\n+\n+  function cell_alat( )\n+    real(DP) :: cell_alat\n+    cell_alat = 4.4\n+  end function cell_alat\n+   END MODULE cell_base\n+\n+\n+  MODULE ions_base\n+      USE kinds,      ONLY : DP\n+      USE parameters, ONLY : ntypx\n+      IMPLICIT NONE\n+      SAVE\n+      INTEGER :: nsp     = 0\n+      INTEGER :: na(5) = 0    \n+      INTEGER :: nax     = 0\n+      INTEGER :: nat     = 0\n+      REAL(DP) :: zv(5)    = 0.0d0\n+      REAL(DP) :: pmass(5) = 0.0d0\n+      REAL(DP) :: amass(5) = 0.0d0\n+      REAL(DP) :: rcmax(5) = 0.0d0\n+      INTEGER,  ALLOCATABLE :: ityp(:)\n+      REAL(DP), ALLOCATABLE :: tau(:,:)     !  initial positions read from stdin (in bohr)\n+      REAL(DP), ALLOCATABLE :: vel(:,:)     !  initial velocities read from stdin (in bohr)\n+      REAL(DP), ALLOCATABLE :: tau_srt(:,:) !  tau sorted by specie in bohr\n+      REAL(DP), ALLOCATABLE :: vel_srt(:,:) !  vel sorted by specie in bohr\n+      INTEGER,  ALLOCATABLE :: ind_srt(:)   !  index of tau sorted by specie\n+      INTEGER,  ALLOCATABLE :: ind_bck(:)   !  reverse of ind_srt\n+      CHARACTER(LEN=3)      :: atm( 5 ) \n+      CHARACTER(LEN=80)     :: tau_units\n+\n+\n+      INTEGER, ALLOCATABLE :: if_pos(:,:)  ! if if_pos( x, i ) = 0 then  x coordinate of \n+                                           ! the i-th atom will be kept fixed\n+      INTEGER, ALLOCATABLE :: iforce(:,:)  ! if_pos sorted by specie \n+      INTEGER :: fixatom   = -1            ! to be removed\n+      INTEGER :: ndofp     = -1            ! ionic degree of freedom\n+      INTEGER :: ndfrz     = 0             ! frozen degrees of freedom\n+\n+      REAL(DP) :: fricp   ! friction parameter for damped dynamics\n+      REAL(DP) :: greasp  ! friction parameter for damped dynamics\n+      REAL(DP), ALLOCATABLE :: taui(:,:)\n+      REAL(DP) :: cdmi(3), cdm(3)\n+      REAL(DP) :: cdms(3)\n+      LOGICAL :: tions_base_init = .FALSE.\n+  CONTAINS\n+    SUBROUTINE packtau( taup, tau, na, nsp )\n+      REAL(DP), INTENT(OUT) :: taup( :, : )\n+      REAL(DP), INTENT(IN) :: tau( :, :, : )\n+      INTEGER, INTENT(IN) :: na( : ), nsp\n+    END SUBROUTINE packtau\n+\n+    SUBROUTINE unpacktau( tau, taup, na, nsp )\n+      REAL(DP), INTENT(IN) :: taup( :, : )\n+      REAL(DP), INTENT(OUT) :: tau( :, :, : )\n+      INTEGER, INTENT(IN) :: na( : ), nsp\n+    END SUBROUTINE unpacktau\n+\n+    SUBROUTINE sort_tau( tausrt, isrt, tau, isp, nat, nsp )\n+      REAL(DP), INTENT(OUT) :: tausrt( :, : )\n+      INTEGER, INTENT(OUT) :: isrt( : )\n+      REAL(DP), INTENT(IN) :: tau( :, : )\n+      INTEGER, INTENT(IN) :: nat, nsp, isp( : )\n+      INTEGER :: ina( nsp ), na( nsp )\n+    END SUBROUTINE sort_tau\n+\n+    SUBROUTINE unsort_tau( tau, tausrt, isrt, nat )\n+      REAL(DP), INTENT(IN) :: tausrt( :, : )\n+      INTEGER, INTENT(IN) :: isrt( : )\n+      REAL(DP), INTENT(OUT) :: tau( :, : )\n+      INTEGER, INTENT(IN) :: nat\n+    END SUBROUTINE unsort_tau\n+\n+    SUBROUTINE ions_base_init( nsp_, nat_, na_, ityp_, tau_, vel_, amass_, &\n+                               atm_, if_pos_, tau_units_, alat_, a1_, a2_, &\n+                               a3_, rcmax_ )\n+      INTEGER,          INTENT(IN) :: nsp_, nat_, na_(:), ityp_(:)\n+      REAL(DP),         INTENT(IN) :: tau_(:,:)\n+      REAL(DP),         INTENT(IN) :: vel_(:,:)\n+      REAL(DP),         INTENT(IN) :: amass_(:)\n+      CHARACTER(LEN=*), INTENT(IN) :: atm_(:)\n+      CHARACTER(LEN=*), INTENT(IN) :: tau_units_\n+      INTEGER,          INTENT(IN) :: if_pos_(:,:)\n+      REAL(DP),         INTENT(IN) :: alat_, a1_(3), a2_(3), a3_(3)\n+      REAL(DP),         INTENT(IN) :: rcmax_(:)\n+    END SUBROUTINE ions_base_init\n+\n+    SUBROUTINE deallocate_ions_base()\n+    END SUBROUTINE deallocate_ions_base\n+\n+    SUBROUTINE ions_vel3( vel, taup, taum, na, nsp, dt )\n+      REAL(DP) :: vel(:,:), taup(:,:), taum(:,:)\n+      INTEGER :: na(:), nsp\n+      REAL(DP) :: dt\n+    END SUBROUTINE ions_vel3\n+\n+    SUBROUTINE ions_vel2( vel, taup, taum, nat, dt )\n+      REAL(DP) :: vel(:,:), taup(:,:), taum(:,:)\n+      INTEGER :: nat\n+      REAL(DP) :: dt\n+    END SUBROUTINE ions_vel2\n+\n+    SUBROUTINE cofmass1( tau, pmass, na, nsp, cdm )\n+      REAL(DP), INTENT(IN) :: tau(:,:,:), pmass(:)\n+      REAL(DP), INTENT(OUT) :: cdm(3)\n+      INTEGER, INTENT(IN) :: na(:), nsp\n+    END SUBROUTINE cofmass1\n+\n+    SUBROUTINE cofmass2( tau, pmass, na, nsp, cdm )\n+      REAL(DP), INTENT(IN) :: tau(:,:), pmass(:)\n+      REAL(DP), INTENT(OUT) :: cdm(3)\n+      INTEGER, INTENT(IN) :: na(:), nsp\n+    END SUBROUTINE cofmass2\n+\n+      SUBROUTINE randpos(tau, na, nsp, tranp, amprp, hinv, ifor )\n+         REAL(DP) :: hinv(3,3)\n+         REAL(DP) :: tau(:,:)\n+         INTEGER, INTENT(IN) :: ifor(:,:), na(:), nsp\n+         LOGICAL, INTENT(IN) :: tranp(:)\n+         REAL(DP), INTENT(IN) :: amprp(:)\n+         REAL(DP) :: oldp(3), rand_disp(3), rdisp(3)\n+\n+       END SUBROUTINE randpos\n+\n+  SUBROUTINE ions_kinene( ekinp, vels, na, nsp, h, pmass )\n+    REAL(DP), intent(out) :: ekinp     !  ionic kinetic energy\n+    REAL(DP), intent(in) :: vels(:,:)  !  scaled ionic velocities\n+    REAL(DP), intent(in) :: pmass(:)   !  ionic masses\n+    REAL(DP), intent(in) :: h(:,:)     !  simulation cell\n+    integer, intent(in) :: na(:), nsp\n+    integer :: i, j, is, ia, ii, isa\n+  END SUBROUTINE ions_kinene\n+\n+  subroutine ions_temp( tempp, temps, ekinpr, vels, na, nsp, h, pmass, ndega, nhpdim, atm2nhp, ekin2nhp )\n+    REAL(DP), intent(out) :: ekinpr, tempp\n+    REAL(DP), intent(out) :: temps(:)\n+    REAL(DP), intent(out) :: ekin2nhp(:)\n+    REAL(DP), intent(in)  :: vels(:,:)\n+    REAL(DP), intent(in)  :: pmass(:)\n+    REAL(DP), intent(in)  :: h(:,:)\n+    integer,        intent(in)  :: na(:), nsp, ndega, nhpdim, atm2nhp(:)\n+  end subroutine ions_temp\n+\n+  subroutine ions_thermal_stress( stress, pmass, omega, h, vels, nsp, na )\n+    REAL(DP), intent(inout) :: stress(3,3)\n+    REAL(DP), intent(in)  :: pmass(:), omega, h(3,3), vels(:,:)\n+    integer, intent(in) :: nsp, na(:)\n+    integer :: i, j, is, ia, isa\n+  end subroutine ions_thermal_stress\n+\n+  subroutine ions_vrescal( tcap, tempw, tempp, taup, tau0, taum, na, nsp, fion, iforce, &\n+                           pmass, delt )\n+    logical, intent(in) :: tcap\n+    REAL(DP), intent(inout) :: taup(:,:)\n+    REAL(DP), intent(in) :: tau0(:,:), taum(:,:), fion(:,:)\n+    REAL(DP), intent(in) :: delt, pmass(:), tempw, tempp\n+    integer, intent(in) :: na(:), nsp\n+    integer, intent(in) :: iforce(:,:)\n+  end subroutine ions_vrescal\n+  subroutine ions_shiftvar( varp, var0, varm )\n+    REAL(DP), intent(in) :: varp\n+    REAL(DP), intent(out) :: varm, var0\n+  end subroutine ions_shiftvar\n+   SUBROUTINE cdm_displacement( dis, tau )\n+      REAL(DP) :: dis\n+      REAL(DP) :: tau\n+   END SUBROUTINE cdm_displacement\n+   SUBROUTINE ions_displacement( dis, tau )\n+      REAL (DP), INTENT(OUT) :: dis\n+      REAL (DP), INTENT(IN)  :: tau\n+   END SUBROUTINE ions_displacement\n+  END MODULE ions_base"}]}