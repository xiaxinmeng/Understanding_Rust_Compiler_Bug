{"sha": "8a63343a744a8584a9dfcbc3817f66755baafe8a", "node_id": "C_kwDOANBUbNoAKDhhNjMzNDNhNzQ0YTg1ODRhOWRmY2JjMzgxN2Y2Njc1NWJhYWZlOGE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-29T14:16:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-30T07:32:01Z"}, "message": "tree-optimization/56654 - sort uninit candidates after RPO\n\nThe following sorts the immediate uses of a possibly uninitialized\nSSA variable after their RPO order so we prefer warning for an\nearlier occuring use rather than issueing the diagnostic for the\nfirst uninitialized immediate use.\n\nThe sorting will inevitably be imperfect but it also allows us to\noptimize the expensive predicate check for the case where there\nare multiple uses in the same basic-block which is a nice side-effect.\n\n\tPR tree-optimization/56654\n\t* tree-ssa-uninit.cc (cand_cmp): New.\n\t(find_uninit_use): First process all PHIs and collect candidate\n\tstmts, then sort those after RPO.\n\t(warn_uninitialized_phi): Pass on bb_to_rpo.\n\t(execute_late_warn_uninitialized): Compute and pass on\n\treverse lookup of RPO number from basic block index.", "tree": {"sha": "dedb67cd8b101462d9c4c148b3b5e1cfcaf46cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dedb67cd8b101462d9c4c148b3b5e1cfcaf46cd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a63343a744a8584a9dfcbc3817f66755baafe8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a63343a744a8584a9dfcbc3817f66755baafe8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a63343a744a8584a9dfcbc3817f66755baafe8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a63343a744a8584a9dfcbc3817f66755baafe8a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8f98fa3bef754abedc3ed7a1839b4c8c782730"}], "stats": {"total": 92, "additions": 61, "deletions": 31}, "files": [{"sha": "0bd567f237c6ef01958b289e50f086a7c6f02267", "filename": "gcc/tree-ssa-uninit.cc", "status": "modified", "additions": 61, "deletions": 31, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a63343a744a8584a9dfcbc3817f66755baafe8a/gcc%2Ftree-ssa-uninit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a63343a744a8584a9dfcbc3817f66755baafe8a/gcc%2Ftree-ssa-uninit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.cc?ref=8a63343a744a8584a9dfcbc3817f66755baafe8a", "patch": "@@ -1154,85 +1154,111 @@ uninit_undef_val_t::phi_arg_set (gphi *phi)\n   return compute_uninit_opnds_pos (phi);\n }\n \n+/* sort helper for find_uninit_use.  */\n+\n+static int\n+cand_cmp (const void *a, const void *b, void *data)\n+{\n+  int *bb_to_rpo = (int *)data;\n+  const gimple *sa = *(const gimple * const *)a;\n+  const gimple *sb = *(const gimple * const *)b;\n+  if (bb_to_rpo[gimple_bb (sa)->index] < bb_to_rpo[gimple_bb (sb)->index])\n+    return -1;\n+  else if (bb_to_rpo[gimple_bb (sa)->index] > bb_to_rpo[gimple_bb (sb)->index])\n+    return 1;\n+  return 0;\n+}\n+\n /* Searches through all uses of a potentially\n    uninitialized variable defined by PHI and returns a use\n    statement if the use is not properly guarded.  It returns\n    NULL if all uses are guarded.  UNINIT_OPNDS is a bitvector\n    holding the position(s) of uninit PHI operands.  */\n \n static gimple *\n-find_uninit_use (gphi *phi, unsigned uninit_opnds)\n+find_uninit_use (gphi *phi, unsigned uninit_opnds, int *bb_to_rpo)\n {\n   /* The Boolean predicate guarding the PHI definition.  Initialized\n      lazily from PHI in the first call to is_use_guarded() and cached\n      for subsequent iterations.  */\n   uninit_undef_val_t eval;\n   uninit_analysis def_preds (eval);\n \n+  /* First process PHIs and record other candidates.  */\n+  auto_vec<gimple *, 64> cands;\n   use_operand_p use_p;\n   imm_use_iterator iter;\n   tree phi_result = gimple_phi_result (phi);\n-  gimple *uninit_use = NULL;\n   FOR_EACH_IMM_USE_FAST (use_p, iter, phi_result)\n     {\n       gimple *use_stmt = USE_STMT (use_p);\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      basic_block use_bb;\n       if (gphi *use_phi = dyn_cast<gphi *> (use_stmt))\n \t{\n-\t  edge e = gimple_phi_arg_edge (use_phi,\n-\t\t\t\t\tPHI_ARG_INDEX_FROM_USE (use_p));\n-\t  use_bb = e->src;\n+\t  unsigned idx = PHI_ARG_INDEX_FROM_USE (use_p);\n+\t  edge e = gimple_phi_arg_edge (use_phi, idx);\n \t  /* Do not look for uses in the next iteration of a loop, predicate\n \t     analysis will not use the appropriate predicates to prove\n \t     reachability.  */\n \t  if (e->flags & EDGE_DFS_BACK)\n \t    continue;\n-\t}\n-      else if (uninit_use)\n-\t/* Only process the first real uninitialized use, but continue\n-\t   looking for unguarded uses in PHIs.  */\n-\tcontinue;\n-      else\n-\tuse_bb = gimple_bb (use_stmt);\n \n-      if (def_preds.is_use_guarded (use_stmt, use_bb, phi, uninit_opnds))\n-\t{\n-\t  /* For a guarded use in a PHI record the PHI argument as\n-\t     initialized.  */\n-\t  if (gphi *use_phi = dyn_cast<gphi *> (use_stmt))\n+\t  basic_block use_bb = e->src;\n+\t  if (def_preds.is_use_guarded (use_stmt, use_bb, phi, uninit_opnds))\n \t    {\n-\t      unsigned idx = PHI_ARG_INDEX_FROM_USE (use_p);\n+\t      /* For a guarded use in a PHI record the PHI argument as\n+\t\t initialized.  */\n \t      if (idx < uninit_analysis::func_t::max_phi_args)\n \t\t{\n \t\t  bool existed_p;\n \t\t  auto &def_mask\n-\t\t    = defined_args->get_or_insert (use_phi, &existed_p);\n+\t\t      = defined_args->get_or_insert (use_phi, &existed_p);\n \t\t  if (!existed_p)\n \t\t    def_mask = 0;\n \t\t  MASK_SET_BIT (def_mask, idx);\n \t\t}\n+\t      continue;\n \t    }\n-\t  continue;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Found unguarded use in bb %u: \",\n+\t\t       use_bb->index);\n+\t      print_gimple_stmt (dump_file, use_stmt, 0);\n+\t    }\n+\t  /* Found a phi use that is not guarded, mark the phi_result as\n+\t     possibly undefined.  */\n+\t  possibly_undefined_names->add (phi_result);\n \t}\n+      else\n+\tcands.safe_push (use_stmt);\n+    }\n+\n+  /* Sort candidates after RPO.  */\n+  cands.stablesort (cand_cmp, bb_to_rpo);\n+  basic_block use_bb = NULL;\n+  for (gimple *use_stmt : cands)\n+    {\n+      /* We only have to try diagnosing the first use in each block.  */\n+      if (gimple_bb (use_stmt) == use_bb)\n+\tcontinue;\n+\n+      use_bb = gimple_bb (use_stmt);\n+      if (def_preds.is_use_guarded (use_stmt, use_bb, phi, uninit_opnds))\n+\tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Found unguarded use in bb %u: \",\n \t\t   use_bb->index);\n \t  print_gimple_stmt (dump_file, use_stmt, 0);\n \t}\n-      /* Found a phi use that is not guarded, mark the phi_result as\n-\t possibly undefined.  */\n-      if (is_a <gphi *> (use_stmt))\n-\tpossibly_undefined_names->add (phi_result);\n-      else\n-\tuninit_use = use_stmt;\n+      return use_stmt;\n     }\n \n-  return uninit_use;\n+  return NULL;\n }\n \n /* Look for inputs to PHI that are SSA_NAMEs that have empty definitions\n@@ -1242,15 +1268,15 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds)\n    by the compiler, the fewer false positives the warning is.  */\n \n static void\n-warn_uninitialized_phi (gphi *phi, unsigned uninit_opnds)\n+warn_uninitialized_phi (gphi *phi, unsigned uninit_opnds, int *bb_to_rpo)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Examining phi: \");\n       print_gimple_stmt (dump_file, phi, 0);\n     }\n \n-  gimple *uninit_use_stmt = find_uninit_use (phi, uninit_opnds);\n+  gimple *uninit_use_stmt = find_uninit_use (phi, uninit_opnds, bb_to_rpo);\n \n   /* All uses are properly guarded.  */\n   if (!uninit_use_stmt)\n@@ -1336,6 +1362,9 @@ execute_late_warn_uninitialized (function *fun)\n   mark_dfs_back_edges (fun);\n   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n   int n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n+  int *bb_to_rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n+  for (int i = 0; i < n; ++i)\n+    bb_to_rpo[rpo[i]] = i;\n \n   /* Re-do the plain uninitialized variable check, as optimization may have\n      straightened control flow.  Do this first so that we don't accidentally\n@@ -1365,10 +1394,11 @@ execute_late_warn_uninitialized (function *fun)\n \tif (MASK_EMPTY (uninit_opnds))\n \t  continue;\n \n-\twarn_uninitialized_phi (phi, uninit_opnds);\n+\twarn_uninitialized_phi (phi, uninit_opnds, bb_to_rpo);\n       }\n \n   free (rpo);\n+  free (bb_to_rpo);\n   delete possibly_undefined_names;\n   possibly_undefined_names = NULL;\n   delete defined_args;"}]}