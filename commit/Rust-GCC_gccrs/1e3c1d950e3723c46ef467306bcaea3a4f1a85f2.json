{"sha": "1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUzYzFkOTUwZTM3MjNjNDZlZjQ2NzMwNmJjYWVhM2E0ZjFhODVmMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-03-05T20:17:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-03-05T20:17:44Z"}, "message": "re PR debug/51902 (lexical_blocks inside inlined_subroutines generate duplicate debug_ranges)\n\n\tPR debug/51902\n\t* tree.h (BLOCK_SAME_RANGE): Define.\n\t* function.c (block_fragments_nreverse): Clear BLOCK_SAME_RANGE\n\tif BLOCK_FRAGMENT_CHAIN is non-NULL, but has it cleared.\n\tAlso clear BLOCK_SAME_RANGE if fragment chain's supercontext fragment\n\tisn't equal to supercontext fragment's fragment chain.\n\tAdjust BLOCK_SUPERCONTEXT to point to supercontext fragment's\n\tfragment origin.\n\t(blocks_nreverse_all): Likewise.\n\t(reorder_blocks_1): Compute BLOCK_SAME_RANGE bits.  Set\n\tBLOCK_SUPERCONTEXT to supercontext fragment instead of\n\tsupercontext fragment's fragment origin.\n\t* dwarf2out.c (add_high_low_attributes): If stmt has the same\n\trange as its parent (or parents thereof etc.), use the parent's\n\tDW_AT_ranges value instead of creating a new .debug_ranges range.\n\nFrom-SVN: r184958", "tree": {"sha": "0a203dfd5709e8e57936d2ab25e4fc15b3529a67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a203dfd5709e8e57936d2ab25e4fc15b3529a67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8993fde43241743b76372651364048d45ce2309e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8993fde43241743b76372651364048d45ce2309e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8993fde43241743b76372651364048d45ce2309e"}], "stats": {"total": 147, "additions": 138, "deletions": 9}, "files": [{"sha": "b7d7dfacbf6cd17aaabb82c67a03e9bebd211cd9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "patch": "@@ -1,3 +1,21 @@\n+2012-03-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/51902\n+\t* tree.h (BLOCK_SAME_RANGE): Define.\n+\t* function.c (block_fragments_nreverse): Clear BLOCK_SAME_RANGE\n+\tif BLOCK_FRAGMENT_CHAIN is non-NULL, but has it cleared.\n+\tAlso clear BLOCK_SAME_RANGE if fragment chain's supercontext fragment\n+\tisn't equal to supercontext fragment's fragment chain.\n+\tAdjust BLOCK_SUPERCONTEXT to point to supercontext fragment's\n+\tfragment origin.\n+\t(blocks_nreverse_all): Likewise.\n+\t(reorder_blocks_1): Compute BLOCK_SAME_RANGE bits.  Set\n+\tBLOCK_SUPERCONTEXT to supercontext fragment instead of\n+\tsupercontext fragment's fragment origin.\n+\t* dwarf2out.c (add_high_low_attributes): If stmt has the same\n+\trange as its parent (or parents thereof etc.), use the parent's\n+\tDW_AT_ranges value instead of creating a new .debug_ranges range.\n+\n 2012-03-05  Richard Henderson  <rth@redhat.com>\n \n \tPR tree-opt/52242"}, {"sha": "b5f921a97abf1525f5a8eb7038f616e5fe29f6d0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "patch": "@@ -18134,7 +18134,9 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n   if (BLOCK_FRAGMENT_CHAIN (stmt)\n       && (dwarf_version >= 3 || !dwarf_strict))\n     {\n-      tree chain;\n+      tree chain, superblock = NULL_TREE;\n+      dw_die_ref pdie;\n+      dw_attr_ref attr = NULL;\n \n       if (inlined_function_outer_scope_p (stmt))\n \t{\n@@ -18143,6 +18145,56 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t  add_AT_lbl_id (die, DW_AT_entry_pc, label);\n \t}\n \n+      /* Optimize duplicate .debug_ranges lists or even tails of\n+\t lists.  If this BLOCK has same ranges as its supercontext,\n+\t lookup DW_AT_ranges attribute in the supercontext (and\n+\t recursively so), verify that the ranges_table contains the\n+\t right values and use it instead of adding a new .debug_range.  */\n+      for (chain = stmt, pdie = die;\n+\t   BLOCK_SAME_RANGE (chain);\n+\t   chain = BLOCK_SUPERCONTEXT (chain))\n+\t{\n+\t  dw_attr_ref new_attr;\n+\n+\t  pdie = pdie->die_parent;\n+\t  if (pdie == NULL)\n+\t    break;\n+\t  if (BLOCK_SUPERCONTEXT (chain) == NULL_TREE)\n+\t    break;\n+\t  new_attr = get_AT (pdie, DW_AT_ranges);\n+\t  if (new_attr == NULL\n+\t      || new_attr->dw_attr_val.val_class != dw_val_class_range_list)\n+\t    break;\n+\t  attr = new_attr;\n+\t  superblock = BLOCK_SUPERCONTEXT (chain);\n+\t}\n+      if (attr != NULL\n+\t  && (ranges_table[attr->dw_attr_val.v.val_offset\n+\t\t\t   / 2 / DWARF2_ADDR_SIZE].num\n+\t      == BLOCK_NUMBER (superblock))\n+\t  && BLOCK_FRAGMENT_CHAIN (superblock))\n+\t{\n+\t  unsigned long off = attr->dw_attr_val.v.val_offset\n+\t\t\t      / 2 / DWARF2_ADDR_SIZE;\n+\t  unsigned long supercnt = 0, thiscnt = 0;\n+\t  for (chain = BLOCK_FRAGMENT_CHAIN (superblock);\n+\t       chain; chain = BLOCK_FRAGMENT_CHAIN (chain))\n+\t    {\n+\t      ++supercnt;\n+\t      gcc_checking_assert (ranges_table[off + supercnt].num\n+\t\t\t\t   == BLOCK_NUMBER (chain));\n+\t    }\n+\t  gcc_checking_assert (ranges_table[off + supercnt + 1].num == 0);\n+\t  for (chain = BLOCK_FRAGMENT_CHAIN (stmt);\n+\t       chain; chain = BLOCK_FRAGMENT_CHAIN (chain))\n+\t    ++thiscnt;\n+\t  gcc_assert (supercnt >= thiscnt);\n+\t  add_AT_range_list (die, DW_AT_ranges,\n+\t\t\t     (off + supercnt - thiscnt)\n+\t\t\t     * 2 * DWARF2_ADDR_SIZE);\n+\t  return;\n+\t}\n+\n       add_AT_range_list (die, DW_AT_ranges, add_ranges (stmt));\n \n       chain = BLOCK_FRAGMENT_CHAIN (stmt);"}, {"sha": "9add7c1a007db7da948fc6273306833f17de5564", "filename": "gcc/function.c", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "patch": "@@ -3998,18 +3998,35 @@ generate_setjmp_warnings (void)\n \n \f\n /* Reverse the order of elements in the fragment chain T of blocks,\n-   and return the new head of the chain (old last element).  */\n+   and return the new head of the chain (old last element).\n+   In addition to that clear BLOCK_SAME_RANGE flags when needed\n+   and adjust BLOCK_SUPERCONTEXT from the super fragment to\n+   its super fragment origin.  */\n \n static tree\n block_fragments_nreverse (tree t)\n {\n-  tree prev = 0, block, next;\n+  tree prev = 0, block, next, prev_super = 0;\n+  tree super = BLOCK_SUPERCONTEXT (t);\n+  if (BLOCK_FRAGMENT_ORIGIN (super))\n+    super = BLOCK_FRAGMENT_ORIGIN (super);\n   for (block = t; block; block = next)\n     {\n       next = BLOCK_FRAGMENT_CHAIN (block);\n       BLOCK_FRAGMENT_CHAIN (block) = prev;\n+      if ((prev && !BLOCK_SAME_RANGE (prev))\n+\t  || (BLOCK_FRAGMENT_CHAIN (BLOCK_SUPERCONTEXT (block))\n+\t      != prev_super))\n+\tBLOCK_SAME_RANGE (block) = 0;\n+      prev_super = BLOCK_SUPERCONTEXT (block);\n+      BLOCK_SUPERCONTEXT (block) = super;\n       prev = block;\n     }\n+  t = BLOCK_FRAGMENT_ORIGIN (t);\n+  if (BLOCK_FRAGMENT_CHAIN (BLOCK_SUPERCONTEXT (t))\n+      != prev_super)\n+    BLOCK_SAME_RANGE (t) = 0;\n+  BLOCK_SUPERCONTEXT (t) = super;\n   return prev;\n }\n \n@@ -4026,11 +4043,15 @@ blocks_nreverse_all (tree t)\n     {\n       next = BLOCK_CHAIN (block);\n       BLOCK_CHAIN (block) = prev;\n-      BLOCK_SUBBLOCKS (block) = blocks_nreverse_all (BLOCK_SUBBLOCKS (block));\n       if (BLOCK_FRAGMENT_CHAIN (block)\n \t  && BLOCK_FRAGMENT_ORIGIN (block) == NULL_TREE)\n-\tBLOCK_FRAGMENT_CHAIN (block)\n-\t  = block_fragments_nreverse (BLOCK_FRAGMENT_CHAIN (block));\n+\t{\n+\t  BLOCK_FRAGMENT_CHAIN (block)\n+\t    = block_fragments_nreverse (BLOCK_FRAGMENT_CHAIN (block));\n+\t  if (!BLOCK_SAME_RANGE (BLOCK_FRAGMENT_CHAIN (block)))\n+\t    BLOCK_SAME_RANGE (block) = 0;\n+\t}\n+      BLOCK_SUBBLOCKS (block) = blocks_nreverse_all (BLOCK_SUBBLOCKS (block));\n       prev = block;\n     }\n   return prev;\n@@ -4085,6 +4106,7 @@ static void\n reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n {\n   rtx insn;\n+  tree prev_beg = NULL_TREE, prev_end = NULL_TREE;\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     {\n@@ -4098,12 +4120,17 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t      gcc_assert (BLOCK_FRAGMENT_ORIGIN (block) == NULL_TREE);\n \t      origin = block;\n \n+\t      if (prev_end)\n+\t\tBLOCK_SAME_RANGE (prev_end) = 0;\n+\t      prev_end = NULL_TREE;\n+\n \t      /* If we have seen this block before, that means it now\n \t\t spans multiple address regions.  Create a new fragment.  */\n \t      if (TREE_ASM_WRITTEN (block))\n \t\t{\n \t\t  tree new_block = copy_node (block);\n \n+\t\t  BLOCK_SAME_RANGE (new_block) = 0;\n \t\t  BLOCK_FRAGMENT_ORIGIN (new_block) = origin;\n \t\t  BLOCK_FRAGMENT_CHAIN (new_block)\n \t\t    = BLOCK_FRAGMENT_CHAIN (origin);\n@@ -4113,17 +4140,34 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t\t  block = new_block;\n \t\t}\n \n+\t      if (prev_beg == current_block && prev_beg)\n+\t\tBLOCK_SAME_RANGE (block) = 1;\n+\n+\t      prev_beg = origin;\n+\n \t      BLOCK_SUBBLOCKS (block) = 0;\n \t      TREE_ASM_WRITTEN (block) = 1;\n \t      /* When there's only one block for the entire function,\n \t\t current_block == block and we mustn't do this, it\n \t\t will cause infinite recursion.  */\n \t      if (block != current_block)\n \t\t{\n+\t\t  tree super;\n \t\t  if (block != origin)\n-\t\t    gcc_assert (BLOCK_SUPERCONTEXT (origin) == current_block);\n-\n-\t\t  BLOCK_SUPERCONTEXT (block) = current_block;\n+\t\t    gcc_assert (BLOCK_SUPERCONTEXT (origin) == current_block\n+\t\t\t\t|| BLOCK_FRAGMENT_ORIGIN (BLOCK_SUPERCONTEXT\n+\t\t\t\t\t\t\t\t      (origin))\n+\t\t\t\t   == current_block);\n+\t\t  if (VEC_empty (tree, *p_block_stack))\n+\t\t    super = current_block;\n+\t\t  else\n+\t\t    {\n+\t\t      super = VEC_last (tree, *p_block_stack);\n+\t\t      gcc_assert (super == current_block\n+\t\t\t\t  || BLOCK_FRAGMENT_ORIGIN (super)\n+\t\t\t\t     == current_block);\n+\t\t    }\n+\t\t  BLOCK_SUPERCONTEXT (block) = super;\n \t\t  BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n \t\t  BLOCK_SUBBLOCKS (current_block) = block;\n \t\t  current_block = origin;\n@@ -4134,8 +4178,20 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t    {\n \t      NOTE_BLOCK (insn) = VEC_pop (tree, *p_block_stack);\n \t      current_block = BLOCK_SUPERCONTEXT (current_block);\n+\t      if (BLOCK_FRAGMENT_ORIGIN (current_block))\n+\t\tcurrent_block = BLOCK_FRAGMENT_ORIGIN (current_block);\n+\t      prev_beg = NULL_TREE;\n+\t      prev_end = BLOCK_SAME_RANGE (NOTE_BLOCK (insn))\n+\t\t\t ? NOTE_BLOCK (insn) : NULL_TREE;\n \t    }\n \t}\n+      else\n+\t{\n+\t  prev_beg = NULL_TREE;\n+\t  if (prev_end)\n+\t    BLOCK_SAME_RANGE (prev_end) = 0;\n+\t  prev_end = NULL_TREE;\n+\t}\n     }\n }\n "}, {"sha": "0a2d61982b8c9c45aab3f662fdc527450c93e57a", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3c1d950e3723c46ef467306bcaea3a4f1a85f2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1e3c1d950e3723c46ef467306bcaea3a4f1a85f2", "patch": "@@ -2088,6 +2088,9 @@ struct GTY(()) tree_omp_clause {\n #define BLOCK_ABSTRACT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.abstract_origin)\n #define BLOCK_ABSTRACT(NODE) (BLOCK_CHECK (NODE)->block.abstract_flag)\n \n+/* True if BLOCK has the same ranges as its BLOCK_SUPERCONTEXT.  */\n+#define BLOCK_SAME_RANGE(NODE) (BLOCK_CHECK (NODE)->base.nameless_flag)\n+\n /* An index number for this block.  These values are not guaranteed to\n    be unique across functions -- whether or not they are depends on\n    the debugging output format in use.  */"}]}