{"sha": "9dac0a42ea1bb2816ceac970652ddba6c88cd0cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRhYzBhNDJlYTFiYjI4MTZjZWFjOTcwNjUyZGRiYTZjODhjZDBjZg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-04-06T09:18:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:18:48Z"}, "message": "decl.c (gnat_to_gnu_entity): Associate an external VAR_DECL to a CONST_DECL we make for a public constant...\n\n2007-04-06  Olivier Hainque  <hainque@adacore.com>\n\t    Eric Botcazou <botcazou@adacore.com>\n\n\t* decl.c (gnat_to_gnu_entity) <E_Constant>: Associate an external\n\tVAR_DECL to a CONST_DECL we make for a public constant when we know the\n\tcorresponding definition has created the so made visible variable.\n\tHandle anonymous access to protected subprogram.\n\t(gnat_to_gnu_entity) <E_Variable>: Do not make the underlying type of an\n\tobject with an address clause volatile.  Re-enable original fix.\n\t<E_Subprogram_Type>: Set TYPE_REF_CAN_ALIAS_ALL on the reference type\n\ttoo.\n\t(gnat_to_gnu_entity) <E_Class_Wide_Type>: Retrieve the TYPE_DECL\n\tassociated with either the Equivalent or Root type, instead of the\n\tnaked type node.\n\t(gnat_to_gnu_entity): Manually mark the top of the DECL_FIELD_OFFSET\n\tsubtree for every field of a global record type.\n\t(gnat_to_gnu_entity) <E_Record_Subtype>: If the subtype has\n\tdiscriminants, invoke again variable_size on its newly computed sizes.\n\nFrom-SVN: r123557", "tree": {"sha": "5165255698abe82cac72b8ba01707f0b335e4311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5165255698abe82cac72b8ba01707f0b335e4311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b150b431d0a9b4dc0c3302b4257ecc209c33fba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b150b431d0a9b4dc0c3302b4257ecc209c33fba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b150b431d0a9b4dc0c3302b4257ecc209c33fba1"}], "stats": {"total": 79, "additions": 46, "deletions": 33}, "files": [{"sha": "2565a011571dc2860ebf93ce677db8dbc1de4abb", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=9dac0a42ea1bb2816ceac970652ddba6c88cd0cf", "patch": "@@ -245,8 +245,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n      when a Full_View exists.  */\n \n   if (present_gnu_tree (gnat_entity)\n-      && (! definition\n-\t  || (Is_Type (gnat_entity) && imported_p)))\n+      && (!definition || (Is_Type (gnat_entity) && imported_p)))\n     {\n       gnu_decl = get_gnu_tree (gnat_entity);\n \n@@ -272,6 +271,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      || (!IN (kind, Numeric_Kind) && !IN (kind, Enumeration_Kind)\n \t\t  && (!IN (kind, Access_Kind)\n \t\t      || kind == E_Access_Protected_Subprogram_Type\n+\t\t      || kind == E_Anonymous_Access_Protected_Subprogram_Type\n \t\t      || kind == E_Access_Subtype)));\n \n   /* Likewise, RM_Size must be specified for all discrete and fixed-point\n@@ -326,7 +326,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (!definition && Present (Full_View (gnat_entity)))\n \t{\n \t  gnu_decl = gnat_to_gnu_entity (Full_View (gnat_entity),\n-\t\t\t\t\t gnu_expr, definition);\n+\t\t\t\t\t gnu_expr, 0);\n \t  saved = true;\n \t  break;\n \t}\n@@ -433,7 +433,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    gnu_decl = gnat_to_gnu_entity (CR_Discriminant (gnat_entity),\n \t\t\t\t\t   gnu_expr, definition);\n-\t    saved = 1;\n+\t    saved = true;\n \t    break;\n \t  }\n \n@@ -469,7 +469,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_decl\n \t\t  = gnat_to_gnu_entity (Original_Record_Component\n \t\t\t\t\t(gnat_entity),\n-\t\t\t\t\tgnu_expr, definition);\n+\t\t\t\t\tgnu_expr, 0);\n \t\tsaved = true;\n \t\tbreak;\n \t      }\n@@ -715,8 +715,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   should treat other types of objects as volatile as well.  */\n \tif ((Treat_As_Volatile (gnat_entity)\n \t     || Is_Exported (gnat_entity)\n-\t     || Is_Imported (gnat_entity)\n-\t     || Present (Address_Clause (gnat_entity)))\n+\t     || Is_Imported (gnat_entity))\n \t    && !TYPE_VOLATILE (gnu_type))\n \t  gnu_type = build_qualified_type (gnu_type,\n \t\t\t\t\t   (TYPE_QUALS (gnu_type)\n@@ -937,18 +936,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Ignore the size.  It's either meaningless or was handled\n \t       above.  */\n \t    gnu_size = NULL_TREE;\n-\t    /* The address expression contains a conversion from pointer type\n-\t       to the system__address integer type, which means the address\n-\t       of the underlying object escapes.  We therefore have no other\n-\t       choice than forcing the type of the object being defined to\n-\t       alias everything in order to make type-based alias analysis\n-\t       aware that it will dereference the escaped address.\n-\t       ??? This uncovers problems in ACATS at -O2 with the volatility\n-\t       of the original type: it may not be correctly propagated, thus\n-\t       causing PRE to enter an infinite loop creating value numbers\n-\t       out of volatile expressions.  Disable it for now.  */\n+\t    /* Convert the type of the object to a reference type that can\n+\t       alias everything as per 13.3(19).  */\n \t    gnu_type\n-\t      = build_reference_type_for_mode (gnu_type, ptr_mode, false);\n+\t      = build_reference_type_for_mode (gnu_type, ptr_mode, true);\n \t    gnu_address = convert (gnu_type, gnu_address);\n \t    used_by_ref = true;\n \t    const_flag = !Is_Public (gnat_entity);\n@@ -977,9 +968,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    || (Is_Imported (gnat_entity)\n \t\t&& Has_Stdcall_Convention (gnat_entity)))\n \t  {\n-\t    /* See the definition case above for the rationale.  */\n+\t    /* Convert the type of the object to a reference type that can\n+\t       alias everything as per 13.3(19).  */\n \t    gnu_type\n-\t      = build_reference_type_for_mode (gnu_type, ptr_mode, false);\n+\t      = build_reference_type_for_mode (gnu_type, ptr_mode, true);\n \t    gnu_size = NULL_TREE;\n \n \t    gnu_expr = NULL_TREE;\n@@ -1174,10 +1166,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      gnat_entity);\n \n \t/* If this is a public constant or we're not optimizing and we're not\n-\t   making a VAR_DECL for it, make one just for export or debugger\n-\t   use.  Likewise if the address is taken or if the object or type is\n-\t   aliased.  */\n-\tif (definition && TREE_CODE (gnu_decl) == CONST_DECL\n+\t   making a VAR_DECL for it, make one just for export or debugger use.\n+\t   Likewise if the address is taken or if either the object or type is\n+\t   aliased.  Make an external declaration for a reference, unless this\n+\t   is a Standard entity since there no real symbol at the object level\n+\t   for these.  */\n+\tif (TREE_CODE (gnu_decl) == CONST_DECL\n+\t    && (definition || Sloc (gnat_entity) > Standard_Location)\n \t    && (Is_Public (gnat_entity)\n \t\t|| optimize == 0\n \t\t|| Address_Taken (gnat_entity)\n@@ -1187,7 +1182,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    tree gnu_corr_var\n \t      = create_true_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n \t\t\t\t      gnu_expr, true, Is_Public (gnat_entity),\n-\t\t\t\t      false, static_p, NULL, gnat_entity);\n+\t\t\t\t      !definition, static_p, NULL,\n+\t\t\t\t      gnat_entity);\n \n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n \t  }\n@@ -1384,13 +1380,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t bounds by always elaborating the first such subtype first, thus\n \t using its name. */\n \n-      if (definition == 0\n+      if (!definition\n \t  && Present (Ancestor_Subtype (gnat_entity))\n \t  && !In_Extended_Main_Code_Unit (Ancestor_Subtype (gnat_entity))\n \t  && (!Compile_Time_Known_Value (Type_Low_Bound (gnat_entity))\n \t      || !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n \tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity),\n-\t\t\t    gnu_expr, definition);\n+\t\t\t    gnu_expr, 0);\n \n       gnu_type = make_node (INTEGER_TYPE);\n       if (Is_Packed_Array_Type (gnat_entity))\n@@ -1511,13 +1507,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t}\n \n       {\n-\tif (definition == 0\n+\tif (!definition\n \t    && Present (Ancestor_Subtype (gnat_entity))\n \t    && !In_Extended_Main_Code_Unit (Ancestor_Subtype (gnat_entity))\n \t    && (!Compile_Time_Known_Value (Type_Low_Bound (gnat_entity))\n \t\t|| !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n \t  gnat_to_gnu_entity (Ancestor_Subtype (gnat_entity),\n-\t\t\t      gnu_expr, definition);\n+\t\t\t      gnu_expr, 0);\n \n \tgnu_type = make_node (REAL_TYPE);\n \tTREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n@@ -2613,7 +2609,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* If an equivalent type is present, that is what we should use.\n \t Otherwise, fall through to handle this like a record subtype\n \t since it may have constraints.  */\n-\n       if (Present (Equivalent_Type (gnat_entity)))\n \t{\n \t  gnu_decl = gnat_to_gnu_entity (Equivalent_Type (gnat_entity),\n@@ -2856,6 +2851,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t actual size.  */\n \t      compute_record_mode (gnu_type);\n \n+\t      /* Reapply variable_size since we have changed the sizes.  */\n+\t      TYPE_SIZE (gnu_type) = variable_size (TYPE_SIZE (gnu_type));\n+\t      TYPE_SIZE_UNIT (gnu_type)\n+\t\t= variable_size (TYPE_SIZE_UNIT (gnu_type));\n+\n \t      /* Fill in locations of fields.  */\n \t      annotate_rep (gnat_entity, gnu_type);\n \t    }\n@@ -3883,7 +3883,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n-\t    gnu_type = build_reference_type (gnu_type);\n+\t    /* Convert the type of the object to a reference type that can\n+\t       alias everything as per 13.3(19).  */\n+\t    gnu_type\n+\t      = build_reference_type_for_mode (gnu_type, ptr_mode, true);\n \t    if (gnu_address)\n \t      gnu_address = convert (gnu_type, gnu_address);\n \n@@ -3989,9 +3992,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t by Gigi unless an Equivalent_Type is specified.  */\n     case E_Class_Wide_Type:\n       if (Present (Equivalent_Type (gnat_entity)))\n-\tgnu_type = gnat_to_gnu_type (Equivalent_Type (gnat_entity));\n+\tgnu_decl = gnat_to_gnu_entity (Equivalent_Type (gnat_entity),\n+\t\t\t\t       NULL_TREE, 0);\n       else\n-\tgnu_type = gnat_to_gnu_type (Root_Type (gnat_entity));\n+\tgnu_decl = gnat_to_gnu_entity (Root_Type (gnat_entity),\n+\t\t\t\t       NULL_TREE, 0);\n \n       maybe_present = true;\n       break;\n@@ -4171,6 +4176,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t right now, we have to put in an explicit multiply and\n \t\t divide by that value.  */\n \t      if (!CONTAINS_PLACEHOLDER_P (DECL_FIELD_OFFSET (gnu_field)))\n+\t\t{\n \t\tDECL_FIELD_OFFSET (gnu_field)\n \t\t  = build_binary_op\n \t\t    (MULT_EXPR, sizetype,\n@@ -4183,6 +4189,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      get_identifier (\"OFFSET\"),\n \t\t      definition, 0),\n \t\t     size_int (DECL_OFFSET_ALIGN (gnu_field) / BITS_PER_UNIT));\n+\n+\t\t/* ??? The context of gnu_field is not necessarily gnu_type so\n+\t\t   the MULT_EXPR node built above may not be marked by the call\n+\t\t   to create_type_decl below.  Mark it manually for now.  */\n+\t\tif (global_bindings_p ())\n+\t\t  TREE_VISITED (DECL_FIELD_OFFSET (gnu_field)) = 1;\n+\t\t}\n \t    }\n \n       gnu_type = build_qualified_type (gnu_type,"}]}