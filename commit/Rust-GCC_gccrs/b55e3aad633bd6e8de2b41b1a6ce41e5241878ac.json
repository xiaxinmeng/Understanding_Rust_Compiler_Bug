{"sha": "b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU1ZTNhYWQ2MzNiZDZlOGRlMmI0MWIxYTZjZTQxZTUyNDE4NzhhYw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2004-07-12T08:45:00Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2004-07-12T08:45:00Z"}, "message": "config.gcc: Add sh-*-symbianelf target.\n\n* config.gcc: Add sh-*-symbianelf target.\n* config/sh/sh.c: Add new target macros:\n  TARGET_ENCODE_SECTION_INFO, TARGET_STRIP_NAME_ENCODING,\n  TARGET_CXX_IMPORT_EXPORT_CLASS.\n  (sh_file_start): Create a definition of the .directive section.\n  (sh_attribute): Add dllimport and dllexport attributes.\n* config/sh/symbian-pre.h: New file.\n* config/sh/symbian-post.h: New file.\n* config/sh/symbian.c: New file. Contains Symbian specific functions.\n* config/sh/sh-protos.h: Add prototypes for new functions provided by symbian.c.\n* config/sh/t-symbian: New file.\n* doc/extend.texi: Document support for dllimport and dllexport\tattributes by\n  the sh-symbianelf target.\n\nFrom-SVN: r84551", "tree": {"sha": "35b091528607aff8382046cbeb9d46bb0dde23d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35b091528607aff8382046cbeb9d46bb0dde23d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/comments", "author": null, "committer": null, "parents": [{"sha": "55e99d5226d32dc4e78fa96375034dda4fbbfcb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e99d5226d32dc4e78fa96375034dda4fbbfcb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e99d5226d32dc4e78fa96375034dda4fbbfcb9"}], "stats": {"total": 1187, "additions": 1164, "deletions": 23}, "files": [{"sha": "26b4897ee431b987480a9b9ba82cfcb18f83d783", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -1671,6 +1671,7 @@ s390x-ibm-tpf*)\n \ttmake_file=\"t-slibgcc-elf-ver s390/t-crtstuff s390/t-tpf\"\n \t;;\n sh-*-elf* | sh[12346l]*-*-elf* | sh*-*-kaos* | \\\n+sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n   sh-*-linux* | sh[346lbe]*-*-linux* | \\\n   sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \\\n    sh64-*-netbsd* | sh64l*-*-netbsd*)\n@@ -1730,6 +1731,12 @@ sh-*-elf* | sh[12346l]*-*-elf* | sh*-*-kaos* | \\\n \t\ttm_file=\"${tm_file} sh/sh64.h\"\n \t\textra_headers=\"shmedia.h ushmedia.h sshmedia.h\"\n \t\t;;\n+\t*-*-symbianelf*)\n+\t\ttmake_file=\"sh/t-symbian\"\n+\t\ttm_file=\"sh/symbian-pre.h sh/little.h ${tm_file} sh/symbian-post.h\"\n+\t\textra_objs=\"symbian.o\"\n+\t\textra_parts=\"crt1.o crti.o crtn.o crtbegin.o crtend.o crtbeginS.o crtendS.o\"\n+\t\t;;\t\n \tesac\n \t# sed el/eb endian suffixes away to avoid confusion with sh[23]e\n \tcase `echo ${target} | sed 's/e[lb]-/-/'` in"}, {"sha": "0d1733c3717fa5e1282331b46524593ffbfab55b", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -143,3 +143,17 @@ extern const char *sh_pch_valid_p (const void *data_p, size_t sz);\n extern bool sh_promote_prototypes (tree);\n \n #endif /* ! GCC_SH_PROTOS_H */\n+\n+#ifdef SYMBIAN\n+extern bool         sh_symbian_dllimport_name_p       (const char *);\n+extern const char * sh_symbian_strip_name_encoding    (const char *);\n+extern bool         sh_symbian_dllexport_name_p       (const char *);\n+extern int          symbian_import_export_class       (tree, int);\n+#ifdef TREE_CODE\n+extern bool         sh_symbian_dllexport_p            (tree);\n+extern tree         sh_symbian_handle_dll_attribute   (tree *, tree, tree, int, bool *);\n+#ifdef RTX_CODE\n+extern void         sh_symbian_encode_section_info    (tree, rtx, int);\n+#endif\n+#endif\n+#endif /* SYMBIAN */"}, {"sha": "dc16c61931bcae6d7bc7a85bddd30faae1200adf", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -451,6 +451,17 @@ static tree sh_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n /* Return current register pressure for regmode.  */\n #define CURR_REGMODE_PRESSURE(MODE) \tcurr_regmode_pressure[((MODE) == SImode) ? 0 : 1]\n \n+#ifdef SYMBIAN\n+\n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO\tsh_symbian_encode_section_info\n+#undef  TARGET_STRIP_NAME_ENCODING\n+#define TARGET_STRIP_NAME_ENCODING\tsh_symbian_strip_name_encoding\n+#undef  TARGET_CXX_IMPORT_EXPORT_CLASS\n+#define TARGET_CXX_IMPORT_EXPORT_CLASS  symbian_import_export_class\n+\n+#endif /* SYMBIAN */\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -1431,6 +1442,12 @@ sh_file_start (void)\n {\n   default_file_start ();\n \n+#ifdef SYMBIAN\n+  /* Declare the .directive section before it is used.  */\n+  fputs (\"\\t.section .directive, \\\"SM\\\", @progbits, 1\\n\", asm_out_file);\n+  fputs (\"\\t.asciz \\\"#<SYMEDIT>#\\\\n\\\"\\n\", asm_out_file);\n+#endif\n+  \n   if (TARGET_ELF)\n     /* We need to show the text section with the proper\n        attributes as in TEXT_SECTION_ASM_OP, before dwarf2out\n@@ -6950,6 +6967,17 @@ const struct attribute_spec sh_attribute_table[] =\n   { \"sp_switch\",         1, 1, true,  false, false, sh_handle_sp_switch_attribute },\n   { \"trap_exit\",         1, 1, true,  false, false, sh_handle_trap_exit_attribute },\n   { \"renesas\",           0, 0, false, true, false, sh_handle_renesas_attribute },\n+#ifdef SYMBIAN\n+  /* Symbian support adds three new attributes:\n+     dllexport - for exporting a function/variable that will live in a dll\n+     dllimport - for importing a function/variable from a dll\n+     \n+     Microsoft allows multiple declspecs in one __declspec, separating\n+     them with spaces.  We do NOT support this.  Instead, use __declspec\n+     multiple times.  */\n+  { \"dllimport\",         0, 0, true,  false, false, sh_symbian_handle_dll_attribute },\n+  { \"dllexport\",         0, 0, true,  false, false, sh_symbian_handle_dll_attribute },\n+#endif\n   { NULL,                0, 0, false, false, false, NULL }\n };\n "}, {"sha": "b39262d52563129c3eaf0343a901ee3ae0988f72", "filename": "gcc/config/sh/symbian-post.h", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsymbian-post.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsymbian-post.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-post.h?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -0,0 +1,89 @@\n+/* Definitions for the Symbian OS running on an SH part.\n+   This file is included after all the other target specific headers.\n+\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION \\\n+  fputs (\" (Renesas SH for Symbian OS)\", stderr);\n+\n+#undef  LINK_EMUL_PREFIX\n+#define LINK_EMUL_PREFIX \"shlsymbian\"\n+\n+\n+#define SYMBIAN_EXPORT_NAME(NAME,FILE,DECL)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((DECL && sh_symbian_dllexport_p (DECL))\t\t\\\n+         || sh_symbian_dllexport_name_p (NAME))\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          fprintf ((FILE), \"\\t.pushsection .directive\\n\");\t\\\n+          fprintf ((FILE), \"\\t.asciz \\\"EXPORT %s\\\\n\\\"\\n\",\t\\\n+\t           sh_symbian_strip_name_encoding (NAME));\t\\\n+          fprintf ((FILE), \"\\t.popsection\\n\");\t\t\t\\\n+       }\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Output a function definition label.  */\n+#undef  ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      SYMBIAN_EXPORT_NAME ((NAME), (FILE), (DECL));\t\t\\\n+      ASM_OUTPUT_TYPE_DIRECTIVE ((FILE), (NAME), \"function\");\t\\\n+      ASM_DECLARE_RESULT ((FILE), DECL_RESULT (DECL));\t\t\\\n+      ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Output the label for an initialized variable.  */\n+#undef  ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT size;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      SYMBIAN_EXPORT_NAME ((NAME), (FILE), (DECL));\t\t\\\n+      ASM_OUTPUT_TYPE_DIRECTIVE ((FILE), (NAME), \"object\");\t\\\n+\t\t\t\t\t\t\t\t\\\n+      size_directive_output = 0;\t\t\t\t\\\n+      if (!flag_inhibit_size_directive\t\t\t\t\\\n+\t  && (DECL)\t\t\t\t\t\t\\\n+          && DECL_SIZE (DECL))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  size_directive_output = 1;\t\t\t\t\\\n+\t  size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n+\t  ASM_OUTPUT_SIZE_DIRECTIVE ((FILE), (NAME), size);\t\\\n+\t}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      asm_fprintf ((FILE), \"%U%s\",\t\t\t\t\\\n+\t\t   sh_symbian_strip_name_encoding (NAME));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "aa23535bda1bf7fd69276fd4c6d5e54126b3f7b0", "filename": "gcc/config/sh/symbian-pre.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -0,0 +1,48 @@\n+/* Definitions for the Symbian OS running on an SH part.\n+   This file is included before any other target specific headers.\n+\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* Enable Symbian specific code.  */\n+#define SYMBIAN\t\t1\n+\n+/* Default to using the Renesas ABI.  */\n+#define TARGET_ABI_DEFAULT\tRENESAS_BIT\n+\n+/* Support the __declspec keyword by turning them into attributes.\n+   We currently only support: naked, dllimport, and dllexport.\n+   Note that the current way we do this may result in a collision with\n+   predefined attributes later on.  This can be solved by using one attribute,\n+   say __declspec__, and passing args to it.  The problem with that approach\n+   is that args are not accumulated: each new appearance would clobber any\n+   existing args.  */\n+#define SUBTARGET_CPP_SPEC \"-D__declspec(x)=__attribute__((x))\"\n+\n+/* Get tree.c to declare merge_dllimport_decl_attributes().  */\n+#define TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\n+/* The Symbian OS currently does not support exception handling.  */\n+#define SUBTARGET_CC1PLUS_SPEC \"-fno-exceptions\"\n+\n+/* Create constructor/destructor sections without the writable flag.\n+   Symbian puts them into the text segment and munges them later on.  */\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"ax\\\",@progbits\"\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"ax\\\",@progbits\""}, {"sha": "33ab711ae2d711e925bc0249aefcf1831a1311db", "filename": "gcc/config/sh/symbian.c", "status": "added", "additions": 906, "deletions": 0, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsymbian.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Fsymbian.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian.c?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -0,0 +1,906 @@\n+/* Routines for GCC for a Symbian OS targeted SH backend.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by RedHat.\n+   Most of this code is stolen from i386/winnt.c.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"tm_p.h\"\n+#include \"cp/cp-tree.h\"\t/* We need access to the OVL_... macros.  */\n+#include \"toplev.h\"\n+\n+/* Select the level of debugging information to display.\n+   0 for no debugging.\n+   1 for informative messages about decisions to add attributes\n+   2 for verbose information about what is being done.  */\n+#define SYMBIAN_DEBUG 0\n+//#define SYMBIAN_DEBUG 1\n+//#define SYMBIAN_DEBUG 2\n+\n+/* A unique character to encode declspec encoded objects.  */\n+#define SH_SYMBIAN_FLAG_CHAR \"$\"\n+\n+/* Unique strings to prefix exported and imported objects.  */\n+#define DLL_IMPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"i.\"\n+#define DLL_EXPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"e.\"\n+\n+\f\n+/* Return the type that we should use to determine if DECL is\n+   imported or exported.  */\n+\n+static tree\n+sh_symbian_associated_type (tree decl)\n+{\n+  tree t = NULL_TREE;\n+\n+  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n+  /* Methods now inherit their dllimport/dllexport attributes correctly\n+     so there is no need to check their class.  In fact it is wrong to\n+     check their class since a method can remain unexported from an\n+     exported class.  */\n+    return t;\n+\n+  /* Otherwise we can just take the DECL_CONTEXT as normal.  */\n+  if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n+    t = DECL_CONTEXT (decl);\n+\n+  return t;\n+}\n+\n+/* Return nonzero if DECL is a dllexport'd object.  */\n+\n+bool\n+sh_symbian_dllexport_p (tree decl)\n+{\n+  tree exp;\n+\n+  if (   TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return false;\n+\n+  exp = lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl));\n+\n+  /* Class members get the dllexport status of their class.  */\n+  if (exp == NULL)\n+    {\n+      tree class = sh_symbian_associated_type (decl);\n+\n+      if (class)\n+\texp = lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (class));\n+    }\n+#if SYMBIAN_DEBUG\n+  if (exp)\n+    {\n+      print_node_brief (stderr, \"dllexport:\", decl, 0);\n+      fprintf (stderr, \"\\n\");\n+    }\n+  else\n+#if SYMBIAN_DEBUG < 2\n+    if (TREE_CODE (decl) != FUNCTION_DECL)\n+#endif\n+    {\n+      print_node_brief (stderr, \"no dllexport:\", decl, 0);\n+      fprintf (stderr, \"\\n\");\n+    }\n+#endif\n+  return exp ? true : false;\n+}\n+\n+/* Return nonzero if DECL is a dllimport'd object.  */\n+\n+static bool\n+sh_symbian_dllimport_p (tree decl)\n+{\n+  tree imp;\n+\n+  if (   TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return false;\n+\n+  imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n+  if (imp)\n+    return true;\n+\n+  /* Class members get the dllimport status of their class.  */\n+  imp = sh_symbian_associated_type (decl);\n+  if (! imp)\n+    return false;\n+\n+  imp = lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (imp));\n+  if (!imp)\n+    return false;\n+\n+  /* Don't mark defined functions as dllimport.  If the definition itself\n+     was marked with dllimport, then sh_symbian_handle_dll_attribute reports\n+     an error. This handles the case when the definition overrides an\n+     earlier declaration.  */\n+  if (TREE_CODE (decl) ==  FUNCTION_DECL\n+      && DECL_INITIAL (decl)\n+      && !DECL_INLINE (decl))\n+    {\n+      /* Don't warn about artificial methods.  */\n+      if (!DECL_ARTIFICIAL (decl))\n+\twarning (\"%H function '%D' is defined after prior declaration as dllimport: attribute ignored\",\n+\t\t & DECL_SOURCE_LOCATION (decl), decl);\n+      return false;\n+    }\n+\n+  /* We ignore the dllimport attribute for inline member functions.\n+     This differs from MSVC behavior which treats it like GNUC\n+     'extern inline' extension.   */\n+  else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n+    {\n+      if (extra_warnings)\n+\twarning (\"%Hinline function '%D' is declared as dllimport: attribute ignored.\",\n+\t\t & DECL_SOURCE_LOCATION (decl), decl);\n+      return false;\n+    }\n+\n+  /*  Don't allow definitions of static data members in dllimport\n+      class.  Just ignore the attribute for vtable data.  */\n+  else if (TREE_CODE (decl) == VAR_DECL\n+\t   && TREE_STATIC (decl)\n+\t   && TREE_PUBLIC (decl)\n+\t   && !DECL_EXTERNAL (decl))\n+    {\n+      if (!DECL_VIRTUAL_P (decl))\n+\terror (\"%Hdefinition of static data member '%D' of dllimport'd class.\",\n+\t       & DECL_SOURCE_LOCATION (decl), decl);\n+      return false;\n+    }\n+\n+  /* Since we can't treat a pointer to a dllimport'd symbol as a\n+     constant address, we turn off the attribute on C++ virtual\n+     methods to allow creation of vtables using thunks.  Don't mark\n+     artificial methods either (in sh_symbian_associated_type, only\n+     COMDAT artificial method get import status from class context).  */\n+  else if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n+\t   && (DECL_VIRTUAL_P (decl) || DECL_ARTIFICIAL (decl)))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n+\n+bool\n+sh_symbian_dllexport_name_p (const char *symbol)\n+{\n+  return strncmp (DLL_EXPORT_PREFIX, symbol,\n+\t\t  strlen (DLL_EXPORT_PREFIX)) == 0;\n+}\n+\n+/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n+\n+\n+bool\n+sh_symbian_dllimport_name_p (const char *symbol)\n+{\n+  return strncmp (DLL_IMPORT_PREFIX, symbol,\n+\t\t  strlen (DLL_IMPORT_PREFIX)) == 0;\n+}\n+\n+/* Mark a DECL as being dllexport'd.\n+   Note that we override the previous setting (eg: dllimport).  */\n+\n+static void\n+sh_symbian_mark_dllexport (tree decl)\n+{\n+  const char *oldname;\n+  char *newname;\n+  rtx rtlname;\n+  tree idp;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+\n+  if (GET_CODE (rtlname) == SYMBOL_REF)\n+    oldname = XSTR (rtlname, 0);\n+  else if (GET_CODE (rtlname) == MEM\n+\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+    oldname = XSTR (XEXP (rtlname, 0), 0);\n+  else\n+    abort ();\n+\n+  if (sh_symbian_dllimport_name_p (oldname))\n+    {\n+     /* Remove DLL_IMPORT_PREFIX.\n+\tNote - we do not issue a warning here.  In Symbian's environment it\n+\tis legitimate for a prototype to be marked as dllimport and the\n+\tcorresponding defintion to be marked as dllexport.  The prototypes\n+\tare in headers used everywhere and the defintion is in a translation\n+\tunit which has included the header in order to ensure argument\n+\tcorrectness.  */\n+      oldname += strlen (DLL_IMPORT_PREFIX);\n+      DECL_NON_ADDR_CONST_P (decl) = 0;\n+    }\n+  else if (sh_symbian_dllexport_name_p (oldname))\n+    return; /* Already done.  */\n+\n+  newname = alloca (strlen (DLL_EXPORT_PREFIX) + strlen (oldname) + 1);\n+  sprintf (newname, \"%s%s\", DLL_EXPORT_PREFIX, oldname);\n+\n+  /* We pass newname through get_identifier to ensure it has a unique\n+     address.  RTL processing can sometimes peek inside the symbol ref\n+     and compare the string's addresses to see if two symbols are\n+     identical.  */\n+  idp = get_identifier (newname);\n+\n+  XEXP (DECL_RTL (decl), 0) =\n+    gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+}\n+\n+/* Mark a DECL as being dllimport'd.  */\n+\n+static void\n+sh_symbian_mark_dllimport (tree decl)\n+{\n+  const char *oldname;\n+  char *newname;\n+  tree idp;\n+  rtx rtlname;\n+  rtx newrtl;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+\n+  if (GET_CODE (rtlname) == SYMBOL_REF)\n+    oldname = XSTR (rtlname, 0);\n+  else if (GET_CODE (rtlname) == MEM\n+\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+    oldname = XSTR (XEXP (rtlname, 0), 0);\n+  else\n+    abort ();\n+\n+  if (sh_symbian_dllexport_name_p (oldname))\n+    {\n+      error (\"`%s' declared as both exported to and imported from a DLL\",\n+             IDENTIFIER_POINTER (DECL_NAME (decl)));\n+    }\n+  else if (sh_symbian_dllimport_name_p (oldname))\n+    {\n+      /* Already done, but do a sanity check to prevent assembler errors.  */\n+      if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n+\terror (\"%Hfailure in redeclaration of '%D': dllimport'd symbol lacks external linkage.\",\n+\t       &DECL_SOURCE_LOCATION (decl), decl);\n+    }\n+  else\n+    {\n+      newname = alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);\n+      sprintf (newname, \"%s%s\", DLL_IMPORT_PREFIX, oldname);\n+\n+      /* We pass newname through get_identifier to ensure it has a unique\n+\t address.  RTL processing can sometimes peek inside the symbol ref\n+\t and compare the string's addresses to see if two symbols are\n+\t identical.  */\n+      idp = get_identifier (newname);\n+      newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+      XEXP (DECL_RTL (decl), 0) = newrtl;\n+    }\n+}\n+\n+void\n+sh_symbian_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  default_encode_section_info (decl, rtl, first);\n+\n+  /* Mark the decl so we can tell from the rtl whether\n+     the object is dllexport'd or dllimport'd.  */\n+  if (sh_symbian_dllexport_p (decl))\n+    sh_symbian_mark_dllexport (decl);\n+  else if (sh_symbian_dllimport_p (decl))\n+    sh_symbian_mark_dllimport (decl);\n+  /* It might be that DECL has already been marked as dllimport, but a\n+     subsequent definition nullified that.  The attribute is gone but\n+     DECL_RTL still has (DLL_IMPORT_PREFIX) prefixed. We need to remove\n+     that. Ditto for the DECL_NON_ADDR_CONST_P flag.  */\n+  else if (  (TREE_CODE (decl) == FUNCTION_DECL\n+\t   || TREE_CODE (decl) == VAR_DECL)\n+\t   && DECL_RTL (decl) != NULL_RTX\n+\t   && GET_CODE (DECL_RTL (decl)) == MEM\n+\t   && GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n+\t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n+\t   && sh_symbian_dllimport_name_p (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n+    {\n+      const char * oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n+      /* Remove DLL_IMPORT_PREFIX.  */\n+      tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n+      rtx newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+\n+      warning (\"%H%s '%D' %s after being referenced with dllimport linkage.\",\n+\t       & DECL_SOURCE_LOCATION (decl),\n+\t       TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\",\n+\t       decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n+\t       ? \"defined locally\" : \"redeclared without dllimport attribute\");\n+\n+      XEXP (DECL_RTL (decl), 0) = newrtl;\n+\n+      DECL_NON_ADDR_CONST_P (decl) = 0;\n+    }\n+}\n+\n+\n+/* Return the length of a function name prefix\n+    that starts with the character 'c'.  */\n+\n+static int\n+sh_symbian_get_strip_length (int c)\n+{\n+  /* XXX Assumes strlen (DLL_EXPORT_PREFIX) == strlen (DLL_IMPORT_PREFIX).  */\n+  return (c == SH_SYMBIAN_FLAG_CHAR[0]) ? strlen (DLL_EXPORT_PREFIX) : 0;\n+}\n+\n+/* Return a pointer to a function's name with any\n+   and all prefix encodings stripped from it.  */\n+\n+const char *\n+sh_symbian_strip_name_encoding (const char *name)\n+{\n+  int skip;\n+\n+  while ((skip = sh_symbian_get_strip_length (*name)))\n+    name += skip;\n+\n+  return name;\n+}\n+\n+/* Add the named attribute to the given node.  Copes with both DECLs and\n+   TYPEs.  Will only add the attribute if it is not already present.  */\n+\n+static void\n+symbian_add_attribute (tree node, const char *attr_name)\n+{\n+  tree attrs;\n+  tree attr;\n+\n+  attrs = DECL_P (node) ? DECL_ATTRIBUTES (node) : TYPE_ATTRIBUTES (node);\n+\n+  if (lookup_attribute (attr_name, attrs) != NULL_TREE)\n+    return;\n+\n+  attr = get_identifier (attr_name);\n+\n+  (DECL_P (node) ? DECL_ATTRIBUTES (node) : TYPE_ATTRIBUTES (node))\n+    = tree_cons (attr, NULL_TREE, attrs);\n+\n+#if SYMBIAN_DEBUG\n+  fprintf (stderr, \"propogate %s attribute\", attr_name);\n+  print_node_brief (stderr, \" to\", node, 0);\n+  fprintf (stderr, \"\\n\");\n+#endif\n+}\n+\n+/* Handle a \"dllimport\" or \"dllexport\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+\n+tree\n+sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n+\t\t\t\t int flags, bool *no_add_attrs)\n+{\n+  tree thunk;\n+  tree node = *pnode;\n+  const char *attr = IDENTIFIER_POINTER (name);\n+\n+  /* These attributes may apply to structure and union types being\n+     created, but otherwise should pass to the declaration involved.  */\n+  if (!DECL_P (node))\n+    {\n+      if (flags & ((int) ATTR_FLAG_DECL_NEXT\n+\t\t   | (int) ATTR_FLAG_FUNCTION_NEXT\n+\t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n+\t{\n+\t  warning (\"`%s' attribute ignored\", attr);\n+\t  *no_add_attrs = true;\n+\t  return tree_cons (name, args, NULL_TREE);\n+\t}\n+\n+      if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n+\t{\n+\t  warning (\"`%s' attribute ignored\", attr);\n+\t  *no_add_attrs = true;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Report error on dllimport ambiguities\n+     seen now before they cause any damage.  */\n+  else if (is_attribute_p (\"dllimport\", name))\n+    {\n+      if (TREE_CODE (node) == VAR_DECL)\n+\t{\n+\t  if (DECL_INITIAL (node))\n+\t    {\n+\t      error (\"%Hvariable `%D' definition is marked dllimport.\",\n+\t\t     & DECL_SOURCE_LOCATION (node), node);\n+\t      *no_add_attrs = true;\n+\t    }\n+\n+\t  /* `extern' needn't be specified with dllimport.\n+\t     Specify `extern' now and hope for the best.  Sigh.  */\n+\t  DECL_EXTERNAL (node) = 1;\n+\t  /* Also, implicitly give dllimport'd variables declared within\n+\t     a function global scope, unless declared static.  */\n+\t  if (current_function_decl != NULL_TREE && ! TREE_STATIC (node))\n+  \t    TREE_PUBLIC (node) = 1;\n+\t}\n+    }\n+\n+  /* If the node is an overloaded constructor or desctructor, then we must\n+     make sure that the attribute is propogated along the overload chain,\n+     as it is these overloaded functions which will be emitted, rather than\n+     the user declared constructor itself.  */\n+  if (TREE_CODE (TREE_TYPE (node)) == METHOD_TYPE\n+      && (DECL_CONSTRUCTOR_P (node) || DECL_DESTRUCTOR_P (node)))\n+    {\n+      tree overload;\n+\n+      for (overload = OVL_CHAIN (node); overload; overload = OVL_CHAIN (overload))\n+\t{\n+\t  tree node_args;\n+\t  tree func_args;\n+\t  tree function = OVL_CURRENT (overload);\n+\n+\t  if (! function\n+\t      || ! DECL_P (function)\n+\t      || (DECL_CONSTRUCTOR_P (node) && ! DECL_CONSTRUCTOR_P (function))\n+\t      || (DECL_DESTRUCTOR_P (node)  && ! DECL_DESTRUCTOR_P (function)))\n+\t    continue;\n+\n+\t  /* The arguments must match as well.  */\n+\t  for (node_args = DECL_ARGUMENTS (node), func_args = DECL_ARGUMENTS (function);\n+\t       node_args && func_args;\n+\t       node_args = TREE_CHAIN (node_args), func_args = TREE_CHAIN (func_args))\n+\t    if (TREE_TYPE (node_args) != TREE_TYPE (func_args))\n+\t      break;\n+\n+\t  if (node_args || func_args)\n+\t    {\n+\t      /* We can ignore an extraneous __in_chrg arguments in the node.\n+\t\t GCC generated destructors, for example, will have this.  */\n+\t      if ((node_args == NULL_TREE\n+\t\t   || func_args != NULL_TREE)\n+\t\t  && strcmp (IDENTIFIER_POINTER (DECL_NAME (node)), \"__in_chrg\") != 0)\n+\t\tcontinue;\n+\t    }\n+\n+\t  symbian_add_attribute (function, attr);\n+\n+\t  /* Propogate the attribute to any function thunks as well.  */\n+\t  for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n+\t    if (TREE_CODE (thunk) == FUNCTION_DECL)\n+\t      symbian_add_attribute (thunk, attr);\n+\t}\n+    }\n+\n+  if (TREE_CODE (node) == FUNCTION_DECL && DECL_VIRTUAL_P (node))\n+    {\n+      /* Propogate the attribute to any thunks of this function.  */\n+      for (thunk = DECL_THUNKS (node); thunk; thunk = TREE_CHAIN (thunk))\n+\tif (TREE_CODE (thunk) == FUNCTION_DECL)\n+\t  symbian_add_attribute (thunk, attr);\n+    }\n+\n+  /*  Report error if symbol is not accessible at global scope.  */\n+  if (!TREE_PUBLIC (node)\n+      && (   TREE_CODE (node) == VAR_DECL\n+\t  || TREE_CODE (node) == FUNCTION_DECL))\n+    {\n+      error (\"%Hexternal linkage required for symbol '%D' because of '%s' attribute.\",\n+\t       & DECL_SOURCE_LOCATION (node), node, IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+#if SYMBIAN_DEBUG\n+  print_node_brief (stderr, \"mark node\", node, 0);\n+  fprintf (stderr, \" as %s\\n\", attr);\n+#endif\n+\n+  return NULL_TREE;\n+}\n+\n+/* This code implements a specification for exporting the vtable and rtti of\n+   classes that have members with the dllexport or dllexport attributes.\n+   This specification is defined here:\n+\n+     http://www.armdevzone.com/EABI/exported_class.txt\n+\n+   Basically it says that a class's vtable and rtti should be exported if\n+   the following rules apply:\n+\n+   - If it has any non-inline non-pure virtual functions,\n+     at least one of these need to be declared dllimport\n+     OR any of the constructors is declared dllimport.\n+\n+   AND\n+\n+   - The class has an inline constructor/destructor and\n+     a key-function (placement of vtable uniquely defined) that\n+     is defined in this translation unit.\n+\n+   The specification also says that for classes which will have their\n+   vtables and rtti exported that their base class(es) might also need a\n+   similar exporting if:\n+\n+   - Every base class needs to have its vtable & rtti exported\n+     as well, if the following the conditions hold true:\n+     + The base class has a non-inline declared non-pure virtual function\n+     + The base class is polymorphic (has or inherits any virtual functions)\n+       or the base class has any virtual base classes.  */\n+\f\n+/* Decide if a base class of a class should\n+   also have its vtable and rtti exported.  */\n+\n+static void\n+symbian_possibly_export_base_class (tree base_class)\n+{\n+  tree methods;\n+  int len;\n+\n+  if (! (TYPE_POLYMORPHIC_P (base_class)\n+\t || TYPE_USES_VIRTUAL_BASECLASSES (base_class)))\n+    return;\n+\n+  methods = CLASSTYPE_METHOD_VEC (base_class);\n+  len = methods ? TREE_VEC_LENGTH (methods) : 0;\n+\n+  for (;len --;)\n+    {\n+      tree member = TREE_VEC_ELT (methods, len);\n+\n+      if (! member)\n+\tcontinue;\n+\n+      for (member = OVL_CURRENT (member); member; member = OVL_NEXT (member))\n+\t{\n+\t  if (TREE_CODE (member) != FUNCTION_DECL)\n+\t    continue;\n+\n+\t  if (DECL_CONSTRUCTOR_P (member) || DECL_DESTRUCTOR_P (member))\n+\t    continue;\n+\n+\t  if (! DECL_VIRTUAL_P (member))\n+\t    continue;\n+\n+\t  if (DECL_PURE_VIRTUAL_P (member))\n+\t    continue;\n+\n+\t  if (DECL_INLINE (member))\n+\t    continue;\n+\n+\t  break;\n+\t}\n+\n+      if (member)\n+\tbreak;\n+    }\n+\n+  if (len < 0)\n+    return;\n+\n+  /* FIXME: According to the spec this base class should be exported, but\n+     a) how do we do this ? and\n+     b) it does not appear to be necessary for compliance with the Symbian\n+        OS which so far is the only consumer of this code.  */\n+#if SYMBIAN_DEBUG\n+  print_node_brief (stderr, \"\", base_class, 0);\n+  fprintf (stderr, \" EXPORTed [base class of exported class]\\n\");\n+#endif\n+}\n+\n+/* Decide if a class needs its vtable and rtti exporting.  */\n+\n+static bool\n+symbian_export_vtable_and_rtti_p (tree ctype)\n+{\n+  bool inline_ctor_dtor;\n+  bool dllimport_ctor_dtor;\n+  bool dllimport_member;\n+  tree binfos;\n+  tree methods;\n+  tree key;\n+  int len;\n+\n+  /* Make sure that we are examining a class...  */\n+  if (TREE_CODE (ctype) != RECORD_TYPE)\n+    {\n+#if SYMBIAN_DEBUG\n+      print_node_brief (stderr, \"\", ctype, 0);\n+      fprintf (stderr, \" does NOT need to be EXPORTed [not a class]\\n\");\n+#endif\n+      return false;\n+    }\n+\n+  /* If the class does not have a key function it\n+     does not need to have its vtable exported.  */\n+  if ((key = CLASSTYPE_KEY_METHOD (ctype)) == NULL_TREE)\n+    {\n+#if SYMBIAN_DEBUG\n+      print_node_brief (stderr, \"\", ctype, 0);\n+      fprintf (stderr, \" does NOT need to be EXPORTed [no key function]\\n\");\n+#endif\n+      return false;\n+    }\n+\n+  /* If the key fn has not been defined\n+     then the class should not be exported.  */\n+  if (! TREE_ASM_WRITTEN (key))\n+    {\n+#if SYMBIAN_DEBUG\n+      print_node_brief (stderr, \"\", ctype, 0);\n+      fprintf (stderr, \" does NOT need to be EXPORTed [key function not defined]\\n\");\n+#endif\n+      return false;\n+    }\n+\n+  /* Check the class's member functions.  */\n+  inline_ctor_dtor = false;\n+  dllimport_ctor_dtor = false;\n+  dllimport_member = false;\n+\n+  methods = CLASSTYPE_METHOD_VEC (ctype);\n+  len = methods ? TREE_VEC_LENGTH (methods) : 0;\n+\n+  for (;len --;)\n+    {\n+      tree member = TREE_VEC_ELT (methods, len);\n+\n+      if (! member)\n+\tcontinue;\n+\n+      for (member = OVL_CURRENT (member); member; member = OVL_NEXT (member))\n+\t{\n+\t  if (TREE_CODE (member) != FUNCTION_DECL)\n+\t    continue;\n+\n+\t  if (DECL_CONSTRUCTOR_P (member) || DECL_DESTRUCTOR_P (member))\n+\t    {\n+\t      if (DECL_INLINE (member)\n+\t\t  /* Ignore C++ backend created inline ctors/dtors.  */\n+\t\t  && (   DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (member)\n+\t\t      || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (member)))\n+\t\tinline_ctor_dtor = true;\n+\n+\t      if (lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (member)))\n+\t\tdllimport_ctor_dtor = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (DECL_PURE_VIRTUAL_P (member))\n+\t\tcontinue;\n+\n+\t      if (! DECL_VIRTUAL_P (member))\n+\t\tcontinue;\n+\n+\t      if (DECL_INLINE (member))\n+\t\tcontinue;\n+\n+\t      if (lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (member)))\n+\t\tdllimport_member = true;\n+\t    }\n+\t}\n+    }\n+\n+  if (! dllimport_member && ! dllimport_ctor_dtor)\n+    {\n+#if SYMBIAN_DEBUG\n+      print_node_brief (stderr, \"\", ctype, 0);\n+      fprintf (stderr,\n+\t       \" does NOT need to be EXPORTed [no non-pure virtuals or ctors/dtors with dllimport]\\n\");\n+#endif\n+      return false;\n+    }\n+\n+  if (! inline_ctor_dtor)\n+    {\n+#if SYMBIAN_DEBUG\n+      print_node_brief (stderr, \"\", ctype, 0);\n+      fprintf (stderr,\n+\t       \" does NOT need to be EXPORTed [no inline ctor/dtor]\\n\");\n+#endif\n+      return false;\n+    }\n+\n+#if SYMBIAN_DEBUG\n+  print_node_brief (stderr, \"\", ctype, 0);\n+  fprintf (stderr, \" DOES need to be EXPORTed\\n\");\n+#endif\n+\n+  /* Now we must check and possibly export the base classes.  */\n+  binfos = BINFO_BASE_BINFOS (TYPE_BINFO (ctype));\n+  len = BINFO_N_BASE_BINFOS (TYPE_BINFO (ctype));\n+\n+  for (; len --;)\n+    {\n+      tree base_binfo;\n+      tree basetype;\n+\n+      /* Figure out which base we're looking at.  */\n+      base_binfo = TREE_VEC_ELT (binfos, len);\n+      basetype = TREE_TYPE (base_binfo);\n+\n+      symbian_possibly_export_base_class (basetype);\n+    }\n+\n+  return true;\n+}\n+\n+/* Add the named attribute to a class and its vtable and rtti.  */\n+\n+static void\n+symbian_add_attribute_to_class_vtable_and_rtti (tree ctype, const char *attr_name)\n+{\n+  symbian_add_attribute (ctype, attr_name);\n+\n+  /* If the vtable exists then they need annotating as well.  */\n+  if (CLASSTYPE_VTABLES (ctype))\n+    /* XXX - Do we need to annotate any vtables other than the primary ?  */\n+    symbian_add_attribute (CLASSTYPE_VTABLES (ctype), attr_name);\n+\n+  /* If the rtti exists then it needs annotating as well.  */\n+  if (TYPE_MAIN_VARIANT (ctype)\n+      && CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)))\n+    symbian_add_attribute (CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)),\n+\t\t\t   attr_name);\n+}\n+\n+/* Decide if a class needs to have an attribute because\n+   one of its member functions has the attribute.  */\n+\n+static bool\n+symbian_class_needs_attribute_p (tree ctype, const char *attribute_name)\n+{\n+  /* If the key function has the attribute then the class needs it too.  */\n+  if (TYPE_POLYMORPHIC_P (ctype)\n+      && CLASSTYPE_KEY_METHOD (ctype)\n+      && lookup_attribute (attribute_name,\n+\t\t\t   DECL_ATTRIBUTES (CLASSTYPE_KEY_METHOD (ctype))))\n+    return true;\n+\n+  /* Check the class's member functions.  */\n+  if (TREE_CODE (ctype) == RECORD_TYPE)\n+    {\n+      tree methods = CLASSTYPE_METHOD_VEC (ctype);\n+      unsigned int len = methods ? TREE_VEC_LENGTH (methods) : 0;\n+\n+      for (;len --;)\n+\t{\n+\t  tree member = TREE_VEC_ELT (methods, len);\n+\n+\t  if (! member)\n+\t    continue;\n+\n+\t  for (member = OVL_CURRENT (member);\n+\t       member;\n+\t       member = OVL_NEXT (member))\n+\t    {\n+\t      if (TREE_CODE (member) != FUNCTION_DECL)\n+\t\tcontinue;\n+\n+\t      if (DECL_PURE_VIRTUAL_P (member))\n+\t\tcontinue;\n+\n+\t      if (! DECL_VIRTUAL_P (member))\n+\t\tcontinue;\n+\n+\t      if (lookup_attribute (attribute_name, DECL_ATTRIBUTES (member)))\n+\t\t{\n+#if SYMBIAN_DEBUG\n+\t\t  print_node_brief (stderr, \"\", ctype, 0);\n+\t\t  fprintf (stderr, \" inherits %s because\", attribute_name);\n+\t\t  print_node_brief (stderr, \"\", member, 0);\n+\t\t  fprintf (stderr, \" has it.\\n\");\n+#endif\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+#if SYMBIAN_DEBUG\n+  print_node_brief (stderr, \"\", ctype, 0);\n+  fprintf (stderr, \" does not inherit %s\\n\", attribute_name);\n+#endif\n+  return false;\n+}\n+\n+int\n+symbian_import_export_class (tree ctype, int import_export)\n+{\n+  const char *attr_name = NULL;\n+\n+  /* If we are exporting the class but it does not have the dllexport\n+     attribute then we may need to add it.  Similarly imported classes\n+     may need the dllimport attribute.  */\n+  switch (import_export)\n+    {\n+    case  1: attr_name = \"dllexport\"; break;\n+    case -1: attr_name = \"dllimport\"; break;\n+    default: break;\n+    }\n+\n+  if (attr_name\n+      && ! lookup_attribute (attr_name, TYPE_ATTRIBUTES (ctype)))\n+    {\n+      if (symbian_class_needs_attribute_p (ctype, attr_name))\n+\tsymbian_add_attribute_to_class_vtable_and_rtti (ctype, attr_name);\n+\n+      /* Classes can be forced to export their\n+\t vtable and rtti under certain conditions.  */\n+      if (symbian_export_vtable_and_rtti_p (ctype))\n+\t{\n+\t  symbian_add_attribute_to_class_vtable_and_rtti (ctype, \"dllexport\");\n+\n+\t  /* Make sure that the class and its vtable are exported.  */\n+\t  import_export = 1;\n+\n+\t  if (CLASSTYPE_VTABLES (ctype))\n+\t    DECL_EXTERNAL (CLASSTYPE_VTABLES (ctype)) = 1;\n+\n+\t  /* Check to make sure that if the class has a key method that\n+\t     it is now on the list of keyed classes.  That way its vtable\n+\t     will be emitted.  */\n+\t  if (CLASSTYPE_KEY_METHOD (ctype))\n+\t    {\n+\t      tree class;\n+\n+\t      for (class = keyed_classes; class; class = TREE_CHAIN (class))\n+\t\tif (class == ctype)\n+\t\t  break;\n+\n+\t      if (class == NULL_TREE)\n+\t\t{\n+#if SYMBIAN_DEBUG\n+\t\t  print_node_brief (stderr, \"Add node\", ctype, 0);\n+\t\t  fprintf (stderr, \" to the keyed classes list\\n\");\n+#endif\n+\t\t  keyed_classes = tree_cons (NULL_TREE, ctype, keyed_classes);\n+\t\t}\n+\t    }\n+\n+\t  /* Make sure that the typeinfo will be emitted as well.  */\n+\t  if (CLASS_TYPE_P (ctype))\n+\t    TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)))) = 1;\n+\t}\n+    }\n+\n+  return import_export;\n+}\n+\n+/* Dummy defintion of this array for cc1 building purposes.  */\n+tree cp_global_trees[CPTI_MAX] __attribute__((weak));\n+\n+#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+\n+/* Dummy version of this G++ function for building cc1.  */\n+void lang_check_failed (const char *, int, const char *) __attribute__((weak));\n+\n+void\n+lang_check_failed (const char *file, int line, const char *function)\n+{\n+  internal_error (\"lang_* check: failed in %s, at %s:%d\",\n+\t\t  function, trim_filename (file), line);\n+}\n+#endif /* ENABLE_TREE_CHECKING */"}, {"sha": "494029fabfab2d00604491cb857be8b69b396fb0", "filename": "gcc/config/sh/t-symbian", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Ft-symbian", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fconfig%2Fsh%2Ft-symbian", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-symbian?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -0,0 +1,35 @@\n+LIB1ASMSRC = sh/lib1funcs.asm\n+LIB1ASMFUNCS = _ashiftrt _ashiftrt_n _ashiftlt _lshiftrt _movstr \\\n+  _movstr_i4 _mulsi3 _sdivsi3 _sdivsi3_i4 _udivsi3 _udivsi3_i4 _set_fpscr \\\n+  $(LIB1ASMFUNCS_CACHE)\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+$(T)crt1.o: $(srcdir)/config/sh/crt1.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crt1.o -x assembler-with-cpp $(srcdir)/config/sh/crt1.asm\n+$(T)crti.o: $(srcdir)/config/sh/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/sh/crti.asm\n+$(T)crtn.o: $(srcdir)/config/sh/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/sh/crtn.asm\n+\n+$(out_object_file): gt-sh.h\n+gt-sh.h : s-gtype ; @true\n+\n+symbian.o: $(srcdir)/config/sh/symbian.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+  $(RTL_H) output.h flags.h $(TREE_H) expr.h toplev.h $(TM_P_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/sh/symbian.c\n+\n+\n+# Local Variables:\n+# mode: Makefile\n+# End:"}, {"sha": "1df022107be883a7aa66b871f2c5fa01be48a4be", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "patch": "@@ -2009,10 +2009,11 @@ types (@pxref{Variable Attributes}, @pxref{Type Attributes}.)\n \n @item dllexport\n @cindex @code{__declspec(dllexport)}\n-On Microsoft Windows targets the @code{dllexport} attribute causes the\n-compiler to provide a global pointer to a pointer in a dll, so that it\n-can be referenced with the @code{dllimport} attribute. The pointer name\n-is formed by combining @code{_imp__} and the function or variable name.\n+On Microsoft Windows targets and Symbian targets the @code{dllexport}\n+attribute causes the compiler to provide a global pointer to a pointer\n+in a dll, so that it can be referenced with the @code{dllimport}\n+attribute. The pointer name is formed by combining @code{_imp__} and\n+the function or variable name.\n \n Currently, the @code{dllexport}attribute is ignored for inlined\n functions, but export can be forced by using the\n@@ -2024,21 +2025,24 @@ member functions and static data members as exports. Static consts\n initialized in-class are not marked unless they are also defined\n out-of-class.\n \n-On cygwin, mingw and arm-pe targets, @code{__declspec(dllexport)} is\n-recognized as a synonym for @code{__attribute__ ((dllexport))} for\n-compatibility with other Microsoft Windows compilers.\n+On cygwin, mingw, arm-pe and sh-symbianelf targets,\n+@code{__declspec(dllexport)} is recognized as a synonym for\n+@code{__attribute__ ((dllexport))} for compatibility with other\n+Microsoft Windows and Symbian compilers. \n \n-Alternative methods for including the symbol in the dll's export table\n-are to use a .def file with an @code{EXPORTS} section or, with GNU ld,\n-using the @option{--export-all} linker flag.\n+For Microsoft Windows targets there are alternative methods for\n+including the symbol in the dll's export table such as using a\n+@file{.def} file with an @code{EXPORTS} section or, with GNU ld, using\n+the @option{--export-all} linker flag.\n \n @item dllimport\n @cindex @code{__declspec(dllimport)}\n-On Microsoft Windows targets, the @code{dllimport} attribute causes the\n-compiler to reference a function or variable via a global pointer to a\n-pointer that is set up by the Microsoft Windows dll library. The pointer\n-name is formed by combining @code{_imp__} and the function or variable\n-name. The attribute implies @code{extern} storage.\n+On Microsoft Windows and Symbian targets, the @code{dllimport}\n+attribute causes the compiler to reference a function or variable via\n+a global pointer to a pointer that is set up by the Microsoft Windows\n+dll library. The pointer name is formed by combining @code{_imp__} and\n+the function or variable name. The attribute implies @code{extern}\n+storage.\n \n Currently, the attribute is ignored for inlined functions. If the\n attribute is applied to a symbol @emph{definition}, an error is reported.\n@@ -2052,15 +2056,25 @@ member functions and static data members as imports.  However, the\n attribute is ignored for virtual methods to allow creation of vtables\n using thunks.\n \n-On cygwin, mingw and arm-pe targets, @code{__declspec(dllimport)} is\n-recognized as a synonym for @code{__attribute__ ((dllimport))} for\n-compatibility with other Microsoft Windows compilers.\n+For Symbian targets the @code{dllimport} attribute also has another\n+affect - it can cause the vtable and run-time type information for a\n+class to be exported.  This happens when the class has a dllimport'ed\n+constructor or a non-inline, non-pure virtual function and, for either\n+of those two conditions, the class also has a inline constructor or\n+destructor and has a key function that is defined in the current\n+translation unit.\n \n-The use of the @code{dllimport} attribute on functions is not necessary,\n-but provides a small performance benefit by eliminating a thunk in the\n-dll. The use of the @code{dllimport} attribute on imported variables was\n-required on older versions of GNU ld, but can now be avoided by passing\n-the @option{--enable-auto-import} switch to ld. As with functions, using\n+On cygwin, mingw, arm-pe sh-symbianelf targets,\n+@code{__declspec(dllimport)} is recognized as a synonym for\n+@code{__attribute__ ((dllimport))} for compatibility with other\n+Microsoft Windows and Symbian compilers. \n+\n+For Microsoft Windows based targets the use of the @code{dllimport}\n+attribute on functions is not necessary, but provides a small\n+performance benefit by eliminating a thunk in the dll. The use of the\n+@code{dllimport} attribute on imported variables was required on older\n+versions of GNU ld, but can now be avoided by passing the\n+@option{--enable-auto-import} switch to ld. As with functions, using\n the attribute for a variable eliminates a thunk in the dll.\n \n One drawback to using this attribute is that a pointer to a function or"}]}