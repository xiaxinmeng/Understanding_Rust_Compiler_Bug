{"sha": "1ff5b671b624facd50c681f4683c16f740455d02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmNWI2NzFiNjI0ZmFjZDUwYzY4MWY0NjgzYzE2Zjc0MDQ1NWQwMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "2000-03-21T04:05:49Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-03-21T04:05:49Z"}, "message": "Minor performance improvements.  Minor EH/unwind bug fix.\n\n\t* config/ia64/ia64.c (ia64_expand_prologue): Don't abort if leaf\n\tfunction uses output registers.  Don't save RP for leaf functions.\n\tDo save RP even if no epilogue.\n\t* config/ia64/ia64.h (FIXED_REGISTERS): Unmark in/out registers.\n\t(CALL_USED_REGISTERS): Unmark in registers.\n\t(REG_ALLOC_ORDER): Move out regs up, to near the top.  Move in regs up,\n\tto near the middle.\n\nFrom-SVN: r32661", "tree": {"sha": "4f79aa00b76655a19ff4514ce0060f758ab5305c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f79aa00b76655a19ff4514ce0060f758ab5305c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff5b671b624facd50c681f4683c16f740455d02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff5b671b624facd50c681f4683c16f740455d02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff5b671b624facd50c681f4683c16f740455d02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff5b671b624facd50c681f4683c16f740455d02/comments", "author": null, "committer": null, "parents": [{"sha": "c1f6390295e646f7e26a9ccc2cca171927b3632c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1f6390295e646f7e26a9ccc2cca171927b3632c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1f6390295e646f7e26a9ccc2cca171927b3632c"}], "stats": {"total": 87, "additions": 48, "deletions": 39}, "files": [{"sha": "1b7cde3dec08f532bebb279476b38f0e7bec9998", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff5b671b624facd50c681f4683c16f740455d02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff5b671b624facd50c681f4683c16f740455d02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ff5b671b624facd50c681f4683c16f740455d02", "patch": "@@ -1,3 +1,13 @@\n+Mon Mar 20 19:53:53 2000  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* config/ia64/ia64.c (ia64_expand_prologue): Don't abort if leaf\n+\tfunction uses output registers.  Don't save RP for leaf functions.\n+\tDo save RP even if no epilogue.\n+\t* config/ia64/ia64.h (FIXED_REGISTERS): Unmark in/out registers.\n+\t(CALL_USED_REGISTERS): Unmark in registers.\n+\t(REG_ALLOC_ORDER): Move out regs up, to near the top.  Move in regs up,\n+\tto near the middle.\n+\n 2000-03-20  Geoff Keating  <geoffk@cygnus.com>\n \n \t* config/rs6000/rs6000.md (bunordered): New expander."}, {"sha": "9de15aba805ff55fc75bcfa5c77109330922e98d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff5b671b624facd50c681f4683c16f740455d02/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff5b671b624facd50c681f4683c16f740455d02/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=1ff5b671b624facd50c681f4683c16f740455d02", "patch": "@@ -775,12 +775,6 @@ save_restore_insns (save_p)\n /* ??? Get inefficient code when the frame size is larger than can fit in an\n    adds instruction.  */\n \n-/* ??? Add support for allocating temporaries from the output registers if\n-   they do not need to live past call instructions.  */\n-\n-/* ??? If the function does not return, then we don't need to save the rp\n-   and ar.pfs registers.  */\n-\n /* ??? If this is a leaf function, then fp/rp/ar.pfs should be put in the\n    low 32 regs.  */\n \n@@ -807,7 +801,7 @@ ia64_expand_prologue ()\n   leaf_function = leaf_function_p ();\n   pop_topmost_sequence ();\n \n-  /* ??? If there is no epilogue, then we don't need some prologue insns.  We\n+  /* If there is no epilogue, then we don't need some prologue insns.  We\n      need to avoid emitting the dead prologue insns, because flow will complain\n      about them.  */\n   if (optimize)\n@@ -863,17 +857,15 @@ ia64_expand_prologue ()\n   else if (profile_block_flag == 2)\n     outputs = MAX (outputs, 2);\n \n-  /* Leaf functions should not use any output registers.  */\n-  if (leaf_function && outputs != 0)\n-    abort ();\n-\n   /* No rotating register support as yet.  */\n \n   rotates = 0;\n \n   /* Allocate two extra locals for saving/restoring rp and ar.pfs.  Also\n      allocate one local for use as the frame pointer if frame_pointer_needed\n      is true.  */\n+  /* ??? If this is a leaf function, then we aren't using one of these local\n+     registers for the RP anymore.  */\n   locals += 2 + frame_pointer_needed;\n \n   /* Save these values in global registers for debugging info.  */\n@@ -925,6 +917,7 @@ ia64_expand_prologue ()\n   /* We don't need an alloc instruction if this is a leaf function, and the\n      locals and outputs are both zero sized.  Since we have already allocated\n      two locals for rp and ar.pfs, we check for two locals.  */\n+  /* Leaf functions can use output registers as call-clobbered temporaries.  */\n   if (locals == 2 && outputs == 0 && leaf_function)\n     {\n       /* If there is no alloc, but there are input registers used, then we\n@@ -940,21 +933,36 @@ ia64_expand_prologue ()\n   else\n     {\n       ia64_need_regstk = 0;\n-\n       ia64_arpfs_regno = LOC_REG (locals - 1);\n-      ia64_rp_regno = LOC_REG (locals - 2);\n-      reg_names[RETURN_ADDRESS_REGNUM] = reg_names[ia64_rp_regno];\n \n       emit_insn (gen_alloc (gen_rtx_REG (DImode, ia64_arpfs_regno),\n \t\t\t    GEN_INT (inputs), GEN_INT (locals),\n \t\t\t    GEN_INT (outputs), GEN_INT (rotates)));\n \n-      /* ??? FIXME ??? We don't need to save BR_REG (0) if this is a leaf\n-\t function.  We also don't need to allocate a local reg for it then.  */\n-      /* ??? Likewise if there is no epilogue.  */\n-      if (epilogue_p)\n-\temit_move_insn (gen_rtx_REG (DImode, ia64_rp_regno),\n-\t\t\tgen_rtx_REG (DImode, BR_REG (0)));\n+      /* Emit a save of BR_REG (0) if we call other functions.\n+\t Do this even if this function doesn't return, as EH\n+         depends on this to be able to unwind the stack.  */\n+      if (! leaf_function)\n+\t{\n+\t  rtx ia64_rp_reg;\n+\n+\t  ia64_rp_regno = LOC_REG (locals - 2);\n+\t  reg_names[RETURN_ADDRESS_REGNUM] = reg_names[ia64_rp_regno];\n+\n+\t  ia64_rp_reg = gen_rtx_REG (DImode, ia64_rp_regno);\n+\t  insn = emit_move_insn (ia64_rp_reg, gen_rtx_REG (DImode,\n+\t\t\t\t\t\t\t   BR_REG (0)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  if (! epilogue_p)\n+\t    {\n+\t      /* If we don't have an epilogue, then the return value\n+\t\t doesn't appear to be needed and the above store will\n+\t\t appear dead and will elicit a warning from flow.  */\n+\t      emit_insn (gen_rtx_USE (VOIDmode, ia64_rp_reg));\n+\t    }\n+\t}\n+      else\n+\tia64_rp_regno = 0;\n     }\n \n   /* Set up frame pointer and stack pointer.  */"}, {"sha": "dd07ae1dab0f6cf831e83d68f5b2223e68544c17", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff5b671b624facd50c681f4683c16f740455d02/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff5b671b624facd50c681f4683c16f740455d02/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=1ff5b671b624facd50c681f4683c16f740455d02", "patch": "@@ -577,16 +577,14 @@ while (0)\n    p0: constant true\n    fp: eliminable frame pointer */   \n \n-/* The last 16 stacked regs are fixed, because they are reserved for the 8\n-   input and 8 output registers.  */\n+/* The last 16 stacked regs are reserved for the 8 input and 8 output\n+   registers.  */\n \n /* ??? Must mark the next 3 stacked regs as fixed, because ia64_expand_prologue\n    assumes that three locals are available for fp, b0, and ar.pfs.  */\n \n /* ??? Should mark b0 as fixed?  */\n \n-/* ??? input and output registers do not have to be marked as fixed.  */\n-\n #define FIXED_REGISTERS \\\n { /* General registers.  */\t\t\t\t\\\n   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,\t\\\n@@ -596,7 +594,7 @@ while (0)\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   /* Floating-point registers.  */\t\t\t\\\n   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n@@ -622,8 +620,6 @@ while (0)\n    therefore identifies the registers that are not available for general\n    allocation of values that must live across function calls.  */\n \n-/* ??? If inputs are not marked as fixed, then they are not call clobbered.  */\n-\n #define CALL_USED_REGISTERS \\\n { /* General registers.  */\t\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -633,7 +629,7 @@ while (0)\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   /* Floating-point registers.  */\t\t\t\\\n   1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n@@ -689,18 +685,16 @@ while (0)\n /* ??? Should the GR return value registers come before or after the rest\n    of the caller-save GRs?  */\n \n-/* ??? Output registers are cheap, because they will be not be saved\n-   by the register engine.  They probably should be early in the list.\n-   We need to make them not fixed first though.  Similarly, input registers\n-   are callee-saved (RSE) like the stacked locals.  */\n-\n #define REG_ALLOC_ORDER \\\n {\t\t\t\t\t\t\t\t\t   \\\n   /* Caller-saved general registers.  */\t\t\t\t   \\\n   R_GR (14), R_GR (15), R_GR (16), R_GR (17), \t\t\t\t   \\\n   R_GR (18), R_GR (19), R_GR (20), R_GR (21), R_GR (22), R_GR (23), \t   \\\n   R_GR (24), R_GR (25), R_GR (26), R_GR (27), R_GR (28), R_GR (29), \t   \\\n   R_GR (30), R_GR (31),\t\t\t\t\t\t\t   \\\n+  /* Output registers.  */\t\t\t\t\t\t   \\\n+  R_GR (120), R_GR (121), R_GR (122), R_GR (123), R_GR (124), R_GR (125),  \\\n+  R_GR (126), R_GR (127), \t\t\t\t\t\t   \\\n   /* Caller-saved general registers, also used for return values.  */\t   \\\n   R_GR (8), R_GR (9), R_GR (10), R_GR (11), \t\t\t\t   \\\n   /* addl caller-saved general registers.  */\t\t\t\t   \\\n@@ -759,6 +753,9 @@ while (0)\n   R_GR (96), R_GR (97), R_GR (98), R_GR (99), R_GR (100), R_GR (101), \t   \\\n   R_GR (102), R_GR (103), R_GR (104), R_GR (105), R_GR (106), R_GR (107),  \\\n   R_GR (108),\t\t\t\t\t\t\t\t   \\\n+  /* Input registers.  */\t\t\t\t\t\t   \\\n+  R_GR (112), R_GR (113), R_GR (114), R_GR (115), R_GR (116), R_GR (117),  \\\n+  R_GR (118), R_GR (119),\t\t\t\t\t\t   \\\n   /* Callee-saved general registers.  */\t\t\t\t   \\\n   R_GR (4), R_GR (5), R_GR (6), R_GR (7),\t\t\t\t   \\\n   /* Callee-saved FP registers.  */\t\t\t\t\t   \\\n@@ -773,12 +770,6 @@ while (0)\n \t\t\t\t\t\t\t\t\t   \\\n   /* ??? Stacked registers reserved for fp, rp, and ar.pfs.  */\t\t   \\\n   R_GR (109), R_GR (110), R_GR (111),\t\t\t\t\t   \\\n-  /* Input registers.  */\t\t\t\t\t\t   \\\n-  R_GR (112), R_GR (113), R_GR (114), R_GR (115), R_GR (116), R_GR (117),  \\\n-  R_GR (118), R_GR (119),\t\t\t\t\t\t   \\\n-  /* Output registers.  */\t\t\t\t\t\t   \\\n-  R_GR (120), R_GR (121), R_GR (122), R_GR (123), R_GR (124), R_GR (125),  \\\n-  R_GR (126), R_GR (127), \t\t\t\t\t\t   \\\n \t\t\t\t\t\t\t\t\t   \\\n   /* Special general registers.  */\t\t\t\t\t   \\\n   R_GR (0), R_GR (1), R_GR (12), R_GR (13), \t\t\t\t   \\"}]}