{"sha": "9a81dba68ad052fa270246786e2fd1b378708e9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4MWRiYTY4YWQwNTJmYTI3MDI0Njc4NmUyZmQxYjM3ODcwOGU5Yw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2016-04-19T14:01:21Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-04-19T14:01:21Z"}, "message": "i386.c (ix86_decompose_address): Use lowpart_subreg instead of simplify_gen_subreg (...\n\n\t* config/i386/i386.c (ix86_decompose_address): Use lowpart_subreg\n\tinstead of simplify_gen_subreg (... , 0).\n\t(ix86_delegitimize_address): Ditto.\n\t(ix86_split_divmod): Ditto.\n\t(ix86_split_copysign_const): Ditto.\n\t(ix86_split_copysign_var): Ditto.\n\t(ix86_expand_args_builtin): Ditto.\n\t(ix86_expand_round_builtin): Ditto.\n\t(ix86_expand_special_args_builtin): Ditto.\n\t* config/i386/i386.md (TARGET_USE_VECTOR_FP_CONVERTS splitters): Ditto.\n\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY splitters and peephole2s): Ditto.\n\t(udivmodqi4): Ditto.\n\t(absneg splitters): Ditto.\n\t(*jcc_bt<mode>_1): Ditto.\n\nFrom-SVN: r235207", "tree": {"sha": "97cd0c9b2ebd22ef42ce747f1928edb258cd6035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97cd0c9b2ebd22ef42ce747f1928edb258cd6035"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a81dba68ad052fa270246786e2fd1b378708e9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a81dba68ad052fa270246786e2fd1b378708e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a81dba68ad052fa270246786e2fd1b378708e9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a81dba68ad052fa270246786e2fd1b378708e9c/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ba065e89ed92e76d5a1941b786111fbc1c70fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba065e89ed92e76d5a1941b786111fbc1c70fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba065e89ed92e76d5a1941b786111fbc1c70fa7"}], "stats": {"total": 106, "additions": 58, "deletions": 48}, "files": [{"sha": "095d1d459143bd364a4ed082e68fb4b62b5fd2b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a81dba68ad052fa270246786e2fd1b378708e9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a81dba68ad052fa270246786e2fd1b378708e9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a81dba68ad052fa270246786e2fd1b378708e9c", "patch": "@@ -1,3 +1,20 @@\n+2016-04-19  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_decompose_address): Use lowpart_subreg\n+\tinstead of simplify_gen_subreg (... , 0).\n+\t(ix86_delegitimize_address): Ditto.\n+\t(ix86_split_divmod): Ditto.\n+\t(ix86_split_copysign_const): Ditto.\n+\t(ix86_split_copysign_var): Ditto.\n+\t(ix86_expand_args_builtin): Ditto.\n+\t(ix86_expand_round_builtin): Ditto.\n+\t(ix86_expand_special_args_builtin): Ditto.\n+\t* config/i386/i386.md (TARGET_USE_VECTOR_FP_CONVERTS splitters): Ditto.\n+\t(TARGET_SSE_PARTIAL_REG_DEPENDENCY splitters and peephole2s): Ditto.\n+\t(udivmodqi4): Ditto.\n+\t(absneg splitters): Ditto.\n+\t(*jcc_bt<mode>_1): Ditto.\n+\n 2016-04-19  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/70724"}, {"sha": "a3ffee9dd4a35c3a0503acf5bfa71b5b4d10a4fe", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a81dba68ad052fa270246786e2fd1b378708e9c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a81dba68ad052fa270246786e2fd1b378708e9c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9a81dba68ad052fa270246786e2fd1b378708e9c", "patch": "@@ -14100,7 +14100,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n       else if (GET_CODE (addr) == AND\n \t       && const_32bit_mask (XEXP (addr, 1), DImode))\n \t{\n-\t  addr = simplify_gen_subreg (SImode, XEXP (addr, 0), DImode, 0);\n+\t  addr = lowpart_subreg (SImode, XEXP (addr, 0), DImode);\n \t  if (addr == NULL_RTX)\n \t    return 0;\n \n@@ -16211,8 +16211,7 @@ ix86_delegitimize_address (rtx x)\n \t  x = XVECEXP (XEXP (x, 0), 0, 0);\n \t  if (GET_MODE (orig_x) != GET_MODE (x) && MEM_P (orig_x))\n \t    {\n-\t      x = simplify_gen_subreg (GET_MODE (orig_x), x,\n-\t\t\t\t       GET_MODE (x), 0);\n+\t      x = lowpart_subreg (GET_MODE (orig_x), x, GET_MODE (x));\n \t      if (x == NULL_RTX)\n \t\treturn orig_x;\n \t    }\n@@ -16303,7 +16302,7 @@ ix86_delegitimize_address (rtx x)\n     }\n   if (GET_MODE (orig_x) != Pmode && MEM_P (orig_x))\n     {\n-      result = simplify_gen_subreg (GET_MODE (orig_x), result, Pmode, 0);\n+      result = lowpart_subreg (GET_MODE (orig_x), result, Pmode);\n       if (result == NULL_RTX)\n \treturn orig_x;\n     }\n@@ -19580,9 +19579,9 @@ ix86_split_idivmod (machine_mode mode, rtx operands[],\n   emit_label (qimode_label);\n   /* Don't use operands[0] for result of 8bit divide since not all\n      registers support QImode ZERO_EXTRACT.  */\n-  tmp0 = simplify_gen_subreg (HImode, scratch, mode, 0);\n-  tmp1 = simplify_gen_subreg (HImode, operands[2], mode, 0);\n-  tmp2 = simplify_gen_subreg (QImode, operands[3], mode, 0);\n+  tmp0 = lowpart_subreg (HImode, scratch, mode);\n+  tmp1 = lowpart_subreg (HImode, operands[2], mode);\n+  tmp2 = lowpart_subreg (QImode, operands[3], mode);\n   emit_insn (gen_udivmodhiqi3 (tmp0, tmp1, tmp2));\n \n   if (signed_p)\n@@ -21016,7 +21015,7 @@ ix86_split_copysign_const (rtx operands[])\n   mode = GET_MODE (dest);\n   vmode = GET_MODE (mask);\n \n-  dest = simplify_gen_subreg (vmode, dest, mode, 0);\n+  dest = lowpart_subreg (vmode, dest, mode);\n   x = gen_rtx_AND (vmode, dest, mask);\n   emit_insn (gen_rtx_SET (dest, x));\n \n@@ -21062,7 +21061,7 @@ ix86_split_copysign_var (rtx operands[])\n       emit_insn (gen_rtx_SET (scratch, x));\n \n       dest = mask;\n-      op0 = simplify_gen_subreg (vmode, op0, mode, 0);\n+      op0 = lowpart_subreg (vmode, op0, mode);\n       x = gen_rtx_NOT (vmode, dest);\n       x = gen_rtx_AND (vmode, x, op0);\n       emit_insn (gen_rtx_SET (dest, x));\n@@ -21076,21 +21075,21 @@ ix86_split_copysign_var (rtx operands[])\n       else\t\t\t\t\t\t/* alternative 2,4 */\n \t{\n           gcc_assert (REGNO (mask) == REGNO (scratch));\n-          op1 = simplify_gen_subreg (vmode, op1, mode, 0);\n+          op1 = lowpart_subreg (vmode, op1, mode);\n \t  x = gen_rtx_AND (vmode, scratch, op1);\n \t}\n       emit_insn (gen_rtx_SET (scratch, x));\n \n       if (REGNO (op0) == REGNO (dest))\t\t\t/* alternative 1,2 */\n \t{\n-\t  dest = simplify_gen_subreg (vmode, op0, mode, 0);\n+\t  dest = lowpart_subreg (vmode, op0, mode);\n \t  x = gen_rtx_AND (vmode, dest, nmask);\n \t}\n       else\t\t\t\t\t\t/* alternative 3,4 */\n \t{\n           gcc_assert (REGNO (nmask) == REGNO (dest));\n \t  dest = nmask;\n-\t  op0 = simplify_gen_subreg (vmode, op0, mode, 0);\n+\t  op0 = lowpart_subreg (vmode, op0, mode);\n \t  x = gen_rtx_AND (vmode, dest, op0);\n \t}\n       emit_insn (gen_rtx_SET (dest, x));\n@@ -39115,7 +39114,7 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n   else\n     {\n       real_target = gen_reg_rtx (tmode);\n-      target = simplify_gen_subreg (rmode, real_target, tmode, 0);\n+      target = lowpart_subreg (rmode, real_target, tmode);\n     }\n \n   for (i = 0; i < nargs; i++)\n@@ -39132,7 +39131,7 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n \t     count.  If count doesn't match, we put it in register.  */\n \t  if (!match)\n \t    {\n-\t      op = simplify_gen_subreg (SImode, op, GET_MODE (op), 0);\n+\t      op = lowpart_subreg (SImode, op, GET_MODE (op));\n \t      if (!insn_p->operand[i + 1].predicate (op, mode))\n \t\top = copy_to_reg (op);\n \t    }\n@@ -39288,7 +39287,7 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n \t  else\n \t    {\n \t      op = copy_to_reg (op);\n-\t      op = simplify_gen_subreg (mode, op, GET_MODE (op), 0);\n+\t      op = lowpart_subreg (mode, op, GET_MODE (op));\n \t    }\n \t}\n \n@@ -39662,7 +39661,7 @@ ix86_expand_round_builtin (const struct builtin_description *d,\n \t  else\n \t    {\n \t      op = copy_to_reg (op);\n-\t      op = simplify_gen_subreg (mode, op, GET_MODE (op), 0);\n+\t      op = lowpart_subreg (mode, op, GET_MODE (op));\n \t    }\n \t}\n \n@@ -40060,7 +40059,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n \t      else\n \t        {\n \t          op = copy_to_reg (op);\n-\t          op = simplify_gen_subreg (mode, op, GET_MODE (op), 0);\n+\t          op = lowpart_subreg (mode, op, GET_MODE (op));\n \t        }\n \t    }\n \t}\n@@ -41276,9 +41275,9 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n       op1 = expand_normal (arg1);\n \n       op0 = copy_to_reg (op0);\n-      op0 = simplify_gen_subreg (mode0, op0, GET_MODE (op0), 0);\n+      op0 = lowpart_subreg (mode0, op0, GET_MODE (op0));\n       op1 = copy_to_reg (op1);\n-      op1 = simplify_gen_subreg (mode0, op1, GET_MODE (op1), 0);\n+      op1 = lowpart_subreg (mode0, op1, GET_MODE (op1));\n \n       target = gen_reg_rtx (QImode);\n       emit_insn (gen_rtx_SET (target, const0_rtx));\n@@ -41669,7 +41668,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n       else\n \t{\n \t  op3 = copy_to_reg (op3);\n-\t  op3 = simplify_gen_subreg (mode3, op3, GET_MODE (op3), 0);\n+\t  op3 = lowpart_subreg (mode3, op3, GET_MODE (op3));\n \t}\n       if (!insn_data[icode].operand[5].predicate (op4, mode4))\n \t{\n@@ -41844,7 +41843,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n       else\n \t{\n \t  op1 = copy_to_reg (op1);\n-\t  op1 = simplify_gen_subreg (mode1, op1, GET_MODE (op1), 0);\n+\t  op1 = lowpart_subreg (mode1, op1, GET_MODE (op1));\n \t}\n \n       if (!insn_data[icode].operand[2].predicate (op2, mode2))\n@@ -41892,7 +41891,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n       else\n \t{\n \t  op0 = copy_to_reg (op0);\n-\t  op0 = simplify_gen_subreg (mode0, op0, GET_MODE (op0), 0);\n+\t  op0 = lowpart_subreg (mode0, op0, GET_MODE (op0));\n \t}\n \n       if (!insn_data[icode].operand[1].predicate (op1, mode1))"}, {"sha": "6596a1d99aaf254c8d466afb3c4b7db7b39f5147", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a81dba68ad052fa270246786e2fd1b378708e9c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a81dba68ad052fa270246786e2fd1b378708e9c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9a81dba68ad052fa270246786e2fd1b378708e9c", "patch": "@@ -4221,8 +4221,8 @@\n \t     (match_dup 3)\n \t     (parallel [(const_int 0) (const_int 1)]))))]\n {\n-  operands[2] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n-  operands[3] = simplify_gen_subreg (V4SFmode, operands[0], DFmode, 0);\n+  operands[2] = lowpart_subreg (V2DFmode, operands[0], DFmode);\n+  operands[3] = lowpart_subreg (V4SFmode, operands[0], DFmode);\n   /* Use movss for loading from memory, unpcklps reg, reg for registers.\n      Try to avoid move when unpacking can be done in source.  */\n   if (REG_P (operands[1]))\n@@ -4239,7 +4239,7 @@\n \t  emit_move_insn (tmp, operands[1]);\n \t}\n       else\n-\toperands[3] = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+\toperands[3] = lowpart_subreg (V4SFmode, operands[1], SFmode);\n       /* FIXME: vec_interleave_lowv4sf for AVX512VL should allow\n \t =v, v, then vbroadcastss will be only needed for AVX512F without\n \t AVX512VL.  */\n@@ -4248,7 +4248,7 @@\n \t\t\t\t\t       operands[3]));\n       else\n \t{\n-\t  rtx tmp = simplify_gen_subreg (V16SFmode, operands[3], V4SFmode, 0);\n+\t  rtx tmp = lowpart_subreg (V16SFmode, operands[3], V4SFmode);\n \t  emit_insn (gen_avx512f_vec_dupv16sf_1 (tmp, tmp));\n \t}\n     }\n@@ -4382,9 +4382,9 @@\n \t     (match_dup 4))\n \t   (match_dup 3)))]\n {\n-  operands[2] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+  operands[2] = lowpart_subreg (V4SFmode, operands[0], SFmode);\n   operands[3] = CONST0_RTX (V2SFmode);\n-  operands[4] = simplify_gen_subreg (V2DFmode, operands[0], SFmode, 0);\n+  operands[4] = lowpart_subreg (V2DFmode, operands[0], SFmode);\n   /* Use movsd for loading from memory, unpcklpd for registers.\n      Try to avoid move when unpacking can be done in source, or SSE3\n      movddup is available.  */\n@@ -4395,12 +4395,12 @@\n \t  && (ORIGINAL_REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n \t      || PSEUDO_REGNO_BYTES (ORIGINAL_REGNO (operands[1])) > 8))\n \t{\n-\t  rtx tmp = simplify_gen_subreg (DFmode, operands[0], SFmode, 0);\n+\t  rtx tmp = lowpart_subreg (DFmode, operands[0], SFmode);\n \t  emit_move_insn (tmp, operands[1]);\n \t  operands[1] = tmp;\n \t}\n       else if (!TARGET_SSE3)\n-\toperands[4] = simplify_gen_subreg (V2DFmode, operands[1], DFmode, 0);\n+\toperands[4] = lowpart_subreg (V2DFmode, operands[1], DFmode);\n       emit_insn (gen_vec_dupv2df (operands[4], operands[1]));\n     }\n   else\n@@ -5141,9 +5141,8 @@\n        || TARGET_AVX512VL)\"\n   [(const_int 0)]\n {\n-  operands[3] = simplify_gen_subreg (<ssevecmode>mode, operands[0],\n-\t\t\t\t     <MODE>mode, 0);\n-  operands[4] = simplify_gen_subreg (V4SImode, operands[0], <MODE>mode, 0);\n+  operands[3] = lowpart_subreg (<ssevecmode>mode, operands[0], <MODE>mode);\n+  operands[4] = lowpart_subreg (V4SImode, operands[0], <MODE>mode);\n \n   emit_insn (gen_sse2_loadld (operands[4],\n \t\t\t      CONST0_RTX (V4SImode), operands[1]));\n@@ -5169,7 +5168,7 @@\n {\n   const machine_mode vmode = <MODEF:ssevecmode>mode;\n   const machine_mode mode = <MODEF:MODE>mode;\n-  rtx t, op0 = simplify_gen_subreg (vmode, operands[0], mode, 0);\n+  rtx t, op0 = lowpart_subreg (vmode, operands[0], mode);\n \n   emit_move_insn (op0, CONST0_RTX (vmode));\n \n@@ -5202,10 +5201,8 @@\n \t  (match_dup 0)\n \t  (const_int 1)))]\n {\n-  operands[0] = simplify_gen_subreg (V4SFmode, operands[0],\n-\t\t\t\t     SFmode, 0);\n-  operands[1] = simplify_gen_subreg (V2DFmode, operands[1],\n-\t\t\t\t     DFmode, 0);\n+  operands[0] = lowpart_subreg (V4SFmode, operands[0], SFmode);\n+  operands[1] = lowpart_subreg (V2DFmode, operands[1], DFmode);\n   emit_move_insn (operands[0], CONST0_RTX (V4SFmode));\n })\n \n@@ -5232,10 +5229,8 @@\n           (match_dup 0)\n           (const_int 1)))]\n {\n-  operands[0] = simplify_gen_subreg (V2DFmode, operands[0],\n-\t\t\t\t     DFmode, 0);\n-  operands[1] = simplify_gen_subreg (V4SFmode, operands[1],\n-\t\t\t\t     SFmode, 0);\n+  operands[0] = lowpart_subreg (V2DFmode, operands[0], DFmode);\n+  operands[1] = lowpart_subreg (V4SFmode, operands[1], SFmode);\n   emit_move_insn (operands[0], CONST0_RTX (V2DFmode));\n })\n \n@@ -7703,14 +7698,13 @@\n   tmp0 = gen_reg_rtx (HImode);\n   tmp1 = gen_reg_rtx (HImode);\n \n-  /* Extend operands[1] to HImode.  Generate 8bit divide.  Result is\n-     in AX.  */\n+  /* Extend operands[1] to HImode.  Generate 8bit divide.  Result is in AX.  */\n   emit_insn (gen_zero_extendqihi2 (tmp1, operands[1]));\n   emit_insn (gen_udivmodhiqi3 (tmp0, tmp1, operands[2]));\n \n   /* Extract remainder from AH.  */\n   tmp1 = gen_rtx_ZERO_EXTRACT (SImode, tmp0, GEN_INT (8), GEN_INT (8));\n-  tmp1 = simplify_gen_subreg (QImode, tmp1, SImode, 0);\n+  tmp1 = lowpart_subreg (QImode, tmp1, SImode);\n   rtx_insn *insn = emit_move_insn (operands[3], tmp1);\n \n   mod = gen_rtx_UMOD (QImode, operands[1], operands[2]);\n@@ -9320,8 +9314,8 @@\n   machine_mode vmode = GET_MODE (operands[2]);\n   rtx tmp;\n \n-  operands[0] = simplify_gen_subreg (vmode, operands[0], mode, 0);\n-  operands[1] = simplify_gen_subreg (vmode, operands[1], mode, 0);\n+  operands[0] = lowpart_subreg (vmode, operands[0], mode);\n+  operands[1] = lowpart_subreg (vmode, operands[1], mode);\n   if (operands_match_p (operands[0], operands[2]))\n     std::swap (operands[1], operands[2]);\n   if (GET_CODE (operands[3]) == ABS)\n@@ -11240,7 +11234,7 @@\n \t\t      (label_ref (match_dup 3))\n \t\t      (pc)))]\n {\n-  operands[2] = simplify_gen_subreg (SImode, operands[2], QImode, 0);\n+  operands[2] = lowpart_subreg (SImode, operands[2], QImode);\n   operands[0] = shallow_copy_rtx (operands[0]);\n   PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));\n })"}]}