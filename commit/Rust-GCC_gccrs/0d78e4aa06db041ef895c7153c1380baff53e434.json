{"sha": "0d78e4aa06db041ef895c7153c1380baff53e434", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ3OGU0YWEwNmRiMDQxZWY4OTVjNzE1M2MxMzgwYmFmZjUzZTQzNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-04-14T18:14:58Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-04-14T18:14:58Z"}, "message": "re PR fortran/89843 (CFI_section delivers incorrect result descriptor)\n\n2019-04-14  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89843\n\t* trans-decl.c (gfc_get_symbol_decl): Assumed shape and assumed\n\trank dummies of bind C procs require deferred initialization.\n\t(convert_CFI_desc): New procedure to convert incoming CFI\n\tdescriptors to gfc types and back again.\n\t(gfc_trans_deferred_vars): Call it.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Null the CFI\n\tdescriptor pointer. Free the descriptor in all cases.\n\n\tPR fortran/89846\n\t* expr.c (is_CFI_desc): New function.\n\t(is_subref_array): Tidy up by referencing the symbol directly.\n\t* gfortran.h : Prototype for is_CFI_desc.\n\t* trans_array.c (get_CFI_desc): New function.\n\t(gfc_get_array_span, gfc_conv_scalarized_array_ref,\n\tgfc_conv_array_ref): Use it.\n\t* trans.c (get_array_span): Extract the span from descriptors\n\tthat are indirect references.\n\n\tPR fortran/90022\n\t* trans-decl.c (gfc_get_symbol_decl): Make sure that the se\n\texpression is a pointer type before converting it to the symbol\n\tbackend_decl type.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Eliminate\n\ttemporary creation for intent(in).\n\n2019-04-14  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89843\n\t* gfortran.dg/ISO_Fortran_binding_4.f90: Modify the value of x\n\tin ctg. Test the conversion of the descriptor types in the main\n\tprogram.\n\t* gfortran.dg/ISO_Fortran_binding_10.f90: New test.\n\t* gfortran.dg/ISO_Fortran_binding_10.c: Called by it.\n\n\tPR fortran/89846\n\t* gfortran.dg/ISO_Fortran_binding_11.f90: New test.\n\t* gfortran.dg/ISO_Fortran_binding_11.c: Called by it.\n\n\tPR fortran/90022\n\t* gfortran.dg/ISO_Fortran_binding_1.c: Correct the indexing for\n\tthe computation of 'ans'. Also, change the expected results for\n\tCFI_is_contiguous to comply with standard.\n\t* gfortran.dg/ISO_Fortran_binding_1.f90: Correct the expected\n\tresults for CFI_is_contiguous to comply with standard.\n\t* gfortran.dg/ISO_Fortran_binding_9.f90: New test.\n\t* gfortran.dg/ISO_Fortran_binding_9.c: Called by it.\n\n2019-04-14  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89843\n\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc): Only\n\treturn immediately if the source pointer is null. Bring\n\tforward the extraction of the gfc type. Extract the kind so\n\tthat the element size can be correctly computed for sections\n\tand components of derived type arrays. Remove the free of the\n\tCFI descriptor since this is now done in trans-expr.c.\n\t(gfc_desc_to_cfi_desc): Only allocate the CFI descriptor if it\n\tis not null.\n\t(CFI_section): Normalise the difference between the upper and\n\tlower bounds by the stride to correctly calculate the extents\n\tof the section.\n\n\tPR fortran/89846\n\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc): Use\n\tthe stride measure for the gfc span if it is not a multiple\n\tof the element length. Otherwise use the element length.\n\n\tPR fortran/90022\n\t* runtime/ISO_Fortran_binding.c (CFI_is_contiguous) : Return\n\t1 for true and 0 otherwise to comply with the standard. Correct\n\tthe contiguity check for rank 3 and greater by using the stride\n\tmeasure of the lower dimension rather than the element length.\n\nFrom-SVN: r270353", "tree": {"sha": "ff263942aea3fd3887c7ff230766d23b43e55cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff263942aea3fd3887c7ff230766d23b43e55cae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d78e4aa06db041ef895c7153c1380baff53e434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d78e4aa06db041ef895c7153c1380baff53e434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d78e4aa06db041ef895c7153c1380baff53e434", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d78e4aa06db041ef895c7153c1380baff53e434/comments", "author": null, "committer": null, "parents": [{"sha": "4d024c32696b98f3ca15505fbaa39600d7c118bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d024c32696b98f3ca15505fbaa39600d7c118bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d024c32696b98f3ca15505fbaa39600d7c118bb"}], "stats": {"total": 839, "additions": 680, "deletions": 159}, "files": [{"sha": "e27743cac2807ef3304fa47c8430a8cf1dc59a0f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -1,3 +1,31 @@\n+2019-04-14  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89843\n+\t* trans-decl.c (gfc_get_symbol_decl): Assumed shape and assumed\n+\trank dummies of bind C procs require deferred initialization.\n+\t(convert_CFI_desc): New procedure to convert incoming CFI\n+\tdescriptors to gfc types and back again.\n+\t(gfc_trans_deferred_vars): Call it.\n+\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Null the CFI\n+\tdescriptor pointer. Free the descriptor in all cases.\n+\n+\tPR fortran/89846\n+\t* expr.c (is_CFI_desc): New function.\n+\t(is_subref_array): Tidy up by referencing the symbol directly.\n+\t* gfortran.h : Prototype for is_CFI_desc.\n+\t* trans_array.c (get_CFI_desc): New function.\n+\t(gfc_get_array_span, gfc_conv_scalarized_array_ref,\n+\tgfc_conv_array_ref): Use it.\n+\t* trans.c (get_array_span): Extract the span from descriptors\n+\tthat are indirect references.\n+\n+\tPR fortran/90022\n+\t* trans-decl.c (gfc_get_symbol_decl): Make sure that the se\n+\texpression is a pointer type before converting it to the symbol\n+\tbackend_decl type.\n+\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Eliminate\n+\ttemporary creation for intent(in).\n+\n 2019-04-13  Dominique d'Humieres  <dominiq@gcc.gnu.org>\n \n \tPR fortran/79842"}, {"sha": "474e9ecc40136422a5354ddb1ef1c47c02e0398d", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -1061,18 +1061,42 @@ gfc_is_constant_expr (gfc_expr *e)\n }\n \n \n+/* Is true if the expression or symbol is a passed CFI descriptor.  */\n+bool\n+is_CFI_desc (gfc_symbol *sym, gfc_expr *e)\n+{\n+  if (sym == NULL\n+      && e && e->expr_type == EXPR_VARIABLE)\n+    sym = e->symtree->n.sym;\n+\n+  if (sym && sym->attr.dummy\n+      && sym->ns->proc_name->attr.is_bind_c\n+      && sym->attr.dimension\n+      && (sym->attr.pointer\n+\t  || sym->attr.allocatable\n+\t  || sym->as->type == AS_ASSUMED_SHAPE\n+\t  || sym->as->type == AS_ASSUMED_RANK))\n+    return true;\n+\n+return false;\n+}\n+\n+\n /* Is true if an array reference is followed by a component or substring\n    reference.  */\n bool\n is_subref_array (gfc_expr * e)\n {\n   gfc_ref * ref;\n   bool seen_array;\n+  gfc_symbol *sym;\n \n   if (e->expr_type != EXPR_VARIABLE)\n     return false;\n \n-  if (e->symtree->n.sym->attr.subref_array_pointer)\n+  sym = e->symtree->n.sym;\n+\n+  if (sym->attr.subref_array_pointer)\n     return true;\n \n   seen_array = false;\n@@ -1097,10 +1121,10 @@ is_subref_array (gfc_expr * e)\n \treturn seen_array;\n     }\n \n-  if (e->symtree->n.sym->ts.type == BT_CLASS\n-      && e->symtree->n.sym->attr.dummy\n-      && CLASS_DATA (e->symtree->n.sym)->attr.dimension\n-      && CLASS_DATA (e->symtree->n.sym)->attr.class_pointer)\n+  if (sym->ts.type == BT_CLASS\n+      && sym->attr.dummy\n+      && CLASS_DATA (sym)->attr.dimension\n+      && CLASS_DATA (sym)->attr.class_pointer)\n     return true;\n \n   return false;"}, {"sha": "23d01b10728086fcb367e86a5eb4cc9693851433", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -3221,6 +3221,7 @@ gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n bool gfc_extract_int (gfc_expr *, int *, int = 0);\n bool gfc_extract_hwi (gfc_expr *, HOST_WIDE_INT *, int = 0);\n \n+bool is_CFI_desc (gfc_symbol *, gfc_expr *);\n bool is_subref_array (gfc_expr *);\n bool gfc_is_simply_contiguous (gfc_expr *, bool, bool);\n bool gfc_is_not_contiguous (gfc_expr *);"}, {"sha": "55879af9730fb00df1b729c63a23ac3f71905c80", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -849,16 +849,56 @@ is_pointer_array (tree expr)\n }\n \n \n+/* If the symbol or expression reference a CFI descriptor, return the\n+   pointer to the converted gfc descriptor. If an array reference is\n+   present as the last argument, check that it is the one applied to\n+   the CFI descriptor in the expression. Note that the CFI object is\n+   always the symbol in the expression!  */\n+\n+static bool\n+get_CFI_desc (gfc_symbol *sym, gfc_expr *expr,\n+\t      tree *desc, gfc_array_ref *ar)\n+{\n+  tree tmp;\n+\n+  if (!is_CFI_desc (sym, expr))\n+    return false;\n+\n+  if (expr && ar)\n+    {\n+      if (!(expr->ref && expr->ref->type == REF_ARRAY)\n+\t  || (&expr->ref->u.ar != ar))\n+\treturn false;\n+    }\n+\n+  if (sym == NULL)\n+    tmp = expr->symtree->n.sym->backend_decl;\n+  else\n+    tmp = sym->backend_decl;\n+\n+  if (tmp && DECL_LANG_SPECIFIC (tmp))\n+    tmp = GFC_DECL_SAVED_DESCRIPTOR (tmp);\n+\n+  *desc = tmp;\n+  return true;\n+}\n+\n+\n /* Return the span of an array.  */\n \n tree\n gfc_get_array_span (tree desc, gfc_expr *expr)\n {\n   tree tmp;\n \n-  if (is_pointer_array (desc))\n-    /* This will have the span field set.  */\n-    tmp = gfc_conv_descriptor_span_get (desc);\n+  if (is_pointer_array (desc) || get_CFI_desc (NULL, expr, &desc, NULL))\n+    {\n+      if (POINTER_TYPE_P (TREE_TYPE (desc)))\n+\tdesc = build_fold_indirect_ref_loc (input_location, desc);\n+\n+      /* This will have the span field set.  */\n+      tmp = gfc_conv_descriptor_span_get (desc);\n+    }\n   else if (TREE_CODE (desc) == COMPONENT_REF\n \t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n \t   && GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (desc, 0))))\n@@ -3466,6 +3506,12 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   if (build_class_array_ref (se, base, index))\n     return;\n \n+  if (get_CFI_desc (NULL, expr, &decl, ar))\n+    {\n+      decl = build_fold_indirect_ref_loc (input_location, decl);\n+      goto done;\n+    }\n+\n   if (expr && ((is_subref_array (expr)\n \t\t&& GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (info->descriptor)))\n \t       || (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE\n@@ -3721,6 +3767,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n   /* A pointer array component can be detected from its field decl. Fix\n      the descriptor, mark the resulting variable decl and pass it to\n      build_array_ref.  */\n+  if (get_CFI_desc (sym, expr, &decl, ar))\n+    decl = build_fold_indirect_ref_loc (input_location, decl);\n   if (!expr->ts.deferred && !sym->attr.codimension\n       && is_pointer_array (se->expr))\n     {"}, {"sha": "a0e1f6aeea564b8d1878a0bbc41ac6732286c617", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -4268,6 +4268,72 @@ gfc_null_and_pass_deferred_len (gfc_symbol *sym, stmtblock_t *init,\n }\n \n \n+/* Convert CFI descriptor dummies into gfc types and back again.  */\n+static void\n+convert_CFI_desc (gfc_wrapped_block * block, gfc_symbol *sym)\n+{\n+  tree gfc_desc;\n+  tree gfc_desc_ptr;\n+  tree CFI_desc;\n+  tree CFI_desc_ptr;\n+  tree dummy_ptr;\n+  tree tmp;\n+  tree incoming;\n+  tree outgoing;\n+  stmtblock_t tmpblock;\n+\n+  /* dummy_ptr will be the pointer to the passed array descriptor,\n+     while CFI_desc is the descriptor itself.  */\n+  if (DECL_LANG_SPECIFIC (sym->backend_decl))\n+    CFI_desc = GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl);\n+  else\n+    CFI_desc = NULL;\n+\n+  dummy_ptr = CFI_desc;\n+\n+  if (CFI_desc)\n+    {\n+      CFI_desc = build_fold_indirect_ref_loc (input_location, CFI_desc);\n+\n+      /* The compiler will have given CFI_desc the correct gfortran\n+\t type. Use this new variable to store the converted\n+\t descriptor.  */\n+      gfc_desc = gfc_create_var (TREE_TYPE (CFI_desc), \"gfc_desc\");\n+      tmp = build_pointer_type (TREE_TYPE (gfc_desc));\n+      gfc_desc_ptr = gfc_create_var (tmp, \"gfc_desc_ptr\");\n+      CFI_desc_ptr = gfc_create_var (pvoid_type_node, \"CFI_desc_ptr\");\n+\n+      gfc_init_block (&tmpblock);\n+      /* Pointer to the gfc descriptor.  */\n+      gfc_add_modify (&tmpblock, gfc_desc_ptr,\n+\t\t      gfc_build_addr_expr (NULL, gfc_desc));\n+      /* Store the pointer to the CFI descriptor.  */\n+      gfc_add_modify (&tmpblock, CFI_desc_ptr,\n+\t\t      fold_convert (pvoid_type_node, dummy_ptr));\n+      tmp = gfc_build_addr_expr (ppvoid_type_node, CFI_desc_ptr);\n+      /* Convert the CFI descriptor.  */\n+      incoming = build_call_expr_loc (input_location,\n+\t\t\tgfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);\n+      gfc_add_expr_to_block (&tmpblock, incoming);\n+      /* Set the dummy pointer to point to the gfc_descriptor.  */\n+      gfc_add_modify (&tmpblock, dummy_ptr,\n+\t\t      fold_convert (TREE_TYPE (dummy_ptr), gfc_desc_ptr));\n+      incoming = gfc_finish_block (&tmpblock);\n+\n+      gfc_init_block (&tmpblock);\n+      /* Convert the gfc descriptor back to the CFI type before going\n+\t out of scope.  */\n+      tmp = gfc_build_addr_expr (ppvoid_type_node, CFI_desc_ptr);\n+      outgoing = build_call_expr_loc (input_location,\n+\t\t\tgfor_fndecl_gfc_to_cfi, 2, tmp, gfc_desc_ptr);\n+      gfc_add_expr_to_block (&tmpblock, outgoing);\n+      outgoing = gfc_finish_block (&tmpblock);\n+\n+      /* Add the lot to the procedure init and finally blocks.  */\n+      gfc_add_init_cleanup (block, incoming, outgoing);\n+    }\n+}\n+\n /* Get the result expression for a procedure.  */\n \n static tree\n@@ -4844,6 +4910,13 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t}\n       else if (!(UNLIMITED_POLY(sym)) && !is_pdt_type)\n \tgcc_unreachable ();\n+\n+      /* Assumed shape and assumed rank arrays are passed to BIND(C) procedures\n+\t as ISO Fortran Interop descriptors. These have to be converted to\n+\t gfortran descriptors and back again.  This has to be done here so that\n+\t the conversion occurs at the start of the init block.  */\n+      if (is_CFI_desc (sym, NULL))\n+\tconvert_CFI_desc (block, sym);\n     }\n \n   gfc_init_block (&tmpblock);"}, {"sha": "21535acb989c8a32c2ab69891c4f5c628e148d87", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 18, "deletions": 77, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -4987,11 +4987,11 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   tree tmp;\n   tree cfi_desc_ptr;\n   tree gfc_desc_ptr;\n-  tree ptr = NULL_TREE;\n-  tree size;\n   tree type;\n+  tree cond;\n   int attribute;\n   symbol_attribute attr = gfc_expr_attr (e);\n+  stmtblock_t block;\n \n   /* If this is a full array or a scalar, the allocatable and pointer\n      attributes can be passed. Otherwise it is 'CFI_attribute_other'*/\n@@ -5056,37 +5056,6 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \t  tmp = fold_convert (gfc_array_index_type, tmp);\n \t  gfc_conv_descriptor_span_set (&parmse->pre, parmse->expr, tmp);\n \t}\n-\n-      /* INTENT(IN) requires a temporary for the data. Assumed types do not\n-\t work with the standard temporary generation schemes. */\n-      if (e->expr_type == EXPR_VARIABLE && fsym->attr.intent == INTENT_IN)\n-\t{\n-\t  /* Fix the descriptor and determine the size of the data.  */\n-\t  parmse->expr = gfc_evaluate_now (parmse->expr, &parmse->pre);\n-\t  size = build_call_expr_loc (input_location,\n-\t\t\t\tgfor_fndecl_size0, 1,\n-\t\t\t\tgfc_build_addr_expr (NULL, parmse->expr));\n-\t  size = fold_convert (size_type_node, size);\n-\t  tmp = gfc_conv_descriptor_span_get (parmse->expr);\n-\t  tmp = fold_convert (size_type_node, tmp);\n-\t  size = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t  size_type_node, size, tmp);\n-\t  /* Fix the size and allocate.  */\n-\t  size = gfc_evaluate_now (size, &parmse->pre);\n-\t  tmp = builtin_decl_explicit (BUILT_IN_MALLOC);\n-\t  ptr = build_call_expr_loc (input_location, tmp, 1, size);\n-\t  ptr = gfc_evaluate_now (ptr, &parmse->pre);\n-\t  /* Copy the data to the temporary descriptor.  */\n-\t  tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n-\t  tmp = build_call_expr_loc (input_location, tmp, 3, ptr,\n-\t\t\t\tgfc_conv_descriptor_data_get (parmse->expr),\n-\t\t\t\tsize);\n-\t  gfc_add_expr_to_block (&parmse->pre, tmp);\n-\n-\t  /* The temporary 'ptr' is freed below.  */\n-\t  gfc_conv_descriptor_data_set (&parmse->pre, parmse->expr, ptr);\n-\t}\n-\n     }\n   else\n     {\n@@ -5096,28 +5065,6 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \tparmse->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t    parmse->expr);\n \n-      /* Copy the scalar for INTENT(IN).  */\n-      if (e->expr_type == EXPR_VARIABLE && fsym->attr.intent == INTENT_IN)\n-\t{\n-\t  if (e->ts.type != BT_CHARACTER)\n-\t    parmse->expr = gfc_evaluate_now (parmse->expr, &parmse->pre);\n-\t  else\n-\t    {\n-\t      /* The temporary string 'ptr' is freed below.  */\n-\t      tmp = build_pointer_type (TREE_TYPE (parmse->expr));\n-\t      ptr = gfc_create_var (tmp, \"str\");\n-\t      tmp = build_call_expr_loc (input_location,\n-\t\t\t\t builtin_decl_explicit (BUILT_IN_MALLOC),\n-\t\t\t\t 1, parmse->string_length);\n-\t      tmp = fold_convert (TREE_TYPE (ptr), tmp);\n-\t      gfc_add_modify (&parmse->pre, ptr, tmp);\n-\t      tmp = gfc_build_memcpy_call (ptr, parmse->expr,\n-\t\t\t\t\t   parmse->string_length);\n-\t      gfc_add_expr_to_block (&parmse->pre, tmp);\n-\t      parmse->expr = ptr;\n-\t    }\n-\t}\n-\n       parmse->expr = gfc_conv_scalar_to_descriptor (parmse,\n \t\t\t\t\t\t    parmse->expr, attr);\n     }\n@@ -5135,6 +5082,8 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   /* Variables to point to the gfc and CFI descriptors.  */\n   gfc_desc_ptr = parmse->expr;\n   cfi_desc_ptr = gfc_create_var (pvoid_type_node, \"cfi\");\n+  gfc_add_modify (&parmse->pre, cfi_desc_ptr,\n+\t\t  build_int_cst (pvoid_type_node, 0));\n \n   /* Allocate the CFI descriptor and fill the fields.  */\n   tmp = gfc_build_addr_expr (NULL_TREE, cfi_desc_ptr);\n@@ -5145,18 +5094,19 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   /* The CFI descriptor is passed to the bind_C procedure.  */\n   parmse->expr = cfi_desc_ptr;\n \n-  if (ptr)\n-    {\n-      /* Free both the temporary data and the CFI descriptor for\n-\t INTENT(IN) arrays.  */\n-      tmp = gfc_call_free (ptr);\n-      gfc_prepend_expr_to_block (&parmse->post, tmp);\n-      tmp = gfc_call_free (cfi_desc_ptr);\n-      gfc_prepend_expr_to_block (&parmse->post, tmp);\n-      return;\n-    }\n+  /* Free the CFI descriptor.  */\n+  gfc_init_block (&block);\n+  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t  logical_type_node, cfi_desc_ptr,\n+\t\t\t  build_int_cst (TREE_TYPE (cfi_desc_ptr), 0));\n+  tmp = gfc_call_free (cfi_desc_ptr);\n+  gfc_add_expr_to_block (&block, tmp);\n+  tmp = build3_v (COND_EXPR, cond,\n+\t\t  gfc_finish_block (&block),\n+\t\t  build_empty_stmt (input_location));\n+  gfc_prepend_expr_to_block (&parmse->post, tmp);\n \n-  /* Transfer values back to gfc descriptor and free the CFI descriptor.  */\n+  /* Transfer values back to gfc descriptor.  */\n   tmp = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n   tmp = build_call_expr_loc (input_location,\n \t\t\t     gfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);\n@@ -5516,11 +5466,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t}\n \n \t      else if (sym->attr.is_bind_c && e\n-\t\t       && ((fsym && fsym->attr.dimension\n-\t\t\t    && (fsym->attr.pointer\n-\t\t\t\t|| fsym->attr.allocatable\n-\t\t\t\t|| fsym->as->type == AS_ASSUMED_RANK\n-\t\t\t\t|| fsym->as->type == AS_ASSUMED_SHAPE))\n+\t\t       && (is_CFI_desc (fsym, NULL)\n \t\t\t   || non_unity_length_string))\n \t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n@@ -5965,12 +5911,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t}\n \n \t      if (sym->attr.is_bind_c && e\n-\t\t  && fsym && fsym->attr.dimension\n-\t\t  && (fsym->attr.pointer\n-\t\t      || fsym->attr.allocatable\n-\t\t      || fsym->as->type == AS_ASSUMED_RANK\n-\t\t      || fsym->as->type == AS_ASSUMED_SHAPE\n-\t\t      || non_unity_length_string))\n+\t\t  && (is_CFI_desc (fsym, NULL) || non_unity_length_string))\n \t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n "}, {"sha": "022ceb9e197a1250edb0d7f36a8196ba859fcdec", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -352,6 +352,9 @@ get_array_span (tree type, tree decl)\n       else\n \tspan = NULL_TREE;\n     }\n+  else if (TREE_CODE (decl) == INDIRECT_REF\n+\t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+    span = gfc_conv_descriptor_span_get (decl);\n   else\n     span = NULL_TREE;\n "}, {"sha": "4ede1de27cf5b9fce5e2c3de2d5e8bf6b8ee5c5d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -1,3 +1,25 @@\n+2019-04-14  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89843\n+\t* gfortran.dg/ISO_Fortran_binding_4.f90: Modify the value of x\n+\tin ctg. Test the conversion of the descriptor types in the main\n+\tprogram.\n+\t* gfortran.dg/ISO_Fortran_binding_10.f90: New test.\n+\t* gfortran.dg/ISO_Fortran_binding_10.c: Called by it.\n+\n+\tPR fortran/89846\n+\t* gfortran.dg/ISO_Fortran_binding_11.f90: New test.\n+\t* gfortran.dg/ISO_Fortran_binding_11.c: Called by it.\n+\n+\tPR fortran/90022\n+\t* gfortran.dg/ISO_Fortran_binding_1.c: Correct the indexing for\n+\tthe computation of 'ans'. Also, change the expected results for\n+\tCFI_is_contiguous to comply with standard.\n+\t* gfortran.dg/ISO_Fortran_binding_1.f90: Correct the expected\n+\tresults for CFI_is_contiguous to comply with standard.\n+\t* gfortran.dg/ISO_Fortran_binding_9.f90: New test.\n+\t* gfortran.dg/ISO_Fortran_binding_9.c: Called by it.\n+\n 2019-04-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/89093"}, {"sha": "a6353c7cca6e7d8e2d754bb8e6a8ca8c049b2126", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -105,7 +105,7 @@ float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n   CFI_index_t idx[CFI_MAX_RANK], lower[CFI_MAX_RANK],\n \t\t  strides[CFI_MAX_RANK], upper[CFI_MAX_RANK];\n   CFI_CDESC_T(1) section;\n-  int ind, size;\n+  int ind;\n   float *ret_addr;\n   float ans = 0.0;\n \n@@ -121,9 +121,7 @@ float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n       if (ind) return -2.0;\n \n       /* Sum over the section  */\n-      size = (section.dim[0].extent - 1)\n-\t\t* section.elem_len/section.dim[0].sm + 1;\n-      for (idx[0] = 0; idx[0] < size; idx[0]++)\n+      for (idx[0] = 0; idx[0] < section.dim[0].extent; idx[0]++)\n         ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);\n       return ans;\n     }\n@@ -143,9 +141,7 @@ float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n       if (ind) return -2.0;\n \n       /* Sum over the section  */\n-      size = (section.dim[0].extent - 1)\n-\t\t* section.elem_len/section.dim[0].sm + 1;\n-      for (idx[0] = 0; idx[0] < size; idx[0]++)\n+      for (idx[0] = 0; idx[0] < section.dim[0].extent; idx[0]++)\n         ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);\n       return ans;\n     }\n@@ -191,15 +187,15 @@ int setpointer_c(CFI_cdesc_t * ptr, int lbounds[])\n \n int assumed_size_c(CFI_cdesc_t * desc)\n {\n-  int ierr;\n+  int res;\n \n-  ierr = CFI_is_contiguous(desc);\n-  if (ierr)\n+  res = CFI_is_contiguous(desc);\n+  if (!res)\n     return 1;\n   if (desc->rank)\n-    ierr = 2 * (desc->dim[desc->rank-1].extent\n+    res = 2 * (desc->dim[desc->rank-1].extent\n \t\t\t\t!= (CFI_index_t)(long long)(-1));\n   else\n-    ierr = 3;\n-  return ierr;\n+    res = 3;\n+  return res;\n }"}, {"sha": "102bc60310c1394d6b9f9b19b28f322f4a71d89a", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.f90", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -170,16 +170,16 @@ subroutine test_CFI_contiguous (arg)\n     integer, dimension (2,*) :: arg\n     character(4), dimension(2) :: chr\n ! These are contiguous\n-    if (c_contiguous (arg) .ne. 0) stop 20\n+    if (c_contiguous (arg) .ne. 1) stop 20\n     if (.not.allocated (x)) allocate (x(2, 2))\n-    if (c_contiguous (x) .ne. 0) stop 22\n+    if (c_contiguous (x) .ne. 1) stop 22\n     deallocate (x)\n-    if (c_contiguous (chr) .ne. 0) stop 23\n+    if (c_contiguous (chr) .ne. 1) stop 23\n ! These are not contiguous\n-    if (c_contiguous (der%i) .eq. 0) stop 24\n-    if (c_contiguous (arg(1:1,1:2)) .eq. 0) stop 25\n-    if (c_contiguous (d(4:2:-2, 1:3:2)) .eq. 0) stop 26\n-    if (c_contiguous (chr(:)(2:3)) .eq. 0) stop 27\n+    if (c_contiguous (der%i) .eq. 1) stop 24\n+    if (c_contiguous (arg(1:1,1:2)) .eq. 1) stop 25\n+    if (c_contiguous (d(4:2:-2, 1:3:2)) .eq. 1) stop 26\n+    if (c_contiguous (chr(:)(2:3)) .eq. 1) stop 27\n   end subroutine test_CFI_contiguous\n \n   subroutine test_CFI_section (arg)"}, {"sha": "adda3b3c18a7750c0e7a2f441c50e9d347e58f51", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_10.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_10.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -0,0 +1,73 @@\n+/* Test the fix of PR89843.  */\n+\n+/* Contributed by Reinhold Bader  <Bader@lrz.de> */\n+\n+#include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <stdbool.h>\n+\n+void sa(CFI_cdesc_t *, int, int *);\n+\n+void si(CFI_cdesc_t *this, int flag, int *status)\n+{\n+  int value, sum;\n+  bool err;\n+  CFI_CDESC_T(1) that;\n+  CFI_index_t lb[] = { 0, 0 };\n+  CFI_index_t ub[] = { 4, 1 };\n+  CFI_index_t st[] = { 2, 0 };\n+  int chksum[] = { 9, 36, 38 };\n+\n+  if (flag == 1)\n+    {\n+      lb[0] = 0; lb[1] = 2;\n+      ub[0] = 2; ub[1] = 2;\n+      st[0] = 1; st[1] = 0;\n+    }\n+  else if (flag == 2)\n+    {\n+      lb[0] = 1; lb[1] = 0;\n+      ub[0] = 1; ub[1] = 3;\n+      st[0] = 0; st[1] = 1;\n+    }\n+\n+  CFI_establish((CFI_cdesc_t *) &that, NULL, CFI_attribute_other,\n+\t\tCFI_type_float, 0, 1, NULL);\n+\n+  *status = CFI_section((CFI_cdesc_t *) &that, this, lb, ub, st);\n+\n+  if (*status != CFI_SUCCESS)\n+    {\n+      printf(\"FAIL C: status is %i\\n\",status);\n+      return;\n+    }\n+\n+  value = CFI_is_contiguous((CFI_cdesc_t *) &that);\n+  err = ((flag == 0 && value != 0)\n+\t || (flag == 1 && value != 1)\n+\t || (flag == 2 && value != 0));\n+\n+  if (err)\n+    {\n+      printf(\"FAIL C: contiguity for flag value %i - is %i\\n\",flag, value);\n+      *status = 10;\n+      return;\n+    }\n+\n+  sum = 0;\n+  for (int i = 0; i < that.dim[0].extent; i++)\n+    {\n+      CFI_index_t idx[] = {i};\n+      sum += (int)(*(float *)CFI_address ((CFI_cdesc_t *)&that, idx));\n+    }\n+\n+  if (sum != chksum[flag])\n+    {\n+      printf (\"FAIL C: check sum = %d(%d)\\n\", sum, chksum[flag]);\n+      *status = 11;\n+      return;\n+    }\n+\n+    sa((CFI_cdesc_t *) &that, flag, status);\n+}"}, {"sha": "602d8f782170333a9a2f126a29a7bbcaf13c8212", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_10.f90", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_10.f90?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -0,0 +1,99 @@\n+! { dg-do run { target c99_runtime } }\n+! { dg-additional-sources ISO_Fortran_binding_10.c }\n+!\n+! Test the fix of PR89843.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_section_01\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  interface\n+     subroutine si(this, flag, status) bind(c)\n+       import :: c_float, c_int\n+       real(c_float) :: this(:,:)\n+       integer(c_int), value :: flag\n+       integer(c_int) :: status\n+     end subroutine si\n+  end interface\n+contains\n+  subroutine sa(this, flag, status) bind(c)\n+    real(c_float) :: this(:)\n+    integer(c_int), value :: flag\n+    integer(c_int) :: status\n+\n+    status = 0\n+\n+    select case (flag)\n+    case (0)\n+       if (is_contiguous(this)) then\n+          write(*,*) 'FAIL 1:'\n+          status = status + 1\n+       end if\n+       if (size(this,1) /= 3) then\n+          write(*,*) 'FAIL 2:',size(this)\n+          status = status + 1\n+          goto 10\n+       end if\n+       if (maxval(abs(this - [ 1.0, 3.0, 5.0 ])) > 1.0e-6) then\n+          write(*,*) 'FAIL 3:',abs(this)\n+          status = status + 1\n+       end if\n+  10   continue\n+   case (1)\n+      if (size(this,1) /= 3) then\n+          write(*,*) 'FAIL 4:',size(this)\n+          status = status + 1\n+          goto 20\n+       end if\n+       if (maxval(abs(this - [ 11.0, 12.0, 13.0 ])) > 1.0e-6) then\n+          write(*,*) 'FAIL 5:',this\n+          status = status + 1\n+       end if\n+  20   continue\n+   case (2)\n+      if (size(this,1) /= 4) then\n+          write(*,*) 'FAIL 6:',size(this)\n+          status = status + 1\n+          goto 30\n+       end if\n+      if (maxval(abs(this - [ 2.0, 7.0, 12.0, 17.0 ])) > 1.0e-6) then\n+          write(*,*) 'FAIL 7:',this\n+          status = status + 1\n+       end if\n+  30   continue\n+    end select\n+\n+!    if (status == 0) then\n+!       write(*,*) 'OK'\n+!    end if\n+  end subroutine sa\n+end module mod_section_01\n+\n+program section_01\n+  use mod_section_01\n+  implicit none\n+  real(c_float) :: v(5,4)\n+  integer :: i\n+  integer :: status\n+\n+  v = reshape( [ (real(i), i = 1, 20) ], [ 5, 4 ] )\n+  call si(v, 0, status)\n+  if (status .ne. 0) stop 1\n+\n+  call sa(v(1:5:2, 1), 0, status)\n+  if (status .ne. 0) stop 2\n+\n+  call si(v, 1, status)\n+  if (status .ne. 0) stop 3\n+\n+  call sa(v(1:3, 3), 1, status)\n+  if (status .ne. 0) stop 4\n+\n+  call si(v, 2, status)\n+  if (status .ne. 0) stop 5\n+\n+  call sa(v(2,1:4), 2, status)\n+  if (status .ne. 0) stop 6\n+\n+end program section_01"}, {"sha": "ac176901bf271ce7ac004a39c7cc1771e2284a6d", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_11.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_11.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -0,0 +1,78 @@\n+/* Test the fix of PR89846.\n+\n+Contributed by Reinhold Bader  <Bader@lrz.de>#include <stdio.h> */\n+\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+#include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+\n+typedef struct\n+{\n+  char n;\n+  float r[2];\n+} t1;\n+\n+typedef struct\n+{\n+  long int i;\n+  t1 t1;\n+} t2;\n+\n+\n+\n+void ta0(CFI_cdesc_t *);\n+void ta1(CFI_cdesc_t *);\n+\n+void ti(CFI_cdesc_t *this, int flag)\n+{\n+  int status;\n+  size_t dis;\n+  CFI_CDESC_T(1) that;\n+  t1 *ans;\n+\n+  switch (flag)\n+    {\n+    case 0:\n+      dis = offsetof(t2, t1);\n+      status = CFI_establish((CFI_cdesc_t *) &that, NULL, CFI_attribute_other,\n+\t\t\t     CFI_type_struct, sizeof(t1), 1, NULL);\n+      if (status != CFI_SUCCESS)\n+\t{\n+\t  printf(\"FAIL 1 establish: nonzero status %i\\n\",status);\n+          exit(1);\n+\t}\n+      status = CFI_select_part((CFI_cdesc_t *) &that, this, dis, 0);\n+      if (status != CFI_SUCCESS)\n+\t{\n+\t  printf(\"FAIL C1: nonzero status %i\\n\",status);\n+\t  exit(1);\n+\t}\n+     break;\n+\n+    case 1:\n+      dis = offsetof(t2, i);\n+      status = CFI_establish((CFI_cdesc_t *) &that, NULL, CFI_attribute_other,\n+\t\t\t     CFI_type_long, 0, 1, NULL);\n+      if (status != CFI_SUCCESS)\n+\t{\n+\t  printf(\"FAIL 2 establish: nonzero status %i\\n\",status);\n+\t  exit(1);\n+\t}\n+      status = CFI_select_part((CFI_cdesc_t *) &that, this, dis, 0);\n+      if (status != CFI_SUCCESS)\n+\t{\n+\t  printf(\"FAIL C2: nonzero status %i\\n\",status);\n+\t  exit(1);\n+\t}\n+    }\n+\n+  if (CFI_is_contiguous((CFI_cdesc_t *) &that))\n+    {\n+      printf(\"FAIL C: contiguity for flag value %i - is %i\\n\",flag,\n+\t     CFI_is_contiguous((CFI_cdesc_t *) &that));\n+    }\n+\n+  if (flag == 0) ta0((CFI_cdesc_t *) &that);\n+  if (flag == 1) ta1((CFI_cdesc_t *) &that);\n+}"}, {"sha": "e509425d9d2309a85eea1cd08acd1d45dbbdca62", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_11.f90", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_11.f90?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -0,0 +1,81 @@\n+! { dg-do run { target c99_runtime } }\n+! { dg-additional-sources ISO_Fortran_binding_11.c }\n+!\n+! Test the fix of PR89846.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_subobj_01\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  integer, parameter :: nelem = 5\n+  type, bind(c) :: t1\n+     character(c_char) :: n\n+     real(c_float) :: r(2)\n+  end type t1\n+  type, bind(c) :: t2\n+     integer(c_long) :: i\n+     type(t1) :: t1\n+  end type t2\n+  interface\n+     subroutine ti(this, flag) bind(c)\n+       import :: t2, c_int\n+       type(t2) :: this(:)\n+       integer(c_int), value :: flag\n+     end subroutine ti\n+  end interface\n+contains\n+  subroutine ta0(this) bind(c)\n+    type(t1) :: this(:)\n+    integer :: i, iw, status\n+    status = 0\n+    if (size(this) /= nelem) then\n+       write(*,*) 'FAIL 1: ',size(this)\n+       status = status + 1\n+    end if\n+    iw = 0\n+    do i=1, nelem\n+       if (this(i)%n /= char(i,c_char) .or. this(i)%r(1) /= real(i,c_float) .or. &\n+            this(i)%r(2) /= real(i+1,c_float)) then\n+          iw = iw + 1\n+       end if\n+    end do\n+    if (iw > 0) then\n+       write(*,*) 'FAIL 2: ' ,this\n+       status = status + 1\n+    end if\n+    if (status /= 0) stop 1\n+  end subroutine ta0\n+  subroutine ta1(this) bind(c)\n+    integer(c_long) :: this(:)\n+    integer :: i, status\n+    status = 0\n+    if (size(this) /= nelem) then\n+       write(*,*) 'FAIL 3: ',size(this)\n+       status = status + 1\n+    end if\n+    if (maxval(abs(this - [ (int(i,c_long),i=1,nelem) ])) > 0) then\n+       write(*,*) 'FAIL 4: ' ,this\n+       status = status + 1\n+    end if\n+    if (status /= 0) stop 2\n+  end subroutine ta1\n+end module mod_subobj_01\n+program subobj_01\n+  use mod_subobj_01\n+  implicit none\n+  integer :: i\n+\n+  type(t2), allocatable :: o_t2(:)\n+\n+  allocate(o_t2(nelem))\n+  do i=1, nelem\n+     o_t2(i)%t1 = t1( char(i,c_char), [ real(i,c_float), real(i+1,c_float) ] )\n+     o_t2(i)%i = int(i,c_long)\n+  end do\n+\n+  call ti(o_t2,0)\n+  call ti(o_t2,1)\n+\n+end program subobj_01\n+"}, {"sha": "20a1e19a1d3cef34592e77233a23c41d74ac599a", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_3.f90", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.f90?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -7,35 +7,14 @@\n   integer, dimension(2,2) :: src = reshape ([1,2,3,4], [2,2])\n \n   allocate (actual, source = src)\n-  ier = test1 (actual)\n-  if (ier .ne. 0) stop 1\n-! C call is INTENT(IN). 'c_test' increments elements of 'src'.\n-  if (any (actual .ne. src)) stop 2\n \n-  ier = test2 (actual)\n+  ier = test1 (actual)\n   if (ier .ne. 0) stop 1\n-! C call is INTENT(INOUT) 'c_test' increments elements of 'src'.\n   if (any (actual .ne. src + 1)) stop 2\n \n contains\n \n   function test1 (arg) RESULT(err)\n-    USE, INTRINSIC :: ISO_C_BINDING\n-    INTEGER(C_INT) :: err\n-    type(*), dimension(..), intent(inOUT) :: arg\n-    interface\n-      function test_c (a) BIND(C, NAME=\"c_test\") RESULT(err)\n-          USE, INTRINSIC :: ISO_C_BINDING\n-          type(*), dimension(..), intent(in) :: a\n-          INTEGER(C_INT) :: err\n-      end function\n-    end interface\n-\n-    err = test_c (arg) ! This used to ICE\n-\n-  end function test1\n-\n-  function test2 (arg) RESULT(err)\n     USE, INTRINSIC :: ISO_C_BINDING\n     INTEGER(C_INT) :: err\n     type(*), dimension(..), intent(inout) :: arg\n@@ -49,5 +28,5 @@ function test_c (a) BIND(C, NAME=\"c_test\") RESULT(err)\n \n     err = test_c (arg) ! This used to ICE\n \n-  end function test2\n+  end function test1\n end"}, {"sha": "09410b71601a2acdcab1fc73b1a506584cc848fe", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_4.f90", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -10,9 +10,11 @@ subroutine ctg(x) BIND(C)\n \n     if (any(abs(x - [2.,4.,6.]) > 1.e-6)) then\n        write(*,*) 'FAIL'\n+       stop 1\n     else\n        write(*,*) 'OK'\n     end if\n+    x = [2.,4.,6.]*10.0\n   end subroutine\n end module\n program p\n@@ -23,5 +25,5 @@ program p\n \n   x = [ (real(i), i=1, size(x)) ]\n   call ctg(x(2::2))\n-\n+  if (any (abs (x - [1.,20.,3.,40.,5.,60.]) > 1.e-6)) stop 2\n end program"}, {"sha": "cb5b91dc79b42a84f4e5141b8d4036dba9198264", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_9.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_9.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -0,0 +1,14 @@\n+/* Test fix of a problem with CFI_is_contiguous.  */\n+\n+/* Contributed by Gilles Gouaillardet  <gilles@rist.or.jp> */\n+\n+#include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+#include <stdlib.h>\n+\n+int cdesc_c(CFI_cdesc_t* x, long *expected)\n+{\n+  int res;\n+  res = CFI_is_contiguous (x);\n+  if (x->base_addr != (void *)*expected) res = 0;\n+  return res;\n+}\n\\ No newline at end of file"}, {"sha": "def51165d5f1d7a3a96a36b531840f14d872081c", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_9.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_9.f90?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run { target c99_runtime } }\n+! { dg-additional-sources ISO_Fortran_binding_9.c }\n+!\n+! Fix a problem with CFI_is_contiguous\n+!\n+! Contributed by Gilles Gouaillardet  <gilles@rist.or.jp>\n+!\n+module cdesc\n+  interface\n+  function cdesc_f08(buf, expected) result (res) BIND(C, name=\"cdesc_c\")\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      implicit none\n+      INTEGER(C_INT) :: res\n+      type(*), dimension(..), INTENT(IN) :: buf\n+      integer(kind=kind(loc(res))),INTENT(IN) :: expected\n+    end function cdesc_f08\n+  end interface\n+end module\n+\n+program cdesc_test\n+  use cdesc\n+  implicit none\n+  integer :: a0, a1(10), a2(10,10), a3(10,10,10)\n+  if (cdesc_f08(a0, LOC(a0)) .ne. 1) stop 1\n+  if (cdesc_f08(a1, LOC(a1(1))) .ne. 1) stop 2\n+  if (cdesc_f08(a2, LOC(a2(1,1))) .ne. 1) stop 3\n+  if (cdesc_f08(a3, LOC(a3(1,1,1))) .ne. 1) stop 4\n+end program"}, {"sha": "80a37fb28ebfcae1e1dcd5f94b3d4d879355f257", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -1,3 +1,29 @@\n+2019-04-14  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89843\n+\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc): Only\n+\treturn immediately if the source pointer is null. Bring\n+\tforward the extraction of the gfc type. Extract the kind so\n+\tthat the element size can be correctly computed for sections\n+\tand components of derived type arrays. Remove the free of the\n+\tCFI descriptor since this is now done in trans-expr.c.\n+\t(gfc_desc_to_cfi_desc): Only allocate the CFI descriptor if it\n+\tis not null.\n+\t(CFI_section): Normalise the difference between the upper and\n+\tlower bounds by the stride to correctly calculate the extents\n+\tof the section.\n+\n+\tPR fortran/89846\n+\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc): Use\n+\tthe stride measure for the gfc span if it is not a multiple\n+\tof the element length. Otherwise use the element length.\n+\n+\tPR fortran/90022\n+\t* runtime/ISO_Fortran_binding.c (CFI_is_contiguous) : Return\n+\t1 for true and 0 otherwise to comply with the standard. Correct\n+\tthe contiguity check for rank 3 and greater by using the stride\n+\tmeasure of the lower dimension rather than the element length.\n+\n 2019-03-25  John David Anglin  <danglin@gcc.gnu.org>\n \n \tPR libgfortran/79540"}, {"sha": "695ef57ac32977455ff2980c5cbe139b14d64f45", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d78e4aa06db041ef895c7153c1380baff53e434/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d78e4aa06db041ef895c7153c1380baff53e434/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=0d78e4aa06db041ef895c7153c1380baff53e434", "patch": "@@ -37,36 +37,42 @@ void\n cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n {\n   int n;\n+  index_type kind;\n   CFI_cdesc_t *s = *s_ptr;\n \n-  /* If not a full pointer or allocatable array free the descriptor\n-     and return.  */\n-  if (!s || s->attribute == CFI_attribute_other)\n-    goto finish;\n+  if (!s)\n+    return;\n \n   GFC_DESCRIPTOR_DATA (d) = s->base_addr;\n-\n-  if (!s->rank || s->dim[0].sm == (CFI_index_t)s->elem_len)\n-    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n-  else\n-    GFC_DESCRIPTOR_SIZE (d) =  (index_type)s->dim[0].sm;\n-\n-  d->dtype.version = s->version;\n-  GFC_DESCRIPTOR_RANK (d) = (signed char)s->rank;\n   GFC_DESCRIPTOR_TYPE (d) = (signed char)(s->type & CFI_type_mask);\n+  kind = (index_type)((s->type - (s->type & CFI_type_mask)) >> CFI_type_kind_shift);\n \n   /* Correct the unfortunate difference in order with types.  */\n   if (GFC_DESCRIPTOR_TYPE (d) == BT_CHARACTER)\n     GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;\n   else if (GFC_DESCRIPTOR_TYPE (d) == BT_DERIVED)\n     GFC_DESCRIPTOR_TYPE (d) = BT_CHARACTER;\n \n+  if (!s->rank || s->dim[0].sm == (CFI_index_t)s->elem_len)\n+    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n+  else if (GFC_DESCRIPTOR_TYPE (d) != BT_DERIVED)\n+    GFC_DESCRIPTOR_SIZE (d) = kind;\n+  else\n+    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n+\n+  d->dtype.version = s->version;\n+  GFC_DESCRIPTOR_RANK (d) = (signed char)s->rank;\n+\n   d->dtype.attribute = (signed short)s->attribute;\n \n   if (s->rank)\n-    d->span = (index_type)s->dim[0].sm;\n+    {\n+      if ((size_t)s->dim[0].sm % s->elem_len)\n+\td->span = (index_type)s->dim[0].sm;\n+      else\n+\td->span = (index_type)s->elem_len;\n+    }\n \n-  /* On the other hand, CFI_establish can change the bounds.  */\n   d->offset = 0;\n   for (n = 0; n < GFC_DESCRIPTOR_RANK (d); n++)\n     {\n@@ -76,11 +82,6 @@ cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n       GFC_DESCRIPTOR_STRIDE(d, n) = (index_type)(s->dim[n].sm / s->elem_len);\n       d->offset -= GFC_DESCRIPTOR_STRIDE(d, n) * GFC_DESCRIPTOR_LBOUND(d, n);\n     }\n-\n-finish:\n-  if (s)\n-    free (s);\n-  s = NULL;\n }\n \n extern void gfc_desc_to_cfi_desc (CFI_cdesc_t **, const gfc_array_void *);\n@@ -95,8 +96,11 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n   /* Play it safe with allocation of the flexible array member 'dim'\n      by setting the length to CFI_MAX_RANK. This should not be necessary\n      but valgrind complains accesses after the allocated block.  */\n-  d = malloc (sizeof (CFI_cdesc_t)\n+  if (*d_ptr == NULL)\n+    d = malloc (sizeof (CFI_cdesc_t)\n \t\t+ (CFI_type_t)(CFI_MAX_RANK * sizeof (CFI_dim_t)));\n+  else\n+    d = *d_ptr;\n \n   d->base_addr = GFC_DESCRIPTOR_DATA (s);\n   d->elem_len = GFC_DESCRIPTOR_SIZE (s);\n@@ -115,7 +119,7 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n     d->type = (CFI_type_t)(d->type\n \t\t+ ((CFI_type_t)d->elem_len << CFI_type_kind_shift));\n \n-  /* Full pointer or allocatable arrays have zero lower_bound.  */\n+  /* Full pointer or allocatable arrays retain their lower_bounds.  */\n   for (n = 0; n < GFC_DESCRIPTOR_RANK (s); n++)\n     {\n       if (d->attribute != CFI_attribute_other)\n@@ -134,7 +138,8 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n       d->dim[n].sm = (CFI_index_t)(GFC_DESCRIPTOR_STRIDE(s, n) * s->span);\n     }\n \n-  *d_ptr = d;\n+  if (*d_ptr == NULL)\n+    *d_ptr = d;\n }\n \n void *CFI_address (const CFI_cdesc_t *dv, const CFI_index_t subscripts[])\n@@ -416,29 +421,29 @@ int CFI_is_contiguous (const CFI_cdesc_t *dv)\n       if (dv == NULL)\n \t{\n \t  fprintf (stderr, \"CFI_is_contiguous: C descriptor is NULL.\\n\");\n-\t  return CFI_INVALID_DESCRIPTOR;\n+\t  return 0;\n \t}\n \n       /* Base address must not be NULL. */\n       if (dv->base_addr == NULL)\n \t{\n \t  fprintf (stderr, \"CFI_is_contiguous: Base address of C Descriptor \"\n \t\t   \"is already NULL.\\n\");\n-\t  return CFI_ERROR_BASE_ADDR_NULL;\n+\t  return 0;\n \t}\n \n       /* Must be an array. */\n       if (dv->rank == 0)\n \t{\n \t  fprintf (stderr, \"CFI_is_contiguous: C Descriptor must describe an \"\n \t\t   \"array (0 < dv->rank = %d).\\n\", dv->rank);\n-\t  return CFI_INVALID_RANK;\n+\t  return 0;\n \t}\n     }\n \n   /* Assumed size arrays are always contiguous.  */\n   if (dv->rank > 0 && dv->dim[dv->rank - 1].extent == -1)\n-    return CFI_SUCCESS;\n+    return 1;\n \n   /* If an array is not contiguous the memory stride is different to the element\n    * length. */\n@@ -447,15 +452,15 @@ int CFI_is_contiguous (const CFI_cdesc_t *dv)\n       if (i == 0 && dv->dim[i].sm == (CFI_index_t)dv->elem_len)\n \tcontinue;\n       else if (i > 0\n-\t       && dv->dim[i].sm == (CFI_index_t)(dv->elem_len\n+\t       && dv->dim[i].sm == (CFI_index_t)(dv->dim[i - 1].sm\n \t\t\t\t   * dv->dim[i - 1].extent))\n \tcontinue;\n \n-      return CFI_FAILURE;\n+      return 0;\n     }\n \n   /* Array sections are guaranteed to be contiguous by the previous test.  */\n-  return CFI_SUCCESS;\n+  return 1;\n }\n \n \n@@ -670,7 +675,7 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n \t}\n       int idx = i - aux;\n       result->dim[idx].lower_bound = lower[i];\n-      result->dim[idx].extent = upper[i] - lower[i] + 1;\n+      result->dim[idx].extent = 1 + (upper[i] - lower[i])/stride[i];\n       result->dim[idx].sm = stride[i] * source->dim[i].sm;\n       /* Adjust 'lower' for the base address offset.  */\n       lower[idx] = lower[idx] - source->dim[i].lower_bound;"}]}