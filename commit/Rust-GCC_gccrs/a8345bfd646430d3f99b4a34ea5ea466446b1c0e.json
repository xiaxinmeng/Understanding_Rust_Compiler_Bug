{"sha": "a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgzNDViZmQ2NDY0MzBkM2Y5OWI0YTM0ZWE1ZWE0NjY0NDZiMWMwZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-27T15:08:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-27T15:08:50Z"}, "message": "visium-protos.h (split_double_move): Rename into...\n\n\t* config/visium/visium-protos.h (split_double_move): Rename into...\n\t(visium_split_double_move): ...this.\n\t(visium_split_double_add): Declare.\n\t* config/visium/visium.c (split_double_move): Rename into...\n\t(visium_split_double_move): ...this.\n\t(visium_split_double_add): New function.\n\t(visium_expand_copysign): Renumber operands for consistency.\n\t* config/visium/visium.md (DImode move splitter): Adjust to renaming.\n\t(DFmode move splitter): Likewise.\n\t(*addi3_insn): Split by means of visium_split_double_add.\n\t(*adddi3_insn_flags): Delete.\n\t(*plus_plus_sltu<subst_arith>): New insn.\n\t(*subdi3_insn): Split by means of visium_split_double_add.\n\t(subdi3_insn_flags): Delete.\n\t(*minus_minus_sltu<subst_arith>): New insn.\n\t(*negdi2_insn): Split by means of visium_split_double_add.\n\t(*negdi2_insn_flags): Delete.\n\nFrom-SVN: r236827", "tree": {"sha": "9f7550fa93477d8dc0c9e2841fa38f5e92a21f01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f7550fa93477d8dc0c9e2841fa38f5e92a21f01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/comments", "author": null, "committer": null, "parents": [{"sha": "7d67159b48803e2558f33600e2f015f4e251a3e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d67159b48803e2558f33600e2f015f4e251a3e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d67159b48803e2558f33600e2f015f4e251a3e1"}], "stats": {"total": 223, "additions": 148, "deletions": 75}, "files": [{"sha": "f04d26d8d565a3e4993313497dd69ca87c18c266", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "patch": "@@ -1,3 +1,23 @@\n+2016-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/visium/visium-protos.h (split_double_move): Rename into...\n+\t(visium_split_double_move): ...this.\n+\t(visium_split_double_add): Declare.\n+\t* config/visium/visium.c (split_double_move): Rename into...\n+\t(visium_split_double_move): ...this.\n+\t(visium_split_double_add): New function.\n+\t(visium_expand_copysign): Renumber operands for consistency.\n+\t* config/visium/visium.md (DImode move splitter): Adjust to renaming.\n+\t(DFmode move splitter): Likewise.\n+\t(*addi3_insn): Split by means of visium_split_double_add.\n+\t(*adddi3_insn_flags): Delete.\n+\t(*plus_plus_sltu<subst_arith>): New insn.\n+\t(*subdi3_insn): Split by means of visium_split_double_add.\n+\t(subdi3_insn_flags): Delete.\n+\t(*minus_minus_sltu<subst_arith>): New insn.\n+\t(*negdi2_insn): Split by means of visium_split_double_add.\n+\t(*negdi2_insn_flags): Delete.\n+\n 2016-05-27  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* configure.ac: Treat a --with-headers option without argument\n@@ -479,7 +499,7 @@\n 2016-05-24  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/71147\n-\t* gcc/tree.h (complete_or_array_type_p): New inline function.\n+\t* tree.h (complete_or_array_type_p): New inline function.\n \n 2016-05-24  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "9dcbc67035f5d756579387de5fd07ff6ebc0f9ee", "filename": "gcc/config/visium/visium-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h?ref=a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "patch": "@@ -49,7 +49,8 @@ extern void visium_split_cbranch (enum rtx_code, rtx, rtx, rtx);\n extern const char *output_ubranch (rtx, rtx_insn *);\n extern const char *output_cbranch (rtx, enum rtx_code, enum machine_mode, int,\n \t\t\t\t   rtx_insn *);\n-extern void split_double_move (rtx *, enum machine_mode);\n+extern void visium_split_double_move (rtx *, enum machine_mode);\n+extern void visium_split_double_add (enum rtx_code, rtx, rtx, rtx);\n extern void visium_expand_copysign (rtx *, enum machine_mode);\n extern void visium_expand_int_cstore (rtx *, enum machine_mode);\n extern void visium_expand_fp_cstore (rtx *, enum machine_mode);"}, {"sha": "44f471a1a4994f46a616777eb47e841fd052df8f", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "patch": "@@ -2026,7 +2026,7 @@ visium_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n /* Split a double move of OPERANDS in MODE.  */\n \n void\n-split_double_move (rtx *operands, enum machine_mode mode)\n+visium_split_double_move (rtx *operands, enum machine_mode mode)\n {\n   bool swap = false;\n \n@@ -2076,52 +2076,112 @@ split_double_move (rtx *operands, enum machine_mode mode)\n     }\n }\n \n+/* Split a double addition or subtraction of operands.  */\n+\n+void\n+visium_split_double_add (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n+{\n+  rtx op3 = gen_lowpart (SImode, op0);\n+  rtx op4 = gen_lowpart (SImode, op1);\n+  rtx op5;\n+  rtx op6 = gen_highpart (SImode, op0);\n+  rtx op7 = (op1 == const0_rtx ? op1 : gen_highpart (SImode, op1));\n+  rtx op8;\n+\n+  /* If operand #2 is a small constant, then its high part is null.  */\n+  if (CONST_INT_P (op2))\n+    {\n+      HOST_WIDE_INT val = INTVAL (op2);\n+\n+      if (val < 0)\n+\t{\n+\t  code = (code == MINUS ? PLUS : MINUS);\n+\t  val = -val;\n+\t}\n+\n+      op5 = gen_int_mode (val, SImode);\n+      op8 = const0_rtx;\n+    }\n+  else\n+    {\n+      op5 = gen_lowpart (SImode, op2);\n+      op8 = gen_highpart (SImode, op2);\n+    }\n+\n+  /* This is the {add,sub,neg}si3_insn_set_flags pattern.  */\n+  rtx x;\n+  if (op4 == const0_rtx)\n+    x = gen_rtx_NEG (SImode, op5);\n+  else\n+    x = gen_rtx_fmt_ee (code, SImode, op4, op5);\n+  rtx pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+  XVECEXP (pat, 0, 0) = gen_rtx_SET (op3, x);\n+  rtx flags = gen_rtx_REG (CC_NOOVmode, FLAGS_REGNUM);\n+  x = gen_rtx_COMPARE (CC_NOOVmode, shallow_copy_rtx (x), const0_rtx);\n+  XVECEXP (pat, 0, 1) = gen_rtx_SET (flags, x);\n+  emit_insn (pat);\n+\n+  /* This is the plus_[plus_]sltu_flags or minus_[minus_]sltu_flags pattern.  */\n+  if (op8 == const0_rtx)\n+    x = op7;\n+  else\n+    x = gen_rtx_fmt_ee (code, SImode, op7, op8);\n+  x = gen_rtx_fmt_ee (code, SImode, x, gen_rtx_LTU (SImode, flags, const0_rtx));\n+  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+  XVECEXP (pat, 0, 0) = gen_rtx_SET (op6, x);\n+  flags = gen_rtx_REG (CCmode, FLAGS_REGNUM);\n+  XVECEXP (pat, 0, 1) = gen_rtx_CLOBBER (VOIDmode, flags);\n+  emit_insn (pat);\n+\n+  visium_flags_exposed = true;\n+}\n+\n /* Expand a copysign of OPERANDS in MODE.  */\n \n void\n visium_expand_copysign (rtx *operands, enum machine_mode mode)\n {\n-  rtx dest = operands[0];\n-  rtx op0 = operands[1];\n-  rtx op1 = operands[2];\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n   rtx mask = force_reg (SImode, GEN_INT (0x7fffffff));\n   rtx x;\n \n   /* We manually handle SFmode because the abs and neg instructions of\n      the FPU on the MCM have a non-standard behavior wrt NaNs.  */\n   gcc_assert (mode == SFmode);\n \n-  /* First get all the non-sign bits of OP0.  */\n-  if (GET_CODE (op0) == CONST_DOUBLE)\n+  /* First get all the non-sign bits of op1.  */\n+  if (GET_CODE (op1) == CONST_DOUBLE)\n     {\n-      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op0)))\n-\top0 = simplify_unary_operation (ABS, mode, op0, mode);\n-      if (op0 != CONST0_RTX (mode))\n+      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op1)))\n+\top1 = simplify_unary_operation (ABS, mode, op1, mode);\n+      if (op1 != CONST0_RTX (mode))\n \t{\n \t  long l;\n-\t  REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (op0), l);\n-\t  op0 = force_reg (SImode, GEN_INT (trunc_int_for_mode (l, SImode)));\n+\t  REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (op1), l);\n+\t  op1 = force_reg (SImode, GEN_INT (trunc_int_for_mode (l, SImode)));\n \t}\n     }\n   else\n     {\n-      op0 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op0));\n-      op0 = force_reg (SImode, gen_rtx_AND (SImode, op0, mask));\n+      op1 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op1));\n+      op1 = force_reg (SImode, gen_rtx_AND (SImode, op1, mask));\n     }\n \n-  /* Then get the sign bit of OP1.  */\n+  /* Then get the sign bit of op2.  */\n   mask = force_reg (SImode, gen_rtx_NOT (SImode, mask));\n-  op1 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op1));\n-  op1 = force_reg (SImode, gen_rtx_AND (SImode, op1, mask));\n+  op2 = copy_to_mode_reg (SImode, gen_lowpart (SImode, op2));\n+  op2 = force_reg (SImode, gen_rtx_AND (SImode, op2, mask));\n \n   /* Finally OR the two values.  */\n-  if (op0 == CONST0_RTX (SFmode))\n-    x = op1;\n+  if (op1 == CONST0_RTX (SFmode))\n+    x = op2;\n   else\n-    x = force_reg (SImode, gen_rtx_IOR (SImode, op0, op1));\n+    x = force_reg (SImode, gen_rtx_IOR (SImode, op1, op2));\n \n   /* And move the result to the destination.  */\n-  emit_insn (gen_rtx_SET (dest, gen_lowpart (SFmode, x)));\n+  emit_insn (gen_rtx_SET (op0, gen_lowpart (SFmode, x)));\n }\n \n /* Expand a cstore of OPERANDS in MODE for EQ/NE/LTU/GTU/GEU/LEU.  We generate"}, {"sha": "41e3e5c57198596366c6fd9d8d06f23981709c20", "filename": "gcc/config/visium/visium.md", "status": "modified", "additions": 45, "deletions": 53, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2Fconfig%2Fvisium%2Fvisium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8345bfd646430d3f99b4a34ea5ea466446b1c0e/gcc%2Fconfig%2Fvisium%2Fvisium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.md?ref=a8345bfd646430d3f99b4a34ea5ea466446b1c0e", "patch": "@@ -627,7 +627,7 @@\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n {\n-  split_double_move (operands, DImode);\n+  visium_split_double_move (operands, DImode);\n })\n \n ;;\n@@ -726,7 +726,7 @@\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n {\n-  split_double_move (operands, DFmode);\n+  visium_split_double_move (operands, DFmode);\n })\n \n ;;\n@@ -815,39 +815,28 @@\n \t\t (match_operand:DI 2 \"add_operand\" \"\")))]\n   \"\")\n \n+; Disfavour the use of add.l because of the early clobber.\n+\n (define_insn_and_split \"*addi3_insn\"\n   [(set (match_operand:DI 0 \"register_operand\"          \"=r,r,&r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0, r\")\n-\t\t (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))]\n+\t\t (match_operand:DI 2 \"add_operand\"      \" L,J, r\")))]\n   \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n   \"#\"\n   \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:DI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC R_FLAGS))])]\n-  \"\"\n-  [(set_attr \"type\" \"arith2\")])\n-\n-; Disfavour the use of add.l because of the early clobber.\n-\n-(define_insn \"*adddi3_insn_flags\"\n-  [(set (match_operand:DI 0 \"register_operand\"          \"=r,r,&r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0, r\")\n-\t\t (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))\n-   (clobber (reg:CC R_FLAGS))]\n-  \"reload_completed\"\n-  \"@\n-    addi    %d0,%2\\n\\tadc.l   %0,%0,r0\n-    subi    %d0,%n2\\n\\tsubc.l  %0,%0,r0\n-    add.l   %d0,%d1,%d2\\n\\tadc.l   %0,%1,%2\"\n+  [(const_int 0)]\n+{\n+  visium_split_double_add (PLUS, operands[0], operands[1], operands[2]);\n+  DONE;\n+}\n   [(set_attr \"type\" \"arith2\")])\n \n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Integer Add with Carry\n ;;\n-;; Only SI mode is supported as slt[u] for the sake of cstore.\n+;; Only SI mode is supported.\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n@@ -869,6 +858,16 @@\n   \"adc.l   %0,%1,r0\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"*plus_plus_sltu<subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t (ltu:SI (reg R_FLAGS) (const_int 0))))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"adc.l   %0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n@@ -955,39 +954,28 @@\n \t\t  (match_operand:DI 2 \"add_operand\" \"\")))]\n   \"\")\n \n+; Disfavour the use of the sub.l because of the early clobber.\n+\n (define_insn_and_split \"*subdi3_insn\"\n   [(set (match_operand:DI 0 \"register_operand\"           \"=r,r,&r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \" 0,0, r\")\n-\t\t  (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))]\n+\t\t  (match_operand:DI 2 \"add_operand\"      \" L,J, r\")))]\n   \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n   \"#\"\n   \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (minus:DI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC R_FLAGS))])]\n- \"\"\n-  [(set_attr \"type\" \"arith2\")])\n-\n-; Disfavour the use of the sub.l because of the early clobber.\n-\n-(define_insn \"*subdi3_insn_flags\"\n-  [(set (match_operand:DI 0 \"register_operand\"           \"=r,r,&r\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \" 0,0, r\")\n-\t\t  (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))\n-   (clobber (reg:CC R_FLAGS))]\n-  \"reload_completed\"\n-  \"@\n-    subi    %d0,%2\\n\\tsubc.l  %0,%0,r0\n-    addi    %d0,%n2\\n\\tadc.l   %0,%0,r0\n-    sub.l   %d0,%d1,%d2\\n\\tsubc.l  %0,%1,%2\"\n+  [(const_int 0)]\n+{\n+  visium_split_double_add (MINUS, operands[0], operands[1], operands[2]);\n+  DONE;\n+}\n   [(set_attr \"type\" \"arith2\")])\n \n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Integer Subtract with Carry\n ;;\n-;; Only SI mode is supported as neg<slt[u]> for the sake of cstore.\n+;; Only SI mode is supported.\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n@@ -1009,6 +997,16 @@\n   \"subc.l  %0,%1,r0\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"*minus_minus_sltu<subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t  (ltu:SI (reg R_FLAGS) (const_int 0))))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"subc.l  %0,%r1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n@@ -1054,17 +1052,11 @@\n   \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n   \"#\"\n   \"reload_completed\"\n-  [(parallel [(set (match_dup 0) (neg:DI (match_dup 1)))\n-\t      (clobber (reg:CC R_FLAGS))])]\n-  \"\"\n-  [(set_attr \"type\" \"arith2\")])\n-\n-(define_insn \"*negdi2_insn_flags\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n-   (clobber (reg:CC R_FLAGS))]\n-  \"reload_completed\"\n-  \"sub.l   %d0,r0,%d1\\n\\tsubc.l  %0,r0,%1\"\n+  [(const_int 0)]\n+{\n+  visium_split_double_add (MINUS, operands[0], const0_rtx, operands[1]);\n+  DONE;\n+}\n   [(set_attr \"type\" \"arith2\")])\n \n ;;"}]}