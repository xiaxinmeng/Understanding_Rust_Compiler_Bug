{"sha": "568de9bb5983e03b566390a0cfe708bf263f7e06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY4ZGU5YmI1OTgzZTAzYjU2NjM5MGEwY2ZlNzA4YmYyNjNmN2UwNg==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-06-16T21:44:55Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-06-16T21:44:55Z"}, "message": "pa.c (pa_output_pic_pcrel_sequence): New.\n\n\t* config/pa/pa.c (pa_output_pic_pcrel_sequence): New.\n\t(pa_output_lbranch): Use pa_output_pic_pcrel_sequence.\n\t(pa_output_millicode_call): Likewise.\n\t(pa_output_call): Likewise.\n\t(pa_output_indirect_call): Likewise.\n\t(pa_asm_output_mi_thunk): Likewise.\n\nFrom-SVN: r237543", "tree": {"sha": "0e133e52a953c7fd0e2fdf4f5c25b3b97a63bf2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e133e52a953c7fd0e2fdf4f5c25b3b97a63bf2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/568de9bb5983e03b566390a0cfe708bf263f7e06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/568de9bb5983e03b566390a0cfe708bf263f7e06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/568de9bb5983e03b566390a0cfe708bf263f7e06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/568de9bb5983e03b566390a0cfe708bf263f7e06/comments", "author": null, "committer": null, "parents": [{"sha": "6f820b684da3a18400b92463c5e40f897c68434b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f820b684da3a18400b92463c5e40f897c68434b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f820b684da3a18400b92463c5e40f897c68434b"}], "stats": {"total": 244, "additions": 115, "deletions": 129}, "files": [{"sha": "f22ac889bffff0742ebd476583e23a6ec671dd35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568de9bb5983e03b566390a0cfe708bf263f7e06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568de9bb5983e03b566390a0cfe708bf263f7e06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=568de9bb5983e03b566390a0cfe708bf263f7e06", "patch": "@@ -1,3 +1,12 @@\n+2016-06-16  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa.c (pa_output_pic_pcrel_sequence): New.\n+\t(pa_output_lbranch): Use pa_output_pic_pcrel_sequence.\n+\t(pa_output_millicode_call): Likewise.\n+\t(pa_output_call): Likewise.\n+\t(pa_output_indirect_call): Likewise.\n+\t(pa_asm_output_mi_thunk): Likewise.\n+\n 2016-06-16  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n \n \t* doc/invoke.texi (x86 Options): Fix -mno-fp-ret-in-387 typo."}, {"sha": "8ce6b57341e62ed8d3e0bdad82864088bf555a3c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 106, "deletions": 129, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568de9bb5983e03b566390a0cfe708bf263f7e06/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568de9bb5983e03b566390a0cfe708bf263f7e06/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=568de9bb5983e03b566390a0cfe708bf263f7e06", "patch": "@@ -6710,6 +6710,57 @@ pa_output_cbranch (rtx *operands, int negated, rtx_insn *insn)\n   return buf;\n }\n \n+/* Output a PIC pc-relative instruction sequence to load the address of\n+   OPERANDS[0] to register OPERANDS[2].  OPERANDS[0] is a symbol ref\n+   or a code label.  OPERANDS[1] specifies the register to use to load\n+   the program counter.  OPERANDS[3] may be used for label generation\n+   The sequence is always three instructions in length.  The program\n+   counter recorded for PA 1.X is eight bytes more than that for PA 2.0.\n+   Register %r1 is clobbered.  */\n+\n+static void\n+pa_output_pic_pcrel_sequence (rtx *operands)\n+{\n+  gcc_assert (SYMBOL_REF_P (operands[0]) || LABEL_P (operands[0]));\n+  if (TARGET_PA_20)\n+    {\n+      /* We can use mfia to determine the current program counter.  */\n+      if (TARGET_SOM || !TARGET_GAS)\n+\t{\n+\t  operands[3] = gen_label_rtx ();\n+\t  targetm.asm_out.internal_label (asm_out_file, \"L\",\n+\t\t\t\t\t  CODE_LABEL_NUMBER (operands[3]));\n+\t  output_asm_insn (\"mfia %1\", operands);\n+\t  output_asm_insn (\"addil L'%0-%l3,%1\", operands);\n+\t  output_asm_insn (\"ldo R'%0-%l3(%%r1),%2\", operands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"mfia %1\", operands);\n+\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+12,%1\", operands);\n+\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+16(%%r1),%2\", operands);\n+\t}\n+    }\n+  else\n+    {\n+      /* We need to use a branch to determine the current program counter.  */\n+      output_asm_insn (\"{bl|b,l} .+8,%1\", operands);\n+      if (TARGET_SOM || !TARGET_GAS)\n+\t{\n+\t  operands[3] = gen_label_rtx ();\n+\t  output_asm_insn (\"addil L'%0-%l3,%1\", operands);\n+\t  targetm.asm_out.internal_label (asm_out_file, \"L\",\n+\t\t\t\t\t  CODE_LABEL_NUMBER (operands[3]));\n+\t  output_asm_insn (\"ldo R'%0-%l3(%%r1),%2\", operands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%1\", operands);\n+\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%2\", operands);\n+\t}\n+    }\n+}\n+\n /* This routine handles output of long unconditional branches that\n    exceed the maximum range of a simple branch instruction.  Since\n    we don't have a register available for the branch, we save register\n@@ -6730,7 +6781,7 @@ pa_output_cbranch (rtx *operands, int negated, rtx_insn *insn)\n const char *\n pa_output_lbranch (rtx dest, rtx_insn *insn, int xdelay)\n {\n-  rtx xoperands[2];\n+  rtx xoperands[4];\n  \n   xoperands[0] = dest;\n \n@@ -6800,20 +6851,9 @@ pa_output_lbranch (rtx dest, rtx_insn *insn, int xdelay)\n     }\n   else if (flag_pic)\n     {\n-      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-      if (TARGET_SOM || !TARGET_GAS)\n-\t{\n-\t  xoperands[1] = gen_label_rtx ();\n-\t  output_asm_insn (\"addil L'%l0-%l1,%%r1\", xoperands);\n-\t  targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t\t  CODE_LABEL_NUMBER (xoperands[1]));\n-\t  output_asm_insn (\"ldo R'%l0-%l1(%%r1),%%r1\", xoperands);\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\"addil L'%l0-$PIC_pcrel$0+4,%%r1\", xoperands);\n-\t  output_asm_insn (\"ldo R'%l0-$PIC_pcrel$0+8(%%r1),%%r1\", xoperands);\n-\t}\n+      xoperands[1] = gen_rtx_REG (Pmode, 1);\n+      xoperands[2] = xoperands[1];\n+      pa_output_pic_pcrel_sequence (xoperands);\n       output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n     }\n   else\n@@ -7642,10 +7682,9 @@ pa_output_millicode_call (rtx_insn *insn, rtx call_dest)\n {\n   int attr_length = get_attr_length (insn);\n   int seq_length = dbr_sequence_length ();\n-  rtx xoperands[3];\n+  rtx xoperands[4];\n \n   xoperands[0] = call_dest;\n-  xoperands[2] = gen_rtx_REG (Pmode, TARGET_64BIT ? 2 : 31);\n \n   /* Handle the common case where we are sure that the branch will\n      reach the beginning of the $CODE$ subspace.  The within reach\n@@ -7657,7 +7696,8 @@ pa_output_millicode_call (rtx_insn *insn, rtx call_dest)\n \t  || (attr_length == 28\n \t      && get_attr_type (insn) == TYPE_SH_FUNC_ADRS)))\n     {\n-      output_asm_insn (\"{bl|b,l} %0,%2\", xoperands);\n+      xoperands[1] = gen_rtx_REG (Pmode, TARGET_64BIT ? 2 : 31);\n+      output_asm_insn (\"{bl|b,l} %0,%1\", xoperands);\n     }\n   else\n     {\n@@ -7668,22 +7708,9 @@ pa_output_millicode_call (rtx_insn *insn, rtx call_dest)\n \t     this doesn't work in shared libraries and other dynamically\n \t     loaded objects.  Using a pc-relative sequence also avoids\n \t     problems related to the implicit use of the gp register.  */\n-\t  output_asm_insn (\"b,l .+8,%%r1\", xoperands);\n-\n-\t  if (TARGET_GAS)\n-\t    {\n-\t      output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n-\t      output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r1\", xoperands);\n-\t    }\n-\t  else\n-\t    {\n-\t      xoperands[1] = gen_label_rtx ();\n-\t      output_asm_insn (\"addil L'%0-%l1,%%r1\", xoperands);\n-\t      targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n-\t      output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n-\t    }\n-\n+\t  xoperands[1] = gen_rtx_REG (Pmode, 1);\n+\t  xoperands[2] = xoperands[1];\n+\t  pa_output_pic_pcrel_sequence (xoperands);\n \t  output_asm_insn (\"bve,l (%%r1),%%r2\", xoperands);\n \t}\n       else if (TARGET_PORTABLE_RUNTIME)\n@@ -7713,27 +7740,12 @@ pa_output_millicode_call (rtx_insn *insn, rtx call_dest)\n \t}\n       else\n \t{\n-\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\t  output_asm_insn (\"addi 16,%%r1,%%r31\", xoperands);\n+\t  xoperands[1] = gen_rtx_REG (Pmode, 31);\n+\t  xoperands[2] = gen_rtx_REG (Pmode, 1);\n+\t  pa_output_pic_pcrel_sequence (xoperands);\n \n-\t  if (TARGET_SOM || !TARGET_GAS)\n-\t    {\n-\t      /* The HP assembler can generate relocations for the\n-\t\t difference of two symbols.  GAS can do this for a\n-\t\t millicode symbol but not an arbitrary external\n-\t\t symbol when generating SOM output.  */\n-\t      xoperands[1] = gen_label_rtx ();\n-\t      targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n-\t      output_asm_insn (\"addil L'%0-%l1,%%r1\", xoperands);\n-\t      output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\"addil L'%0-$PIC_pcrel$0+8,%%r1\", xoperands);\n-\t      output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+12(%%r1),%%r1\",\n-\t\t\t       xoperands);\n-\t    }\n+\t  /* Adjust return address.  */\n+\t  output_asm_insn (\"ldo {16|24}(%%r31),%%r31\", xoperands);\n \n \t  /* Jump to our target address in %r1.  */\n \t  output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n@@ -7811,8 +7823,7 @@ pa_attr_length_call (rtx_insn *insn, int sibcall)\n \n   /* long pc-relative branch sequence.  */\n   else if (TARGET_LONG_PIC_SDIFF_CALL\n-\t   || (TARGET_GAS && !TARGET_SOM\n-\t       && (TARGET_LONG_PIC_PCREL_CALL || local_call)))\n+\t   || (TARGET_GAS && !TARGET_SOM && local_call))\n     {\n       length += 20;\n \n@@ -7854,7 +7865,7 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n   int seq_length = dbr_sequence_length ();\n   tree call_decl = SYMBOL_REF_DECL (call_dest);\n   int local_call = call_decl && targetm.binds_local_p (call_decl);\n-  rtx xoperands[2];\n+  rtx xoperands[4];\n \n   xoperands[0] = call_dest;\n \n@@ -7918,8 +7929,7 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n              they don't allow an instruction in the delay slot.  */\n \t  if (!((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)\n \t      && !TARGET_LONG_PIC_SDIFF_CALL\n-\t      && !(TARGET_GAS && !TARGET_SOM\n-\t\t   && (TARGET_LONG_PIC_PCREL_CALL || local_call))\n+\t      && !(TARGET_GAS && !TARGET_SOM && local_call)\n \t      && !TARGET_64BIT)\n \t    indirect_call = 1;\n \n@@ -7964,33 +7974,23 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \t    }\n \t  else\n \t    {\n-\t      if (TARGET_LONG_PIC_SDIFF_CALL)\n-\t\t{\n-\t\t  /* The HP assembler and linker can handle relocations\n-\t\t     for the difference of two symbols.  The HP assembler\n-\t\t     recognizes the sequence as a pc-relative call and\n-\t\t     the linker provides stubs when needed.  */\n-\t\t  xoperands[1] = gen_label_rtx ();\n-\t\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\t\t  output_asm_insn (\"addil L'%0-%l1,%%r1\", xoperands);\n-\t\t  targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-\t\t  output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n-\t\t}\n-\t      else if (TARGET_GAS && !TARGET_SOM\n-\t\t       && (TARGET_LONG_PIC_PCREL_CALL || local_call))\n+\t      /* The HP assembler and linker can handle relocations for\n+\t\t the difference of two symbols.  The HP assembler\n+\t\t recognizes the sequence as a pc-relative call and\n+\t\t the linker provides stubs when needed.  */\n+\n+\t      /* GAS currently can't generate the relocations that\n+\t\t are needed for the SOM linker under HP-UX using this\n+\t\t sequence.  The GNU linker doesn't generate the stubs\n+\t\t that are needed for external calls on TARGET_ELF32\n+\t\t with this sequence.  For now, we have to use a longer\n+\t         plabel sequence when using GAS for non local calls.  */\n+\t      if (TARGET_LONG_PIC_SDIFF_CALL\n+\t\t  || (TARGET_GAS && !TARGET_SOM && local_call))\n \t\t{\n-\t\t  /*  GAS currently can't generate the relocations that\n-\t\t      are needed for the SOM linker under HP-UX using this\n-\t\t      sequence.  The GNU linker doesn't generate the stubs\n-\t\t      that are needed for external calls on TARGET_ELF32\n-\t\t      with this sequence.  For now, we have to use a\n-\t\t      longer plabel sequence when using GAS.  */\n-\t\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\t\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\",\n-\t\t\t\t   xoperands);\n-\t\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r1\",\n-\t\t\t\t   xoperands);\n+\t\t  xoperands[1] = gen_rtx_REG (Pmode, 1);\n+\t\t  xoperands[2] = xoperands[1];\n+\t\t  pa_output_pic_pcrel_sequence (xoperands);\n \t\t}\n \t      else\n \t\t{\n@@ -8131,7 +8131,7 @@ pa_attr_length_indirect_call (rtx_insn *insn)\n const char *\n pa_output_indirect_call (rtx_insn *insn, rtx call_dest)\n {\n-  rtx xoperands[1];\n+  rtx xoperands[4];\n \n   if (TARGET_64BIT)\n     {\n@@ -8171,25 +8171,12 @@ pa_output_indirect_call (rtx_insn *insn, rtx call_dest)\n     return \"ldil L'$$dyncall,%%r31\\n\\tldo R'$$dyncall(%%r31),%%r31\\n\\tblr %%r0,%%r2\\n\\tbv,n %%r0(%%r31)\";\n \n   /* We need a long PIC call to $$dyncall.  */\n-  xoperands[0] = NULL_RTX;\n-  output_asm_insn (\"{bl|b,l} .+8,%%r2\", xoperands);\n-  if (TARGET_SOM || !TARGET_GAS)\n-    {\n-      xoperands[0] = gen_label_rtx ();\n-      output_asm_insn (\"addil L'$$dyncall-%0,%%r2\", xoperands);\n-      targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t      CODE_LABEL_NUMBER (xoperands[0]));\n-      output_asm_insn (\"ldo R'$$dyncall-%0(%%r1),%%r1\", xoperands);\n-    }\n-  else\n-    {\n-      output_asm_insn (\"addil L'$$dyncall-$PIC_pcrel$0+4,%%r2\", xoperands);\n-      output_asm_insn (\"ldo R'$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\",\n-\t\t       xoperands);\n-    }\n+  xoperands[0] = gen_rtx_SYMBOL_REF (Pmode, \"$$dyncall\");\n+  xoperands[1] = gen_rtx_REG (Pmode, 2);\n+  xoperands[2] = gen_rtx_REG (Pmode, 1);\n+  pa_output_pic_pcrel_sequence (xoperands);\n   output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n-  output_asm_insn (\"ldo 12(%%r2),%%r2\", xoperands);\n-  return \"\";\n+  return \"ldo {12|20}(%%r2),%%r2\";\n }\n \n /* In HPUX 8.0's shared library scheme, special relocations are needed\n@@ -8333,6 +8320,8 @@ pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n     }\n   else if (TARGET_64BIT)\n     {\n+      rtx xop[4];\n+\n       /* We only have one call-clobbered scratch register, so we can't\n          make use of the delay slot if delta doesn't fit in 14 bits.  */\n       if (!val_14)\n@@ -8341,18 +8330,11 @@ pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n \t  output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n \t}\n \n-      output_asm_insn (\"b,l .+8,%%r1\", xoperands);\n-\n-      if (TARGET_GAS)\n-\t{\n-\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n-\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r1\", xoperands);\n-\t}\n-      else\n-\t{\n-\t  xoperands[3] = GEN_INT (val_14 ? 8 : 16);\n-\t  output_asm_insn (\"addil L'%0-%1-%3,%%r1\", xoperands);\n-\t}\n+      /* Load function address into %r1.  */\n+      xop[0] = xoperands[0];\n+      xop[1] = gen_rtx_REG (Pmode, 1);\n+      xop[2] = xop[1];\n+      pa_output_pic_pcrel_sequence (xop);\n \n       if (val_14)\n \t{\n@@ -8372,7 +8354,7 @@ pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n       output_asm_insn (\"ldo R'%0(%%r1),%%r22\", xoperands);\n \n       if (!val_14)\n-\toutput_asm_insn (\"addil L'%2,%%r26\", xoperands);\n+\toutput_asm_insn (\"ldil L'%2,%%r26\", xoperands);\n \n       output_asm_insn (\"bv %%r0(%%r22)\", xoperands);\n \n@@ -8383,7 +8365,7 @@ pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n \t}\n       else\n \t{\n-\t  output_asm_insn (\"ldo R'%2(%%r1),%%r26\", xoperands);\n+\t  output_asm_insn (\"ldo R'%2(%%r26),%%r26\", xoperands);\n \t  nbytes += 20;\n \t}\n     }\n@@ -8435,18 +8417,13 @@ pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n     }\n   else if (flag_pic)\n     {\n-      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+      rtx xop[4];\n \n-      if (TARGET_SOM || !TARGET_GAS)\n-\t{\n-\t  output_asm_insn (\"addil L'%0-%1-8,%%r1\", xoperands);\n-\t  output_asm_insn (\"ldo R'%0-%1-8(%%r1),%%r22\", xoperands);\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n-\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r22\", xoperands);\n-\t}\n+      /* Load function address into %r22.  */\n+      xop[0] = xoperands[0];\n+      xop[1] = gen_rtx_REG (Pmode, 1);\n+      xop[2] = gen_rtx_REG (Pmode, 22);\n+      pa_output_pic_pcrel_sequence (xop);\n \n       if (!val_14)\n \toutput_asm_insn (\"addil L'%2,%%r26\", xoperands);"}]}