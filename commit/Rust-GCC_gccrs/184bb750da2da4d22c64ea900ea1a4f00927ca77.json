{"sha": "184bb750da2da4d22c64ea900ea1a4f00927ca77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg0YmI3NTBkYTJkYTRkMjJjNjRlYTkwMGVhMWE0ZjAwOTI3Y2E3Nw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-01-10T20:54:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-10T20:54:37Z"}, "message": "regmove.c: New implementation of regmove pass.\n\n        * regmove.c: New implementation of regmove pass.\n        * local-alloc.c (optimize_reg_copy_1, optimize_reg_copy_2): Remove\n        decls, make them have external linkage.  Return a value from\n        optimize_reg_copy_1.\n        * reload.h (count_occurrences): Add decl.\n        * reload1.c (count_occurrences): Delete decl, make it have external\n        linkage.\n        * rtl.h (optimize_reg_copy_1, optimize_reg_copy_2): Declare.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r17316", "tree": {"sha": "418c1299a8009344c78283c0c866d1a9d9bbd115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/418c1299a8009344c78283c0c866d1a9d9bbd115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/184bb750da2da4d22c64ea900ea1a4f00927ca77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184bb750da2da4d22c64ea900ea1a4f00927ca77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/184bb750da2da4d22c64ea900ea1a4f00927ca77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184bb750da2da4d22c64ea900ea1a4f00927ca77/comments", "author": null, "committer": null, "parents": [{"sha": "9d1943807a48cb47240d612ca4302c1054c4b23a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1943807a48cb47240d612ca4302c1054c4b23a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1943807a48cb47240d612ca4302c1054c4b23a"}], "stats": {"total": 2043, "additions": 1243, "deletions": 800}, "files": [{"sha": "9d04f8350b04df5eb8fffa9b8dfd183b0c9022f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=184bb750da2da4d22c64ea900ea1a4f00927ca77", "patch": "@@ -1,3 +1,15 @@\n+Sat Jan 10 21:50:16 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\t\t\t  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* regmove.c: New implementation of regmove pass.\n+\t* local-alloc.c (optimize_reg_copy_1, optimize_reg_copy_2): Remove\n+\tdecls, make them have external linkage.  Return a value from\n+\toptimize_reg_copy_1.\n+\t* reload.h (count_occurrences): Add decl.\n+\t* reload1.c (count_occurrences): Delete decl, make it have external\n+\tlinkage.\n+\t* rtl.h (optimize_reg_copy_1, optimize_reg_copy_2): Declare.\n+\n Sat Jan 10 20:30:12 1998  Jeffrey A Law  (law@cygnus.com)\n  \n \t* regclass.c (record_address_regs): Don't use REG_OK_FOR_BASE_P"}, {"sha": "7f149d9f7525190ec0343faa6613d32ec8e141f8", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=184bb750da2da4d22c64ea900ea1a4f00927ca77", "patch": "@@ -1,5 +1,5 @@\n /* Allocate registers within a basic block, for GNU compiler.\n-   Copyright (C) 1987, 88, 91, 93-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 93-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -249,8 +249,6 @@ static int validate_equiv_mem\tPROTO((rtx, rtx, rtx));\n static int contains_replace_regs PROTO((rtx, char *));\n static int memref_referenced_p\tPROTO((rtx, rtx));\n static int memref_used_between_p PROTO((rtx, rtx, rtx));\n-static void optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n-static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n static void update_equiv_regs\tPROTO((void));\n static void block_alloc\t\tPROTO((int));\n static int qty_sugg_compare    \tPROTO((int, int));\n@@ -752,7 +750,7 @@ memref_used_between_p (memref, start, end)\n    DEST to be tied to SRC, thus often saving one register in addition to a\n    register-register copy.  */\n \n-static void\n+int\n optimize_reg_copy_1 (insn, dest, src)\n      rtx insn;\n      rtx dest;\n@@ -764,15 +762,15 @@ optimize_reg_copy_1 (insn, dest, src)\n   int sregno = REGNO (src);\n   int dregno = REGNO (dest);\n \n-  /* We don't want to mess with hard regs if register classes are small. */\n   if (sregno == dregno\n+      /* We don't want to mess with hard regs if register classes are small. */\n       || (SMALL_REGISTER_CLASSES\n \t  && (sregno < FIRST_PSEUDO_REGISTER\n \t      || dregno < FIRST_PSEUDO_REGISTER))\n       /* We don't see all updates to SP if they are in an auto-inc memory\n \t reference, so we must disallow this optimization on them.  */\n       || sregno == STACK_POINTER_REGNUM || dregno == STACK_POINTER_REGNUM)\n-    return;\n+    return 0;\n \n   for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n     {\n@@ -864,9 +862,13 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t later.  Make sure ALL of DEST dies here; again, this is\n \t\t overly conservative.  */\n \t      if (dest_death == 0\n-\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0\n-\t\t  && GET_MODE (XEXP (dest_death, 0)) == GET_MODE (dest))\n-\t\tremove_note (q, dest_death);\n+\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0)\n+\t\t{\n+\t\t  if (GET_MODE (XEXP (dest_death, 0)) != GET_MODE (dest))\n+\t\t    failed = 1, dest_death = 0;\n+\t\t  else\n+\t\t    remove_note (q, dest_death);\n+\t\t}\n \t    }\n \n \t  if (! failed)\n@@ -876,7 +878,7 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t  if (REG_LIVE_LENGTH (sregno) >= 0)\n \t\t    {\n \t\t      REG_LIVE_LENGTH (sregno) -= length;\n-\t\t      /* reg_live_length is only an approximation after\n+\t\t      /* REG_LIVE_LENGTH is only an approximation after\n \t\t\t combine if sched is not run, so make sure that we\n \t\t\t still have a reasonable value.  */\n \t\t      if (REG_LIVE_LENGTH (sregno) < 2)\n@@ -907,7 +909,7 @@ optimize_reg_copy_1 (insn, dest, src)\n \t      REG_NOTES (p) = dest_death;\n \t    }\n \n-\t  return;\n+\t  return ! failed;\n \t}\n \n       /* If SRC is a hard register which is set or killed in some other\n@@ -916,6 +918,7 @@ optimize_reg_copy_1 (insn, dest, src)\n \t       && dead_or_set_p (p, src))\n \tbreak;\n     }\n+  return 0;\n }\n \f\n /* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have\n@@ -932,7 +935,7 @@ optimize_reg_copy_1 (insn, dest, src)\n    It is assumed that DEST and SRC are pseudos; it is too complicated to do\n    this for hard registers since the substitutions we may make might fail.  */\n \n-static void\n+void\n optimize_reg_copy_2 (insn, dest, src)\n      rtx insn;\n      rtx dest;"}, {"sha": "d6d78d291213ab883ec933d0e52f90fbd23e6bec", "filename": "gcc/regmove.c", "status": "modified", "additions": 1206, "deletions": 782, "changes": 1988, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=184bb750da2da4d22c64ea900ea1a4f00927ca77", "patch": "@@ -1,5 +1,5 @@\n /* Move registers around to reduce number of move instructions needed.\n-   Copyright (C) 1987, 88, 89, 92-5, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -39,11 +39,38 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"output.h\"\n #include \"reload.h\"\n #include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"insn-flags.h\"\n+\n+#ifndef REG_N_CALLS_CROSSED\n+#define REG_N_CALLS_CROSSED(x) (reg_n_calls_crossed[(x)])\n+#define REG_N_SETS(x) (reg_n_sets[(x)])\n+#define REG_N_REFS(x) (reg_n_refs[(x)])\n+#define REG_N_DEATHS(x) (reg_n_deaths[(x)])\n+#define REG_LIVE_LENGTH(x) (reg_live_length[(x)])\n+#endif\n+\n+static void optimize_reg_copy_3\tPROTO((rtx, rtx, rtx));\n \n+extern int flag_regmove;\n+\n+struct match {\n+  int with[MAX_RECOG_OPERANDS];\n+  enum { READ, WRITE, READWRITE } use[MAX_RECOG_OPERANDS];\n+  int commutative[MAX_RECOG_OPERANDS];\n+  int early_clobber[MAX_RECOG_OPERANDS];\n+};\n+\n+static int find_matches PROTO((rtx, struct match *));\n+static int fixup_match_1 PROTO((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n+;\n+static int reg_is_remote_constant_p PROTO((rtx, rtx, rtx));\n static int stable_but_for_p PROTO((rtx, rtx, rtx));\n+static int loop_depth;\n \n-#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT) \\\n-    || defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+#ifdef AUTO_INC_DEC\n \n /* INC_INSN is an instruction that adds INCREMENT to REG.\n    Try to fold INC_INSN as a post/pre in/decrement into INSN.\n@@ -79,617 +106,486 @@ try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n #ifdef HAVE_PRE_DECREMENT\n \t      || (pre == 1 && (inc_code = PRE_DEC, increment == -size))\n #endif\n-          )\n-            {\n-              if (inc_insn_set)\n-                validate_change\n-                  (inc_insn, \n-                   &SET_SRC (inc_insn_set),\n+\t  )\n+\t    {\n+\t      if (inc_insn_set)\n+\t\tvalidate_change\n+\t\t  (inc_insn, \n+\t\t   &SET_SRC (inc_insn_set),\n \t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n-              validate_change (insn, &XEXP (use, 0),\n-                               gen_rtx (inc_code,\n-                                        Pmode,\n-                                        reg), 1);\n-              if (apply_change_group ())\n-                {\n-                  REG_NOTES (insn)\n-                    = gen_rtx (EXPR_LIST, REG_INC,\n-                               reg, REG_NOTES (insn));\n-                  if (! inc_insn_set)\n-                    {\n-                      PUT_CODE (inc_insn, NOTE);\n-                      NOTE_LINE_NUMBER (inc_insn) = NOTE_INSN_DELETED;\n-                      NOTE_SOURCE_FILE (inc_insn) = 0;\n-                    }\n+\t      validate_change (insn, &XEXP (use, 0),\n+\t\t\t       gen_rtx (inc_code,\n+\t\t\t\t\tPmode,\n+\t\t\t\t\treg), 1);\n+\t      if (apply_change_group ())\n+\t\t{\n+\t\t  REG_NOTES (insn)\n+\t\t    = gen_rtx (EXPR_LIST, REG_INC,\n+\t\t\t       reg, REG_NOTES (insn));\n+\t\t  if (! inc_insn_set)\n+\t\t    {\n+\t\t      PUT_CODE (inc_insn, NOTE);\n+\t\t      NOTE_LINE_NUMBER (inc_insn) = NOTE_INSN_DELETED;\n+\t\t      NOTE_SOURCE_FILE (inc_insn) = 0;\n+\t\t    }\n \t\t  return 1;\n-                }\n-            }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+#endif  /* AUTO_INC_DEC */\n+\n+static int *regno_src_regno;\n+\n+/* Indicate how good a choice REG (which appears as a source) is to replace\n+   a destination register with.  The higher the returned value, the better\n+   the choice.  The main objective is to avoid using a register that is\n+   a candidate for tying to a hard register, since the output might in\n+   turn be a candidate to be tied to a different hard register.  */\n+int\n+replacement_quality(reg)\n+     rtx reg;\n+{\n+  int src_regno;\n+\n+  /* Bad if this isn't a register at all.  */\n+  if (GET_CODE (reg) != REG)\n+    return 0;\n+\n+  /* If this register is not meant to get a hard register,\n+     it is a poor choice.  */\n+  if (REG_LIVE_LENGTH (REGNO (reg)) < 0)\n+    return 0;\n+\n+  src_regno = regno_src_regno[REGNO (reg)];\n+\n+  /* If it was not copied from another register, it is fine.  */\n+  if (src_regno < 0)\n+    return 3;\n+\n+  /* Copied from a hard register?  */\n+  if (src_regno < FIRST_PSEUDO_REGISTER)\n+    return 1;\n+\n+  /* Copied from a pseudo register - not as bad as from a hard register,\n+     yet still cumbersome, since the register live length will be lengthened\n+     when the registers get tied.  */\n+  return 2;\n+}\n+\n+/* INSN is a ZERO_EXTEND or SIGN_EXTEND of SRC to DEST.\n+   Look if SRC dies there, and if it is only set once, by loading\n+   it from memory.  If so, try to encorporate the zero/sign extension\n+   into the memory read, change SRC to the mode of DEST, and alter\n+   the remaining accesses to use the appropriate SUBREG.  This allows\n+   SRC and DEST to be tied later.  */\n+static void\n+optimize_reg_copy_3 (insn, dest, src)\n+     rtx insn;\n+     rtx dest;\n+     rtx src;\n+{\n+  rtx src_reg = XEXP (src, 0);\n+  int src_no = REGNO (src_reg);\n+  int dst_no = REGNO (dest);\n+  rtx p, set, subreg;\n+  enum machine_mode old_mode;\n+\n+  if (src_no < FIRST_PSEUDO_REGISTER\n+      || dst_no < FIRST_PSEUDO_REGISTER\n+      || ! find_reg_note (insn, REG_DEAD, src_reg)\n+      || REG_N_SETS (src_no) != 1)\n+    return;\n+  for (p = PREV_INSN (insn); ! reg_set_p (src_reg, p); p = PREV_INSN (p))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+      if (GET_CODE (p) == JUMP_INSN)\n+\treturn;\n+    }\n+  if (! (set = single_set (p))\n+      || GET_CODE (SET_SRC (set)) != MEM\n+      || SET_DEST (set) != src_reg)\n+    return;\n+  old_mode = GET_MODE (src_reg);\n+  PUT_MODE (src_reg, GET_MODE (src));\n+  XEXP (src, 0) = SET_SRC (set);\n+  if (! validate_change (p, &SET_SRC (set), src, 0))\n+    {\n+      PUT_MODE (src_reg, old_mode);\n+      XEXP (src, 0) = src_reg;\n+      return;\n+    }\n+  subreg = gen_rtx(SUBREG, old_mode, src_reg, 0);\n+  while (p = NEXT_INSN (p), p != insn)\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+      validate_replace_rtx (src_reg, subreg, p);\n+    }\n+  validate_replace_rtx (src, src_reg, insn);\n+}\n+\n+/* Return whether REG is set in only one location, and is set to a\n+   constant, but is set in a different basic block from INSN (an\n+   instructions which uses REG).  In this case REG is equivalent to a\n+   constant, and we don't want to break that equivalence, because that\n+   may increase register pressure and make reload harder.  If REG is\n+   set in the same basic block as INSN, we don't worry about it,\n+   because we'll probably need a register anyhow (??? but what if REG\n+   is used in a different basic block as well as this one?).  FIRST is\n+   the first insn in the function.  */\n+\n+static int\n+reg_is_remote_constant_p (reg, insn, first)\n+     rtx reg;\n+     rtx insn;\n+     rtx first;\n+{\n+  register rtx p;\n+\n+  if (REG_N_SETS (REGNO (reg)) != 1)\n+    return 0;\n+\n+  /* Look for the set.  */\n+  for (p = LOG_LINKS (insn); p; p = XEXP (p, 1))\n+    {\n+      rtx s;\n+\n+      if (REG_NOTE_KIND (p) != 0)\n+\tcontinue;\n+      s = single_set (XEXP (p, 0));\n+      if (s != 0\n+\t  && GET_CODE (SET_DEST (s)) == REG\n+\t  && REGNO (SET_DEST (s)) == REGNO (reg))\n+\t{\n+\t  /* The register is set in the same basic block.  */\n+\t  return 0;\n+\t}\n+    }\n+\n+  for (p = first; p && p != insn; p = NEXT_INSN (p))\n+    {\n+      rtx s;\n+\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+      s = single_set (p);\n+      if (s != 0\n+\t  && GET_CODE (SET_DEST (s)) == REG\n+\t  && REGNO (SET_DEST (s)) == REGNO (reg))\n+\t{\n+\t  /* This is the instruction which sets REG.  If there is a\n+             REG_EQUAL note, then REG is equivalent to a constant.  */\n+\t  if (find_reg_note (p, REG_EQUAL, NULL_RTX))\n+\t    return 1;\n+\t  return 0;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* cse disrupts preincrement / postdecrement squences when it finds a\n+   hard register as ultimate source, like the frame pointer.  */\n+int fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n+     rtx insn, dst, src, offset;\n+     FILE *regmove_dump_file;\n+{\n+  rtx p, dst_death = 0;\n+  int length, num_calls = 0;\n+\n+  /* If SRC dies in INSN, we'd have to move the death note.  This is\n+     considered to be very unlikely, so we just skip the optimization\n+     in this case.  */\n+  if (find_regno_note (insn, REG_DEAD, REGNO (src)))\n+    return 0;\n+\n+  /* Scan backward to find the first instruction that sets DST.  */\n+\n+  for (length = 0, p = PREV_INSN (insn); p; p = PREV_INSN (p))\n+    {\n+      rtx pset;\n+\n+      if (GET_CODE (p) == CODE_LABEL\n+          || GET_CODE (p) == JUMP_INSN\n+          || (GET_CODE (p) == NOTE\n+              && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+                  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+        break;\n+\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+        continue;\n+\n+  if (find_regno_note (p, REG_DEAD, REGNO (dst)))\n+    dst_death = p;\n+  if (! dst_death)\n+    length++;\n+\n+      pset = single_set (p);\n+      if (pset && SET_DEST (pset) == dst\n+\t  && GET_CODE (SET_SRC (pset)) == PLUS\n+\t  && XEXP (SET_SRC (pset), 0) == src\n+\t  && GET_CODE (XEXP (SET_SRC (pset), 1)) == CONST_INT)\n+        {\n+\t  HOST_WIDE_INT newconst\n+\t    = INTVAL (offset) - INTVAL (XEXP (SET_SRC (pset), 1));\n+\t  if (validate_change (insn, &PATTERN (insn),\n+\t\t\t       gen_addsi3 (dst, dst, GEN_INT (newconst)), 0))\n+\t    {\n+\t      /* Remove the death note for DST from DST_DEATH.  */\n+\t      if (dst_death)\n+\t\t{\n+\t\t  remove_death (REGNO (dst), dst_death);\n+\t\t  REG_LIVE_LENGTH (REGNO (dst)) += length;\n+\t\t  REG_N_CALLS_CROSSED (REGNO (dst)) += num_calls;\n+\t\t}\n+\n+\t      REG_N_REFS (REGNO (dst)) += loop_depth;\n+\t      REG_N_REFS (REGNO (src)) -= loop_depth;\n+\n+\t      if (regmove_dump_file)\n+\t\tfprintf (regmove_dump_file,\n+\t\t\t \"Fixed operand of insn %d.\\n\",\n+\t\t\t  INSN_UID (insn));\n+\n+#ifdef AUTO_INC_DEC\n+\t      for (p = PREV_INSN (insn); p; p = PREV_INSN (p))\n+\t\t{\n+\t\t  if (GET_CODE (p) == CODE_LABEL\n+\t\t      || GET_CODE (p) == JUMP_INSN\n+\t\t      || (GET_CODE (p) == NOTE\n+\t\t\t  && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t\t      || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\t\t    break;\n+\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n+\t\t    {\n+\t\t      if (try_auto_increment (p, insn, 0, dst, newconst, 0))\n+\t\t\treturn 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+\t\t{\n+\t\t  if (GET_CODE (p) == CODE_LABEL\n+\t\t      || GET_CODE (p) == JUMP_INSN\n+\t\t      || (GET_CODE (p) == NOTE\n+\t\t\t  && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t\t      || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\t\t    break;\n+\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n+\t\t    {\n+\t\t      try_auto_increment (p, insn, 0, dst, newconst, 1);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+#endif\n+\t      return 1;\n+\t    }\n         }\n+\n+      if (reg_set_p (dst, PATTERN (p)))\n+        break;\n+\n+      /* If we have passed a call instruction, and the\n+         pseudo-reg SRC is not already live across a call,\n+         then don't perform the optimization.  */\n+      /* reg_set_p is overly conservative for CALL_INSNS, thinks that all\n+\t hard regs are clobbered.  Thus, we only use it for src for\n+\t non-call insns.  */\n+      if (GET_CODE (p) == CALL_INSN)\n+        {\n+\t  if (! dst_death)\n+\t    num_calls++;\n+\n+          if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n+            break;\n+\n+\t  if (call_used_regs [REGNO (dst)]\n+\t      || find_reg_fusage (p, CLOBBER, dst))\n+\t    break;\n+        }\n+      else if (reg_set_p (src, PATTERN (p)))\n+        break;\n     }\n+\n   return 0;\n }\n-#endif  /* defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT) */\n \n void\n regmove_optimize (f, nregs, regmove_dump_file)\n      rtx f;\n      int nregs;\n      FILE *regmove_dump_file;\n {\n-#ifdef REGISTER_CONSTRAINTS\n   rtx insn;\n-  int matches[MAX_RECOG_OPERANDS][MAX_RECOG_OPERANDS];\n-  int modified[MAX_RECOG_OPERANDS];\n-  int early_clobber[MAX_RECOG_OPERANDS];\n-  int commutative;\n+  struct match match;\n   int pass;\n+  int maxregnum = max_reg_num (), i;\n+\n+  regno_src_regno = (int *)alloca (sizeof *regno_src_regno * maxregnum);\n+  for (i = maxregnum; --i >= 0; ) regno_src_regno[i] = -1;\n \n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n-  for (pass = 0; pass < 2; pass++)\n+  loop_depth = 1;\n+\n+  for (pass = 0; pass <= 2; pass++)\n     {\n+      if (! flag_regmove && pass >= flag_expensive_optimizations)\n+\treturn;\n+\n       if (regmove_dump_file)\n \tfprintf (regmove_dump_file, \"Starting %s pass...\\n\",\n \t\t pass ? \"backward\" : \"forward\");\n \n       for (insn = pass ? get_last_insn () : f; insn;\n \t   insn = pass ? PREV_INSN (insn) : NEXT_INSN (insn))\n \t{\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t  rtx set;\n+\t  int insn_code_number;\n+\t  int operand_number, match_number;\n+\n+\t  if (GET_CODE (insn) == NOTE)\n \t    {\n-\t      int insn_code_number = recog_memoized (insn);\n-\t      int operand_number, match_number;\n-\t      \n-\t      if (insn_code_number < 0)\n-\t\tcontinue;\n-    \n-\t      insn_extract (insn);\n-\t      if (! constrain_operands (insn_code_number, 0))\n-\t\tcontinue;\n-\t      \n-\t      commutative = -1;\n-    \n-\t      /* Must initialize this before the loop, because the code for\n-\t\t the commutative case may set matches for operands other than\n-\t\t the current one.  */\n-\t      bzero ((char *)matches, sizeof (matches));\n-    \n-\t      for (operand_number = 0;\n-\t\t   operand_number < insn_n_operands[insn_code_number];\n-\t\t   operand_number++)\n-\t\t{\n-\t\t  int output_operand = 0;\n-\t\t  int matching_operand = operand_number;\n-\t\t  char *p, c;\n-\t\t  int i = 0;\n-    \n-\t\t  modified[operand_number] = 0;\n-\t\t  early_clobber[operand_number] = 0;\n-    \n-\t\t  p = insn_operand_constraint[insn_code_number][operand_number];\n+\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t\tloop_depth++;\n+\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t\tloop_depth--;\n+\t    }\n \n-\t\t  if (*p == '=')\n-\t\t    modified[operand_number] = 2;\n-\t\t  else if (*p == '+')\n-\t\t    modified[operand_number] = 1;\n+\t  set = single_set (insn);\n+\t  if (! set)\n+\t    continue;\n \n-\t\t  for (;*p && i < which_alternative; p++)\n-\t\t    if (*p == ',')\n-\t\t      i++;\n-    \n-\t\t  while ((c = *p++) != '\\0' && c != ',')\n-\t\t    switch (c)\n-\t\t      {\n-\t\t      case '=':\n-\t\t\tbreak;\n-\t\t      case '+':\n-\t\t\tbreak;\n-\t\t      case '&':\n-\t\t\tearly_clobber[operand_number] = 1;\n-\t\t\tbreak;\n-\t\t      case '%':\n-\t\t\tcommutative = operand_number;\n-\t\t\tbreak;\n-\t\t      case '0': case '1': case '2': case '3': case '4':\n-\t\t      case '5': case '6': case '7': case '8': case '9':\n-\t\t\tc -= '0';\n-\t\t\tmatches[operand_number][c] = 1;\n-\t\t\tif (commutative >= 0)\n-\t\t\t  {\n-\t\t\t    if (c == commutative || c == commutative + 1)\n-\t\t\t      {\n-\t\t\t\tint other = c + (c == commutative ? 1 : -1);\n-\t\t\t\tmatches[operand_number][other] = 1;\n-\t\t\t      }\n-\t\t\t    if (operand_number == commutative\n-\t\t\t\t|| operand_number == commutative + 1)\n-\t\t\t      {\n-\t\t\t\tint other = (operand_number\n-\t\t\t\t\t     + (operand_number == commutative\n-\t\t\t\t\t\t? 1 : -1));\n-\t\t\t\tmatches[other][c] = 1;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\tbreak;\n-\t\t      }\n-\t\t}\n-    \n-\t      /* Now scan through the operands looking for a source operand\n-\t\t which is supposed to match the destination operand.\n-\t\t Then scan forward for an instruction which uses the dest\n-\t\t operand.\n-\t\t If it dies there, then replace the dest in both operands with\n-\t\t the source operand.  */\n-    \n-\t      for (operand_number = 0;\n-\t\t   operand_number < insn_n_operands[insn_code_number];\n-\t\t   operand_number++)\n+\t  if (flag_expensive_optimizations && ! pass\n+\t      && (GET_CODE (SET_SRC (set)) == SIGN_EXTEND\n+\t\t  || GET_CODE (SET_SRC (set)) == ZERO_EXTEND)\n+\t      && GET_CODE (XEXP (SET_SRC (set), 0)) == REG\n+\t      && GET_CODE (SET_DEST(set)) == REG)\n+\t    optimize_reg_copy_3 (insn, SET_DEST (set), SET_SRC (set));\n+\n+\t  if (flag_expensive_optimizations && ! pass\n+\t      && GET_CODE (SET_SRC (set)) == REG\n+\t      && GET_CODE (SET_DEST(set)) == REG)\n+\t    {\n+\t      /* If this is a register-register copy where SRC is not dead,\n+\t\t see if we can optimize it.  If this optimization succeeds,\n+\t\t it will become a copy where SRC is dead.  */\n+\t      if ((find_reg_note (insn, REG_DEAD, SET_SRC (set))\n+\t\t   || optimize_reg_copy_1 (insn, SET_DEST (set), SET_SRC (set)))\n+\t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  for (match_number = 0;\n-\t\t       match_number < insn_n_operands[insn_code_number];\n-\t\t       match_number++)\n+\t\t  /* Similarly for a pseudo-pseudo copy when SRC is dead.  */\n+\t\t  if (REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER)\n+\t\t    optimize_reg_copy_2 (insn, SET_DEST (set), SET_SRC (set));\n+\t\t  if (regno_src_regno[REGNO (SET_DEST (set))] < 0\n+\t\t      && SET_SRC (set) != SET_DEST (set))\n \t\t    {\n-\t\t      rtx set, p, src, dst, src_subreg;\n-\t\t      rtx post_inc = 0, post_inc_set = 0, search_end = 0;\n-\t\t      rtx src_note, dst_note;\n-\t\t      int success = 0;\n-\t\t      int num_calls = 0;\n-\t\t      enum rtx_code code = NOTE;\n-\t\t      HOST_WIDE_INT insn_const, newconst;\n-\t\t      rtx overlap = 0; /* need to move insn ? */\n-    \n-\t\t      /* Nothing to do if the two operands aren't supposed to\n-\t\t\t match.  */\n-\t\t      if (matches[operand_number][match_number] == 0)\n-\t\t\tcontinue;\n-    \n-\t\t      src = recog_operand[operand_number];\n-\t\t      dst = recog_operand[match_number];\n-    \n-\t\t      if (GET_CODE (src) != REG\n-\t\t\t  || REGNO (src) < FIRST_PSEUDO_REGISTER)\n-\t\t\tcontinue;\n-    \n-\t\t      src_subreg = src;\n-\t\t      if (GET_CODE (dst) == SUBREG\n-\t\t\t  && GET_MODE_SIZE (GET_MODE (dst))\n-\t\t\t     >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dst))))\n-\t\t\t{\n-\t\t\t  src_subreg\n-\t\t\t    = gen_rtx(SUBREG,  GET_MODE (SUBREG_REG (dst)),\n-\t\t\t\t      src, SUBREG_WORD (dst));\n-\t\t\t  dst = SUBREG_REG (dst);\n-\t\t\t}\n-\t\t      if (GET_CODE (dst) != REG\n-\t\t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n-\t\t\tcontinue;\n-    \n-\t\t      /* If the operands already match, then there is nothing\n-\t\t\t to do.  */\n-\t\t      if (operands_match_p (src, dst))\n-\t\t\tcontinue;\n-    \n-\t\t      set = single_set (insn);\n-\t\t      if (! set)\n-\t\t\tcontinue;\n-    \n-\t\t      /* operand_number/src must be a read-only operand, and\n-\t\t\t match_operand/dst must be a write-only operand.  */\n-\t\t      if (modified[match_number] != 2)\n-\t\t\tcontinue;\n-    \n-\t\t      if (early_clobber[match_number] == 1)\n-\t\t\tcontinue;\n-    \n-\t\t      if (modified[operand_number] != 0)\n-\t\t\tcontinue;\n-    \n-\t\t      /* Make sure match_operand is the destination.  */\n-\t\t      if (recog_operand[match_number] != SET_DEST (set))\n-\t\t\tcontinue;\n-\t\t  \n-\t\t      src_note = find_reg_note (insn, REG_DEAD, src);\n-    \n-\t\t      if (! src_note)\n-\t\t\t{\n-\t\t\t  /* Look for (set (regX) (op regA constX))\n-\t\t\t\t      (set (regY) (op regA constY))\n-\t\t\t     and change that to\n-\t\t\t\t      (set (regA) (op regA constX)).\n-\t\t\t\t      (set (regY) (op regA constY-constX)).\n-\t\t\t     This works for add and shift operations, if\n-\t\t\t     regA is dead after or set by the second insn.  */\n-\n-\t\t\t  code = GET_CODE (SET_SRC (set));\n-\t\t\t  if ((code == PLUS || code == LSHIFTRT\n-\t\t\t       || code == ASHIFT || code == ASHIFTRT)\n-\t\t\t      && XEXP (SET_SRC (set), 0) == src\n-\t\t\t      && (GET_CODE (XEXP (SET_SRC (set), 1))\n-\t\t\t\t  == CONST_INT))\n-\t\t\t    insn_const = INTVAL (XEXP (SET_SRC (set), 1));\n-\t\t\t  else if (! stable_but_for_p (SET_SRC (set), src, dst))\n-\t\t\t    continue;\n-\t\t\t  else\n-\t\t\t    /* We might find a src_note while scanning.  */\n-\t\t\t    code = NOTE;\n-\t\t\t}\n-\n-\t\t      if (regmove_dump_file)\n-\t\t\tfprintf (regmove_dump_file,\n-\t\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t\t operand_number, INSN_UID (insn), match_number);\n-    \n-\t\t      /* ??? If src is set once, and is set equal to a\n-\t\t\t constant, then do not use it for this optimization,\n-\t\t\t as this would make it no longer equivalent to a\n-\t\t\t constant?  */\n-    \n-\t\t      /* Scan forward to find the next instruction that\n-\t\t\t uses the output operand.  If the operand dies here,\n-\t\t\t then replace it in both instructions with\n-\t\t\t operand_number.  */\n-    \n-\t\t      for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n-\t\t\t{\n-\t\t\t  if (GET_CODE (p) == CODE_LABEL\n-\t\t\t      || GET_CODE (p) == JUMP_INSN\n-\t\t\t      || (GET_CODE (p) == NOTE\n-\t\t\t\t  && ((NOTE_LINE_NUMBER (p)\n-\t\t\t\t       == NOTE_INSN_LOOP_BEG)\n-\t\t\t\t      || (NOTE_LINE_NUMBER (p)\n-\t\t\t\t\t  == NOTE_INSN_LOOP_END))))\n-\t\t\t    break;\n-    \n-\t\t\t  if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n-\t\t\t    continue;\n-    \n-\t\t\t  if (reg_set_p (src, p) || reg_set_p (dst, p)\n-\t\t\t      || (GET_CODE (PATTERN (p)) == USE\n-\t\t\t\t  && reg_overlap_mentioned_p (src,\n-\t\t\t\t\t\t\t      XEXP (PATTERN (p),\n-\t\t\t\t\t\t\t      0))))\n-\t\t\t    break;\n-    \n-\t\t\t  /* See if all of DST dies in P.  This test is\n-\t\t\t     slightly more conservative than it needs to be.  */\n-\t\t\t  if ((dst_note\n-\t\t\t\t= find_regno_note (p, REG_DEAD, REGNO (dst)))\n-\t\t\t      && (GET_MODE (XEXP (dst_note, 0))\n-\t\t\t\t  == GET_MODE (dst)))\n-\t\t\t    {\n-\t\t\t      if (! src_note)\n-\t\t\t\t{\n-\t\t\t\t  rtx q;\n-\t\t\t\t  rtx set2;\n-    \n-\t\t\t\t  /* If an optimization is done, the value\n-\t\t\t\t     of SRC while P is executed will be\n-\t\t\t\t     changed.  Check that this is OK.  */\n-\t\t\t\t  if (reg_overlap_mentioned_p (src,\n-\t\t\t\t\t\t\t       PATTERN (p)))\n-\t\t\t\t    break;\n-\t\t\t\t  for (q = p; q; q = NEXT_INSN (q))\n-\t\t\t\t    {\n-\t\t\t\t      if (GET_CODE (q) == CODE_LABEL\n-\t\t\t\t\t  || GET_CODE (q) == JUMP_INSN\n-\t\t\t\t\t  || (GET_CODE (q) == NOTE\n-\t\t\t\t\t      && ((NOTE_LINE_NUMBER (q)\n-\t\t\t\t\t\t   == NOTE_INSN_LOOP_BEG)\n-\t\t\t\t\t\t  || (NOTE_LINE_NUMBER (q)\n-\t\t\t\t\t\t      == NOTE_INSN_LOOP_END))))\n-\t\t\t\t\t{\n-\t\t\t\t\t  q = 0;\n-\t\t\t\t\t  break;\n-\t\t\t\t\t}\n-\t\t\t\t      if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n-\t\t\t\t\tcontinue;\n-\t\t\t\t      if (reg_overlap_mentioned_p (src,\n-\t\t\t\t\t\t\t\t   PATTERN (q))\n-\t\t\t\t\t  || reg_set_p (src, q))\n-\t\t\t\t\tbreak;\n-\t\t\t\t    }\n-\t\t\t\t  if (q)\n-\t\t\t\t    set2 = single_set (q);\n-\t\t\t\t  if (! q || ! set2\n-\t\t\t\t      || GET_CODE (SET_SRC (set2)) != code\n-\t\t\t\t      || XEXP (SET_SRC (set2), 0) != src\n-\t\t\t\t      || (GET_CODE (XEXP (SET_SRC (set2), 1))\n-\t\t\t\t\t  != CONST_INT)\n-\t\t\t\t      || (SET_DEST (set2) != src\n-\t\t\t\t\t  && !find_reg_note (q, REG_DEAD, src)))\n-\t\t\t\t    {\n-\t\t\t\t      /* If this is a PLUS, we can still save\n-\t\t\t\t\t a register by doing\n-\t\t\t\t\t src += insn_const;\n-\t\t\t\t\t P;\n-\t\t\t\t\t src -= insn_const; .\n-\t\t\t\t\t This also gives opportunities for\n-\t\t\t\t\t subsequent optimizations in the\n-\t\t\t\t\t backward pass, so do it there.  */\n-\t\t\t\t      if (code == PLUS && pass == 1\n-#ifdef HAVE_cc0\n-\t\t\t\t\t  /* We man not emit an insn directly\n-\t\t\t\t\t     after P if the latter sets CC0.  */\n-\t\t\t\t\t  && ! sets_cc0_p (PATTERN (p))\n-#endif\n-\t\t\t\t\t  )\n-\n-\t\t\t\t\t{\n-\t\t\t\t\t  search_end = q;\n-\t\t\t\t\t  q = insn;\n-\t\t\t\t\t  set2 = set;\n-\t\t\t\t\t  newconst = -insn_const;\n-\t\t\t\t\t  code = MINUS;\n-\t\t\t\t\t}\n-\t\t\t\t      else\n-\t\t\t\t\tbreak;\n-\t\t\t\t    }\n-\t\t\t\t  else\n-\t\t\t\t    {\n-\t\t\t\t      newconst\n-\t\t\t\t\t= (INTVAL (XEXP (SET_SRC (set2), 1))\n-\t\t\t\t\t   - insn_const);\n-\t\t\t\t      /* Reject out of range shifts.  */\n-\t\t\t\t      if (code != PLUS\n-\t\t\t\t\t  && (newconst < 0\n-\t\t\t\t\t      || (newconst\n-\t\t\t\t\t\t  >= GET_MODE_BITSIZE (GET_MODE (SET_SRC (set2))))))\n-\t\t\t\t\tbreak;\n-\t\t\t\t      if (code == PLUS)\n-\t\t\t\t\t{\n-\t\t\t\t\t  post_inc = q;\n-\t\t\t\t\t  if (SET_DEST (set2) != src)\n-\t\t\t\t\t    post_inc_set = set2;\n-\t\t\t\t\t}\n-\t\t\t\t    }\n-\t\t\t\t  /* We use 1 as last argument to\n-\t\t\t\t     validate_change so that all changes\n-\t\t\t\t     are accepted or rejected together by\n-\t\t\t\t     apply_change_group when it is called\n-\t\t\t\t     by validate_replace_rtx .  */\n-\t\t\t\t  validate_change (q, &XEXP (SET_SRC (set2), 1),\n-\t\t\t\t\t\t   GEN_INT (newconst), 1);\n-\t\t\t\t}\n-\t\t\t      validate_change (insn,\n-\t\t\t\t\t       recog_operand_loc[match_number],\n-\t\t\t\t\t       src, 1);\n-\t\t\t      if (validate_replace_rtx (dst, src_subreg, p))\n-\t\t\t\tsuccess = 1;\n-\t\t\t      break;\n-\t\t\t    }\n-    \n-\t\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n-\t\t\t    break;\n-\t\t\t  if (! src_note\n-\t\t\t      && reg_overlap_mentioned_p (src, PATTERN (p)))\n-\t\t\t    {\n-\t\t\t      /* INSN was already checked to be movable when\n-\t\t\t\t we found no REG_DEAD note for src on it.  */\n-\t\t\t      overlap = p;\n-\t\t\t      src_note = find_reg_note (p, REG_DEAD, src);\n-\t\t\t    }\n-    \n-\t\t\t  /* If we have passed a call instruction, and the\n-\t\t\t     pseudo-reg SRC is not already live across a call,\n-\t\t\t     then don't perform the optimization.  */\n-\t\t\t  if (GET_CODE (p) == CALL_INSN)\n-\t\t\t    {\n-\t\t\t      num_calls++;\n-    \n-\t\t\t      if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t}\n-    \n-\t\t      if (success)\n-\t\t\t{\n-\t\t\t  /* Remove the death note for DST from P.  */\n-\t\t\t  remove_note (p, dst_note);\n-\t\t\t  if (code == MINUS)\n-\t\t\t    {\n-\t\t\t      post_inc\n-\t\t\t\t= emit_insn_after (copy_rtx (PATTERN (insn)),\n-\t\t\t\t\t\t   p);\n-#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n-\t\t\t      if (search_end\n-\t\t\t\t  && try_auto_increment (search_end, post_inc,\n-\t\t\t\t\t\t\t 0, src, newconst, 1))\n-\t\t\t\tpost_inc = 0;\n-#endif\n-\t\t\t      validate_change (insn, &XEXP (SET_SRC (set), 1),\n-\t\t\t\t\t       GEN_INT (insn_const), 0);\n-\t\t\t      REG_N_SETS (REGNO (src))++;\n-\t\t\t    }\n-\t\t\t  if (overlap)\n-\t\t\t    {\n-\t\t\t      /* The lifetime of src and dest overlap,\n-\t\t\t\t but we can change this by moving insn.  */\n-\t\t\t      rtx pat = PATTERN (insn);\n-\t\t\t      if (src_note)\n-\t\t\t\tremove_note (overlap, src_note);\n-#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT)\n-\t\t\t      if (code == PLUS\n-\t\t\t\t  && try_auto_increment (overlap, insn, 0,\n-\t\t\t\t\t\t\t src, insn_const, 0))\n-\t\t\t\tinsn = overlap;\n-\t\t\t      else\n-#endif\n-\t\t\t\t{\n-\t\t\t\t  rtx notes = REG_NOTES (insn);\n-\n-\t\t\t\t  emit_insn_after_with_line_notes\n-\t\t\t\t    (pat, PREV_INSN (p), insn);\n-\t\t\t\t  PUT_CODE (insn, NOTE);\n-\t\t\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t\t\t  /* emit_insn_after_with_line_notes\n-\t\t\t\t     has no return value, so search\n-\t\t\t\t     for the new insn.  */\n-\t\t\t\t  for (insn = p; PATTERN (insn) != pat; )\n-\t\t\t\t    insn = PREV_INSN (insn);\n-\n-\t\t\t\t  REG_NOTES (insn) = notes;\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t  /* Sometimes we'd generate src = const; src += n;\n-\t\t\t     if so, replace the instruction that set src\n-\t\t\t     in the first place.  */\n-\t\t\t\n-\t\t\t  if (! overlap && (code == PLUS || code == MINUS))\n-\t\t\t    {\n-\t\t\t      rtx note\n-\t\t\t\t= find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\t\t\t      rtx q, set2;\n-\t\t\t      int num_calls2 = 0;\n-\n-\t\t\t      if (note && CONSTANT_P (XEXP (note, 0)))\n-\t\t\t\t{\n-\t\t\t\t  for (q = PREV_INSN (insn); q;\n-\t\t\t\t       q = PREV_INSN(q))\n-\t\t\t\t    {\n-\t\t\t\t      if (GET_CODE (q) == JUMP_INSN)\n-\t\t\t\t\t{\n-\t\t\t\t\t  q = 0;\n-\t\t\t\t\t  break;\n-\t\t\t\t\t}\n-\t\t\t\t      if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n-\t\t\t\t\tcontinue;\n-\t\t\t\t      if (reg_set_p (src, q))\n-\t\t\t\t\t{\n-\t\t\t\t\t  set2 = single_set (q);\n-\t\t\t\t\t  break;\n-\t\t\t\t\t}\n-\t\t\t\t      if (reg_overlap_mentioned_p (src,\n-\t\t\t\t\t  PATTERN (q)))\n-\t\t\t\t\t{\n-\t\t\t\t\t  q = 0;\n-\t\t\t\t\t  break;\n-\t\t\t\t\t}\n-\t\t\t\t      if (GET_CODE (p) == CALL_INSN)\n-\t\t\t\t\tnum_calls2++;\n-\t\t\t\t    }\n-\t\t\t\t  if (q && set2 && SET_DEST (set2) == src\n-\t\t\t\t      && CONSTANT_P (SET_SRC (set2))\n-\t\t\t\t      && validate_change (insn, &SET_SRC (set),\n-\t\t\t\t\t\t\t  XEXP (note, 0), 0))\n-\t\t\t\t    {\n-\t\t\t\t      PUT_CODE (q, NOTE);\n-\t\t\t\t      NOTE_LINE_NUMBER (q) = NOTE_INSN_DELETED;\n-\t\t\t\t      NOTE_SOURCE_FILE (q) = 0;\n-\t\t\t\t      REG_N_SETS (REGNO (src))--;\n-\t\t\t\t      REG_N_CALLS_CROSSED (REGNO (src))\n-\t\t\t\t\t-= num_calls2;\n-\t\t\t\t      insn_const = 0;\n-\t\t\t\t    }\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t  if (0) ;\n-#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n-\t\t\t  else if ((code == PLUS || code == MINUS)\n-\t\t\t\t   && insn_const\n-\t\t\t\t   && try_auto_increment (p, insn, 0,\n-\t\t\t\t\t\t\t  src, insn_const, 1))\n-\t\t\t    insn = p;\n-#endif\n-#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT)\n-\t\t\t  else if (post_inc\n-\t\t\t\t   && try_auto_increment (p, post_inc,\n-\t\t\t\t\t\t\t  post_inc_set, src,\n-\t\t\t\t\t\t\t  newconst, 0))\n-\t\t\t    post_inc = 0;\n-#endif\n-#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n-\t\t\t  /* If post_inc still prevails, try to find an\n-\t\t\t     insn where it can be used as a pre-in/decrement.\n-\t\t\t     If code is MINUS, this was already tried.  */\n-\t\t\t  if (post_inc && code == PLUS\n-\t\t\t  /* Check that newconst is likely to be usable\n-\t\t\t     in a pre-in/decrement before starting the\n-\t\t\t     search.  */\n-\t\t\t      && (0\n-#if defined (HAVE_PRE_INCREMENT)\n-\t\t\t\t  || (newconst > 0 && newconst <= MOVE_MAX)\n-#endif\n-#if defined (HAVE_PRE_DECREMENT)\n-\t\t\t\t  || (newconst < 0 && newconst >= -MOVE_MAX)\n-#endif\n-\t\t\t\t ) && exact_log2 (newconst))\n-\t\t\t    {\n-\t\t\t      rtx q, inc_dest;\n-\n-\t\t\t      inc_dest\n-\t\t\t\t= post_inc_set ? SET_DEST (post_inc_set) : src;\n-\t\t\t      for (q = post_inc; q = NEXT_INSN (q); )\n-\t\t\t\t{\n-\t\t\t\t  if (GET_CODE (q) == CODE_LABEL\n-\t\t\t\t      || GET_CODE (q) == JUMP_INSN\n-\t\t\t\t      || (GET_CODE (q) == NOTE\n-\t\t\t\t\t  && ((NOTE_LINE_NUMBER (q)\n-\t\t\t\t\t       == NOTE_INSN_LOOP_BEG)\n-\t\t\t\t\t      || (NOTE_LINE_NUMBER (q)\n-\t\t\t\t\t\t  == NOTE_INSN_LOOP_END))))\n-\t\t\t\t    break;\n-\t\t\t\t  if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n-\t\t\t\t    continue;\n-\t\t\t\t  if (src != inc_dest\n-\t\t\t\t      && (reg_overlap_mentioned_p (src,\n-\t\t\t\t\t\t\t\t   PATTERN (q))\n-\t\t\t\t\t  || reg_set_p (src, q)))\n-\t\t\t\t    break;\n-\t\t\t\t  if (reg_set_p (inc_dest, q))\n-\t\t\t\t    break;\n-\t\t\t\t  if (reg_overlap_mentioned_p (inc_dest,\n-\t\t\t\t\t\t\t       PATTERN (q)))\n-\t\t\t\t    {\n-\t\t\t\t      try_auto_increment (q, post_inc,\n-\t\t\t\t\t\t\t  post_inc_set,\n-\t\t\t\t\t\t\t  inc_dest,\n-\t\t\t\t\t\t\t  newconst, 1);\n-\t\t\t\t      break;\n-\t\t\t\t    }\n-\t\t\t\t}\n-\t\t\t    }\n-#endif /* defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) */\n-\t\t\t  /* Move the death note for DST to INSN if it is used\n-\t\t\t     there.  */\n-\t\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (insn)))\n-\t\t\t    {\n-\t\t\t      XEXP (dst_note, 1) = REG_NOTES (insn);\n-\t\t\t      REG_NOTES (insn) = dst_note;\n-\t\t\t    }\n-    \n-\t\t\t  if (src_note)\n-\t\t\t    {\n-\t\t\t      /* Move the death note for SRC from INSN to P.  */\n-\t\t\t      if (! overlap)\n-\t\t\t\tremove_note (insn, src_note);\n-\t\t\t      XEXP (src_note, 1) = REG_NOTES (p);\n-\t\t\t      REG_NOTES (p) = src_note;\n-    \n-\t\t\t      REG_N_CALLS_CROSSED (REGNO (src)) += num_calls;\n-\t\t\t    }\n-    \n-\t\t\t  REG_N_SETS (REGNO (src))++;\n-\t\t\t  REG_N_SETS (REGNO (dst))--;\n-    \n-\t\t\t  REG_N_CALLS_CROSSED (REGNO (dst)) -= num_calls;\n-    \n-\t\t\t  /* ??? Must adjust reg_live_length, and reg_n_refs for\n-\t\t\t     both registers.  Must keep track of loop_depth in\n-\t\t\t     order to get reg_n_refs adjustment correct.  */\n-    \n-\t\t\t  if (regmove_dump_file)\n-\t\t\t    fprintf (regmove_dump_file,\n-\t\t\t\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t\t     operand_number, INSN_UID (insn),\n-\t\t\t\t     match_number);\n-    \n-\t\t\t  goto done_forwards;\n-\t\t\t}\n+\t\t      int srcregno = REGNO (SET_SRC(set));\n+\t\t      if (regno_src_regno[srcregno] >= 0)\n+\t\t\tsrcregno = regno_src_regno[srcregno];\n+\t\t      regno_src_regno[REGNO (SET_DEST (set))] = srcregno;\n \t\t    }\n \t\t}\n-\t    done_forwards:\n-\t      ;\n+\t    }\n+#ifdef REGISTER_CONSTRAINTS\n+\t  insn_code_number\n+\t    = find_matches (insn, &match);\n+\n+\t  if (insn_code_number < 0)\n+\t    continue;\n+\n+\t  /* Now scan through the operands looking for a source operand\n+\t     which is supposed to match the destination operand.\n+\t     Then scan forward for an instruction which uses the dest\n+\t     operand.\n+\t     If it dies there, then replace the dest in both operands with\n+\t     the source operand.  */\n+\n+\t  for (operand_number = 0;\n+\t       operand_number < insn_n_operands[insn_code_number];\n+\t       operand_number++)\n+\t    {\n+\t      rtx p, src, dst, src_subreg;\n+\t      enum reg_class src_class, dst_class;\n+\n+\t      match_number = match.with[operand_number];\n+\n+\t      /* Nothing to do if the two operands aren't supposed to match.  */\n+\t      if (match_number < 0)\n+\t\tcontinue;\n+\n+\t      src = recog_operand[operand_number];\n+\t      dst = recog_operand[match_number];\n+\n+\t      if (GET_CODE (src) != REG)\n+\t\tcontinue;\n+\n+\t      src_subreg = src;\n+\t      if (GET_CODE (dst) == SUBREG\n+\t\t  && GET_MODE_SIZE (GET_MODE (dst))\n+\t\t     >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dst))))\n+\t\t{\n+\t\t  src_subreg\n+\t\t    = gen_rtx(SUBREG,  GET_MODE (SUBREG_REG (dst)),\n+\t\t\t      src, SUBREG_WORD (dst));\n+\t\t  dst = SUBREG_REG (dst);\n+\t\t}\n+\t      if (GET_CODE (dst) != REG\n+\t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n+\t\tcontinue;\n+\n+\t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  if (match.commutative[operand_number] < operand_number)\n+\t\t    regno_src_regno[REGNO (dst)] = REGNO (src);\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (REG_LIVE_LENGTH (REGNO (src)) < 0)\n+\t\tcontinue;\n+\n+\t      /* operand_number/src must be a read-only operand, and\n+\t\t match_operand/dst must be a write-only operand.  */\n+\t      if (match.use[operand_number] != READ\n+\t\t  || match.use[match_number] != WRITE)\n+\t\tcontinue;\n+\n+\t      if (match.early_clobber[match_number]\n+\t\t  && count_occurrences (PATTERN (insn), src) > 1)\n+\t\tcontinue;\n+\n+\t      /* Make sure match_operand is the destination.  */\n+\t      if (recog_operand[match_number] != SET_DEST (set))\n+\t\tcontinue;\n+\n+\t      /* If the operands already match, then there is nothing to do.  */\n+\t      /* But in the commutative case, we might find a better match.  */\n+\t      if (operands_match_p (src, dst)\n+\t\t  || (match.commutative[operand_number] >= 0\n+\t\t      && operands_match_p (recog_operand[match.commutative\n+\t\t\t\t\t\t\t [operand_number]], dst)\n+\t\t      && (replacement_quality (recog_operand[match.commutative\n+\t\t\t\t\t\t\t     [operand_number]])\n+\t\t\t  >= replacement_quality (src))))\n+\t\tcontinue;\n+\n+\t      src_class = reg_preferred_class (REGNO (src));\n+\t      dst_class = reg_preferred_class (REGNO (dst));\n+\t      if (src_class != dst_class\n+\t\t  && (! reg_class_subset_p (src_class, dst_class)\n+\t\t      || CLASS_LIKELY_SPILLED_P (src_class))\n+\t\t  && (! reg_class_subset_p (dst_class, src_class)\n+\t\t      || CLASS_LIKELY_SPILLED_P (dst_class)))\n+\t\tcontinue;\n+\t  \n+\t      if (fixup_match_1 (insn, set, src, src_subreg, dst, pass,\n+\t\t\t\t operand_number, match_number,\n+\t\t\t\t regmove_dump_file))\n+\t\tbreak;\n \t    }\n \t}\n     }\n@@ -699,87 +595,25 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   if (regmove_dump_file)\n     fprintf (regmove_dump_file, \"Starting backward pass...\\n\");\n \n+  loop_depth = 1;\n+\n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n     {\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t    loop_depth++;\n+\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t    loop_depth--;\n+\t}\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n-\t  int insn_code_number = recog_memoized (insn);\n+\t  int insn_code_number = find_matches (insn, &match);\n \t  int operand_number, match_number;\n \t  \n \t  if (insn_code_number < 0)\n \t    continue;\n \n-\t  insn_extract (insn);\n-\t  if (! constrain_operands (insn_code_number, 0))\n-\t    continue;\n-\t  \n-\t  commutative = -1;\n-\n-\t  /* Must initialize this before the loop, because the code for\n-\t     the commutative case may set matches for operands other than\n-\t     the current one.  */\n-\t  bzero ((char *) matches, sizeof (matches));\n-\n-\t  for (operand_number = 0;\n-\t       operand_number < insn_n_operands[insn_code_number];\n-\t       operand_number++)\n-\t    {\n-\t      int output_operand = 0;\n-\t      int matching_operand = operand_number;\n-\t      char *p, c;\n-\t      int i = 0;\n-\n-\t      modified[operand_number] = 0;\n-\t      early_clobber[operand_number] = 0;\n-\n-\t      p = insn_operand_constraint[insn_code_number][operand_number];\n-\n-\t      if (*p == '=')\n-\t\tmodified[operand_number] = 2;\n-\t      else if (*p == '+')\n-\t\tmodified[operand_number] = 1;\n-\n-\t      for (; *p && i < which_alternative; p++)\n-\t\tif (*p == ',')\n-\t\t  i++;\n-\n-\t      while ((c = *p++) != '\\0' && c != ',')\n-\t\tswitch (c)\n-\t\t  {\n-\t\t  case '=':\n-\t\t    break;\n-\t\t  case '+':\n-\t\t    break;\n-\t\t  case '&':\n-\t\t    early_clobber[operand_number] = 1;\n-\t\t    break;\n-\t\t  case '%':\n-\t\t    commutative = operand_number;\n-\t\t    break;\n-\t\t  case '0': case '1': case '2': case '3': case '4':\n-\t\t  case '5': case '6': case '7': case '8': case '9':\n-\t\t    c -= '0';\n-\t\t    matches[c][operand_number] = 1;\n-\t\t    if (commutative >= 0)\n-\t\t      {\n-\t\t\tif (c == commutative || c == commutative + 1)\n-\t\t\t  {\n-\t\t\t    int other = c + (c == commutative ? 1 : -1);\n-\t\t\t    matches[other][operand_number] = 1;\n-\t\t\t  }\n-\t\t\tif (operand_number == commutative\n-\t\t\t    || operand_number == commutative + 1)\n-\t\t\t  {\n-\t\t\t    int other = (operand_number\n-\t\t\t\t\t + (operand_number == commutative\n-\t\t\t\t\t    ? 1 : -1));\n-\t\t\t    matches[c][other] = 1;\n-\t\t\t  }\n-\t\t      }\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\n \t  /* Now scan through the operands looking for a destination operand\n \t     which is supposed to match a source operand.\n \t     Then scan backward for an instruction which sets the source\n@@ -790,175 +624,713 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t       operand_number < insn_n_operands[insn_code_number];\n \t       operand_number++)\n \t    {\n-\t      for (match_number = 0;\n-\t\t   match_number < insn_n_operands[insn_code_number];\n-\t\t   match_number++)\n-\t\t{\n-\t\t  rtx set, p, src, dst;\n-\t\t  rtx src_note, dst_note;\n-\t\t  int success = 0;\n-\t\t  int num_calls = 0;\n-\n-\t\t  /* Nothing to do if the two operands aren't supposed to\n-\t\t     match.  */\n-\t\t  if (matches[operand_number][match_number] == 0)\n-\t\t    continue;\n+\t      rtx set, p, src, dst;\n+\t      rtx src_note, dst_note;\n+\t      int success = 0;\n+\t      int num_calls = 0;\n+\t      enum reg_class src_class, dst_class;\n+\t      int length;\n \n-\t\t  dst = recog_operand[operand_number];\n-\t\t  src = recog_operand[match_number];\n+\t      match_number = match.with[operand_number];\n \n-\t\t  if (GET_CODE (src) != REG\n-\t\t      || REGNO (src) < FIRST_PSEUDO_REGISTER)\n-\t\t    continue;\n+\t      /* Nothing to do if the two operands aren't supposed to match.  */\n+\t      if (match_number < 0)\n+\t\tcontinue;\n \n-\t\t  if (GET_CODE (dst) != REG\n-\t\t      || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n-\t\t    continue;\n+\t      dst = recog_operand[match_number];\n+\t      src = recog_operand[operand_number];\n \n-\t\t  /* If the operands already match, then there is nothing\n-\t\t     to do.  */\n-\t\t  if (operands_match_p (src, dst))\n-\t\t    continue;\n+\t      if (GET_CODE (src) != REG)\n+\t\tcontinue;\n \n-\t\t  set = single_set (insn);\n-\t\t  if (! set)\n-\t\t    continue;\n+\t      if (GET_CODE (dst) != REG\n+\t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER\n+\t\t  || REG_LIVE_LENGTH (REGNO (dst)) < 0)\n+\t\tcontinue;\n \n-\t\t  /* operand_number/dst must be a write-only operand, and\n-\t\t     match_operand/src must be a read-only operand.  */\n-\t\t  if (modified[match_number] != 0)\n-\t\t    continue;\n+\t      /* If the operands already match, then there is nothing to do.  */\n+\t      if (operands_match_p (src, dst)\n+\t\t  || (match.commutative[operand_number] >= 0\n+\t\t      && operands_match_p (recog_operand[match.commutative[operand_number]], dst)))\n+\t\tcontinue;\n \n-\t\t  if (early_clobber[operand_number] == 1)\n-\t\t    continue;\n+\t      set = single_set (insn);\n+\t      if (! set)\n+\t\tcontinue;\n \n-\t\t  if (modified[operand_number] != 2)\n-\t\t    continue;\n+\t      /* match_number/dst must be a write-only operand, and\n+\t\t operand_operand/src must be a read-only operand.  */\n+\t      if (match.use[operand_number] != READ\n+\t\t  || match.use[match_number] != WRITE)\n+\t\tcontinue;\n \n-\t\t  /* Make sure operand_number is the destination.  */\n-\t\t  if (recog_operand[operand_number] != SET_DEST (set))\n-\t\t    continue;\n-\t      \n-\t\t  if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n-\t\t    continue;\n+\t      if (match.early_clobber[match_number]\n+\t\t  && count_occurrences (PATTERN (insn), src) > 1)\n+\t\tcontinue;\n \n-\t\t  /* Can not modify an earlier insn to set dst if this insn\n-\t\t     uses an old value in the source.  */\n-\t\t  if (reg_overlap_mentioned_p (dst, SET_SRC (set)))\n-\t\t    continue;\n+\t      /* Make sure match_number is the destination.  */\n+\t      if (recog_operand[match_number] != SET_DEST (set))\n+\t\tcontinue;\n \n-\t\t  if (regmove_dump_file)\n-\t\t    fprintf (regmove_dump_file,\n-\t\t\t     \"Could fix operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t     operand_number, INSN_UID (insn), match_number);\n+\t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  if (GET_CODE (SET_SRC (set)) == PLUS\n+\t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT\n+\t\t      && XEXP (SET_SRC (set), 0) == src\n+\t\t      && fixup_match_2 (insn, dst, src,\n+\t\t\t\t\tXEXP (SET_SRC (set), 1),\n+\t\t\t\t\tregmove_dump_file))\n+\t\t    break;\n+\t\t  continue;\n+\t\t}\n+\t      src_class = reg_preferred_class (REGNO (src));\n+\t      dst_class = reg_preferred_class (REGNO (dst));\n+\t      if (src_class != dst_class\n+\t\t  && (! reg_class_subset_p (src_class, dst_class)\n+\t\t      || CLASS_LIKELY_SPILLED_P (src_class))\n+\t\t  && (! reg_class_subset_p (dst_class, src_class)\n+\t\t      || CLASS_LIKELY_SPILLED_P (dst_class)))\n+\t\tcontinue;\n+\t  \n+\t      if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n+\t\tcontinue;\n \n-\t\t  /* ??? If src is set once, and is set equal to a constant,\n-\t\t     then do not use it for this optimization, as this would\n-\t\t     make it no longer equivalent to a constant?  */\n+\t      /* Can not modify an earlier insn to set dst if this insn\n+\t\t uses an old value in the source.  */\n+\t      if (reg_overlap_mentioned_p (dst, SET_SRC (set)))\n+\t\tcontinue;\n \n-\t\t  /* Scan backward to find the first instruction that uses\n-\t\t     the input operand.  If the operand is set here, then\n-\t\t     replace it in both instructions with operand_number.  */\n+\t      if (regmove_dump_file)\n+\t\tfprintf (regmove_dump_file,\n+\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t operand_number, INSN_UID (insn), match_number);\n \n-\t\t  for (p = PREV_INSN (insn); p; p = PREV_INSN (p))\n-\t\t    {\n-\t\t      rtx pset;\n+\t      /* If src is set once in a different basic block,\n+\t\t and is set equal to a constant, then do not use\n+\t\t it for this optimization, as this would make it\n+\t\t no longer equivalent to a constant.  */\n+\t      if (reg_is_remote_constant_p (src, insn, f))\n+\t\tcontinue;\n \n-\t\t      if (GET_CODE (p) == CODE_LABEL\n-\t\t\t  || GET_CODE (p) == JUMP_INSN\n-\t\t\t  || (GET_CODE (p) == NOTE\n-\t\t\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n-\t\t\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n-\t\t\tbreak;\n+\t      /* Scan backward to find the first instruction that uses\n+\t\t the input operand.  If the operand is set here, then\n+\t\t replace it in both instructions with match_number.  */\n+\n+\t      for (length = 0, p = PREV_INSN (insn); p; p = PREV_INSN (p))\n+\t\t{\n+\t\t  rtx pset;\n+\n+\t\t  if (GET_CODE (p) == CODE_LABEL\n+\t\t      || GET_CODE (p) == JUMP_INSN\n+\t\t      || (GET_CODE (p) == NOTE\n+\t\t\t  && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t\t      || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\t\t    break;\n+\n+\t\t  if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\t\t    continue;\n \n-\t\t      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n-\t\t\tcontinue;\n+\t\t  length++;\n \n-\t\t      /* ??? See if all of SRC is set in P.  This test is much\n-\t\t\t more conservative than it needs to be.  */\n-\t\t      pset = single_set (p);\n-\t\t      if (pset && SET_DEST (pset) == src)\n+\t\t  /* ??? See if all of SRC is set in P.  This test is much\n+\t\t     more conservative than it needs to be.  */\n+\t\t  pset = single_set (p);\n+\t\t  if (pset && SET_DEST (pset) == src)\n+\t\t    {\n+\t\t      /* We use validate_replace_rtx, in case there\n+\t\t\t are multiple identical source operands.  All of\n+\t\t\t them have to be changed at the same time.  */\n+\t\t      if (validate_replace_rtx (src, dst, insn))\n \t\t\t{\n-\t\t\t  /* We use validate_replace_rtx, in case there\n-\t\t\t     are multiple identical source operands.  All of\n-\t\t\t     them have to be changed at the same time.  */\n-\t\t\t  if (validate_replace_rtx (src, dst, insn))\n+\t\t\t  if (validate_change (p, &SET_DEST (pset),\n+\t\t\t\t\t       dst, 0))\n+\t\t\t    success = 1;\n+\t\t\t  else\n \t\t\t    {\n-\t\t\t      if (validate_change (p, &SET_DEST (pset),\n-\t\t\t\t\t\t   dst, 0))\n-\t\t\t\tsuccess = 1;\n-\t\t\t      else\n-\t\t\t\t{\n-\t\t\t\t  /* Change all source operands back.\n-\t\t\t\t     This modifies the dst as a side-effect.  */\n-\t\t\t\t  validate_replace_rtx (dst, src, insn);\n-\t\t\t\t  /* Now make sure the dst is right.  */\n-\t\t\t\t  validate_change (insn,\n-\t\t\t\t\t\t   recog_operand_loc[operand_number],\n-\t\t\t\t\t\t   dst, 0);\n-\t\t\t\t}\n+\t\t\t      /* Change all source operands back.\n+\t\t\t\t This modifies the dst as a side-effect.  */\n+\t\t\t      validate_replace_rtx (dst, src, insn);\n+\t\t\t      /* Now make sure the dst is right.  */\n+\t\t\t      validate_change (insn,\n+\t\t\t\t\t       recog_operand_loc[match_number],\n+\t\t\t\t\t       dst, 0);\n \t\t\t    }\n-\t\t\t  break;\n \t\t\t}\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  if (reg_overlap_mentioned_p (src, PATTERN (p))\n+\t\t      || reg_overlap_mentioned_p (dst, PATTERN (p)))\n+\t\t    break;\n \n-\t\t      if (reg_overlap_mentioned_p (src, PATTERN (p))\n-\t\t\t  || reg_overlap_mentioned_p (dst, PATTERN (p)))\n+\t\t  /* If we have passed a call instruction, and the\n+\t\t     pseudo-reg DST is not already live across a call,\n+\t\t     then don't perform the optimization.  */\n+\t\t  if (GET_CODE (p) == CALL_INSN)\n+\t\t    {\n+\t\t      num_calls++;\n+\n+\t\t      if (REG_N_CALLS_CROSSED (REGNO (dst)) == 0)\n \t\t\tbreak;\n+\t\t    }\n+\t\t}\n \n-\t\t      /* If we have passed a call instruction, and the\n-\t\t\t pseudo-reg DST is not already live across a call,\n-\t\t\t then don't perform the optimization.  */\n-\t\t      if (GET_CODE (p) == CALL_INSN)\n-\t\t\t{\n-\t\t\t  num_calls++;\n+\t      if (success)\n+\t\t{\n+\t\t  int dstno, srcno;\n \n-\t\t\t  if (REG_N_CALLS_CROSSED (REGNO (dst)) == 0)\n-\t\t\t    break;\n-\t\t\t}\n+\t\t  /* Remove the death note for SRC from INSN.  */\n+\t\t  remove_note (insn, src_note);\n+\t\t  /* Move the death note for SRC to P if it is used\n+\t\t     there.  */\n+\t\t  if (reg_overlap_mentioned_p (src, PATTERN (p)))\n+\t\t    {\n+\t\t      XEXP (src_note, 1) = REG_NOTES (p);\n+\t\t      REG_NOTES (p) = src_note;\n \t\t    }\n+\t\t  /* If there is a REG_DEAD note for DST on P, then remove\n+\t\t     it, because DST is now set there.  */\n+\t\t  if (dst_note = find_reg_note (p, REG_DEAD, dst))\n+\t\t    remove_note (p, dst_note);\n+\n+\t\t  dstno = REGNO (dst);\n+\t\t  srcno = REGNO (src);\n+\n+\t\t  REG_N_SETS (dstno)++;\n+\t\t  REG_N_SETS (srcno)--;\n \n-\t\t  if (success)\n+\t\t  REG_N_CALLS_CROSSED (dstno) += num_calls;\n+\t\t  REG_N_CALLS_CROSSED (srcno) -= num_calls;\n+\n+\t\t  REG_LIVE_LENGTH (dstno) += length;\n+\t\t  if (REG_LIVE_LENGTH (srcno) >= 0)\n \t\t    {\n-\t\t      /* Remove the death note for SRC from INSN.  */\n-\t\t      remove_note (insn, src_note);\n-\t\t      /* Move the death note for SRC to P if it is used\n-\t\t\t there.  */\n-\t\t      if (reg_overlap_mentioned_p (src, PATTERN (p)))\n-\t\t\t{\n-\t\t\t  XEXP (src_note, 1) = REG_NOTES (p);\n-\t\t\t  REG_NOTES (p) = src_note;\n-\t\t\t}\n-\t\t      /* If there is a REG_DEAD note for DST on P, then remove\n-\t\t\t it, because DST is now set there.  */\n-\t\t      if (dst_note = find_reg_note (p, REG_DEAD, dst))\n-\t\t\tremove_note (p, dst_note);\n+\t\t      REG_LIVE_LENGTH (srcno) -= length;\n+\t\t      /* REG_LIVE_LENGTH is only an approximation after\n+\t\t\t combine if sched is not run, so make sure that we\n+\t\t\t still have a reasonable value.  */\n+\t\t      if (REG_LIVE_LENGTH (srcno) < 2)\n+\t\t\tREG_LIVE_LENGTH (srcno) = 2;\n+\t\t    }\n \n-\t\t      REG_N_SETS (REGNO (dst))++;\n-\t\t      REG_N_SETS (REGNO (src))--;\n+\t\t  /* We assume that a register is used exactly once per\n+\t\t     insn in the updates above.  If this is not correct,\n+\t\t     no great harm is done.  */\n \n-\t\t      REG_N_CALLS_CROSSED (REGNO (dst)) += num_calls;\n-\t\t      REG_N_CALLS_CROSSED (REGNO (src)) -= num_calls;\n+\t\t  REG_N_REFS (dstno) += 2 * loop_depth;\n+\t\t  REG_N_REFS (srcno) -= 2 * loop_depth;\n \n-\t\t      /* ??? Must adjust reg_live_length, and reg_n_refs for\n-\t\t\t both registers.  Must keep track of loop_depth in\n-\t\t\t order to get reg_n_refs adjustment correct.  */\n+                  /* If that was the only time src was set,\n+                     and src was not live at the start of the\n+                     function, we know that we have no more\n+                     references to src; clear REG_N_REFS so it\n+                     won't make reload do any work.  */\n+                  if (REG_N_SETS (REGNO (src)) == 0\n+                      && ! regno_uninitialized (REGNO (src)))\n+                    REG_N_REFS (REGNO (src)) = 0;\n \n-\t\t      if (regmove_dump_file)\n-\t\t\tfprintf (regmove_dump_file,\n-\t\t\t\t \"Fixed operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t\t operand_number, INSN_UID (insn), match_number);\n+\t\t  if (regmove_dump_file)\n+\t\t    fprintf (regmove_dump_file,\n+\t\t\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t     operand_number, INSN_UID (insn), match_number);\n \n-\t\t      goto done_backwards;\n-\t\t    }\n+\t\t  break;\n \t\t}\n \t    }\n-\tdone_backwards:\n-\t  ;\n \t}\n     }\n #endif /* REGISTER_CONSTRAINTS */\n }\n \n+\n+static int\n+find_matches (insn, matchp)\n+     rtx insn;\n+     struct match *matchp;\n+{\n+  int likely_spilled[MAX_RECOG_OPERANDS];\n+  int operand_number;\n+  int insn_code_number = recog_memoized (insn);\n+  int any_matches = 0;\n+\n+  if (insn_code_number < 0)\n+    return -1;\n+\n+  insn_extract (insn);\n+  if (! constrain_operands (insn_code_number, 0))\n+    return -1;\n+\n+  /* Must initialize this before main loop, because the code for\n+     the commutative case may set matches for operands other than\n+     the current one.  */\n+  for (operand_number = insn_n_operands[insn_code_number];\n+       --operand_number >= 0; )\n+    matchp->with[operand_number] = matchp->commutative[operand_number] = -1;\n+\n+  for (operand_number = 0; operand_number < insn_n_operands[insn_code_number];\n+       operand_number++)\n+    {\n+      int output_operand = 0;\n+      int matching_operand = operand_number;\n+      char *p, c;\n+      int i = 0;\n+\n+      p = insn_operand_constraint[insn_code_number][operand_number];\n+\n+      likely_spilled[operand_number] = 0;\n+      matchp->use[operand_number] = READ;\n+      if (*p == '=')\n+\tmatchp->use[operand_number] = WRITE;\n+      else if (*p == '+')\n+\tmatchp->use[operand_number] = READWRITE;\n+\n+      for (;*p && i < which_alternative; p++)\n+\tif (*p == ',')\n+\t  i++;\n+\n+      while ((c = *p++) != '\\0' && c != ',')\n+\tswitch (c)\n+\t  {\n+\t  case '=':\n+\t    break;\n+\t  case '+':\n+\t    break;\n+\t  case '&':\n+\t    matchp->early_clobber[operand_number] = 1;\n+\t    break;\n+\t  case '%':\n+\t    matchp->commutative[operand_number] = operand_number + 1;\n+\t    matchp->commutative[operand_number + 1] = operand_number;\n+\t    break;\n+\t  case '0': case '1': case '2': case '3': case '4':\n+\t  case '5': case '6': case '7': case '8': case '9':\n+\t    c -= '0';\n+\t    if (c < operand_number && likely_spilled[c])\n+\t      break;\n+\t    matchp->with[operand_number] = c;\n+\t    any_matches = 1;\n+\t    if (matchp->commutative[operand_number] >= 0)\n+\t      matchp->with[matchp->commutative[operand_number]] = c;\n+\t    break;\n+\t  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'h':\n+\t  case 'j': case 'k': case 'l': case 'p': case 'q': case 't': case 'u':\n+\t  case 'v': case 'w': case 'x': case 'y': case 'z': case 'A': case 'B':\n+\t  case 'C': case 'D': case 'W': case 'Y': case 'Z':\n+\t    if (CLASS_LIKELY_SPILLED_P (REG_CLASS_FROM_LETTER (c)))\n+\t      likely_spilled[operand_number] = 1;\n+\t    break;\n+\t  }\n+    }\n+  return any_matches ? insn_code_number : -1;\n+}\n+\n+/* Try to replace output operand DST in SET, with input operand SRC.  SET is\n+   the only set in INSN.  INSN has just been recgnized and constrained.\n+   SRC is operand number OPERAND_NUMBER in INSN.\n+   DST is operand number MATCH_NUMBER in INSN.\n+   If BACKWARD is nonzero, we have been called in a backward pass.\n+   Return nonzero for success.  */\n+static int\n+fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n+\t       match_number, regmove_dump_file)\n+     rtx insn, set, src, src_subreg, dst;\n+     int backward, operand_number, match_number;\n+     FILE *regmove_dump_file;\n+{\n+  rtx p;\n+  rtx post_inc = 0, post_inc_set = 0, search_end = 0;\n+  int success = 0;\n+  int num_calls = 0, s_num_calls = 0;\n+  enum rtx_code code = NOTE;\n+  HOST_WIDE_INT insn_const, newconst;\n+  rtx overlap = 0; /* need to move insn ? */\n+  rtx src_note = find_reg_note (insn, REG_DEAD, src), dst_note;\n+  int length, s_length, true_loop_depth;\n+\n+  if (! src_note)\n+    {\n+      /* Look for (set (regX) (op regA constX))\n+\t\t  (set (regY) (op regA constY))\n+\t and change that to\n+\t\t  (set (regA) (op regA constX)).\n+\t\t  (set (regY) (op regA constY-constX)).\n+\t This works for add and shift operations, if\n+\t regA is dead after or set by the second insn.  */\n+\n+      code = GET_CODE (SET_SRC (set));\n+      if ((code == PLUS || code == LSHIFTRT\n+\t   || code == ASHIFT || code == ASHIFTRT)\n+\t  && XEXP (SET_SRC (set), 0) == src\n+\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n+\tinsn_const = INTVAL (XEXP (SET_SRC (set), 1));\n+      else if (! stable_but_for_p (SET_SRC (set), src, dst))\n+\treturn 0;\n+      else\n+\t/* We might find a src_note while scanning.  */\n+\tcode = NOTE;\n+    }\n+\n+  if (regmove_dump_file)\n+    fprintf (regmove_dump_file,\n+\t     \"Could fix operand %d of insn %d matching operand %d.\\n\",\n+\t     operand_number, INSN_UID (insn), match_number);\n+\n+  /* If SRC is equivalent to a constant set in a different basic block,\n+     then do not use it for this optimization.  We want the equivalence\n+     so that if we have to reload this register, we can reload the\n+     constant, rather than extending the lifespan of the register.  */\n+  if (reg_is_remote_constant_p (src, insn, get_insns ()))\n+    return 0;\n+\n+  /* Scan forward to find the next instruction that\n+     uses the output operand.  If the operand dies here,\n+     then replace it in both instructions with\n+     operand_number.  */\n+\n+  for (length = s_length = 0, p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+    {\n+      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n+\t  || (GET_CODE (p) == NOTE\n+\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\tbreak;\n+\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+\n+      length++;\n+      if (src_note)\n+\ts_length++;\n+\n+      if (reg_set_p (src, p) || reg_set_p (dst, p)\n+\t  || (GET_CODE (PATTERN (p)) == USE\n+\t      && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n+\tbreak;\n+\n+      /* See if all of DST dies in P.  This test is\n+\t slightly more conservative than it needs to be.  */\n+      if ((dst_note = find_regno_note (p, REG_DEAD, REGNO (dst)))\n+\t  && (GET_MODE (XEXP (dst_note, 0)) == GET_MODE (dst)))\n+\t{\n+\t  if (! src_note)\n+\t    {\n+\t      rtx q;\n+\t      rtx set2;\n+\n+\t      /* If an optimization is done, the value of SRC while P\n+\t\t is executed will be changed.  Check that this is OK.  */\n+\t      if (reg_overlap_mentioned_p (src, PATTERN (p)))\n+\t\tbreak;\n+\t      for (q = p; q; q = NEXT_INSN (q))\n+\t\t{\n+\t\t  if (GET_CODE (q) == CODE_LABEL || GET_CODE (q) == JUMP_INSN\n+\t\t      || (GET_CODE (q) == NOTE\n+\t\t\t  && (NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_BEG\n+\t\t\t      || NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_END)))\n+\t\t    {\n+\t\t      q = 0;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n+\t\t    continue;\n+\t\t  if (reg_overlap_mentioned_p (src, PATTERN (q))\n+\t\t      || reg_set_p (src, q))\n+\t\t    break;\n+\t\t}\n+\t      if (q)\n+\t\tset2 = single_set (q);\n+\t      if (! q || ! set2 || GET_CODE (SET_SRC (set2)) != code\n+\t\t  || XEXP (SET_SRC (set2), 0) != src\n+\t\t  || GET_CODE (XEXP (SET_SRC (set2), 1)) != CONST_INT\n+\t\t  || (SET_DEST (set2) != src\n+\t\t      && ! find_reg_note (q, REG_DEAD, src)))\n+\t\t{\n+\t\t  /* If this is a PLUS, we can still save a register by doing\n+\t\t     src += insn_const;\n+\t\t     P;\n+\t\t     src -= insn_const; .\n+\t\t     This also gives opportunities for subsequent\n+\t\t     optimizations in the backward pass, so do it there.  */\n+\t\t  if (code == PLUS && backward\n+#ifdef HAVE_cc0\n+\t\t      /* We may not emit an insn directly\n+\t\t\t after P if the latter sets CC0.  */\n+\t\t      && ! sets_cc0_p (PATTERN (p))\n+#endif\n+\t\t      )\n+\n+\t\t    {\n+\t\t      search_end = q;\n+\t\t      q = insn;\n+\t\t      set2 = set;\n+\t\t      newconst = -insn_const;\n+\t\t      code = MINUS;\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  newconst = INTVAL (XEXP (SET_SRC (set2), 1)) - insn_const;\n+\t\t  /* Reject out of range shifts.  */\n+\t\t  if (code != PLUS\n+\t\t      && (newconst < 0\n+\t\t\t  || (newconst\n+\t\t\t      >= GET_MODE_BITSIZE (GET_MODE (SET_SRC (set2))))))\n+\t\t    break;\n+\t\t  if (code == PLUS)\n+\t\t    {\n+\t\t      post_inc = q;\n+\t\t      if (SET_DEST (set2) != src)\n+\t\t\tpost_inc_set = set2;\n+\t\t    }\n+\t\t}\n+\t      /* We use 1 as last argument to validate_change so that all\n+\t\t changes are accepted or rejected together by apply_change_group\n+\t\t when it is called by validate_replace_rtx .  */\n+\t      validate_change (q, &XEXP (SET_SRC (set2), 1),\n+\t\t\t       GEN_INT (newconst), 1);\n+\t    }\n+\t  validate_change (insn, recog_operand_loc[match_number], src, 1);\n+\t  if (validate_replace_rtx (dst, src_subreg, p))\n+\t    success = 1;\n+\t  break;\n+\t}\n+\n+      if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n+\tbreak;\n+      if (! src_note && reg_overlap_mentioned_p (src, PATTERN (p)))\n+\t{\n+\t  /* INSN was already checked to be movable when\n+\t     we found no REG_DEAD note for src on it.  */\n+\t  overlap = p;\n+\t  src_note = find_reg_note (p, REG_DEAD, src);\n+\t}\n+\n+      /* If we have passed a call instruction, and the pseudo-reg SRC is not\n+\t already live across a call, then don't perform the optimization.  */\n+      if (GET_CODE (p) == CALL_INSN)\n+\t{\n+\t  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n+\t    break;\n+\n+\t  num_calls++;\n+\n+\t  if (src_note)\n+\t    s_num_calls++;\n+\n+\t}\n+    }\n+\n+  if (! success)\n+    return 0;\n+\n+  true_loop_depth = backward ? 2 - loop_depth : loop_depth;\n+\n+  /* Remove the death note for DST from P.  */\n+  remove_note (p, dst_note);\n+  if (code == MINUS)\n+    {\n+      post_inc = emit_insn_after (copy_rtx (PATTERN (insn)), p);\n+#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+      if (search_end\n+\t  && try_auto_increment (search_end, post_inc, 0, src, newconst, 1))\n+\tpost_inc = 0;\n+#endif\n+      validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (insn_const), 0);\n+      REG_N_SETS (REGNO (src))++;\n+      REG_N_REFS (REGNO (src)) += true_loop_depth;\n+      REG_LIVE_LENGTH (REGNO (src))++;\n+    }\n+  if (overlap)\n+    {\n+      /* The lifetime of src and dest overlap,\n+\t but we can change this by moving insn.  */\n+      rtx pat = PATTERN (insn);\n+      if (src_note)\n+\tremove_note (overlap, src_note);\n+#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT)\n+      if (code == PLUS\n+\t  && try_auto_increment (overlap, insn, 0, src, insn_const, 0))\n+\tinsn = overlap;\n+      else\n+#endif\n+\t{\n+\t  rtx notes = REG_NOTES (insn);\n+\n+\t  emit_insn_after_with_line_notes (pat, PREV_INSN (p), insn);\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  /* emit_insn_after_with_line_notes has no\n+\t     return value, so search for the new insn.  */\n+\t  for (insn = p; PATTERN (insn) != pat; )\n+\t    insn = PREV_INSN (insn);\n+\n+\t  REG_NOTES (insn) = notes;\n+\t}\n+    }\n+  /* Sometimes we'd generate src = const; src += n;\n+     if so, replace the instruction that set src\n+     in the first place.  */\n+\n+  if (! overlap && (code == PLUS || code == MINUS))\n+    {\n+      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+      rtx q, set2;\n+      int num_calls2 = 0, s_length2 = 0;\n+\n+      if (note && CONSTANT_P (XEXP (note, 0)))\n+\t{\n+\t  for (q = PREV_INSN (insn); q; q = PREV_INSN(q))\n+\t    {\n+\t      if (GET_CODE (q) == JUMP_INSN)\n+\t\t{\n+\t\t  q = 0;\n+\t\t  break;\n+\t\t}\n+\t      if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n+\t\tcontinue;\n+\t      s_length2++;\n+\t      if (reg_set_p (src, q))\n+\t\t{\n+\t\t  set2 = single_set (q);\n+\t\t  break;\n+\t\t}\n+\t      if (reg_overlap_mentioned_p (src, PATTERN (q)))\n+\t\t{\n+\t\t  q = 0;\n+\t\t  break;\n+\t\t}\n+\t      if (GET_CODE (p) == CALL_INSN)\n+\t\tnum_calls2++;\n+\t    }\n+\t  if (q && set2 && SET_DEST (set2) == src && CONSTANT_P (SET_SRC (set2))\n+\t      && validate_change (insn, &SET_SRC (set), XEXP (note, 0), 0))\n+\t    {\n+\t      PUT_CODE (q, NOTE);\n+\t      NOTE_LINE_NUMBER (q) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (q) = 0;\n+\t      REG_N_SETS (REGNO (src))--;\n+\t      REG_N_CALLS_CROSSED (REGNO (src)) -= num_calls2;\n+\t      REG_N_REFS (REGNO (src)) -= true_loop_depth;\n+\t      REG_LIVE_LENGTH (REGNO (src)) -= s_length2;\n+\t      insn_const = 0;\n+\t    }\n+\t}\n+    }\n+  if (0) ;\n+#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+  else if ((code == PLUS || code == MINUS) && insn_const\n+\t   && try_auto_increment (p, insn, 0, src, insn_const, 1))\n+    insn = p;\n+#endif\n+#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT)\n+  else if (post_inc\n+\t   && try_auto_increment (p, post_inc, post_inc_set, src, newconst, 0))\n+    post_inc = 0;\n+#endif\n+#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+  /* If post_inc still prevails, try to find an\n+     insn where it can be used as a pre-in/decrement.\n+     If code is MINUS, this was already tried.  */\n+  if (post_inc && code == PLUS\n+  /* Check that newconst is likely to be usable\n+     in a pre-in/decrement before starting the search.  */\n+      && (0\n+#if defined (HAVE_PRE_INCREMENT)\n+\t  || (newconst > 0 && newconst <= MOVE_MAX)\n+#endif\n+#if defined (HAVE_PRE_DECREMENT)\n+\t  || (newconst < 0 && newconst >= -MOVE_MAX)\n+#endif\n+\t ) && exact_log2 (newconst))\n+    {\n+      rtx q, inc_dest;\n+\n+      inc_dest = post_inc_set ? SET_DEST (post_inc_set) : src;\n+      for (q = post_inc; q = NEXT_INSN (q); )\n+\t{\n+\t  if (GET_CODE (q) == CODE_LABEL || GET_CODE (q) == JUMP_INSN\n+\t      || (GET_CODE (q) == NOTE\n+\t\t  && (NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_BEG\n+\t\t      || NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_END)))\n+\t    break;\n+\t  if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n+\t    continue;\n+\t  if (src != inc_dest && (reg_overlap_mentioned_p (src, PATTERN (q))\n+\t\t\t\t  || reg_set_p (src, q)))\n+\t    break;\n+\t  if (reg_set_p (inc_dest, q))\n+\t    break;\n+\t  if (reg_overlap_mentioned_p (inc_dest, PATTERN (q)))\n+\t    {\n+\t      try_auto_increment (q, post_inc,\n+\t\t\t\t  post_inc_set, inc_dest, newconst, 1);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+#endif /* defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) */\n+  /* Move the death note for DST to INSN if it is used\n+     there.  */\n+  if (reg_overlap_mentioned_p (dst, PATTERN (insn)))\n+    {\n+      XEXP (dst_note, 1) = REG_NOTES (insn);\n+      REG_NOTES (insn) = dst_note;\n+    }\n+\n+  if (src_note)\n+    {\n+      /* Move the death note for SRC from INSN to P.  */\n+      if (! overlap)\n+\tremove_note (insn, src_note);\n+      XEXP (src_note, 1) = REG_NOTES (p);\n+      REG_NOTES (p) = src_note;\n+\n+      REG_N_CALLS_CROSSED (REGNO (src)) += s_num_calls;\n+    }\n+\n+  REG_N_SETS (REGNO (src))++;\n+  REG_N_SETS (REGNO (dst))--;\n+\n+  REG_N_CALLS_CROSSED (REGNO (dst)) -= num_calls;\n+\n+  REG_LIVE_LENGTH (REGNO (src)) += s_length;\n+  if (REG_LIVE_LENGTH (REGNO (dst)) >= 0)\n+    {\n+      REG_LIVE_LENGTH (REGNO (dst)) -= length;\n+      /* REG_LIVE_LENGTH is only an approximation after\n+\t combine if sched is not run, so make sure that we\n+\t still have a reasonable value.  */\n+      if (REG_LIVE_LENGTH (REGNO (dst)) < 2)\n+\tREG_LIVE_LENGTH (REGNO (dst)) = 2;\n+    }\n+\n+  /* We assume that a register is used exactly once per\n+      insn in the updates above.  If this is not correct,\n+      no great harm is done.  */\n+\n+  REG_N_REFS (REGNO (src)) += 2 * true_loop_depth;\n+  REG_N_REFS (REGNO (dst)) -= 2 * true_loop_depth;\n+\n+  /* If that was the only time dst was set,\n+     and dst was not live at the start of the\n+     function, we know that we have no more\n+     references to dst; clear REG_N_REFS so it\n+     won't make reload do any work.  */\n+  if (REG_N_SETS (REGNO (dst)) == 0\n+      && ! regno_uninitialized (REGNO (dst)))\n+    REG_N_REFS (REGNO (dst)) = 0;\n+\n+  if (regmove_dump_file)\n+    fprintf (regmove_dump_file,\n+\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n+\t     operand_number, INSN_UID (insn), match_number);\n+  return 1;\n+}\n+\n+\n /* return nonzero if X is stable but for mentioning SRC or mentioning /\n    changing DST .  If in doubt, presume it is unstable.  */\n static int\n@@ -985,3 +1357,55 @@ stable_but_for_p (x, src, dst)\n       return ! rtx_unstable_p (x);\n     }\n }\n+\n+/* Test if regmove seems profitable for this target.  */\n+int\n+regmove_profitable_p ()\n+{\n+#ifdef REGISTER_CONSTRAINTS\n+  struct match match;\n+  enum machine_mode mode;\n+  optab tstoptab = add_optab;\n+  do /* check add_optab and ashl_optab */\n+    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t{\n+\t  int icode = (int) tstoptab->handlers[(int) mode].insn_code;\n+\t  rtx reg0, reg1, reg2, pat;\n+\t  int i;\n+    \n+\t  if (GET_MODE_BITSIZE (mode) < 32 || icode == CODE_FOR_nothing)\n+\t    continue;\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i))\n+\t      break;\n+\t  if (i + 2 >= FIRST_PSEUDO_REGISTER)\n+\t    break;\n+\t  reg0 = gen_rtx (REG, insn_operand_mode[icode][0], i);\n+\t  reg1 = gen_rtx (REG, insn_operand_mode[icode][1], i + 1);\n+\t  reg2 = gen_rtx (REG, insn_operand_mode[icode][2], i + 2);\n+\t  if (! (*insn_operand_predicate[icode][0]) (reg0, VOIDmode)\n+\t      || ! (*insn_operand_predicate[icode][1]) (reg1, VOIDmode)\n+\t      || ! (*insn_operand_predicate[icode][2]) (reg2, VOIDmode))\n+\t    break;\n+\t  pat = GEN_FCN (icode) (reg0, reg1, reg2);\n+\t  if (! pat)\n+\t    continue;\n+\t  if (GET_CODE (pat) == SEQUENCE)\n+\t    pat = XVECEXP (pat, 0,  XVECLEN (pat, 0) - 1);\n+\t  else\n+\t    pat = make_insn_raw (pat);\n+\t  if (! single_set (pat)\n+\t      || GET_CODE (SET_SRC (single_set (pat))) != tstoptab->code)\n+\t    /* Unexpected complexity;  don't need to handle this unless\n+\t       we find a machine where this occurs and regmove should\n+\t       be enabled.  */\n+\t    break;\n+\t  if (find_matches (pat, &match) >= 0)\n+\t    return 1;\n+\t  break;\n+\t}\n+  while (tstoptab != ashl_optab && (tstoptab = ashl_optab, 1));\n+#endif /* REGISTER_CONSTRAINTS */\n+  return 0;\n+}"}, {"sha": "14197299608a2e909f6d639b3b74d9f8a549e7d5", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=184bb750da2da4d22c64ea900ea1a4f00927ca77", "patch": "@@ -1,5 +1,5 @@\n /* Communication between reload.c and reload1.c.\n-   Copyright (C) 1987, 91, 92, 93, 94, 95, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91-95, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -200,9 +200,10 @@ extern rtx find_equiv_reg PROTO((rtx, rtx, enum reg_class, int, short *,\n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n extern int regno_clobbered_p PROTO((int, rtx));\n \n-\n /* Functions in reload1.c:  */\n \n+int count_occurrences            PROTO((rtx, rtx));\n+\n /* Initialize the reload pass once per compilation.  */\n extern void init_reload PROTO((void));\n "}, {"sha": "b9177181bf6b58af6283a89c0f7d37480cc26875", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=184bb750da2da4d22c64ea900ea1a4f00927ca77", "patch": "@@ -1,5 +1,5 @@\n /* Reload pseudo regs into hard regs for insns that require hard regs.\n-   Copyright (C) 1987, 88, 89, 92-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-7 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -392,7 +392,6 @@ static void emit_reload_insns\t\tPROTO((rtx));\n static void delete_output_reload\tPROTO((rtx, int, rtx));\n static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n-static int count_occurrences\t\tPROTO((rtx, rtx));\n static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx));\n static void reload_cse_invalidate_mem\tPROTO((rtx));\n@@ -7510,7 +7509,7 @@ constraint_accepts_reg_p (string, reg)\n /* Return the number of places FIND appears within X, but don't count\n    an occurrence if some SET_DEST is FIND.  */\n \n-static int\n+int\n count_occurrences (x, find)\n      register rtx x, find;\n {"}, {"sha": "992b75b15ad9ce006c435b9d87a56c1d0cde2ca8", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184bb750da2da4d22c64ea900ea1a4f00927ca77/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=184bb750da2da4d22c64ea900ea1a4f00927ca77", "patch": "@@ -1,5 +1,5 @@\n /* Register Transfer Language (RTL) definitions for GNU C-Compiler\n-   Copyright (C) 1987, 91-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1389,4 +1389,8 @@ extern void init_alias_once\t\tPROTO ((void));\n extern void init_alias_analysis\t\tPROTO ((void));\n extern void end_alias_analysis\t\tPROTO ((void));\n \n+/* In local-alloc.c */\n+extern int optimize_reg_copy_1  \tPROTO((rtx, rtx, rtx));\n+extern void optimize_reg_copy_2 \tPROTO((rtx, rtx, rtx));\n+\n #endif /* _RTL_H */"}]}