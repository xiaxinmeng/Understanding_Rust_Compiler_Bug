{"sha": "c8945d5632cc44d3f05178c67b73b666cc64c8a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg5NDVkNTYzMmNjNDRkM2YwNTE3OGM2N2I3M2I2NjZjYzY0YzhhNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-10-31T18:19:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:19:52Z"}, "message": "gigi.h: (tree_code_for_record_type): Declare.\n\n2006-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n\t    Nicolas Setton  <setton@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* gigi.h: (tree_code_for_record_type): Declare.\n\t(add_global_renaming_pointer): Rename to record_global_renaming_pointer.\n\t(get_global_renaming_pointers): Rename to\n\tinvalidate_global_renaming_pointers.\n\t(static_ctors): Delete.\n\t(static_dtors): Likewise.\n\t(gnat_write_global_declarations): Declare.\n\t(create_var_decl): Adjust descriptive comment to indicate that the\n\tsubprogram may return a CONST_DECL node.\n\t(create_true_var_decl): Declare new function, similar to\n\tcreate_var_decl but forcing the creation of a VAR_DECL node.\n\t(get_global_renaming_pointers): Declare.\n\t(add_global_renaming_pointer): Likewise.\n\n\t* ada-tree.h (DECL_READONLY_ONCE_ELAB): New macro.\n\n\t* decl.c (gnat_to_gnu_entity) <case E_Function>: Don't copy the type\n\ttree before setting TREE_ADDRESSABLE for by-reference return mechanism\n\tprocessing.\n\t(gnat_to_gnu_entity): Remove From_With_Type from computation for\n\timported_p.\n\t<E_Access_Type>: Use the Non_Limited_View as the full view of the\n\tdesignated type if the pointer comes from a limited_with clause.  Make\n\tincomplete designated type if it is in the main unit and has a freeze\n\tnode.\n\t<E_Incomplete_Type>: Rework to treat Non_Limited_View, Full_View, and\n\tUnderlying_Full_View similarly.  Return earlier if the full view already\n\thas an associated tree.\n\t(gnat_to_gnu_entity) <E_Record_Type>: Restore comment.\n\t(gnat_to_gnu_entity) <E_Record_Type>: Do not use a dummy type.\n\t(gnat_to_gnu_entity) <E_Variable>: Set TYPE_REF_CAN_ALIAS_ALL on the\n\treference type built for objects with an address clause.\n\tUse create_true_var_decl with const_flag set for\n\tDECL_CONST_CORRESPONDING_VARs, ensuring a VAR_DECL is created with\n\tTREE_READONLY set.\n\t(gnat_to_gnu_entity, case E_Enumeration_Type): Set TYPE_NAME\n\tfor Character and Wide_Character types. This info is read by the\n\tdwarf-2 writer, and is needed to be able to use the command \"ptype\n\tcharacter\" in the debugger.\n\t(gnat_to_gnu_entity): When generating a type representing\n\ta Character or Wide_Character type, set the flag TYPE_STRING_FLAG,\n\tso that debug writers can distinguish it from ordinary integers.\n\t(elaborate_expression_1): Test the DECL_READONLY_ONCE_ELAB flag in\n\taddition to TREE_READONLY to assert the constantness of variables for\n\telaboration purposes.\n\t(gnat_to_gnu_entity, subprogram cases): Change loops on formal\n\tparameters to call new Einfo function First_Formal_With_Extras.\n\t(gnat_to_gnu_entity): In type_annotate mode, replace a discriminant of a\n\tprotected type with its corresponding discriminant, to obtain a usable\n\tdeclaration\n\t(gnat_to_gnu_entity) <E_Access_Protected_Subprogram_Type>: Be prepared\n\tfor a multiple elaboration of the \"equivalent\" type.\n\t(gnat_to_gnu_entity): Adjust for renaming of add_global_renaming_pointer\n\tinto record_global_renaming_pointer.\n\t(gnat_to_gnu_entity) <E_Array_Type>: Do not force\n\tTYPE_NONALIASED_COMPONENT to 0 if the element type is an aggregate.\n\t<E_Array_Subtype>: Likewise.\n\t(gnat_to_gnu_entity) <E_Incomplete_Subtype>: Add support for regular\n\tincomplete subtypes and incomplete subtypes of incomplete types visible\n\tthrough a limited with clause.\n\t(gnat_to_gnu_entity) <E_Array_Subtype>: Take into account the bounds of\n\tthe base index type for the maximum size of the array only if they are\n\tconstant.\n\t(gnat_to_gnu_entity, renaming object case): Do not wrap up the\n\texpression into a SAVE_EXPR if stabilization failed.\n\n\t* utils.c (create_subprog_decl): Turn TREE_ADDRESSABLE on the type of\n\ta result decl into DECL_BY_REFERENCE on this decl, now what is expected\n\tby lower level compilation passes.\n\t(gnat_genericize): New function, lowering a function body to GENERIC.\n\tTurn the type of RESULT_DECL into a real reference type if the decl\n\thas been marked DECL_BY_REFERENCE, and adjust references to the latter\n\taccordingly.\n\t(gnat_genericize_r): New function. Tree walking callback for\n\tgnat_genericize.\n\t(convert_from_reference, is_byref_result): New functions. Helpers for\n\tgnat_genericize_r.\n\t(create_type_decl): Call gnat_pushdecl before calling\n\trest_of_decl_compilation, to make sure that field TYPE_NAME of\n\ttype_decl is properly set before calling the debug information writers.\n\t(write_record_type_debug_info): The heuristics which compute the\n\talignment of a field in a variant record might not be accurate. Add a\n\tsafety test to make sure no alignment is set to a smaller value than\n\tthe alignment of the field type.\n\t(make_dummy_type): Use the Non_Limited_View as the underlying type if\n\tthe type comes from a limited_with clause. Do not loop on the full view.\n\t(GET_GNU_TREE, SET_GNU_TREE, PRESENT_GNU_TREE): New macros.\n\t(dummy_node_table): New global variable, moved from decl.c.\n\t(GET_DUMMY_NODE, SET_DUMMY_NODE, PRESENT_DUMMY_NODE): New macros.\n\t(save_gnu_tree): Use above macros.\n\t(get_gnu_tree): Likewise.\n\t(present_gnu_tree): Likewise.\n\t(init_dummy_type): New function, moved from decl.c. Use above macros.\n\t(make_dummy_type): Likewise.\n\t(tree_code_for_record_type): New function extracted from make_dummy_type\n\t(init_gigi_decls): Set DECL_IS_MALLOC on gnat_malloc.\n\t(static_ctors): Change it to a vector, make static.\n\t(static_dtors): Likewise.\n\t(end_subprog_body): Adjust for above change.\n\t(build_global_cdtor): Moved from trans.c.\n\t(gnat_write_global_declarations): Emit global constructor and\n\tdestructor, and call cgraph_optimize before emitting debug info for\n\tglobal declarations.\n\t(global_decls): New global variable.\n\t(gnat_pushdecl): Store the global declarations in global_decls, for\n\tlater use.\n\t(gnat_write_global_declarations): Emit debug information for global\n\t declarations.\n\t(create_var_decl_1): Former create_var_decl, with an extra argument to\n\t state whether the creation of a CONST_DECL is allowed.\n\t(create_var_decl): Behavior unchanged. Now a wrapper around\n\tcreate_var_decl_1 allowing CONST_DECL creation.\n\t(create_true_var_decl): New function, similar to create_var_decl but\n\tforcing the creation of a VAR_DECL node (CONST_DECL not allowed).\n\t(create_field_decl): Do not always mark the field as addressable\n\tif its type is an aggregate.\n\t(global_renaming_pointers): New static variable.\n\t(add_global_renaming_pointer): New function.\n\t(get_global_renaming_pointers): Likewise.\n\n\t* misc.c (gnat_dwarf_name): New function.\n\t(LANG_HOOKS_DWARF_NAME): Define to gnat_dwarf_name.\n\t(gnat_post_options): Add comment about structural alias analysis.\n\t(gnat_parse_file): Do not call cgraph_optimize here.\n\t(LANG_HOOKS_WRITE_GLOBALS): Define to gnat_write_global_declarations.\n\n\t* trans.c (process_freeze_entity): Don't abort if we already have a\n\tnon dummy GCC tree for a Concurrent_Record_Type, as it might\n\tlegitimately have been elaborated while processing the associated\n\tConcurrent_Type prior to this explicit freeze node.\n\t(Identifier_to_gnu): Do not make a variable referenced in a SJLJ\n\texception handler volatile if it is of variable size.\n\t(process_type): Remove bypass for types coming from a limited_with\n\tclause.\n\t(call_to_gnu): When processing the copy-out of a N_Type_Conversion GNAT\n\tactual, convert the corresponding gnu_actual to the real destination\n\ttype when necessary.\n\t(add_decl_expr): Set the DECL_READONLY_ONCE_ELAB flag on variables\n\toriginally TREE_READONLY but whose elaboration cannot be performed\n\tstatically.\n\tPart of fix for F504-021.\n\t(tree_transform, subprogram cases): Change loops on formal parameters to\n\tcall new Einfo function First_Formal_With_Extras.\n\t(gnat_to_gnu) <N_Op_Shift_Right_Arithmetic>: Ignore constant overflow\n\tstemming from type conversion for the lhs.\n\t(Attribute_to_gnu) <Attr_Alignment>: Also divide the alignment by the\n\tnumber of bits per unit for components of records.\n\t(gnat_to_gnu) <N_Code_Statement>: Mark operands addressable if needed.\n\t(Handled_Sequence_Of_Statements_to_gnu): Register the cleanup associated\n\twith At_End_Proc after the SJLJ EH cleanup.\n\t(Compilation_Unit_to_gnu): Call elaborate_all_entities only on the main\n\tcompilation unit.\n\t(elaborate_all_entities): Do not retest type_annotate_only.\n\t(tree_transform) <N_Abstract_Subprogram_Declaration>: Process the\n\tresult type of an abstract subprogram, which may be an itype associated\n\twith an anonymous access result (related to AI-318-02).\n\t(build_global_cdtor): Move to utils.c.\n\t(Case_Statement_to_gnu): Avoid adding the choice of a when statement if\n\tthis choice is not a null tree nor an integer constant.\n\t(gigi): Run unshare_save_expr via walk_tree_without_duplicates\n\ton the body of elaboration routines instead of mark_unvisited.\n\t(add_stmt): Do not mark the tree.\n\t(add_decl_expr): Tweak comment.\n\t(mark_unvisited): Delete.\n\t(unshare_save_expr): New static function.\n\t(call_to_gnu): Issue an error when making a temporary around a\n\tprocedure call because of non-addressable actual parameter if the\n\ttype of the formal is by_reference.\n\t(Compilation_Unit_to_gnu): Invalidate the global renaming pointers\n\tafter building the elaboration routine.\n\nFrom-SVN: r118331", "tree": {"sha": "c5e8ce80b183e80e687e1da8ae37243121191806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5e8ce80b183e80e687e1da8ae37243121191806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8945d5632cc44d3f05178c67b73b666cc64c8a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8945d5632cc44d3f05178c67b73b666cc64c8a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8945d5632cc44d3f05178c67b73b666cc64c8a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8945d5632cc44d3f05178c67b73b666cc64c8a4/comments", "author": null, "committer": null, "parents": [{"sha": "bfc8aa81e42ee0a2284061843b07e8035b91460a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfc8aa81e42ee0a2284061843b07e8035b91460a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfc8aa81e42ee0a2284061843b07e8035b91460a"}], "stats": {"total": 1413, "additions": 949, "deletions": 464}, "files": [{"sha": "0bc81e4d71869f08483eadb160494120782da24b", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=c8945d5632cc44d3f05178c67b73b666cc64c8a4", "patch": "@@ -232,6 +232,10 @@ struct lang_type GTY(()) {tree t; };\n    discriminant.  */\n #define DECL_STUBBED_P(NODE) DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n \n+/* Nonzero in a VAR_DECL if it is guaranteed to be constant after having\n+   been elaborated and TREE_READONLY is not set on it.  */\n+#define DECL_READONLY_ONCE_ELAB(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n+\n /* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF\n    is needed to access the object.  */\n #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)"}, {"sha": "c18f08d74933e8b3a375319280d1223db84eaad3", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 198, "deletions": 226, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=c8945d5632cc44d3f05178c67b73b666cc64c8a4", "patch": "@@ -176,8 +176,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n        : LONG_LONG_TYPE_SIZE);\n   tree gnu_size = 0;\n   bool imported_p\n-    = ((Is_Imported (gnat_entity) && No (Address_Clause (gnat_entity)))\n-       || From_With_Type (gnat_entity));\n+    = (Is_Imported (gnat_entity) && No (Address_Clause (gnat_entity)));\n   unsigned int align = 0;\n \n   /* Since a use of an Itype is a definition, process it as such if it\n@@ -424,6 +423,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    break;\n \t  }\n \n+\telse if (Present (CR_Discriminant (gnat_entity))\n+\t\t && type_annotate_only)\n+\t  {\n+\t    gnu_decl = gnat_to_gnu_entity (CR_Discriminant (gnat_entity),\n+\t\t\t\t\t   gnu_expr, definition);\n+\t    saved = 1;\n+\t    break;\n+\t  }\n+\n \t/* If the enclosing record has explicit stored discriminants,\n \t   then it is an untagged record. If the Corresponding_Discriminant\n \t   is not empty then this must be a renamed discriminant and its\n@@ -815,21 +823,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   object, we just make a \"bare\" pointer, and the renamed\n \t\t   entity is always accessed indirectly through it.  */\n \t\t{\n-\t\t  bool expr_has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n-\n \t\t  inner_const_flag = TREE_READONLY (gnu_expr);\n \t\t  const_flag = true;\n \t\t  gnu_type = build_reference_type (gnu_type);\n \n \t\t  /* If a previous attempt at unrestricted stabilization\n \t\t     failed, there is no point trying again and we can reuse\n-\t\t     the result without attaching it to the pointer.  */\n+\t\t     the result without attaching it to the pointer.  In this\n+\t\t     case it will only be used as the initializing expression\n+\t\t     of the pointer and thus needs no special treatment with\n+\t\t     regard to multiple evaluations.  */\n \t\t  if (maybe_stable_expr)\n \t\t    ;\n \n-\t\t  /* Otherwise, try to stabilize now, restricting to\n-\t\t     lvalues only, and attach the expression to the pointer\n-\t\t     if the stabilization succeeds.\n+\t\t  /* Otherwise, try to stabilize now, restricting to lvalues\n+\t\t     only, and attach the expression to the pointer if the\n+\t\t     stabilization succeeds.\n \n \t\t     Note that this might introduce SAVE_EXPRs and we don't\n \t\t     check whether we're at the global level or not.  This is\n@@ -852,21 +861,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t      if (stabilized)\n \t\t\trenamed_obj = maybe_stable_expr;\n+\n \t\t      /* Attaching is actually performed downstream, as soon\n-\t\t\t as we have a DECL for the pointer we make.  */\n+\t\t\t as we have a VAR_DECL for the pointer we make.  */\n \t\t    }\n \n \t\t  gnu_expr\n \t\t    = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n \n-\t\t  /* If the initial expression has side effects, we might\n-\t\t     still have an unstabilized version at this point (for\n-\t\t     instance if it involves a function call).  Wrap the\n-\t\t     result into a SAVE_EXPR now, in case it happens to be\n-\t\t     referenced several times.  */\n-\t\t  if (expr_has_side_effects && ! stabilized)\n-\t\t    gnu_expr = save_expr (gnu_expr);\n-\n \t\t  gnu_size = NULL_TREE;\n \t\t  used_by_ref = true;\n \t\t}\n@@ -930,7 +932,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Ignore the size.  It's either meaningless or was handled\n \t       above.  */\n \t    gnu_size = NULL_TREE;\n-\t    gnu_type = build_reference_type (gnu_type);\n+\t    /* The address expression contains a conversion from pointer type\n+\t       to the system__address integer type, which means the address\n+\t       of the underlying object escapes.  We therefore have no other\n+\t       choice than forcing the type of the object being defined to\n+\t       alias everything in order to make type-based alias analysis\n+\t       aware that it will dereference the escaped address.\n+\t       ??? This uncovers problems in ACATS at -O2 with the volatility\n+\t       of the original type: it may not be correctly propagated, thus\n+\t       causing PRE to enter an infinite loop creating value numbers\n+\t       out of volatile expressions.  Disable it for now.  */\n+\t    gnu_type\n+\t      = build_reference_type_for_mode (gnu_type, ptr_mode, false);\n \t    gnu_address = convert (gnu_type, gnu_address);\n \t    used_by_ref = true;\n \t    const_flag = !Is_Public (gnat_entity);\n@@ -959,7 +972,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    || (Is_Imported (gnat_entity)\n \t\t&& Has_Stdcall_Convention (gnat_entity)))\n \t  {\n-\t    gnu_type = build_reference_type (gnu_type);\n+\t    /* See the definition case above for the rationale.  */\n+\t    gnu_type\n+\t      = build_reference_type_for_mode (gnu_type, ptr_mode, false);\n \t    gnu_size = NULL_TREE;\n \n \t    gnu_expr = NULL_TREE;\n@@ -1134,17 +1149,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (TREE_CODE (gnu_decl) == VAR_DECL && renamed_obj)\n \t  {\n \t    SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n-\t    DECL_RENAMING_GLOBAL_P (gnu_decl) = global_bindings_p ();\n+\t    if (global_bindings_p ())\n+\t      {\n+\t\tDECL_RENAMING_GLOBAL_P (gnu_decl) = 1;\n+\t\trecord_global_renaming_pointer (gnu_decl);\n+\t      }\n \t  }\n \n-\t/* If we have an address clause and we've made this indirect, it's\n-\t   not enough to merely mark the type as volatile since volatile\n-\t   references only conflict with other volatile references while this\n-\t   reference must conflict with all other references.  So ensure that\n-\t   the dereferenced value has alias set 0.  */\n-\tif (Present (Address_Clause (gnat_entity)) && used_by_ref)\n-\t  DECL_POINTER_ALIAS_SET (gnu_decl) = 0;\n-\n \tif (definition && DECL_SIZE (gnu_decl)\n \t    && get_block_jmpbuf_decl ()\n \t    && (TREE_CODE (DECL_SIZE (gnu_decl)) != INTEGER_CST\n@@ -1169,9 +1180,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n \t  {\n \t    tree gnu_corr_var\n-\t      = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n-\t\t\t\t gnu_expr, false, Is_Public (gnat_entity),\n-\t\t\t\t false, static_p, NULL, gnat_entity);\n+\t      = create_true_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n+\t\t\t\t      gnu_expr, true, Is_Public (gnat_entity),\n+\t\t\t\t      false, static_p, NULL, gnat_entity);\n \n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n \t  }\n@@ -1220,6 +1231,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (No (First_Literal (gnat_entity)))\n \t{\n \t  gnu_type = make_unsigned_type (esize);\n+\t  TYPE_NAME (gnu_type) = gnu_entity_id;\n+\n+\t  /* Set the TYPE_STRING_FLAG for Ada Character and\n+\t     Wide_Character types. This is needed by the dwarf-2 debug writer to\n+\t     distinguish between unsigned integer types and character types.  */\n+\t  TYPE_STRING_FLAG (gnu_type) = 1;\n \t  break;\n \t}\n \n@@ -1734,18 +1751,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    tem = build_array_type (tem, gnu_index_types[index]);\n \t    TYPE_MULTI_ARRAY_P (tem) = (index > 0);\n \n-\t    /* If the type below this an multi-array type, then this\n-\t       does not not have aliased components.\n-\n-\t       ??? Otherwise, for now, we say that any component of aggregate\n-\t       type is addressable because the front end may take 'Reference\n-\t       of it. But we have to make it addressable if it must be passed\n-\t       by reference or it that is the default.  */\n-\t    TYPE_NONALIASED_COMPONENT (tem)\n-\t      = ((TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n-\t\t  && TYPE_MULTI_ARRAY_P (TREE_TYPE (tem))) ? 1\n-\t\t : (!Has_Aliased_Components (gnat_entity)\n-\t\t    && !AGGREGATE_TYPE_P (TREE_TYPE (tem))));\n+\t    /* If the type below this is a multi-array type, then this\n+\t       does not have aliased components.  But we have to make\n+\t       them addressable if it must be passed by reference or\n+\t       if that is the default.  */\n+\t    if ((TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n+\t\t && TYPE_MULTI_ARRAY_P (TREE_TYPE (tem)))\n+\t\t|| (!Has_Aliased_Components (gnat_entity)\n+\t\t    && !must_pass_by_ref (TREE_TYPE (tem))\n+\t\t    && !default_pass_by_ref (TREE_TYPE (tem))))\n+\t      TYPE_NONALIASED_COMPONENT (tem) = 1;\n \t  }\n \n \t/* If an alignment is specified, use it if valid.  But ignore it for\n@@ -1957,13 +1972,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      if ((TREE_CODE (gnu_min) == INTEGER_CST\n \t\t   && !TREE_OVERFLOW (gnu_min)\n \t\t   && !operand_equal_p (gnu_min, gnu_base_base_min, 0))\n-\t\t  || !CONTAINS_PLACEHOLDER_P (gnu_min))\n+\t\t  || !CONTAINS_PLACEHOLDER_P (gnu_min)\n+\t\t  || !(TREE_CODE (gnu_base_min) == INTEGER_CST\n+\t\t       && !TREE_OVERFLOW (gnu_base_min)))\n \t\tgnu_base_min = gnu_min;\n \n \t      if ((TREE_CODE (gnu_max) == INTEGER_CST\n \t\t   && !TREE_OVERFLOW (gnu_max)\n \t\t   && !operand_equal_p (gnu_max, gnu_base_base_max, 0))\n-\t\t  || !CONTAINS_PLACEHOLDER_P (gnu_max))\n+\t\t  || !CONTAINS_PLACEHOLDER_P (gnu_max)\n+\t\t  || !(TREE_CODE (gnu_base_max) == INTEGER_CST\n+\t\t       && !TREE_OVERFLOW (gnu_base_max)))\n \t\tgnu_base_max = gnu_max;\n \n \t      if ((TREE_CODE (gnu_base_min) == INTEGER_CST\n@@ -2054,18 +2073,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      gnu_type = build_array_type (gnu_type, gnu_index_type[index]);\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n-\t    /* If the type below this an multi-array type, then this\n-\t       does not not have aliased components.\n-\n-\t       ??? Otherwise, for now, we say that any component of aggregate\n-\t       type is addressable because the front end may take 'Reference\n-\t       of it. But we have to make it addressable if it must be passed\n-\t       by reference or it that is the default.  */\n-\t      TYPE_NONALIASED_COMPONENT (gnu_type)\n-\t      = ((TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE\n-\t\t  && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type))) ? 1\n-\t\t : (!Has_Aliased_Components (gnat_entity)\n-\t\t    && !AGGREGATE_TYPE_P (TREE_TYPE (gnu_type))));\n+\n+\t      /* If the type below this is a multi-array type, then this\n+\t\t does not have aliased components.  But we have to make\n+\t\t them addressable if it must be passed by reference or\n+\t\t if that is the default.  */\n+\t      if ((TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE\n+\t\t   && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))\n+\t\t  || (!Has_Aliased_Components (gnat_entity)\n+\t\t      && !must_pass_by_ref (TREE_TYPE (gnu_type))\n+\t\t      && !default_pass_by_ref (TREE_TYPE (gnu_type))))\n+\t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n \t    }\n \n \t  /* If we are at file level and this is a multi-dimensional array, we\n@@ -2381,27 +2399,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \t/* Make a node for the record.  If we are not defining the record,\n-\t   suppress expanding incomplete types.  We use the same RECORD_TYPE\n-\t   as for a dummy type and reset TYPE_DUMMY_P to show it's no longer\n-\t   a dummy.\n-\n-\t   It is very tempting to delay resetting this bit until we are done\n-\t   with completing the type, e.g. to let possible intermediate\n-\t   elaboration of access types designating the record know it is not\n-\t   complete and arrange for update_pointer_to to fix things up later.\n-\n-\t   It would be wrong, however, because dummy types are expected only\n-\t   to be created for Ada incomplete or private types, which is not\n-\t   what we have here.  Doing so would make other parts of gigi think\n-\t   we are dealing with a really incomplete or private type, and have\n-\t   nasty side effects, typically on the generation of the associated\n-\t   debugging information.  */\n-\tgnu_type = make_dummy_type (gnat_entity);\n-\tTYPE_DUMMY_P (gnu_type) = 0;\n-\n-\tif (TREE_CODE (TYPE_NAME (gnu_type)) == TYPE_DECL && debug_info_p)\n-\t  DECL_IGNORED_P (TYPE_NAME (gnu_type)) = 0;\n-\n+\t   suppress expanding incomplete types.  */\n+\tgnu_type = make_node (tree_code_for_record_type (gnat_entity));\n+\tTYPE_NAME (gnu_type) = gnu_entity_id;\n+\t/* ??? We should have create_type_decl like in the E_Record_Subtype\n+\t   case below.  Unfortunately this would cause GNU_TYPE to be marked\n+\t   as visited, thus precluding the subtrees of the type that will be\n+\t   built below from being marked as visited when the real TYPE_DECL\n+\t   is eventually created.  A solution could be to devise a special\n+\t   version of the function under the name create_type_stub_decl.  */\n+\tTYPE_STUB_DECL (gnu_type)\n+\t  = build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n \tTYPE_ALIGN (gnu_type) = 0;\n \tTYPE_PACKED (gnu_type) = packed || has_rep;\n \n@@ -2926,10 +2934,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_General_Access_Type:\n       {\n \tEntity_Id gnat_desig_type = Directly_Designated_Type (gnat_entity);\n+\t/* Get the \"full view\" of this entity.  If this is an incomplete\n+\t   entity from a limited with, treat its non-limited view as the\n+\t   full view.  Otherwise, if this is an incomplete or private\n+\t   type, use the full view.  */\n \tEntity_Id gnat_desig_full\n-\t  = ((IN (Ekind (Etype (gnat_desig_type)),\n-\t\t  Incomplete_Or_Private_Kind))\n-\t     ? Full_View (gnat_desig_type) : 0);\n+\t  = (IN (Ekind (gnat_desig_type), Incomplete_Kind)\n+\t     && From_With_Type (gnat_desig_type))\n+\t    ? Non_Limited_View (gnat_desig_type)\n+\t    : IN (Ekind (gnat_desig_type), Incomplete_Or_Private_Kind)\n+\t      ? Full_View (gnat_desig_type)\n+\t      : Empty;\n \t/* We want to know if we'll be seeing the freeze node for any\n \t   incomplete type we may be pointing to.  */\n \tbool in_main_unit\n@@ -3008,6 +3023,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t&& defer_incomplete_level\n \t\t&& !present_gnu_tree (gnat_desig_type)\n \t\t&& Is_Array_Type (gnat_desig_type)\n+\t\t&& ! Is_Constrained (gnat_desig_type))\n+\t    || (in_main_unit && From_With_Type (gnat_entity)\n+\t\t&& (Present (gnat_desig_full)\n+\t\t    ? Present (Freeze_Node (gnat_desig_full))\n+\t\t    : Present (Freeze_Node (gnat_desig_type)))\n+\t\t&& Is_Array_Type (gnat_desig_type)\n \t\t&& !Is_Constrained (gnat_desig_type)))\n \t  {\n \t    tree gnu_old\n@@ -3089,6 +3110,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_desig_type = make_dummy_type (gnat_desig_type);\n \t    made_dummy = true;\n \t  }\n+\n+\t/* If this is a reference from a limited_with type back to our\n+\t   main unit and there's a Freeze_Node for it, either we have\n+\t   already processed the declaration and made the dummy type,\n+\t   in which case we just reuse the latter, or we have not yet,\n+\t   in which case we make the dummy type and it will be reused\n+\t   when the declaration is processed.  In both cases, the pointer\n+\t   eventually created below will be automatically adjusted when\n+\t   the Freeze_Node is processed.  Note that the unconstrained\n+\t   array case is handled above. */\n+\telse if (in_main_unit && From_With_Type (gnat_entity)\n+\t\t && (Present (gnat_desig_full)\n+\t\t     ? Present (Freeze_Node (gnat_desig_full))\n+\t\t     : Present (Freeze_Node (gnat_desig_type))))\n+\t  {\n+\t    gnu_desig_type = make_dummy_type (gnat_desig_type);\n+\t    made_dummy = true;\n+\t  }\n+\n \telse if (gnat_desig_type == gnat_entity)\n \t  {\n \t    gnu_type\n@@ -3097,6 +3137,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t     No_Strict_Aliasing (gnat_entity));\n \t    TREE_TYPE (gnu_type) = TYPE_POINTER_TO (gnu_type) = gnu_type;\n \t  }\n+\n \telse\n \t  gnu_desig_type = gnat_to_gnu_type (gnat_desig_type);\n \n@@ -3210,8 +3251,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (type_annotate_only && No (Equivalent_Type (gnat_entity)))\n \tgnu_type = build_pointer_type (void_type_node);\n       else\n-\t/* The runtime representation is the equivalent type. */\n-\tgnu_type = gnat_to_gnu_type (Equivalent_Type (gnat_entity));\n+\t{\n+\t  /* The runtime representation is the equivalent type. */\n+\t  gnu_type = gnat_to_gnu_type (Equivalent_Type (gnat_entity));\n+\t  maybe_present = 1;\n+\t}\n \n       if (Is_Itype (Directly_Designated_Type (gnat_entity))\n \t  && !present_gnu_tree (Directly_Designated_Type (gnat_entity))\n@@ -3373,7 +3417,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t   gnu_expr, 0);\n \n \t    /* Elaborate any Itypes in the parameters of this entity.  */\n-\t    for (gnat_temp = First_Formal (gnat_entity);\n+\t    for (gnat_temp = First_Formal_With_Extras (gnat_entity);\n \t\t Present (gnat_temp);\n \t\t gnat_temp = Next_Formal_With_Extras (gnat_temp))\n \t      if (Is_Itype (Etype (gnat_temp)))\n@@ -3413,8 +3457,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (kind == E_Function\n \t\t && Mechanism (gnat_entity) == By_Reference)\n \t  {\n-\t    gnu_return_type = copy_type (gnu_return_type);\n \t    TREE_ADDRESSABLE (gnu_return_type) = 1;\n+\n+\t    /* We expect this bit to be reset by gigi shortly, so can avoid a\n+\t       type node copy here.  This actually also prevents troubles with\n+\t       the generation of debug information for the function, because\n+\t       we might have issued such info for this type already, and would\n+\t       be attaching a distinct type node to the function if we made a\n+\t       copy here.  */\n \t  }\n \n \t/* If we are supposed to return an unconstrained array,\n@@ -3479,7 +3529,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   each.  While doing this, build a copy-out structure if\n \t   we need one.  */\n \n-\tfor (gnat_param = First_Formal (gnat_entity), parmnum = 0;\n+\tfor (gnat_param = First_Formal_With_Extras (gnat_entity), parmnum = 0;\n \t     Present (gnat_param);\n \t     gnat_param = Next_Formal_With_Extras (gnat_param), parmnum++)\n \t  {\n@@ -3858,71 +3908,76 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Incomplete_Type:\n+    case E_Incomplete_Subtype:\n     case E_Private_Type:\n-    case E_Limited_Private_Type:\n-    case E_Record_Type_With_Private:\n     case E_Private_Subtype:\n+    case E_Limited_Private_Type:\n     case E_Limited_Private_Subtype:\n+    case E_Record_Type_With_Private:\n     case E_Record_Subtype_With_Private:\n-\n-      /* If this type does not have a full view in the unit we are\n-\t compiling, then just get the type from its Etype.  */\n-      if (No (Full_View (gnat_entity)))\n-\t{\n-\t  /* If this is an incomplete type with no full view, it must be\n-\t     either a limited view brought in by a limited_with clause, in\n-\t     which case we use the non-limited view, or a Taft Amendement\n-\t     type, in which case we just return a dummy type.  */\n-\t  if (kind == E_Incomplete_Type)\n-\t    {\n-\t      if (From_With_Type (gnat_entity)\n-\t\t  && Present (Non_Limited_View (gnat_entity)))\n-\t\tgnu_decl = gnat_to_gnu_entity (Non_Limited_View (gnat_entity),\n+      {\n+\t/* Get the \"full view\" of this entity.  If this is an incomplete\n+\t   entity from a limited with, treat its non-limited view as the\n+\t   full view.  Otherwise, use either the full view or the underlying\n+\t   full view, whichever is present.  This is used in all the tests\n+\t   below.  */\n+\tEntity_Id full_view\n+\t  = (IN (Ekind (gnat_entity), Incomplete_Kind)\n+\t     && From_With_Type (gnat_entity))\n+\t    ? Non_Limited_View (gnat_entity)\n+\t    : Present (Full_View (gnat_entity))\n+\t      ? Full_View (gnat_entity)\n+\t      : Underlying_Full_View (gnat_entity);\n+\n+\t/* If this is an incomplete type with no full view, it must be a Taft\n+\t   Amendment type, in which case we return a dummy type.  Otherwise,\n+\t   just get the type from its Etype.  */\n+\tif (No (full_view))\n+\t  {\n+\t    if (kind == E_Incomplete_Type)\n+\t      gnu_type = make_dummy_type (gnat_entity);\n+\t    else\n+\t      {\n+\t\tgnu_decl = gnat_to_gnu_entity (Etype (gnat_entity),\n \t\t\t\t\t       NULL_TREE, 0);\n-\t      else\n-\t\tgnu_type = make_dummy_type (gnat_entity);\n-\t    }\n-\n-\t  else if (Present (Underlying_Full_View (gnat_entity)))\n-\t    gnu_decl = gnat_to_gnu_entity (Underlying_Full_View (gnat_entity),\n-\t\t\t\t\t   NULL_TREE, 0);\n-\t  else\n-\t    {\n-\t      gnu_decl = gnat_to_gnu_entity (Etype (gnat_entity),\n-\t\t\t\t\t     NULL_TREE, 0);\n-\t      maybe_present = true;\n-\t    }\n-\n-\t  break;\n-\t}\n+\t\tmaybe_present = true;\n+\t      }\n+\t    break;\n+\t  }\n \n-      /* Otherwise, if we are not defining the type now, get the\n-\t type from the full view. But always get the type from the full\n-\t view for define on use types, since otherwise we won't see them! */\n+\t/* If we already made a type for the full view, reuse it.  */\n+\telse if (present_gnu_tree (full_view))\n+\t  {\n+\t    gnu_decl = get_gnu_tree (full_view);\n+\t    break;\n+\t  }\n \n-      else if (!definition\n-\t       || (Is_Itype (Full_View (gnat_entity))\n+\t/* Otherwise, if we are not defining the type now, get the type\n+\t   from the full view.  But always get the type from the full view\n+\t   for define on use types, since otherwise we won't see them!  */\n+\telse if (!definition\n+\t\t || (Is_Itype (full_view)\n \t\t   && No (Freeze_Node (gnat_entity)))\n-\t       || (Is_Itype (gnat_entity)\n-\t\t   && No (Freeze_Node (Full_View (gnat_entity)))))\n-\t{\n-\t  gnu_decl = gnat_to_gnu_entity (Full_View (gnat_entity),\n-                                         NULL_TREE, 0);\n-\t  maybe_present = true;\n-\t  break;\n-\t}\n+\t\t || (Is_Itype (gnat_entity)\n+\t\t   && No (Freeze_Node (full_view))))\n+\t  {\n+\t    gnu_decl = gnat_to_gnu_entity (full_view, NULL_TREE, 0);\n+\t    maybe_present = true;\n+\t    break;\n+\t  }\n \n-      /* For incomplete types, make a dummy type entry which will be\n-\t replaced later.  */\n-      gnu_type = make_dummy_type (gnat_entity);\n+\t/* For incomplete types, make a dummy type entry which will be\n+\t   replaced later.  */\n+\tgnu_type = make_dummy_type (gnat_entity);\n \n-      /* Save this type as the full declaration's type so we can do any needed\n-\t updates when we see it.  */\n-      gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n-\t\t\t\t   !Comes_From_Source (gnat_entity),\n-\t\t\t\t   debug_info_p, gnat_entity);\n-      save_gnu_tree (Full_View (gnat_entity), gnu_decl, false);\n-      break;\n+\t/* Save this type as the full declaration's type so we can do any\n+\t   needed updates when we see it.  */\n+\tgnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\t\t\t\t     !Comes_From_Source (gnat_entity),\n+\t\t\t\t     debug_info_p, gnat_entity);\n+\tsave_gnu_tree (full_view, gnu_decl, 0);\n+\tbreak;\n+      }\n \n       /* Simple class_wide types are always viewed as their root_type\n \t by Gigi unless an Equivalent_Type is specified.  */\n@@ -4521,88 +4576,6 @@ substitution_list (Entity_Id gnat_subtype, Entity_Id gnat_type,\n   return gnu_list;\n }\n \f\n-/* For the following two functions: for each GNAT entity, the GCC\n-   tree node used as a dummy for that entity, if any.  */\n-\n-static GTY((length (\"max_gnat_nodes\"))) tree * dummy_node_table;\n-\n-/* Initialize the above table.  */\n-\n-void\n-init_dummy_type (void)\n-{\n-  Node_Id gnat_node;\n-\n-  dummy_node_table = (tree *) ggc_alloc (max_gnat_nodes * sizeof (tree));\n-\n-  for (gnat_node = 0; gnat_node < max_gnat_nodes; gnat_node++)\n-    dummy_node_table[gnat_node] = NULL_TREE;\n-\n-  dummy_node_table -= First_Node_Id;\n-}\n-\n-/* Make a dummy type corresponding to GNAT_TYPE.  */\n-\n-tree\n-make_dummy_type (Entity_Id gnat_type)\n-{\n-  Entity_Id gnat_underlying;\n-  tree gnu_type;\n-  enum tree_code code;\n-\n-  /* Find a full type for GNAT_TYPE, taking into account any class wide\n-     types.  */\n-  if (Is_Class_Wide_Type (gnat_type) && Present (Equivalent_Type (gnat_type)))\n-    gnat_type = Equivalent_Type (gnat_type);\n-  else if (Ekind (gnat_type) == E_Class_Wide_Type)\n-    gnat_type = Root_Type (gnat_type);\n-\n-  for (gnat_underlying = gnat_type;\n-       (IN (Ekind (gnat_underlying), Incomplete_Or_Private_Kind)\n-\t&& Present (Full_View (gnat_underlying)));\n-       gnat_underlying = Full_View (gnat_underlying))\n-    ;\n-\n-  /* If it there already a dummy type, use that one.  Else make one.  */\n-  if (dummy_node_table[gnat_underlying])\n-    return dummy_node_table[gnat_underlying];\n-\n-  /* If this is a record, make this a RECORD_TYPE or UNION_TYPE; else make\n-     it an ENUMERAL_TYPE.  */\n-  if (Is_Record_Type (gnat_underlying))\n-    {\n-      Node_Id component_list\n-\t= Component_List (Type_Definition\n-\t\t\t  (Declaration_Node\n-\t\t\t   (Implementation_Base_Type (gnat_underlying))));\n-      Node_Id component;\n-\n-      /* Make this a UNION_TYPE unless it's either not an Unchecked_Union or\n-\t we have a non-discriminant field outside a variant.  In either case,\n-\t it's a RECORD_TYPE.  */\n-      code = UNION_TYPE;\n-      if (!Is_Unchecked_Union (gnat_underlying))\n-\tcode = RECORD_TYPE;\n-      else\n-\tfor (component = First_Non_Pragma (Component_Items (component_list));\n-\t     Present (component); component = Next_Non_Pragma (component))\n-\t  if (Ekind (Defining_Entity (component)) == E_Component)\n-\t    code = RECORD_TYPE;\n-    }\n-  else\n-    code = ENUMERAL_TYPE;\n-\n-  gnu_type = make_node (code);\n-  TYPE_NAME (gnu_type) = get_entity_name (gnat_type);\n-  TYPE_DUMMY_P (gnu_type) = 1;\n-  if (AGGREGATE_TYPE_P (gnu_type))\n-    TYPE_STUB_DECL (gnu_type) = build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n-\n-  dummy_node_table[gnat_underlying] = gnu_type;\n-\n-  return gnu_type;\n-}\n-\f\n /* Return true if the size represented by GNU_SIZE can be handled by an\n    allocation.  If STATIC_P is true, consider only what can be done with a\n    static allocation.  */\n@@ -4830,7 +4803,8 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n \n   expr_variable = (!CONSTANT_CLASS_P (gnu_expr)\n \t\t   && !(TREE_CODE (gnu_inner_expr) == VAR_DECL\n-\t\t\t&& TREE_READONLY (gnu_inner_expr))\n+\t\t\t&& (TREE_READONLY (gnu_inner_expr)\n+\t\t\t    || DECL_READONLY_ONCE_ELAB (gnu_inner_expr)))\n \t\t   && !CONTAINS_PLACEHOLDER_P (gnu_expr));\n \n   /* If this is a static expression or contains a discriminant, we don't\n@@ -6875,5 +6849,3 @@ concat_id_with_name (tree gnu_id, const char *suffix)\n   strcpy (Name_Buffer + len, suffix);\n   return get_identifier (Name_Buffer);\n }\n-\n-#include \"gt-ada-decl.h\""}, {"sha": "1c1c161334dd84ab599e1209b3725f01c165bf6d", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=c8945d5632cc44d3f05178c67b73b666cc64c8a4", "patch": "@@ -380,9 +380,6 @@ enum standard_datatypes\n extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n \n-extern GTY(()) tree static_ctors;\n-extern GTY(()) tree static_dtors;\n-\n #define longest_float_type_node gnat_std_decls[(int) ADT_longest_float_type]\n #define void_type_decl_node gnat_std_decls[(int) ADT_void_type_decl]\n #define except_type_node gnat_std_decls[(int) ADT_except_type]\n@@ -448,6 +445,9 @@ extern tree gnat_type_for_size (unsigned precision, int unsignedp);\n    an unsigned type; otherwise a signed type is returned.  */\n extern tree gnat_type_for_mode (enum machine_mode mode, int unsignedp);\n \n+/* Emit debug info for all global variable declarations.  */\n+extern void gnat_write_global_declarations (void);\n+\n /* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n extern tree gnat_unsigned_type (tree type_node);\n \n@@ -533,10 +533,11 @@ extern tree create_type_decl (tree type_name, tree type,\n                               bool artificial_p, bool debug_info_p,\n \t\t\t      Node_Id gnat_node);\n \n-/* Returns a GCC VAR_DECL node. VAR_NAME gives the name of the variable.\n-   ASM_NAME is its assembler name (if provided).  TYPE is\n-   its data type (a GCC ..._TYPE node).  VAR_INIT is the GCC tree for an\n-   optional initial expression; NULL_TREE if none.\n+/* Returns a GCC VAR_DECL or CONST_DECL node.\n+\n+   VAR_NAME gives the name of the variable.  ASM_NAME is its assembler name\n+   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  VAR_INIT is\n+   the GCC tree for an optional initial expression; NULL_TREE if none.\n \n    CONST_FLAG is true if this variable is constant.\n \n@@ -556,9 +557,22 @@ extern tree create_var_decl (tree var_name, tree asm_name, tree type,\n                              bool static_flag,\n \t\t\t     struct attrib *attr_list, Node_Id gnat_node);\n \n+/* Similar to create_var_decl, forcing the creation of a VAR_DECL node.  */\n+extern tree create_true_var_decl (tree var_name, tree asm_name, tree type,\n+\t\t\t\t  tree var_init, bool const_flag,\n+\t\t\t\t  bool public_flag, bool extern_flag,\n+\t\t\t\t  bool static_flag,\n+\t\t\t\t  struct attrib *attr_list, Node_Id gnat_node);\n+\n /* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n extern void process_attributes (tree decl, struct attrib *attr_list);\n \n+/* Record a global renaming pointer.  */\n+void record_global_renaming_pointer (tree);\n+\n+/* Invalidate the global renaming pointers.   */\n+void invalidate_global_renaming_pointers (void);\n+\n /* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n    this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n@@ -656,6 +670,10 @@ extern tree maybe_unconstrained_array (tree exp);\n    If NOTRUNC_P is true, truncation operations should be suppressed.  */\n extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n \n+/* Return the appropriate GCC tree code for the specified GNAT type,\n+   the latter being a record type as predicated by Is_Record_Type.  */\n+extern enum tree_code tree_code_for_record_type (Entity_Id);\n+\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n "}, {"sha": "c6fb0d95a01fdc60709a82a64ed166774fbcbaf0", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=c8945d5632cc44d3f05178c67b73b666cc64c8a4", "patch": "@@ -127,6 +127,8 @@ static tree gnat_type_max_size\t\t(tree);\n #define LANG_HOOKS_GETDECLS\t\tlhd_return_null_tree_v\n #undef  LANG_HOOKS_PUSHDECL\n #define LANG_HOOKS_PUSHDECL\t\tlhd_return_tree\n+#undef  LANG_HOOKS_WRITE_GLOBALS\n+#define LANG_HOOKS_WRITE_GLOBALS      gnat_write_global_declarations\n #undef  LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n #undef\tLANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS\n@@ -233,23 +235,22 @@ gnat_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n {\n   int seh[2];\n \n-  /* call the target specific initializations */\n+  /* Call the target specific initializations.  */\n   __gnat_initialize (NULL);\n \n-  /* ??? call the SEH initialization routine, this is to workaround a\n-  bootstrap path problem. The call below should be removed at some point and\n-  the seh pointer passed to __gnat_initialize() above.  */\n-\n+  /* ??? Call the SEH initialization routine.  This is to workaround\n+  a bootstrap path problem.  The call below should be removed at some\n+  point and the SEH pointer passed to __gnat_initialize() above.  */\n   __gnat_install_SEH_handler((void *)seh);\n \n-  /* Call the front-end elaboration procedures */\n+  /* Call the front-end elaboration procedures.  */\n   adainit ();\n \n-  /* Call the front end */\n+  /* Call the front end.  */\n   _ada_gnat1drv ();\n \n+  /* We always have a single compilation unit in Ada.  */\n   cgraph_finalize_compilation_unit ();\n-  cgraph_optimize ();\n }\n \n /* Decode all the language specific options that cannot be decoded by GCC.\n@@ -365,6 +366,9 @@ gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n   if (flag_inline_functions)\n     flag_inline_trees = 2;\n \n+  /* The structural alias analysis machinery essentially assumes that\n+     everything is addressable (modulo bit-fields) by disregarding\n+     the TYPE_NONALIASED_COMPONENT and DECL_NONADDRESSABLE_P macros.  */\n   flag_tree_salias = 0;\n \n   return false;\n@@ -771,7 +775,7 @@ gnat_type_max_size (tree gnu_type)\n       && TYPE_ADA_SIZE (gnu_type))\n     {\n       tree max_adasize = max_size (TYPE_ADA_SIZE (gnu_type), true);\n-      \n+\n       /* If we have succeded in finding a constant, round it up to the\n \t type's alignment and return the result in byte units.  */\n "}, {"sha": "eaa6fc64aff9449128165cd2433c3d516b51e7f1", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 272, "deletions": 181, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=c8945d5632cc44d3f05178c67b73b666cc64c8a4", "patch": "@@ -149,7 +149,7 @@ static void insert_code_for (Node_Id);\n static void start_stmt_group (void);\n static void add_cleanup (tree);\n static tree mark_visited (tree *, int *, void *);\n-static tree mark_unvisited (tree *, int *, void *);\n+static tree unshare_save_expr (tree *, int *, void *);\n static tree end_stmt_group (void);\n static void add_stmt_list (List_Id);\n static tree build_stmt_group (List_Id, bool);\n@@ -171,7 +171,6 @@ static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference_1 (tree, bool);\n static void annotate_with_node (tree, Node_Id);\n-static void build_global_cdtor (int, tree *);\n \n \f\n /* This is the main program of the back-end.  It sets up all the table\n@@ -252,8 +251,15 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       tree gnu_body = DECL_SAVED_TREE (info->elab_proc);\n       tree gnu_stmts;\n \n-      /* Mark everything we have as not visited.  */\n-      walk_tree_without_duplicates (&gnu_body, mark_unvisited, NULL);\n+      /* Unshare SAVE_EXPRs between subprograms.  These are not unshared by\n+\t the gimplifier for obvious reasons, but it turns out that we need to\n+\t unshare them for the global level because of SAVE_EXPRs made around\n+\t checks for global objects and around allocators for global objects\n+\t of variable size, in order to prevent node sharing in the underlying\n+\t expression.  Note that this implicitly assumes that the SAVE_EXPR\n+\t nodes themselves are not shared between subprograms, which would be\n+\t an upstream bug for which we would not change the outcome.  */\n+      walk_tree_without_duplicates (&gnu_body, unshare_save_expr, NULL);\n \n       /* Set the current function to be the elaboration procedure and gimplify\n \t what we have.  */\n@@ -382,10 +388,17 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      handler, only if it is referenced in the handler and declared in an\n      enclosing block, but we have no way of testing that right now.\n \n-     ??? Also, for now all we can do is make it volatile.  But we only\n-     do this for SJLJ.  */\n+     ??? We used to essentially set the TREE_ADDRESSABLE flag on the variable\n+\ufffd \ufffd \ufffdhere, but it can now be removed by the Tree aliasing machinery if the\n+\ufffd \ufffd \ufffdaddress of the variable is never taken. \ufffdAll we can do is to make the\n+\ufffd \ufffd \ufffdvariable volatile, which might incur the generation of temporaries just\n+     to access the memory in some circumstances. \ufffdThis can be avoided for\n+\ufffd \ufffd \ufffdvariables of non-constant size because they are automatically allocated\n+\ufffd \ufffd \ufffdto memory.  There might be no way of allocating a proper temporary for\n+     them in any case.  We only do this for SJLJ though.  */\n   if (TREE_VALUE (gnu_except_ptr_stack)\n-      && TREE_CODE (gnu_result) == VAR_DECL)\n+      && TREE_CODE (gnu_result) == VAR_DECL\n+      && TREE_CODE (DECL_SIZE_UNIT (gnu_result)) == INTEGER_CST)\n     TREE_THIS_VOLATILE (gnu_result) = TREE_SIDE_EFFECTS (gnu_result) = 1;\n \n   /* Some objects (such as parameters passed by reference, globals of\n@@ -452,18 +465,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t    == Attr_Unchecked_Access)\n \t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n \t\t\t   == Attr_Unrestricted_Access)))))\n-\t{\n-\t  gnu_result = DECL_INITIAL (gnu_result);\n-\t  /* ??? The mark/unmark mechanism implemented in Gigi to prevent tree\n-\t     sharing between global level and subprogram level doesn't apply\n-\t     to elaboration routines.  As a result, the DECL_INITIAL tree may\n-\t     be shared between the static initializer of a global object and\n-\t     the elaboration routine, thus wreaking havoc if a local temporary\n-\t     is created in place during gimplification of the latter and the\n-\t     former is emitted afterwards.  Manually unshare for now.  */\n-\t  if (TREE_VISITED (gnu_result))\n-\t    gnu_result = unshare_expr (gnu_result);\n-\t}\n+\tgnu_result = DECL_INITIAL (gnu_result);\n     }\n \n   *gnu_result_type_p = gnu_result_type;\n@@ -795,10 +797,9 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       prefix_unused = true;\n \n-      if (TREE_CODE (gnu_prefix) == COMPONENT_REF)\n-\tgnu_result = size_int (DECL_ALIGN (TREE_OPERAND (gnu_prefix, 1)));\n-      else\n-\tgnu_result = size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT);\n+      gnu_result = size_int ((TREE_CODE (gnu_prefix) == COMPONENT_REF\n+\t\t\t      ? DECL_ALIGN (TREE_OPERAND (gnu_prefix, 1))\n+\t\t\t      : TYPE_ALIGN (gnu_type)) / BITS_PER_UNIT);\n       break;\n \n     case Attr_First:\n@@ -1145,6 +1146,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n        gnat_when = Next_Non_Pragma (gnat_when))\n     {\n       Node_Id gnat_choice;\n+      int choices_added = 0;\n \n       /* First compile all the different case choices for the current WHEN\n \t alternative.  */\n@@ -1195,18 +1197,33 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t      gcc_unreachable ();\n \t    }\n \n-\t  add_stmt_with_node (build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t\t      gnu_low, gnu_high,\n-\t\t\t\t      create_artificial_label ()),\n-\t\t\t      gnat_choice);\n+         /* If the case value is a subtype that raises Constraint_Error at\n+             run-time because of a wrong bound, then gnu_low or gnu_high\n+             is not transtaleted into an INTEGER_CST.  In such a case, we need\n+             to ensure that the when statement is not added in the tree,\n+             otherwise it will crash the gimplifier.  */\n+         if ((!gnu_low || TREE_CODE (gnu_low) == INTEGER_CST)\n+              && (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST))\n+          {\n+\n+             add_stmt_with_node (build3 (CASE_LABEL_EXPR, void_type_node,\n+                                         gnu_low, gnu_high,\n+                                         create_artificial_label ()),\n+                                 gnat_choice);\n+             choices_added++;\n+          }\n \t}\n \n       /* Push a binding level here in case variables are declared since we want\n-\t them to be local to this set of statements instead of the block\n-\t containing the Case statement.  */\n-      add_stmt (build_stmt_group (Statements (gnat_when), true));\n-      add_stmt (build1 (GOTO_EXPR, void_type_node,\n-\t\t\tTREE_VALUE (gnu_switch_label_stack)));\n+         them to be local to this set of statements instead of the block\n+         containing the Case statement.  */\n+\n+       if (choices_added > 0)\n+       {\n+         add_stmt (build_stmt_group (Statements (gnat_when), true));\n+         add_stmt (build1 (GOTO_EXPR, void_type_node,\n+                           TREE_VALUE (gnu_switch_label_stack)));\n+       }\n     }\n \n   /* Now emit a definition of the label all the cases branched to. */\n@@ -1484,7 +1501,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      nodes here.  Fill them in to TYPE_CI_CO_LIST, which must contain the empty\n      entry as well.  We can match up the entries because TYPE_CI_CO_LIST is in\n      the order of the parameters.  */\n-  for (gnat_param = First_Formal (gnat_subprog_id);\n+  for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n        Present (gnat_param);\n        gnat_param = Next_Formal_With_Extras (gnat_param))\n     if (!present_gnu_tree (gnat_param))\n@@ -1570,7 +1587,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* Disconnect the trees for parameters that we made variables for from the\n      GNAT entities since these are unusable after we end the function.  */\n-  for (gnat_param = First_Formal (gnat_subprog_id);\n+  for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n        Present (gnat_param);\n        gnat_param = Next_Formal_With_Extras (gnat_param))\n     if (TREE_CODE (get_gnu_tree (gnat_param)) == VAR_DECL)\n@@ -1687,12 +1704,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n      type the access type is pointing to.  Otherwise, get the formals from\n      entity being called.  */\n   if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n-    gnat_formal = First_Formal (Etype (Name (gnat_node)));\n+    gnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)\n     /* Assume here that this must be 'Elab_Body or 'Elab_Spec.  */\n     gnat_formal = 0;\n   else\n-    gnat_formal = First_Formal (Entity (Name (gnat_node)));\n+    gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n \n   /* Create the list of the actual parameters as GCC expects it, namely a chain\n      of TREE_LIST nodes in which the TREE_VALUE field of each node is a\n@@ -1741,6 +1758,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      tree gnu_copy = gnu_name;\n \t      tree gnu_temp;\n \n+\t      /* If the type is by_reference, a copy is not allowed.  */\n+\t      if (Is_By_Reference_Type (Etype (gnat_formal)))\n+\t\tpost_error\n+\t\t  (\"misaligned & cannot be passed by reference\", gnat_actual);\n+\n \t      /* For users of Starlet we issue a warning because the\n \t\t interface apparently assumes that by-ref parameters\n \t\t outlive the procedure invocation.  The code still\n@@ -1749,7 +1771,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t would allocate temporaries at will because of the\n \t\t misalignment if we did not do so here.  */\n \n-\t      if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n+\t      else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n \t\t{\n \t\t  post_error\n \t\t    (\"?possible violation of implicit assumption\",\n@@ -1889,6 +1911,13 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      && !addressable_p (gnu_actual))\n \t    gnu_actual = TREE_OPERAND (gnu_actual, 0);\n \n+\t  /* For In parameters, gnu_actual might still not be addressable at\n+\t     this point and we need the creation of a temporary copy since\n+\t     this is to be passed by ref.  Resorting to save_expr to force a\n+\t     SAVE_EXPR temporary creation here is not guaranteed to work\n+\t     because the actual might be invariant or readonly without side\n+\t     effects, so we let the gimplifier process this case.  */\n+\n \t  /* The symmetry of the paths to the type of an entity is broken here\n \t     since arguments don't know that they will be passed by ref. */\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n@@ -2026,9 +2055,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t}\n \n       if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n-\tgnat_formal = First_Formal (Etype (Name (gnat_node)));\n+\tgnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n       else\n-\tgnat_formal = First_Formal (Entity (Name (gnat_node)));\n+\tgnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n \n       for (gnat_actual = First_Actual (gnat_node);\n \t   Present (gnat_actual);\n@@ -2053,8 +2082,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t: build_component_ref (gnu_subprog_call, NULL_TREE,\n \t\t\t\t       TREE_PURPOSE (scalar_return_list),\n \t\t\t\t       false);\n-\t    bool unchecked_conversion = (Nkind (gnat_actual)\n-\t\t\t\t\t == N_Unchecked_Type_Conversion);\n+\n \t    /* If the actual is a conversion, get the inner expression, which\n \t       will be the real destination, and convert the result to the\n \t       type of the actual parameter.  */\n@@ -2068,16 +2096,33 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t\t       (TREE_TYPE (gnu_result))),\n \t\t\t\t    gnu_result);\n \n-\t    /* If the result is a type conversion, do it.  */\n+\t    /* If the actual is a type conversion, the real target object is\n+\t       denoted by the inner Expression and we need to convert the\n+\t       result to the associated type.\n+\n+\t       We also need to convert our gnu assignment target to this type\n+\t       if the corresponding gnu_name was constructed from the GNAT\n+\t       conversion node and not from the inner Expression.  */\n \t    if (Nkind (gnat_actual) == N_Type_Conversion)\n-\t      gnu_result\n-\t\t= convert_with_check\n-\t\t  (Etype (Expression (gnat_actual)), gnu_result,\n-\t\t   Do_Overflow_Check (gnat_actual),\n-\t\t   Do_Range_Check (Expression (gnat_actual)),\n-\t\t   Float_Truncate (gnat_actual));\n+\t      {\n+\t\tgnu_result\n+\t\t  = convert_with_check\n+\t\t    (Etype (Expression (gnat_actual)), gnu_result,\n+\t\t     Do_Overflow_Check (gnat_actual),\n+\t\t     Do_Range_Check (Expression (gnat_actual)),\n+\t\t     Float_Truncate (gnat_actual));\n+\n+\t\tif (!Is_Composite_Type\n+\t\t     (Underlying_Type (Etype (gnat_formal))))\n+\t\t  gnu_actual\n+\t\t    = convert (TREE_TYPE (gnu_result), gnu_actual);\n+\t      }\n \n-\t    else if (unchecked_conversion)\n+\t    /* Unchecked conversions as actuals for out parameters are not\n+\t       allowed in user code because they are not variables, but do\n+\t       occur in front-end expansions.  The associated gnu_name is\n+\t       always obtained from the inner expression in such cases.  */\n+\t    else if (Nkind (gnat_actual) == N_Unchecked_Type_Conversion)\n \t      gnu_result = unchecked_convert (TREE_TYPE (gnu_actual),\n \t\t\t\t\t      gnu_result,\n \t\t\t\t\t      No_Truncation (gnat_actual));\n@@ -2152,11 +2197,6 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       gnat_pushlevel ();\n     }\n \n-  /* If we are to call a function when exiting this block add a cleanup\n-     to the binding level we made above.  */\n-  if (at_end)\n-    add_cleanup (build_call_0_expr (gnat_to_gnu (At_End_Proc (gnat_node))));\n-\n   /* If using setjmp_longjmp, make the variables for the setjmp buffer and save\n      area for address of previous buffer.  Do this first since we need to have\n      the setjmp buf known for any decls in this block.  */\n@@ -2183,6 +2223,12 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       add_cleanup (build_call_1_expr (set_jmpbuf_decl, gnu_jmpsave_decl));\n     }\n \n+  /* If we are to call a function when exiting this block, add a cleanup\n+     to the binding level we made above.  Note that add_cleanup is FIFO\n+     so we must register this cleanup after the EH cleanup just above.  */\n+  if (at_end)\n+    add_cleanup (build_call_0_expr (gnat_to_gnu (At_End_Proc (gnat_node))));\n+\n   /* Now build the tree for the declarations and statements inside this block.\n      If this is SJLJ, set our jmp_buf as the current buffer.  */\n   start_stmt_group ();\n@@ -2525,7 +2571,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n \n   process_inlined_subprograms (gnat_node);\n \n-  if (type_annotate_only)\n+  if (type_annotate_only && gnat_node == Cunit (Main_Unit))\n     {\n       elaborate_all_entities (gnat_node);\n \n@@ -2558,14 +2604,10 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n      we did or not.  */\n   pop_stack (&gnu_elab_proc_stack);\n \n-  /* Generate functions to call static constructors and destructors\n-     for targets that do not support .ctors/.dtors sections.  These\n-     functions have magic names which are detected by collect2.  */\n-  if (static_ctors)\n-    build_global_cdtor ('I', &static_ctors);\n-\n-  if (static_dtors)\n-    build_global_cdtor ('D', &static_dtors);\n+  /* Invalidate the global renaming pointers.  This is necessary because\n+     stabilization of the renamed entities may create SAVE_EXPRs which\n+     have been tied to a specific elaboration routine just above.  */\n+  invalidate_global_renaming_pointers ();\n }\n \f\n /* This function is the driver of the GNAT to GCC tree transformation\n@@ -3330,6 +3372,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_And_Then: case N_Or_Else:\n       {\n \tenum tree_code code = gnu_codes[Nkind (gnat_node)];\n+\tbool ignore_lhs_overflow = false;\n \ttree gnu_type;\n \n \tgnu_lhs = gnat_to_gnu (Left_Opnd (gnat_node));\n@@ -3378,17 +3421,32 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  }\n \n \t/* For right shifts, the type says what kind of shift to do,\n-\t   so we may need to choose a different type.  */\n+\t   so we may need to choose a different type.  In this case,\n+\t   we have to ignore integer overflow lest it propagates all\n+\t   the way down and causes a CE to be explicitly raised.  */\n \tif (Nkind (gnat_node) == N_Op_Shift_Right\n \t    && !TYPE_UNSIGNED (gnu_type))\n-\t  gnu_type = gnat_unsigned_type (gnu_type);\n+\t  {\n+\t    gnu_type = gnat_unsigned_type (gnu_type);\n+\t    ignore_lhs_overflow = true;\n+\t  }\n \telse if (Nkind (gnat_node) == N_Op_Shift_Right_Arithmetic\n \t\t && TYPE_UNSIGNED (gnu_type))\n-\t  gnu_type = gnat_signed_type (gnu_type);\n+\t  {\n+\t    gnu_type = gnat_signed_type (gnu_type);\n+\t    ignore_lhs_overflow = true;\n+\t  }\n \n \tif (gnu_type != gnu_result_type)\n \t  {\n+\t    tree gnu_old_lhs = gnu_lhs;\n \t    gnu_lhs = convert (gnu_type, gnu_lhs);\n+\t    if (TREE_CODE (gnu_lhs) == INTEGER_CST && ignore_lhs_overflow)\n+\t      {\n+\t\tTREE_OVERFLOW (gnu_lhs) = TREE_OVERFLOW (gnu_old_lhs);\n+\t\tTREE_CONSTANT_OVERFLOW (gnu_lhs)\n+\t\t  = TREE_CONSTANT_OVERFLOW (gnu_old_lhs);\n+\t      }\n \t    gnu_rhs = convert (gnu_type, gnu_rhs);\n \t  }\n \n@@ -3773,16 +3831,31 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Abstract_Subprogram_Declaration:\n       /* This subprogram doesn't exist for code generation purposes, but we\n-\t have to elaborate the types of any parameters, unless they are\n-\t imported types (nothing to generate in this case).  */\n+\t have to elaborate the types of any parameters and result, unless\n+\t they are imported types (nothing to generate in this case).  */\n+\n+      /* Process the parameter types first.  */\n+\n       for (gnat_temp\n-\t   = First_Formal (Defining_Entity (Specification (gnat_node)));\n+\t   = First_Formal_With_Extras\n+\t       (Defining_Entity (Specification (gnat_node)));\n \t   Present (gnat_temp);\n \t   gnat_temp = Next_Formal_With_Extras (gnat_temp))\n \tif (Is_Itype (Etype (gnat_temp))\n \t    && !From_With_Type (Etype (gnat_temp)))\n \t  gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, 0);\n \n+\n+      /* Then the result type, set to Standard_Void_Type for procedures.  */\n+\n+      {\n+\tEntity_Id gnat_temp_type\n+\t  = Etype (Defining_Entity (Specification (gnat_node)));\n+\n+\tif (Is_Itype (gnat_temp_type) && !From_With_Type (gnat_temp_type))\n+\t  gnat_to_gnu_entity (Etype (gnat_temp_type), NULL_TREE, 0);\n+      }\n+\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -3965,47 +4038,102 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (!type_annotate_only)\n \t{\n \t  tree gnu_template = gnat_to_gnu (Asm_Template (gnat_node));\n-\t  tree gnu_input_list = NULL_TREE, gnu_output_list = NULL_TREE;\n-\t  tree gnu_clobber_list = NULL_TREE;\n+\t  tree gnu_inputs = NULL_TREE, gnu_outputs = NULL_TREE;\n+\t  tree gnu_clobbers = NULL_TREE, tail;\n+\t  bool allows_mem, allows_reg, fake;\n+\t  int ninputs, noutputs, i;\n+\t  const char **oconstraints;\n+\t  const char *constraint;\n \t  char *clobber;\n \n-\t  /* First process inputs, then outputs, then clobbers.  */\n-\t  Setup_Asm_Inputs (gnat_node);\n-\t  while (Present (gnat_temp = Asm_Input_Value ()))\n+\t  /* First retrieve the 3 operand lists built by the front-end.  */\n+\t  Setup_Asm_Outputs (gnat_node);\n+\t  while (Present (gnat_temp = Asm_Output_Variable ()))\n \t    {\n \t      tree gnu_value = gnat_to_gnu (gnat_temp);\n \t      tree gnu_constr = build_tree_list (NULL_TREE, gnat_to_gnu\n-\t\t\t\t\t\t (Asm_Input_Constraint ()));\n+\t\t\t\t\t\t (Asm_Output_Constraint ()));\n \n-\t      gnu_input_list\n-\t\t= tree_cons (gnu_constr, gnu_value, gnu_input_list);\n-\t      Next_Asm_Input ();\n+\t      gnu_outputs = tree_cons (gnu_constr, gnu_value, gnu_outputs);\n+\t      Next_Asm_Output ();\n \t    }\n \n-\t  Setup_Asm_Outputs (gnat_node);\n-\t  while (Present (gnat_temp = Asm_Output_Variable ()))\n+\t  Setup_Asm_Inputs (gnat_node);\n+\t  while (Present (gnat_temp = Asm_Input_Value ()))\n \t    {\n \t      tree gnu_value = gnat_to_gnu (gnat_temp);\n \t      tree gnu_constr = build_tree_list (NULL_TREE, gnat_to_gnu\n-\t\t\t\t\t\t (Asm_Output_Constraint ()));\n+\t\t\t\t\t\t (Asm_Input_Constraint ()));\n \n-\t      gnu_output_list\n-\t\t= tree_cons (gnu_constr, gnu_value, gnu_output_list);\n-\t      Next_Asm_Output ();\n+\t      gnu_inputs = tree_cons (gnu_constr, gnu_value, gnu_inputs);\n+\t      Next_Asm_Input ();\n \t    }\n \n \t  Clobber_Setup (gnat_node);\n \t  while ((clobber = Clobber_Get_Next ()))\n-\t    gnu_clobber_list\n+\t    gnu_clobbers\n \t      = tree_cons (NULL_TREE,\n \t\t\t   build_string (strlen (clobber) + 1, clobber),\n-\t\t\t   gnu_clobber_list);\n+\t\t\t   gnu_clobbers);\n+\n+          /* Then perform some standard checking and processing on the\n+\t     operands.  In particular, mark them addressable if needed.  */\n+\t  gnu_outputs = nreverse (gnu_outputs);\n+\t  noutputs = list_length (gnu_outputs);\n+\t  gnu_inputs = nreverse (gnu_inputs);\n+\t  ninputs = list_length (gnu_inputs);\n+\t  oconstraints\n+\t    = (const char **) alloca (noutputs * sizeof (const char *));\n+\n+\t  for (i = 0, tail = gnu_outputs; tail; ++i, tail = TREE_CHAIN (tail))\n+\t    {\n+\t      tree output = TREE_VALUE (tail);\n+\t      constraint\n+\t\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n+\t      oconstraints[i] = constraint;\n+\n+\t      if (parse_output_constraint (&constraint, i, ninputs, noutputs,\n+\t\t\t\t\t   &allows_mem, &allows_reg, &fake))\n+\t\t{\n+\t\t  /* If the operand is going to end up in memory,\n+\t\t     mark it addressable.  Note that we don't test\n+\t\t     allows_mem like in the input case below; this\n+\t\t     is modelled on the C front-end.  */\n+\t\t  if (!allows_reg\n+\t\t      && !gnat_mark_addressable (output))\n+\t\t    output = error_mark_node;\n+\t\t}\n+\t      else\n+\t\toutput = error_mark_node;\n+\n+\t      TREE_VALUE (tail) = output;\n+\t    }\n+\n+\t  for (i = 0, tail = gnu_inputs; tail; ++i, tail = TREE_CHAIN (tail))\n+\t    {\n+\t      tree input = TREE_VALUE (tail);\n+\t      constraint\n+\t\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n+\n+\t      if (parse_input_constraint (&constraint, i, ninputs, noutputs,\n+\t\t\t\t\t  0, oconstraints,\n+\t\t\t\t\t  &allows_mem, &allows_reg))\n+\t\t{\n+\t\t  /* If the operand is going to end up in memory,\n+\t\t     mark it addressable.  */\n+\t\t  if (!allows_reg && allows_mem\n+\t\t      && !gnat_mark_addressable (input))\n+\t\t    input = error_mark_node;\n+\t\t}\n+\t      else\n+\t\tinput = error_mark_node;\n+\n+\t      TREE_VALUE (tail) = input;\n+\t    }\n \n-\t  gnu_input_list = nreverse (gnu_input_list);\n-\t  gnu_output_list = nreverse (gnu_output_list);\n \t  gnu_result = build4 (ASM_EXPR,  void_type_node,\n-\t\t\t       gnu_template, gnu_output_list,\n-\t\t\t       gnu_input_list, gnu_clobber_list);\n+\t\t\t       gnu_template, gnu_outputs,\n+\t\t\t       gnu_inputs, gnu_clobbers);\n \t  ASM_VOLATILE_P (gnu_result) = Is_Asm_Volatile (gnat_node);\n \t}\n       else\n@@ -4372,12 +4500,6 @@ void\n add_stmt (tree gnu_stmt)\n {\n   append_to_statement_list (gnu_stmt, &current_stmt_group->stmt_list);\n-\n-  /* If we're at top level, show everything in here is in use in case\n-     any of it is shared by a subprogram.  */\n-  if (global_bindings_p ())\n-    walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n-\n }\n \n /* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n@@ -4407,15 +4529,16 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n \t  && TREE_CODE (TREE_TYPE (gnu_decl)) == UNCONSTRAINED_ARRAY_TYPE))\n     return;\n \n+  gnu_stmt = build1 (DECL_EXPR, void_type_node, gnu_decl);\n+\n   /* If we are global, we don't want to actually output the DECL_EXPR for\n      this decl since we already have evaluated the expressions in the\n-     sizes and positions as globals and doing it again would be wrong.\n-     But we do have to mark everything as used.  */\n-  gnu_stmt = build1 (DECL_EXPR, void_type_node, gnu_decl);\n-  if (!global_bindings_p ())\n-    add_stmt_with_node (gnu_stmt, gnat_entity);\n-  else\n+     sizes and positions as globals and doing it again would be wrong.  */\n+  if (global_bindings_p ())\n     {\n+      /* Mark everything as used to prevent node sharing with subprograms.\n+\t Note that walk_tree knows how to handle TYPE_DECL, but neither\n+\t VAR_DECL nor CONST_DECL.  This appears to be somewhat arbitrary.  */\n       walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n       if (TREE_CODE (gnu_decl) == VAR_DECL\n \t  || TREE_CODE (gnu_decl) == CONST_DECL)\n@@ -4425,6 +4548,8 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n \t  walk_tree (&DECL_INITIAL (gnu_decl), mark_visited, NULL, NULL);\n \t}\n     }\n+  else\n+    add_stmt_with_node (gnu_stmt, gnat_entity);\n \n   /* If this is a DECL_EXPR for a variable with DECL_INITIAL set,\n      there are two cases we need to handle here.  */\n@@ -4455,8 +4580,12 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n \t    = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t       gnu_lhs, DECL_INITIAL (gnu_decl));\n \n-\t  DECL_INITIAL (gnu_decl) = 0;\n-\t  TREE_READONLY (gnu_decl) = 0;\n+\t  DECL_INITIAL (gnu_decl) = NULL_TREE;\n+\t  if (TREE_READONLY (gnu_decl))\n+\t    {\n+\t      TREE_READONLY (gnu_decl) = 0;\n+\t      DECL_READONLY_ONCE_ELAB (gnu_decl) = 1;\n+\t    }\n \t  annotate_with_locus (gnu_assign_stmt,\n \t\t\t       DECL_SOURCE_LOCATION (gnu_decl));\n \t  add_stmt (gnu_assign_stmt);\n@@ -4486,13 +4615,16 @@ mark_visited (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n-/* Likewise, but to mark as unvisited.  */\n+/* Utility function to unshare expressions wrapped up in a SAVE_EXPR.  */\n \n static tree\n-mark_unvisited (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\tvoid *data ATTRIBUTE_UNUSED)\n+unshare_save_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t   void *data ATTRIBUTE_UNUSED)\n {\n-  TREE_VISITED (*tp) = 0;\n+  tree t = *tp;\n+\n+  if (TREE_CODE (t) == SAVE_EXPR)\n+    TREE_OPERAND (t, 0) = unshare_expr (TREE_OPERAND (t, 0));\n \n   return NULL_TREE;\n }\n@@ -4833,48 +4965,33 @@ gnat_gimplify_stmt (tree *stmt_p)\n     }\n }\n \f\n-/* Force references to each of the entities in packages GNAT_NODE with's\n-   so that the debugging information for all of them are identical\n-   in all clients.  Operate recursively on anything it with's, but check\n-   that we aren't elaborating something more than once.  */\n-\n-/* The reason for this routine's existence is two-fold.\n-   First, with some debugging formats, notably MDEBUG on SGI\n-   IRIX, the linker will remove duplicate debugging information if two\n-   clients have identical debugging information.  With the normal scheme\n-   of elaboration, this does not usually occur, since entities in with'ed\n-   packages are elaborated on demand, and if clients have different usage\n-   patterns, the normal case, then the order and selection of entities\n-   will differ.  In most cases however, it seems that linkers do not know\n-   how to eliminate duplicate debugging information, even if it is\n-   identical, so the use of this routine would increase the total amount\n-   of debugging information in the final executable.\n-\n-   Second, this routine is called in type_annotate mode, to compute DDA\n-   information for types in withed units, for ASIS use  */\n+/* Force references to each of the entities in packages withed by GNAT_NODE.\n+   Operate recursively but check that we aren't elaborating something more\n+   than once.\n+\n+   This routine is exclusively called in type_annotate mode, to compute DDA\n+   information for types in withed units, for ASIS use.  */\n \n static void\n elaborate_all_entities (Node_Id gnat_node)\n {\n   Entity_Id gnat_with_clause, gnat_entity;\n \n-  /* Process each unit only once. As we trace the context of all relevant\n+  /* Process each unit only once.  As we trace the context of all relevant\n      units transitively, including generic bodies, we may encounter the\n-     same generic unit repeatedly */\n-\n+     same generic unit repeatedly.  */\n   if (!present_gnu_tree (gnat_node))\n      save_gnu_tree (gnat_node, integer_zero_node, true);\n \n-  /* Save entities in all context units. A body may have an implicit_with\n+  /* Save entities in all context units.  A body may have an implicit_with\n      on its own spec, if the context includes a child unit, so don't save\n      the spec twice.  */\n-\n   for (gnat_with_clause = First (Context_Items (gnat_node));\n        Present (gnat_with_clause);\n        gnat_with_clause = Next (gnat_with_clause))\n     if (Nkind (gnat_with_clause) == N_With_Clause\n \t&& !present_gnu_tree (Library_Unit (gnat_with_clause))\n-        && Library_Unit (gnat_with_clause) != Library_Unit (Cunit (Main_Unit)))\n+\t&& Library_Unit (gnat_with_clause) != Library_Unit (Cunit (Main_Unit)))\n       {\n \telaborate_all_entities (Library_Unit (gnat_with_clause));\n \n@@ -4897,23 +5014,23 @@ elaborate_all_entities (Node_Id gnat_node)\n \t\t  && !IN (Ekind (gnat_entity), Generic_Unit_Kind))\n \t\tgnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n           }\n-        else if (Ekind (Entity (Name (gnat_with_clause))) == E_Generic_Package)\n-           {\n-            Node_Id gnat_body\n+\telse if (Ekind (Entity (Name (gnat_with_clause))) == E_Generic_Package)\n+\t  {\n+\t    Node_Id gnat_body\n \t      = Corresponding_Body (Unit (Library_Unit (gnat_with_clause)));\n \n-            /* Retrieve compilation unit node of generic body.  */\n-            while (Present (gnat_body)\n+\t    /* Retrieve compilation unit node of generic body.  */\n+\t    while (Present (gnat_body)\n \t\t   && Nkind (gnat_body) != N_Compilation_Unit)\n \t      gnat_body = Parent (gnat_body);\n \n-            /* If body is available, elaborate its context.  */\n-            if (Present (gnat_body))\n-                elaborate_all_entities (gnat_body);\n-           }\n+\t    /* If body is available, elaborate its context.  */\n+\t    if (Present (gnat_body))\n+\t      elaborate_all_entities (gnat_body);\n+\t  }\n       }\n \n-  if (Nkind (Unit (gnat_node)) == N_Package_Body && type_annotate_only)\n+  if (Nkind (Unit (gnat_node)) == N_Package_Body)\n     elaborate_all_entities (Library_Unit (gnat_node));\n }\n \f\n@@ -4969,19 +5086,22 @@ process_freeze_entity (Node_Id gnat_node)\n         && Ekind (gnat_entity) == E_Subprogram_Type)))\n     return;\n \n-  /* If we have a non-dummy type old tree, we have nothing to do.   Unless\n-     this is the public view of a private type whose full view was not\n-     delayed, this node was never delayed as it should have been.\n-     Also allow this to happen for concurrent types since we may have\n-     frozen both the Corresponding_Record_Type and this type.  */\n+  /* If we have a non-dummy type old tree, we have nothing to do, except\n+     aborting if this is the public view of a private type whose full view was\n+     not delayed, as this node was never delayed as it should have been.  We\n+     let this happen for concurrent types and their Corresponding_Record_Type,\n+     however, because each might legitimately be elaborated before it's own\n+     freeze node, e.g. while processing the other.  */\n   if (gnu_old\n       && !(TREE_CODE (gnu_old) == TYPE_DECL\n \t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n     {\n       gcc_assert ((IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n \t\t   && Present (Full_View (gnat_entity))\n \t\t   && No (Freeze_Node (Full_View (gnat_entity))))\n-\t\t  || Is_Concurrent_Type (gnat_entity));\n+\t\t  || Is_Concurrent_Type (gnat_entity)\n+\t\t  || (IN (Ekind (gnat_entity), Record_Kind)\n+\t\t      && Is_Concurrent_Record_Type (gnat_entity)));\n       return;\n     }\n \n@@ -5220,7 +5340,7 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)\n \n   /* There's no good type to use here, so we might as well use\n      integer_type_node. Note that the form of the check is\n-        (not (expr >= lo)) or (not (expr >= hi))\n+        (not (expr >= lo)) or (not (expr <= hi))\n       the reason for this slightly convoluted form is that NaN's\n       are not considered to be in range in the float case. */\n   return emit_check\n@@ -5619,15 +5739,8 @@ process_type (Entity_Id gnat_entity)\n      pointers.  */\n   if (gnu_old)\n     {\n-      if (TREE_CODE (gnu_old) != TYPE_DECL\n-\t  || !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old)))\n-\t{\n-\t  /* If this was a withed access type, this is not an error\n-\t     and merely indicates we've already elaborated the type\n-\t     already. */\n-\t  gcc_assert (Is_Type (gnat_entity) && From_With_Type (gnat_entity));\n-\t  return;\n-\t}\n+      gcc_assert (TREE_CODE (gnu_old) == TYPE_DECL\n+\t\t  && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old)));\n \n       save_gnu_tree (gnat_entity, NULL_TREE, false);\n     }\n@@ -6085,28 +6198,6 @@ gnat_stabilize_reference_1 (tree e, bool force)\n   TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n   return result;\n }\n-\n-/* Build a global constructor or destructor function.  METHOD_TYPE gives\n-   the type of the function and CDTORS points to the list of constructor\n-   or destructor functions to be invoked.  FIXME: Migrate into cgraph.  */\n-\n-static void\n-build_global_cdtor (int method_type, tree *cdtors)\n-{\n-  tree body = 0;\n-\n-  for (; *cdtors; *cdtors = TREE_CHAIN (*cdtors))\n-    {\n-      tree fn = TREE_VALUE (*cdtors);\n-      tree fntype = TREE_TYPE (fn);\n-      tree fnaddr = build1 (ADDR_EXPR, build_pointer_type (fntype), fn);\n-      tree fncall = build3 (CALL_EXPR, TREE_TYPE (fntype), fnaddr, NULL_TREE,\n-\t\t\t    NULL_TREE);\n-      append_to_statement_list (fncall, &body);\n-    }\n-\n-  cgraph_build_static_cdtor (method_type, body, DEFAULT_INIT_PRIORITY);\n-}\n \f\n extern char *__gnat_to_canonical_file_spec (char *);\n "}, {"sha": "b5854faf74abefe61246a4350f51cfd60dee4711", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 437, "deletions": 41, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8945d5632cc44d3f05178c67b73b666cc64c8a4/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=c8945d5632cc44d3f05178c67b73b666cc64c8a4", "patch": "@@ -42,6 +42,7 @@\n #include \"tree-inline.h\"\n #include \"tree-gimple.h\"\n #include \"tree-dump.h\"\n+#include \"pointer-set.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -74,11 +75,6 @@ tree gnat_std_decls[(int) ADT_LAST];\n /* Functions to call for each of the possible raise reasons.  */\n tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n \n-/* List of functions called automatically at the beginning and\n-   end of execution, on targets without .ctors/.dtors sections.  */\n-tree static_ctors;\n-tree static_dtors;\n-\n /* Forward declarations for handlers of attributes.  */\n static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n static tree handle_nothrow_attribute (tree *, tree, tree, int, bool *);\n@@ -99,6 +95,27 @@ const struct attribute_spec gnat_internal_attribute_table[] =\n    of `save_gnu_tree' for more info.  */\n static GTY((length (\"max_gnat_nodes\"))) tree *associate_gnat_to_gnu;\n \n+#define GET_GNU_TREE(GNAT_ENTITY)\t\\\n+  associate_gnat_to_gnu[(GNAT_ENTITY) - First_Node_Id]\n+\n+#define SET_GNU_TREE(GNAT_ENTITY,VAL)\t\\\n+  associate_gnat_to_gnu[(GNAT_ENTITY) - First_Node_Id] = (VAL)\n+\n+#define PRESENT_GNU_TREE(GNAT_ENTITY)\t\\\n+  (associate_gnat_to_gnu[(GNAT_ENTITY) - First_Node_Id] != NULL_TREE)\n+\n+/* Associates a GNAT entity to a GCC tree node used as a dummy, if any.  */\n+static GTY((length (\"max_gnat_nodes\"))) tree *dummy_node_table;\n+\n+#define GET_DUMMY_NODE(GNAT_ENTITY)\t\\\n+  dummy_node_table[(GNAT_ENTITY) - First_Node_Id]\n+\n+#define SET_DUMMY_NODE(GNAT_ENTITY,VAL)\t\\\n+  dummy_node_table[(GNAT_ENTITY) - First_Node_Id] = (VAL)\n+\n+#define PRESENT_DUMMY_NODE(GNAT_ENTITY)\t\\\n+  (dummy_node_table[(GNAT_ENTITY) - First_Node_Id] != NULL_TREE)\n+\n /* This variable keeps a table for types for each precision so that we only\n    allocate each of them once. Signed and unsigned types are kept separate.\n \n@@ -130,6 +147,17 @@ static GTY(()) struct gnat_binding_level *current_binding_level;\n /* A chain of gnat_binding_level structures awaiting reuse.  */\n static GTY((deletable)) struct gnat_binding_level *free_binding_level;\n \n+/* An array of global declarations.  */\n+static GTY(()) VEC (tree,gc) *global_decls;\n+\n+/* An array of global renaming pointers.  */\n+static GTY(()) VEC (tree,gc) *global_renaming_pointers;\n+\n+/* Arrays of functions called automatically at the beginning and\n+   end of execution, on targets without .ctors/.dtors sections.  */\n+static GTY(()) VEC (tree,gc) *static_ctors;\n+static GTY(()) VEC (tree,gc) *static_dtors;\n+\n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n@@ -172,10 +200,11 @@ save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, bool no_check)\n      to something which is a decl.  Raise gigi 401 if not.  Usually, this\n      means GNAT_ENTITY is defined twice, but occasionally is due to some\n      Gigi problem.  */\n-  gcc_assert (!gnu_decl\n-\t      || (!associate_gnat_to_gnu[gnat_entity - First_Node_Id]\n-\t\t  && (no_check || DECL_P (gnu_decl))));\n-  associate_gnat_to_gnu[gnat_entity - First_Node_Id] = gnu_decl;\n+  gcc_assert (!(gnu_decl\n+\t\t&& (PRESENT_GNU_TREE (gnat_entity)\n+\t\t    || (!no_check && !DECL_P (gnu_decl)))));\n+\n+  SET_GNU_TREE (gnat_entity, gnu_decl);\n }\n \n /* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n@@ -188,18 +217,75 @@ save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, bool no_check)\n tree\n get_gnu_tree (Entity_Id gnat_entity)\n {\n-  gcc_assert (associate_gnat_to_gnu[gnat_entity - First_Node_Id]);\n-  return associate_gnat_to_gnu[gnat_entity - First_Node_Id];\n+  gcc_assert (PRESENT_GNU_TREE (gnat_entity));\n+  return GET_GNU_TREE (gnat_entity);\n }\n \n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n \n bool\n present_gnu_tree (Entity_Id gnat_entity)\n {\n-  return (associate_gnat_to_gnu[gnat_entity - First_Node_Id]) != 0;\n+  return PRESENT_GNU_TREE (gnat_entity);\n+}\n+\f\n+/* Initialize the association of GNAT nodes to GCC trees as dummies.  */\n+\n+void\n+init_dummy_type (void)\n+{\n+  dummy_node_table\n+    = (tree *) ggc_alloc_cleared (max_gnat_nodes * sizeof (tree));\n }\n \n+/* Make a dummy type corresponding to GNAT_TYPE.  */\n+\n+tree\n+make_dummy_type (Entity_Id gnat_type)\n+{\n+  Entity_Id gnat_underlying;\n+  tree gnu_type;\n+  enum tree_code code;\n+\n+  /* Find a full type for GNAT_TYPE, taking into account any class wide\n+     types.  */\n+  if (Is_Class_Wide_Type (gnat_type) && Present (Equivalent_Type (gnat_type)))\n+    gnat_type = Equivalent_Type (gnat_type);\n+  else if (Ekind (gnat_type) == E_Class_Wide_Type)\n+    gnat_type = Root_Type (gnat_type);\n+\n+  /* Find a full view for GNAT_TYPE, looking through any incomplete or\n+     private types.  */\n+  if (IN (Ekind (gnat_type), Incomplete_Kind)\n+      && From_With_Type (gnat_type))\n+    gnat_underlying = Non_Limited_View (gnat_type);\n+  else if (IN (Ekind (gnat_type), Incomplete_Or_Private_Kind)\n+\t   && Present (Full_View (gnat_type)))\n+    gnat_underlying = Full_View (gnat_type);\n+  else\n+    gnat_underlying = gnat_type;\n+\n+  /* If it there already a dummy type, use that one.  Else make one.  */\n+  if (PRESENT_DUMMY_NODE (gnat_underlying))\n+    return GET_DUMMY_NODE (gnat_underlying);\n+\n+  /* If this is a record, make this a RECORD_TYPE or UNION_TYPE; else make\n+     it an ENUMERAL_TYPE.  */\n+  if (Is_Record_Type (gnat_underlying))\n+    code = tree_code_for_record_type (gnat_underlying);\n+  else\n+    code = ENUMERAL_TYPE;\n+\n+  gnu_type = make_node (code);\n+  TYPE_NAME (gnu_type) = get_entity_name (gnat_type);\n+  TYPE_DUMMY_P (gnu_type) = 1;\n+  if (AGGREGATE_TYPE_P (gnu_type))\n+    TYPE_STUB_DECL (gnu_type) = build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n+\n+  SET_DUMMY_NODE (gnat_underlying, gnu_type);\n+\n+  return gnu_type;\n+}\n \f\n /* Return nonzero if we are currently in the global binding level.  */\n \n@@ -354,16 +440,20 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n   add_decl_expr (decl, gnat_node);\n \n   /* Put the declaration on the list.  The list of declarations is in reverse\n-     order. The list will be reversed later.  We don't do this for global\n-     variables.  Also, don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into\n-     the list.  They will cause trouble with the debugger and aren't needed\n+     order. The list will be reversed later.  Put global variables in the\n+     globals list. Don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into the\n+     list, as they will cause trouble with the debugger and aren't needed\n      anyway.  */\n-  if (!global_bindings_p ()\n-      && (TREE_CODE (decl) != TYPE_DECL\n-\t  || TREE_CODE (TREE_TYPE (decl)) != UNCONSTRAINED_ARRAY_TYPE))\n+  if (TREE_CODE (decl) != TYPE_DECL\n+      || TREE_CODE (TREE_TYPE (decl)) != UNCONSTRAINED_ARRAY_TYPE)\n     {\n-      TREE_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n-      BLOCK_VARS (current_binding_level->block) = decl;\n+      if (global_bindings_p ())\n+\tVEC_safe_push (tree, gc, global_decls, decl);\n+      else\n+\t{\n+\t  TREE_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n+\t  BLOCK_VARS (current_binding_level->block) = decl;\n+\t}\n     }\n \n   /* For the declaration of a type, set its name if it either is not already\n@@ -494,6 +584,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\t\t\t     endlink)),\n \t\t\t\t     NULL_TREE, false, true, true, NULL,\n \t\t\t\t     Empty);\n+  DECL_IS_MALLOC (malloc_decl) = 1;\n \n   /* free is a function declaration tree for a function to free memory.  */\n   free_decl\n@@ -970,6 +1061,12 @@ write_record_type_debug_info (tree record_type)\n \t      var = true;\n \t    }\n \n+\t  /* The heuristics above might get the alignment wrong.\n+\t     Adjust the obvious case where align is smaller than the\n+\t     alignments necessary for objects of field_type. */\n+\t  if (align < TYPE_ALIGN(field_type))\n+\t    align = TYPE_ALIGN(field_type);\n+\n \t  /* Make a new field name, if necessary.  */\n \t  if (var || align != 0)\n \t    {\n@@ -1229,6 +1326,9 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \n   DECL_ARTIFICIAL (type_decl) = artificial_p;\n \n+  if (!TYPE_IS_DUMMY_P (type))\n+    gnat_pushdecl (type_decl, gnat_node);\n+\n   process_attributes (type_decl, attr_list);\n \n   /* Pass type declaration information to the debugger unless this is an\n@@ -1245,18 +1345,18 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \t\t&& TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n     rest_of_decl_compilation (type_decl, global_bindings_p (), 0);\n \n-  if (!TYPE_IS_DUMMY_P (type))\n-    gnat_pushdecl (type_decl, gnat_node);\n-\n   return type_decl;\n }\n \n-/* Returns a GCC VAR_DECL node. VAR_NAME gives the name of the variable.\n-   ASM_NAME is its assembler name (if provided).  TYPE is its data type\n-   (a GCC ..._TYPE node).  VAR_INIT is the GCC tree for an optional initial\n-   expression; NULL_TREE if none.\n+/* Helper for create_var_decl and create_true_var_decl. Returns a GCC VAR_DECL\n+   or CONST_DECL node.\n \n-   CONST_FLAG is true if this variable is constant.\n+   VAR_NAME gives the name of the variable.  ASM_NAME is its assembler name\n+   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  VAR_INIT is\n+   the GCC tree for an optional initial expression; NULL_TREE if none.\n+\n+   CONST_FLAG is true if this variable is constant, in which case we might\n+   return a CONST_DECL node unless CONST_DECL_ALLOWED_FLAG is false.\n \n    PUBLIC_FLAG is true if this definition is to be made visible outside of\n    the current compilation unit. This flag should be set when processing the\n@@ -1269,10 +1369,11 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \n    GNAT_NODE is used for the position of the decl.  */\n \n-tree\n-create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n-                 bool const_flag, bool public_flag, bool extern_flag,\n-                 bool static_flag, struct attrib *attr_list, Node_Id gnat_node)\n+static tree\n+create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n+\t\t   bool const_flag, bool const_decl_allowed_flag,\n+\t\t   bool public_flag, bool extern_flag, bool static_flag,\n+\t\t   struct attrib *attr_list, Node_Id gnat_node)\n {\n   bool init_const\n     = (!var_init\n@@ -1283,7 +1384,7 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t\t\t\t\t   TREE_TYPE (var_init))\n \t      : TREE_CONSTANT (var_init))));\n   tree var_decl\n-    = build_decl ((const_flag && init_const\n+    = build_decl ((const_flag && const_decl_allowed_flag && init_const\n \t\t   /* Only make a CONST_DECL for sufficiently-small objects.\n \t\t      We consider complex double \"sufficiently-small\"  */\n \t\t   && TYPE_SIZE (type) != 0\n@@ -1351,6 +1452,38 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n \n   return var_decl;\n }\n+\n+/* Wrapper around create_var_decl_1 for cases where we don't care whether\n+   a VAR or a CONST decl node is created.  */\n+\n+tree\n+create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n+\t\t bool const_flag, bool public_flag, bool extern_flag,\n+\t\t bool static_flag, struct attrib *attr_list,\n+\t\t Node_Id gnat_node)\n+{\n+  return create_var_decl_1 (var_name, asm_name, type, var_init,\n+\t\t\t    const_flag, true,\n+\t\t\t    public_flag, extern_flag, static_flag,\n+\t\t\t    attr_list, gnat_node);\n+}\n+\n+/* Wrapper around create_var_decl_1 for cases where a VAR_DECL node is\n+   required.  The primary intent is for DECL_CONST_CORRESPONDING_VARs, which\n+   must be VAR_DECLs and on which we want TREE_READONLY set to have them\n+   possibly assigned to a readonly data section.  */\n+\n+tree\n+create_true_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n+\t\t      bool const_flag, bool public_flag, bool extern_flag,\n+\t\t      bool static_flag, struct attrib *attr_list,\n+\t\t      Node_Id gnat_node)\n+{\n+  return create_var_decl_1 (var_name, asm_name, type, var_init,\n+\t\t\t    const_flag, false,\n+\t\t\t    public_flag, extern_flag, static_flag,\n+\t\t\t    attr_list, gnat_node);\n+}\n \f\n /* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n@@ -1466,11 +1599,6 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n   if (must_pass_by_ref (field_type) || default_pass_by_ref (field_type))\n     addressable = 1;\n \n-  /* ??? For now, we say that any field of aggregate type is addressable\n-     because the front end may take 'Reference of it.  */\n-  if (AGGREGATE_TYPE_P (field_type))\n-    addressable = 1;\n-\n   /* Mark the decl as nonaddressable if it is indicated so semantically,\n      meaning we won't ever attempt to take the address of the field.\n \n@@ -1589,6 +1717,29 @@ process_attributes (tree decl, struct attrib *attr_list)\n       }\n }\n \f\n+/* Record a global renaming pointer.  */\n+\n+void\n+record_global_renaming_pointer (tree decl)\n+{\n+  gcc_assert (DECL_RENAMED_OBJECT (decl));\n+  VEC_safe_push (tree, gc, global_renaming_pointers, decl);\n+}\n+\n+/* Invalidate the global renaming pointers.   */\n+\n+void\n+invalidate_global_renaming_pointers (void)\n+{\n+  unsigned int i;\n+  tree iter;\n+\n+  for (i = 0; VEC_iterate(tree, global_renaming_pointers, i, iter); i++)\n+    SET_DECL_RENAMED_OBJECT (iter, NULL_TREE);\n+\n+  VEC_free (tree, gc, global_renaming_pointers);\n+}\n+\n /* Return true if VALUE is a known to be a multiple of FACTOR, which must be\n    a power of 2. */\n \n@@ -1700,6 +1851,19 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n   DECL_ARTIFICIAL (DECL_RESULT (subprog_decl)) = 1;\n   DECL_IGNORED_P (DECL_RESULT (subprog_decl)) = 1;\n \n+   /* TREE_ADDRESSABLE is set on the result type to request the use of the\n+      target by-reference return mechanism.  This is not supported all the\n+      way down to RTL expansion with GCC 4, which ICEs on temporary creation\n+      attempts with such a type and expects DECL_BY_REFERENCE to be set on\n+      the RESULT_DECL instead - see gnat_genericize for more details.  */\n+   if (TREE_ADDRESSABLE (TREE_TYPE (DECL_RESULT (subprog_decl))))\n+     {\n+       tree result_decl = DECL_RESULT (subprog_decl);\n+\n+       TREE_ADDRESSABLE (TREE_TYPE (result_decl)) = 0;\n+       DECL_BY_REFERENCE (result_decl) = 1;\n+     }\n+\n   if (inline_flag)\n     DECL_DECLARED_INLINE_P (subprog_decl) = 1;\n \n@@ -1744,6 +1908,163 @@ begin_subprog_body (tree subprog_decl)\n   get_pending_sizes ();\n }\n \n+\n+/* Helper for the genericization callback.  Return a dereference of VAL\n+   if it is of a reference type.  */\n+\n+static tree\n+convert_from_reference (tree val)\n+{\n+  tree value_type, ref;\n+\n+  if (TREE_CODE (TREE_TYPE (val)) != REFERENCE_TYPE)\n+    return val;\n+\n+  value_type =  TREE_TYPE (TREE_TYPE (val));\n+  ref = build1 (INDIRECT_REF, value_type, val);\n+\n+  /* See if what we reference is CONST or VOLATILE, which requires\n+     looking into array types to get to the component type.  */\n+\n+  while (TREE_CODE (value_type) == ARRAY_TYPE)\n+    value_type = TREE_TYPE (value_type);\n+\n+  TREE_READONLY (ref)\n+    = (TYPE_QUALS (value_type) & TYPE_QUAL_CONST);\n+  TREE_THIS_VOLATILE (ref)\n+    = (TYPE_QUALS (value_type) & TYPE_QUAL_VOLATILE);\n+\n+  TREE_SIDE_EFFECTS (ref)\n+    = (TREE_THIS_VOLATILE (ref) || TREE_SIDE_EFFECTS (val));\n+\n+  return ref;\n+}\n+\n+/* Helper for the genericization callback.  Returns true if T denotes\n+   a RESULT_DECL with DECL_BY_REFERENCE set.  */\n+\n+static inline bool\n+is_byref_result (tree t)\n+{\n+  return (TREE_CODE (t) == RESULT_DECL && DECL_BY_REFERENCE (t));\n+}\n+\n+\n+/* Tree walking callback for gnat_genericize. Currently ...\n+\n+   o Adjust references to the function's DECL_RESULT if it is marked\n+     DECL_BY_REFERENCE and so has had its type turned into a reference\n+     type at the end of the function compilation.  */\n+\n+static tree\n+gnat_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n+{\n+  /* This implementation is modeled after what the C++ front-end is\n+     doing, basis of the downstream passes behavior.  */\n+\n+  tree stmt = *stmt_p;\n+  struct pointer_set_t *p_set = (struct pointer_set_t*) data;\n+\n+  /* If we have a direct mention of the result decl, dereference.  */\n+  if (is_byref_result (stmt))\n+    {\n+      *stmt_p = convert_from_reference (stmt);\n+      *walk_subtrees = 0;\n+      return NULL;\n+    }\n+\n+  /* Otherwise, no need to walk the the same tree twice.  */\n+  if (pointer_set_contains (p_set, stmt))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  /* If we are taking the address of what now is a reference, just get the\n+     reference value.  */\n+  if (TREE_CODE (stmt) == ADDR_EXPR\n+      && is_byref_result (TREE_OPERAND (stmt, 0)))\n+    {\n+      *stmt_p = convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n+      *walk_subtrees = 0;\n+    }\n+\n+  /* Don't dereference an by-reference RESULT_DECL inside a RETURN_EXPR.  */\n+  else if (TREE_CODE (stmt) == RETURN_EXPR\n+           && TREE_OPERAND (stmt, 0)\n+\t   && is_byref_result (TREE_OPERAND (stmt, 0)))\n+    *walk_subtrees = 0;\n+\n+  /* Don't look inside trees that cannot embed references of interest.  */\n+  else if (IS_TYPE_OR_DECL_P (stmt))\n+    *walk_subtrees = 0;\n+\n+  pointer_set_insert (p_set, *stmt_p);\n+\n+  return NULL;\n+}\n+\n+/* Perform lowering of Ada trees to GENERIC. In particular:\n+\n+   o Turn a DECL_BY_REFERENCE RESULT_DECL into a real by-reference decl\n+     and adjust all the references to this decl accordingly.  */\n+\n+static void\n+gnat_genericize (tree fndecl)\n+{\n+  /* Prior to GCC 4, an explicit By_Reference result mechanism for a function\n+     was handled by simply setting TREE_ADDRESSABLE on the result type.\n+     Everything required to actually pass by invisible ref using the target\n+     mechanism (e.g. extra parameter) was handled at RTL expansion time.\n+\n+     This doesn't work with GCC 4 any more for several reasons.  First, the\n+     gimplification process might need the creation of temporaries of this\n+     type, and the gimplifier ICEs on such attempts.  Second, the middle-end\n+     now relies on a different attribute for such cases (DECL_BY_REFERENCE on\n+     RESULT/PARM_DECLs), and expects the user invisible by-reference-ness to\n+     be explicitely accounted for by the front-end in the function body.\n+\n+     We achieve the complete transformation in two steps:\n+\n+     1/ create_subprog_decl performs early attribute tweaks: it clears\n+        TREE_ADDRESSABLE from the result type and sets DECL_BY_REFERENCE on\n+        the result decl.  The former ensures that the bit isn't set in the GCC\n+        tree saved for the function, so prevents ICEs on temporary creation.\n+        The latter we use here to trigger the rest of the processing.\n+\n+     2/ This function performs the type transformation on the result decl\n+        and adjusts all the references to this decl from the function body\n+\taccordingly.\n+\n+     Clearing TREE_ADDRESSABLE from the type differs from the C++ front-end\n+     strategy, which escapes the gimplifier temporary creation issues by\n+     creating it's own temporaries using TARGET_EXPR nodes.  Our way relies\n+     on simple specific support code in aggregate_value_p to look at the\n+     target function result decl explicitely.  */\n+\n+  struct pointer_set_t *p_set;\n+  tree decl_result = DECL_RESULT (fndecl);\n+\n+  if (!DECL_BY_REFERENCE (decl_result))\n+    return;\n+\n+  /* Make the DECL_RESULT explicitely by-reference and adjust all the\n+     occurrences in the function body using the common tree-walking facility.\n+     We want to see every occurrence of the result decl to adjust the\n+     referencing tree, so need to use our own pointer set to control which\n+     trees should be visited again or not.  */\n+\n+  p_set = pointer_set_create ();\n+\n+  TREE_TYPE (decl_result) = build_reference_type (TREE_TYPE (decl_result));\n+  TREE_ADDRESSABLE (decl_result) = 0;\n+  relayout_decl (decl_result);\n+\n+  walk_tree (&DECL_SAVED_TREE (fndecl), gnat_genericize_r, p_set, NULL);\n+\n+  pointer_set_destroy (p_set);\n+}\n+\n /* Finish the definition of the current subprogram and compile it all the way\n    to assembler language output.  BODY is the tree corresponding to\n    the subprogram.  */\n@@ -1784,10 +2105,13 @@ end_subprog_body (tree body)\n   /* If we don't have .ctors/.dtors sections, and this is a static\n      constructor or destructor, it must be recorded now.  */\n   if (DECL_STATIC_CONSTRUCTOR (fndecl) && !targetm.have_ctors_dtors)\n-    static_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n+    VEC_safe_push (tree, gc, static_ctors, fndecl);\n \n   if (DECL_STATIC_DESTRUCTOR (fndecl) && !targetm.have_ctors_dtors)\n-    static_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n+    VEC_safe_push (tree, gc, static_dtors, fndecl);\n+\n+  /* Perform the required pre-gimplfication transformations on the tree.  */\n+  gnat_genericize (fndecl);\n \n   /* We do different things for nested and non-nested functions.\n      ??? This should be in cgraph.  */\n@@ -3371,7 +3695,6 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n /* Search the chain of currently reachable declarations for a builtin\n    FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n    Return the first node found, if any, or NULL_TREE otherwise.  */\n-\n tree\n builtin_decl_for (tree name __attribute__ ((unused)))\n {\n@@ -3380,5 +3703,78 @@ builtin_decl_for (tree name __attribute__ ((unused)))\n   return NULL_TREE;\n }\n \n+/* Return the appropriate GCC tree code for the specified GNAT type,\n+   the latter being a record type as predicated by Is_Record_Type.  */\n+\n+enum tree_code\n+tree_code_for_record_type (Entity_Id gnat_type)\n+{\n+  Node_Id component_list\n+    = Component_List (Type_Definition\n+\t\t      (Declaration_Node\n+\t\t       (Implementation_Base_Type (gnat_type))));\n+  Node_Id component;\n+\n+ /* Make this a UNION_TYPE unless it's either not an Unchecked_Union or\n+    we have a non-discriminant field outside a variant.  In either case,\n+    it's a RECORD_TYPE.  */\n+\n+  if (!Is_Unchecked_Union (gnat_type))\n+    return RECORD_TYPE;\n+\n+  for (component = First_Non_Pragma (Component_Items (component_list));\n+       Present (component);\n+       component = Next_Non_Pragma (component))\n+    if (Ekind (Defining_Entity (component)) == E_Component)\n+      return RECORD_TYPE;\n+\n+  return UNION_TYPE;\n+}\n+\n+/* Build a global constructor or destructor function.  METHOD_TYPE gives\n+   the type of the function and VEC points to the vector of constructor\n+   or destructor functions to be invoked.  FIXME: Migrate into cgraph.  */\n+\n+static void\n+build_global_cdtor (int method_type, tree *vec, int len)\n+{\n+  tree body = NULL_TREE;\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      tree fntype = TREE_TYPE (vec[i]);\n+      tree fnaddr = build1 (ADDR_EXPR, build_pointer_type (fntype), vec[i]);\n+      tree fncall = build3 (CALL_EXPR, TREE_TYPE (fntype), fnaddr, NULL_TREE,\n+\t\t\t    NULL_TREE);\n+      append_to_statement_list (fncall, &body);\n+    }\n+\n+  if (body)\n+    cgraph_build_static_cdtor (method_type, body, DEFAULT_INIT_PRIORITY);\n+}\n+\n+/* Perform final processing on global variables.  */\n+\n+void\n+gnat_write_global_declarations (void)\n+{\n+  /* Generate functions to call static constructors and destructors\n+     for targets that do not support .ctors/.dtors sections.  These\n+     functions have magic names which are detected by collect2.  */\n+  build_global_cdtor ('I', VEC_address (tree, static_ctors),\n+\t\t\t   VEC_length (tree, static_ctors));\n+  build_global_cdtor ('D', VEC_address (tree, static_dtors),\n+\t\t\t   VEC_length (tree, static_dtors));\n+\n+  /* Proceed to optimize and emit assembly.\n+     FIXME: shouldn't be the front end's responsibility to call this.  */\n+  cgraph_optimize ();\n+\n+  /* Emit debug info for all global declarations.  */\n+  emit_debug_global_declarations (VEC_address (tree, global_decls),\n+\t\t\t\t  VEC_length (tree, global_decls));\n+}\n+\n #include \"gt-ada-utils.h\"\n #include \"gtype-ada.h\""}]}