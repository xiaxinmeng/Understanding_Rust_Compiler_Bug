{"sha": "cf7eac5805e714c7e71b699329e2c4f4a88addc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y3ZWFjNTgwNWU3MTRjN2U3MWI2OTkzMjllMmM0ZjRhODhhZGRjMQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-03T08:03:22Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-03T19:23:59Z"}, "message": "coroutines: Allow parameter packs in co_await/yield expressions [PR95345]\n\nThis corrects a pasto, where I copied the constraint on bare\nparameter packs from the co_return to co_yield/await without\nproperly reviewing it.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95345\n\t* coroutines.cc (finish_co_await_expr): Revise to allow for\n\tparameter packs.\n\t(finish_co_yield_expr): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95345\n\t* g++.dg/coroutines/pr95345.C: New test.", "tree": {"sha": "fc58d64b47f4c023670d0c8de19eb9f5c6596f88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc58d64b47f4c023670d0c8de19eb9f5c6596f88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf7eac5805e714c7e71b699329e2c4f4a88addc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7eac5805e714c7e71b699329e2c4f4a88addc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7eac5805e714c7e71b699329e2c4f4a88addc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7eac5805e714c7e71b699329e2c4f4a88addc1/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b19d8aac15649f31a7588b2634411a1922906ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19d8aac15649f31a7588b2634411a1922906ea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b19d8aac15649f31a7588b2634411a1922906ea8"}], "stats": {"total": 77, "additions": 53, "deletions": 24}, "files": [{"sha": "58102f51797a28c44a7aeea3b038de76d10f7cf2", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7eac5805e714c7e71b699329e2c4f4a88addc1/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7eac5805e714c7e71b699329e2c4f4a88addc1/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=cf7eac5805e714c7e71b699329e2c4f4a88addc1", "patch": "@@ -851,19 +851,18 @@ finish_co_await_expr (location_t kw, tree expr)\n   /* The current function has now become a coroutine, if it wasn't already.  */\n   DECL_COROUTINE_P (current_function_decl) = 1;\n \n-  if (processing_template_decl)\n-    {\n-      current_function_returns_value = 1;\n-\n-      if (check_for_bare_parameter_packs (expr))\n-\treturn error_mark_node;\n+  /* This function will appear to have no return statement, even if it\n+     is declared to return non-void (most likely).  This is correct - we\n+     synthesize the return for the ramp in the compiler.  So suppress any\n+     extraneous warnings during substitution.  */\n+  TREE_NO_WARNING (current_function_decl) = true;\n \n-      /* If we don't know the promise type, we can't proceed.  */\n-      tree functype = TREE_TYPE (current_function_decl);\n-      if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n-\treturn build5_loc (kw, CO_AWAIT_EXPR, unknown_type_node, expr,\n-\t\t\t   NULL_TREE, NULL_TREE, NULL_TREE, integer_zero_node);\n-    }\n+  /* If we don't know the promise type, we can't proceed, build the\n+     co_await with the expression unchanged.  */\n+  tree functype = TREE_TYPE (current_function_decl);\n+  if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n+    return build5_loc (kw, CO_AWAIT_EXPR, unknown_type_node, expr,\n+\t\t       NULL_TREE, NULL_TREE, NULL_TREE, integer_zero_node);\n \n   /* We must be able to look up the \"await_transform\" method in the scope of\n      the promise type, and obtain its return type.  */\n@@ -928,19 +927,17 @@ finish_co_yield_expr (location_t kw, tree expr)\n   /* The current function has now become a coroutine, if it wasn't already.  */\n   DECL_COROUTINE_P (current_function_decl) = 1;\n \n-  if (processing_template_decl)\n-    {\n-      current_function_returns_value = 1;\n-\n-      if (check_for_bare_parameter_packs (expr))\n-\treturn error_mark_node;\n+  /* This function will appear to have no return statement, even if it\n+     is declared to return non-void (most likely).  This is correct - we\n+     synthesize the return for the ramp in the compiler.  So suppress any\n+     extraneous warnings during substitution.  */\n+  TREE_NO_WARNING (current_function_decl) = true;\n \n-      tree functype = TREE_TYPE (current_function_decl);\n-      /* If we don't know the promise type, we can't proceed.  */\n-      if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n-\treturn build2_loc (kw, CO_YIELD_EXPR, unknown_type_node, expr,\n-\t\t\t   NULL_TREE);\n-    }\n+  /* If we don't know the promise type, we can't proceed, build the\n+     co_await with the expression unchanged.  */\n+  tree functype = TREE_TYPE (current_function_decl);\n+  if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n+    return build2_loc (kw, CO_YIELD_EXPR, unknown_type_node, expr, NULL_TREE);\n \n   if (!coro_promise_type_found_p (current_function_decl, kw))\n     /* We must be able to look up the \"yield_value\" method in the scope of"}, {"sha": "90e946d91c2b3a6d48d2ab642b61ee8b9bb9233e", "filename": "gcc/testsuite/g++.dg/coroutines/pr95345.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7eac5805e714c7e71b699329e2c4f4a88addc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95345.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7eac5805e714c7e71b699329e2c4f4a88addc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95345.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95345.C?ref=cf7eac5805e714c7e71b699329e2c4f4a88addc1", "patch": "@@ -0,0 +1,32 @@\n+#if __has_include (<coroutine>)\n+#include <coroutine>\n+using namespace std;\n+#elif defined (__clang__) && __has_include (<experimental/coroutine>)\n+#include <experimental/coroutine>\n+using namespace std::experimental;\n+#endif\n+\n+struct dummy_coro\n+{\n+  using promise_type = dummy_coro;\n+  bool await_ready() { return false; }\n+  void await_suspend(std::coroutine_handle<>) { }\n+  void await_resume() { }\n+  dummy_coro get_return_object() { return {}; }\n+  dummy_coro initial_suspend() { return {}; }\n+  dummy_coro final_suspend() { return {}; }\n+  void return_void() { }\n+  void unhandled_exception() { }\n+};\n+\n+template <int ...I>\n+dummy_coro\n+foo()\n+{\n+ ((co_await [](int){ return std::suspend_never{}; }(I)), ...);\n+  co_return;\n+}\n+\n+void bar() {\n+  foo<1>();\n+}"}]}