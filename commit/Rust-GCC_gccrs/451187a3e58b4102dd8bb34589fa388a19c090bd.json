{"sha": "451187a3e58b4102dd8bb34589fa388a19c090bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUxMTg3YTNlNThiNDEwMmRkOGJiMzQ1ODlmYTM4OGExOWMwOTBiZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-05-10T20:02:44Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-07T09:26:57Z"}, "message": "[Ada] Move generation of range checks for entry families to expander\n\ngcc/ada/\n\n\t* checks.ads (Expander Routines): Update the description of the\n\tDo_Range_Check mechanism.\n\t* checks.adb (Selected_Range_Checks): Fix typo.\n\t* exp_ch9.adb: Add with and use clause for Checks.\n\t(Actual_Index_Expression): Generate a range check if requested.\n\t(Entry_Index_Expression): Likewise.\n\t* sem_attr.adb (Resolve_Attribute) <Attribute_Count>: Call\n\tApply_Scalar_Range_Check instead of Apply_Range_Check.\n\t* sem_ch9.adb (Analyze_Accept_Statement): Likewise.\n\t* sem_res.adb (Resolve_Entry): Likewise, after having set the\n\tactual index type on the prefix of the indexed component.\n\t(Resolve_Indexed_Component): Remove useless conditional construct.", "tree": {"sha": "7e274694f870db341251f57b9a0e2f3fa69bdb5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e274694f870db341251f57b9a0e2f3fa69bdb5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/451187a3e58b4102dd8bb34589fa388a19c090bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/451187a3e58b4102dd8bb34589fa388a19c090bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/451187a3e58b4102dd8bb34589fa388a19c090bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/451187a3e58b4102dd8bb34589fa388a19c090bd/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e724314af6587d9833bc0ec1b10c9e24206b311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e724314af6587d9833bc0ec1b10c9e24206b311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e724314af6587d9833bc0ec1b10c9e24206b311"}], "stats": {"total": 69, "additions": 46, "deletions": 23}, "files": [{"sha": "6f1bb18d9b5fb4a5764fd4054c8fff4e77f35806", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=451187a3e58b4102dd8bb34589fa388a19c090bd", "patch": "@@ -354,7 +354,7 @@ package body Checks is\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Warn_Node  : Node_Id) return Check_Result;\n-   --  Like Apply_Range_Checks, except it doesn't modify anything, just\n+   --  Like Apply_Range_Check, except it does not modify anything, just\n    --  returns a list of nodes as described in the spec of this package\n    --  for the Range_Check function.\n "}, {"sha": "aca1b7eea60597cfbc9828bb5c786ef0bca9a243", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=451187a3e58b4102dd8bb34589fa388a19c090bd", "patch": "@@ -674,13 +674,13 @@ package Checks is\n    -- Expander Routines --\n    -----------------------\n \n-   --  Some of the earlier processing for checks results in temporarily setting\n-   --  the Do_Range_Check flag rather than actually generating checks. Probably\n-   --  we could eliminate the Do_Range_Check flag entirely and generate checks\n-   --  earlier, but this is a delicate area and it seems safer to implement the\n-   --  following routines, which are called later on in the expansion process.\n-   --  They check the Do_Range_Check flag and if it is set, generate the actual\n-   --  checks and reset the flag.\n+   --  In most cases, the processing for range checks done by semantic analysis\n+   --  only results in setting the Do_Range_Check flag, rather than actually\n+   --  generating checks. The following routines must be called later on in the\n+   --  expansion process upon seeing the Do_Range_Check flag; they generate the\n+   --  actual checks and reset the flag. The remaining cases where range checks\n+   --  are still directly generated during semantic analysis occur as part of\n+   --  the processing of constraints in (sub)type and object declarations.\n \n    procedure Generate_Range_Check\n      (N           : Node_Id;\n@@ -694,11 +694,11 @@ package Checks is\n    --  if raised.\n    --\n    --  Note: if the expander is not active, or if we are in GNATprove mode,\n-   --  then we do not generate explicit range code. Instead we just turn the\n+   --  then we do not generate explicit range checks. Instead we just turn the\n    --  Do_Range_Check flag on, since in these cases that's what we want to see\n    --  in the tree (GNATprove in particular depends on this flag being set). If\n-   --  we generate the actual range check, then we make sure the flag is off,\n-   --  since the code we generate takes complete care of the check.\n+   --  we generate the actual range checks, then we make sure the flag is off\n+   --  afterward, since the code we generate takes complete care of the checks.\n    --\n    --  Historical note: We used to just pass on the Do_Range_Check flag to the\n    --  back end to generate the check, but now in code-generation mode we never"}, {"sha": "70fdf1d1851d3aedd74cf2e412202c63139235f1", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=451187a3e58b4102dd8bb34589fa388a19c090bd", "patch": "@@ -24,6 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n+with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -589,6 +590,14 @@ package body Exp_Ch9 is\n       if Present (Index) then\n          S := Entry_Index_Type (Ent);\n \n+         --  First make sure the index is in range if requested. The index type\n+         --  has been directly set on the prefix, see Resolve_Entry.\n+\n+         if Do_Range_Check (Index) then\n+            Generate_Range_Check\n+              (Index, Etype (Prefix (Parent (Index))), CE_Range_Check_Failed);\n+         end if;\n+\n          Expr :=\n            Make_Op_Add (Sloc,\n              Left_Opnd  => Num,\n@@ -5624,6 +5633,13 @@ package body Exp_Ch9 is\n       if Present (Index) then\n          S := Entry_Index_Type (Ent);\n \n+         --  First make sure the index is in range if requested. The index type\n+         --  is the pristine Entry_Index_Type of the entry.\n+\n+         if Do_Range_Check (Index) then\n+            Generate_Range_Check (Index, S, CE_Range_Check_Failed);\n+         end if;\n+\n          Expr :=\n            Make_Op_Add (Sloc,\n              Left_Opnd  => Num,"}, {"sha": "7a2f5953d3829c1cf5c6197834ca55c4571170b8", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=451187a3e58b4102dd8bb34589fa388a19c090bd", "patch": "@@ -11698,7 +11698,7 @@ package body Sem_Attr is\n                   Fam  : constant Entity_Id := Entity (Prefix (P));\n                begin\n                   Resolve (Indx, Entry_Index_Type (Fam));\n-                  Apply_Range_Check (Indx, Entry_Index_Type (Fam));\n+                  Apply_Scalar_Range_Check (Indx, Entry_Index_Type (Fam));\n                end;\n             end if;\n "}, {"sha": "4fe3c9b361a34887d3133835523a02fe046327c3", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=451187a3e58b4102dd8bb34589fa388a19c090bd", "patch": "@@ -915,12 +915,12 @@ package body Sem_Ch9 is\n          end loop;\n       end;\n \n-      if Ekind (E) = E_Entry_Family then\n+      if Ekind (Entry_Nam) = E_Entry_Family then\n          if No (Index) then\n             Error_Msg_N (\"missing entry index in accept for entry family\", N);\n          else\n-            Analyze_And_Resolve (Index, Entry_Index_Type (E));\n-            Apply_Range_Check (Index, Entry_Index_Type (E));\n+            Analyze_And_Resolve (Index, Entry_Index_Type (Entry_Nam));\n+            Apply_Scalar_Range_Check (Index, Entry_Index_Type (Entry_Nam));\n          end if;\n \n       elsif Present (Index) then"}, {"sha": "0e6acf7d3a18bb866882d033bed5f2c2bf82c203", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/451187a3e58b4102dd8bb34589fa388a19c090bd/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=451187a3e58b4102dd8bb34589fa388a19c090bd", "patch": "@@ -7836,7 +7836,7 @@ package body Sem_Res is\n          --  to the discriminant of the same name in the target task. If the\n          --  entry name is the target of a requeue statement and the entry is\n          --  in the current protected object, the bound to be used is the\n-         --  discriminal of the object (see Apply_Range_Checks for details of\n+         --  discriminal of the object (see Apply_Range_Check for details of\n          --  the transformation).\n \n          -----------------------------\n@@ -8002,6 +8002,17 @@ package body Sem_Res is\n          Nam := Entity (Selector_Name (Prefix (Entry_Name)));\n          Resolve (Prefix (Prefix (Entry_Name)));\n          Resolve_Implicit_Dereference (Prefix (Prefix (Entry_Name)));\n+\n+         --  We do not resolve the prefix because an Entry_Family has no type,\n+         --  although it has the semantics of an array since it can be indexed.\n+         --  In order to perform the associated range check, we would need to\n+         --  build an array type on the fly and set it on the prefix, but this\n+         --  would be wasteful since only the index type matters. Therefore we\n+         --  attach this index type directly, so that Actual_Index_Expression\n+         --  can pick it up later in order to generate the range check.\n+\n+         Set_Etype (Prefix (Entry_Name), Actual_Index_Type (Nam));\n+\n          Index := First (Expressions (Entry_Name));\n          Resolve (Index, Entry_Index_Type (Nam));\n \n@@ -8017,7 +8028,7 @@ package body Sem_Res is\n          if Nkind (Index) = N_Parameter_Association then\n             Error_Msg_N (\"expect expression for entry index\", Index);\n          else\n-            Apply_Range_Check (Index, Actual_Index_Type (Nam));\n+            Apply_Scalar_Range_Check (Index, Etype (Prefix (Entry_Name)));\n          end if;\n       end if;\n    end Resolve_Entry;\n@@ -9071,15 +9082,11 @@ package body Sem_Res is\n          Resolve (Expr, Standard_Positive);\n \n       else\n-         while Present (Index) and Present (Expr) loop\n+         while Present (Index) and then Present (Expr) loop\n             Resolve (Expr, Etype (Index));\n             Check_Unset_Reference (Expr);\n \n-            if Is_Scalar_Type (Etype (Expr)) then\n-               Apply_Scalar_Range_Check (Expr, Etype (Index));\n-            else\n-               Apply_Range_Check (Expr, Get_Actual_Subtype (Index));\n-            end if;\n+            Apply_Scalar_Range_Check (Expr, Etype (Index));\n \n             Next_Index (Index);\n             Next (Expr);"}]}