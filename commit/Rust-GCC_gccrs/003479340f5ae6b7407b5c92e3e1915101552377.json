{"sha": "003479340f5ae6b7407b5c92e3e1915101552377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAzNDc5MzQwZjVhZTZiNzQwN2I1YzkyZTNlMTkxNTEwMTU1MjM3Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-30T12:49:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-30T12:49:06Z"}, "message": "[12/n] PR85694: Rework detection of widened operations\n\nThis patch adds helper functions for detecting widened operations and\ngeneralises the existing code to handle more cases.\n\nOne of the main changes is to recognise multi-stage type conversions,\nwhich are possible even in the original IR and can also occur as a\nresult of earlier pattern matching (especially after the main\nover-widening patch).  E.g. for:\n\n  unsigned int res = 0;\n  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n    {\n      int av = a[i];\n      int bv = b[i];\n      short diff = av - bv;\n      unsigned short abs = diff < 0 ? -diff : diff;\n      res += abs;\n    }\n\nwe have:\n\n  _9 = _7 - _8;\n  diff_20 = (short int) _9;\n  _10 = (int) diff_20;\n  _11 = ABS_EXPR <_10>;\n\nwhere the first cast establishes the sign of the promotion done\nby the second cast.\n\nvect_recog_sad_pattern didn't handle this kind of intermediate promotion\nbetween the MINUS_EXPR and the ABS_EXPR.  Sign extensions and casts from\nunsigned to signed are both OK there.  Unsigned promotions aren't, and\nneed to be rejected, but should have been folded away earlier anyway.\n\nAlso, the dot_prod and widen_sum patterns both required the promotions\nto be from one signedness to the same signedness, rather than say signed\nchar to unsigned int.  That shouldn't be necessary, since it's only the\nsign of the input to the promotion that matters.  Nothing requires the\nnarrow and wide types in a DOT_PROD_EXPR or WIDEN_SUM_EXPR to have the\nsame sign (and IMO that's a good thing).\n\nFixing these fixed an XFAIL in gcc.dg/vect/vect-widen-mult-sum.c.\n\nvect_widened_op_tree is a bit more general than the current patch needs,\nsince it copes with a tree of operations rather than a single statement.\nThis is used by the later average-detection patch.\n\nThe patch also uses a common routine to handle both the WIDEN_MULT_EXPR\nand WIDEN_LSHIFT_EXPR patterns.  I hope this could be reused for other\nsimilar operations in future.\n\nAlso, the patch means we recognise the index calculations in\nvect-mult-const-pattern*.c as widening multiplications, whereas the\nscan test was expecting them to be recognised as mult patterns instead.\nThe patch makes the tests check specifically for the multiplication we\ncare about.\n\n2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (append_pattern_def_seq): Take an optional\n\tvector type.  If given, install it in the new statement's\n\tSTMT_VINFO_VECTYPE.\n\t(vect_element_precision): New function.\n\t(vect_unpromoted_value): New struct.\n\t(vect_unpromoted_value::vect_unpromoted_value): New function.\n\t(vect_unpromoted_value::set_op): Likewise.\n\t(vect_look_through_possible_promotion): Likewise.\n\t(vect_joust_widened_integer, vect_joust_widened_type): Likewise.\n\t(vect_widened_op_tree, vect_convert_input): Likewise.\n\t(vect_convert_inputs, vect_convert_output): Likewise.\n\t(vect_recog_dot_prod_pattern): Use vect_look_through_possible_promotion\n\tto handle the optional cast of the multiplication result and\n\tvect_widened_op_tree to detect the widened multiplication itself.\n\tDo not require the input and output of promotion casts to have\n\tthe same sign, but base the signedness of the operation on the\n\tinput rather than the result.  If the pattern includes two\n\tpromotions, check that those promotions have the same sign.\n\tDo not restrict the MULT_EXPR handling to a double-width result;\n\thandle quadruple-width results and wider.  Use vect_convert_inputs\n\tto convert the inputs to the common type.\n\t(vect_recog_sad_pattern):  Use vect_look_through_possible_promotion\n\tto handle the optional cast of the ABS result.  Also allow a sign\n\tchange or a sign extension between the ABS and MINUS.\n\tUse vect_widened_op_tree to detect the widened subtraction and use\n\tvect_convert_inputs to convert the inputs to the common type.\n\t(vect_handle_widen_op_by_const): Delete.\n\t(vect_recog_widen_op_pattern): New function.\n\t(vect_recog_widen_mult_pattern): Use it.\n\t(vect_recog_widen_shift_pattern): Likewise.\n\t(vect_recog_widen_sum_pattern): Use\n\tvect_look_through_possible_promotion to handle the promoted\n\tPLUS_EXPR operand.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-widen-mult-sum.c: Remove xfail.\n\t* gcc.dg/vect/no-scevccp-outer-6.c: Don't match widened multiplications\n\tby 4 in the computation of a[i].\n\t* gcc.dg/vect/vect-mult-const-pattern-1.c: Test specifically for the\n\tmain multiplication constant.\n\t* gcc.dg/vect/vect-mult-const-pattern-2.c: Likewise.\n\t* gcc.dg/vect/vect-widen-mult-const-s16.c: Likewise.\n\t* gcc.dg/vect/vect-widen-mult-const-u16.c: Likewise.  Expect the\n\tpattern to cast the result to int.\n\t* gcc.dg/vect/vect-reduc-dot-1.c: New test.\n\t* gcc.dg/vect/vect-reduc-dot-2.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-dot-3.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-dot-4.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-dot-5.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-dot-6.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-dot-7.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-dot-8.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-1.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-2.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-3.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-4.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-5.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-6.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-7.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-sad-8.c: Likewise.\n\t* gcc.dg/vect/vect-widen-mult-1.c: Likewise.\n\t* gcc.dg/vect/vect-widen-mult-2.c: Likewise.\n\t* gcc.dg/vect/vect-widen-mult-3.c: Likewise.\n\t* gcc.dg/vect/vect-widen-mult-4.c: Likewise.\n\nFrom-SVN: r262276", "tree": {"sha": "51918c55262a737b8078aa62210f1d5bf92c4471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51918c55262a737b8078aa62210f1d5bf92c4471"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/003479340f5ae6b7407b5c92e3e1915101552377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003479340f5ae6b7407b5c92e3e1915101552377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/003479340f5ae6b7407b5c92e3e1915101552377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003479340f5ae6b7407b5c92e3e1915101552377/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "41949de9de0c8ebabb7adb2701e775ecd671aa72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41949de9de0c8ebabb7adb2701e775ecd671aa72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41949de9de0c8ebabb7adb2701e775ecd671aa72"}], "stats": {"total": 1489, "additions": 935, "deletions": 554}, "files": [{"sha": "58076bb10153e7367ac206878098bb1e59bd88df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -1,3 +1,39 @@\n+2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (append_pattern_def_seq): Take an optional\n+\tvector type.  If given, install it in the new statement's\n+\tSTMT_VINFO_VECTYPE.\n+\t(vect_element_precision): New function.\n+\t(vect_unpromoted_value): New struct.\n+\t(vect_unpromoted_value::vect_unpromoted_value): New function.\n+\t(vect_unpromoted_value::set_op): Likewise.\n+\t(vect_look_through_possible_promotion): Likewise.\n+\t(vect_joust_widened_integer, vect_joust_widened_type): Likewise.\n+\t(vect_widened_op_tree, vect_convert_input): Likewise.\n+\t(vect_convert_inputs, vect_convert_output): Likewise.\n+\t(vect_recog_dot_prod_pattern): Use vect_look_through_possible_promotion\n+\tto handle the optional cast of the multiplication result and\n+\tvect_widened_op_tree to detect the widened multiplication itself.\n+\tDo not require the input and output of promotion casts to have\n+\tthe same sign, but base the signedness of the operation on the\n+\tinput rather than the result.  If the pattern includes two\n+\tpromotions, check that those promotions have the same sign.\n+\tDo not restrict the MULT_EXPR handling to a double-width result;\n+\thandle quadruple-width results and wider.  Use vect_convert_inputs\n+\tto convert the inputs to the common type.\n+\t(vect_recog_sad_pattern):  Use vect_look_through_possible_promotion\n+\tto handle the optional cast of the ABS result.  Also allow a sign\n+\tchange or a sign extension between the ABS and MINUS.\n+\tUse vect_widened_op_tree to detect the widened subtraction and use\n+\tvect_convert_inputs to convert the inputs to the common type.\n+\t(vect_handle_widen_op_by_const): Delete.\n+\t(vect_recog_widen_op_pattern): New function.\n+\t(vect_recog_widen_mult_pattern): Use it.\n+\t(vect_recog_widen_shift_pattern): Likewise.\n+\t(vect_recog_widen_sum_pattern): Use\n+\tvect_look_through_possible_promotion to handle the promoted\n+\tPLUS_EXPR operand.\n+\n 2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gimple-iterator.c (gsi_for_stmt): Add a new overload that takes"}, {"sha": "d70a10fdb6152735033d074ffe86d7c0cdf37580", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -1,3 +1,35 @@\n+2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/vect-widen-mult-sum.c: Remove xfail.\n+\t* gcc.dg/vect/no-scevccp-outer-6.c: Don't match widened multiplications\n+\tby 4 in the computation of a[i].\n+\t* gcc.dg/vect/vect-mult-const-pattern-1.c: Test specifically for the\n+\tmain multiplication constant.\n+\t* gcc.dg/vect/vect-mult-const-pattern-2.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-const-s16.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-const-u16.c: Likewise.  Expect the\n+\tpattern to cast the result to int.\n+\t* gcc.dg/vect/vect-reduc-dot-1.c: New test.\n+\t* gcc.dg/vect/vect-reduc-dot-2.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-3.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-4.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-5.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-6.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-7.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-8.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-1.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-2.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-3.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-4.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-5.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-6.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-7.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-sad-8.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-1.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-2.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-3.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-4.c: Likewise.\n+\n 2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/vect-reduc-dot-u16b.c: Remove xfail and update the"}, {"sha": "ad2f472f1ed100912386d51ef999353baf50dd93", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-6.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -52,4 +52,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail { unaligned_stack || { vect_no_align && { ! vect_hw_misalign } } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n+/* Exclude widening of i * 4 in the calculation of a[i].  */\n+/* { dg-final { scan-tree-dump-times {vect_recog_widen_mult_pattern: detected: [^\\n]* \\* ([^4]|4[^;])} 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "b63e9a8a6d9d0c396c3843069d100fbb9d5fa913", "filename": "gcc/testsuite/gcc.dg/vect/vect-mult-const-pattern-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-1.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -37,5 +37,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_mult_pattern: detected\" 2 \"vect\" { target aarch64*-*-* xfail aarch64_sve } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_mult_pattern: detected:[^\\n]* \\* 123} \"vect\" { target aarch64*-*-* xfail aarch64_sve } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target aarch64*-*-* } } } */"}, {"sha": "a8253837c3863f5bc5bfea1d188a5588aea501c6", "filename": "gcc/testsuite/gcc.dg/vect/vect-mult-const-pattern-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-const-pattern-2.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -36,5 +36,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_mult_pattern: detected\" 2 \"vect\"  { target aarch64*-*-* xfail aarch64_sve } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_mult_pattern: detected:[^\\n]* \\* -19594} \"vect\" { target aarch64*-*-* xfail aarch64_sve } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target aarch64*-*-* } } } */"}, {"sha": "4ee25f8d0f7291bbcbf2abd403d559f6807358e4", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-1.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 50\n+\n+#ifndef SIGNEDNESS_1\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 unsigned\n+#endif\n+\n+SIGNEDNESS_1 int __attribute__ ((noipa))\n+f (SIGNEDNESS_1 int res, SIGNEDNESS_3 char *restrict a,\n+   SIGNEDNESS_3 char *restrict b)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      int av = a[i];\n+      int bv = b[i];\n+      SIGNEDNESS_2 short mult = av * bv;\n+      res += mult;\n+    }\n+  return res;\n+}\n+\n+#define BASE ((SIGNEDNESS_3 int) -1 < 0 ? -126 : 4)\n+#define OFFSET 20\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS_3 char a[N], b[N];\n+  int expected = 0x12345;\n+  for (int i = 0; i < N; ++i)\n+    {\n+      a[i] = BASE + i * 5;\n+      b[i] = BASE + OFFSET + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+      expected += (SIGNEDNESS_2 short) (a[i] * b[i]);\n+    }\n+  if (f (0x12345, a, b) != expected)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" { target vect_sdot_qi } } } */"}, {"sha": "25757d2b6713b53a325979b96f89396dbf4675b8", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-2.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-dot-1.c\"\n+\n+/* { dg-final { scan-tree-dump-not \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "b1deb64e186da99ef42cb687d107445c0b800bd8", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-3.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 unsigned\n+\n+#include \"vect-reduc-dot-1.c\"\n+\n+/* { dg-final { scan-tree-dump-not \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "c17aa7b89786abf4a257a93ac56b28d43080dd62", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-4.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-dot-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "e4d2087942faf0aba926dcd7d355a18236907cb8", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-5.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-5.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 unsigned\n+\n+#include \"vect-reduc-dot-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "b690c9f2eb18b34f4b147d779bb3da582e285399", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-6.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-6.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-dot-1.c\"\n+\n+/* { dg-final { scan-tree-dump-not \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "29e442e8bbf7176cf861518dc171a83d82967764", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-7.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-7.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 unsigned\n+\n+#include \"vect-reduc-dot-1.c\"\n+\n+/* { dg-final { scan-tree-dump-not \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "dca784f8cc5352dc137bb25cb624587e79823f73", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-8.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-8.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-dot-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_dot_prod_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "73a83b8faacf524a4dd3434b714264c65db4939f", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-1.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 50\n+\n+#ifndef SIGNEDNESS_1\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 unsigned\n+#endif\n+\n+SIGNEDNESS_1 int __attribute__ ((noipa))\n+f (SIGNEDNESS_1 int res, SIGNEDNESS_3 char *restrict a,\n+   SIGNEDNESS_3 char *restrict b)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      int av = a[i];\n+      int bv = b[i];\n+      short diff = av - bv;\n+      SIGNEDNESS_2 short abs = diff < 0 ? -diff : diff;\n+      res += abs;\n+    }\n+  return res;\n+}\n+\n+#define BASE1 ((SIGNEDNESS_3 int) -1 < 0 ? -126 : 4)\n+#define BASE2 ((SIGNEDNESS_3 int) -1 < 0 ? 116 : 220)\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS_3 char a[N], b[N];\n+  int expected = 0x12345;\n+  for (int i = 0; i < N; ++i)\n+    {\n+      a[i] = BASE1 + i * 5;\n+      b[i] = BASE1 - i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+      int diff = a[i] - b[i];\n+      expected += (SIGNEDNESS_2 short) (diff < 0 ? -diff : diff);\n+    }\n+  if (f (0x12345, a, b) != expected)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" { target vect_sdot_qi } } } */"}, {"sha": "4c846ff905f256aa18239ebb8a9bd4a79493989c", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-2.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-sad-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "fbd8d8dab19bdd61b380bc5003a0b7be867d3ec6", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-3.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 unsigned\n+\n+#include \"vect-reduc-sad-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "fbdaf4cd0375dca7be46bbee4889e630ed7046e2", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-4.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-sad-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "56847c314b872e331bf69de6773acbfd12258200", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-5.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-5.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 unsigned\n+\n+#include \"vect-reduc-sad-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "f907528f6e878cda6dea07340cdeb729700ffd2c", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-6.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-6.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 unsigned\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-sad-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "2ab743914df4120cbe69df945ed46342899289c7", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-7.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-7.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 unsigned\n+\n+#include \"vect-reduc-sad-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "089583c661e4d5376de2159ab9c884f475d483dd", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad-8.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad-8.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 signed\n+#define SIGNEDNESS_3 signed\n+\n+#include \"vect-reduc-sad-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_sad_pattern: detected\" \"vect\" } } */\n+"}, {"sha": "0d6e64081a17fed8d9b9239f9ba02ffa1b7a758d", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-1.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 50\n+\n+#ifndef SIGNEDNESS_1\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 signed\n+#endif\n+\n+void __attribute__ ((noipa))\n+f (SIGNEDNESS_1 short *restrict a, SIGNEDNESS_2 char *restrict b,\n+   SIGNEDNESS_2 char *restrict c)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      int bv = (SIGNEDNESS_2 char) b[i];\n+      int cv = (SIGNEDNESS_2 char) c[i];\n+      a[i] = bv * cv;\n+    }\n+}\n+\n+#define BASE ((SIGNEDNESS_2 int) -1 < 0 ? -126 : 4)\n+#define OFFSET 20\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS_1 short a[N];\n+  SIGNEDNESS_2 char b[N], c[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = BASE + i * 5;\n+      c[i] = BASE + OFFSET + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != (SIGNEDNESS_1 short) ((BASE + i * 5)\n+\t\t\t\t      * (BASE + OFFSET + i * 4)))\n+      __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_widen_mult_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */"}, {"sha": "73ffe6ae42fa359d0e287e704a6e615de2f32583", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-2.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 unsigned\n+#define SIGNEDNESS_2 unsigned\n+\n+#include \"vect-widen-mult-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_widen_mult_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */"}, {"sha": "fc4ca8f271be48a4ee608c81162f1014f07e41b6", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-3.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 unsigned\n+\n+#include \"vect-widen-mult-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_widen_mult_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */"}, {"sha": "315b55628bd1b5af5c8fdc32fc209703f8dea335", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-4.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#define SIGNEDNESS_1 signed\n+#define SIGNEDNESS_2 signed\n+\n+#include \"vect-widen-mult-1.c\"\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_widen_mult_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" { target vect_widen_mult_qi_to_hi } } } */"}, {"sha": "89f983cad062c4e58b1906530f775672dd5d004d", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-s16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-s16.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -56,6 +56,6 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n-/* { dg-final { scan-tree-dump-times \"widen_mult pattern recognized\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times {vect_recog_widen_mult_pattern: detected:[^\\n]* 2333} 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times {widen_mult pattern recognized:[^\\n]* 2333} 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n "}, {"sha": "e319699cd92103f3fba580825e131517ed203306", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-u16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-u16.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -73,5 +73,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n-/* { dg-final { scan-tree-dump-times \"widen_mult pattern recognized\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times {vect_recog_widen_mult_pattern: detected:[^\\n]* 2333} 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times {widen_mult pattern recognized:[^\\n]* = \\(int\\)} 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */"}, {"sha": "26b5e43cdf672e88b0fa7a40319d48119efbb0c6", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-sum.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-sum.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -43,4 +43,4 @@ int main (void)\n \n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"vect_recog_widen_mult_pattern: detected\" \"vect\" } } */"}, {"sha": "2ac765e1864b13df19d7226c59ea986590757954", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 543, "deletions": 546, "changes": 1089, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003479340f5ae6b7407b5c92e3e1915101552377/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=003479340f5ae6b7407b5c92e3e1915101552377", "patch": "@@ -96,11 +96,24 @@ vect_set_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n   vect_init_pattern_stmt (pattern_stmt, orig_stmt_info, vectype);\n }\n \n+/* Add NEW_STMT to STMT_INFO's pattern definition statements.  If VECTYPE\n+   is nonnull, record that NEW_STMT's vector type is VECTYPE, which might\n+   be different from the vector type of the final pattern statement.  */\n+\n static inline void\n-append_pattern_def_seq (stmt_vec_info stmt_info, gimple *stmt)\n+append_pattern_def_seq (stmt_vec_info stmt_info, gimple *new_stmt,\n+\t\t\ttree vectype = NULL_TREE)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n+  if (vectype)\n+    {\n+      gcc_assert (!vinfo_for_stmt (new_stmt));\n+      stmt_vec_info new_stmt_info = new_stmt_vec_info (new_stmt, vinfo);\n+      set_vinfo_for_stmt (new_stmt, new_stmt_info);\n+      STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n+    }\n   gimple_seq_add_stmt_without_update (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_info),\n-\t\t\t\t      stmt);\n+\t\t\t\t      new_stmt);\n }\n \n static inline void\n@@ -187,6 +200,15 @@ vect_single_imm_use (gimple *def_stmt)\n   return use_stmt;\n }\n \n+/* Round bit precision PRECISION up to a full element.  */\n+\n+static unsigned int\n+vect_element_precision (unsigned int precision)\n+{\n+  precision = 1 << ceil_log2 (precision);\n+  return MAX (precision, BITS_PER_UNIT);\n+}\n+\n /* If OP is defined by a statement that's being considered for vectorization,\n    return information about that statement, otherwise return NULL.  */\n \n@@ -253,6 +275,322 @@ type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n   return true;\n }\n \n+/* Holds information about an input operand after some sign changes\n+   and type promotions have been peeled away.  */\n+struct vect_unpromoted_value {\n+  vect_unpromoted_value ();\n+\n+  void set_op (tree, vect_def_type, stmt_vec_info = NULL);\n+\n+  /* The value obtained after peeling away zero or more casts.  */\n+  tree op;\n+\n+  /* The type of OP.  */\n+  tree type;\n+\n+  /* The definition type of OP.  */\n+  vect_def_type dt;\n+\n+  /* If OP is the result of peeling at least one cast, and if the cast\n+     of OP itself is a vectorizable statement, CASTER identifies that\n+     statement, otherwise it is null.  */\n+  stmt_vec_info caster;\n+};\n+\n+inline vect_unpromoted_value::vect_unpromoted_value ()\n+  : op (NULL_TREE),\n+    type (NULL_TREE),\n+    dt (vect_uninitialized_def),\n+    caster (NULL)\n+{\n+}\n+\n+/* Set the operand to OP_IN, its definition type to DT_IN, and the\n+   statement that casts it to CASTER_IN.  */\n+\n+inline void\n+vect_unpromoted_value::set_op (tree op_in, vect_def_type dt_in,\n+\t\t\t       stmt_vec_info caster_in)\n+{\n+  op = op_in;\n+  type = TREE_TYPE (op);\n+  dt = dt_in;\n+  caster = caster_in;\n+}\n+\n+/* If OP is a vectorizable SSA name, strip a sequence of integer conversions\n+   to reach some vectorizable inner operand OP', continuing as long as it\n+   is possible to convert OP' back to OP using a possible sign change\n+   followed by a possible promotion P.  Return this OP', or null if OP is\n+   not a vectorizable SSA name.  If there is a promotion P, describe its\n+   input in UNPROM, otherwise describe OP' in UNPROM.\n+\n+   A successful return means that it is possible to go from OP' to OP\n+   via UNPROM.  The cast from OP' to UNPROM is at most a sign change,\n+   whereas the cast from UNPROM to OP might be a promotion, a sign\n+   change, or a nop.\n+\n+   E.g. say we have:\n+\n+       signed short *ptr = ...;\n+       signed short C = *ptr;\n+       unsigned short B = (unsigned short) C;    // sign change\n+       signed int A = (signed int) B;            // unsigned promotion\n+       ...possible other uses of A...\n+       unsigned int OP = (unsigned int) A;       // sign change\n+\n+   In this case it's possible to go directly from C to OP using:\n+\n+       OP = (unsigned int) (unsigned short) C;\n+\t    +------------+ +--------------+\n+\t       promotion      sign change\n+\n+   so OP' would be C.  The input to the promotion is B, so UNPROM\n+   would describe B.  */\n+\n+static tree\n+vect_look_through_possible_promotion (vec_info *vinfo, tree op,\n+\t\t\t\t      vect_unpromoted_value *unprom)\n+{\n+  tree res = NULL_TREE;\n+  tree op_type = TREE_TYPE (op);\n+  unsigned int orig_precision = TYPE_PRECISION (op_type);\n+  stmt_vec_info caster = NULL;\n+  while (TREE_CODE (op) == SSA_NAME && INTEGRAL_TYPE_P (op_type))\n+    {\n+      /* See whether OP is simple enough to vectorize.  */\n+      gimple *def_stmt;\n+      vect_def_type dt;\n+      if (!vect_is_simple_use (op, vinfo, &dt, &def_stmt))\n+\tbreak;\n+\n+      /* If OP is the input of a demotion, skip over it to see whether\n+\t OP is itself the result of a promotion.  If so, the combined\n+\t effect of the promotion and the demotion might fit the required\n+\t pattern, otherwise neither operation fits.\n+\n+\t This copes with cases such as the result of an arithmetic\n+\t operation being truncated before being stored, and where that\n+\t arithmetic operation has been recognized as an over-widened one.  */\n+      if (TYPE_PRECISION (op_type) <= orig_precision)\n+\t{\n+\t  /* Use OP as the UNPROM described above if we haven't yet\n+\t     found a promotion, or if using the new input preserves the\n+\t     sign of the previous promotion.  */\n+\t  if (!res\n+\t      || TYPE_PRECISION (unprom->type) == orig_precision\n+\t      || TYPE_SIGN (unprom->type) == TYPE_SIGN (op_type))\n+\t    unprom->set_op (op, dt, caster);\n+\t  /* Stop if we've already seen a promotion and if this\n+\t     conversion does more than change the sign.  */\n+\t  else if (TYPE_PRECISION (op_type)\n+\t\t   != TYPE_PRECISION (unprom->type))\n+\t    break;\n+\n+\t  /* The sequence now extends to OP.  */\n+\t  res = op;\n+\t}\n+\n+      /* See whether OP is defined by a cast.  Record it as CASTER if\n+\t the cast is potentially vectorizable.  */\n+      if (!def_stmt)\n+\tbreak;\n+      if (dt == vect_internal_def)\n+\tcaster = vinfo_for_stmt (def_stmt);\n+      else\n+\tcaster = NULL;\n+      gassign *assign = dyn_cast <gassign *> (def_stmt);\n+      if (!assign || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt)))\n+\tbreak;\n+\n+      /* Continue with the input to the cast.  */\n+      op = gimple_assign_rhs1 (def_stmt);\n+      op_type = TREE_TYPE (op);\n+    }\n+  return res;\n+}\n+\n+/* OP is an integer operand to an operation that returns TYPE, and we\n+   want to treat the operation as a widening one.  So far we can treat\n+   it as widening from *COMMON_TYPE.\n+\n+   Return true if OP is suitable for such a widening operation,\n+   either widening from *COMMON_TYPE or from some supertype of it.\n+   Update *COMMON_TYPE to the supertype in the latter case.\n+\n+   SHIFT_P is true if OP is a shift amount.  */\n+\n+static bool\n+vect_joust_widened_integer (tree type, bool shift_p, tree op,\n+\t\t\t    tree *common_type)\n+{\n+  /* Calculate the minimum precision required by OP, without changing\n+     the sign of either operand.  */\n+  unsigned int precision;\n+  if (shift_p)\n+    {\n+      if (!wi::leu_p (wi::to_widest (op), TYPE_PRECISION (type) / 2))\n+\treturn false;\n+      precision = TREE_INT_CST_LOW (op);\n+    }\n+  else\n+    {\n+      precision = wi::min_precision (wi::to_widest (op),\n+\t\t\t\t     TYPE_SIGN (*common_type));\n+      if (precision * 2 > TYPE_PRECISION (type))\n+\treturn false;\n+    }\n+\n+  /* If OP requires a wider type, switch to that type.  The checks\n+     above ensure that this is still narrower than the result.  */\n+  precision = vect_element_precision (precision);\n+  if (TYPE_PRECISION (*common_type) < precision)\n+    *common_type = build_nonstandard_integer_type\n+      (precision, TYPE_UNSIGNED (*common_type));\n+  return true;\n+}\n+\n+/* Return true if the common supertype of NEW_TYPE and *COMMON_TYPE\n+   is narrower than type, storing the supertype in *COMMON_TYPE if so.  */\n+\n+static bool\n+vect_joust_widened_type (tree type, tree new_type, tree *common_type)\n+{\n+  if (types_compatible_p (*common_type, new_type))\n+    return true;\n+\n+  /* See if *COMMON_TYPE can hold all values of NEW_TYPE.  */\n+  if ((TYPE_PRECISION (new_type) < TYPE_PRECISION (*common_type))\n+      && (TYPE_UNSIGNED (new_type) || !TYPE_UNSIGNED (*common_type)))\n+    return true;\n+\n+  /* See if NEW_TYPE can hold all values of *COMMON_TYPE.  */\n+  if (TYPE_PRECISION (*common_type) < TYPE_PRECISION (new_type)\n+      && (TYPE_UNSIGNED (*common_type) || !TYPE_UNSIGNED (new_type)))\n+    {\n+      *common_type = new_type;\n+      return true;\n+    }\n+\n+  /* We have mismatched signs, with the signed type being\n+     no wider than the unsigned type.  In this case we need\n+     a wider signed type.  */\n+  unsigned int precision = MAX (TYPE_PRECISION (*common_type),\n+\t\t\t\tTYPE_PRECISION (new_type));\n+  precision *= 2;\n+  if (precision * 2 > TYPE_PRECISION (type))\n+    return false;\n+\n+  *common_type = build_nonstandard_integer_type (precision, false);\n+  return true;\n+}\n+\n+/* Check whether STMT_INFO can be viewed as a tree of integer operations\n+   in which each node either performs CODE or WIDENED_CODE, and where\n+   each leaf operand is narrower than the result of STMT_INFO.  MAX_NOPS\n+   specifies the maximum number of leaf operands.  SHIFT_P says whether\n+   CODE and WIDENED_CODE are some sort of shift.\n+\n+   If STMT_INFO is such a tree, return the number of leaf operands\n+   and describe them in UNPROM[0] onwards.  Also set *COMMON_TYPE\n+   to a type that (a) is narrower than the result of STMT_INFO and\n+   (b) can hold all leaf operand values.\n+\n+   Return 0 if STMT_INFO isn't such a tree, or if no such COMMON_TYPE\n+   exists.  */\n+\n+static unsigned int\n+vect_widened_op_tree (stmt_vec_info stmt_info, tree_code code,\n+\t\t      tree_code widened_code, bool shift_p,\n+\t\t      unsigned int max_nops,\n+\t\t      vect_unpromoted_value *unprom, tree *common_type)\n+{\n+  /* Check for an integer operation with the right code.  */\n+  gassign *assign = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!assign)\n+    return 0;\n+\n+  tree_code rhs_code = gimple_assign_rhs_code (assign);\n+  if (rhs_code != code && rhs_code != widened_code)\n+    return 0;\n+\n+  tree type = gimple_expr_type (assign);\n+  if (!INTEGRAL_TYPE_P (type))\n+    return 0;\n+\n+  /* Assume that both operands will be leaf operands.  */\n+  max_nops -= 2;\n+\n+  /* Check the operands.  */\n+  unsigned int next_op = 0;\n+  for (unsigned int i = 0; i < 2; ++i)\n+    {\n+      vect_unpromoted_value *this_unprom = &unprom[next_op];\n+      unsigned int nops = 1;\n+      tree op = gimple_op (assign, i + 1);\n+      if (i == 1 && TREE_CODE (op) == INTEGER_CST)\n+\t{\n+\t  /* We already have a common type from earlier operands.\n+\t     Update it to account for OP.  */\n+\t  this_unprom->set_op (op, vect_constant_def);\n+\t  if (!vect_joust_widened_integer (type, shift_p, op, common_type))\n+\t    return 0;\n+\t}\n+      else\n+\t{\n+\t  /* Only allow shifts by constants.  */\n+\t  if (shift_p && i == 1)\n+\t    return 0;\n+\n+\t  if (!vect_look_through_possible_promotion (stmt_info->vinfo, op,\n+\t\t\t\t\t\t     this_unprom))\n+\t    return 0;\n+\n+\t  if (TYPE_PRECISION (this_unprom->type) == TYPE_PRECISION (type))\n+\t    {\n+\t      /* The operand isn't widened.  If STMT_INFO has the code\n+\t\t for an unwidened operation, recursively check whether\n+\t\t this operand is a node of the tree.  */\n+\t      if (rhs_code != code\n+\t\t  || max_nops == 0\n+\t\t  || this_unprom->dt != vect_internal_def)\n+\t\treturn 0;\n+\n+\t      /* Give back the leaf slot allocated above now that we're\n+\t\t not treating this as a leaf operand.  */\n+\t      max_nops += 1;\n+\n+\t      /* Recursively process the definition of the operand.  */\n+\t      stmt_vec_info def_stmt_info\n+\t\t= vinfo_for_stmt (SSA_NAME_DEF_STMT (this_unprom->op));\n+\t      nops = vect_widened_op_tree (def_stmt_info, code, widened_code,\n+\t\t\t\t\t   shift_p, max_nops, this_unprom,\n+\t\t\t\t\t   common_type);\n+\t      if (nops == 0)\n+\t\treturn 0;\n+\n+\t      max_nops -= nops;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Make sure that the operand is narrower than the result.  */\n+\t      if (TYPE_PRECISION (this_unprom->type) * 2\n+\t\t  > TYPE_PRECISION (type))\n+\t\treturn 0;\n+\n+\t      /* Update COMMON_TYPE for the new operand.  */\n+\t      if (i == 0)\n+\t\t*common_type = this_unprom->type;\n+\t      else if (!vect_joust_widened_type (type, this_unprom->type,\n+\t\t\t\t\t\t common_type))\n+\t\treturn 0;\n+\t    }\n+\t}\n+      next_op += nops;\n+    }\n+  return next_op;\n+}\n+\n /* Helper to return a new temporary for pattern of TYPE for STMT.  If STMT\n    is NULL, the caller must set SSA_NAME_DEF_STMT for the returned SSA var. */\n \n@@ -262,6 +600,81 @@ vect_recog_temp_ssa_var (tree type, gimple *stmt)\n   return make_temp_ssa_name (type, stmt, \"patt\");\n }\n \n+/* Convert UNPROM to TYPE and return the result, adding new statements\n+   to STMT_INFO's pattern definition statements if no better way is\n+   available.  VECTYPE is the vector form of TYPE.  */\n+\n+static tree\n+vect_convert_input (stmt_vec_info stmt_info, tree type,\n+\t\t    vect_unpromoted_value *unprom, tree vectype)\n+{\n+  /* Check for a no-op conversion.  */\n+  if (types_compatible_p (type, TREE_TYPE (unprom->op)))\n+    return unprom->op;\n+\n+  /* Allow the caller to create constant vect_unpromoted_values.  */\n+  if (TREE_CODE (unprom->op) == INTEGER_CST)\n+    return wide_int_to_tree (type, wi::to_widest (unprom->op));\n+\n+  /* See if we can reuse an existing result.  */\n+  if (unprom->caster)\n+    {\n+      tree lhs = gimple_get_lhs (unprom->caster->stmt);\n+      if (types_compatible_p (TREE_TYPE (lhs), type))\n+\treturn lhs;\n+    }\n+\n+  /* We need a new conversion statement.  */\n+  tree new_op = vect_recog_temp_ssa_var (type, NULL);\n+  gassign *new_stmt = gimple_build_assign (new_op, NOP_EXPR, unprom->op);\n+\n+  /* As a (common) last resort, add the statement to the pattern itself.  */\n+  append_pattern_def_seq (stmt_info, new_stmt, vectype);\n+  return new_op;\n+}\n+\n+/* Invoke vect_convert_input for N elements of UNPROM and store the\n+   result in the corresponding elements of RESULT.  */\n+\n+static void\n+vect_convert_inputs (stmt_vec_info stmt_info, unsigned int n,\n+\t\t     tree *result, tree type, vect_unpromoted_value *unprom,\n+\t\t     tree vectype)\n+{\n+  for (unsigned int i = 0; i < n; ++i)\n+    {\n+      unsigned int j;\n+      for (j = 0; j < i; ++j)\n+\tif (unprom[j].op == unprom[i].op)\n+\t  break;\n+      if (j < i)\n+\tresult[i] = result[j];\n+      else\n+\tresult[i] = vect_convert_input (stmt_info, type, &unprom[i], vectype);\n+    }\n+}\n+\n+/* The caller has created a (possibly empty) sequence of pattern definition\n+   statements followed by a single statement PATTERN_STMT.  Cast the result\n+   of this final statement to TYPE.  If a new statement is needed, add\n+   PATTERN_STMT to the end of STMT_INFO's pattern definition statements\n+   and return the new statement, otherwise return PATTERN_STMT as-is.\n+   VECITYPE is the vector form of PATTERN_STMT's result type.  */\n+\n+static gimple *\n+vect_convert_output (stmt_vec_info stmt_info, tree type, gimple *pattern_stmt,\n+\t\t     tree vecitype)\n+{\n+  tree lhs = gimple_get_lhs (pattern_stmt);\n+  if (!types_compatible_p (type, TREE_TYPE (lhs)))\n+    {\n+      append_pattern_def_seq (stmt_info, pattern_stmt, vecitype);\n+      tree cast_var = vect_recog_temp_ssa_var (type, NULL);\n+      pattern_stmt = gimple_build_assign (cast_var, NOP_EXPR, lhs);\n+    }\n+  return pattern_stmt;\n+}\n+\n /* Return true if STMT_VINFO describes a reduction for which reassociation\n    is allowed.  If STMT_INFO is part of a group, assume that it's part of\n    a reduction chain and optimistically assume that all statements\n@@ -351,16 +764,13 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_info, tree_code code,\n static gimple *\n vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n-  gimple *stmt, *last_stmt = (*stmts)[0];\n+  gimple *last_stmt = (*stmts)[0];\n   tree oprnd0, oprnd1;\n-  tree oprnd00, oprnd01;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   tree type, half_type;\n   gimple *pattern_stmt;\n-  tree prod_type;\n   tree var;\n-  bool promotion;\n \n   /* Look for the following pattern\n           DX = (TYPE1) X;\n@@ -391,79 +801,50 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n     return NULL;\n \n   type = gimple_expr_type (last_stmt);\n-  stmt = last_stmt;\n \n-  gimple *def_stmt;\n-  if (type_conversion_p (oprnd0, stmt, true, &half_type, &def_stmt,\n-\t\t\t &promotion)\n-      && promotion)\n-    {\n-      stmt = def_stmt;\n-      oprnd0 = gimple_assign_rhs1 (stmt);\n-    }\n-  else\n-    half_type = type;\n+  vect_unpromoted_value unprom_mult;\n+  oprnd0 = vect_look_through_possible_promotion (vinfo, oprnd0, &unprom_mult);\n \n   /* So far so good.  Since last_stmt was detected as a (summation) reduction,\n      we know that oprnd1 is the reduction variable (defined by a loop-header\n      phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.\n      Left to check that oprnd0 is defined by a (widen_)mult_expr  */\n-  if (TREE_CODE (oprnd0) != SSA_NAME)\n+  if (!oprnd0)\n     return NULL;\n \n-  prod_type = half_type;\n   stmt_vec_info mult_vinfo = vect_get_internal_def (vinfo, oprnd0);\n   if (!mult_vinfo)\n     return NULL;\n \n   /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n      inside the loop (in case we are analyzing an outer-loop).  */\n-  gassign *mult = dyn_cast <gassign *> (mult_vinfo->stmt);\n-  if (!mult)\n+  vect_unpromoted_value unprom0[2];\n+  if (!vect_widened_op_tree (mult_vinfo, MULT_EXPR, WIDEN_MULT_EXPR,\n+\t\t\t     false, 2, unprom0, &half_type))\n     return NULL;\n-  if (gimple_assign_rhs_code (mult) == WIDEN_MULT_EXPR)\n-    {\n-      /* Has been detected as a widening multiplication?  */\n-      oprnd00 = gimple_assign_rhs1 (mult);\n-      oprnd01 = gimple_assign_rhs2 (mult);\n-    }\n-  else\n-    {\n-      tree half_type0, half_type1;\n-      gimple *def_stmt;\n-      tree oprnd0, oprnd1;\n-\n-      if (gimple_assign_rhs_code (mult) != MULT_EXPR)\n-\treturn NULL;\n \n-      oprnd0 = gimple_assign_rhs1 (mult);\n-      oprnd1 = gimple_assign_rhs2 (mult);\n-      if (!type_conversion_p (oprnd0, mult, true, &half_type0, &def_stmt,\n-\t\t\t      &promotion)\n-\t  || !promotion)\n-        return NULL;\n-      oprnd00 = gimple_assign_rhs1 (def_stmt);\n-      if (!type_conversion_p (oprnd1, mult, true, &half_type1, &def_stmt,\n-\t\t\t      &promotion)\n-\t  || !promotion)\n-        return NULL;\n-      oprnd01 = gimple_assign_rhs1 (def_stmt);\n-      if (!types_compatible_p (half_type0, half_type1))\n-        return NULL;\n-      if (TYPE_PRECISION (prod_type) != TYPE_PRECISION (half_type0) * 2)\n-\treturn NULL;\n-    }\n+  /* If there are two widening operations, make sure they agree on\n+     the sign of the extension.  */\n+  if (TYPE_PRECISION (unprom_mult.type) != TYPE_PRECISION (type)\n+      && TYPE_SIGN (unprom_mult.type) != TYPE_SIGN (half_type))\n+    return NULL;\n \n   vect_pattern_detected (\"vect_recog_dot_prod_pattern\", last_stmt);\n \n-  half_type = TREE_TYPE (oprnd00);\n+  tree half_vectype;\n   if (!vect_supportable_direct_optab_p (type, DOT_PROD_EXPR, half_type,\n-\t\t\t\t\ttype_out))\n+\t\t\t\t\ttype_out, &half_vectype))\n     return NULL;\n \n+  /* Get the inputs in the appropriate types.  */\n+  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+  tree mult_oprnd[2];\n+  vect_convert_inputs (stmt_vinfo, 2, mult_oprnd, half_type,\n+\t\t       unprom0, half_vectype);\n+\n   var = vect_recog_temp_ssa_var (type, NULL);\n   pattern_stmt = gimple_build_assign (var, DOT_PROD_EXPR,\n-\t\t\t\t      oprnd00, oprnd01, oprnd1);\n+\t\t\t\t      mult_oprnd[0], mult_oprnd[1], oprnd1);\n \n   return pattern_stmt;\n }\n@@ -510,11 +891,9 @@ static gimple *\n vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = (*stmts)[0];\n-  tree sad_oprnd0, sad_oprnd1;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   tree half_type;\n-  bool promotion;\n \n   /* Look for the following pattern\n           DX = (TYPE1) X;\n@@ -550,24 +929,23 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n \n   tree sum_type = gimple_expr_type (last_stmt);\n \n-  /* The type conversion could be promotion, demotion,\n-     or just signed -> unsigned.  */\n-  gimple *def_stmt;\n-  if (type_conversion_p (plus_oprnd0, last_stmt, false,\n-\t\t\t &half_type, &def_stmt, &promotion))\n-    plus_oprnd0 = gimple_assign_rhs1 (def_stmt);\n-  else\n-    half_type = sum_type;\n+  /* Any non-truncating sequence of conversions is OK here, since\n+     with a successful match, the result of the ABS(U) is known to fit\n+     within the nonnegative range of the result type.  (It cannot be the\n+     negative of the minimum signed value due to the range of the widening\n+     MINUS_EXPR.)  */\n+  vect_unpromoted_value unprom_abs;\n+  plus_oprnd0 = vect_look_through_possible_promotion (vinfo, plus_oprnd0,\n+\t\t\t\t\t\t      &unprom_abs);\n \n   /* So far so good.  Since last_stmt was detected as a (summation) reduction,\n      we know that plus_oprnd1 is the reduction variable (defined by a loop-header\n      phi), and plus_oprnd0 is an ssa-name defined by a stmt in the loop body.\n      Then check that plus_oprnd0 is defined by an abs_expr.  */\n \n-  if (TREE_CODE (plus_oprnd0) != SSA_NAME)\n+  if (!plus_oprnd0)\n     return NULL;\n \n-  tree abs_type = half_type;\n   stmt_vec_info abs_stmt_vinfo = vect_get_internal_def (vinfo, plus_oprnd0);\n   if (!abs_stmt_vinfo)\n     return NULL;\n@@ -581,334 +959,114 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n     return NULL;\n \n   tree abs_oprnd = gimple_assign_rhs1 (abs_stmt);\n+  tree abs_type = TREE_TYPE (abs_oprnd);\n   if (TYPE_UNSIGNED (abs_type))\n     return NULL;\n \n-  /* We then detect if the operand of abs_expr is defined by a minus_expr.  */\n-\n-  if (TREE_CODE (abs_oprnd) != SSA_NAME)\n+  /* Peel off conversions from the ABS input.  This can involve sign\n+     changes (e.g. from an unsigned subtraction to a signed ABS input)\n+     or signed promotion, but it can't include unsigned promotion.\n+     (Note that ABS of an unsigned promotion should have been folded\n+     away before now anyway.)  */\n+  vect_unpromoted_value unprom_diff;\n+  abs_oprnd = vect_look_through_possible_promotion (vinfo, abs_oprnd,\n+\t\t\t\t\t\t    &unprom_diff);\n+  if (!abs_oprnd)\n+    return NULL;\n+  if (TYPE_PRECISION (unprom_diff.type) != TYPE_PRECISION (abs_type)\n+      && TYPE_UNSIGNED (unprom_diff.type))\n     return NULL;\n \n+  /* We then detect if the operand of abs_expr is defined by a minus_expr.  */\n   stmt_vec_info diff_stmt_vinfo = vect_get_internal_def (vinfo, abs_oprnd);\n   if (!diff_stmt_vinfo)\n     return NULL;\n \n   /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n      inside the loop (in case we are analyzing an outer-loop).  */\n-  gassign *diff_stmt = dyn_cast <gassign *> (diff_stmt_vinfo->stmt);\n-  if (!diff_stmt || gimple_assign_rhs_code (diff_stmt) != MINUS_EXPR)\n-    return NULL;\n-\n-  tree half_type0, half_type1;\n-\n-  tree minus_oprnd0 = gimple_assign_rhs1 (diff_stmt);\n-  tree minus_oprnd1 = gimple_assign_rhs2 (diff_stmt);\n-\n-  if (!type_conversion_p (minus_oprnd0, diff_stmt, false,\n-                          &half_type0, &def_stmt, &promotion)\n-      || !promotion)\n-    return NULL;\n-  sad_oprnd0 = gimple_assign_rhs1 (def_stmt);\n-\n-  if (!type_conversion_p (minus_oprnd1, diff_stmt, false,\n-                          &half_type1, &def_stmt, &promotion)\n-      || !promotion)\n-    return NULL;\n-  sad_oprnd1 = gimple_assign_rhs1 (def_stmt);\n-\n-  if (!types_compatible_p (half_type0, half_type1))\n-    return NULL;\n-  if (TYPE_PRECISION (abs_type) < TYPE_PRECISION (half_type0) * 2\n-      || TYPE_PRECISION (sum_type) < TYPE_PRECISION (half_type0) * 2)\n+  vect_unpromoted_value unprom[2];\n+  if (!vect_widened_op_tree (diff_stmt_vinfo, MINUS_EXPR, MINUS_EXPR,\n+\t\t\t     false, 2, unprom, &half_type))\n     return NULL;\n \n   vect_pattern_detected (\"vect_recog_sad_pattern\", last_stmt);\n \n-  if (!vect_supportable_direct_optab_p (sum_type, SAD_EXPR,\n-\t\t\t\t\tTREE_TYPE (sad_oprnd0), type_out))\n+  tree half_vectype;\n+  if (!vect_supportable_direct_optab_p (sum_type, SAD_EXPR, half_type,\n+\t\t\t\t\ttype_out, &half_vectype))\n     return NULL;\n \n+  /* Get the inputs to the SAD_EXPR in the appropriate types.  */\n+  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+  tree sad_oprnd[2];\n+  vect_convert_inputs (stmt_vinfo, 2, sad_oprnd, half_type,\n+\t\t       unprom, half_vectype);\n+\n   tree var = vect_recog_temp_ssa_var (sum_type, NULL);\n-  gimple *pattern_stmt = gimple_build_assign (var, SAD_EXPR, sad_oprnd0,\n-\t\t\t\t\t      sad_oprnd1, plus_oprnd1);\n+  gimple *pattern_stmt = gimple_build_assign (var, SAD_EXPR, sad_oprnd[0],\n+\t\t\t\t\t      sad_oprnd[1], plus_oprnd1);\n \n   return pattern_stmt;\n }\n \n+/* Recognize an operation that performs ORIG_CODE on widened inputs,\n+   so that it can be treated as though it had the form:\n \n-/* Handle widening operation by a constant.  At the moment we support MULT_EXPR\n-   and LSHIFT_EXPR.\n+      A_TYPE a;\n+      B_TYPE b;\n+      HALF_TYPE a_cast = (HALF_TYPE) a;  // possible no-op\n+      HALF_TYPE b_cast = (HALF_TYPE) b;  // possible no-op\n+    | RES_TYPE a_extend = (RES_TYPE) a_cast;  // promotion from HALF_TYPE\n+    | RES_TYPE b_extend = (RES_TYPE) b_cast;  // promotion from HALF_TYPE\n+    | RES_TYPE res = a_extend ORIG_CODE b_extend;\n \n-   For MULT_EXPR we check that CONST_OPRND fits HALF_TYPE, and for LSHIFT_EXPR\n-   we check that CONST_OPRND is less or equal to the size of HALF_TYPE.\n+   Try to replace the pattern with:\n \n-   Otherwise, if the type of the result (TYPE) is at least 4 times bigger than\n-   HALF_TYPE, and there is an intermediate type (2 times smaller than TYPE)\n-   that satisfies the above restrictions,  we can perform a widening opeartion\n-   from the intermediate type to TYPE and replace a_T = (TYPE) a_t;\n-   with a_it = (interm_type) a_t;  Store such operation in *WSTMT.  */\n+      A_TYPE a;\n+      B_TYPE b;\n+      HALF_TYPE a_cast = (HALF_TYPE) a;  // possible no-op\n+      HALF_TYPE b_cast = (HALF_TYPE) b;  // possible no-op\n+    | EXT_TYPE ext = a_cast WIDE_CODE b_cast;\n+    | RES_TYPE res = (EXT_TYPE) ext;  // possible no-op\n \n-static bool\n-vect_handle_widen_op_by_const (gimple *stmt, enum tree_code code,\n-\t\t               tree const_oprnd, tree *oprnd,\n-\t\t\t       gimple **wstmt, tree type,\n-\t\t\t       tree *half_type, gimple *def_stmt)\n-{\n-  tree new_type, new_oprnd;\n-\n-  if (code != MULT_EXPR && code != LSHIFT_EXPR)\n-    return false;\n+   where EXT_TYPE is wider than HALF_TYPE but has the same signedness.\n \n-  if (((code == MULT_EXPR && int_fits_type_p (const_oprnd, *half_type))\n-        || (code == LSHIFT_EXPR\n-            && compare_tree_int (const_oprnd, TYPE_PRECISION (*half_type))\n-\t    \t!= 1))\n-      && TYPE_PRECISION (type) == (TYPE_PRECISION (*half_type) * 2))\n-    {\n-      /* CONST_OPRND is a constant of HALF_TYPE.  */\n-      *oprnd = gimple_assign_rhs1 (def_stmt);\n-      return true;\n-    }\n-\n-  if (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 4))\n-    return false;\n-\n-  if (!vect_same_loop_or_bb_p (stmt, def_stmt))\n-    return false;\n-\n-  /* TYPE is 4 times bigger than HALF_TYPE, try widening operation for\n-     a type 2 times bigger than HALF_TYPE.  */\n-  new_type = build_nonstandard_integer_type (TYPE_PRECISION (type) / 2,\n-                                             TYPE_UNSIGNED (type));\n-  if ((code == MULT_EXPR && !int_fits_type_p (const_oprnd, new_type))\n-      || (code == LSHIFT_EXPR\n-          && compare_tree_int (const_oprnd, TYPE_PRECISION (new_type)) == 1))\n-    return false;\n-\n-  /* Use NEW_TYPE for widening operation and create a_T = (NEW_TYPE) a_t;  */\n-  *oprnd = gimple_assign_rhs1 (def_stmt);\n-  new_oprnd = make_ssa_name (new_type);\n-  *wstmt = gimple_build_assign (new_oprnd, NOP_EXPR, *oprnd);\n-  *oprnd = new_oprnd;\n-\n-  *half_type = new_type;\n-  return true;\n-}\n-\n-\n-/* Function vect_recog_widen_mult_pattern\n-\n-   Try to find the following pattern:\n-\n-     type1 a_t;\n-     type2 b_t;\n-     TYPE a_T, b_T, prod_T;\n-\n-     S1  a_t = ;\n-     S2  b_t = ;\n-     S3  a_T = (TYPE) a_t;\n-     S4  b_T = (TYPE) b_t;\n-     S5  prod_T = a_T * b_T;\n-\n-   where type 'TYPE' is at least double the size of type 'type1' and 'type2'.\n-\n-   Also detect unsigned cases:\n-\n-     unsigned type1 a_t;\n-     unsigned type2 b_t;\n-     unsigned TYPE u_prod_T;\n-     TYPE a_T, b_T, prod_T;\n-\n-     S1  a_t = ;\n-     S2  b_t = ;\n-     S3  a_T = (TYPE) a_t;\n-     S4  b_T = (TYPE) b_t;\n-     S5  prod_T = a_T * b_T;\n-     S6  u_prod_T = (unsigned TYPE) prod_T;\n-\n-   and multiplication by constants:\n-\n-     type a_t;\n-     TYPE a_T, prod_T;\n-\n-     S1  a_t = ;\n-     S3  a_T = (TYPE) a_t;\n-     S5  prod_T = a_T * CONST;\n-\n-   A special case of multiplication by constants is when 'TYPE' is 4 times\n-   bigger than 'type', but CONST fits an intermediate type 2 times smaller\n-   than 'TYPE'.  In that case we create an additional pattern stmt for S3\n-   to create a variable of the intermediate type, and perform widen-mult\n-   on the intermediate type as well:\n-\n-     type a_t;\n-     interm_type a_it;\n-     TYPE a_T, prod_T,  prod_T';\n-\n-     S1  a_t = ;\n-     S3  a_T = (TYPE) a_t;\n-           '--> a_it = (interm_type) a_t;\n-     S5  prod_T = a_T * CONST;\n-           '--> prod_T' = a_it w* CONST;\n-\n-   Input/Output:\n-\n-   * STMTS: Contains a stmt from which the pattern search begins.  In the\n-   example, when this function is called with S5, the pattern {S3,S4,S5,(S6)}\n-   is detected.  In case of unsigned widen-mult, the original stmt (S5) is\n-   replaced with S6 in STMTS.  In case of multiplication by a constant\n-   of an intermediate type (the last case above), STMTS also contains S3\n-   (inserted before S5).\n-\n-   Output:\n-\n-   * TYPE_OUT: The type of the output of this pattern.\n-\n-   * Return value: A new stmt that will be used to replace the sequence of\n-   stmts that constitute the pattern.  In this case it will be:\n-        WIDEN_MULT <a_t, b_t>\n-   If the result of WIDEN_MULT needs to be converted to a larger type, the\n-   returned stmt will be this type conversion stmt.\n-*/\n+   SHIFT_P is true if ORIG_CODE and WIDE_CODE are shifts.  NAME is the\n+   name of the pattern being matched, for dump purposes.  */\n \n static gimple *\n-vect_recog_widen_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_widen_op_pattern (vec<gimple *> *stmts, tree *type_out,\n+\t\t\t     tree_code orig_code, tree_code wide_code,\n+\t\t\t     bool shift_p, const char *name)\n {\n   gimple *last_stmt = stmts->pop ();\n-  gimple *def_stmt0, *def_stmt1;\n-  tree oprnd0, oprnd1;\n-  tree type, half_type0, half_type1;\n-  gimple *new_stmt = NULL, *pattern_stmt = NULL;\n-  tree vectype, vecitype;\n-  tree var;\n-  enum tree_code dummy_code;\n-  int dummy_int;\n-  vec<tree> dummy_vec;\n-  bool op1_ok;\n-  bool promotion;\n-\n-  if (!is_gimple_assign (last_stmt))\n-    return NULL;\n-\n-  type = gimple_expr_type (last_stmt);\n-\n-  /* Starting from LAST_STMT, follow the defs of its uses in search\n-     of the above pattern.  */\n+  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n \n-  if (gimple_assign_rhs_code (last_stmt) != MULT_EXPR)\n+  vect_unpromoted_value unprom[2];\n+  tree half_type;\n+  if (!vect_widened_op_tree (last_stmt_info, orig_code, orig_code,\n+\t\t\t     shift_p, 2, unprom, &half_type))\n     return NULL;\n \n-  oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (last_stmt);\n-\n-  /* Check argument 0.  */\n-  if (!type_conversion_p (oprnd0, last_stmt, false, &half_type0, &def_stmt0,\n-                         &promotion)\n-      || !promotion)\n-     return NULL;\n-  /* Check argument 1.  */\n-  op1_ok = type_conversion_p (oprnd1, last_stmt, false, &half_type1,\n-                              &def_stmt1, &promotion);\n-\n-  if (op1_ok && promotion)\n-    {\n-      oprnd0 = gimple_assign_rhs1 (def_stmt0);\n-      oprnd1 = gimple_assign_rhs1 (def_stmt1);\n-    }\t       \n-  else\n-    {\n-      if (TREE_CODE (oprnd1) == INTEGER_CST\n-          && TREE_CODE (half_type0) == INTEGER_TYPE\n-          && vect_handle_widen_op_by_const (last_stmt, MULT_EXPR, oprnd1,\n-\t\t                            &oprnd0, &new_stmt, type,\n-\t\t\t\t\t    &half_type0, def_stmt0))\n-\t{\n-\t  half_type1 = half_type0;\n-\t  oprnd1 = fold_convert (half_type1, oprnd1);\n-\t}\n-      else\n-        return NULL;\n-    }\n-\n-  /* If the two arguments have different sizes, convert the one with\n-     the smaller type into the larger type.  */\n-  if (TYPE_PRECISION (half_type0) != TYPE_PRECISION (half_type1))\n-    {\n-      /* If we already used up the single-stmt slot give up.  */\n-      if (new_stmt)\n-\treturn NULL;\n-\n-      tree* oprnd = NULL;\n-      gimple *def_stmt = NULL;\n-\n-      if (TYPE_PRECISION (half_type0) < TYPE_PRECISION (half_type1))\n-\t{\n-\t  def_stmt = def_stmt0;\n-\t  half_type0 = half_type1;\n-\t  oprnd = &oprnd0;\n-\t}\n-      else\n-\t{\n-\t  def_stmt = def_stmt1;\n-\t  half_type1 = half_type0;\n-\t  oprnd = &oprnd1;\n-\t}\n-\n-      tree old_oprnd = gimple_assign_rhs1 (def_stmt);\n-      tree new_oprnd = make_ssa_name (half_type0);\n-      new_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, old_oprnd);\n-      *oprnd = new_oprnd;\n-    }\n-\n-  /* Handle unsigned case.  Look for\n-     S6  u_prod_T = (unsigned TYPE) prod_T;\n-     Use unsigned TYPE as the type for WIDEN_MULT_EXPR.  */\n-  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type0))\n-    {\n-      gimple *use_stmt;\n-      tree use_lhs;\n-      tree use_type;\n-\n-      if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (half_type1))\n-        return NULL;\n-\n-      use_stmt = vect_single_imm_use (last_stmt);\n-      if (!use_stmt || !is_gimple_assign (use_stmt)\n-\t  || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n-        return NULL;\n-\n-      use_lhs = gimple_assign_lhs (use_stmt);\n-      use_type = TREE_TYPE (use_lhs);\n-      if (!INTEGRAL_TYPE_P (use_type)\n-          || (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (use_type))\n-          || (TYPE_PRECISION (type) != TYPE_PRECISION (use_type)))\n-        return NULL;\n-\n-      type = use_type;\n-      last_stmt = use_stmt;\n-    }\n-\n-  if (!types_compatible_p (half_type0, half_type1))\n-    return NULL;\n+  /* Pattern detected.  */\n+  vect_pattern_detected (name, last_stmt);\n \n-  /* If TYPE is more than twice larger than HALF_TYPE, we use WIDEN_MULT\n-     to get an intermediate result of type ITYPE.  In this case we need\n-     to build a statement to convert this intermediate result to type TYPE.  */\n+  tree type = gimple_expr_type (last_stmt);\n   tree itype = type;\n-  if (TYPE_PRECISION (type) > TYPE_PRECISION (half_type0) * 2)\n-    itype = build_nonstandard_integer_type\n-\t      (GET_MODE_BITSIZE (SCALAR_TYPE_MODE (half_type0)) * 2,\n-\t       TYPE_UNSIGNED (type));\n-\n-  /* Pattern detected.  */\n-  vect_pattern_detected (\"vect_recog_widen_mult_pattern\", last_stmt);\n+  if (TYPE_PRECISION (type) != TYPE_PRECISION (half_type) * 2\n+      || TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type))\n+    itype = build_nonstandard_integer_type (TYPE_PRECISION (half_type) * 2,\n+\t\t\t\t\t    TYPE_UNSIGNED (half_type));\n \n   /* Check target support  */\n-  vectype = get_vectype_for_scalar_type (half_type0);\n-  vecitype = get_vectype_for_scalar_type (itype);\n+  tree vectype = get_vectype_for_scalar_type (half_type);\n+  tree vecitype = get_vectype_for_scalar_type (itype);\n+  enum tree_code dummy_code;\n+  int dummy_int;\n+  auto_vec<tree> dummy_vec;\n   if (!vectype\n       || !vecitype\n-      || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n+      || !supportable_widening_operation (wide_code, last_stmt,\n \t\t\t\t\t  vecitype, vectype,\n \t\t\t\t\t  &dummy_code, &dummy_code,\n \t\t\t\t\t  &dummy_int, &dummy_vec))\n@@ -918,43 +1076,28 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n   if (!*type_out)\n     return NULL;\n \n-  /* Pattern supported. Create a stmt to be used to replace the pattern: */\n-  var = vect_recog_temp_ssa_var (itype, NULL);\n-  pattern_stmt = gimple_build_assign (var, WIDEN_MULT_EXPR, oprnd0, oprnd1);\n-\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+  STMT_VINFO_PATTERN_DEF_SEQ (last_stmt_info) = NULL;\n+  tree oprnd[2];\n+  vect_convert_inputs (last_stmt_info, 2, oprnd, half_type, unprom, vectype);\n \n-  /* If the original two operands have different sizes, we may need to convert\n-     the smaller one into the larget type.  If this is the case, at this point\n-     the new stmt is already built.  */\n-  if (new_stmt)\n-    {\n-      append_pattern_def_seq (stmt_vinfo, new_stmt);\n-      stmt_vec_info new_stmt_info\n-        = new_stmt_vec_info (new_stmt, stmt_vinfo->vinfo);\n-      set_vinfo_for_stmt (new_stmt, new_stmt_info);\n-      STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n-    }\n-\n-  /* If ITYPE is not TYPE, we need to build a type convertion stmt to convert\n-     the result of the widen-mult operation into type TYPE.  */\n-  if (itype != type)\n-    {\n-      append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n-      stmt_vec_info pattern_stmt_info\n-        = new_stmt_vec_info (pattern_stmt, stmt_vinfo->vinfo);\n-      set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n-      STMT_VINFO_VECTYPE (pattern_stmt_info) = vecitype;\n-      pattern_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n-\t\t\t\t\t  NOP_EXPR,\n-\t\t\t\t\t  gimple_assign_lhs (pattern_stmt));\n-    }\n+  tree var = vect_recog_temp_ssa_var (itype, NULL);\n+  gimple *pattern_stmt = gimple_build_assign (var, wide_code,\n+\t\t\t\t\t      oprnd[0], oprnd[1]);\n \n   stmts->safe_push (last_stmt);\n-  return pattern_stmt;\n+  return vect_convert_output (last_stmt_info, type, pattern_stmt, vecitype);\n }\n \n+/* Try to detect multiplication on widened inputs, converting MULT_EXPR\n+   to WIDEN_MULT_EXPR.  See vect_recog_widen_op_pattern for details.  */\n+\n+static gimple *\n+vect_recog_widen_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n+{\n+  return vect_recog_widen_op_pattern (stmts, type_out, MULT_EXPR,\n+\t\t\t\t      WIDEN_MULT_EXPR, false,\n+\t\t\t\t      \"vect_recog_widen_mult_pattern\");\n+}\n \n /* Function vect_recog_pow_pattern\n \n@@ -1147,13 +1290,13 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_out)\n static gimple *\n vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n-  gimple *stmt, *last_stmt = (*stmts)[0];\n+  gimple *last_stmt = (*stmts)[0];\n   tree oprnd0, oprnd1;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  tree type, half_type;\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n+  tree type;\n   gimple *pattern_stmt;\n   tree var;\n-  bool promotion;\n \n   /* Look for the following pattern\n           DX = (TYPE) X;\n@@ -1177,21 +1320,19 @@ vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n      Left to check that oprnd0 is defined by a cast from type 'type' to type\n      'TYPE'.  */\n \n-  if (!type_conversion_p (oprnd0, last_stmt, true, &half_type, &stmt,\n-                          &promotion)\n-      || !promotion)\n+  vect_unpromoted_value unprom0;\n+  if (!vect_look_through_possible_promotion (vinfo, oprnd0, &unprom0)\n+      || TYPE_PRECISION (unprom0.type) * 2 > TYPE_PRECISION (type))\n     return NULL;\n \n-  oprnd0 = gimple_assign_rhs1 (stmt);\n-\n   vect_pattern_detected (\"vect_recog_widen_sum_pattern\", last_stmt);\n \n-  if (!vect_supportable_direct_optab_p (type, WIDEN_SUM_EXPR, half_type,\n+  if (!vect_supportable_direct_optab_p (type, WIDEN_SUM_EXPR, unprom0.type,\n \t\t\t\t\ttype_out))\n     return NULL;\n \n   var = vect_recog_temp_ssa_var (type, NULL);\n-  pattern_stmt = gimple_build_assign (var, WIDEN_SUM_EXPR, oprnd0, oprnd1);\n+  pattern_stmt = gimple_build_assign (var, WIDEN_SUM_EXPR, unprom0.op, oprnd1);\n \n   return pattern_stmt;\n }\n@@ -1556,159 +1697,15 @@ vect_recog_over_widening_pattern (vec<gimple *> *stmts, tree *type_out)\n   return pattern_stmt;\n }\n \n-/* Detect widening shift pattern:\n-\n-   type a_t;\n-   TYPE a_T, res_T;\n-\n-   S1 a_t = ;\n-   S2 a_T = (TYPE) a_t;\n-   S3 res_T = a_T << CONST;\n-\n-  where type 'TYPE' is at least double the size of type 'type'.\n-\n-  Also detect cases where the shift result is immediately converted\n-  to another type 'result_type' that is no larger in size than 'TYPE'.\n-  In those cases we perform a widen-shift that directly results in\n-  'result_type', to avoid a possible over-widening situation:\n-\n-  type a_t;\n-  TYPE a_T, res_T;\n-  result_type res_result;\n-\n-  S1 a_t = ;\n-  S2 a_T = (TYPE) a_t;\n-  S3 res_T = a_T << CONST;\n-  S4 res_result = (result_type) res_T;\n-      '--> res_result' = a_t w<< CONST;\n-\n-  And a case when 'TYPE' is 4 times bigger than 'type'.  In that case we\n-  create an additional pattern stmt for S2 to create a variable of an\n-  intermediate type, and perform widen-shift on the intermediate type:\n-\n-  type a_t;\n-  interm_type a_it;\n-  TYPE a_T, res_T, res_T';\n-\n-  S1 a_t = ;\n-  S2 a_T = (TYPE) a_t;\n-      '--> a_it = (interm_type) a_t;\n-  S3 res_T = a_T << CONST;\n-      '--> res_T' = a_it <<* CONST;\n-\n-  Input/Output:\n-\n-  * STMTS: Contains a stmt from which the pattern search begins.\n-    In case of unsigned widen-shift, the original stmt (S3) is replaced with S4\n-    in STMTS.  When an intermediate type is used and a pattern statement is\n-    created for S2, we also put S2 here (before S3).\n-\n-  Output:\n-\n-  * TYPE_OUT: The type of the output of this pattern.\n-\n-  * Return value: A new stmt that will be used to replace the sequence of\n-    stmts that constitute the pattern.  In this case it will be:\n-    WIDEN_LSHIFT_EXPR <a_t, CONST>.  */\n+/* Try to detect a shift left of a widened input, converting LSHIFT_EXPR\n+   to WIDEN_LSHIFT_EXPR.  See vect_recog_widen_op_pattern for details.  */\n \n static gimple *\n vect_recog_widen_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n-  gimple *last_stmt = stmts->pop ();\n-  gimple *def_stmt0;\n-  tree oprnd0, oprnd1;\n-  tree type, half_type0;\n-  gimple *pattern_stmt;\n-  tree vectype, vectype_out = NULL_TREE;\n-  tree var;\n-  enum tree_code dummy_code;\n-  int dummy_int;\n-  vec<tree>  dummy_vec;\n-  gimple *use_stmt;\n-  bool promotion;\n-\n-  if (!is_gimple_assign (last_stmt) || !vinfo_for_stmt (last_stmt))\n-    return NULL;\n-\n-  if (gimple_assign_rhs_code (last_stmt) != LSHIFT_EXPR)\n-    return NULL;\n-\n-  oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (last_stmt);\n-  if (TREE_CODE (oprnd0) != SSA_NAME || TREE_CODE (oprnd1) != INTEGER_CST)\n-    return NULL;\n-\n-  /* Check operand 0: it has to be defined by a type promotion.  */\n-  if (!type_conversion_p (oprnd0, last_stmt, false, &half_type0, &def_stmt0,\n-\t\t\t  &promotion)\n-      || !promotion)\n-     return NULL;\n-\n-  /* Check operand 1: has to be positive.  We check that it fits the type\n-     in vect_handle_widen_op_by_const ().  */\n-  if (tree_int_cst_compare (oprnd1, size_zero_node) <= 0)\n-    return NULL;\n-\n-  oprnd0 = gimple_assign_rhs1 (def_stmt0);\n-  type = gimple_expr_type (last_stmt);\n-\n-  /* Check for subsequent conversion to another type.  */\n-  use_stmt = vect_single_imm_use (last_stmt);\n-  if (use_stmt && is_gimple_assign (use_stmt)\n-      && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n-      && !STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (use_stmt)))\n-    {\n-      tree use_lhs = gimple_assign_lhs (use_stmt);\n-      tree use_type = TREE_TYPE (use_lhs);\n-\n-      if (INTEGRAL_TYPE_P (use_type)\n-\t  && TYPE_PRECISION (use_type) <= TYPE_PRECISION (type))\n-\t{\n-\t  last_stmt = use_stmt;\n-\t  type = use_type;\n-\t}\n-    }\n-\n-  /* Check if this a widening operation.  */\n-  gimple *wstmt = NULL;\n-  if (!vect_handle_widen_op_by_const (last_stmt, LSHIFT_EXPR, oprnd1,\n-       \t\t\t\t      &oprnd0, &wstmt,\n-\t                              type, &half_type0, def_stmt0))\n-    return NULL;\n-\n-  /* Pattern detected.  */\n-  vect_pattern_detected (\"vect_recog_widen_shift_pattern\", last_stmt);\n-\n-  /* Check target support.  */\n-  vectype = get_vectype_for_scalar_type (half_type0);\n-  vectype_out = get_vectype_for_scalar_type (type);\n-\n-  if (!vectype\n-      || !vectype_out\n-      || !supportable_widening_operation (WIDEN_LSHIFT_EXPR, last_stmt,\n-\t\t\t\t\t  vectype_out, vectype,\n-\t\t\t\t\t  &dummy_code, &dummy_code,\n-\t\t\t\t\t  &dummy_int, &dummy_vec))\n-    return NULL;\n-\n-  *type_out = vectype_out;\n-\n-  /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n-  var = vect_recog_temp_ssa_var (type, NULL);\n-  pattern_stmt\n-    = gimple_build_assign (var, WIDEN_LSHIFT_EXPR, oprnd0, oprnd1);\n-  if (wstmt)\n-    {\n-      stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-      new_pattern_def_seq (stmt_vinfo, wstmt);\n-      stmt_vec_info new_stmt_info\n-\t= new_stmt_vec_info (wstmt, stmt_vinfo->vinfo);\n-      set_vinfo_for_stmt (wstmt, new_stmt_info);\n-      STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n-    }\n-\n-  stmts->safe_push (last_stmt);\n-  return pattern_stmt;\n+  return vect_recog_widen_op_pattern (stmts, type_out, LSHIFT_EXPR,\n+\t\t\t\t      WIDEN_LSHIFT_EXPR, true,\n+\t\t\t\t      \"vect_widen_shift_pattern\");\n }\n \n /* Detect a rotate pattern wouldn't be otherwise vectorized:"}]}