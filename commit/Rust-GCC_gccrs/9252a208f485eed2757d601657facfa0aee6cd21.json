{"sha": "9252a208f485eed2757d601657facfa0aee6cd21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI1MmEyMDhmNDg1ZWVkMjc1N2Q2MDE2NTdmYWNmYTBhZWU2Y2QyMQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-30T06:26:51Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-30T07:22:05Z"}, "message": "coroutines: Collect the function body rewrite code.\n\nThe standard describes a rewrite of the body of the user-authored\nfunction (which wraps it in a try-catch block and provides the\ninitial and final suspend expressions).  The exact arrangement of\nthis was still in flux right up until the DIS and as a consequence\nwas a bit of a moving target.\n\nThe net result was a fragmented implementation of the parts of\nthe rewrite which is now impeding progress in fixing other issues.\n\nThis patch collates the rewrite action into a single function and\ncarries this out earlier.\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (expand_one_await_expression): Remove\n\tcode dealing with initial suspend.\n\t(build_actor_fn): Remove code special-casing initial\n\tand final suspend. Handle the final suspend and marking\n\tof the coroutine as done.\n\t(coro_rewrite_function_body): New.\n\t(bind_expr_find_in_subtree): Remove.\n\t(coro_body_contains_bind_expr_p): Remove.\n\t(morph_fn_to_coro): Split the rewrite of the original\n\tfunction into coro_rewrite_function_body and call it.", "tree": {"sha": "88960f669da6a9ea2fe21c4af5a0bb380a155c09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88960f669da6a9ea2fe21c4af5a0bb380a155c09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9252a208f485eed2757d601657facfa0aee6cd21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9252a208f485eed2757d601657facfa0aee6cd21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9252a208f485eed2757d601657facfa0aee6cd21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9252a208f485eed2757d601657facfa0aee6cd21/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b7272a2f7333905a4cd2caedff27c1fbec95f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b7272a2f7333905a4cd2caedff27c1fbec95f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b7272a2f7333905a4cd2caedff27c1fbec95f09"}], "stats": {"total": 542, "additions": 213, "deletions": 329}, "files": [{"sha": "ba4ac682f11de49a2f19a96daed91e97c8116285", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 213, "deletions": 329, "changes": 542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9252a208f485eed2757d601657facfa0aee6cd21/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9252a208f485eed2757d601657facfa0aee6cd21/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=9252a208f485eed2757d601657facfa0aee6cd21", "patch": "@@ -1573,8 +1573,6 @@ expand_one_await_expression (tree *stmt, tree *await_expr, void *d)\n   tree awaiter_calls = TREE_OPERAND (saved_co_await, 3);\n \n   tree source = TREE_OPERAND (saved_co_await, 4);\n-  bool is_initial =\n-    (source && TREE_INT_CST_LOW (source) == (int) INITIAL_SUSPEND_POINT);\n   bool is_final = (source\n \t\t   && TREE_INT_CST_LOW (source) == (int) FINAL_SUSPEND_POINT);\n   bool needs_dtor = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (var));\n@@ -1724,16 +1722,6 @@ expand_one_await_expression (tree *stmt, tree *await_expr, void *d)\n   resume_label = build_stmt (loc, LABEL_EXPR, resume_label);\n   append_to_statement_list (resume_label, &stmt_list);\n \n-  if (is_initial)\n-    {\n-      /* Note that we are about to execute the await_resume() for the initial\n-\t await expression.  */\n-      r = build2_loc (loc, MODIFY_EXPR, boolean_type_node, data->i_a_r_c,\n-\t\t      boolean_true_node);\n-      r = coro_build_cvt_void_expr_stmt (r, loc);\n-      append_to_statement_list (r, &stmt_list);\n-    }\n-\n   /* This will produce the value (if one is provided) from the co_await\n      expression.  */\n   tree resume_call = TREE_VEC_ELT (awaiter_calls, 2); /* await_resume().  */\n@@ -2102,19 +2090,16 @@ static void\n build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t\ttree orig, hash_map<tree, param_info> *param_uses,\n \t\thash_map<tree, local_var_info> *local_var_uses,\n-\t\tvec<tree, va_gc> *param_dtor_list, tree initial_await,\n-\t\ttree final_await, unsigned body_count, tree frame_size)\n+\t\tvec<tree, va_gc> *param_dtor_list,\n+\t\ttree fs_label, tree resume_fn_field,\n+\t\tunsigned body_count, tree frame_size)\n {\n   verify_stmt_tree (fnbody);\n   /* Some things we inherit from the original function.  */\n-  tree coro_frame_ptr = build_pointer_type (coro_frame_type);\n   tree handle_type = get_coroutine_handle_type (orig);\n   tree self_h_proxy = get_coroutine_self_handle_proxy (orig);\n   tree promise_type = get_coroutine_promise_type (orig);\n   tree promise_proxy = get_coroutine_promise_proxy (orig);\n-  tree act_des_fn_type\n-    = build_function_type_list (void_type_node, coro_frame_ptr, NULL_TREE);\n-  tree act_des_fn_ptr = build_pointer_type (act_des_fn_type);\n \n   /* One param, the coro frame pointer.  */\n   tree actor_fp = DECL_ARGUMENTS (actor);\n@@ -2145,21 +2130,15 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   DECL_CONTEXT (continuation) = actor;\n   BIND_EXPR_VARS (actor_bind) = continuation;\n \n-  /* Update the block associated with the outer scope of the orig fn.  */\n+  /* Link in the block associated with the outer scope of the re-written\n+     function body.  */\n   tree first = expr_first (fnbody);\n-  if (first && TREE_CODE (first) == BIND_EXPR)\n-    {\n-      /* We will discard this, since it's connected to the original scope\n-\t nest.  */\n-      tree block = BIND_EXPR_BLOCK (first);\n-      if (block) /* For this to be missing is probably a bug.  */\n-\t{\n-\t  gcc_assert (BLOCK_SUPERCONTEXT (block) == NULL_TREE);\n-\t  gcc_assert (BLOCK_CHAIN (block) == NULL_TREE);\n-\t  BLOCK_SUPERCONTEXT (block) = top_block;\n-\t  BLOCK_SUBBLOCKS (top_block) = block;\n-\t}\n-    }\n+  gcc_checking_assert (first && TREE_CODE (first) == BIND_EXPR);\n+  tree block = BIND_EXPR_BLOCK (first);\n+  gcc_checking_assert (BLOCK_SUPERCONTEXT (block) == NULL_TREE);\n+  gcc_checking_assert (BLOCK_CHAIN (block) == NULL_TREE);\n+  BLOCK_SUPERCONTEXT (block) = top_block;\n+  BLOCK_SUBBLOCKS (top_block) = block;\n \n   add_stmt (actor_bind);\n   tree actor_body = push_stmt_list ();\n@@ -2236,7 +2215,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   add_stmt (b);\n \n   short unsigned lab_num = 3;\n-  for (unsigned destr_pt = 0; destr_pt < body_count + 2; destr_pt++)\n+  for (unsigned destr_pt = 0; destr_pt < body_count; destr_pt++)\n     {\n       tree l_num = build_int_cst (short_unsigned_type_node, lab_num);\n       b = build_case_label (l_num, NULL_TREE,\n@@ -2272,8 +2251,10 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   add_stmt (b);\n \n   lab_num = 2;\n-  /* The final resume should be made to hit the default (trap, UB) entry.  */\n-  for (unsigned resu_pt = 0; resu_pt < body_count + 1; resu_pt++)\n+  /* The final resume should be made to hit the default (trap, UB) entry\n+     although it will be unreachable via the normal entry point, since that\n+     is set to NULL on reaching final suspend.  */\n+  for (unsigned resu_pt = 0; resu_pt < body_count; resu_pt++)\n     {\n       tree l_num = build_int_cst (short_unsigned_type_node, lab_num);\n       b = build_case_label (l_num, NULL_TREE,\n@@ -2326,55 +2307,19 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   await_xform_data xform\n     = {actor, actor_frame, promise_proxy, ap, self_h_proxy, ash};\n \n-  /* Get a reference to the initial suspend var in the frame.  */\n-  transform_await_expr (initial_await, &xform);\n-  tree initial_await_stmt = coro_build_expr_stmt (initial_await, loc);\n-\n-  /* co_return branches to the final_suspend label, so declare that now.  */\n-  tree fs_label = create_named_label_with_ctx (loc, \"final.suspend\", actor);\n-\n   /* Expand co_returns in the saved function body  */\n   fnbody = expand_co_returns (&fnbody, promise_proxy, ap, fs_label);\n \n-  /* Specific behaviour to treat exceptions thrown by the await_resume ()\n-     of the initial suspend expression.  In order to implement this, we\n-     need to treat the initial_suspend expression as if it were part of the\n-     user-authored function body.  This only applies if exceptions are\n-     enabled.  */\n-  if (flag_exceptions)\n-    {\n-      tree outer = fnbody;\n-      if (TREE_CODE (outer) == BIND_EXPR)\n-\touter = BIND_EXPR_BODY (outer);\n-      gcc_checking_assert (TREE_CODE (outer) == TRY_BLOCK);\n-      tree sl = TRY_STMTS (outer);\n-      if (TREE_CODE (sl) == STATEMENT_LIST)\n-\t{\n-\t  tree_stmt_iterator si = tsi_start (sl);\n-\t  tsi_link_before (&si, initial_await_stmt, TSI_NEW_STMT);\n-\t}\n-      else\n-\t{\n-\t  tree new_try = NULL_TREE;\n-\t  append_to_statement_list (initial_await_stmt, &new_try);\n-\t  append_to_statement_list (sl, &new_try);\n-\t  TRY_STMTS (outer) = new_try;\n-\t}\n-    }\n-  else\n-    add_stmt (initial_await_stmt);\n-\n   /* Transform the await expressions in the function body.  Only do each\n      await tree once!  */\n   hash_set<tree> pset;\n   cp_walk_tree (&fnbody, transform_await_wrapper, &xform, &pset);\n \n-  /* Add in our function body with the co_returns rewritten to final form.  */\n-  add_stmt (fnbody);\n-\n-  /* Final suspend starts here.  */\n-  r = build_stmt (loc, LABEL_EXPR, fs_label);\n-  add_stmt (r);\n+  /* Now replace the promise proxy with its real value.  */\n+  proxy_replace p_data;\n+  p_data.from = promise_proxy;\n+  p_data.to = ap;\n+  cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n \n   /* Set the actor pointer to null, so that 'done' will work.\n      Resume from here is UB anyway - although a 'ready' await will\n@@ -2384,15 +2329,12 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree res_x = build_class_member_access_expr (actor_frame, resume_m, NULL_TREE,\n \t\t\t\t\t       false, tf_warning_or_error);\n-  r = build1 (CONVERT_EXPR, act_des_fn_ptr, integer_zero_node);\n-  r = build2 (INIT_EXPR, act_des_fn_ptr, res_x, r);\n-  r = coro_build_cvt_void_expr_stmt (r, loc);\n-  add_stmt (r);\n+  p_data.from = resume_fn_field;\n+  p_data.to = res_x;\n+  cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n \n-  /* Get a reference to the final suspend var in the frame.  */\n-  transform_await_expr (final_await, &xform);\n-  r = coro_build_expr_stmt (final_await, loc);\n-  add_stmt (r);\n+  /* Add in our function body with the co_returns rewritten to final form.  */\n+  add_stmt (fnbody);\n \n   /* now do the tail of the function.  */\n   tree del_promise_label\n@@ -2559,20 +2501,10 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n     = build_class_member_access_expr (actor_frame, res_idx_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n \n-  /* Boolean value to flag that the initial suspend expression's\n-     await_resume () has been called, and therefore we are in the user's\n-     function body for the purposes of handing exceptions.  */\n-  tree i_a_r_c_m\n-    = lookup_member (coro_frame_type, get_identifier (\"__i_a_r_c\"),\n-\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n-  tree i_a_r_c\n-    = build_class_member_access_expr (actor_frame, i_a_r_c_m, NULL_TREE,\n-\t\t\t\t      false, tf_warning_or_error);\n-\n   /* We've now rewritten the tree and added the initial and final\n      co_awaits.  Now pass over the tree and expand the co_awaits.  */\n \n-  coro_aw_data data = {actor, actor_fp, resume_pt_number, i_a_r_c,\n+  coro_aw_data data = {actor, actor_fp, resume_pt_number, NULL_TREE,\n \t\t       ash, del_promise_label, ret_label,\n \t\t       continue_label, continuation, 2};\n   cp_walk_tree (&actor_body, await_statement_expander, &data, NULL);\n@@ -3641,23 +3573,165 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n   return fn;\n }\n \n-/* Return a bind expression if we see one, else NULL_TREE.  */\n+/* Re-write the body as per [dcl.fct.def.coroutine] / 5.  */\n+\n static tree\n-bind_expr_find_in_subtree (tree *stmt, int *, void *)\n+coro_rewrite_function_body (location_t fn_start, tree fnbody,\n+\t\t\t    tree orig, tree resume_fn_ptr_type,\n+\t\t\t    tree& resume_fn_field, tree& fs_label)\n {\n-  if (TREE_CODE (*stmt) == BIND_EXPR)\n-    return *stmt;\n-  return NULL_TREE;\n-}\n+  /* This will be our new outer scope.  */\n+  tree update_body = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+  tree top_block = make_node (BLOCK);\n+  BIND_EXPR_BLOCK (update_body) = top_block;\n+  BIND_EXPR_BODY (update_body) = push_stmt_list ();\n \n-/* Return the first bind expression that the sub-tree given by STMT\n-   contains.  */\n+  /* If the function has a top level bind expression, then connect that\n+     after first making sure we give it a new block.  */\n+  tree first = expr_first (fnbody);\n+  if (first && TREE_CODE (first) == BIND_EXPR)\n+    {\n+      tree block = BIND_EXPR_BLOCK (first);\n+      gcc_checking_assert (block);\n+      gcc_checking_assert (BLOCK_SUPERCONTEXT (block) == NULL_TREE);\n+      gcc_checking_assert (BLOCK_CHAIN (block) == NULL_TREE);\n+      /* Replace the top block to avoid issues with locations for args\n+\t appearing to be in a non-existent place.  */\n+      tree replace_blk = make_node (BLOCK);\n+      BLOCK_VARS (replace_blk) = BLOCK_VARS (block);\n+      BLOCK_SUBBLOCKS (replace_blk) = BLOCK_SUBBLOCKS (block);\n+      for (tree b = BLOCK_SUBBLOCKS (replace_blk); b; b = BLOCK_CHAIN (b))\n+\tBLOCK_SUPERCONTEXT (b) = replace_blk;\n+      BIND_EXPR_BLOCK (first) = replace_blk;\n+      /* The top block has one child, so far, and we have now got a \n+\t superblock.  */\n+      BLOCK_SUPERCONTEXT (block) = top_block;\n+      BLOCK_SUBBLOCKS (top_block) = block;\n+    }\n \n-static tree\n-coro_body_contains_bind_expr_p (tree *stmt)\n-{\n-  hash_set<tree> visited;\n-  return cp_walk_tree (stmt, bind_expr_find_in_subtree, NULL, &visited);\n+  /* Wrap the function body in a try {} catch (...) {} block, if exceptions\n+     are enabled.  */\n+  tree promise = get_coroutine_promise_proxy (orig);\n+  tree var_list = NULL_TREE;\n+  tree initial_await = build_init_or_final_await (fn_start, false);\n+\n+  /* [stmt.return.coroutine] / 3\n+     If p.return_void() is a valid expression, flowing off the end of a\n+     coroutine is equivalent to a co_return with no operand; otherwise\n+     flowing off the end of a coroutine results in undefined behavior.  */\n+  tree return_void\n+    = get_coroutine_return_void_expr (current_function_decl, fn_start, false);\n+\n+  if (flag_exceptions)\n+    {\n+      /* Build promise.unhandled_exception();  */\n+      tree ueh\n+\t= coro_build_promise_expression (current_function_decl, promise,\n+\t\t\t\t\t coro_unhandled_exception_identifier,\n+\t\t\t\t\t fn_start, NULL, /*musthave=*/true);\n+      /* Create and initialize the initial-await-resume-called variable per\n+\t [dcl.fct.def.coroutine] / 5.3.  */\n+      tree i_a_r_c = build_lang_decl (VAR_DECL, get_identifier (\"__i_a_r_c\"),\n+\t\t\t\t      boolean_type_node);\n+      DECL_ARTIFICIAL (i_a_r_c) = true;\n+      DECL_CHAIN (i_a_r_c) = var_list;\n+      var_list = i_a_r_c;\n+      DECL_INITIAL (i_a_r_c) = boolean_false_node;\n+      add_decl_expr (i_a_r_c);\n+      /* Start the try-catch.  */\n+      tree tcb = build_stmt (fn_start, TRY_BLOCK, NULL_TREE, NULL_TREE);\n+      add_stmt (tcb);\n+      TRY_STMTS (tcb) = push_stmt_list ();\n+      if (initial_await != error_mark_node)\n+\t{\n+\t  /* Build a compound expression that sets the\n+\t     initial-await-resume-called variable true and then calls the\n+\t     initial suspend expression await resume.  */\n+\t  tree vec = TREE_OPERAND (initial_await, 3);\n+\t  tree aw_r = TREE_VEC_ELT (vec, 2);\n+\t  tree update = build2 (MODIFY_EXPR, boolean_type_node, i_a_r_c,\n+\t\t\t\tboolean_true_node);\n+\t  aw_r = cp_build_compound_expr (update, aw_r, tf_warning_or_error);\n+\t  TREE_VEC_ELT (vec, 2) = aw_r;\n+\t}\n+      /* Add the initial await to the start of the user-authored function.  */\n+      finish_expr_stmt (initial_await);\n+      /* Append the original function body.  */\n+      add_stmt (fnbody);\n+      if (return_void)\n+\tadd_stmt (return_void);\n+      TRY_STMTS (tcb) = pop_stmt_list (TRY_STMTS (tcb));\n+      TRY_HANDLERS (tcb) = push_stmt_list ();\n+      /* Mimic what the parser does for the catch.  */\n+      tree handler = begin_handler ();\n+      finish_handler_parms (NULL_TREE, handler); /* catch (...) */\n+\n+      /* Get the initial await resume called value.  */\n+      tree not_iarc_if = begin_if_stmt ();\n+      tree not_iarc = build1_loc (fn_start, TRUTH_NOT_EXPR,\n+\t\t\t\t  boolean_type_node, i_a_r_c);\n+      finish_if_stmt_cond (not_iarc, not_iarc_if);\n+      /* If the initial await resume called value is false, rethrow...  */\n+      tree rethrow = build_throw (fn_start, NULL_TREE);\n+      TREE_NO_WARNING (rethrow) = true;\n+      finish_expr_stmt (rethrow);\n+      finish_then_clause (not_iarc_if);\n+      tree iarc_scope = IF_SCOPE (not_iarc_if);\n+      IF_SCOPE (not_iarc_if) = NULL;\n+      not_iarc_if = do_poplevel (iarc_scope);\n+      add_stmt (not_iarc_if);\n+      /* ... else call the promise unhandled exception method.  */\n+      ueh = maybe_cleanup_point_expr_void (ueh);\n+      add_stmt (ueh);\n+      finish_handler (handler);\n+      TRY_HANDLERS (tcb) = pop_stmt_list (TRY_HANDLERS (tcb));\n+    }\n+  else\n+    {\n+      if (pedantic)\n+\t{\n+\t  /* We still try to look for the promise method and warn if it's not\n+\t     present.  */\n+\t  tree ueh_meth\n+\t    = lookup_promise_method (orig, coro_unhandled_exception_identifier,\n+\t\t\t\t     fn_start, /*musthave=*/false);\n+\t  if (!ueh_meth || ueh_meth == error_mark_node)\n+\t    warning_at (fn_start, 0, \"no member named %qE in %qT\",\n+\t\t\tcoro_unhandled_exception_identifier,\n+\t\t\tget_coroutine_promise_type (orig));\n+\t}\n+      /* Else we don't check and don't care if the method is missing..\n+\t just add the initial suspend, function and return.  */\n+      finish_expr_stmt (initial_await);\n+      /* Append the original function body.  */\n+      add_stmt (fnbody);\n+      if (return_void)\n+\tadd_stmt (return_void);\n+    }\n+\n+  /* co_return branches to the final_suspend label, so declare that now.  */\n+  fs_label\n+    = create_named_label_with_ctx (fn_start, \"final.suspend\", NULL_TREE);\n+  add_stmt (build_stmt (fn_start, LABEL_EXPR, fs_label));\n+\n+  /* Before entering the final suspend point, we signal that this point has\n+     been reached by setting the resume function pointer to zero (this is\n+     what the 'done()' builtin tests) as per the current ABI.  */\n+  resume_fn_field\n+    = build_lang_decl (VAR_DECL, get_identifier (\"resume.fn.ptr.proxy\"),\n+\t\t       resume_fn_ptr_type);\n+  DECL_ARTIFICIAL (resume_fn_field) = true;\n+  tree zero_resume\n+    = build1 (CONVERT_EXPR, resume_fn_ptr_type, integer_zero_node);\n+  zero_resume\n+    = build2 (INIT_EXPR, resume_fn_ptr_type, resume_fn_field, zero_resume);\n+  finish_expr_stmt (zero_resume);\n+  finish_expr_stmt (build_init_or_final_await (fn_start, true));\n+  BIND_EXPR_BODY (update_body) = pop_stmt_list (BIND_EXPR_BODY (update_body));\n+  BIND_EXPR_VARS (update_body) = nreverse (var_list);\n+  BLOCK_VARS (top_block) = BIND_EXPR_VARS (update_body);\n+\n+  return update_body;\n }\n \n /* Here we:\n@@ -3734,55 +3808,32 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       return false;\n     }\n \n-  /* So, we've tied off the original body.  Now start the replacement.\n+  /* So, we've tied off the original user-authored body in fn_body.\n+\n+     Start the replacement synthesized ramp body as newbody.\n      If we encounter a fatal error we might return a now-empty body.\n-     TODO: determine if it would help to restore the original.\n-\t   determine if looking for more errors in coro_function_valid_p()\n-\t   and stashing types is a better solution.  */\n+\n+     Note, the returned ramp body is not 'popped', to be compatible with\n+     the way that decl.c handles regular functions, the scope pop is done\n+     in the caller.  */\n \n   tree newbody = push_stmt_list ();\n   DECL_SAVED_TREE (orig) = newbody;\n \n   /* If our original body is noexcept, then that's what we apply to our\n-     generated functions.  Remember that we're NOEXCEPT and fish out the\n-     contained list (we tied off to the top level already).  */\n+     generated ramp, transfer any MUST_NOT_THOW_EXPR to that.  */\n   bool is_noexcept = TREE_CODE (body_start) == MUST_NOT_THROW_EXPR;\n   if (is_noexcept)\n     {\n-      /* Simplified abstract from begin_eh_spec_block, since we already\n-\t know the outcome.  */\n-      fnbody = TREE_OPERAND (body_start, 0); /* Stash the original...  */\n-      add_stmt (body_start);\t\t     /* ... and start the new.  */\n+      /* The function body we will continue with is the single operand to\n+\t the must-not-throw.  */\n+      fnbody = TREE_OPERAND (body_start, 0);\n+      /* Transfer the must-not-throw to the ramp body.  */\n+      add_stmt (body_start);\n+      /* Re-start the ramp as must-not-throw.  */\n       TREE_OPERAND (body_start, 0) = push_stmt_list ();\n     }\n \n-  /* We can be presented with a function that currently has no outer bind\n-     expression.  We will insert bind scopes in expanding await expressions,\n-     and therefore need a top level to the tree, so synthesize an outer bind\n-     expression and scope.  */\n-  tree check_bind = expr_first (fnbody);\n-  if (check_bind && TREE_CODE (check_bind) != BIND_EXPR)\n-    {\n-      tree update_body = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-      tree blk = make_node (BLOCK);\n-      gcc_checking_assert (!coro_body_contains_bind_expr_p (&fnbody));\n-      BIND_EXPR_BLOCK (update_body) = blk;\n-      if (TREE_CODE (fnbody) == STATEMENT_LIST)\n-\tBIND_EXPR_BODY (update_body) = fnbody;\n-      else\n-\t{\n-\t  tree tlist = NULL_TREE;\n-\t  append_to_statement_list_force (fnbody, &tlist);\n-\t  TREE_SIDE_EFFECTS (tlist) = TREE_SIDE_EFFECTS (fnbody);\n-\t  BIND_EXPR_BODY (update_body) = tlist;\n-\t}\n-      tree new_body_list = NULL_TREE;\n-      TREE_SIDE_EFFECTS (update_body) = true;\n-      append_to_statement_list (update_body, &new_body_list);\n-      TREE_SIDE_EFFECTS (new_body_list) = true;\n-      fnbody = new_body_list;\n-    }\n-\n   /* Create the coro frame type, as far as it can be known at this stage.\n      1. Types we already know.  */\n \n@@ -3792,35 +3843,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   /* 2. Types we need to define or look up.  */\n \n-  /* We need to know, and inspect, each suspend point in the function\n-     in several places.  It's convenient to place this map out of line\n-     since it's used from tree walk callbacks.  */\n-  suspend_points = new hash_map<tree, suspend_point_info>;\n-\n-  /* Initial and final suspend types are special in that the co_awaits for\n-     them are synthetic.  We need to find the type for each awaiter from\n-     the coroutine promise.  */\n-  tree initial_await = build_init_or_final_await (fn_start, false);\n-  if (initial_await == error_mark_node)\n-    {\n-      /* Suppress warnings about the missing return value.  */\n-      TREE_NO_WARNING (orig) = true;\n-      return false;\n-    }\n-  /* The type of the frame var for this is the type of its temp proxy.  */\n-  tree initial_suspend_type = TREE_TYPE (TREE_OPERAND (initial_await, 1));\n-\n-  tree final_await = build_init_or_final_await (fn_start, true);\n-  if (final_await == error_mark_node)\n-    {\n-      /* Suppress warnings about the missing return value.  */\n-      TREE_NO_WARNING (orig) = true;\n-      return false;\n-    }\n-\n-  /* The type of the frame var for this is the type of its temp proxy.  */\n-  tree final_suspend_type = TREE_TYPE (TREE_OPERAND (final_await, 1));\n-\n   tree fr_name = get_fn_local_identifier (orig, \"frame\");\n   tree coro_frame_type = xref_tag (record_type, fr_name, ts_current, false);\n   DECL_CONTEXT (TYPE_NAME (coro_frame_type)) = current_scope ();\n@@ -3833,20 +3855,27 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree actor = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, \"actor\");\n   tree destroy = act_des_fn (orig, act_des_fn_type, coro_frame_ptr, \"destroy\");\n \n+  /* Construct the wrapped function body; we will analyze this to determine\n+     the requirements for the coroutine frame.  */\n+\n+  tree resume_fn_field = NULL_TREE;\n+  tree fs_label = NULL_TREE;\n+  fnbody = coro_rewrite_function_body (fn_start, fnbody, orig, act_des_fn_ptr,\n+\t\t\t\t       resume_fn_field, fs_label);\n   /* Build our dummy coro frame layout.  */\n   coro_frame_type = begin_class_definition (coro_frame_type);\n \n   tree field_list = NULL_TREE;\n   tree resume_name\n-    = coro_make_frame_entry (&field_list, \"__resume\", act_des_fn_ptr, fn_start);\n-  tree destroy_name = coro_make_frame_entry (&field_list, \"__destroy\",\n-\t\t\t\t\t     act_des_fn_ptr, fn_start);\n+    = coro_make_frame_entry (&field_list, \"__resume\",\n+\t\t\t     act_des_fn_ptr, fn_start);\n+  tree destroy_name\n+    = coro_make_frame_entry (&field_list, \"__destroy\",\n+\t\t\t     act_des_fn_ptr, fn_start);\n   tree promise_name\n     = coro_make_frame_entry (&field_list, \"__p\", promise_type, fn_start);\n   tree fnf_name = coro_make_frame_entry (&field_list, \"__frame_needs_free\",\n \t\t\t\t\t boolean_type_node, fn_start);\n-  tree iarc_name = coro_make_frame_entry (&field_list, \"__i_a_r_c\",\n-\t\t\t\t\t boolean_type_node, fn_start);\n   tree resume_idx_name\n     = coro_make_frame_entry (&field_list, \"__resume_at\",\n \t\t\t     short_unsigned_type_node, fn_start);\n@@ -3928,11 +3957,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       cp_walk_tree (&fnbody, register_param_uses, &param_data, NULL);\n     }\n \n-  /* Initial suspend is mandated.  */\n-  tree init_susp_name = coro_make_frame_entry (&field_list, \"__aw_s.is\",\n-\t\t\t\t\t       initial_suspend_type, fn_start);\n-\n-  register_await_info (initial_await, initial_suspend_type, init_susp_name);\n+  /* We need to know, and inspect, each suspend point in the function\n+     in several places.  It's convenient to place this map out of line\n+     since it's used from tree walk callbacks.  */\n+  suspend_points = new hash_map<tree, suspend_point_info>;\n \n   /* Now insert the data for any body await points, at this time we also need\n      to promote any temporaries that are captured by reference (to regular\n@@ -3945,12 +3973,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   body_aw_points.to_replace = make_tree_vector ();\n   cp_walk_tree (&fnbody, await_statement_walker, &body_aw_points, NULL);\n \n-  /* Final suspend is mandated.  */\n-  tree fin_susp_name = coro_make_frame_entry (&field_list, \"__aw_s.fs\",\n-\t\t\t\t\t      final_suspend_type, fn_start);\n-\n-  register_await_info (final_await, final_suspend_type, fin_susp_name);\n-\n   /* 4. Now make space for local vars, this is conservative again, and we\n      would expect to delete unused entries later.  */\n   hash_map<tree, local_var_info> local_var_uses;\n@@ -4455,17 +4477,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n-  /* Initialize 'initial-await-resume-called' as per\n-     [dcl.fct.def.coroutine] / 5.3 */\n-  tree i_a_r_c_m\n-    = lookup_member (coro_frame_type, iarc_name, 1, 0, tf_warning_or_error);\n-  tree i_a_r_c = build_class_member_access_expr (deref_fp, i_a_r_c_m,\n-\t\t\t\t\t\t NULL_TREE, false,\n-\t\t\t\t\t\t tf_warning_or_error);\n-  r = build2 (INIT_EXPR, boolean_type_node, i_a_r_c, boolean_false_node);\n-  r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-  add_stmt (r);\n-\n   /* So .. call the actor ..  */\n   r = build_call_expr_loc (fn_start, actor, 1, coro_fp);\n   r = maybe_cleanup_point_expr_void (r);\n@@ -4535,133 +4546,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   BIND_EXPR_BODY (ramp_bind) = pop_stmt_list (ramp_body);\n   TREE_SIDE_EFFECTS (ramp_bind) = true;\n \n-  /* We know the \"real\" promise and have a frame layout with a slot for each\n-     suspend point, so we can build an actor function (which contains the\n-     functionality for both 'resume' and 'destroy').\n-\n-     wrap the function body in a try {} catch (...) {} block, if exceptions\n-     are enabled.  */\n-\n-  /* First make a new block for the body - that will be embedded in the\n-     re-written function.  */\n-  tree first = expr_first (fnbody);\n-  bool orig_fn_has_outer_bind = false;\n-  tree replace_blk = NULL_TREE;\n-  if (first && TREE_CODE (first) == BIND_EXPR)\n-    {\n-      orig_fn_has_outer_bind = true;\n-      tree block = BIND_EXPR_BLOCK (first);\n-      replace_blk = make_node (BLOCK);\n-      if (block) /* missing block is probably an error.  */\n-\t{\n-\t  gcc_assert (BLOCK_SUPERCONTEXT (block) == NULL_TREE);\n-\t  gcc_assert (BLOCK_CHAIN (block) == NULL_TREE);\n-\t  BLOCK_VARS (replace_blk) = BLOCK_VARS (block);\n-\t  BLOCK_SUBBLOCKS (replace_blk) = BLOCK_SUBBLOCKS (block);\n-\t  for (tree b = BLOCK_SUBBLOCKS (replace_blk); b; b = BLOCK_CHAIN (b))\n-\t    BLOCK_SUPERCONTEXT (b) = replace_blk;\n-\t}\n-      BIND_EXPR_BLOCK (first) = replace_blk;\n-    }\n-\n-  /* actor's version of the promise.  */\n-  tree actor_frame = build1_loc (fn_start, INDIRECT_REF, coro_frame_type,\n-\t\t\t\t DECL_ARGUMENTS (actor));\n-  tree ap_m = lookup_member (coro_frame_type, get_identifier (\"__p\"), 1, 0,\n-\t\t\t     tf_warning_or_error);\n-  tree ap = build_class_member_access_expr (actor_frame, ap_m, NULL_TREE,\n-\t\t\t\t\t    false, tf_warning_or_error);\n-\n-  /* Now we've built the promise etc, process fnbody for co_returns.\n-     We want the call to return_void () below and it has no params so\n-     we can create it once here.\n-     Calls to return_value () will have to be checked and created as\n-     required.  */\n-\n-  tree return_void\n-    = coro_build_promise_expression (current_function_decl, ap,\n-\t\t\t\t     coro_return_void_identifier,\n-\t\t\t\t     fn_start, NULL, /*musthave=*/false);\n-\n-  /* [stmt.return.coroutine] (2.2 : 3) if p.return_void() is a valid\n-     expression, flowing off the end of a coroutine is equivalent to\n-     co_return; otherwise UB.\n-     We just inject the call to p.return_void() here, and fall through to\n-     the final_suspend: label (eliding the goto).  If the function body has\n-     a co_return, then this statement will be unreachable and DCEd.  */\n-  if (return_void != NULL_TREE)\n-    {\n-      tree append = push_stmt_list ();\n-      add_stmt (fnbody);\n-      add_stmt (return_void);\n-      fnbody = pop_stmt_list(append);\n-    }\n-\n-  if (flag_exceptions)\n-    {\n-      tree ueh\n-\t= coro_build_promise_expression (current_function_decl, ap,\n-\t\t\t\t\t coro_unhandled_exception_identifier,\n-\t\t\t\t\t fn_start, NULL, /*musthave=*/true);\n-\n-      /* The try block is just the original function, there's no real\n-\t need to call any function to do this.  */\n-      fnbody = build_stmt (fn_start, TRY_BLOCK, fnbody, NULL_TREE);\n-      TRY_HANDLERS (fnbody) = push_stmt_list ();\n-      /* Mimic what the parser does for the catch.  */\n-      tree handler = begin_handler ();\n-      finish_handler_parms (NULL_TREE, handler); /* catch (...) */\n-\n-      /* Get the initial await resume called value.  */\n-      tree i_a_r_c = build_class_member_access_expr (actor_frame, i_a_r_c_m,\n-\t\t\t\t\t\t     NULL_TREE, false,\n-\t\t\t\t\t\t     tf_warning_or_error);\n-      tree not_iarc_if = begin_if_stmt ();\n-      tree not_iarc = build1_loc (fn_start, TRUTH_NOT_EXPR,\n-\t\t\t\t  boolean_type_node, i_a_r_c);\n-      finish_if_stmt_cond (not_iarc, not_iarc_if);\n-      /* If the initial await resume called value is false, rethrow...  */\n-      tree rethrow = build_throw (fn_start, NULL_TREE);\n-      TREE_NO_WARNING (rethrow) = true;\n-      finish_expr_stmt (rethrow);\n-      finish_then_clause (not_iarc_if);\n-      tree iarc_scope = IF_SCOPE (not_iarc_if);\n-      IF_SCOPE (not_iarc_if) = NULL;\n-      not_iarc_if = do_poplevel (iarc_scope);\n-      add_stmt (not_iarc_if);\n-      /* ... else call the promise unhandled exception method.  */\n-      ueh = maybe_cleanup_point_expr_void (ueh);\n-      add_stmt (ueh);\n-      finish_handler (handler);\n-      TRY_HANDLERS (fnbody) = pop_stmt_list (TRY_HANDLERS (fnbody));\n-      /* If the function starts with a BIND_EXPR, then we need to create\n-\t one here to contain the try-catch and to link up the scopes.  */\n-      if (orig_fn_has_outer_bind)\n-\t{\n-\t  fnbody = build3 (BIND_EXPR, void_type_node, NULL, fnbody, NULL);\n-\t  /* Make and connect the scope blocks.  */\n-\t  tree tcb_block = make_node (BLOCK);\n-\t  /* .. and connect it here.  */\n-\t  BLOCK_SUPERCONTEXT (replace_blk) = tcb_block;\n-\t  BLOCK_SUBBLOCKS (tcb_block) = replace_blk;\n-\t  BIND_EXPR_BLOCK (fnbody) = tcb_block;\n-\t  TREE_SIDE_EFFECTS (fnbody) = true;\n-\t}\n-    }\n-  else if (pedantic)\n-    {\n-      /* We still try to look for the promise method and warn if it's not\n-\t present.  */\n-      tree ueh_meth\n-\t= lookup_promise_method (orig, coro_unhandled_exception_identifier,\n-\t\t\t\t fn_start, /*musthave=*/false);\n-      if (!ueh_meth || ueh_meth == error_mark_node)\n-\twarning_at (fn_start, 0, \"no member named %qE in %qT\",\n-\t\t    coro_unhandled_exception_identifier,\n-\t\t    get_coroutine_promise_type (orig));\n-    }\n-  /* Else we don't check and don't care if the method is missing.  */\n-\n   /* Start to build the final functions.\n \n      We push_deferring_access_checks to avoid these routines being seen as\n@@ -4671,7 +4555,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   /* Build the actor...  */\n   build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig, param_uses,\n-\t\t  &local_var_uses, param_dtor_list, initial_await, final_await,\n+\t\t  &local_var_uses, param_dtor_list, fs_label, resume_fn_field,\n \t\t  body_aw_points.await_number, frame_size);\n \n   /* Destroyer ... */"}]}