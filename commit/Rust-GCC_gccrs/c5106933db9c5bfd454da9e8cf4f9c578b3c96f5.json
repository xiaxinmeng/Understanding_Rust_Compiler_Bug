{"sha": "c5106933db9c5bfd454da9e8cf4f9c578b3c96f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUxMDY5MzNkYjljNWJmZDQ1NGRhOWU4Y2Y0ZjljNTc4YjNjOTZmNQ==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-03-23T02:42:15Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-03-23T02:42:15Z"}, "message": "treetree.c (tree_code_if_start): Use fold_buildN.\n\n2005-03-22  James A. Morrison  <phython@gcc.gnu.org>\n\n        * treetree.c (tree_code_if_start): Use fold_buildN.\n        (tree_code_create_variable): Likewise.\n        (tree_code_generate_return): Likewise.\n        (tree_code_get_expression): Likewise.\n        (tree_code_add_parameter): Likewise.\n\nFrom-SVN: r96920", "tree": {"sha": "95dc8c8c0b4730e128e949eda250da82cab8f38d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95dc8c8c0b4730e128e949eda250da82cab8f38d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5/comments", "author": null, "committer": null, "parents": [{"sha": "52f9be1826f5223837fab5696816f74c1f2a2861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52f9be1826f5223837fab5696816f74c1f2a2861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52f9be1826f5223837fab5696816f74c1f2a2861"}], "stats": {"total": 46, "additions": 27, "deletions": 19}, "files": [{"sha": "ae07033fec251dbd9200cc80c4d2d981aea05643", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=c5106933db9c5bfd454da9e8cf4f9c578b3c96f5", "patch": "@@ -1,3 +1,11 @@\n+2005-03-22  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* treetree.c (tree_code_if_start): Use fold_buildN. \n+\t(tree_code_create_variable): Likewise.\n+\t(tree_code_generate_return): Likewise.\n+\t(tree_code_get_expression): Likewise.\n+\t(tree_code_add_parameter): Likewise.\n+\n 2005-03-22  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* treelang.h (struct parameter_part): Skip WHERE_TO_PUT_VAR_TREE"}, {"sha": "6f22298c151b11d897fbeb5f9b0d5b58dac7146f", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5106933db9c5bfd454da9e8cf4f9c578b3c96f5/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=c5106933db9c5bfd454da9e8cf4f9c578b3c96f5", "patch": "@@ -257,9 +257,9 @@ void\n tree_code_if_start (tree exp, location_t loc)\n {\n   tree cond_exp, cond;\n-  cond_exp = fold (build2 (NE_EXPR, boolean_type_node, exp,\n-\t\t\t   fold (build1 (CONVERT_EXPR, TREE_TYPE (exp),\n-\t\t\t\t\t integer_zero_node))));\n+  cond_exp = fold_build2 (NE_EXPR, boolean_type_node, exp,\n+\t\t\t  fold_build1 (CONVERT_EXPR, TREE_TYPE (exp),\n+\t\t\t\t       integer_zero_node));\n   SET_EXPR_LOCATION (cond_exp, loc);\n   cond = build3 (COND_EXPR, void_type_node, cond_exp, NULL_TREE,\n                  NULL_TREE);\n@@ -525,7 +525,7 @@ tree_code_create_variable (unsigned int storage_class,\n \n   /* 3a. Initialization.  */\n   if (init)\n-    DECL_INITIAL (var_decl) = fold (build1 (CONVERT_EXPR, var_type, init));\n+    DECL_INITIAL (var_decl) = fold_build1 (CONVERT_EXPR, var_type, init);\n   else\n     DECL_INITIAL (var_decl) = NULL_TREE;\n \n@@ -583,9 +583,9 @@ tree_code_generate_return (tree type, tree exp)\n \n   if (exp && TREE_TYPE (TREE_TYPE (current_function_decl)) != void_type_node)\n     {\n-      setret = fold (build2 (MODIFY_EXPR, type, \n-                             DECL_RESULT (current_function_decl),\n-                             fold (build1 (CONVERT_EXPR, type, exp))));\n+      setret = fold_build2 (MODIFY_EXPR, type, \n+                            DECL_RESULT (current_function_decl),\n+                            fold_build1 (CONVERT_EXPR, type, exp));\n       TREE_SIDE_EFFECTS (setret) = 1;\n       TREE_USED (setret) = 1;\n       setret = build1 (RETURN_EXPR, type, setret);\n@@ -661,9 +661,8 @@ tree_code_get_expression (unsigned int exp_type,\n     case EXP_ASSIGN:\n       gcc_assert (op1 && op2);\n       operator = MODIFY_EXPR;\n-      ret1 = fold (build2 (operator, void_type_node, op1,\n-                           fold (build1 (CONVERT_EXPR, TREE_TYPE (op1),\n-\t\t\t\t\t op2))));\n+      ret1 = fold_build2 (operator, void_type_node, op1,\n+                          fold_build1 (CONVERT_EXPR, TREE_TYPE (op1), op2));\n \n       break;\n \n@@ -682,9 +681,9 @@ tree_code_get_expression (unsigned int exp_type,\n     /* Expand a binary expression.  Ensure the operands are the right type.  */\n     binary_expression:\n       gcc_assert (op1 && op2);\n-      ret1  =  fold (build2 (operator, type,\n-                       fold (build1 (CONVERT_EXPR, type, op1)),\n-                       fold (build1 (CONVERT_EXPR, type, op2))));\n+      ret1  =  fold_build2 (operator, type,\n+\t\t\t    fold_build1 (CONVERT_EXPR, type, op1),\n+\t\t\t    fold_build1 (CONVERT_EXPR, type, op2));\n       break;\n \n       /* Reference to a variable.  This is dead easy, just return the\n@@ -697,17 +696,18 @@ tree_code_get_expression (unsigned int exp_type,\n       if (type == TREE_TYPE (op1))\n         ret1 = build1 (NOP_EXPR, type, op1);\n       else\n-        ret1 = fold (build1 (CONVERT_EXPR, type, op1));\n+        ret1 = fold_build1 (CONVERT_EXPR, type, op1);\n       break;\n \n     case EXP_FUNCTION_INVOCATION:\n       gcc_assert (op1);\n       {\n         tree fun_ptr;\n \tTREE_USED (op1) = 1;\n-        fun_ptr = fold (build1 (ADDR_EXPR,\n-                                build_pointer_type (TREE_TYPE (op1)), op1));\n-        ret1 = build3 (CALL_EXPR, type, fun_ptr, nreverse (op2), NULL_TREE);\n+        fun_ptr = fold_build1 (ADDR_EXPR,\n+\t\t\t       build_pointer_type (TREE_TYPE (op1)), op1);\n+        ret1 = fold_build3 (CALL_EXPR, type, fun_ptr, nreverse (op2),\n+\t\t\t    NULL_TREE);\n       }\n       break;\n \n@@ -738,8 +738,8 @@ tree_code_add_parameter (tree list, tree proto_exp, tree exp)\n {\n   tree new_exp;\n   new_exp = tree_cons (NULL_TREE,\n-                       fold (build1 (CONVERT_EXPR, TREE_TYPE (proto_exp),\n-\t\t\t\t     exp)), NULL_TREE);\n+                       fold_build1 (CONVERT_EXPR, TREE_TYPE (proto_exp),\n+\t\t\t\t    exp), NULL_TREE);\n   if (!list)\n     return new_exp;\n   return chainon (new_exp, list);"}]}