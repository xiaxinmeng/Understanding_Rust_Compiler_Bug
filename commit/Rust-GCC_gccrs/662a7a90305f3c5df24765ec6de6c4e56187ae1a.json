{"sha": "662a7a90305f3c5df24765ec6de6c4e56187ae1a", "node_id": "C_kwDOANBUbNoAKDY2MmE3YTkwMzA1ZjNjNWRmMjQ3NjVlYzZkZTZjNGU1NjE4N2FlMWE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-19T09:59:18Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T15:03:33Z"}, "message": "Refactor method call type checking\n\nWe used a visitor interface to handle type checking argument passing on\nmethod call expressions. This was completely unnessecary as all method\ncalls should _always_ be to TyTy::FnType's. The benifit here is that we\nneed to reuse this interface to handle method resolution type checking\nfor FnTrait calls as closure calls dont have an HIR::MethodExpr so we\nneed a more abstract interface so that we can specify the types directly\nwith relevant location info.", "tree": {"sha": "917b38da9e35857bd58f4fc3445b65c438f4e881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/917b38da9e35857bd58f4fc3445b65c438f4e881"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/662a7a90305f3c5df24765ec6de6c4e56187ae1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662a7a90305f3c5df24765ec6de6c4e56187ae1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/662a7a90305f3c5df24765ec6de6c4e56187ae1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662a7a90305f3c5df24765ec6de6c4e56187ae1a/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4cf085d9afeada0e6c79c29904ee597c51bd25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4cf085d9afeada0e6c79c29904ee597c51bd25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4cf085d9afeada0e6c79c29904ee597c51bd25"}], "stats": {"total": 180, "additions": 106, "deletions": 74}, "files": [{"sha": "aa044ddb9c80e3011cb35fe4c5e882ba04136818", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662a7a90305f3c5df24765ec6de6c4e56187ae1a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662a7a90305f3c5df24765ec6de6c4e56187ae1a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=662a7a90305f3c5df24765ec6de6c4e56187ae1a", "patch": "@@ -1162,7 +1162,8 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n   rust_debug (\"type-checking method_call: {%s}\", lookup->debug_str ().c_str ());\n \n   TyTy::BaseType *function_ret_tyty\n-    = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self, context);\n+    = TyTy::TypeCheckMethodCallExpr::go (static_cast<TyTy::FnType *> (lookup),\n+\t\t\t\t\t expr, adjusted_self, context);\n   if (function_ret_tyty == nullptr\n       || function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n     {"}, {"sha": "18a34be09bfc9be3c9b29e262d4e41316817a20d", "filename": "gcc/rust/typecheck/rust-tyty-call.cc", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662a7a90305f3c5df24765ec6de6c4e56187ae1a/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662a7a90305f3c5df24765ec6de6c4e56187ae1a/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc?ref=662a7a90305f3c5df24765ec6de6c4e56187ae1a", "patch": "@@ -216,29 +216,77 @@ TypeCheckCallExpr::visit (FnPtr &type)\n \n // method call checker\n \n-void\n-TypeCheckMethodCallExpr::visit (FnType &type)\n+TypeCheckMethodCallExpr::TypeCheckMethodCallExpr (\n+  Analysis::NodeMapping call_mappings, std::vector<Argument> &args,\n+  Location call_locus, Location receiver_locus, TyTy::BaseType *adjusted_self,\n+  Resolver::TypeCheckContext *context)\n+  : call_mappings (call_mappings), arguments (args), call_locus (call_locus),\n+    receiver_locus (receiver_locus), adjusted_self (adjusted_self),\n+    context (context), mappings (Analysis::Mappings::get ())\n+{}\n+\n+BaseType *\n+TypeCheckMethodCallExpr::go (FnType *ref, HIR::MethodCallExpr &call,\n+\t\t\t     TyTy::BaseType *adjusted_self,\n+\t\t\t     Resolver::TypeCheckContext *context)\n+{\n+  std::vector<Argument> args;\n+  for (auto &arg : call.get_arguments ())\n+    {\n+      BaseType *argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (arg.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (arg->get_locus (),\n+\t\t\t \"failed to resolve type for argument\");\n+\t  return new ErrorType (ref->get_ref ());\n+\t}\n+\n+      Argument a (arg->get_mappings (), argument_expr_tyty, arg->get_locus ());\n+      args.push_back (std::move (a));\n+    }\n+\n+  TypeCheckMethodCallExpr checker (call.get_mappings (), args,\n+\t\t\t\t   call.get_locus (),\n+\t\t\t\t   call.get_receiver ()->get_locus (),\n+\t\t\t\t   adjusted_self, context);\n+  return checker.check (*ref);\n+}\n+\n+BaseType *\n+TypeCheckMethodCallExpr::go (FnType *ref, Analysis::NodeMapping call_mappings,\n+\t\t\t     std::vector<Argument> &args, Location call_locus,\n+\t\t\t     Location receiver_locus,\n+\t\t\t     TyTy::BaseType *adjusted_self,\n+\t\t\t     Resolver::TypeCheckContext *context)\n+{\n+  TypeCheckMethodCallExpr checker (call_mappings, args, call_locus,\n+\t\t\t\t   receiver_locus, adjusted_self, context);\n+  return checker.check (*ref);\n+}\n+\n+BaseType *\n+TypeCheckMethodCallExpr::check (FnType &type)\n {\n   Resolver::TypeCheckBase::unify_site (\n-    call.get_mappings ().get_hirid (), TyWithLocation (type.get_self_type ()),\n-    TyWithLocation (adjusted_self, call.get_receiver ()->get_locus ()),\n-    call.get_locus ());\n+    call_mappings.get_hirid (), TyWithLocation (type.get_self_type ()),\n+    TyWithLocation (adjusted_self, receiver_locus), call_locus);\n \n   // +1 for the receiver self\n-  size_t num_args_to_call = call.num_params () + 1;\n+  size_t num_args_to_call = arguments.size () + 1;\n   if (num_args_to_call != type.num_params ())\n     {\n-      rust_error_at (call.get_locus (),\n+      rust_error_at (call_locus,\n \t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) num_args_to_call,\n \t\t     (unsigned long) type.num_params ());\n-      return;\n+      return new ErrorType (type.get_ref ());\n     }\n \n   size_t i = 1;\n-  for (auto &argument : call.get_arguments ())\n+  for (auto &argument : arguments)\n     {\n-      Location arg_locus = argument->get_locus ();\n+      Location arg_locus = argument.get_locus ();\n \n       auto fnparam = type.param_at (i);\n       HIR::Pattern *fn_param_pattern = fnparam.first;\n@@ -248,41 +296,31 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n \t    ? mappings->lookup_location (param_ty->get_ref ())\n \t    : fn_param_pattern->get_locus ();\n \n-      auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n-      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (\n-\t    argument->get_locus (),\n-\t    \"failed to resolve type for argument expr in CallExpr\");\n-\t  return;\n-\t}\n-\n-      HirId coercion_side_id = argument->get_mappings ().get_hirid ();\n+      auto argument_expr_tyty = argument.get_argument_type ();\n+      HirId coercion_side_id = argument.get_mappings ().get_hirid ();\n       auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n \tcoercion_side_id, TyWithLocation (param_ty, param_locus),\n-\tTyWithLocation (argument_expr_tyty, arg_locus), argument->get_locus ());\n+\tTyWithLocation (argument_expr_tyty, arg_locus), arg_locus);\n       if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"Type Resolution failure on parameter\");\n-\t  return;\n+\t  rust_error_at (arg_locus, \"Type Resolution failure on parameter\");\n+\t  return new ErrorType (type.get_ref ());\n \t}\n \n       i++;\n     }\n \n   if (i != num_args_to_call)\n     {\n-      rust_error_at (call.get_locus (),\n+      rust_error_at (call_locus,\n \t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n-      return;\n+\t\t     (unsigned long) i, (unsigned long) arguments.size ());\n+      return new ErrorType (type.get_ref ());\n     }\n \n   type.monomorphize ();\n \n-  resolved = type.get_return_type ()->monomorphized_clone ();\n+  return type.get_return_type ()->monomorphized_clone ();\n }\n \n } // namespace TyTy"}, {"sha": "eef567ac419b5a22aa0ce7d79210f1b71590eeb4", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 36, "deletions": 43, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662a7a90305f3c5df24765ec6de6c4e56187ae1a/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662a7a90305f3c5df24765ec6de6c4e56187ae1a/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=662a7a90305f3c5df24765ec6de6c4e56187ae1a", "patch": "@@ -84,58 +84,51 @@ class TypeCheckCallExpr : private TyVisitor\n   Analysis::Mappings *mappings;\n };\n \n-class TypeCheckMethodCallExpr : private TyVisitor\n+class Argument\n {\n public:\n-  // Resolve the Method parameters and return back the return type\n-  static BaseType *go (BaseType *ref, HIR::MethodCallExpr &call,\n-\t\t       TyTy::BaseType *adjusted_self,\n-\t\t       Resolver::TypeCheckContext *context)\n-  {\n-    TypeCheckMethodCallExpr checker (call, adjusted_self, context);\n-    ref->accept_vis (checker);\n-    return checker.resolved;\n-  }\n+  Argument (Analysis::NodeMapping mapping, BaseType *argument_type,\n+\t    Location locus)\n+    : mapping (mapping), argument_type (argument_type), locus (locus)\n+  {}\n \n-  void visit (InferType &) override { gcc_unreachable (); }\n-  void visit (TupleType &) override { gcc_unreachable (); }\n-  void visit (ArrayType &) override { gcc_unreachable (); }\n-  void visit (SliceType &) override { gcc_unreachable (); }\n-  void visit (BoolType &) override { gcc_unreachable (); }\n-  void visit (IntType &) override { gcc_unreachable (); }\n-  void visit (UintType &) override { gcc_unreachable (); }\n-  void visit (FloatType &) override { gcc_unreachable (); }\n-  void visit (USizeType &) override { gcc_unreachable (); }\n-  void visit (ISizeType &) override { gcc_unreachable (); }\n-  void visit (ErrorType &) override { gcc_unreachable (); }\n-  void visit (ADTType &) override { gcc_unreachable (); };\n-  void visit (CharType &) override { gcc_unreachable (); }\n-  void visit (ReferenceType &) override { gcc_unreachable (); }\n-  void visit (PointerType &) override { gcc_unreachable (); }\n-  void visit (ParamType &) override { gcc_unreachable (); }\n-  void visit (StrType &) override { gcc_unreachable (); }\n-  void visit (NeverType &) override { gcc_unreachable (); }\n-  void visit (PlaceholderType &) override { gcc_unreachable (); }\n-  void visit (ProjectionType &) override { gcc_unreachable (); }\n-  void visit (DynamicObjectType &) override { gcc_unreachable (); }\n+  Location get_locus () const { return locus; }\n \n-  // FIXME\n-  void visit (FnPtr &type) override { gcc_unreachable (); }\n+  BaseType *get_argument_type () { return argument_type; }\n \n-  // call fns\n-  void visit (FnType &type) override;\n-  void visit (ClosureType &type) override { gcc_unreachable (); }\n+  Analysis::NodeMapping get_mappings () const { return mapping; }\n \n private:\n-  TypeCheckMethodCallExpr (HIR::MethodCallExpr &c,\n+  Analysis::NodeMapping mapping;\n+  BaseType *argument_type;\n+  Location locus;\n+};\n+\n+class TypeCheckMethodCallExpr\n+{\n+public:\n+  static BaseType *go (FnType *ref, HIR::MethodCallExpr &call,\n+\t\t       TyTy::BaseType *adjusted_self,\n+\t\t       Resolver::TypeCheckContext *context);\n+\n+  static BaseType *go (FnType *ref, Analysis::NodeMapping call_mappings,\n+\t\t       std::vector<Argument> &args, Location call_locus,\n+\t\t       Location receiver_locus, TyTy::BaseType *adjusted_self,\n+\t\t       Resolver::TypeCheckContext *context);\n+\n+protected:\n+  BaseType *check (FnType &type);\n+\n+  TypeCheckMethodCallExpr (Analysis::NodeMapping call_mappings,\n+\t\t\t   std::vector<Argument> &args, Location call_locus,\n+\t\t\t   Location receiver_locus,\n \t\t\t   TyTy::BaseType *adjusted_self,\n-\t\t\t   Resolver::TypeCheckContext *context)\n-    : resolved (nullptr), call (c), adjusted_self (adjusted_self),\n-      context (context), mappings (Analysis::Mappings::get ())\n-  {}\n+\t\t\t   Resolver::TypeCheckContext *context);\n \n-  BaseType *resolved;\n-  HIR::MethodCallExpr &call;\n+  Analysis::NodeMapping call_mappings;\n+  std::vector<Argument> &arguments;\n+  Location call_locus;\n+  Location receiver_locus;\n   TyTy::BaseType *adjusted_self;\n   Resolver::TypeCheckContext *context;\n   Analysis::Mappings *mappings;"}]}