{"sha": "051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxZjhjYzZjNzFjZjI5YmRhMzllZmZlYjRiYzZiMGZmMmUzNmQ2NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-09-24T21:47:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-09-24T21:47:59Z"}, "message": "lto-symtab.c (lto_symtab_entry_def): Add guessed field.\n\n\n\t* lto-symtab.c (lto_symtab_entry_def): Add guessed field.\n\t(lto_symtab_resolve_symbols): Set it.\n\t(lto_symtab_merge_decls_1): Do not compute used_from_object_file;\n\tstore resolution field in cgraph/varpool.\n\t* cgraph.c (cgraph_same_body_alias, cgraph_add_thunk): Return node.\n\t(cgraph_get_node_or_alias, cgraph_get_node_or_alias): Constify.\n\t(cgraph_dump_node): Drop used_from_object_file.\n\t(cgraph_clone_node, cgraph_create_virtual_clone): Likewise.\n\t(cgraph_function_body_availability): Use decl_replaceable_p.\n\t(cgraph_make_node_local): Set resolution to LDPR_PREVAILING_DEF_IRONLY.\n\t(cgraph_can_remove_if_no_direct_calls_and_refs): Use\n\tcgraph_used_from_object_file_p.\n\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Use\n\tcgraph_used_from_object_file_p.\n\t(resolution_used_from_other_file_p): New functoin.\n\t(cgraph_used_from_object_file_p): New predicate.\n\t* cgraph.h: Include plugin-api.h\n\t(struct cgraph_local_info): Remove used_from_object_file.\n\t(struct cgraph_node): Add resolution field.\n\t(struct varpool_node): Likewise; remove used_from_object_file;\n\treove const_value_known.\n\t(cgraph_get_node, cgraph_get_node_or_alias, cgraph_node,\n\tcgraph_same_body_alias, cgraph_add_thunk): Update prototypes.\n\t(resolution_used_from_other_file_p, cgraph_used_from_object_file_p,\n\tvarpool_used_from_object_file_p): Declare.\n\t(varpool_get_node, varpool_extra_name_alias): Update prototype.\n\t* tree.h (DECL_REPLACEABLE_P): Remove.\n\t(decl_replaceable_p, decl_binds_to_current_def_p): Declare.\n\t* final.c (rest_of_clean_state): Use decl_binds_to_current_def_p.\n\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n\tinput_overwrite_node, input_node, input_varpool_node): Stream\n\tresolution.\n\t* expr.c (expand_expr_real_1): Use const_value_known_p\n\t* ipa.c (ipa_discover_readonly_nonaddressable_var): Do not set\n\tconst_value_known.\n\t(cgraph_externally_visible_p): Use cgraph_used_from_object_file_p.\n\t(function_and_variable_visibility): Set resolution for local vars\n\tand functions.\n\tuse varpool_used_from_object_file_p.\n\t* varasm.c (resolution_to_local_definition_p, resolution_local_p): New\n\tstatic functions.\n\t(default_binds_local_p_1): Use resolutoin info.\n\t(decl_binds_to_current_def_p, decl_replaceable_p): New functions.\n\t* varpool.c (varpool_get_node): Constify.\n\t(const_value_known_p): Do not use vnode->const_value_known;\n\tuse decl_replaceable_p.\n\t(varpool_finalize_decl): Do not set const_value_known.\n\t(cgraph_variable_initializer_availability): Use decl_replaceable_p\n\t(varpool_extra_name_alias): Return new node.\n\t(varpool_used_from_object_file_p): New function.\n\n\t* decl.c (finish_function): Use decl_replaceable_p\n\t* method.c (make_alias_for_thunk): Update call of cgraph_same_body_alias.\n\n\t* lto.c (lto_promote_cross_file_statics): Use const_value_known_p.\n\nFrom-SVN: r164610", "tree": {"sha": "83ac2cd6e9618944ed45f4905c495d5b42344809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83ac2cd6e9618944ed45f4905c495d5b42344809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/comments", "author": null, "committer": null, "parents": [{"sha": "5c255b57b25e4847b8e556c4b6450e6f559329ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c255b57b25e4847b8e556c4b6450e6f559329ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c255b57b25e4847b8e556c4b6450e6f559329ff"}], "stats": {"total": 464, "additions": 337, "deletions": 127}, "files": [{"sha": "2bd82c19dfac3312d1895ccc23f9a9b67fb68f4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -1,3 +1,56 @@\n+2010-09-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_symtab_entry_def): Add guessed field.\n+\t(lto_symtab_resolve_symbols): Set it.\n+\t(lto_symtab_merge_decls_1): Do not compute used_from_object_file;\n+\tstore resolution field in cgraph/varpool.\n+\t* cgraph.c (cgraph_same_body_alias, cgraph_add_thunk): Return node.\n+\t(cgraph_get_node_or_alias, cgraph_get_node_or_alias): Constify.\n+\t(cgraph_dump_node): Drop used_from_object_file.\n+\t(cgraph_clone_node, cgraph_create_virtual_clone): Likewise.\n+\t(cgraph_function_body_availability): Use decl_replaceable_p.\n+\t(cgraph_make_node_local): Set resolution to LDPR_PREVAILING_DEF_IRONLY.\n+\t(cgraph_can_remove_if_no_direct_calls_and_refs): Use\n+\tcgraph_used_from_object_file_p.\n+\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Use\n+\tcgraph_used_from_object_file_p.\n+\t(resolution_used_from_other_file_p): New functoin.\n+\t(cgraph_used_from_object_file_p): New predicate.\n+\t* cgraph.h: Include plugin-api.h\n+\t(struct cgraph_local_info): Remove used_from_object_file.\n+\t(struct cgraph_node): Add resolution field.\n+\t(struct varpool_node): Likewise; remove used_from_object_file;\n+\treove const_value_known.\n+\t(cgraph_get_node, cgraph_get_node_or_alias, cgraph_node,\n+\tcgraph_same_body_alias, cgraph_add_thunk): Update prototypes.\n+\t(resolution_used_from_other_file_p, cgraph_used_from_object_file_p,\n+\tvarpool_used_from_object_file_p): Declare.\n+\t(varpool_get_node, varpool_extra_name_alias): Update prototype.\n+\t* tree.h (DECL_REPLACEABLE_P): Remove.\n+\t(decl_replaceable_p, decl_binds_to_current_def_p): Declare.\n+\t* final.c (rest_of_clean_state): Use decl_binds_to_current_def_p.\n+\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n+\tinput_overwrite_node, input_node, input_varpool_node): Stream\n+\tresolution.\n+\t* expr.c (expand_expr_real_1): Use const_value_known_p\n+\t* ipa.c (ipa_discover_readonly_nonaddressable_var): Do not set\n+\tconst_value_known.\n+\t(cgraph_externally_visible_p): Use cgraph_used_from_object_file_p.\n+\t(function_and_variable_visibility): Set resolution for local vars\n+\tand functions.\n+\tuse varpool_used_from_object_file_p.\n+\t* varasm.c (resolution_to_local_definition_p, resolution_local_p): New\n+\tstatic functions.\n+\t(default_binds_local_p_1): Use resolutoin info.\n+\t(decl_binds_to_current_def_p, decl_replaceable_p): New functions.\n+\t* varpool.c (varpool_get_node): Constify.\n+\t(const_value_known_p): Do not use vnode->const_value_known;\n+\tuse decl_replaceable_p.\n+\t(varpool_finalize_decl): Do not set const_value_known.\n+\t(cgraph_variable_initializer_availability): Use decl_replaceable_p\n+\t(varpool_extra_name_alias): Return new node.\n+\t(varpool_used_from_object_file_p): New function.\n+\n 2010-09-24  Richard Henderson  <rth@redhat.com>\n \n \t* config/ia64/ia64.c (ia64_dwarf_handle_frame_unspec): New."}, {"sha": "383ddba8f5485dd6ca8fa7f0e4aeb0d422e904f0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -915,7 +915,7 @@ IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h $(BITMAP_H) $(TREE_H)\n IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)\n CGRAPH_H = cgraph.h $(VEC_H) $(TREE_H) $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n-\tcif-code.def ipa-ref.h ipa-ref-inline.h\n+\tcif-code.def ipa-ref.h ipa-ref-inline.h $(LINKER_PLUGIN_API_H)\n DF_H = df.h $(BITMAP_H) $(REGSET_H) sbitmap.h $(BASIC_BLOCK_H) \\\n \talloc-pool.h $(TIMEVAR_H)\n RESOURCE_H = resource.h hard-reg-set.h $(DF_H)"}, {"sha": "7293b6dee03ae6f882859ca9c19a6bf1c7dc120a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -555,24 +555,29 @@ cgraph_same_body_alias_1 (tree alias, tree decl)\n   return alias_node;\n }\n \n-/* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n+/* Attempt to mark ALIAS as an alias to DECL.  Return alias node if successful\n+   and NULL otherwise. \n    Same body aliases are output whenever the body of DECL is output,\n    and cgraph_node (ALIAS) transparently returns cgraph_node (DECL).   */\n \n-bool\n+struct cgraph_node *\n cgraph_same_body_alias (tree alias, tree decl)\n {\n #ifndef ASM_OUTPUT_DEF\n   /* If aliases aren't supported by the assembler, fail.  */\n-  return false;\n+  return NULL;\n #endif\n \n   /*gcc_assert (!assembler_name_hash);*/\n \n-  return cgraph_same_body_alias_1 (alias, decl) != NULL;\n+  return cgraph_same_body_alias_1 (alias, decl);\n }\n \n-void\n+/* Add thunk alias into callgraph.  The alias declaration is ALIAS and it\n+   alises DECL with an adjustments made into the first parameter.\n+   See comments in thunk_adjust for detail on the parameters.  */\n+\n+struct cgraph_node *\n cgraph_add_thunk (tree alias, tree decl, bool this_adjusting,\n \t\t  HOST_WIDE_INT fixed_offset, HOST_WIDE_INT virtual_value,\n \t\t  tree virtual_offset,\n@@ -599,13 +604,14 @@ cgraph_add_thunk (tree alias, tree decl, bool this_adjusting,\n   node->thunk.virtual_offset_p = virtual_offset != NULL;\n   node->thunk.alias = real_alias;\n   node->thunk.thunk_p = true;\n+  return node;\n }\n \n /* Returns the cgraph node assigned to DECL or NULL if no cgraph node\n    is assigned.  */\n \n struct cgraph_node *\n-cgraph_get_node_or_alias (tree decl)\n+cgraph_get_node_or_alias (const_tree decl)\n {\n   struct cgraph_node key, *node = NULL, **slot;\n \n@@ -614,7 +620,7 @@ cgraph_get_node_or_alias (tree decl)\n   if (!cgraph_hash)\n     return NULL;\n \n-  key.decl = decl;\n+  key.decl = CONST_CAST2 (tree, const_tree, decl);\n \n   slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key,\n \t\t\t\t\t\t NO_INSERT);\n@@ -628,7 +634,7 @@ cgraph_get_node_or_alias (tree decl)\n    is assigned.  */\n \n struct cgraph_node *\n-cgraph_get_node (tree decl)\n+cgraph_get_node (const_tree decl)\n {\n   struct cgraph_node key, *node = NULL, **slot;\n \n@@ -637,7 +643,7 @@ cgraph_get_node (tree decl)\n   if (!cgraph_hash)\n     return NULL;\n \n-  key.decl = decl;\n+  key.decl = CONST_CAST2 (tree, const_tree, decl);\n \n   slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key,\n \t\t\t\t\t\t NO_INSERT);\n@@ -1849,8 +1855,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" local\");\n   if (node->local.externally_visible)\n     fprintf (f, \" externally_visible\");\n-  if (node->local.used_from_object_file)\n-    fprintf (f, \" used_from_object_file\");\n   if (node->local.finalized)\n     fprintf (f, \" finalized\");\n   if (node->local.disregard_inline_limits)\n@@ -2124,7 +2128,6 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   new_node->analyzed = n->analyzed;\n   new_node->local = n->local;\n   new_node->local.externally_visible = false;\n-  new_node->local.used_from_object_file = false;\n   new_node->local.local = true;\n   new_node->local.vtable_method = false;\n   new_node->global = n->global;\n@@ -2318,7 +2321,6 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   else\n     new_node->clone.combined_args_to_skip = args_to_skip;\n   new_node->local.externally_visible = 0;\n-  new_node->local.used_from_object_file = 0;\n   new_node->local.local = 1;\n   new_node->lowered = true;\n   new_node->reachable = true;\n@@ -2369,7 +2371,7 @@ cgraph_function_body_availability (struct cgraph_node *node)\n      AVAIL_AVAILABLE here?  That would be good reason to preserve this\n      bit.  */\n \n-  else if (DECL_REPLACEABLE_P (node->decl) && !DECL_EXTERNAL (node->decl))\n+  else if (decl_replaceable_p (node->decl) && !DECL_EXTERNAL (node->decl))\n     avail = AVAIL_OVERWRITABLE;\n   else avail = AVAIL_AVAILABLE;\n \n@@ -2556,6 +2558,7 @@ cgraph_make_node_local (struct cgraph_node *node)\n \n       node->local.externally_visible = false;\n       node->local.local = true;\n+      node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n       gcc_assert (cgraph_function_body_availability (node) == AVAIL_LOCAL);\n     }\n }\n@@ -2720,7 +2723,8 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n     return false;\n   /* Only COMDAT functions can be removed if externally visible.  */\n   if (node->local.externally_visible\n-      && (!DECL_COMDAT (node->decl) || node->local.used_from_object_file))\n+      && (!DECL_COMDAT (node->decl)\n+\t  || cgraph_used_from_object_file_p (node)))\n     return false;\n   /* Constructors and destructors are executed by the runtime, however\n      we can get rid of all pure constructors and destructors.  */\n@@ -2753,12 +2757,43 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n bool\n cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node)\n {\n-  if (node->local.used_from_object_file)\n+  if (cgraph_used_from_object_file_p (node))\n     return false;\n   if (!in_lto_p && !flag_whole_program)\n     return cgraph_only_called_directly_p (node);\n   else\n     return cgraph_can_remove_if_no_direct_calls_p (node);\n }\n \n+/* Return true when RESOLUTION indicate that linker will use\n+   the symbol from non-LTo object files.  */\n+\n+bool\n+resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n+{\n+  return (resolution == LDPR_PREVAILING_DEF\n+          || resolution == LDPR_PREEMPTED_REG\n+          || resolution == LDPR_RESOLVED_EXEC\n+          || resolution == LDPR_RESOLVED_DYN);\n+}\n+\n+/* Return true when NODE is known to be used from other (non-LTO) object file.\n+   Known only when doing LTO via linker plugin.  */\n+\n+bool\n+cgraph_used_from_object_file_p (struct cgraph_node *node)\n+{\n+  struct cgraph_node *alias;\n+\n+  if (!TREE_PUBLIC (node->decl))\n+    return false;\n+  if (resolution_used_from_other_file_p (node->resolution))\n+    return true;\n+  for (alias = node->same_body; alias; alias = alias->next)\n+    if (TREE_PUBLIC (alias->decl)\n+\t&& resolution_used_from_other_file_p (alias->resolution))\n+      return true;\n+  return false;\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "330c88396361bca49ba52dc3054f8518ac92f65a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CGRAPH_H\n #define GCC_CGRAPH_H\n \n+#include \"plugin-api.h\"\n #include \"vec.h\"\n #include \"tree.h\"\n #include \"basic-block.h\"\n@@ -101,9 +102,6 @@ struct GTY(()) cgraph_local_info {\n \n   /* Set when function is visible by other units.  */\n   unsigned externally_visible : 1;\n-\n-  /* Set when resolver determines that function is visible by other units.  */\n-  unsigned used_from_object_file : 1;\n   \n   /* Set once it has been finalized so we consider it to be output.  */\n   unsigned finalized : 1;\n@@ -259,6 +257,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* unique id for profiling. pid is not suitable because of different\n      number of cfg nodes with -fprofile-generate and -fprofile-use */\n   int pid;\n+  enum ld_plugin_symbol_resolution resolution;\n \n   /* Set when function must be output for some reason.  The primary\n      use of this flag is to mark functions needed to be output for\n@@ -476,6 +475,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   PTR GTY ((skip)) aux;\n   /* Ordering of all cgraph nodes.  */\n   int order;\n+  enum ld_plugin_symbol_resolution resolution;\n \n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n@@ -492,8 +492,6 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   unsigned output : 1;\n   /* Set when function is visible by other units.  */\n   unsigned externally_visible : 1;\n-  /* Set when resolver determines that variable is visible by other units.  */\n-  unsigned used_from_object_file : 1;\n   /* Set for aliases once they got through assemble_alias.  Also set for\n      extra name aliases in varpool_extra_name_alias.  */\n   unsigned alias : 1;\n@@ -503,8 +501,6 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n      During WPA output it is used to mark nodes that are present in\n      multiple partitions.  */\n   unsigned in_other_partition : 1;\n-  /* True when variable is constant and its value is known.  */\n-  unsigned int const_value_known : 1;\n };\n \n /* Every top level asm statement is put into a cgraph_asm_node.  */\n@@ -561,11 +557,12 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tgimple, gcov_type, int, int);\n struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple, int,\n \t\t\t\t\t\t gcov_type, int, int);\n-struct cgraph_node * cgraph_get_node (tree);\n-struct cgraph_node * cgraph_get_node_or_alias (tree);\n-struct cgraph_node *cgraph_node (tree);\n-bool cgraph_same_body_alias (tree, tree);\n-void cgraph_add_thunk (tree, tree, bool, HOST_WIDE_INT, HOST_WIDE_INT, tree, tree);\n+struct cgraph_node * cgraph_get_node (const_tree);\n+struct cgraph_node * cgraph_get_node_or_alias (const_tree);\n+struct cgraph_node * cgraph_node (tree);\n+struct cgraph_node * cgraph_same_body_alias (tree, tree);\n+struct cgraph_node * cgraph_add_thunk (tree, tree, bool, HOST_WIDE_INT,\n+\t\t\t\t       HOST_WIDE_INT, tree, tree);\n void cgraph_remove_same_body_alias (struct cgraph_node *);\n struct cgraph_node *cgraph_node_for_asm (tree);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n@@ -614,6 +611,9 @@ bool cgraph_will_be_removed_from_program_if_no_direct_calls\n   (struct cgraph_node *node);\n bool cgraph_can_remove_if_no_direct_calls_and_refs_p\n   (struct cgraph_node *node);\n+bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution);\n+bool cgraph_used_from_object_file_p (struct cgraph_node *node);\n+bool varpool_used_from_object_file_p (struct varpool_node *node);\n \n /* In cgraphunit.c  */\n extern FILE *cgraph_dump_file;\n@@ -718,14 +718,14 @@ void cgraph_make_node_local (struct cgraph_node *);\n bool cgraph_node_can_be_local_p (struct cgraph_node *);\n \n \n-struct varpool_node * varpool_get_node (tree decl);\n+struct varpool_node * varpool_get_node (const_tree decl);\n void varpool_remove_node (struct varpool_node *node);\n bool varpool_assemble_pending_decls (void);\n bool varpool_assemble_decl (struct varpool_node *node);\n bool varpool_analyze_pending_decls (void);\n void varpool_remove_unreferenced_decls (void);\n void varpool_empty_needed_queue (void);\n-bool varpool_extra_name_alias (tree, tree);\n+struct varpool_node * varpool_extra_name_alias (tree, tree);\n const char * varpool_node_name (struct varpool_node *node);\n void varpool_reset_queue (void);\n bool const_value_known_p (tree);"}, {"sha": "4b6eb74fe8db227bbb97d25e27288ff5f0f2fa2a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -1,3 +1,8 @@\n+2010-09-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl.c (finish_function): Use decl_replaceable_p\n+\t* method.c (make_alias_for_thunk): Update call of cgraph_same_body_alias.\n+\n 2010-09-24  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (compute_array_index_type): Remember type dependence of"}, {"sha": "07eddb551df2c51208b92e8ff43d24a801738b4b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -12674,7 +12674,7 @@ finish_function (int flags)\n   if (!processing_template_decl\n       && !cp_function_chain->can_throw\n       && !flag_non_call_exceptions\n-      && !DECL_REPLACEABLE_P (fndecl))\n+      && !decl_replaceable_p (fndecl))\n     TREE_NOTHROW (fndecl) = 1;\n \n   /* This must come after expand_function_end because cleanups might"}, {"sha": "1083e16dc55277703e8b84550027b97a5c1a88b0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -259,9 +259,9 @@ make_alias_for_thunk (tree function)\n \n   if (!flag_syntax_only)\n     {\n-      bool ok = cgraph_same_body_alias (alias, function);\n+      struct cgraph_node *aliasn = cgraph_same_body_alias (alias, function);\n       DECL_ASSEMBLER_NAME (function);\n-      gcc_assert (ok);\n+      gcc_assert (aliasn != NULL);\n     }\n \n   return alias;"}, {"sha": "d63ee55e8aa9c14538c67e59374a6a30bc94e91b", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -8830,7 +8830,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n \t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n \t\t && TREE_CODE (DECL_INITIAL (array)) != ERROR_MARK\n-\t\t && targetm.binds_local_p (array))\n+\t\t && const_value_known_p (array))\n \t  {\n \t    if (TREE_CODE (index) == INTEGER_CST)\n \t      {"}, {"sha": "4fe1031458cc8f9230a0e07a8547ec65f5180709", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -4441,7 +4441,10 @@ rest_of_clean_state (void)\n \n   delete_tree_ssa ();\n \n-  if (targetm.binds_local_p (current_function_decl))\n+  /* We can reduce stack alignment on call site only when we are sure that\n+     the function body just produced will be actually used in the final\n+     executable.  */\n+  if (decl_binds_to_current_def_p (current_function_decl))\n     {\n       unsigned int pref = crtl->preferred_stack_boundary;\n       if (crtl->stack_alignment_needed > crtl->preferred_stack_boundary)"}, {"sha": "9670a9c7941576f1731cec801e33a64eb04f9121", "filename": "gcc/ipa.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -570,7 +570,6 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t    if (dump_file)\n \t      fprintf (dump_file, \" %s (read-only)\", varpool_node_name (vnode));\n \t    TREE_READONLY (vnode->decl) = 1;\n-\t    vnode->const_value_known |= const_value_known_p (vnode->decl);\n \t  }\n       }\n   if (dump_file)\n@@ -622,7 +621,7 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n \t      return true;\n \t}\n     }\n-  if (node->local.used_from_object_file)\n+  if (cgraph_used_from_object_file_p (node))\n     return true;\n   if (DECL_PRESERVE_P (node->decl))\n     return true;\n@@ -739,6 +738,7 @@ function_and_variable_visibility (bool whole_program)\n           struct cgraph_node *alias;\n \t  gcc_assert (whole_program || in_lto_p || !TREE_PUBLIC (node->decl));\n \t  cgraph_make_decl_local (node->decl);\n+\t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t  for (alias = node->same_body; alias; alias = alias->next)\n \t    cgraph_make_decl_local (alias->decl);\n \t  if (node->same_comdat_group)\n@@ -777,9 +777,6 @@ function_and_variable_visibility (bool whole_program)\n \t      || ! (ADDR_SPACE_GENERIC_P\n \t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->decl))))))\n \tDECL_COMMON (vnode->decl) = 0;\n-     /* Even extern variables might have initializers known.\n-\tSee, for example testsuite/g++.dg/opt/static3.C  */\n-     vnode->const_value_known |= const_value_known_p (vnode->decl);\n     }\n   for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     {\n@@ -802,7 +799,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t      In this case we do not sed used_from_object_file.  */\n \t\t   || !vnode->finalized))\n \t      || DECL_PRESERVE_P (vnode->decl)\n-              || vnode->used_from_object_file\n+              || varpool_used_from_object_file_p (vnode)\n \t      || pointer_set_contains (aliased_vnodes, vnode)\n \t      || lookup_attribute (\"externally_visible\",\n \t\t\t\t   DECL_ATTRIBUTES (vnode->decl))))\n@@ -813,8 +810,8 @@ function_and_variable_visibility (bool whole_program)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n \t  cgraph_make_decl_local (vnode->decl);\n+\t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n-     vnode->const_value_known |= const_value_known_p (vnode->decl);\n      gcc_assert (TREE_STATIC (vnode->decl));\n     }\n   pointer_set_destroy (aliased_nodes);"}, {"sha": "b82fa735deda8e8f98e184f272fb579af2b3109b", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -519,6 +519,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->finalized_by_frontend, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   lto_output_bitpack (&bp);\n+  lto_output_uleb128_stream (ob->main_stream, node->resolution);\n \n   if (node->same_body)\n     {\n@@ -550,6 +551,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t      lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n \t\t\t\t\talias->thunk.alias);\n \t    }\n+\t  lto_output_uleb128_stream (ob->main_stream, alias->resolution);\n \t  alias = alias->previous;\n \t}\n       while (alias);\n@@ -578,7 +580,6 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp_pack_value (&bp, node->force_output, 1);\n   bp_pack_value (&bp, node->finalized, 1);\n   bp_pack_value (&bp, node->alias, 1);\n-  bp_pack_value (&bp, node->const_value_known, 1);\n   gcc_assert (!node->alias || !node->extra_name);\n   gcc_assert (node->finalized || !node->analyzed);\n   gcc_assert (node->needed);\n@@ -611,12 +612,16 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   else\n     ref = LCC_NOT_FOUND;\n   lto_output_sleb128_stream (ob->main_stream, ref);\n+  lto_output_uleb128_stream (ob->main_stream, node->resolution);\n \n   if (count)\n     {\n       lto_output_uleb128_stream (ob->main_stream, count);\n       for (alias = node->extra_name; alias; alias = alias->next)\n-\tlto_output_var_decl_index (ob->decl_state, ob->main_stream, alias->decl);\n+\t{\n+\t  lto_output_var_decl_index (ob->decl_state, ob->main_stream, alias->decl);\n+\t  lto_output_uleb128_stream (ob->main_stream, alias->resolution);\n+\t}\n     }\n }\n \n@@ -926,7 +931,8 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t      unsigned int self_time,\n \t\t      unsigned int time_inlining_benefit,\n \t\t      unsigned int self_size,\n-\t\t      unsigned int size_inlining_benefit)\n+\t\t      unsigned int size_inlining_benefit,\n+\t\t      enum ld_plugin_symbol_resolution resolution)\n {\n   node->aux = (void *) tag;\n   node->local.inline_summary.estimated_self_stack_size = stack_size;\n@@ -972,6 +978,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->alias = bp_unpack_value (bp, 1);\n   node->finalized_by_frontend = bp_unpack_value (bp, 1);\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n+  node->resolution = resolution;\n }\n \n /* Output the part of the cgraph in SET.  */\n@@ -1019,6 +1026,7 @@ input_node (struct lto_file_decl_data *file_data,\n   int size_inlining_benefit = 0;\n   unsigned long same_body_count = 0;\n   int clone_ref;\n+  enum ld_plugin_symbol_resolution resolution;\n \n   clone_ref = lto_input_sleb128 (ib);\n \n@@ -1057,9 +1065,10 @@ input_node (struct lto_file_decl_data *file_data,\n \t\t    \"node %d\", node->uid);\n \n   bp = lto_input_bitpack (ib);\n+  resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n   input_overwrite_node (file_data, node, tag, &bp, stack_size, self_time,\n   \t\t\ttime_inlining_benefit, self_size,\n-\t\t\tsize_inlining_benefit);\n+\t\t\tsize_inlining_benefit, resolution);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n@@ -1072,6 +1081,7 @@ input_node (struct lto_file_decl_data *file_data,\n     {\n       tree alias_decl;\n       int type;\n+      struct cgraph_node *alias;\n       decl_index = lto_input_uleb128 (ib);\n       alias_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n       type = lto_input_uleb128 (ib);\n@@ -1080,7 +1090,7 @@ input_node (struct lto_file_decl_data *file_data,\n \t  tree real_alias;\n \t  decl_index = lto_input_uleb128 (ib);\n \t  real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-\t  cgraph_same_body_alias (alias_decl, real_alias);\n+\t  alias = cgraph_same_body_alias (alias_decl, real_alias);\n \t}\n       else\n         {\n@@ -1089,11 +1099,12 @@ input_node (struct lto_file_decl_data *file_data,\n \t  tree real_alias;\n \t  decl_index = lto_input_uleb128 (ib);\n \t  real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-\t  cgraph_add_thunk (alias_decl, fn_decl, type & 2, fixed_offset,\n-\t  \t\t    virtual_value,\n-\t\t\t    (type & 4) ? size_int (virtual_value) : NULL_TREE,\n-\t\t\t    real_alias);\n+\t  alias = cgraph_add_thunk (alias_decl, fn_decl, type & 2, fixed_offset,\n+\t\t\t\t    virtual_value,\n+\t\t\t\t    (type & 4) ? size_int (virtual_value) : NULL_TREE,\n+\t\t\t\t    real_alias);\n \t}\n+       alias->resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n     }\n   return node;\n }\n@@ -1123,7 +1134,6 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->force_output = bp_unpack_value (&bp, 1);\n   node->finalized = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n-  node->const_value_known = bp_unpack_value (&bp, 1);\n   node->analyzed = node->finalized; \n   node->used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->in_other_partition = bp_unpack_value (&bp, 1);\n@@ -1138,14 +1148,17 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   ref = lto_input_sleb128 (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->same_comdat_group = (struct varpool_node *) (intptr_t) ref;\n+  node->resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n   if (aliases_p)\n     {\n       count = lto_input_uleb128 (ib);\n       for (; count > 0; count --)\n \t{\n \t  tree decl = lto_file_decl_data_get_var_decl (file_data,\n \t\t\t\t\t\t       lto_input_uleb128 (ib));\n-\t  varpool_extra_name_alias (decl, var_decl);\n+\t  struct varpool_node *alias;\n+\t  alias = varpool_extra_name_alias (decl, var_decl);\n+\t  alias->resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n \t}\n     }\n   return node;"}, {"sha": "1d90ab113f60992af02ad145fb14bd588046b763", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -51,6 +51,8 @@ struct GTY(()) lto_symtab_entry_def\n   /* LTO file-data and symbol resolution for this decl.  */\n   struct lto_file_decl_data * GTY((skip (\"\"))) file_data;\n   enum ld_plugin_symbol_resolution resolution;\n+  /* True when resolution was guessed and not read from the file.  */\n+  bool guessed;\n   /* Pointer to the next entry with the same key.  Before decl merging\n      this links all symbols from the different TUs.  After decl merging\n      this links merged but incompatible decls, thus all prevailing ones\n@@ -513,12 +515,14 @@ lto_symtab_resolve_symbols (void **slot)\n       if (!lto_symtab_resolve_can_prevail_p (e))\n \t{\n \t  e->resolution = LDPR_RESOLVED_IR;\n+          e->guessed = true;\n \t  continue;\n \t}\n \n       /* Set a default resolution - the final prevailing one will get\n          adjusted later.  */\n       e->resolution = LDPR_PREEMPTED_IR;\n+      e->guessed = true;\n       if (!lto_symtab_resolve_replaceable_p (e))\n \t{\n \t  if (prevailing)\n@@ -572,6 +576,7 @@ lto_symtab_resolve_symbols (void **slot)\n     resolution file.  These variables still need manual\n     externally_visible attribute.  */\n     prevailing->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+    prevailing->guessed = true;\n }\n \n /* Merge all decls in the symbol table chain to the prevailing decl and\n@@ -740,27 +745,21 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n       && TREE_CODE (prevailing->decl) != VAR_DECL)\n     prevailing->next = NULL;\n \n-  /* Set used_from_object_file flags.  */\n-  if (prevailing->resolution == LDPR_PREVAILING_DEF\n-      || prevailing->resolution == LDPR_PREEMPTED_REG\n-      || prevailing->resolution == LDPR_RESOLVED_EXEC\n-      || prevailing->resolution == LDPR_RESOLVED_DYN)\n-    {\n-      if (TREE_CODE (prevailing->decl) == FUNCTION_DECL)\n-\t{\n-\t  if (prevailing->node->same_body_alias)\n-\t    prevailing->node->same_body->local.used_from_object_file = true;\n-\t  else\n-\t    prevailing->node->local.used_from_object_file = true;\n-\t}\n-      else\n-\t{\n-\t  if (prevailing->vnode->alias)\n-\t    prevailing->vnode->extra_name->used_from_object_file = true;\n-\t  else\n-\t    prevailing->vnode->used_from_object_file = true;\n-\t}\n-    }\n+  /* Store resolution decision into the callgraph.  \n+     In LTRANS don't overwrite information we stored into callgraph at\n+     WPA stage.\n+\n+     Do not bother to store guessed decisions.  Generic code knows how\n+     to handle UNKNOWN relocation well.\n+\n+     The problem with storing guessed decision is whether to use\n+     PREVAILING_DEF or PREVAILING_DEF_IRONLY.  First one would disable\n+     some whole program optimizations, while ther second would imply\n+     to many whole program assumptions.  */\n+  if (prevailing->node && !flag_ltrans && !prevailing->guessed)\n+    prevailing->node->resolution = prevailing->resolution;\n+  else if (prevailing->vnode && !flag_ltrans && !prevailing->guessed)\n+    prevailing->vnode->resolution = prevailing->resolution;\n   return 1;\n }\n "}, {"sha": "ec853a9b9e6657ef87707067e5ce04c75b71cbfa", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -1,3 +1,7 @@\n+2010-09-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_promote_cross_file_statics): Use const_value_known_p.\n+\n 2010-09-20  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimize/45605"}, {"sha": "f52c66e6a475d1bd0d5008e9f361364ca933af23", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -1048,7 +1048,8 @@ lto_promote_cross_file_statics (void)\n \t\t\t   && !v->externally_visible && v->analyzed)\n \t\t    {\n \t\t      if (promote_var (v)\n-\t\t\t  && DECL_INITIAL (v->decl) && v->const_value_known\n+\t\t\t  && DECL_INITIAL (v->decl)\n+\t\t\t  && const_value_known_p (v->decl)\n \t\t\t  && !pointer_set_insert (inserted, vnode))\n \t\t\tVEC_safe_push (varpool_node_ptr, heap,\n \t\t\t\t       promoted_initializers, v);"}, {"sha": "03950d6305904eb3948efc9d7839db0e80acdea4", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -3002,31 +3002,6 @@ struct GTY(()) tree_parm_decl {\n    multiple translation units should be merged.  */\n #define DECL_ONE_ONLY(NODE) (DECL_COMDAT_GROUP (NODE) != NULL_TREE)\n \n-/* A replaceable function is one which may be replaced at link-time\n-   with an entirely different definition, provided that the\n-   replacement has the same type.  For example, functions declared\n-   with __attribute__((weak)) on most systems are replaceable.\n-\n-   COMDAT functions are not replaceable, since all definitions of the\n-   function must be equivalent.  It is important that COMDAT functions\n-   not be treated as replaceable so that use of C++ template\n-   instantiations is not penalized.\n-\n-   In other respects, the condition is usually equivalent to whether\n-   the function binds to the current module (shared library or executable).\n-   However, weak functions can always be overridden by earlier TUs\n-   in the same module, even if they bind locally to that module.\n-\n-   For example, DECL_REPLACEABLE is used to determine whether or not a\n-   function (including a template instantiation) which is not\n-   explicitly declared \"inline\" can be inlined.  If the function is\n-   DECL_REPLACEABLE then it is not safe to do the inlining, since the\n-   implementation chosen at link-time may be different.  However, a\n-   function that is not DECL_REPLACEABLE can be inlined, since all\n-   versions of the function will be functionally identical.  */\n-#define DECL_REPLACEABLE_P(NODE) \\\n-  (!DECL_COMDAT (NODE) && (DECL_WEAK (NODE) || !targetm.binds_local_p (NODE)))\n-\n /* The name of the object as the assembler will see it (but before any\n    translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n    as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n@@ -5299,6 +5274,8 @@ extern void process_pending_assemble_externals (void);\n extern void finish_aliases_1 (void);\n extern void finish_aliases_2 (void);\n extern void remove_unreachable_alias_pairs (void);\n+extern bool decl_replaceable_p (tree);\n+extern bool decl_binds_to_current_def_p (tree);\n \n /* In stmt.c */\n extern void expand_computed_goto (tree);"}, {"sha": "b02462bdec4a391ce2d55df0ecae750f128e70cb", "filename": "gcc/varasm.c", "status": "modified", "additions": 123, "deletions": 7, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -6381,6 +6381,30 @@ default_use_anchors_for_symbol_p (const_rtx symbol)\n   return true;\n }\n \n+/* Return true when RESOLUTION indicate that symbol will be bound to the\n+   definition provided by current .o file.  */\n+\n+static bool\n+resolution_to_local_definition_p (enum ld_plugin_symbol_resolution resolution)\n+{\n+  return (resolution == LDPR_PREVAILING_DEF\n+\t  || resolution == LDPR_PREVAILING_DEF_IRONLY);\n+}\n+\n+/* Return true when RESOLUTION indicate that symbol will be bound locally\n+   within current executable or DSO.  */\n+\n+static bool\n+resolution_local_p (enum ld_plugin_symbol_resolution resolution)\n+{\n+  return (resolution == LDPR_PREVAILING_DEF\n+\t  || resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t  || resolution == LDPR_PREEMPTED_REG\n+\t  || resolution == LDPR_PREEMPTED_IR\n+\t  || resolution == LDPR_RESOLVED_IR\n+\t  || resolution == LDPR_RESOLVED_EXEC);\n+}\n+\n /* Assume ELF-ish defaults, since that's pretty much the most liberal\n    wrt cross-module name binding.  */\n \n@@ -6394,41 +6418,72 @@ bool\n default_binds_local_p_1 (const_tree exp, int shlib)\n {\n   bool local_p;\n+  bool resolved_locally = false;\n+  bool resolved_to_local_def = false;\n+\n+  /* With resolution file in hands, take look into resolutions.\n+     We can't just return true for resolved_localy symbols,\n+     because dynamic linking might overwrite symbols\n+     in shared libraries.  */\n+  if (TREE_CODE (exp) == VAR_DECL && TREE_PUBLIC (exp)\n+      && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n+    {\n+      struct varpool_node *vnode = varpool_get_node (exp);\n+      if (vnode && resolution_local_p (vnode->resolution))\n+\tresolved_locally = true;\n+      if (vnode\n+\t  && resolution_to_local_definition_p (vnode->resolution))\n+\tresolved_to_local_def = true;\n+    }\n+  else if (TREE_CODE (exp) == FUNCTION_DECL && TREE_PUBLIC (exp))\n+    {\n+      struct cgraph_node *node = cgraph_get_node_or_alias (exp);\n+      if (node\n+\t  && resolution_local_p (node->resolution))\n+\tresolved_locally = true;\n+      if (node\n+\t  && resolution_to_local_definition_p (node->resolution))\n+\tresolved_to_local_def = true;\n+    }\n \n   /* A non-decl is an entry in the constant pool.  */\n   if (!DECL_P (exp))\n     local_p = true;\n   /* Weakrefs may not bind locally, even though the weakref itself is\n-     always static and therefore local.  */\n+     always static and therefore local.\n+     FIXME: We can resolve this more curefuly by looking at the weakref\n+     alias.  */\n   else if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (exp)))\n     local_p = false;\n   /* Static variables are always local.  */\n   else if (! TREE_PUBLIC (exp))\n     local_p = true;\n   /* A variable is local if the user has said explicitly that it will\n      be.  */\n-  else if (DECL_VISIBILITY_SPECIFIED (exp)\n+  else if ((DECL_VISIBILITY_SPECIFIED (exp)\n+\t    || resolved_to_local_def)\n \t   && DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)\n     local_p = true;\n   /* Variables defined outside this object might not be local.  */\n-  else if (DECL_EXTERNAL (exp))\n+  else if (DECL_EXTERNAL (exp) && !resolved_locally)\n     local_p = false;\n   /* If defined in this object and visibility is not default, must be\n      local.  */\n   else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)\n     local_p = true;\n   /* Default visibility weak data can be overridden by a strong symbol\n      in another module and so are not local.  */\n-  else if (DECL_WEAK (exp))\n+  else if (DECL_WEAK (exp)\n+\t   && !resolved_locally)\n     local_p = false;\n   /* If PIC, then assume that any global name can be overridden by\n-     symbols resolved from other modules, unless we are compiling with\n-     -fwhole-program, which assumes that names are local.  */\n+     symbols resolved from other modules.  */\n   else if (shlib)\n-    local_p = flag_whole_program;\n+    local_p = false;\n   /* Uninitialized COMMON variable may be unified with symbols\n      resolved from other modules.  */\n   else if (DECL_COMMON (exp)\n+\t   && !resolved_locally\n \t   && (DECL_INITIAL (exp) == NULL\n \t       || DECL_INITIAL (exp) == error_mark_node))\n     local_p = false;\n@@ -6440,6 +6495,67 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n   return local_p;\n }\n \n+/* Return true when references to DECL must bind to current definition in\n+   final executable.\n+\n+   The condition is usually equivalent to whether the function binds to the\n+   current module (shared library or executable), that is to binds_local_p.\n+   We use this fact to avoid need for another target hook and implement\n+   the logic using binds_local_p and just special cases where\n+   decl_binds_to_current_def_p is stronger than binds local_p.  In particular\n+   the weak definitions (that can be overwritten at linktime by other\n+   definition from different object file) and when resolution info is available\n+   we simply use the knowledge passed to us by linker plugin.  */\n+bool\n+decl_binds_to_current_def_p (tree decl)\n+{\n+  gcc_assert (DECL_P (decl));\n+  if (!TREE_PUBLIC (decl))\n+    return true;\n+  if (!targetm.binds_local_p (decl))\n+    return false;\n+  /* When resolution is available, just use it.  */\n+  if (TREE_CODE (decl) == VAR_DECL && TREE_PUBLIC (decl)\n+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+    {\n+      struct varpool_node *vnode = varpool_get_node (decl);\n+      if (vnode\n+\t  && vnode->resolution != LDPR_UNKNOWN)\n+\treturn resolution_to_local_definition_p (vnode->resolution);\n+    }\n+  else if (TREE_CODE (decl) == FUNCTION_DECL && TREE_PUBLIC (decl))\n+    {\n+      struct cgraph_node *node = cgraph_get_node_or_alias (decl);\n+      if (node\n+\t  && node->resolution != LDPR_UNKNOWN)\n+\treturn resolution_to_local_definition_p (node->resolution);\n+    }\n+  /* Otherwise we have to assume the worst for DECL_WEAK (hidden weaks\n+     binds localy but still can be overwritten).\n+     This rely on fact that binds_local_p behave as decl_replaceable_p\n+     for all other declaration types.  */\n+  return !DECL_WEAK (decl);\n+}\n+\n+/* A replaceable function or variable is one which may be replaced\n+   at link-time with an entirely different definition, provided that the\n+   replacement has the same type.  For example, functions declared\n+   with __attribute__((weak)) on most systems are replaceable.\n+\n+   COMDAT functions are not replaceable, since all definitions of the\n+   function must be equivalent.  It is important that COMDAT functions\n+   not be treated as replaceable so that use of C++ template\n+   instantiations is not penalized.  */\n+\n+bool\n+decl_replaceable_p (tree decl)\n+{\n+  gcc_assert (DECL_P (decl));\n+  if (!TREE_PUBLIC (decl) || DECL_COMDAT (decl))\n+    return false;\n+  return !decl_binds_to_current_def_p (decl);\n+}\n+\n /* Default function to output code that will globalize a label.  A\n    target must define GLOBAL_ASM_OP or provide its own function to\n    globalize a label.  */"}, {"sha": "ff3631b3478361c2da7edd2bb092d0f70725f0cb", "filename": "gcc/varpool.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=051f8cc6c71cf29bda39effeb4bc6b0ff2e36d65", "patch": "@@ -107,7 +107,7 @@ eq_varpool_node (const void *p1, const void *p2)\n \n /* Return varpool node assigned to DECL without creating new one.  */\n struct varpool_node *\n-varpool_get_node (tree decl)\n+varpool_get_node (const_tree decl)\n {\n   struct varpool_node key, **slot;\n \n@@ -116,7 +116,7 @@ varpool_get_node (tree decl)\n \n   if (!varpool_hash)\n     return NULL;\n-  key.decl = decl;\n+  key.decl = CONST_CAST2 (tree, const_tree, decl);\n   slot = (struct varpool_node **)\n     htab_find_slot (varpool_hash, &key, NO_INSERT);\n   if (!slot)\n@@ -365,8 +365,6 @@ decide_is_variable_needed (struct varpool_node *node, tree decl)\n bool\n const_value_known_p (tree decl)\n {\n-  struct varpool_node *vnode;\n-\n   if (TREE_CODE (decl) != VAR_DECL\n       &&TREE_CODE (decl) != CONST_DECL)\n     return false;\n@@ -386,21 +384,12 @@ const_value_known_p (tree decl)\n \n   gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n \n-  /* In WHOPR mode we can put variable into one partition\n-     and make it external in the other partition.  In this\n-     case we still know the value, but it can't be determined\n-     from DECL flags.  For this reason we keep const_value_known\n-     flag in varpool nodes.  */\n-  if ((vnode = varpool_get_node (decl))\n-      && vnode->const_value_known)\n-    return true;\n-\n   /* Variables declared 'const' without an initializer\n      have zero as the initializer if they may not be\n      overridden at link or run time.  */\n   if (!DECL_INITIAL (decl)\n       && (DECL_EXTERNAL (decl)\n-\t  || DECL_REPLACEABLE_P (decl)))\n+\t  || decl_replaceable_p (decl)))\n     return false;\n \n   /* Variables declared `const' with an initializer are considered\n@@ -444,7 +433,6 @@ varpool_finalize_decl (tree decl)\n      there.  */\n   else if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n     varpool_mark_needed_node (node);\n-  node->const_value_known |= const_value_known_p (node->decl);\n   if (cgraph_global_info_ready)\n     varpool_assemble_pending_decls ();\n }\n@@ -462,7 +450,7 @@ cgraph_variable_initializer_availability (struct varpool_node *node)\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n      care of at least two notable extensions - the COMDAT variables\n      used to share template instantiations in C++.  */\n-  if (!(*targetm.binds_local_p) (node->decl) && !DECL_COMDAT (node->decl))\n+  if (!decl_replaceable_p (node->decl))\n     return AVAIL_OVERWRITABLE;\n   return AVAIL_AVAILABLE;\n }\n@@ -674,7 +662,7 @@ add_new_static_var (tree type)\n /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n    Extra name aliases are output whenever DECL is output.  */\n \n-bool\n+struct varpool_node *\n varpool_extra_name_alias (tree alias, tree decl)\n {\n   struct varpool_node key, *alias_node, *decl_node, **slot;\n@@ -695,7 +683,7 @@ varpool_extra_name_alias (tree alias, tree decl)\n \n   /* If the varpool_node has been already created, fail.  */\n   if (*slot)\n-    return false;\n+    return NULL;\n \n   alias_node = ggc_alloc_cleared_varpool_node ();\n   alias_node->decl = alias;\n@@ -707,7 +695,26 @@ varpool_extra_name_alias (tree alias, tree decl)\n     decl_node->extra_name->prev = alias_node;\n   decl_node->extra_name = alias_node;\n   *slot = alias_node;\n-  return true;\n+  return alias_node;\n+}\n+\n+/* Return true when NODE is known to be used from other (non-LTO) object file.\n+   Known only when doing LTO via linker plugin.  */\n+\n+bool\n+varpool_used_from_object_file_p (struct varpool_node *node)\n+{\n+  struct varpool_node *alias;\n+\n+  if (!TREE_PUBLIC (node->decl))\n+    return false;\n+  if (resolution_used_from_other_file_p (node->resolution))\n+    return true;\n+  for (alias = node->extra_name; alias; alias = alias->next)\n+    if (TREE_PUBLIC (alias->decl)\n+\t&& resolution_used_from_other_file_p (alias->resolution))\n+      return true;\n+  return false;\n }\n \n #include \"gt-varpool.h\""}]}