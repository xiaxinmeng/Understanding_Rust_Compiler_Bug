{"sha": "5da4f54878a344fd7712ebdfd8e2b351b12992a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhNGY1NDg3OGEzNDRmZDc3MTJlYmRmZDhlMmIzNTFiMTI5OTJhMQ==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2002-07-16T16:07:13Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2002-07-16T16:07:13Z"}, "message": "explow.c (convert_memory_address): Remove special handling when POINTERS_EXTEND_UNSIGNED < 0.\n\n\t* gcc/explow.c (convert_memory_address): Remove special handling\n\twhen POINTERS_EXTEND_UNSIGNED < 0.\n\t* gcc/config/ia64.md (movsi_symbolic): New instruction for ILP32\n\tmode.\n\t(movedi_symbolic): Fix typo.\n\t(load_fptr): Remove mode restriction so it works for SI and DI.\n\t(load_fptr_internal1): Ditto.\n\t(load_gprel): Ditto.\n\t(load_symptr_internal1): Ditto.\n\t(call_pic): Ditto.\n\t* gcc/config/ia64.c (call_operand): Modify mode check.\n\t(ia64_expand_load_address): Handle DI and SI addresses and symbols.\n\t(ia64_expand_move): Ditto.\n\t(ia64_assemble_integer): Handle SImode function pointers.\n\t(ia64_expand_fetch_and_op): Handle SImode mem addresses.\n\t(ia64_expand_op_and_fetch): Ditto.\n\t(ia64_expand_compare_and_swap): Ditto.\n\t(ia64_expand_lock_test_and_set): Ditto.\n\t(ia64_expand_lock_release): Ditto.\n\nFrom-SVN: r55488", "tree": {"sha": "2179a5c81855008c66bb0dfa9ca2d9b2f05490ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2179a5c81855008c66bb0dfa9ca2d9b2f05490ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5da4f54878a344fd7712ebdfd8e2b351b12992a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da4f54878a344fd7712ebdfd8e2b351b12992a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da4f54878a344fd7712ebdfd8e2b351b12992a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da4f54878a344fd7712ebdfd8e2b351b12992a1/comments", "author": null, "committer": null, "parents": [{"sha": "1575c31ee110a9e863f005b69be55903e6016106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1575c31ee110a9e863f005b69be55903e6016106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1575c31ee110a9e863f005b69be55903e6016106"}], "stats": {"total": 147, "additions": 104, "deletions": 43}, "files": [{"sha": "e619a217ad29dfea7a945760b702f6dd276a82ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5da4f54878a344fd7712ebdfd8e2b351b12992a1", "patch": "@@ -1,3 +1,24 @@\n+2002-07-16  Steve Ellcey  <sje@cup.hp.com>\n+\t* gcc/explow.c (convert_memory_address): Remove special handling\n+\twhen POINTERS_EXTEND_UNSIGNED < 0.\n+\t* gcc/config/ia64.md (movsi_symbolic): New instruction for ILP32\n+\tmode.\n+\t(movedi_symbolic): Fix typo.\n+\t(load_fptr): Remove mode restriction so it works for SI and DI.\n+\t(load_fptr_internal1): Ditto.\n+\t(load_gprel): Ditto.\n+\t(load_symptr_internal1): Ditto.\n+\t(call_pic): Ditto.\n+\t* gcc/config/ia64.c (call_operand): Modify mode check.\n+\t(ia64_expand_load_address): Handle DI and SI addresses and symbols.\n+\t(ia64_expand_move): Ditto.\n+\t(ia64_assemble_integer): Handle SImode function pointers.\n+\t(ia64_expand_fetch_and_op): Handle SImode mem addresses.\n+\t(ia64_expand_op_and_fetch): Ditto.\n+\t(ia64_expand_compare_and_swap): Ditto.\n+\t(ia64_expand_lock_test_and_set): Ditto.\n+\t(ia64_expand_lock_release): Ditto.\n+\n 2002-07-16  Jeroen Dobbelaere <jeroen.dobbelaere@acunia.com>\n \n \t* arm.c (emit_sfm): Don't set RTX_FRAME_RELATED_P on DWARF."}, {"sha": "326c4d5b8e28d7a22328b432e7fafd560dadae46", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5da4f54878a344fd7712ebdfd8e2b351b12992a1", "patch": "@@ -250,7 +250,7 @@ call_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (mode != GET_MODE (op))\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n     return 0;\n \n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG\n@@ -992,7 +992,10 @@ ia64_expand_load_address (dest, src, scratch)\n   /* The destination could be a MEM during initial rtl generation,\n      which isn't a valid destination for the PIC load address patterns.  */\n   if (! register_operand (dest, DImode))\n-    temp = gen_reg_rtx (DImode);\n+    if (! scratch || ! register_operand (scratch, DImode))\n+      temp = gen_reg_rtx (DImode);\n+    else\n+      temp = scratch;\n   else\n     temp = dest;\n \n@@ -1003,7 +1006,8 @@ ia64_expand_load_address (dest, src, scratch)\n     emit_insn (gen_load_gprel64 (temp, src));\n   else if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_FLAG (src))\n     emit_insn (gen_load_fptr (temp, src));\n-  else if (sdata_symbolic_operand (src, DImode))\n+  else if ((GET_MODE (src) == Pmode || GET_MODE (src) == ptr_mode)\n+           && sdata_symbolic_operand (src, VOIDmode))\n     emit_insn (gen_load_gprel (temp, src));\n   else if (GET_CODE (src) == CONST\n \t   && GET_CODE (XEXP (src, 0)) == PLUS\n@@ -1038,7 +1042,11 @@ ia64_expand_load_address (dest, src, scratch)\n     }\n \n   if (temp != dest)\n-    emit_move_insn (dest, temp);\n+    {\n+      if (GET_MODE (dest) != GET_MODE (temp))\n+\ttemp = convert_to_mode (GET_MODE (dest), temp, 0);\n+      emit_move_insn (dest, temp);\n+    }\n }\n \n static GTY(()) rtx gen_tls_tga;\n@@ -1073,7 +1081,7 @@ ia64_expand_move (op0, op1)\n   if (!reload_in_progress && !reload_completed && !ia64_move_ok (op0, op1))\n     op1 = force_reg (mode, op1);\n \n-  if (mode == Pmode)\n+  if (mode == Pmode || mode == ptr_mode)\n     {\n       enum tls_model tls_kind;\n       if ((tls_kind = tls_symbolic_operand (op1, Pmode)))\n@@ -1184,7 +1192,9 @@ ia64_expand_move (op0, op1)\n \t      abort ();\n \t    }\n \t}\n-      else if (!TARGET_NO_PIC && symbolic_operand (op1, DImode))\n+      else if (!TARGET_NO_PIC &&\n+\t       (symbolic_operand (op1, Pmode) ||\n+\t\tsymbolic_operand (op1, ptr_mode)))\n \t{\n \t  /* Before optimization starts, delay committing to any particular\n \t     type of PIC address load.  If this function gets deferred, we\n@@ -1208,7 +1218,10 @@ ia64_expand_move (op0, op1)\n \t\t    && (SYMBOL_REF_FLAG (op1)\n \t\t\t|| CONSTANT_POOL_ADDRESS_P (op1)\n \t\t\t|| STRING_POOL_ADDRESS_P (op1))))\n-\t    emit_insn (gen_movdi_symbolic (op0, op1));\n+\t    if (GET_MODE (op1) == DImode)\n+\t      emit_insn (gen_movdi_symbolic (op0, op1));\n+\t    else\n+\t      emit_insn (gen_movsi_symbolic (op0, op1));\n \t  else\n \t    ia64_expand_load_address (op0, op1, NULL_RTX);\n \t  return NULL_RTX;\n@@ -2857,12 +2870,16 @@ ia64_assemble_integer (x, size, aligned_p)\n      unsigned int size;\n      int aligned_p;\n {\n-  if (size == UNITS_PER_WORD && aligned_p\n+  if (size == (TARGET_ILP32 ? 4 : 8)\n+      && aligned_p\n       && !(TARGET_NO_PIC || TARGET_AUTO_PIC)\n       && GET_CODE (x) == SYMBOL_REF\n       && SYMBOL_REF_FLAG (x))\n     {\n-      fputs (\"\\tdata8\\t@fptr(\", asm_out_file);\n+      if (TARGET_ILP32)\n+\tfputs (\"\\tdata4\\t@fptr(\", asm_out_file);\n+      else\n+\tfputs (\"\\tdata8\\t@fptr(\", asm_out_file);\n       output_addr_const (asm_out_file, x);\n       fputs (\")\\n\", asm_out_file);\n       return true;\n@@ -7631,6 +7648,10 @@ ia64_expand_fetch_and_op (binoptab, mode, arglist, target)\n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n   mem = expand_expr (arg0, NULL_RTX, Pmode, 0);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  if (GET_MODE(mem) != Pmode)\n+    mem = convert_memory_address (Pmode, mem);\n+#endif\n   value = expand_expr (arg1, NULL_RTX, mode, 0);\n \n   mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));\n@@ -7708,6 +7729,11 @@ ia64_expand_op_and_fetch (binoptab, mode, arglist, target)\n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n   mem = expand_expr (arg0, NULL_RTX, Pmode, 0);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  if (GET_MODE(mem) != Pmode)\n+    mem = convert_memory_address (Pmode, mem);\n+#endif\n+\n   value = expand_expr (arg1, NULL_RTX, mode, 0);\n \n   mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));\n@@ -7771,11 +7797,11 @@ ia64_expand_compare_and_swap (mode, boolp, arglist, target)\n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n   arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);\n+  mem = expand_expr (arg0, NULL_RTX, ptr_mode, 0);\n   old = expand_expr (arg1, NULL_RTX, mode, 0);\n   new = expand_expr (arg2, NULL_RTX, mode, 0);\n \n-  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));\n+  mem = gen_rtx_MEM (mode, force_reg (ptr_mode, mem));\n   MEM_VOLATILE_P (mem) = 1;\n \n   if (! register_operand (old, mode))\n@@ -7820,10 +7846,10 @@ ia64_expand_lock_test_and_set (mode, arglist, target)\n \n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);\n+  mem = expand_expr (arg0, NULL_RTX, ptr_mode, 0);\n   new = expand_expr (arg1, NULL_RTX, mode, 0);\n \n-  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));\n+  mem = gen_rtx_MEM (mode, force_reg (ptr_mode, mem));\n   MEM_VOLATILE_P (mem) = 1;\n   if (! register_operand (new, mode))\n     new = copy_to_mode_reg (mode, new);\n@@ -7854,9 +7880,9 @@ ia64_expand_lock_release (mode, arglist, target)\n   rtx mem;\n \n   arg0 = TREE_VALUE (arglist);\n-  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);\n+  mem = expand_expr (arg0, NULL_RTX, ptr_mode, 0);\n \n-  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));\n+  mem = gen_rtx_MEM (mode, force_reg (ptr_mode, mem));\n   MEM_VOLATILE_P (mem) = 1;\n \n   emit_move_insn (mem, const0_rtx);"}, {"sha": "75a36b3a1a01c43b8551b7e9072b956deb7e1abf", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=5da4f54878a344fd7712ebdfd8e2b351b12992a1", "patch": "@@ -1,5 +1,5 @@\n ;; IA-64 Machine description template\n-;; Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+;; Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n ;; Contributed by James E. Wilson <wilson@cygnus.com> and\n ;;\t\t  David Mosberger <davidm@hpl.hp.com>.\n \n@@ -340,6 +340,29 @@\n   operands[1] = op1;\n })\n \n+;; This is used during early compilation to delay the decision on\n+;; how to refer to a variable as long as possible.  This is especially\n+;; important between initial rtl generation and optimization for\n+;; deferred functions, since we may acquire additional information\n+;; on the variables used in the meantime.\n+\n+(define_insn_and_split \"movsi_symbolic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"symbolic_operand\" \"s\"))\n+   (clobber (match_scratch:DI 2 \"=r\"))\n+   (use (reg:DI 1))]\n+  \"\"\n+  \"* abort ();\"\n+  \"!no_new_pseudos || reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx scratch = operands[2];\n+  if (!reload_completed)\n+    scratch = gen_reg_rtx (Pmode);\n+  ia64_expand_load_address (operands[0], operands[1], scratch); \n+  DONE;\n+})\n+\n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"destination_operand\" \"=r,r,r,r, m, r,*f,*f, r,*d\")\n \t(match_operand:SI 1 \"move_operand\"        \"rO,J,i,m,rO,*f,rO,*f,*d,rK\"))]\n@@ -387,7 +410,7 @@\n {\n   rtx scratch = operands[2];\n   if (!reload_completed)\n-    gen_reg_rtx (Pmode);\n+    scratch = gen_reg_rtx (Pmode);\n   ia64_expand_load_address (operands[0], operands[1], scratch); \n   DONE;\n })\n@@ -440,7 +463,7 @@\n \n (define_expand \"load_fptr\"\n   [(set (match_dup 2)\n-\t(plus:DI (reg:DI 1) (match_operand:DI 1 \"function_operand\" \"\")))\n+\t(plus:DI (reg:DI 1) (match_operand 1 \"function_operand\" \"\")))\n    (set (match_operand:DI 0 \"register_operand\" \"\") (match_dup 3))]\n   \"\"\n {\n@@ -451,14 +474,14 @@\n \n (define_insn \"*load_fptr_internal1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (reg:DI 1) (match_operand:DI 1 \"function_operand\" \"s\")))]\n+\t(plus:DI (reg:DI 1) (match_operand 1 \"function_operand\" \"s\")))]\n   \"\"\n   \"addl %0 = @ltoff(@fptr(%1)), gp\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n (define_insn \"load_gprel\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (reg:DI 1) (match_operand:DI 1 \"sdata_symbolic_operand\" \"s\")))]\n+\t(plus:DI (reg:DI 1) (match_operand 1 \"sdata_symbolic_operand\" \"s\")))]\n   \"\"\n   \"addl %0 = @gprel(%1), gp\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n@@ -494,7 +517,7 @@\n \n (define_insn \"*load_symptr_internal1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (reg:DI 1) (match_operand:DI 1 \"got_symbolic_operand\" \"s\")))]\n+\t(plus:DI (reg:DI 1) (match_operand 1 \"got_symbolic_operand\" \"s\")))]\n   \"\"\n   \"addl %0 = @ltoff(%1), gp\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n@@ -4749,7 +4772,7 @@\n   [(set_attr \"itanium_class\" \"br,scall\")])\n \n (define_insn \"call_pic\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"b,i\"))\n+  [(call (mem (match_operand 0 \"call_operand\" \"b,i\"))\n \t (match_operand 1 \"\" \"\"))\n    (use (unspec [(reg:DI 1)] UNSPEC_PIC_CALL))\n    (clobber (match_operand:DI 2 \"register_operand\" \"=b,b\"))]"}, {"sha": "13a7b82be5be2a84c76125987d61d65ebe49c5b3", "filename": "gcc/explow.c", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da4f54878a344fd7712ebdfd8e2b351b12992a1/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=5da4f54878a344fd7712ebdfd8e2b351b12992a1", "patch": "@@ -363,36 +363,28 @@ convert_memory_address (to_mode, x)\n       return x;\n \n     case SUBREG:\n-      if (POINTERS_EXTEND_UNSIGNED >= 0\n-\t  && (SUBREG_PROMOTED_VAR_P (x) || REG_POINTER (SUBREG_REG (x)))\n+      if ((SUBREG_PROMOTED_VAR_P (x) || REG_POINTER (SUBREG_REG (x)))\n \t  && GET_MODE (SUBREG_REG (x)) == to_mode)\n \treturn SUBREG_REG (x);\n       break;\n \n     case LABEL_REF:\n-      if (POINTERS_EXTEND_UNSIGNED >= 0)\n-\t{\n-\t  temp = gen_rtx_LABEL_REF (to_mode, XEXP (x, 0));\n-\t  LABEL_REF_NONLOCAL_P (temp) = LABEL_REF_NONLOCAL_P (x);\n-\t  return temp;\n-\t}\n+      temp = gen_rtx_LABEL_REF (to_mode, XEXP (x, 0));\n+      LABEL_REF_NONLOCAL_P (temp) = LABEL_REF_NONLOCAL_P (x);\n+      return temp;\n       break;\n \n     case SYMBOL_REF:\n-      if (POINTERS_EXTEND_UNSIGNED >= 0)\n-\t{\n-\t  temp = gen_rtx_SYMBOL_REF (to_mode, XSTR (x, 0));\n-\t  SYMBOL_REF_FLAG (temp) = SYMBOL_REF_FLAG (x);\n-\t  CONSTANT_POOL_ADDRESS_P (temp) = CONSTANT_POOL_ADDRESS_P (x);\n-\t  STRING_POOL_ADDRESS_P (temp) = STRING_POOL_ADDRESS_P (x);\n-\t  return temp;\n-\t}\n+      temp = gen_rtx_SYMBOL_REF (to_mode, XSTR (x, 0));\n+      SYMBOL_REF_FLAG (temp) = SYMBOL_REF_FLAG (x);\n+      CONSTANT_POOL_ADDRESS_P (temp) = CONSTANT_POOL_ADDRESS_P (x);\n+      STRING_POOL_ADDRESS_P (temp) = STRING_POOL_ADDRESS_P (x);\n+      return temp;\n       break;\n \n     case CONST:\n-      if (POINTERS_EXTEND_UNSIGNED >= 0)\n-\treturn gen_rtx_CONST (to_mode,\n-\t\t\t      convert_memory_address (to_mode, XEXP (x, 0)));\n+      return gen_rtx_CONST (to_mode,\n+\t\t\t    convert_memory_address (to_mode, XEXP (x, 0)));\n       break;\n \n     case PLUS:\n@@ -401,8 +393,7 @@ convert_memory_address (to_mode, x)\n \t permute the conversion and addition operation.  We can always safely\n \t permute them if we are making the address narrower.  In addition,\n \t always permute the operations if this is a constant.  */\n-      if (POINTERS_EXTEND_UNSIGNED >= 0\n-\t  && (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)\n+      if ((GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)\n \t      || (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t\t  && (INTVAL (XEXP (x, 1)) + 20000 < 40000\n \t\t      || CONSTANT_P (XEXP (x, 0))))))"}]}