{"sha": "d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc4N2JhNTY4YWE5YmZhMDBjNzFmNTViODZkZGI5NWEzZDE1M2RiMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:18:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:18:45Z"}, "message": "[60/77] Pass scalar_int_modes to do_jump_by_parts_*\n\nThe callers of do_jump_by_parts_* had already established\nthat the modes were MODE_INTs, so this patch passes the\nmodes down as scalar_int_modes.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* dojump.c (do_jump_by_parts_greater_rtx): Change the type of\n\tthe mode argument to scalar_int_mode.\n\t(do_jump_by_parts_zero_rtx): Likewise.\n\t(do_jump_by_parts_equality_rtx): Likewise.\n\t(do_jump_by_parts_greater): Take a mode argument.\n\t(do_jump_by_parts_equality): Likewise.\n\t(do_jump_1): Update calls accordingly.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251512", "tree": {"sha": "79ff3c8099cb3359a27b27f61119e03a1d59be7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79ff3c8099cb3359a27b27f61119e03a1d59be7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d787ba568aa9bfa00c71f55b86ddb95a3d153db0/comments", "author": null, "committer": null, "parents": [{"sha": "d305ca88fc9b180a1790e02b144e921d17b393f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d305ca88fc9b180a1790e02b144e921d17b393f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d305ca88fc9b180a1790e02b144e921d17b393f0"}], "stats": {"total": 58, "additions": 35, "deletions": 23}, "files": [{"sha": "8c829dc2fe26ab51f4caa123146a136a1dbed024", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d787ba568aa9bfa00c71f55b86ddb95a3d153db0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d787ba568aa9bfa00c71f55b86ddb95a3d153db0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "patch": "@@ -1,3 +1,15 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* dojump.c (do_jump_by_parts_greater_rtx): Change the type of\n+\tthe mode argument to scalar_int_mode.\n+\t(do_jump_by_parts_zero_rtx): Likewise.\n+\t(do_jump_by_parts_equality_rtx): Likewise.\n+\t(do_jump_by_parts_greater): Take a mode argument.\n+\t(do_jump_by_parts_equality): Likewise.\n+\t(do_jump_1): Update calls accordingly.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "cda6f48eb7ad278529247f04ec365a5400885253", "filename": "gcc/dojump.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d787ba568aa9bfa00c71f55b86ddb95a3d153db0/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d787ba568aa9bfa00c71f55b86ddb95a3d153db0/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "patch": "@@ -38,11 +38,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n \n static bool prefer_and_bit_test (machine_mode, int);\n-static void do_jump_by_parts_greater (tree, tree, int,\n+static void do_jump_by_parts_greater (scalar_int_mode, tree, tree, int,\n \t\t\t\t      rtx_code_label *, rtx_code_label *,\n \t\t\t\t      profile_probability);\n-static void do_jump_by_parts_equality (tree, tree, rtx_code_label *,\n-\t\t\t\t       rtx_code_label *, profile_probability);\n+static void do_jump_by_parts_equality (scalar_int_mode, tree, tree,\n+\t\t\t\t       rtx_code_label *, rtx_code_label *,\n+\t\t\t\t       profile_probability);\n static void do_compare_and_jump\t(tree, tree, enum rtx_code, enum rtx_code,\n \t\t\t\t rtx_code_label *, rtx_code_label *,\n \t\t\t\t profile_probability);\n@@ -221,8 +222,8 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \t\t   prob.invert ());\n \telse if (is_int_mode (TYPE_MODE (inner_type), &int_mode)\n \t\t && !can_compare_p (EQ, int_mode, ccp_jump))\n-\t  do_jump_by_parts_equality (op0, op1, if_false_label, if_true_label,\n-\t\t\t\t     prob);\n+\t  do_jump_by_parts_equality (int_mode, op0, op1, if_false_label,\n+\t\t\t\t     if_true_label, prob);\n         else\n \t  do_compare_and_jump (op0, op1, EQ, EQ, if_false_label, if_true_label,\n \t\t\t       prob);\n@@ -242,8 +243,8 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \t  do_jump (op0, if_false_label, if_true_label, prob);\n \telse if (is_int_mode (TYPE_MODE (inner_type), &int_mode)\n \t\t && !can_compare_p (NE, int_mode, ccp_jump))\n-\t  do_jump_by_parts_equality (op0, op1, if_true_label, if_false_label,\n-\t\t\t\t     prob.invert ());\n+\t  do_jump_by_parts_equality (int_mode, op0, op1, if_true_label,\n+\t\t\t\t     if_false_label, prob.invert ());\n         else\n \t  do_compare_and_jump (op0, op1, NE, NE, if_false_label, if_true_label,\n \t\t\t       prob);\n@@ -254,7 +255,7 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (is_int_mode (mode, &int_mode)\n \t  && ! can_compare_p (LT, int_mode, ccp_jump))\n-\tdo_jump_by_parts_greater (op0, op1, 1, if_false_label,\n+\tdo_jump_by_parts_greater (int_mode, op0, op1, 1, if_false_label,\n \t\t\t\t  if_true_label, prob);\n       else\n \tdo_compare_and_jump (op0, op1, LT, LTU, if_false_label, if_true_label,\n@@ -265,8 +266,8 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (is_int_mode (mode, &int_mode)\n \t  && ! can_compare_p (LE, int_mode, ccp_jump))\n-\tdo_jump_by_parts_greater (op0, op1, 0, if_true_label, if_false_label,\n-\t\t\t\t  prob.invert ());\n+\tdo_jump_by_parts_greater (int_mode, op0, op1, 0, if_true_label,\n+\t\t\t\t  if_false_label, prob.invert ());\n       else\n \tdo_compare_and_jump (op0, op1, LE, LEU, if_false_label, if_true_label,\n \t\t\t     prob);\n@@ -276,7 +277,7 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (is_int_mode (mode, &int_mode)\n \t  && ! can_compare_p (GT, int_mode, ccp_jump))\n-\tdo_jump_by_parts_greater (op0, op1, 0, if_false_label,\n+\tdo_jump_by_parts_greater (int_mode, op0, op1, 0, if_false_label,\n \t\t\t\t  if_true_label, prob);\n       else\n \tdo_compare_and_jump (op0, op1, GT, GTU, if_false_label, if_true_label,\n@@ -287,8 +288,8 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n       mode = TYPE_MODE (TREE_TYPE (op0));\n       if (is_int_mode (mode, &int_mode)\n \t  && ! can_compare_p (GE, int_mode, ccp_jump))\n-\tdo_jump_by_parts_greater (op0, op1, 1, if_true_label, if_false_label,\n-\t\t\t\t  prob.invert ());\n+\tdo_jump_by_parts_greater (int_mode, op0, op1, 1, if_true_label,\n+\t\t\t\t  if_false_label, prob.invert ());\n       else\n \tdo_compare_and_jump (op0, op1, GE, GEU, if_false_label, if_true_label,\n \t\t\t     prob);\n@@ -667,7 +668,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */\n \n static void\n-do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n+do_jump_by_parts_greater_rtx (scalar_int_mode mode, int unsignedp, rtx op0,\n \t\t\t      rtx op1, rtx_code_label *if_false_label,\n \t\t\t      rtx_code_label *if_true_label,\n \t\t\t      profile_probability prob)\n@@ -743,17 +744,16 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n /* Given a comparison expression EXP for values too wide to be compared\n    with one insn, test the comparison and jump to the appropriate label.\n    The code of EXP is ignored; we always test GT if SWAP is 0,\n-   and LT if SWAP is 1.  */\n+   and LT if SWAP is 1.  MODE is the mode of the two operands.  */\n \n static void\n-do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n-\t\t\t  rtx_code_label *if_false_label,\n+do_jump_by_parts_greater (scalar_int_mode mode, tree treeop0, tree treeop1,\n+\t\t\t  int swap, rtx_code_label *if_false_label,\n \t\t\t  rtx_code_label *if_true_label,\n \t\t\t  profile_probability prob)\n {\n   rtx op0 = expand_normal (swap ? treeop1 : treeop0);\n   rtx op1 = expand_normal (swap ? treeop0 : treeop1);\n-  machine_mode mode = TYPE_MODE (TREE_TYPE (treeop0));\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (treeop0));\n \n   do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,\n@@ -766,7 +766,7 @@ do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n    to indicate drop through.  */\n \n static void\n-do_jump_by_parts_zero_rtx (machine_mode mode, rtx op0,\n+do_jump_by_parts_zero_rtx (scalar_int_mode mode, rtx op0,\n \t\t\t   rtx_code_label *if_false_label,\n \t\t\t   rtx_code_label *if_true_label,\n \t\t\t   profile_probability prob)\n@@ -817,7 +817,7 @@ do_jump_by_parts_zero_rtx (machine_mode mode, rtx op0,\n    to indicate drop through.  */\n \n static void\n-do_jump_by_parts_equality_rtx (machine_mode mode, rtx op0, rtx op1,\n+do_jump_by_parts_equality_rtx (scalar_int_mode mode, rtx op0, rtx op1,\n \t\t\t       rtx_code_label *if_false_label,\n \t\t\t       rtx_code_label *if_true_label,\n \t\t\t       profile_probability prob)\n@@ -855,17 +855,17 @@ do_jump_by_parts_equality_rtx (machine_mode mode, rtx op0, rtx op1,\n }\n \n /* Given an EQ_EXPR expression EXP for values too wide to be compared\n-   with one insn, test the comparison and jump to the appropriate label.  */\n+   with one insn, test the comparison and jump to the appropriate label.\n+   MODE is the mode of the two operands.  */\n \n static void\n-do_jump_by_parts_equality (tree treeop0, tree treeop1,\n+do_jump_by_parts_equality (scalar_int_mode mode, tree treeop0, tree treeop1,\n \t\t\t   rtx_code_label *if_false_label,\n \t\t\t   rtx_code_label *if_true_label,\n \t\t\t   profile_probability prob)\n {\n   rtx op0 = expand_normal (treeop0);\n   rtx op1 = expand_normal (treeop1);\n-  machine_mode mode = TYPE_MODE (TREE_TYPE (treeop0));\n   do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,\n \t\t\t\t if_true_label, prob);\n }"}]}