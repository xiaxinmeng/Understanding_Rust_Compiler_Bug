{"sha": "dfed7971fb42cbd5196ee92e27e8292f46fa72e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZlZDc5NzFmYjQyY2JkNTE5NmVlOTJlMjdlODI5MmY0NmZhNzJlOQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-11-29T05:29:47Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-11-29T05:29:47Z"}, "message": "rs6000: Make deallocation of a large frame work (PR77687)\n\nIf we use ABI_V4 and we have a big stack frame, we end the epilogue\nwith a \"mr 1,11\" (or similar) instruction.  This instruction however\nhas no dependencies on the earlier restores from stack (done via r11),\nso sched2 can end up reordering the insns, which is bad because we\nhave no red zone so that you then restore from stack that is already\ndeallocated.\n\nThis fixes it by making that restore depend on the memory accesses.\n\n\n\tPR target/77687\n\t* config/rs6000/rs6000.c (rs6000_emit_stack_reset): Emit the\n\tstack_restore_tie insn instead of stack_tie, for the SVR4 and\n\tSPE ABIs.\n\t* config/rs6000/rs6000.md (stack_restore_tie): New define_insn.\n\nFrom-SVN: r242949", "tree": {"sha": "0b1ed8816a840b84d110cc33df30aca22480a93b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b1ed8816a840b84d110cc33df30aca22480a93b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfed7971fb42cbd5196ee92e27e8292f46fa72e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfed7971fb42cbd5196ee92e27e8292f46fa72e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfed7971fb42cbd5196ee92e27e8292f46fa72e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfed7971fb42cbd5196ee92e27e8292f46fa72e9/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08dd2b683f98c6a721329f02f16a9a815a143f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08dd2b683f98c6a721329f02f16a9a815a143f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08dd2b683f98c6a721329f02f16a9a815a143f48"}], "stats": {"total": 37, "additions": 32, "deletions": 5}, "files": [{"sha": "27f4137134a7de205f216aa9128bc8607f78f933", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfed7971fb42cbd5196ee92e27e8292f46fa72e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfed7971fb42cbd5196ee92e27e8292f46fa72e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfed7971fb42cbd5196ee92e27e8292f46fa72e9", "patch": "@@ -1,3 +1,11 @@\n+2016-11-29  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR target/77687\n+\t* config/rs6000/rs6000.c (rs6000_emit_stack_reset): Emit the\n+\tstack_restore_tie insn instead of stack_tie, for the SVR4 and\n+\tSPE ABIs.\n+\t* config/rs6000/rs6000.md (stack_restore_tie): New define_insn.\n+\n 2016-11-28  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* shrink-wrap.c (init_separate_shrink_wrap): Do not clear"}, {"sha": "0a6a784a9409202056737928a39db446f64f2941", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfed7971fb42cbd5196ee92e27e8292f46fa72e9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfed7971fb42cbd5196ee92e27e8292f46fa72e9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dfed7971fb42cbd5196ee92e27e8292f46fa72e9", "patch": "@@ -27534,26 +27534,29 @@ rs6000_emit_stack_reset (rs6000_stack_t *info,\n \t\t\t rtx frame_reg_rtx, HOST_WIDE_INT frame_off,\n \t\t\t unsigned updt_regno)\n {\n-  rtx updt_reg_rtx;\n+  /* If there is nothing to do, don't do anything.  */\n+  if (frame_off == 0 && REGNO (frame_reg_rtx) == updt_regno)\n+    return NULL_RTX;\n+\n+  rtx updt_reg_rtx = gen_rtx_REG (Pmode, updt_regno);\n \n   /* This blockage is needed so that sched doesn't decide to move\n      the sp change before the register restores.  */\n   if (DEFAULT_ABI == ABI_V4\n       || (TARGET_SPE_ABI\n \t  && info->spe_64bit_regs_used != 0\n \t  && info->first_gp_reg_save != 32))\n-    rs6000_emit_stack_tie (frame_reg_rtx, frame_pointer_needed);\n+    return emit_insn (gen_stack_restore_tie (updt_reg_rtx, frame_reg_rtx,\n+\t\t\t\t\t     GEN_INT (frame_off)));\n \n   /* If we are restoring registers out-of-line, we will be using the\n      \"exit\" variants of the restore routines, which will reset the\n      stack for us.  But we do need to point updt_reg into the\n      right place for those routines.  */\n-  updt_reg_rtx = gen_rtx_REG (Pmode, updt_regno);\n-\n   if (frame_off != 0)\n     return emit_insn (gen_add3_insn (updt_reg_rtx,\n \t\t\t\t     frame_reg_rtx, GEN_INT (frame_off)));\n-  else if (REGNO (frame_reg_rtx) != updt_regno)\n+  else\n     return emit_move_insn (updt_reg_rtx, frame_reg_rtx);\n \n   return NULL_RTX;"}, {"sha": "cb982d383cae8890e57af5c5d00ffa009e883d00", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfed7971fb42cbd5196ee92e27e8292f46fa72e9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfed7971fb42cbd5196ee92e27e8292f46fa72e9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dfed7971fb42cbd5196ee92e27e8292f46fa72e9", "patch": "@@ -12813,6 +12813,22 @@\n   \"\"\n   [(set_attr \"length\" \"0\")])\n \n+; Some 32-bit ABIs do not have a red zone, so the stack deallocation has to\n+; stay behind all restores from the stack, it cannot be reordered to before\n+; one.  See PR77687.  This insn is an add or mr, and a stack_tie on the\n+; operands of that.\n+(define_insn \"stack_restore_tie\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"O,rI\")))\n+   (set (mem:BLK (match_dup 0)) (const_int 0))\n+   (set (mem:BLK (match_dup 1)) (const_int 0))]\n+  \"TARGET_32BIT\"\n+  \"@\n+   mr %0,%1\n+   add%I2 %0,%1,%2\"\n+  [(set_attr \"type\" \"*,add\")])\n+\n (define_expand \"epilogue\"\n   [(use (const_int 0))]\n   \"\""}]}