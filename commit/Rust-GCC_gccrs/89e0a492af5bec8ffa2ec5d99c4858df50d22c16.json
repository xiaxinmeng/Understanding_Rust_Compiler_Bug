{"sha": "89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODllMGE0OTJhZjViZWM4ZmZhMmVjNWQ5OWM0ODU4ZGY1MGQyMmMxNg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-10-09T20:58:00Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-10-09T20:58:00Z"}, "message": "Implement C++20 P0388R4, DR 1307, and DR 330.\n\nThis patch implements P0388R4, Permit conversions to arrays of unknown bound,\n<http://wg21.link/p0388r4>.  CWG 393 allowed references to arrays of unknown\nbound and this C++20 feature allows conversions like\n\n  void f(int(&)[]);\n  int arr[1];\n\n  void g() { f(arr); }\n  int(&r)[] = arr;\n\nThe proposal seemed fairly straightforward but it turned out to be quite\nshifty.  I found out that I needed to implement DR 2352 (done), and also\nDR 1307 (done in this patch).  The latter DR added wording for\nlist-initialization ranking of references to arrays which this proposal\nextends.  DR 330 was also implemented in this patch.\n\n\tPR c++/91364 - P0388R4: Permit conversions to arrays of\tunknown bound.\n\tPR c++/69531 - DR 1307: Differently bounded array parameters.\n\tPR c++/88128 - DR 330: Qual convs and pointers to arrays of pointers.\n\t* call.c (build_array_conv): Build ck_identity at the beginning\n\tof the conversion.\n\t(standard_conversion): Pass bounds_none to comp_ptr_ttypes_const.\n\t(maybe_warn_array_conv): New.\n\t(convert_like_real): Call it.  Add an error message about converting\n\tfrom arrays of unknown bounds.\n\t(conv_get_original_expr): New.\n\t(nelts_initialized_by_list_init): New.\n\t(conv_binds_to_array_of_unknown_bound): New.\n\t(compare_ics): Implement list-initialization ranking based on\n\tarray sizes, as specified in DR 1307 and P0388R.\n\t* cp-tree.h (comp_ptr_ttypes_const): Adjust declaration.\n\t(compare_bounds_t): New enum.\n\t* typeck.c (comp_array_types): New bool and compare_bounds_t\n\tparameters.  Use them.\n\t(structural_comptypes): Adjust the call to comp_array_types.\n\t(similar_type_p): Handle ARRAY_TYPE.\n\t(build_const_cast_1): Pass bounds_none to comp_ptr_ttypes_const.\n\t(comp_ptr_ttypes_real): Don't check cv-quals of ARRAY_TYPEs.  Use\n\tcomp_array_types to compare array types.  Look through arrays as per\n\tDR 330.\n\t(comp_ptr_ttypes_const): Use comp_array_types to compare array types.\n\tLook through arrays as per DR 330.\n\n\t* g++.dg/conversion/qual1.C: New test.\n\t* g++.dg/conversion/qual2.C: New test.\n\t* g++.dg/conversion/qual3.C: New test.\n\t* g++.dg/conversion/ref2.C: New test.\n\t* g++.dg/conversion/ref3.C: New test.\n\t* g++.dg/cpp0x/initlist-array3.C: Remove dg-error.\n\t* g++.dg/cpp0x/initlist-array7.C: New test.\n\t* g++.dg/cpp0x/initlist-array8.C: New test.\n\t* g++.dg/cpp2a/array-conv1.C: New test.\n\t* g++.dg/cpp2a/array-conv10.C: New test.\n\t* g++.dg/cpp2a/array-conv11.C: New test.\n\t* g++.dg/cpp2a/array-conv12.C: New test.\n\t* g++.dg/cpp2a/array-conv13.C: New test.\n\t* g++.dg/cpp2a/array-conv14.C: New test.\n\t* g++.dg/cpp2a/array-conv15.C: New test.\n\t* g++.dg/cpp2a/array-conv16.C: New test.\n\t* g++.dg/cpp2a/array-conv17.C: New test.\n\t* g++.dg/cpp2a/array-conv2.C: New test.\n\t* g++.dg/cpp2a/array-conv3.C: New test.\n\t* g++.dg/cpp2a/array-conv4.C: New test.\n\t* g++.dg/cpp2a/array-conv5.C: New test.\n\t* g++.dg/cpp2a/array-conv6.C: New test.\n\t* g++.dg/cpp2a/array-conv7.C: New test.\n\t* g++.dg/cpp2a/array-conv8.C: New test.\n\t* g++.dg/cpp2a/array-conv9.C: New test.\n\t* g++.old-deja/g++.bugs/900321_01.C: Adjust dg-error.\n\n\t* testsuite/23_containers/span/lwg3255.cc: Adjust test to match the\n\tpost-P0388R4 behavior.\n\nFrom-SVN: r276771", "tree": {"sha": "a667aef79edfb7885e24c98250e956116d0c8550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a667aef79edfb7885e24c98250e956116d0c8550"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3b29211acb2b463a664875bf55cec0242e95d2ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b29211acb2b463a664875bf55cec0242e95d2ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b29211acb2b463a664875bf55cec0242e95d2ea"}], "stats": {"total": 933, "additions": 902, "deletions": 31}, "files": [{"sha": "e47e8ca6ddcd9a07bc0473f4d0408853b290ad1f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -1,3 +1,32 @@\n+2019-10-09  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/91364 - P0388R4: Permit conversions to arrays of\tunknown bound.\n+\tPR c++/69531 - DR 1307: Differently bounded array parameters.\n+\tPR c++/88128 - DR 330: Qual convs and pointers to arrays of pointers.\n+\t* call.c (build_array_conv): Build ck_identity at the beginning\n+\tof the conversion.\n+\t(standard_conversion): Pass bounds_none to comp_ptr_ttypes_const.\n+\t(maybe_warn_array_conv): New.\n+\t(convert_like_real): Call it.  Add an error message about converting\n+\tfrom arrays of unknown bounds.\n+\t(conv_get_original_expr): New.\n+\t(nelts_initialized_by_list_init): New.\n+\t(conv_binds_to_array_of_unknown_bound): New.\n+\t(compare_ics): Implement list-initialization ranking based on\n+\tarray sizes, as specified in DR 1307 and P0388R.\n+\t* cp-tree.h (comp_ptr_ttypes_const): Adjust declaration.\n+\t(compare_bounds_t): New enum.\n+\t* typeck.c (comp_array_types): New bool and compare_bounds_t\n+\tparameters.  Use them.\n+\t(structural_comptypes): Adjust the call to comp_array_types.\n+\t(similar_type_p): Handle ARRAY_TYPE.\n+\t(build_const_cast_1): Pass bounds_none to comp_ptr_ttypes_const.\n+\t(comp_ptr_ttypes_real): Don't check cv-quals of ARRAY_TYPEs.  Use\n+\tcomp_array_types to compare array types.  Look through arrays as per\n+\tDR 330.\n+\t(comp_ptr_ttypes_const): Use comp_array_types to compare array types.\n+\tLook through arrays as per DR 330.\n+\n 2019-10-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/92032 - DR 1601: Promotion of enum with fixed underlying\ttype."}, {"sha": "55d2abaaddd4fb143147e6058849f6ecf64cdaa8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 153, "deletions": 7, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -122,7 +122,8 @@ struct conversion {\n        of using this field directly.  */\n     conversion *next;\n     /* The expression at the beginning of the conversion chain.  This\n-       variant is used only if KIND is ck_identity or ck_ambig.  */\n+       variant is used only if KIND is ck_identity or ck_ambig.  You can\n+       use conv_get_original_expr to get this expression.  */\n     tree expr;\n     /* The array of conversions for an initializer_list, so this\n        variant is used only when KIN D is ck_list.  */\n@@ -223,6 +224,8 @@ static void add_candidates (tree, tree, const vec<tree, va_gc> *, tree, tree,\n \t\t\t    tsubst_flags_t);\n static conversion *merge_conversion_sequences (conversion *, conversion *);\n static tree build_temp (tree, tree, int, diagnostic_t *, tsubst_flags_t);\n+static conversion *build_identity_conv (tree, tree);\n+static inline bool conv_binds_to_array_of_unknown_bound (conversion *);\n \n /* Returns nonzero iff the destructor name specified in NAME matches BASETYPE.\n    NAME can take many forms...  */\n@@ -1066,7 +1069,7 @@ build_array_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n   c->rank = rank;\n   c->user_conv_p = user;\n   c->bad_p = bad;\n-  c->u.next = NULL;\n+  c->u.next = build_identity_conv (TREE_TYPE (ctor), ctor);\n   return c;\n }\n \n@@ -1366,7 +1369,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \n       if (same_type_p (from, to))\n \t/* OK */;\n-      else if (c_cast_p && comp_ptr_ttypes_const (to, from))\n+      else if (c_cast_p && comp_ptr_ttypes_const (to, from, bounds_either))\n \t/* In a C-style cast, we ignore CV-qualification because we\n \t   are allowed to perform a static_cast followed by a\n \t   const_cast.  */\n@@ -1668,7 +1671,14 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n       maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n       /* DR 1288: Otherwise, if the initializer list has a single element\n \t of type E and ... [T's] referenced type is reference-related to E,\n-\t the object or reference is initialized from that element... */\n+\t the object or reference is initialized from that element...\n+\n+\t ??? With P0388R4, we should bind 't' directly to U{}:\n+\t   using U = A[2];\n+\t   A (&&t)[] = {U{}};\n+\t because A[] and A[2] are reference-related.  But we don't do it\n+\t because grok_reference_init has deduced the array size (to 1), and\n+\t A[1] and A[2] aren't reference-related.  */\n       if (CONSTRUCTOR_NELTS (expr) == 1)\n \t{\n \t  tree elt = CONSTRUCTOR_ELT (expr, 0)->value;\n@@ -6958,6 +6968,27 @@ maybe_inform_about_fndecl_for_bogus_argument_init (tree fn, int argnum)\n \t    \"  initializing argument %P of %qD\", argnum, fn);\n }\n \n+/* Maybe warn about C++20 Conversions to arrays of unknown bound.  C is\n+   the conversion, EXPR is the expression we're converting.  */\n+\n+static void\n+maybe_warn_array_conv (location_t loc, conversion *c, tree expr)\n+{\n+  if (cxx_dialect >= cxx2a)\n+    return;\n+\n+  tree type = TREE_TYPE (expr);\n+  type = strip_pointer_operator (type);\n+\n+  if (TREE_CODE (type) != ARRAY_TYPE\n+      || TYPE_DOMAIN (type) == NULL_TREE)\n+    return;\n+\n+  if (conv_binds_to_array_of_unknown_bound (c))\n+    pedwarn (loc, OPT_Wpedantic, \"conversions to arrays of unknown bound \"\n+\t     \"are only available with %<-std=c++2a%> or %<-std=gnu++2a%>\");\n+}\n+\n /* Perform the conversions in CONVS on the expression EXPR.  FN and\n    ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n    indicates the `this' argument of a method.  INNER is nonzero when\n@@ -7377,15 +7408,29 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t      error_at (loc, \"cannot bind non-const lvalue reference of \"\n \t\t\t\"type %qH to an rvalue of type %qI\", totype, extype);\n \t    else if (!reference_compatible_p (TREE_TYPE (totype), extype))\n-\t      error_at (loc, \"binding reference of type %qH to %qI \"\n-\t\t\t\"discards qualifiers\", totype, extype);\n+\t      {\n+\t\t/* If we're converting from T[] to T[N], don't talk\n+\t\t   about discarding qualifiers.  (Converting from T[N] to\n+\t\t   T[] is allowed by P0388R4.)  */\n+\t\tif (TREE_CODE (extype) == ARRAY_TYPE\n+\t\t    && TYPE_DOMAIN (extype) == NULL_TREE\n+\t\t    && TREE_CODE (TREE_TYPE (totype)) == ARRAY_TYPE\n+\t\t    && TYPE_DOMAIN (TREE_TYPE (totype)) != NULL_TREE)\n+\t\t  error_at (loc, \"cannot bind reference of type %qH to %qI \"\n+\t\t\t    \"due to different array bounds\", totype, extype);\n+\t\telse\n+\t\t  error_at (loc, \"binding reference of type %qH to %qI \"\n+\t\t\t    \"discards qualifiers\", totype, extype);\n+\t      }\n \t    else\n \t      gcc_unreachable ();\n \t    maybe_print_user_conv_context (convs);\n \t    maybe_inform_about_fndecl_for_bogus_argument_init (fn, argnum);\n \n \t    return error_mark_node;\n \t  }\n+\telse if (complain & tf_warning)\n+\t  maybe_warn_array_conv (loc, convs, expr);\n \n \t/* If necessary, create a temporary. \n \n@@ -7469,7 +7514,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n     case ck_qual:\n       /* Warn about deprecated conversion if appropriate.  */\n       if (complain & tf_warning)\n-\tstring_conv_p (totype, expr, 1);\n+\t{\n+\t  string_conv_p (totype, expr, 1);\n+\t  maybe_warn_array_conv (loc, convs, expr);\n+\t}\n       break;\n \n     case ck_ptr:\n@@ -10061,6 +10109,50 @@ maybe_handle_ref_bind (conversion **ics)\n   return NULL;\n }\n \n+/* Get the expression at the beginning of the conversion chain C.  */\n+\n+static tree\n+conv_get_original_expr (conversion *c)\n+{\n+  for (; c; c = next_conversion (c))\n+    if (c->kind == ck_identity || c->kind == ck_ambig)\n+      return c->u.expr;\n+  return NULL_TREE;\n+}\n+\n+/* Return a tree representing the number of elements initialized by the\n+   list-initialization C.  The caller must check that C converts to an\n+   array type.  */\n+\n+static tree\n+nelts_initialized_by_list_init (conversion *c)\n+{\n+  /* If the array we're converting to has a dimension, we'll use that.  */\n+  if (TYPE_DOMAIN (c->type))\n+    return array_type_nelts_top (c->type);\n+  else\n+    {\n+      /* Otherwise, we look at how many elements the constructor we're\n+\t initializing from has.  */\n+      tree ctor = conv_get_original_expr (c);\n+      return size_int (CONSTRUCTOR_NELTS (ctor));\n+    }\n+}\n+\n+/* True iff C is a conversion that binds a reference or a pointer to\n+   an array of unknown bound.  */\n+\n+static inline bool\n+conv_binds_to_array_of_unknown_bound (conversion *c)\n+{\n+  /* ck_ref_bind won't have the reference stripped.  */\n+  tree type = non_reference (c->type);\n+  /* ck_qual won't have the pointer stripped.  */\n+  type = strip_pointer_operator (type);\n+  return (TREE_CODE (type) == ARRAY_TYPE\n+\t  && TYPE_DOMAIN (type) == NULL_TREE);\n+}\n+\n /* Compare two implicit conversion sequences according to the rules set out in\n    [over.ics.rank].  Return values:\n \n@@ -10174,6 +10266,38 @@ compare_ics (conversion *ics1, conversion *ics2)\n \t  if (f1 != f2)\n \t    return 0;\n \t}\n+      /* List-initialization sequence L1 is a better conversion sequence than\n+\t list-initialization sequence L2 if\n+\n+\t -- L1 and L2 convert to arrays of the same element type, and either\n+\t the number of elements n1 initialized by L1 is less than the number\n+\t of elements n2 initialized by L2, or n1=n2 and L2 converts to an array\n+\t of unknown bound and L1 does not.  (Added in CWG 1307 and extended by\n+\t P0388R4.)  */\n+      else if (t1->kind == ck_aggr\n+\t       && TREE_CODE (t1->type) == ARRAY_TYPE\n+\t       && TREE_CODE (t2->type) == ARRAY_TYPE)\n+\t{\n+\t  /* The type of the array elements must be the same.  */\n+\t  if (!same_type_p (TREE_TYPE (t1->type), TREE_TYPE (t2->type)))\n+\t    return 0;\n+\n+\t  tree n1 = nelts_initialized_by_list_init (t1);\n+\t  tree n2 = nelts_initialized_by_list_init (t2);\n+\t  if (tree_int_cst_lt (n1, n2))\n+\t    return 1;\n+\t  else if (tree_int_cst_lt (n2, n1))\n+\t    return -1;\n+\t  /* The n1 == n2 case.  */\n+\t  bool c1 = conv_binds_to_array_of_unknown_bound (t1);\n+\t  bool c2 = conv_binds_to_array_of_unknown_bound (t2);\n+\t  if (c1 && !c2)\n+\t    return -1;\n+\t  else if (!c1 && c2)\n+\t    return 1;\n+\t  else\n+\t    return 0;\n+\t}\n       else\n \t{\n \t  /* For ambiguous or aggregate conversions, use the target type as\n@@ -10469,6 +10593,28 @@ compare_ics (conversion *ics1, conversion *ics2)\n \n       if (same_type_ignoring_top_level_qualifiers_p (to_type1, to_type2))\n \t{\n+\t  /* Per P0388R4:\n+\n+\t    void f (int(&)[]),     // (1)\n+\t\t f (int(&)[1]),    // (2)\n+\t\t f (int*);\t   // (3)\n+\n+\t    (2) is better than (1), but (3) should be equal to (1) and to\n+\t    (2).  For that reason we don't use ck_qual for (1) which would\n+\t    give it the cr_exact rank while (3) remains ck_identity.\n+\t    Therefore we compare (1) and (2) here.  For (1) we'll have\n+\n+\t      ck_ref_bind <- ck_identity\n+\t\tint[] &\t       int[1]\n+\n+\t    so to handle this we must look at ref_conv.  */\n+\t  bool c1 = conv_binds_to_array_of_unknown_bound (ref_conv1);\n+\t  bool c2 = conv_binds_to_array_of_unknown_bound (ref_conv2);\n+\t  if (c1 && !c2)\n+\t    return -1;\n+\t  else if (!c1 && c2)\n+\t    return 1;\n+\n \t  int q1 = cp_type_quals (TREE_TYPE (ref_conv1->type));\n \t  int q2 = cp_type_quals (TREE_TYPE (ref_conv2->type));\n \t  if (ref_conv1->bad_p)"}, {"sha": "c1301a451df825cf7a2513bedb3c29169841fb89", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -7372,6 +7372,10 @@ extern void cxx_print_error_function\t\t(diagnostic_context *,\n \t\t\t\t\t\t struct diagnostic_info *);\n \n /* in typeck.c */\n+/* Says how we should behave when comparing two arrays one of which\n+   has unknown bounds.  */\n+enum compare_bounds_t { bounds_none, bounds_either, bounds_first };\n+\n extern bool cxx_mark_addressable\t\t(tree, bool = false);\n extern int string_conv_p\t\t\t(const_tree, const_tree, int);\n extern tree cp_truthvalue_conversion\t\t(tree);\n@@ -7462,7 +7466,7 @@ extern tree convert_for_initialization\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t impl_conv_rhs, tree, int,\n                                                  tsubst_flags_t);\n extern int comp_ptr_ttypes\t\t\t(tree, tree);\n-extern bool comp_ptr_ttypes_const\t\t(tree, tree);\n+extern bool comp_ptr_ttypes_const\t\t(tree, tree, compare_bounds_t);\n extern bool error_type_p\t\t\t(const_tree);\n extern bool ptr_reasonably_similar\t\t(const_tree, const_tree);\n extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool,"}, {"sha": "a67dd4b155a3bb96bada4f9b247a11cda5c41e01", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -54,7 +54,7 @@ static tree rationalize_conditional_expr (enum tree_code, tree,\n \t\t\t\t\t  tsubst_flags_t);\n static int comp_ptr_ttypes_real (tree, tree, int);\n static bool comp_except_types (tree, tree, bool);\n-static bool comp_array_types (const_tree, const_tree, bool);\n+static bool comp_array_types (const_tree, const_tree, compare_bounds_t, bool);\n static tree pointer_diff (location_t, tree, tree, tree, tsubst_flags_t, tree *);\n static tree get_delta_difference (tree, tree, bool, bool, tsubst_flags_t);\n static void casts_away_constness_r (tree *, tree *, tsubst_flags_t);\n@@ -1084,11 +1084,15 @@ comp_except_specs (const_tree t1, const_tree t2, int exact)\n   return exact == ce_derived || base == NULL_TREE || length == list_length (t1);\n }\n \n-/* Compare the array types T1 and T2.  ALLOW_REDECLARATION is true if\n-   [] can match [size].  */\n+/* Compare the array types T1 and T2.  CB says how we should behave when\n+   comparing array bounds: bounds_none doesn't allow dimensionless arrays,\n+   bounds_either says than any array can be [], bounds_first means that\n+   onlt T1 can be an array with unknown bounds.  STRICT is true if\n+   qualifiers must match when comparing the types of the array elements.  */\n \n static bool\n-comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)\n+comp_array_types (const_tree t1, const_tree t2, compare_bounds_t cb,\n+\t\t  bool strict)\n {\n   tree d1;\n   tree d2;\n@@ -1098,7 +1102,9 @@ comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)\n     return true;\n \n   /* The type of the array elements must be the same.  */\n-  if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+  if (strict\n+      ? !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+      : !similar_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n     return false;\n \n   d1 = TYPE_DOMAIN (t1);\n@@ -1119,8 +1125,10 @@ comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)\n        declarations for an array object can specify\n        array types that differ by the presence or absence of a major\n        array bound (_dcl.array_).  */\n-  if (!d1 || !d2)\n-    return allow_redeclaration;\n+  if (!d1 && d2)\n+    return cb >= bounds_either;\n+  else if (d1 && !d2)\n+    return cb == bounds_either;\n \n   /* Check that the dimensions are the same.  */\n \n@@ -1368,7 +1376,9 @@ structural_comptypes (tree t1, tree t2, int strict)\n \n     case ARRAY_TYPE:\n       /* Target types must match incl. qualifiers.  */\n-      if (!comp_array_types (t1, t2, !!(strict & COMPARE_REDECLARATION)))\n+      if (!comp_array_types (t1, t2, ((strict & COMPARE_REDECLARATION)\n+\t\t\t\t      ? bounds_either : bounds_none),\n+\t\t\t     /*strict=*/true))\n \treturn false;\n       break;\n \n@@ -1549,10 +1559,10 @@ similar_type_p (tree type1, tree type2)\n   if (same_type_ignoring_top_level_qualifiers_p (type1, type2))\n     return true;\n \n-  /* FIXME This ought to handle ARRAY_TYPEs too.  */\n   if ((TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n-      || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2)))\n-    return comp_ptr_ttypes_const (type1, type2);\n+      || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2))\n+      || (TREE_CODE (type1) == ARRAY_TYPE && TREE_CODE (type2) == ARRAY_TYPE))\n+    return comp_ptr_ttypes_const (type1, type2, bounds_either);\n \n   return false;\n }\n@@ -7867,7 +7877,7 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n \n   if (TYPE_PTR_P (src_type) || TYPE_PTRDATAMEM_P (src_type))\n     {\n-      if (comp_ptr_ttypes_const (dst_type, src_type))\n+      if (comp_ptr_ttypes_const (dst_type, src_type, bounds_none))\n \t{\n \t  if (valid_p)\n \t    {\n@@ -9909,9 +9919,10 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n \t\t\t   TYPE_OFFSET_BASETYPE (to)))\n \treturn 0;\n \n-      /* Const and volatile mean something different for function types,\n-\t so the usual checks are not appropriate.  */\n-      if (!FUNC_OR_METHOD_TYPE_P (to))\n+      /* Const and volatile mean something different for function and\n+\t array types, so the usual checks are not appropriate.  We'll\n+\t check the array type elements in further iterations.  */\n+      if (!FUNC_OR_METHOD_TYPE_P (to) && TREE_CODE (to) != ARRAY_TYPE)\n \t{\n \t  if (!at_least_as_qualified_p (to, from))\n \t    return 0;\n@@ -9930,7 +9941,17 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n       if (VECTOR_TYPE_P (to))\n \tis_opaque_pointer = vector_targets_convertible_p (to, from);\n \n-      if (!TYPE_PTR_P (to) && !TYPE_PTRDATAMEM_P (to))\n+      /* P0388R4 allows a conversion from int[N] to int[] but not the\n+\t other way round.  When both arrays have bounds but they do\n+\t not match, then no conversion is possible.  */\n+      if (TREE_CODE (to) == ARRAY_TYPE\n+\t  && !comp_array_types (to, from, bounds_first, /*strict=*/false))\n+\treturn 0;\n+\n+      if (!TYPE_PTR_P (to)\n+\t  && !TYPE_PTRDATAMEM_P (to)\n+\t  /* CWG 330 says we need to look through arrays.  */\n+\t  && TREE_CODE (to) != ARRAY_TYPE)\n \treturn ((constp >= 0 || to_more_cv_qualified)\n \t\t&& (is_opaque_pointer\n \t\t    || same_type_ignoring_top_level_qualifiers_p (to, from)));\n@@ -10033,10 +10054,10 @@ ptr_reasonably_similar (const_tree to, const_tree from)\n \n /* Return true if TO and FROM (both of which are POINTER_TYPEs or\n    pointer-to-member types) are the same, ignoring cv-qualification at\n-   all levels.  */\n+   all levels.  CB says how we should behave when comparing array bounds.  */\n \n bool\n-comp_ptr_ttypes_const (tree to, tree from)\n+comp_ptr_ttypes_const (tree to, tree from, compare_bounds_t cb)\n {\n   bool is_opaque_pointer = false;\n \n@@ -10053,7 +10074,14 @@ comp_ptr_ttypes_const (tree to, tree from)\n       if (VECTOR_TYPE_P (to))\n \tis_opaque_pointer = vector_targets_convertible_p (to, from);\n \n-      if (!TYPE_PTR_P (to))\n+      if (TREE_CODE (to) == ARRAY_TYPE\n+\t  /* Ignore cv-qualification, but if we see e.g. int[3] and int[4],\n+\t     we must fail.  */\n+\t  && !comp_array_types (to, from, cb, /*strict=*/false))\n+\treturn false;\n+\n+      /* CWG 330 says we need to look through arrays.  */\n+      if (!TYPE_PTR_P (to) && TREE_CODE (to) != ARRAY_TYPE)\n \treturn (is_opaque_pointer\n \t\t|| same_type_ignoring_top_level_qualifiers_p (to, from));\n     }"}, {"sha": "5ee2a814831c3ed731c137416490041fdbe5d702", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -1,3 +1,35 @@\n+2019-10-09  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/91364 - P0388R4: Permit conversions to arrays of\tunknown bound.\n+\tPR c++/69531 - DR 1307: Differently bounded array parameters.\n+\tPR c++/88128 - DR 330: Qual convs and pointers to arrays of pointers.\n+\t* g++.dg/conversion/qual1.C: New test.\n+\t* g++.dg/conversion/qual2.C: New test.\n+\t* g++.dg/conversion/qual3.C: New test.\n+\t* g++.dg/conversion/ref2.C: New test.\n+\t* g++.dg/conversion/ref3.C: New test.\n+\t* g++.dg/cpp0x/initlist-array3.C: Remove dg-error.\n+\t* g++.dg/cpp0x/initlist-array7.C: New test.\n+\t* g++.dg/cpp0x/initlist-array8.C: New test.\n+\t* g++.dg/cpp2a/array-conv1.C: New test.\n+\t* g++.dg/cpp2a/array-conv10.C: New test.\n+\t* g++.dg/cpp2a/array-conv11.C: New test.\n+\t* g++.dg/cpp2a/array-conv12.C: New test.\n+\t* g++.dg/cpp2a/array-conv13.C: New test.\n+\t* g++.dg/cpp2a/array-conv14.C: New test.\n+\t* g++.dg/cpp2a/array-conv15.C: New test.\n+\t* g++.dg/cpp2a/array-conv16.C: New test.\n+\t* g++.dg/cpp2a/array-conv17.C: New test.\n+\t* g++.dg/cpp2a/array-conv2.C: New test.\n+\t* g++.dg/cpp2a/array-conv3.C: New test.\n+\t* g++.dg/cpp2a/array-conv4.C: New test.\n+\t* g++.dg/cpp2a/array-conv5.C: New test.\n+\t* g++.dg/cpp2a/array-conv6.C: New test.\n+\t* g++.dg/cpp2a/array-conv7.C: New test.\n+\t* g++.dg/cpp2a/array-conv8.C: New test.\n+\t* g++.dg/cpp2a/array-conv9.C: New test.\n+\t* g++.old-deja/g++.bugs/900321_01.C: Adjust dg-error.\n+\n 2019-10-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/92032 - DR 1601: Promotion of enum with fixed underlying\ttype."}, {"sha": "5022da9da47ca431a9ac30cd29ed3acf9f036891", "filename": "gcc/testsuite/g++.dg/conversion/qual1.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual1.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,51 @@\n+// PR c++/88128 - Implement DR 330: Qualification conversions and pointers to\n+// arrays of pointers.\n+\n+int *a[4];\n+const int *const(*ap1)[4] = &a;\n+/* if at some level k the P2 is more cv-qualified than P1, then there\n+   must be a const at every single level (other than level zero) of P2\n+   up until k.  */\n+const int *(*ap2)[4] = &a; // { dg-error \"cannot convert\" }\n+int *const(*ap3)[4] = &a;\n+int *(*ap4)[4] = &a;\n+int *(*const ap5)[4] = &a;\n+const int *const(*const ap6)[4] = &a;\n+int *const(*const ap7)[4] = &a;\n+int *(*const ap8)[4] = &a;\n+\n+const int *b[4];\n+const int *const(*bp1)[4] = &b;\n+const int *(*bp2)[4] = &b;\n+int *const(*bp3)[4] = &b; // { dg-error \"cannot convert\" }\n+int *(*bp4)[4] = &b; // { dg-error \"cannot convert\" }\n+int *(*const bp5)[4] = &b; // { dg-error \"cannot convert\" }\n+const int *const(*const bp6)[4] = &b;\n+int *const(*const bp7)[4] = &b; // { dg-error \"cannot convert\" }\n+int *(*const bp8)[4] = &b; // { dg-error \"cannot convert\" }\n+\n+int *c[2][3];\n+int const *const (*cp1)[3] = c;\n+int const *(*cp2)[3] = c; // { dg-error \"cannot convert\" }\n+int const *const (*const cp3)[3] = c;\n+int *const (*cp4)[3] = c;\n+int *(*cp5)[3] = c;\n+\n+double *const (*d)[3];\n+double const *const (*e)[3] = d;\n+int *(*f)[3];\n+const int *const (*g)[3] = f;\n+\n+// From PR88128.\n+int* (*xx)[];\n+const int* const(*yy)[] = xx;\n+\n+// From DR 330.\n+int main()\n+{\n+   double *array2D[2][3];\n+\n+   double       *       (*array2DPtr1)[3] = array2D;\n+   double       * const (*array2DPtr2)[3] = array2DPtr1;\n+   double const * const (*array2DPtr3)[3] = array2DPtr2;\n+}"}, {"sha": "8a063a03e7937420dde89c7beb1c498920ff9199", "filename": "gcc/testsuite/g++.dg/conversion/qual2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual2.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/88128 - DR 330: Qual convs and pointers to arrays of pointers.\n+\n+// Make sure we don't accept different bounds.\n+\n+int *a[4];\n+const int *const(*ap1)[5] = &a; // { dg-error \"cannot convert\" }\n+\n+int *(*b)[3];\n+const int *const (*bp1)[3] = &b; // { dg-error \"cannot convert\" }\n+const int *const (*bp2)[4] = &b; // { dg-error \"cannot convert\" }\n+int *(*bp3)[4] = &b; // { dg-error \"cannot convert\" }\n+\n+int *c[2][3];\n+int const *const (*cp1)[4] = c; // { dg-error \"cannot convert\" }"}, {"sha": "4b466d9ea5df64ac6c32976dc58a476a11b16a3b", "filename": "gcc/testsuite/g++.dg/conversion/qual3.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fqual3.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,53 @@\n+// PR c++/88128 - DR 330: Qual convs and pointers to arrays of pointers.\n+// { dg-do compile { target c++17 } }\n+\n+using P = int *(*)[3];\n+using Q = const int *const (*)[3];\n+using Qi = const int *[3];\n+using Q2 = Qi const *;\n+using R = const int *const (*)[4];\n+using S = const int *const (*)[];\n+using T = const int *(*)[];\n+\n+void\n+f (P p, Q q, Q2 q2, R r, S s, T t)\n+{\n+  q = p;\n+  q2 = p;\n+  r = p; // { dg-error \"cannot convert\" }\n+  t = p; // { dg-error \"cannot convert\" }\n+  s = t;\n+  t = s; // { dg-error \"invalid conversion\" }\n+\n+  // Test const_cast.\n+  const_cast<P>(q);\n+  const_cast<P>(q2);\n+  const_cast<Q>(p);\n+  const_cast<Q2>(p);\n+  const_cast<S>(p); // { dg-error \"invalid .const_cast.\" }\n+  const_cast<P>(s); // { dg-error \"invalid .const_cast.\" }\n+  const_cast<S>(q); // { dg-error \"invalid .const_cast.\" }\n+  const_cast<S>(q2); // { dg-error \"invalid .const_cast.\" }\n+  const_cast<Q>(s); // { dg-error \"invalid .const_cast.\" }\n+  const_cast<Q2>(s); // { dg-error \"invalid .const_cast.\" }\n+  const_cast<T>(s);\n+  const_cast<S>(t);\n+  const_cast<T>(q); // { dg-error \"invalid .const_cast.\" }\n+  const_cast<Q>(t); // { dg-error \"invalid .const_cast.\" }\n+\n+  // Test reinterpret_cast.\n+  reinterpret_cast<P>(q); // { dg-error \"casts away qualifiers\" }\n+  reinterpret_cast<P>(q2); // { dg-error \"casts away qualifiers\" }\n+  reinterpret_cast<Q>(p);\n+  reinterpret_cast<Q2>(p);\n+  reinterpret_cast<S>(p);\n+  reinterpret_cast<P>(s); // { dg-error \"casts away qualifiers\" }\n+  reinterpret_cast<S>(q);\n+  reinterpret_cast<S>(q2);\n+  reinterpret_cast<Q>(s);\n+  reinterpret_cast<Q2>(s);\n+  reinterpret_cast<T>(s); // { dg-error \"casts away qualifiers\" }\n+  reinterpret_cast<S>(t);\n+  reinterpret_cast<T>(q); // { dg-error \"casts away qualifiers\" }\n+  reinterpret_cast<Q>(t);\n+}"}, {"sha": "418e711946f0db279d874d72ed530df59036d0b1", "filename": "gcc/testsuite/g++.dg/conversion/ref2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref2.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/88128 - Implement DR 330: Qualification conversions and pointers to\n+// arrays of pointers.\n+\n+int *ar[4];\n+/* if at some level k the P2 is more cv-qualified than P1, then there\n+   must be a const at every single level (other than level zero) of P2\n+   up until k.  */\n+const int *(&arp)[4] = ar; // { dg-error \"discards qualifiers\" }\n+const int *const(&arp2)[4] = ar;\n+int *const(&arp3)[4] = ar;\n+int *(&arp4)[4] = ar;\n+\n+const int *br[4];\n+const int *(&brp)[4] = br;\n+const int *const(&brp2)[4] = br;\n+int *const(&brp3)[4] = br; // { dg-error \"discards qualifiers\" }\n+int *(&brp4)[4] = br; // { dg-error \"discards qualifiers\" }\n+\n+int *c[2][3];\n+int const *const (&cp1)[3] = *c;\n+int const *(&cp2)[3] = *c; // { dg-error \"discards qualifiers\" }\n+int *const (&cp3)[3] = *c;\n+int *(&cp4)[3] = *c;\n+\n+double *const (*d)[3];\n+double const *const (&e)[3] = *d;\n+\n+int *(*f)[3];\n+const int *const (&g)[3] = *f;"}, {"sha": "ca5326ce8e803e931e0ff707fb33f6abda0163df", "filename": "gcc/testsuite/g++.dg/conversion/ref3.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref3.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,4 @@\n+int a[2];\n+const int (&rc)[2] = a;\n+volatile int (&rv)[2] = a;\n+const volatile int (&rcv)[2] = a;"}, {"sha": "4140cd92d7b50e36a6984f0471053cd9f1eb1939", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-array3.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array3.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -6,5 +6,6 @@ void composite (int const (&) [3]);\n \n int main ()\n {\n-  composite({0,1});\t\t// { dg-error \"ambiguous\" }\n+  // Not ambiguous since CWG 1307.\n+  composite({0,1});\n }"}, {"sha": "7a689c6675f78b7a8ede48cd1e4eb7da3532c9fe", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-array7.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array7.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/69531 - DR 1307, Overload resolution based on size of array init-list.\n+// { dg-do run { target c++11 } }\n+\n+int f(int const(&)[2]) { return 1; }\n+int f(int const(&)[3]) { return 2; }\n+\n+int\n+main ()\n+{\n+   if (f({}) != 1)\n+    __builtin_abort ();\n+\n+   if (f({1}) != 1)\n+    __builtin_abort ();\n+\n+   if (f({1, 2}) != 1)\n+    __builtin_abort ();\n+\n+   if (f({1, 2, 3}) != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "ac2774e06b4a338194371fe70001c94d375f7239", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-array8.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array8.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/69531 - DR 1307, Overload resolution based on size of array init-list.\n+// { dg-do run { target c++2a } }\n+\n+int f(int (&)[1][1]) { return 1; }\n+int f(int (&)[1][2]) { return 2; }\n+\n+int g(int (&&)[2][1]) { return 1; }\n+int g(int (&&)[2][2]) { return 2; }\n+\n+int h(int (&&)[][1]) { return 1; }\n+int h(int (&&)[][2]) { return 2; }\n+\n+int\n+main ()\n+{\n+  int arr1[1][1];\n+  int arr2[1][2];\n+\n+  if (f(arr1) != 1)\n+    __builtin_abort ();\n+  if (f(arr2) != 2)\n+    __builtin_abort ();\n+\n+  if (g({ { 1, 2 }, { 3 } }) != 2)\n+    __builtin_abort ();\n+\n+  if (g({ { 1, 2 }, { 3, 4 } }) != 2)\n+    __builtin_abort ();\n+\n+  if (h({ { 1, 2 }, { 3 } }) != 2)\n+    __builtin_abort ();\n+\n+  if (h({ { 1, 2 }, { 3, 4 } }) != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "e90b340b0d69160e31e76ae14983319f5d5fbecc", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv1.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-Wpedantic\" }\n+// C++17, because that has CWG 393.\n+\n+void f(int(&)[]);\n+void fp(int(*)[]);\n+void f2(int(&)[][10]);\n+void fp2(int(*)[][10]);\n+int arr[10];\n+int arr2[10][10];\n+\n+void\n+g ()\n+{\n+  f (arr); // { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+  fp (&arr); // { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+  f2 (arr2);// { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+  fp2 (&arr2);// { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+}\n+\n+int(&r1)[] = arr;// { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+int(&r2)[10] = arr;\n+int(&r3)[][10] = arr2;// { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+/* Note that\n+   int (&r)[10][] = arr2;\n+   is invalid.  */\n+int(&r4)[10][10] = arr2;\n+\n+int(*p1)[] = &arr;// { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+int(*p2)[10] = &arr;\n+int(*p3)[][10] = &arr2;// { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }\n+int(*p4)[10][10] = &arr2;"}, {"sha": "1ee1a771f635b1b377966faf1aa71745ee3a06e1", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv10.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv10.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-Wpedantic\" }\n+\n+// The other direction: converting from int[] to int(&)[3] is forbidden.\n+\n+extern int a[];\n+extern int (*b)[];\n+extern int (&c)[];\n+int (&y)[] = a;\n+int (&x)[3] = y; // { dg-error \"cannot bind reference\" }\n+int (&z)[3] = a; // { dg-error \"cannot bind reference\" }\n+\n+void f(int (*)[3]);\n+void f2(int (&)[3]);\n+\n+void\n+test ()\n+{\n+  f(b); // { dg-error \"cannot convert\" }\n+  f2(c); // { dg-error \"cannot bind reference\" }\n+}"}, {"sha": "a072b29191dcc12306b3746437dd37fbf9b07408", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv11.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv11.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+// { dg-options \"-Wpedantic\" }\n+\n+// Test flexible array member.  Here we're binding int[] to int[].  This worked\n+// even before P0388R4.\n+\n+typedef int T[];\n+extern T arr;\n+T &t1 = arr;\n+\n+struct S {\n+  int i;\n+  int a[]; // { dg-warning \"flexible array member\" }\n+};\n+\n+void f (int (&)[]);\n+\n+void\n+test (S s)\n+{\n+  f (s.a);\n+}"}, {"sha": "1156ea32df5549ad22fbe7187769cc36e7fe4282", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv12.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv12.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+// { dg-options \"-Wpedantic\" }\n+\n+int arr[1] = { 42 };\n+int(&r)[]{arr};\n+int(&r2)[] = {arr};\n+int(&&r3)[]{};\n+int(&&r4)[]{42};\n+int(&&r5)[] = {};\n+int(&&r6)[] = {42};\n+int(&r7)[](arr); // { dg-warning \"conversions to arrays of unknown bound are only available\" \"\" { target c++17_down } }"}, {"sha": "9908b7e911891da1355ad047f77227b6868458f1", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv13.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv13.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+\n+template <typename T> void foo(T);\n+\n+template <typename F, typename T, typename = decltype(foo<T>(F()))>\n+void test(int) { }\n+\n+// No other overload, so if the above fails because of the conversion,\n+// we fail.\n+\n+void\n+fn ()\n+{\n+  test<int(*)[2], int(*)[]>(0);\n+  test<int(*)[], int(*)[]>(0);\n+}"}, {"sha": "793e85d7b1c9c9c1e00580bb51d73d7f19168862", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv14.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv14.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+\n+void f(const int(*)[]);\n+void fb(const int(*)[3]);\n+void f2(const int(&)[]);\n+void fb2(const int(&)[3]);\n+\n+void\n+g ()\n+{\n+  int arr[3];\n+  f(&arr);\n+  fb(&arr);\n+  f2(arr);\n+  fb2(arr);\n+}"}, {"sha": "033a74683a71ea740158e9625dea704a0376eb20", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv15.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv15.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/69531 - DR 1307, Overload resolution based on size of array init-list.\n+// { dg-do run { target c++2a } }\n+\n+int f(int, int const(&)[2]) { return 1; }\n+int f(double, int const(&)[2]) { return 2; }\n+\n+int f2(int, int const(&)[1]) { return 1; }\n+int f2(int, int const(&)[2]) { return 2; }\n+\n+int f3(int, int const(&)[]) { return 1; }\n+int f3(double, int const(&)[]) { return 2; }\n+\n+int main ()\n+{\n+  if (f (1, {1}) != 1)\n+    __builtin_abort ();\n+\n+  if (f2 (1, {1}) != 1)\n+    __builtin_abort ();\n+\n+  if (f3 (1, {1}) != 1)\n+    __builtin_abort ();\n+}"}, {"sha": "bfb39d1c12c979d44e094e3d6c50e06d7a3eaf73", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv16.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv16.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/91364 - P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+\n+using P = int *(*)[3];\n+using S = const int *const (*)[];\n+using Q = const int *const (*)[3];\n+using Qi = const int *[3];\n+using Q2 = Qi const *;\n+\n+void\n+f (P p, S s, Q q, Q2 q2)\n+{\n+  s = p;\n+  s = q;\n+  s = q2;\n+}"}, {"sha": "3313ed466fbaaadab2013a11760dfb5adb7d43b8", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv17.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv17.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,39 @@\n+// PR c++/91364 - P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+\n+// As conversion/qual1.C, but with [].\n+\n+int *a[4];\n+const int *const(*ap1)[] = &a;\n+/* if at some level k the P2 is more cv-qualified than P1, then there\n+   must be a const at every single level (other than level zero) of P2\n+   up until k.  */\n+const int *(*ap2)[] = &a; // { dg-error \"cannot convert\" }\n+int *const(*ap3)[] = &a;\n+int *(*ap4)[] = &a;\n+int *(*const ap5)[] = &a;\n+const int *const(*const ap6)[] = &a;\n+int *const(*const ap7)[] = &a;\n+int *(*const ap8)[] = &a;\n+\n+const int *b[4];\n+const int *const(*bp1)[] = &b;\n+const int *(*bp2)[] = &b;\n+int *const(*bp3)[] = &b; // { dg-error \"cannot convert\" }\n+int *(*bp4)[] = &b; // { dg-error \"cannot convert\" }\n+int *(*const bp5)[] = &b; // { dg-error \"cannot convert\" }\n+const int *const(*const bp6)[] = &b;\n+int *const(*const bp7)[] = &b; // { dg-error \"cannot convert\" }\n+int *(*const bp8)[] = &b; // { dg-error \"cannot convert\" }\n+\n+int *c[2][3];\n+int const *const (*cp1)[] = c;\n+int const *(*cp2)[] = c; // { dg-error \"cannot convert\" }\n+int const *const (*const cp3)[] = c;\n+int *const (*cp4)[] = c;\n+int *(*cp5)[] = c;\n+\n+double *const (*d)[3];\n+double const *const (*e)[] = d;\n+int *(*f)[3];\n+const int *const (*g)[] = f;"}, {"sha": "5245d830f1f3f983d91ebdd0b40002ea6d89d017", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv2.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv2.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+\n+struct A {\n+  A();\n+  A(const A(&)[2]);\n+};\n+\n+using T = A[];\n+using U = A[2];\n+\n+// t binds directly to U{} now.  Before it bound indirectly to a temporary\n+// A{U{}}.  ??? But we don't do it now; see reference_binding and the \n+// BRACE_ENCLOSED_INITIALIZER_P block.\n+A (&&t)[] = {U{}};\n+\n+U u{};\n+\n+T &\n+foo ()\n+{\n+  // This didn't compile before P0388R4: invalid initialization of non-const\n+  // reference of type 'A (&)[]' from an rvalue of type\n+  // '<brace-enclosed initializer list>'.\n+  return {u};\n+}"}, {"sha": "3d92b40124717e84e14b12cd3c83a67be1069ab3", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv3.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv3.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do run { target c++2a } }\n+\n+// Ranking of reference initialization conversions\n+\n+int f(int(&)[]) { return 1; }\t    // (1)\n+int f(int(&)[1]) { return 2; }\t    // (2)\n+\n+int h(int(*)[]) { return 1; }\t    // (a)\n+int h(int(*)[1]) { return 2; }\t    // (b)\n+\n+// From P0388R4:\n+// (2) and (b) should clearly be better than (1) and (a), respectively,\n+// as the former overloads are more restricted. \n+// (a) should be worse than (b), which is implied by (a) necessitating\n+// a qualification conversion in that case.\n+\n+int\n+main ()\n+{\n+  int arr[1];\n+  if (f(arr) != 2)\n+    __builtin_abort ();\n+  if (h(&arr) != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "979c69b055520850acb9cdbe66fa5e15106fa743", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv4.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv4.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+\n+// Ranking of reference initialization conversions\n+\n+void f(int(&)[]) {}\t    // (1)\n+//void f(int(&)[1]) { }\t    // (2)\n+void f(int*) { }\t    // (3)\n+\n+//void f2(int(&)[]) { }\t    // (1)\n+void f2(int(&)[1]) { }\t    // (2)\n+void f2(int*) { }\t    // (3)\n+\n+// From P0388R4:\n+// (3) should be equal to (1) (as it is to (2))\n+// Check that we get \"ambiguous overload\" errors.\n+\n+void\n+doit ()\n+{\n+  int arr[1];\n+  f(arr); // { dg-error \"ambiguous\" }\n+  f2(arr); // { dg-error \"ambiguous\" }\n+}"}, {"sha": "34678f5cead3bbfcead6853eb24ca1e7bfd715ea", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv5.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv5.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do run { target c++2a } }\n+\n+// Ranking of list-initialization sequences\n+int b(int   (&&)[] ) { return 1; }   // #1\n+int b(long  (&&)[] ) { return 2; }   // #2\n+int b(int   (&&)[1]) { return 3; }   // #3\n+int b(long  (&&)[1]) { return 4; }   // #4\n+int b(int   (&&)[2]) { return 5; }   // #5\n+\n+/* Here,\n+   -- #1, #3 and #5 should rank better than both #2 and #4, as no promotion\n+      is necessitated.\n+   -- #1 should rank worse than #3, being far less specialized.\n+   -- #1 should rank better than #5, as the latter requires a larger array\n+      temporary.  (#3 also ranks better than #5 for the same reason--cf. core\n+      issue 1307).  */\n+\n+int\n+main ()\n+{\n+  if (b({1}) != 3)\n+    __builtin_abort ();\n+}"}, {"sha": "c2389c822733193677b01030119c44937f6cedaa", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv6.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv6.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do run { target c++2a } }\n+\n+// Ranking of reference initialization conversions\n+\n+int f1(const int(&)[]) { return 1; }\n+int f1(const int(&)[1]) { return 2; }\n+\n+int f2(const int(&)[]) { return 1; }\n+int f2(int(&)[1]) { return 2; }\n+\n+int f3(int(&)[]) { return 1; }\n+int f3(const int(&)[1]) { return 2; }\n+\n+const int arr[1] = { 42 };\n+\n+int\n+main ()\n+{\n+  if (f1(arr) != 2)\n+    __builtin_abort ();\n+\n+  if (f2(arr) != 1)\n+    __builtin_abort ();\n+\n+  if (f3(arr) != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "07c709ff10f263de57f27de6297cb5d7709e9cb1", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv7.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv7.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/69531 - DR 1307, Overload resolution based on size of array init-list.\n+// { dg-do run { target c++2a } }\n+\n+int f(int const(&)[]) { return 1; }\n+int f(int const(&)[2]) { return 2; }\n+\n+int f2(int const(&)[]) { return 1; }\n+int f2(int const(&)[1]) { return 2; }\n+\n+int f3(int const(&)[]) { return 1; }\n+int f3(int const(&)[1]) { return 2; }\n+int f3(int const(&)[2]) { return 3; }\n+\n+int main ()\n+{\n+  if (f ({}) != 1)\n+    __builtin_abort ();\n+  if (f ({1}) != 1)\n+    __builtin_abort ();\n+  if (f ({1, 2}) != 2)\n+    __builtin_abort ();\n+\n+  if (f2 ({}) != 1)\n+    __builtin_abort ();\n+  if (f2 ({1}) != 2)\n+    __builtin_abort ();\n+\n+  if (f3 ({}) != 1)\n+    __builtin_abort ();\n+  if (f3 ({1}) != 2)\n+    __builtin_abort ();\n+  if (f3 ({1, 2}) != 3)\n+    __builtin_abort ();\n+}"}, {"sha": "635c7679a21ba30b80007863726e57f28e8ab2bc", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv8.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv8.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/69531 - DR 1307, Overload resolution based on size of array init-list.\n+// { dg-do run { target c++2a } }\n+// Example from [over.ics.rank].\n+\n+int f(int    (&&)[] ) { return 1; }    // #1\n+int f(double (&&)[] ) { return 2; }    // #2\n+int f(int    (&&)[2]) { return 3; }    // #3\n+\n+int\n+main ()\n+{\n+  // Calls #1: Better than #2 due to conversion, better than #3 due to bounds.\n+  if (f({1}) != 1)\n+     __builtin_abort ();\n+  // Calls #2: Identity conversion is better than floating-integral conversion.\n+  if (f({1.0}) != 2)\n+     __builtin_abort ();\n+  // Calls #2: Identity conversion is better than floating-integral conversion.\n+  if (f({1.0, 2.0}) != 2)\n+     __builtin_abort ();\n+  // Calls #3: Converting to array of known bound is better than to unknown\n+  // bound, and an identity conversion is better than floating-integral\n+  // conversion.\n+  if (f({1, 2}) != 3)\n+     __builtin_abort ();\n+}"}, {"sha": "82f615db2e7292d6da246b35cbaedd8eaaac4c41", "filename": "gcc/testsuite/g++.dg/cpp2a/array-conv9.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Farray-conv9.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/91364 - Implement P0388R4: Permit conversions to arrays of unknown bound.\n+// { dg-do compile { target c++2a } }\n+\n+int arr[1];\n+extern int arr2[];\n+\n+void\n+test ()\n+{\n+  int (&r)[1] = const_cast<int(&)[1]>(arr);\n+  int (&r2)[] = const_cast<int(&)[]>(arr); // { dg-error \"invalid\" }\n+  int (&r3)[1] = (int(&)[1]) arr;\n+  int (&r4)[] = (int(&)[]) arr;\n+  int (&r5)[1] = static_cast<int(&)[1]>(arr);\n+  int (&r6)[] = static_cast<int(&)[]>(arr);\n+\n+  // Try c_cast_p.\n+  int(*p1)[] = (int(*)[]) &arr;\n+  int(*p2)[1] = (int(*)[]) &arr; // { dg-error \"cannot convert\" }\n+  int(*p3)[] = (int(*)[1]) &arr;\n+  int(*p4)[] = (int(*)[1]) &arr2;\n+  int(*p5)[] = (int(*)[]) (int(*)[1]) &arr;\n+  int(*p6)[] = (int(*)[1]) (int(*)[]) &arr;\n+  int(*p7)[] = static_cast<int(*)[]>(&arr);\n+  int(*p8)[] = static_cast<int(*)[1]>(&arr);\n+  int(*p9)[] = static_cast<int(*)[1]>(&arr2); // { dg-error \"invalid\" }\n+}"}, {"sha": "c3b1ab56282e75c5ffbbaebb286344c0d4591443", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900321_01.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900321_01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900321_01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900321_01.C?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -20,7 +20,7 @@ void function_0 ()\n {\n   // we miss the first two because typeck.c (comp_array_types) deems\n   // it okay if one of the sizes is null\n-  ptr_to_array_of_ints = ptr_to_array_of_3_ints;\t// { dg-error \"\" } \n+  ptr_to_array_of_ints = ptr_to_array_of_3_ints;\t// { dg-error \"conversions to arrays\" \"\" { target c++17_down } }\n   ptr_to_array_of_3_ints = ptr_to_array_of_ints;\t// { dg-error \"\" } \n \n   ptr_to_array_of_3_ints = ptr_to_array_of_5_ints;\t// { dg-error \"\" } "}, {"sha": "8b7443c17e8e6c52ce49c29062c7345bbd1798be", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -1,3 +1,11 @@\n+2019-10-09  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/91364 - P0388R4: Permit conversions to arrays of\tunknown bound.\n+\tPR c++/69531 - DR 1307: Differently bounded array parameters.\n+\tPR c++/88128 - DR 330: Qual convs and pointers to arrays of pointers.\n+\t* testsuite/23_containers/span/lwg3255.cc: Adjust test to match the\n+\tpost-P0388R4 behavior.\n+\n 2019-10-09  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/91057"}, {"sha": "bab7da3bf19f89e3aad6ecc6f046209262847afa", "filename": "libstdc++-v3/testsuite/23_containers/span/lwg3255.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Flwg3255.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e0a492af5bec8ffa2ec5d99c4858df50d22c16/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Flwg3255.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Flwg3255.cc?ref=89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "patch": "@@ -28,8 +28,7 @@ using std::is_constructible_v;\n \n // LWG 3255 span's array constructor is too strict\n \n-// FIXME: remove '!' from next line when P0388R4 is implemented:\n-static_assert( ! is_constructible_v<span<const int* const>, array<int*, 2>> );\n+static_assert( is_constructible_v<span<const int* const>, array<int*, 2>> );\n static_assert( is_constructible_v<span<const int>, array<const int, 4>> );\n \n static_assert( is_constructible_v<span<int, 1>, int(&)[1]> );"}]}