{"sha": "73e61092e104b922e0f83f63fe988795cebe46bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNlNjEwOTJlMTA0YjkyMmUwZjgzZjYzZmU5ODg3OTVjZWJlNDZiZg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-01-17T00:37:47Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-01-17T00:37:47Z"}, "message": "[multiple changes]\n\n2004-01-15  Geoffrey Keating  <geoffk@apple.com>\n\n\t* Makefile.in (MD5_H): New.\n\t(fold-const.o): Depend on md5.h.\n\t(dwarf2out.o): Likewise.\n\t(cppfiles.o): Likewise.\n\t* cppfiles.c: Include md5.h.\n\t(should_stack_file): Check against list read from PCH file.\n\t(struct pchf_data): New.\n\t(pchf): New variable.\n\t(struct pchf_adder_info): New.\n\t(pchf_adder): New.\n\t(pchf_save_compare): New.\n\t(_cpp_save_file_entries): New.\n\t(_cpp_read_file_entries): New.\n\t(struct pchf_compare_data): New.\n\t(pchf_compare): New.\n\t(check_file_against_entries): New.\n\t* cpphash.h (_cpp_save_file_entries): Prototype.\n\t(_cpp_read_file_entries): Prototype.\n\t* cpppch.c (cpp_write_pch_state): Write the list of headers.\n\t(cpp_read_state): Read the list of headers.\n\nIndex: testsuite/ChangeLog\n2004-01-16  Geoffrey Keating  <geoffk@apple.com>\n\n\t* gcc.dg/pch/import-1.c: New.\n\t* gcc.dg/pch/import-1.hs: New.\n\t* gcc.dg/pch/import-1a.h: New.\n\t* gcc.dg/pch/import-1b.h: New.\n\t* gcc.dg/pch/import-1c.h: New.\n\nFrom-SVN: r76016", "tree": {"sha": "da307f1c660e3c776f8f7737d4a9ccdfec5ed91e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da307f1c660e3c776f8f7737d4a9ccdfec5ed91e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73e61092e104b922e0f83f63fe988795cebe46bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e61092e104b922e0f83f63fe988795cebe46bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73e61092e104b922e0f83f63fe988795cebe46bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e61092e104b922e0f83f63fe988795cebe46bf/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "790b6144d14ef4c6cc8559e0399e724e6f855092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/790b6144d14ef4c6cc8559e0399e724e6f855092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/790b6144d14ef4c6cc8559e0399e724e6f855092"}], "stats": {"total": 339, "additions": 328, "deletions": 11}, "files": [{"sha": "b952881f562ce78c5c1b1fbad2a804334f509239", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -1,3 +1,26 @@\n+2004-01-16  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* Makefile.in (MD5_H): New.\n+\t(fold-const.o): Depend on md5.h.\n+\t(dwarf2out.o): Likewise.\n+\t(cppfiles.o): Likewise.\n+\t* cppfiles.c: Include md5.h.\n+\t(should_stack_file): Check against list read from PCH file.\n+\t(struct pchf_data): New.\n+\t(pchf): New variable.\n+\t(struct pchf_adder_info): New.\n+\t(pchf_adder): New.\n+\t(pchf_save_compare): New.\n+\t(_cpp_save_file_entries): New.\n+\t(_cpp_read_file_entries): New.\n+\t(struct pchf_compare_data): New.\n+\t(pchf_compare): New.\n+\t(check_file_against_entries): New.\n+\t* cpphash.h (_cpp_save_file_entries): Prototype.\n+\t(_cpp_read_file_entries): Prototype.\n+\t* cpppch.c (cpp_write_pch_state): Write the list of headers.\n+\t(cpp_read_state): Read the list of headers.\n+\n 2004-01-17  Jan Hubicka  <jh@suse.cz>\n \n \t* c-common.c (c_estimate_num_insns_1): Handle builtin_constant_p and"}, {"sha": "e3eb186a9c384f0916409fcf7c36f40d623562ad", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -2,7 +2,7 @@\n # Run 'configure' to generate Makefile from Makefile.in\n \n # Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,\n-# 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+# 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -340,6 +340,7 @@ OBSTACK_H   = $(srcdir)/../include/obstack.h\n SPLAY_TREE_H= $(srcdir)/../include/splay-tree.h\n FIBHEAP_H   = $(srcdir)/../include/fibheap.h\n PARTITION_H = $(srcdir)/../include/partition.h\n+MD5_H\t    = $(srcdir)/../include/md5.h\n \n # Default native SYSTEM_HEADER_DIR, to be overridden by targets.\n NATIVE_SYSTEM_HEADER_DIR = /usr/include\n@@ -1502,8 +1503,9 @@ print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    flags.h function.h $(EXPR_H) $(RTL_H) toplev.h $(GGC_H) $(TM_P_H) $(TARGET_H) \\\n    langhooks.h\n-fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   flags.h real.h toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) $(GGC_H) $(TM_P_H) langhooks.h\n+fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) flags.h real.h toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) $(GGC_H) \\\n+   $(TM_P_H) langhooks.h $(MD5_H)\n diagnostic.o : diagnostic.c $(DIAGNOSTIC_H) real.h \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(TM_P_H) flags.h $(GGC_H) \\\n    input.h toplev.h intl.h langhooks.h $(LANGHOOKS_DEF_H)\n@@ -1596,11 +1598,12 @@ sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n    flags.h function.h $(EXPR_H) output.h hard-reg-set.h $(REGS_H) real.h \\\n    insn-config.h xcoffout.h c-pragma.h $(GGC_H) $(TARGET_H) \\\n    sdbout.h toplev.h $(TM_P_H) except.h debug.h langhooks.h gt-sdbout.h\n-dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(RTL_H) dwarf2.h debug.h flags.h insn-config.h reload.h output.h $(DIAGNOSTIC_H) real.h \\\n-   hard-reg-set.h $(REGS_H) $(EXPR_H) libfuncs.h toplev.h dwarf2out.h varray.h \\\n-   $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) \\\n-   gt-dwarf2out.h $(TARGET_H) cgraph.h\n+dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) $(RTL_H) dwarf2.h debug.h flags.h insn-config.h reload.h \\\n+   output.h $(DIAGNOSTIC_H) real.h hard-reg-set.h $(REGS_H) $(EXPR_H) \\\n+   libfuncs.h toplev.h dwarf2out.h varray.h $(GGC_H) except.h dwarf2asm.h \\\n+   $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h $(TARGET_H) cgraph.h \\\n+   $(MD5_H)\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) flags.h $(RTL_H) \\\n    $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) gt-dwarf2asm.h\n vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -2342,7 +2345,7 @@ cppmacro.o: cppmacro.c $(LIBCPP_DEPS)\n cpplib.o:   cpplib.c   $(LIBCPP_DEPS)\n cpphash.o:  cpphash.c  $(LIBCPP_DEPS)\n cpptrad.o:  cpptrad.c  $(LIBCPP_DEPS)\n-cppfiles.o: cppfiles.c $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h\n+cppfiles.o: cppfiles.c $(LIBCPP_DEPS) $(HASHTAB_H) $(MD5_H) mkdeps.h\n cppinit.o:  cppinit.c  $(LIBCPP_DEPS) mkdeps.h\n cpppch.o:   cpppch.c   $(LIBCPP_DEPS) mkdeps.h\n "}, {"sha": "f7fdec6b5e63b31808401ee40b4e0440272fc9bb", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 232, "deletions": 1, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -1,6 +1,6 @@\n /* Part of CPP library.  File handling.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998,\n-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -28,6 +28,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"mkdeps.h\"\n #include \"hashtab.h\"\n+#include \"md5.h\"\n #include <dirent.h>\n \n /* Variable length record files on VMS will have a stat size that includes\n@@ -180,6 +181,10 @@ static char *remap_filename (cpp_reader *pfile, _cpp_file *file);\n static char *append_file_to_dir (const char *fname, cpp_dir *dir);\n static bool validate_pch (cpp_reader *, _cpp_file *file, const char *pchname);\n static bool include_pch_p (_cpp_file *file);\n+static int pchf_adder (void **slot, void *data);\n+static int pchf_save_compare (const void *e1, const void *e2);\n+static int pchf_compare (const void *d_p, const void *e_p);\n+static bool check_file_against_entries (cpp_reader *, _cpp_file *, bool);\n \n /* Given a filename in FILE->PATH, with the empty string interpreted\n    as <stdin>, open it.\n@@ -590,6 +595,19 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import)\n   if (!read_file (pfile, file))\n     return false;\n \n+  /* Check the file against the PCH file.  This is done before\n+     checking against files we've already seen, since it may save on\n+     I/O.  */\n+  if (check_file_against_entries (pfile, file, import))\n+    {\n+      /* If this isn't a #import, but yet we can't include the file,\n+\t that means that it was #import-ed in the PCH file,\n+\t so we can never include it again.  */\n+      if (! import)\n+\t_cpp_mark_file_once_only (pfile, file);\n+      return false;\n+    }\n+\n   /* Now we've read the file's contents, we can stack it if there\n      are no once-only files.  */\n   if (!pfile->seen_once_only)\n@@ -1249,3 +1267,216 @@ validate_pch (cpp_reader *pfile, _cpp_file *file, const char *pchname)\n   file->path = saved_path;\n   return valid;\n }\n+\f\n+/* This datastructure holds the list of header files that were seen\n+   while the PCH was being built.  The 'entries' field is kept sorted\n+   in memcmp() order; yes, this means that on little-endian systems,\n+   it's sorted initially by the least-significant byte of 'size', but\n+   that's OK.  The code does rely on having entries with the same size\n+   next to each other.  */\n+\n+struct pchf_data {\n+  /* Number of pchf_entry structures.  */\n+  size_t count;\n+\n+  /* Are there any values with once_only set?\n+     This is used as an optimisation, it means we don't have to search\n+     the structure if we're processing a regular #include.  */\n+  bool have_once_only;\n+  \n+  struct pchf_entry {\n+    /* The size of this file.  This is used to save running a MD5 checksum\n+       if the sizes don't match.  */\n+    off_t size;\n+    /* The MD5 checksum of this file.  */\n+    unsigned char sum[16];\n+    /* Is this file to be included only once?  */\n+    bool once_only;\n+  } entries[1];\n+};\n+\n+static struct pchf_data *pchf;\n+\n+/* Data for pchf_addr.  */\n+struct pchf_adder_info \n+{\n+  cpp_reader *pfile;\n+  struct pchf_data *d;\n+};\n+\n+/* A hash traversal function to add entries into DATA->D.  */\n+\n+static int\n+pchf_adder (void **slot, void *data)\n+{\n+  struct file_hash_entry *h = (struct file_hash_entry *) *slot;\n+  struct pchf_adder_info *i = (struct pchf_adder_info *) data;\n+\n+  if (h->start_dir != NULL && h->u.file->stack_count != 0)\n+    {\n+      struct pchf_data *d = i->d;\n+      _cpp_file *f = h->u.file;\n+      size_t count = d->count++;\n+\n+      /* This should probably never happen, since if a read error occurred\n+\t the PCH file shouldn't be written...  */\n+      if (f->dont_read || f->err_no)\n+\treturn 1;\n+      \n+      d->entries[count].once_only = f->once_only;\n+      d->have_once_only |= f->once_only;\n+      if (f->buffer_valid)\n+\t  md5_buffer ((const char *)f->buffer, \n+\t\t      f->st.st_size, d->entries[count].sum);\n+      else\n+\t{\n+\t  FILE *ff;\n+\t  int oldfd = f->fd;\n+\n+\t  if (!open_file (f))\n+\t    {\n+\t      open_file_failed (i->pfile, f);\n+\t      return 0;\n+\t    }\n+\t  ff = fdopen (f->fd, \"rb\");\n+\t  md5_stream (ff, d->entries[count].sum);\n+\t  fclose (ff);\n+\t  f->fd = oldfd;\n+\t}\n+      d->entries[count].size = f->st.st_size;\n+    }\n+  return 1;\n+}\n+\n+/* A qsort ordering function for pchf_entry structures.  */\n+\n+static int\n+pchf_save_compare (const void *e1, const void *e2)\n+{\n+  return memcmp (e1, e2, sizeof (struct pchf_entry));\n+}\n+\n+/* Create and write to F a pchf_data structure.  */\n+\n+bool\n+_cpp_save_file_entries (cpp_reader *pfile, FILE *f)\n+{\n+  size_t count = 0;\n+  struct pchf_data *result;\n+  size_t result_size;\n+  struct pchf_adder_info pai;\n+  \n+  count = htab_elements (pfile->file_hash);\n+  result_size = (sizeof (struct pchf_data) \n+\t\t + sizeof (struct pchf_entry) * (count - 1));\n+  result = xcalloc (result_size, 1);\n+  \n+  result->count = 0;\n+  result->have_once_only = false;\n+  \n+  pai.pfile = pfile;\n+  pai.d = result;\n+  htab_traverse (pfile->file_hash, pchf_adder, &pai);\n+\n+  result_size = (sizeof (struct pchf_data)\n+                 + sizeof (struct pchf_entry) * (result->count - 1));\n+  \n+  qsort (result->entries, result->count, sizeof (struct pchf_entry),\n+\t pchf_save_compare);\n+\n+  return fwrite (result, result_size, 1, f) == 1;\n+}\n+\n+/* Read the pchf_data structure from F.  */\n+\n+bool\n+_cpp_read_file_entries (cpp_reader *pfile ATTRIBUTE_UNUSED, FILE *f)\n+{\n+  struct pchf_data d;\n+  \n+  if (fread (&d, sizeof (struct pchf_data) - sizeof (struct pchf_entry), 1, f)\n+       != 1)\n+    return false;\n+  \n+  pchf = xmalloc (sizeof (struct pchf_data)\n+\t\t  + sizeof (struct pchf_entry) * (d.count - 1));\n+  memcpy (pchf, &d, sizeof (struct pchf_data) - sizeof (struct pchf_entry));\n+  if (fread (pchf->entries, sizeof (struct pchf_entry), d.count, f)\n+      != d.count)\n+    return false;\n+  return true;\n+}\n+\n+/* The parameters for pchf_compare.  */\n+\n+struct pchf_compare_data\n+{\n+  /* The size of the file we're looking for.  */\n+  off_t size;\n+\n+  /* The MD5 checksum of the file, if it's been computed.  */\n+  unsigned char sum[16];\n+\n+  /* Is SUM valid?  */\n+  bool sum_computed;\n+\n+  /* Do we need to worry about entries that don't have ONCE_ONLY set?  */\n+  bool check_included;\n+  \n+  /* The file that we're searching for.  */\n+  _cpp_file *f;\n+};\n+\n+/* bsearch comparison function; look for D_P in E_P.  */\n+\n+static int\n+pchf_compare (const void *d_p, const void *e_p)\n+{\n+  const struct pchf_entry *e = (const struct pchf_entry *)e_p;\n+  struct pchf_compare_data *d = (struct pchf_compare_data *)d_p;\n+  int result;\n+  \n+  result = memcmp (&d->size, &e->size, sizeof (off_t));\n+  if (result != 0)\n+    return result;\n+  \n+  if (! d->sum_computed)\n+    {\n+      _cpp_file *const f = d->f;\n+      \n+      md5_buffer ((const char *)f->buffer, f->st.st_size, d->sum);\n+      d->sum_computed = true;\n+    }\n+\n+  result = memcmp (d->sum, e->sum, 16);\n+  if (result != 0)\n+    return result;\n+\n+  if (d->check_included || e->once_only)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+/* Check that F is not in a list read from a PCH file (if any).  \n+   Assumes that f->buffer_valid is true.  Return TRUE if the file\n+   should not be read.  */\n+\n+static bool\n+check_file_against_entries (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t\t\t    _cpp_file *f,\n+\t\t\t    bool check_included)\n+{\n+  struct pchf_compare_data d;\n+  \n+  if (pchf == NULL\n+      || (! check_included && ! pchf->have_once_only))\n+    return false;\n+\n+  d.size = f->st.st_size;\n+  d.sum_computed = false;\n+  d.f = f;\n+  d.check_included = check_included;\n+  return bsearch (&d, pchf->entries, pchf->count, sizeof (struct pchf_entry),\n+\t\t  pchf_compare) != NULL;\n+}"}, {"sha": "ddac5665cd4b9ff838f16f72d538fa6186e47873", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -530,6 +530,8 @@ extern void _cpp_report_missing_guards (cpp_reader *);\n extern void _cpp_init_files (cpp_reader *);\n extern void _cpp_cleanup_files (cpp_reader *);\n extern void _cpp_pop_file_buffer (cpp_reader *, struct _cpp_file *);\n+extern bool _cpp_save_file_entries (cpp_reader *pfile, FILE *f);\n+extern bool _cpp_read_file_entries (cpp_reader *, FILE *);\n \n /* In cppexp.c */\n extern bool _cpp_parse_expr (cpp_reader *);"}, {"sha": "8cb5bcff87a4855c8cb172aafe7e8ccb01d61be4", "filename": "gcc/cpppch.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Fcpppch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Fcpppch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpppch.c?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -1,5 +1,5 @@\n /* Part of CPP library.  (Precompiled header reading/writing.)\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -366,6 +366,12 @@ cpp_write_pch_state (cpp_reader *r, FILE *f)\n       return -1;\n     }\n \n+  if (! _cpp_save_file_entries (r, f))\n+    {\n+      cpp_errno (r, CPP_DL_ERROR, \"while writing precompiled header\");\n+      return -1;\n+    }\n+\n   return 0;\n }\n \n@@ -709,6 +715,9 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n       != 0)\n     goto error;\n \n+  if (! _cpp_read_file_entries (r, f))\n+    goto error;\n+\n   return 0;\n   \n  error:"}, {"sha": "bb7015e6825f6c5851cc0a7943bcfd19287ccf93", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -1,3 +1,11 @@\n+2004-01-16  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/import-1.c: New.\n+\t* gcc.dg/pch/import-1.hs: New.\n+\t* gcc.dg/pch/import-1a.h: New.\n+\t* gcc.dg/pch/import-1b.h: New.\n+\t* gcc.dg/pch/import-1c.h: New.\n+\n 2004-01-16  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13574"}, {"sha": "09460af057ed47007fd68afc6411b370d7fd57e5", "filename": "gcc/testsuite/gcc.dg/pch/import-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1.c?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-options \"-I. -I $srcdir/gcc.dg/pch\" } */\n+#include \"import-1.h\"\n+#include \"import-1a.h\"\n+#import \"import-1b.h\"\n+#include \"import-1c.h\"\n+\n+#ifndef IMPORT_1A\n+IMPORT_1A not defined\n+#endif\n+\n+#ifndef IMPORT_1B\n+IMPORT_1B not defined\n+#endif\n+\n+#ifndef IMPORT_1C\n+IMPORT_1C not defined\n+#endif\n+\n+#ifndef IMPORT_1\n+IMPORT_1 not defined\n+#endif"}, {"sha": "87d9ed92bea3ae6877f4094912df5cca1efacb5a", "filename": "gcc/testsuite/gcc.dg/pch/import-1.hs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1.hs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1.hs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1.hs?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-options \"-I. -I $srcdir/gcc.dg/pch\" } */\n+#import \"import-1a.h\"\n+#include \"import-1b.h\"\n+#include \"import-1c.h\"\n+#define IMPORT_1"}, {"sha": "d65336afe62f670cc219c5ce00d9e44531048810", "filename": "gcc/testsuite/gcc.dg/pch/import-1a.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1a.h?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -0,0 +1,5 @@\n+#ifdef IMPORT_1A\n+#error import-1a failure\n+#endif\n+#define IMPORT_1A\n+"}, {"sha": "0dd0c9a9d8577f0b90de7a0603ea57607338c78b", "filename": "gcc/testsuite/gcc.dg/pch/import-1b.h", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1b.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1b.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1b.h?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -0,0 +1,4 @@\n+#ifdef IMPORT_1B\n+#error import-1b failure\n+#endif\n+#define IMPORT_1B"}, {"sha": "1c16356cf9d9fc3b4225c8992a43350ef5e901b9", "filename": "gcc/testsuite/gcc.dg/pch/import-1c.h", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e61092e104b922e0f83f63fe988795cebe46bf/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fimport-1c.h?ref=73e61092e104b922e0f83f63fe988795cebe46bf", "patch": "@@ -0,0 +1,6 @@\n+#pragma once\n+#ifdef IMPORT_1C\n+#error import-1c failure\n+#endif\n+#define IMPORT_1C\n+"}]}