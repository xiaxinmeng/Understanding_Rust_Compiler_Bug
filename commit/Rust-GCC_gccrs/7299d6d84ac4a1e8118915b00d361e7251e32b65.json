{"sha": "7299d6d84ac4a1e8118915b00d361e7251e32b65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5OWQ2ZDg0YWM0YTFlODExODkxNWIwMGQzNjFlNzI1MWUzMmI2NQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-25T08:25:40Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-25T08:25:40Z"}, "message": "Test a new ASTFragment union representation", "tree": {"sha": "0a386081e0b3ef3b21dd1e4c11692af70a8b6878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a386081e0b3ef3b21dd1e4c11692af70a8b6878"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7299d6d84ac4a1e8118915b00d361e7251e32b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7299d6d84ac4a1e8118915b00d361e7251e32b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7299d6d84ac4a1e8118915b00d361e7251e32b65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7299d6d84ac4a1e8118915b00d361e7251e32b65/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "627121b6996146d7b14f2ad848f416682b1ce0fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/627121b6996146d7b14f2ad848f416682b1ce0fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/627121b6996146d7b14f2ad848f416682b1ce0fe"}], "stats": {"total": 257, "additions": 209, "deletions": 48}, "files": [{"sha": "1329978f0f5a43cebb011a646fa8c27e54d07825", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=7299d6d84ac4a1e8118915b00d361e7251e32b65", "patch": "@@ -1358,9 +1358,9 @@ TypeAlias::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n \n   str += \"\\n Type: \" + existing_type->as_string ();\n \n@@ -5398,7 +5398,7 @@ Attribute::check_cfg_predicate (const Session &session) const\n   if (!has_attr_input ()\n       || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\"))\n     return false;\n-  \n+\n   // assume that it has already been parsed\n   if (!is_parsed_to_meta_item ())\n     return false;\n@@ -5419,10 +5419,10 @@ Attribute::separate_cfg_attrs () const\n   return attr_input->separate_cfg_attrs ();\n }\n \n-bool \n-Attribute::is_parsed_to_meta_item () const \n-{ \n-  return has_attr_input () && attr_input->is_meta_item (); \n+bool\n+Attribute::is_parsed_to_meta_item () const\n+{\n+  return has_attr_input () && attr_input->is_meta_item ();\n }\n \n /* Visitor implementations - these are short but inlining can't happen anyway"}, {"sha": "46dde8c72be43dfeb217970f75a3478b8a22c641", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=7299d6d84ac4a1e8118915b00d361e7251e32b65", "patch": "@@ -363,7 +363,9 @@ class SimplePath\n };\n \n // path-to-string inverse comparison operator\n-inline bool operator!= (const SimplePath& lhs, const std::string &rhs) {\n+inline bool\n+operator!= (const SimplePath &lhs, const std::string &rhs)\n+{\n   return !(lhs == rhs);\n }\n \n@@ -632,7 +634,10 @@ class AttrInputMetaItemContainer : public AttrInput\n \n   // TODO: this mutable getter seems dodgy\n   std::vector<std::unique_ptr<MetaItemInner> > &get_items () { return items; }\n-  const std::vector<std::unique_ptr<MetaItemInner> > &get_items () const { return items; }\n+  const std::vector<std::unique_ptr<MetaItemInner> > &get_items () const\n+  {\n+    return items;\n+  }\n \n protected:\n   // Use covariance to implement clone function as returning this type\n@@ -1371,7 +1376,7 @@ class ExternalItem\n   virtual ExternalItem *clone_external_item_impl () const = 0;\n };\n \n-/* Data structure to store the data used in macro invocations and macro \n+/* Data structure to store the data used in macro invocations and macro\n  * invocations with semicolons. */\n struct MacroInvocData\n {\n@@ -1386,11 +1391,15 @@ struct MacroInvocData\n public:\n   std::string as_string () const;\n \n-  MacroInvocData (SimplePath path, DelimTokenTree token_tree) \n-    : path (std::move (path)), token_tree (std::move (token_tree)) {}\n-  \n+  MacroInvocData (SimplePath path, DelimTokenTree token_tree)\n+    : path (std::move (path)), token_tree (std::move (token_tree))\n+  {}\n+\n   // Copy constructor with vector clone\n-  MacroInvocData (const MacroInvocData &other) : path (other.path), token_tree (other.token_tree), parsed_to_meta_item (other.parsed_to_meta_item) {\n+  MacroInvocData (const MacroInvocData &other)\n+    : path (other.path), token_tree (other.token_tree),\n+      parsed_to_meta_item (other.parsed_to_meta_item)\n+  {\n     parsed_items.reserve (other.parsed_items.size ());\n     for (const auto &e : other.parsed_items)\n       parsed_items.push_back (e->clone_meta_item_inner ());\n@@ -1413,7 +1422,7 @@ struct MacroInvocData\n   // Move constructors\n   MacroInvocData (MacroInvocData &&other) = default;\n   MacroInvocData &operator= (MacroInvocData &&other) = default;\n-  \n+\n   // Invalid if path is empty, so base stripping on that.\n   void mark_for_strip () { path = SimplePath::create_empty (); }\n   bool is_marked_for_strip () const { return path.is_empty (); }\n@@ -1430,13 +1439,20 @@ struct MacroInvocData\n   SimplePath &get_path () { return path; }\n   const SimplePath &get_path () const { return path; }\n \n-  void set_meta_item_output (std::vector<std::unique_ptr<MetaItemInner> > new_items) \n-  { \n-    parsed_items = std::move (new_items); \n+  void\n+  set_meta_item_output (std::vector<std::unique_ptr<MetaItemInner> > new_items)\n+  {\n+    parsed_items = std::move (new_items);\n   }\n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items () { return parsed_items; }\n-  const std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items () const { return parsed_items; }\n+  std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items ()\n+  {\n+    return parsed_items;\n+  }\n+  const std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items () const\n+  {\n+    return parsed_items;\n+  }\n };\n \n /* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n@@ -1467,10 +1483,11 @@ class MacroInvocationSemi : public MacroItem,\n       delim_type (delim_type), token_trees (std::move (token_trees)),\n       locus (locus)\n   {}*/\n-  MacroInvocationSemi (MacroInvocData invoc_data, \n-            std::vector<Attribute> outer_attrs, Location locus) \n-    : outer_attrs (std::move (outer_attrs)), invoc_data (std::move (invoc_data)),\n-      locus (locus) {}\n+  MacroInvocationSemi (MacroInvocData invoc_data,\n+\t\t       std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      invoc_data (std::move (invoc_data)), locus (locus)\n+  {}\n \n   /*\n   // Copy constructor with vector clone\n@@ -1525,7 +1542,10 @@ class MacroInvocationSemi : public MacroItem,\n   bool is_marked_for_strip () const override { return path.is_empty (); }\n   */\n   void mark_for_strip () override { invoc_data.mark_for_strip (); }\n-  bool is_marked_for_strip () const override { return invoc_data.is_marked_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return invoc_data.is_marked_for_strip ();\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }"}, {"sha": "eeb8ecf60a4389af35e672ebcbc045aea2773415", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 137, "deletions": 6, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=7299d6d84ac4a1e8118915b00d361e7251e32b65", "patch": "@@ -349,19 +349,23 @@ class MacroInvocation : public TypeNoBounds,\n     : ExprWithoutBlock (std::move (outer_attrs)), path (std::move (path)),\n       token_tree (std::move (token_tree)), locus (locus)\n   {}*/\n-  MacroInvocation (MacroInvocData invoc_data, \n-        std::vector<Attribute> outer_attrs, Location locus) \n-    : ExprWithoutBlock (std::move (outer_attrs)), \n-      invoc_data (std::move (invoc_data)), locus (locus) {}\n- \n+  MacroInvocation (MacroInvocData invoc_data,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : ExprWithoutBlock (std::move (outer_attrs)),\n+      invoc_data (std::move (invoc_data)), locus (locus)\n+  {}\n+\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if path is empty, so base stripping on that.\n   void mark_for_strip () override { invoc_data.mark_for_strip (); }\n-  bool is_marked_for_strip () const override { return invoc_data.is_marked_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return invoc_data.is_marked_for_strip ();\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -586,6 +590,133 @@ class MetaListNameValueStr : public MetaItem\n   }\n };\n \n+/* A \"tagged union\" describing a single AST node. Due to technical difficulties\n+ * with unions, had to use raw pointers. */\n+struct SingleASTNode\n+{\n+  public:\n+    union {\n+      std::unique_ptr<Expr> expr;\n+      std::unique_ptr<Stmt> stmt;\n+      std::unique_ptr<Item> item;\n+      std::unique_ptr<Type> type;\n+      std::unique_ptr<Pattern> pattern;\n+      std::unique_ptr<TraitItem> trait_item;\n+      std::unique_ptr<InherentImplItem> inherent_impl_item;\n+      std::unique_ptr<TraitImplItem> trait_impl_item;\n+      std::unique_ptr<ExternalItem> external_item;\n+    };\n+\n+    enum tag_types {\n+      EXPR,\n+      STMT,\n+      ITEM,\n+      TYPE,\n+      PATTERN,\n+      TRAIT_ITEM,\n+      INHERENT_IMPL_ITEM,\n+      TRAIT_IMPL_ITEM,\n+      EXTERNAL_ITEM\n+      // TODO: other types like inside macro_rules? \n+    };\n+\n+    SingleASTNode (std::unique_ptr<Expr> expr) : tag (EXPR), expr (std::move (expr)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<Stmt> stmt) : tag (STMT), stmt (std::move (stmt)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<Item> item) : tag (ITEM), item (std::move (item)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<Type> type) : tag (TYPE), type (std::move (type)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<Pattern> pattern) : tag (PATTERN), pattern (std::move (pattern)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<TraitItem> trait_item) : tag (TRAIT_ITEM), trait_item (std::move (trait_item)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<InherentImplItem> inherent_impl_item) : tag (INHERENT_IMPL_ITEM), inherent_impl_item (std::move (inherent_impl_item)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item) : tag (TRAIT_IMPL_ITEM), trait_impl_item (std::move (trait_impl_item)) {\n+\n+    }\n+\n+    SingleASTNode (std::unique_ptr<ExternalItem> external_item) : tag (EXTERNAL_ITEM), external_item (std::move (external_item)) {\n+\n+    }\n+\n+    ~SingleASTNode () {\n+      switch (tag) {\n+        case EXPR:\n+          expr.~unique_ptr<Expr> ();\n+          break;\n+        case STMT:\n+          stmt.~unique_ptr<Stmt> ();\n+          break;\n+        case ITEM:\n+          item.~unique_ptr<Item> ();\n+          break;\n+        case TYPE:\n+          type.~unique_ptr<Type> ();\n+          break;\n+        case PATTERN:\n+          pattern.~unique_ptr<Pattern> ();\n+          break;\n+        case TRAIT_ITEM:\n+          trait_item.~unique_ptr<TraitItem> ();\n+          break;\n+        case INHERENT_IMPL_ITEM:\n+          inherent_impl_item.~unique_ptr<InherentImplItem> ();\n+          break;\n+        case TRAIT_IMPL_ITEM:\n+          trait_impl_item.~unique_ptr<TraitImplItem> ();\n+          break;\n+        case EXTERNAL_ITEM:\n+          external_item.~unique_ptr<ExternalItem> ();\n+          break;\n+        default:\n+          // should not happen\n+          gcc_unreachable ();\n+          break;\n+      }\n+    }\n+\n+  private:\n+    tag_types tag;\n+\n+};\n+\n+/* Basically, a \"fragment\" that can be incorporated into the AST, created as \n+ * a result of macro expansion. Really annoying to work with due to the fact \n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment. */\n+struct ASTFragment\n+{\n+private:\n+  /* basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create \n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance. */\n+\n+  std::vector<SingleASTNode> nodes;\n+\n+public:\n+  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n+};\n+\n // Object that parses macros from a token stream.\n /* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n  * attributes, I believe */"}, {"sha": "02dcf87454331063feb447f92344264d98a9b2c6", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=7299d6d84ac4a1e8118915b00d361e7251e32b65", "patch": "@@ -3561,17 +3561,18 @@ MacroExpander::parse_macro_to_meta_item (AST::MacroInvocData &invoc)\n \n   std::unique_ptr<AST::AttrInputMetaItemContainer> converted_input (\n     invoc.get_delim_tok_tree ().parse_to_meta_item ());\n-  \n-  if (converted_input == nullptr) \n-  {\n-    fprintf (stderr, \"DEBUG: failed to parse macro to meta item\\n\");\n-    // TODO: do something now? is this an actual error?\n-  } \n+\n+  if (converted_input == nullptr)\n+    {\n+      fprintf (stderr, \"DEBUG: failed to parse macro to meta item\\n\");\n+      // TODO: do something now? is this an actual error?\n+    }\n   else\n-  {\n-    std::vector<std::unique_ptr<AST::MetaItemInner> > meta_items (std::move (converted_input->get_items ()));\n-    invoc.set_meta_item_output (std::move (meta_items));\n-  }\n+    {\n+      std::vector<std::unique_ptr<AST::MetaItemInner> > meta_items (\n+\tstd::move (converted_input->get_items ()));\n+      invoc.set_meta_item_output (std::move (meta_items));\n+    }\n }\n \n AST::Literal\n@@ -3583,17 +3584,23 @@ MacroExpander::expand_cfg_macro (AST::MacroInvocData &invoc)\n \n   parse_macro_to_meta_item (invoc);\n \n-  // TODO: assuming that cfg! macros can only have one meta item inner, like cfg attributes\n-  if (invoc.get_meta_items ().size () != 1) \n+  /* TODO: assuming that cfg! macros can only have one meta item inner, like cfg\n+   * attributes */\n+  if (invoc.get_meta_items ().size () != 1)\n     return AST::Literal::create_error ();\n-  \n+\n   bool result = invoc.get_meta_items ()[0]->check_cfg_predicate (session);\n   if (result)\n     return AST::Literal (\"true\", AST::Literal::BOOL);\n-  else \n+  else\n     return AST::Literal (\"false\", AST::Literal::BOOL);\n }\n \n+AST::ASTFragment \n+MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc, AST::MacroRulesDefinition &rules_def) {\n+  \n+}\n+\n void\n MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n {"}, {"sha": "66e506d91ba6a41a29ee7dd13621ff409969f65b", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=7299d6d84ac4a1e8118915b00d361e7251e32b65", "patch": "@@ -16,9 +16,9 @@ struct ExpansionCfg\n {\n   // features?\n   unsigned int recursion_limit = 50; // TODO: determine default recursion limit\n-\t\t\t\t// trace macros?\n-\t\t\t\t// should test?\n-\t\t\t\t// more default stuff?\n+\t\t\t\t     // trace macros?\n+\t\t\t\t     // should test?\n+\t\t\t\t     // more default stuff?\n };\n \n // Object used to store shared data (between functions) for macro expansion.\n@@ -41,6 +41,9 @@ struct MacroExpander\n   // should this be public or private?\n   void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n+  // Expands a single declarative macro. \n+  AST::ASTFragment expand_decl_macro (AST::MacroInvocData &invoc, AST::MacroRulesDefinition &rules_def);\n+\n   void expand_cfg_attrs (std::vector<AST::Attribute> &attrs);\n   bool fails_cfg (const std::vector<AST::Attribute> &attr) const;\n   bool fails_cfg_with_expand (std::vector<AST::Attribute> &attrs) const;"}, {"sha": "974e34697b86a50e85b34ea53f1c680c25466c25", "filename": "gcc/testsuite/rust.test/compilable/arrays3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299d6d84ac4a1e8118915b00d361e7251e32b65/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays3.rs?ref=7299d6d84ac4a1e8118915b00d361e7251e32b65", "previous_filename": "gcc/testsuite/rust.test/compilable/arrays2.rs"}]}