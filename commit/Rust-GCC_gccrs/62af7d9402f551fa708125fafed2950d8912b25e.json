{"sha": "62af7d9402f551fa708125fafed2950d8912b25e", "node_id": "C_kwDOANBUbNoAKDYyYWY3ZDk0MDJmNTUxZmE3MDgxMjVmYWZlZDI5NTBkODkxMmIyNWU", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-03T00:45:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-03T00:45:47Z"}, "message": "Fix wrong code caulsed by retslot EAF flags propagation [PR103040]\n\nFixe (quite nasty) thinko in how I propagate EAF flags from callee\nto caller.  In this case some flags needs to be changed.  In particular\n  - EAF_NOT_RETURNED in callee does not really mean EAF_NOT_RETURNED in caller\n    since we speak of different return values\n  - if callee escapes the parametr, we caller may return it\n  - for retslot the rewritting is even bit more funny, since escaping to of\n    return slot to return slot is not really an escape, however escape of\n    argument to itself is.\n\nThis patch should correct all of the cases above and does fix the testcase from PR103040.\n\nBootstrapped/regtested x86_64 with all languages.  Also lto-bootstrapped.\n\ngcc/ChangeLog:\n\n\tPR ipa/103040\n\t* ipa-modref.c (callee_to_caller_flags): New function.\n\t(modref_eaf_analysis::analyze_ssa_name): Use it.\n\t(ipa_merge_modref_summary_after_inlining): Fix whitespace.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/torture/pr103040.C: New test.", "tree": {"sha": "6bbffaabf0fd0dd372077fd2914f5c922aeffb71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bbffaabf0fd0dd372077fd2914f5c922aeffb71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62af7d9402f551fa708125fafed2950d8912b25e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62af7d9402f551fa708125fafed2950d8912b25e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62af7d9402f551fa708125fafed2950d8912b25e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62af7d9402f551fa708125fafed2950d8912b25e/comments", "author": null, "committer": null, "parents": [{"sha": "b4df2dd3f47129f7936e21bb10fe9e8e2227ba3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4df2dd3f47129f7936e21bb10fe9e8e2227ba3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4df2dd3f47129f7936e21bb10fe9e8e2227ba3b"}], "stats": {"total": 172, "additions": 141, "deletions": 31}, "files": [{"sha": "db071d2212f0cb374ba9e8247063f0cee882e813", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 104, "deletions": 31, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62af7d9402f551fa708125fafed2950d8912b25e/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62af7d9402f551fa708125fafed2950d8912b25e/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=62af7d9402f551fa708125fafed2950d8912b25e", "patch": "@@ -1694,7 +1694,8 @@ class modref_eaf_analysis\n /* Call statements may return their parameters.  Consider argument number\n    ARG of USE_STMT and determine flags that can needs to be cleared\n    in case pointer possibly indirectly references from ARG I is returned.\n-   LATTICE, DEPTH and ipa are same as in analyze_ssa_name.  */\n+   LATTICE, DEPTH and ipa are same as in analyze_ssa_name.\n+   ARG is set to -1 for static chain.  */\n \n void\n modref_eaf_analysis::merge_call_lhs_flags (gcall *call, int arg,\n@@ -1708,30 +1709,56 @@ modref_eaf_analysis::merge_call_lhs_flags (gcall *call, int arg,\n \n   /* If we know that function returns given argument and it is not ARG\n      we can still be happy.  */\n-  int flags = gimple_call_return_flags (call);\n-  if ((flags & ERF_RETURNS_ARG)\n-      && (flags & ERF_RETURN_ARG_MASK) != arg)\n-    return;\n-\n-  int eaf_flags = gimple_call_arg_flags (call, arg);\n-\n-  if (eaf_flags & (EAF_NOT_RETURNED | EAF_UNUSED))\n-    return;\n+  if (arg >= 0)\n+    {\n+      int flags = gimple_call_return_flags (call);\n+      if ((flags & ERF_RETURNS_ARG)\n+\t  && (flags & ERF_RETURN_ARG_MASK) != arg)\n+\treturn;\n+    }\n \n   /* If return value is SSA name determine its flags.  */\n   if (TREE_CODE (gimple_call_lhs (call)) == SSA_NAME)\n     {\n       tree lhs = gimple_call_lhs (call);\n-      merge_with_ssa_name (name, lhs,\n-\t\t\t   (deref || (eaf_flags & EAF_NOT_RETURNED_DIRECTLY)));\n+      merge_with_ssa_name (name, lhs, deref);\n     }\n   /* In the case of memory store we can do nothing.  */\n-  else if (eaf_flags & EAF_NOT_RETURNED_DIRECTLY)\n+  else if (deref)\n     m_lattice[index].merge (deref_flags (0, false));\n   else\n     m_lattice[index].merge (0);\n }\n \n+/* CALL_FLAGS are EAF_FLAGS of the argument.  Turn them\n+   into flags for caller, update LATTICE of corresponding\n+   argument if needed.  */\n+\n+static int\n+callee_to_caller_flags (int call_flags, bool ignore_stores,\n+\t\t\tmodref_lattice &lattice)\n+{\n+  /* call_flags is about callee returning a value\n+     that is not the same as caller returning it.  */\n+  call_flags |= EAF_NOT_RETURNED\n+\t\t| EAF_NOT_RETURNED_DIRECTLY;\n+  /* TODO: We miss return value propagation.\n+     Be conservative and if value escapes to memory\n+     also mark it as escaping.  */\n+  if (!ignore_stores && !(call_flags & EAF_UNUSED))\n+    {\n+      if (!(call_flags & EAF_NOESCAPE))\n+\tlattice.merge (~(EAF_NOT_RETURNED | EAF_UNUSED));\n+      if (!(call_flags & (EAF_NODIRECTESCAPE | EAF_NOESCAPE)))\n+\tlattice.merge (~(EAF_NOT_RETURNED_DIRECTLY\n+\t\t\t | EAF_NOT_RETURNED\n+\t\t\t | EAF_UNUSED));\n+    }\n+  else\n+    call_flags |= ignore_stores_eaf_flags;\n+  return call_flags;\n+}\n+\n /* Analyze EAF flags for SSA name NAME and store result to LATTICE.\n    LATTICE is an array of modref_lattices.\n    DEPTH is a recursion depth used to make debug output prettier.\n@@ -1843,12 +1870,55 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t\t     may make LHS to escape.  See PR 98499.  */\n \t\t  if (gimple_call_return_slot_opt_p (call)\n \t\t      && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (call))))\n-\t\t    m_lattice[index].merge (gimple_call_retslot_flags (call));\n+\t\t    {\n+\t\t      int call_flags = gimple_call_retslot_flags (call);\n+\t\t      bool isretslot = false;\n+\n+\t\t      if (DECL_RESULT (current_function_decl)\n+\t\t\t  && DECL_BY_REFERENCE\n+\t\t\t\t(DECL_RESULT (current_function_decl)))\n+\t\t\tisretslot = ssa_default_def\n+\t\t\t\t\t (cfun,\n+\t\t\t\t\t  DECL_RESULT (current_function_decl))\n+\t\t\t\t\t == name;\n+\n+\t\t      /* Passing returnslot to return slot is special because\n+\t\t\t not_returned and escape has same meaning.\n+\t\t\t However passing arg to return slot is different.  If\n+\t\t\t the callee's return slot is returned it means that\n+\t\t\t arg is written to itself which is an escape.  */\n+\t\t      if (!isretslot)\n+\t\t\t{\n+\t\t\t  if (!(call_flags & (EAF_NOT_RETURNED | EAF_UNUSED)))\n+\t\t\t    m_lattice[index].merge (~(EAF_NOESCAPE\n+\t\t\t\t\t\t      | EAF_UNUSED));\n+\t\t\t  if (!(call_flags & (EAF_NOT_RETURNED_DIRECTLY\n+\t\t\t\t\t      | EAF_UNUSED\n+\t\t\t\t\t      | EAF_NOT_RETURNED)))\n+\t\t\t    m_lattice[index].merge (~(EAF_NODIRECTESCAPE\n+\t\t\t\t\t\t      | EAF_NOESCAPE\n+\t\t\t\t\t\t      | EAF_UNUSED));\n+\t\t\t  call_flags = callee_to_caller_flags\n+\t\t\t\t\t   (call_flags, false,\n+\t\t\t\t\t    m_lattice[index]);\n+\t\t\t}\n+\t\t      m_lattice[index].merge (call_flags);\n+\t\t    }\n \t\t}\n \n \t      if (gimple_call_chain (call)\n \t\t  && (gimple_call_chain (call) == name))\n-\t\tm_lattice[index].merge (gimple_call_static_chain_flags (call));\n+\t\t{\n+\t\t  int call_flags = gimple_call_static_chain_flags (call);\n+\t\t  if (!ignore_retval\n+\t\t       && !(call_flags & (EAF_NOT_RETURNED | EAF_UNUSED)))\n+\t\t    merge_call_lhs_flags (call, -1, name, false);\n+\t\t  call_flags = callee_to_caller_flags\n+\t\t\t\t   (call_flags, ignore_stores,\n+\t\t\t\t    m_lattice[index]);\n+\t\t  if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS)))\n+\t\t    m_lattice[index].merge (call_flags);\n+\t\t}\n \n \t      /* Process internal functions and right away.  */\n \t      bool record_ipa = m_ipa && !gimple_call_internal_p (call);\n@@ -1860,42 +1930,45 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t\t/* Name is directly passed to the callee.  */\n \t\tif (gimple_call_arg (call, i) == name)\n \t\t  {\n+\t\t    int call_flags = gimple_call_arg_flags (call, i);\n+\t\t    if (!ignore_retval && !(call_flags\n+\t\t\t\t\t    & (EAF_NOT_RETURNED | EAF_UNUSED)))\n+\t\t      merge_call_lhs_flags\n+\t\t\t      (call, i, name,\n+\t\t\t       call_flags & EAF_NOT_RETURNED_DIRECTLY);\n \t\t    if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS)))\n \t\t      {\n-\t\t\tint call_flags = gimple_call_arg_flags (call, i)\n-\t\t\t\t\t | EAF_NOT_RETURNED\n-\t\t\t\t\t | EAF_NOT_RETURNED_DIRECTLY;\n-\t\t\tif (ignore_stores)\n-\t\t\t  call_flags |= ignore_stores_eaf_flags;\n-\n+\t\t\tcall_flags = callee_to_caller_flags\n+\t\t\t\t\t (call_flags, ignore_stores,\n+\t\t\t\t\t  m_lattice[index]);\n \t\t\tif (!record_ipa)\n \t\t\t  m_lattice[index].merge (call_flags);\n \t\t\telse\n \t\t\t  m_lattice[index].add_escape_point (call, i,\n \t\t\t\t\t\t\t   call_flags, true);\n \t\t      }\n-\t\t    if (!ignore_retval)\n-\t\t      merge_call_lhs_flags (call, i, name, false);\n \t\t  }\n \t\t/* Name is dereferenced and passed to a callee.  */\n \t\telse if (memory_access_to (gimple_call_arg (call, i), name))\n \t\t  {\n+\t\t    int call_flags = deref_flags\n+\t\t\t    (gimple_call_arg_flags (call, i), ignore_stores);\n+\t\t    if (!ignore_retval\n+\t\t\t && !(call_flags & (EAF_NOT_RETURNED | EAF_UNUSED)))\n+\t\t      merge_call_lhs_flags (call, i, name, true);\n \t\t    if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n \t\t      m_lattice[index].merge_direct_load ();\n \t\t    else\n \t\t      {\n-\t\t\tint call_flags = deref_flags\n-\t\t\t   (gimple_call_arg_flags (call, i)\n-\t\t\t    | EAF_NOT_RETURNED\n-\t\t\t    | EAF_NOT_RETURNED_DIRECTLY, ignore_stores);\n+\t\t\tcall_flags = callee_to_caller_flags\n+\t\t\t\t\t (call_flags, ignore_stores,\n+\t\t\t\t\t  m_lattice[index]);\n \t\t\tif (!record_ipa)\n \t\t\t  m_lattice[index].merge (call_flags);\n \t\t\telse\n \t\t\t  m_lattice[index].add_escape_point (call, i,\n-\t\t\t\t\t\t\t   call_flags, false);\n+\t\t\t\t\t\t\t     call_flags, false);\n \t\t      }\n-\t\t    if (!ignore_retval)\n-\t\t      merge_call_lhs_flags (call, i, name, true);\n \t\t  }\n \t    }\n \t}\n@@ -4068,7 +4141,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t      needed = true;\n \t  }\n \tif (to_info_lto\n-     \t    && (int)to_info_lto->arg_flags.length () > ee->parm_index)\n+\t    && (int)to_info_lto->arg_flags.length () > ee->parm_index)\n \t  {\n \t    int flags = callee_info_lto\n \t\t\t&& callee_info_lto->arg_flags.length () > ee->arg"}, {"sha": "d63489528262cc2bb77034dde61daf0df24f601e", "filename": "gcc/testsuite/g++.dg/torture/pr103040.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62af7d9402f551fa708125fafed2950d8912b25e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr103040.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62af7d9402f551fa708125fafed2950d8912b25e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr103040.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr103040.C?ref=62af7d9402f551fa708125fafed2950d8912b25e", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do run }\n+// { dg-additional-options \"-fno-early-inlining\" }\n+struct S101273\n+{\n+    int x;\n+    S101273* impl;\n+    S101273(int x)\n+    {\n+        this->x = x;\n+        this->impl = this;\n+    }\n+    S101273(const S101273 &o)\n+    {\n+\tthis->x = o.x;\n+\tthis->impl = this;\n+    }\n+    ~S101273() { }\n+};\n+\n+S101273 makeS101273()\n+{\n+    return S101273(2);\n+}\n+\n+S101273 nrvo101273()\n+{\n+    S101273 ret = makeS101273();\n+    return ret;\n+}\n+\n+int main()\n+{\n+    auto nrvo = nrvo101273();\n+    if(&nrvo != nrvo.impl) __builtin_abort ();\n+\n+    return 0;\n+}"}]}