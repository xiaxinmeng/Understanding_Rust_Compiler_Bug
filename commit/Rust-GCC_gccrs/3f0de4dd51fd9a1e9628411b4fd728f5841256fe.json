{"sha": "3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YwZGU0ZGQ1MWZkOWExZTk2Mjg0MTFiNGZkNzI4ZjU4NDEyNTZmZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-04-15T21:04:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-04-29T18:33:39Z"}, "message": "c++: unset COMPOUND_LITERAL_P [PR100079]\n\nOnce a CONSTRUCTOR has been digested and used as an initializer, it no\nlonger represents a compound literal by itself, so we can clear the flag,\nletting us use it consistently to distinguish between digested and\nundigested initializer-lists.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h: Clarify comments.\n\t* pt.c (get_template_parm_object): Add assert.\n\t* semantics.c (finish_compound_literal): Clear TREE_HAS_CONSTRUCTOR.\n\t* tree.c (zero_init_expr_p): Check TREE_HAS_CONSTRUCTOR.\n\t* typeck2.c (store_init_value): Likewise.", "tree": {"sha": "af3e957d72b4b8b8005c81047b611418db51cc84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af3e957d72b4b8b8005c81047b611418db51cc84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efeca0ac4155b76ce713155f190422aac20537c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efeca0ac4155b76ce713155f190422aac20537c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efeca0ac4155b76ce713155f190422aac20537c5"}], "stats": {"total": 30, "additions": 19, "deletions": 11}, "files": [{"sha": "e80902a213992bdad4af52c55d3993c10bc578e3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "patch": "@@ -4407,7 +4407,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    When appearing in a SAVE_EXPR, it means that underneath\n    is a call to a constructor.\n \n-   When appearing in a CONSTRUCTOR, the expression is a\n+   When appearing in a CONSTRUCTOR, the expression is an unconverted\n    compound literal.\n \n    When appearing in a FIELD_DECL, it means that this field\n@@ -4419,7 +4419,9 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (TREE_CODE (NODE) == CONSTRUCTOR && TREE_TYPE (NODE) == init_list_type_node)\n \n /* True if NODE is a compound-literal, i.e., a brace-enclosed\n-   initializer cast to a particular type.  */\n+   initializer cast to a particular type.  This is mostly only set during\n+   template parsing; once the initializer has been digested into an actual\n+   value of the type, the expression is represented by a TARGET_EXPR.  */\n #define COMPOUND_LITERAL_P(NODE) \\\n   (TREE_CODE (NODE) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (NODE))\n "}, {"sha": "fc5065be4dbf7f99169ad17fc9736dacbccc146f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "patch": "@@ -7157,7 +7157,7 @@ get_template_parm_object (tree expr, tsubst_flags_t complain)\n     return error_mark_node;\n \n   /* This is no longer a compound literal.  */\n-  TREE_HAS_CONSTRUCTOR (expr) = 0;\n+  gcc_assert (!TREE_HAS_CONSTRUCTOR (expr));\n \n   tree name = mangle_template_parm_object (expr);\n   tree decl = get_global_binding (name);"}, {"sha": "319a3a816ed2a1c3bcd0370b6f8693a65f8cf8aa", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "patch": "@@ -3177,9 +3177,13 @@ finish_compound_literal (tree type, tree compound_literal,\n     }\n \n   /* Represent other compound literals with TARGET_EXPR so we produce\n-     an lvalue, but can elide copies.  */\n+     a prvalue, and can elide copies.  */\n   if (!VECTOR_TYPE_P (type))\n-    compound_literal = get_target_expr_sfinae (compound_literal, complain);\n+    {\n+      /* The CONSTRUCTOR is now an initializer, not a compound literal.  */\n+      TREE_HAS_CONSTRUCTOR (compound_literal) = false;\n+      compound_literal = get_target_expr_sfinae (compound_literal, complain);\n+    }\n \n   return compound_literal;\n }"}, {"sha": "3a20cd33fdc2eb0b7cd7486562e76f976ea1d24f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "patch": "@@ -4684,13 +4684,9 @@ zero_init_expr_p (tree t)\n     return null_member_pointer_value_p (t);\n   if (TREE_CODE (t) == CONSTRUCTOR)\n     {\n-      if (CONSTRUCTOR_IS_DEPENDENT (t)\n+      if (COMPOUND_LITERAL_P (t)\n \t  || BRACE_ENCLOSED_INITIALIZER_P (t))\n-\t/* Undigested, conversions might change the zeroness.\n-\n-\t   Other COMPOUND_LITERAL_P in template context are also undigested,\n-\t   but there isn't currently a way to distinguish between them and\n-\t   COMPOUND_LITERAL_P from non-template context that are digested.  */\n+\t/* Undigested, conversions might change the zeroness.  */\n \treturn false;\n       for (constructor_elt &elt : CONSTRUCTOR_ELTS (t))\n \t{"}, {"sha": "ce3016c780d492af6498cfb90ec4fd9d1b68c16e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f0de4dd51fd9a1e9628411b4fd728f5841256fe/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=3f0de4dd51fd9a1e9628411b4fd728f5841256fe", "patch": "@@ -818,6 +818,12 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n   /* Handle aggregate NSDMI in non-constant initializers, too.  */\n   value = replace_placeholders (value, decl);\n \n+  /* A COMPOUND_LITERAL_P CONSTRUCTOR is the syntactic form; by the time we get\n+     here it should have been digested into an actual value for the type.  */\n+  gcc_checking_assert (TREE_CODE (value) != CONSTRUCTOR\n+\t\t       || processing_template_decl\n+\t\t       || !TREE_HAS_CONSTRUCTOR (value));\n+\n   /* If the initializer is not a constant, fill in DECL_INITIAL with\n      the bits that are constant, and then return an expression that\n      will perform the dynamic initialization.  */"}]}