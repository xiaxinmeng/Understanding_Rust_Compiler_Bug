{"sha": "e8c487163ac2988dc7d90774e068d9c043193a3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThjNDg3MTYzYWMyOTg4ZGM3ZDkwNzc0ZTA2OGQ5YzA0MzE5M2EzZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-06-19T18:59:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-06-19T18:59:51Z"}, "message": "cp-tree.h (CONSTRUCTOR_NO_IMPLICIT_ZERO): Remove.\n\n\t* cp-tree.h (CONSTRUCTOR_NO_IMPLICIT_ZERO): Remove.\n\n\t* constexpr.c: Use CONSTRUCTOR_NO_CLEARING instead.\n\nFrom-SVN: r261758", "tree": {"sha": "3dc1a31bdf173a6c5d6cc767a9e735c5a1494411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dc1a31bdf173a6c5d6cc767a9e735c5a1494411"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8c487163ac2988dc7d90774e068d9c043193a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c487163ac2988dc7d90774e068d9c043193a3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8c487163ac2988dc7d90774e068d9c043193a3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c487163ac2988dc7d90774e068d9c043193a3d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e570cf8b6e47bc3ee9031eae70acf57bc5fd655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e570cf8b6e47bc3ee9031eae70acf57bc5fd655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e570cf8b6e47bc3ee9031eae70acf57bc5fd655"}], "stats": {"total": 51, "additions": 24, "deletions": 27}, "files": [{"sha": "430b4352ca9072262885f563fc3cfc4df72289fe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c487163ac2988dc7d90774e068d9c043193a3d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c487163ac2988dc7d90774e068d9c043193a3d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e8c487163ac2988dc7d90774e068d9c043193a3d", "patch": "@@ -1,5 +1,8 @@\n 2018-06-19  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-tree.h (CONSTRUCTOR_NO_IMPLICIT_ZERO): Remove.\n+\t* constexpr.c: Use CONSTRUCTOR_NO_CLEARING instead.\n+\n \tPR c++/86192 - ICE with anonymous union passed to template.\n \t* pt.c (tsubst_expr) [DECL_EXPR]: Handle an anonymous union type\n \tused to declare a named variable."}, {"sha": "216eecd4b06558d7386b12eeda8a3e77dfd86bc1", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c487163ac2988dc7d90774e068d9c043193a3d/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c487163ac2988dc7d90774e068d9c043193a3d/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=e8c487163ac2988dc7d90774e068d9c043193a3d", "patch": "@@ -1445,14 +1445,14 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n   return t;\n }\n \n-/* Clean CONSTRUCTOR_NO_IMPLICIT_ZERO from CTOR and its sub-aggregates.  */\n+/* Clean CONSTRUCTOR_NO_CLEARING from CTOR and its sub-aggregates.  */\n \n static void\n clear_no_implicit_zero (tree ctor)\n {\n-  if (CONSTRUCTOR_NO_IMPLICIT_ZERO (ctor))\n+  if (CONSTRUCTOR_NO_CLEARING (ctor))\n     {\n-      CONSTRUCTOR_NO_IMPLICIT_ZERO (ctor) = false;\n+      CONSTRUCTOR_NO_CLEARING (ctor) = false;\n       tree elt; unsigned HOST_WIDE_INT idx;\n       FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (ctor), idx, elt)\n \tif (TREE_CODE (elt) == CONSTRUCTOR)\n@@ -1525,7 +1525,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t If we don't already have one in CTX, use the AGGR_INIT_EXPR_SLOT.  */\n       new_ctx.object = AGGR_INIT_EXPR_SLOT (t);\n       tree ctor = new_ctx.ctor = build_constructor (DECL_CONTEXT (fun), NULL);\n-      CONSTRUCTOR_NO_IMPLICIT_ZERO (ctor) = true;\n+      CONSTRUCTOR_NO_CLEARING (ctor) = true;\n       ctx->values->put (new_ctx.object, ctor);\n       ctx = &new_ctx;\n     }\n@@ -1787,7 +1787,7 @@ reduced_constant_expression_p (tree t)\n     case CONSTRUCTOR:\n       /* And we need to handle PTRMEM_CST wrapped in a CONSTRUCTOR.  */\n       tree idx, val, field; unsigned HOST_WIDE_INT i;\n-      if (CONSTRUCTOR_NO_IMPLICIT_ZERO (t))\n+      if (CONSTRUCTOR_NO_CLEARING (t))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n \t    /* An initialized vector would have a VECTOR_CST.  */\n@@ -1812,9 +1812,9 @@ reduced_constant_expression_p (tree t)\n \t}\n       if (field)\n \treturn false;\n-      else if (CONSTRUCTOR_NO_IMPLICIT_ZERO (t))\n+      else if (CONSTRUCTOR_NO_CLEARING (t))\n \t/* All the fields are initialized.  */\n-\tCONSTRUCTOR_NO_IMPLICIT_ZERO (t) = false;\n+\tCONSTRUCTOR_NO_CLEARING (t) = false;\n       return true;\n \n     default:\n@@ -2487,7 +2487,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   /* Not found.  */\n \n   if (TREE_CODE (ary) == CONSTRUCTOR\n-      && CONSTRUCTOR_NO_IMPLICIT_ZERO (ary))\n+      && CONSTRUCTOR_NO_CLEARING (ary))\n     {\n       /* 'ary' is part of the aggregate initializer we're currently\n \t building; if there's no initializer for this element yet,\n@@ -2582,7 +2582,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n \n   gcc_assert (DECL_CONTEXT (part) == TYPE_MAIN_VARIANT (TREE_TYPE (whole)));\n \n-  if (CONSTRUCTOR_NO_IMPLICIT_ZERO (whole))\n+  if (CONSTRUCTOR_NO_CLEARING (whole))\n     {\n       /* 'whole' is part of the aggregate initializer we're currently\n \t building; if there's no initializer for this member yet, that's an\n@@ -2788,7 +2788,7 @@ init_subob_ctx (const constexpr_ctx *ctx, constexpr_ctx &new_ctx,\n   if (ctx->object)\n     new_ctx.object = build_ctor_subob_ref (index, type, ctx->object);\n   tree elt = build_constructor (type, NULL);\n-  CONSTRUCTOR_NO_IMPLICIT_ZERO (elt) = true;\n+  CONSTRUCTOR_NO_CLEARING (elt) = true;\n   new_ctx.ctor = elt;\n \n   if (TREE_CODE (value) == TARGET_EXPR)\n@@ -2920,7 +2920,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n   t = ctx->ctor;\n   /* We're done building this CONSTRUCTOR, so now we can interpret an\n      element without an explicit initializer as value-initialized.  */\n-  CONSTRUCTOR_NO_IMPLICIT_ZERO (t) = false;\n+  CONSTRUCTOR_NO_CLEARING (t) = false;\n   TREE_CONSTANT (t) = constant_p;\n   TREE_SIDE_EFFECTS (t) = side_effects_p;\n   if (VECTOR_TYPE_P (type))\n@@ -3055,7 +3055,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n   if (!*non_constant_p)\n     {\n       init = ctx->ctor;\n-      CONSTRUCTOR_NO_IMPLICIT_ZERO (init) = false;\n+      CONSTRUCTOR_NO_CLEARING (init) = false;\n     }\n   return init;\n }\n@@ -3619,7 +3619,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       if (*valp == NULL_TREE)\n \t{\n \t  *valp = build_constructor (type, NULL);\n-\t  CONSTRUCTOR_NO_IMPLICIT_ZERO (*valp) = no_zero_init;\n+\t  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;\n \t}\n       else if (TREE_CODE (*valp) == STRING_CST)\n \t{\n@@ -3652,7 +3652,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n       /* If the value of object is already zero-initialized, any new ctors for\n \t subobjects will also be zero-initialized.  */\n-      no_zero_init = CONSTRUCTOR_NO_IMPLICIT_ZERO (*valp);\n+      no_zero_init = CONSTRUCTOR_NO_CLEARING (*valp);\n \n       vec_safe_push (ctors, *valp);\n \n@@ -3722,7 +3722,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       if (*valp == NULL_TREE)\n \t{\n \t  *valp = build_constructor (type, NULL);\n-\t  CONSTRUCTOR_NO_IMPLICIT_ZERO (*valp) = no_zero_init;\n+\t  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;\n \t}\n       else if (TREE_CODE (*valp) == PTRMEM_CST)\n \t*valp = cplus_expand_constant (*valp);\n@@ -3745,8 +3745,8 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       CONSTRUCTOR_ELTS (*valp) = CONSTRUCTOR_ELTS (init);\n       TREE_CONSTANT (*valp) = TREE_CONSTANT (init);\n       TREE_SIDE_EFFECTS (*valp) = TREE_SIDE_EFFECTS (init);\n-      CONSTRUCTOR_NO_IMPLICIT_ZERO (*valp)\n-\t= CONSTRUCTOR_NO_IMPLICIT_ZERO (init);\n+      CONSTRUCTOR_NO_CLEARING (*valp)\n+\t= CONSTRUCTOR_NO_CLEARING (init);\n     }\n   else\n     *valp = init;\n@@ -4236,7 +4236,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    new_ctx = *ctx;\n \t    new_ctx.object = r;\n \t    new_ctx.ctor = build_constructor (TREE_TYPE (r), NULL);\n-\t    CONSTRUCTOR_NO_IMPLICIT_ZERO (new_ctx.ctor) = true;\n+\t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n \t    new_ctx.values->put (r, new_ctx.ctor);\n \t    ctx = &new_ctx;\n \t  }\n@@ -4276,7 +4276,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t     strips the TARGET_EXPR before we get here.  */\n \t  new_ctx = *ctx;\n \t  new_ctx.ctor = build_constructor (TREE_TYPE (t), NULL);\n-\t  CONSTRUCTOR_NO_IMPLICIT_ZERO (new_ctx.ctor) = true;\n+\t  CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n \t  new_ctx.object = TARGET_EXPR_SLOT (t);\n \t  ctx->values->put (new_ctx.object, new_ctx.ctor);\n \t  ctx = &new_ctx;\n@@ -4893,7 +4893,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t for C++11 constexpr constructors that refer to the object being\n \t initialized.  */\n       ctx.ctor = build_constructor (type, NULL);\n-      CONSTRUCTOR_NO_IMPLICIT_ZERO (ctx.ctor) = true;\n+      CONSTRUCTOR_NO_CLEARING (ctx.ctor) = true;\n       if (!object)\n \t{\n \t  if (TREE_CODE (t) == TARGET_EXPR)\n@@ -4932,7 +4932,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n     }\n \n   if (TREE_CODE (r) == CONSTRUCTOR\n-      && CONSTRUCTOR_NO_IMPLICIT_ZERO (r))\n+      && CONSTRUCTOR_NO_CLEARING (r))\n     {\n       if (!allow_non_constant)\n \terror (\"%qE is not a constant expression because it refers to \""}, {"sha": "f0aae66772394d28423081bc9aaa6e0f77bf2e12", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c487163ac2988dc7d90774e068d9c043193a3d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c487163ac2988dc7d90774e068d9c043193a3d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e8c487163ac2988dc7d90774e068d9c043193a3d", "patch": "@@ -387,7 +387,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       DECL_FINAL_P (in FUNCTION_DECL)\n       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)\n       DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)\n-      CONSTRUCTOR_NO_IMPLICIT_ZERO (in CONSTRUCTOR)\n       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)\n       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)\n       OVL_USING_P (in OVERLOAD)\n@@ -4136,11 +4135,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    B b{1,2}, not B b({1,2}) or B b = {1,2}.  */\n #define CONSTRUCTOR_IS_DIRECT_INIT(NODE) (TREE_LANG_FLAG_0 (CONSTRUCTOR_CHECK (NODE)))\n \n-/* True if an uninitialized element in NODE should not be treated as\n-   implicitly value-initialized.  Only used in constexpr evaluation.  */\n-#define CONSTRUCTOR_NO_IMPLICIT_ZERO(NODE) \\\n-  (TREE_LANG_FLAG_1 (CONSTRUCTOR_CHECK (NODE)))\n-\n /* True if this CONSTRUCTOR should not be used as a variable initializer\n    because it was loaded from a constexpr variable with mutable fields.  */\n #define CONSTRUCTOR_MUTABLE_POISON(NODE) \\"}]}