{"sha": "a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhNzBiZjY2OTBlMzEwZmIxZDRhZmE0YjNkZDFiMTlkZGQwZTJmNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-04T12:17:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-04T12:38:09Z"}, "message": "Simplify SLP code wrt SLP_TREE_DEF_TYPE\n\nThe following removes the ugly pushing of SLP_TREE_DEF_TYPE to\nstmt_infos and instead makes sure to handle invariants fully\nin vect_is_simple_use plus adjusting a few places I refrained\nfrom touching when enforcing vector types for them.\n\nIt also simplifies building SLP nodes with all external operands\nfrom scalars by not doing that in the parent but instead not\nbuilding those from the start.  That also gets rid of\nvect_update_all_shared_vectypes.\n\n2020-06-04  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_update_all_shared_vectypes): Remove.\n\t(vect_build_slp_tree_2): Simplify building all external op\n\tnodes from scalars.\n\t(vect_slp_analyze_node_operations): Remove push/pop of\n\tSTMT_VINFO_DEF_TYPE.\n\t(vect_schedule_slp_instance): Likewise.\n\t* tree-vect-stmts.c (ect_check_store_rhs): Pass in the\n\tstmt_info, use the vect_is_simple_use overload combining\n\tSLP and stmt_info analysis.\n\t(vect_is_simple_cond): Likewise.\n\t(vectorizable_store): Adjust.\n\t(vectorizable_condition): Likewise.\n\t(vect_is_simple_use): Fully handle invariant SLP nodes\n\there.  Amend stmt_info operand extraction with COND_EXPR\n\tand masked stores.\n\t* tree-vect-loop.c (vectorizable_reduction): Deal with\n\tCOND_EXPR representation ugliness.", "tree": {"sha": "d8d99bdbe301c1007e5e81b3285f9f83ddc77cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8d99bdbe301c1007e5e81b3285f9f83ddc77cfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43088bb4dadd3d14b6b594c5f9363fe879f3d7f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43088bb4dadd3d14b6b594c5f9363fe879f3d7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43088bb4dadd3d14b6b594c5f9363fe879f3d7f7"}], "stats": {"total": 283, "additions": 89, "deletions": 194}, "files": [{"sha": "ad26663595c64f4ada8cd6b701613f3cd808b159", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4", "patch": "@@ -6197,6 +6197,12 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n       gcc_assert (SLP_TREE_REPRESENTATIVE (slp_for_stmt_info) == stmt_info);\n     }\n   slp_tree *slp_op = XALLOCAVEC (slp_tree, op_type);\n+  /* We need to skip an extra operand for COND_EXPRs with embedded\n+     comparison.  */\n+  unsigned opno_adjust = 0;\n+  if (code == COND_EXPR\n+      && COMPARISON_CLASS_P (gimple_assign_rhs1 (stmt)))\n+    opno_adjust = 1;\n   for (i = 0; i < op_type; i++)\n     {\n       /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n@@ -6207,7 +6213,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n       enum vect_def_type dt;\n       tree op;\n       if (!vect_is_simple_use (loop_vinfo, stmt_info, slp_for_stmt_info,\n-\t\t\t       i, &op, &slp_op[i], &dt, &tem,\n+\t\t\t       i + opno_adjust, &op, &slp_op[i], &dt, &tem,\n \t\t\t       &def_stmt_info))\n \t{\n \t  if (dump_enabled_p ())"}, {"sha": "f8b12f0dae9e2275b1cdcce5bc252521825ec172", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 34, "deletions": 169, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4", "patch": "@@ -616,26 +616,6 @@ vect_update_shared_vectype (stmt_vec_info stmt_info, tree vectype)\n   return false;\n }\n \n-/* Try to infer and assign a vector type to all the statements in STMTS.\n-   Used only for BB vectorization.  */\n-\n-static bool\n-vect_update_all_shared_vectypes (vec_info *vinfo, vec<stmt_vec_info> stmts)\n-{\n-  tree vectype, nunits_vectype;\n-  if (!vect_get_vector_types_for_stmt (vinfo, stmts[0], &vectype,\n-\t\t\t\t       &nunits_vectype, stmts.length ()))\n-    return false;\n-\n-  stmt_vec_info stmt_info;\n-  unsigned int i;\n-  FOR_EACH_VEC_ELT (stmts, i, stmt_info)\n-    if (!vect_update_shared_vectype (stmt_info, vectype))\n-      return false;\n-\n-  return true;\n-}\n-\n /* Return true if call statements CALL1 and CALL2 are similar enough\n    to be combined into the same SLP group.  */\n \n@@ -1349,7 +1329,6 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   FOR_EACH_VEC_ELT (oprnds_info, i, oprnd_info)\n     {\n       slp_tree child;\n-      unsigned old_tree_size = this_tree_size;\n       unsigned int j;\n \n       if (oprnd_info->first_dt == vect_uninitialized_def)\n@@ -1376,45 +1355,6 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t\tmatches, npermutes,\n \t\t\t\t\t&this_tree_size, bst_map)) != NULL)\n \t{\n-\t  /* If we have all children of a non-unary child built up from\n-\t     scalars then just throw that away and build it up this node\n-\t     from scalars.  */\n-\t  if (is_a <bb_vec_info> (vinfo)\n-\t      && SLP_TREE_CHILDREN (child).length () > 1\n-\t      /* ???  Rejecting patterns this way doesn't work.  We'd have to\n-\t\t do extra work to cancel the pattern so the uses see the\n-\t\t scalar version.  */\n-\t      && !oprnd_info->any_pattern)\n-\t    {\n-\t      slp_tree grandchild;\n-\n-\t      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n-\t\tif (SLP_TREE_DEF_TYPE (grandchild) != vect_external_def)\n-\t\t  break;\n-\t      if (!grandchild\n-\t\t  && vect_update_all_shared_vectypes (vinfo,\n-\t\t\t\t\t\t      oprnd_info->def_stmts))\n-\t\t{\n-\t\t  /* Roll back.  */\n-\t\t  this_tree_size = old_tree_size;\n-\t\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n-\t\t    vect_free_slp_tree (grandchild, false);\n-\t\t  SLP_TREE_CHILDREN (child).truncate (0);\n-\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t     \"Building parent vector operands from \"\n-\t\t\t\t     \"scalars instead\\n\");\n-\t\t  oprnd_info->def_stmts = vNULL;\n-\t\t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n-\t\t  SLP_TREE_SCALAR_OPS (child) = oprnd_info->ops;\n-\t\t  oprnd_info->ops = vNULL;\n-\t\t  ++this_tree_size;\n-\t\t  children.safe_push (child);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n \t  oprnd_info->def_stmts = vNULL;\n \t  children.safe_push (child);\n \t  continue;\n@@ -1434,16 +1374,13 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t     do extra work to cancel the pattern so the uses see the\n \t     scalar version.  */\n \t  && !is_pattern_stmt_p (stmt_info)\n-\t  && !oprnd_info->any_pattern\n-\t  && vect_update_all_shared_vectypes (vinfo, oprnd_info->def_stmts))\n+\t  && !oprnd_info->any_pattern)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Building vector operands from scalars\\n\");\n \t  this_tree_size++;\n-\t  child = vect_create_new_slp_node (oprnd_info->def_stmts, 0);\n-\t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n-\t  SLP_TREE_SCALAR_OPS (child) = oprnd_info->ops;\n+\t  child = vect_create_new_slp_node (oprnd_info->ops);\n \t  children.safe_push (child);\n \t  oprnd_info->ops = vNULL;\n \t  oprnd_info->def_stmts = vNULL;\n@@ -1517,46 +1454,6 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t\t    tem, npermutes,\n \t\t\t\t\t    &this_tree_size, bst_map)) != NULL)\n \t    {\n-\t      /* If we have all children of a non-unary child built up from\n-\t\t scalars then just throw that away and build it up this node\n-\t\t from scalars.  */\n-\t      if (is_a <bb_vec_info> (vinfo)\n-\t\t  && SLP_TREE_CHILDREN (child).length () > 1\n-\t\t  /* ???  Rejecting patterns this way doesn't work.  We'd have\n-\t\t     to do extra work to cancel the pattern so the uses see the\n-\t\t     scalar version.  */\n-\t\t  && !oprnd_info->any_pattern)\n-\t\t{\n-\t\t  unsigned int j;\n-\t\t  slp_tree grandchild;\n-\n-\t\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n-\t\t    if (SLP_TREE_DEF_TYPE (grandchild) != vect_external_def)\n-\t\t      break;\n-\t\t  if (!grandchild\n-\t\t      && (vect_update_all_shared_vectypes\n-\t\t\t    (vinfo, oprnd_info->def_stmts)))\n-\t\t    {\n-\t\t      /* Roll back.  */\n-\t\t      this_tree_size = old_tree_size;\n-\t\t      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n-\t\t\tvect_free_slp_tree (grandchild, false);\n-\t\t      SLP_TREE_CHILDREN (child).truncate (0);\n-\n-\t\t      if (dump_enabled_p ())\n-\t\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t\t \"Building parent vector operands from \"\n-\t\t\t\t\t \"scalars instead\\n\");\n-\t\t      oprnd_info->def_stmts = vNULL;\n-\t\t      SLP_TREE_DEF_TYPE (child) = vect_external_def;\n-\t\t      SLP_TREE_SCALAR_OPS (child) = oprnd_info->ops;\n-\t\t      oprnd_info->ops = vNULL;\n-\t\t      ++this_tree_size;\n-\t\t      children.safe_push (child);\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\n \t      oprnd_info->def_stmts = vNULL;\n \t      children.safe_push (child);\n \t      continue;\n@@ -1575,6 +1472,35 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \n   vect_free_oprnd_info (oprnds_info);\n \n+  /* If we have all children of a non-unary child built up from\n+     scalars then just throw that away, causing it built up\n+     from scalars.  */\n+  if (nops > 1\n+      && is_a <bb_vec_info> (vinfo)\n+      /* ???  Rejecting patterns this way doesn't work.  We'd have to\n+\t do extra work to cancel the pattern so the uses see the\n+\t scalar version.  */\n+      && !is_pattern_stmt_p (stmt_info))\n+    {\n+      slp_tree child;\n+      unsigned j;\n+      FOR_EACH_VEC_ELT (children, j, child)\n+\tif (SLP_TREE_DEF_TYPE (child) != vect_external_def)\n+\t  break;\n+      if (!child)\n+\t{\n+\t  /* Roll back.  */\n+\t  FOR_EACH_VEC_ELT (children, j, child)\n+\t    vect_free_slp_tree (child, false);\n+\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Building parent vector operands from \"\n+\t\t\t     \"scalars instead\\n\");\n+\t  return NULL;\n+\t}\n+    }\n+\n   *tree_size += this_tree_size + 1;\n   *max_nunits = this_max_nunits;\n \n@@ -2817,51 +2743,8 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \t\t\t\t\t   visited, lvisited, cost_vec))\n       return false;\n \n-  /* ???  We have to catch the case late where two first scalar stmts appear\n-     in multiple SLP children with different def type and fail.  Remember\n-     original def types first since SLP_TREE_DEF_TYPE doesn't necessarily\n-     match it when that is vect_internal_def.  */\n-  auto_vec<vect_def_type, 4> dt;\n-  dt.safe_grow (SLP_TREE_CHILDREN (node).length ());\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n-      dt[j] = STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]);\n-\n-  /* Push SLP node def-type to stmt operands.  */\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def\n-\t&& SLP_TREE_SCALAR_STMTS (child).length () != 0)\n-      STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n-\t= SLP_TREE_DEF_TYPE (child);\n-\n-  /* Check everything worked out.  */\n-  bool res = true;\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-      if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n-\t{\n-\t  if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-\t    {\n-\t      if (STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n-\t\t  != SLP_TREE_DEF_TYPE (child))\n-\t\tres = false;\n-\t    }\n-\t  else if (STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n-\t\t   != dt[j])\n-\t    res = false;\n-\t}\n-  if (!res && dump_enabled_p ())\n-    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t     \"not vectorized: same operand with different \"\n-\t\t     \"def type in stmt.\\n\");\n-\n-  if (res)\n-    res = vect_slp_analyze_node_operations_1 (vinfo, node, node_instance,\n-\t\t\t\t\t      cost_vec);\n-\n-  /* Restore def-types.  */\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n-      STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]) = dt[j];\n+  bool res = vect_slp_analyze_node_operations_1 (vinfo, node, node_instance,\n+\t\t\t\t\t\t cost_vec);\n \n   /* When the node can be vectorized cost invariant nodes it references.\n      This is not done in DFS order to allow the refering node\n@@ -4038,7 +3921,7 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t\t\t    slp_tree node, slp_instance instance)\n {\n   gimple_stmt_iterator si;\n-  int i, j;\n+  int i;\n   slp_tree child;\n \n   /* See if we have already vectorized the node in the graph of the\n@@ -4065,15 +3948,6 @@ vect_schedule_slp_instance (vec_info *vinfo,\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_schedule_slp_instance (vinfo, child, instance);\n \n-  /* Push SLP node def-type to stmts.  */\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      {\n-\tstmt_vec_info child_stmt_info;\n-\tFOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, child_stmt_info)\n-\t  STMT_VINFO_DEF_TYPE (child_stmt_info) = SLP_TREE_DEF_TYPE (child);\n-      }\n-\n   stmt_vec_info stmt_info = SLP_TREE_REPRESENTATIVE (node);\n \n   /* VECTYPE is the type of the destination.  */\n@@ -4172,15 +4046,6 @@ vect_schedule_slp_instance (vec_info *vinfo,\n     }\n   if (!done_p)\n     vect_transform_stmt (vinfo, stmt_info, &si, node, instance);\n-\n-  /* Restore stmt def-types.  */\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      {\n-\tstmt_vec_info child_stmt_info;\n-\tFOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, child_stmt_info)\n-\t  STMT_VINFO_DEF_TYPE (child_stmt_info) = vect_internal_def;\n-      }\n }\n \n /* Replace scalar calls from SLP node NODE with setting of their lhs to zero."}, {"sha": "4cca06ee96e2c7fa251e48d7f7dd27017c3f2236", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a3a70bf6690e310fb1d4afa4b3dd1b19ddd0e2f4", "patch": "@@ -2573,7 +2573,8 @@ vect_check_scalar_mask (vec_info *vinfo, stmt_vec_info stmt_info, tree mask,\n    *RHS_VECTYPE_OUT and the type of the store in *VLS_TYPE_OUT.  */\n \n static bool\n-vect_check_store_rhs (vec_info *vinfo, stmt_vec_info stmt_info, tree rhs,\n+vect_check_store_rhs (vec_info *vinfo, stmt_vec_info stmt_info,\n+\t\t      slp_tree slp_node, tree rhs,\n \t\t      vect_def_type *rhs_dt_out, tree *rhs_vectype_out,\n \t\t      vec_load_store_type *vls_type_out)\n {\n@@ -2589,7 +2590,9 @@ vect_check_store_rhs (vec_info *vinfo, stmt_vec_info stmt_info, tree rhs,\n \n   enum vect_def_type rhs_dt;\n   tree rhs_vectype;\n-  if (!vect_is_simple_use (rhs, vinfo, &rhs_dt, &rhs_vectype))\n+  slp_tree slp_op;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 0,\n+\t\t\t   &rhs, &slp_op, &rhs_dt, &rhs_vectype))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -7487,7 +7490,7 @@ vectorizable_store (vec_info *vinfo,\n       return false;\n     }\n \n-  if (!vect_check_store_rhs (vinfo, stmt_info,\n+  if (!vect_check_store_rhs (vinfo, stmt_info, slp_node,\n \t\t\t     op, &rhs_dt, &rhs_vectype, &vls_type))\n     return false;\n \n@@ -9977,18 +9980,20 @@ vectorizable_load (vec_info *vinfo,\n    condition operands are supportable using vec_is_simple_use.  */\n \n static bool\n-vect_is_simple_cond (tree cond, vec_info *vinfo, slp_tree slp_node,\n-\t\t     tree *comp_vectype, enum vect_def_type *dts,\n-\t\t     tree vectype)\n+vect_is_simple_cond (tree cond, vec_info *vinfo, stmt_vec_info stmt_info,\n+\t\t     slp_tree slp_node, tree *comp_vectype,\n+\t\t     enum vect_def_type *dts, tree vectype)\n {\n   tree lhs, rhs;\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n+  slp_tree slp_op;\n \n   /* Mask case.  */\n   if (TREE_CODE (cond) == SSA_NAME\n       && VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (cond)))\n     {\n-      if (!vect_is_simple_use (cond, vinfo, &dts[0], comp_vectype)\n+      if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 0, &cond,\n+\t\t\t       &slp_op, &dts[0], comp_vectype)\n \t  || !*comp_vectype\n \t  || !VECTOR_BOOLEAN_TYPE_P (*comp_vectype))\n \treturn false;\n@@ -10003,7 +10008,8 @@ vect_is_simple_cond (tree cond, vec_info *vinfo, slp_tree slp_node,\n \n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n-      if (!vect_is_simple_use (lhs, vinfo, &dts[0], &vectype1))\n+      if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 0,\n+\t\t\t       &lhs, &slp_op, &dts[0], &vectype1))\n \treturn false;\n     }\n   else if (TREE_CODE (lhs) == INTEGER_CST || TREE_CODE (lhs) == REAL_CST\n@@ -10014,7 +10020,8 @@ vect_is_simple_cond (tree cond, vec_info *vinfo, slp_tree slp_node,\n \n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n-      if (!vect_is_simple_use (rhs, vinfo, &dts[1], &vectype2))\n+      if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 1,\n+\t\t\t       &rhs, &slp_op, &dts[1], &vectype2))\n \treturn false;\n     }\n   else if (TREE_CODE (rhs) == INTEGER_CST || TREE_CODE (rhs) == REAL_CST\n@@ -10158,21 +10165,17 @@ vectorizable_condition (vec_info *vinfo,\n \n   cond_expr = gimple_assign_rhs1 (stmt);\n \n-  if (!vect_is_simple_cond (cond_expr, vinfo, slp_node,\n+  if (!vect_is_simple_cond (cond_expr, vinfo, stmt_info, slp_node,\n \t\t\t    &comp_vectype, &dts[0], vectype)\n       || !comp_vectype)\n     return false;\n \n-  unsigned slp_adjust = 0;\n-  if (slp_node && SLP_TREE_CHILDREN (slp_node).length () == 4)\n-    /* ???  Hack.  Hope for COND_EXPR GIMPLE sanitizing or refactor\n-       things more...  */\n-    slp_adjust = 1;\n+  unsigned op_adjust = COMPARISON_CLASS_P (cond_expr) ? 1 : 0;\n   slp_tree then_slp_node, else_slp_node;\n-  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 1 + slp_adjust,\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 1 + op_adjust,\n \t\t\t   &then_clause, &then_slp_node, &dts[2], &vectype1))\n     return false;\n-  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 2 + slp_adjust,\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 2 + op_adjust,\n \t\t\t   &else_clause, &else_slp_node, &dts[3], &vectype2))\n     return false;\n \n@@ -10301,7 +10304,7 @@ vectorizable_condition (vec_info *vinfo,\n       if (slp_node\n \t  && (!vect_maybe_update_slp_op_vectype\n \t\t (SLP_TREE_CHILDREN (slp_node)[0], comp_vectype)\n-\t      || (slp_adjust == 1\n+\t      || (op_adjust == 1\n \t\t  && !vect_maybe_update_slp_op_vectype\n \t\t\t(SLP_TREE_CHILDREN (slp_node)[1], comp_vectype))\n \t      || !vect_maybe_update_slp_op_vectype (then_slp_node, vectype)\n@@ -11853,19 +11856,40 @@ vect_is_simple_use (vec_info *vinfo, stmt_vec_info stmt, slp_tree slp_node,\n       if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n \t*op = gimple_get_lhs (SLP_TREE_SCALAR_STMTS (child)[0]->stmt);\n       else\n-\t*op = SLP_TREE_SCALAR_OPS (child)[0];\n+\t{\n+\t  if (def_stmt_info_out)\n+\t    *def_stmt_info_out = NULL;\n+\t  *op = SLP_TREE_SCALAR_OPS (child)[0];\n+\t  *dt = SLP_TREE_DEF_TYPE (child);\n+\t  *vectype = SLP_TREE_VECTYPE (child);\n+\t  return true;\n+\t}\n     }\n   else\n     {\n       if (gassign *ass = dyn_cast <gassign *> (stmt->stmt))\n \t{\n-\t  *op = gimple_op (ass, operand + 1);\n-\t  /* ???  Ick.  But it will vanish with SLP only.  */\n-\t  if (TREE_CODE (*op) == VIEW_CONVERT_EXPR)\n-\t    *op = TREE_OPERAND (*op, 0);\n+\t  if (gimple_assign_rhs_code (ass) == COND_EXPR\n+\t      && COMPARISON_CLASS_P (gimple_assign_rhs1 (ass)))\n+\t    {\n+\t      if (operand < 2)\n+\t\t*op = TREE_OPERAND (gimple_assign_rhs1 (ass), operand);\n+\t      else\n+\t\t*op = gimple_op (ass, operand);\n+\t    }\n+\t  else if (gimple_assign_rhs_code (ass) == VIEW_CONVERT_EXPR)\n+\t    *op = TREE_OPERAND (gimple_assign_rhs1 (ass), 0);\n+\t  else\n+\t    *op = gimple_op (ass, operand + 1);\n \t}\n       else if (gcall *call = dyn_cast <gcall *> (stmt->stmt))\n-\t*op = gimple_call_arg (call, operand);\n+\t{\n+\t  if (gimple_call_internal_p (call)\n+\t      && internal_store_fn_p (gimple_call_internal_fn (call)))\n+\t    operand = internal_fn_stored_value_index (gimple_call_internal_fn\n+\t\t\t\t\t\t\t\t\t(call));\n+\t  *op = gimple_call_arg (call, operand);\n+\t}\n       else\n \tgcc_unreachable ();\n     }"}]}