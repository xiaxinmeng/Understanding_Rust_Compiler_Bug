{"sha": "a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxZTVlODZjMGJiY2IwZGNhNjMxMWE1ZTZkYWI4ZDdlMDA1YTA3Ng==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-05T14:51:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-05T14:51:16Z"}, "message": "tree.c (reference_alias_ptr_type): New function.\n\n2010-07-05  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.c (reference_alias_ptr_type): New function.\n\t* tree.h (reference_alias_ptr_type): Declare.\n\t* tree-ssa-loop-ivopts.c (copy_ref_info): Restructure to\n\tallow non-TARGET_MEM_REF new refs.\n\t(rewrite_use_address): Pass old alias pointer type to\n\tcreate_mem_ref.\n\t* tree-ssa-address.c (create_mem_ref_raw): Get alias pointer type.\n\tBuild a MEM_REF instead of a TARGET_MEM_REF if possible.\n\t(create_mem_ref): Get alias pointer type.  Adjust calls to\n\tcreate_mem_ref_raw.\n\t(maybe_fold_tmr): Likewise.\n\t* tree-flow.h (create_mem_ref): Adjust prototype.\n\nFrom-SVN: r161840", "tree": {"sha": "26e22ad4b9ee130b7097d46360e487d9f427ecf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26e22ad4b9ee130b7097d46360e487d9f427ecf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c144a5fadc5f5d8df422e6f85e8464c1b918780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c144a5fadc5f5d8df422e6f85e8464c1b918780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c144a5fadc5f5d8df422e6f85e8464c1b918780"}], "stats": {"total": 138, "additions": 100, "deletions": 38}, "files": [{"sha": "f4ad9076a1ba0e7ab71ae3f88b1d53f1dce6a867", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "patch": "@@ -1,3 +1,18 @@\n+2010-07-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.c (reference_alias_ptr_type): New function.\n+\t* tree.h (reference_alias_ptr_type): Declare.\n+\t* tree-ssa-loop-ivopts.c (copy_ref_info): Restructure to\n+\tallow non-TARGET_MEM_REF new refs.\n+\t(rewrite_use_address): Pass old alias pointer type to\n+\tcreate_mem_ref.\n+\t* tree-ssa-address.c (create_mem_ref_raw): Get alias pointer type.\n+\tBuild a MEM_REF instead of a TARGET_MEM_REF if possible.\n+\t(create_mem_ref): Get alias pointer type.  Adjust calls to\n+\tcreate_mem_ref_raw.\n+\t(maybe_fold_tmr): Likewise.\n+\t* tree-flow.h (create_mem_ref): Adjust prototype.\n+\n 2010-07-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/44808"}, {"sha": "fd9a5425368e93d95733ff6b2605165d23d06d3e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "patch": "@@ -833,7 +833,7 @@ struct mem_address\n };\n \n struct affine_tree_combination;\n-tree create_mem_ref (gimple_stmt_iterator *, tree,\n+tree create_mem_ref (gimple_stmt_iterator *, tree, tree,\n \t\t     struct affine_tree_combination *, tree, bool);\n rtx addr_for_mem_ref (struct mem_address *, addr_space_t, bool);\n void get_address_description (tree, struct mem_address *);"}, {"sha": "cf7a81d66d00c9475a5ce28be25141dcede3915d", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "patch": "@@ -338,7 +338,7 @@ valid_mem_ref_p (enum machine_mode mode, addr_space_t as,\n    TARGET_MEM_REF.  */\n \n static tree\n-create_mem_ref_raw (tree type, struct mem_address *addr)\n+create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr)\n {\n   if (!valid_mem_ref_p (TYPE_MODE (type), TYPE_ADDR_SPACE (type), addr))\n     return NULL_TREE;\n@@ -349,6 +349,24 @@ create_mem_ref_raw (tree type, struct mem_address *addr)\n   if (addr->offset && integer_zerop (addr->offset))\n     addr->offset = NULL_TREE;\n \n+  /* If possible use a plain MEM_REF instead of a TARGET_MEM_REF.  */\n+  if (alias_ptr_type\n+      && !addr->index\n+      && !addr->step)\n+    {\n+      tree base, offset;\n+      gcc_assert (!addr->symbol ^ !addr->base);\n+      if (addr->symbol)\n+\tbase = build_fold_addr_expr (addr->symbol);\n+      else\n+\tbase = addr->base;\n+      if (addr->offset)\n+\toffset = fold_convert (alias_ptr_type, addr->offset);\n+      else\n+\toffset = build_int_cst (alias_ptr_type, 0);\n+      return fold_build2 (MEM_REF, type, base, offset);\n+    }\n+\n   return build6 (TARGET_MEM_REF, type,\n \t\t addr->symbol, addr->base, addr->index,\n \t\t addr->step, addr->offset, NULL);\n@@ -628,16 +646,16 @@ gimplify_mem_ref_parts (gimple_stmt_iterator *gsi, struct mem_address *parts)\n    of created memory reference.  */\n \n tree\n-create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n-\t\ttree base_hint, bool speed)\n+create_mem_ref (gimple_stmt_iterator *gsi, tree type, tree alias_ptr_type,\n+\t\taff_tree *addr, tree base_hint, bool speed)\n {\n   tree mem_ref, tmp;\n   tree atype;\n   struct mem_address parts;\n \n   addr_to_parts (type, addr, base_hint, &parts, speed);\n   gimplify_mem_ref_parts (gsi, &parts);\n-  mem_ref = create_mem_ref_raw (type, &parts);\n+  mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n   if (mem_ref)\n     return mem_ref;\n \n@@ -653,7 +671,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \t\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n       parts.step = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -688,7 +706,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \tparts.base = tmp;\n       parts.symbol = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -709,7 +727,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \tparts.base = parts.index;\n       parts.index = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -731,7 +749,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \n       parts.offset = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -819,7 +837,7 @@ maybe_fold_tmr (tree ref)\n   if (!changed)\n     return NULL_TREE;\n \n-  ret = create_mem_ref_raw (TREE_TYPE (ref), &addr);\n+  ret = create_mem_ref_raw (TREE_TYPE (ref), NULL_TREE, &addr);\n   if (!ret)\n     return NULL_TREE;\n "}, {"sha": "db56b93470b3e7d3feba73bd94d8c83e41be13f6", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "patch": "@@ -5547,33 +5547,41 @@ unshare_and_remove_ssa_names (tree ref)\n static void\n copy_ref_info (tree new_ref, tree old_ref)\n {\n-  if (TREE_CODE (old_ref) == TARGET_MEM_REF)\n-    copy_mem_ref_info (new_ref, old_ref);\n-  else\n-    {\n-      TMR_ORIGINAL (new_ref) = unshare_and_remove_ssa_names (old_ref);\n-      TREE_SIDE_EFFECTS (new_ref) = TREE_SIDE_EFFECTS (old_ref);\n-      TREE_THIS_VOLATILE (new_ref) = TREE_THIS_VOLATILE (old_ref);\n-      /* We can transfer points-to information from an old pointer\n-         or decl base to the new one.  */\n-      if (TMR_BASE (new_ref)\n-\t  && TREE_CODE (TMR_BASE (new_ref)) == SSA_NAME\n-\t  && POINTER_TYPE_P (TREE_TYPE (TMR_BASE (new_ref)))\n-\t  && !SSA_NAME_PTR_INFO (TMR_BASE (new_ref)))\n+  tree new_ptr_base = NULL_TREE;\n+\n+  if (TREE_CODE (old_ref) == TARGET_MEM_REF\n+      && TREE_CODE (new_ref) == TARGET_MEM_REF)\n+    TMR_ORIGINAL (new_ref) = TMR_ORIGINAL (old_ref);\n+  else if (TREE_CODE (new_ref) == TARGET_MEM_REF)\n+    TMR_ORIGINAL (new_ref) = unshare_and_remove_ssa_names (old_ref);\n+\n+  TREE_SIDE_EFFECTS (new_ref) = TREE_SIDE_EFFECTS (old_ref);\n+  TREE_THIS_VOLATILE (new_ref) = TREE_THIS_VOLATILE (old_ref);\n+\n+  if (TREE_CODE (new_ref) == TARGET_MEM_REF)\n+    new_ptr_base = TMR_BASE (new_ref);\n+  else if (TREE_CODE (new_ref) == MEM_REF)\n+    new_ptr_base = TREE_OPERAND (new_ref, 0);\n+\n+  /* We can transfer points-to information from an old pointer\n+     or decl base to the new one.  */\n+  if (new_ptr_base\n+      && TREE_CODE (new_ptr_base) == SSA_NAME\n+      && POINTER_TYPE_P (TREE_TYPE (new_ptr_base))\n+      && !SSA_NAME_PTR_INFO (new_ptr_base))\n+    {\n+      tree base = get_base_address (old_ref);\n+      if ((INDIRECT_REF_P (base)\n+\t   || TREE_CODE (base) == MEM_REF)\n+\t  && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n+\tduplicate_ssa_name_ptr_info\n+\t    (new_ptr_base, SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)));\n+      else if (TREE_CODE (base) == VAR_DECL\n+\t       || TREE_CODE (base) == PARM_DECL\n+\t       || TREE_CODE (base) == RESULT_DECL)\n \t{\n-\t  tree base = get_base_address (old_ref);\n-\t  if ((INDIRECT_REF_P (base)\n-\t       || TREE_CODE (base) == MEM_REF)\n-\t      && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n-\t    duplicate_ssa_name_ptr_info\n-\t      (TMR_BASE (new_ref), SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)));\n-\t  else if (TREE_CODE (base) == VAR_DECL\n-\t\t   || TREE_CODE (base) == PARM_DECL\n-\t\t   || TREE_CODE (base) == RESULT_DECL)\n-\t    {\n-\t      struct ptr_info_def *pi = get_ptr_info (TMR_BASE (new_ref));\n-\t      pt_solution_set_var (&pi->pt, base);\n-\t    }\n+\t  struct ptr_info_def *pi = get_ptr_info (new_ptr_base);\n+\t  pt_solution_set_var (&pi->pt, base);\n \t}\n     }\n }\n@@ -5608,8 +5616,9 @@ rewrite_use_address (struct ivopts_data *data,\n   if (cand->iv->base_object)\n     base_hint = var_at_stmt (data->current_loop, cand, use->stmt);\n \n-  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff, base_hint,\n-\t\t\tdata->speed);\n+  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p),\n+\t\t\treference_alias_ptr_type (*use->op_p),\n+\t\t\t&aff, base_hint, data->speed);\n   copy_ref_info (ref, *use->op_p);\n   *use->op_p = ref;\n }"}, {"sha": "e6deacce0f79e5868d482725ccac663a22808bf1", "filename": "gcc/tree.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "patch": "@@ -3913,6 +3913,25 @@ mem_ref_offset (const_tree t)\n \t\t\t  TYPE_PRECISION (TREE_TYPE (toff)));\n }\n \n+/* Return the pointer-type relevant for TBAA purposes from the\n+   gimple memory reference tree T.  This is the type to be used for\n+   the offset operand of MEM_REF or TARGET_MEM_REF replacements of T.  */\n+\n+tree\n+reference_alias_ptr_type (const_tree t)\n+{\n+  const_tree base = t;\n+  while (handled_component_p (base))\n+    base = TREE_OPERAND (base, 0);\n+  if (TREE_CODE (base) == MEM_REF)\n+    return TREE_TYPE (TREE_OPERAND (base, 1));\n+  else if (TREE_CODE (base) == TARGET_MEM_REF\n+\t   || TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n+    return NULL_TREE;\n+  else\n+    return build_pointer_type (TYPE_MAIN_VARIANT (TREE_TYPE (base)));\n+}\n+\n /* Similar except don't specify the TREE_TYPE\n    and leave the TREE_SIDE_EFFECTS as 0.\n    It is permissible for arguments to be null,"}, {"sha": "934de7de68e3bc0a8ca82d4f0b6bd6e7a578e484", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a41e5e86c0bbcb0dca6311a5e6dab8d7e005a076", "patch": "@@ -4965,6 +4965,7 @@ extern tree build_simple_mem_ref_loc (location_t, tree);\n #define build_simple_mem_ref(T)\\\n \tbuild_simple_mem_ref_loc (UNKNOWN_LOCATION, T)\n extern double_int mem_ref_offset (const_tree);\n+extern tree reference_alias_ptr_type (const_tree);\n extern tree constant_boolean_node (int, tree);\n extern tree div_if_zero_remainder (enum tree_code, const_tree, const_tree);\n "}]}