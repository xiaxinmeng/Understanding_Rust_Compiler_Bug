{"sha": "b3e01c3d1b61ecc903b577920ca43804a2cb5497", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNlMDFjM2QxYjYxZWNjOTAzYjU3NzkyMGNhNDM4MDRhMmNiNTQ5Nw==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-02-10T22:55:32Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-05-09T01:51:34Z"}, "message": "cris: Introduce CC_NZVCmode and CC_NZmode.\n\nThis is just the framework bits of splitting CCmode into classes\nwhere the cc-setter can merge mode (CCmode), classes where the\ncc-setter must set V and C \"usefully\" (as well as N and Z flags)\nand classes where the cc-setter is something like an arithmetic\ninstruction, where N and Z are valid but C and V reflect the\noperation rather than a compare of the result with zero.  This\nshould yield identical or near-identical code.\n\nThe old split of conditions into the ncond and ocond sets took\ninto account the transformations done by final.c:alter_cond from\ncc_status.flags & CC_NO_OVERFLOW, and wasn't a reflection of the\nhardware description of the conditions (i.e. whether V mattered\nor not).\n\ngcc:\n\tPrepare for cmpelim pass to eliminate redundant compare insns.\n\t* config/cris/cris-modes.def: New file.\n\t* config/cris/cris-protos.h (cris_select_cc_mode): Declare.\n\t(cris_notice_update_cc): Remove left-over declaration.\n\t* config/cris/cris.c (TARGET_CC_MODES_COMPATIBLE): Define.\n\t(cris_select_cc_mode, cris_cc_modes_compatible): New functions.\n\t* config/cris/cris.h (SELECT_CC_MODE): Define.\n\t* config/cris/cris.md (NZSET, NZUSE, NZVCSET, NZVCUSE): New\n\tmode_iterators.\n\t(cond): New code_iterator.\n\t(nzcond): Replacement for incorrect ncond.  All callers changed.\n\t(nzvccond): Replacement for ocond.  All callers changed.\n\t(rnzcond): Replacement for rcond.  All callers changed.\n\t(xCC): New code_attr.\n\t(cmp_op1c, cmp_op0c): Renumber from cmp_op1c and cmp_op2c.  All\n\tusers changed.\n\t(\"*cmpdi<NZVCSET:mode>\"): Rename from \"*cmpdi\".  Replace\n\tCCmode with iteration over NZVCSET.\n\t(\"*cmp_ext<BW:mode><NZVCSET:mode>\"): Similarly; rename from\n\t\"*cmp_ext<mode>\".\n\t(\"*cmpsi<NZVCSET:mode>\"): Similarly, from \"*cmpsi\".\n\t(\"*cmp<BW:mode><NZVCSET:mode>\"): Similarly from \"*cmp<mode>\".\n\t(\"*btst<mode>\"): Similarly, from \"*btst\".\n\t(\"*cbranch<mode><code>4\"): Rename from \"*cbranch<mode>4\",\n\titerating over cond instead of matching the comparison with\n\tordered_comparison_operator.\n\t(\"*cbranch<mode>4_btstq<CC>\"): Correct label operand number.\n\t(\"b<zcond:code><mode>\"): Rename from \"b<ncond:code>\", iterating\n\tover NZUSE.\n\t(\"b<nzvccond:code><mode>\"): Similarly from \"b<ocond:code>\", over\n\tNZVCUSE.  Remove FIXME.\n\t(\"*b<nzcond:code>_reversed<mode>\"): Similarly from\n\t\"*b<ncond:code>_reversed\", over NZUSE.\n\t(\"*b<nzvccond:code>_reversed<mode>\"): Similarly from\n\t\"*b<ocond:code>_reversed\", over NZVCUSE.  Remove FIXME.\n\t(\"b<rnzcond:code><mode>\"): Similarly from \"b<rcond:code>\",\n\tover NZUSE.  Reinstate \"b<oCC>\" vs. \"b<CC>\" mnemonic choice,\n\tdepending on CC_NZmode vs. CCmode.  Remove FIXME.\n\t(\"*b<rnzcond:code>_reversed<mode>\"): Similarly from\n\t\"*b<rcond:code>_reversed\", over NZUSE.\n\t(\"*cstore<mode><code>4\"): Rename from \"*cstore<mode>4\",\n\titerating over cond instead of matching the comparison with\n\tordered_comparison_operator.\n\t(\"*s<nzcond:code><mode>\"): Rename from \"*s<ncond:code>\",\n\titerating over NZUSE.\n\t(\"*s<rnzcond:code><mode>\"): Similar from \"*s<rcond:code>\", over\n\tNZUSE.  Reinstate \"b<oCC>\" vs. \"b<CC>\" mnemonic choice,\n\tdepending on CC_NZmode vs. CCmode.\n\t(\"*s<nzvccond:code><mode>\"): Simlar from \"*s<ocond:code>\", over\n\tNZVCUSE.  Remove FIXME.", "tree": {"sha": "21db75d825f0d3a52c1b992d7ff2f73c0348fc2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21db75d825f0d3a52c1b992d7ff2f73c0348fc2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3e01c3d1b61ecc903b577920ca43804a2cb5497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3e01c3d1b61ecc903b577920ca43804a2cb5497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3e01c3d1b61ecc903b577920ca43804a2cb5497", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3e01c3d1b61ecc903b577920ca43804a2cb5497/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12bdaa7d3e94cf30f8ce1750325a245175bdbee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12bdaa7d3e94cf30f8ce1750325a245175bdbee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12bdaa7d3e94cf30f8ce1750325a245175bdbee5"}], "stats": {"total": 360, "additions": 288, "deletions": 72}, "files": [{"sha": "31241541b6742aec0532dea8d15423b0eb9b79c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3e01c3d1b61ecc903b577920ca43804a2cb5497", "patch": "@@ -52,6 +52,57 @@\n \t(\"*mov_fromzero<mode>_split\"): New split.\n \t(\"*mov_fromzero<mode>\"): New insn.\n \n+\tPrepare for cmpelim pass to eliminate redundant compare insns.\n+\t* config/cris/cris-modes.def: New file.\n+\t* config/cris/cris-protos.h (cris_select_cc_mode): Declare.\n+\t(cris_notice_update_cc): Remove left-over declaration.\n+\t* config/cris/cris.c (TARGET_CC_MODES_COMPATIBLE): Define.\n+\t(cris_select_cc_mode, cris_cc_modes_compatible): New functions.\n+\t* config/cris/cris.h (SELECT_CC_MODE): Define.\n+\t* config/cris/cris.md (NZSET, NZUSE, NZVCSET, NZVCUSE): New\n+\tmode_iterators.\n+\t(cond): New code_iterator.\n+\t(nzcond): Replacement for incorrect ncond.  All callers changed.\n+\t(nzvccond): Replacement for ocond.  All callers changed.\n+\t(rnzcond): Replacement for rcond.  All callers changed.\n+\t(xCC): New code_attr.\n+\t(cmp_op1c, cmp_op0c): Renumber from cmp_op1c and cmp_op2c.  All\n+\tusers changed.\n+\t(\"*cmpdi<NZVCSET:mode>\"): Rename from \"*cmpdi\".  Replace\n+\tCCmode with iteration over NZVCSET.\n+\t(\"*cmp_ext<BW:mode><NZVCSET:mode>\"): Similarly; rename from\n+\t\"*cmp_ext<mode>\".\n+\t(\"*cmpsi<NZVCSET:mode>\"): Similarly, from \"*cmpsi\".\n+\t(\"*cmp<BW:mode><NZVCSET:mode>\"): Similarly from \"*cmp<mode>\".\n+\t(\"*btst<mode>\"): Similarly, from \"*btst\".\n+\t(\"*cbranch<mode><code>4\"): Rename from \"*cbranch<mode>4\",\n+\titerating over cond instead of matching the comparison with\n+\tordered_comparison_operator.\n+\t(\"*cbranch<mode>4_btstq<CC>\"): Correct label operand number.\n+\t(\"b<zcond:code><mode>\"): Rename from \"b<ncond:code>\", iterating\n+\tover NZUSE.\n+\t(\"b<nzvccond:code><mode>\"): Similarly from \"b<ocond:code>\", over\n+\tNZVCUSE.  Remove FIXME.\n+\t(\"*b<nzcond:code>_reversed<mode>\"): Similarly from\n+\t\"*b<ncond:code>_reversed\", over NZUSE.\n+\t(\"*b<nzvccond:code>_reversed<mode>\"): Similarly from\n+\t\"*b<ocond:code>_reversed\", over NZVCUSE.  Remove FIXME.\n+\t(\"b<rnzcond:code><mode>\"): Similarly from \"b<rcond:code>\",\n+\tover NZUSE.  Reinstate \"b<oCC>\" vs. \"b<CC>\" mnemonic choice,\n+\tdepending on CC_NZmode vs. CCmode.  Remove FIXME.\n+\t(\"*b<rnzcond:code>_reversed<mode>\"): Similarly from\n+\t\"*b<rcond:code>_reversed\", over NZUSE.\n+\t(\"*cstore<mode><code>4\"): Rename from \"*cstore<mode>4\",\n+\titerating over cond instead of matching the comparison with\n+\tordered_comparison_operator.\n+\t(\"*s<nzcond:code><mode>\"): Rename from \"*s<ncond:code>\",\n+\titerating over NZUSE.\n+\t(\"*s<rnzcond:code><mode>\"): Similar from \"*s<rcond:code>\", over\n+\tNZUSE.  Reinstate \"b<oCC>\" vs. \"b<CC>\" mnemonic choice,\n+\tdepending on CC_NZmode vs. CCmode.\n+\t(\"*s<nzvccond:code><mode>\"): Simlar from \"*s<ocond:code>\", over\n+\tNZVCUSE.  Remove FIXME.\n+\n 2020-05-08  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* ira-color.c (update_costs_from_allocno): Remove"}, {"sha": "1e72b539caff96fd59746a2959fcf1a793de953c", "filename": "gcc/config/cris/cris-modes.def", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-modes.def?ref=b3e01c3d1b61ecc903b577920ca43804a2cb5497", "patch": "@@ -0,0 +1,54 @@\n+/* Definitions of target machine for GNU compiler, for CRIS.\n+   Copyright (C) 2002-2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Node: Condition Code */\n+\n+/* The mode used for condition-codes depends on both the way the\n+   condition-codes are generated (the CC-setter, typically the compare\n+   instruction), and used (the CC-user, typically a branch).  For CRIS, we\n+   have ordinary compares and incidental condition-code settings from\n+   preceding instructions, setting a subset of N, Z, V and C to usable\n+   values, from the perspective of comparing the result against zero\n+   (fpcraz).  The two subsets meaningful to gcc are all of N, Z, V, C\n+   versus just N, Z; some CC-users care only about N and/or Z and some\n+   that care about at least one of those flags together with V and/or C.\n+   (FIXME: the result of testing a single bit using the btst instruction\n+   should be described as a separate mode.)\n+\n+   The plain \"CC_MODE (CC)\" (which is always present in gcc), is used to\n+   reflect the \"unoptimized\" state, where the CC-setter is a compare\n+   against zero and the CC-user is any branch or s<condition> instruction,\n+   before reload.  After reload, a need for C or V is reflected as\n+   CC_NZVCmode in both setters and users, and others remain CCmode, until\n+   or if optimization of CC-setter and CC-users, when CCmode setters can\n+   be changed or replaced by either CC_NZmode or CC_NZVCmode.  To wit, all\n+   users that require CC_NZVCmode must match only that mode at any time.\n+   All other users must match all CCmodes.  All setters that set only\n+   CC_NZmode must set only that mode.  All other setters must match\n+   setting all CCmodes.  */\n+\n+/* Z and N flags only.  For a condition-code setter: only the Z and N\n+   flags are set to usable values, fpcraz.  For a condition-code user: the\n+   operation using the condition codes only care about the Z and N flags.  */\n+CC_MODE (CC_NZ);\n+\n+/* Z and N *and* V and C flags.  For a condition-code setter: all flags\n+   are set to usable values, fpcraz.  For a condition-code user: at least\n+   one of V and C are used and possibly N and Z too.  */\n+CC_MODE (CC_NZVC);"}, {"sha": "2db1ea1b8bceee7ec54d9b1c31b2f40393ec80fe", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=b3e01c3d1b61ecc903b577920ca43804a2cb5497", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n extern bool cris_simple_epilogue (void);\n #ifdef RTX_CODE\n extern const char *cris_op_str (rtx);\n-extern void cris_notice_update_cc (rtx, rtx_insn *);\n+extern machine_mode cris_select_cc_mode (enum rtx_code, rtx, rtx);\n extern bool cris_reload_address_legitimized (rtx, machine_mode, int, int, int);\n extern int cris_side_effect_mode_ok (enum rtx_code, rtx *, int, int,\n                                      int, int, int);"}, {"sha": "04c80c314a33d6d283700d34814a5a4b44a947a7", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=b3e01c3d1b61ecc903b577920ca43804a2cb5497", "patch": "@@ -133,6 +133,7 @@ static reg_class_t cris_preferred_reload_class (rtx, reg_class_t);\n \n static int cris_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n static int cris_memory_move_cost (machine_mode, reg_class_t, bool);\n+static machine_mode cris_cc_modes_compatible (machine_mode, machine_mode);\n static bool cris_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int cris_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool cris_pass_by_reference (cumulative_args_t,\n@@ -226,6 +227,9 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n    nothing.  Beware of changes to its usage; it may make sense to enable\n    \"later\".  */\n \n+#undef TARGET_CC_MODES_COMPATIBLE\n+#define TARGET_CC_MODES_COMPATIBLE cris_cc_modes_compatible\n+\n #undef TARGET_FLAGS_REGNUM\n #define TARGET_FLAGS_REGNUM CRIS_CC0_REGNUM\n \n@@ -1509,6 +1513,73 @@ cris_memory_move_cost (machine_mode mode,\n     return 6;\n }\n \n+/* Worker function for SELECT_CC_MODE.  */\n+\n+machine_mode\n+cris_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n+{\n+  /* We have different sets of patterns before and after\n+     reload_completed, and everything before reload_completed is CCmode.\n+     At the time of this writing, this function isn't called before that\n+     time, so let's just gcc_assert on that assumption rather than doing\n+     \"if (!reload_completed) return CCmode;\".  */\n+  gcc_assert (reload_completed);\n+\n+  /* For float mode or comparisons with something other than 0, we\n+     always go with CCmode.  */\n+  if (GET_MODE_CLASS (GET_MODE (x)) != MODE_INT || y != const0_rtx)\n+    return CCmode;\n+\n+  /* If we have a comparison that doesn't have to look at V or C, check\n+     operand x; if it looks like a binary operator, return CC_NZmode,\n+     else CCmode, so we only use CC_NZmode for the cases where we don't\n+     actually have both V and C valid.  */\n+  if (op == EQ || op ==  NE || op ==  GTU || op ==  LEU\n+      || op ==  LT || op ==  GE)\n+    {\n+      enum rtx_code e = GET_CODE (x);\n+\n+    /* Mentioning the rtx_code here is required but not sufficient: the\n+       insn also needs to be decorated with <setnz> (and the\n+       anonymization prefix <anz> for a named pattern).  */\n+      return e == PLUS || e == MINUS || e == MULT || e == NOT\n+\t? CC_NZmode : CCmode;\n+    }\n+\n+  /* We should only get here for comparison operators.  */\n+  gcc_assert (op ==  GEU || op ==  LTU || op ==  GT || op ==  LE);\n+\n+  return CC_NZVCmode;\n+}\n+\n+/* Worker function for TARGET_CC_MODES_COMPATIBLE.\n+   We start with CCmode for most comparisons, which merges and yields to\n+   CC_NZmode or CC_NZVCmode.  The exceptions have CC_NZVCmode and can't do with\n+   another mode.  */\n+\n+static machine_mode\n+cris_cc_modes_compatible (machine_mode m1, machine_mode m2)\n+{\n+  if (m1 == CC_NZVCmode)\n+    {\n+      if (m2 == CC_NZVCmode || m2 == CCmode)\n+\treturn CC_NZVCmode;\n+      return VOIDmode;\n+    }\n+\n+  if (m2 == CC_NZVCmode)\n+    {\n+      if (m1 == CC_NZVCmode || m1 == CCmode)\n+\treturn CC_NZVCmode;\n+      return VOIDmode;\n+    }\n+\n+  if (m1 != m2)\n+    return CC_NZmode;\n+\n+  return m1;\n+}\n+\n /* Return != 0 if the return sequence for the current function is short,\n    like \"ret\" or \"jump [sp+]\".  Prior to reloading, we can't tell if\n    registers must be saved, so return 0 then.  */"}, {"sha": "2a938fe20263db641438e0711a450077d3d04173", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=b3e01c3d1b61ecc903b577920ca43804a2cb5497", "patch": "@@ -699,7 +699,9 @@ struct cum_args {int regs;};\n /* Node: Condition Code */\n \n /* FIXME: Maybe define TARGET_CANONICALIZE_COMPARISON later, when\n-   playing with optimizations.  Definitely define SELECT_CC_MODE.  */\n+   playing with optimizations.  */\n+\n+#define SELECT_CC_MODE(op, x, y) cris_select_cc_mode(op, x, y)\n \n #define REVERSIBLE_CC_MODE(MODE) true\n "}, {"sha": "362d63f6dc5b3d77cb3b4d1f0f4f34013e3ef475", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 108, "deletions": 70, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e01c3d1b61ecc903b577920ca43804a2cb5497/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=b3e01c3d1b61ecc903b577920ca43804a2cb5497", "patch": "@@ -179,16 +179,51 @@\n (define_code_attr shlr [(ashiftrt \"ashr\") (lshiftrt \"lshr\") (ashift \"ashl\")])\n (define_code_attr slr [(ashiftrt \"asr\") (lshiftrt \"lsr\") (ashift \"lsl\")])\n \n+;; Compares, branches, cbranch, cstore.  Conditions gt and le are CC_NZVC.\n+;; Others start out as CCmode and can degenerate to CC_NZmode.\n+;; Incidental setters are either CC_NZVCmode or CC_NZmode.  See also\n+;; cris-modes.def.\n+(define_mode_iterator NZSET [CC_NZ])\n+(define_mode_iterator NZUSE [CC CC_NZ CC_NZVC])\n+(define_mode_iterator NZVCSET [CC CC_NZVC CC_NZ])\n+(define_mode_iterator NZVCUSE [CC_NZVC])\n+\n+;; All conditions.\n+(define_code_iterator cond [eq ne gtu ltu geu leu gt le lt ge])\n+\n+;; Just equal and not equal.\n (define_code_iterator zcond [eq ne])\n-(define_code_iterator ncond [eq ne gtu ltu geu leu])\n-(define_code_iterator ocond [gt le])\n-(define_code_iterator rcond [lt ge])\n+\n+;; Conditions that look only at Z and/or N (or can do with that).\n+(define_code_iterator nzcond [eq ne gtu leu lt ge])\n+\n+;; The complement of nzcond within cond; conditions that look (also) on V\n+;; or C.\n+(define_code_iterator nzvccond [geu ltu gt le])\n+\n+;; Within nzcond, those that give different opcodes when operands are\n+;; reversed or that can ignore V or C.  Also, the complement of zcond\n+;; within nzcond.\n+(define_code_iterator rnzcond [gtu leu lt ge])\n+\n+;; CRIS condition mnemonic.\n (define_code_attr CC [(eq \"eq\") (ne \"ne\") (gt \"gt\") (gtu \"hi\") (lt \"lt\")\n \t\t      (ltu \"lo\") (ge \"ge\") (geu \"hs\") (le \"le\") (leu \"ls\")])\n+\n+;; CRIS reverse condition mnemonic.\n (define_code_attr rCC [(eq \"ne\") (ne \"eq\") (gt \"le\") (gtu \"ls\") (lt \"ge\")\n \t\t       (ltu \"hs\") (ge \"lt\") (geu \"lo\") (le \"gt\") (leu \"hi\")])\n-(define_code_attr oCC [(lt \"mi\") (ge \"pl\")])\n-(define_code_attr roCC [(lt \"pl\") (ge \"mi\")])\n+\n+;; Mnemomic for the CRIS condition when V or C can be ignored.\n+(define_code_attr oCC [(lt \"mi\") (ge \"pl\") (gtu \"eq\") (ltu \"ne\")])\n+\n+;; Reverse of oCC.\n+(define_code_attr roCC [(lt \"pl\") (ge \"mi\") (gtu \"eq\") (ltu \"ne\")])\n+\n+;; Required unoptimized CCmode, different for nzcond and nzvccond.\n+(define_code_attr xCC [(eq \"CC\") (ne \"CC\") (gtu \"CC\") (ltu \"CC_NZVC\")\n+\t\t       (geu \"CC_NZVC\") (leu \"CC\") (lt \"CC\") (ge \"CC\")\n+\t\t       (gt \"CC_NZVC\") (le \"CC_NZVC\")])\n \n ;; Operand and operator predicates.\n \n@@ -209,20 +244,21 @@\n ;; (It shouldn't be; it should be done as part of register allocation.)\n (define_mode_attr sCC_destc\n  [(DI \"r, r,r,r,r,r,r\") (SI \"r,r, r,  r,r,r\") (HI \"r, r,  r,r\") (QI \"r, r,  r,r\")])\n-(define_mode_attr cmp_op1c\n+(define_mode_attr cmp_op0c\n  [(DI \"rm,r,r,r,r,r,r\") (SI \"r,r, rQ>,r,r,m\") (HI \"r, rQ>,r,m\") (QI \"r, rQ>,r,m\")])\n-(define_mode_attr cmp_op2c\n+(define_mode_attr cmp_op1c\n  [(DI \"M,Kc,I,P,n,r,o\") (SI \"I,rQ>,M, P,g,M\") (HI \"rQ>,M, g,M\") (QI \"rQ>,M, g,M\")])\n \n ;; We could optimize the sizes of the immediate operands for various\n ;; cases, but that is not worth it because of the very little usage of\n ;; DImode for anything else but a structure/block-mode.  Just do the\n ;; obvious stuff for the straight-forward constraint letters.\n \n-(define_insn \"*cmpdi\"\n-  [(set (reg:CC CRIS_CC0_REGNUM)\n-\t(compare:CC (match_operand:DI_ 0 \"nonimmediate_operand\" \"<cmp_op1c>\")\n-\t\t    (match_operand:DI_ 1 \"general_operand\" \"<cmp_op2c>\")))]\n+(define_insn \"*cmpdi<NZVCSET:mode>\"\n+  [(set (reg:NZVCSET CRIS_CC0_REGNUM)\n+\t(compare:NZVCSET\n+\t (match_operand:DI_ 0 \"nonimmediate_operand\" \"<cmp_op0c>\")\n+\t (match_operand:DI_ 1 \"general_operand\" \"<cmp_op1c>\")))]\n   \"reload_completed\"\n   \"@\n    test.d %M0\\;ax\\;test.d %H0\n@@ -252,9 +288,9 @@\n ;; constants, but sometimes gcc will find its way to use it for other\n ;; (memory) operands.  Avoid side-effect patterns, though (see above).\n \n-(define_insn \"*cmp_ext<mode>\"\n-  [(set (reg:CC CRIS_CC0_REGNUM)\n-\t(compare:CC\n+(define_insn \"*cmp_ext<BW:mode><NZVCSET:mode>\"\n+  [(set (reg:NZVCSET CRIS_CC0_REGNUM)\n+\t(compare:NZVCSET\n \t (match_operand:SI 0 \"register_operand\" \"r,r\")\n \t (match_operator:SI 2 \"cris_extend_operator\"\n \t\t\t [(match_operand:BW 1 \"memory_operand\" \"Q>,m\")])))]\n@@ -265,11 +301,11 @@\n ;; The \"normal\" compare patterns, from SI on.  Special-cases with zero\n ;; are covered above.\n \n-(define_insn \"*cmpsi\"\n-  [(set (reg:CC CRIS_CC0_REGNUM)\n-\t(compare:CC\n-\t (match_operand:SI_ 0 \"nonimmediate_operand\" \"<cmp_op1c>\")\n-\t (match_operand:SI_ 1 \"general_operand\" \"<cmp_op2c>\")))]\n+(define_insn \"*cmpsi<NZVCSET:mode>\"\n+  [(set (reg:NZVCSET CRIS_CC0_REGNUM)\n+\t(compare:NZVCSET\n+\t (match_operand:SI_ 0 \"nonimmediate_operand\" \"<cmp_op0c>\")\n+\t (match_operand:SI_ 1 \"general_operand\" \"<cmp_op1c>\")))]\n   \"reload_completed\"\n   \"@\n    cmpq %1,%0\n@@ -280,10 +316,11 @@\n    test.d %0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,no,no,no\")])\n \n-(define_insn \"*cmp<mode>\"\n-  [(set (reg:CC CRIS_CC0_REGNUM)\n-\t(compare:CC (match_operand:BW 0 \"nonimmediate_operand\" \"<cmp_op1c>\")\n-\t\t    (match_operand:BW 1 \"general_operand\" \"<cmp_op2c>\")))]\n+(define_insn \"*cmp<BW:mode><NZVCSET:mode>\"\n+  [(set (reg:NZVCSET CRIS_CC0_REGNUM)\n+\t(compare:NZVCSET\n+\t (match_operand:BW 0 \"nonimmediate_operand\" \"<cmp_op0c>\")\n+\t (match_operand:BW 1 \"general_operand\" \"<cmp_op1c>\")))]\n   \"reload_completed\"\n   \"@\n    cmp<m> %1,%0\n@@ -299,9 +336,9 @@\n \n ;; SImode.  This mode is the only one needed, since gcc automatically\n ;; extends subregs for lower-size modes.  FIXME: Add testcase.\n-(define_insn \"*btst\"\n-  [(set (reg:CC CRIS_CC0_REGNUM)\n-\t(compare:CC\n+(define_insn \"*btst<mode>\"\n+  [(set (reg:NZVCSET CRIS_CC0_REGNUM)\n+\t(compare:NZVCSET\n \t (zero_extract:SI\n \t  (match_operand:SI 0 \"nonmemory_operand\" \"r, r,r, r,r, r,Kp\")\n \t  (match_operand:SI 1 \"const_int_operand\" \"Kc,n,Kc,n,Kc,n,n\")\n@@ -1978,22 +2015,23 @@\n   \"\"\n   \"cris_reduce_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_insn_and_split \"*cbranch<mode>4\"\n+(define_insn_and_split \"*cbranch<mode><code>4\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"ordered_comparison_operator\"\n-\t  [(match_operand:BWDD 1 \"nonimmediate_operand\" \"<cmp_op1c>\")\n-\t   (match_operand:BWDD 2 \"general_operand\" \"<cmp_op2c>\")])\n-\t (label_ref (match_operand 3 \"\"))\n+\t (cond\n+\t  (match_operand:BWDD 0 \"nonimmediate_operand\" \"<cmp_op0c>\")\n+\t  (match_operand:BWDD 1 \"general_operand\" \"<cmp_op1c>\"))\n+\t (label_ref (match_operand 2 \"\"))\n \t (pc)))\n    (clobber (reg:CC CRIS_CC0_REGNUM))]\n   \"\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (reg:CC CRIS_CC0_REGNUM) (compare:CC (match_dup 1) (match_dup 2)))\n+  [(set (reg:<xCC> CRIS_CC0_REGNUM)\n+\t(compare:<xCC> (match_dup 0) (match_dup 1)))\n    (set (pc)\n-\t(if_then_else (match_op_dup 0 [(reg:CC CRIS_CC0_REGNUM) (const_int 0)])\n-\t\t      (label_ref (match_dup 3))\n+\t(if_then_else (cond (reg:<xCC> CRIS_CC0_REGNUM) (const_int 0))\n+\t\t      (label_ref (match_dup 2))\n \t\t      (pc)))]\n   \"\")\n \n@@ -2019,7 +2057,7 @@\n \t (const_int 0)))\n    (set (pc)\n \t(if_then_else (zcond (reg:CC CRIS_CC0_REGNUM) (const_int 0))\n-\t\t      (label_ref (match_dup 3))\n+\t\t      (label_ref (match_dup 2))\n \t\t      (pc)))]\n   \"\")\n \n@@ -2028,70 +2066,70 @@\n ;; e.g. m68k, so we have to check if overflow bit is set on all \"signed\"\n ;; conditions.\n \n-(define_insn \"b<ncond:code>\"\n+(define_insn \"b<zcond:code><mode>\"\n   [(set (pc)\n-\t(if_then_else (ncond (reg:CC CRIS_CC0_REGNUM)\n+\t(if_then_else (zcond (reg:NZUSE CRIS_CC0_REGNUM)\n \t\t\t     (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"reload_completed\"\n   \"b<CC> %l0%#\"\n   [(set_attr \"slottable\" \"has_slot\")])\n \n-(define_insn \"b<ocond:code>\"\n+(define_insn \"b<nzvccond:code><mode>\"\n   [(set (pc)\n-\t(if_then_else (ocond (reg:CC CRIS_CC0_REGNUM)\n+\t(if_then_else (nzvccond (reg:NZVCUSE CRIS_CC0_REGNUM)\n \t\t\t     (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"reload_completed\"\n-  ;; FIXME: optimize out the compare and handle CC_NO_OVERFLOW.\n   \"b<CC> %l0%#\"\n   [(set_attr \"slottable\" \"has_slot\")])\n \n-(define_insn \"b<rcond:code>\"\n+(define_insn \"b<rnzcond:code><mode>\"\n   [(set (pc)\n-\t(if_then_else (rcond (reg:CC CRIS_CC0_REGNUM)\n+\t(if_then_else (rnzcond (reg:NZUSE CRIS_CC0_REGNUM)\n \t\t\t     (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"reload_completed\"\n-  ;; FIXME: optimize out the compare and handle CC_NO_OVERFLOW.\n-  \"b<CC> %l0%#\"\n+{\n+  return <MODE>mode == CC_NZmode ? \"b<oCC> %l0%#\": \"b<CC> %l0%#\";\n+}\n   [(set_attr \"slottable\" \"has_slot\")])\n \f\n ;; Reversed anonymous patterns to the ones above, as mandated.\n \n-(define_insn \"*b<ncond:code>_reversed\"\n+(define_insn \"*b<nzcond:code>_reversed<mode>\"\n   [(set (pc)\n-\t(if_then_else (ncond (reg:CC CRIS_CC0_REGNUM)\n+\t(if_then_else (nzcond (reg:NZUSE CRIS_CC0_REGNUM)\n \t\t\t     (const_int 0))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"reload_completed\"\n   \"b<rCC> %l0%#\"\n   [(set_attr \"slottable\" \"has_slot\")])\n \n-(define_insn \"*b<ocond:code>_reversed\"\n+(define_insn \"*b<nzvccond:code>_reversed<mode>\"\n   [(set (pc)\n-\t(if_then_else (ocond (reg:CC CRIS_CC0_REGNUM)\n+\t(if_then_else (nzvccond (reg:NZVCUSE CRIS_CC0_REGNUM)\n \t\t\t     (const_int 0))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"reload_completed\"\n-  ;; FIXME: optimize out the compare and handle CC_NO_OVERFLOW.\n   \"b<rCC> %l0%#\"\n   [(set_attr \"slottable\" \"has_slot\")])\n \n-(define_insn \"*b<rcond:code>_reversed\"\n+(define_insn \"*b<rnzcond:code>_reversed<mode>\"\n   [(set (pc)\n-\t(if_then_else (rcond (reg:CC CRIS_CC0_REGNUM)\n+\t(if_then_else (rnzcond (reg:NZUSE CRIS_CC0_REGNUM)\n \t\t\t     (const_int 0))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"reload_completed\"\n-  ;; FIXME: optimize out the compare and handle CC_NO_OVERFLOW.\n-  \"b<rCC> %l0%#\"\n+{\n+  return <MODE>mode == CC_NZmode ? \"b<roCC> %l0%#\" : \"b<rCC> %l0%#\";\n+}\n   [(set_attr \"slottable\" \"has_slot\")])\n \f\n ;; Set on condition: sCC.\n@@ -2106,46 +2144,46 @@\n   \"\"\n   \"cris_reduce_compare (&operands[1], &operands[2], &operands[3]);\")\n \n-(define_insn_and_split \"*cstore<mode>4\"\n+(define_insn_and_split \"*cstore<mode><code>4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=<sCC_destc>\")\n-\t(match_operator:SI 1 \"ordered_comparison_operator\"\n-\t [(match_operand:BWDD 2 \"nonimmediate_operand\" \"<cmp_op1c>\")\n-\t  (match_operand:BWDD 3 \"general_operand\" \"<cmp_op2c>\")]))\n+\t(cond:SI\n+\t (match_operand:BWDD 1 \"nonimmediate_operand\" \"<cmp_op0c>\")\n+\t (match_operand:BWDD 2 \"general_operand\" \"<cmp_op1c>\")))\n    (clobber (reg:CC CRIS_CC0_REGNUM))]\n   \"\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (reg:CC CRIS_CC0_REGNUM) (compare:CC (match_dup 2) (match_dup 3)))\n-   (set (match_operand:SI 0 \"register_operand\")\n-\t(match_operator:SI 1 \"ordered_comparison_operator\"\n-\t [(reg:CC CRIS_CC0_REGNUM) (const_int 0)]))]\n+  [(set (reg:<xCC> CRIS_CC0_REGNUM)\n+\t(compare:<xCC> (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(cond:SI (reg:<xCC> CRIS_CC0_REGNUM) (const_int 0)))]\n   \"\")\n \n ;; Like bCC, we have to check the overflow bit for\n ;; signed conditions.\n \n-(define_insn \"*s<ncond:code>\"\n+(define_insn \"*s<nzcond:code><mode>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ncond:SI (reg:CC CRIS_CC0_REGNUM) (const_int 0)))]\n+\t(nzcond:SI (reg:NZUSE CRIS_CC0_REGNUM) (const_int 0)))]\n   \"reload_completed\"\n   \"s<CC> %0\"\n   [(set_attr \"slottable\" \"yes\")\n    (set_attr \"cc\" \"none\")])\n \n-(define_insn \"*s<rcond:code>\"\n+(define_insn \"*s<rnzcond:code><mode>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(rcond:SI (reg:CC CRIS_CC0_REGNUM) (const_int 0)))]\n+\t(rnzcond:SI (reg:NZUSE CRIS_CC0_REGNUM) (const_int 0)))]\n   \"reload_completed\"\n-  ;; FIXME: optimize out the compare and handle CC_NO_OVERFLOW.\n-  \"s<CC> %0\"\n+{\n+  return <MODE>mode == CC_NZmode ? \"s<oCC> %0\" : \"s<CC> %0\";\n+}\n   [(set_attr \"slottable\" \"yes\")\n    (set_attr \"cc\" \"none\")])\n \n-(define_insn \"*s<ocond:code>\"\n+(define_insn \"*s<nzvccond:code><mode>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ocond:SI (reg:CC CRIS_CC0_REGNUM) (const_int 0)))]\n+\t(nzvccond:SI (reg:NZVCUSE CRIS_CC0_REGNUM) (const_int 0)))]\n   \"reload_completed\"\n-  ;; FIXME: optimize out the compare and handle CC_NO_OVERFLOW.\n   \"s<CC> %0\"\n   [(set_attr \"slottable\" \"yes\")\n    (set_attr \"cc\" \"none\")])"}]}