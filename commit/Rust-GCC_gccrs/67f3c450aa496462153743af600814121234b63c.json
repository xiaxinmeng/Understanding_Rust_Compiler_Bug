{"sha": "67f3c450aa496462153743af600814121234b63c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmM2M0NTBhYTQ5NjQ2MjE1Mzc0M2FmNjAwODE0MTIxMjM0YjYzYw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2006-10-31T18:09:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:09:03Z"}, "message": "sem_disp.adb (Check_Dispatching_Operation): Do not flag subprograms inherited from an interface ancestor by another...\n\n2006-10-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_disp.adb (Check_Dispatching_Operation): Do not flag subprograms\n\tinherited from an interface ancestor by another interface in the\n\tcontext of an instance as 'late'.\n\t(Is_Tag_Indeterminate, Propagate_Tag): Handle properly the dereference\n\tof a call to a function that dispatches on access result.\n\t(Check_Dispatching_Operation): In case of late overriding of a primitive\n\tthat covers abstract interface subprograms we register it in all the\n\tsecondary dispatch tables associated with abstract interfaces.\n\t(Check_Dispatching_Call): Add check that a dispatching call is not made\n\tto a function with a controlling result of a limited type. This is a\n\tcurrent implementation restriction.\n\t(Check_Controlling_Formal): Remove bogus checks for E.2.2(14).\n\t(Check_Dispatching_Operation): Do no emit a warning if the controlling\n\targument is an interface type that is a generic formal.\n\t(Is_Interface_Subprogram): Removed.\n\t(Check_Dispatching_Operation): If the subprogram is not a dispatching\n\toperation, check the formals to handle the case in which it is\n\tassociated with an abstract interface type.\n\nFrom-SVN: r118308", "tree": {"sha": "9c45ac0587feaceb2cd3c805ca1ad16afa1c658a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c45ac0587feaceb2cd3c805ca1ad16afa1c658a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67f3c450aa496462153743af600814121234b63c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f3c450aa496462153743af600814121234b63c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f3c450aa496462153743af600814121234b63c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f3c450aa496462153743af600814121234b63c/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3100e48f7cdb3af1709b00d9d71a7932d92dcbba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3100e48f7cdb3af1709b00d9d71a7932d92dcbba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3100e48f7cdb3af1709b00d9d71a7932d92dcbba"}], "stats": {"total": 288, "additions": 166, "deletions": 122}, "files": [{"sha": "9ccbff7c71860fe3165a7b531167702105d10a3a", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 166, "deletions": 122, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f3c450aa496462153743af600814121234b63c/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f3c450aa496462153743af600814121234b63c/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=67f3c450aa496462153743af600814121234b63c", "patch": "@@ -29,9 +29,9 @@ with Debug;    use Debug;\n with Elists;   use Elists;\n with Einfo;    use Einfo;\n with Exp_Disp; use Exp_Disp;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Tss;  use Exp_Tss;\n-with Exp_Util; use Exp_Util;\n with Errout;   use Errout;\n with Hostparm; use Hostparm;\n with Nlists;   use Nlists;\n@@ -94,10 +94,6 @@ package body Sem_Disp is\n    is\n       Formal    : Entity_Id;\n       Ctrl_Type : Entity_Id;\n-      Remote    : constant Boolean :=\n-                    Is_Remote_Types (Current_Scope)\n-                      and then Comes_From_Source (Subp)\n-                      and then Scope (Typ) = Current_Scope;\n \n    begin\n       Formal := First_Formal (Subp);\n@@ -109,9 +105,9 @@ package body Sem_Disp is\n             if Ctrl_Type = Typ then\n                Set_Is_Controlling_Formal (Formal);\n \n-               --  Ada 2005 (AI-231):Anonymous access types used in controlling\n-               --  parameters exclude null because it is necessary to read the\n-               --  tag to dispatch, and null has no tag.\n+               --  Ada 2005 (AI-231): Anonymous access types used in\n+               --  controlling parameters exclude null because it is necessary\n+               --  to read the tag to dispatch, and null has no tag.\n \n                if Ekind (Etype (Formal)) = E_Anonymous_Access_Type then\n                   Set_Can_Never_Be_Null (Etype (Formal));\n@@ -153,16 +149,6 @@ package body Sem_Disp is\n                Error_Msg_N\n                  (\"operation can be dispatching in only one type\", Subp);\n             end if;\n-\n-         --  Verify that the restriction in E.2.2 (14) is obeyed\n-\n-         elsif Remote\n-           and then Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n-         then\n-            Error_Msg_N\n-              (\"access parameter of remote object primitive\"\n-               & \" must be controlling\",\n-                Formal);\n          end if;\n \n          Next_Formal (Formal);\n@@ -175,8 +161,7 @@ package body Sem_Disp is\n             if Ctrl_Type = Typ then\n                Set_Has_Controlling_Result (Subp);\n \n-               --  Check that the result subtype statically matches\n-               --  the first subtype.\n+               --  Check that result subtype statically matches first subtype\n \n                if not Subtypes_Statically_Match (Typ, Etype (Subp)) then\n                   Error_Msg_N\n@@ -187,18 +172,6 @@ package body Sem_Disp is\n                Error_Msg_N\n                  (\"operation can be dispatching in only one type\", Subp);\n             end if;\n-\n-         --  The following check is clearly required, although the RM says\n-         --  nothing about return types. If the return type is a limited\n-         --  class-wide type declared in the current scope, there is no way\n-         --  to declare stream procedures for it, so the return cannot be\n-         --  marshalled.\n-\n-         elsif Remote\n-           and then Is_Limited_Type (Typ)\n-           and then Etype (Subp) = Class_Wide_Type (Typ)\n-         then\n-            Error_Msg_N (\"return type has no stream attributes\", Subp);\n          end if;\n       end if;\n    end Check_Controlling_Formals;\n@@ -456,6 +429,25 @@ package body Sem_Disp is\n \n             Set_Controlling_Argument (N, Control);\n \n+            --  Ada 2005 (AI-318-02): Check current implementation restriction\n+            --  that a dispatching call cannot be made to a primitive function\n+            --  with a limited result type. This restriction can be removed\n+            --  once calls to limited functions with class-wide results are\n+            --  supported. ???\n+\n+            if Ada_Version = Ada_05\n+              and then Nkind (N) = N_Function_Call\n+            then\n+               Func := Entity (Name (N));\n+\n+               if Has_Controlling_Result (Func)\n+                 and then Is_Limited_Type (Etype (Func))\n+               then\n+                  Error_Msg_N (\"(Ada 2005) limited function call in this\" &\n+                    \" context is not yet implemented\", N);\n+               end if;\n+            end if;\n+\n          else\n             --  The call is not dispatching, so check that there aren't any\n             --  tag-indeterminate abstract calls left.\n@@ -574,6 +566,61 @@ package body Sem_Disp is\n            and then Is_Dispatching_Operation (Alias (Subp));\n \n       if No (Tagged_Type) then\n+\n+         --  Ada 2005 (AI-251): Check that Subp is not a primitive associated\n+         --  with an abstract interface type unless the interface acts as a\n+         --  parent type in a derivation. If the interface type is a formal\n+         --  type then the operation is not primitive and therefore legal.\n+\n+         declare\n+            E   : Entity_Id;\n+            Typ : Entity_Id;\n+\n+         begin\n+            E := First_Entity (Subp);\n+            while Present (E) loop\n+               if Is_Access_Type (Etype (E)) then\n+                  Typ := Designated_Type (Etype (E));\n+               else\n+                  Typ := Etype (E);\n+               end if;\n+\n+               if not Is_Class_Wide_Type (Typ)\n+                 and then Is_Interface (Typ)\n+                 and then not Is_Derived_Type (Typ)\n+                 and then not Is_Generic_Type (Typ)\n+               then\n+                  Error_Msg_N (\"?declaration of& is too late!\", Subp);\n+                  Error_Msg_NE\n+                    (\"\\spec should appear immediately after declaration of &!\",\n+                     Subp, Typ);\n+                  exit;\n+               end if;\n+\n+               Next_Entity (E);\n+            end loop;\n+\n+            --  In case of functions check also the result type\n+\n+            if Ekind (Subp) = E_Function then\n+               if Is_Access_Type (Etype (Subp)) then\n+                  Typ := Designated_Type (Etype (Subp));\n+               else\n+                  Typ := Etype (Subp);\n+               end if;\n+\n+               if not Is_Class_Wide_Type (Typ)\n+                 and then Is_Interface (Typ)\n+                 and then not Is_Derived_Type (Typ)\n+               then\n+                  Error_Msg_N (\"?declaration of& is too late!\", Subp);\n+                  Error_Msg_NE\n+                    (\"\\spec should appear immediately after declaration of &!\",\n+                     Subp, Typ);\n+               end if;\n+            end if;\n+         end;\n+\n          return;\n \n       --  The subprograms build internally after the freezing point (such as\n@@ -744,6 +791,41 @@ package body Sem_Disp is\n          else\n             Override_Dispatching_Operation (Tagged_Type, Old_Subp, Subp);\n             Set_Is_Overriding_Operation (Subp);\n+\n+            --  Ada 2005 (AI-251): In case of late overriding of a primitive\n+            --  that covers abstract interface subprograms we must register it\n+            --  in all the secondary dispatch tables associated with abstract\n+            --  interfaces.\n+\n+            if Body_Is_Last_Primitive then\n+               declare\n+                  Subp_Body : constant Node_Id := Unit_Declaration_Node (Subp);\n+                  Elmt      : Elmt_Id;\n+                  Prim      : Node_Id;\n+\n+               begin\n+                  Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n+                  while Present (Elmt) loop\n+                     Prim := Node (Elmt);\n+\n+                     if Present (Alias (Prim))\n+                       and then Present (Abstract_Interface_Alias (Prim))\n+                       and then Alias (Prim) = Subp\n+                     then\n+                        Register_Interface_DT_Entry (Subp_Body, Prim);\n+                     end if;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+\n+                  --  Redisplay the contents of the updated dispatch table.\n+\n+                  if Debug_Flag_ZZ then\n+                     Write_Str (\"Late overriding: \");\n+                     Write_DT (Tagged_Type);\n+                  end if;\n+               end;\n+            end if;\n          end if;\n \n       --  If no old subprogram, then we add this as a dispatching operation,\n@@ -815,7 +897,7 @@ package body Sem_Disp is\n \n             --  The new operation is added to the actions of the freeze\n             --  node for the type, but this node has already been analyzed,\n-            --  so we must retrieve and analyze explicitly the one new body,\n+            --  so we must retrieve and analyze explicitly the new body.\n \n             if Present (F_Node)\n               and then Present (Actions (F_Node))\n@@ -1176,6 +1258,16 @@ package body Sem_Disp is\n           Nkind (Prefix (Orig_Node)) /= N_Attribute_Reference\n       then\n          return True;\n+\n+      --  In Ada 2005 a function that returns an anonymous access type can\n+      --  dispatching, and the dereference of a call to such a function\n+      --  is also tag-indeterminate.\n+\n+      elsif Nkind (Orig_Node) = N_Explicit_Dereference\n+        and then Ada_Version >= Ada_05\n+      then\n+         return Is_Tag_Indeterminate (Prefix (Orig_Node));\n+\n       else\n          return False;\n       end if;\n@@ -1190,38 +1282,8 @@ package body Sem_Disp is\n       Prev_Op     : Entity_Id;\n       New_Op      : Entity_Id)\n    is\n-      Op_Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Tagged_Type));\n-      Elmt    : Elmt_Id;\n-      Found   : Boolean;\n-      E       : Entity_Id;\n-\n-      function Is_Interface_Subprogram (Op : Entity_Id) return Boolean;\n-      --  Traverse the list of aliased entities to check if the overriden\n-      --  entity corresponds with a primitive operation of an abstract\n-      --  interface type.\n-\n-      -----------------------------\n-      -- Is_Interface_Subprogram --\n-      -----------------------------\n-\n-      function Is_Interface_Subprogram (Op : Entity_Id) return Boolean is\n-         Aux : Entity_Id;\n-\n-      begin\n-         Aux := Op;\n-         while Present (Alias (Aux))\n-            and then Present (DTC_Entity (Alias (Aux)))\n-         loop\n-            if Is_Interface (Scope (DTC_Entity (Alias (Aux)))) then\n-               return True;\n-            end if;\n-            Aux := Alias (Aux);\n-         end loop;\n-\n-         return False;\n-      end Is_Interface_Subprogram;\n-\n-   --  Start of processing for Override_Dispatching_Operation\n+      Elmt : Elmt_Id;\n+      Prim : Node_Id;\n \n    begin\n       --  Diagnose failure to match No_Return in parent (Ada-2005, AI-414, but\n@@ -1232,79 +1294,52 @@ package body Sem_Disp is\n          Error_Msg_N (\"\\since overridden procedure has No_Return\", New_Op);\n       end if;\n \n-      --  Patch the primitive operation list\n+      --  If there is no previous operation to override, the type declaration\n+      --  was malformed, and an error must have been emitted already.\n \n-      while Present (Op_Elmt)\n-        and then Node (Op_Elmt) /= Prev_Op\n+      Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n+      while Present (Elmt)\n+        and then Node (Elmt) /= Prev_Op\n       loop\n-         Next_Elmt (Op_Elmt);\n+         Next_Elmt (Elmt);\n       end loop;\n \n-      --  If there is no previous operation to override, the type declaration\n-      --  was malformed, and an error must have been emitted already.\n-\n-      if No (Op_Elmt) then\n+      if No (Elmt) then\n          return;\n       end if;\n \n-      --  Ada 2005 (AI-251): Do not replace subprograms inherited from\n-      --  abstract interfaces. They will be used later to generate the\n-      --  corresponding thunks to initialize the Vtable (see subprogram\n-      --  Freeze_Subprogram). The inherited operation itself must also\n-      --  become hidden, to avoid spurious ambiguities;  name resolution\n-      --  must pick up only the operation that implements it,\n-\n-      if Is_Interface_Subprogram (Prev_Op) then\n-         Set_DT_Position              (Prev_Op, DT_Position (Alias (Prev_Op)));\n-         Set_Is_Abstract              (Prev_Op, Is_Abstract (New_Op));\n-         Set_Is_Overriding_Operation  (Prev_Op);\n-\n-         --  Traverse the list of aliased entities to look for the overriden\n-         --  abstract interface subprogram.\n-\n-         E := Alias (Prev_Op);\n-         while Present (Alias (E))\n-           and then Present (DTC_Entity (E))\n-           and then not (Is_Abstract (E))\n-           and then not Is_Interface (Scope (DTC_Entity (E)))\n-         loop\n-            E := Alias (E);\n-         end loop;\n+      Replace_Elmt (Elmt, New_Op);\n \n-         Set_Abstract_Interface_Alias (Prev_Op, E);\n-         Set_Alias                    (Prev_Op, New_Op);\n-         Set_Is_Internal              (Prev_Op);\n-         Set_Is_Hidden                (Prev_Op);\n+      if Ada_Version >= Ada_05\n+        and then Has_Abstract_Interfaces (Tagged_Type)\n+      then\n+         --  Ada 2005 (AI-251): Update the attribute alias of all the aliased\n+         --  entities of the overriden primitive to reference New_Op, and also\n+         --  propagate them the new value of the attribute Is_Abstract.\n \n-         --  Override predefined primitive operations\n+         Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n+         while Present (Elmt) loop\n+            Prim := Node (Elmt);\n \n-         if Is_Predefined_Dispatching_Operation (Prev_Op) then\n-            Replace_Elmt (Op_Elmt, New_Op);\n-            return;\n-         end if;\n+            if Prim = New_Op then\n+               null;\n \n-         --  Check if this primitive operation was previously added for another\n-         --  interface.\n+            elsif Present (Abstract_Interface_Alias (Prim))\n+              and then Alias (Prim) = Prev_Op\n+            then\n+               Set_Alias (Prim, New_Op);\n+               Set_Is_Abstract (Prim, Is_Abstract (New_Op));\n \n-         Elmt  := First_Elmt (Primitive_Operations (Tagged_Type));\n-         Found := False;\n-         while Present (Elmt) loop\n-            if Node (Elmt) = New_Op then\n-               Found := True;\n-               exit;\n+               --  Ensure that this entity will be expanded to fill the\n+               --  corresponding entry in its dispatch table.\n+\n+               if not Is_Abstract (Prim) then\n+                  Set_Has_Delayed_Freeze (Prim);\n+               end if;\n             end if;\n \n             Next_Elmt (Elmt);\n          end loop;\n-\n-         if not Found then\n-            Append_Elmt (New_Op, Primitive_Operations (Tagged_Type));\n-         end if;\n-\n-         return;\n-\n-      else\n-         Replace_Elmt (Op_Elmt, New_Op);\n       end if;\n \n       if (not Is_Package_Or_Generic_Package (Current_Scope))\n@@ -1350,6 +1385,15 @@ package body Sem_Disp is\n \n          Call_Node := Expression (Parent (Entity (Actual)));\n \n+      --  Ada 2005: If this is a dereference of a call to a function with a\n+      --  dispatching access-result, the tag is propagated when the dereference\n+      --  itself is expanded (see exp_ch6.adb) and there is nothing else to do.\n+\n+      elsif Nkind (Actual) = N_Explicit_Dereference\n+        and then Nkind (Original_Node (Prefix (Actual))) = N_Function_Call\n+      then\n+         return;\n+\n       --  Only other possibilities are parenthesized or qualified expression,\n       --  or an expander-generated unchecked conversion of a function call to\n       --  a stream Input attribute."}]}