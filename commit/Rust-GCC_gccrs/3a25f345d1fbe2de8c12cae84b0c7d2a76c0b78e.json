{"sha": "3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EyNWYzNDVkMWZiZTJkZThjMTJjYWU4NGIwYzdkMmE3NmMwYjc4ZQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-02-24T17:12:28Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-02-24T23:28:35Z"}, "message": "analyzer: fix ICE with OFFSET_TYPE [PR 93899]\n\nPR analyzer/93899 reports an ICE within make_region_for_type when\nhandling a param of type OFFSET_TYPE within\nexploded_graph::add_function_entry.\n\nThis patch fixes the ICE by further generalizing the \"give up on this\ntree code\" logic from\n  r10-6667-gf76a88ebf089871dcce215aa0cb1956ccc060895\n     for PR analyzer/93388 and\n  r10-6695-g2e6233935c77b56a68e939c629702f960b8e6fb2\n     for PR analyzer/93778\nby replacing the gcc_unreachable in make_region_for_type with a return\nof NULL, and handling this in add_region_for_type by notifying the ctxt.\n\nDoing so means that numerous places that create regions now need to have\na context passed to them, so most of the patch is churn involved in\npassing a context around to where it's needed.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/93899\n\t* engine.cc\n\t(impl_region_model_context::impl_region_model_context): Add logger\n\tparam.\n\t* engine.cc (exploded_graph::add_function_entry): Create an\n\timpl_region_model_context and pass it to the push_frame call.\n\tBail if the resulting state is invalid.\n\t(exploded_graph::build_initial_worklist): Likewise.\n\t(exploded_graph::build_initial_worklist): Handle the case where\n\tadd_function_entry fails.\n\t* exploded-graph.h\n\t(impl_region_model_context::impl_region_model_context): Add logger\n\tparam.\n\t* region-model.cc (map_region::get_or_create): Add ctxt param and\n\tpass it to add_region_for_type.\n\t(map_region::can_merge_p): Pass NULL as a ctxt to call to\n\tget_or_create.\n\t(array_region::get_element): Pass ctxt to call to get_or_create.\n\t(array_region::get_or_create): Add ctxt param and pass it to\n\tadd_region_for_type.\n\t(root_region::push_frame): Pass ctxt to get_or_create calls.\n\t(region_model::get_lvalue_1): Likewise.\n\t(region_model::make_region_for_unexpected_tree_code): Assert that\n\tctxt is non-NULL.\n\t(region_model::get_rvalue_1): Pass ctxt to get_svalue_for_fndecl\n\tand get_svalue_for_label calls.\n\t(region_model::get_svalue_for_fndecl): Add ctxt param and pass it\n\tto get_region_for_fndecl.\n\t(region_model::get_region_for_fndecl): Add ctxt param and pass it\n\tto get_or_create.\n\t(region_model::get_svalue_for_label): Add ctxt param and pass it\n\tto get_region_for_label.\n\t(region_model::get_region_for_label): Add ctxt param and pass it\n\tto get_region_for_fndecl and get_or_create.\n\t(region_model::get_field_region): Add ctxt param and pass it to\n\tget_or_create_view and get_or_create.\n\t(make_region_for_type): Replace gcc_unreachable with return NULL.\n\t(region_model::add_region_for_type): Add ctxt param.  Handle a\n\treturn of NULL from make_region_for_type by calling\n\tmake_region_for_unexpected_tree_code.\n\t(region_model::get_or_create_mem_ref): Pass ctxt to calls to\n\tget_or_create_view.\n\t(region_model::get_or_create_view): Add ctxt param and pass it to\n\tadd_region_for_type.\n\t(selftest::test_state_merging): Pass ctxt to get_or_create_view.\n\t* region-model.h (region_model::get_or_create): Add ctxt param.\n\t(region_model::add_region_for_type): Likewise.\n\t(region_model::get_svalue_for_fndecl): Likewise.\n\t(region_model::get_svalue_for_label): Likewise.\n\t(region_model::get_region_for_fndecl): Likewise.\n\t(region_model::get_region_for_label): Likewise.\n\t(region_model::get_field_region): Likewise.\n\t(region_model::get_or_create_view): Likewise.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/93899\n\t* g++.dg/analyzer/pr93899.C: New test.", "tree": {"sha": "ae11948c8297d90695c72caf23cb4c6ff9379eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae11948c8297d90695c72caf23cb4c6ff9379eb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4dbb9b25a60143c699de55cd6226cebeb3b3c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4dbb9b25a60143c699de55cd6226cebeb3b3c3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4dbb9b25a60143c699de55cd6226cebeb3b3c3e"}], "stats": {"total": 229, "additions": 167, "deletions": 62}, "files": [{"sha": "0882ec6ac3abbc0b0cf45f4912bd23da86b42f02", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "patch": "@@ -1,3 +1,59 @@\n+2020-02-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/93899\n+\t* engine.cc\n+\t(impl_region_model_context::impl_region_model_context): Add logger\n+\tparam.\n+\t* engine.cc (exploded_graph::add_function_entry): Create an\n+\timpl_region_model_context and pass it to the push_frame call.\n+\tBail if the resulting state is invalid.\n+\t(exploded_graph::build_initial_worklist): Likewise.\n+\t(exploded_graph::build_initial_worklist): Handle the case where\n+\tadd_function_entry fails.\n+\t* exploded-graph.h\n+\t(impl_region_model_context::impl_region_model_context): Add logger\n+\tparam.\n+\t* region-model.cc (map_region::get_or_create): Add ctxt param and\n+\tpass it to add_region_for_type.\n+\t(map_region::can_merge_p): Pass NULL as a ctxt to call to\n+\tget_or_create.\n+\t(array_region::get_element): Pass ctxt to call to get_or_create.\n+\t(array_region::get_or_create): Add ctxt param and pass it to\n+\tadd_region_for_type.\n+\t(root_region::push_frame): Pass ctxt to get_or_create calls.\n+\t(region_model::get_lvalue_1): Likewise.\n+\t(region_model::make_region_for_unexpected_tree_code): Assert that\n+\tctxt is non-NULL.\n+\t(region_model::get_rvalue_1): Pass ctxt to get_svalue_for_fndecl\n+\tand get_svalue_for_label calls.\n+\t(region_model::get_svalue_for_fndecl): Add ctxt param and pass it\n+\tto get_region_for_fndecl.\n+\t(region_model::get_region_for_fndecl): Add ctxt param and pass it\n+\tto get_or_create.\n+\t(region_model::get_svalue_for_label): Add ctxt param and pass it\n+\tto get_region_for_label.\n+\t(region_model::get_region_for_label): Add ctxt param and pass it\n+\tto get_region_for_fndecl and get_or_create.\n+\t(region_model::get_field_region): Add ctxt param and pass it to\n+\tget_or_create_view and get_or_create.\n+\t(make_region_for_type): Replace gcc_unreachable with return NULL.\n+\t(region_model::add_region_for_type): Add ctxt param.  Handle a\n+\treturn of NULL from make_region_for_type by calling\n+\tmake_region_for_unexpected_tree_code.\n+\t(region_model::get_or_create_mem_ref): Pass ctxt to calls to\n+\tget_or_create_view.\n+\t(region_model::get_or_create_view): Add ctxt param and pass it to\n+\tadd_region_for_type.\n+\t(selftest::test_state_merging): Pass ctxt to get_or_create_view.\n+\t* region-model.h (region_model::get_or_create): Add ctxt param.\n+\t(region_model::add_region_for_type): Likewise.\n+\t(region_model::get_svalue_for_fndecl): Likewise.\n+\t(region_model::get_svalue_for_label): Likewise.\n+\t(region_model::get_region_for_fndecl): Likewise.\n+\t(region_model::get_region_for_label): Likewise.\n+\t(region_model::get_field_region): Likewise.\n+\t(region_model::get_or_create_view): Likewise.\n+\n 2020-02-24  David Malcolm  <dmalcolm@redhat.com>\n \n \t* checker-path.cc (superedge_event::should_filter_p): Update"}, {"sha": "7f8a4223eed94e1e64eea9c12ef32fbd0cb0d578", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "patch": "@@ -90,8 +90,9 @@ impl_region_model_context (exploded_graph &eg,\n impl_region_model_context::\n impl_region_model_context (program_state *state,\n \t\t\t   state_change *change,\n-\t\t\t   const extrinsic_state &ext_state)\n-: m_eg (NULL), m_logger (NULL), m_enode_for_diag (NULL),\n+\t\t\t   const extrinsic_state &ext_state,\n+\t\t\t   logger *logger)\n+: m_eg (NULL), m_logger (logger), m_enode_for_diag (NULL),\n   m_old_state (NULL),\n   m_new_state (state),\n   m_change (change),\n@@ -1829,7 +1830,11 @@ exploded_graph::add_function_entry (function *fun)\n {\n   program_point point = program_point::from_function_entry (m_sg, fun);\n   program_state state (m_ext_state);\n-  state.m_region_model->push_frame (fun, NULL, NULL);\n+  impl_region_model_context ctxt (&state, NULL, m_ext_state, get_logger ());\n+  state.m_region_model->push_frame (fun, NULL, &ctxt);\n+\n+  if (!state.m_valid)\n+    return NULL;\n \n   exploded_node *enode = get_or_create_node (point, state, NULL);\n   /* We should never fail to add such a node.  */\n@@ -2150,8 +2155,13 @@ exploded_graph::build_initial_worklist ()\n       continue;\n     exploded_node *enode = add_function_entry (fun);\n     if (logger)\n-      logger->log (\"created EN %i for %qE entrypoint\",\n-\t\t   enode->m_index, fun->decl);\n+      {\n+\tif (enode)\n+\t  logger->log (\"created EN %i for %qE entrypoint\",\n+\t\t       enode->m_index, fun->decl);\n+\telse\n+\t  logger->log (\"did not create enode for %qE entrypoint\", fun->decl);\n+      }\n   }\n }\n "}, {"sha": "7c2612d7b85eeaf9e44fdefcffdecbbcdb0682be", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "patch": "@@ -43,7 +43,8 @@ class impl_region_model_context : public region_model_context\n \n   impl_region_model_context (program_state *state,\n \t\t\t     state_change *change,\n-\t\t\t     const extrinsic_state &ext_state);\n+\t\t\t     const extrinsic_state &ext_state,\n+\t\t\t     logger *logger = NULL);\n \n   void warn (pending_diagnostic *d) FINAL OVERRIDE;\n "}, {"sha": "a71884d7b118699ca38de3a210064305cb29a1b5", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "patch": "@@ -1660,20 +1660,22 @@ map_region::dump_child_label (const region_model &model,\n    If it doesn't already exist, create a child map_region, using TYPE for\n    its type.\n    Return the region_id of the child (whether pre-existing, or\n-   newly-created).  */\n+   newly-created).\n+   Notify CTXT if we don't know how to handle TYPE.  */\n \n region_id\n map_region::get_or_create (region_model *model,\n \t\t\t   region_id this_rid,\n \t\t\t   tree key,\n-\t\t\t   tree type)\n+\t\t\t   tree type,\n+\t\t\t   region_model_context *ctxt)\n {\n   gcc_assert (key);\n   gcc_assert (valid_key_p (key));\n   region_id *slot = m_map.get (key);\n   if (slot)\n     return *slot;\n-  region_id child_rid = model->add_region_for_type (this_rid, type);\n+  region_id child_rid = model->add_region_for_type (this_rid, type, ctxt);\n   m_map.put (key, child_rid);\n   return child_rid;\n }\n@@ -1906,7 +1908,8 @@ map_region::can_merge_p (const map_region *map_region_a,\n \t    = merged_map_region->get_or_create (merger->m_merged_model,\n \t\t\t\t\t\tmerged_rid,\n \t\t\t\t\t\tkey_a,\n-\t\t\t\t\t\tchild_region_a->get_type ());\n+\t\t\t\t\t\tchild_region_a->get_type (),\n+\t\t\t\t\t\tNULL);\n \n \t  region *child_merged_region\n \t    = merger->m_merged_model->get_region (child_merged_rid);\n@@ -2194,19 +2197,19 @@ region_id\n array_region::get_element (region_model *model,\n \t\t\t   region_id this_rid,\n \t\t\t   svalue_id index_sid,\n-\t\t\t   region_model_context *ctxt ATTRIBUTE_UNUSED)\n+\t\t\t   region_model_context *ctxt)\n {\n   tree element_type = TREE_TYPE (get_type ());\n   svalue *index_sval = model->get_svalue (index_sid);\n   if (tree cst_index = index_sval->maybe_get_constant ())\n     {\n       key_t key = key_from_constant (cst_index);\n       region_id element_rid\n-\t= get_or_create (model, this_rid, key, element_type);\n+\t= get_or_create (model, this_rid, key, element_type, ctxt);\n       return element_rid;\n    }\n \n-  return model->get_or_create_view (this_rid, element_type);\n+  return model->get_or_create_view (this_rid, element_type, ctxt);\n }\n \n /* Implementation of region::clone vfunc for array_region.  */\n@@ -2323,18 +2326,20 @@ array_region::dump_child_label (const region_model &model,\n    If it doesn't already exist, create a child array_region, using TYPE for\n    its type.\n    Return the region_id of the child (whether pre-existing, or\n-   newly-created).  */\n+   newly-created).\n+   Notify CTXT if we don't know how to handle TYPE.  */\n \n region_id\n array_region::get_or_create (region_model *model,\n \t\t\t     region_id this_rid,\n \t\t\t     key_t key,\n-\t\t\t     tree type)\n+\t\t\t     tree type,\n+\t\t\t     region_model_context *ctxt)\n {\n   region_id *slot = m_map.get (key);\n   if (slot)\n     return *slot;\n-  region_id child_rid = model->add_region_for_type (this_rid, type);\n+  region_id child_rid = model->add_region_for_type (this_rid, type, ctxt);\n   m_map.put (key, child_rid);\n   return child_rid;\n }\n@@ -2890,7 +2895,7 @@ root_region::push_frame (region_model *model, function *fun,\n \t  svalue_id arg_sid = (*arg_sids)[idx];\n \t  region_id parm_rid\n \t    = region->get_or_create (model, frame_rid, iter_parm,\n-\t\t\t\t     TREE_TYPE (iter_parm));\n+\t\t\t\t     TREE_TYPE (iter_parm), ctxt);\n \t  model->set_value (parm_rid, arg_sid, ctxt);\n \n \t  /* Also do it for default SSA name (sharing the same unknown\n@@ -2900,7 +2905,7 @@ root_region::push_frame (region_model *model, function *fun,\n \t    {\n \t      region_id defssa_rid\n \t\t= region->get_or_create (model, frame_rid, parm_default_ssa,\n-\t\t\t\t\t TREE_TYPE (iter_parm));\n+\t\t\t\t\t TREE_TYPE (iter_parm), ctxt);\n \t      model->set_value (defssa_rid, arg_sid, ctxt);\n \t    }\n \t}\n@@ -2917,7 +2922,7 @@ root_region::push_frame (region_model *model, function *fun,\n \t{\n \t  region_id parm_rid\n \t    = region->get_or_create (model, frame_rid, iter_parm,\n-\t\t\t\t     TREE_TYPE (iter_parm));\n+\t\t\t\t     TREE_TYPE (iter_parm), ctxt);\n \t  svalue_id parm_sid\n \t    = model->set_to_new_unknown_value (parm_rid, TREE_TYPE (iter_parm),\n \t\t\t\t\t       ctxt);\n@@ -2929,7 +2934,7 @@ root_region::push_frame (region_model *model, function *fun,\n \t    {\n \t      region_id defssa_rid\n \t\t= region->get_or_create (model, frame_rid, parm_default_ssa,\n-\t\t\t\t\t TREE_TYPE (iter_parm));\n+\t\t\t\t\t TREE_TYPE (iter_parm), ctxt);\n \t      model->get_region (defssa_rid)->set_value (*model, defssa_rid,\n \t\t\t\t\t\t\t parm_sid, ctxt);\n \t    }\n@@ -4665,7 +4670,8 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt)\n       {\n \t/* For now, create a view, as if a cast, ignoring the bit positions.  */\n \ttree obj = TREE_OPERAND (expr, 0);\n-\treturn get_or_create_view (get_lvalue (obj, ctxt), TREE_TYPE (expr));\n+\treturn get_or_create_view (get_lvalue (obj, ctxt), TREE_TYPE (expr),\n+\t\t\t\t   ctxt);\n       };\n       break;\n \n@@ -4688,7 +4694,7 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt)\n \t    = get_root_region ()->ensure_globals_region (this);\n \t  map_region *globals = get_region<map_region> (globals_rid);\n \t  region_id var_rid = globals->get_or_create (this, globals_rid, expr,\n-\t\t\t\t\t\t      TREE_TYPE (expr));\n+\t\t\t\t\t\t      TREE_TYPE (expr), ctxt);\n \t  return var_rid;\n \t}\n \n@@ -4710,7 +4716,7 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt)\n \tframe_region *frame = get_region <frame_region> (frame_rid);\n \tgcc_assert (frame);\n \tregion_id child_rid = frame->get_or_create (this, frame_rid, expr,\n-\t\t\t\t\t\t    TREE_TYPE (expr));\n+\t\t\t\t\t\t    TREE_TYPE (expr), ctxt);\n \treturn child_rid;\n       }\n \n@@ -4726,15 +4732,15 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt)\n \t\t\t\t\t\t       dump_location_t ());\n \tregion_id obj_rid = get_lvalue (obj, ctxt);\n \tregion_id struct_or_union_rid\n-\t  = get_or_create_view (obj_rid, TREE_TYPE (obj));\n-\treturn get_field_region (struct_or_union_rid, field);\n+\t  = get_or_create_view (obj_rid, TREE_TYPE (obj), ctxt);\n+\treturn get_field_region (struct_or_union_rid, field, ctxt);\n       }\n       break;\n \n     case CONST_DECL:\n       {\n \ttree cst_type = TREE_TYPE (expr);\n-\tregion_id cst_rid = add_region_for_type (m_root_rid, cst_type);\n+\tregion_id cst_rid = add_region_for_type (m_root_rid, cst_type, ctxt);\n \tif (tree value = DECL_INITIAL (expr))\n \t  {\n \t    svalue_id sid = get_rvalue (value, ctxt);\n@@ -4758,7 +4764,8 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt)\n     case VIEW_CONVERT_EXPR:\n       {\n \ttree obj = TREE_OPERAND (expr, 0);\n-\treturn get_or_create_view (get_lvalue (obj, ctxt), TREE_TYPE (expr));\n+\treturn get_or_create_view (get_lvalue (obj, ctxt), TREE_TYPE (expr),\n+\t\t\t\t   ctxt);\n       };\n       break;\n     }\n@@ -4776,6 +4783,7 @@ region_model::make_region_for_unexpected_tree_code (region_model_context *ctxt,\n \t\t\t\t\t\t    tree t,\n \t\t\t\t\t\t    const dump_location_t &loc)\n {\n+  gcc_assert (ctxt);\n   region_id new_rid\n     = add_region (new symbolic_region (m_root_rid, NULL_TREE, false));\n   ctxt->on_unexpected_tree_code (t, loc);\n@@ -4840,9 +4848,9 @@ region_model::get_rvalue_1 (path_var pv, region_model_context *ctxt)\n \ttree expr = pv.m_tree;\n \ttree op0 = TREE_OPERAND (expr, 0);\n \tif (TREE_CODE (op0) == FUNCTION_DECL)\n-\t  return get_svalue_for_fndecl (TREE_TYPE (expr), op0);\n+\t  return get_svalue_for_fndecl (TREE_TYPE (expr), op0, ctxt);\n \telse if (TREE_CODE (op0) == LABEL_DECL)\n-\t  return get_svalue_for_label (TREE_TYPE (expr), op0);\n+\t  return get_svalue_for_label (TREE_TYPE (expr), op0, ctxt);\n \tregion_id expr_rid = get_lvalue (op0, ctxt);\n \treturn get_or_create_ptr_svalue (TREE_TYPE (expr), expr_rid);\n       }\n@@ -4945,52 +4953,58 @@ region_model::get_or_create_constant_svalue (tree cst_expr)\n    creating the function_region if necessary.  */\n \n svalue_id\n-region_model::get_svalue_for_fndecl (tree ptr_type, tree fndecl)\n+region_model::get_svalue_for_fndecl (tree ptr_type, tree fndecl,\n+\t\t\t\t     region_model_context *ctxt)\n {\n   gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n-  region_id function_rid = get_region_for_fndecl (fndecl);\n+  region_id function_rid = get_region_for_fndecl (fndecl, ctxt);\n   return get_or_create_ptr_svalue (ptr_type, function_rid);\n }\n \n /* Return a region_id for a function_region for FNDECL,\n    creating it if necessary.  */\n \n region_id\n-region_model::get_region_for_fndecl (tree fndecl)\n+region_model::get_region_for_fndecl (tree fndecl,\n+\t\t\t\t     region_model_context *ctxt)\n {\n   gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n \n   region_id code_rid = get_root_region ()->ensure_code_region (this);\n   code_region *code = get_root_region ()->get_code_region (this);\n \n-  return code->get_or_create (this, code_rid, fndecl, TREE_TYPE (fndecl));\n+  return code->get_or_create (this, code_rid, fndecl, TREE_TYPE (fndecl),\n+\t\t\t      ctxt);\n }\n \n /* Return an svalue_id for a region_svalue for LABEL,\n    creating the label_region if necessary.  */\n \n svalue_id\n-region_model::get_svalue_for_label (tree ptr_type, tree label)\n+region_model::get_svalue_for_label (tree ptr_type, tree label,\n+\t\t\t\t    region_model_context *ctxt)\n {\n   gcc_assert (TREE_CODE (label) == LABEL_DECL);\n-  region_id label_rid = get_region_for_label (label);\n+  region_id label_rid = get_region_for_label (label, ctxt);\n   return get_or_create_ptr_svalue (ptr_type, label_rid);\n }\n \n /* Return a region_id for a label_region for LABEL,\n    creating it if necessary.  */\n \n region_id\n-region_model::get_region_for_label (tree label)\n+region_model::get_region_for_label (tree label,\n+\t\t\t\t    region_model_context *ctxt)\n {\n   gcc_assert (TREE_CODE (label) == LABEL_DECL);\n \n   tree fndecl = DECL_CONTEXT (label);\n   gcc_assert (fndecl && TREE_CODE (fndecl) == FUNCTION_DECL);\n \n-  region_id func_rid = get_region_for_fndecl (fndecl);\n+  region_id func_rid = get_region_for_fndecl (fndecl, ctxt);\n   function_region *func_reg = get_region <function_region> (func_rid);\n-  return func_reg->get_or_create (this, func_rid, label, TREE_TYPE (label));\n+  return func_reg->get_or_create (this, func_rid, label, TREE_TYPE (label),\n+\t\t\t\t  ctxt);\n }\n \n /* Build a cast of SRC_EXPR to DST_TYPE, or return NULL_TREE.\n@@ -5124,7 +5138,8 @@ region_model::maybe_cast (tree dst_type, svalue_id sid,\n    return the child region's region_id.  */\n \n region_id\n-region_model::get_field_region (region_id struct_or_union_rid, tree field)\n+region_model::get_field_region (region_id struct_or_union_rid, tree field,\n+\t\t\t\tregion_model_context *ctxt)\n {\n   struct_or_union_region *sou_reg\n     = get_region<struct_or_union_region> (struct_or_union_rid);\n@@ -5141,15 +5156,15 @@ region_model::get_field_region (region_id struct_or_union_rid, tree field)\n       /* Union.\n \t Get a view of the union as a whole, with the type of the field.  */\n       region_id view_rid\n-\t= get_or_create_view (struct_or_union_rid, field_type_with_quals);\n+\t= get_or_create_view (struct_or_union_rid, field_type_with_quals, ctxt);\n       return view_rid;\n     }\n   else\n     {\n       /* Struct.  */\n       region_id child_rid\n \t= sou_reg->get_or_create (this, struct_or_union_rid, field,\n-\t\t\t\t  field_type_with_quals);\n+\t\t\t\t  field_type_with_quals, ctxt);\n       return child_rid;\n     }\n }\n@@ -6061,7 +6076,8 @@ region_model::get_region (region_id rid) const\n }\n \n /* Make a region of an appropriate subclass for TYPE,\n-   with parent PARENT_RID.  */\n+   with parent PARENT_RID, or return NULL for types we don't yet know\n+   how to handle.  */\n \n static region *\n make_region_for_type (region_id parent_rid, tree type)\n@@ -6091,18 +6107,24 @@ make_region_for_type (region_id parent_rid, tree type)\n   if (VOID_TYPE_P (type))\n     return new symbolic_region (parent_rid, type, false);\n \n-  gcc_unreachable ();\n+  return NULL;\n }\n \n /* Add a region with type TYPE and parent PARENT_RID.  */\n \n region_id\n-region_model::add_region_for_type (region_id parent_rid, tree type)\n+region_model::add_region_for_type (region_id parent_rid, tree type,\n+\t\t\t\t   region_model_context *ctxt)\n {\n   gcc_assert (TYPE_P (type));\n \n-  region *new_region = make_region_for_type (parent_rid, type);\n-  return add_region (new_region);\n+  if (region *new_region = make_region_for_type (parent_rid, type))\n+    return add_region (new_region);\n+\n+  /* If we can't handle TYPE, return a placeholder region, and stop\n+     exploring this path.  */\n+  return make_region_for_unexpected_tree_code (ctxt, type,\n+\t\t\t\t\t       dump_location_t ());\n }\n \n /* Helper class for region_model::purge_unused_svalues.  */\n@@ -6581,7 +6603,7 @@ region_model::get_or_create_mem_ref (tree type,\n       if (zerop (cst_sval->get_constant ()))\n \t{\n \t  /* Handle the zero offset case.  */\n-\t  return get_or_create_view (raw_rid, type);\n+\t  return get_or_create_view (raw_rid, type, ctxt);\n \t}\n \n       /* If we're already within an array of the correct type,\n@@ -6622,15 +6644,15 @@ region_model::get_or_create_mem_ref (tree type,\n \t\t  region_id element_rid\n \t\t    = parent_array->get_element (this, raw_rid, index_sid,\n \t\t\t\t\t\t ctxt);\n-\t\t  return get_or_create_view (element_rid, type);\n+\t\t  return get_or_create_view (element_rid, type, ctxt);\n \t\t}\n \t    }\n \t}\n     }\n \n   tree array_type = build_array_type (TREE_TYPE (ptr_type),\n \t\t\t\t      integer_type_node);\n-  region_id array_view_rid = get_or_create_view (raw_rid, array_type);\n+  region_id array_view_rid = get_or_create_view (raw_rid, array_type, ctxt);\n   array_region *array_reg = get_region <array_region> (array_view_rid);\n \n   svalue_id index_sid\n@@ -6639,7 +6661,7 @@ region_model::get_or_create_mem_ref (tree type,\n   region_id element_rid\n     = array_reg->get_element (this, array_view_rid, index_sid, ctxt);\n \n-  return get_or_create_view (element_rid, type);\n+  return get_or_create_view (element_rid, type, ctxt);\n }\n \n /* Get a region of type TYPE for PTR_SID + OFFSET_SID.\n@@ -6664,7 +6686,8 @@ region_model::get_or_create_pointer_plus_expr (tree type,\n    Return the id of the view (or RAW_ID if it of the same type).  */\n \n region_id\n-region_model::get_or_create_view (region_id raw_rid, tree type)\n+region_model::get_or_create_view (region_id raw_rid, tree type,\n+\t\t\t\t  region_model_context *ctxt)\n {\n   region *raw_region = get_region (raw_rid);\n \n@@ -6679,7 +6702,7 @@ region_model::get_or_create_view (region_id raw_rid, tree type)\n \n       /* Otherwise, make one (adding it to the region_model and\n \t to the viewed region).  */\n-      region_id view_rid = add_region_for_type (raw_rid, type);\n+      region_id view_rid = add_region_for_type (raw_rid, type, ctxt);\n       raw_region->add_view (view_rid, this);\n       // TODO: something to signify that this is a \"view\"\n       return view_rid;\n@@ -8102,7 +8125,8 @@ test_state_merging ()\n     region_model model0;\n \n     region_id x_rid = model0.get_lvalue (x, &ctxt);\n-    region_id x_as_ptr = model0.get_or_create_view (x_rid, ptr_type_node);\n+    region_id x_as_ptr = model0.get_or_create_view (x_rid, ptr_type_node,\n+\t\t\t\t\t\t    &ctxt);\n     model0.set_value (x_as_ptr, model0.get_rvalue (addr_of_y, &ctxt), &ctxt);\n \n     region_model model1 (model0);"}, {"sha": "c185eb18d0b82f0f4aaa21b23aa0e646ccc26df4", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "patch": "@@ -978,7 +978,8 @@ class map_region : public region\n \n   region_id get_or_create (region_model *model,\n \t\t\t   region_id this_rid,\n-\t\t\t   tree expr, tree type);\n+\t\t\t   tree expr, tree type,\n+\t\t\t   region_model_context *ctxt);\n   void unbind (tree expr);\n   region_id *get (tree expr);\n \n@@ -1374,7 +1375,8 @@ class array_region : public region\n \n   region_id get_or_create (region_model *model,\n \t\t\t   region_id this_rid,\n-\t\t\t   key_t key, tree type);\n+\t\t\t   key_t key, tree type,\n+\t\t\t   region_model_context *ctxt);\n //  void unbind (int expr);\n   region_id *get (key_t key);\n \n@@ -1719,7 +1721,8 @@ class region_model\n \n   region_id add_region (region *r);\n \n-  region_id add_region_for_type (region_id parent_rid, tree type);\n+  region_id add_region_for_type (region_id parent_rid, tree type,\n+\t\t\t\t region_model_context *ctxt);\n \n   svalue *get_svalue (svalue_id sval_id) const;\n   region *get_region (region_id rid) const;\n@@ -1740,16 +1743,19 @@ class region_model\n \n   svalue_id get_or_create_ptr_svalue (tree ptr_type, region_id id);\n   svalue_id get_or_create_constant_svalue (tree cst_expr);\n-  svalue_id get_svalue_for_fndecl (tree ptr_type, tree fndecl);\n-  svalue_id get_svalue_for_label (tree ptr_type, tree label);\n+  svalue_id get_svalue_for_fndecl (tree ptr_type, tree fndecl,\n+\t\t\t\t   region_model_context *ctxt);\n+  svalue_id get_svalue_for_label (tree ptr_type, tree label,\n+\t\t\t\t  region_model_context *ctxt);\n \n-  region_id get_region_for_fndecl (tree fndecl);\n-  region_id get_region_for_label (tree label);\n+  region_id get_region_for_fndecl (tree fndecl, region_model_context *ctxt);\n+  region_id get_region_for_label (tree label, region_model_context *ctxt);\n \n   svalue_id maybe_cast (tree type, svalue_id sid, region_model_context *ctxt);\n   svalue_id maybe_cast_1 (tree type, svalue_id sid);\n \n-  region_id get_field_region (region_id rid, tree field);\n+  region_id get_field_region (region_id rid, tree field,\n+\t\t\t      region_model_context *ctxt);\n \n   region_id deref_rvalue (svalue_id ptr_sid, region_model_context *ctxt);\n   region_id deref_rvalue (tree ptr, region_model_context *ctxt);\n@@ -1826,7 +1832,8 @@ class region_model\n \t\t\t\t\t     svalue_id ptr_sid,\n \t\t\t\t\t     svalue_id offset_sid,\n \t\t\t\t\t     region_model_context *ctxt);\n-  region_id get_or_create_view (region_id raw_rid, tree type);\n+  region_id get_or_create_view (region_id raw_rid, tree type,\n+\t\t\t\tregion_model_context *ctxt);\n \n   tree get_fndecl_for_call (const gcall *call,\n \t\t\t    region_model_context *ctxt);"}, {"sha": "a2844a3b13ab025f7dde71f55a8809e4f263d429", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "patch": "@@ -1,3 +1,8 @@\n+2020-02-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/93899\n+\t* g++.dg/analyzer/pr93899.C: New test.\n+\n 2020-02-24  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/93804"}, {"sha": "12fe0a2c881772daf0019b61025a44e80cde9796", "filename": "gcc/testsuite/g++.dg/analyzer/pr93899.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93899.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93899.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93899.C?ref=3a25f345d1fbe2de8c12cae84b0c7d2a76c0b78e", "patch": "@@ -0,0 +1,2 @@\n+// { dg-do compile { target c++11 } }\n+#include \"../abi/mangle55.C\""}]}