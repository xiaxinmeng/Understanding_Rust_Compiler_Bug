{"sha": "80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBlYzczZjRlZTJiY2Y0YjIzMzhlZWZlMzUyMTk0MGFiMGZkNmRjNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-04T10:49:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-04T10:49:21Z"}, "message": "Turn HARD_REGNO_CALL_PART_CLOBBERED into a target hook\n\nThe SVE patches change the size of a machine_mode from a compile-time\nconstant to a runtime invariant.  However, target-specific code can\ncontinue to treat the modes as constant-sized if the target only has\nconstant-sized modes.\n\nThe main snag with this approach is that target-independent code still\nuses macros from the target .h file.  This patch is one of several that\nconverts a target macro to a hook.\n\n2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (hard_regno_call_part_clobbered): New hook.\n\t* doc/tm.texi.in (HARD_REGNO_CALL_PART_CLOBBERED): Replace with...\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): ...this hook.\n\t* doc/tm.texi: Regenerate.\n\t* hooks.h (hook_bool_uint_mode_false): Declare.\n\t* hooks.c (hook_bool_uint_mode_false): New function.\n\t* regs.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* cselib.c (cselib_process_insn): Use\n\ttargetm.hard_regno_call_part_clobbered instead of\n\tHARD_REGNO_CALL_PART_CLOBBERED.\n\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n\t* ira-costs.c (ira_tune_allocno_costs): Likewise.\n\t* lra-constraints.c (need_for_call_save_p): Likewise.\n\t* lra-lives.c: Include target.h.\n\t(check_pseudos_live_through_calls): Use\n\ttargetm.hard_regno_call_part_clobbered instead of\n\tHARD_REGNO_CALL_PART_CLOBBERED.\n\t* regcprop.c: Include target.h.\n\t(copyprop_hardreg_forward_1): Use\n\ttargetm.hard_regno_call_part_clobbered instead of\n\tHARD_REGNO_CALL_PART_CLOBBERED.\n\t* reginfo.c (choose_hard_reg_mode): Likewise.\n\t* regrename.c (check_new_reg_p): Likewise.\n\t* reload.c (find_equiv_reg): Likewise.\n\t* reload1.c (emit_reload_insns): Likewise.\n\t* sched-deps.c (deps_analyze_insn): Likewise.\n\t* sel-sched.c (init_regs_for_mode): Likewise.\n\t(mark_unavailable_hard_regs): Likewise.\n\t* targhooks.c (default_dwarf_frame_reg_mode): Likewise.\n\t* config/aarch64/aarch64.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* config/aarch64/aarch64.c (aarch64_hard_regno_call_part_clobbered):\n\tNew function.\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n\t* config/avr/avr.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* config/avr/avr-protos.h (avr_hard_regno_call_part_clobbered):\n\tDelete.\n\t* config/avr/avr.c (avr_hard_regno_call_part_clobbered): Make static\n\tand return a bool.\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n\t* config/i386/i386.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* config/i386/i386.c (ix86_hard_regno_call_part_clobbered): New\n\tfunction.\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n\t* config/mips/mips.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): New\n\tfunction.\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n\t* config/powerpcspe/powerpcspe.h (HARD_REGNO_CALL_PART_CLOBBERED):\n\tDelete.\n\t* config/powerpcspe/powerpcspe.c\n\t(rs6000_hard_regno_call_part_clobbered): New function.\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n\t* config/rs6000/rs6000.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_call_part_clobbered):\n\tNew function.\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n\t* config/s390/s390.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* config/s390/s390.c (s390_hard_regno_call_part_clobbered): New\n\tfunction.\n\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n\t* config/sh/sh.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n\t* system.h (HARD_REGNO_CALL_PART_CLOBBERED): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251645", "tree": {"sha": "0d5d88cd2bf9a5c1f0f18848ddc0092b0884a2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d5d88cd2bf9a5c1f0f18848ddc0092b0884a2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/comments", "author": null, "committer": null, "parents": [{"sha": "3d09ba95c150d9676f9a2585fb61315e86fa644a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d09ba95c150d9676f9a2585fb61315e86fa644a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d09ba95c150d9676f9a2585fb61315e86fa644a"}], "stats": {"total": 377, "additions": 275, "deletions": 102}, "files": [{"sha": "1c5100173ee5137f5e3f23d88797445da72880a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1,3 +1,70 @@\n+2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (hard_regno_call_part_clobbered): New hook.\n+\t* doc/tm.texi.in (HARD_REGNO_CALL_PART_CLOBBERED): Replace with...\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): ...this hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* hooks.h (hook_bool_uint_mode_false): Declare.\n+\t* hooks.c (hook_bool_uint_mode_false): New function.\n+\t* regs.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* cselib.c (cselib_process_insn): Use\n+\ttargetm.hard_regno_call_part_clobbered instead of\n+\tHARD_REGNO_CALL_PART_CLOBBERED.\n+\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n+\t* ira-costs.c (ira_tune_allocno_costs): Likewise.\n+\t* lra-constraints.c (need_for_call_save_p): Likewise.\n+\t* lra-lives.c: Include target.h.\n+\t(check_pseudos_live_through_calls): Use\n+\ttargetm.hard_regno_call_part_clobbered instead of\n+\tHARD_REGNO_CALL_PART_CLOBBERED.\n+\t* regcprop.c: Include target.h.\n+\t(copyprop_hardreg_forward_1): Use\n+\ttargetm.hard_regno_call_part_clobbered instead of\n+\tHARD_REGNO_CALL_PART_CLOBBERED.\n+\t* reginfo.c (choose_hard_reg_mode): Likewise.\n+\t* regrename.c (check_new_reg_p): Likewise.\n+\t* reload.c (find_equiv_reg): Likewise.\n+\t* reload1.c (emit_reload_insns): Likewise.\n+\t* sched-deps.c (deps_analyze_insn): Likewise.\n+\t* sel-sched.c (init_regs_for_mode): Likewise.\n+\t(mark_unavailable_hard_regs): Likewise.\n+\t* targhooks.c (default_dwarf_frame_reg_mode): Likewise.\n+\t* config/aarch64/aarch64.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* config/aarch64/aarch64.c (aarch64_hard_regno_call_part_clobbered):\n+\tNew function.\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n+\t* config/avr/avr.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* config/avr/avr-protos.h (avr_hard_regno_call_part_clobbered):\n+\tDelete.\n+\t* config/avr/avr.c (avr_hard_regno_call_part_clobbered): Make static\n+\tand return a bool.\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n+\t* config/i386/i386.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* config/i386/i386.c (ix86_hard_regno_call_part_clobbered): New\n+\tfunction.\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n+\t* config/mips/mips.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): New\n+\tfunction.\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n+\t* config/powerpcspe/powerpcspe.h (HARD_REGNO_CALL_PART_CLOBBERED):\n+\tDelete.\n+\t* config/powerpcspe/powerpcspe.c\n+\t(rs6000_hard_regno_call_part_clobbered): New function.\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n+\t* config/rs6000/rs6000.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_call_part_clobbered):\n+\tNew function.\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n+\t* config/s390/s390.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* config/s390/s390.c (s390_hard_regno_call_part_clobbered): New\n+\tfunction.\n+\t(TARGET_HARD_REGNO_CALL_PART_CLOBBERED): Redefine.\n+\t* config/sh/sh.h (HARD_REGNO_CALL_PART_CLOBBERED): Delete.\n+\t* system.h (HARD_REGNO_CALL_PART_CLOBBERED): Poison.\n+\n 2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "ba48b28d1d54af52a0921e9f180af863b11e24ca", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1115,6 +1115,16 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n   return 0;\n }\n \n+/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  The callee only saves\n+   the lower 64 bits of a 128-bit register.  Tell the compiler the callee\n+   clobbers the top 64 bits when restoring the bottom 64 bits.  */\n+\n+static bool\n+aarch64_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+{\n+  return FP_REGNUM_P (regno) && GET_MODE_SIZE (mode) > 8;\n+}\n+\n /* Implement HARD_REGNO_CALLER_SAVE_MODE.  */\n machine_mode\n aarch64_hard_regno_caller_save_mode (unsigned regno, unsigned nregs,\n@@ -15659,6 +15669,10 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 4\n \n+#undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n+#define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n+  aarch64_hard_regno_call_part_clobbered\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests"}, {"sha": "fd5d53d51b28ef2d23f8dc05a6ed04d8c56d68cd", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -888,12 +888,6 @@ typedef struct\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n   aarch64_hard_regno_caller_save_mode ((REGNO), (NREGS), (MODE))\n \n-/* Callee only saves lower 64-bits of a 128-bit register.  Tell the\n-   compiler the callee clobbers the top 64-bits when restoring the\n-   bottom 64-bits.  */\n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) \\\n-\t\t(FP_REGNUM_P (REGNO) && GET_MODE_SIZE (MODE) > 8)\n-\n #undef SWITCHABLE_TARGET\n #define SWITCHABLE_TARGET 1\n "}, {"sha": "f9116e6bf30e688b67a7e91a6cd0542101769279", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -46,7 +46,6 @@ extern void avr_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx, tree);\n #endif /* TREE_CODE */\n \n #ifdef RTX_CODE\n-extern int avr_hard_regno_call_part_clobbered (unsigned, machine_mode);\n extern const char *output_movqi (rtx_insn *insn, rtx operands[], int *l);\n extern const char *output_movhi (rtx_insn *insn, rtx operands[], int *l);\n extern const char *output_movsisf (rtx_insn *insn, rtx operands[], int *l);"}, {"sha": "df4cbf343b4d609258bf0d16dcefd015638faced", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -12186,9 +12186,9 @@ avr_hard_regno_mode_ok (int regno, machine_mode mode)\n }\n \n \n-/* Implement `HARD_REGNO_CALL_PART_CLOBBERED'.  */\n+/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n-int\n+static bool\n avr_hard_regno_call_part_clobbered (unsigned regno, machine_mode mode)\n {\n   /* FIXME: This hook gets called with MODE:REGNO combinations that don't\n@@ -14693,6 +14693,10 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n \n #undef  TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK avr_hard_regno_scratch_ok\n+#undef  TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n+#define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n+  avr_hard_regno_call_part_clobbered\n+\n #undef  TARGET_CASE_VALUES_THRESHOLD\n #define TARGET_CASE_VALUES_THRESHOLD avr_case_values_threshold\n "}, {"sha": "212ca695ad50efcd891cbb5c8045935f0d38862b", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -285,9 +285,6 @@ enum reg_class {\n \n #define REGNO_OK_FOR_INDEX_P(NUM) 0\n \n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)     \\\n-  avr_hard_regno_call_part_clobbered (REGNO, MODE)\n-\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n #define STACK_PUSH_CODE POST_DEC"}, {"sha": "6c1057fba598900680a5257453540c2e6d53592b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -41407,6 +41407,17 @@ ix86_hard_regno_mode_ok (int regno, machine_mode mode)\n   return false;\n }\n \n+/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  The only ABI that\n+   saves SSE registers across calls is Win64 (thus no need to check the\n+   current ABI here), and with AVX enabled Win64 only guarantees that\n+   the low 16 bytes are saved.  */\n+\n+static bool\n+ix86_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+{\n+  return SSE_REGNO_P (regno) && GET_MODE_SIZE (mode) > 16;\n+}\n+\n /* A subroutine of ix86_modes_tieable_p.  Return true if MODE is a\n    tieable integer mode.  */\n \n@@ -53250,6 +53261,10 @@ ix86_run_selftests (void)\n #undef TARGET_NOCE_CONVERSION_PROFITABLE_P\n #define TARGET_NOCE_CONVERSION_PROFITABLE_P ix86_noce_conversion_profitable_p\n \n+#undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n+#define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n+  ix86_hard_regno_call_part_clobbered\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::ix86_run_selftests"}, {"sha": "05dabf273e228569e01b9041a25aa098b8c6eb5d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1214,12 +1214,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \t\t\t   || MASK_REGNO_P (REGNO)) ? SImode\t\t\\\n    : (MODE))\n \n-/* The only ABI that saves SSE registers across calls is Win64 (thus no\n-   need to check the current ABI here), and with AVX enabled Win64 only\n-   guarantees that the low 16 bytes are saved.  */\n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)             \\\n-  (SSE_REGNO_P (REGNO) && GET_MODE_SIZE (MODE) > 16)\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "0ee6a31a8ca108cfa0fc518f142fbc14b1feb6cc", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -12857,6 +12857,26 @@ mips_hard_regno_scratch_ok (unsigned int regno)\n   return true;\n }\n \n+/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  Odd-numbered\n+   single-precision registers are not considered callee-saved for o32\n+   FPXX as they will be clobbered when run on an FR=1 FPU.  MSA vector\n+   registers with MODE > 64 bits are part clobbered too.  */\n+\n+static bool\n+mips_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+{\n+  if (TARGET_FLOATXX\n+      && hard_regno_nregs[regno][mode] == 1\n+      && FP_REG_P (regno)\n+      && (regno & 1) != 0)\n+    return true;\n+\n+  if (ISA_HAS_MSA && FP_REG_P (regno) && GET_MODE_SIZE (mode) > 8)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Implement HARD_REGNO_NREGS.  */\n \n unsigned int\n@@ -22558,6 +22578,10 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK mips_hard_regno_scratch_ok\n \n+#undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n+#define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n+  mips_hard_regno_call_part_clobbered\n+\n /* The architecture reserves bit 0 for MIPS16 so use bit 1 for descriptors.  */\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 2"}, {"sha": "4358b92f637d81b04896a691636ee0b44e8c389e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1971,14 +1971,6 @@ FP_ASM_SPEC \"\\\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n   mips_hard_regno_caller_save_mode (REGNO, NREGS, MODE)\n \n-/* Odd-numbered single-precision registers are not considered callee-saved\n-   for o32 FPXX as they will be clobbered when run on an FR=1 FPU.\n-   MSA vector registers with MODE > 64 bits are part clobbered too.  */\n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n-  ((TARGET_FLOATXX && hard_regno_nregs[REGNO][MODE] == 1\t\t\\\n-   && FP_REG_P (REGNO) && ((REGNO) & 1))\t\t\t\t\\\n-   || (ISA_HAS_MSA && FP_REG_P (REGNO) && GET_MODE_SIZE (MODE) > 8))\n-\n #define MODES_TIEABLE_P mips_modes_tieable_p\n \n /* Register to use for pushing function arguments.  */"}, {"sha": "4c37be79a50978704e2082fc0429d360b9c363e5", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1971,6 +1971,10 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n+\n+#undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n+#define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n+  rs6000_hard_regno_call_part_clobbered\n \f\n \n /* Processor table.  */\n@@ -2156,6 +2160,26 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n \n+/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n+\n+static bool\n+rs6000_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+{\n+  if (TARGET_32BIT\n+      && TARGET_POWERPC64\n+      && GET_MODE_SIZE (mode) > 4\n+      && INT_REGNO_P (regno))\n+    return true;\n+\n+  if (TARGET_VSX\n+      && FP_REGNO_P (regno)\n+      && GET_MODE_SIZE (mode) > 8\n+      && !FLOAT128_2REG_P (mode))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Print interesting facts about registers.  */\n static void\n rs6000_debug_reg_print (int first_regno, int last_regno, const char *reg_name)"}, {"sha": "4e4078f3377497b25dae39b063fb66e03362c68a", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1302,13 +1302,6 @@ enum data_align { align_abi, align_opt, align_both };\n    ? DImode\t\t\t\t\t\t\t\t\\\n    : choose_hard_reg_mode ((REGNO), (NREGS), false))\n \n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n-  (((TARGET_32BIT && TARGET_POWERPC64\t\t\t\t\t\\\n-     && (GET_MODE_SIZE (MODE) > 4)\t\t\t\t\t\\\n-     && INT_REGNO_P (REGNO)) ? 1 : 0)\t\t\t\t\t\\\n-   || (TARGET_VSX && FP_REGNO_P (REGNO)\t\t\t\t\t\\\n-       && GET_MODE_SIZE (MODE) > 8 && !FLOAT128_2REG_P (MODE)))\n-\n #define VSX_VECTOR_MODE(MODE)\t\t\\\n \t ((MODE) == V4SFmode\t\t\\\n \t  || (MODE) == V2DFmode)\t\\"}, {"sha": "9c6beb1839a9b8caa481efaa63d4152078159307", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1962,6 +1962,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_OPTION_FUNCTION_VERSIONS\n #define TARGET_OPTION_FUNCTION_VERSIONS common_function_versions\n \n+#undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n+#define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n+  rs6000_hard_regno_call_part_clobbered\n \f\n \n /* Processor table.  */\n@@ -2124,6 +2127,26 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n \n+/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n+\n+static bool\n+rs6000_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+{\n+  if (TARGET_32BIT\n+      && TARGET_POWERPC64\n+      && GET_MODE_SIZE (mode) > 4\n+      && INT_REGNO_P (regno))\n+    return true;\n+\n+  if (TARGET_VSX\n+      && FP_REGNO_P (regno)\n+      && GET_MODE_SIZE (mode) > 8\n+      && !FLOAT128_2REG_P (mode))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Print interesting facts about registers.  */\n static void\n rs6000_debug_reg_print (int first_regno, int last_regno, const char *reg_name)"}, {"sha": "9114b35e46f66b31afbf9d06392c479aed130416", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1236,13 +1236,6 @@ enum data_align { align_abi, align_opt, align_both };\n    ? DImode\t\t\t\t\t\t\t\t\\\n    : choose_hard_reg_mode ((REGNO), (NREGS), false))\n \n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n-  (((TARGET_32BIT && TARGET_POWERPC64\t\t\t\t\t\\\n-     && (GET_MODE_SIZE (MODE) > 4)\t\t\t\t\t\\\n-     && INT_REGNO_P (REGNO)) ? 1 : 0)\t\t\t\t\t\\\n-   || (TARGET_VSX && FP_REGNO_P (REGNO)\t\t\t\t\t\\\n-       && GET_MODE_SIZE (MODE) > 8 && !FLOAT128_2REG_P (MODE)))\n-\n #define VSX_VECTOR_MODE(MODE)\t\t\\\n \t ((MODE) == V4SFmode\t\t\\\n \t  || (MODE) == V2DFmode)\t\\"}, {"sha": "86b77138d0a3252c72a4f593e2fc2a521d432a99", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -10491,6 +10491,29 @@ s390_hard_regno_scratch_ok (unsigned int regno)\n   return true;\n }\n \n+/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  When generating\n+   code that runs in z/Architecture mode, but conforms to the 31-bit\n+   ABI, GPRs can hold 8 bytes; the ABI guarantees only that the lower 4\n+   bytes are saved across calls, however.  */\n+\n+static bool\n+s390_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+{\n+  if (!TARGET_64BIT\n+      && TARGET_ZARCH\n+      && GET_MODE_SIZE (mode) > 4\n+      && ((regno >= 6 && regno <= 15) || regno == 32))\n+    return true;\n+\n+  if (TARGET_VX\n+      && GET_MODE_SIZE (mode) > 8\n+      && (((TARGET_64BIT && regno >= 24 && regno <= 31))\n+\t  || (!TARGET_64BIT && (regno == 18 || regno == 19))))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Maximum number of registers to represent a value of mode MODE\n    in a register of class RCLASS.  */\n \n@@ -15938,6 +15961,10 @@ s390_asan_shadow_offset (void)\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK s390_hard_regno_scratch_ok\n \n+#undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n+#define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n+  s390_hard_regno_call_part_clobbered\n+\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE s390_attribute_table\n "}, {"sha": "bdeba1e867647813ded9842b6537b838e38e2414", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -509,19 +509,6 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n    (((MODE1) == SFmode || (MODE1) == DFmode)\t\\\n    == ((MODE2) == SFmode || (MODE2) == DFmode))\n \n-/* When generating code that runs in z/Architecture mode,\n-   but conforms to the 31-bit ABI, GPRs can hold 8 bytes;\n-   the ABI guarantees only that the lower 4 bytes are\n-   saved across calls, however.  */\n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n-  ((!TARGET_64BIT && TARGET_ZARCH\t\t\t\t\t\\\n-    && GET_MODE_SIZE (MODE) > 4\t\t\t\t\t\t\\\n-    && (((REGNO) >= 6 && (REGNO) <= 15) || (REGNO) == 32))\t\t\\\n-   || (TARGET_VX\t\t\t\t\t\t\t\\\n-       && GET_MODE_SIZE (MODE) > 8\t\t\t\t\t\\\n-       && (((TARGET_64BIT && (REGNO) >= 24 && (REGNO) <= 31))\t\t\\\n-\t   || (!TARGET_64BIT && ((REGNO) == 18 || (REGNO) == 19)))))\n-\n /* Maximum number of registers to represent a value of mode MODE\n    in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\"}, {"sha": "195f50419783aeab7fb9bd46e36135241e07a930", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -812,8 +812,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   1,      1,      0,      0,\t\t\t\t\t\t\\\n }\n \n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO,MODE) (false)\n-\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE"}, {"sha": "c11c9ee20ff5c6727306b843052b7477f81e6cfd", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -2662,8 +2662,8 @@ cselib_process_insn (rtx_insn *insn)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (call_used_regs[i]\n \t    || (REG_VALUES (i) && REG_VALUES (i)->elt\n-\t\t&& HARD_REGNO_CALL_PART_CLOBBERED (i,\n-\t\t      GET_MODE (REG_VALUES (i)->elt->val_rtx))))\n+\t\t&& (targetm.hard_regno_call_part_clobbered\n+\t\t    (i, GET_MODE (REG_VALUES (i)->elt->val_rtx)))))\n \t  cselib_invalidate_regno (i, reg_raw_mode[i]);\n \n       /* Since it is not clear how cselib is going to be used, be"}, {"sha": "0c77b533adbe1571e9e8936e00bc7be4bf7df4c1", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1869,16 +1869,19 @@ This macro is optional.  If not specified, it defaults to the value\n of @code{CALL_USED_REGISTERS}.\n @end defmac\n \n-@defmac HARD_REGNO_CALL_PART_CLOBBERED (@var{regno}, @var{mode})\n @cindex call-used register\n @cindex call-clobbered register\n @cindex call-saved register\n-A C expression that is nonzero if it is not permissible to store a\n-value of mode @var{mode} in hard register number @var{regno} across a\n-call without some part of it being clobbered.  For most machines this\n-macro need not be defined.  It is only required for machines that do not\n-preserve the entire contents of a register across a call.\n-@end defmac\n+@deftypefn {Target Hook} bool TARGET_HARD_REGNO_CALL_PART_CLOBBERED (unsigned int @var{regno}, machine_mode @var{mode})\n+This hook should return true if @var{regno} is partly call-saved and\n+partly call-clobbered, and if a value of mode @var{mode} would be partly\n+clobbered by a call.  For example, if the low 32 bits of @var{regno} are\n+preserved across a call but higher bits are clobbered, this hook should\n+return true for a 64-bit mode but false for a 32-bit mode.\n+\n+The default implementation returns false, which is correct\n+for targets that don't have partly call-clobbered registers.\n+@end deftypefn\n \n @findex fixed_regs\n @findex call_used_regs"}, {"sha": "3fec545d8f9551e87ef9787a4e44bf958b1fb477", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1698,16 +1698,10 @@ This macro is optional.  If not specified, it defaults to the value\n of @code{CALL_USED_REGISTERS}.\n @end defmac\n \n-@defmac HARD_REGNO_CALL_PART_CLOBBERED (@var{regno}, @var{mode})\n @cindex call-used register\n @cindex call-clobbered register\n @cindex call-saved register\n-A C expression that is nonzero if it is not permissible to store a\n-value of mode @var{mode} in hard register number @var{regno} across a\n-call without some part of it being clobbered.  For most machines this\n-macro need not be defined.  It is only required for machines that do not\n-preserve the entire contents of a register across a call.\n-@end defmac\n+@hook TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n \n @findex fixed_regs\n @findex call_used_regs"}, {"sha": "be23dec6217eb2bcb88ae214c8d7c31d4c45172f", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -126,6 +126,13 @@ hook_bool_mode_uhwi_false (machine_mode, unsigned HOST_WIDE_INT)\n   return false;\n }\n \n+/* Generic hook that takes (unsigned int, machine_mode) and returns false.  */\n+bool\n+hook_bool_uint_mode_false (unsigned int, machine_mode)\n+{\n+  return false;\n+}\n+\n /* Generic hook that takes (FILE *, const char *) and does nothing.  */\n void\n hook_void_FILEptr_constcharptr (FILE *, const char *)"}, {"sha": "b8f17f62d0021efac3e4048a31aeaa61f8c86615", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -38,6 +38,7 @@ extern bool hook_bool_const_rtx_insn_const_rtx_insn_true (const rtx_insn *,\n \t\t\t\t\t\t\t  const rtx_insn *);\n extern bool hook_bool_mode_uhwi_false (machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT);\n+extern bool hook_bool_uint_mode_false (unsigned int, machine_mode);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_const_tree_false (const_tree);\n extern bool hook_bool_tree_true (tree);"}, {"sha": "50069c1d10574fc6257c0b0b4198c26bf7b76f57", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -743,6 +743,7 @@ ira_build_conflicts (void)\n       for (i = 0; i < n; i++)\n \t{\n \t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  machine_mode obj_mode = obj->allocno->mode;\n \t  rtx allocno_reg = regno_reg_rtx [ALLOCNO_REGNO (a)];\n \n \t  if ((! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n@@ -804,8 +805,8 @@ ira_build_conflicts (void)\n \t\t regs must conflict with them.  */\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (!TEST_HARD_REG_BIT (call_used_reg_set, regno)\n-\t\t    && HARD_REGNO_CALL_PART_CLOBBERED (regno,\n-\t\t\t\t\t\t       obj->allocno->mode))\n+\t\t    && targetm.hard_regno_call_part_clobbered (regno,\n+\t\t\t\t\t\t\t       obj_mode))\n \t\t  {\n \t\t    SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);\n \t\t    SET_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),"}, {"sha": "187802f35fa178fb0a0271cf6773c4d1cd716d53", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -2336,7 +2336,8 @@ ira_tune_allocno_costs (void)\n \t\t\t\t\t\t   *crossed_calls_clobber_regs)\n \t\t  && (ira_hard_reg_set_intersection_p (regno, mode,\n \t\t\t\t\t\t       call_used_reg_set)\n-\t\t      || HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n+\t\t      || targetm.hard_regno_call_part_clobbered (regno,\n+\t\t\t\t\t\t\t\t mode)))\n \t\tcost += (ALLOCNO_CALL_FREQ (a)\n \t\t\t * (ira_memory_move_cost[mode][rclass][0]\n \t\t\t    + ira_memory_move_cost[mode][rclass][1]));"}, {"sha": "221642ed3a6d1c29fa8bde8ec577eacc0c4b1e7e", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -5295,8 +5295,8 @@ need_for_call_save_p (int regno)\n \t       ? lra_reg_info[regno].actual_call_used_reg_set\n \t       : call_used_reg_set,\n \t       PSEUDO_REGNO_MODE (regno), reg_renumber[regno])\n-\t      || HARD_REGNO_CALL_PART_CLOBBERED (reg_renumber[regno],\n-\t\t\t\t\t\t PSEUDO_REGNO_MODE (regno))));\n+\t      || (targetm.hard_regno_call_part_clobbered\n+\t\t  (reg_renumber[regno], PSEUDO_REGNO_MODE (regno)))));\n }\n \n /* Global registers occurring in the current EBB.  */"}, {"sha": "f29dd049bad0e7d55c7382fe62d7f59020a5e379", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"cfganal.h\"\n #include \"sparseset.h\"\n #include \"lra-int.h\"\n+#include \"target.h\"\n \n /* Program points are enumerated by numbers from range\n    0..LRA_LIVE_MAX_POINT-1.  There are approximately two times more\n@@ -575,7 +576,8 @@ check_pseudos_live_through_calls (int regno,\n \t\t    last_call_used_reg_set);\n \n   for (hr = 0; hr < FIRST_PSEUDO_REGISTER; hr++)\n-    if (HARD_REGNO_CALL_PART_CLOBBERED (hr, PSEUDO_REGNO_MODE (regno)))\n+    if (targetm.hard_regno_call_part_clobbered (hr,\n+\t\t\t\t\t\tPSEUDO_REGNO_MODE (regno)))\n       SET_HARD_REG_BIT (lra_reg_info[regno].conflict_hard_regs, hr);\n   lra_reg_info[regno].call_p = true;\n   if (! sparseset_bit_p (pseudos_live_through_setjumps, regno))"}, {"sha": "40307b01fb2da6c60ca2fda9bb32771289e29724", "filename": "gcc/regcprop.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -34,6 +34,7 @@\n #include \"tree-pass.h\"\n #include \"rtl-iter.h\"\n #include \"cfgrtl.h\"\n+#include \"target.h\"\n \n /* The following code does forward propagation of hard register copies.\n    The object is to eliminate as many dependencies as possible, so that\n@@ -1055,7 +1056,8 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t\t\t\t  regs_invalidated_by_call);\n \t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t    if ((TEST_HARD_REG_BIT (regs_invalidated_by_this_call, regno)\n-\t\t || HARD_REGNO_CALL_PART_CLOBBERED (regno, vd->e[regno].mode))\n+\t\t || (targetm.hard_regno_call_part_clobbered\n+\t\t     (regno, vd->e[regno].mode)))\n \t\t&& (regno < set_regno || regno >= set_regno + set_nregs))\n \t      kill_value_regno (regno, 1, vd);\n "}, {"sha": "970cbb61e0df2173f719d16ccaa807a3076557ce", "filename": "gcc/reginfo.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -635,28 +635,32 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n   FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n-\t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n+\t&& (!call_saved\n+\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n-\t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n+\t&& (!call_saved\n+\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n-\t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n+\t&& (!call_saved\n+\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t&& HARD_REGNO_MODE_OK (regno, mode)\n-\t&& (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n+\t&& (!call_saved\n+\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n@@ -669,7 +673,8 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n       mode = (machine_mode) m;\n       if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n \t  && HARD_REGNO_MODE_OK (regno, mode)\n-\t  && (! call_saved || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n+\t  && (!call_saved\n+\t      || !targetm.hard_regno_call_part_clobbered (regno, mode)))\n \treturn mode;\n     }\n "}, {"sha": "ff5f3e2efe903254266953e3310da9a4857c6808", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -338,9 +338,9 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n     if ((! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n \t && ! DEBUG_INSN_P (tmp->insn))\n \t|| (this_head->need_caller_save_reg\n-\t    && ! (HARD_REGNO_CALL_PART_CLOBBERED\n+\t    && ! (targetm.hard_regno_call_part_clobbered\n \t\t  (reg, GET_MODE (*tmp->loc)))\n-\t    && (HARD_REGNO_CALL_PART_CLOBBERED\n+\t    && (targetm.hard_regno_call_part_clobbered\n \t\t(new_reg, GET_MODE (*tmp->loc)))))\n       return false;\n "}, {"sha": "1a3ccce6e55c491751f6767042a118a3b8fe1a87", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -193,12 +193,6 @@ extern int caller_save_needed;\n   choose_hard_reg_mode (REGNO, NREGS, false)\n #endif\n \n-/* Registers that get partially clobbered by a call in a given mode.\n-   These must not be call used registers.  */\n-#ifndef HARD_REGNO_CALL_PART_CLOBBERED\n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) 0\n-#endif\n-\n /* Target-dependent globals.  */\n struct target_regs {\n   /* For each starting hard register, the number of consecutive hard"}, {"sha": "ee4798d07081abaa8a40b0db4475d07642cb7baa", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -6927,13 +6927,14 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n \t    for (i = 0; i < nregs; ++i)\n \t      if (call_used_regs[regno + i]\n-\t\t  || HARD_REGNO_CALL_PART_CLOBBERED (regno + i, mode))\n+\t\t  || targetm.hard_regno_call_part_clobbered (regno + i, mode))\n \t\treturn 0;\n \n \t  if (valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER)\n \t    for (i = 0; i < valuenregs; ++i)\n \t      if (call_used_regs[valueno + i]\n-\t\t  || HARD_REGNO_CALL_PART_CLOBBERED (valueno + i, mode))\n+\t\t  || targetm.hard_regno_call_part_clobbered (valueno + i,\n+\t\t\t\t\t\t\t     mode))\n \t\treturn 0;\n \t}\n "}, {"sha": "d1ac40a25b43173ee6ce699e112a022ef73b03b2", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -8275,7 +8275,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t   : out_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (regno + k, mode))\n+\t\t      if (targetm.hard_regno_call_part_clobbered (regno + k,\n+\t\t\t\t\t\t\t\t  mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  regno + k);\n \t\t      else\n@@ -8354,7 +8355,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t   : in_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (regno + k, mode))\n+\t\t      if (targetm.hard_regno_call_part_clobbered (regno + k,\n+\t\t\t\t\t\t\t\t  mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  regno + k);\n \t\t      else\n@@ -8468,8 +8470,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t      reg_reloaded_insn[src_regno + k] = store_insn;\n \t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, src_regno + k);\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + k);\n-\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (src_regno + k,\n-\t\t\t\t\t\t\t  mode))\n+\t\t      if (targetm.hard_regno_call_part_clobbered\n+\t\t\t  (src_regno + k, mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  src_regno + k);\n \t\t      else"}, {"sha": "20838b26d7570f67b672cea928b9ee54c4d2e7c1", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -3706,7 +3706,8 @@ deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n              Since we only have a choice between 'might be clobbered'\n              and 'definitely not clobbered', we must include all\n              partly call-clobbered registers here.  */\n-            else if (HARD_REGNO_CALL_PART_CLOBBERED (i, reg_raw_mode[i])\n+\t    else if (targetm.hard_regno_call_part_clobbered (i,\n+\t\t\t\t\t\t\t     reg_raw_mode[i])\n                      || TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n               SET_REGNO_REG_SET (reg_pending_clobbers, i);\n           /* We don't know what set of fixed registers might be used"}, {"sha": "b504b5d1482e9f6e22ce3bab41762ea78aa43f9e", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1102,7 +1102,7 @@ init_regs_for_mode (machine_mode mode)\n       if (i >= 0)\n         continue;\n \n-      if (HARD_REGNO_CALL_PART_CLOBBERED (cur_reg, mode))\n+      if (targetm.hard_regno_call_part_clobbered (cur_reg, mode))\n         SET_HARD_REG_BIT (sel_hrd.regs_for_call_clobbered[mode],\n                           cur_reg);\n \n@@ -1251,7 +1251,7 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n \n   /* Exclude registers that are partially call clobbered.  */\n   if (def->crosses_call\n-      && ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n+      && !targetm.hard_regno_call_part_clobbered (regno, mode))\n     AND_COMPL_HARD_REG_SET (reg_rename_p->available_for_renaming,\n                             sel_hrd.regs_for_call_clobbered[mode]);\n "}, {"sha": "4eea495f00b20ef5c4a5e84d7d4ee263307fe3a8", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -910,7 +910,8 @@ extern void fancy_abort (const char *, int, const char *)\n \tASM_BYTE_OP MEMBER_TYPE_FORCES_BLK LIBGCC2_HAS_SF_MODE\t\t\\\n \tLIBGCC2_HAS_DF_MODE LIBGCC2_HAS_XF_MODE LIBGCC2_HAS_TF_MODE\t\\\n \tCLEAR_BY_PIECES_P MOVE_BY_PIECES_P SET_BY_PIECES_P\t\t\\\n-\tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\n+\tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\t\t\t\\\n+\tHARD_REGNO_CALL_PART_CLOBBERED\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "689c0a03ef0c1ae6d4c422d26fa360dc09ebca0b", "filename": "gcc/target.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -5395,6 +5395,19 @@ The default version of this hook always returns @code{true}.\",\n  bool, (unsigned int regno),\n  default_hard_regno_scratch_ok)\n \n+DEFHOOK\n+(hard_regno_call_part_clobbered,\n+ \"This hook should return true if @var{regno} is partly call-saved and\\n\\\n+partly call-clobbered, and if a value of mode @var{mode} would be partly\\n\\\n+clobbered by a call.  For example, if the low 32 bits of @var{regno} are\\n\\\n+preserved across a call but higher bits are clobbered, this hook should\\n\\\n+return true for a 64-bit mode but false for a 32-bit mode.\\n\\\n+\\n\\\n+The default implementation returns false, which is correct\\n\\\n+for targets that don't have partly call-clobbered registers.\",\n+ bool, (unsigned int regno, machine_mode mode),\n+ hook_bool_uint_mode_false)\n+\n /* Return the smallest number of different values for which it is best to\n    use a jump-table instead of a tree of conditional branches.  */\n DEFHOOK"}, {"sha": "78657fbd410bbb73e35aeb825f9e3cb2294465fa", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "patch": "@@ -1737,7 +1737,7 @@ default_dwarf_frame_reg_mode (int regno)\n {\n   machine_mode save_mode = reg_raw_mode[regno];\n \n-  if (HARD_REGNO_CALL_PART_CLOBBERED (regno, save_mode))\n+  if (targetm.hard_regno_call_part_clobbered (regno, save_mode))\n     save_mode = choose_hard_reg_mode (regno, 1, true);\n   return save_mode;\n }"}]}