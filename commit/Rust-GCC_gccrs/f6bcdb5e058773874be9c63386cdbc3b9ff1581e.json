{"sha": "f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZiY2RiNWUwNTg3NzM4NzRiZTljNjMzODZjZGJjM2I5ZmYxNTgxZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-07-30T12:14:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-07-30T12:14:58Z"}, "message": "lto-streamer.h (lto_write_data): New function.\n\n2014-07-30  Richard Biener  <rguenther@suse.de>\n\n\t* lto-streamer.h (lto_write_data): New function.\n\t* langhooks.c (lhd_append_data): Do not free block.\n\t* lto-section-out.c (lto_write_data): New function writing\n\traw data to the current section.\n\t(lto_write_stream): Adjust for langhook semantic change.\n\t(lto_destroy_simple_output_block): Write header directly.\n\t* lto-opts.c (lto_write_options): Write options directly.\n\t* lto-streamer-out.c (produce_asm): Write heaeder directly.\n\t(lto_output_toplevel_asms): Likewise.\n\t(copy_function_or_variable): Copy data directly.\n\t(write_global_references): Output index table directly.\n\t(lto_output_decl_state_refs): Likewise.\n\t(write_symbol): Write data directly.\n\t(produce_symtab): Adjust.\n\t(produce_asm_for_decls): Output header and refs directly.\n\n\tlto/\n\t* lto-object.c (lto_obj_append_data): Do not free block.\n\nFrom-SVN: r213253", "tree": {"sha": "17ed7ba165f1d2672b9045df3792853564446f62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17ed7ba165f1d2672b9045df3792853564446f62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93a87598b928f58f9e467bea8c718c5e2c91e498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a87598b928f58f9e467bea8c718c5e2c91e498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93a87598b928f58f9e467bea8c718c5e2c91e498"}], "stats": {"total": 151, "additions": 79, "deletions": 72}, "files": [{"sha": "d6f074c6b38a26b3c2746d82f39688bb1b5db026", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -1,3 +1,21 @@\n+2014-07-30  Richard Biener  <rguenther@suse.de>\n+\n+\t* lto-streamer.h (lto_write_data): New function.\n+\t* langhooks.c (lhd_append_data): Do not free block.\n+\t* lto-section-out.c (lto_write_data): New function writing\n+\traw data to the current section.\n+\t(lto_write_stream): Adjust for langhook semantic change.\n+\t(lto_destroy_simple_output_block): Write header directly.\n+\t* lto-opts.c (lto_write_options): Write options directly.\n+\t* lto-streamer-out.c (produce_asm): Write heaeder directly.\n+\t(lto_output_toplevel_asms): Likewise.\n+\t(copy_function_or_variable): Copy data directly.\n+\t(write_global_references): Output index table directly.\n+\t(lto_output_decl_state_refs): Likewise.\n+\t(write_symbol): Write data directly.\n+\t(produce_symtab): Adjust.\n+\t(produce_asm_for_decls): Output header and refs directly.\n+\n 2014-07-29  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-devirt.c (polymorphic_call_target_d): Rename nonconstruction_targets"}, {"sha": "aaf65d44a5df323d5b1302533127e87c5a150579", "filename": "gcc/langhooks.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -661,14 +661,13 @@ lhd_begin_section (const char *name)\n \n \n /* Write DATA of length LEN to the current LTO output section.  This default\n-   implementation just calls assemble_string and frees BLOCK.  */\n+   implementation just calls assemble_string.  */\n \n void\n-lhd_append_data (const void *data, size_t len, void *block)\n+lhd_append_data (const void *data, size_t len, void *)\n {\n   if (data)\n     assemble_string ((const char *)data, len);\n-  free (block);\n }\n \n "}, {"sha": "986fb971071c93e0532638c10cf4555e298bb166", "filename": "gcc/lto-opts.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -67,7 +67,6 @@ append_to_collect_gcc_options (struct obstack *ob,\n void\n lto_write_options (void)\n {\n-  struct lto_output_stream stream;\n   char *section_name;\n   struct obstack temporary_obstack;\n   unsigned int i, j;\n@@ -76,7 +75,6 @@ lto_write_options (void)\n \n   section_name = lto_get_section_name (LTO_section_opts, NULL, NULL);\n   lto_begin_section (section_name, false);\n-  memset (&stream, 0, sizeof (stream));\n \n   obstack_init (&temporary_obstack);\n \n@@ -170,9 +168,7 @@ lto_write_options (void)\n     }\n   obstack_grow (&temporary_obstack, \"\\0\", 1);\n   args = XOBFINISH (&temporary_obstack, char *);\n-  lto_output_data_stream (&stream, args, strlen (args) + 1);\n-\n-  lto_write_stream (&stream);\n+  lto_write_data (args, strlen (args) + 1);\n   lto_end_section ();\n \n   obstack_free (&temporary_obstack, NULL);"}, {"sha": "2494191f288906ff9bc7eedb967eaed4c6c19967", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -98,6 +98,16 @@ lto_end_section (void)\n   lang_hooks.lto.end_section ();\n }\n \n+/* Write SIZE bytes starting at DATA to the assembler.  */\n+\n+void\n+lto_write_data (const void *data, unsigned int size)\n+{\n+  if (compression_stream)\n+    lto_compress_block (compression_stream, (const char *)data, size);\n+  else\n+    lang_hooks.lto.append_data ((const char *)data, size, NULL);\n+}\n \n /* Write all of the chars in OBS to the assembler.  Recycle the blocks\n    in obs as this is being done.  */\n@@ -128,12 +138,10 @@ lto_write_stream (struct lto_output_stream *obs)\n          blocks up output differently to the way it's blocked here.  So for\n          now, we don't compress WPA output.  */\n       if (compression_stream)\n-\t{\n-\t  lto_compress_block (compression_stream, base, num_chars);\n-\t  lang_hooks.lto.append_data (NULL, 0, block);\n-\t}\n+\tlto_compress_block (compression_stream, base, num_chars);\n       else\n \tlang_hooks.lto.append_data (base, num_chars, block);\n+      free (block);\n       block_size *= 2;\n     }\n }\n@@ -335,7 +343,6 @@ lto_destroy_simple_output_block (struct lto_simple_output_block *ob)\n {\n   char *section_name;\n   struct lto_simple_header header;\n-  struct lto_output_stream *header_stream;\n \n   section_name = lto_get_section_name (ob->section_type, NULL, NULL);\n   lto_begin_section (section_name, !flag_wpa);\n@@ -346,15 +353,9 @@ lto_destroy_simple_output_block (struct lto_simple_output_block *ob)\n   memset (&header, 0, sizeof (struct lto_simple_header));\n   header.lto_header.major_version = LTO_major_version;\n   header.lto_header.minor_version = LTO_minor_version;\n-\n   header.compressed_size = 0;\n-\n   header.main_size = ob->main_stream->total_size;\n-\n-  header_stream = XCNEW (struct lto_output_stream);\n-  lto_output_data_stream (header_stream, &header, sizeof header);\n-  lto_write_stream (header_stream);\n-  free (header_stream);\n+  lto_write_data (&header, sizeof header);\n \n   lto_write_stream (ob->main_stream);\n "}, {"sha": "6b3f78fd3ab9b8414424af4eaa6141c176b61e57", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 25, "deletions": 49, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -1872,7 +1872,6 @@ produce_asm (struct output_block *ob, tree fn)\n   enum lto_section_type section_type = ob->section_type;\n   struct lto_function_header header;\n   char *section_name;\n-  struct lto_output_stream *header_stream;\n \n   if (section_type == LTO_section_function_body)\n     {\n@@ -1898,11 +1897,7 @@ produce_asm (struct output_block *ob, tree fn)\n     header.cfg_size = ob->cfg_stream->total_size;\n   header.main_size = ob->main_stream->total_size;\n   header.string_size = ob->string_stream->total_size;\n-\n-  header_stream = XCNEW (struct lto_output_stream);\n-  lto_output_data_stream (header_stream, &header, sizeof header);\n-  lto_write_stream (header_stream);\n-  free (header_stream);\n+  lto_write_data (&header, sizeof header);\n \n   /* Put all of the gimple and the string table out the asm file as a\n      block of text.  */\n@@ -2104,7 +2099,6 @@ lto_output_toplevel_asms (void)\n   struct output_block *ob;\n   struct asm_node *can;\n   char *section_name;\n-  struct lto_output_stream *header_stream;\n   struct lto_asm_header header;\n \n   if (! asm_nodes)\n@@ -2136,11 +2130,7 @@ lto_output_toplevel_asms (void)\n \n   header.main_size = ob->main_stream->total_size;\n   header.string_size = ob->string_stream->total_size;\n-\n-  header_stream = XCNEW (struct lto_output_stream);\n-  lto_output_data_stream (header_stream, &header, sizeof (header));\n-  lto_write_stream (header_stream);\n-  free (header_stream);\n+  lto_write_data (&header, sizeof header);\n \n   /* Put all of the gimple and the string table out the asm file as a\n      block of text.  */\n@@ -2160,7 +2150,6 @@ copy_function_or_variable (struct symtab_node *node)\n {\n   tree function = node->decl;\n   struct lto_file_decl_data *file_data = node->lto_file_data;\n-  struct lto_output_stream *output_stream = XCNEW (struct lto_output_stream);\n   const char *data;\n   size_t len;\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function));\n@@ -2181,8 +2170,7 @@ copy_function_or_variable (struct symtab_node *node)\n   gcc_assert (data);\n \n   /* Do a bit copy of the function body.  */\n-  lto_output_data_stream (output_stream, data, len);\n-  lto_write_stream (output_stream);\n+  lto_write_data (data, len);\n \n   /* Copy decls. */\n   in_state =\n@@ -2206,7 +2194,6 @@ copy_function_or_variable (struct symtab_node *node)\n \n   lto_free_section_data (file_data, LTO_section_function_body, name,\n \t\t\t data, len);\n-  free (output_stream);\n   lto_end_section ();\n }\n \n@@ -2348,15 +2335,15 @@ write_global_stream (struct output_block *ob,\n \n static void\n write_global_references (struct output_block *ob,\n-\t\t\t struct lto_output_stream *ref_stream,\n  \t\t\t struct lto_tree_ref_encoder *encoder)\n {\n   tree t;\n   uint32_t index;\n   const uint32_t size = lto_tree_ref_encoder_size (encoder);\n \n-  /* Write size as 32-bit unsigned. */\n-  lto_output_data_stream (ref_stream, &size, sizeof (int32_t));\n+  /* Write size and slot indexes as 32-bit unsigned numbers. */\n+  uint32_t *data = XNEWVEC (uint32_t, size + 1);\n+  data[0] = size;\n \n   for (index = 0; index < size; index++)\n     {\n@@ -2365,8 +2352,11 @@ write_global_references (struct output_block *ob,\n       t = lto_tree_ref_encoder_get_tree (encoder, index);\n       streamer_tree_cache_lookup (ob->writer_cache, t, &slot_num);\n       gcc_assert (slot_num != (unsigned)-1);\n-      lto_output_data_stream (ref_stream, &slot_num, sizeof slot_num);\n+      data[index + 1] = slot_num;\n     }\n+\n+  lto_write_data (data, sizeof (int32_t) * (size + 1));\n+  free (data);\n }\n \n \n@@ -2389,7 +2379,6 @@ lto_output_decl_state_streams (struct output_block *ob,\n \n void\n lto_output_decl_state_refs (struct output_block *ob,\n-\t\t\t    struct lto_output_stream *out_stream,\n \t\t\t    struct lto_out_decl_state *state)\n {\n   unsigned i;\n@@ -2401,10 +2390,10 @@ lto_output_decl_state_refs (struct output_block *ob,\n   decl = (state->fn_decl) ? state->fn_decl : void_type_node;\n   streamer_tree_cache_lookup (ob->writer_cache, decl, &ref);\n   gcc_assert (ref != (unsigned)-1);\n-  lto_output_data_stream (out_stream, &ref, sizeof (uint32_t));\n+  lto_write_data (&ref, sizeof (uint32_t));\n \n   for (i = 0;  i < LTO_N_DECL_STREAMS; i++)\n-    write_global_references (ob, out_stream, &state->streams[i]);\n+    write_global_references (ob, &state->streams[i]);\n }\n \n \n@@ -2432,7 +2421,6 @@ lto_out_decl_state_written_size (struct lto_out_decl_state *state)\n \n static void\n write_symbol (struct streamer_tree_cache_d *cache,\n-\t      struct lto_output_stream *stream,\n \t      tree t, struct pointer_set_t *seen, bool alias)\n {\n   const char *name;\n@@ -2531,14 +2519,14 @@ write_symbol (struct streamer_tree_cache_d *cache,\n   else\n     comdat = \"\";\n \n-  lto_output_data_stream (stream, name, strlen (name) + 1);\n-  lto_output_data_stream (stream, comdat, strlen (comdat) + 1);\n+  lto_write_data (name, strlen (name) + 1);\n+  lto_write_data (comdat, strlen (comdat) + 1);\n   c = (unsigned char) kind;\n-  lto_output_data_stream (stream, &c, 1);\n+  lto_write_data (&c, 1);\n   c = (unsigned char) visibility;\n-  lto_output_data_stream (stream, &c, 1);\n-  lto_output_data_stream (stream, &size, 8);\n-  lto_output_data_stream (stream, &slot_num, 4);\n+  lto_write_data (&c, 1);\n+  lto_write_data (&size, 8);\n+  lto_write_data (&slot_num, 4);\n }\n \n /* Return true if NODE should appear in the plugin symbol table.  */\n@@ -2589,15 +2577,13 @@ produce_symtab (struct output_block *ob)\n   struct streamer_tree_cache_d *cache = ob->writer_cache;\n   char *section_name = lto_get_section_name (LTO_section_symtab, NULL, NULL);\n   struct pointer_set_t *seen;\n-  struct lto_output_stream stream;\n   lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n   lto_symtab_encoder_iterator lsei;\n \n   lto_begin_section (section_name, false);\n   free (section_name);\n \n   seen = pointer_set_create ();\n-  memset (&stream, 0, sizeof (stream));\n \n   /* Write the symbol table.\n      First write everything defined and then all declarations.\n@@ -2609,7 +2595,7 @@ produce_symtab (struct output_block *ob)\n \n       if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))\n \tcontinue;\n-      write_symbol (cache, &stream, node->decl, seen, false);\n+      write_symbol (cache, node->decl, seen, false);\n     }\n   for (lsei = lsei_start (encoder);\n        !lsei_end_p (lsei); lsei_next (&lsei))\n@@ -2618,10 +2604,9 @@ produce_symtab (struct output_block *ob)\n \n       if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))\n \tcontinue;\n-      write_symbol (cache, &stream, node->decl, seen, false);\n+      write_symbol (cache, node->decl, seen, false);\n     }\n \n-  lto_write_stream (&stream);\n   pointer_set_destroy (seen);\n \n   lto_end_section ();\n@@ -2642,7 +2627,6 @@ produce_asm_for_decls (void)\n   struct lto_decl_header header;\n   char *section_name;\n   struct output_block *ob;\n-  struct lto_output_stream *header_stream, *decl_state_stream;\n   unsigned idx, num_fns;\n   size_t decl_state_size;\n   int32_t num_decl_states;\n@@ -2701,26 +2685,18 @@ produce_asm_for_decls (void)\n   header.main_size = ob->main_stream->total_size;\n   header.string_size = ob->string_stream->total_size;\n \n-  header_stream = XCNEW (struct lto_output_stream);\n-  lto_output_data_stream (header_stream, &header, sizeof header);\n-  lto_write_stream (header_stream);\n-  free (header_stream);\n+  lto_write_data (&header, sizeof header);\n \n   /* Write the main out-decl state, followed by out-decl states of\n      functions. */\n-  decl_state_stream = XCNEW (struct lto_output_stream);\n   num_decl_states = num_fns + 1;\n-  lto_output_data_stream (decl_state_stream, &num_decl_states,\n-\t\t\t  sizeof (num_decl_states));\n-  lto_output_decl_state_refs (ob, decl_state_stream, out_state);\n+  lto_write_data (&num_decl_states, sizeof (num_decl_states));\n+  lto_output_decl_state_refs (ob, out_state);\n   for (idx = 0; idx < num_fns; idx++)\n     {\n-      fn_out_state =\n-\tlto_function_decl_states[idx];\n-      lto_output_decl_state_refs (ob, decl_state_stream, fn_out_state);\n+      fn_out_state = lto_function_decl_states[idx];\n+      lto_output_decl_state_refs (ob, fn_out_state);\n     }\n-  lto_write_stream (decl_state_stream);\n-  free (decl_state_stream);\n \n   lto_write_stream (ob->main_stream);\n   lto_write_stream (ob->string_stream);"}, {"sha": "423108b60eb5257ef47dab09fdf5b2f8873a4c28", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -777,6 +777,7 @@ extern void lto_value_range_error (const char *,\n /* In lto-section-out.c  */\n extern void lto_begin_section (const char *, bool);\n extern void lto_end_section (void);\n+extern void lto_write_data (const void *, unsigned int);\n extern void lto_write_stream (struct lto_output_stream *);\n extern void lto_output_data_stream (struct lto_output_stream *, const void *,\n \t\t\t\t    size_t);"}, {"sha": "a0a21b87b7640ce43fa563fc46533c9f894ef699", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -1,3 +1,21 @@\n+2014-07-30  Richard Biener  <rguenther@suse.de>\n+\n+\t* lto-streamer.h (lto_write_data): New function.\n+\t* langhooks.c (lhd_append_data): Do not free block.\n+\t* lto-section-out.c (lto_write_data): New function writing\n+\traw data to the current section.\n+\t(lto_write_stream): Adjust for langhook semantic change.\n+\t(lto_destroy_simple_output_block): Write header directly.\n+\t* lto-opts.c (lto_write_options): Write options directly.\n+\t* lto-streamer-out.c (produce_asm): Write heaeder directly.\n+\t(lto_output_toplevel_asms): Likewise.\n+\t(copy_function_or_variable): Copy data directly.\n+\t(write_global_references): Output index table directly.\n+\t(lto_output_decl_state_refs): Likewise.\n+\t(write_symbol): Write data directly.\n+\t(produce_symtab): Adjust.\n+\t(produce_asm_for_decls): Output header and refs directly.\n+\n 2014-07-25  Andi Kleen  <ak@linux.intel.com>\n \n \t* lto.c (hash_canonical_type): Call iterative_hstate_expr."}, {"sha": "323f7b2a74eb3c323ee9f3783b21c7cf9ae63df9", "filename": "gcc/lto/lto-object.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto%2Flto-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcdb5e058773874be9c63386cdbc3b9ff1581e/gcc%2Flto%2Flto-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-object.c?ref=f6bcdb5e058773874be9c63386cdbc3b9ff1581e", "patch": "@@ -354,7 +354,7 @@ lto_obj_begin_section (const char *name)\n    DATA.  */\n \n void\n-lto_obj_append_data (const void *data, size_t len, void *block)\n+lto_obj_append_data (const void *data, size_t len, void *)\n {\n   struct lto_simple_object *lo;\n   const char *errmsg;\n@@ -372,8 +372,6 @@ lto_obj_append_data (const void *data, size_t len, void *block)\n       else\n \tfatal_error (\"%s: %s\", errmsg, xstrerror (errno));\n     }\n-\n-  free (block);\n }\n \n /* Stop writing to the current output section.  */"}]}