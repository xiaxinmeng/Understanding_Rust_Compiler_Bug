{"sha": "a1bac22c43e4b71d5e770ca9b43aaf9fbee45022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFiYWMyMmM0M2U0YjcxZDVlNzcwY2E5YjQzYWFmOWZiZWU0NTAyMg==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2004-04-20T03:57:59Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2004-04-20T03:57:59Z"}, "message": "Eliminate broken unused function.\n\n\t* rtl.h (reg_set_last): Delete declaration.\n\t* rtlanal.c (reg_set_last): Delete.\n\nFrom-SVN: r80879", "tree": {"sha": "9f167c3380e53fb9a4d41188b8831a8b9f90116f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f167c3380e53fb9a4d41188b8831a8b9f90116f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022/comments", "author": null, "committer": null, "parents": [{"sha": "e419fe91e53678f478dfcd1c3367e563f3c07433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e419fe91e53678f478dfcd1c3367e563f3c07433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e419fe91e53678f478dfcd1c3367e563f3c07433"}], "stats": {"total": 54, "additions": 5, "deletions": 49}, "files": [{"sha": "2d7b398fad578a44456a1e502b9b519682530b64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1bac22c43e4b71d5e770ca9b43aaf9fbee45022", "patch": "@@ -1,3 +1,8 @@\n+2004-04-19  James E Wilson  <wilson@specifixinc.com>\n+\n+\t* rtl.h (reg_set_last): Delete declaration.\n+\t* rtlanal.c (reg_set_last): Delete.\n+\n 2004-04-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold_convert): Make function extern/public."}, {"sha": "4c443324fd4b991af1cf537288d523f75715fce2", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a1bac22c43e4b71d5e770ca9b43aaf9fbee45022", "patch": "@@ -1844,7 +1844,6 @@ extern int reg_overlap_mentioned_p (rtx, rtx);\n extern rtx set_of (rtx, rtx);\n extern void note_stores (rtx, void (*) (rtx, rtx, void *), void *);\n extern void note_uses (rtx *, void (*) (rtx *, void *), void *);\n-extern rtx reg_set_last (rtx, rtx);\n extern int dead_or_set_p (rtx, rtx);\n extern int dead_or_set_regno_p (rtx, unsigned int);\n extern rtx find_reg_note (rtx, enum reg_note, rtx);"}, {"sha": "aade423eefeed4a53b4ba9cfccb35a0afed4da95", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1bac22c43e4b71d5e770ca9b43aaf9fbee45022/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=a1bac22c43e4b71d5e770ca9b43aaf9fbee45022", "patch": "@@ -1598,54 +1598,6 @@ reg_overlap_mentioned_p (rtx x, rtx in)\n     }\n }\n \f\n-/* Return the last value to which REG was set prior to INSN.  If we can't\n-   find it easily, return 0.\n-\n-   We only return a REG, SUBREG, or constant because it is too hard to\n-   check if a MEM remains unchanged.  */\n-\n-rtx\n-reg_set_last (rtx x, rtx insn)\n-{\n-  rtx orig_insn = insn;\n-\n-  /* Scan backwards until reg_set_last_1 changed one of the above flags.\n-     Stop when we reach a label or X is a hard reg and we reach a\n-     CALL_INSN (if reg_set_last_last_regno is a hard reg).\n-\n-     If we find a set of X, ensure that its SET_SRC remains unchanged.  */\n-\n-  /* We compare with <= here, because reg_set_last_last_regno\n-     is actually the number of the first reg *not* in X.  */\n-  for (;\n-       insn && GET_CODE (insn) != CODE_LABEL\n-       && ! (GET_CODE (insn) == CALL_INSN\n-\t     && REGNO (x) <= FIRST_PSEUDO_REGISTER);\n-       insn = PREV_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\trtx set = set_of (x, insn);\n-\t/* OK, this function modify our register.  See if we understand it.  */\n-\tif (set)\n-\t  {\n-\t    rtx last_value;\n-\t    if (GET_CODE (set) != SET || SET_DEST (set) != x)\n-\t      return 0;\n-\t    last_value = SET_SRC (x);\n-\t    if (CONSTANT_P (last_value)\n-\t\t|| ((GET_CODE (last_value) == REG\n-\t\t     || GET_CODE (last_value) == SUBREG)\n-\t\t    && ! reg_set_between_p (last_value,\n-\t\t\t\t\t    insn, orig_insn)))\n-\t      return last_value;\n-\t    else\n-\t      return 0;\n-\t  }\n-      }\n-\n-  return 0;\n-}\n-\f\n /* Call FUN on each register or MEM that is stored into or clobbered by X.\n    (X would be the pattern of an insn).\n    FUN receives two arguments:"}]}