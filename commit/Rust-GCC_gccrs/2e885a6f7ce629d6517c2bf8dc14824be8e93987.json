{"sha": "2e885a6f7ce629d6517c2bf8dc14824be8e93987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU4ODVhNmY3Y2U2MjlkNjUxN2MyYmY4ZGMxNDgyNGJlOGU5Mzk4Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-27T11:01:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-27T11:01:35Z"}, "message": "[multiple changes]\n\n2016-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.ads Aspects Export and Import do not require delay. They\n\twere classified as delayed aspects, but treated as non-delayed\n\tby the analysis of aspects.\n\t* freeze.adb (Copy_Import_Pragma): New routine.\n\t(Wrap_Imported_Subprogram): Copy the import pragma by first\n\tresetting all semantic fields to avoid an infinite loop when\n\tperforming the copy.\n\t* sem_ch13.adb (Analyze_Aspects_At_Freeze_Point): Add\n\tcomment on the processing of aspects Export and Import\n\tat the freeze point.\n\t(Analyze_Aspect_Convention: New routine.\n\t(Analyze_Aspect_Export_Import): New routine.\n\t(Analyze_Aspect_External_Link_Name): New routine.\n\t(Analyze_Aspect_External_Or_Link_Name): Removed.\n\t(Analyze_Aspect_Specifications): Factor out the analysis of\n\taspects Convention, Export, External_Name, Import, and Link_Name\n\tin their respective routines.  Aspects Export and Import should\n\tnot generate a Boolean pragma because their corresponding pragmas\n\thave a very different syntax.\n\t(Build_Export_Import_Pragma): New routine.\n\t(Get_Interfacing_Aspects): New routine.\n\n2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* inline.adb (Add_Inlined_Body): Overhaul implementation,\n\trobustify handling of -gnatn1, add special treatment for\n\texpression functions.\n\n2016-04-27  Doug Rupp  <rupp@adacore.com>\n\n\t* g-traceb.ads: Update comment.\n\t* exp_ch2.adb: minor style fix in object declaration\n\nFrom-SVN: r235483", "tree": {"sha": "97c19940d80f087c3cbe29b3c4615f73aafba48f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97c19940d80f087c3cbe29b3c4615f73aafba48f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e885a6f7ce629d6517c2bf8dc14824be8e93987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e885a6f7ce629d6517c2bf8dc14824be8e93987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e885a6f7ce629d6517c2bf8dc14824be8e93987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e885a6f7ce629d6517c2bf8dc14824be8e93987/comments", "author": null, "committer": null, "parents": [{"sha": "2a253c5bba9ecf4f09242253bf8efd05c9cce9de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a253c5bba9ecf4f09242253bf8efd05c9cce9de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a253c5bba9ecf4f09242253bf8efd05c9cce9de"}], "stats": {"total": 974, "additions": 684, "deletions": 290}, "files": [{"sha": "cbbc3b28942d9ed75887bc054f68e35c36e1e995", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2e885a6f7ce629d6517c2bf8dc14824be8e93987", "patch": "@@ -1,3 +1,38 @@\n+2016-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.ads Aspects Export and Import do not require delay. They\n+\twere classified as delayed aspects, but treated as non-delayed\n+\tby the analysis of aspects.\n+\t* freeze.adb (Copy_Import_Pragma): New routine.\n+\t(Wrap_Imported_Subprogram): Copy the import pragma by first\n+\tresetting all semantic fields to avoid an infinite loop when\n+\tperforming the copy.\n+\t* sem_ch13.adb (Analyze_Aspects_At_Freeze_Point): Add\n+\tcomment on the processing of aspects Export and Import\n+\tat the freeze point.\n+\t(Analyze_Aspect_Convention: New routine.\n+\t(Analyze_Aspect_Export_Import): New routine.\n+\t(Analyze_Aspect_External_Link_Name): New routine.\n+\t(Analyze_Aspect_External_Or_Link_Name): Removed.\n+\t(Analyze_Aspect_Specifications): Factor out the analysis of\n+\taspects Convention, Export, External_Name, Import, and Link_Name\n+\tin their respective routines.  Aspects Export and Import should\n+\tnot generate a Boolean pragma because their corresponding pragmas\n+\thave a very different syntax.\n+\t(Build_Export_Import_Pragma): New routine.\n+\t(Get_Interfacing_Aspects): New routine.\n+\n+2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* inline.adb (Add_Inlined_Body): Overhaul implementation,\n+\trobustify handling of -gnatn1, add special treatment for\n+\texpression functions.\n+\n+2016-04-27  Doug Rupp  <rupp@adacore.com>\n+\n+\t* g-traceb.ads: Update comment.\n+\t* exp_ch2.adb: minor style fix in object declaration\n+\n 2016-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_elab.adb (Check_Internal_Call): Do not"}, {"sha": "fe13b304369924d96ce7de62ed04dd41e6fcd9be", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=2e885a6f7ce629d6517c2bf8dc14824be8e93987", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2010-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -652,12 +652,10 @@ package Aspects is\n       Aspect_Dispatching_Domain           => Always_Delay,\n       Aspect_Dynamic_Predicate            => Always_Delay,\n       Aspect_Elaborate_Body               => Always_Delay,\n-      Aspect_Export                       => Always_Delay,\n       Aspect_External_Name                => Always_Delay,\n       Aspect_External_Tag                 => Always_Delay,\n       Aspect_Favor_Top_Level              => Always_Delay,\n       Aspect_Implicit_Dereference         => Always_Delay,\n-      Aspect_Import                       => Always_Delay,\n       Aspect_Independent                  => Always_Delay,\n       Aspect_Independent_Components       => Always_Delay,\n       Aspect_Inline                       => Always_Delay,\n@@ -726,9 +724,11 @@ package Aspects is\n       Aspect_Disable_Controlled           => Never_Delay,\n       Aspect_Effective_Reads              => Never_Delay,\n       Aspect_Effective_Writes             => Never_Delay,\n+      Aspect_Export                       => Never_Delay,\n       Aspect_Extensions_Visible           => Never_Delay,\n       Aspect_Ghost                        => Never_Delay,\n       Aspect_Global                       => Never_Delay,\n+      Aspect_Import                       => Never_Delay,\n       Aspect_Initial_Condition            => Never_Delay,\n       Aspect_Initializes                  => Never_Delay,\n       Aspect_No_Elaboration_Code_All      => Never_Delay,"}, {"sha": "65b2212ac42a1e4fb61af4e7a8604c0fb3e09393", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=2e885a6f7ce629d6517c2bf8dc14824be8e93987", "patch": "@@ -413,7 +413,7 @@ package body Exp_Ch2 is\n         and then (Is_Atomic (E) or else Is_Atomic (Etype (E)))\n       then\n          declare\n-            Set  : Boolean;\n+            Set : Boolean;\n \n          begin\n             --  If variable is atomic, but type is not, setting depends on"}, {"sha": "796d9ca599471ce3ff700c3e71bf693e20f78c76", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=2e885a6f7ce629d6517c2bf8dc14824be8e93987", "patch": "@@ -4676,14 +4676,65 @@ package body Freeze is\n       --  for the subprogram body that calls the inner procedure.\n \n       procedure Wrap_Imported_Subprogram (E : Entity_Id) is\n+         function Copy_Import_Pragma return Node_Id;\n+         --  Obtain a copy of the Import_Pragma which belongs to subprogram E\n+\n+         ------------------------\n+         -- Copy_Import_Pragma --\n+         ------------------------\n+\n+         function Copy_Import_Pragma return Node_Id is\n+\n+            --  The subprogram should have an import pragma, otherwise it does\n+            --  need a wrapper.\n+\n+            Prag : constant Node_Id := Import_Pragma (E);\n+            pragma Assert (Present (Prag));\n+\n+            --  Save all semantic fields of the pragma\n+\n+            Save_Asp  : constant Node_Id := Corresponding_Aspect (Prag);\n+            Save_From : constant Boolean := From_Aspect_Specification (Prag);\n+            Save_Prag : constant Node_Id := Next_Pragma (Prag);\n+            Save_Rep  : constant Node_Id := Next_Rep_Item (Prag);\n+\n+            Result : Node_Id;\n+\n+         begin\n+            --  Reset all semantic fields. This avoids a potential infinite\n+            --  loop when the pragma comes from an aspect as the duplication\n+            --  will copy the aspect, then copy the corresponding pragma and\n+            --  so on.\n+\n+            Set_Corresponding_Aspect      (Prag, Empty);\n+            Set_From_Aspect_Specification (Prag, False);\n+            Set_Next_Pragma               (Prag, Empty);\n+            Set_Next_Rep_Item             (Prag, Empty);\n+\n+            Result := Copy_Separate_Tree (Prag);\n+\n+            --  Restore the original semantic fields\n+\n+            Set_Corresponding_Aspect      (Prag, Save_Asp);\n+            Set_From_Aspect_Specification (Prag, Save_From);\n+            Set_Next_Pragma               (Prag, Save_Prag);\n+            Set_Next_Rep_Item             (Prag, Save_Rep);\n+\n+            return Result;\n+         end Copy_Import_Pragma;\n+\n+         --  Local variables\n+\n          Loc   : constant Source_Ptr := Sloc (E);\n          CE    : constant Name_Id    := Chars (E);\n-         Spec  : Node_Id;\n-         Parms : List_Id;\n-         Stmt  : Node_Id;\n-         Iprag : Node_Id;\n          Bod   : Node_Id;\n          Forml : Entity_Id;\n+         Parms : List_Id;\n+         Prag  : Node_Id;\n+         Spec  : Node_Id;\n+         Stmt  : Node_Id;\n+\n+      --  Start of processing for Wrap_Imported_Subprogram\n \n       begin\n          --  Nothing to do if not imported\n@@ -4706,18 +4757,14 @@ package body Freeze is\n             --  generates the right visibility, and that is exactly what the\n             --  calls to Copy_Separate_Tree give us.\n \n-            --  Acquire copy of Inline pragma, and indicate that it does not\n-            --  come from an aspect, as it applies to an internal entity.\n-\n-            Iprag := Copy_Separate_Tree (Import_Pragma (E));\n-            Set_From_Aspect_Specification (Iprag, False);\n+            Prag := Copy_Import_Pragma;\n \n             --  Fix up spec to be not imported any more\n \n-            Set_Is_Imported    (E, False);\n-            Set_Interface_Name (E, Empty);\n             Set_Has_Completion (E, False);\n             Set_Import_Pragma  (E, Empty);\n+            Set_Interface_Name (E, Empty);\n+            Set_Is_Imported    (E, False);\n \n             --  Grab the subprogram declaration and specification\n \n@@ -4757,13 +4804,12 @@ package body Freeze is\n                   Copy_Separate_Tree (Spec),\n                 Declarations               => New_List (\n                   Make_Subprogram_Declaration (Loc,\n-                    Specification =>\n-                      Copy_Separate_Tree (Spec)),\n-                    Iprag),\n+                    Specification => Copy_Separate_Tree (Spec)),\n+                  Prag),\n                 Handled_Statement_Sequence =>\n                   Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements             => New_List (Stmt),\n-                    End_Label              => Make_Identifier (Loc, CE)));\n+                    Statements => New_List (Stmt),\n+                    End_Label  => Make_Identifier (Loc, CE)));\n \n             --  Append the body to freeze result\n "}, {"sha": "6c0e7a340368981942b5d604de1159f8742c4298", "filename": "gcc/ada/g-traceb.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Fg-traceb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Fg-traceb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-traceb.ads?ref=2e885a6f7ce629d6517c2bf8dc14824be8e93987", "patch": "@@ -62,6 +62,7 @@\n --     GNU/Linux PowerPC\n --     LynxOS x86\n --     LynxOS 178 xcoff PowerPC\n+--     LynxOS 178 elf PowerPC\n --     Solaris x86\n --     Solaris sparc\n --     VxWorks PowerPC"}, {"sha": "4a04e11b54ab74fee360fb069a5e519f1d547da3", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=2e885a6f7ce629d6517c2bf8dc14824be8e93987", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -390,6 +390,40 @@ package body Inline is\n          return;\n       end if;\n \n+      --  Find out whether the call must be inlined. Unless the result is\n+      --  Dont_Inline, Must_Inline also creates an edge for the call in the\n+      --  callgraph; however, it will not be activated until after Is_Called\n+      --  is set on the subprogram.\n+\n+      Level := Must_Inline;\n+\n+      if Level = Dont_Inline then\n+         return;\n+      end if;\n+\n+      --  If the call was generated by the compiler and is to a subprogram in\n+      --  a run-time unit, we need to suppress debugging information for it,\n+      --  so that the code that is eventually inlined will not affect the\n+      --  debugging of the program. We do not do it if the call comes from\n+      --  source because, even if the call is inlined, the user may expect it\n+      --  to be present in the debugging information.\n+\n+      if not Comes_From_Source (N)\n+        and then In_Extended_Main_Source_Unit (N)\n+        and then\n+          Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (E)))\n+      then\n+         Set_Needs_Debug_Info (E, False);\n+      end if;\n+\n+      --  If the subprogram is an expression function, then there is no need to\n+      --  load any package body since the body of the function is in the spec.\n+\n+      if Is_Expression_Function (E) then\n+         Set_Is_Called (E);\n+         return;\n+      end if;\n+\n       --  Find unit containing E, and add to list of inlined bodies if needed.\n       --  If the body is already present, no need to load any other unit. This\n       --  is the case for an initialization procedure, which appears in the\n@@ -403,77 +437,48 @@ package body Inline is\n       --  no enclosing package to retrieve. In this case, it is the body of\n       --  the function that will have to be loaded.\n \n-      Level := Must_Inline;\n-\n-      if Level /= Dont_Inline then\n-         declare\n-            Pack : constant Entity_Id := Get_Code_Unit_Entity (E);\n-\n-         begin\n-            --  Ensure that Analyze_Inlined_Bodies will be invoked after\n-            --  completing the analysis of the current unit.\n+      declare\n+         Pack : constant Entity_Id := Get_Code_Unit_Entity (E);\n \n-            Inline_Processing_Required := True;\n+      begin\n+         if Pack = E then\n+            Set_Is_Called (E);\n+            Inlined_Bodies.Increment_Last;\n+            Inlined_Bodies.Table (Inlined_Bodies.Last) := E;\n \n-            if Pack = E then\n+         elsif Ekind (Pack) = E_Package then\n+            Set_Is_Called (E);\n \n-               --  Library-level inlined function. Add function itself to\n-               --  list of needed units.\n+            if Is_Generic_Instance (Pack) then\n+               null;\n \n-               Set_Is_Called (E);\n+            --  Do not inline the package if the subprogram is an init proc\n+            --  or other internally generated subprogram, because in that\n+            --  case the subprogram body appears in the same unit that\n+            --  declares the type, and that body is visible to the back end.\n+            --  Do not inline it either if it is in the main unit.\n+            --  Extend the -gnatn2 processing to -gnatn1 for Inline_Always\n+            --  calls if the back-end takes care of inlining the call.\n+\n+            elsif (Level = Inline_Package\n+                    or else (Level = Inline_Call\n+                              and then Has_Pragma_Inline_Always (E)\n+                              and then Back_End_Inlining))\n+              and then not Is_Inlined (Pack)\n+              and then not Is_Internal (E)\n+              and then not In_Main_Unit_Or_Subunit (Pack)\n+            then\n+               Set_Is_Inlined (Pack);\n                Inlined_Bodies.Increment_Last;\n-               Inlined_Bodies.Table (Inlined_Bodies.Last) := E;\n-\n-            elsif Ekind (Pack) = E_Package then\n-               Set_Is_Called (E);\n-\n-               if Is_Generic_Instance (Pack) then\n-                  null;\n-\n-               --  Do not inline the package if the subprogram is an init proc\n-               --  or other internally generated subprogram, because in that\n-               --  case the subprogram body appears in the same unit that\n-               --  declares the type, and that body is visible to the back end.\n-               --  Do not inline it either if it is in the main unit.\n-\n-               elsif Level = Inline_Package\n-                 and then not Is_Inlined (Pack)\n-                 and then not Is_Internal (E)\n-                 and then not In_Main_Unit_Or_Subunit (Pack)\n-               then\n-                  Set_Is_Inlined (Pack);\n-                  Inlined_Bodies.Increment_Last;\n-                  Inlined_Bodies.Table (Inlined_Bodies.Last) := Pack;\n-\n-               --  Extend the -gnatn2 processing to -gnatn1 for Inline_Always\n-               --  calls if the back-end takes care of inlining the call.\n-\n-               elsif Level = Inline_Call\n-                 and then Has_Pragma_Inline_Always (E)\n-                 and then Back_End_Inlining\n-               then\n-                  Set_Is_Inlined (Pack);\n-                  Inlined_Bodies.Increment_Last;\n-                  Inlined_Bodies.Table (Inlined_Bodies.Last) := Pack;\n-               end if;\n+               Inlined_Bodies.Table (Inlined_Bodies.Last) := Pack;\n             end if;\n+         end if;\n \n-            --  If the call was generated by the compiler and is to a function\n-            --  in a run-time unit, we need to suppress debugging information\n-            --  for it, so that the code that is eventually inlined will not\n-            --  affect debugging of the program. We do not do it if the call\n-            --  comes from source because, even if the call is inlined, the\n-            --  user may expect it to be present in the debugging information.\n-\n-            if not Comes_From_Source (N)\n-               and then In_Extended_Main_Source_Unit (N)\n-               and then\n-                 Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (E)))\n-            then\n-               Set_Needs_Debug_Info (E, False);\n-            end if;\n-         end;\n-      end if;\n+         --  Ensure that Analyze_Inlined_Bodies will be invoked after\n+         --  completing the analysis of the current unit.\n+\n+         Inline_Processing_Required := True;\n+      end;\n    end Add_Inlined_Body;\n \n    ----------------------------"}, {"sha": "5e4368e563ce4603196f08f0a67ba86222082f2b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 512, "deletions": 205, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e885a6f7ce629d6517c2bf8dc14824be8e93987/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2e885a6f7ce629d6517c2bf8dc14824be8e93987", "patch": "@@ -101,6 +101,13 @@ package body Sem_Ch13 is\n    --  list is stored in Static_Discrete_Predicate (Typ), and the Expr is\n    --  rewritten as a canonicalized membership operation.\n \n+   function Build_Export_Import_Pragma\n+     (Asp : Node_Id;\n+      Id  : Entity_Id) return Node_Id;\n+   --  Create the corresponding pragma for aspect Export or Import denoted by\n+   --  Asp. Id is the related entity subject to the aspect. Return Empty when\n+   --  the expression of aspect Asp evaluates to False or is erroneous.\n+\n    function Build_Predicate_Function_Declaration\n       (Typ : Entity_Id) return Node_Id;\n    --  Build the declaration for a predicate function. The declaration is built\n@@ -136,6 +143,27 @@ package body Sem_Ch13 is\n    --  Uint value. If the value is inappropriate, then error messages are\n    --  posted as required, and a value of No_Uint is returned.\n \n+   procedure Get_Interfacing_Aspects\n+     (Iface_Asp : Node_Id;\n+      Conv_Asp  : out Node_Id;\n+      EN_Asp    : out Node_Id;\n+      Expo_Asp  : out Node_Id;\n+      Imp_Asp   : out Node_Id;\n+      LN_Asp    : out Node_Id;\n+      Do_Checks : Boolean := False);\n+   --  Given a single interfacing aspect Iface_Asp, retrieve other interfacing\n+   --  aspects that apply to the same related entity. The aspects considered by\n+   --  this routine are as follows:\n+   --\n+   --    Conv_Asp - aspect Convention\n+   --    EN_Asp   - aspect External_Name\n+   --    Expo_Asp - aspect Export\n+   --    Imp_Asp  - aspect Import\n+   --    LN_Asp   - aspect Link_Name\n+   --\n+   --  When flag Do_Checks is set, this routine will flag duplicate uses of\n+   --  aspects.\n+\n    function Is_Operational_Item (N : Node_Id) return Boolean;\n    --  A specification for a stream attribute is allowed before the full type\n    --  is declared, as explained in AI-00137 and the corrigendum. Attributes\n@@ -730,10 +758,6 @@ package body Sem_Ch13 is\n    -------------------------------------\n \n    procedure Analyze_Aspects_At_Freeze_Point (E : Entity_Id) is\n-      ASN   : Node_Id;\n-      A_Id  : Aspect_Id;\n-      Ritem : Node_Id;\n-\n       procedure Analyze_Aspect_Default_Value (ASN : Node_Id);\n       --  This routine analyzes an Aspect_Default_[Component_]Value denoted by\n       --  the aspect specification node ASN.\n@@ -771,6 +795,7 @@ package body Sem_Ch13 is\n       ----------------------------------\n \n       procedure Analyze_Aspect_Default_Value (ASN : Node_Id) is\n+         A_Id : constant Aspect_Id := Get_Aspect_Id (ASN);\n          Ent  : constant Entity_Id := Entity (ASN);\n          Expr : constant Node_Id   := Expression (ASN);\n          Id   : constant Node_Id   := Identifier (ASN);\n@@ -817,7 +842,8 @@ package body Sem_Ch13 is\n       ---------------------------------\n \n       procedure Inherit_Delayed_Rep_Aspects (ASN : Node_Id) is\n-         P : constant Entity_Id := Entity (ASN);\n+         A_Id : constant Aspect_Id := Get_Aspect_Id (ASN);\n+         P    : constant Entity_Id := Entity (ASN);\n          --  Entithy for parent type\n \n          N : Node_Id;\n@@ -1013,8 +1039,6 @@ package body Sem_Ch13 is\n          Expr   : constant Node_Id    := Expression (ASN);\n          Loc    : constant Source_Ptr := Sloc (ASN);\n \n-         Prag : Node_Id;\n-\n          procedure Check_False_Aspect_For_Derived_Type;\n          --  This procedure checks for the case of a false aspect for a derived\n          --  type, which improperly tries to cancel an aspect inherited from\n@@ -1088,6 +1112,10 @@ package body Sem_Ch13 is\n               (\"derived type& inherits aspect%, cannot cancel\", Expr, E);\n          end Check_False_Aspect_For_Derived_Type;\n \n+         --  Local variables\n+\n+         Prag : Node_Id;\n+\n       --  Start of processing for Make_Pragma_From_Boolean_Aspect\n \n       begin\n@@ -1101,12 +1129,11 @@ package body Sem_Ch13 is\n          else\n             Prag :=\n               Make_Pragma (Loc,\n+                Pragma_Identifier            =>\n+                  Make_Identifier (Sloc (Ident), Chars (Ident)),\n                 Pragma_Argument_Associations => New_List (\n                   Make_Pragma_Argument_Association (Sloc (Ident),\n-                    Expression => New_Occurrence_Of (Ent, Sloc (Ident)))),\n-\n-                Pragma_Identifier            =>\n-                  Make_Identifier (Sloc (Ident), Chars (Ident)));\n+                    Expression => New_Occurrence_Of (Ent, Sloc (Ident)))));\n \n             Set_From_Aspect_Specification (Prag, True);\n             Set_Corresponding_Aspect (Prag, ASN);\n@@ -1116,6 +1143,12 @@ package body Sem_Ch13 is\n          end if;\n       end Make_Pragma_From_Boolean_Aspect;\n \n+      --  Local variables\n+\n+      A_Id  : Aspect_Id;\n+      ASN   : Node_Id;\n+      Ritem : Node_Id;\n+\n    --  Start of processing for Analyze_Aspects_At_Freeze_Point\n \n    begin\n@@ -1142,7 +1175,25 @@ package body Sem_Ch13 is\n \n                   when Boolean_Aspects      |\n                        Library_Unit_Aspects =>\n-                     Make_Pragma_From_Boolean_Aspect (ASN);\n+\n+                     --  Aspects Export and Import require special handling.\n+                     --  Both are by definition Boolean and may benefit from\n+                     --  forward references, however their expressions are\n+                     --  treated as static. In addition, the syntax of their\n+                     --  corresponding pragmas requires extra \"pieces\" which\n+                     --  may also contain forward references. To account for\n+                     --  all of this, the corresponding pragma is created by\n+                     --  Analyze_Aspect_Export_Import, but is not analyzed as\n+                     --  the complete analysis must happen now.\n+\n+                     if A_Id = Aspect_Export or else A_Id = Aspect_Import then\n+                        null;\n+\n+                     --  Otherwise create a corresponding pragma\n+\n+                     else\n+                        Make_Pragma_From_Boolean_Aspect (ASN);\n+                     end if;\n \n                   --  Special handling for aspects that don't correspond to\n                   --  pragmas/attributes.\n@@ -1435,8 +1486,9 @@ package body Sem_Ch13 is\n       --  Insert pragmas/attribute definition clause after this node when no\n       --  delayed analysis is required.\n \n-      --  Start of processing for Analyze_Aspect_Specifications\n+   --  Start of processing for Analyze_Aspect_Specifications\n \n+   begin\n       --  The general processing involves building an attribute definition\n       --  clause or a pragma node that corresponds to the aspect. Then in order\n       --  to delay the evaluation of this aspect to the freeze point, we attach\n@@ -1456,7 +1508,6 @@ package body Sem_Ch13 is\n       --  of visibility for the expression analysis. Thus, we just insert\n       --  the pragma after the node N.\n \n-   begin\n       pragma Assert (Present (L));\n \n       --  Loop through aspects\n@@ -1478,8 +1529,14 @@ package body Sem_Ch13 is\n             --  Source location of expression, modified when we split PPC's. It\n             --  is set below when Expr is present.\n \n-            procedure Analyze_Aspect_External_Or_Link_Name;\n-            --  Perform analysis of the External_Name or Link_Name aspects\n+            procedure Analyze_Aspect_Convention;\n+            --  Perform analysis of aspect Convention\n+\n+            procedure Analyze_Aspect_Export_Import;\n+            --  Perform analysis of aspects Export or Import\n+\n+            procedure Analyze_Aspect_External_Link_Name;\n+            --  Perform analysis of aspects External_Name or Link_Name\n \n             procedure Analyze_Aspect_Implicit_Dereference;\n             --  Perform analysis of the Implicit_Dereference aspects\n@@ -1496,35 +1553,193 @@ package body Sem_Ch13 is\n             --  True, and sets Corresponding_Aspect to point to the aspect.\n             --  The resulting pragma is assigned to Aitem.\n \n-            ------------------------------------------\n-            -- Analyze_Aspect_External_Or_Link_Name --\n-            ------------------------------------------\n+            -------------------------------\n+            -- Analyze_Aspect_Convention --\n+            -------------------------------\n+\n+            procedure Analyze_Aspect_Convention is\n+               Conv    : Node_Id;\n+               Dummy_1 : Node_Id;\n+               Dummy_2 : Node_Id;\n+               Dummy_3 : Node_Id;\n+               Expo    : Node_Id;\n+               Imp     : Node_Id;\n \n-            procedure Analyze_Aspect_External_Or_Link_Name is\n             begin\n-               --  Verify that there is an Import/Export aspect defined for the\n-               --  entity. The processing of that aspect in turn checks that\n-               --  there is a Convention aspect declared. The pragma is\n-               --  constructed when processing the Convention aspect.\n+               --  Obtain all interfacing aspects that apply to the related\n+               --  entity.\n+\n+               Get_Interfacing_Aspects\n+                 (Iface_Asp => Aspect,\n+                  Conv_Asp  => Dummy_1,\n+                  EN_Asp    => Dummy_2,\n+                  Expo_Asp  => Expo,\n+                  Imp_Asp   => Imp,\n+                  LN_Asp    => Dummy_3,\n+                  Do_Checks => True);\n+\n+               --  The related entity is subject to aspect Export or Import.\n+               --  Do not process Convention now because it must be analysed\n+               --  as part of Export or Import.\n+\n+               if Present (Expo) or else Present (Imp) then\n+                  return;\n \n-               declare\n-                  A : Node_Id;\n+               --  Otherwise Convention appears by itself\n \n-               begin\n-                  A := First (L);\n-                  while Present (A) loop\n-                     exit when Nam_In (Chars (Identifier (A)), Name_Export,\n-                                                               Name_Import);\n-                     Next (A);\n-                  end loop;\n+               else\n+                  --  The aspect specifies a particular convention\n+\n+                  if Present (Expr) then\n+                     Conv := New_Copy_Tree (Expr);\n+\n+                  --  Otherwise assume convention Ada\n+\n+                  else\n+                     Conv := Make_Identifier (Loc, Name_Ada);\n+                  end if;\n+\n+                  --  Generate:\n+                  --    pragma Convention (<Conv>, <E>);\n+\n+                  Make_Aitem_Pragma\n+                    (Pragma_Name => Name_Convention,\n+                     Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Conv),\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => New_Occurrence_Of (E, Loc))));\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+               end if;\n+            end Analyze_Aspect_Convention;\n+\n+            ----------------------------------\n+            -- Analyze_Aspect_Export_Import --\n+            ----------------------------------\n+\n+            procedure Analyze_Aspect_Export_Import is\n+               Dummy_1 : Node_Id;\n+               Dummy_2 : Node_Id;\n+               Dummy_3 : Node_Id;\n+               Expo    : Node_Id;\n+               Imp     : Node_Id;\n+\n+            begin\n+               --  Obtain all interfacing aspects that apply to the related\n+               --  entity.\n+\n+               Get_Interfacing_Aspects\n+                 (Iface_Asp => Aspect,\n+                  Conv_Asp  => Dummy_1,\n+                  EN_Asp    => Dummy_2,\n+                  Expo_Asp  => Expo,\n+                  Imp_Asp   => Imp,\n+                  LN_Asp    => Dummy_3,\n+                  Do_Checks => True);\n+\n+               --  The related entity cannot be subject to both aspects Export\n+               --  and Import.\n+\n+               if Present (Expo) and then Present (Imp) then\n+                  Error_Msg_N\n+                    (\"incompatible interfacing aspects given for &\", E);\n+                  Error_Msg_Sloc := Sloc (Expo);\n+                  Error_Msg_N (\"\\aspect `Export` #\", E);\n+                  Error_Msg_Sloc := Sloc (Imp);\n+                  Error_Msg_N (\"\\aspect `Import` #\", E);\n+               end if;\n+\n+               --  A variable is most likely modified from the outside. Take\n+               --  Take the optimistic approach to avoid spurious errors.\n+\n+               if Ekind (E) = E_Variable then\n+                  Set_Never_Set_In_Source (E, False);\n+               end if;\n+\n+               --  Resolve the expression of an Import or Export here, and\n+               --  require it to be of type Boolean and static. This is not\n+               --  quite right, because in general this should be delayed,\n+               --  but that seems tricky for these, because normally Boolean\n+               --  aspects are replaced with pragmas at the freeze point in\n+               --  Make_Pragma_From_Boolean_Aspect.\n+\n+               if not Present (Expr)\n+                 or else Is_True (Static_Boolean (Expr))\n+               then\n+                  if A_Id = Aspect_Import then\n+                     Set_Has_Completion (E);\n+                     Set_Is_Imported (E);\n+\n+                     --  An imported object cannot be explicitly initialized\n+\n+                     if Nkind (N) = N_Object_Declaration\n+                       and then Present (Expression (N))\n+                     then\n+                        Error_Msg_N\n+                          (\"imported entities cannot be initialized \"\n+                           & \"(RM B.1(24))\", Expression (N));\n+                     end if;\n+\n+                  else\n+                     pragma Assert (A_Id = Aspect_Export);\n+                     Set_Is_Exported (E);\n+                  end if;\n+\n+                  --  Create the proper form of pragma Export or Import taking\n+                  --  into account Conversion, External_Name, and Link_Name.\n+\n+                  Aitem := Build_Export_Import_Pragma (Aspect, E);\n+               end if;\n+            end Analyze_Aspect_Export_Import;\n+\n+            ---------------------------------------\n+            -- Analyze_Aspect_External_Link_Name --\n+            ---------------------------------------\n \n-                  if No (A) then\n+            procedure Analyze_Aspect_External_Link_Name is\n+               Dummy_1 : Node_Id;\n+               Dummy_2 : Node_Id;\n+               Dummy_3 : Node_Id;\n+               Expo    : Node_Id;\n+               Imp     : Node_Id;\n+\n+            begin\n+               --  Obtain all interfacing aspects that apply to the related\n+               --  entity.\n+\n+               Get_Interfacing_Aspects\n+                 (Iface_Asp => Aspect,\n+                  Conv_Asp  => Dummy_1,\n+                  EN_Asp    => Dummy_2,\n+                  Expo_Asp  => Expo,\n+                  Imp_Asp   => Imp,\n+                  LN_Asp    => Dummy_3,\n+                  Do_Checks => True);\n+\n+               --  Ensure that aspect External_Name applies to aspect Export or\n+               --  Import.\n+\n+               if A_Id = Aspect_External_Name then\n+                  if No (Expo) and then No (Imp) then\n                      Error_Msg_N\n-                       (\"missing Import/Export for Link/External name\",\n-                        Aspect);\n+                       (\"aspect `External_Name` requires aspect `Import` or \"\n+                        & \"`Export`\", Aspect);\n                   end if;\n-               end;\n-            end Analyze_Aspect_External_Or_Link_Name;\n+\n+               --  Otherwise ensure that aspect Link_Name applies to aspect\n+               --  Export or Import.\n+\n+               else\n+                  pragma Assert (A_Id = Aspect_Link_Name);\n+                  if No (Expo) and then No (Imp) then\n+                     Error_Msg_N\n+                       (\"aspect `Link_Name` requires aspect `Import` or \"\n+                        & \"`Export`\", Aspect);\n+                  end if;\n+               end if;\n+            end Analyze_Aspect_External_Link_Name;\n \n             -----------------------------------------\n             -- Analyze_Aspect_Implicit_Dereference --\n@@ -1561,8 +1776,7 @@ package body Sem_Ch13 is\n                   --  Error if no proper access discriminant\n \n                   if No (Disc) then\n-                     Error_Msg_NE\n-                      (\"not an access discriminant of&\", Expr, E);\n+                     Error_Msg_NE (\"not an access discriminant of&\", Expr, E);\n                      return;\n                   end if;\n                end if;\n@@ -1578,8 +1792,9 @@ package body Sem_Ch13 is\n                   if Present (Parent_Disc)\n                     and then Corresponding_Discriminant (Disc) /= Parent_Disc\n                   then\n-                     Error_Msg_N (\"reference discriminant does not match \" &\n-                       \"discriminant of parent type\", Expr);\n+                     Error_Msg_N\n+                       (\"reference discriminant does not match discriminant \"\n+                        & \"of parent type\", Expr);\n                   end if;\n                end if;\n             end Analyze_Aspect_Implicit_Dereference;\n@@ -2040,101 +2255,16 @@ package body Sem_Ch13 is\n \n                --  Convention\n \n-               when Aspect_Convention  =>\n-\n-                  --  The aspect may be part of the specification of an import\n-                  --  or export pragma. Scan the aspect list to gather the\n-                  --  other components, if any. The name of the generated\n-                  --  pragma is one of Convention/Import/Export.\n-\n-                  declare\n-                     Args : constant List_Id := New_List (\n-                              Make_Pragma_Argument_Association (Sloc (Expr),\n-                                Expression => Relocate_Node (Expr)),\n-                              Make_Pragma_Argument_Association (Sloc (Ent),\n-                                Expression => Ent));\n-\n-                     Imp_Exp_Seen : Boolean := False;\n-                     --  Flag set when aspect Import or Export has been seen\n-\n-                     Imp_Seen : Boolean := False;\n-                     --  Flag set when aspect Import has been seen\n-\n-                     Asp        : Node_Id;\n-                     Asp_Nam    : Name_Id;\n-                     Extern_Arg : Node_Id;\n-                     Link_Arg   : Node_Id;\n-                     Prag_Nam   : Name_Id;\n-\n-                  begin\n-                     Extern_Arg := Empty;\n-                     Link_Arg   := Empty;\n-                     Prag_Nam   := Chars (Id);\n-\n-                     Asp := First (L);\n-                     while Present (Asp) loop\n-                        Asp_Nam := Chars (Identifier (Asp));\n-\n-                        --  Aspects Import and Export take precedence over\n-                        --  aspect Convention. As a result the generated pragma\n-                        --  must carry the proper interfacing aspect's name.\n-\n-                        if Nam_In (Asp_Nam, Name_Import, Name_Export) then\n-                           if Imp_Exp_Seen then\n-                              Error_Msg_N (\"conflicting\", Asp);\n-                           else\n-                              Imp_Exp_Seen := True;\n-\n-                              if Asp_Nam = Name_Import then\n-                                 Imp_Seen := True;\n-                              end if;\n-                           end if;\n-\n-                           Prag_Nam := Asp_Nam;\n-\n-                        --  Aspect External_Name adds an extra argument to the\n-                        --  generated pragma.\n-\n-                        elsif Asp_Nam = Name_External_Name then\n-                           Extern_Arg :=\n-                             Make_Pragma_Argument_Association (Loc,\n-                               Chars      => Asp_Nam,\n-                               Expression => Relocate_Node (Expression (Asp)));\n-\n-                        --  Aspect Link_Name adds an extra argument to the\n-                        --  generated pragma.\n-\n-                        elsif Asp_Nam = Name_Link_Name then\n-                           Link_Arg :=\n-                             Make_Pragma_Argument_Association (Loc,\n-                               Chars      => Asp_Nam,\n-                               Expression => Relocate_Node (Expression (Asp)));\n-                        end if;\n-\n-                        Next (Asp);\n-                     end loop;\n-\n-                     --  Assemble the full argument list\n-\n-                     if Present (Extern_Arg) then\n-                        Append_To (Args, Extern_Arg);\n-                     end if;\n-\n-                     if Present (Link_Arg) then\n-                        Append_To (Args, Link_Arg);\n-                     end if;\n-\n-                     Make_Aitem_Pragma\n-                       (Pragma_Argument_Associations => Args,\n-                        Pragma_Name                  => Prag_Nam);\n+               when Aspect_Convention =>\n+                  Analyze_Aspect_Convention;\n+                  goto Continue;\n \n-                     --  Store the generated pragma Import in the related\n-                     --  subprogram.\n+               --  External_Name, Link_Name\n \n-                     if Imp_Seen and then Is_Subprogram (E) then\n-                        Set_Import_Pragma (E, Aitem);\n-                     end if;\n-                  end;\n+               when Aspect_External_Name |\n+                    Aspect_Link_Name     =>\n+                  Analyze_Aspect_External_Link_Name;\n+                  goto Continue;\n \n                --  CPU, Interrupt_Priority, Priority\n \n@@ -2937,8 +3067,9 @@ package body Sem_Ch13 is\n                   if not (Is_Array_Type (E)\n                            and then Is_Scalar_Type (Component_Type (E)))\n                   then\n-                     Error_Msg_N (\"aspect Default_Component_Value can only \"\n-                       & \"apply to an array of scalar components\", N);\n+                     Error_Msg_N\n+                       (\"aspect Default_Component_Value can only apply to an \"\n+                        & \"array of scalar components\", N);\n                   end if;\n \n                   Aitem := Empty;\n@@ -2956,13 +3087,6 @@ package body Sem_Ch13 is\n                   Analyze_Aspect_Implicit_Dereference;\n                   goto Continue;\n \n-               --  External_Name, Link_Name\n-\n-               when Aspect_External_Name |\n-                    Aspect_Link_Name     =>\n-                  Analyze_Aspect_External_Or_Link_Name;\n-                  goto Continue;\n-\n                --  Dimension\n \n                when Aspect_Dimension =>\n@@ -3187,61 +3311,8 @@ package body Sem_Ch13 is\n \n                      goto Continue;\n \n-                  elsif A_Id = Aspect_Import or else A_Id = Aspect_Export then\n-\n-                     --  For the case of aspects Import and Export, we don't\n-                     --  consider that we know the entity is never set in the\n-                     --  source, since it is is likely modified outside the\n-                     --  program.\n-\n-                     --  Note: one might think that the analysis of the\n-                     --  resulting pragma would take care of that, but\n-                     --  that's not the case since it won't be from source.\n-\n-                     if Ekind (E) = E_Variable then\n-                        Set_Never_Set_In_Source (E, False);\n-                     end if;\n-\n-                     --  In older versions of Ada the corresponding pragmas\n-                     --  specified a Convention. In Ada 2012 the convention is\n-                     --  specified as a separate aspect, and it is optional,\n-                     --  given that it defaults to Convention_Ada. The code\n-                     --  that verifed that there was a matching convention\n-                     --  is now obsolete.\n-\n-                     --  Resolve the expression of an Import or Export here,\n-                     --  and require it to be of type Boolean and static. This\n-                     --  is not quite right, because in general this should be\n-                     --  delayed, but that seems tricky for these, because\n-                     --  normally Boolean aspects are replaced with pragmas at\n-                     --  the freeze point (in Make_Pragma_From_Boolean_Aspect),\n-                     --  but in the case of these aspects we can't generate\n-                     --  a simple pragma with just the entity name. ???\n-\n-                     if not Present (Expr)\n-                       or else Is_True (Static_Boolean (Expr))\n-                     then\n-                        if A_Id = Aspect_Import then\n-                           Set_Is_Imported (E);\n-                           Set_Has_Completion (E);\n-\n-                           --  An imported entity cannot have an explicit\n-                           --  initialization.\n-\n-                           if Nkind (N) = N_Object_Declaration\n-                             and then Present (Expression (N))\n-                           then\n-                              Error_Msg_N\n-                                (\"imported entities cannot be initialized \"\n-                                 & \"(RM B.1(24))\", Expression (N));\n-                           end if;\n-\n-                        elsif A_Id = Aspect_Export then\n-                           Set_Is_Exported (E);\n-                        end if;\n-                     end if;\n-\n-                     goto Continue;\n+                  elsif A_Id = Aspect_Export or else A_Id = Aspect_Import then\n+                     Analyze_Aspect_Export_Import;\n \n                   --  Disable_Controlled\n \n@@ -3302,11 +3373,20 @@ package body Sem_Ch13 is\n                   --  expression is missing other than the above cases.\n \n                   if not Delay_Required or else No (Expr) then\n-                     Make_Aitem_Pragma\n-                       (Pragma_Argument_Associations => New_List (\n-                          Make_Pragma_Argument_Association (Sloc (Ent),\n-                            Expression => Ent)),\n-                        Pragma_Name                  => Chars (Id));\n+\n+                     --  Exclude aspects Export and Import because their pragma\n+                     --  syntax does not map directly to a Boolean aspect.\n+\n+                     if A_Id /= Aspect_Export\n+                       and then A_Id /= Aspect_Import\n+                     then\n+                        Make_Aitem_Pragma\n+                          (Pragma_Argument_Associations => New_List (\n+                             Make_Pragma_Argument_Association (Sloc (Ent),\n+                               Expression => Ent)),\n+                           Pragma_Name                  => Chars (Id));\n+                     end if;\n+\n                      Delay_Required := False;\n \n                   --  In general cases, the corresponding pragma/attribute\n@@ -3506,7 +3586,7 @@ package body Sem_Ch13 is\n             --  unit, we simply insert the pragma/attribute definition clause\n             --  in sequence.\n \n-            else\n+            elsif Present (Aitem) then\n                Insert_After (Ins_Node, Aitem);\n                Ins_Node := Aitem;\n             end if;\n@@ -7814,6 +7894,133 @@ package body Sem_Ch13 is\n          return;\n    end Build_Discrete_Static_Predicate;\n \n+   --------------------------------\n+   -- Build_Export_Import_Pragma --\n+   --------------------------------\n+\n+   function Build_Export_Import_Pragma\n+     (Asp : Node_Id;\n+      Id  : Entity_Id) return Node_Id\n+   is\n+      Asp_Id : constant Aspect_Id  := Get_Aspect_Id (Asp);\n+      Expr   : constant Node_Id    := Expression (Asp);\n+      Loc    : constant Source_Ptr := Sloc (Asp);\n+\n+      Args     : List_Id;\n+      Conv     : Node_Id;\n+      Conv_Arg : Node_Id;\n+      Dummy_1  : Node_Id;\n+      Dummy_2  : Node_Id;\n+      EN       : Node_Id;\n+      LN       : Node_Id;\n+      Prag     : Node_Id;\n+\n+      Create_Pragma : Boolean := False;\n+      --  This flag is set when the aspect form is such that it warrants the\n+      --  creation of a corresponding pragma.\n+\n+   begin\n+      if Present (Expr) then\n+         if Error_Posted (Expr) then\n+            null;\n+\n+         elsif Is_True (Expr_Value (Expr)) then\n+            Create_Pragma := True;\n+         end if;\n+\n+      --  Otherwise the aspect defaults to True\n+\n+      else\n+         Create_Pragma := True;\n+      end if;\n+\n+      --  Nothing to do when the expression is False or is erroneous\n+\n+      if not Create_Pragma then\n+         return Empty;\n+      end if;\n+\n+      --  Obtain all interfacing aspects that apply to the related entity\n+\n+      Get_Interfacing_Aspects\n+        (Iface_Asp => Asp,\n+         Conv_Asp  => Conv,\n+         EN_Asp    => EN,\n+         Expo_Asp  => Dummy_1,\n+         Imp_Asp   => Dummy_2,\n+         LN_Asp    => LN);\n+\n+      Args := New_List;\n+\n+      --  Handle the convention argument\n+\n+      if Present (Conv) then\n+         Conv_Arg := New_Copy_Tree (Expression (Conv));\n+\n+      --  Assume convention \"Ada' when aspect Convention is missing\n+\n+      else\n+         Conv_Arg := Make_Identifier (Loc, Name_Ada);\n+      end if;\n+\n+      Append_To (Args,\n+        Make_Pragma_Argument_Association (Loc,\n+          Chars      => Name_Convention,\n+          Expression => Conv_Arg));\n+\n+      --  Handle the entity argument\n+\n+      Append_To (Args,\n+        Make_Pragma_Argument_Association (Loc,\n+          Chars      => Name_Entity,\n+          Expression => New_Occurrence_Of (Id, Loc)));\n+\n+      --  Handle the External_Name argument\n+\n+      if Present (EN) then\n+         Append_To (Args,\n+           Make_Pragma_Argument_Association (Loc,\n+             Chars      => Name_External_Name,\n+             Expression => New_Copy_Tree (Expression (EN))));\n+      end if;\n+\n+      --  Handle the Link_Name argument\n+\n+      if Present (LN) then\n+         Append_To (Args,\n+           Make_Pragma_Argument_Association (Loc,\n+             Chars      => Name_Link_Name,\n+             Expression => New_Copy_Tree (Expression (LN))));\n+      end if;\n+\n+      --  Generate:\n+      --    pragma Export/Import\n+      --      (Convention    => <Conv>/Ada,\n+      --       Entity        => <Id>,\n+      --      [External_Name => <EN>,]\n+      --      [Link_Name     => <LN>]);\n+\n+      Prag :=\n+        Make_Pragma (Loc,\n+          Pragma_Identifier            =>\n+            Make_Identifier (Loc, Chars (Identifier (Asp))),\n+          Pragma_Argument_Associations => Args);\n+\n+      --  Decorate the relevant aspect and the pragma\n+\n+      Set_Aspect_Rep_Item (Asp, Prag);\n+\n+      Set_Corresponding_Aspect      (Prag, Asp);\n+      Set_From_Aspect_Specification (Prag);\n+      Set_Parent                    (Prag, Asp);\n+\n+      if Asp_Id = Aspect_Import and then Is_Subprogram (Id) then\n+         Set_Import_Pragma (Id, Prag);\n+      end if;\n+\n+      return Prag;\n+   end Build_Export_Import_Pragma;\n+\n    -------------------------------------------\n    -- Build_Invariant_Procedure_Declaration --\n    -------------------------------------------\n@@ -11298,6 +11505,106 @@ package body Sem_Ch13 is\n       end if;\n    end Get_Alignment_Value;\n \n+   -----------------------------\n+   -- Get_Interfacing_Aspects --\n+   -----------------------------\n+\n+   procedure Get_Interfacing_Aspects\n+     (Iface_Asp : Node_Id;\n+      Conv_Asp  : out Node_Id;\n+      EN_Asp    : out Node_Id;\n+      Expo_Asp  : out Node_Id;\n+      Imp_Asp   : out Node_Id;\n+      LN_Asp    : out Node_Id;\n+      Do_Checks : Boolean := False)\n+   is\n+      procedure Save_Or_Duplication_Error\n+        (Asp : Node_Id;\n+         To  : in out Node_Id);\n+      --  Save the value of aspect Asp in node To. If To already has a value,\n+      --  then this is considered a duplicate use of aspect. Emit an error if\n+      --  flag Do_Checks is set.\n+\n+      -------------------------------\n+      -- Save_Or_Duplication_Error --\n+      -------------------------------\n+\n+      procedure Save_Or_Duplication_Error\n+        (Asp : Node_Id;\n+         To  : in out Node_Id)\n+      is\n+      begin\n+         --  Detect an extra aspect and issue an error\n+\n+         if Present (To) then\n+            if Do_Checks then\n+               Error_Msg_Name_1 := Chars (Identifier (Asp));\n+               Error_Msg_Sloc   := Sloc (To);\n+               Error_Msg_N (\"aspect % previously given #\", Asp);\n+            end if;\n+\n+         --  Otherwise capture the aspect\n+\n+         else\n+            To := Asp;\n+         end if;\n+      end Save_Or_Duplication_Error;\n+\n+      --  Local variables\n+\n+      Asp    : Node_Id;\n+      Asp_Id : Aspect_Id;\n+\n+      --  The following variables capture each individual aspect\n+\n+      Conv : Node_Id := Empty;\n+      EN   : Node_Id := Empty;\n+      Expo : Node_Id := Empty;\n+      Imp  : Node_Id := Empty;\n+      LN   : Node_Id := Empty;\n+\n+   --  Start of processing for Get_Interfacing_Aspects\n+\n+   begin\n+      --  The input interfacing aspect should reside in an aspect specification\n+      --  list.\n+\n+      pragma Assert (Is_List_Member (Iface_Asp));\n+\n+      --  Examine the aspect specifications of the related entity. Find and\n+      --  capture all interfacing aspects. Detect duplicates and emit errors\n+      --  if applicable.\n+\n+      Asp := First (List_Containing (Iface_Asp));\n+      while Present (Asp) loop\n+         Asp_Id := Get_Aspect_Id (Asp);\n+\n+         if Asp_Id = Aspect_Convention then\n+            Save_Or_Duplication_Error (Asp, Conv);\n+\n+         elsif Asp_Id = Aspect_External_Name then\n+            Save_Or_Duplication_Error (Asp, EN);\n+\n+         elsif Asp_Id = Aspect_Export then\n+            Save_Or_Duplication_Error (Asp, Expo);\n+\n+         elsif Asp_Id = Aspect_Import then\n+            Save_Or_Duplication_Error (Asp, Imp);\n+\n+         elsif Asp_Id = Aspect_Link_Name then\n+            Save_Or_Duplication_Error (Asp, LN);\n+         end if;\n+\n+         Next (Asp);\n+      end loop;\n+\n+      Conv_Asp := Conv;\n+      EN_Asp   := EN;\n+      Expo_Asp := Expo;\n+      Imp_Asp  := Imp;\n+      LN_Asp   := LN;\n+   end Get_Interfacing_Aspects;\n+\n    -------------------------------------\n    -- Inherit_Aspects_At_Freeze_Point --\n    -------------------------------------"}]}