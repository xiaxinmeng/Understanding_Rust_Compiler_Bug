{"sha": "ea6136a283596a40c177cf79e01c204cc2fc555e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE2MTM2YTI4MzU5NmE0MGMxNzdjZjc5ZTAxYzIwNGNjMmZjNTU1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-16T03:11:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-16T03:11:28Z"}, "message": "bbpart: Use a VEC for crossing_edges.\n\nFrom-SVN: r176349", "tree": {"sha": "93511d20a3ae241fcf7429cad83efcd8717d4a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93511d20a3ae241fcf7429cad83efcd8717d4a16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea6136a283596a40c177cf79e01c204cc2fc555e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6136a283596a40c177cf79e01c204cc2fc555e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea6136a283596a40c177cf79e01c204cc2fc555e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6136a283596a40c177cf79e01c204cc2fc555e/comments", "author": null, "committer": null, "parents": [{"sha": "b6e1009aed072d9a6905931eef52b5c0ded20ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e1009aed072d9a6905931eef52b5c0ded20ddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e1009aed072d9a6905931eef52b5c0ded20ddd"}], "stats": {"total": 282, "additions": 122, "deletions": 160}, "files": [{"sha": "46997c418b4569e00af9a24f700f896efd9f9d9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea6136a283596a40c177cf79e01c204cc2fc555e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea6136a283596a40c177cf79e01c204cc2fc555e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea6136a283596a40c177cf79e01c204cc2fc555e", "patch": "@@ -1,3 +1,15 @@\n+2011-07-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* bb-reorder.c (find_rarely_executed_basic_blocks_and_crossing_edges):\n+\tReplace all three arguments by returning a VEC of edges.\n+\t(add_labels_and_missing_jumps): Accept a VEC of edges, not bare\n+\tpointers and counts.\n+\t(fix_edges_for_rarely_executed_code): Merge ...\n+\t(rest_of_handle_partition_blocks): ... into...\n+\t(partition_hot_cold_basic_blocks): ... here.  Return todo items if\n+\tany work was performed.\n+\t(pass_partition_blocks): Clear todo_flags_finish.\n+\n 2011-07-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n \t    Jonathan Wakely  <jwakely.gcc@gmail.com>"}, {"sha": "81369eaf38e6fcdff421df93a2261c1cd8c0875a", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 110, "deletions": 160, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea6136a283596a40c177cf79e01c204cc2fc555e/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea6136a283596a40c177cf79e01c204cc2fc555e/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ea6136a283596a40c177cf79e01c204cc2fc555e", "patch": "@@ -182,15 +182,6 @@ static void connect_traces (int, struct trace *);\n static bool copy_bb_p (const_basic_block, int);\n static int get_uncond_jump_length (void);\n static bool push_to_next_round_p (const_basic_block, int, int, int, gcov_type);\n-static void find_rarely_executed_basic_blocks_and_crossing_edges (edge **,\n-\t\t\t\t\t\t\t\t  int *,\n-\t\t\t\t\t\t\t\t  int *);\n-static void add_labels_and_missing_jumps (edge *, int);\n-static void add_reg_crossing_jump_notes (void);\n-static void fix_up_fall_thru_edges (void);\n-static void fix_edges_for_rarely_executed_code (edge *, int);\n-static void fix_crossing_conditional_branches (void);\n-static void fix_crossing_unconditional_branches (void);\n \f\n /* Check to see if bb should be pushed into the next round of trace\n    collections or not.  Reasons for pushing the block forward are 1).\n@@ -1219,16 +1210,14 @@ get_uncond_jump_length (void)\n \n /* Find the basic blocks that are rarely executed and need to be moved to\n    a separate section of the .o file (to cut down on paging and improve\n-   cache locality).  */\n+   cache locality).  Return a vector of all edges that cross.  */\n \n-static void\n-find_rarely_executed_basic_blocks_and_crossing_edges (edge **crossing_edges,\n-\t\t\t\t\t\t      int *n_crossing_edges,\n-\t\t\t\t\t\t      int *max_idx)\n+static VEC(edge, heap) *\n+find_rarely_executed_basic_blocks_and_crossing_edges (void)\n {\n+  VEC(edge, heap) *crossing_edges = NULL;\n   basic_block bb;\n   edge e;\n-  int i;\n   edge_iterator ei;\n \n   /* Mark which partition (hot/cold) each basic block belongs in.  */\n@@ -1243,7 +1232,6 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge **crossing_edges,\n \n   /* Mark every edge that crosses between sections.  */\n \n-  i = 0;\n   FOR_EACH_BB (bb)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -1252,77 +1240,62 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge **crossing_edges,\n \t  && BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n \t{\n \t  e->flags |= EDGE_CROSSING;\n-\t  if (i == *max_idx)\n-\t    {\n-\t      *max_idx *= 2;\n-\t      *crossing_edges = XRESIZEVEC (edge, *crossing_edges, *max_idx);\n-\t    }\n-\t  (*crossing_edges)[i++] = e;\n+\t  VEC_safe_push (edge, heap, crossing_edges, e);\n \t}\n       else\n \te->flags &= ~EDGE_CROSSING;\n     }\n-  *n_crossing_edges = i;\n+\n+  return crossing_edges;\n }\n \n /* If any destination of a crossing edge does not have a label, add label;\n-   Convert any fall-through crossing edges (for blocks that do not contain\n-   a jump) to unconditional jumps.  */\n+   Convert any easy fall-through crossing edges to unconditional jumps.  */\n \n static void\n-add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n+add_labels_and_missing_jumps (VEC(edge, heap) *crossing_edges)\n {\n-  int i;\n-  basic_block src;\n-  basic_block dest;\n-  rtx label;\n-  rtx barrier;\n-  rtx new_jump;\n+  size_t i;\n+  edge e;\n \n-  for (i=0; i < n_crossing_edges; i++)\n+  FOR_EACH_VEC_ELT (edge, crossing_edges, i, e)\n     {\n-      if (crossing_edges[i])\n-\t{\n-\t  src = crossing_edges[i]->src;\n-\t  dest = crossing_edges[i]->dest;\n+      basic_block src = e->src;\n+      basic_block dest = e->dest;\n+      rtx label, barrier, new_jump;\n \n-\t  /* Make sure dest has a label.  */\n+      if (dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n \n-\t  if (dest && (dest != EXIT_BLOCK_PTR))\n-\t    {\n-\t      label = block_label (dest);\n+      /* Make sure dest has a label.  */\n+      label = block_label (dest);\n \n-\t      /* Make sure source block ends with a jump.  If the\n-\t         source block does not end with a jump it might end\n-\t         with a call_insn;  this case will be handled in\n-\t         fix_up_fall_thru_edges function.  */\n+      /* Nothing to do for non-fallthru edges.  */\n+      if (src == ENTRY_BLOCK_PTR)\n+\tcontinue;\n+      if ((e->flags & EDGE_FALLTHRU) == 0)\n+\tcontinue;\n \n-\t      if (src && (src != ENTRY_BLOCK_PTR))\n-\t\t{\n-\t\t  if (!JUMP_P (BB_END (src))\n-\t\t      && !block_ends_with_call_p (src)\n-\t\t      && !can_throw_internal (BB_END (src)))\n-\t\t    /* bb just falls through.  */\n-\t\t    {\n-\t\t      /* make sure there's only one successor */\n-\t\t      gcc_assert (single_succ_p (src));\n-\n-\t\t      /* Find label in dest block.  */\n-\t\t      label = block_label (dest);\n-\n-\t\t      new_jump = emit_jump_insn_after (gen_jump (label),\n-\t\t\t\t\t\t       BB_END (src));\n-\t\t      barrier = emit_barrier_after (new_jump);\n-\t\t      JUMP_LABEL (new_jump) = label;\n-\t\t      LABEL_NUSES (label) += 1;\n-\t\t      src->il.rtl->footer = unlink_insn_chain (barrier, barrier);\n-\t\t      /* Mark edge as non-fallthru.  */\n-\t\t      crossing_edges[i]->flags &= ~EDGE_FALLTHRU;\n-\t\t    } /* end: 'if (!JUMP_P ... '  */\n-\t\t} /* end: 'if (src && src !=...'  */\n-\t    } /* end: 'if (dest && dest !=...'  */\n-\t} /* end: 'if (crossing_edges[i]...'  */\n-    } /* end for loop  */\n+      /* If the block does not end with a control flow insn, then we\n+\t can trivially add a jump to the end to fixup the crossing.\n+\t Otherwise the jump will have to go in a new bb, which will\n+\t be handled by fix_up_fall_thru_edges function.  */\n+      if (control_flow_insn_p (BB_END (src)))\n+\tcontinue;\n+\n+      /* Make sure there's only one successor.  */\n+      gcc_assert (single_succ_p (src));\n+\n+      new_jump = emit_jump_insn_after (gen_jump (label), BB_END (src));\n+      BB_END (src) = new_jump;\n+      barrier = emit_barrier_after (new_jump);\n+      JUMP_LABEL (new_jump) = label;\n+      LABEL_NUSES (label) += 1;\n+      src->il.rtl->footer = unlink_insn_chain (barrier, barrier);\n+\n+      /* Mark edge as non-fallthru.  */\n+      e->flags &= ~EDGE_FALLTHRU;\n+    }\n }\n \n /* Find any bb's where the fall-through edge is a crossing edge (note that\n@@ -1796,71 +1769,6 @@ add_reg_crossing_jump_notes (void)\n \tadd_reg_note (BB_END (e->src), REG_CROSSING_JUMP, NULL_RTX);\n }\n \n-/* Hot and cold basic blocks are partitioned and put in separate\n-   sections of the .o file, to reduce paging and improve cache\n-   performance (hopefully).  This can result in bits of code from the\n-   same function being widely separated in the .o file.  However this\n-   is not obvious to the current bb structure.  Therefore we must take\n-   care to ensure that: 1). There are no fall_thru edges that cross\n-   between sections; 2). For those architectures which have \"short\"\n-   conditional branches, all conditional branches that attempt to\n-   cross between sections are converted to unconditional branches;\n-   and, 3). For those architectures which have \"short\" unconditional\n-   branches, all unconditional branches that attempt to cross between\n-   sections are converted to indirect jumps.\n-\n-   The code for fixing up fall_thru edges that cross between hot and\n-   cold basic blocks does so by creating new basic blocks containing\n-   unconditional branches to the appropriate label in the \"other\"\n-   section.  The new basic block is then put in the same (hot or cold)\n-   section as the original conditional branch, and the fall_thru edge\n-   is modified to fall into the new basic block instead.  By adding\n-   this level of indirection we end up with only unconditional branches\n-   crossing between hot and cold sections.\n-\n-   Conditional branches are dealt with by adding a level of indirection.\n-   A new basic block is added in the same (hot/cold) section as the\n-   conditional branch, and the conditional branch is retargeted to the\n-   new basic block.  The new basic block contains an unconditional branch\n-   to the original target of the conditional branch (in the other section).\n-\n-   Unconditional branches are dealt with by converting them into\n-   indirect jumps.  */\n-\n-static void\n-fix_edges_for_rarely_executed_code (edge *crossing_edges,\n-\t\t\t\t    int n_crossing_edges)\n-{\n-  /* Make sure the source of any crossing edge ends in a jump and the\n-     destination of any crossing edge has a label.  */\n-\n-  add_labels_and_missing_jumps (crossing_edges, n_crossing_edges);\n-\n-  /* Convert all crossing fall_thru edges to non-crossing fall\n-     thrus to unconditional jumps (that jump to the original fall\n-     thru dest).  */\n-\n-  fix_up_fall_thru_edges ();\n-\n-  /* If the architecture does not have conditional branches that can\n-     span all of memory, convert crossing conditional branches into\n-     crossing unconditional branches.  */\n-\n-  if (!HAS_LONG_COND_BRANCH)\n-    fix_crossing_conditional_branches ();\n-\n-  /* If the architecture does not have unconditional branches that\n-     can span all of memory, convert crossing unconditional branches\n-     into indirect jumps.  Since adding an indirect jump also adds\n-     a new register usage, update the register usage information as\n-     well.  */\n-\n-  if (!HAS_LONG_UNCOND_BRANCH)\n-    fix_crossing_unconditional_branches ();\n-\n-  add_reg_crossing_jump_notes ();\n-}\n-\n /* Verify, in the basic block chain, that there is at most one switch\n    between hot/cold partitions. This is modelled on\n    rtl_verify_flow_info_1, but it cannot go inside that function\n@@ -2178,28 +2086,79 @@ struct rtl_opt_pass pass_duplicate_computed_gotos =\n    if we could perform this optimization later in the compilation, but\n    unfortunately the fact that we may need to create indirect jumps\n    (through registers) requires that this optimization be performed\n-   before register allocation.  */\n+   before register allocation.\n \n-static void\n+   Hot and cold basic blocks are partitioned and put in separate\n+   sections of the .o file, to reduce paging and improve cache\n+   performance (hopefully).  This can result in bits of code from the\n+   same function being widely separated in the .o file.  However this\n+   is not obvious to the current bb structure.  Therefore we must take\n+   care to ensure that: 1). There are no fall_thru edges that cross\n+   between sections; 2). For those architectures which have \"short\"\n+   conditional branches, all conditional branches that attempt to\n+   cross between sections are converted to unconditional branches;\n+   and, 3). For those architectures which have \"short\" unconditional\n+   branches, all unconditional branches that attempt to cross between\n+   sections are converted to indirect jumps.\n+\n+   The code for fixing up fall_thru edges that cross between hot and\n+   cold basic blocks does so by creating new basic blocks containing\n+   unconditional branches to the appropriate label in the \"other\"\n+   section.  The new basic block is then put in the same (hot or cold)\n+   section as the original conditional branch, and the fall_thru edge\n+   is modified to fall into the new basic block instead.  By adding\n+   this level of indirection we end up with only unconditional branches\n+   crossing between hot and cold sections.\n+\n+   Conditional branches are dealt with by adding a level of indirection.\n+   A new basic block is added in the same (hot/cold) section as the\n+   conditional branch, and the conditional branch is retargeted to the\n+   new basic block.  The new basic block contains an unconditional branch\n+   to the original target of the conditional branch (in the other section).\n+\n+   Unconditional branches are dealt with by converting them into\n+   indirect jumps.  */\n+\n+static unsigned\n partition_hot_cold_basic_blocks (void)\n {\n-  edge *crossing_edges;\n-  int n_crossing_edges;\n-  int max_edges = 2 * last_basic_block;\n+  VEC(edge, heap) *crossing_edges;\n \n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n-    return;\n+    return 0;\n+\n+  crossing_edges = find_rarely_executed_basic_blocks_and_crossing_edges ();\n+  if (crossing_edges == NULL)\n+    return 0;\n+\n+  /* Make sure the source of any crossing edge ends in a jump and the\n+     destination of any crossing edge has a label.  */\n+  add_labels_and_missing_jumps (crossing_edges);\n+\n+  /* Convert all crossing fall_thru edges to non-crossing fall\n+     thrus to unconditional jumps (that jump to the original fall\n+     thru dest).  */\n+  fix_up_fall_thru_edges ();\n+\n+  /* If the architecture does not have conditional branches that can\n+     span all of memory, convert crossing conditional branches into\n+     crossing unconditional branches.  */\n+  if (!HAS_LONG_COND_BRANCH)\n+    fix_crossing_conditional_branches ();\n \n-  crossing_edges = XCNEWVEC (edge, max_edges);\n+  /* If the architecture does not have unconditional branches that\n+     can span all of memory, convert crossing unconditional branches\n+     into indirect jumps.  Since adding an indirect jump also adds\n+     a new register usage, update the register usage information as\n+     well.  */\n+  if (!HAS_LONG_UNCOND_BRANCH)\n+    fix_crossing_unconditional_branches ();\n \n-  find_rarely_executed_basic_blocks_and_crossing_edges (&crossing_edges,\n-\t\t\t\t\t\t\t&n_crossing_edges,\n-\t\t\t\t\t\t\t&max_edges);\n+  add_reg_crossing_jump_notes ();\n \n-  if (n_crossing_edges > 0)\n-    fix_edges_for_rarely_executed_code (crossing_edges, n_crossing_edges);\n+  VEC_free (edge, heap, crossing_edges);\n \n-  free (crossing_edges);\n+  return TODO_verify_flow | TODO_verify_rtl_sharing;\n }\n \f\n static bool\n@@ -2271,27 +2230,18 @@ gate_handle_partition_blocks (void)\n      sections of the .o file does not work well with linkonce or with\n      user defined section attributes.  Don't call it if either case\n      arises.  */\n-\n   return (flag_reorder_blocks_and_partition\n \t  && !DECL_ONE_ONLY (current_function_decl)\n \t  && !user_defined_section_attribute);\n }\n \n-/* Partition hot and cold basic blocks.  */\n-static unsigned int\n-rest_of_handle_partition_blocks (void)\n-{\n-  partition_hot_cold_basic_blocks ();\n-  return 0;\n-}\n-\n struct rtl_opt_pass pass_partition_blocks =\n {\n  {\n   RTL_PASS,\n   \"bbpart\",                             /* name */\n   gate_handle_partition_blocks,         /* gate */\n-  rest_of_handle_partition_blocks,      /* execute */\n+  partition_hot_cold_basic_blocks,      /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -2300,6 +2250,6 @@ struct rtl_opt_pass pass_partition_blocks =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing               /* todo_flags_finish */\n+  0\t\t\t\t\t/* todo_flags_finish */\n  }\n };"}]}