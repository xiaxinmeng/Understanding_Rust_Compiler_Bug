{"sha": "6354dc9bf8355ab4fd2c90a2cbdac03a80e438de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1NGRjOWJmODM1NWFiNGZkMmM5MGEyY2JkYWMwM2E4MGU0MzhkZQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "2000-03-29T19:15:36Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-03-29T19:15:36Z"}, "message": "Minor formatting changes.\n\nAdd definitions of ASM_SPEC and SUBTARGET_EXTRA_ASM_SPEC to arm.h if not\nalready defined.\n\nFrom-SVN: r32810", "tree": {"sha": "73fe401367820d3b65298266434da30bffcc22db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73fe401367820d3b65298266434da30bffcc22db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de/comments", "author": null, "committer": null, "parents": [{"sha": "0194e877a39d909dfcc6db2057be773c6a01f7d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0194e877a39d909dfcc6db2057be773c6a01f7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0194e877a39d909dfcc6db2057be773c6a01f7d2"}], "stats": {"total": 286, "additions": 145, "deletions": 141}, "files": [{"sha": "53c85b149062f0db52318c287b0a2cb4114a2ccd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6354dc9bf8355ab4fd2c90a2cbdac03a80e438de", "patch": "@@ -1,3 +1,10 @@\n+2000-03-29  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.c: Minor formatting changes/\n+\t* config/arm/arm.h (SUBTARGET_EXTRA_ASM_SPEC): Define if not\n+\talready defined.\n+\t(ASM_SPEC): Define if not already defined.\n+\n 2000-03-29  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cppfiles.c (cpp_read_file): Don't pass zero-length string to"}, {"sha": "6fe5707e565c8b3c8fc9e7833f5ab5c57d57353f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 120, "deletions": 139, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6354dc9bf8355ab4fd2c90a2cbdac03a80e438de", "patch": "@@ -64,7 +64,7 @@ static int eliminate_lr2ip \t\tPARAMS ((rtx *));\n static char * shift_op \t\t\tPARAMS ((rtx, HOST_WIDE_INT *));\n static int pattern_really_clobbers_lr \tPARAMS ((rtx));\n static int function_really_clobbers_lr \tPARAMS ((rtx));\n-static rtx emit_multi_reg_push\t \tPARAMS ((int));\n+static rtx emit_multi_reg_push\t\tPARAMS ((int));\n static rtx emit_sfm \t\t\tPARAMS ((int, int));\n static enum arm_cond_code get_arm_condition_code PARAMS ((rtx));\n static int const_ok_for_op \t\tPARAMS ((HOST_WIDE_INT, enum rtx_code));\n@@ -76,23 +76,23 @@ static int max_insns_skipped = 5;\n \n extern FILE * asm_out_file;\n \n-/* True if we are currently building a constant table. */\n+/* True if we are currently building a constant table.  */\n int making_const_table;\n \n /* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation. */\n+   stored from the compare operation.  */\n rtx arm_compare_op0, arm_compare_op1;\n \n-/* What type of floating point are we tuning for? */\n+/* What type of floating point are we tuning for?  */\n enum floating_point_type arm_fpu;\n \n-/* What type of floating point instructions are available? */\n+/* What type of floating point instructions are available?  */\n enum floating_point_type arm_fpu_arch;\n \n-/* What program mode is the cpu running in? 26-bit mode or 32-bit mode */\n+/* What program mode is the cpu running in? 26-bit mode or 32-bit mode.  */\n enum prog_mode_type arm_prgmode;\n \n-/* Set by the -mfp=... option */\n+/* Set by the -mfp=... option.  */\n const char * target_fp_name = NULL;\n \n /* Used to parse -mstructure_size_boundary command line option.  */\n@@ -125,10 +125,10 @@ static int tune_flags = 0;\n /* Nonzero if this is an \"M\" variant of the processor.  */\n int arm_fast_multiply = 0;\n \n-/* Nonzero if this chip supports the ARM Architecture 4 extensions */\n+/* Nonzero if this chip supports the ARM Architecture 4 extensions.  */\n int arm_arch4 = 0;\n \n-/* Nonzero if this chip supports the ARM Architecture 5 extensions */\n+/* Nonzero if this chip supports the ARM Architecture 5 extensions.  */\n int arm_arch5 = 0;\n \n /* Nonzero if this chip can benefit from load scheduling.  */\n@@ -153,11 +153,11 @@ const char * arm_pic_register_string = NULL;\n int arm_pic_register = 9;\n \n /* Set to one if we think that lr is only saved because of subroutine calls,\n-   but all of these can be `put after' return insns */\n+   but all of these can be `put after' return insns.  */\n int lr_save_eliminated;\n \n /* Set to 1 when a return insn is output, this means that the epilogue\n-   is not needed. */\n+   is not needed.  */\n static int return_used_this_function;\n \n /* Set to 1 after arm_reorg has started.  Reset to start at the start of\n@@ -184,7 +184,7 @@ static enum arm_cond_code get_arm_condition_code ();\n \n #define streq(string1, string2) (strcmp (string1, string2) == 0)\n \f\n-/* Initialization code */\n+/* Initialization code.  */\n \n struct processors\n {\n@@ -308,7 +308,7 @@ arm_override_options ()\n \t\t    /* If we have been given an architecture and a processor\n \t\t       make sure that they are compatible.  We only generate\n \t\t       a warning though, and we prefer the CPU over the\n-\t\t       architecture. */\n+\t\t       architecture.  */\n \t\t    if (insn_flags != 0 && (insn_flags ^ sel->flags))\n \t\t      warning (\"switch -mcpu=%s conflicts with -march= switch\",\n \t\t\t       ptr->string);\n@@ -604,8 +604,7 @@ arm_add_gc_roots ()\n }\n \n \f\n-/* Return 1 if it is possible to return using a single instruction */\n-\n+/* Return 1 if it is possible to return using a single instruction.  */\n int\n use_return_insn (iscond)\n      int iscond;\n@@ -636,7 +635,7 @@ use_return_insn (iscond)\n     }\n       \n   /* Can't be done if any of the FPU regs are pushed, since this also\n-     requires an insn */\n+     requires an insn.  */\n   for (regno = 16; regno < 24; regno++)\n     if (regs_ever_live[regno] && ! call_used_regs[regno])\n       return 0;\n@@ -680,7 +679,7 @@ const_ok_for_arm (i)\n   return FALSE;\n }\n \n-/* Return true if I is a valid constant for the operation CODE. */\n+/* Return true if I is a valid constant for the operation CODE.  */\n static int\n const_ok_for_op (i, code)\n      HOST_WIDE_INT i;\n@@ -895,7 +894,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n       abort ();\n     }\n \n-  /* If we can do it in one insn get out quickly */\n+  /* If we can do it in one insn get out quickly.  */\n   if (const_ok_for_arm (val)\n       || (can_negate_initial && const_ok_for_arm (-val))\n       || (can_invert && const_ok_for_arm (~val)))\n@@ -908,10 +907,8 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n       return 1;\n     }\n \n-\n   /* Calculate a few attributes that may be useful for specific\n-     optimizations. */\n-\n+     optimizations.  */\n   for (i = 31; i >= 0; i--)\n     {\n       if ((remainder & (1 << i)) == 0)\n@@ -993,7 +990,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t  temp1 = remainder & 0xffff0000UL;\n \t  temp2 = remainder & 0x0000ffff;\n \n-\t  /* Overlaps outside this range are best done using other methods. */\n+\t  /* Overlaps outside this range are best done using other methods.  */\n \t  for (i = 9; i < 24; i++)\n \t    {\n \t      if ((((temp2 | (temp2 << i)) & 0xffffffffUL) == remainder)\n@@ -1016,7 +1013,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t\t}\n \t    }\n \n-\t  /* Don't duplicate cases already considered. */\n+\t  /* Don't duplicate cases already considered.  */\n \t  for (i = 17; i < 24; i++)\n \t    {\n \t      if (((temp1 | (temp1 >> i)) == remainder)\n@@ -1227,7 +1224,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n      We start by looking for the largest block of zeros that are aligned on\n      a 2-bit boundary, we then fill up the temps, wrapping around to the\n      top of the word when we drop off the bottom.\n-     In the worst case this code should produce no more than four insns. */\n+     In the worst case this code should produce no more than four insns.  */\n   {\n     int best_start = 0;\n     int best_consecutive_zeros = 0;\n@@ -1254,7 +1251,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \n     /* Now start emitting the insns, starting with the one with the highest\n        bit set: we do this so that the smallest number will be emitted last;\n-       this is more likely to be combinable with addressing insns. */\n+       this is more likely to be combinable with addressing insns.  */\n     i = best_start;\n     do\n       {\n@@ -1466,8 +1463,7 @@ arm_return_in_memory (type)\n       return 0;\n     }\n   \n-  /* XXX Not sure what should be done for\n-     other aggregates so put them in memory.  */\n+  /* Put other aggregates in memory.  */\n   return 1;\n }\n \n@@ -1648,8 +1644,8 @@ arm_encode_call_attribute (decl, flag)\n   char flag;\n {\n   const char * str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n-  int    len = strlen (str);\n-  char * newstr;\n+  int          len = strlen (str);\n+  char *       newstr;\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     return;\n@@ -1809,8 +1805,7 @@ legitimize_pic_address (orig, mode, reg)\n \n #ifdef AOF_ASSEMBLER\n       /* The AOF assembler can generate relocations for these directly, and\n-\t understands that the PIC register has to be added into the offset.\n-\t */\n+\t understands that the PIC register has to be added into the offset.  */\n       insn = emit_insn (gen_pic_load_addr_based (reg, orig));\n #else\n       if (subregs)\n@@ -2103,7 +2098,7 @@ arm_rtx_costs (x, code)\n \n     case MULT:\n       /* There is no point basing this on the tuning, since it is always the\n-\t fast variant if it exists at all */\n+\t fast variant if it exists at all.  */\n       if (arm_fast_multiply && mode == DImode\n \t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n \t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n@@ -2120,7 +2115,8 @@ arm_rtx_costs (x, code)\n \t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffffUL);\n \t  int add_cost = const_ok_for_arm (i) ? 4 : 8;\n \t  int j;\n-\t  /* Tune as appropriate */ \n+\t  \n+\t  /* Tune as appropriate.  */ \n \t  int booth_unit_size = ((tune_flags & FL_FAST_MULT) ? 8 : 2);\n \t  \n \t  for (j = 0; i && j < 32; j += booth_unit_size)\n@@ -2206,7 +2202,7 @@ arm_adjust_cost (insn, link, dep, cost)\n {\n   rtx i_pat, d_pat;\n \n-  /* XXX This is not strictly true for the FPA. */\n+  /* XXX This is not strictly true for the FPA.  */\n   if (REG_NOTE_KIND(link) == REG_DEP_ANTI\n       || REG_NOTE_KIND(link) == REG_DEP_OUTPUT)\n     return 0;\n@@ -2219,7 +2215,7 @@ arm_adjust_cost (insn, link, dep, cost)\n       /* This is a load after a store, there is no conflict if the load reads\n \t from a cached area.  Assume that loads from the stack, and from the\n \t constant pool are cached, and that others will miss.  This is a \n-\t hack. */\n+\t hack.  */\n       \n       if (CONSTANT_POOL_ADDRESS_P (XEXP (SET_SRC (i_pat), 0))\n \t  || reg_mentioned_p (stack_pointer_rtx, XEXP (SET_SRC (i_pat), 0))\n@@ -2232,7 +2228,7 @@ arm_adjust_cost (insn, link, dep, cost)\n   return cost;\n }\n \n-/* This code has been fixed for cross compilation. */\n+/* This code has been fixed for cross compilation.  */\n \n static int fpa_consts_inited = 0;\n \n@@ -2259,7 +2255,7 @@ init_fpa_table ()\n   fpa_consts_inited = 1;\n }\n \n-/* Return TRUE if rtx X is a valid immediate FPU constant. */\n+/* Return TRUE if rtx X is a valid immediate FPU constant.  */\n \n int\n const_double_rtx_ok_for_fpu (x)\n@@ -2282,7 +2278,7 @@ const_double_rtx_ok_for_fpu (x)\n   return 0;\n }\n \n-/* Return TRUE if rtx X is a valid immediate FPU constant. */\n+/* Return TRUE if rtx X is a valid immediate FPU constant.  */\n \n int\n neg_const_double_rtx_ok_for_fpu (x)\n@@ -2384,20 +2380,20 @@ bad_signed_byte_operand (op, mode)\n \n   op = XEXP (op, 0);\n \n-  /* A sum of anything more complex than reg + reg or reg + const is bad */\n+  /* A sum of anything more complex than reg + reg or reg + const is bad.  */\n   if ((GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n       && (! s_register_operand (XEXP (op, 0), VOIDmode)\n \t  || (! s_register_operand (XEXP (op, 1), VOIDmode)\n \t      && GET_CODE (XEXP (op, 1)) != CONST_INT)))\n     return 1;\n \n-  /* Big constants are also bad */\n+  /* Big constants are also bad.  */\n   if (GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT\n       && (INTVAL (XEXP (op, 1)) > 0xff\n \t  || -INTVAL (XEXP (op, 1)) > 0xff))\n     return 1;\n \n-  /* Everything else is good, or can will automatically be made so. */\n+  /* Everything else is good, or can will automatically be made so.  */\n   return 0;\n }\n \n@@ -2634,7 +2630,7 @@ soft_df_operand (op, mode)\n     }\n }\n \n-/* Return TRUE for valid index operands. */\n+/* Return TRUE for valid index operands.  */\n \n int\n index_operand (op, mode)\n@@ -2648,7 +2644,7 @@ index_operand (op, mode)\n \n /* Return TRUE for valid shifts by a constant. This also accepts any\n    power of two on the (somewhat overly relaxed) assumption that the\n-   shift operator in this case was a mult. */\n+   shift operator in this case was a mult.  */\n \n int\n const_shift_operand (op, mode)\n@@ -2696,7 +2692,7 @@ logical_binary_operator (x, mode)\n     }\n }\n \n-/* Return TRUE for shift operators. */\n+/* Return TRUE for shift operators.  */\n \n int\n shift_operator (x, mode)\n@@ -2717,15 +2713,16 @@ shift_operator (x, mode)\n     }\n }\n \n-int equality_operator (x, mode)\n+/* Return TRUE if x is EQ or NE.  */\n+int\n+equality_operator (x, mode)\n      rtx x;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return GET_CODE (x) == EQ || GET_CODE (x) == NE;\n }\n \n-/* Return TRUE for SMIN SMAX UMIN UMAX operators. */\n-\n+/* Return TRUE for SMIN SMAX UMIN UMAX operators.  */\n int\n minmax_operator (x, mode)\n      rtx x;\n@@ -2739,11 +2736,8 @@ minmax_operator (x, mode)\n   return code == SMIN || code == SMAX || code == UMIN || code == UMAX;\n }\n \n-/* return TRUE if x is EQ or NE */\n-\n /* Return TRUE if this is the condition code register, if we aren't given\n-   a mode, accept any class CCmode register */\n-\n+   a mode, accept any class CCmode register.  */\n int\n cc_register (x, mode)\n      rtx x;\n@@ -2765,7 +2759,6 @@ cc_register (x, mode)\n /* Return TRUE if this is the condition code register, if we aren't given\n    a mode, accept any class CCmode register which indicates a dominance\n    expression.  */\n-\n int\n dominant_cc_register (x, mode)\n      rtx x;\n@@ -2867,8 +2860,7 @@ minmax_code (x)\n   abort ();\n }\n \n-/* Return 1 if memory locations are adjacent */\n-\n+/* Return 1 if memory locations are adjacent.  */\n int\n adjacent_mem_locations (a, b)\n      rtx a, b;\n@@ -2903,7 +2895,7 @@ adjacent_mem_locations (a, b)\n }\n \n /* Return 1 if OP is a load multiple operation.  It is known to be\n-   parallel and the first section will be tested. */\n+   parallel and the first section will be tested.  */\n \n int\n load_multiple_operation (op, mode)\n@@ -2920,13 +2912,13 @@ load_multiple_operation (op, mode)\n       || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n     return 0;\n \n-  /* Check to see if this might be a write-back */\n+  /* Check to see if this might be a write-back.  */\n   if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n     {\n       i++;\n       base = 1;\n \n-      /* Now check it more carefully */\n+      /* Now check it more carefully.  */\n       if (GET_CODE (SET_DEST (elt)) != REG\n           || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n           || REGNO (XEXP (SET_SRC (elt), 0)) != REGNO (SET_DEST (elt))\n@@ -2958,7 +2950,7 @@ load_multiple_operation (op, mode)\n       if (GET_CODE (elt) != SET\n           || GET_CODE (SET_DEST (elt)) != REG\n           || GET_MODE (SET_DEST (elt)) != SImode\n-          || REGNO (SET_DEST (elt)) != dest_regno + i - base\n+          || REGNO (SET_DEST (elt)) != (unsigned int)(dest_regno + i - base)\n           || GET_CODE (SET_SRC (elt)) != MEM\n           || GET_MODE (SET_SRC (elt)) != SImode\n           || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n@@ -2972,8 +2964,7 @@ load_multiple_operation (op, mode)\n }\n \n /* Return 1 if OP is a store multiple operation.  It is known to be\n-   parallel and the first section will be tested. */\n-\n+   parallel and the first section will be tested.  */\n int\n store_multiple_operation (op, mode)\n      rtx op;\n@@ -2989,13 +2980,13 @@ store_multiple_operation (op, mode)\n       || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n     return 0;\n \n-  /* Check to see if this might be a write-back */\n+  /* Check to see if this might be a write-back.  */\n   if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n     {\n       i++;\n       base = 1;\n \n-      /* Now check it more carefully */\n+      /* Now check it more carefully.  */\n       if (GET_CODE (SET_DEST (elt)) != REG\n           || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n           || REGNO (XEXP (SET_SRC (elt), 0)) != REGNO (SET_DEST (elt))\n@@ -3027,7 +3018,7 @@ store_multiple_operation (op, mode)\n       if (GET_CODE (elt) != SET\n           || GET_CODE (SET_SRC (elt)) != REG\n           || GET_MODE (SET_SRC (elt)) != SImode\n-          || REGNO (SET_SRC (elt)) != src_regno + i - base\n+          || REGNO (SET_SRC (elt)) != (unsigned int)(src_regno + i - base)\n           || GET_CODE (SET_DEST (elt)) != MEM\n           || GET_MODE (SET_DEST (elt)) != SImode\n           || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n@@ -3103,7 +3094,7 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n \t    }\n \t  else \n \t    {\n-\t      if (base_reg != REGNO (reg))\n+\t      if (base_reg != (int) REGNO (reg))\n \t\t/* Not addressed from the same base register.  */\n \t\treturn 0;\n \n@@ -3338,7 +3329,7 @@ store_multiple_sequence (operands, nops, regs, base, load_offset)\n \t    }\n \t  else \n \t    {\n-\t      if (base_reg != REGNO (reg))\n+\t      if (base_reg != (int) REGNO (reg))\n \t\t/* Not addressed from the same base register.  */\n \t\treturn 0;\n \n@@ -3513,8 +3504,7 @@ arm_naked_function_p (func)\n   return a != NULL_TREE;\n }\n \f\n-/* Routines for use in generating RTL */\n-\n+/* Routines for use in generating RTL.  */\n rtx\n arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n \t\t       in_struct_p, scalar_p)\n@@ -3729,7 +3719,7 @@ arm_gen_movstrqi (operands)\n       if (part_bytes_reg == NULL)\n \tabort ();\n \n-      /* The bytes we want are in the top end of the word */\n+      /* The bytes we want are in the top end of the word.  */\n       emit_insn (gen_lshrsi3 (tmp, part_bytes_reg,\n \t\t\t      GEN_INT (8 * (4 - last_bytes))));\n       part_bytes_reg = tmp;\n@@ -4040,7 +4030,7 @@ arm_reload_in_hi (operands)\n \t  base = find_replacement (&XEXP (ref, 0));\n \t}\n       else\n-\t/* The slot is out of range, or was dressed up in a SUBREG */\n+\t/* The slot is out of range, or was dressed up in a SUBREG.  */\n \tbase = reg_equiv_address[REGNO (ref)];\n     }\n   else\n@@ -4057,13 +4047,13 @@ arm_reload_in_hi (operands)\n     }\n   else if (GET_CODE (base) == PLUS)\n     {\n-      /* The addend must be CONST_INT, or we would have dealt with it above */\n+      /* The addend must be CONST_INT, or we would have dealt with it above.  */\n       HOST_WIDE_INT hi, lo;\n \n       offset += INTVAL (XEXP (base, 1));\n       base = XEXP (base, 0);\n \n-      /* Rework the address into a legal sequence of insns */\n+      /* Rework the address into a legal sequence of insns.  */\n       /* Valid range for lo is -4095 -> 4095 */\n       lo = (offset >= 0\n \t    ? (offset & 0xfff)\n@@ -4087,7 +4077,7 @@ arm_reload_in_hi (operands)\n \t  rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n \n \t  /* Get the base address; addsi3 knows how to handle constants\n-\t     that require more than one insn */\n+\t     that require more than one insn.  */\n \t  emit_insn (gen_addsi3 (base_plus, base, GEN_INT (hi)));\n \t  base = base_plus;\n \t  offset = lo;\n@@ -4158,7 +4148,7 @@ arm_reload_out_hi (operands)\n \t  base = find_replacement (&XEXP (ref, 0));\n \t}\n       else\n-\t/* The slot is out of range, or was dressed up in a SUBREG */\n+\t/* The slot is out of range, or was dressed up in a SUBREG.  */\n \tbase = reg_equiv_address[REGNO (ref)];\n     }\n   else\n@@ -4203,13 +4193,13 @@ arm_reload_out_hi (operands)\n     }\n   else if (GET_CODE (base) == PLUS)\n     {\n-      /* The addend must be CONST_INT, or we would have dealt with it above */\n+      /* The addend must be CONST_INT, or we would have dealt with it above.  */\n       HOST_WIDE_INT hi, lo;\n \n       offset += INTVAL (XEXP (base, 1));\n       base = XEXP (base, 0);\n \n-      /* Rework the address into a legal sequence of insns */\n+      /* Rework the address into a legal sequence of insns.  */\n       /* Valid range for lo is -4095 -> 4095 */\n       lo = (offset >= 0\n \t    ? (offset & 0xfff)\n@@ -4259,7 +4249,7 @@ arm_reload_out_hi (operands)\n \t    }\n \n \t  /* Get the base address; addsi3 knows how to handle constants\n-\t     that require more than one insn */\n+\t     that require more than one insn.  */\n \t  emit_insn (gen_addsi3 (base_plus, base, GEN_INT (hi)));\n \t  base = base_plus;\n \t  offset = lo;\n@@ -4342,19 +4332,17 @@ arm_reload_out_hi (operands)\n    been inserted, the insns are then modified to reference the\n    relevant entry in the pool.\n \n-   Possible enhancements to the alogorithm (not implemented) are:\n+   Possible enhancements to the algorithm (not implemented) are:\n \n-   1) ARM instructions (but not thumb) can use negative offsets, so we\n+   1) ARM instructions (but not Thumb) can use negative offsets, so we\n    could reference back to a previous pool rather than forwards to a\n    new one.  For large functions this may reduce the number of pools\n    required.\n \n    2) For some processors and object formats, there may be benefit in\n    aligning the pools to the start of cache lines; this alignment\n    would need to be taken into account when calculating addressability\n-   of a pool.\n-\n- */\n+   of a pool.  */\n \n typedef struct\n {\n@@ -4366,7 +4354,6 @@ typedef struct\n /* The maximum number of constants that can fit into one pool, since\n    the pc relative range is 0...4092 bytes and constants are at least 4\n    bytes long.  */\n-\n #define MAX_MINIPOOL_SIZE (4092/4)\n static minipool_node minipool_vector[MAX_MINIPOOL_SIZE];\n static int minipool_size;\n@@ -4402,7 +4389,7 @@ add_minipool_constant (x, mode)\n \t}\n     }\n \n-  /* Need a new one */\n+  /* Need a new one.  */\n   minipool_vector[minipool_size].next_offset = GET_MODE_SIZE (mode);\n   offset = 0;\n   if (minipool_size == 0)\n@@ -4417,7 +4404,7 @@ add_minipool_constant (x, mode)\n   return offset;\n }\n \n-/* Output the literal table */\n+/* Output the literal table.  */\n static void\n dump_minipool (scan)\n      rtx scan;\n@@ -4471,7 +4458,7 @@ find_barrier (from, max_count)\n       if (GET_CODE (from) == BARRIER)\n \tfound_barrier = from;\n \n-      /* Count the length of this insn */\n+      /* Count the length of this insn.  */\n       if (GET_CODE (from) == JUMP_INSN\n \t  && JUMP_LABEL (from) != 0\n \t  && ((tmp = next_real_insn (JUMP_LABEL (from)))\n@@ -4587,7 +4574,7 @@ push_minipool_fix (insn, address, loc, mode, value)\n   if (fix->range == 0)\n     abort ();\n \n-  /* Add it to the chain of fixes */\n+  /* Add it to the chain of fixes.  */\n   fix->next = NULL;\n   if (minipool_fix_head != NULL)\n     minipool_fix_tail->next = fix;\n@@ -4604,10 +4591,10 @@ note_invalid_constants (insn, address)\n {\n   int opno;\n \n-  /* Extract the operands of the insn */\n+  /* Extract the operands of the insn.  */\n   extract_insn(insn);\n \n-  /* Find the alternative selected */\n+  /* Find the alternative selected.  */\n   if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n \n@@ -4616,7 +4603,7 @@ note_invalid_constants (insn, address)\n \n   for (opno = 0; opno < recog_data.n_operands; opno++)\n     {\n-      /* Things we need to fix can only occur in inputs */\n+      /* Things we need to fix can only occur in inputs.  */\n       if (recog_data.operand_type[opno] != OP_IN)\n \tcontinue;\n \n@@ -4788,7 +4775,7 @@ arm_reorg (first)\n \n /* If the rtx is the correct value then return the string of the number.\n    In this way we can ensure that valid double constants are generated even\n-   when cross compiling. */\n+   when cross compiling.  */\n char *\n fp_immediate_constant (x)\n      rtx x;\n@@ -4857,13 +4844,13 @@ print_multi_reg (stream, instr, reg, mask, hat)\n   fprintf (stream, \"}%s\\n\", hat ? \"^\" : \"\");\n }\n \n-/* Output a 'call' insn. */\n+/* Output a 'call' insn.  */\n \n char *\n output_call (operands)\n      rtx * operands;\n {\n-  /* Handle calls to lr using ip (which may be clobbered in subr anyway). */\n+  /* Handle calls to lr using ip (which may be clobbered in subr anyway).  */\n \n   if (REGNO (operands[0]) == LR_REGNUM)\n     {\n@@ -4901,7 +4888,7 @@ eliminate_lr2ip (x)\n         }\n       return 0;\n     default:\n-      /* Scan through the sub-elements and change any references there */\n+      /* Scan through the sub-elements and change any references there.  */\n       fmt = GET_RTX_FORMAT (code);\n       \n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -4915,15 +4902,14 @@ eliminate_lr2ip (x)\n     }\n }\n   \n-/* Output a 'call' insn that is a reference in memory. */\n+/* Output a 'call' insn that is a reference in memory.  */\n \n char *\n output_call_mem (operands)\n      rtx * operands;\n {\n-  operands[0] = copy_rtx (operands[0]); /* Be ultra careful */\n-  /* Handle calls using lr by using ip (which may be clobbered in subr anyway).\n-   */\n+  operands[0] = copy_rtx (operands[0]); /* Be ultra careful.  */\n+  /* Handle calls using lr by using ip (which may be clobbered in subr anyway).  */\n   if (eliminate_lr2ip (&operands[0]))\n     output_asm_insn (\"mov%?\\t%|ip, %|lr\", operands);\n \n@@ -4997,7 +4983,7 @@ char *\n output_mov_long_double_arm_from_arm (operands)\n      rtx * operands;\n {\n-  /* We have to be careful here because the two might overlap */\n+  /* We have to be careful here because the two might overlap.  */\n   int dest_start = REGNO (operands[0]);\n   int src_start = REGNO (operands[1]);\n   rtx ops[2];\n@@ -5092,7 +5078,7 @@ output_move_double (operands)\n \t  if (reg1 == IP_REGNUM)\n \t    abort ();\n \n-\t  /* Ensure the second source is not overwritten */\n+\t  /* Ensure the second source is not overwritten.  */\n \t  if (reg1 == reg0 + (WORDS_BIG_ENDIAN ? -1 : 1))\n \t    output_asm_insn (\"mov%?\\t%Q0, %Q1\\n\\tmov%?\\t%R0, %R1\", operands);\n \t  else\n@@ -5145,7 +5131,7 @@ output_move_double (operands)\n \t      operands[1] = GEN_INT (ARM_SIGN_EXTEND (INTVAL (operands[1])));\n \t    }\n #else\n-\t  /* Sign extend the intval into the high-order word */\n+\t  /* Sign extend the intval into the high-order word.  */\n \t  if (WORDS_BIG_ENDIAN)\n \t    {\n \t      otherops[1] = operands[1];\n@@ -5167,7 +5153,7 @@ output_move_double (operands)\n \t      break;\n \n   \t    case PRE_INC:\n-\t      abort (); /* Should never happen now */\n+\t      abort (); /* Should never happen now.  */\n \t      break;\n \n \t    case PRE_DEC:\n@@ -5179,7 +5165,7 @@ output_move_double (operands)\n \t      break;\n \n \t    case POST_DEC:\n-\t      abort (); /* Should never happen now */\n+\t      abort (); /* Should never happen now.  */\n \t      break;\n \n \t    case LABEL_REF:\n@@ -5242,7 +5228,7 @@ output_move_double (operands)\n \t    }\n \t}\n       else\n-\tabort ();  /* Constraints should prevent this */\n+\tabort ();  /* Constraints should prevent this.  */\n     }\n   else if (code0 == MEM && code1 == REG)\n     {\n@@ -5256,7 +5242,7 @@ output_move_double (operands)\n \t  break;\n \n         case PRE_INC:\n-\t  abort (); /* Should never happen now */\n+\t  abort (); /* Should never happen now.  */\n \t  break;\n \n         case PRE_DEC:\n@@ -5268,7 +5254,7 @@ output_move_double (operands)\n \t  break;\n \n         case POST_DEC:\n-\t  abort (); /* Should never happen now */\n+\t  abort (); /* Should never happen now.  */\n \t  break;\n \n \tcase PLUS:\n@@ -5331,13 +5317,13 @@ output_mov_immediate (operands)\n       return \"\";\n     }\n \n-  /* If all else fails, make it out of ORRs or BICs as appropriate. */\n+  /* If all else fails, make it out of ORRs or BICs as appropriate.  */\n \n   for (i=0; i < 32; i++)\n     if (n & 1 << i)\n       n_ones++;\n \n-  if (n_ones > 16)  /* Shorter to use MVN with BIC in this case. */\n+  if (n_ones > 16)  /* Shorter to use MVN with BIC in this case.  */\n     output_multi_immediate(operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1,\n \t\t\t   ~n);\n   else\n@@ -5393,14 +5379,14 @@ output_multi_immediate (operands, instr1, instr2, immed_op, n)\n   if (n == 0)\n     {\n       operands[immed_op] = const0_rtx;\n-      output_asm_insn (instr1, operands); /* Quick and easy output */\n+      output_asm_insn (instr1, operands); /* Quick and easy output.  */\n     }\n   else\n     {\n       int i;\n       char *instr = instr1;\n \n-      /* Note that n is never zero here (which would give no output) */\n+      /* Note that n is never zero here (which would give no output).  */\n       for (i = 0; i < 32; i += 2)\n \t{\n \t  if (n & (3 << i))\n@@ -5453,7 +5439,7 @@ arithmetic_instr (op, shift_first_arg)\n    for the operation code.  The returned result should not be overwritten.\n    OP is the rtx code of the shift.\n    On exit, *AMOUNTP will be -1 if the shift is by a register, or a constant\n-   shift. */\n+   shift.  */\n \n static char *\n shift_op (op, amountp)\n@@ -5528,8 +5514,7 @@ shift_op (op, amountp)\n }\n \n \n-/* Obtain the shift from the POWER of two. */\n-\n+/* Obtain the shift from the POWER of two.  */\n static HOST_WIDE_INT\n int_log2 (power)\n      HOST_WIDE_INT power;\n@@ -5635,8 +5620,7 @@ output_ascii_pseudo_op (stream, p, len)\n    NOTE: This code does not check for side-effect expressions in a SET_SRC:\n    such a check should not be needed because these only update an existing\n    value within a register; the register must still be set elsewhere within\n-   the function. */\n-\n+   the function.  */\n static int\n pattern_really_clobbers_lr (x)\n      rtx x;\n@@ -5715,7 +5699,7 @@ function_really_clobbers_lr (first)\n \n         case CALL_INSN:\n \t  /* Don't yet know how to handle those calls that are not to a \n-\t     SYMBOL_REF */\n+\t     SYMBOL_REF.  */\n \t  if (GET_CODE (PATTERN (insn)) != PARALLEL)\n \t    abort ();\n \n@@ -5734,7 +5718,7 @@ function_really_clobbers_lr (first)\n \t\treturn 1;\n \t      break;\n \n-\t    default:\t/* Don't recognize it, be safe */\n+\t    default:\t/* Don't recognize it, be safe.  */\n \t      return 1;\n \t    }\n \n@@ -5748,11 +5732,12 @@ function_really_clobbers_lr (first)\n \t  if ((next = next_nonnote_insn (insn)) == NULL)\n \t    return 1;\n \n-\t  /* No need to worry about lr if the call never returns */\n+\t  /* No need to worry about lr if the call never returns.  */\n \t  if (GET_CODE (next) == BARRIER)\n \t    break;\n \n-\t  if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == USE\n+\t  if (GET_CODE (next) == INSN\n+\t      && GET_CODE (PATTERN (next)) == USE\n \t      && (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n \t      && (REGNO (SET_DEST (XVECEXP (PATTERN (insn), 0, 0)))\n \t\t  == REGNO (XEXP (PATTERN (next), 0))))\n@@ -5769,7 +5754,7 @@ function_really_clobbers_lr (first)\n         }\n     }\n \n-  /* We have reached the end of the chain so lr was _not_ clobbered */\n+  /* We have reached the end of the chain so lr was _not_ clobbered.  */\n   return 0;\n }\n \n@@ -5908,12 +5893,12 @@ output_return_instruction (operand, really_return, reverse)\n    Such functions never return, and many memory cycles can be saved\n    by not storing register values that will never be needed again.\n    This optimization was added to speed up context switching in a\n-   kernel application. */\n-\n+   kernel application.  */\n int\n arm_volatile_func ()\n {\n-  return (optimize > 0 && current_function_nothrow\n+  return (optimize > 0\n+\t  && current_function_nothrow\n \t  && TREE_THIS_VOLATILE (current_function_decl));\n }\n \n@@ -5969,8 +5954,7 @@ arm_poke_function_name (stream, name)\n    no stack frame requirement and no live registers execpt for `lr'.  If we\n    can guarantee that by making all function calls into tail calls and that\n    lr is not clobbered in any other way, then there is no need to push lr\n-   onto the stack. */\n-   \n+   onto the stack.  */\n void\n output_func_prologue (f, frame_size)\n      FILE * f;\n@@ -5984,7 +5968,7 @@ output_func_prologue (f, frame_size)\n   int store_arg_regs = 0;\n \n   if (arm_ccfsm_state || arm_target_insn)\n-    abort ();\t\t\t\t\t/* Sanity check */\n+    abort ();\t\t\t\t\t/* Sanity check.  */\n \n   if (arm_naked_function_p (current_function_decl))\n     return;\n@@ -6026,11 +6010,10 @@ output_func_prologue (f, frame_size)\n \n   if (live_regs_mask)\n     {\n-      /* if a di mode load/store multiple is used, and the base register\n+      /* If a di mode load/store multiple is used, and the base register\n \t is r3, then r4 can become an ever live register without lr\n \t doing so,  in this case we need to push lr as well, or we\n-\t will fail to get a proper return. */\n-\n+\t will fail to get a proper return.  */\n       live_regs_mask |= 1 << LR_REGNUM;\n       lr_save_eliminated = 0;\n \n@@ -6050,7 +6033,7 @@ arm_output_epilogue ()\n {\n   int reg;\n   int live_regs_mask = 0;\n-  /* If we need this, then it will always be at least this much */\n+  /* If we need this, then it will always be at least this much.  */\n   int floats_offset = 12;\n   rtx operands[3];\n   int frame_size = get_frame_size ();\n@@ -6112,7 +6095,7 @@ arm_output_epilogue ()\n \t\t{\n \t\t  floats_offset += 12;\n \t\t  \n-\t\t  /* We can't unstack more than four registers at once */\n+\t\t  /* We can't unstack more than four registers at once.  */\n \t\t  if (start_reg - reg == 3)\n \t\t    {\n \t\t      asm_fprintf (f, \"\\tlfm\\t%r, 4, [%r, #-%d]\\n\",\n@@ -6224,7 +6207,7 @@ arm_output_epilogue ()\n \t{\n \t  if (live_regs_mask || regs_ever_live[LR_REGNUM])\n \t    {\n-\t      /* Restore the integer regs, and the return address into lr */\n+\t      /* Restore the integer regs, and the return address into lr.  */\n \t      if (! lr_save_eliminated)\n \t\tlive_regs_mask |= 1 << LR_REGNUM;\n \n@@ -6234,12 +6217,12 @@ arm_output_epilogue ()\n \n \t  if (current_function_pretend_args_size)\n \t    {\n-\t      /* Unwind the pre-pushed regs */\n+\t      /* Unwind the pre-pushed regs.  */\n \t      operands[0] = operands[1] = stack_pointer_rtx;\n \t      operands[2] = GEN_INT (current_function_pretend_args_size);\n \t      output_add_immediate (operands);\n \t    }\n-\t  /* And finally, go home */\n+\t  /* And finally, go home.  */\n \t  if (TARGET_INTERWORK)\n \t    asm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n \t  else if (TARGET_APCS_32)\n@@ -6270,7 +6253,6 @@ output_func_epilogue (frame_size)\n    Unfortunately, since this insn does not reflect very well the actual\n    semantics of the operation, we need to annotate the insn for the benefit\n    of DWARF2 frame unwind information.  */\n-\n static rtx\n emit_multi_reg_push (mask)\n      int mask;\n@@ -6459,7 +6441,6 @@ arm_expand_prologue ()\n     }\n       \n   /* And now the floating point regs.  */\n-\n   if (! volatile_func)\n     {\n       if (arm_fpu_arch == FP_SOFT2)\n@@ -6676,7 +6657,7 @@ arm_print_operand (stream, x, code)\n       else if (GET_CODE (x) == CONST_DOUBLE)\n \tfprintf (stream, \"#%s\", fp_immediate_constant (x));\n       else if (GET_CODE (x) == NEG)\n-\tabort (); /* This should never happen now. */\n+\tabort (); /* This should never happen now.  */\n       else\n \t{\n \t  fputc ('#', stream);\n@@ -6846,7 +6827,7 @@ arm_final_prescan_insn (insn)\n      out what the conditions are when the jump isn't taken.  */\n   int jump_clobbers = 0;\n   \n-  /* If we start with a return insn, we only succeed if we find another one. */\n+  /* If we start with a return insn, we only succeed if we find another one.  */\n   int seeking_return = 0;\n   \n   /* START_INSN will hold the insn from where we start looking.  This is the\n@@ -7002,7 +6983,7 @@ arm_final_prescan_insn (insn)\n \t      /* Succeed if the following insn is the target label.\n \t\t Otherwise fail.  \n \t\t If return insns are used then the last insn in a function \n-\t\t will be a barrier. */\n+\t\t will be a barrier.  */\n \t      this_insn = next_nonnote_insn (this_insn);\n \t      if (this_insn && this_insn == label)\n \t\t{\n@@ -7190,7 +7171,7 @@ arm_strip_name_encoding (const char * name)\n }\n \n #ifdef AOF_ASSEMBLER\n-/* Special functions only needed when producing AOF syntax assembler. */\n+/* Special functions only needed when producing AOF syntax assembler.  */\n \n rtx aof_pic_label = NULL_RTX;\n struct pic_chain"}, {"sha": "8e7b857930cd9f1c580cb71553ed47372d8587e5", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6354dc9bf8355ab4fd2c90a2cbdac03a80e438de/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6354dc9bf8355ab4fd2c90a2cbdac03a80e438de", "patch": "@@ -250,6 +250,22 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define SUBTARGET_CPP_SPEC      \"\"\n #endif\n \n+#ifndef SUBTARGET_EXTRA_ASM_SPEC\n+#define SUBTARGET_EXTRA_ASM_SPEC\n+#endif\n+\n+#ifndef ASM_SPEC\n+#define ASM_SPEC \"\\\n+%{mbig-endian:-EB} \\\n+%{mcpu=*:-m%*} \\\n+%{march=*:-m%*} \\\n+%{mapcs-*:-mapcs-%*} \\\n+%{matpcs:-matpcs} \\\n+%{mapcs-float:-mfloat} \\\n+%{msoft-float:-mno-fpu} \\\n+%{mthumb-interwork:-mthumb-interwork} \\\n+\" SUBTARGET_EXTRA_ASM_SPEC\n+#endif\n \f\n /* Run-time Target Specification.  */\n #ifndef TARGET_VERSION\n@@ -2100,7 +2116,7 @@ extern struct rtx_def * arm_compare_op1;\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n-        arm_poke_function_name (STREAM, NAME);\t\t\\\n+        arm_poke_function_name (STREAM, (char *) NAME);\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -2240,7 +2256,7 @@ extern struct rtx_def * arm_compare_op1;\n   do\t\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\t\\\n       int mi_delta = (DELTA);\t\t\t\t\t\t\t\\\n-      const char *mi_op = mi_delta < 0 ? \"sub\" : \"add\";\t\t\t\t\\\n+      const char * mi_op = mi_delta < 0 ? \"sub\" : \"add\";\t\t\t\\\n       int shift = 0;\t\t\t\t\t\t\t\t\\\n       int this_regno = (aggregate_value_p (TREE_TYPE (TREE_TYPE (FUNCTION)))\t\\\n \t\t        ? 1 : 0);\t\t\t\t\t\t\\"}]}