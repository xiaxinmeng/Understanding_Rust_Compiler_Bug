{"sha": "e9b34037cdd196ab912a7ac3358f8a8d3e307e92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliMzQwMzdjZGQxOTZhYjkxMmE3YWMzMzU4ZjhhOGQzZTMwN2U5Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-02-22T12:20:26Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-02-22T12:20:26Z"}, "message": "Fortran/OpenMP: Fix optional dummy procedures [PR99171]\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/99171\n\t* trans-openmp.c (gfc_omp_is_optional_argument): Regard optional\n\tdummy procs as nonoptional as no special treatment is needed.\n\nlibgomp/ChangeLog:\n\n\tPR fortran/99171\n\t* testsuite/libgomp.fortran/dummy-procs-1.f90: New test.", "tree": {"sha": "b0e0acb1e2d51633ffd9d111637a0a663aa030e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0e0acb1e2d51633ffd9d111637a0a663aa030e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b34037cdd196ab912a7ac3358f8a8d3e307e92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b34037cdd196ab912a7ac3358f8a8d3e307e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b34037cdd196ab912a7ac3358f8a8d3e307e92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b34037cdd196ab912a7ac3358f8a8d3e307e92/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "451002e626620833a57c35002ea9ac4e5ba7633a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/451002e626620833a57c35002ea9ac4e5ba7633a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/451002e626620833a57c35002ea9ac4e5ba7633a"}], "stats": {"total": 398, "additions": 397, "deletions": 1}, "files": [{"sha": "349df1cc3468e6e32903920c3b5eed99d6bfd218", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b34037cdd196ab912a7ac3358f8a8d3e307e92/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b34037cdd196ab912a7ac3358f8a8d3e307e92/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=e9b34037cdd196ab912a7ac3358f8a8d3e307e92", "patch": "@@ -64,7 +64,9 @@ gfc_omp_is_allocatable_or_ptr (const_tree decl)\n /* True if the argument is an optional argument; except that false is also\n    returned for arguments with the value attribute (nonpointers) and for\n    assumed-shape variables (decl is a local variable containing arg->data).\n-   Note that pvoid_type_node is for 'type(c_ptr), value.  */\n+   Note that for 'procedure(), optional' the value false is used as that's\n+   always a pointer and no additional indirection is used.\n+   Note that pvoid_type_node is for 'type(c_ptr), value' (and c_funloc).  */\n \n static bool\n gfc_omp_is_optional_argument (const_tree decl)\n@@ -73,6 +75,7 @@ gfc_omp_is_optional_argument (const_tree decl)\n \t  && DECL_LANG_SPECIFIC (decl)\n \t  && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n \t  && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl)))\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) != FUNCTION_TYPE\n \t  && GFC_DECL_OPTIONAL_ARGUMENT (decl));\n }\n "}, {"sha": "fcb17ce69a91561e1a51441ecb1e60e6bc8d9d6c", "filename": "libgomp/testsuite/libgomp.fortran/dummy-procs-1.f90", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b34037cdd196ab912a7ac3358f8a8d3e307e92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdummy-procs-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b34037cdd196ab912a7ac3358f8a8d3e307e92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdummy-procs-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdummy-procs-1.f90?ref=e9b34037cdd196ab912a7ac3358f8a8d3e307e92", "patch": "@@ -0,0 +1,393 @@\n+! { dg-do run }\n+!\n+! PR fortran/99171\n+!\n+! Check dummy procedure arguments, especially optional ones\n+!\n+module m\n+  use iso_c_binding\n+  implicit none (type, external)\n+  integer :: cnt\n+  integer :: cnt2\n+contains\n+  subroutine proc()\n+    cnt = cnt + 1\n+  end subroutine\n+\n+  subroutine proc2()\n+    cnt2 = cnt2 + 1\n+  end subroutine\n+\n+  subroutine check(my_proc)\n+    procedure(proc) :: my_proc\n+    cnt = 42\n+    call my_proc()\n+    if (cnt /= 43) stop 1\n+\n+    !$omp parallel\n+      call my_proc()\n+    !$omp end parallel\n+    if (cnt <= 43) stop 2 \n+  end\n+\n+  subroutine check_opt(my_proc)\n+    procedure(proc), optional :: my_proc\n+    logical :: is_present\n+    is_present = present(my_proc)\n+    cnt = 55\n+    if (present (my_proc)) then\n+      call my_proc()\n+      if (cnt /= 56) stop 3\n+    endif\n+\n+    !$omp parallel\n+      if (is_present .neqv. present (my_proc)) stop 4\n+      if (present (my_proc)) then\n+        call my_proc()\n+        if (cnt <= 56) stop 5\n+      end if\n+    !$omp end parallel\n+    if (is_present) then\n+      if (cnt <= 56) stop 6\n+    else if (cnt /= 55) then\n+      stop 7\n+    end if\n+  end\n+\n+  subroutine check_ptr(my_proc)\n+    procedure(proc), pointer :: my_proc\n+    logical :: is_assoc\n+    integer :: mycnt\n+    is_assoc = associated (my_proc)\n+\n+    cnt = 10\n+    cnt2 = 20\n+    if (associated (my_proc)) then\n+      call my_proc()\n+      if (cnt /= 11 .or. cnt2 /= 20) stop 8\n+    endif\n+\n+    !$omp parallel\n+      if (is_assoc .neqv. associated (my_proc)) stop 9\n+      if (associated (my_proc)) then\n+        if (.not. associated (my_proc, proc)) stop 10\n+        call my_proc()\n+        if (cnt <= 11 .or. cnt2 /= 20) stop 11\n+      else if (cnt /= 10 .or. cnt2 /= 20) then\n+        stop 12\n+      end if\n+    !$omp end parallel\n+    if (is_assoc .neqv. associated (my_proc)) stop 13\n+    if (associated (my_proc)) then\n+      if (cnt <= 11 .or. cnt2 /= 20) stop 14\n+    else if (is_assoc .and. (cnt /= 11 .or. cnt2 /= 20)) then\n+      stop 15\n+    end if\n+\n+    cnt = 30\n+    cnt2 = 40\n+    mycnt = 0\n+    !$omp parallel shared(mycnt)\n+      !$omp critical\n+         my_proc => proc2\n+         if (.not.associated (my_proc, proc2)) stop 17\n+         mycnt = mycnt + 1\n+         call my_proc()\n+         if (cnt2 /= 40 + mycnt .or. cnt /= 30) stop 18\n+      !$omp end critical\n+    !$omp end parallel\n+    if (.not.associated (my_proc, proc2)) stop 19\n+    if (cnt2 /= 40 + mycnt .or. cnt /= 30) stop 20\n+  end\n+\n+  subroutine check_ptr_opt(my_proc)\n+    procedure(proc), pointer, optional :: my_proc\n+    logical :: is_assoc, is_present\n+    integer :: mycnt\n+    is_assoc = .false.\n+    is_present = present(my_proc)\n+\n+    cnt = 10\n+    cnt2 = 20\n+    if (present (my_proc)) then\n+      is_assoc = associated (my_proc)\n+      if (associated (my_proc)) then\n+        call my_proc()\n+        if (cnt /= 11 .or. cnt2 /= 20) stop 21\n+      endif\n+   end if\n+\n+    !$omp parallel\n+      if (is_present .neqv. present (my_proc)) stop 22\n+      if (present (my_proc)) then\n+        if (is_assoc .neqv. associated (my_proc)) stop 23\n+        if (associated (my_proc)) then\n+          if (.not. associated (my_proc, proc)) stop 24\n+          call my_proc()\n+          if (cnt <= 11 .or. cnt2 /= 20) stop 25\n+        else if (cnt /= 10 .or. cnt2 /= 20) then\n+          stop 26\n+        end if\n+      end if\n+    !$omp end parallel\n+    if (present (my_proc)) then\n+      if (is_assoc .neqv. associated (my_proc)) stop 27\n+      if (associated (my_proc)) then\n+        if (cnt <= 11 .or. cnt2 /= 20) stop 28\n+      else if (is_assoc .and. (cnt /= 11 .or. cnt2 /= 20)) then\n+        stop 29\n+      end if\n+    end if\n+\n+    cnt = 30\n+    cnt2 = 40\n+    mycnt = 0\n+    !$omp parallel shared(mycnt)\n+      if (is_present .neqv. present (my_proc)) stop 30\n+      !$omp critical\n+         if (present (my_proc)) then\n+           my_proc => proc2\n+           if (.not.associated (my_proc, proc2)) stop 31\n+           mycnt = mycnt + 1\n+           call my_proc()\n+           if (cnt2 /= 40 + mycnt .or. cnt /= 30) stop 32\n+         end if\n+      !$omp end critical\n+    !$omp end parallel\n+    if (present (my_proc)) then\n+      if (.not.associated (my_proc, proc2)) stop 33\n+      if (cnt2 /= 40 + mycnt .or. cnt /= 30) stop 34\n+    end if\n+  end\n+\n+  ! ----------------------\n+\n+  subroutine cfun_check(my_cfun)\n+    type(c_funptr) :: my_cfun\n+    procedure(proc), pointer :: pptr\n+    logical :: has_cfun\n+\n+    has_cfun = c_associated (my_cfun)\n+    pptr => null()\n+    cnt = 42\n+    call c_f_procpointer (my_cfun, pptr)\n+    if (has_cfun) then\n+      call pptr()\n+      if (cnt /= 43) stop 35\n+    end if\n+\n+    pptr => null()\n+    !$omp parallel\n+      if (has_cfun .neqv. c_associated (my_cfun)) stop 36\n+      !$omp critical\n+        call c_f_procpointer (my_cfun, pptr)\n+      !$omp end critical\n+      if (has_cfun) then\n+        call pptr()\n+        if (cnt <= 43) stop 37\n+      else\n+        if (associated (pptr)) stop 38\n+      end if\n+    !$omp end parallel\n+  end\n+\n+  subroutine cfun_check_opt(my_cfun)\n+    type(c_funptr), optional :: my_cfun\n+    procedure(proc), pointer :: pptr\n+    logical :: has_cfun, is_present\n+\n+    has_cfun = .false.\n+    is_present = present (my_cfun)\n+    if (is_present) has_cfun = c_associated (my_cfun)\n+\n+    cnt = 1\n+    pptr => null()\n+    !$omp parallel\n+      if (is_present .neqv. present (my_cfun)) stop 39\n+      if (is_present) then\n+        if (has_cfun .neqv. c_associated (my_cfun, c_funloc(proc))) stop 40\n+        !$omp critical\n+          call c_f_procpointer (my_cfun, pptr)\n+        !$omp end critical\n+        if (has_cfun) then\n+          call pptr()\n+          if (cnt <= 1) stop 41\n+        else\n+          if (associated (pptr)) stop 42\n+        end if\n+      end if\n+    !$omp end parallel\n+  end\n+\n+  subroutine cfun_check_ptr(my_cfun)\n+    type(c_funptr), pointer :: my_cfun\n+    procedure(proc), pointer :: pptr\n+    logical :: has_cfun, is_assoc\n+\n+    has_cfun = .false.\n+    is_assoc = associated (my_cfun)\n+    if (is_assoc) has_cfun = c_associated (my_cfun)\n+\n+    cnt = 1\n+    pptr => null()\n+    !$omp parallel\n+      if (is_assoc .neqv. associated (my_cfun)) stop 43\n+      if (is_assoc) then\n+        if (has_cfun .neqv. c_associated (my_cfun, c_funloc(proc))) stop 44\n+        !$omp critical\n+          call c_f_procpointer (my_cfun, pptr)\n+        !$omp end critical\n+        if (has_cfun) then\n+          call pptr()\n+          if (cnt <= 1) stop 45\n+        else\n+          if (associated (pptr)) stop 46\n+        end if\n+      end if\n+    !$omp end parallel\n+\n+    cnt = 42\n+    cnt2 = 1\n+    pptr => null()\n+    !$omp parallel\n+      if (is_assoc .neqv. associated (my_cfun)) stop 47\n+      if (is_assoc) then\n+        !$omp critical\n+          my_cfun = c_funloc (proc2)\n+          call c_f_procpointer (my_cfun, pptr)\n+        !$omp end critical\n+        if (.not. associated (pptr, proc2)) stop 48\n+        if (.not. c_associated (my_cfun, c_funloc(proc2))) stop 49\n+        call pptr()\n+        if (cnt /= 42 .or. cnt2 <= 1) stop 50\n+      end if\n+    !$omp end parallel\n+    if (is_assoc) then\n+      if (.not. associated (pptr, proc2)) stop 51\n+      if (.not. c_associated (my_cfun, c_funloc(proc2))) stop 52\n+    else\n+      if (associated (pptr)) stop 53\n+    end if\n+  end\n+\n+  subroutine cfun_check_ptr_opt (my_cfun)\n+    type(c_funptr), pointer, optional :: my_cfun\n+    procedure(proc), pointer :: pptr\n+    logical :: is_present, has_cfun, is_assoc\n+\n+    has_cfun = .false.\n+    is_assoc = .false.\n+    is_present = present (my_cfun)\n+    if (is_present) then\n+      is_assoc = associated (my_cfun)\n+      if (is_assoc) has_cfun = c_associated (my_cfun)\n+    end if\n+\n+    cnt = 1\n+    pptr => null()\n+    !$omp parallel\n+      if (is_present .neqv. present (my_cfun)) stop 54\n+      if (is_present) then\n+        if (is_assoc .neqv. associated (my_cfun)) stop 55\n+        if (is_assoc) then\n+          if (has_cfun .neqv. c_associated (my_cfun, c_funloc(proc))) stop 56\n+          !$omp critical\n+            call c_f_procpointer (my_cfun, pptr)\n+          !$omp end critical\n+          if (has_cfun) then\n+            call pptr()\n+            if (cnt <= 1) stop 57\n+          else\n+            if (associated (pptr)) stop 58\n+          end if\n+        end if\n+      end if\n+    !$omp end parallel\n+\n+    cnt = 42\n+    cnt2 = 1\n+    pptr => null()\n+    !$omp parallel\n+      if (is_present .neqv. present (my_cfun)) stop 59\n+      if (is_present) then\n+        if (is_assoc .neqv. associated (my_cfun)) stop 60\n+        if (is_assoc) then\n+          !$omp critical\n+            my_cfun = c_funloc (proc2)\n+            call c_f_procpointer (my_cfun, pptr)\n+          !$omp end critical\n+          if (.not. associated (pptr, proc2)) stop 61\n+          if (.not. c_associated (my_cfun, c_funloc(proc2))) stop 62\n+          call pptr()\n+          if (cnt /= 42 .or. cnt2 <= 1) stop 63\n+        end if\n+      end if\n+    !$omp end parallel\n+    if (is_present .and. is_assoc) then\n+      if (.not. associated (pptr, proc2)) stop 64\n+      if (.not. c_associated (my_cfun, c_funloc(proc2))) stop 65\n+    else\n+      if (associated (pptr)) stop 66\n+    end if\n+  end\n+end module m\n+\n+\n+\n+program main\n+  use m\n+  implicit none (type, external)\n+  procedure(proc), pointer :: pptr\n+  type(c_funptr), target :: cfun\n+  type(c_funptr), pointer :: cfun_ptr\n+\n+  call check(proc)\n+  call check_opt()\n+  call check_opt(proc)\n+\n+  pptr => null()\n+  call check_ptr(pptr)\n+  pptr => proc\n+  call check_ptr(pptr)\n+\n+  call check_ptr_opt()\n+  pptr => null()\n+  call check_ptr_opt(pptr)\n+  pptr => proc\n+  call check_ptr_opt(pptr)\n+\n+  ! -------------------\n+  pptr => null()\n+\n+  cfun = c_funloc (pptr)\n+  call cfun_check(cfun)\n+\n+  cfun = c_funloc (proc)\n+  call cfun_check(cfun)\n+\n+  call cfun_check_opt()\n+\n+  cfun = c_funloc (pptr)\n+  call cfun_check_opt(cfun)\n+\n+  cfun = c_funloc (proc)\n+  call cfun_check_opt(cfun)\n+\n+  ! - - - -\n+  cfun_ptr => null()\n+  call cfun_check_ptr (cfun_ptr)\n+\n+  cfun = c_funloc (proc)\n+  cfun_ptr => cfun\n+  call cfun_check_ptr (cfun_ptr)\n+\n+  ! - - - -\n+  call cfun_check_ptr_opt ()\n+\n+  cfun_ptr => null()\n+  call cfun_check_ptr_opt (cfun_ptr)\n+\n+  cfun = c_funloc (proc)\n+  cfun_ptr => cfun\n+  call cfun_check_ptr_opt (cfun_ptr)\n+end program"}]}