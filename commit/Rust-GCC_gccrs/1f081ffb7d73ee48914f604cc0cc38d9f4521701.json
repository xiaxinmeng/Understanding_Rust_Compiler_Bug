{"sha": "1f081ffb7d73ee48914f604cc0cc38d9f4521701", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYwODFmZmI3ZDczZWU0ODkxNGY2MDRjYzBjYzM4ZDlmNDUyMTcwMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-08-25T00:00:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-25T00:00:03Z"}, "message": "jump.c (jump_optimize_1): Do cmov opt on any single-set; force B into a register before emit_conditional_move.\n\n        * jump.c (jump_optimize_1): Do cmov opt on any single-set; force\n        B into a register before emit_conditional_move.\n\nFrom-SVN: r28830", "tree": {"sha": "ba4c869ebe132fc47fee6de1e228593454524e8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba4c869ebe132fc47fee6de1e228593454524e8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f081ffb7d73ee48914f604cc0cc38d9f4521701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f081ffb7d73ee48914f604cc0cc38d9f4521701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f081ffb7d73ee48914f604cc0cc38d9f4521701", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f081ffb7d73ee48914f604cc0cc38d9f4521701/comments", "author": null, "committer": null, "parents": [{"sha": "abe4f192b718200fec889f10b289503e22a3df06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe4f192b718200fec889f10b289503e22a3df06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe4f192b718200fec889f10b289503e22a3df06"}], "stats": {"total": 38, "additions": 31, "deletions": 7}, "files": [{"sha": "4920ebe8f8740c4704b691f40c409c23f3360f61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f081ffb7d73ee48914f604cc0cc38d9f4521701/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f081ffb7d73ee48914f604cc0cc38d9f4521701/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f081ffb7d73ee48914f604cc0cc38d9f4521701", "patch": "@@ -1,3 +1,8 @@\n+Tue Aug 24 16:58:15 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* jump.c (jump_optimize_1): Do cmov opt on any single-set; force\n+\tB into a register before emit_conditional_move.\n+\n Tue Aug 24 15:37:03 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* fold-const.c (fold): Reassociate (+ (+ (* a b) c) (* d e))"}, {"sha": "9a9e9b252bf2c40518436364c26600e493ee74ec", "filename": "gcc/jump.c", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f081ffb7d73ee48914f604cc0cc38d9f4521701/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f081ffb7d73ee48914f604cc0cc38d9f4521701/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=1f081ffb7d73ee48914f604cc0cc38d9f4521701", "patch": "@@ -874,24 +874,25 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n \t     INSN here is the jump around the store.  We set:\n \n-\t     TEMP to the \"x = b;\" insn.\n+\t     TEMP to the \"x op= b;\" insn.\n \t     TEMP1 to X.\n \t     TEMP2 to B.\n \t     TEMP3 to A (X in the second case).\n \t     TEMP4 to the condition being tested.\n-\t     TEMP5 to the earliest insn used to find the condition.  */\n+\t     TEMP5 to the earliest insn used to find the condition.\n+\t     TEMP6 to the SET of TEMP.  */\n \n \t  if (/* We can't do this after reload has completed.  */\n \t      ! reload_completed\n \t      && this_is_condjump && ! this_is_simplejump\n \t      /* Set TEMP to the \"x = b;\" insn.  */\n \t      && (temp = next_nonnote_insn (insn)) != 0\n \t      && GET_CODE (temp) == INSN\n-\t      && GET_CODE (PATTERN (temp)) == SET\n-\t      && GET_CODE (temp1 = SET_DEST (PATTERN (temp))) == REG\n+\t      && (temp6 = single_set (temp)) != NULL_RTX\n+\t      && GET_CODE (temp1 = SET_DEST (temp6)) == REG\n \t      && (! SMALL_REGISTER_CLASSES\n \t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n-\t      && ! side_effects_p (temp2 = SET_SRC (PATTERN (temp)))\n+\t      && ! side_effects_p (temp2 = SET_SRC (temp6))\n \t      && ! may_trap_p (temp2)\n \t      /* Allow either form, but prefer the former if both apply. \n \t\t There is no point in using the old value of TEMP1 if\n@@ -936,7 +937,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\tenum rtx_code code = GET_CODE (temp4);\n \t\trtx var = temp1;\n \t\trtx cond0, cond1, aval, bval;\n-\t\trtx target;\n+\t\trtx target, new_insn;\n \n \t\t/* Copy the compared variables into cond0 and cond1, so that\n \t\t   any side effects performed in or after the old comparison,\n@@ -955,10 +956,28 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\telse\n \t\t  cond1 = gen_reg_rtx (GET_MODE (XEXP (temp4, 1)));\n \n+\t\t/* Careful about copying these values -- an IOR or what may\n+\t\t   need to do other things, like clobber flags.  */\n+\t\t/* ??? Assume for the moment that AVAL is ok.  */\n \t\taval = temp3;\n-\t\tbval = temp2;\n \n \t\tstart_sequence ();\n+\n+\t\t/* If we're not dealing with a register or the insn is more\n+\t\t   complex than a simple SET, duplicate the computation and\n+\t\t   replace the destination with a new temporary.  */\n+\t\tif (register_operand (temp2, GET_MODE (var))\n+\t\t    && GET_CODE (PATTERN (temp)) == SET)\n+\t\t  bval = temp2;\n+\t\telse\n+\t\t  {\n+\t\t    bval = gen_reg_rtx (GET_MODE (var));\n+\t\t    new_insn = copy_rtx (temp);\n+\t\t    temp6 = single_set (new_insn);\n+\t\t    SET_DEST (temp6) = bval;\n+\t\t    emit_insn (PATTERN (new_insn));\n+\t\t  }\n+\t\t  \n \t\ttarget = emit_conditional_move (var, code,\n \t\t\t\t\t\tcond0, cond1, VOIDmode,\n \t\t\t\t\t\taval, bval, GET_MODE (var),"}]}