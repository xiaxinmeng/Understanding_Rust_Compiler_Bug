{"sha": "3d2f6864225cc660adfc9136c859dd26e2a40135", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QyZjY4NjQyMjVjYzY2MGFkZmM5MTM2Yzg1OWRkMjZlMmE0MDEzNQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-07-17T02:34:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-07-17T02:34:10Z"}, "message": "re PR c++/45329 (When printing a list of candidate functions, explain why each function failed to match.)\n\n\tPR c++/45329\n\tPR c++/48934\n\t* cp-tree.h (fn_type_unification): Add `bool' parameter.\n\t* pt.c (enum template_base_result): Define.\n\t(unify_success, unify_unknown): Define.\n\t(unify_parameter_deduction_failure): Define.\n\t(unify_invalid, unify_cv_qual_mismatch, unify_type_mismatch): Define.\n\t(unify_parameter_pack_mismatch): Define.\n\t(unify_parameter_pack_inconsistent): Define.\n\t(unify_ptrmem_cst_mismatch, unify_vla_arg): Define.\n\t(unify_expression_unequal, unify_inconsistency): Define.\n\t(unify_method_type_error, unify_arity): Likewise.\n\t(unify_too_many_parameters, unify_too_few_parameters): Define.\n\t(unify_arg_conversion, unify_no_common_base): Define.\n\t(unify_illformed_ptrmem_cst_expr): Define.\n\t(unify_substitution_failure): Define.\n\t(unify_inconsistent_template_template_parameters): Define.\n\t(unify_template_deduction_failure): Define.\n\t(unify_template_argument_mismatch): Define.\n\t(unify_overload_resolution_failure): Define.\n\t(comp_template_args_with_info): New function, split out from...\n\t(comp_template_args): ...here.\tCall it.\n\t(deduction_tsubst_fntype): Add `complain' parameter'.  Pass it\n\tto tsubst.\n\t(unify): Add `explain_p' parameter.  Pass to all relevant calls.\n\tCall above status functions when appropriate.\n\t(resolve_overloaded_unification, try_one_overload): Likewise.\n\t(type_unification, type_unification_real): Likewise.\n\t(unify_pack_expansion): Likewise.\n\t(get_template_base, try_class_unification): Likewise.\n\t(get_bindings, more_specialized_fn): Pass false to unification\n\tcalls.\n\t(get_class_bindings, do_auto_deduction): Likewise.\n\t(convert_nontype_argument): Likewise.\n\t(fn_type_unification): Likewise.  Pass tf_warning_or_error if\n\texplain_p.\n\t(get_template_base): Add `explain_p' parameter and pass it to\n\ttry_class_unification.\tReturn an enum template_base_result.\n\t* class.c (resolve_address_of_overloaded_function): Pass false to\n\tfn_type_unification.\n\t* call.c (enum rejection_reason_code): Add new codes.\n\t(struct rejection_reason): Add template_unification field.\n\tAdd template_instantiation field.\n\t(template_unification_rejection): Define.\n\t(template_unification_error_rejection): Define.\n\t(template_instantiation_rejection): Define.\n\t(invalid_copy_with_fn_template_rejection): Define.\n\t(add_template_candidate): Pass false to unify.\n\tProvide more rejection reasons when possible.\n\t(print_template_unification_rejection): Define.\n\t(print_arity_rejection): Define, split out from...\n\t(print_z_candidate): ...here.  Add cases for new rejection\n\treasons.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r176365", "tree": {"sha": "8686f4122e795ce6ee0e3abdbf5a370034464f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8686f4122e795ce6ee0e3abdbf5a370034464f27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d2f6864225cc660adfc9136c859dd26e2a40135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2f6864225cc660adfc9136c859dd26e2a40135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d2f6864225cc660adfc9136c859dd26e2a40135", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2f6864225cc660adfc9136c859dd26e2a40135/comments", "author": null, "committer": null, "parents": [{"sha": "c6f4a801a697e19df5560fb79b91fe7ee77a1cca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f4a801a697e19df5560fb79b91fe7ee77a1cca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6f4a801a697e19df5560fb79b91fe7ee77a1cca"}], "stats": {"total": 1149, "additions": 872, "deletions": 277}, "files": [{"sha": "4db0c7e89208f6606939c95278bdbde2652001cb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -1,3 +1,60 @@\n+2011-07-16  Nathan Froyd  <froydnj@codesourcery.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/45329\n+\tPR c++/48934\n+\t* cp-tree.h (fn_type_unification): Add `bool' parameter.\n+\t* pt.c (enum template_base_result): Define.\n+\t(unify_success, unify_unknown): Define.\n+\t(unify_parameter_deduction_failure): Define.\n+\t(unify_invalid, unify_cv_qual_mismatch, unify_type_mismatch): Define.\n+\t(unify_parameter_pack_mismatch): Define.\n+\t(unify_parameter_pack_inconsistent): Define.\n+\t(unify_ptrmem_cst_mismatch, unify_vla_arg): Define.\n+\t(unify_expression_unequal, unify_inconsistency): Define.\n+\t(unify_method_type_error, unify_arity): Likewise.\n+\t(unify_too_many_parameters, unify_too_few_parameters): Define.\n+\t(unify_arg_conversion, unify_no_common_base): Define.\n+\t(unify_illformed_ptrmem_cst_expr): Define.\n+\t(unify_substitution_failure): Define.\n+\t(unify_inconsistent_template_template_parameters): Define.\n+\t(unify_template_deduction_failure): Define.\n+\t(unify_template_argument_mismatch): Define.\n+\t(unify_overload_resolution_failure): Define.\n+\t(comp_template_args_with_info): New function, split out from...\n+\t(comp_template_args): ...here.\tCall it.\n+\t(deduction_tsubst_fntype): Add `complain' parameter'.  Pass it\n+\tto tsubst.\n+\t(unify): Add `explain_p' parameter.  Pass to all relevant calls.\n+\tCall above status functions when appropriate.\n+\t(resolve_overloaded_unification, try_one_overload): Likewise.\n+\t(type_unification, type_unification_real): Likewise.\n+\t(unify_pack_expansion): Likewise.\n+\t(get_template_base, try_class_unification): Likewise.\n+\t(get_bindings, more_specialized_fn): Pass false to unification\n+\tcalls.\n+\t(get_class_bindings, do_auto_deduction): Likewise.\n+\t(convert_nontype_argument): Likewise.\n+\t(fn_type_unification): Likewise.  Pass tf_warning_or_error if\n+\texplain_p.\n+\t(get_template_base): Add `explain_p' parameter and pass it to\n+\ttry_class_unification.\tReturn an enum template_base_result.\n+\t* class.c (resolve_address_of_overloaded_function): Pass false to\n+\tfn_type_unification.\n+\t* call.c (enum rejection_reason_code): Add new codes.\n+\t(struct rejection_reason): Add template_unification field.\n+\tAdd template_instantiation field.\n+\t(template_unification_rejection): Define.\n+\t(template_unification_error_rejection): Define.\n+\t(template_instantiation_rejection): Define.\n+\t(invalid_copy_with_fn_template_rejection): Define.\n+\t(add_template_candidate): Pass false to unify.\n+\tProvide more rejection reasons when possible.\n+\t(print_template_unification_rejection): Define.\n+\t(print_arity_rejection): Define, split out from...\n+\t(print_z_candidate): ...here.  Add cases for new rejection\n+\treasons.\n+\n 2011-07-15  Jason Merrill  <jason@redhat.com>\n \n \t* Make-lang.in (check-g++-strict-gc): New."}, {"sha": "99f9cc3d25a55e1e1891ad873e534754cf45c54d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 135, "deletions": 9, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -434,7 +434,10 @@ enum rejection_reason_code {\n   rr_arity,\n   rr_explicit_conversion,\n   rr_arg_conversion,\n-  rr_bad_arg_conversion\n+  rr_bad_arg_conversion,\n+  rr_template_unification,\n+  rr_template_instantiation,\n+  rr_invalid_copy\n };\n \n struct conversion_info {\n@@ -462,6 +465,24 @@ struct rejection_reason {\n     struct conversion_info conversion;\n     /* Same, but for bad argument conversions.  */\n     struct conversion_info bad_conversion;\n+    /* Information about template unification failures.  These are the\n+       parameters passed to fn_type_unification.  */\n+    struct {\n+      tree tmpl;\n+      tree explicit_targs;\n+      tree targs;\n+      const tree *args;\n+      unsigned int nargs;\n+      tree return_type;\n+      unification_kind_t strict;\n+      int flags;\n+    } template_unification;\n+    /* Information about template instantiation failures.  These are the\n+       parameters passed to instantiate_template.  */\n+    struct {\n+      tree tmpl;\n+      tree targs;\n+    } template_instantiation;\n   } u;\n };\n \n@@ -622,6 +643,50 @@ explicit_conversion_rejection (tree from, tree to)\n   return r;\n }\n \n+static struct rejection_reason *\n+template_unification_rejection (tree tmpl, tree explicit_targs, tree targs,\n+\t\t\t\tconst tree *args, unsigned int nargs,\n+\t\t\t\ttree return_type, unification_kind_t strict,\n+\t\t\t\tint flags)\n+{\n+  size_t args_n_bytes = sizeof (*args) * nargs;\n+  tree *args1 = (tree *) conversion_obstack_alloc (args_n_bytes);\n+  struct rejection_reason *r = alloc_rejection (rr_template_unification);\n+  r->u.template_unification.tmpl = tmpl;\n+  r->u.template_unification.explicit_targs = explicit_targs;\n+  r->u.template_unification.targs = targs;\n+  /* Copy args to our own storage.  */\n+  memcpy (args1, args, args_n_bytes);\n+  r->u.template_unification.args = args1;\n+  r->u.template_unification.nargs = nargs;\n+  r->u.template_unification.return_type = return_type;\n+  r->u.template_unification.strict = strict;\n+  r->u.template_unification.flags = flags;\n+  return r;\n+}\n+\n+static struct rejection_reason *\n+template_unification_error_rejection (void)\n+{\n+  return alloc_rejection (rr_template_unification);\n+}\n+\n+static struct rejection_reason *\n+template_instantiation_rejection (tree tmpl, tree targs)\n+{\n+  struct rejection_reason *r = alloc_rejection (rr_template_instantiation);\n+  r->u.template_instantiation.tmpl = tmpl;\n+  r->u.template_instantiation.targs = targs;\n+  return r;\n+}\n+\n+static struct rejection_reason *\n+invalid_copy_with_fn_template_rejection (void)\n+{\n+  struct rejection_reason *r = alloc_rejection (rr_invalid_copy);\n+  return r;\n+}\n+\n /* Dynamically allocate a conversion.  */\n \n static conversion *\n@@ -2859,6 +2924,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   int i;\n   tree fn;\n   struct rejection_reason *reason = NULL;\n+  int errs;\n \n   /* We don't do deduction on the in-charge parameter, the VTT\n      parameter or 'this'.  */\n@@ -2901,17 +2967,31 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n     }\n   gcc_assert (ia == nargs_without_in_chrg);\n \n+  errs = errorcount+sorrycount;\n   i = fn_type_unification (tmpl, explicit_targs, targs,\n \t\t\t   args_without_in_chrg,\n \t\t\t   nargs_without_in_chrg,\n-\t\t\t   return_type, strict, flags);\n+\t\t\t   return_type, strict, flags, false);\n \n   if (i != 0)\n-    goto fail;\n+    {\n+      /* Don't repeat unification later if it already resulted in errors.  */\n+      if (errorcount+sorrycount == errs)\n+\treason = template_unification_rejection (tmpl, explicit_targs,\n+\t\t\t\t\t\t targs, args_without_in_chrg,\n+\t\t\t\t\t\t nargs_without_in_chrg,\n+\t\t\t\t\t\t return_type, strict, flags);\n+      else\n+\treason = template_unification_error_rejection ();\n+      goto fail;\n+    }\n \n   fn = instantiate_template (tmpl, targs, tf_none);\n   if (fn == error_mark_node)\n-    goto fail;\n+    {\n+      reason = template_instantiation_rejection (tmpl, targs);\n+      goto fail;\n+    }\n \n   /* In [class.copy]:\n \n@@ -2940,7 +3020,10 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n       tree arg_types = FUNCTION_FIRST_USER_PARMTYPE (fn);\n       if (arg_types && same_type_p (TYPE_MAIN_VARIANT (TREE_VALUE (arg_types)),\n \t\t\t\t    ctype))\n-\tgoto fail;\n+\t{\n+\t  reason = invalid_copy_with_fn_template_rejection ();\n+\t  goto fail;\n+\t}\n     }\n \n   if (obj != NULL_TREE)\n@@ -3108,6 +3191,18 @@ print_conversion_rejection (location_t loc, struct conversion_info *info)\n \t    info->n_arg+1, info->from_type, info->to_type);\n }\n \n+/* Print information about a candidate with WANT parameters and we found\n+   HAVE.  */\n+\n+static void\n+print_arity_information (location_t loc, unsigned int have, unsigned int want)\n+{\n+  inform_n (loc, want,\n+\t    \"  candidate expects %d argument, %d provided\",\n+\t    \"  candidate expects %d arguments, %d provided\",\n+\t    want, have);\n+}\n+\n /* Print information about one overload candidate CANDIDATE.  MSGSTR\n    is the text to print before the candidate itself.\n \n@@ -3154,10 +3249,8 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n       switch (r->code)\n \t{\n \tcase rr_arity:\n-\t  inform_n (loc, r->u.arity.expected,\n-\t\t    \"  candidate expects %d argument, %d provided\",\n-\t\t    \"  candidate expects %d arguments, %d provided\",\n-\t\t    r->u.arity.expected, r->u.arity.actual);\n+\t  print_arity_information (loc, r->u.arity.actual,\n+\t\t\t\t   r->u.arity.expected);\n \t  break;\n \tcase rr_arg_conversion:\n \t  print_conversion_rejection (loc, &r->u.conversion);\n@@ -3171,6 +3264,39 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n \t\t  \"conversion\", r->u.conversion.from_type,\n \t\t  r->u.conversion.to_type);\n \t  break;\n+\tcase rr_template_unification:\n+\t  /* We use template_unification_error_rejection if unification caused\n+\t     actual non-SFINAE errors, in which case we don't need to repeat\n+\t     them here.  */\n+\t  if (r->u.template_unification.tmpl == NULL_TREE)\n+\t    {\n+\t      inform (loc, \"  substitution of deduced template arguments \"\n+\t\t      \"resulted in errors seen above\");\n+\t      break;\n+\t    }\n+\t  /* Re-run template unification with diagnostics.  */\n+\t  inform (loc, \"  template argument deduction/substitution failed:\");\n+\t  fn_type_unification (r->u.template_unification.tmpl,\n+\t\t\t       r->u.template_unification.explicit_targs,\n+\t\t\t       r->u.template_unification.targs,\n+\t\t\t       r->u.template_unification.args,\n+\t\t\t       r->u.template_unification.nargs,\n+\t\t\t       r->u.template_unification.return_type,\n+\t\t\t       r->u.template_unification.strict,\n+\t\t\t       r->u.template_unification.flags,\n+\t\t\t       true);\n+\t  break;\n+\tcase rr_template_instantiation:\n+\t  /* Re-run template instantiation with diagnostics.  */\n+\t  instantiate_template (r->u.template_instantiation.tmpl,\n+\t\t\t\tr->u.template_instantiation.targs,\n+\t\t\t\ttf_warning_or_error);\n+\t  break;\n+\tcase rr_invalid_copy:\n+\t  inform (loc,\n+\t\t  \"  a constructor taking a single argument of its own \"\n+\t\t  \"class type is invalid\");\n+\t  break;\n \tcase rr_none:\n \tdefault:\n \t  /* This candidate didn't have any issues or we failed to"}, {"sha": "61c1380d7b2203996af702b2135879b46f19e90a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -6570,7 +6570,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  targs = make_tree_vec (DECL_NTPARMS (fn));\n \t  if (fn_type_unification (fn, explicit_targs, targs, args, nargs,\n \t\t\t\t   target_ret_type, DEDUCE_EXACT,\n-\t\t\t\t   LOOKUP_NORMAL))\n+\t\t\t\t   LOOKUP_NORMAL, false))\n \t    /* Argument deduction failed.  */\n \t    continue;\n "}, {"sha": "c5905850ca458937cf064ec92b6522d739bc30f5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -5161,7 +5161,8 @@ extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n extern int fn_type_unification\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t const tree *, unsigned int,\n-\t\t\t\t\t\t tree, unification_kind_t, int);\n+\t\t\t\t\t\t tree, unification_kind_t, int,\n+\t\t\t\t\t\t bool);\n extern void mark_decl_instantiated\t\t(tree, int);\n extern int more_specialized_fn\t\t\t(tree, tree, int);\n extern void do_decl_instantiation\t\t(tree, tree);"}, {"sha": "a93f677c8419ff0939d4efc2136ecfc3c7377d90", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 501, "deletions": 182, "changes": 683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -109,15 +109,22 @@ static GTY(()) VEC(tree,gc) *canonical_template_parms;\n #define UNIFY_ALLOW_OUTER_MORE_CV_QUAL 32\n #define UNIFY_ALLOW_OUTER_LESS_CV_QUAL 64\n \n+enum template_base_result {\n+  tbr_incomplete_type,\n+  tbr_ambiguous_baseclass,\n+  tbr_success\n+};\n+\n static void push_access_scope (tree);\n static void pop_access_scope (tree);\n static void push_deduction_access_scope (tree);\n static void pop_deduction_access_scope (tree);\n static bool resolve_overloaded_unification (tree, tree, tree, tree,\n-\t\t\t\t\t    unification_kind_t, int);\n+\t\t\t\t\t    unification_kind_t, int,\n+\t\t\t\t\t    bool);\n static int try_one_overload (tree, tree, tree, tree, tree,\n-\t\t\t     unification_kind_t, int, bool);\n-static int unify (tree, tree, tree, tree, int);\n+\t\t\t     unification_kind_t, int, bool, bool);\n+static int unify (tree, tree, tree, tree, int, bool);\n static void add_pending_template (tree);\n static tree reopen_tinst_level (struct tinst_level *);\n static tree tsubst_initializer_list (tree, tree);\n@@ -131,7 +138,8 @@ static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*,\n \t\t\t\t\t     tree);\n static int type_unification_real (tree, tree, tree, const tree *,\n-\t\t\t\t  unsigned int, int, unification_kind_t, int);\n+\t\t\t\t  unsigned int, int, unification_kind_t, int,\n+\t\t\t\t  bool);\n static void note_template_header (int);\n static tree convert_nontype_argument_function (tree, tree);\n static tree convert_nontype_argument (tree, tree, tsubst_flags_t);\n@@ -156,7 +164,8 @@ static tree get_bindings (tree, tree, tree, bool);\n static int template_decl_level (tree);\n static int check_cv_quals_for_unify (int, tree, tree);\n static void template_parm_level_and_index (tree, int*, int*);\n-static int unify_pack_expansion (tree, tree, tree, tree, int, bool, bool);\n+static int unify_pack_expansion (tree, tree, tree,\n+\t\t\t\t tree, int, bool, bool, bool);\n static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_args (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n@@ -168,8 +177,9 @@ static tree tsubst_function_type (tree, tree, tsubst_flags_t, tree);\n static bool check_specialization_scope (void);\n static tree process_partial_specialization (tree);\n static void set_current_access_from_decl (tree);\n-static tree get_template_base (tree, tree, tree, tree);\n-static tree try_class_unification (tree, tree, tree, tree);\n+static enum template_base_result get_template_base (tree, tree, tree, tree,\n+\t\t\t\t\t\t    bool , tree *);\n+static tree try_class_unification (tree, tree, tree, tree, bool);\n static int coerce_template_template_parms (tree, tree, tsubst_flags_t,\n \t\t\t\t\t   tree, tree);\n static bool template_template_parm_bindings_ok_p (tree, tree);\n@@ -5267,6 +5277,211 @@ has_value_dependent_address (tree op)\n   return false;\n }\n \n+/* The next set of functions are used for providing helpful explanatory\n+   diagnostics for failed overload resolution.  Their messages should be\n+   indented by two spaces for consistency with the messages in\n+   call.c  */\n+\n+static int\n+unify_success (bool explain_p ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+static int\n+unify_parameter_deduction_failure (bool explain_p, tree parm)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  couldn't deduce template parameter %qD\", parm);\n+  return 1;\n+}\n+\n+static int\n+unify_invalid (bool explain_p ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n+static int\n+unify_cv_qual_mismatch (bool explain_p, tree parm, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  types %qT and %qT have incompatible cv-qualifiers\",\n+\t    parm, arg);\n+  return 1;\n+}\n+\n+static int\n+unify_type_mismatch (bool explain_p, tree parm, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location, \"  mismatched types %qT and %qT\", parm, arg);\n+  return 1;\n+}\n+\n+static int\n+unify_parameter_pack_mismatch (bool explain_p, tree parm, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  template parameter %qD is not a parameter pack, but \"\n+\t    \"argument %qD is\",\n+\t    parm, arg);\n+  return 1;\n+}\n+\n+static int\n+unify_ptrmem_cst_mismatch (bool explain_p, tree parm, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  template argument %qE does not match \"\n+\t    \"pointer-to-member constant %qE\",\n+\t    arg, parm);\n+  return 1;\n+}\n+\n+static int\n+unify_expression_unequal (bool explain_p, tree parm, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location, \"  %qE is not equivalent to %qE\", parm, arg);\n+  return 1;\n+}\n+\n+static int\n+unify_parameter_pack_inconsistent (bool explain_p, tree old_arg, tree new_arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  inconsistent parameter pack deduction with %qT and %qT\",\n+\t    old_arg, new_arg);\n+  return 1;\n+}\n+\n+static int\n+unify_inconsistency (bool explain_p, tree parm, tree first, tree second)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  deduced conflicting types for parameter %qT (%qT and %qT)\",\n+\t    parm, first, second);\n+  return 1;\n+}\n+\n+static int\n+unify_vla_arg (bool explain_p, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  variable-sized array type %qT is not \"\n+\t    \"a valid template argument\",\n+\t    arg);\n+  return 1;\n+}\n+\n+static int\n+unify_method_type_error (bool explain_p, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  member function type %qT is not a valid template argument\",\n+\t    arg);\n+  return 1;\n+}\n+\n+static int\n+unify_arity (bool explain_p, int have, int wanted)\n+{\n+  if (explain_p)\n+    inform_n (input_location, wanted,\n+\t      \"  candidate expects %d argument, %d provided\",\n+\t      \"  candidate expects %d arguments, %d provided\",\n+\t      wanted, have);\n+  return 1;\n+}\n+\n+static int\n+unify_too_many_arguments (bool explain_p, int have, int wanted)\n+{\n+  return unify_arity (explain_p, have, wanted);\n+}\n+\n+static int\n+unify_too_few_arguments (bool explain_p, int have, int wanted)\n+{\n+  return unify_arity (explain_p, have, wanted);\n+}\n+\n+static int\n+unify_arg_conversion (bool explain_p, tree to_type,\n+\t\t      tree from_type, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location, \"  cannot convert %qE (type %qT) to type %qT\",\n+\t    arg, from_type, to_type);\n+  return 1;\n+}\n+\n+static int\n+unify_no_common_base (bool explain_p, enum template_base_result r,\n+\t\t      tree parm, tree arg)\n+{\n+  if (explain_p)\n+    switch (r)\n+      {\n+      case tbr_ambiguous_baseclass:\n+\tinform (input_location, \"  %qT is an ambiguous base class of %qT\",\n+\t\targ, parm);\n+\tbreak;\n+      default:\n+\tinform (input_location, \"  %qT is not derived from %qT\", arg, parm);\n+\tbreak;\n+      }\n+  return 1;\n+}\n+\n+static int\n+unify_inconsistent_template_template_parameters (bool explain_p)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  template parameters of a template template argument are \"\n+\t    \"inconsistent with other deduced template arguments\");\n+  return 1;\n+}\n+\n+static int\n+unify_template_deduction_failure (bool explain_p, tree parm, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  can't deduce a template for %qT from non-template type %qT\",\n+\t    parm, arg);\n+  return 1;\n+}\n+\n+static int\n+unify_template_argument_mismatch (bool explain_p, tree parm, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  template argument %qE does not match %qD\", arg, parm);\n+  return 1;\n+}\n+\n+static int\n+unify_overload_resolution_failure (bool explain_p, tree arg)\n+{\n+  if (explain_p)\n+    inform (input_location,\n+\t    \"  could not resolve address from overloaded function %qE\",\n+\t    arg);\n+  return 1;\n+}\n+\n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n    converted value.  If the conversion is unsuccessful, return\n@@ -6550,11 +6765,13 @@ template_args_equal (tree ot, tree nt)\n     return cp_tree_equal (ot, nt);\n }\n \n-/* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n-   of template arguments.  Returns 0 otherwise.  */\n+/* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets of\n+   template arguments.  Returns 0 otherwise, and updates OLDARG_PTR and\n+   NEWARG_PTR with the offending arguments if they are non-NULL.  */\n \n-int\n-comp_template_args (tree oldargs, tree newargs)\n+static int\n+comp_template_args_with_info (tree oldargs, tree newargs,\n+\t\t\t      tree *oldarg_ptr, tree *newarg_ptr)\n {\n   int i;\n \n@@ -6567,11 +6784,26 @@ comp_template_args (tree oldargs, tree newargs)\n       tree ot = TREE_VEC_ELT (oldargs, i);\n \n       if (! template_args_equal (ot, nt))\n-\treturn 0;\n+\t{\n+\t  if (oldarg_ptr != NULL)\n+\t    *oldarg_ptr = ot;\n+\t  if (newarg_ptr != NULL)\n+\t    *newarg_ptr = nt;\n+\t  return 0;\n+\t}\n     }\n   return 1;\n }\n \n+/* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n+   of template arguments.  Returns 0 otherwise.  */\n+\n+int\n+comp_template_args (tree oldargs, tree newargs)\n+{\n+  return comp_template_args_with_info (oldargs, newargs, NULL, NULL);\n+}\n+\n static void\n add_pending_template (tree d)\n {\n@@ -13724,7 +13956,7 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n    This is, of course, not reentrant.  */\n \n static tree\n-deduction_tsubst_fntype (tree fn, tree targs)\n+deduction_tsubst_fntype (tree fn, tree targs, tsubst_flags_t complain)\n {\n   static bool excessive_deduction_depth;\n   static int deduction_depth;\n@@ -13748,7 +13980,7 @@ deduction_tsubst_fntype (tree fn, tree targs)\n   input_location = DECL_SOURCE_LOCATION (fn);\n   ++deduction_depth;\n   push_deduction_access_scope (fn);\n-  r = tsubst (fntype, targs, tf_none, NULL_TREE);\n+  r = tsubst (fntype, targs, complain, NULL_TREE);\n   pop_deduction_access_scope (fn);\n   --deduction_depth;\n \n@@ -13961,7 +14193,8 @@ fn_type_unification (tree fn,\n \t\t     unsigned int nargs,\n \t\t     tree return_type,\n \t\t     unification_kind_t strict,\n-\t\t     int flags)\n+\t\t     int flags,\n+\t\t     bool explain_p)\n {\n   tree parms;\n   tree fntype;\n@@ -13996,12 +14229,15 @@ fn_type_unification (tree fn,\n       bool incomplete = false;\n \n       if (explicit_targs == error_mark_node)\n-\treturn 1;\n+\treturn unify_invalid (explain_p);\n \n       converted_args\n-\t= (coerce_template_parms (tparms, explicit_targs, NULL_TREE, tf_none,\n-\t\t\t\t  /*require_all_args=*/false,\n-\t\t\t\t  /*use_default_args=*/false));\n+\t= (coerce_template_parms (tparms, explicit_targs, NULL_TREE,\n+\t\t\t\t  (explain_p\n+\t\t\t\t   ? tf_warning_or_error\n+\t\t\t\t   : tf_none),\n+\t\t\t\t   /*require_all_args=*/false,\n+\t\t\t\t   /*use_default_args=*/false));\n       if (converted_args == error_mark_node)\n \treturn 1;\n \n@@ -14060,7 +14296,10 @@ fn_type_unification (tree fn,\n         incomplete = NUM_TMPL_ARGS (explicit_targs) != NUM_TMPL_ARGS (targs);\n \n       processing_template_decl += incomplete;\n-      fntype = deduction_tsubst_fntype (fn, converted_args);\n+      fntype = deduction_tsubst_fntype (fn, converted_args,\n+\t\t\t\t\t(explain_p\n+\t\t\t\t\t ? tf_warning_or_error\n+\t\t\t\t\t : tf_none));\n       processing_template_decl -= incomplete;\n \n       if (fntype == error_mark_node)\n@@ -14092,7 +14331,7 @@ fn_type_unification (tree fn,\n      event.  */\n   result = type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n \t\t\t\t  targs, parms, args, nargs, /*subr=*/0,\n-\t\t\t\t  strict, flags);\n+\t\t\t\t  strict, flags, explain_p);\n \n   /* Now that we have bindings for all of the template arguments,\n      ensure that the arguments deduced for the template template\n@@ -14118,7 +14357,7 @@ fn_type_unification (tree fn,\n   if (result == 0\n       && !template_template_parm_bindings_ok_p \n            (DECL_INNERMOST_TEMPLATE_PARMS (fn), targs))\n-    return 1;\n+    return unify_inconsistent_template_template_parameters (explain_p);\n \n   if (result == 0)\n     /* All is well so far.  Now, check:\n@@ -14131,7 +14370,10 @@ fn_type_unification (tree fn,\n        substitution results in an invalid type, as described above,\n        type deduction fails.  */\n     {\n-      tree substed = deduction_tsubst_fntype (fn, targs);\n+      tree substed = deduction_tsubst_fntype (fn, targs,\n+\t\t\t\t\t      (explain_p\n+\t\t\t\t\t       ? tf_warning_or_error\n+\t\t\t\t\t       : tf_none));\n       if (substed == error_mark_node)\n \treturn 1;\n \n@@ -14148,7 +14390,8 @@ fn_type_unification (tree fn,\n \t    sarg = tree_cons (NULL_TREE, TREE_TYPE (substed), sarg);\n \t  for (i = 0; i < nargs && sarg; ++i, sarg = TREE_CHAIN (sarg))\n \t    if (!same_type_p (args[i], TREE_VALUE (sarg)))\n-\t      return 1;\n+\t      return unify_type_mismatch (explain_p, args[i],\n+\t\t\t\t\t  TREE_VALUE (sarg));\n \t}\n     }\n \n@@ -14279,7 +14522,8 @@ type_unification_real (tree tparms,\n \t\t       unsigned int xnargs,\n \t\t       int subr,\n \t\t       unification_kind_t strict,\n-\t\t       int flags)\n+\t\t       int flags,\n+\t\t       bool explain_p)\n {\n   tree parm, arg, arg_expr;\n   int i;\n@@ -14350,7 +14594,7 @@ type_unification_real (tree tparms,\n       arg_expr = NULL;\n \n       if (arg == error_mark_node)\n-\treturn 1;\n+\treturn unify_invalid (explain_p);\n       if (arg == unknown_type_node)\n \t/* We can't deduce anything from this, but we might get all the\n \t   template args from other function args.  */\n@@ -14376,7 +14620,10 @@ type_unification_real (tree tparms,\n \t\t\t\t  flags))\n \t    continue;\n \n-\t  return 1;\n+\t  if (strict == DEDUCE_EXACT)\n+\t    return unify_type_mismatch (explain_p, parm, arg);\n+\t  else\n+\t    return unify_arg_conversion (explain_p, parm, type, arg);\n \t}\n \n       if (!TYPE_P (arg))\n@@ -14392,15 +14639,15 @@ type_unification_real (tree tparms,\n \t\t function templates and at most one of a set of\n \t\t overloaded functions provides a unique match.  */\n \t      if (resolve_overloaded_unification\n-\t\t  (tparms, targs, parm, arg, strict, sub_strict))\n+\t\t  (tparms, targs, parm, arg, strict, sub_strict, explain_p))\n \t\tcontinue;\n \n-\t      return 1;\n+\t      return unify_overload_resolution_failure (explain_p, arg);\n \t    }\n \t  arg_expr = arg;\n \t  arg = unlowered_expr_type (arg);\n \t  if (arg == error_mark_node)\n-\t    return 1;\n+\t    return unify_invalid (explain_p);\n \t}\n \n       {\n@@ -14412,7 +14659,9 @@ type_unification_real (tree tparms,\n \n \tif (arg == init_list_type_node && arg_expr)\n \t  arg = arg_expr;\n-\tif (unify (tparms, targs, parm, arg, arg_strict))\n+\tif (unify (tparms, targs, parm, arg, arg_strict, explain_p))\n+\t  /* If unification failed, the recursive call will have updated\n+\t     UI appropriately.  */\n \t  return 1;\n       }\n     }\n@@ -14434,7 +14683,7 @@ type_unification_real (tree tparms,\n       /* Copy the parameter into parmvec.  */\n       TREE_VEC_ELT (parmvec, 0) = TREE_VALUE (parms);\n       if (unify_pack_expansion (tparms, targs, parmvec, argvec, strict,\n-                                /*call_args_p=*/true, /*subr=*/subr))\n+                                /*call_args_p=*/true, /*subr=*/subr, explain_p))\n         return 1;\n \n       /* Advance to the end of the list of parameters.  */\n@@ -14444,11 +14693,20 @@ type_unification_real (tree tparms,\n   /* Fail if we've reached the end of the parm list, and more args\n      are present, and the parm list isn't variadic.  */\n   if (ia < nargs && parms == void_list_node)\n-    return 1;\n+    return unify_too_many_arguments (explain_p, nargs, ia);\n   /* Fail if parms are left and they don't have default values.  */\n   if (parms && parms != void_list_node\n       && TREE_PURPOSE (parms) == NULL_TREE)\n-    return 1;\n+    {\n+      unsigned int count = nargs;\n+      tree p = parms;\n+      while (p && p != void_list_node)\n+\t{\n+\t  count++;\n+\t  p = TREE_CHAIN (p);\n+\t}\n+      return unify_too_few_arguments (explain_p, ia, count);\n+    }\n \n   if (!subr)\n     {\n@@ -14503,7 +14761,10 @@ type_unification_real (tree tparms,\n \t      tree parm = TREE_VALUE (TREE_VEC_ELT (tparms, i));\n \t      tree arg = TREE_PURPOSE (TREE_VEC_ELT (tparms, i));\n \t      arg = tsubst_template_arg (arg, targs, tf_none, NULL_TREE);\n-\t      arg = convert_template_argument (parm, arg, targs, tf_none,\n+\t      arg = convert_template_argument (parm, arg, targs,\n+\t\t\t\t\t       (explain_p\n+\t\t\t\t\t\t? tf_warning_or_error\n+\t\t\t\t\t\t: tf_none),\n \t\t\t\t\t       i, NULL_TREE);\n \t      if (arg == error_mark_node)\n \t\treturn 1;\n@@ -14540,15 +14801,15 @@ type_unification_real (tree tparms,\n \t      continue;\n \t    }\n \n-\t  return 2;\n+\t  return unify_parameter_deduction_failure (explain_p, tparm);\n \t}\n     }\n #ifdef ENABLE_CHECKING\n   if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs))\n     SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs, TREE_VEC_LENGTH (targs));\n #endif\n \n-  return 0;\n+  return unify_success (explain_p);\n }\n \n /* Subroutine of type_unification_real.  Args are like the variables\n@@ -14563,7 +14824,8 @@ resolve_overloaded_unification (tree tparms,\n \t\t\t\ttree parm,\n \t\t\t\ttree arg,\n \t\t\t\tunification_kind_t strict,\n-\t\t\t\tint sub_strict)\n+\t\t\t\tint sub_strict,\n+\t\t\t        bool explain_p)\n {\n   tree tempargs = copy_node (targs);\n   int good = 0;\n@@ -14615,7 +14877,7 @@ resolve_overloaded_unification (tree tparms,\n \t    {\n \t      elem = tsubst (TREE_TYPE (fn), subargs, tf_none, NULL_TREE);\n \t      if (try_one_overload (tparms, targs, tempargs, parm,\n-\t\t\t\t    elem, strict, sub_strict, addr_p)\n+\t\t\t\t    elem, strict, sub_strict, addr_p, explain_p)\n \t\t  && (!goodfn || !decls_match (goodfn, elem)))\n \t\t{\n \t\t  goodfn = elem;\n@@ -14643,7 +14905,7 @@ resolve_overloaded_unification (tree tparms,\n     for (; arg; arg = OVL_NEXT (arg))\n       if (try_one_overload (tparms, targs, tempargs, parm,\n \t\t\t    TREE_TYPE (OVL_CURRENT (arg)),\n-\t\t\t    strict, sub_strict, addr_p)\n+\t\t\t    strict, sub_strict, addr_p, explain_p)\n \t  && (!goodfn || !decls_match (goodfn, OVL_CURRENT (arg))))\n \t{\n \t  goodfn = OVL_CURRENT (arg);\n@@ -14790,7 +15052,8 @@ try_one_overload (tree tparms,\n \t\t  tree arg,\n \t\t  unification_kind_t strict,\n \t\t  int sub_strict,\n-\t\t  bool addr_p)\n+\t\t  bool addr_p,\n+\t\t  bool explain_p)\n {\n   int nargs;\n   tree tempargs;\n@@ -14820,7 +15083,7 @@ try_one_overload (tree tparms,\n   nargs = TREE_VEC_LENGTH (targs);\n   tempargs = make_tree_vec (nargs);\n \n-  if (unify (tparms, tempargs, parm, arg, sub_strict) != 0)\n+  if (unify (tparms, tempargs, parm, arg, sub_strict, explain_p))\n     return 0;\n \n   /* First make sure we didn't deduce anything that conflicts with\n@@ -14858,7 +15121,8 @@ try_one_overload (tree tparms,\n    TARGS are as for unify.  */\n \n static tree\n-try_class_unification (tree tparms, tree targs, tree parm, tree arg)\n+try_class_unification (tree tparms, tree targs, tree parm, tree arg,\n+\t\t       bool explain_p)\n {\n   tree copy_of_targs;\n \n@@ -14901,7 +15165,7 @@ try_class_unification (tree tparms, tree targs, tree parm, tree arg)\n \n   /* If unification failed, we're done.  */\n   if (unify (tparms, copy_of_targs, CLASSTYPE_TI_ARGS (parm),\n-\t     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE))\n+\t     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE, explain_p))\n     return NULL_TREE;\n \n   return arg;\n@@ -14914,8 +15178,9 @@ try_class_unification (tree tparms, tree targs, tree parm, tree arg)\n    a partial specialization, as well as a plain template type.  Used\n    by unify.  */\n \n-static tree\n-get_template_base (tree tparms, tree targs, tree parm, tree arg)\n+static enum template_base_result\n+get_template_base (tree tparms, tree targs, tree parm, tree arg,\n+\t\t   bool explain_p, tree *result)\n {\n   tree rval = NULL_TREE;\n   tree binfo;\n@@ -14924,14 +15189,18 @@ get_template_base (tree tparms, tree targs, tree parm, tree arg)\n \n   binfo = TYPE_BINFO (complete_type (arg));\n   if (!binfo)\n-    /* The type could not be completed.  */\n-    return NULL_TREE;\n+    {\n+      /* The type could not be completed.  */\n+      *result = NULL_TREE;\n+      return tbr_incomplete_type;\n+    }\n \n   /* Walk in inheritance graph order.  The search order is not\n      important, and this avoids multiple walks of virtual bases.  */\n   for (binfo = TREE_CHAIN (binfo); binfo; binfo = TREE_CHAIN (binfo))\n     {\n-      tree r = try_class_unification (tparms, targs, parm, BINFO_TYPE (binfo));\n+      tree r = try_class_unification (tparms, targs, parm,\n+\t\t\t\t      BINFO_TYPE (binfo), explain_p);\n \n       if (r)\n \t{\n@@ -14944,13 +15213,17 @@ get_template_base (tree tparms, tree targs, tree parm, tree arg)\n \n \t     applies.  */\n \t  if (rval && !same_type_p (r, rval))\n-\t    return NULL_TREE;\n+\t    {\n+\t      *result = NULL_TREE;\n+\t      return tbr_ambiguous_baseclass;\n+\t    }\n \n \t  rval = r;\n \t}\n     }\n \n-  return rval;\n+  *result = rval;\n+  return tbr_success;\n }\n \n /* Returns the level of DECL, which declares a template parameter.  */\n@@ -15032,17 +15305,23 @@ template_parm_level_and_index (tree parm, int* level, int* index)\n     }\n }\n \n+#define RECUR_AND_CHECK_FAILURE(TP, TA, P, A, S, EP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (unify (TP, TA, P, A, S, EP))\t\t\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+  } while (0);\n+\n /* Unifies the remaining arguments in PACKED_ARGS with the pack\n    expansion at the end of PACKED_PARMS. Returns 0 if the type\n    deduction succeeds, 1 otherwise. STRICT is the same as in\n    unify. CALL_ARGS_P is true iff PACKED_ARGS is actually a function\n    call argument list. We'll need to adjust the arguments to make them\n    types. SUBR tells us if this is from a recursive call to\n    type_unification_real.  */\n-int\n+static int\n unify_pack_expansion (tree tparms, tree targs, tree packed_parms, \n                       tree packed_args, int strict, bool call_args_p,\n-                      bool subr)\n+                      bool subr, bool explain_p)\n {\n   tree parm \n     = TREE_VEC_ELT (packed_parms, TREE_VEC_LENGTH (packed_parms) - 1);\n@@ -15132,7 +15411,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n                     if (resolve_overloaded_unification\n                         (tparms, targs, parm, arg,\n \t\t\t (unification_kind_t) strict,\n-\t\t\t sub_strict)\n+\t\t\t sub_strict, explain_p)\n                         != 0)\n                       return 1;\n                     skip_arg_p = true;\n@@ -15160,8 +15439,8 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n \t    /* For deduction from an init-list we need the actual list.  */\n \t    if (arg_expr && BRACE_ENCLOSED_INITIALIZER_P (arg_expr))\n \t      arg = arg_expr;\n-            if (unify (tparms, targs, parm, arg, arg_strict))\n-              return 1;\n+\t    RECUR_AND_CHECK_FAILURE (tparms, targs, parm, arg, arg_strict,\n+\t\t\t\t     explain_p);\n           }\n       }\n \n@@ -15252,13 +15531,21 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n           ARGUMENT_PACK_INCOMPLETE_P (old_pack) = 1;\n           ARGUMENT_PACK_EXPLICIT_ARGS (old_pack) = explicit_args;\n         }\n-      else if (!comp_template_args (ARGUMENT_PACK_ARGS (old_pack),\n-                                    new_args))\n-        /* Inconsistent unification of this parameter pack.  */\n-        return 1;\n+      else\n+\t{\n+\t  tree bad_old_arg, bad_new_arg;\n+\t  tree old_args = ARGUMENT_PACK_ARGS (old_pack);\n+\n+\t  if (!comp_template_args_with_info (old_args, new_args,\n+\t\t\t\t\t     &bad_old_arg, &bad_new_arg))\n+\t    /* Inconsistent unification of this parameter pack.  */\n+\t    return unify_parameter_pack_inconsistent (explain_p,\n+\t\t\t\t\t\t      bad_old_arg,\n+\t\t\t\t\t\t      bad_new_arg);\n+\t}\n     }\n \n-  return 0;\n+  return unify_success (explain_p);\n }\n \n /* Deduce the value of template parameters.  TPARMS is the (innermost)\n@@ -15303,7 +15590,8 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n        qualified at this point.  */\n \n static int\n-unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n+unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n+       bool explain_p)\n {\n   int idx;\n   tree targ;\n@@ -15318,19 +15606,19 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n     parm = TREE_OPERAND (parm, 0);\n \n   if (arg == error_mark_node)\n-    return 1;\n+    return unify_invalid (explain_p);\n   if (arg == unknown_type_node\n       || arg == init_list_type_node)\n     /* We can't deduce anything from this, but we might get all the\n        template args from other function args.  */\n-    return 0;\n+    return unify_success (explain_p);\n \n   /* If PARM uses template parameters, then we can't bail out here,\n      even if ARG == PARM, since we won't record unifications for the\n      template parameters.  We might need them if we're trying to\n      figure out which of two things is more specialized.  */\n   if (arg == parm && !uses_template_parms (parm))\n-    return 0;\n+    return unify_success (explain_p);\n \n   /* Handle init lists early, so the rest of the function can assume\n      we're dealing with a type. */\n@@ -15349,7 +15637,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t/* We can only deduce from an initializer list argument if the\n \t   parameter is std::initializer_list; otherwise this is a\n \t   non-deduced context. */\n-\treturn 0;\n+\treturn unify_success (explain_p);\n \n       elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (parm), 0);\n \n@@ -15358,7 +15646,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  int elt_strict = strict;\n \n \t  if (elt == error_mark_node)\n-\t    return 1;\n+\t    return unify_invalid (explain_p);\n \n \t  if (!BRACE_ENCLOSED_INITIALIZER_P (elt))\n \t    {\n@@ -15370,8 +15658,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t      elt = type;\n \t    }\n \n-\t  if (unify (tparms, targs, elttype, elt, elt_strict))\n-\t    return 1;\n+\t  RECUR_AND_CHECK_FAILURE (tparms, targs, elttype, elt, elt_strict,\n+\t\t\t\t   explain_p);\n \t}\n \n       /* If the std::initializer_list<T> deduction worked, replace the\n@@ -15383,7 +15671,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  targ = listify (targ);\n \t  TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = targ;\n \t}\n-      return 0;\n+      return unify_success (explain_p);\n     }\n \n   /* Immediately reject some pairs that won't unify because of\n@@ -15400,7 +15688,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t is more specialized, for example.  */\n       && TREE_CODE (arg) != TEMPLATE_TYPE_PARM\n       && !check_cv_quals_for_unify (strict_in, arg, parm))\n-    return 1;\n+    return unify_cv_qual_mismatch (explain_p, parm, arg);\n \n   if (!(strict & UNIFY_ALLOW_OUTER_LEVEL)\n       && TYPE_P (parm) && !CP_TYPE_CONST_P (parm))\n@@ -15418,21 +15706,26 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       /* In a type which contains a nested-name-specifier, template\n \t argument values cannot be deduced for template parameters used\n \t within the nested-name-specifier.  */\n-      return 0;\n+      return unify_success (explain_p);\n \n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, 0));\n       if (tparm == error_mark_node)\n-\treturn 1;\n+\treturn unify_invalid (explain_p);\n \n       if (TEMPLATE_TYPE_LEVEL (parm)\n \t  != template_decl_level (tparm))\n \t/* The PARM is not one we're trying to unify.  Just check\n \t   to see if it matches ARG.  */\n-\treturn (TREE_CODE (arg) == TREE_CODE (parm)\n-\t\t&& same_type_p (parm, arg)) ? 0 : 1;\n+\t{\n+\t  if (TREE_CODE (arg) == TREE_CODE (parm)\n+\t      && same_type_p (parm, arg))\n+\t    return unify_success (explain_p);\n+\t  else\n+\t    return unify_type_mismatch (explain_p, parm, arg);\n+\t}\n       idx = TEMPLATE_TYPE_IDX (parm);\n       targ = TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx);\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, idx));\n@@ -15442,15 +15735,15 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t   && TREE_CODE (tparm) != TYPE_DECL)\n \t  || (TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM\n \t      && TREE_CODE (tparm) != TEMPLATE_DECL))\n-\treturn 1;\n+\tgcc_unreachable ();\n \n       if (TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t{\n \t  /* ARG must be constructed from a template class or a template\n \t     template parameter.  */\n \t  if (TREE_CODE (arg) != BOUND_TEMPLATE_TEMPLATE_PARM\n \t      && !CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P (arg))\n-\t    return 1;\n+\t    return unify_template_deduction_failure (explain_p, parm, arg);\n \n \t  {\n \t    tree parmvec = TYPE_TI_ARGS (parm);\n@@ -15492,7 +15785,9 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t    if (coerce_template_parms (parm_parms,\n                                        full_argvec,\n \t\t\t\t       TYPE_TI_TEMPLATE (parm),\n-\t\t\t\t       tf_none,\n+\t\t\t\t       (explain_p\n+\t\t\t\t\t? tf_warning_or_error\n+\t\t\t\t\t: tf_none),\n \t\t\t\t       /*require_all_args=*/true,\n \t\t\t\t       /*use_default_args=*/false)\n \t\t== error_mark_node)\n@@ -15515,23 +15810,23 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n               parm_variadic_p = 1;\n             \n             if (TREE_VEC_LENGTH (argvec) < len - parm_variadic_p)\n-              return 1;\n+              return unify_too_few_arguments (explain_p,\n+\t\t\t\t\t      TREE_VEC_LENGTH (argvec), len);\n \n              for (i = 0; i < len - parm_variadic_p; ++i)\n \t      {\n-\t\tif (unify (tparms, targs,\n-\t\t\t   TREE_VEC_ELT (parmvec, i),\n-\t\t\t   TREE_VEC_ELT (argvec, i),\n-\t\t\t   UNIFY_ALLOW_NONE))\n-\t\t  return 1;\n+\t\tRECUR_AND_CHECK_FAILURE (tparms, targs,\n+\t\t\t\t\t TREE_VEC_ELT (parmvec, i),\n+\t\t\t\t\t TREE_VEC_ELT (argvec, i),\n+\t\t\t\t\t UNIFY_ALLOW_NONE, explain_p);\n \t      }\n \n \t    if (parm_variadic_p\n \t\t&& unify_pack_expansion (tparms, targs,\n \t\t\t\t\t parmvec, argvec,\n \t\t\t\t\t UNIFY_ALLOW_NONE,\n \t\t\t\t\t /*call_args_p=*/false,\n-\t\t\t\t\t /*subr=*/false))\n+\t\t\t\t\t /*subr=*/false, explain_p))\n \t      return 1;\n \t  }\n \t  arg = TYPE_TI_TEMPLATE (arg);\n@@ -15546,9 +15841,9 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n \t  /* Simple cases: Value already set, does match or doesn't.  */\n \t  if (targ != NULL_TREE && template_args_equal (targ, arg))\n-\t    return 0;\n+\t    return unify_success (explain_p);\n \t  else if (targ)\n-\t    return 1;\n+\t    return unify_inconsistency (explain_p, parm, targ, arg);\n \t}\n       else\n \t{\n@@ -15558,20 +15853,20 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t     that binds `const int' to `T'.  */\n \t  if (!check_cv_quals_for_unify (strict_in | UNIFY_ALLOW_LESS_CV_QUAL,\n \t\t\t\t\t arg, parm))\n-\t    return 1;\n+\t    return unify_cv_qual_mismatch (explain_p, parm, arg);\n \n \t  /* Consider the case where ARG is `const volatile int' and\n \t     PARM is `const T'.  Then, T should be `volatile int'.  */\n \t  arg = cp_build_qualified_type_real\n \t    (arg, cp_type_quals (arg) & ~cp_type_quals (parm), tf_none);\n \t  if (arg == error_mark_node)\n-\t    return 1;\n+\t    return unify_invalid (explain_p);\n \n \t  /* Simple cases: Value already set, does match or doesn't.  */\n \t  if (targ != NULL_TREE && same_type_p (targ, arg))\n-\t    return 0;\n+\t    return unify_success (explain_p);\n \t  else if (targ)\n-\t    return 1;\n+\t    return unify_inconsistency (explain_p, parm, targ, arg);\n \n \t  /* Make sure that ARG is not a variable-sized array.  (Note\n \t     that were talking about variable-sized arrays (like\n@@ -15581,7 +15876,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t     instantiation.  Besides, such types are not allowed in\n \t     ISO C++, so we can do as we please here.  */\n \t  if (variably_modified_type_p (arg, NULL_TREE))\n-\t    return 1;\n+\t    return unify_vla_arg (explain_p, arg);\n \n \t  /* Strip typedefs as in convert_template_argument.  */\n \t  arg = canonicalize_type_argument (arg, tf_none);\n@@ -15591,35 +15886,45 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t against it unless PARM is also a parameter pack.  */\n       if ((template_parameter_pack_p (arg) || PACK_EXPANSION_P (arg))\n \t  && !template_parameter_pack_p (parm))\n-\treturn 1;\n+\treturn unify_parameter_pack_mismatch (explain_p, parm, arg);\n \n       /* If the argument deduction results is a METHOD_TYPE,\n          then there is a problem.\n          METHOD_TYPE doesn't map to any real C++ type the result of\n \t the deduction can not be of that type.  */\n       if (TREE_CODE (arg) == METHOD_TYPE)\n-\treturn 1;\n+\treturn unify_method_type_error (explain_p, arg);\n \n       TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;\n-      return 0;\n+      return unify_success (explain_p);\n \n     case TEMPLATE_PARM_INDEX:\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, 0));\n       if (tparm == error_mark_node)\n-\treturn 1;\n+\treturn unify_invalid (explain_p);\n \n       if (TEMPLATE_PARM_LEVEL (parm)\n \t  != template_decl_level (tparm))\n-\t/* The PARM is not one we're trying to unify.  Just check\n-\t   to see if it matches ARG.  */\n-\treturn !(TREE_CODE (arg) == TREE_CODE (parm)\n-\t\t && cp_tree_equal (parm, arg));\n+\t{\n+\t  /* The PARM is not one we're trying to unify.  Just check\n+\t     to see if it matches ARG.  */\n+\t  int result = !(TREE_CODE (arg) == TREE_CODE (parm)\n+\t\t\t && cp_tree_equal (parm, arg));\n+\t  if (result)\n+\t    unify_expression_unequal (explain_p, parm, arg);\n+\t  return result;\n+\t}\n \n       idx = TEMPLATE_PARM_IDX (parm);\n       targ = TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx);\n \n       if (targ)\n-\treturn !cp_tree_equal (targ, arg);\n+\t{\n+\t  int x = !cp_tree_equal (targ, arg);\n+\t  if (x)\n+\t    unify_inconsistency (explain_p, parm, targ, arg);\n+\t  return x;\n+\t}\n \n       /* [temp.deduct.type] If, in the declaration of a function template\n \t with a non-type template-parameter, the non-type\n@@ -15646,25 +15951,25 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       else if (uses_template_parms (tparm))\n \t/* We haven't deduced the type of this parameter yet.  Try again\n \t   later.  */\n-\treturn 0;\n+\treturn unify_success (explain_p);\n       else\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, tparm, arg);\n \n       /* If ARG is a parameter pack or an expansion, we cannot unify\n \t against it unless PARM is also a parameter pack.  */\n       if ((template_parameter_pack_p (arg) || PACK_EXPANSION_P (arg))\n \t  && !TEMPLATE_PARM_PARAMETER_PACK (parm))\n-\treturn 1;\n+\treturn unify_parameter_pack_mismatch (explain_p, parm, arg);\n \n       TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;\n-      return 0;\n+      return unify_success (explain_p);\n \n     case PTRMEM_CST:\n      {\n \t/* A pointer-to-member constant can be unified only with\n \t another constant.  */\n       if (TREE_CODE (arg) != PTRMEM_CST)\n-\treturn 1;\n+\treturn unify_ptrmem_cst_mismatch (explain_p, parm, arg);\n \n       /* Just unify the class member. It would be useless (and possibly\n \t wrong, depending on the strict flags) to unify also\n@@ -15677,13 +15982,13 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n \t Unification of &A::x and &B::x must succeed.  */\n       return unify (tparms, targs, PTRMEM_CST_MEMBER (parm),\n-\t\t    PTRMEM_CST_MEMBER (arg), strict);\n+\t\t    PTRMEM_CST_MEMBER (arg), strict, explain_p);\n      }\n \n     case POINTER_TYPE:\n       {\n \tif (TREE_CODE (arg) != POINTER_TYPE)\n-\t  return 1;\n+\t  return unify_type_mismatch (explain_p, parm, arg);\n \n \t/* [temp.deduct.call]\n \n@@ -15701,21 +16006,21 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  strict |= (strict_in & UNIFY_ALLOW_DERIVED);\n \n \treturn unify (tparms, targs, TREE_TYPE (parm),\n-\t\t      TREE_TYPE (arg), strict);\n+\t\t      TREE_TYPE (arg), strict, explain_p);\n       }\n \n     case REFERENCE_TYPE:\n       if (TREE_CODE (arg) != REFERENCE_TYPE)\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict & UNIFY_ALLOW_MORE_CV_QUAL);\n+\t\t    strict & UNIFY_ALLOW_MORE_CV_QUAL, explain_p);\n \n     case ARRAY_TYPE:\n       if (TREE_CODE (arg) != ARRAY_TYPE)\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n       if ((TYPE_DOMAIN (parm) == NULL_TREE)\n \t  != (TYPE_DOMAIN (arg) == NULL_TREE))\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n       if (TYPE_DOMAIN (parm) != NULL_TREE)\n \t{\n \t  tree parm_max;\n@@ -15754,7 +16059,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n                 Here, the type of the ARG will be \"int [g(i)]\", and\n                 may be a SAVE_EXPR, etc.  */\n \t      if (TREE_CODE (arg_max) != MINUS_EXPR)\n-\t\treturn 1;\n+\t\treturn unify_vla_arg (explain_p, arg);\n \t      arg_max = TREE_OPERAND (arg_max, 0);\n \t    }\n \n@@ -15771,11 +16076,11 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t\t\t   arg_max,\n \t\t\t\t   integer_one_node);\n \n-\t  if (unify (tparms, targs, parm_max, arg_max, UNIFY_ALLOW_INTEGER))\n-\t    return 1;\n+\t  RECUR_AND_CHECK_FAILURE (tparms, targs, parm_max, arg_max,\n+\t\t\t\t   UNIFY_ALLOW_INTEGER, explain_p);\n \t}\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict & UNIFY_ALLOW_MORE_CV_QUAL);\n+\t\t    strict & UNIFY_ALLOW_MORE_CV_QUAL, explain_p);\n \n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n@@ -15785,16 +16090,16 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n     case ENUMERAL_TYPE:\n     case VOID_TYPE:\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n \n       /* We have already checked cv-qualification at the top of the\n \t function.  */\n       if (!same_type_ignoring_top_level_qualifiers_p (arg, parm))\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n \n       /* As far as unification is concerned, this wins.\t Later checks\n \t will invalidate it if necessary.  */\n-      return 0;\n+      return unify_success (explain_p);\n \n       /* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */\n       /* Type INTEGER_CST can come from ordinary constant template args.  */\n@@ -15803,38 +16108,41 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \targ = TREE_OPERAND (arg, 0);\n \n       if (TREE_CODE (arg) != INTEGER_CST)\n-\treturn 1;\n-      return !tree_int_cst_equal (parm, arg);\n+\treturn unify_template_argument_mismatch (explain_p, parm, arg);\n+      return (tree_int_cst_equal (parm, arg)\n+\t      ? unify_success (explain_p)\n+\t      : unify_template_argument_mismatch (explain_p, parm, arg));\n \n     case TREE_VEC:\n       {\n \tint i;\n \tif (TREE_CODE (arg) != TREE_VEC)\n-\t  return 1;\n+\t  return unify_template_argument_mismatch (explain_p, parm, arg);\n \tif (TREE_VEC_LENGTH (parm) != TREE_VEC_LENGTH (arg))\n-\t  return 1;\n+\t  return unify_arity (explain_p, TREE_VEC_LENGTH (arg),\n+\t\t\t      TREE_VEC_LENGTH (parm));\n \tfor (i = 0; i < TREE_VEC_LENGTH (parm); ++i)\n-\t  if (unify (tparms, targs,\n-\t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n-\t\t     UNIFY_ALLOW_NONE))\n-\t    return 1;\n-\treturn 0;\n+\t  RECUR_AND_CHECK_FAILURE (tparms, targs,\n+\t\t\t\t   TREE_VEC_ELT (parm, i),\n+\t\t\t\t   TREE_VEC_ELT (arg, i),\n+\t\t\t\t   UNIFY_ALLOW_NONE, explain_p);\n+\treturn unify_success (explain_p);\n       }\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n \n       if (TYPE_PTRMEMFUNC_P (parm))\n \t{\n \t  if (!TYPE_PTRMEMFUNC_P (arg))\n-\t    return 1;\n+\t    return unify_type_mismatch (explain_p, parm, arg);\n \n \t  return unify (tparms, targs,\n \t\t\tTYPE_PTRMEMFUNC_FN_TYPE (parm),\n \t\t\tTYPE_PTRMEMFUNC_FN_TYPE (arg),\n-\t\t\tstrict);\n+\t\t\tstrict, explain_p);\n \t}\n \n       if (CLASSTYPE_TEMPLATE_INFO (parm))\n@@ -15845,7 +16153,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t    {\n \t      /* First, we try to unify the PARM and ARG directly.  */\n \t      t = try_class_unification (tparms, targs,\n-\t\t\t\t\t parm, arg);\n+\t\t\t\t\t parm, arg, explain_p);\n \n \t      if (!t)\n \t\t{\n@@ -15858,10 +16166,12 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t       a class of the form template-id, A can be a\n \t\t       pointer to a derived class pointed to by the\n \t\t       deduced A.  */\n-\t\t  t = get_template_base (tparms, targs, parm, arg);\n+\t\t  enum template_base_result r;\n+\t\t  r = get_template_base (tparms, targs, parm, arg,\n+\t\t\t\t\t explain_p, &t);\n \n \t\t  if (!t)\n-\t\t    return 1;\n+\t\t    return unify_no_common_base (explain_p, r, parm, arg);\n \t\t}\n \t    }\n \t  else if (CLASSTYPE_TEMPLATE_INFO (arg)\n@@ -15872,14 +16182,14 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t    t = arg;\n \t  else\n \t    /* There's no chance of unification succeeding.  */\n-\t    return 1;\n+\t    return unify_type_mismatch (explain_p, parm, arg);\n \n \t  return unify (tparms, targs, CLASSTYPE_TI_ARGS (parm),\n-\t\t\tCLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE);\n+\t\t\tCLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE, explain_p);\n \t}\n       else if (!same_type_ignoring_top_level_qualifiers_p (parm, arg))\n-\treturn 1;\n-      return 0;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n+      return unify_success (explain_p);\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n@@ -15890,7 +16200,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \tunsigned int i;\n \n \tif (TREE_CODE (arg) != TREE_CODE (parm))\n-\t  return 1;\n+\t  return unify_type_mismatch (explain_p, parm, arg);\n \n \t/* CV qualifications for methods can never be deduced, they must\n \t   match exactly.  We need to check them explicitly here,\n@@ -15901,11 +16211,10 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t(UNIFY_ALLOW_NONE,\n \t\t class_of_this_parm (arg),\n \t\t class_of_this_parm (parm))))\n-\t  return 1;\n+\t  return unify_cv_qual_mismatch (explain_p, parm, arg);\n \n-\tif (unify (tparms, targs, TREE_TYPE (parm),\n-\t\t   TREE_TYPE (arg), UNIFY_ALLOW_NONE))\n-\t  return 1;\n+\tRECUR_AND_CHECK_FAILURE (tparms, targs, TREE_TYPE (parm),\n+\t\t\t\t TREE_TYPE (arg), UNIFY_ALLOW_NONE, explain_p);\n \n \tnargs = list_length (TYPE_ARG_TYPES (arg));\n \targs = XALLOCAVEC (tree, nargs);\n@@ -15917,7 +16226,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n \treturn type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t\t      args, nargs, 1, DEDUCE_EXACT,\n-\t\t\t\t      LOOKUP_NORMAL);\n+\t\t\t\t      LOOKUP_NORMAL, explain_p);\n       }\n \n     case OFFSET_TYPE:\n@@ -15930,11 +16239,11 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n \t  /* Check top-level cv qualifiers */\n \t  if (!check_cv_quals_for_unify (UNIFY_ALLOW_NONE, arg, parm))\n-\t    return 1;\n+\t    return unify_cv_qual_mismatch (explain_p, parm, arg);\n \n-\t  if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n-\t\t     TYPE_PTRMEMFUNC_OBJECT_TYPE (arg), UNIFY_ALLOW_NONE))\n-\t    return 1;\n+\t  RECUR_AND_CHECK_FAILURE (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n+\t\t\t\t   TYPE_PTRMEMFUNC_OBJECT_TYPE (arg),\n+\t\t\t\t   UNIFY_ALLOW_NONE, explain_p);\n \n \t  /* Determine the type of the function we are unifying against. */\n \t  method_type = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (arg));\n@@ -15946,28 +16255,28 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t     implicit object parameter and place them on the function\n \t     type to be restored later. */\n \t  fntype = apply_memfn_quals (fntype, type_memfn_quals (method_type));\n-\t  return unify (tparms, targs, TREE_TYPE (parm), fntype, strict);\n+\t  return unify (tparms, targs, TREE_TYPE (parm), fntype, strict, explain_p);\n \t}\n \n       if (TREE_CODE (arg) != OFFSET_TYPE)\n-\treturn 1;\n-      if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n-\t\t TYPE_OFFSET_BASETYPE (arg), UNIFY_ALLOW_NONE))\n-\treturn 1;\n+\treturn unify_type_mismatch (explain_p, parm, arg);\n+      RECUR_AND_CHECK_FAILURE (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n+\t\t\t       TYPE_OFFSET_BASETYPE (arg),\n+\t\t\t       UNIFY_ALLOW_NONE, explain_p);\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict);\n+\t\t    strict, explain_p);\n \n     case CONST_DECL:\n       if (DECL_TEMPLATE_PARM_P (parm))\n-\treturn unify (tparms, targs, DECL_INITIAL (parm), arg, strict);\n+\treturn unify (tparms, targs, DECL_INITIAL (parm), arg, strict, explain_p);\n       if (arg != integral_constant_value (parm))\n-\treturn 1;\n-      return 0;\n+\treturn unify_template_argument_mismatch (explain_p, parm, arg);\n+      return unify_success (explain_p);\n \n     case FIELD_DECL:\n     case TEMPLATE_DECL:\n       /* Matched cases are handled by the ARG == PARM test above.  */\n-      return 1;\n+      return unify_template_argument_mismatch (explain_p, parm, arg);\n \n     case VAR_DECL:\n       /* A non-type template parameter that is a variable should be a\n@@ -15997,7 +16306,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t  /* Since there is something following the pack\n \t\t     expansion, we cannot unify this template argument\n \t\t     list.  */\n-\t\t  return 0;\n+\t\t  return unify_success (explain_p);\n \t      }\n \t  }\n \t  \n@@ -16006,25 +16315,27 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n            (not counting the pack expression at the end), or we have\n            too many arguments for a parameter list that doesn't end in\n            a pack expression, we can't unify.  */\n-        if (argslen < (len - parm_variadic_p)\n-            || (argslen > len && !parm_variadic_p))\n-          return 1;\n+        if (argslen < (len - parm_variadic_p))\n+\t  return unify_too_few_arguments (explain_p, argslen, len);\n+\tif (argslen > len && !parm_variadic_p)\n+\t  return unify_too_many_arguments (explain_p, argslen, len);\n \n         /* Unify all of the parameters that precede the (optional)\n            pack expression.  */\n         for (i = 0; i < len - parm_variadic_p; ++i)\n           {\n-            if (unify (tparms, targs, TREE_VEC_ELT (packed_parms, i),\n-                       TREE_VEC_ELT (packed_args, i), strict))\n-              return 1;\n+\t    RECUR_AND_CHECK_FAILURE (tparms, targs,\n+\t\t\t\t     TREE_VEC_ELT (packed_parms, i),\n+\t\t\t\t     TREE_VEC_ELT (packed_args, i),\n+\t\t\t\t     strict, explain_p);\n           }\n \n         if (parm_variadic_p)\n           return unify_pack_expansion (tparms, targs, \n                                        packed_parms, packed_args,\n                                        strict, /*call_args_p=*/false,\n-                                       /*subr=*/false);\n-        return 0;\n+                                       /*subr=*/false, explain_p);\n+        return unify_success (explain_p);\n       }\n \n       break;\n@@ -16034,16 +16345,16 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n     case UNDERLYING_TYPE:\n       /* Cannot deduce anything from TYPEOF_TYPE, DECLTYPE_TYPE,\n \t or UNDERLYING_TYPE nodes.  */\n-      return 0;\n+      return unify_success (explain_p);\n \n     case ERROR_MARK:\n       /* Unification fails if we hit an error node.  */\n-      return 1;\n+      return unify_invalid (explain_p);\n \n     default:\n       /* An unresolved overload is a nondeduced context.  */\n       if (type_unknown_p (parm))\n-\treturn 0;\n+\treturn unify_success (explain_p);\n       gcc_assert (EXPR_P (parm));\n \n       /* We must be looking at an expression.  This can happen with\n@@ -16067,11 +16378,12 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n       if (!uses_template_parms (parm)\n \t  && !template_args_equal (parm, arg))\n-\treturn 1;\n+\treturn unify_expression_unequal (explain_p, parm, arg);\n       else\n-\treturn 0;\n+\treturn unify_success (explain_p);\n     }\n }\n+#undef RECUR_AND_CHECK_FAILURE\n \f\n /* Note that DECL can be defined in this translation unit, if\n    required.  */\n@@ -16334,10 +16646,11 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n           for (i = 0; i < len2; i++, ta = TREE_CHAIN (ta))\n             TREE_VEC_ELT (argvec, i) = TREE_VALUE (ta);\n \n-          deduce1 = !unify_pack_expansion (tparms1, targs1, parmvec, \n+          deduce1 = (unify_pack_expansion (tparms1, targs1, parmvec,\n \t\t\t\t\t   argvec, UNIFY_ALLOW_NONE, \n                                            /*call_args_p=*/false, \n-\t\t\t\t\t   /*subr=*/0);\n+\t\t\t\t\t   /*subr=*/0, /*explain_p=*/false)\n+\t\t     == 0);\n \n           /* We cannot deduce in the other direction, because ARG1 is\n              a pack expansion but ARG2 is not.  */\n@@ -16358,10 +16671,11 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n           for (i = 0; i < len1; i++, ta = TREE_CHAIN (ta))\n             TREE_VEC_ELT (argvec, i) = TREE_VALUE (ta);\n \n-          deduce2 = !unify_pack_expansion (tparms2, targs2, parmvec, \n+          deduce2 = (unify_pack_expansion (tparms2, targs2, parmvec,\n \t\t\t\t\t   argvec, UNIFY_ALLOW_NONE, \n                                            /*call_args_p=*/false, \n-\t\t\t\t\t   /*subr=*/0);\n+\t\t\t\t\t   /*subr=*/0, /*explain_p=*/false)\n+\t\t     == 0);\n \n           /* We cannot deduce in the other direction, because ARG2 is\n              a pack expansion but ARG1 is not.*/\n@@ -16372,8 +16686,12 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n         {\n           /* The normal case, where neither argument is a pack\n              expansion.  */\n-          deduce1 = !unify (tparms1, targs1, arg1, arg2, UNIFY_ALLOW_NONE);\n-          deduce2 = !unify (tparms2, targs2, arg2, arg1, UNIFY_ALLOW_NONE);\n+          deduce1 = (unify (tparms1, targs1, arg1, arg2,\n+\t\t\t    UNIFY_ALLOW_NONE, /*explain_p=*/false)\n+\t\t     == 0);\n+          deduce2 = (unify (tparms2, targs2, arg2, arg1,\n+\t\t\t    UNIFY_ALLOW_NONE, /*explain_p=*/false)\n+\t\t     == 0);\n         }\n \n       /* If we couldn't deduce arguments for tparms1 to make arg1 match\n@@ -16587,7 +16905,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n \t\t\t   args, ix,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n \t\t\t    ? TREE_TYPE (decl_type) : NULL_TREE),\n-\t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL))\n+\t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL, /*explain_p=*/false))\n     return NULL_TREE;\n \n   return targs;\n@@ -16629,7 +16947,7 @@ get_class_bindings (tree tparms, tree spec_args, tree args)\n   if (unify (tparms, deduced_args,\n \t     INNERMOST_TEMPLATE_ARGS (spec_args),\n \t     INNERMOST_TEMPLATE_ARGS (args),\n-\t     UNIFY_ALLOW_NONE))\n+\t     UNIFY_ALLOW_NONE, /*explain_p=*/false))\n     return NULL_TREE;\n \n   for (i =  0; i < ntparms; ++i)\n@@ -19436,7 +19754,8 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n   TREE_VEC_ELT (tparms, 0)\n     = build_tree_list (NULL_TREE, TYPE_NAME (auto_node));\n   val = type_unification_real (tparms, targs, parms, args, 1, 0,\n-\t\t\t       DEDUCE_CALL, LOOKUP_NORMAL);\n+\t\t\t       DEDUCE_CALL, LOOKUP_NORMAL,\n+\t\t\t       /*explain_p=*/false);\n   if (val > 0)\n     {\n       if (processing_template_decl)"}, {"sha": "1c00214e92974829b7056a5548027f39ba41d7d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -1,3 +1,61 @@\n+2011-07-16  Nathan Froyd  <froydnj@codesourcery.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/45329\n+\tPR c++/48934\n+\t* g++.dg/cpp0x/decltype29.C: Adjust.\n+\t* g++.dg/cpp0x/error4.C: Adjust.\n+\t* g++.dg/cpp0x/sfinae26.C: Adjust.\n+\t* g++.dg/cpp0x/variadic105.C: Adjust.\n+\t* g++.dg/template/deduce3.C: Adjust.\n+\t* g++.dg/template/error45.C: Adjust.\n+\t* g++.dg/template/ptrmem2.C: Adjust.\n+\t* g++.dg/template/sfinae2.C: Adjust.\n+\t* g++.old-deja/g++.pt/crash60.C: Adjust.\n+\t* g++.old-deja/g++.pt/unify6.C: Adjust.\n+\t* g++.dg/cpp0x/lambda/lambda-ice2.C: Adjust.\n+\t* g++.dg/cpp0x/nullptr15.C: Adjust.\n+\t* g++.dg/cpp0x/pr31431-2.C: Adjust.\n+\t* g++.dg/cpp0x/pr31431.C: Adjust.\n+\t* g++.dg/cpp0x/pr31434.C: Adjust.\n+\t* g++.dg/cpp0x/sfinae11.C: Adjust\n+\t* g++.dg/cpp0x/temp_default2.C: Adjust.\n+\t* g++.dg/cpp0x/trailing4.C: Adjust.\n+\t* g++.dg/cpp0x/variadic-ex3.C: Adjust.\n+\t* g++.dg/cpp0x/variadic-ex4.C: Adjust.\n+\t* g++.dg/cpp0x/variadic105.C: Adjust.\n+\t* g++.dg/cpp0x/vt-37737-2.C: Adjust.\n+\t* g++.dg/ext/vla2.C: Adjust.\n+\t* g++.dg/other/ptrmem10.C: Adjust.\n+\t* g++.dg/other/ptrmem11.C: Adjust.\n+\t* g++.dg/overload/unknown1.C: Adjust.\n+\t* g++.dg/template/conv11.C: Adjust.\n+\t* g++.dg/template/dependent-expr5.C: Adjust.\n+\t* g++.dg/template/friend.C: Adjust.\n+\t* g++.dg/template/incomplete2.C: Adjust.\n+\t* g++.dg/template/local4.C: Adjust.\n+\t* g++.dg/template/local6.C: Adjust.\n+\t* g++.dg/template/operator9.C: Adjust.\n+\t* g++.dg/template/ttp25.C: Adjust.\n+\t* g++.dg/template/unify10.C: Adjust.\n+\t* g++.dg/template/unify11.C: Adjust.\n+\t* g++.dg/template/unify6.C: Adjust.\n+\t* g++.dg/template/unify9.C: Adjust.\n+\t* g++.dg/template/varmod1.C: Adjust.\n+\t* g++.old-deja/g++.brendan/crash56.C: Adjust.\n+\t* g++.old-deja/g++.pt/crash28.C: Adjust.\n+\t* g++.old-deja/g++.pt/explicit41.C: Adjust.\n+\t* g++.old-deja/g++.pt/explicit77.C: Adjust.\n+\t* g++.old-deja/g++.pt/expr2.C: Adjust.\n+\t* g++.old-deja/g++.pt/ptrmem6.C: Adjust.\n+\t* g++.old-deja/g++.pt/spec5.C: Adjust.\n+\t* g++.old-deja/g++.pt/spec6.C: Adjust.\n+\t* g++.old-deja/g++.pt/unify4.C: Adjust.\n+\t* g++.old-deja/g++.pt/unify8.C: Adjust.\n+\t* g++.old-deja/g++.robertl/eb98.C: Adjust.\n+\t* g++.dg/overload/template5.C: New testcase.\n+\t* g++.dg/template/overload12.C: New testcase.\n+\n 2011-07-11  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray_14.f90: Remove dg-error \"sorry not implemented\"."}, {"sha": "70fe4412dcb00c25705ede35d1f9555a8b3cd3c5", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype29.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -13,7 +13,7 @@ decltype (ft<F> (F()))\n ft() {}\t\t\t\t// { dg-error \"depth\" }\n \n int main() {\n-    ft<struct a*, 0>();\t\t// { dg-error \"no match\" }\n+    ft<struct a*, 0>();\t\t// { dg-error \"no match|wrong number\" }\n }\n \n // { dg-prune-output \"note\" }"}, {"sha": "064c2f2f6204c14a9c576e26ebaad3cb170f4d87", "filename": "gcc/testsuite/g++.dg/cpp0x/error4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror4.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -10,7 +10,7 @@ struct S {\n     static U get(const volatile T&);\n \n   template<typename U>\n-    static decltype(*declval<U>()) get(...);\n+    static decltype(*declval<U>()) get(...); // { dg-error \"operator*\" }\n \n   typedef decltype(get<T>(declval<T>())) type; // { dg-error \"no match\" }\n };"}, {"sha": "8d7d093dc409b7c67434a64f1961002b9b8ea2c4", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice2.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ice2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ice2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ice2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -9,8 +9,9 @@ decltype(F()) run(F f) // { dg-message \"note\" }\n \n int main()\n {\n-  auto l = []() { return 5; };\n+  auto l = []() { return 5; }; // { dg-error \"lambda closure type\" }\n \n   run(l); // { dg-error \"no match\" }\n   // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 14 }\n+  // { dg-error \"use of deleted function\" \"candidate explanation\" { target *-*-* } 5 }\n }"}, {"sha": "af661ecc3af5023e1ae3be4c7d0eeb8b87bb9c43", "filename": "gcc/testsuite/g++.dg/cpp0x/nullptr15.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnullptr15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnullptr15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnullptr15.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -17,10 +17,10 @@ void test_g()\n   // Deduction to nullptr_t, no deduction to pointer type\n   //\n   g(nullptr);               // { dg-error \"no matching function for call to \" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 19 }\n+  // { dg-message \"(candidate|mismatched types)\" \"candidate note\" { target *-*-* } 19 }\n   type_equal<float*>(g((float*)nullptr));\n   decltype(nullptr) mynull = 0;\n   g(mynull);                // { dg-error \"no matching function for call to \" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 23 }\n+  // { dg-message \"(candidate|mismatched types)\" \"candidate note\" { target *-*-* } 23 }\n   type_equal<float*>(g((float*)mynull));\n }"}, {"sha": "076493938a8e6a9d8d57cab34a3f562ce3ee570a", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31431-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431-2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -4,5 +4,5 @@ template<typename, typename..., typename> void foo(); // { dg-message \"note\" }\n void bar()\n {\n   foo<int>(); // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 6 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 6 }\n }"}, {"sha": "afd323715746d3e120a344a839565426fbf329c2", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31431.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31431.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -4,5 +4,5 @@ template<typename..., typename> void foo(); // { dg-message \"note\" }\n void bar()\n {\n   foo<int>(); // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 6 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 6 }\n }"}, {"sha": "54786167c35bef5c2fb163b194a72d68c739893e", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31434.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31434.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31434.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31434.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -8,5 +8,5 @@ template<typename... T> int foo(const T&) // { dg-error \"not expanded with|T\" }\n void bar()\n {\n   foo(0); // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 10 }\n+  // { dg-message \"(candidate|cannot convert)\" \"candidate note\" { target *-*-* } 10 }\n }"}, {"sha": "e62c08984e78ee193a18bccc3a3cf08faa141a1b", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae11.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -51,6 +51,6 @@ int main()\n   // static_assert(  noexcept( f3(y) ), \"shall be ill-formed(OK).\" );\n \n   noexcept( f1(z) );\t\t// { dg-message \"required\" }\n-  static_assert(  noexcept( f2(z) ), \"shall be ill-formed.\" ); // { dg-error \"no match\" }\n+  static_assert(  noexcept( f2(z) ), \"shall be ill-formed.\" ); // { dg-error \"no match|could not convert\" }\n   noexcept( f3(z) );\t\t// { dg-message \"required\" }\n }"}, {"sha": "42b48eb5a6b27a49a61e102a68fe84098d17d671", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae26.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae26.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -32,7 +32,7 @@ struct S {\n   template<class... U,\n     typename enable_if<and_<is_same<T, U>...>::value>::type*& = enabler\n   >\n-  S(U...){} // #\n+  S(U...){}\t\t\t// { dg-error \"no type named 'type'\" }\n };\n \n S<bool> s(0);\t\t\t// { dg-error \"no match\" }"}, {"sha": "dab1650e448018a8d7d28aecf9dea946ae344306", "filename": "gcc/testsuite/g++.dg/cpp0x/temp_default2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp_default2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp_default2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp_default2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -8,7 +8,7 @@ void g()\n   f(1, 'c'); // f<int,char>(1,'c') \n   f(1); // f<int,double>(1,0) \n   f(); // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 10 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 10 }\n   f<int>(); // f<int,double>(0,0) \n   f<int,char>(); // f<int,char>(0,0) \n } "}, {"sha": "8d4baa97e5d5172c0f6d3e00bdcb1f1c985e771e", "filename": "gcc/testsuite/g++.dg/cpp0x/trailing4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrailing4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrailing4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrailing4.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -8,5 +8,5 @@ auto f(T,U) -> decltype(T() + U())\n template<class T> void g(T){}\t// { dg-message \"note\" }\n \n int main() { g(f); }\t\t// { dg-error \"no matching function\" }\n-// { dg-message \"candidate\" \"candidate note\" { target *-*-* } 10 }\n+// { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 10 }\n "}, {"sha": "018eaa3ed8b85b6a98b56ed45824af7d788ec02d", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-ex3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-ex3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-ex3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-ex3.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -4,8 +4,8 @@ void g()\n { \n   int i = f<int>(5.6);\n   int j = f(5.6);         // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 6 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 6 }\n   f<void>(f<int, bool>);\n   f<void>(f<int>);        // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 9 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 9 }\n } "}, {"sha": "0a777c4853bf7d37807d334556bf390a1d97620a", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-ex4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-ex4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-ex4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-ex4.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -8,6 +8,6 @@ void g()\n   f<int>(\"aa\",3.0); // Y is deduced to be char*, and \n                     // Z is deduced to be double \n   f(\"aa\",3.0); // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 10 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 10 }\n   f2<char, short, int, long>(); // okay\n } "}, {"sha": "66387b23c473fc9441d7748e1d8e09ad21b5cb8f", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic105.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic105.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic105.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic105.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -21,4 +21,5 @@ struct call_sum {\n int main() {\n   // This shouldn't be an error; this is bug 35722.\n   reverse<call_sum>(1,2);\t// { dg-bogus \"no match\" \"\" { xfail *-*-* } }\n+  // { dg-bogus \"sorry, unimplemented\" \"candidate explanation\" { xfail *-*-* } 6 }\n }"}, {"sha": "5514259ec3f46bb0805649522c98f0528400d8be", "filename": "gcc/testsuite/g++.dg/cpp0x/vt-37737-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-37737-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-37737-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-37737-2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -4,7 +4,7 @@ template<class U, class... T>\n void f()\t\t\t// { dg-message \"note\" }\n {\n   f<T...>(); // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 6 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 6 }\n }\n \n template<>"}, {"sha": "3e83c8b3de969180b627cb5d413df668c8f396b6", "filename": "gcc/testsuite/g++.dg/ext/vla2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -15,5 +15,5 @@ void bar(int i)\n   char d[i] ;\n   \n   begin(d);  // { dg-error \"no matching function\" \"\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 17 }\n+  // { dg-message \"(candidate|valid template argument)\" \"candidate note\" { target *-*-* } 17 }\n }"}, {"sha": "a17df7fb362552a96ca1b32d775fc1a60d2030fd", "filename": "gcc/testsuite/g++.dg/other/ptrmem10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem10.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -13,7 +13,7 @@ template <class C>\n static void\n bar(C *c, void (C::*m) ())\n {\n-  foo<C,m>((void *)c);// { dg-error \"(not a valid template arg|pointer-to-member|no matching fun)\" }\n+  foo<C,m>((void *)c);// { dg-error \"(not a valid template arg|pointer-to-member|no matching fun|could not convert)\" }\n   // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 16 }\n }\n "}, {"sha": "e73164eef26bc28899b40236303cabe922c65b6e", "filename": "gcc/testsuite/g++.dg/other/ptrmem11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fptrmem11.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -14,7 +14,7 @@ template <typename T>\n int\n bar(int T::* p)\n {\n-  return foo<p>(0);// { dg-error \"(not a valid template arg|no matching func|pointer-to-member)\" }\n+  return foo<p>(0);// { dg-error \"(not a valid template arg|no matching func|pointer-to-member|could not convert)\" }\n   // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 17 }\n }\n "}, {"sha": "b1dc65ebe1805c3d1ca7bc137f671ba20a5ca45b", "filename": "gcc/testsuite/g++.dg/overload/template5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Ftemplate5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Ftemplate5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Ftemplate5.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+\n+template<typename T>\n+int low(T a, T b, T c) { return a + b + c; } // { dg-message \"template\" }\n+\n+template<typename T>\n+int high(T a, T b, T c) { return a + b + c; } // { dg-message \"template\" }\n+\n+int test (void)\n+{\n+  low (5, 6);\t\t\t// { dg-error \"no matching function\" }\n+  // { dg-message \"(candidate|3 arguments, 2 provided)\" \"\" { target *-*-* } 11 }\n+  high (5, 6, 7, 8);\t\t// { dg-error \"no matching function\" }\n+  // { dg-message \"(candidate|3 arguments, 4 provided)\" \"\" { target *-*-* } 13 }\n+}"}, {"sha": "128c4344fede4e2f0427884dba9165d0825f8a72", "filename": "gcc/testsuite/g++.dg/overload/unknown1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Funknown1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Funknown1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Funknown1.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -6,5 +6,5 @@ template <typename T> void bar(T f); // { dg-message \"note\" }\n \n void baz() {\n   bar(foo); // { dg-error \"<unresolved overloaded function type>\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 8 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 8 }\n }"}, {"sha": "f08e756a3ee0bdea4858f9ba14ee93424c538a86", "filename": "gcc/testsuite/g++.dg/template/conv11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv11.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -7,5 +7,5 @@ struct A\n int main()\n {\n   A().operator int();\t\t// { dg-error \"operator int\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 9 }\n+  // { dg-message \"(candidate|mismatched types)\" \"candidate note\" { target *-*-* } 9 }\n }"}, {"sha": "c5d6e00daf70cf24c8516e302ea3577179ea98b7", "filename": "gcc/testsuite/g++.dg/template/deduce3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdeduce3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdeduce3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdeduce3.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -4,8 +4,8 @@ void f(int, T (*)() = 0);\t// { dg-message \"note\" }\n void g() {\n   typedef int A[2];\n   f<A>(0); // { dg-error \"\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 6 }\n+  // { dg-error \"returning an array\" \"candidate explanation\" { target *-*-* } 2 }\n   typedef void F();\n   f<F>(0); // { dg-error \"\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 9 }\n+  // { dg-error \"returning a function\" \"candidate explanation\" { target *-*-* } 2 }\n }"}, {"sha": "af0dfb912a22e298a2020632bc058500c27e6813", "filename": "gcc/testsuite/g++.dg/template/dependent-expr5.C", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr5.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -40,36 +40,36 @@ struct foo {\n       bind (&bar::baikt);\n \n       bind (&barf); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 42 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 42 }\n       bind (&foo::barf); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 44 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 44 }\n \n       bindm (&barf); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 47 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 47 }\n       bindm (&foo::barf);\n \n       bindn (&barf);\n       bindn (&foo::barf);\n \n       bindb (&barf);\n       bindb (&foo::barf); // { dg-error \"ambiguous\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 55 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 55 }\n \n       bind (&bark); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 58 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 58 }\n       bind (&bar::bark); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 60 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 60 }\n \n       bindm (&bark); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 63 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 63 }\n       bindm (&bar::bark);\n \n       bindn (&bark);\n       bindn (&bar::bark);\n \n       bindb (&bark);\n       bindb (&bar::bark); // { dg-error \"ambiguous\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 71 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 71 }\n     }\n   };\n \n@@ -92,36 +92,36 @@ struct foo {\n       bind (&barT::baikt);\n \n       bind (&barf); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 94 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 94 }\n       bind (&foo::barf); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 96 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 96 }\n \n       bindm (&barf); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 99 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 99 }\n       bindm (&foo::barf);\n \n       bindn (&barf);\n       bindn (&foo::barf);\n \n       bindb (&barf);\n       bindb (&foo::barf); // { dg-error \"ambiguous\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 107 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 107 }\n \n       bind (&bark); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 110 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 110 }\n       bind (&barT::bark); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 112 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 112 }\n \n       bindm (&bark); // { dg-error \"no matching function\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 115 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 115 }\n       bindm (&barT::bark);\n \n       bindn (&bark);\n       bindn (&barT::bark);\n \n       bindb (&bark);\n       bindb (&barT::bark); // { dg-error \"ambiguous\" }\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 123 }\n+      // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 123 }\n     }\n   };\n "}, {"sha": "064554dfe71f661071a64073e14d8dc2b7cfed01", "filename": "gcc/testsuite/g++.dg/template/error45.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror45.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -11,7 +11,7 @@ struct enable_if< true, T >\n \n template < typename T >\n struct enable_if< true, T >::type\n-f( T x );\n+f( T x );\t\t\t// { dg-error \"not a class type\" }\n \n void\n g( void )"}, {"sha": "e315a1a0902ca2fecf51b1f8795891e431269a70", "filename": "gcc/testsuite/g++.dg/template/friend.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -26,5 +26,5 @@ int main()\n {\n   s<int>::t y;\n   cout << y; // { dg-error \"\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 28 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 28 }\n }"}, {"sha": "b855569088fb14463c4979ed70df5b3f91858bc4", "filename": "gcc/testsuite/g++.dg/template/incomplete2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fincomplete2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fincomplete2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fincomplete2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -9,6 +9,6 @@ A a;  // { dg-error \"incomplete type\" }\n \n void bar()\n {\n-  foo<a>();  // { dg-error \"no matching function\" }\n+  foo<a>();  // { dg-error \"(no matching function|could not convert)\" }\n   // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 12 }\n }"}, {"sha": "d842076bd80afad01c3ee8db61fee48eac5bad06", "filename": "gcc/testsuite/g++.dg/template/local4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal4.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -5,6 +5,6 @@ template <typename T> void foo() {} // { dg-message \"note\" }\n \n int main () {\n   struct S {};\n-  foo<S> (); // { dg-error \"match\" } \n+  foo<S> (); // { dg-error \"(match|template argument for|trying to instantiate)\" } \n   // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 8 }\n }"}, {"sha": "3eb828fd7118fae50efa812fa9f1a94cb57d040c", "filename": "gcc/testsuite/g++.dg/template/local6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal6.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -5,7 +5,7 @@ template <class T> struct PCVector2 // { dg-message \"note\" }\n     PCVector2<T> operator- (const PCVector2<T> &ov) const \n \t{ \n \t  return PCVector2<T>(ov.xFIELD, ov.yFIELD); // { dg-error \"matching\" }\n-\t  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 7 }\n+\t  // { dg-message \"(candidate|expects 1 argument, 2 provided|cannot convert)\" \"candidate note\" { target *-*-* } 7 }\n \t}\n \n     T xFIELD, yFIELD;"}, {"sha": "46eef0a9ac7cdb10dcaa61d6d0827024bef13d2d", "filename": "gcc/testsuite/g++.dg/template/operator9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator9.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -5,6 +5,6 @@ template<operator+> void foo(); // { dg-error \"before|non-function|template\" }\n void bar()\n {\n   foo();                        // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 7 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 7 }\n }\n  "}, {"sha": "656dcaefeedcc519b550a5ac118527d09e11e2a9", "filename": "gcc/testsuite/g++.dg/template/overload12.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foverload12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foverload12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foverload12.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+\n+struct S {int x; int y;};\n+template<typename T>\n+int foo(T a, T b) {return a + b;} // { dg-message \"template\" }\n+template<typename T, typename T2>\n+int foo(T a, T2& b, T2 c) {return a + b;}  // { dg-message \"template\" }\n+int foo(char*, S&); // { dg-message \"foo\" }\n+// { dg-message \"candidate expects 2 arguments, 3 provided\" \"arity\" { target *-*-* } 8 }\n+\n+int foo2(int x)\n+{\n+  S s={1,2};\n+  char c;\n+  foo(c, 2, c); // { dg-error \"no matching function\" }\n+  // { dg-message \"(candidate|deduced conflicting types for)\" \"candidate note\" { target *-*-* } 15 }\n+}"}, {"sha": "5f03580c1b20cb69f756435452334e4ad67bcb7a", "filename": "gcc/testsuite/g++.dg/template/ptrmem2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -7,7 +7,7 @@\n \n struct A {};\n \n-template <typename T> T A::* Foo (); // { dg-message \"note\" }\n+template <typename T> T A::* Foo (); // { dg-error \"reference\" }\n \n void Baz ()\n {"}, {"sha": "c9e103114dd7f7d4feed2dc886cbb9f3217b77f2", "filename": "gcc/testsuite/g++.dg/template/sfinae2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -8,7 +8,7 @@ template<int T> struct cl {\n   const static int value = T;\n };\n \n-template<int I> void fn (char (*) [cl<I>::value] = 0 ); // { dg-message \"note\" }\n+template<int I> void fn (char (*) [cl<I>::value] = 0 ); // { dg-error \"zero-size array\" }\n \n void foo (void)\n {"}, {"sha": "46762ae21aff53ad7cbf326aa0ef874de279c15c", "filename": "gcc/testsuite/g++.dg/template/ttp25.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp25.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -18,12 +18,12 @@ void f4(T, C<5>);\t\t// { dg-message \"note\" }\n template<int N> struct X {};\n void g() {\n   f1(5l, X<5>()); // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 20 }\n+  // { dg-message \"(candidate|inconsistent with)\" \"candidate note\" { target *-*-* } 20 }\n   f2(X<5>(), 5);\n   f3(X<5>(), 5l); // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 23 }\n+  // { dg-message \"(candidate|inconsistent with)\" \"candidate note\" { target *-*-* } 23 }\n   f4(5, X<5>());\n   f4(5l, X<5>()); // { dg-error \"no matching\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 26 }\n+  // { dg-message \"(candidate|inconsistent with)\" \"candidate note\" { target *-*-* } 26 }\n   f4((short)5, X<5>());\n }"}, {"sha": "7f2fd534624b30d42d8641580686871911029344", "filename": "gcc/testsuite/g++.dg/template/unify10.C", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify10.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -26,34 +26,34 @@ void cvFunction(void (CLASS::* method)() const volatile) {} // { dg-message \"not\n int main() {\n   mFunction(&MyClass::mMethod);\n   mFunction(&MyClass::cMethod);    // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 28 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 28 }\n   mFunction(&MyClass::vMethod);    // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 30 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 30 }\n   mFunction(&MyClass::cvMethod);   // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 32 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 32 }\n \n   cFunction(&MyClass::mMethod);    // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 35 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 35 }\n   cFunction(&MyClass::cMethod);\n   cFunction(&MyClass::vMethod);    // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 38 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 38 }\n   cFunction(&MyClass::cvMethod);   // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 40 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 40 }\n \n   vFunction(&MyClass::mMethod);    // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 43 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 43 }\n   vFunction(&MyClass::cMethod);    // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 45 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 45 }\n   vFunction(&MyClass::vMethod);\n   vFunction(&MyClass::cvMethod);   // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 48 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 48 }\n \n   cvFunction(&MyClass::mMethod);   // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 51 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 51 }\n   cvFunction(&MyClass::cMethod);   // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 53 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 53 }\n   cvFunction(&MyClass::vMethod);   // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 55 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 55 }\n   cvFunction(&MyClass::cvMethod);\n \n   return 0;"}, {"sha": "25606dc4af885f26b6d3ff7f4cf4e6eb98f0aac6", "filename": "gcc/testsuite/g++.dg/template/unify11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify11.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -20,7 +20,7 @@ struct B\n     C (U t)\n     {\n       A a;\n-      A b = foo (this, a, t); // { dg-error \"no matching function\" }\n+      A b = foo (this, a, t); // { dg-error \"(no matching function|is not a)\" }\n       // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 23 }\n     }\n   } c;"}, {"sha": "551c96ebb9fedc8915164f6fa7c70db8c64d2b67", "filename": "gcc/testsuite/g++.dg/template/unify6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify6.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -19,5 +19,5 @@ void Bar ()\n   Foo3 (&Baz);\n \n   Foo3 (&Baz, &Baz); // { dg-error \"no matching function\" \"\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 21 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 21 }\n }"}, {"sha": "88d9fd9baa0230adb9c1aed3950651d416963f67", "filename": "gcc/testsuite/g++.dg/template/unify7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify7.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -11,5 +11,5 @@ int main()\n {\n   Foo (f);\n   Baz (f); // { dg-error \"no matching function\" \"\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 13 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 13 }\n }"}, {"sha": "f06f83a8d1b722877388ea76fe3d599f9d691ebb", "filename": "gcc/testsuite/g++.dg/template/unify9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify9.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -14,5 +14,5 @@ const X *x;\n  \n int main () { \n   f (*x, &X::g);  // {  dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 16 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 16 }\n } "}, {"sha": "4ba11049b5ad1bf4940e45f7866d34cf1acb6215", "filename": "gcc/testsuite/g++.dg/template/varmod1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fvarmod1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fvarmod1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fvarmod1.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -7,5 +7,5 @@ void bar()\n   int i;\n   int A[i][i]; \n   foo(A); // { dg-error \"\" } \n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 9 }\n+  // { dg-message \"(candidate|not a valid template argument)\" \"candidate note\" { target *-*-* } 9 }\n }"}, {"sha": "e3bff80e610755f5d541a78eb8a09ac12b066041", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash56.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -278,7 +278,7 @@ SetLD<T>::remove(const T& item)\n     Vix x;\n     for (first(x); 0 != x && this->REMOVE_CURRENT != a; next(x, a))\n \ta = operator()(x) == item ? this->REMOVE_CURRENT: this->NORMAL; // { dg-error \"\" } .*\n-    // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 280 }\n+    // { dg-message \"(candidate|not derived from)\" \"candidate note\" { target *-*-* } 280 }\n }\n template<class T>\n bool\n@@ -287,7 +287,7 @@ SetLD<T>::contains(const T& item) const\n     Vix x;\n     for (first(x); 0 != x; next(x)) {\n \tif (operator()(x) == item)// { dg-error \"\" } .*\n-\t  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 289 }\n+\t  // { dg-message \"(candidate|not derived from)\" \"candidate note\" { target *-*-* } 289 }\n \t    return TRUE;\n     }\n     return FALSE;"}, {"sha": "81ed85a28ef5c2f2b0b528419d7a454149727482", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash28.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash28.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -11,5 +11,5 @@ void f(unsigned int n) {\n   int x[n];\n \n   asize(x); // { dg-error \"\" } no matching function\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 13 }\n+  // { dg-message \"(candidate|not a valid template argument)\" \"candidate note\" { target *-*-* } 13 }\n }"}, {"sha": "747af9b409036d32e2b7b7a95c03754344aec61b", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash60.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash60.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash60.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash60.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -7,7 +7,7 @@\n template< typename SID, class SDR >\n void k( SID sid, SDR* p,\n  void (SDR::*)\n- ( typename SID::T ) );\t\t// { dg-message \"note\" }\n+ ( typename SID::T ) );\t\t// { dg-error \"no type named 'T'\" }\n \n struct E { };\n struct S { void f( int ); };"}, {"sha": "c27d131238174d3b2a4cc5da8900f6d6fe6381b5", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit41.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit41.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -1,6 +1,6 @@\n // { dg-do assemble  }\n template <int I>\n-void f(int i);\t\t\t// { dg-message \"note\" }\n+void f(int i);\t\t\t// { dg-message \"void f\" }\n \n void g()\n {"}, {"sha": "b97c1cd02237a75528c768f6711ea3f5ffeb75a0", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit77.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit77.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit77.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit77.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -15,5 +15,5 @@ void g() {\n   \n   f<0>(s0, s2);\n   f(s0, s2); // { dg-error \"\" } no matching function\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 17 }\n+  // { dg-message \"(candidate|deduced conflicting types|ambiguous base class)\" \"candidate note\" { target *-*-* } 17 }\n }"}, {"sha": "06d22d5197a73bcef45c328821ac5d918f651d58", "filename": "gcc/testsuite/g++.old-deja/g++.pt/expr2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr2.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -9,5 +9,5 @@ void foo(S<J + 2>);\t\t// { dg-message \"note\" }\n void bar()\n {\n   foo(S<3>()); // { dg-error \"\" } no way to deduce J from this.\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 11 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 11 }\n }"}, {"sha": "8802e983b677614fd5da8ef617763d9c69d8c417", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -13,9 +13,9 @@ public:\n };\n \n template <void (A::*)() >\n-void g() {}\t\t\t// { dg-message \"note\" }\n+void g() {}\t\t\t// { dg-message \"void g\" }\n template <int A::*>\n-void h() {}\t\t\t// { dg-message \"note\" }\n+void h() {}\t\t\t// { dg-message \"void h\" }\n \n \n int main() {"}, {"sha": "96e8cf911607117ea09f149c1fa5229ed19764fd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec5.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -14,9 +14,9 @@ template void g(int i, int j);\n void h()\n {\n   f(3, 'c'); // { dg-error \"\" } no matching function\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 16 }\n+  // { dg-message \"(candidate|deduced conflicting types)\" \"candidate note\" { target *-*-* } 16 }\n   g(3, 'c'); // { dg-error \"\" } no matching function\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 18 }\n+  // { dg-message \"(candidate|deduced conflicting types)\" \"candidate note\" { target *-*-* } 18 }\n }\n \n "}, {"sha": "b8f6673fa0b3b3eb60744ca9317b0e888c416128", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec6.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -25,9 +25,9 @@ void h()\n {\n   S1 s1;\n   s1.f(3, 'c'); // { dg-error \"\" } no matching function\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 27 }\n+  // { dg-message \"(candidate|deduced conflicting types)\" \"candidate note\" { target *-*-* } 27 }\n \n   S2<char> s2;\n   s2.f(3, 'c'); // { dg-error \"\" } no matching function\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 31 }\n+  // { dg-message \"(candidate|deduced conflicting types)\" \"candidate note\" { target *-*-* } 31 }\n }"}, {"sha": "9285b21c2ee860c46fe23e854ae256dff7828172", "filename": "gcc/testsuite/g++.old-deja/g++.pt/unify4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify4.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -8,6 +8,6 @@ int\n main ()\n {\n   f (g);\t\t\t// { dg-error \"\" } ambiguous unification\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 10 }\n+  // { dg-message \"(candidate|deduce template parameter)\" \"candidate note\" { target *-*-* } 10 }\n   return 0;\n }"}, {"sha": "a6f76744d228a30b605d8ad566e460d0a73f4115", "filename": "gcc/testsuite/g++.old-deja/g++.pt/unify6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify6.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -19,7 +19,7 @@ template<> void fn<int &>() {} // ok, specialize A\n template<> void fn<void ()>() {} // ok, specialize A\n \n // now make sure we moan when we really should\n-template<class T> void foo(T const *){} // { dg-message \"note\" }\n+template<class T> void foo(T const *){} // { dg-error \"pointer to reference\" }\n \n void f()\n {"}, {"sha": "3a86d977ec3a3f4ecbc7e300acff09faf0cf6115", "filename": "gcc/testsuite/g++.old-deja/g++.pt/unify8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -16,6 +16,6 @@ void Foo (float);     // { dg-message \"note\" } candidate\n void baz (int **p1)\n {\n   Foo (p1);   // { dg-error \"match\" } no such function\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 18 }\n+  // { dg-message \"(candidate|incompatible cv-qualifiers)\" \"candidate note\" { target *-*-* } 18 }\n   Bar (p1);   // OK\n }"}, {"sha": "410a336911821b65f7041920fc1bf94859a213ee", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb98.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb98.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2f6864225cc660adfc9136c859dd26e2a40135/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb98.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb98.C?ref=3d2f6864225cc660adfc9136c859dd26e2a40135", "patch": "@@ -15,5 +15,5 @@\n     void f()\n     {\n       extent(b);  // { dg-error \"\" } no matching function\n-      // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 17 }\n+      // { dg-message \"(candidate|mismatched types)\" \"candidate note\" { target *-*-* } 17 }\n     }"}]}