{"sha": "ce33801fe4c2272b31c64288b34c67a61529ce37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UzMzgwMWZlNGMyMjcyYjMxYzY0Mjg4YjM0YzY3YTYxNTI5Y2UzNw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-28T19:16:06Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-28T22:55:44Z"}, "message": "libstdc++: Fix bogus use of memcmp in ranges::lexicographical_compare (PR 93972)\n\nWe were enabling the memcmp optimization in ranges::lexicographical_compare for\nsigned integral types and for integral types wider than a byte.  But memcmp\ngives the wrong answer for arrays of such types.  This patch fixes this issue by\nrefining the condition that enables the memcmp optimization.  It's now\nconsistent with the corresponding condition used in\nstd::lexicographical_compare.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/93972\n\t* include/bits/ranges_algo.h (__lexicographical_compare_fn::operator()):\n\tFix condition for when to use memcmp, making it consistent with the\n\tcorresponding condition used in std::lexicographical_compare.\n\t* testsuite/25_algorithms/lexicographical_compare/93972.cc: New test.", "tree": {"sha": "60a5ff84a1d13e63770f1fafbed63864e92043c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60a5ff84a1d13e63770f1fafbed63864e92043c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce33801fe4c2272b31c64288b34c67a61529ce37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce33801fe4c2272b31c64288b34c67a61529ce37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce33801fe4c2272b31c64288b34c67a61529ce37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce33801fe4c2272b31c64288b34c67a61529ce37/comments", "author": null, "committer": null, "parents": [{"sha": "e82192021dd08291ee418cb33bb7af037952e963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82192021dd08291ee418cb33bb7af037952e963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e82192021dd08291ee418cb33bb7af037952e963"}], "stats": {"total": 183, "additions": 181, "deletions": 2}, "files": [{"sha": "efbe1dafdf5f4469871e3e60654af7a4bfc7d3d4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce33801fe4c2272b31c64288b34c67a61529ce37/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce33801fe4c2272b31c64288b34c67a61529ce37/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ce33801fe4c2272b31c64288b34c67a61529ce37", "patch": "@@ -1,5 +1,11 @@\n 2020-02-28  Patrick Palka  <ppalka@redhat.com>\n \n+\tPR libstdc++/93972\n+\t* include/bits/ranges_algo.h (__lexicographical_compare_fn::operator()):\n+\tFix condition for when to use memcmp, making it consistent with the\n+\tcorresponding condition used in std::lexicographical_compare.\n+\t* testsuite/25_algorithms/lexicographical_compare/93972.cc: New test.\n+\n \t* testsuite/26_numerics/headers/numeric/synopsis.cc: Add signatures for\n \tfunctions introduced in C++11, C++17 and C++2a.  Add 'constexpr' to\n \texisting signatures for C++2a."}, {"sha": "8fa4a8a91610fa3f4d724ea5053a9ab73bb49a1e", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce33801fe4c2272b31c64288b34c67a61529ce37/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce33801fe4c2272b31c64288b34c67a61529ce37/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=ce33801fe4c2272b31c64288b34c67a61529ce37", "patch": "@@ -3466,9 +3466,13 @@ namespace ranges\n \t      {\n \t\tusing _ValueType1 = iter_value_t<_Iter1>;\n \t\tusing _ValueType2 = iter_value_t<_Iter2>;\n+\t\t// This condition is consistent with the one in\n+\t\t// __lexicographical_compare_aux in <bits/stl_algobase.h>.\n \t\tconstexpr bool __use_memcmp\n-\t\t  = ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>)\n-\t\t     && is_same_v<_ValueType1, _ValueType2>\n+\t\t  = (__is_byte<_ValueType1>::__value\n+\t\t     && __is_byte<_ValueType2>::__value\n+\t\t     && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed\n+\t\t     && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed\n \t\t     && is_pointer_v<_Iter1>\n \t\t     && is_pointer_v<_Iter2>\n \t\t     && (is_same_v<_Comp, ranges::less>"}, {"sha": "53c4e0daddcfdc8ed493af65c5660f847344b586", "filename": "libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/93972.cc", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce33801fe4c2272b31c64288b34c67a61529ce37/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F93972.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce33801fe4c2272b31c64288b34c67a61529ce37/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F93972.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F93972.cc?ref=ce33801fe4c2272b31c64288b34c67a61529ce37", "patch": "@@ -0,0 +1,169 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using std::signed_integral;\n+\n+namespace ranges = std::ranges;\n+\n+template<signed_integral T>\n+void\n+test01()\n+{\n+  T i[] = { -1 };\n+  T j[] = { 1 };\n+\n+  VERIFY( ranges::lexicographical_compare(i, j) );\n+  VERIFY( !ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( !ranges::lexicographical_compare(j, i) );\n+  VERIFY( ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+template<signed_integral T>\n+void\n+test02()\n+{\n+  T i[] = { -5 };\n+  T j[] = { -5, 3 };\n+\n+  VERIFY( ranges::lexicographical_compare(i, j) );\n+  VERIFY( ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( !ranges::lexicographical_compare(j, i) );\n+  VERIFY( !ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+template<signed_integral T>\n+void\n+test03()\n+{\n+  T i[] = { -10 };\n+  T j[] = { -5, 3 };\n+\n+  VERIFY( ranges::lexicographical_compare(i, j) );\n+  VERIFY( !ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( !ranges::lexicographical_compare(j, i) );\n+  VERIFY( ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+template<signed_integral T>\n+void\n+test04()\n+{\n+  T i[] = { -2 };\n+  T j[] = { -5, 3 };\n+\n+  VERIFY( !ranges::lexicographical_compare(i, j) );\n+  VERIFY( ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( ranges::lexicographical_compare(j, i) );\n+  VERIFY( !ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+void\n+test05()\n+{\n+  unsigned i[] = { 1 };\n+  unsigned j[] = { 256 };\n+\n+  VERIFY( ranges::lexicographical_compare(i, j) );\n+  VERIFY( !ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( !ranges::lexicographical_compare(j, i) );\n+  VERIFY( ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+void\n+test06()\n+{\n+  signed char i[] = { 100, 1 };\n+  unsigned char j[] = { 100 };\n+\n+  VERIFY( !ranges::lexicographical_compare(i, j) );\n+  VERIFY( !ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( ranges::lexicographical_compare(j, i) );\n+  VERIFY( ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+void\n+test07()\n+{\n+  char i[] = { 95, 1 };\n+  unsigned char j[] = { 100 };\n+\n+  VERIFY( ranges::lexicographical_compare(i, j) );\n+  VERIFY( !ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( !ranges::lexicographical_compare(j, i) );\n+  VERIFY( ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+void\n+test08()\n+{\n+  signed char i[] = { 112, 1 };\n+  signed char j[] = { 87 };\n+\n+  VERIFY( !ranges::lexicographical_compare(i, j) );\n+  VERIFY( ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( ranges::lexicographical_compare(j, i) );\n+  VERIFY( !ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+void\n+test09()\n+{\n+  char i[] = { 1 };\n+  unsigned char j[] = { 100 };\n+\n+  VERIFY( ranges::lexicographical_compare(i, j) );\n+  VERIFY( !ranges::lexicographical_compare(i, j, ranges::greater{}) );\n+\n+  VERIFY( !ranges::lexicographical_compare(j, i) );\n+  VERIFY( ranges::lexicographical_compare(j, i, ranges::greater{}) );\n+}\n+\n+int\n+main()\n+{\n+  test01<signed char>();\n+  test01<int>();\n+\n+  test02<signed char>();\n+  test02<int>();\n+\n+  test03<signed char>();\n+  test03<int>();\n+\n+  test04<signed char>();\n+  test04<int>();\n+\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  test09();\n+}"}]}