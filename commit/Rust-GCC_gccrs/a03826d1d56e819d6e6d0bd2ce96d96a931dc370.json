{"sha": "a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAzODI2ZDFkNTZlODE5ZDZlNmQwYmQyY2U5NmQ5NmE5MzFkYzM3MA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-11-24T13:10:37Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-11-24T13:10:37Z"}, "message": "re PR fortran/37779 (Missing RECURSIVE not detected)\n\n2008-11-24  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37779\n\t* resolve.c (resolve_procedure_expression): New method.\n\t(resolve_variable): Call it.\n\t(resolve_actual_arglist): Call gfc_resolve_expr for procedure arguments.\n\n2008-11-24  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37779\n\t* gfortran.dg/c_funloc_tests.f03: Added missing `RECURSIVE'.\n\t* gfortran.dg/c_funloc_tests_2.f03: Ditto.\n\t* gfortran.dg/recursive_check_4.f03: New test.\n\t* gfortran.dg/recursive_check_5.f03: New test.\n\nFrom-SVN: r142158", "tree": {"sha": "6d3d651ee55170c647ffb5c2494dd04d553c5f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d3d651ee55170c647ffb5c2494dd04d553c5f08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72a2609f5d7421ab10d04b06f10e78814b0370cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a2609f5d7421ab10d04b06f10e78814b0370cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a2609f5d7421ab10d04b06f10e78814b0370cc"}], "stats": {"total": 114, "additions": 109, "deletions": 5}, "files": [{"sha": "8a0092175ee15f91a41f262b9ede225cd3ee0bbf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "patch": "@@ -1,3 +1,10 @@\n+2008-11-24  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37779\n+\t* resolve.c (resolve_procedure_expression): New method.\n+\t(resolve_variable): Call it.\n+\t(resolve_actual_arglist): Call gfc_resolve_expr for procedure arguments.\n+\n 2008-11-24  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/34820"}, {"sha": "f1c27e62b59a1d63f9557af6970b32e666e92aca", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "patch": "@@ -1072,6 +1072,33 @@ count_specific_procs (gfc_expr *e)\n   return n;\n }\n \n+\n+/* Resolve a procedure expression, like passing it to a called procedure or as\n+   RHS for a procedure pointer assignment.  */\n+\n+static gfc_try\n+resolve_procedure_expression (gfc_expr* expr)\n+{\n+  gfc_symbol* sym;\n+\n+  if (expr->ts.type != BT_PROCEDURE || expr->expr_type != EXPR_VARIABLE)\n+    return SUCCESS;\n+  gcc_assert (expr->symtree);\n+  sym = expr->symtree->n.sym;\n+  gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n+\n+  /* A non-RECURSIVE procedure that is used as procedure expression within its\n+     own body is in danger of being called recursively.  */\n+  if (!sym->attr.recursive && sym == gfc_current_ns->proc_name\n+      && !gfc_option.flag_recursive)\n+    gfc_warning (\"Non-RECURSIVE procedure '%s' at %L is possibly calling\"\n+\t\t \" itself recursively.  Declare it RECURSIVE or use\"\n+\t\t \" -frecursive\", sym->name, &expr->where);\n+  \n+  return SUCCESS;\n+}\n+\n+\n /* Resolve an actual argument list.  Most of the time, this is just\n    resolving the expressions in the list.\n    The exception is that we sometimes have to decide whether arguments\n@@ -1180,8 +1207,8 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t&& sym->ns == gfc_current_ns\n \t\t&& !sym->ns->entries->sym->attr.recursive)\n \t    {\n-\t      gfc_error (\"Reference to ENTRY '%s' at %L is recursive, but procedure \"\n-\t\t\t \"'%s' is not declared as RECURSIVE\",\n+\t      gfc_error (\"Reference to ENTRY '%s' at %L is recursive, but\"\n+\t\t\t \" procedure '%s' is not declared as RECURSIVE\",\n \t\t\t sym->name, &e->where, sym->ns->entries->sym->name);\n \t    }\n \n@@ -1211,6 +1238,9 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t      sym->attr.intrinsic = 1;\n \t      sym->attr.function = 1;\n \t    }\n+\n+\t  if (gfc_resolve_expr (e) == FAILURE)\n+\t    return FAILURE;\n \t  goto argument_list;\n \t}\n \n@@ -1235,6 +1265,8 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  || sym->attr.intrinsic\n \t  || sym->attr.external)\n \t{\n+\t  if (gfc_resolve_expr (e) == FAILURE)\n+\t    return FAILURE;\n \t  goto argument_list;\n \t}\n \n@@ -4155,7 +4187,7 @@ resolve_variable (gfc_expr *e)\n   if (sym->attr.flavor == FL_PROCEDURE && !sym->attr.function)\n     {\n       e->ts.type = BT_PROCEDURE;\n-      return SUCCESS;\n+      goto resolve_procedure;\n     }\n \n   if (sym->ts.type != BT_UNKNOWN)\n@@ -4237,6 +4269,10 @@ resolve_variable (gfc_expr *e)\n \tsym->entry_id = current_entry_id + 1;\n     }\n \n+resolve_procedure:\n+  if (t == SUCCESS && resolve_procedure_expression (e) == FAILURE)\n+    t = FAILURE;\n+\n   return t;\n }\n "}, {"sha": "d66b4eba18c797ac45adc3eeaca7769cd3037e84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "patch": "@@ -1,3 +1,11 @@\n+2008-11-24  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37779\n+\t* gfortran.dg/c_funloc_tests.f03: Added missing `RECURSIVE'.\n+\t* gfortran.dg/c_funloc_tests_2.f03: Ditto.\n+\t* gfortran.dg/recursive_check_4.f03: New test.\n+\t* gfortran.dg/recursive_check_5.f03: New test.\n+\n 2008-11-24  Mikael Morin <mikael.morin@tele2.fr>\n \n \tPR fortran/35681"}, {"sha": "8ba07b9fbba10635d0a7495dfd33ce11bd8668c7", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests.f03?ref=a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "patch": "@@ -5,7 +5,7 @@ module c_funloc_tests\n   use, intrinsic :: iso_c_binding, only: c_funptr, c_funloc\n \n contains\n-  subroutine sub0() bind(c)\n+  recursive subroutine sub0() bind(c)\n     type(c_funptr) :: my_c_funptr\n \n     my_c_funptr = c_funloc(sub0)"}, {"sha": "d3ed265ea8c3f7744f91f9150e9842a04d3178b5", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_2.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03?ref=a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "patch": "@@ -4,7 +4,7 @@ module c_funloc_tests_2\n   implicit none\n \n contains\n-  subroutine sub0() bind(c)\n+  recursive subroutine sub0() bind(c)\n     type(c_funptr) :: my_c_funptr\n     integer :: my_local_variable\n     "}, {"sha": "2a95554ff2547370a4f82a2d8370fecb652feae6", "filename": "gcc/testsuite/gfortran.dg/recursive_check_4.f03", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_4.f03?ref=a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+\n+! PR fortran/37779\n+! Check that using a non-recursive procedure as \"value\" is an error.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+CONTAINS\n+\n+  SUBROUTINE test ()\n+    IMPLICIT NONE\n+    PROCEDURE(test), POINTER :: procptr\n+\n+    CALL bar (test) ! { dg-warning \"Non-RECURSIVE\" }\n+    procptr => test ! { dg-warning \"Non-RECURSIVE\" }\n+  END SUBROUTINE test\n+\n+  INTEGER FUNCTION func ()\n+    ! Using a result variable is ok of course!\n+    func = 42 ! { dg-bogus \"Non-RECURSIVE\" }\n+  END FUNCTION func\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "4014986b3b54654e3ae501a312318ad54a173219", "filename": "gcc/testsuite/gfortran.dg/recursive_check_5.f03", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03826d1d56e819d6e6d0bd2ce96d96a931dc370/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_5.f03?ref=a03826d1d56e819d6e6d0bd2ce96d96a931dc370", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! { dg-options \"-frecursive\" }\n+\n+! PR fortran/37779\n+! Check that -frecursive allows using procedures in as procedure expressions.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+CONTAINS\n+\n+  SUBROUTINE test ()\n+    IMPLICIT NONE\n+    PROCEDURE(test), POINTER :: procptr\n+\n+    CALL bar (test) ! { dg-bogus \"Non-RECURSIVE\" }\n+    procptr => test ! { dg-bogus \"Non-RECURSIVE\" }\n+  END SUBROUTINE test\n+\n+  INTEGER FUNCTION func ()\n+    ! Using a result variable is ok of course!\n+    func = 42 ! { dg-bogus \"Non-RECURSIVE\" }\n+  END FUNCTION func\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}