{"sha": "ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYxZWQxM2Q5YWIyZTJjOWRhY2RiNWFlMDZhZmI4NmNhNmFkNzE5Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-01-11T04:48:22Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-11T04:48:22Z"}, "message": "compiler: Use backend interface for type sizes and alignments.\n\n\t* go-gcc.cc (Gcc_backend::type_size): New function.\n\t(Gcc_backend::type_alignment): New function.\n\t(Gcc_backend::type_field_alignment): New function.\n\t(Gcc_backend::type_field_offset): New function.\n\t* go-backend.c (go_type_alignment): Remove.\n\t* go-c.h (go_type_alignment): Don't declare.\n\nFrom-SVN: r183089", "tree": {"sha": "5bbea3053021715319cc56c179b13eb1af9ea5af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bbea3053021715319cc56c179b13eb1af9ea5af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/comments", "author": null, "committer": null, "parents": [{"sha": "5313d330b2a6596686c2b5e04431c167ef4544be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5313d330b2a6596686c2b5e04431c167ef4544be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5313d330b2a6596686c2b5e04431c167ef4544be"}], "stats": {"total": 376, "additions": 313, "deletions": 63}, "files": [{"sha": "20675583b781cd6e8eb5c3088ba2ea0d1083af19", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -1,3 +1,12 @@\n+2012-01-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::type_size): New function.\n+\t(Gcc_backend::type_alignment): New function.\n+\t(Gcc_backend::type_field_alignment): New function.\n+\t(Gcc_backend::type_field_offset): New function.\n+\t* go-backend.c (go_type_alignment): Remove.\n+\t* go-c.h (go_type_alignment): Don't declare.\n+\n 2011-12-27  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::set_placeholder_struct_type): Use"}, {"sha": "5dab2f1864c95f7f2a63982dbef6b0b9006a7e38", "filename": "gcc/go/go-backend.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgo-backend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgo-backend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-backend.c?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -1,5 +1,5 @@\n /* go-backend.c -- Go frontend interface to gcc backend.\n-   Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+   Copyright (C) 2010, 2011, 2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -48,14 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n /* This file holds all the cases where the Go frontend needs\n    information from gcc's backend.  */\n \n-/* Return the alignment in bytes of a value of type T.  */\n-\n-unsigned int\n-go_type_alignment (tree t)\n-{\n-  return TYPE_ALIGN_UNIT (t);\n-}\n-\n /* Return the alignment in bytes of a struct field of type T.  */\n \n unsigned int"}, {"sha": "0bfed85322a6e65332577d1446fa225b40d211fd", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -1,5 +1,5 @@\n /* go-c.h -- Header file for go frontend gcc C interface.\n-   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -59,8 +59,6 @@ extern void go_preserve_from_gc (tree);\n \n extern const char *go_localize_identifier (const char*);\n \n-extern unsigned int go_type_alignment (tree);\n-\n extern unsigned int go_field_alignment (tree);\n \n extern void go_trampoline_info (unsigned int *size, unsigned int *alignment);"}, {"sha": "bfa0ec77df3f72d595e2ea08de3ce3c5b43491b8", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -1,5 +1,5 @@\n // go-gcc.cc -- Go frontend to gcc IR.\n-// Copyright (C) 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n // Contributed by Ian Lance Taylor, Google.\n \n // This file is part of GCC.\n@@ -195,6 +195,18 @@ class Gcc_backend : public Backend\n   bool\n   is_circular_pointer_type(Btype*);\n \n+  size_t\n+  type_size(Btype*);\n+\n+  size_t\n+  type_alignment(Btype*);\n+\n+  size_t\n+  type_field_alignment(Btype*);\n+\n+  size_t\n+  type_field_offset(Btype*, size_t index);\n+\n   // Expressions.\n \n   Bexpression*\n@@ -755,6 +767,56 @@ Gcc_backend::is_circular_pointer_type(Btype* btype)\n   return btype->get_tree() == ptr_type_node;\n }\n \n+// Return the size of a type.\n+\n+size_t\n+Gcc_backend::type_size(Btype* btype)\n+{\n+  tree t = TYPE_SIZE_UNIT(btype->get_tree());\n+  gcc_assert(TREE_CODE(t) == INTEGER_CST);\n+  gcc_assert(TREE_INT_CST_HIGH(t) == 0);\n+  unsigned HOST_WIDE_INT val_wide = TREE_INT_CST_LOW(t);\n+  size_t ret = static_cast<size_t>(val_wide);\n+  gcc_assert(ret == val_wide);\n+  return ret;\n+}\n+\n+// Return the alignment of a type.\n+\n+size_t\n+Gcc_backend::type_alignment(Btype* btype)\n+{\n+  return TYPE_ALIGN_UNIT(btype->get_tree());\n+}\n+\n+// Return the alignment of a struct field of type BTYPE.\n+\n+size_t\n+Gcc_backend::type_field_alignment(Btype* btype)\n+{\n+  return go_field_alignment(btype->get_tree());\n+}\n+\n+// Return the offset of a field in a struct.\n+\n+size_t\n+Gcc_backend::type_field_offset(Btype* btype, size_t index)\n+{\n+  tree struct_tree = btype->get_tree();\n+  gcc_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n+  tree field = TYPE_FIELDS(struct_tree);\n+  for (; index > 0; --index)\n+    {\n+      field = DECL_CHAIN(field);\n+      gcc_assert(field != NULL_TREE);\n+    }\n+  HOST_WIDE_INT offset_wide = int_byte_position(field);\n+  gcc_assert(offset_wide >= 0);\n+  size_t ret = static_cast<size_t>(offset_wide);\n+  gcc_assert(ret == static_cast<unsigned HOST_WIDE_INT>(offset_wide));\n+  return ret;\n+}\n+\n // Return the zero value for a type.\n \n Bexpression*"}, {"sha": "9777acc65f21eef4559f569da04219c37f7fbf24", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -198,6 +198,25 @@ class Backend\n   virtual bool\n   is_circular_pointer_type(Btype*) = 0;\n \n+  // Return the size of a type.\n+  virtual size_t\n+  type_size(Btype*) = 0;\n+\n+  // Return the alignment of a type.\n+  virtual size_t\n+  type_alignment(Btype*) = 0;\n+\n+  // Return the alignment of a struct field of this type.  This is\n+  // normally the same as type_alignment, but not always.\n+  virtual size_t\n+  type_field_alignment(Btype*) = 0;\n+\n+  // Return the offset of field INDEX in a struct type.  INDEX is the\n+  // entry in the FIELDS std::vector parameter of struct_type or\n+  // set_placeholder_struct_type.\n+  virtual size_t\n+  type_field_offset(Btype*, size_t index) = 0;\n+\n   // Expressions.\n \n   // Return an expression for a zero value of the given type.  This is"}, {"sha": "337b9494aaa2478cb5db2808a660a280286ee878", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 34, "deletions": 45, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -7979,35 +7979,32 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n \treturn false;\n       if (arg_type->named_type() != NULL)\n \targ_type->named_type()->convert(this->gogo_);\n-      tree arg_type_tree = type_to_tree(arg_type->get_backend(this->gogo_));\n-      if (arg_type_tree == error_mark_node)\n-\treturn false;\n-      unsigned long val_long;\n+\n+      unsigned int ret;\n       if (this->code_ == BUILTIN_SIZEOF)\n \t{\n-\t  tree type_size = TYPE_SIZE_UNIT(arg_type_tree);\n-\t  go_assert(TREE_CODE(type_size) == INTEGER_CST);\n-\t  if (TREE_INT_CST_HIGH(type_size) != 0)\n-\t    return false;\n-\t  unsigned HOST_WIDE_INT val_wide = TREE_INT_CST_LOW(type_size);\n-\t  val_long = static_cast<unsigned long>(val_wide);\n-\t  if (val_long != val_wide)\n+\t  if (!arg_type->backend_type_size(this->gogo_, &ret))\n \t    return false;\n \t}\n       else if (this->code_ == BUILTIN_ALIGNOF)\n \t{\n \t  if (arg->field_reference_expression() == NULL)\n-\t    val_long = go_type_alignment(arg_type_tree);\n+\t    {\n+\t      if (!arg_type->backend_type_align(this->gogo_, &ret))\n+\t\treturn false;\n+\t    }\n \t  else\n \t    {\n \t      // Calling unsafe.Alignof(s.f) returns the alignment of\n \t      // the type of f when it is used as a field in a struct.\n-\t      val_long = go_field_alignment(arg_type_tree);\n+\t      if (!arg_type->backend_type_field_align(this->gogo_, &ret))\n+\t\treturn false;\n \t    }\n \t}\n       else\n \tgo_unreachable();\n-      mpz_set_ui(val, val_long);\n+\n+      mpz_set_ui(val, ret);\n       *ptype = NULL;\n       return true;\n     }\n@@ -8025,21 +8022,12 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n \treturn false;\n       if (st->named_type() != NULL)\n \tst->named_type()->convert(this->gogo_);\n-      tree struct_tree = type_to_tree(st->get_backend(this->gogo_));\n-      go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n-      tree field = TYPE_FIELDS(struct_tree);\n-      for (unsigned int index = farg->field_index(); index > 0; --index)\n-\t{\n-\t  field = DECL_CHAIN(field);\n-\t  go_assert(field != NULL_TREE);\n-\t}\n-      HOST_WIDE_INT offset_wide = int_byte_position (field);\n-      if (offset_wide < 0)\n+      unsigned int offset;\n+      if (!st->struct_type()->backend_field_offset(this->gogo_,\n+\t\t\t\t\t\t   farg->field_index(),\n+\t\t\t\t\t\t   &offset))\n \treturn false;\n-      unsigned long offset_long = static_cast<unsigned long>(offset_wide);\n-      if (offset_long != static_cast<unsigned HOST_WIDE_INT>(offset_wide))\n-\treturn false;\n-      mpz_set_ui(val, offset_long);\n+      mpz_set_ui(val, offset);\n       return true;\n     }\n   return false;\n@@ -13939,25 +13927,26 @@ Type_info_expression::do_type()\n tree\n Type_info_expression::do_get_tree(Translate_context* context)\n {\n-  tree type_tree = type_to_tree(this->type_->get_backend(context->gogo()));\n-  if (type_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  tree val_type_tree = type_to_tree(this->type()->get_backend(context->gogo()));\n-  go_assert(val_type_tree != error_mark_node);\n-\n-  if (this->type_info_ == TYPE_INFO_SIZE)\n-    return fold_convert_loc(BUILTINS_LOCATION, val_type_tree,\n-\t\t\t    TYPE_SIZE_UNIT(type_tree));\n-  else\n+  Btype* btype = this->type_->get_backend(context->gogo());\n+  Gogo* gogo = context->gogo();\n+  size_t val;\n+  switch (this->type_info_)\n     {\n-      unsigned int val;\n-      if (this->type_info_ == TYPE_INFO_ALIGNMENT)\n-\tval = go_type_alignment(type_tree);\n-      else\n-\tval = go_field_alignment(type_tree);\n-      return build_int_cstu(val_type_tree, val);\n+    case TYPE_INFO_SIZE:\n+      val = gogo->backend()->type_size(btype);\n+      break;\n+    case TYPE_INFO_ALIGNMENT:\n+      val = gogo->backend()->type_alignment(btype);\n+      break;\n+    case TYPE_INFO_FIELD_ALIGNMENT:\n+      val = gogo->backend()->type_field_alignment(btype);\n+      break;\n+    default:\n+      go_unreachable();\n     }\n+  tree val_type_tree = type_to_tree(this->type()->get_backend(gogo));\n+  go_assert(val_type_tree != error_mark_node);\n+  return build_int_cstu(val_type_tree, val);\n }\n \n // Dump ast representation for a type info expression."}, {"sha": "d93b68bfc109939ccab76b6a903ce0f97f8a2d16", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 145, "deletions": 2, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -1950,6 +1950,126 @@ Type::mangled_name(Gogo* gogo) const\n   return ret;\n }\n \n+// Return whether the backend size of the type is known.\n+\n+bool\n+Type::is_backend_type_size_known(Gogo* gogo) const\n+{\n+  switch (this->classification_)\n+    {\n+    case TYPE_ERROR:\n+    case TYPE_VOID:\n+    case TYPE_BOOLEAN:\n+    case TYPE_INTEGER:\n+    case TYPE_FLOAT:\n+    case TYPE_COMPLEX:\n+    case TYPE_STRING:\n+    case TYPE_FUNCTION:\n+    case TYPE_POINTER:\n+    case TYPE_NIL:\n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+    case TYPE_INTERFACE:\n+      return true;\n+\n+    case TYPE_STRUCT:\n+      {\n+\tconst Struct_field_list* fields = this->struct_type()->fields();\n+\tfor (Struct_field_list::const_iterator pf = fields->begin();\n+\t     pf != fields->end();\n+\t     ++pf)\n+\t  if (!pf->type()->is_backend_type_size_known(gogo))\n+\t    return false;\n+\treturn true;\n+      }\n+\n+    case TYPE_ARRAY:\n+      {\n+\tconst Array_type* at = this->array_type();\n+\tif (at->length() == NULL)\n+\t  return true;\n+\telse\n+\t  {\n+\t    mpz_t ival;\n+\t    mpz_init(ival);\n+\t    Type* dummy;\n+\t    bool length_known = at->length()->integer_constant_value(true,\n+\t\t\t\t\t\t\t\t     ival,\n+\t\t\t\t\t\t\t\t     &dummy);\n+\t    mpz_clear(ival);\n+\t    if (!length_known)\n+\t      return false;\n+\t    return at->element_type()->is_backend_type_size_known(gogo);\n+\t  }\n+      }\n+\n+    case TYPE_NAMED:\n+      return this->named_type()->is_named_backend_type_size_known();\n+\n+    case TYPE_FORWARD:\n+      {\n+\tconst Forward_declaration_type* fdt = this->forward_declaration_type();\n+\treturn fdt->real_type()->is_backend_type_size_known(gogo);\n+      }\n+\n+    case TYPE_SINK:\n+    case TYPE_CALL_MULTIPLE_RESULT:\n+      go_unreachable();\n+\n+    default:\n+      go_unreachable();\n+    }\n+}\n+\n+// If the size of the type can be determined, set *PSIZE to the size\n+// in bytes and return true.  Otherwise, return false.  This queries\n+// the backend.\n+\n+bool\n+Type::backend_type_size(Gogo* gogo, unsigned int *psize)\n+{\n+  Btype* btype = this->get_backend(gogo);\n+  if (!this->is_backend_type_size_known(gogo))\n+    return false;\n+  size_t size = gogo->backend()->type_size(btype);\n+  *psize = static_cast<unsigned int>(size);\n+  if (*psize != size)\n+    return false;\n+  return true;\n+}\n+\n+// If the alignment of the type can be determined, set *PALIGN to\n+// the alignment in bytes and return true.  Otherwise, return false.\n+\n+bool\n+Type::backend_type_align(Gogo* gogo, unsigned int *palign)\n+{\n+  Btype* btype = this->get_backend(gogo);\n+  if (!this->is_backend_type_size_known(gogo))\n+    return false;\n+  size_t align = gogo->backend()->type_alignment(btype);\n+  *palign = static_cast<unsigned int>(align);\n+  if (*palign != align)\n+    return false;\n+  return true;\n+}\n+\n+// Like backend_type_align, but return the alignment when used as a\n+// field.\n+\n+bool\n+Type::backend_type_field_align(Gogo* gogo, unsigned int *palign)\n+{\n+  Btype* btype = this->get_backend(gogo);\n+  if (!this->is_backend_type_size_known(gogo))\n+    return false;\n+  size_t a = gogo->backend()->type_field_alignment(btype);\n+  *palign = static_cast<unsigned int>(a);\n+  if (*palign != a)\n+    return false;\n+  return true;\n+}\n+\n // Default function to export a type.\n \n void\n@@ -4589,6 +4709,24 @@ Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n   ret->push_back('e');\n }\n \n+// If the offset of field INDEX in the backend implementation can be\n+// determined, set *POFFSET to the offset in bytes and return true.\n+// Otherwise, return false.\n+\n+bool\n+Struct_type::backend_field_offset(Gogo* gogo, unsigned int index,\n+\t\t\t\t  unsigned int* poffset)\n+{\n+  Btype* btype = this->get_backend(gogo);\n+  if (!this->is_backend_type_size_known(gogo))\n+    return false;\n+  size_t offset = gogo->backend()->type_field_offset(btype, index);\n+  *poffset = static_cast<unsigned int>(offset);\n+  if (*poffset != offset)\n+    return false;\n+  return true;\n+}\n+\n // Export.\n \n void\n@@ -7518,6 +7656,7 @@ Named_type::convert(Gogo* gogo)\n \n   this->named_btype_ = bt;\n   this->is_converted_ = true;\n+  this->is_placeholder_ = false;\n }\n \n // Create the placeholder for a named type.  This is the first step in\n@@ -7578,6 +7717,7 @@ Named_type::create_placeholder(Gogo* gogo)\n     case TYPE_STRUCT:\n       bt = gogo->backend()->placeholder_struct_type(this->name(),\n \t\t\t\t\t\t    this->location_);\n+      this->is_placeholder_ = true;\n       set_name = false;\n       break;\n \n@@ -7586,8 +7726,11 @@ Named_type::create_placeholder(Gogo* gogo)\n \tbt = gogo->backend()->placeholder_struct_type(this->name(),\n \t\t\t\t\t\t      this->location_);\n       else\n-\tbt = gogo->backend()->placeholder_array_type(this->name(),\n-\t\t\t\t\t\t     this->location_);\n+\t{\n+\t  bt = gogo->backend()->placeholder_array_type(this->name(),\n+\t\t\t\t\t\t       this->location_);\n+\t  this->is_placeholder_ = true;\n+\t}\n       set_name = false;\n       break;\n "}, {"sha": "200164c6ab26c2da50ab06212cc4dcd34d56c402", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=ef1ed13d9ab2e2c9dacdb5ae06afb86ca6ad7193", "patch": "@@ -861,6 +861,27 @@ class Type\n   std::string\n   mangled_name(Gogo*) const;\n \n+  // If the size of the type can be determined, set *PSIZE to the size\n+  // in bytes and return true.  Otherwise, return false.  This queries\n+  // the backend.\n+  bool\n+  backend_type_size(Gogo*, unsigned int* psize);\n+\n+  // If the alignment of the type can be determined, set *PALIGN to\n+  // the alignment in bytes and return true.  Otherwise, return false.\n+  bool\n+  backend_type_align(Gogo*, unsigned int* palign);\n+\n+  // If the alignment of a struct field of this type can be\n+  // determined, set *PALIGN to the alignment in bytes and return\n+  // true.  Otherwise, return false.\n+  bool\n+  backend_type_field_align(Gogo*, unsigned int* palign);\n+\n+  // Whether the backend size is known.\n+  bool\n+  is_backend_type_size_known(Gogo*) const;\n+\n   // Get the hash and equality functions for a type.\n   void\n   type_functions(Gogo*, Named_type* name, Function_type* hash_fntype,\n@@ -2013,6 +2034,12 @@ class Struct_type : public Type\n   traverse_field_types(Traverse* traverse)\n   { return this->do_traverse(traverse); }\n \n+  // If the offset of field INDEX in the backend implementation can be\n+  // determined, set *POFFSET to the offset in bytes and return true.\n+  // Otherwise, return false.\n+  bool\n+  backend_field_offset(Gogo*, unsigned int index, unsigned int* poffset);\n+\n   // Import a struct type.\n   static Struct_type*\n   do_import(Import*);\n@@ -2507,8 +2534,9 @@ class Named_type : public Type\n       local_methods_(NULL), all_methods_(NULL),\n       interface_method_tables_(NULL), pointer_interface_method_tables_(NULL),\n       location_(location), named_btype_(NULL), dependencies_(),\n-      is_visible_(true), is_error_(false), is_converted_(false),\n-      is_circular_(false), seen_(false), seen_in_get_backend_(false)\n+      is_visible_(true), is_error_(false), is_placeholder_(false),\n+      is_converted_(false), is_circular_(false), seen_(false),\n+      seen_in_get_backend_(false)\n   { }\n \n   // Return the associated Named_object.  This holds the actual name.\n@@ -2672,6 +2700,13 @@ class Named_type : public Type\n   add_dependency(Named_type* nt)\n   { this->dependencies_.push_back(nt); }\n \n+  // Return true if the size and alignment of the backend\n+  // representation of this type is known.  This is always true after\n+  // types have been converted, but may be false beforehand.\n+  bool\n+  is_named_backend_type_size_known() const\n+  { return this->named_btype_ != NULL && !this->is_placeholder_; }\n+\n   // Export the type.\n   void\n   export_named_type(Export*, const std::string& name) const;\n@@ -2766,8 +2801,11 @@ class Named_type : public Type\n   bool is_visible_;\n   // Whether this type is erroneous.\n   bool is_error_;\n+  // Whether the current value of named_btype_ is a placeholder for\n+  // which the final size of the type is not known.\n+  bool is_placeholder_;\n   // Whether this type has been converted to the backend\n-  // representation.\n+  // representation.  Implies that is_placeholder_ is false.\n   bool is_converted_;\n   // Whether this is a pointer or function type which refers to the\n   // type itself."}]}