{"sha": "6147e9d0c9a0f329bb278c73321400525c0066ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE0N2U5ZDBjOWEwZjMyOWJiMjc4YzczMzIxNDAwNTI1YzAwNjZhZQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-12-28T04:34:33Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-12-28T04:34:33Z"}, "message": "re PR libgcj/1516 (Method.invoke won't accept boolean parameters)\n\n\tFix for PR libgcj/1516:\n\t* java/lang/reflect/natMethod.cc (primitives): Remove void entry.\n\tAdd boolean entry.\n\t(can_widen): Declared inline. Remove redundant checks for void\n\targuments and char->short conversion. Add special case for boolean\n\tconversions.\n\t(ffi_type): Declared inline.\n\t(_Jv_CallAnyMethodA): Move unwrapping logic inside isPrimitive() block.\n\nFrom-SVN: r38506", "tree": {"sha": "e2e74608e77b55df5cf68f5e3403d53821775e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e74608e77b55df5cf68f5e3403d53821775e72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6147e9d0c9a0f329bb278c73321400525c0066ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6147e9d0c9a0f329bb278c73321400525c0066ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6147e9d0c9a0f329bb278c73321400525c0066ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6147e9d0c9a0f329bb278c73321400525c0066ae/comments", "author": null, "committer": null, "parents": [{"sha": "867e24ad3d3190a4b7b54bc8665d1066907d4079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867e24ad3d3190a4b7b54bc8665d1066907d4079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867e24ad3d3190a4b7b54bc8665d1066907d4079"}], "stats": {"total": 82, "additions": 48, "deletions": 34}, "files": [{"sha": "84b0124deebd826e350c93bd62026d0374b30253", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6147e9d0c9a0f329bb278c73321400525c0066ae/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6147e9d0c9a0f329bb278c73321400525c0066ae/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6147e9d0c9a0f329bb278c73321400525c0066ae", "patch": "@@ -1,3 +1,17 @@\n+2000-12-28  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/lang/natClass.cc (_Jv_IsAssignableFrom): Primitive TYPEs can\n+\tnot be assigned to Object.\n+\n+\tFix for PR libgcj/1516:\n+\t* java/lang/reflect/natMethod.cc (primitives): Remove void entry.\n+\tAdd boolean entry.\n+\t(can_widen): Declared inline. Remove redundant checks for void \n+\targuments and char->short conversion. Add special case for boolean \n+\tconversions.\n+\t(ffi_type): Declared inline.\n+\t(_Jv_CallAnyMethodA): Move unwrapping logic inside isPrimitive() block.\n+\n 2000-12-26  Petter Reinholdtsen  <pere@hungry.com>\n \n \t* java/sql/SQLWarning.java: Fixed typo in comment."}, {"sha": "26886e9bd85258108aec2fdb4c0fd93965f2b0e4", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6147e9d0c9a0f329bb278c73321400525c0066ae/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6147e9d0c9a0f329bb278c73321400525c0066ae/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=6147e9d0c9a0f329bb278c73321400525c0066ae", "patch": "@@ -47,6 +47,7 @@ details.  */\n #include <ffi.h>\n \n // FIXME: remove these.\n+#define BooleanClass java::lang::Boolean::class$\n #define VoidClass java::lang::Void::class$\n #define ByteClass java::lang::Byte::class$\n #define ShortClass java::lang::Short::class$\n@@ -66,8 +67,8 @@ struct cpair\n // allowed.\n static cpair primitives[] =\n {\n-#define VOID 0\n-  { JvPrimClass (void), &VoidClass },\n+#define BOOLEAN 0\n+  { JvPrimClass (boolean), &BooleanClass },\n   { JvPrimClass (byte), &ByteClass },\n #define SHORT 2\n   { JvPrimClass (short), &ShortClass },\n@@ -80,7 +81,7 @@ static cpair primitives[] =\n   { NULL, NULL }\n };\n \n-static jboolean\n+static inline jboolean\n can_widen (jclass from, jclass to)\n {\n   int fromx = -1, tox = -1;\n@@ -96,17 +97,17 @@ can_widen (jclass from, jclass to)\n   // Can't handle a miss.\n   if (fromx == -1 || tox == -1)\n     return false;\n-  // Can't handle Void arguments.\n-  if (fromx == VOID || tox == VOID)\n+  // Boolean arguments may not be widened.\n+  if (fromx == BOOLEAN && tox != BOOLEAN)\n     return false;\n-  // Special-case short/char conversions.\n-  if ((fromx == SHORT && tox == CHAR) || (fromx == CHAR && tox == SHORT))\n+  // Special-case short->char conversions.\n+  if (fromx == SHORT && tox == CHAR)\n     return false;\n \n   return fromx <= tox;\n }\n \n-static ffi_type *\n+static inline ffi_type *\n get_ffi_type (jclass klass)\n {\n   // A special case.\n@@ -469,37 +470,36 @@ _Jv_CallAnyMethodA (jobject obj,\n \t      || ! k\n \t      || ! can_widen (k, paramelts[i]))\n \t    JvThrow (new java::lang::IllegalArgumentException);\n+\t    \n+\t  if (paramelts[i] == JvPrimClass (boolean))\n+\t    COPY (&argvals[i],\n+\t\t  ((java::lang::Boolean *) argelts[i])->booleanValue(),\n+\t\t  jboolean);\n+\t  else if (paramelts[i] == JvPrimClass (char))\n+\t    COPY (&argvals[i],\n+\t\t  ((java::lang::Character *) argelts[i])->charValue(),\n+\t\t  jchar);\n+          else\n+\t    {\n+\t      java::lang::Number *num = (java::lang::Number *) argelts[i];\n+\t      if (paramelts[i] == JvPrimClass (byte))\n+\t\tCOPY (&argvals[i], num->byteValue(), jbyte);\n+\t      else if (paramelts[i] == JvPrimClass (short))\n+\t\tCOPY (&argvals[i], num->shortValue(), jshort);\n+\t      else if (paramelts[i] == JvPrimClass (int))\n+\t\tCOPY (&argvals[i], num->intValue(), jint);\n+\t      else if (paramelts[i] == JvPrimClass (long))\n+\t\tCOPY (&argvals[i], num->longValue(), jlong);\n+\t      else if (paramelts[i] == JvPrimClass (float))\n+\t\tCOPY (&argvals[i], num->floatValue(), jfloat);\n+\t      else if (paramelts[i] == JvPrimClass (double))\n+\t\tCOPY (&argvals[i], num->doubleValue(), jdouble);\n+\t    }\n \t}\n       else\n \t{\n \t  if (argelts[i] && ! paramelts[i]->isAssignableFrom (k))\n \t    JvThrow (new java::lang::IllegalArgumentException);\n-\t}\n-\n-      java::lang::Number *num = (java::lang::Number *) argelts[i];\n-      if (paramelts[i] == JvPrimClass (byte))\n-\tCOPY (&argvals[i], num->byteValue(), jbyte);\n-      else if (paramelts[i] == JvPrimClass (short))\n-\tCOPY (&argvals[i], num->shortValue(), jshort);\n-      else if (paramelts[i] == JvPrimClass (int))\n-\tCOPY (&argvals[i], num->intValue(), jint);\n-      else if (paramelts[i] == JvPrimClass (long))\n-\tCOPY (&argvals[i], num->longValue(), jlong);\n-      else if (paramelts[i] == JvPrimClass (float))\n-\tCOPY (&argvals[i], num->floatValue(), jfloat);\n-      else if (paramelts[i] == JvPrimClass (double))\n-\tCOPY (&argvals[i], num->doubleValue(), jdouble);\n-      else if (paramelts[i] == JvPrimClass (boolean))\n-\tCOPY (&argvals[i],\n-\t      ((java::lang::Boolean *) argelts[i])->booleanValue(),\n-\t      jboolean);\n-      else if (paramelts[i] == JvPrimClass (char))\n-\tCOPY (&argvals[i],\n-\t      ((java::lang::Character *) argelts[i])->charValue(),\n-\t      jchar);\n-      else\n-\t{\n-\t  JvAssert (! paramelts[i]->isPrimitive());\n \t  COPY (&argvals[i], argelts[i], jobject);\n \t}\n     }"}]}