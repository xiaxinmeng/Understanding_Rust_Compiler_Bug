{"sha": "1de31913d20a467b78904c0e96efd5fbd6facd2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRlMzE5MTNkMjBhNDY3Yjc4OTA0YzBlOTZlZmQ1ZmJkNmZhY2QyYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-06-15T14:06:38Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-06-15T14:07:11Z"}, "message": "Fortran/OpenMP: Extend defaultmap clause for OpenMP 5 [PR92568]\n\n\tPR fortran/92568\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.c (show_omp_clauses): Update for defaultmap.\n\t* f95-lang.c (LANG_HOOKS_OMP_ALLOCATABLE_P,\n\tLANG_HOOKS_OMP_SCALAR_TARGET_P): New.\n\t* gfortran.h (enum gfc_omp_defaultmap,\n\tenum gfc_omp_defaultmap_category): New.\n\t* openmp.c (gfc_match_omp_clauses): Update defaultmap matching.\n\t* trans-decl.c (gfc_finish_decl_attrs): Set GFC_DECL_SCALAR_TARGET.\n\t* trans-openmp.c (gfc_omp_allocatable_p, gfc_omp_scalar_target_p): New.\n\t(gfc_omp_scalar_p): Take 'ptr_alloc_ok' argument.\n\t(gfc_trans_omp_clauses, gfc_split_omp_clauses): Update for\n\tdefaultmap changes.\n\t* trans.h (gfc_omp_scalar_p): Update prototype.\n\t(gfc_omp_allocatable_p, gfc_omp_scalar_target_p): New.\n\t(struct lang_decl): Add scalar_target.\n\t(GFC_DECL_SCALAR_TARGET, GFC_DECL_GET_SCALAR_TARGET): New.\n\ngcc/ChangeLog:\n\n\t* gimplify.c (enum gimplify_defaultmap_kind): Add GDMK_SCALAR_TARGET.\n\t(struct gimplify_omp_ctx): Extend defaultmap array by one.\n\t(new_omp_context): Init defaultmap[GDMK_SCALAR_TARGET].\n\t(omp_notice_variable): Update type classification for Fortran.\n\t(gimplify_scan_omp_clauses): Update calls for new argument; handle\n\tGDMK_SCALAR_TARGET; for Fortran, GDMK_POINTER avoid GOVD_MAP_0LEN_ARRAY.\n\t* langhooks-def.h (lhd_omp_scalar_p): Add 'ptr_ok' argument.\n\t* langhooks.c (lhd_omp_scalar_p): Likewise.\n\t(LANG_HOOKS_OMP_ALLOCATABLE_P, LANG_HOOKS_OMP_SCALAR_TARGET_P): New.\n\t(LANG_HOOKS_DECLS): Add them.\n\t* langhooks.h (struct lang_hooks_for_decls): Add new hooks, update\n\tomp_scalar_p pointer type to include the new bool argument.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.fortran/defaultmap-8.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/pr99928-1.f90: Uncomment 'defaultmap(none)'.\n\t* gfortran.dg/gomp/pr99928-2.f90: Uncomment 'defaultmap(none)'.\n\t* gfortran.dg/gomp/pr99928-3.f90: Uncomment 'defaultmap(none)'.\n\t* gfortran.dg/gomp/pr99928-4.f90: Uncomment 'defaultmap(none)'.\n\t* gfortran.dg/gomp/pr99928-5.f90: Uncomment 'defaultmap(none)'.\n\t* gfortran.dg/gomp/pr99928-6.f90: Uncomment 'defaultmap(none)'.\n\t* gfortran.dg/gomp/pr99928-8.f90: Uncomment 'defaultmap(none)'.\n\t* gfortran.dg/gomp/defaultmap-1.f90: New test.\n\t* gfortran.dg/gomp/defaultmap-2.f90: New test.\n\t* gfortran.dg/gomp/defaultmap-3.f90: New test.\n\t* gfortran.dg/gomp/defaultmap-4.f90: New test.\n\t* gfortran.dg/gomp/defaultmap-5.f90: New test.\n\t* gfortran.dg/gomp/defaultmap-6.f90: New test.\n\t* gfortran.dg/gomp/defaultmap-7.f90: New test.", "tree": {"sha": "56187de4669a2701ebd347a3a794d99419250b05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56187de4669a2701ebd347a3a794d99419250b05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1de31913d20a467b78904c0e96efd5fbd6facd2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de31913d20a467b78904c0e96efd5fbd6facd2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de31913d20a467b78904c0e96efd5fbd6facd2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de31913d20a467b78904c0e96efd5fbd6facd2c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b"}], "stats": {"total": 1294, "additions": 1217, "deletions": 77}, "files": [{"sha": "07e98b7e30d2767834fe08159718f6d1b90b46cd", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -1751,16 +1751,48 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n     }\n   if (omp_clauses->dist_sched_kind != OMP_SCHED_NONE)\n     {\n-      fprintf (dumpfile, \" DIST_SCHEDULE (STATIC\");\n+      fputs (\" DIST_SCHEDULE (STATIC\", dumpfile);\n       if (omp_clauses->dist_chunk_size)\n \t{\n \t  fputc (',', dumpfile);\n \t  show_expr (omp_clauses->dist_chunk_size);\n \t}\n       fputc (')', dumpfile);\n     }\n-  if (omp_clauses->defaultmap)\n-    fputs (\" DEFALTMAP (TOFROM: SCALAR)\", dumpfile);\n+  for (int i = 0; i < OMP_DEFAULTMAP_CAT_NUM; i++)\n+    {\n+      const char *dfltmap;\n+      if (omp_clauses->defaultmap[i] == OMP_DEFAULTMAP_UNSET)\n+\tcontinue;\n+      fputs (\" DEFAULTMAP (\", dumpfile);\n+      switch (omp_clauses->defaultmap[i])\n+\t{\n+\tcase OMP_DEFAULTMAP_ALLOC: dfltmap = \"ALLOC\"; break;\n+\tcase OMP_DEFAULTMAP_TO: dfltmap = \"TO\"; break;\n+\tcase OMP_DEFAULTMAP_FROM: dfltmap = \"FROM\"; break;\n+\tcase OMP_DEFAULTMAP_TOFROM: dfltmap = \"TOFROM\"; break;\n+\tcase OMP_DEFAULTMAP_FIRSTPRIVATE: dfltmap = \"FIRSTPRIVATE\"; break;\n+\tcase OMP_DEFAULTMAP_NONE: dfltmap = \"NONE\"; break;\n+\tcase OMP_DEFAULTMAP_DEFAULT: dfltmap = \"DEFAULT\"; break;\n+\tcase OMP_DEFAULTMAP_PRESENT: dfltmap = \"PRESENT\"; break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+      fputs (dfltmap, dumpfile);\n+      if (i != OMP_DEFAULTMAP_CAT_UNCATEGORIZED)\n+\t{\n+\t  fputc (':', dumpfile);\n+\t  switch ((enum gfc_omp_defaultmap) i)\n+\t    {\n+\t    case OMP_DEFAULTMAP_CAT_SCALAR: dfltmap = \"SCALAR\"; break;\n+\t    case OMP_DEFAULTMAP_CAT_AGGREGATE: dfltmap = \"AGGREGATE\"; break;\n+\t    case OMP_DEFAULTMAP_CAT_ALLOCATABLE: dfltmap = \"ALLOCATABLE\"; break;\n+\t    case OMP_DEFAULTMAP_CAT_POINTER: dfltmap = \"POINTER\"; break;\n+\t    default: gcc_unreachable ();\n+\t    }\n+\t  fputs (dfltmap, dumpfile);\n+\t}\n+      fputc (')', dumpfile);\n+    }\n   if (omp_clauses->nogroup)\n     fputs (\" NOGROUP\", dumpfile);\n   if (omp_clauses->simd)"}, {"sha": "5fc848158f927c0f1e2e04c2d922609115f473a9", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -126,6 +126,8 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR\n #undef LANG_HOOKS_OMP_CLAUSE_DTOR\n #undef LANG_HOOKS_OMP_FINISH_CLAUSE\n+#undef LANG_HOOKS_OMP_ALLOCATABLE_P\n+#undef LANG_HOOKS_OMP_SCALAR_TARGET_P\n #undef LANG_HOOKS_OMP_SCALAR_P\n #undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n #undef LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\n@@ -162,7 +164,9 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR\tgfc_omp_clause_linear_ctor\n #define LANG_HOOKS_OMP_CLAUSE_DTOR\t\tgfc_omp_clause_dtor\n #define LANG_HOOKS_OMP_FINISH_CLAUSE\t\tgfc_omp_finish_clause\n+#define LANG_HOOKS_OMP_ALLOCATABLE_P\t\tgfc_omp_allocatable_p\n #define LANG_HOOKS_OMP_SCALAR_P\t\t\tgfc_omp_scalar_p\n+#define LANG_HOOKS_OMP_SCALAR_TARGET_P\t\tgfc_omp_scalar_target_p\n #define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\tgfc_omp_disregard_value_expr\n #define LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\tgfc_omp_private_debug_clause\n #define LANG_HOOKS_OMP_PRIVATE_OUTER_REF\tgfc_omp_private_outer_ref"}, {"sha": "f4a50d74f141b6b7784da0224b8fa3d8526275c3", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -1241,6 +1241,29 @@ enum gfc_omp_map_op\n   OMP_MAP_ALWAYS_TOFROM\n };\n \n+enum gfc_omp_defaultmap\n+{\n+  OMP_DEFAULTMAP_UNSET,\n+  OMP_DEFAULTMAP_ALLOC,\n+  OMP_DEFAULTMAP_TO,\n+  OMP_DEFAULTMAP_FROM,\n+  OMP_DEFAULTMAP_TOFROM,\n+  OMP_DEFAULTMAP_FIRSTPRIVATE,\n+  OMP_DEFAULTMAP_NONE,\n+  OMP_DEFAULTMAP_DEFAULT,\n+  OMP_DEFAULTMAP_PRESENT\n+};\n+\n+enum gfc_omp_defaultmap_category\n+{\n+  OMP_DEFAULTMAP_CAT_UNCATEGORIZED,\n+  OMP_DEFAULTMAP_CAT_SCALAR,\n+  OMP_DEFAULTMAP_CAT_AGGREGATE,\n+  OMP_DEFAULTMAP_CAT_ALLOCATABLE,\n+  OMP_DEFAULTMAP_CAT_POINTER,\n+  OMP_DEFAULTMAP_CAT_NUM\n+};\n+\n enum gfc_omp_linear_op\n {\n   OMP_LINEAR_DEFAULT,\n@@ -1423,9 +1446,10 @@ typedef struct gfc_omp_clauses\n   enum gfc_omp_device_type device_type;\n   struct gfc_expr *chunk_size;\n   enum gfc_omp_default_sharing default_sharing;\n+  enum gfc_omp_defaultmap defaultmap[OMP_DEFAULTMAP_CAT_NUM];\n   int collapse, orderedc;\n   bool nowait, ordered, untied, mergeable;\n-  bool inbranch, notinbranch, defaultmap, nogroup;\n+  bool inbranch, notinbranch, nogroup;\n   bool sched_simd, sched_monotonic, sched_nonmonotonic;\n   bool simd, threads, depend_source, destroy, order_concurrent, capture;\n   enum gfc_omp_atomic_op atomic_op;"}, {"sha": "357a1e15e019447c29af14172db282c617a30ee3", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -1539,10 +1539,87 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\tcontinue;\n \t    }\n \t  if ((mask & OMP_CLAUSE_DEFAULTMAP)\n-\t      && !c->defaultmap\n-\t      && gfc_match (\"defaultmap ( tofrom : scalar )\") == MATCH_YES)\n+\t      && gfc_match (\"defaultmap ( \") == MATCH_YES)\n \t    {\n-\t      c->defaultmap = true;\n+\t      enum gfc_omp_defaultmap behavior;\n+\t      gfc_omp_defaultmap_category category\n+\t\t= OMP_DEFAULTMAP_CAT_UNCATEGORIZED;\n+\t      if (gfc_match (\"alloc \") == MATCH_YES)\n+\t\tbehavior = OMP_DEFAULTMAP_ALLOC;\n+\t      else if (gfc_match (\"tofrom \") == MATCH_YES)\n+\t\tbehavior = OMP_DEFAULTMAP_TOFROM;\n+\t      else if (gfc_match (\"to \") == MATCH_YES)\n+\t\tbehavior = OMP_DEFAULTMAP_TO;\n+\t      else if (gfc_match (\"from \") == MATCH_YES)\n+\t\tbehavior = OMP_DEFAULTMAP_FROM;\n+\t      else if (gfc_match (\"firstprivate \") == MATCH_YES)\n+\t\tbehavior = OMP_DEFAULTMAP_FIRSTPRIVATE;\n+\t      else if (gfc_match (\"none \") == MATCH_YES)\n+\t\tbehavior = OMP_DEFAULTMAP_NONE;\n+\t      else if (gfc_match (\"default \") == MATCH_YES)\n+\t\tbehavior = OMP_DEFAULTMAP_DEFAULT;\n+\t      else\n+\t\t{\n+\t\t  gfc_error (\"Expected ALLOC, TO, FROM, TOFROM, FIRSTPRIVATE, \"\n+\t\t\t   \"NONE or DEFAULT at %C\");\n+\t\t  break;\n+\t\t}\n+\t      if (')' == gfc_peek_ascii_char ())\n+\t\t;\n+\t      else if (gfc_match (\": \") != MATCH_YES)\n+\t\tbreak;\n+\t      else\n+\t\t{\n+\t\t  if (gfc_match (\"scalar \") == MATCH_YES)\n+\t\t    category = OMP_DEFAULTMAP_CAT_SCALAR;\n+\t\t  else if (gfc_match (\"aggregate \") == MATCH_YES)\n+\t\t    category = OMP_DEFAULTMAP_CAT_AGGREGATE;\n+\t\t  else if (gfc_match (\"allocatable \") == MATCH_YES)\n+\t\t    category = OMP_DEFAULTMAP_CAT_ALLOCATABLE;\n+\t\t  else if (gfc_match (\"pointer \") == MATCH_YES)\n+\t\t    category = OMP_DEFAULTMAP_CAT_POINTER;\n+\t\t  else\n+\t\t    {\n+\t\t      gfc_error (\"Expected SCALAR, AGGREGATE, ALLOCATABLE or \"\n+\t\t\t\t \"POINTER at %C\");\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      for (int i = 0; i < OMP_DEFAULTMAP_CAT_NUM; ++i)\n+\t\t{\n+\t\t  if (i != category\n+\t\t      && category != OMP_DEFAULTMAP_CAT_UNCATEGORIZED)\n+\t\t    continue;\n+\t\t  if (c->defaultmap[i] != OMP_DEFAULTMAP_UNSET)\n+\t\t    {\n+\t\t      const char *pcategory = NULL;\n+\t\t      switch (i)\n+\t\t\t{\n+\t\t\tcase OMP_DEFAULTMAP_CAT_UNCATEGORIZED: break;\n+\t\t\tcase OMP_DEFAULTMAP_CAT_SCALAR: pcategory = \"SCALAR\"; break;\n+\t\t\tcase OMP_DEFAULTMAP_CAT_AGGREGATE:\n+\t\t\t  pcategory = \"AGGREGATE\";\n+\t\t\t  break;\n+\t\t\tcase OMP_DEFAULTMAP_CAT_ALLOCATABLE:\n+\t\t\t  pcategory = \"ALLOCATABLE\";\n+\t\t\t  break;\n+\t\t\tcase OMP_DEFAULTMAP_CAT_POINTER:\n+\t\t\t  pcategory = \"POINTER\";\n+\t\t\t  break;\n+\t\t\tdefault: gcc_unreachable ();\n+\t\t\t}\n+\t\t     if (i == OMP_DEFAULTMAP_CAT_UNCATEGORIZED)\n+\t\t      gfc_error (\"DEFAULTMAP at %C but prior DEFAULTMAP with \"\n+\t\t\t\t \"unspecified category\");\n+\t\t     else\n+\t\t      gfc_error (\"DEFAULTMAP at %C but prior DEFAULTMAP for \"\n+\t\t\t\t \"category %s\", pcategory);\n+\t\t     goto end;\n+\t\t    }\n+\t\t}\n+\t      c->defaultmap[category] = behavior;\n+\t      if (gfc_match (\")\") != MATCH_YES)\n+\t\tbreak;\n \t      continue;\n \t    }\n \t  if ((mask & OMP_CLAUSE_DELETE)\n@@ -2459,6 +2536,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n       break;\n     }\n \n+end:\n   if (gfc_match_omp_eos () != MATCH_YES)\n     {\n       if (!gfc_error_flag_test ())"}, {"sha": "479ba6fa6ce962025a37294b31af311e6a96af92", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -605,6 +605,11 @@ gfc_finish_decl_attrs (tree decl, symbol_attribute *attr)\n \t  gfc_allocate_lang_decl (decl);\n \t  GFC_DECL_SCALAR_POINTER (decl) = 1;\n \t}\n+      if (attr->target)\n+\t{\n+\t  gfc_allocate_lang_decl (decl);\n+\t  GFC_DECL_SCALAR_TARGET (decl) = 1;\n+\t}\n     }\n }\n "}, {"sha": "ce1991e366bf9835e92d7fa69a75a7850c36ff5d", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -393,6 +393,28 @@ gfc_is_unlimited_polymorphic_nonptr (tree type)\n   return true;\n }\n \n+/* Return true if the DECL is for an allocatable array or scalar.  */\n+\n+bool\n+gfc_omp_allocatable_p (tree decl)\n+{\n+  if (!DECL_P (decl))\n+    return false;\n+\n+  if (GFC_DECL_GET_SCALAR_ALLOCATABLE (decl))\n+    return true;\n+\n+  tree type = TREE_TYPE (decl);\n+  if (gfc_omp_privatize_by_reference (decl))\n+    type = TREE_TYPE (type);\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (type)\n+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n+    return true;\n+\n+  return false;\n+}\n+\n \n /* Return true if DECL in private clause needs\n    OMP_CLAUSE_PRIVATE_OUTER_REF on the private clause.  */\n@@ -1663,10 +1685,11 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p, bool openacc)\n \n \n /* Return true if DECL is a scalar variable (for the purpose of\n-   implicit firstprivatization).  */\n+   implicit firstprivatization/mapping). Only if 'ptr_alloc_ok.'\n+   is true, allocatables and pointers are permitted. */\n \n bool\n-gfc_omp_scalar_p (tree decl)\n+gfc_omp_scalar_p (tree decl, bool ptr_alloc_ok)\n {\n   tree type = TREE_TYPE (decl);\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n@@ -1675,7 +1698,11 @@ gfc_omp_scalar_p (tree decl)\n     {\n       if (GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)\n \t  || GFC_DECL_GET_SCALAR_POINTER (decl))\n-\ttype = TREE_TYPE (type);\n+\t{\n+\t  if (!ptr_alloc_ok)\n+\t    return false;\n+\t  type = TREE_TYPE (type);\n+\t}\n       if (GFC_ARRAY_TYPE_P (type)\n \t  || GFC_CLASS_TYPE_P (type))\n \treturn false;\n@@ -1691,6 +1718,17 @@ gfc_omp_scalar_p (tree decl)\n }\n \n \n+/* Return true if DECL is a scalar with target attribute but does not have the\n+   allocatable (or pointer) attribute (for the purpose of implicit mapping).  */\n+\n+bool\n+gfc_omp_scalar_target_p (tree decl)\n+{\n+  return (DECL_P (decl) && GFC_DECL_GET_SCALAR_TARGET (decl)\n+\t  && gfc_omp_scalar_p (decl, false));\n+}\n+\n+\n /* Return true if DECL's DECL_VALUE_EXPR (if any) should be\n    disregarded in OpenMP construct, because it is going to be\n    remapped during OpenMP lowering.  SHARED is true if DECL\n@@ -4036,13 +4074,55 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_NOGROUP);\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n-  if (clauses->defaultmap)\n+\n+  for (int i = 0; i < OMP_DEFAULTMAP_CAT_NUM; i++)\n     {\n+      if (clauses->defaultmap[i] == OMP_DEFAULTMAP_UNSET)\n+       continue;\n+      enum omp_clause_defaultmap_kind behavior, category;\n+      switch ((gfc_omp_defaultmap_category) i)\n+\t{\n+\tcase OMP_DEFAULTMAP_CAT_UNCATEGORIZED:\n+\t  category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED;\n+\t  break;\n+\tcase OMP_DEFAULTMAP_CAT_SCALAR:\n+\t  category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR;\n+\t  break;\n+\tcase OMP_DEFAULTMAP_CAT_AGGREGATE:\n+\t  category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE;\n+\t  break;\n+\tcase OMP_DEFAULTMAP_CAT_ALLOCATABLE:\n+\t  category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_ALLOCATABLE;\n+\t  break;\n+\tcase OMP_DEFAULTMAP_CAT_POINTER:\n+\t  category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER;\n+\t  break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+      switch (clauses->defaultmap[i])\n+\t{\n+\tcase OMP_DEFAULTMAP_ALLOC:\n+\t  behavior = OMP_CLAUSE_DEFAULTMAP_ALLOC;\n+\t  break;\n+\tcase OMP_DEFAULTMAP_TO: behavior = OMP_CLAUSE_DEFAULTMAP_TO; break;\n+\tcase OMP_DEFAULTMAP_FROM: behavior = OMP_CLAUSE_DEFAULTMAP_FROM; break;\n+\tcase OMP_DEFAULTMAP_TOFROM:\n+\t  behavior = OMP_CLAUSE_DEFAULTMAP_TOFROM;\n+\t  break;\n+\tcase OMP_DEFAULTMAP_FIRSTPRIVATE:\n+\t  behavior = OMP_CLAUSE_DEFAULTMAP_FIRSTPRIVATE;\n+\t  break;\n+\tcase OMP_DEFAULTMAP_NONE: behavior = OMP_CLAUSE_DEFAULTMAP_NONE; break;\n+\tcase OMP_DEFAULTMAP_DEFAULT:\n+\t  behavior = OMP_CLAUSE_DEFAULTMAP_DEFAULT;\n+\t  break;\n+\tdefault: gcc_unreachable ();\n+\t}\n       c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_DEFAULTMAP);\n-      OMP_CLAUSE_DEFAULTMAP_SET_KIND (c, OMP_CLAUSE_DEFAULTMAP_TOFROM,\n-\t\t\t\t      OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR);\n+      OMP_CLAUSE_DEFAULTMAP_SET_KIND (c, behavior, category);\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n+\n   if (clauses->depend_source)\n     {\n       c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_DEPEND);\n@@ -5672,8 +5752,9 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->lists[OMP_LIST_IS_DEVICE_PTR];\n \t  clausesa[GFC_OMP_SPLIT_TARGET].device\n \t    = code->ext.omp_clauses->device;\n-\t  clausesa[GFC_OMP_SPLIT_TARGET].defaultmap\n-\t    = code->ext.omp_clauses->defaultmap;\n+\t  for (int i = 0; i < OMP_DEFAULTMAP_CAT_NUM; i++)\n+\t    clausesa[GFC_OMP_SPLIT_TARGET].defaultmap[i]\n+\t      = code->ext.omp_clauses->defaultmap[i];\n \t  clausesa[GFC_OMP_SPLIT_TARGET].if_exprs[OMP_IF_TARGET]\n \t    = code->ext.omp_clauses->if_exprs[OMP_IF_TARGET];\n \t  /* And this is copied to all.  */"}, {"sha": "78578cfd7328655434ff802492621627399bdf38", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -823,7 +823,9 @@ tree gfc_omp_clause_assign_op (tree, tree, tree);\n tree gfc_omp_clause_linear_ctor (tree, tree, tree, tree);\n tree gfc_omp_clause_dtor (tree, tree);\n void gfc_omp_finish_clause (tree, gimple_seq *, bool);\n-bool gfc_omp_scalar_p (tree);\n+bool gfc_omp_allocatable_p (tree);\n+bool gfc_omp_scalar_p (tree, bool);\n+bool gfc_omp_scalar_target_p (tree);\n bool gfc_omp_disregard_value_expr (tree, bool);\n bool gfc_omp_private_debug_clause (tree, bool);\n bool gfc_omp_private_outer_ref (tree);\n@@ -1030,6 +1032,7 @@ struct GTY(()) lang_decl {\n   tree token, caf_offset;\n   unsigned int scalar_allocatable : 1;\n   unsigned int scalar_pointer : 1;\n+  unsigned int scalar_target : 1;\n   unsigned int optional_arg : 1;\n };\n \n@@ -1044,12 +1047,16 @@ struct GTY(()) lang_decl {\n   (DECL_LANG_SPECIFIC (node)->scalar_allocatable)\n #define GFC_DECL_SCALAR_POINTER(node) \\\n   (DECL_LANG_SPECIFIC (node)->scalar_pointer)\n+#define GFC_DECL_SCALAR_TARGET(node) \\\n+  (DECL_LANG_SPECIFIC (node)->scalar_target)\n #define GFC_DECL_OPTIONAL_ARGUMENT(node) \\\n   (DECL_LANG_SPECIFIC (node)->optional_arg)\n #define GFC_DECL_GET_SCALAR_ALLOCATABLE(node) \\\n   (DECL_LANG_SPECIFIC (node) ? GFC_DECL_SCALAR_ALLOCATABLE (node) : 0)\n #define GFC_DECL_GET_SCALAR_POINTER(node) \\\n   (DECL_LANG_SPECIFIC (node) ? GFC_DECL_SCALAR_POINTER (node) : 0)\n+#define GFC_DECL_GET_SCALAR_TARGET(node) \\\n+  (DECL_LANG_SPECIFIC (node) ? GFC_DECL_SCALAR_TARGET (node) : 0)\n #define GFC_DECL_PACKED_ARRAY(node) DECL_LANG_FLAG_0(node)\n #define GFC_DECL_PARTIAL_PACKED_ARRAY(node) DECL_LANG_FLAG_1(node)\n #define GFC_DECL_ASSIGN(node) DECL_LANG_FLAG_2(node)"}, {"sha": "2606998152d776bc6cb30dcca033e3c5978feed6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -212,6 +212,7 @@ struct gimplify_ctx\n enum gimplify_defaultmap_kind\n {\n   GDMK_SCALAR,\n+  GDMK_SCALAR_TARGET, /* w/ Fortran's target attr, implicit mapping, only.  */\n   GDMK_AGGREGATE,\n   GDMK_ALLOCATABLE,\n   GDMK_POINTER\n@@ -236,7 +237,7 @@ struct gimplify_omp_ctx\n   bool order_concurrent;\n   bool has_depend;\n   bool in_for_exprs;\n-  int defaultmap[4];\n+  int defaultmap[5];\n };\n \n static struct gimplify_ctx *gimplify_ctxp;\n@@ -461,6 +462,7 @@ new_omp_context (enum omp_region_type region_type)\n   else\n     c->default_kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n   c->defaultmap[GDMK_SCALAR] = GOVD_MAP;\n+  c->defaultmap[GDMK_SCALAR_TARGET] = GOVD_MAP;\n   c->defaultmap[GDMK_AGGREGATE] = GOVD_MAP;\n   c->defaultmap[GDMK_ALLOCATABLE] = GOVD_MAP;\n   c->defaultmap[GDMK_POINTER] = GOVD_MAP;\n@@ -7503,13 +7505,17 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t\t{\n \t\t  int gdmk;\n \t\t  enum omp_clause_defaultmap_kind kind;\n-\t\t  if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n-\t\t      || (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n-\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_TYPE (decl)))\n-\t\t\t      == POINTER_TYPE)))\n-\t\t    gdmk = GDMK_POINTER;\n-\t\t  else if (lang_hooks.decls.omp_scalar_p (decl))\n+\t\t  if (lang_hooks.decls.omp_allocatable_p (decl))\n+\t\t    gdmk = GDMK_ALLOCATABLE;\n+\t\t  else if (lang_hooks.decls.omp_scalar_target_p (decl))\n+\t\t    gdmk = GDMK_SCALAR_TARGET;\n+\t\t  else if (lang_hooks.decls.omp_scalar_p (decl, false))\n \t\t    gdmk = GDMK_SCALAR;\n+\t\t  else if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n+\t\t\t   || (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+\t\t\t       && (TREE_CODE (TREE_TYPE (TREE_TYPE (decl)))\n+\t\t\t\t   == POINTER_TYPE)))\n+\t\t    gdmk = GDMK_POINTER;\n \t\t  else\n \t\t    gdmk = GDMK_AGGREGATE;\n \t\t  kind = lang_hooks.decls.omp_predetermined_mapping (decl);\n@@ -8746,6 +8752,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n       if (!lang_GNU_Fortran ())\n \tctx->defaultmap[GDMK_POINTER] = GOVD_MAP | GOVD_MAP_0LEN_ARRAY;\n       ctx->defaultmap[GDMK_SCALAR] = GOVD_FIRSTPRIVATE;\n+      ctx->defaultmap[GDMK_SCALAR_TARGET] = (lang_GNU_Fortran ()\n+\t\t\t\t\t     ? GOVD_MAP : GOVD_FIRSTPRIVATE);\n     }\n   if (!lang_GNU_Fortran ())\n     switch (code)\n@@ -8827,7 +8835,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  if (error_operand_p (decl))\n \t    goto do_add;\n \t  if (OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c)\n-\t      && !lang_hooks.decls.omp_scalar_p (decl))\n+\t      && !lang_hooks.decls.omp_scalar_p (decl, true))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"non-scalar variable %qD in conditional \"\n@@ -10025,7 +10033,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      gdmkmax = GDMK_POINTER;\n \t      break;\n \t    case OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR:\n-\t      gdmkmin = gdmkmax = GDMK_SCALAR;\n+\t      gdmkmin = GDMK_SCALAR;\n+\t      gdmkmax = GDMK_SCALAR_TARGET;\n \t      break;\n \t    case OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE:\n \t      gdmkmin = gdmkmax = GDMK_AGGREGATE;\n@@ -10066,12 +10075,18 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  case GDMK_SCALAR:\n \t\t    ctx->defaultmap[gdmk] = GOVD_FIRSTPRIVATE;\n \t\t    break;\n+\t\t  case GDMK_SCALAR_TARGET:\n+\t\t    ctx->defaultmap[gdmk] = (lang_GNU_Fortran ()\n+\t\t\t\t\t     ? GOVD_MAP : GOVD_FIRSTPRIVATE);\n+\t\t    break;\n \t\t  case GDMK_AGGREGATE:\n \t\t  case GDMK_ALLOCATABLE:\n \t\t    ctx->defaultmap[gdmk] = GOVD_MAP;\n \t\t    break;\n \t\t  case GDMK_POINTER:\n-\t\t    ctx->defaultmap[gdmk] = GOVD_MAP | GOVD_MAP_0LEN_ARRAY;\n+\t\t    ctx->defaultmap[gdmk] = GOVD_MAP;\n+\t\t    if (!lang_GNU_Fortran ())\n+\t\t      ctx->defaultmap[gdmk] |= GOVD_MAP_0LEN_ARRAY;\n \t\t    break;\n \t\t  default:\n \t\t    gcc_unreachable ();"}, {"sha": "8b744d96fb23af9c16c4860a3ac1c715b292fc24", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -86,7 +86,7 @@ struct gimplify_omp_ctx;\n extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n \t\t\t\t\t       tree);\n extern bool lhd_omp_mappable_type (tree);\n-extern bool lhd_omp_scalar_p (tree);\n+extern bool lhd_omp_scalar_p (tree, bool);\n extern tree *lhd_omp_get_decl_init (tree);\n extern void lhd_omp_finish_decl_inits ();\n \n@@ -266,7 +266,9 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n #define LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR NULL\n #define LANG_HOOKS_OMP_CLAUSE_DTOR hook_tree_tree_tree_null\n #define LANG_HOOKS_OMP_FINISH_CLAUSE lhd_omp_finish_clause\n+#define LANG_HOOKS_OMP_ALLOCATABLE_P hook_bool_tree_false\n #define LANG_HOOKS_OMP_SCALAR_P lhd_omp_scalar_p\n+#define LANG_HOOKS_OMP_SCALAR_TARGET_P hook_bool_tree_false\n #define LANG_HOOKS_OMP_GET_DECL_INIT lhd_omp_get_decl_init\n #define LANG_HOOKS_OMP_FINISH_DECL_INITS lhd_omp_finish_decl_inits\n \n@@ -297,7 +299,9 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n   LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR, \\\n   LANG_HOOKS_OMP_CLAUSE_DTOR, \\\n   LANG_HOOKS_OMP_FINISH_CLAUSE, \\\n+  LANG_HOOKS_OMP_ALLOCATABLE_P, \\\n   LANG_HOOKS_OMP_SCALAR_P, \\\n+  LANG_HOOKS_OMP_SCALAR_TARGET_P, \\\n   LANG_HOOKS_OMP_GET_DECL_INIT, \\\n   LANG_HOOKS_OMP_FINISH_DECL_INITS \\\n }"}, {"sha": "d753199ffe02c6e5a5c54ad500cdd25012f1e01d", "filename": "gcc/langhooks.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -615,10 +615,11 @@ lhd_omp_finish_clause (tree, gimple_seq *, bool)\n }\n \n /* Return true if DECL is a scalar variable (for the purpose of\n-   implicit firstprivatization).  */\n+   implicit firstprivatization & mapping). Only if alloc_ptr_ok\n+   are allocatables and pointers accepted. */\n \n bool\n-lhd_omp_scalar_p (tree decl)\n+lhd_omp_scalar_p (tree decl, bool ptr_ok)\n {\n   tree type = TREE_TYPE (decl);\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n@@ -627,7 +628,7 @@ lhd_omp_scalar_p (tree decl)\n     type = TREE_TYPE (type);\n   if (INTEGRAL_TYPE_P (type)\n       || SCALAR_FLOAT_TYPE_P (type)\n-      || TREE_CODE (type) == POINTER_TYPE)\n+      || (ptr_ok && TREE_CODE (type) == POINTER_TYPE))\n     return true;\n   return false;\n }"}, {"sha": "1b417a01a4e08c5c62a969100dbdd81843dfef9e", "filename": "gcc/langhooks.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -296,9 +296,18 @@ struct lang_hooks_for_decls\n   /* Do language specific checking on an implicitly determined clause.  */\n   void (*omp_finish_clause) (tree clause, gimple_seq *pre_p, bool);\n \n+  /* Return true if DECL is an allocatable variable (for the purpose of\n+     implicit mapping).  */\n+  bool (*omp_allocatable_p) (tree decl);\n+\n   /* Return true if DECL is a scalar variable (for the purpose of\n-     implicit firstprivatization).  */\n-  bool (*omp_scalar_p) (tree decl);\n+     implicit firstprivatization). If 'ptr_or', pointers and\n+     allocatables are also permitted.  */\n+  bool (*omp_scalar_p) (tree decl, bool ptr_ok);\n+\n+  /* Return true if DECL is a scalar variable with Fortran target but not\n+     allocatable or pointer attribute (for the purpose of implicit mapping).  */\n+  bool (*omp_scalar_target_p) (tree decl);\n \n   /* Return a pointer to the tree representing the initializer\n      expression for the non-local variable DECL.  Return NULL if"}, {"sha": "299d971f23cbacfd65a4a651ea2ccb51b7b0cdcf", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-1.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,19 @@\n+! PR fortran/92568\n+\n+implicit none\n+\n+!$omp target defaultmap(bar)  ! { dg-error \"25: Expected ALLOC, TO, FROM, TOFROM, FIRSTPRIVATE, NONE or DEFAULT\" }\n+\n+!$omp target defaultmap ( alloc: foo)  ! { dg-error \"34: Expected SCALAR, AGGREGATE, ALLOCATABLE or POINTER\" }\n+\n+!$omp target defaultmap(alloc:scalar) defaultmap(none:Scalar)  ! { dg-error \"DEFAULTMAP at .1. but prior DEFAULTMAP for category SCALAR\" }\n+\n+!$omp target defaultmap(default:aggregate) defaultmap(tofrom)  ! { dg-error \"DEFAULTMAP at .1. but prior DEFAULTMAP for category AGGREGATE\" }\n+\n+!$omp target defaultmap(from:pointer) defaultmap(tofrom:pointer)  ! { dg-error \"DEFAULTMAP at .1. but prior DEFAULTMAP for category POINTER\" }\n+\n+!$omp target defaultmap(from:scalar) defaultmap(to:allocatable) defaultmap(tofrom:allocatable)  ! { dg-error \"DEFAULTMAP at .1. but prior DEFAULTMAP for category ALLOCATABLE\" }\n+\n+!$omp target defaultmap(from) defaultmap(to)  !  { dg-error \"DEFAULTMAP at .1. but prior DEFAULTMAP with unspecified category\" }\n+\n+end"}, {"sha": "1658424cf59aff619285188779480ae40f51b075", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-2.f90", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-2.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,108 @@\n+! PR fortran/92568\n+!\n+implicit none\n+  type t\n+  end type t\n+\n+  integer :: ii\n+  integer :: arr(5)\n+  integer, allocatable :: aii, aarr(:)\n+  integer, pointer :: pii, parr(:)\n+\n+  character :: str1, str1arr(5), str1a, str1aarr(:), str1p, str1parr(:)\n+  character(len=5) :: str5, str5arr(5), str5a, str5aarr(:), str5p, str5parr(:)\n+  character(len=:) :: strXa, strXaarr(:), strXp, strXparr(:)\n+  allocatable :: str1a, str1aarr, str5a, str5aarr, strXa, strXaarr\n+  pointer :: str1p, str1parr, str5p, str5parr, strXp, strXparr\n+\n+  type(t) :: dt, dtarr(5), dta, dtaarr(:), dtp, dtparr(:)\n+  allocatable :: dta, dtaarr\n+  pointer :: dtp, dtparr\n+\n+  allocate(aii, aarr(5), str1a, str1aarr(5), dta, dtparr(5))\n+  allocate(pii, parr(5), str1p, str1parr(5), dtp, dtparr(5))\n+  allocate(character(len=7) :: strXa, strXaarr(5), strXp, strXparr(5))\n+\n+\n+  !$omp target defaultmap ( none )  ! { dg-note \"enclosing 'target'\" }\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    ! { dg-error \"'ii' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'arr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'aii' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'aarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'pii' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'parr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    ! { dg-error \"'str1' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'str1arr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'str1a' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'str1aarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'str1p' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'str1parr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    ! { dg-error \"'str5' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'str5arr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'str5a' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'str5aarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'str5p' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'str5parr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    ! { dg-error \"'strxa' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'strxaarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'strxp' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'strxparr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+    ! { dg-error \"'dt' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'dtarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'dta' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'dtaarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'dtp' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'dtparr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+  !$omp end target\n+\n+\n+  !$omp target defaultmap(none : scalar)  defaultmap(none : aggregate)  &\n+  !$omp&       defaultmap(none : allocatable) defaultmap(none : pointer)   ! { dg-note \"enclosing 'target'\" }\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    ! { dg-error \"'ii' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'arr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'aii' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'aarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'pii' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'parr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    ! { dg-error \"'str1' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'str1arr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'str1a' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'str1aarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'str1p' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'str1parr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    ! { dg-error \"'str5' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'str5arr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'str5a' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'str5aarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'str5p' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'str5parr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    ! { dg-error \"'strxa' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'strxaarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'strxp' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'strxparr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+    ! { dg-error \"'dt' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"'dtarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-2 }\n+    ! { dg-error \"'dta' not specified in enclosing 'target'\" \"\" { target *-*-* } .-3 }\n+    ! { dg-error \"'dtaarr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-4 }\n+    ! { dg-error \"'dtp' not specified in enclosing 'target'\" \"\" { target *-*-* } .-5 }\n+    ! { dg-error \"'dtparr' not specified in enclosing 'target'\" \"\" { target *-*-* } .-6 }\n+  !$omp end target\n+end"}, {"sha": "cfe40e8eea8e7f1dabe15999d975c03fa78ec73b", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-3.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-3.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,60 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+!\n+! PR fortran/92568\n+!\n+implicit none\n+  type t\n+  end type t\n+\n+  integer :: ii\n+  integer :: arr(5)\n+  integer, allocatable :: aii, aarr(:)\n+  integer, pointer :: pii, parr(:)\n+\n+  character :: str1, str1arr(5), str1a, str1aarr(:), str1p, str1parr(:)\n+  character(len=5) :: str5, str5arr(5), str5a, str5aarr(:), str5p, str5parr(:)\n+  character(len=:) :: strXa, strXaarr(:), strXp, strXparr(:)\n+  allocatable :: str1a, str1aarr, str5a, str5aarr, strXa, strXaarr\n+  pointer :: str1p, str1parr, str5p, str5parr, strXp, strXparr\n+\n+  type(t) :: dt, dtarr(5), dta, dtaarr(:), dtp, dtparr(:)\n+  allocatable :: dta, dtaarr\n+  pointer :: dtp, dtparr\n+\n+  allocate(aii, aarr(5), str1a, str1aarr(5), dta, dtparr(5))\n+  allocate(pii, parr(5), str1p, str1parr(5), dtp, dtparr(5))\n+  allocate(character(len=7) :: strXa, strXaarr(5), strXp, strXparr(5))\n+\n+\n+  !$omp target defaultmap ( none )  &\n+  !$omp&  map(tofrom: ii, arr, aii, aarr, pii, parr)  &\n+  !$omp&  map(tofrom: str1, str1arr, str1a, str1aarr, str1p, str1parr)  &\n+  !$omp&  map(tofrom: str5, str5arr, str5a, str5aarr, str5p, str5parr)  &\n+  !$omp&  map(tofrom: strXa, strXaarr, strXp, strXparr)  &\n+  !$omp&  map(tofrom: dt, dtarr, dta, dtaarr, dtp, dtparr)\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+  !$omp end target\n+\n+\n+  !$omp target defaultmap(none : scalar)  defaultmap(none : aggregate)  &\n+  !$omp&       defaultmap(none : allocatable) defaultmap(none : pointer) &\n+  !$omp&  map(alloc: ii, arr, aii, aarr, pii, parr)  &\n+  !$omp&  map(alloc: str1, str1arr, str1a, str1aarr, str1p, str1parr)  &\n+  !$omp&  map(alloc: str5, str5arr, str5a, str5aarr, str5p, str5parr)  &\n+  !$omp&  map(alloc: strXa, strXaarr, strXp, strXparr)  &\n+  !$omp&  map(alloc: dt, dtarr, dta, dtaarr, dtp, dtparr)\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+  !$omp end target\n+end\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp target map\\\\(tofrom:.* defaultmap\\\\(none\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target map\\\\(alloc:.* defaultmap\\\\(none:scalar\\\\) defaultmap\\\\(none:aggregate\\\\) defaultmap\\\\(none:allocatable\\\\) defaultmap\\\\(none:pointer\\\\)\" 1 \"original\" } }"}, {"sha": "89bbe87e570feb50a4f85dc7d277a7f1c4c90d0c", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-4.f90", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-4.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,141 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+!\n+! PR fortran/92568\n+!\n+implicit none\n+  type t\n+  end type t\n+\n+  integer :: ii\n+  integer :: arr(5)\n+  integer, allocatable :: aii, aarr(:)\n+  integer, pointer :: pii, parr(:)\n+\n+  character :: str1, str1arr(5), str1a, str1aarr(:), str1p, str1parr(:)\n+  character(len=5) :: str5, str5arr(5), str5a, str5aarr(:), str5p, str5parr(:)\n+  character(len=:) :: strXa, strXaarr(:), strXp, strXparr(:)\n+  allocatable :: str1a, str1aarr, str5a, str5aarr, strXa, strXaarr\n+  pointer :: str1p, str1parr, str5p, str5parr, strXp, strXparr\n+\n+  type(t) :: dt, dtarr(5), dta, dtaarr(:), dtp, dtparr(:)\n+  allocatable :: dta, dtaarr\n+  pointer :: dtp, dtparr\n+\n+  allocate(aii, aarr(5), str1a, str1aarr(5), dta, dtparr(5))\n+  allocate(pii, parr(5), str1p, str1parr(5), dtp, dtparr(5))\n+  allocate(character(len=7) :: strXa, strXaarr(5), strXp, strXparr(5))\n+\n+\n+  !$omp target defaultmap ( alloc )\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+  !$omp end target\n+\n+  !$omp target defaultmap(alloc : scalar)  defaultmap(to : aggregate)  &\n+  !$omp&       defaultmap(tofrom : allocatable) defaultmap(firstprivate : pointer)\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+  !$omp end target\n+end\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp target defaultmap\\\\(alloc:scalar\\\\) defaultmap\\\\(to:aggregate\\\\) defaultmap\\\\(tofrom:allocatable\\\\) defaultmap\\\\(firstprivate:pointer\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target defaultmap\\\\(alloc\\\\)\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(dtp\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(pii\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(str1p\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(str5p\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(strxp\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*aii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:aii \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) dtaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) dtparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) str1aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) str1parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) str5aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) str5parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) strxaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) strxparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:1\\\\\\] \\\\* restrict\\\\) str1aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:5\\\\\\] \\\\* restrict\\\\) str5aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:\\\\.strxaarr\\\\\\] \\\\* restrict\\\\) strxaarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*dta \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dta \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dtarr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dt \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*dtp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dtp \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:ii \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*pii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:pii \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*str1a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1a \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*str1p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1p \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*str5a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5a \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*str5p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5p \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(struct t\\\\\\[0:\\\\\\] \\\\* restrict\\\\) dtaarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*strxa \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:strxa \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\*strxp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:strxp \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:1\\\\\\] \\\\*\\\\) str1parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:5\\\\\\] \\\\*\\\\) str5parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:\\\\.strxparr\\\\\\] \\\\*\\\\) strxparr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(struct t\\\\\\[0:\\\\\\] \\\\*\\\\) dtparr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:aarr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) dtparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) str1parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) str5parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) strxparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtaarr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtarr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dt \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtparr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*aii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) dtaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str1aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str5aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) strxaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*dta \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str1a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str5a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*strxa \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:parr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1aarr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1parr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5aarr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5parr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxaarr \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:strxaarr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxa \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxparr \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:strxparr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxp \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(alloc\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(alloc:scalar\\\\) defaultmap\\\\(to:aggregate\\\\) defaultmap\\\\(tofrom:allocatable\\\\) defaultmap\\\\(firstprivate:pointer\\\\)\" 1 \"gimple\" } }"}, {"sha": "d6b32dc90bcc3f8e43e0db89ad8b46ce15f40652", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-5.f90", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-5.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,145 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+!\n+! PR fortran/92568\n+!\n+implicit none\n+  type t\n+  end type t\n+\n+  integer :: ii\n+  integer :: arr(5)\n+  integer, allocatable :: aii, aarr(:)\n+  integer, pointer :: pii, parr(:)\n+\n+  character :: str1, str1arr(5), str1a, str1aarr(:), str1p, str1parr(:)\n+  character(len=5) :: str5, str5arr(5), str5a, str5aarr(:), str5p, str5parr(:)\n+  character(len=:) :: strXa, strXaarr(:), strXp, strXparr(:)\n+  allocatable :: str1a, str1aarr, str5a, str5aarr, strXa, strXaarr\n+  pointer :: str1p, str1parr, str5p, str5parr, strXp, strXparr\n+\n+  type(t) :: dt, dtarr(5), dta, dtaarr(:), dtp, dtparr(:)\n+  allocatable :: dta, dtaarr\n+  pointer :: dtp, dtparr\n+\n+  allocate(aii, aarr(5), str1a, str1aarr(5), dta, dtparr(5))\n+  allocate(pii, parr(5), str1p, str1parr(5), dtp, dtparr(5))\n+  allocate(character(len=7) :: strXa, strXaarr(5), strXp, strXparr(5))\n+\n+\n+  !$omp target defaultmap ( to )\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+  !$omp end target\n+\n+\n+  ! FIXME: strXp disabled because of PR fortran/100965\n+\n+  !$omp target defaultmap(to : scalar)  defaultmap(tofrom : aggregate)  &\n+  !$omp&       defaultmap(firstprivate : allocatable) defaultmap(default : pointer)\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    !strXa = \"\";\n+    strXaarr = \"\";\n+    ! strXp = \"\"\n+    strXparr = \"\"\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+  !$omp end target\n+end\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp target defaultmap\\\\(to\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target defaultmap\\\\(to:scalar\\\\) defaultmap\\\\(tofrom:aggregate\\\\) defaultmap\\\\(firstprivate:allocatable\\\\) defaultmap\\\\(default:pointer\\\\)\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(aarr\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(aii\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(dta\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(dtaarr\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(str1a\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(str1aarr\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(str5a\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(str5aarr\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(strxaarr\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:aii \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:1\\\\\\] \\\\* restrict\\\\) str1aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:5\\\\\\] \\\\* restrict\\\\) str5aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:\\\\.strxaarr\\\\\\] \\\\* restrict\\\\) strxaarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dta \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dtp \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:pii \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1a \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1p \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5a \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5p \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(struct t\\\\\\[0:\\\\\\] \\\\* restrict\\\\) dtaarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:strxa \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:strxp \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:1\\\\\\] \\\\*\\\\) str1parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:5\\\\\\] \\\\*\\\\) str5parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:\\\\.strxparr\\\\\\] \\\\*\\\\) strxparr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(struct t\\\\\\[0:\\\\\\] \\\\*\\\\) dtparr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:aarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*aii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) dtaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) dtparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) str1aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) str1parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) str5aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) str5parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) strxaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*\\\\(c_char \\\\*\\\\) strxparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtaarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*dta \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtarr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dt \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtparr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*dtp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) dtparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str1parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str5parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) strxparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:dtarr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:dt \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*dtp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*pii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str1arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str1 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str1p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str5arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str5 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str5p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:ii \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:parr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*pii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1aarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*str1a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1parr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*str1p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5aarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*str5a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5parr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*str5p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxaarr \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:strxaarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*strxa \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxa \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxparr \\\\\\[len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:strxparr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*strxp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(to\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(to:scalar\\\\) defaultmap\\\\(tofrom:aggregate\\\\) defaultmap\\\\(firstprivate:allocatable\\\\) defaultmap\\\\(default:pointer\\\\)\" 1 \"gimple\" } }"}, {"sha": "fabf771f9c7e91e636215f13843f07a67c2042d3", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-6.f90", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-6.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,104 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+!\n+! PR fortran/92568\n+!\n+implicit none\n+  type t\n+  end type t\n+\n+  integer :: ii\n+  integer :: arr(5)\n+  integer, allocatable :: aii, aarr(:)\n+  integer, pointer :: pii, parr(:)\n+\n+  character :: str1, str1arr(5), str1a, str1aarr(:), str1p, str1parr(:)\n+  character(len=5) :: str5, str5arr(5), str5a, str5aarr(:), str5p, str5parr(:)\n+  character(len=:) :: strXa, strXaarr(:), strXp, strXparr(:)\n+  allocatable :: str1a, str1aarr, str5a, str5aarr, strXa, strXaarr\n+  pointer :: str1p, str1parr, str5p, str5parr, strXp, strXparr\n+\n+  type(t) :: dt, dtarr(5), dta, dtaarr(:), dtp, dtparr(:)\n+  allocatable :: dta, dtaarr\n+  pointer :: dtp, dtparr\n+\n+  allocate(aii, aarr(5), str1a, str1aarr(5), dta, dtparr(5))\n+  allocate(pii, parr(5), str1p, str1parr(5), dtp, dtparr(5))\n+  allocate(character(len=7) :: strXa, strXaarr(5), strXp, strXparr(5))\n+\n+\n+  !$omp target defaultmap ( default )\n+    ii = 42; arr = 42; aii = 42; aarr = 42; pii = 42; parr = 42\n+    str1 = \"\"; str1arr = \"\"; str1a = \"\"; str1aarr = \"\"; str1p = \"\"; str1parr = \"\"\n+    str5 = \"\"; str5arr = \"\"; str5a = \"\"; str5aarr = \"\"; str5p = \"\"; str5parr = \"\"\n+    strXa = \"\"; strXaarr = \"\"; strXp = \"\"; strXparr = \"\"\n+    dt = t(); dtarr = t(); dta = t(); dtaarr = t(); dtp = t(); dtparr = t()\n+  !$omp end target\n+\n+end\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp target defaultmap\\\\(default\\\\)\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ii\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:aii \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:1\\\\\\] \\\\* restrict\\\\) str1aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:5\\\\\\] \\\\* restrict\\\\) str5aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:\\\\.strxaarr\\\\\\] \\\\* restrict\\\\) strxaarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dta \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:dtp \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) aarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:pii \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1a \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str1p \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5a \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:str5p \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:\\\\(struct t\\\\\\[0:\\\\\\] \\\\* restrict\\\\) dtaarr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:strxa \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:strxp \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:1\\\\\\] \\\\*\\\\) str1parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:5\\\\\\] \\\\*\\\\) str5parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:\\\\.strxparr\\\\\\] \\\\*\\\\) strxparr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) parr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(always_pointer:\\\\(struct t\\\\\\[0:\\\\\\] \\\\*\\\\) dtparr\\\\.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:aarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtaarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:dtparr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*aii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) dtaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) dtparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str1aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str1parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str5aarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) str5parr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) strxaarr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*\\\\(c_char \\\\*\\\\) strxparr\\\\.data \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*dta \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:dtarr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:dt \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*dtp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*pii \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str1a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str1arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str1 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str1p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str5a \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str5arr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str5 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*str5p \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*strxa \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*strxp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:parr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1aarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str1parr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5aarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:str5parr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxaarr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:strxaarr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxa \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxparr \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:strxparr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxp \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(default\\\\)\" 1 \"gimple\" } }"}, {"sha": "e1b4fc2364ff4883ba71856ddeeb9b88ec9f38d2", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-7.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-7.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,24 @@\n+! PR fortran/92568\n+!\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+implicit none\n+  integer :: ii, aa, pp\n+  allocatable :: aa\n+  pointer :: pp\n+  character :: str\n+  character(len=2) :: str2\n+\n+!$omp target\n+  ii = 1\n+  aa = 5\n+  pp = 7\n+  str = '1'\n+  str2 = '12'\n+!$omp end target\n+end\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ii\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*aa\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:\\\\*pp\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str2 \\\\\\[len:\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:str \\\\\\[len:\" 1 \"gimple\" } }"}, {"sha": "b61b2fc32b7f6c8a9b01daaf636e4ba81d0a6887", "filename": "gcc/testsuite/gfortran.dg/gomp/pr99928-1.f90", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-1.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -108,41 +108,41 @@ subroutine bar ()\n   !$omp end parallel sections\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f13\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f13\\\\)\" \"gimple\" } }\n-  !$omp target parallel firstprivate (f13) default(none) ! defaultmap(none)\n+  !$omp target parallel firstprivate (f13) default(none) defaultmap(none)\n   f13 = f13 + 1\n   !$omp end target parallel\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f14\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f14\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f14\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target parallel do firstprivate (f14) default(none) ! defaultmap(none)\n+  !$omp target parallel do firstprivate (f14) default(none) defaultmap(none)\n   do i = 1, 64\n     f14 = f14 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } }\n-  !$omp target parallel do simd firstprivate (f15) default(none) ! defaultmap(none)\n+  !$omp target parallel do simd firstprivate (f15) default(none) defaultmap(none)\n   do i = 1, 64\n     f15 = f15 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } }\n-  !$omp target parallel loop firstprivate (f16) default(none) ! defaultmap(none)\n+  !$omp target parallel loop firstprivate (f16) default(none) defaultmap(none)\n   do i = 1, 64\n     f16 = f16 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f17\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f17\\\\)\" \"gimple\" } }\n-  !$omp target teams firstprivate (f17) default(none) ! defaultmap(none)\n+  !$omp target teams firstprivate (f17) default(none) defaultmap(none)\n   f17 = f17 + 1\n   !$omp end target teams\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f18\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f18\\\\)\" \"gimple\" } } ! FIXME: This should be on distribute instead. \n   ! { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f18\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target teams distribute firstprivate (f18) default(none) ! defaultmap(none)\n+  !$omp target teams distribute firstprivate (f18) default(none) defaultmap(none)\n   do i = 1, 64\n     f18 = f18 + 1\n   end do\n@@ -151,7 +151,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target teams distribute parallel do firstprivate (f19) default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do firstprivate (f19) default(none) defaultmap(none)\n   do i = 1, 64\n     f19 = f19 + 1\n   end do\n@@ -161,15 +161,15 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute parallel do simd firstprivate (f20) default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do simd firstprivate (f20) default(none) defaultmap(none)\n   do i = 1, 64\n     f20 = f20 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute simd firstprivate (f21) default(none) ! defaultmap(none)\n+  !$omp target teams distribute simd firstprivate (f21) default(none) defaultmap(none)\n   do i = 1, 64\n     f21 = f21 + 1\n   end do\n@@ -179,13 +179,13 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(f22\\\\)\" \"gimple\" } } ! NOTE: This is an implementation detail. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f22\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f22\\\\)\" \"gimple\" } }\n-  !$omp target teams loop firstprivate (f22) default(none) ! defaultmap(none)\n+  !$omp target teams loop firstprivate (f22) default(none) defaultmap(none)\n   do i = 1, 64\n     f22 = f22 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f23\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f23\\\\)\" \"gimple\" } }\n-  !$omp target simd firstprivate (f23) ! defaultmap(none)\n+  !$omp target simd firstprivate (f23) defaultmap(none)\n   do i = 1, 64\n     f23 = f23 + 1\n   end do"}, {"sha": "7a9824865c28644f87807daaec0177c6cbf32b78", "filename": "gcc/testsuite/gfortran.dg/gomp/pr99928-2.f90", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-2.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -108,7 +108,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l11\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l11\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l11\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target parallel do lastprivate (l11) default(none) ! defaultmap(none)\n+  !$omp target parallel do lastprivate (l11) default(none) defaultmap(none)\n   do i = 1, 64\n     l11 = i\n   end do\n@@ -117,7 +117,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l12\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l12\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l12\\\\)\" \"gimple\" } }\n-  !$omp target parallel do simd lastprivate (l12) default(none) ! defaultmap(none)\n+  !$omp target parallel do simd lastprivate (l12) default(none) defaultmap(none)\n   do i = 1, 64\n     l12 = i\n   end do\n@@ -126,14 +126,14 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j01\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j01\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(j01\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n-  !$omp target parallel loop lastprivate (j01) default(none) ! defaultmap(none)\n+  !$omp target parallel loop lastprivate (j01) default(none) defaultmap(none)\n   do j01 = 0, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l13\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l13\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l13\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l13\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute lastprivate (l13) default(none) ! defaultmap(none)\n+  !$omp target teams distribute lastprivate (l13) default(none) defaultmap(none)\n   do i = 1, 64\n     l13 = i\n   end do\n@@ -143,7 +143,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l14\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l14\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l14\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target teams distribute parallel do lastprivate (l14) default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do lastprivate (l14) default(none) defaultmap(none)\n   do i = 1, 64\n     l14 = i\n   end do\n@@ -154,7 +154,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l15\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l15\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l15\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute parallel do simd lastprivate (l15) default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do simd lastprivate (l15) default(none) defaultmap(none)\n   do i = 1, 64\n     l15 = i\n   end do\n@@ -163,7 +163,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l16\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l16\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l16\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute simd lastprivate (l16) default(none) ! defaultmap(none)\n+  !$omp target teams distribute simd lastprivate (l16) default(none) defaultmap(none)\n   do i = 1, 64\n     l16 = i\n   end do\n@@ -174,13 +174,13 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j02\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n   ! { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n-  !$omp target teams loop lastprivate (j02) default(none) ! defaultmap(none)\n+  !$omp target teams loop lastprivate (j02) default(none) defaultmap(none)\n   do j02 = 0, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l17\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l17\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l17\\\\)\" \"gimple\" } }\n-  !$omp target simd lastprivate (l17) ! defaultmap(none)\n+  !$omp target simd lastprivate (l17) defaultmap(none)\n   do i = 1, 64\n     l17 = i\n   end do"}, {"sha": "3c02c88c483bf1498d70033d43b85c0b099859c2", "filename": "gcc/testsuite/gfortran.dg/gomp/pr99928-3.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-3.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -101,7 +101,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l08\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l08\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l08\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target parallel do firstprivate (l08) lastprivate (l08) default(none) ! defaultmap(none)\n+  !$omp target parallel do firstprivate (l08) lastprivate (l08) default(none) defaultmap(none)\n   do i = 1, 64\n     l08 = i\n   end do\n@@ -114,15 +114,15 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l09\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } }\n-  !$omp target parallel do simd firstprivate (l09) lastprivate (l09) default(none) ! defaultmap(none)\n+  !$omp target parallel do simd firstprivate (l09) lastprivate (l09) default(none) defaultmap(none)\n   do i = 1, 64\n     l09 = i\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l10\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l10\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l10\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l10\\\\)\" \"gimple\" } }\n-  !$omp target simd firstprivate (l10) lastprivate (l10) ! defaultmap(none)\n+  !$omp target simd firstprivate (l10) lastprivate (l10) defaultmap(none)\n   do i = 1, 64\n     l10 = i\n   end do"}, {"sha": "1563c4fbbd059899b03fc724a8e16ddc22d464af", "filename": "gcc/testsuite/gfortran.dg/gomp/pr99928-4.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-4.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -57,7 +57,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l05\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l05\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*linear\\\\(l05:1\\\\)\" \"gimple\" } }\n-  !$omp target parallel do linear (l05) default(none) ! defaultmap(none)\n+  !$omp target parallel do linear (l05) default(none) defaultmap(none)\n   do i = 1, 64\n     l05 = l05 + 1\n   end do\n@@ -68,14 +68,14 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l06\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l06:1\\\\)\" \"gimple\" } }\n-  !$omp target parallel do simd linear (l06) default(none) ! defaultmap(none)\n+  !$omp target parallel do simd linear (l06) default(none) defaultmap(none)\n   do i = 1, 64\n     l06 = l06 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l07\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l07\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l07:1\\\\)\" \"gimple\" } }\n-  !$omp target simd linear (l07) ! defaultmap(none)\n+  !$omp target simd linear (l07) defaultmap(none)\n   do i = 1, 64\n     l07 = l07 + 1\n   end do"}, {"sha": "259f6cc0136a356e2d8c8376d5ae4bd47da1c5de", "filename": "gcc/testsuite/gfortran.dg/gomp/pr99928-5.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-5.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -57,13 +57,13 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j06:1\\\\)\" \"gimple\" } }\n-  !$omp target parallel do simd linear (j06) default(none) ! defaultmap(none)\n+  !$omp target parallel do simd linear (j06) default(none) defaultmap(none)\n   do j06 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j07\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j07\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j07:1\\\\)\" \"gimple\" } }\n-  !$omp target simd linear (j07) ! defaultmap(none)\n+  !$omp target simd linear (j07) defaultmap(none)\n   do j07 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j08\" \"gimple\" } }\n@@ -73,15 +73,15 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j08:1\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute parallel do simd linear (j08) default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do simd linear (j08) default(none) defaultmap(none)\n   do j08 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j09\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j09\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j09\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j09\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j09:1\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute simd linear (j09) default(none) ! defaultmap(none)\n+  !$omp target teams distribute simd linear (j09) default(none) defaultmap(none)\n   do j09 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j10\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. "}, {"sha": "a9ad2264e398f22132d86dd94b6aa7e3113b0c81", "filename": "gcc/testsuite/gfortran.dg/gomp/pr99928-6.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-6.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -57,13 +57,13 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j06:1\\\\)\" \"gimple\" } }\n-  !$omp target parallel do simd default(none) ! defaultmap(none)\n+  !$omp target parallel do simd default(none) defaultmap(none)\n   do j06 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j07\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j07\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j07:1\\\\)\" \"gimple\" } }\n-  !$omp target simd ! defaultmap(none)\n+  !$omp target simd defaultmap(none)\n   do j07 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j08\" \"gimple\" } }\n@@ -73,15 +73,15 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j08:1\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute parallel do simd default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do simd default(none) defaultmap(none)\n   do j08 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j09\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j09\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j09\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j09\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j09:1\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute simd default(none) ! defaultmap(none)\n+  !$omp target teams distribute simd default(none) defaultmap(none)\n   do j09 = 1, 64\n   end do\n   ! { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j10\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. "}, {"sha": "a0414a57a5194c2abb1260a1aa9f5d4256ba0685", "filename": "gcc/testsuite/gfortran.dg/gomp/pr99928-8.f90", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr99928-8.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -113,14 +113,14 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r13\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r13\\\\)\" \"gimple\" } }\n-  !$omp target parallel reduction(+:r13) default(none) ! defaultmap(none)\n+  !$omp target parallel reduction(+:r13) default(none) defaultmap(none)\n   r13 = r13 + 1\n   !$omp end target parallel\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r14\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r14\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r14\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target parallel do reduction(+:r14) default(none) ! defaultmap(none)\n+  !$omp target parallel do reduction(+:r14) default(none) defaultmap(none)\n   do i = 1, 64\n     r14 = r14 + 1\n   end do\n@@ -129,7 +129,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } }\n-  !$omp target parallel do simd reduction(+:r15) default(none) ! defaultmap(none)\n+  !$omp target parallel do simd reduction(+:r15) default(none) defaultmap(none)\n   do i = 1, 64\n     r15 = r15 + 1\n   end do\n@@ -138,21 +138,21 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r16\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r16\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r16\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n-  !$omp target parallel loop reduction(+:r16) default(none) ! defaultmap(none)\n+  !$omp target parallel loop reduction(+:r16) default(none) defaultmap(none)\n   do i = 1, 64\n     r16 = r16 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r17\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r17\\\\)\" \"gimple\" } }\n-  !$omp target teams reduction(+:r17) default(none) ! defaultmap(none)\n+  !$omp target teams reduction(+:r17) default(none) defaultmap(none)\n   r17 = r17 + 1\n   !$omp end target teams\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r18\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r18\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r18\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute reduction(+:r18) default(none) ! defaultmap(none)\n+  !$omp target teams distribute reduction(+:r18) default(none) defaultmap(none)\n   do i = 1, 64\n     r18 = r18 + 1\n   end do\n@@ -162,7 +162,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } ! FIXME. \n-  !$omp target teams distribute parallel do reduction(+:r19) default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do reduction(+:r19) default(none) defaultmap(none)\n   do i = 1, 64\n     r19 = r19 + 1\n   end do\n@@ -173,7 +173,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } ! FIXME: This should be on for instead. \n   ! { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } ! FIXME. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute parallel do simd reduction(+:r20) default(none) ! defaultmap(none)\n+  !$omp target teams distribute parallel do simd reduction(+:r20) default(none) defaultmap(none)\n   do i = 1, 64\n     r20 = r20 + 1\n   end do\n@@ -182,7 +182,7 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } }\n-  !$omp target teams distribute simd reduction(+:r21) default(none) ! defaultmap(none)\n+  !$omp target teams distribute simd reduction(+:r21) default(none) defaultmap(none)\n   do i = 1, 64\n     r21 = r21 + 1\n   end do\n@@ -193,14 +193,14 @@ subroutine bar ()\n   ! { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n   ! { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r22\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r22\\\\)\" \"gimple\" } } ! NOTE: This is implementation detail. \n-  !$omp target teams loop reduction(+:r22) default(none) ! defaultmap(none)\n+  !$omp target teams loop reduction(+:r22) default(none) defaultmap(none)\n   do i = 1, 64\n     r22 = r22 + 1\n   end do\n   ! { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r23\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" } }\n   ! { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r23\\\\)\" \"gimple\" } }\n-  !$omp target simd reduction(+:r23) ! defaultmap(none)\n+  !$omp target simd reduction(+:r23) defaultmap(none)\n   do i = 1, 64\n     r23 = r23 + 1\n   end do"}, {"sha": "ddf5057618e6dc6ba026f68fdc2e8cd19b7e4dae", "filename": "libgomp/testsuite/libgomp.fortran/defaultmap-8.f90", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de31913d20a467b78904c0e96efd5fbd6facd2c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdefaultmap-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de31913d20a467b78904c0e96efd5fbd6facd2c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdefaultmap-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdefaultmap-8.f90?ref=1de31913d20a467b78904c0e96efd5fbd6facd2c", "patch": "@@ -0,0 +1,279 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+!\n+! PR fortran/92568\n+!\n+program main\n+  implicit none\n+  integer :: xa1, xa2, xp1, xp2, xat1, xat2, xt1, xt2, xi1, xi2\n+  allocatable :: xa1, xa2, xat1, xat2\n+  pointer :: xp1, xp2\n+\n+  allocate (xa1, xa2, xat1, xat2, xp1, xp2)\n+\n+  call foo (xa1, xa2, xp1, xp2, xat1, xat2, xt1, xt2, xi1, xi2)\n+  call foo2 (xa1, xa2, xp1, xp2, xat1, xat2, xt1, xt2, xi1, xi2)\n+  call foo3 (xa1, xa2, xp1, xp2, xat1, xat2, xt1, xt2, xi1, xi2)\n+  call bar (xa1, xa2, xp1, xp2, xat1, xat2, xt1, xt2, xi1, xi2)\n+\n+  deallocate (xa1, xa2, xat1, xat2, xp1, xp2)\n+contains\n+! Implicit mapping\n+subroutine foo (ia1, ia2, ip1, ip2, iat1, iat2, it1, it2, ii1, ii2)\n+  implicit none\n+  integer :: ia1, ia2, ia3, ip1, ip2, ip3, iat1, iat2, iat3, it1, it2, it3, ii1, ii2, ii3\n+  allocatable :: ia1, ia2, ia3, iat1, iat2, iat3\n+  pointer :: ip1, ip2, ip3\n+  target :: iat1, iat2, iat3, it1, it2, it3\n+  optional :: ia1, ip1, iat1, it1, ii1\n+\n+  allocate(ia3, iat3, ip3)\n+\n+  ia1 = 2; ia2 = 2; ia3 = 2; ip1 = 2; ip2 = 2; ip3 = 2;\n+  iat1 = 2; iat2 = 2; iat3 = 2; it1 = 2; it2 = 2; it3 = 2\n+  ii1 = 2; ii2 = 2; ii3 = 2\n+\n+  ! Implicitly, scalars are 'firstprivate' except\n+  ! if target, allocatable, pointer they are always tofrom.\n+  !$omp target\n+    if (ia1 /= 2) stop 1\n+    if (ia2 /= 2) stop 2\n+    if (ia3 /= 2) stop 3\n+    if (ip1 /= 2) stop 4\n+    if (ip2 /= 2) stop 5\n+    if (ip3 /= 2) stop 6\n+    if (iat1 /= 2) stop 7\n+    if (iat2 /= 2) stop 8\n+    if (iat3 /= 2) stop 9\n+    if (it1 /= 2) stop 10\n+    if (it2 /= 2) stop 11\n+    if (it3 /= 2) stop 12\n+    if (ii1 /= 2) stop 13\n+    if (ii2 /= 2) stop 14\n+    if (ii3 /= 2) stop 15\n+\n+    ia1 = 1; ia2 = 1; ia3 = 1; ip1 = 1; ip2 = 1; ip3 = 1;\n+    iat1 = 1; iat2 = 1; iat3 = 1; it1 = 1; it2 = 1; it3 = 1\n+    ii1 = 1; ii2 = 1; ii3 = 1\n+  !$omp end target\n+\n+  ! (target,allocatable,pointer) -> tofrom\n+  if (ia1 /= 1) stop 16\n+  if (ia2 /= 1) stop 17\n+  if (ia3 /= 1) stop 18\n+  if (ip1 /= 1) stop 19\n+  if (ip2 /= 1) stop 20\n+  if (ip3 /= 1) stop 21\n+  if (iat1 /= 1) stop 22\n+  if (iat2 /= 1) stop 23\n+  if (iat3 /= 1) stop 24\n+  if (it1 /= 1) stop 25\n+  if (it2 /= 1) stop 26\n+  if (it3 /= 1) stop 27\n+  ! non-(target,allocatable,pointer) -> firstprivate\n+  !if (ii1 /= 2) stop 28  !  FIXME: optional scalar wrongly mapped as tofrom, PR fortran/100991\n+  if (ii2 /= 2) stop 29\n+  if (ii3 /= 2) stop 30\n+\n+  deallocate(ia3, iat3, ip3)\n+end\n+\n+! Implicit mapping likewise even though there is defaultmap\n+subroutine foo2 (ia1, ia2, ip1, ip2, iat1, iat2, it1, it2, ii1, ii2)\n+  implicit none\n+  integer :: ia1, ia2, ia3, ip1, ip2, ip3, iat1, iat2, iat3, it1, it2, it3, ii1, ii2, ii3\n+  allocatable :: ia1, ia2, ia3, iat1, iat2, iat3\n+  pointer :: ip1, ip2, ip3\n+  target :: iat1, iat2, iat3, it1, it2, it3\n+  optional :: ia1, ip1, iat1, it1, ii1\n+\n+  allocate(ia3, iat3, ip3)\n+\n+  ia1 = 2; ia2 = 2; ia3 = 2; ip1 = 2; ip2 = 2; ip3 = 2;\n+  iat1 = 2; iat2 = 2; iat3 = 2; it1 = 2; it2 = 2; it3 = 2\n+  ii1 = 2; ii2 = 2; ii3 = 2\n+\n+  ! Implicitly, scalars are 'firstprivate' except\n+  ! if target, allocatable, pointer they are always tofrom.\n+  !$omp target defaultmap(default)\n+    if (ia1 /= 2) stop 31\n+    if (ia2 /= 2) stop 32\n+    if (ia3 /= 2) stop 33\n+    if (ip1 /= 2) stop 34\n+    if (ip2 /= 2) stop 35\n+    if (ip3 /= 2) stop 36\n+    if (iat1 /= 2) stop 37\n+    if (iat2 /= 2) stop 38\n+    if (iat3 /= 2) stop 39\n+    if (it1 /= 2) stop 40\n+    if (it2 /= 2) stop 41\n+    if (it3 /= 2) stop 42\n+    if (ii1 /= 2) stop 43\n+    if (ii2 /= 2) stop 44\n+    if (ii3 /= 2) stop 45\n+\n+    ia1 = 1; ia2 = 1; ia3 = 1; ip1 = 1; ip2 = 1; ip3 = 1;\n+    iat1 = 1; iat2 = 1; iat3 = 1; it1 = 1; it2 = 1; it3 = 1\n+    ii1 = 1; ii2 = 1; ii3 = 1\n+  !$omp end target\n+\n+  ! (target,allocatable,pointer) -> tofrom\n+  if (ia1 /= 1) stop 46\n+  if (ia2 /= 1) stop 47\n+  if (ia3 /= 1) stop 48\n+  if (ip1 /= 1) stop 49\n+  if (ip2 /= 1) stop 50\n+  if (ip3 /= 1) stop 51\n+  if (iat1 /= 1) stop 52\n+  if (iat2 /= 1) stop 53\n+  if (iat3 /= 1) stop 54\n+  if (it1 /= 1) stop 55\n+  if (it2 /= 1) stop 56\n+  if (it3 /= 1) stop 57\n+  ! non-(target,allocatable,pointer) -> firstprivate\n+  !if (ii1 /= 2) stop 58  !  FIXME: optional scalar wrongly mapped as tofrom, PR fortran/100991\n+  if (ii2 /= 2) stop 59\n+  if (ii3 /= 2) stop 60\n+\n+  deallocate(ia3, iat3, ip3)\n+end\n+\n+! Implicit mapping likewise even though there is defaultmap\n+subroutine foo3 (ia1, ia2, ip1, ip2, iat1, iat2, it1, it2, ii1, ii2)\n+  implicit none\n+  integer :: ia1, ia2, ia3, ip1, ip2, ip3, iat1, iat2, iat3, it1, it2, it3, ii1, ii2, ii3\n+  allocatable :: ia1, ia2, ia3, iat1, iat2, iat3\n+  pointer :: ip1, ip2, ip3\n+  target :: iat1, iat2, iat3, it1, it2, it3\n+  optional :: ia1, ip1, iat1, it1, ii1\n+\n+  allocate(ia3, iat3, ip3)\n+\n+  ia1 = 2; ia2 = 2; ia3 = 2; ip1 = 2; ip2 = 2; ip3 = 2;\n+  iat1 = 2; iat2 = 2; iat3 = 2; it1 = 2; it2 = 2; it3 = 2\n+  ii1 = 2; ii2 = 2; ii3 = 2\n+\n+  ! Implicitly, scalars are 'firstprivate' except\n+  ! if target, allocatable, pointer they are always tofrom.\n+  !$omp target defaultmap(none:aggregate)\n+    if (ia1 /= 2) stop 61\n+    if (ia2 /= 2) stop 62\n+    if (ia3 /= 2) stop 63\n+    if (ip1 /= 2) stop 64\n+    if (ip2 /= 2) stop 65\n+    if (ip3 /= 2) stop 66\n+    if (iat1 /= 2) stop 67\n+    if (iat2 /= 2) stop 68\n+    if (iat3 /= 2) stop 69\n+    if (it1 /= 2) stop 70\n+    if (it2 /= 2) stop 71\n+    if (it3 /= 2) stop 72\n+    if (ii1 /= 2) stop 73\n+    if (ii2 /= 2) stop 74\n+    if (ii3 /= 2) stop 75\n+\n+    ia1 = 1; ia2 = 1; ia3 = 1; ip1 = 1; ip2 = 1; ip3 = 1;\n+    iat1 = 1; iat2 = 1; iat3 = 1; it1 = 1; it2 = 1; it3 = 1\n+    ii1 = 1; ii2 = 1; ii3 = 1\n+  !$omp end target\n+\n+  ! (target,allocatable,pointer) -> tofrom\n+  if (ia1 /= 1) stop 76\n+  if (ia2 /= 1) stop 77\n+  if (ia3 /= 1) stop 78\n+  if (ip1 /= 1) stop 79\n+  if (ip2 /= 1) stop 80\n+  if (ip3 /= 1) stop 81\n+  if (iat1 /= 1) stop 82\n+  if (iat2 /= 1) stop 83\n+  if (iat3 /= 1) stop 84\n+  if (it1 /= 1) stop 85\n+  if (it2 /= 1) stop 86\n+  if (it3 /= 1) stop 87\n+  ! non-(target,allocatable,pointer) -> firstprivate\n+  !if (ii1 /= 2) stop 88  !  FIXME: optional scalar wrongly mapped as tofrom, PR fortran/100991\n+  if (ii2 /= 2) stop 89\n+  if (ii3 /= 2) stop 90\n+\n+  deallocate(ia3, iat3, ip3)\n+end\n+\n+subroutine bar (ea1, ea2, ep1, ep2, eat1, eat2, et1, et2, ei1, ei2)\n+  implicit none\n+  integer :: ea1, ea2, ea3, ep1, ep2, ep3, eat1, eat2, eat3, et1, et2, et3, ei1, ei2, ei3\n+  allocatable :: ea1, ea2, ea3, eat1, eat2, eat3\n+  pointer :: ep1, ep2, ep3\n+  target :: eat1, eat2, eat3, et1, et2, et3\n+  optional :: ea1, ep1, eat1, et1, ei1\n+\n+  allocate(ea3, eat3, ep3)\n+\n+  ea1 = 2; ea2 = 2; ea3 = 2; ep1 = 2; ep2 = 2; ep3 = 2;\n+  eat1 = 2; eat2 = 2; eat3 = 2; et1 = 2; et2 = 2; et3 = 2\n+  ei1 = 2; ei2 = 2; ei3 = 2\n+\n+  ! While here 'scalar' implies nonallocatable/nonpointer and\n+  ! the target attribute plays no role.\n+  !$omp target defaultmap(tofrom:scalar) defaultmap(firstprivate:allocatable) &\n+  !$omp&       defaultmap(none:aggregate) defaultmap(firstprivate:pointer)\n+    if (ea1 /= 2) stop 91\n+    if (ea2 /= 2) stop 92\n+    if (ea3 /= 2) stop 93\n+    if (ep1 /= 2) stop 94\n+    if (ep2 /= 2) stop 95\n+    if (ep3 /= 2) stop 96\n+    if (eat1 /= 2) stop 97\n+    if (eat2 /= 2) stop 98\n+    if (eat3 /= 2) stop 99\n+    if (et1 /= 2) stop 100\n+    if (et2 /= 2) stop 101\n+    if (et3 /= 2) stop 102\n+    if (ei1 /= 2) stop 103\n+    if (ei2 /= 2) stop 104\n+    if (ei3 /= 2) stop 105\n+    ep1 => null(); ep2 => null(); ep3 => null()\n+    ea1 = 1; ea2 = 1; ea3 = 1\n+    eat1 = 1; eat2 = 1; eat3 = 1\n+    et1 = 1; et2 = 1; et3 = 1\n+    ei1 = 1; ei2 = 1; ei3 = 1\n+  !$omp end target\n+  ! (allocatable,pointer) -> firstprivate\n+\n+! FIXME: allocatables not properly privatized, cf. PR fortran/90742\n+\n+!  if (ea1 /= 2) stop 106\n+!  if (ea2 /= 2) stop 107\n+!  if (ea3 /= 2) stop 108\n+!  if (eat1 /= 2) stop 112\n+!  if (eat2 /= 2) stop 113\n+!  if (eat3 /= 2) stop 114\n+  if (ep1 /= 2) stop 109\n+  if (ep2 /= 2) stop 110\n+  if (ep3 /= 2) stop 111\n+  ! (scalar) -> tofrom\n+  !if (et1 /= 1) stop 115  !  FIXME: optional scalar wrongly mapped as 'firstprivate', PR fortran/100991\n+  if (et2 /= 1) stop 116\n+  if (et3 /= 1) stop 117\n+  !if (ei1 /= 1) stop 118  !  FIXME: optional scalar wrongly mapped as 'firstprivate', PR fortran/100991\n+  if (ei2 /= 1) stop 119\n+  if (ei3 /= 1) stop 120\n+\n+  deallocate(ea3, eat3, ep3)\n+end\n+\n+end\n+\n+! FIXME/xfail: Optional scalars wrongly classified, PR fortran/100991\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ii1\\\\)\" 3 \"gimple\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-not \"firstprivate\\\\(et1\\\\)\" \"gimple\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-not \"firstprivate\\\\(ei1\\\\)\" \"gimple\" { xfail *-*-* } } }\n+\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ea1\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ea2\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ea3\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(eat1\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(eat2\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(eat3\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ep1\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ep2\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(ep3\\\\)\" 1 \"gimple\" } }"}]}