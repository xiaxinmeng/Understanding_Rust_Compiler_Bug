{"sha": "0c685f1256349ca34726d19826dad68f3559a6e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM2ODVmMTI1NjM0OWNhMzQ3MjZkMTk4MjZkYWQ2OGYzNTU5YTZlMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-12-23T14:43:28Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-12-23T14:43:28Z"}, "message": "tree.c (save_expr): Allow either side of a dyadic operand to be constant.\n\n\t* tree.c (save_expr): Allow either side of a dyadic operand to be\n\tconstant.\n\n\t* doc/portability.texi (portability): Update portability goals.\n\nFrom-SVN: r60435", "tree": {"sha": "31685ad42eeb50810729dd451ba7b19f425a95a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31685ad42eeb50810729dd451ba7b19f425a95a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c685f1256349ca34726d19826dad68f3559a6e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c685f1256349ca34726d19826dad68f3559a6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c685f1256349ca34726d19826dad68f3559a6e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c685f1256349ca34726d19826dad68f3559a6e1/comments", "author": null, "committer": null, "parents": [{"sha": "1df7e439e15df663a524df0bbc3aa59617383db0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df7e439e15df663a524df0bbc3aa59617383db0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1df7e439e15df663a524df0bbc3aa59617383db0"}], "stats": {"total": 44, "additions": 32, "deletions": 12}, "files": [{"sha": "ae22fbc4e59170bc047ecc4c25ab00145834d79e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c685f1256349ca34726d19826dad68f3559a6e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c685f1256349ca34726d19826dad68f3559a6e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c685f1256349ca34726d19826dad68f3559a6e1", "patch": "@@ -1,3 +1,10 @@\n+2002-12-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.c (save_expr): Allow either side of a dyadic operand to be\n+\tconstant.\n+\n+\t* doc/portability.texi (portability): Update portability goals.\n+\n 2002-12-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (output_a_shift): Remove unused code."}, {"sha": "b05698dcfa699df24aedfa101b406000b1879fc2", "filename": "gcc/doc/portability.texi", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c685f1256349ca34726d19826dad68f3559a6e1/gcc%2Fdoc%2Fportability.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c685f1256349ca34726d19826dad68f3559a6e1/gcc%2Fdoc%2Fportability.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fportability.texi?ref=0c685f1256349ca34726d19826dad68f3559a6e1", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-@c 1999, 2000, 2001 Free Software Foundation, Inc.\n+@c 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -8,10 +8,11 @@\n @cindex portability\n @cindex GCC and portability\n \n-The main goal of GCC was to make a good, fast compiler for machines in\n-the class that the GNU system aims to run on: 32-bit machines that address\n-8-bit bytes and have several general registers.  Elegance, theoretical\n-power and simplicity are only secondary.\n+GCC itself aims to be portable to any machine where @code{int} is at least\n+a 32-bit type.  It aims to target machines with a flat (non-segmented) byte\n+addressed data address space (the code address space can be separate).\n+Target ABIs may have 8, 16, 32 or 64-bit @code{int} type. @code{char}\n+can be wider than 8 bits.\n \n GCC gets most of the information about the target machine from a machine\n description which gives an algebraic formula for each of the machine's"}, {"sha": "f2fc48fd8ce2273bc27450aa67123dbf3279f9c9", "filename": "gcc/tree.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c685f1256349ca34726d19826dad68f3559a6e1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c685f1256349ca34726d19826dad68f3559a6e1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0c685f1256349ca34726d19826dad68f3559a6e1", "patch": "@@ -1363,12 +1363,23 @@ save_expr (expr)\n      a constant, it will be more efficient to not make another SAVE_EXPR since\n      it will allow better simplification and GCSE will be able to merge the\n      computations if they actualy occur.  */\n-  for (inner = t;\n-       (TREE_CODE_CLASS (TREE_CODE (inner)) == '1'\n-\t|| (TREE_CODE_CLASS (TREE_CODE (inner)) == '2'\n-\t    && TREE_CONSTANT (TREE_OPERAND (inner, 1))));\n-       inner = TREE_OPERAND (inner, 0))\n-    ;\n+  inner = t;\n+  while (1)\n+    {\n+      if (TREE_CODE_CLASS (TREE_CODE (inner)) == '1')\n+\tinner = TREE_OPERAND (inner, 0);\n+      else if (TREE_CODE_CLASS (TREE_CODE (inner)) == '2')\n+\t{\n+\t  if (TREE_CONSTANT (TREE_OPERAND (inner, 1)))\n+\t    inner = TREE_OPERAND (inner, 0);\n+\t  else if (TREE_CONSTANT (TREE_OPERAND (inner, 0)))\n+\t    inner = TREE_OPERAND (inner, 1);\n+\t  else\n+\t    break;\n+\t}\n+      else\n+\tbreak;\n+    }\n \n   /* If the tree evaluates to a constant, then we don't want to hide that\n      fact (i.e. this allows further folding, and direct checks for constants).\n@@ -1377,7 +1388,8 @@ save_expr (expr)\n      literal node.  */\n   if (TREE_CONSTANT (inner)\n       || (TREE_READONLY (inner) && ! TREE_SIDE_EFFECTS (inner))\n-      || TREE_CODE (inner) == SAVE_EXPR || TREE_CODE (inner) == ERROR_MARK)\n+      || TREE_CODE (inner) == SAVE_EXPR\n+      || TREE_CODE (inner) == ERROR_MARK)\n     return t;\n \n   /* If T contains a PLACEHOLDER_EXPR, we must evaluate it each time, since"}]}