{"sha": "3bbbe009de4f810f7240eae51e45d861582ecf79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JiYmUwMDlkZTRmODEwZjcyNDBlYWU1MWU0NWQ4NjE1ODJlY2Y3OQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2015-07-14T22:56:45Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2015-07-14T22:56:45Z"}, "message": "nios2.h (LABEL_ALIGN): Define.\n\n2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Cesar Philippidis  <cesar@codesourcery.com>\n\t    Chung-Lin Tang  <cltang@codesourcery.com>\n\n\tgcc/\n\t* config/nios2/nios2.h (LABEL_ALIGN): Define.\n\t(REG_ALLOC_ORDER): Define.\n\t(ADJUST_REG_ALLOC_ORDER): Define.\n\t(HONOR_REG_ALLOC_ORDER): Define.\n\t(CDX_REG_P): Define.\n\t(ANDCLEAR_INT): Define.\n\t* config/nios2/nios2-protos.h (nios2_add_insn_asm): Declare.\n\t(nios2_label_align): Declare.\n\t(nios2_cdx_narrow_form_p): Declare.\n\t(nios2_adjust_reg_alloc_order): Declare.\n\t* config/nios2/nios2.c (nios2_rtx_costs): Adjust for BMX zero-extract\n\toperation.\n\t(nios2_large_unspec_reloc_p): New function, split from...\n\t(nios2_legitimate_pic_operand_p): ...here.\n\t(nios2_emit_move_sequence): Add *high/*lo_sum constant expand code.\n\t(nios2_print_operand_punct_valid_p): New.\n\t(nios2_print_operand): Add %., %!, %x, %y, %A.  Remove %U.\n\t(split_mem_address): New.\n\t(split_alu_insn): New.\n\t(cdxreg): New.\n\t(cdx_add_immed, cdx_and_immed, cdx_mov_immed, cdx_shift_immed): New.\n\t(enum nios2_add_insn_kind): New.\n\t(nios2_add_insn_names, nios2_add_insn_narrow): New.\n\t(nios2_add_insn_classify): New.\n\t(nios2_add_insn_asm): New.\n\t(nios2_cdx_narrow_form_p): New.\n\t(label_align, min_labelno, max_labelno): New.\n\t(nios2_reorg): New.\n\t(nios2_label_align): New.\n\t(nios2_adjust_reg_alloc_order): New.\n\t(TARGET_PRINT_OPERAND_PUNCT_VALID_P): Define.\n\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t* config/nios2/constraints.md (P): New constraint.\n\t* config/nios2/predicates.md (const_and_operand): New.\n\t(and_operand): New.\n\t(stack_memory_operand): New.\n\t* config/nios2/nios2.md (SP_REGNO): Define stack pointer regno.\n\t(length): Update to use nios2_cdx_narrow_form_p().\n\t(type): Add new insn type values.\n\t(control, alu, st, ld, shift): Update insn reservations with\n\tnew insn type values.\n\t(*high, *lo_sum): Define new insn patterns for constant generation.\n\t(movqi_internal, movhi_internal, movsi_internal): Reduce\n\talternatives, update asm template to handle CDX variants, update\n\ttype attributes.\n\t(zero_extendhisi2, zero_extendqi<mode>2): Add CDX variants to asm\n\ttemplate, update type attributes.\n\t(extendhisi2, extendqi<mode>2): Likewise.\n\t(addsi3): Change to use function for asm string.\n\t(subsi3): Add CDX notation to asm template, update type attributes.\n\t(negsi3, one_cmplsi3): Likewise.\n\t(andsi3): New pattern, specialized from logical patterns.\n\t(<code>si3): Remove and case, combine alternatives, update asm\n\ttemplate.\n\t(<shift_op>si3): Add CDX notation, update type attributes.\n\t(rotrsi3): Update type attribute.\n\t(*merge, extzv, insv): New insn patterns.\n\t(return): Change to define_expand.\n\t(simple_return): Add CDX notation, update type attributes.\n\t(indirect_jump): Add CDX notation.\n\t(jump): Update asm cases, update length attribute expression.\n\t(*call, *call_value, *sibcall, *sibcall_value): Add CDX variant.\n\t(nios2_cbranch): Update asm cases and length attribute expression\n\tto handle CDX variants.\n\t(nios2_cmp<code>): Update asm template.\n\t(nop): Add CDX notation, update type attributes.\n\t(trap): Add CDX notation.\n\t(ctrapsi4): Update asm cases and length attribute expression to\n\thandle CDX variant.\n\t* doc/md.texi (Machine Constraints): Document P constraint.\n\n\tgcc/testsuite/\n\t* gcc.target/nios2/andci.c: New.\n\t* gcc.target/nios2/bmx.c: New.\n\t* gcc.target/nios2/cdx-add.c: New.\n\t* gcc.target/nios2/cdx-branch.c: New.\n\t* gcc.target/nios2/cdx-callret.c: New.\n\t* gcc.target/nios2/cdx-loadstore.c: New.\n\t* gcc.target/nios2/cdx-logical.c: New.\n\t* gcc.target/nios2/cdx-mov.c: New.\n\t* gcc.target/nios2/cdx-shift.c: New.\n\t* gcc.target/nios2/cdx-sub.c: New.\n\t* gcc.target/nios2/nios2-trap-insn.c: Adjust pattern.\n\nCo-Authored-By: Cesar Philippidis <cesar@codesourcery.com>\nCo-Authored-By: Chung-Lin Tang <cltang@codesourcery.com>\n\nFrom-SVN: r225796", "tree": {"sha": "632e931ab3af5cc88ed8677341490d7049b9c96a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/632e931ab3af5cc88ed8677341490d7049b9c96a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bbbe009de4f810f7240eae51e45d861582ecf79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbbe009de4f810f7240eae51e45d861582ecf79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bbbe009de4f810f7240eae51e45d861582ecf79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbbe009de4f810f7240eae51e45d861582ecf79/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a03c6ae38806e3ec5e017ff42471d8f6bff70a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03c6ae38806e3ec5e017ff42471d8f6bff70a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a03c6ae38806e3ec5e017ff42471d8f6bff70a41"}], "stats": {"total": 1512, "additions": 1390, "deletions": 122}, "files": [{"sha": "418a8aaa81ee683cff611967698648c66a136e75", "filename": "gcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -1,3 +1,78 @@\n+2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* config/nios2/nios2.h (LABEL_ALIGN): Define.\n+\t(REG_ALLOC_ORDER): Define.\n+\t(ADJUST_REG_ALLOC_ORDER): Define.\n+\t(HONOR_REG_ALLOC_ORDER): Define.\n+\t(CDX_REG_P): Define.\n+\t(ANDCLEAR_INT): Define.\n+\t* config/nios2/nios2-protos.h (nios2_add_insn_asm): Declare.\n+\t(nios2_label_align): Declare.\n+\t(nios2_cdx_narrow_form_p): Declare.\n+\t(nios2_adjust_reg_alloc_order): Declare.\n+\t* config/nios2/nios2.c (nios2_rtx_costs): Adjust for BMX zero-extract\n+\toperation.\n+\t(nios2_large_unspec_reloc_p): New function, split from...\n+\t(nios2_legitimate_pic_operand_p): ...here.\n+\t(nios2_emit_move_sequence): Add *high/*lo_sum constant expand code.\n+\t(nios2_print_operand_punct_valid_p): New.\n+\t(nios2_print_operand): Add %., %!, %x, %y, %A.  Remove %U.\n+\t(split_mem_address): New.\n+\t(split_alu_insn): New.\n+\t(cdxreg): New.\n+\t(cdx_add_immed, cdx_and_immed, cdx_mov_immed, cdx_shift_immed): New.\n+\t(enum nios2_add_insn_kind): New.\n+\t(nios2_add_insn_names, nios2_add_insn_narrow): New.\n+\t(nios2_add_insn_classify): New.\n+\t(nios2_add_insn_asm): New.\n+\t(nios2_cdx_narrow_form_p): New.\n+\t(label_align, min_labelno, max_labelno): New.\n+\t(nios2_reorg): New.\n+\t(nios2_label_align): New.\n+\t(nios2_adjust_reg_alloc_order): New.\n+\t(TARGET_PRINT_OPERAND_PUNCT_VALID_P): Define.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t* config/nios2/constraints.md (P): New constraint.\n+\t* config/nios2/predicates.md (const_and_operand): New.\n+\t(and_operand): New.\n+\t(stack_memory_operand): New.\n+\t* config/nios2/nios2.md (SP_REGNO): Define stack pointer regno.\n+\t(length): Update to use nios2_cdx_narrow_form_p().\n+\t(type): Add new insn type values.\n+\t(control, alu, st, ld, shift): Update insn reservations with\n+\tnew insn type values.\n+\t(*high, *lo_sum): Define new insn patterns for constant generation.\n+\t(movqi_internal, movhi_internal, movsi_internal): Reduce\n+\talternatives, update asm template to handle CDX variants, update\n+\ttype attributes.\n+\t(zero_extendhisi2, zero_extendqi<mode>2): Add CDX variants to asm\n+\ttemplate, update type attributes.\n+\t(extendhisi2, extendqi<mode>2): Likewise.\n+\t(addsi3): Change to use function for asm string.\n+\t(subsi3): Add CDX notation to asm template, update type attributes.\n+\t(negsi3, one_cmplsi3): Likewise.\n+\t(andsi3): New pattern, specialized from logical patterns.\n+\t(<code>si3): Remove and case, combine alternatives, update asm\n+\ttemplate.\n+\t(<shift_op>si3): Add CDX notation, update type attributes.\n+\t(rotrsi3): Update type attribute.\n+\t(*merge, extzv, insv): New insn patterns.\n+\t(return): Change to define_expand.\n+\t(simple_return): Add CDX notation, update type attributes.\n+\t(indirect_jump): Add CDX notation.\n+\t(jump): Update asm cases, update length attribute expression.\n+\t(*call, *call_value, *sibcall, *sibcall_value): Add CDX variant.\n+\t(nios2_cbranch): Update asm cases and length attribute expression\n+\tto handle CDX variants.\n+\t(nios2_cmp<code>): Update asm template.\n+\t(nop): Add CDX notation, update type attributes.\n+\t(trap): Add CDX notation.\n+\t(ctrapsi4): Update asm cases and length attribute expression to\n+\thandle CDX variant.\n+\t* doc/md.texi (Machine Constraints): Document P constraint.\n+\n 2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>"}, {"sha": "0ec817fd77182b27e3f2d48102b09ee8b3166563", "filename": "gcc/config/nios2/constraints.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fconstraints.md?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -20,9 +20,10 @@\n \n ;; We use the following constraint letters for constants\n ;;\n-;;  I: -32768 to -32767\n+;;  I: -32768 to 32767\n ;;  J: 0 to 65535\n ;;  K: $nnnn0000 for some nnnn\n+;;  P: Under R2, $nnnnffff or $ffffnnnn for some nnnn\n ;;  L: 0 to 31 (for shift counts)\n ;;  M: 0\n ;;  N: 0 to 255 (for custom instruction numbers)\n@@ -86,6 +87,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival >= 0 && ival <= 31\")))\n \n+(define_constraint \"P\"\n+  \"An immediate operand for R2 andchi/andci instructions.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_ARCH_R2 && ANDCLEAR_INT (ival)\")))\n+\n (define_constraint \"S\"\n   \"An immediate stored in small data, accessible by GP.\"\n   (match_test \"gprel_constant_p (op)\"))"}, {"sha": "617b6ab46fad77bc6e87e98dde7018be90715dfc", "filename": "gcc/config/nios2/nios2-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -42,12 +42,18 @@ extern bool nios2_validate_fpu_compare (machine_mode, rtx *, rtx *, rtx *,\n \n extern bool nios2_fpu_insn_enabled (enum n2fpu_code);\n extern const char * nios2_fpu_insn_asm (enum n2fpu_code);\n+extern const char * nios2_add_insn_asm (rtx_insn *, rtx *);\n \n extern bool nios2_legitimate_pic_operand_p (rtx);\n extern bool gprel_constant_p (rtx);\n extern bool nios2_regno_ok_for_base_p (int, bool);\n extern bool nios2_unspec_reloc_p (rtx);\n \n+extern int nios2_label_align (rtx);\n+extern bool nios2_cdx_narrow_form_p (rtx_insn *);\n+\n+extern void nios2_adjust_reg_alloc_order (void);\n+\n #ifdef TREE_CODE\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines both ARGS_SIZE_RTX and `enum direction' */"}, {"sha": "d9fe6054b4de4b3e9b55298a80eab19a15e68ed8", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 692, "deletions": 25, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -1195,6 +1195,13 @@ nios2_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n           return false;\n         }\n \n+    case ZERO_EXTRACT:\n+      if (TARGET_HAS_BMX)\n+\t{\n+          *total = COSTS_N_INSNS (1);\n+          return true;\n+\t}\n+\n       default:\n         return false;\n     }\n@@ -1262,6 +1269,14 @@ nios2_unspec_reloc_p (rtx op)\n \t  && ! nios2_large_offset_p (XINT (XEXP (op, 0), 1)));\n }\n \n+static bool\n+nios2_large_unspec_reloc_p (rtx op)\n+{\n+  return (GET_CODE (op) == CONST\n+\t  && GET_CODE (XEXP (op, 0)) == UNSPEC\n+\t  && nios2_large_offset_p (XINT (XEXP (op, 0), 1)));\n+}\n+\n /* Helper to generate unspec constant.  */\n static rtx\n nios2_unspec_offset (rtx loc, int unspec)\n@@ -1871,9 +1886,7 @@ nios2_load_pic_address (rtx sym, int unspec, rtx tmp)\n bool\n nios2_legitimate_pic_operand_p (rtx x)\n {\n-  if (GET_CODE (x) == CONST\n-      && GET_CODE (XEXP (x, 0)) == UNSPEC\n-      && nios2_large_offset_p (XINT (XEXP (x, 0), 1)))\n+  if (nios2_large_unspec_reloc_p (x))\n     return true;\n \n   return ! (GET_CODE (x) == SYMBOL_REF\n@@ -2001,10 +2014,37 @@ nios2_emit_move_sequence (rtx *operands, machine_mode mode)\n       from = copy_to_mode_reg (mode, from);\n     }\n \n-  if (GET_CODE (from) == SYMBOL_REF || GET_CODE (from) == LABEL_REF\n-      || (GET_CODE (from) == CONST\n-\t  && GET_CODE (XEXP (from, 0)) != UNSPEC))\n-    from = nios2_legitimize_constant_address (from);\n+  if (CONSTANT_P (from))\n+    {\n+      if (CONST_INT_P (from))\n+\t{\n+\t  if (!SMALL_INT (INTVAL (from))\n+\t      && !SMALL_INT_UNSIGNED (INTVAL (from))\n+\t      && !UPPER16_INT (INTVAL (from)))\n+\t    {\n+\t      HOST_WIDE_INT high = (INTVAL (from) + 0x8000) & ~0xffff;\n+\t      HOST_WIDE_INT low = INTVAL (from) & 0xffff;\n+\t      emit_move_insn (to, gen_int_mode (high, SImode));\n+\t      emit_insn (gen_add2_insn (to, gen_int_mode (low, HImode)));\n+\t      set_unique_reg_note (get_last_insn (), REG_EQUAL,\n+\t\t\t\t   copy_rtx (from));\n+\t      return true;\n+\t    }\n+\t}\n+      else if (!gprel_constant_p (from))\n+\t{\n+\t  if (!nios2_large_unspec_reloc_p (from))\n+\t    from = nios2_legitimize_constant_address (from);\n+\t  if (CONSTANT_P (from))\n+\t    {\n+\t      emit_insn (gen_rtx_SET (to, gen_rtx_HIGH (Pmode, from)));\n+\t      emit_insn (gen_rtx_SET (to, gen_rtx_LO_SUM (Pmode, to, from)));\n+\t      set_unique_reg_note (get_last_insn (), REG_EQUAL,\n+\t\t\t\t   copy_rtx (operands[1]));\n+\t      return true;\n+\t    }\n+\t}\n+    }\n \n   operands[0] = to;\n   operands[1] = from;\n@@ -2037,25 +2077,106 @@ nios2_adjust_call_address (rtx *call_op, rtx reg)\n \f\n /* Output assembly language related definitions.  */\n \n+/* Implement TARGET_PRINT_OPERAND_PUNCT_VALID_P.  */\n+static bool\n+nios2_print_operand_punct_valid_p (unsigned char code)\n+{\n+  return (code == '.' || code == '!');\n+}\n+\n+\n /* Print the operand OP to file stream FILE modified by LETTER.\n    LETTER can be one of:\n \n-     i: print \"i\" if OP is an immediate, except 0\n-     o: print \"io\" if OP is volatile\n-     z: for const0_rtx print $0 instead of 0\n+     i: print i/hi/ui suffixes (used for mov instruction variants),\n+        when OP is the appropriate immediate operand.\n+\n+     u: like 'i', except without \"ui\" suffix case (used for cmpgeu/cmpltu)\n+\n+     o: print \"io\" if OP needs volatile access (due to TARGET_BYPASS_CACHE\n+        or TARGET_BYPASS_CACHE_VOLATILE).\n+\n+     x: print i/hi/ci/chi suffixes for the and instruction,\n+        when OP is the appropriate immediate operand.\n+\n+     z: prints the third register immediate operand in assembly\n+        instructions.  Outputs const0_rtx as the 'zero' register\n+\tinstead of '0'.\n+\t\n+     y: same as 'z', but for specifically for logical instructions,\n+        where the processing for immediates are slightly different.\n+\n      H: for %hiadj\n      L: for %lo\n-     U: for upper half of 32 bit value\n      D: for the upper 32-bits of a 64-bit double value\n      R: prints reverse condition.\n+     A: prints (reg) operand for ld[s]ex and st[s]ex.\n+\n+     .: print .n suffix for 16-bit instructions.\n+     !: print r.n suffix for 16-bit instructions.  Used for jmpr.n.\n */\n static void\n nios2_print_operand (FILE *file, rtx op, int letter)\n {\n \n+  /* First take care of the format letters that just insert a string\n+     into the output stream.  */\n   switch (letter)\n     {\n+    case '.':\n+      if (current_output_insn && get_attr_length (current_output_insn) == 2)\n+\tfprintf (file, \".n\");\n+      return;\n+\n+    case '!':\n+      if (current_output_insn && get_attr_length (current_output_insn) == 2)\n+\tfprintf (file, \"r.n\");\n+      return;\n+\n+    case 'x':\n+      if (CONST_INT_P (op))\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (op);\n+\t  HOST_WIDE_INT low = val & 0xffff;\n+\t  HOST_WIDE_INT high = (val >> 16) & 0xffff;\n+\n+\t  if (val != 0)\n+\t    {\n+\t      if (high != 0)\n+\t\t{\n+\t\t  if (low != 0)\n+\t\t    {\n+\t\t      gcc_assert (TARGET_ARCH_R2);\n+\t\t      if (high == 0xffff)\n+\t\t\tfprintf (file, \"c\");\n+\t\t      else if (low == 0xffff)\n+\t\t\tfprintf (file, \"ch\");\n+\t\t      else\n+\t\t\tgcc_unreachable ();\n+\t\t    }\n+\t\t  else\n+\t\t    fprintf (file, \"h\");\n+\t\t}\n+\t      fprintf (file, \"i\");\n+\t    }\n+\t}\n+      return;\n+\n+    case 'u':\n     case 'i':\n+      if (CONST_INT_P (op))\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (op);\n+\t  HOST_WIDE_INT low = val & 0xffff;\n+\t  HOST_WIDE_INT high = (val >> 16) & 0xffff;\n+\t  if (val != 0)\n+\t    {\n+\t      if (low == 0 && high != 0)\n+\t\tfprintf (file, \"h\");\n+\t      else if (high == 0 && (low & 0x8000) != 0 && letter != 'u')\n+\t\tfprintf (file, \"u\");\n+\t    }\n+\t}\n       if (CONSTANT_P (op) && op != const0_rtx)\n         fprintf (file, \"i\");\n       return;\n@@ -2064,13 +2185,18 @@ nios2_print_operand (FILE *file, rtx op, int letter)\n       if (GET_CODE (op) == MEM\n \t  && ((MEM_VOLATILE_P (op) && TARGET_BYPASS_CACHE_VOLATILE)\n \t      || TARGET_BYPASS_CACHE))\n-        fprintf (file, \"io\");\n+\t{\n+\t  gcc_assert (current_output_insn\n+\t\t      && get_attr_length (current_output_insn) == 4);\n+\t  fprintf (file, \"io\");\n+\t}\n       return;\n \n     default:\n       break;\n     }\n \n+  /* Handle comparison operator names.  */\n   if (comparison_operator (op, VOIDmode))\n     {\n       enum rtx_code cond = GET_CODE (op);\n@@ -2086,10 +2212,11 @@ nios2_print_operand (FILE *file, rtx op, int letter)\n \t}\n     }\n \n+  /* Now handle the cases where we actually need to format an operand.  */\n   switch (GET_CODE (op))\n     {\n     case REG:\n-      if (letter == 0 || letter == 'z')\n+      if (letter == 0 || letter == 'z' || letter == 'y')\n         {\n           fprintf (file, \"%s\", reg_names[REGNO (op)]);\n           return;\n@@ -2102,19 +2229,64 @@ nios2_print_operand (FILE *file, rtx op, int letter)\n       break;\n \n     case CONST_INT:\n-      if (INTVAL (op) == 0 && letter == 'z')\n-        {\n-          fprintf (file, \"zero\");\n-          return;\n-        }\n+      {\n+\trtx int_rtx = op;\n+\tHOST_WIDE_INT val = INTVAL (int_rtx);\n+\tHOST_WIDE_INT low = val & 0xffff;\n+\tHOST_WIDE_INT high = (val >> 16) & 0xffff;\n+\n+\tif (letter == 'y')\n+\t  {\n+\t    if (val == 0)\n+\t      fprintf (file, \"zero\");\n+\t    else\n+\t      {\n+\t\tif (high != 0)\n+\t\t  {\n+\t\t    if (low != 0)\n+\t\t      {\n+\t\t\tgcc_assert (TARGET_ARCH_R2);\n+\t\t\tif (high == 0xffff)\n+\t\t\t  /* andci.  */\n+\t\t\t  int_rtx = gen_int_mode (low, SImode);\n+\t\t\telse if (low == 0xffff)\n+\t\t\t  /* andchi.  */\n+\t\t\t  int_rtx = gen_int_mode (high, SImode);\n+\t\t\telse\n+\t\t\t  gcc_unreachable ();\n+\t\t      }\n+\t\t    else\n+\t\t      /* andhi.  */\n+\t\t      int_rtx = gen_int_mode (high, SImode);\n+\t\t  }\n+\t\telse\n+\t\t  /* andi.  */\n+\t\t  int_rtx = gen_int_mode (low, SImode);\n+\t\toutput_addr_const (file, int_rtx);\n+\t      }\n+\t    return;\n+\t  }\n+\telse if (letter == 'z')\n+\t  {\n+\t    if (val == 0)\n+\t      fprintf (file, \"zero\");\n+\t    else\n+\t      {\n+\t\tif (low == 0 && high != 0)\n+\t\t  int_rtx = gen_int_mode (high, SImode);\n+\t\telse if (low != 0)\n+\t\t  {\n+\t\t    gcc_assert (high == 0 || high == 0xffff);\n+\t\t    int_rtx = gen_int_mode (low, high == 0 ? SImode : HImode);\n+\t\t  }\n+\t\telse\n+\t\t  gcc_unreachable ();\n+\t\toutput_addr_const (file, int_rtx);\n+\t      }\n+\t    return;\n+\t  }\n+      }\n \n-      if (letter == 'U')\n-        {\n-          HOST_WIDE_INT val = INTVAL (op);\n-\t  val = (val >> 16) & 0xFFFF;\n-\t  output_addr_const (file, gen_int_mode (val, SImode));\n-          return;\n-        }\n       /* Else, fall through.  */\n \n     case CONST:\n@@ -2147,6 +2319,12 @@ nios2_print_operand (FILE *file, rtx op, int letter)\n \n     case SUBREG:\n     case MEM:\n+      if (letter == 'A')\n+\t{\n+\t  /* Address of '(reg)' form, with no index.  */\n+\t  fprintf (file, \"(%s)\", reg_names[REGNO (XEXP (op, 0))]);\n+\t  return;\n+\t}\n       if (letter == 0)\n         {\n           output_address (op);\n@@ -3462,6 +3640,489 @@ nios2_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   reload_completed = 0;\n }\n \n+\n+/* Utility function to break a memory address into\n+   base register + constant offset.  Return false if something\n+   unexpected is seen.  */\n+static bool\n+split_mem_address (rtx addr, rtx *base_reg, rtx *offset)\n+{\n+  if (REG_P (addr))\n+    {\n+      *base_reg = addr;\n+      *offset = const0_rtx;\n+      return true;\n+    }\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      *base_reg = XEXP (addr, 0);\n+      *offset = XEXP (addr, 1);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Splits out the operands of an ALU insn, places them in *LHS, *RHS1, *RHS2.  */\n+static void\n+split_alu_insn (rtx_insn *insn, rtx *lhs, rtx *rhs1, rtx *rhs2)\n+{\n+  rtx pat = PATTERN (insn);\n+  gcc_assert (GET_CODE (pat) == SET);\n+  *lhs = SET_DEST (pat);\n+  *rhs1 = XEXP (SET_SRC (pat), 0);\n+  if (GET_RTX_CLASS (GET_CODE (SET_SRC (pat))) != RTX_UNARY)\n+    *rhs2 = XEXP (SET_SRC (pat), 1);\n+  return;\n+}\n+\n+/* Returns true if OP is a REG and assigned a CDX reg.  */\n+static bool\n+cdxreg (rtx op)\n+{\n+  return REG_P (op) && (!reload_completed || CDX_REG_P (REGNO (op)));\n+}\n+\n+/* Returns true if OP is within range of CDX addi.n immediates.  */\n+static bool\n+cdx_add_immed (rtx op)\n+{\n+  if (CONST_INT_P (op))\n+    {\n+      HOST_WIDE_INT ival = INTVAL (op);\n+      return ival <= 128 && ival > 0 && (ival & (ival - 1)) == 0;\n+    }\n+  return false;\n+}\n+\n+/* Returns true if OP is within range of CDX andi.n immediates.  */\n+static bool\n+cdx_and_immed (rtx op)\n+{\n+  if (CONST_INT_P (op))\n+    {\n+      HOST_WIDE_INT ival = INTVAL (op);\n+      return (ival == 1 || ival == 2 || ival == 3 || ival == 4\n+\t      || ival == 8 || ival == 0xf || ival == 0x10\n+\t      || ival == 0x10 || ival == 0x1f || ival == 0x20\n+\t      || ival == 0x3f || ival == 0x3f || ival == 0x7f\n+\t      || ival == 0x80 || ival == 0xff || ival == 0x7ff\n+\t      || ival == 0xff00 || ival == 0xffff);\n+    }\n+  return false;\n+}\n+\n+/* Returns true if OP is within range of CDX movi.n immediates.  */\n+static bool\n+cdx_mov_immed (rtx op)\n+{\n+  if (CONST_INT_P (op))\n+    {\n+      HOST_WIDE_INT ival = INTVAL (op);\n+      return ((ival >= 0 && ival <= 124)\n+\t      || ival == 0xff || ival == -2 || ival == -1);\n+    }\n+  return false;\n+}\n+\n+/* Returns true if OP is within range of CDX slli.n/srli.n immediates.  */\n+static bool\n+cdx_shift_immed (rtx op)\n+{\n+  if (CONST_INT_P (op))\n+    {\n+      HOST_WIDE_INT ival = INTVAL (op);\n+      return (ival == 1 || ival == 2 || ival == 3 || ival == 8\n+\t      || ival == 12 || ival == 16 || ival == 24\n+\t      || ival == 31);\n+    }\n+  return false;\n+}\n+\n+\n+\n+/* Classification of different kinds of add instructions.  */\n+enum nios2_add_insn_kind {\n+  nios2_add_n_kind,\n+  nios2_addi_n_kind,\n+  nios2_subi_n_kind,\n+  nios2_spaddi_n_kind,\n+  nios2_spinci_n_kind,\n+  nios2_spdeci_n_kind,\n+  nios2_add_kind,\n+  nios2_addi_kind\n+};\n+\n+static const char *nios2_add_insn_names[] = {\n+  \"add.n\", \"addi.n\", \"subi.n\", \"spaddi.n\",  \"spinci.n\", \"spdeci.n\",\n+  \"add\", \"addi\" };\n+static bool nios2_add_insn_narrow[] = {\n+  true, true, true, true, true, true,\n+  false, false};\n+\n+/* Function to classify kinds of add instruction patterns.  */\n+static enum nios2_add_insn_kind \n+nios2_add_insn_classify (rtx_insn *insn ATTRIBUTE_UNUSED,\n+\t\t\t rtx lhs, rtx rhs1, rtx rhs2)\n+{\n+  if (TARGET_HAS_CDX)\n+    {\n+      if (cdxreg (lhs) && cdxreg (rhs1))\n+\t{\n+\t  if (cdxreg (rhs2))\n+\t    return nios2_add_n_kind;\n+\t  if (CONST_INT_P (rhs2))\n+\t    {\n+\t      HOST_WIDE_INT ival = INTVAL (rhs2);\n+\t      if (ival > 0 && cdx_add_immed (rhs2))\n+\t\treturn nios2_addi_n_kind;\n+\t      if (ival < 0 && cdx_add_immed (GEN_INT (-ival)))\n+\t\treturn nios2_subi_n_kind;\n+\t    }\n+\t}\n+      else if (rhs1 == stack_pointer_rtx\n+\t       && CONST_INT_P (rhs2))\n+\t{\n+\t  HOST_WIDE_INT imm7 = INTVAL (rhs2) >> 2;\n+\t  HOST_WIDE_INT rem = INTVAL (rhs2) & 3;\n+\t  if (rem == 0 && (imm7 & ~0x7f) == 0)\n+\t    {\n+\t      if (cdxreg (lhs))\n+\t\treturn nios2_spaddi_n_kind;\n+\t      if (lhs == stack_pointer_rtx)\n+\t\treturn nios2_spinci_n_kind;\n+\t    }\n+\t  imm7 = -INTVAL(rhs2) >> 2;\n+\t  rem = -INTVAL (rhs2) & 3;\n+\t  if (lhs == stack_pointer_rtx\n+\t      && rem == 0 && (imm7 & ~0x7f) == 0)\n+\t    return nios2_spdeci_n_kind;\n+\t}\n+    }\n+  return ((REG_P (rhs2) || rhs2 == const0_rtx)\n+\t  ? nios2_add_kind : nios2_addi_kind);\n+}\n+\n+/* Emit assembly language for the different kinds of add instructions.  */\n+const char*\n+nios2_add_insn_asm (rtx_insn *insn, rtx *operands)\n+{\n+  static char buf[256];\n+  int ln = 256;\n+  enum nios2_add_insn_kind kind\n+    = nios2_add_insn_classify (insn, operands[0], operands[1], operands[2]);\n+  if (kind == nios2_subi_n_kind)\n+    snprintf (buf, ln, \"subi.n\\t%%0, %%1, %d\", (int) -INTVAL (operands[2]));\n+  else if (kind == nios2_spaddi_n_kind)\n+    snprintf (buf, ln, \"spaddi.n\\t%%0, %%2\");\n+  else if (kind == nios2_spinci_n_kind)\n+    snprintf (buf, ln, \"spinci.n\\t%%2\");\n+  else if (kind == nios2_spdeci_n_kind)\n+    snprintf (buf, ln, \"spdeci.n\\t%d\", (int) -INTVAL (operands[2]));\n+  else\n+    snprintf (buf, ln, \"%s\\t%%0, %%1, %%z2\", nios2_add_insn_names[(int)kind]);\n+  return buf;\n+}\n+\n+/* This routine, which the default \"length\" attribute computation is\n+   based on, encapsulates information about all the cases where CDX\n+   provides a narrow 2-byte instruction form.  */\n+bool\n+nios2_cdx_narrow_form_p (rtx_insn *insn)\n+{\n+  rtx pat, lhs, rhs1, rhs2;\n+  enum attr_type type;\n+  if (!TARGET_HAS_CDX)\n+    return false;\n+  type = get_attr_type (insn);\n+  pat = PATTERN (insn);\n+  gcc_assert (reload_completed);\n+  switch (type)\n+    {\n+    case TYPE_CONTROL:\n+      if (GET_CODE (pat) == SIMPLE_RETURN)\n+\treturn true;\n+      if (GET_CODE (pat) == PARALLEL)\n+\tpat = XVECEXP (pat, 0, 0);\n+      if (GET_CODE (pat) == SET)\n+\tpat = SET_SRC (pat);\n+      if (GET_CODE (pat) == IF_THEN_ELSE)\n+\t{\n+\t  /* Conditional branch patterns; for these we\n+\t     only check the comparison to find beqz.n/bnez.n cases.\n+\t     For the 'nios2_cbranch' pattern, we cannot also check\n+\t     the branch range here. That will be done at the md\n+\t     pattern \"length\" attribute computation.  */\n+\t  rtx cmp = XEXP (pat, 0);\n+\t  return ((GET_CODE (cmp) == EQ || GET_CODE (cmp) == NE)\n+\t\t  && cdxreg (XEXP (cmp, 0))\n+\t\t  && XEXP (cmp, 1) == const0_rtx);\n+\t}\n+      if (GET_CODE (pat) == TRAP_IF)\n+\t/* trap.n is always usable.  */\n+\treturn true;\n+      if (GET_CODE (pat) == CALL)\n+\tpat = XEXP (XEXP (pat, 0), 0);\n+      if (REG_P (pat))\n+\t/* Control instructions taking a register operand are indirect\n+\t   jumps and calls.  The CDX instructions have a 5-bit register\n+\t   field so any reg is valid.  */\n+\treturn true;\n+      else\n+\t{\n+\t  gcc_assert (!insn_variable_length_p (insn));\n+\t  return false;\n+\t}\n+    case TYPE_ADD:\n+      {\n+\tenum nios2_add_insn_kind kind;\n+\tsplit_alu_insn (insn, &lhs, &rhs1, &rhs2);\n+\tkind = nios2_add_insn_classify (insn, lhs, rhs1, rhs2);\n+\treturn nios2_add_insn_narrow[(int)kind];\n+      }\n+    case TYPE_LD:\n+      {\n+\tbool ret;\n+\tHOST_WIDE_INT offset, rem = 0;\n+\trtx addr, reg = SET_DEST (pat), mem = SET_SRC (pat);\n+\tif (GET_CODE (mem) == SIGN_EXTEND)\n+\t  /* No CDX form for sign-extended load.  */\n+\t  return false;\n+\tif (GET_CODE (mem) == ZERO_EXTEND)\n+\t  /* The load alternatives in the zero_extend* patterns.  */\n+\t  mem = XEXP (mem, 0);\n+\tif (MEM_P (mem))\n+\t  {\n+\t    /* ldxio.  */\n+\t    if ((MEM_VOLATILE_P (mem) && TARGET_BYPASS_CACHE_VOLATILE)\n+\t\t|| TARGET_BYPASS_CACHE)\n+\t      return false;\n+\t    addr = XEXP (mem, 0);\n+\t    /* GP-based references are never narrow.  */\n+\t    if (gprel_constant_p (addr))\n+\t\treturn false;\n+\t    ret = split_mem_address (addr, &rhs1, &rhs2);\n+\t    gcc_assert (ret);\n+\t  }\n+\telse\n+\t  return false;\n+\n+\toffset = INTVAL (rhs2);\n+\tif (GET_MODE (mem) == SImode)\n+\t  {\n+\t    rem = offset & 3;\n+\t    offset >>= 2;\n+\t    /* ldwsp.n case.  */\n+\t    if (rtx_equal_p (rhs1, stack_pointer_rtx)\n+\t\t&& rem == 0 && (offset & ~0x1f) == 0)\n+\t      return true;\n+\t  }\n+\telse if (GET_MODE (mem) == HImode)\n+\t  {\n+\t    rem = offset & 1;\n+\t    offset >>= 1;\n+\t  }\n+\t/* ldbu.n, ldhu.n, ldw.n cases.  */\n+\treturn (cdxreg (reg) && cdxreg (rhs1)\n+\t\t&& rem == 0 && (offset & ~0xf) == 0);\n+      }\n+    case TYPE_ST:\n+      if (GET_CODE (pat) == PARALLEL)\n+\t/* stex, stsex.  */\n+\treturn false;\n+      else\n+\t{\n+\t  bool ret;\n+\t  HOST_WIDE_INT offset, rem = 0;\n+\t  rtx addr, reg = SET_SRC (pat), mem = SET_DEST (pat);\n+\t  if (!MEM_P (mem))\n+\t    return false;\n+\t  /* stxio.  */\n+\t  if ((MEM_VOLATILE_P (mem) && TARGET_BYPASS_CACHE_VOLATILE)\n+\t      || TARGET_BYPASS_CACHE)\n+\t    return false;\n+\t  addr = XEXP (mem, 0);\n+\t  /* GP-based references are never narrow.  */\n+\t  if (gprel_constant_p (addr))\n+\t    return false;\n+\t  ret = split_mem_address (addr, &rhs1, &rhs2);\n+\t  gcc_assert (ret);\n+\t  offset = INTVAL (rhs2);\n+\t  if (GET_MODE (mem) == SImode)\n+\t    {\n+\t      rem = offset & 3;\n+\t      offset >>= 2;\n+\t      /* stwsp.n case.  */\n+\t      if (rtx_equal_p (rhs1, stack_pointer_rtx)\n+\t\t  && rem == 0 && (offset & ~0x1f) == 0)\n+\t\treturn true;\n+\t      /* stwz.n case.  */\n+\t      else if (reg == const0_rtx && cdxreg (rhs1)\n+\t\t       && rem == 0 && (offset & ~0x3f) == 0)\n+\t\treturn true;\n+\t    }\n+\t  else if (GET_MODE (mem) == HImode)\n+\t    {\n+\t      rem = offset & 1;\n+\t      offset >>= 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (GET_MODE (mem) == QImode);\n+\t      /* stbz.n case.  */\n+\t      if (reg == const0_rtx && cdxreg (rhs1)\n+\t\t  && (offset & ~0x3f) == 0)\n+\t\treturn true;\n+\t    }\n+\n+\t  /* stbu.n, sthu.n, stw.n cases.  */\n+\t  return (cdxreg (reg) && cdxreg (rhs1)\n+\t\t  && rem == 0 && (offset & ~0xf) == 0);\n+\t}\n+    case TYPE_MOV:\n+      lhs = SET_DEST (pat);\n+      rhs1 = SET_SRC (pat);\n+      if (CONST_INT_P (rhs1))\n+\treturn (cdxreg (lhs) && cdx_mov_immed (rhs1));\n+      gcc_assert (REG_P (lhs) && REG_P (rhs1));\n+      return true;\n+\n+    case TYPE_AND:\n+      /* Some zero_extend* alternatives are and insns.  */\n+      if (GET_CODE (SET_SRC (pat)) == ZERO_EXTEND)\n+\treturn (cdxreg (SET_DEST (pat))\n+\t\t&& cdxreg (XEXP (SET_SRC (pat), 0)));\n+      split_alu_insn (insn, &lhs, &rhs1, &rhs2);\n+      if (CONST_INT_P (rhs2))\n+\treturn (cdxreg (lhs) && cdxreg (rhs1) && cdx_and_immed (rhs2));\n+      return (cdxreg (lhs) && cdxreg (rhs2)\n+\t      && (!reload_completed || rtx_equal_p (lhs, rhs1)));\n+\n+    case TYPE_OR:\n+    case TYPE_XOR:\n+      /* Note the two-address limitation for CDX form.  */\n+      split_alu_insn (insn, &lhs, &rhs1, &rhs2);\n+      return (cdxreg (lhs) && cdxreg (rhs2)\n+\t      && (!reload_completed || rtx_equal_p (lhs, rhs1)));\n+\n+    case TYPE_SUB:\n+      split_alu_insn (insn, &lhs, &rhs1, &rhs2);\n+      return (cdxreg (lhs) && cdxreg (rhs1) && cdxreg (rhs2));\n+\n+    case TYPE_NEG:\n+    case TYPE_NOT:\n+      split_alu_insn (insn, &lhs, &rhs1, NULL);\n+      return (cdxreg (lhs) && cdxreg (rhs1));\n+\n+    case TYPE_SLL:\n+    case TYPE_SRL:\n+      split_alu_insn (insn, &lhs, &rhs1, &rhs2);\n+      return (cdxreg (lhs)\n+\t      && ((cdxreg (rhs1) && cdx_shift_immed (rhs2))\n+\t\t  || (cdxreg (rhs2)\n+\t\t      && (!reload_completed || rtx_equal_p (lhs, rhs1)))));\n+    case TYPE_NOP:\n+    case TYPE_PUSH:\n+    case TYPE_POP:\n+      return true;\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Implement TARGET_MACHINE_DEPENDENT_REORG:\n+   We use this hook when emitting CDX code to enforce the 4-byte\n+   alignment requirement for labels that are used as the targets of\n+   jmpi instructions.  CDX code can otherwise contain a mix of 16-bit\n+   and 32-bit instructions aligned on any 16-bit boundary, but functions\n+   and jmpi labels have to be 32-bit aligned because of the way the address\n+   is encoded in the instruction.  */\n+\n+static unsigned char *label_align;\n+static int min_labelno, max_labelno;\n+\n+static void\n+nios2_reorg (void)\n+{\n+  bool changed = true;\n+  rtx_insn *insn;\n+\n+  if (!TARGET_HAS_CDX)\n+    return;\n+\n+  /* Initialize the data structures.  */\n+  if (label_align)\n+    free (label_align);\n+  max_labelno = max_label_num ();\n+  min_labelno = get_first_label_num ();\n+  label_align = XCNEWVEC (unsigned char, max_labelno - min_labelno + 1);\n+  \n+  /* Iterate on inserting alignment and adjusting branch lengths until\n+     no more changes.  */\n+  while (changed)\n+    {\n+      changed = false;\n+      shorten_branches (get_insns ());\n+\n+      for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))\n+\tif (JUMP_P (insn) && insn_variable_length_p (insn))\n+\t  {\n+\t    rtx label = JUMP_LABEL (insn);\n+\t    /* We use the current fact that all cases of 'jmpi'\n+\t       doing the actual branch in the machine description\n+\t       has a computed length of 6 or 8.  Length 4 and below\n+\t       are all PC-relative 'br' branches without the jump-align\n+\t       problem.  */\n+\t    if (label && LABEL_P (label) && get_attr_length (insn) > 4)\n+\t      {\n+\t\tint index = CODE_LABEL_NUMBER (label) - min_labelno;\n+\t\tif (label_align[index] != 2)\n+\t\t  {\n+\t\t    label_align[index] = 2;\n+\t\t    changed = true;\n+\t\t  }\n+\t      }\n+\t  }\n+    }\n+}\n+\n+/* Implement LABEL_ALIGN, using the information gathered in nios2_reorg.  */\n+int\n+nios2_label_align (rtx label)\n+{\n+  int n = CODE_LABEL_NUMBER (label);\n+\n+  if (label_align && n >= min_labelno && n <= max_labelno)\n+    return MAX (label_align[n - min_labelno], align_labels_log);\n+  return align_labels_log;\n+}\n+\n+/* Implement ADJUST_REG_ALLOC_ORDER.  We use the default ordering\n+   for R1 and non-CDX R2 code; for CDX we tweak thing to prefer\n+   the registers that can be used as operands to instructions that\n+   have 3-bit register fields.  */\n+void\n+nios2_adjust_reg_alloc_order (void)\n+{\n+  const int cdx_reg_alloc_order[] =\n+    {\n+      /* Call-clobbered GPRs within CDX 3-bit encoded range.  */\n+      2, 3, 4, 5, 6, 7, \n+      /* Call-saved GPRs within CDX 3-bit encoded range.  */\n+      16, 17,\n+      /* Other call-clobbered GPRs.  */\n+      8, 9, 10, 11, 12, 13, 14, 15,\n+      /* Other call-saved GPRs. RA placed first since it is always saved.  */\n+      31, 18, 19, 20, 21, 22, 23, 28,\n+      /* Fixed GPRs, not used by the register allocator.  */\n+      0, 1, 24, 25, 26, 27, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39\n+   };\n+\n+  if (TARGET_HAS_CDX)\n+    memcpy (reg_alloc_order, cdx_reg_alloc_order,\n+\t    sizeof (int) * FIRST_PSEUDO_REGISTER);\n+}\n+\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n@@ -3549,6 +4210,9 @@ nios2_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n #undef TARGET_ASM_OUTPUT_DWARF_DTPREL\n #define TARGET_ASM_OUTPUT_DWARF_DTPREL nios2_output_dwarf_dtprel\n \n+#undef TARGET_PRINT_OPERAND_PUNCT_VALID_P\n+#define TARGET_PRINT_OPERAND_PUNCT_VALID_P nios2_print_operand_punct_valid_p\n+\n #undef TARGET_PRINT_OPERAND\n #define TARGET_PRINT_OPERAND nios2_print_operand\n \n@@ -3589,6 +4253,9 @@ nios2_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n #undef  TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK nios2_asm_output_mi_thunk\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG nios2_reorg\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-nios2.h\""}, {"sha": "ff25ade9372a97e7bb33d699727fdecebecbf7d1", "filename": "gcc/config/nios2/nios2.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.h?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -96,6 +96,8 @@\n   ((TREE_CODE (EXP) == STRING_CST)                              \\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n+#define LABEL_ALIGN(LABEL) nios2_label_align (LABEL)\n+\n /* Layout of source language data types.  */\n \n #define INT_TYPE_SIZE 32\n@@ -175,6 +177,20 @@\n #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n+/* Order in which to allocate registers.  Each register must be\n+   listed once.  This is the default ordering for R1 and non-CDX R2\n+   code.  For CDX, we overwrite this in ADJUST_REG_ALLOC_ORDER.  */\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, \\\n+      20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, \\\n+      37, 38, 39 }\n+\n+#define ADJUST_REG_ALLOC_ORDER nios2_adjust_reg_alloc_order ()\n+\n+/* Caller-save costs can be less emphasized under R2 CDX, where we can\n+   use push.n/pop.n.  */\n+#define HONOR_REG_ALLOC_ORDER (TARGET_HAS_CDX)\n+\n /* Register Classes.  */\n \n enum reg_class\n@@ -213,6 +229,9 @@ enum reg_class\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n+#define CDX_REG_P(REGNO)\t\t\t\t\t\t\\\n+  ((REGNO) == 16 || (REGNO) == 17 || (2 <= (REGNO) && (REGNO) <= 7))\n+\n /* Tests for various kinds of constants used in the Nios II port.  */\n \n #define SMALL_INT(X) ((unsigned HOST_WIDE_INT)(X) + 0x8000 < 0x10000)\n@@ -222,6 +241,8 @@ enum reg_class\n #define SHIFT_INT(X) ((X) >= 0 && (X) <= 31)\n #define RDWRCTL_INT(X) ((X) >= 0 && (X) <= 31)\n #define CUSTOM_INSN_OPCODE(X) ((X) >= 0 && (X) <= 255)\n+#define ANDCLEAR_INT(X) \\\n+  (((X) & 0xffff) == 0xffff || (((X) >> 16) & 0xffff) == 0xffff)\n \n /* Say that the epilogue uses the return address register.  Note that\n    in the case of sibcalls, the values \"used by the epilogue\" are"}, {"sha": "a27df17670eaa5b377b7348944133d829d74ffe4", "filename": "gcc/config/nios2/nios2.md", "status": "modified", "additions": 230, "deletions": 95, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fnios2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.md?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -30,6 +30,7 @@\n \n    (TP_REGNO              23)\t; Thread pointer register\n    (GP_REGNO\t          26)\t; Global pointer register\n+   (SP_REGNO\t          27)\t; Stack pointer register\n    (FP_REGNO\t          28)\t; Frame pointer register\n    (EA_REGNO\t          29)\t; Exception return address register\n    (RA_REGNO              31)\t; Return address register\n@@ -92,9 +93,14 @@\n ; incuring a stall.\n \n ; length of an instruction (in bytes)\n-(define_attr \"length\" \"\" (const_int 4))\n+(define_attr \"length\" \"\"\n+  (if_then_else (match_test \"nios2_cdx_narrow_form_p (insn)\")\n+    (const_int 2)\n+    (const_int 4)))\n+\n (define_attr \"type\" \n-  \"unknown,complex,control,alu,cond_alu,st,ld,shift,mul,div,custom\" \n+  \"unknown,complex,control,alu,cond_alu,st,ld,stwm,ldwm,push,pop,mul,div,\\\n+   custom,add,sub,mov,and,or,xor,neg,not,sll,srl,sra,rol,ror,nop\"\n   (const_string \"complex\"))\n \n (define_asm_attributes\n@@ -118,19 +124,19 @@\n   \"cpu\")\n \n (define_insn_reservation \"control\" 1\n-  (eq_attr \"type\" \"control\")\n+  (eq_attr \"type\" \"control,pop\")\n   \"cpu\")\n \n (define_insn_reservation \"alu\" 1\n-  (eq_attr \"type\" \"alu\")\n+  (eq_attr \"type\" \"alu,add,sub,mov,and,or,xor,neg,not\")\n   \"cpu\")\n \n (define_insn_reservation \"cond_alu\" 1\n   (eq_attr \"type\" \"cond_alu\")\n   \"cpu\")\n \n (define_insn_reservation \"st\" 1\n-  (eq_attr \"type\" \"st\")\n+  (eq_attr \"type\" \"st,stwm,push\")\n   \"cpu\")\n   \n (define_insn_reservation \"custom\" 1\n@@ -139,11 +145,11 @@\n \n ; shifts, muls and lds have three cycle latency\n (define_insn_reservation \"ld\" 3\n-  (eq_attr \"type\" \"ld\")\n+  (eq_attr \"type\" \"ld,ldwm\")\n   \"cpu\")\n \n (define_insn_reservation \"shift\" 3\n-  (eq_attr \"type\" \"shift\")\n+  (eq_attr \"type\" \"sll,srl,sra,rol,ror\")\n   \"cpu\")\n \n (define_insn_reservation \"mul\" 3\n@@ -171,46 +177,90 @@\n     DONE;\n })\n \n+(define_insn \"*high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (high:SI (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"movhi\\\\t%0, %H1\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"*lo_sum\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (lo_sum:SI (match_operand:SI 1 \"register_operand\"  \"r\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"addi\\\\t%0, %1, %L2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n (define_insn \"movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=m, r,r, r\")\n-        (match_operand:QI 1 \"general_operand\"       \"rM,m,rM,I\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=m, r,r\")\n+        (match_operand:QI 1 \"general_operand\"       \"rM,m,rI\"))]\n   \"(register_operand (operands[0], QImode)\n     || reg_or_0_operand (operands[1], QImode))\"\n-  \"@\n-    stb%o0\\\\t%z1, %0\n-    ldbu%o1\\\\t%0, %1\n-    mov\\\\t%0, %z1\n-    movi\\\\t%0, %1\"\n-  [(set_attr \"type\" \"st,ld,alu,alu\")])\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+\tif (get_attr_length (insn) != 2)\n+\t  return \"stb%o0\\\\t%z1, %0\";\n+\telse if (const_0_operand (operands[1], QImode))\n+\t  return \"stbz.n\\\\t%z1, %0\";\n+\telse\n+\t  return \"stb.n\\\\t%z1, %0\";\n+      case 1:\n+\treturn \"ldbu%o1%.\\\\t%0, %1\";\n+      case 2:\n+\treturn \"mov%i1%.\\\\t%0, %z1\";\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+  [(set_attr \"type\" \"st,ld,mov\")])\n \n (define_insn \"movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m, r,r, r\")\n-        (match_operand:HI 1 \"general_operand\"       \"rM,m,rM,I\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m, r,r\")\n+        (match_operand:HI 1 \"general_operand\"       \"rM,m,rI\"))]\n   \"(register_operand (operands[0], HImode)\n     || reg_or_0_operand (operands[1], HImode))\"\n   \"@\n-    sth%o0\\\\t%z1, %0\n-    ldhu%o1\\\\t%0, %1\n-    mov\\\\t%0, %z1\n-    movi\\\\t%0, %1\"\n-  [(set_attr \"type\" \"st,ld,alu,alu\")])\n+    sth%o0%.\\\\t%z1, %0\n+    ldhu%o1%.\\\\t%0, %1\n+    mov%i1%.\\\\t%0, %z1\"\n+  [(set_attr \"type\" \"st,ld,mov\")])\n \n (define_insn \"movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m, r,r, r,r,r,r,r\")\n-        (match_operand:SI 1 \"general_operand\"       \"rM,m,rM,I,J,K,S,i\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m, r,r,   r\")\n+        (match_operand:SI 1 \"general_operand\"       \"rM,m,rIJK,S\"))]\n   \"(register_operand (operands[0], SImode)\n     || reg_or_0_operand (operands[1], SImode))\"\n-  \"@\n-    stw%o0\\\\t%z1, %0\n-    ldw%o1\\\\t%0, %1\n-    mov\\\\t%0, %z1\n-    movi\\\\t%0, %1\n-    movui\\\\t%0, %1\n-    movhi\\\\t%0, %H1\n-    addi\\\\t%0, gp, %%gprel(%1)\n-    movhi\\\\t%0, %H1\\;addi\\\\t%0, %0, %L1\"\n-  [(set_attr \"type\" \"st,ld,alu,alu,alu,alu,alu,alu\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,8\")])\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+\tif (get_attr_length (insn) != 2)\n+\t  return \"stw%o0\\\\t%z1, %0\";\n+\telse if (stack_memory_operand (operands[0], SImode))\n+\t  return \"stwsp.n\\\\t%z1, %0\";\n+\telse if (const_0_operand (operands[1], SImode))\n+\t  return \"stwz.n\\\\t%z1, %0\";\n+\telse\n+\t  return \"stw.n\\\\t%z1, %0\";\n+      case 1:\n+\tif (get_attr_length (insn) != 2)\n+\t  return \"ldw%o1\\\\t%0, %1\";\n+\telse if (stack_memory_operand (operands[1], SImode))\n+\t  return \"ldwsp.n\\\\t%0, %1\";\n+\telse\n+\t  return \"ldw.n\\\\t%0, %1\";\n+      case 2:\n+\treturn \"mov%i1%.\\\\t%0, %z1\";\n+      case 3:\n+\treturn \"addi\\\\t%0, gp, %%gprel(%1)\";\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+  [(set_attr \"type\" \"st,ld,mov,alu\")])\n \n (define_mode_iterator BH [QI HI])\n (define_mode_iterator BHW [QI HI SI])\n@@ -264,18 +314,18 @@\n         (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    andi\\\\t%0, %1, 0xffff\n-    ldhu%o1\\\\t%0, %1\"\n-  [(set_attr \"type\"     \"alu,ld\")])\n+    andi%.\\\\t%0, %1, 0xffff\n+    ldhu%o1%.\\\\t%0, %1\"\n+  [(set_attr \"type\"     \"and,ld\")])\n \n (define_insn \"zero_extendqi<mode>2\"\n   [(set (match_operand:QX 0 \"register_operand\" \"=r,r\")\n         (zero_extend:QX (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    andi\\\\t%0, %1, 0xff\n-    ldbu%o1\\\\t%0, %1\"\n-  [(set_attr \"type\"     \"alu,ld\")])\n+    andi%.\\\\t%0, %1, 0xff\n+    ldbu%o1%.\\\\t%0, %1\"\n+  [(set_attr \"type\"     \"and,ld\")])\n \n ;; Sign extension patterns\n \n@@ -285,7 +335,7 @@\n   \"\"\n   \"@\n    #\n-   ldh%o1\\\\t%0, %1\"\n+   ldh%o1%.\\\\t%0, %1\"\n   [(set_attr \"type\" \"alu,ld\")])\n \n (define_insn \"extendqi<mode>2\"\n@@ -294,7 +344,7 @@\n   \"\"\n   \"@\n    #\n-   ldb%o1\\\\t%0, %1\"\n+   ldb%o1%.\\\\t%0, %1\"\n   [(set_attr \"type\" \"alu,ld\")])\n \n ;; Split patterns for register alternative cases.\n@@ -331,16 +381,18 @@\n         (plus:SI (match_operand:SI 1 \"register_operand\"   \"%r\")\n                  (match_operand:SI 2 \"add_regimm_operand\" \"rIT\")))]\n   \"\"\n-  \"add%i2\\\\t%0, %1, %z2\"\n-  [(set_attr \"type\" \"alu\")])\n+{\n+  return nios2_add_insn_asm (insn, operands);\n+}\n+  [(set_attr \"type\" \"add\")])\n \n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"           \"=r\")\n         (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rM\")\n                   (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"sub\\\\t%0, %z1, %2\"\n-  [(set_attr \"type\" \"alu\")])\n+  \"sub%.\\\\t%0, %z1, %2\"\n+  [(set_attr \"type\" \"sub\")])\n \n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n@@ -422,32 +474,47 @@\n   [(set (match_operand:SI 0 \"register_operand\"        \"=r\")\n         (neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"sub\\\\t%0, zero, %1\"\n-  [(set_attr \"type\" \"alu\")])\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \"neg.n\\\\t%0, %1\";\n+  else\n+    return \"sub\\\\t%0, zero, %1\";\n+}\n+  [(set_attr \"type\" \"neg\")])\n \n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\"        \"=r\")\n         (not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"nor\\\\t%0, zero, %1\"\n-  [(set_attr \"type\" \"alu\")])\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \"not.n\\\\t%0, %1\";\n+  else\n+    return \"nor\\\\t%0, zero, %1\";\n+}\n+  [(set_attr \"type\" \"not\")])\n \n \f\n ;;  Integer logical Operations\n \n-(define_code_iterator LOGICAL [and ior xor])\n-(define_code_attr logical_asm [(and \"and\") (ior \"or\") (xor \"xor\")])\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n+        (and:SI (match_operand:SI 1 \"register_operand\"  \"%r\")\n+                (match_operand:SI 2 \"and_operand\"     \"rJKP\")))]\n+  \"\"\n+  \"and%x2%.\\\\t%0, %1, %y2\"\n+  [(set_attr \"type\" \"and\")])\n+\n+(define_code_iterator LOGICAL [ior xor])\n+(define_code_attr logical_asm [(ior \"or\") (xor \"xor\")])\n \n (define_insn \"<code>si3\"\n-  [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r\")\n-        (LOGICAL:SI (match_operand:SI 1 \"register_operand\" \"%r,r,r\")\n-                    (match_operand:SI 2 \"logical_operand\"  \"rM,J,K\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"             \"=r\")\n+        (LOGICAL:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+                    (match_operand:SI 2 \"logical_operand\" \"rJK\")))]\n   \"\"\n-  \"@\n-    <logical_asm>\\\\t%0, %1, %z2\n-    <logical_asm>%i2\\\\t%0, %1, %2\n-    <logical_asm>h%i2\\\\t%0, %1, %U2\"\n-  [(set_attr \"type\" \"alu\")])\n+  \"<logical_asm>%x2%.\\\\t%0, %1, %y2\"\n+  [(set_attr \"type\" \"<logical_asm>\")])\n \n (define_insn \"*norsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"                 \"=r\")\n@@ -471,16 +538,57 @@\n         (SHIFT:SI (match_operand:SI 1 \"register_operand\" \"r\")\n                   (match_operand:SI 2 \"shift_operand\"    \"rL\")))]\n   \"\"\n-  \"<shift_asm>%i2\\\\t%0, %1, %z2\"\n-  [(set_attr \"type\" \"shift\")])\n+  \"<shift_asm>%i2%.\\\\t%0, %1, %z2\"\n+  [(set_attr \"type\" \"<shift_asm>\")])\n \n (define_insn \"rotrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"             \"=r\")\n         (rotatert:SI (match_operand:SI 1 \"register_operand\" \"r\")\n                      (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"ror\\\\t%0, %1, %2\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"ror\")])\n+\n+;; Nios II R2 Bit Manipulation Extension (BMX), provides\n+;; bit merge/insertion/extraction instructions.\n+\n+(define_insn \"*merge\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\"   \"+r\")\n+\t\t\t (match_operand:SI 1 \"const_shift_operand\" \"L\")\n+\t\t\t (match_operand:SI 2 \"const_shift_operand\" \"L\"))\n+        (zero_extract:SI (match_operand:SI 3 \"register_operand\"    \"r\")\n+                         (match_dup 1) (match_dup 2)))]\n+  \"TARGET_HAS_BMX\"\n+{\n+  operands[4] = GEN_INT (INTVAL (operands[1]) + INTVAL (operands[2]) - 1);\n+  return \"merge\\\\t%0, %3, %4, %2\";\n+}\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (zero_extract:SI (match_operand:SI 1 \"register_operand\"    \"r\")\n+                         (match_operand:SI 2 \"const_shift_operand\" \"L\")\n+                         (match_operand:SI 3 \"const_shift_operand\" \"L\")))]\n+  \"TARGET_HAS_BMX\"\n+{\n+  operands[4] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[3]) - 1);\n+  return \"extract\\\\t%0, %1, %4, %3\";\n+}\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\"   \"+r\")\n+\t\t\t (match_operand:SI 1 \"const_shift_operand\" \"L\")\n+\t\t\t (match_operand:SI 2 \"const_shift_operand\" \"L\"))\n+\t(match_operand:SI 3 \"reg_or_0_operand\" \"rM\"))]\n+  \"TARGET_HAS_BMX\"\n+{\n+  operands[4] = GEN_INT (INTVAL (operands[1]) + INTVAL (operands[2]) - 1);\n+  return \"insert\\\\t%0, %z3, %4, %2\";\n+}\n+  [(set_attr \"type\" \"alu\")])\n+\n \n \f\n ;; Floating point instructions\n@@ -635,15 +743,16 @@\n   DONE;\n })\n \n-(define_insn \"return\"\n+(define_expand \"return\"\n   [(simple_return)]\n   \"nios2_can_use_return_insn ()\"\n-  \"ret\")\n+  \"\")\n \n (define_insn \"simple_return\"\n   [(simple_return)]\n   \"\"\n-  \"ret\")\n+  \"ret%.\"\n+  [(set_attr \"type\" \"control\")])\n \n ;; Block any insns from being moved before this point, since the\n ;; profiling call to mcount can use various registers that aren't\n@@ -699,27 +808,34 @@\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"c\"))]\n   \"\"\n-  \"jmp\\\\t%0\"\n+  \"jmp%!\\\\t%0\"\n   [(set_attr \"type\" \"control\")])\n \n (define_insn \"jump\"\n   [(set (pc)\n         (label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   {\n-    if (flag_pic || get_attr_length (insn) == 4)\n+    if (get_attr_length (insn) == 2)\n+      return \"br.n\\\\t%0\";\n+    else if (get_attr_length (insn) == 4)\n       return \"br\\\\t%0\";\n     else\n       return \"jmpi\\\\t%0\";\n   }\n   [(set_attr \"type\" \"control\")\n    (set (attr \"length\") \n         (if_then_else\n-\t    (and (ge (minus (match_dup 0) (pc)) (const_int -32768))\n-\t         (le (minus (match_dup 0) (pc)) (const_int 32764)))\n-\t    (const_int 4)\n-\t    (const_int 8)))])\n-\n+\t    (and (match_test \"TARGET_HAS_CDX\")\n+\t         (and (ge (minus (match_dup 0) (pc)) (const_int -1022))\n+\t              (le (minus (match_dup 0) (pc)) (const_int 1022))))\n+\t    (const_int 2)\n+\t    (if_then_else\n+\t        (ior (match_test \"flag_pic\")\n+\t             (and (ge (minus (match_dup 0) (pc)) (const_int -32764))\n+\t                  (le (minus (match_dup 0) (pc)) (const_int 32764))))\n+\t        (const_int 4)\n+\t        (const_int 8))))])\n \n (define_expand \"call\"\n   [(parallel [(call (match_operand 0 \"\" \"\")\n@@ -743,7 +859,7 @@\n   \"\"\n   \"@\n    call\\\\t%0\n-   callr\\\\t%0\"\n+   callr%.\\\\t%0\"\n   [(set_attr \"type\" \"control\")])\n \n (define_insn \"*call_value\"\n@@ -754,7 +870,7 @@\n   \"\"\n   \"@\n    call\\\\t%1\n-   callr\\\\t%1\"\n+   callr%.\\\\t%1\"\n   [(set_attr \"type\" \"control\")])\n \n (define_expand \"sibcall\"\n@@ -779,7 +895,7 @@\n   \"\"\n   \"@\n    jmpi\\\\t%0\n-   jmp\\\\t%0\"\n+   jmp%!\\\\t%0\"\n   [(set_attr \"type\" \"control\")])\n \n (define_insn \"sibcall_value_internal\"\n@@ -790,7 +906,7 @@\n   \"\"\n   \"@\n    jmpi\\\\t%1\n-   jmp\\\\t%1\"\n+   jmp%!\\\\t%1\"\n   [(set_attr \"type\" \"control\")])\n \n (define_expand \"tablejump\"\n@@ -814,7 +930,7 @@\n         (match_operand:SI 0 \"register_operand\" \"c\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"jmp\\\\t%0\"\n+  \"jmp%!\\\\t%0\"\n   [(set_attr \"type\" \"control\")])\n \n \f\n@@ -868,18 +984,30 @@\n        (label_ref (match_operand 3 \"\" \"\"))\n        (pc)))]\n   \"\"\n-  {\n-    if (flag_pic || get_attr_length (insn) == 4)\n-      return \"b%0\\t%z1, %z2, %l3\";\n-    else\n-      return \"b%R0\\t%z1, %z2, .+8;jmpi\\t%l3\";\n-  }\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \"b%0z.n\\t%z1, %l3\";\n+  else if (get_attr_length (insn) == 4)\n+    return \"b%0\\t%z1, %z2, %l3\";\n+  else if (get_attr_length (insn) == 6)\n+    return \"b%R0z.n\\t%z1, .+6;jmpi\\t%l3\";\n+  else\n+    return \"b%R0\\t%z1, %z2, .+8;jmpi\\t%l3\";\n+}\n   [(set_attr \"type\" \"control\")\n    (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 3) (pc)) (const_int -32768))\n-\t         (le (minus (match_dup 3) (pc)) (const_int 32764)))\n-\t    (const_int 4) (const_int 8)))])\n+        (cond\n+         [(and (match_test \"nios2_cdx_narrow_form_p (insn)\")\n+               (ge (minus (match_dup 3) (pc)) (const_int -126))\n+               (le (minus (match_dup 3) (pc)) (const_int 126)))\n+          (const_int 2)\n+          (ior (match_test \"flag_pic\")\n+               (and (ge (minus (match_dup 3) (pc)) (const_int -32764))\n+                    (le (minus (match_dup 3) (pc)) (const_int 32764))))\n+          (const_int 4)\n+          (match_test \"nios2_cdx_narrow_form_p (insn)\")\n+          (const_int 6)]\n+         (const_int 8)))])\n \n ;; Floating point comparisons\n (define_code_iterator FCMP [eq ne gt ge le lt])\n@@ -917,7 +1045,7 @@\n         (UCMP:SI (match_operand:SI 1 \"reg_or_0_operand\"  \"rM\")\n                  (match_operand:SI 2 \"uns_arith_operand\" \"rJ\")))]\n   \"\"\n-  \"cmp<code>%i2\\\\t%0, %z1, %z2\"\n+  \"cmp<code>%u2\\\\t%0, %z1, %z2\"\n   [(set_attr \"type\" \"alu\")])\n \n \n@@ -951,8 +1079,8 @@\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n-  \"nop\"\n-  [(set_attr \"type\" \"alu\")])\n+  \"nop%.\"\n+  [(set_attr \"type\" \"nop\")])\n \n ;; Connect 'sync' to 'memory_barrier' standard expand name\n (define_expand \"memory_barrier\"\n@@ -1000,7 +1128,7 @@\n (define_insn \"trap\"\n   [(trap_if (const_int 1) (const_int 3))]\n   \"\"\n-  \"trap\\\\t3\"\n+  \"trap%.\\\\t3\"\n   [(set_attr \"type\" \"control\")])\n \n (define_insn \"ctrapsi4\"\n@@ -1009,9 +1137,16 @@\n                (match_operand:SI 2 \"reg_or_0_operand\" \"rM\")])\n             (match_operand 3 \"const_int_operand\" \"i\"))]\n   \"\"\n-  \"b%R0\\\\t%z1, %z2, 1f\\;trap\\\\t%3\\;1:\"\n+{\n+  if (get_attr_length (insn) == 6)\n+    return \"b%R0\\\\t%z1, %z2, 1f\\;trap.n\\\\t%3\\;1:\";\n+  else\n+    return \"b%R0\\\\t%z1, %z2, 1f\\;trap\\\\t%3\\;1:\";\n+}\n   [(set_attr \"type\" \"control\")\n-   (set_attr \"length\" \"8\")])\n+   (set (attr \"length\")\n+        (if_then_else (match_test \"nios2_cdx_narrow_form_p (insn)\")\n+                      (const_int 6) (const_int 8)))])\n   \n ;; Load the GOT register.\n (define_insn \"load_got_register\""}, {"sha": "ccf3689082b005e79e1ab4bf61ff4a03a9e05d68", "filename": "gcc/config/nios2/predicates.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fconfig%2Fnios2%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fpredicates.md?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -55,6 +55,16 @@\n   (ior (match_operand 0 \"const_logical_operand\")\n        (match_operand 0 \"register_operand\")))\n \n+(define_predicate \"const_and_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_INT_UNSIGNED (INTVAL (op))\n+                    || UPPER16_INT (INTVAL (op))\n+                    || (TARGET_ARCH_R2 && ANDCLEAR_INT (INTVAL (op)))\")))\n+\n+(define_predicate \"and_operand\"\n+  (ior (match_operand 0 \"const_and_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n (define_predicate \"const_shift_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"SHIFT_INT (INTVAL (op))\")))\n@@ -84,6 +94,16 @@\n                                          false));\n })\n \n+(define_predicate \"stack_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  rtx addr = XEXP (op, 0);\n+  return ((REG_P (addr) && REGNO (addr) == SP_REGNO)\n+          || (GET_CODE (addr) == PLUS\n+              && REG_P (XEXP (addr, 0)) && REGNO (XEXP (addr, 0)) == SP_REGNO\n+              && CONST_INT_P (XEXP (addr, 1))));\n+})\n+\n (define_predicate \"ldstio_memory_operand\"\n   (match_code \"mem\")\n {"}, {"sha": "888380e9011ab7ec75d498481a520615b7a6b545", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -2991,6 +2991,9 @@ instead of @code{0} in the assembly output.\n Integer that is valid as an immediate operand for\n a custom instruction opcode. Range 0 to 255.\n \n+@item P\n+An immediate operand for R2 andchi/andci instructions. \n+\n @item S\n Matches immediates which are addresses in the small\n data section and therefore can be added to @code{gp}"}, {"sha": "d090dfc70ae65c3cd7bdd202e5a0b57484c7218c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -1,3 +1,19 @@\n+2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* gcc.target/nios2/andci.c: New.\n+\t* gcc.target/nios2/bmx.c: New.\n+\t* gcc.target/nios2/cdx-add.c: New.\n+\t* gcc.target/nios2/cdx-branch.c: New.\n+\t* gcc.target/nios2/cdx-callret.c: New.\n+\t* gcc.target/nios2/cdx-loadstore.c: New.\n+\t* gcc.target/nios2/cdx-logical.c: New.\n+\t* gcc.target/nios2/cdx-mov.c: New.\n+\t* gcc.target/nios2/cdx-shift.c: New.\n+\t* gcc.target/nios2/cdx-sub.c: New.\n+\t* gcc.target/nios2/nios2-trap-insn.c: Adjust pattern.\n+\n 2015-07-14  Andrea Azzarone  <azzaronea@gmail.com>\n \n \tPR c++/65071"}, {"sha": "98dfb2d725f59f600fd895afca6e7fc41290b116", "filename": "gcc/testsuite/gcc.target/nios2/andci.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fandci.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fandci.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fandci.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2\" } */\n+\n+/* Test generation of Nios II R2 \"andci\" and \"andchi\" instructions.  */\n+\n+unsigned int f (unsigned int a)\n+{\n+  return a & 0xfffffff0;\n+}\n+\n+unsigned int g (unsigned int b)\n+{\n+  return b & 0xfff0ffff;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tandci\\t.*\" } }  */\n+/* { dg-final { scan-assembler \"\\tandchi\\t.*\" } }  */\n+"}, {"sha": "9daa60635726455c52877dd2db5c5967deadd6ac", "filename": "gcc/testsuite/gcc.target/nios2/bmx.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fbmx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fbmx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fbmx.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mbmx\" } */\n+\n+/* Test generation of Nios II R2 BMX instructions.  */\n+\n+struct s {\n+  unsigned int pad1 : 3;\n+  unsigned int bitfield : 20;\n+  unsigned int intfield;\n+};\n+\n+void f (struct s *a, struct s *b)\n+{\n+  a->bitfield = b->bitfield;\n+}\n+\n+void g (struct s *a, struct s *b)\n+{\n+  a->bitfield = b->intfield;\n+}\n+\n+void h (struct s *a, struct s *b)\n+{\n+  a->intfield = b->bitfield;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tmerge\\t.*, 22, 3\" } }  */\n+/* { dg-final { scan-assembler \"\\tinsert\\t.*, 22, 3\" } }  */\n+/* { dg-final { scan-assembler \"\\textract\\t.*, 22, 3\" } }  */"}, {"sha": "32f1986e768a58e040a0b1fe0692439c69a534fb", "filename": "gcc/testsuite/gcc.target/nios2/cdx-add.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-add.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX add.n and addi.n instructions.  */\n+\n+int f (int a, int b)\n+{\n+  return a + b;\n+}\n+\n+int g (int a)\n+{\n+  return a + 32;\n+}\n+\n+int h (int a)\n+{\n+  return a + 33;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tadd\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\taddi\\\\.n\\t.*, 32\" } } */\n+/* { dg-final { scan-assembler \"\\taddi\\t.*, 33\" } } */\n+"}, {"sha": "3b984f2712ac7e2252be0ee050600f99c242fe13", "filename": "gcc/testsuite/gcc.target/nios2/cdx-branch.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-branch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-branch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-branch.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX br.n, beqz.n, bnez.n instructions.  */\n+\n+int f (int a, int b, int c)\n+{\n+  if (a == 0)\n+    return b;\n+  else\n+    return c;\n+}\n+\n+int g (int a, int b, int c)\n+{\n+  if (a != 0)\n+    return b;\n+  else\n+    return c;\n+}\n+\n+extern int i (int);\n+extern int j (int);\n+extern int k (int);\n+\n+int h (int a)\n+{\n+  int x;\n+\n+  /* As well as the conditional branch for the \"if\", there has to be\n+     an unconditional branch from one branch of the \"if\" to\n+     the return statement.  We compile this testcase with -Os to\n+     avoid insertion of a duplicate epilogue in place of the branch.  */\n+  if (a == 1)\n+    x = i (37);\n+  else\n+    x = j (42);\n+  return x + a + k (x);\n+}\n+\n+/* { dg-final { scan-assembler \"\\tbeqz\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\tbnez\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\tbeq\\t|\\tbne\\t\" } } */\n+/* { dg-final { scan-assembler \"\\tbr\\\\.n\\t.*\" } } */"}, {"sha": "239ec6e943e7b925d221b3a2ca6b27d85db42267", "filename": "gcc/testsuite/gcc.target/nios2/cdx-callret.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-callret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-callret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-callret.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX callr.n, jmpr.n, ret.n instructions.  */\n+\n+typedef int (*F) (void);\n+\n+int x (F f)\n+{\n+  f ();\n+\n+  /* Note that the compiler might generate a return via pop.n or ldwm;\n+     the test below is to make sure that it doesn't generate a 32-bit\n+     return instruction.  */\n+  return 3;\n+}\n+\n+int y (F f)\n+{\n+  return f ();\n+}\n+\n+/* { dg-final { scan-assembler \"\\tcallr\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler-not \"\\tret$\" } } */\n+/* { dg-final { scan-assembler \"\\tjmpr\\\\.n\\t.*\" } } */"}, {"sha": "f6a67b9df3e80abde819f4f462905c11f43a0ebe", "filename": "gcc/testsuite/gcc.target/nios2/cdx-loadstore.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-loadstore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-loadstore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-loadstore.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX load/store instructions.  */\n+\n+unsigned char ldb (unsigned char *p)\n+{\n+  return p[7];\n+}\n+\n+unsigned short ldh (unsigned short *p)\n+{\n+  return p[7];\n+}\n+\n+unsigned int ldw (unsigned int *p)\n+{\n+  return p[7];\n+}\n+\n+void stb (unsigned char *p, unsigned char x)\n+{\n+  p[15] = x;\n+}\n+\n+void sth (unsigned short *p, unsigned short x)\n+{\n+  p[15] = x;\n+}\n+\n+void stw (unsigned int *p, unsigned int x)\n+{\n+  p[15] = x;\n+}\n+\n+void no_cdx_stb (unsigned char *p, unsigned char x)\n+{\n+  p[16] = x;\n+}\n+\n+void no_cdx_sth (unsigned short *p, unsigned short x)\n+{\n+  p[16] = x;\n+}\n+\n+void no_cdx_stw (unsigned int *p, unsigned int x)\n+{\n+  p[16] = x;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tldbu\\\\.n\\t.*, 7\\\\(.*\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tldhu\\\\.n\\t.*, 14\\\\(.*\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tldw\\\\.n\\t.*, 28\\\\(.*\\\\)\" } } */\n+\n+/* { dg-final { scan-assembler \"\\tstb\\\\.n\\t.*, 15\\\\(.*\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tsth\\\\.n\\t.*, 30\\\\(.*\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tstw\\\\.n\\t.*, 60\\\\(.*\\\\)\" } } */\n+\n+/* { dg-final { scan-assembler \"\\tstb\\t.*, 16\\\\(.*\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tsth\\t.*, 32\\\\(.*\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tstw\\t.*, 64\\\\(.*\\\\)\" } } */"}, {"sha": "bf3819a819da164f770416ae9ce2605505e4f4f2", "filename": "gcc/testsuite/gcc.target/nios2/cdx-logical.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-logical.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-logical.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-logical.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX and.n, andi.n, or.n, xor.n, and not.n\n+   instructions.\n+\n+   and.n, or.n, and x.n require one of the input registers to be the same\n+   as the output register.  Since the tests below want to put the result\n+   in the return value register, they use this function to make sure that\n+   one of the input operands is also already in the return register.  */\n+\n+extern unsigned int x (unsigned int a);\n+\n+unsigned int f (unsigned int a, unsigned int b)\n+{\n+  return x (a) & b;\n+}\n+\n+unsigned int g (unsigned int a)\n+{\n+  return a & 31;\n+}\n+\n+unsigned int h (unsigned int a, unsigned int b)\n+{\n+  return x (a) | b;\n+}\n+\n+unsigned int i (unsigned int a, unsigned int b)\n+{\n+  return x (a) ^ b;\n+}\n+\n+unsigned int j (unsigned int a)\n+{\n+  return ~a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tand\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\tandi\\\\.n\\t.*, 31\" } } */\n+/* { dg-final { scan-assembler \"\\tor\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\txor\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\tnot\\\\.n\\t.*\" } } */"}, {"sha": "000b38bb6264b4fb56c70a855d31f5da7ce09fa3", "filename": "gcc/testsuite/gcc.target/nios2/cdx-mov.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-mov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-mov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-mov.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX mov.n and movi.n instructions.  */\n+\n+extern void f (int a, int b, int c, int d);\n+\n+int g (int x, int y, int z)\n+{\n+  f (100, x, y, z);\n+  return -1;\n+}\n+\n+/* We should always get mov.n and never mov when compiling with -mcdx.  */\n+/* { dg-final { scan-assembler \"\\tmov\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmov\\t.*\" } } */\n+\n+/* Both of the constant loads are expressible with movi.n.  */\n+/* { dg-final { scan-assembler \"\\tmovi\\\\.n\\t.*, 100\" } } */\n+/* { dg-final { scan-assembler \"\\tmovi\\\\.n\\t.*, -1\" } } */"}, {"sha": "25bf959863ad9e5126c5a7c0cfa6357e4c3a5a6e", "filename": "gcc/testsuite/gcc.target/nios2/cdx-shift.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-shift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-shift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-shift.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX and.n, andi.n, or.n, xor.n, and not.n\n+   instructions.  */\n+\n+extern unsigned int x (unsigned int a);\n+\n+unsigned int f (unsigned int a, unsigned int b)\n+{\n+  return x (a) << b;\n+}\n+\n+unsigned int g (unsigned int a)\n+{\n+  return x (a) << 24;\n+}\n+\n+unsigned int h (unsigned int a, unsigned int b)\n+{\n+  return x (a) >> b;\n+}\n+\n+unsigned int i (unsigned int a, unsigned int b)\n+{\n+  return x (a) >> 24;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tsll\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\tslli\\\\.n\\t.*, 24\" } } */\n+/* { dg-final { scan-assembler \"\\tsrl\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\tsrli\\\\.n\\t.*, 24\" } } */"}, {"sha": "532a0f40e89bdc72f1d99ae352eb3a59dd1f023f", "filename": "gcc/testsuite/gcc.target/nios2/cdx-sub.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-sub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-sub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-sub.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=r2 -mcdx\" } */\n+\n+/* Check generation of R2 CDX sub.n, subi.n, and neg.n instructions.  */\n+\n+int f (int a, int b)\n+{\n+  return a - b;\n+}\n+\n+int g (int a)\n+{\n+  return a - 32;\n+}\n+\n+int h (int a)\n+{\n+  return -a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tsub\\\\.n\\t.*\" } } */\n+/* { dg-final { scan-assembler \"\\tsubi\\\\.n\\t.*, 32\" } } */\n+/* { dg-final { scan-assembler \"\\tneg\\\\.n\\t.*\" } } */"}, {"sha": "588a7f38749385a87474cf04de99ca81c42bc94c", "filename": "gcc/testsuite/gcc.target/nios2/nios2-trap-insn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fnios2-trap-insn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbbe009de4f810f7240eae51e45d861582ecf79/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fnios2-trap-insn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fnios2-trap-insn.c?ref=3bbbe009de4f810f7240eae51e45d861582ecf79", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-final { scan-assembler \"trap\\\\t3\" } } */\n+/* { dg-final { scan-assembler \"trap\\\\t3|trap.n\\\\t3\" } } */\n \n /* Test the nios2 trap instruction */\n void foo(void){"}]}