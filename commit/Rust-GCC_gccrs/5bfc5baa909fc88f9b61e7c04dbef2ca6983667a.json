{"sha": "5bfc5baa909fc88f9b61e7c04dbef2ca6983667a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJmYzViYWE5MDlmYzg4ZjliNjFlN2MwNGRiZWYyY2E2OTgzNjY3YQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2010-09-02T14:46:35Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2010-09-02T14:46:35Z"}, "message": "neon.md (UNSPEC_VCLE, [...]): New constants for unspecs.\n\n\tgcc/\n\t* config/arm/neon.md (UNSPEC_VCLE, UNSPEC_VCLT): New constants for\n\tunspecs.\n\t(vcond<mode>, vcondu<mode>): New expanders.\n\t(neon_vceq<mode>, neon_vcge<mode>, neon_vcgt<mode>): Support\n\tcomparisons with zero.\n\t(neon_vcle<mode>, neon_vclt<mode>): New patterns.\n\t* config/arm/constraints.md (Dz): New constraint.\n\nFrom-SVN: r163780", "tree": {"sha": "b5f23201b3527c1a02866d2ac395d9b51928587e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5f23201b3527c1a02866d2ac395d9b51928587e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07b8f0a812a056b69fcaf00bde67aa74b5b02397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b8f0a812a056b69fcaf00bde67aa74b5b02397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b8f0a812a056b69fcaf00bde67aa74b5b02397"}], "stats": {"total": 267, "additions": 247, "deletions": 20}, "files": [{"sha": "83746347fc287d9954569ec69ae5f770e8b4bcf0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5bfc5baa909fc88f9b61e7c04dbef2ca6983667a", "patch": "@@ -1,3 +1,13 @@\n+2010-09-02  Julian Brown  <julian@codesourcery.com>\n+\n+\t* config/arm/neon.md (UNSPEC_VCLE, UNSPEC_VCLT): New constants for\n+\tunspecs.\n+\t(vcond<mode>, vcondu<mode>): New expanders.\n+\t(neon_vceq<mode>, neon_vcge<mode>, neon_vcgt<mode>): Support\n+\tcomparisons with zero.\n+\t(neon_vcle<mode>, neon_vclt<mode>): New patterns.\n+\t* config/arm/constraints.md (Dz): New constraint.\n+\n 2010-09-02  Anatoly Sokolov  <aesok@post.ru>\n \n \t* target.def (class_likely_spilled_p): New hook."}, {"sha": "41a0663797532ba05b348dc4d2691bfa2289bca3", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=5bfc5baa909fc88f9b61e7c04dbef2ca6983667a", "patch": "@@ -29,7 +29,7 @@\n ;; in Thumb-1 state: I, J, K, L, M, N, O\n \n ;; The following multi-letter normal constraints have been used:\n-;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy, Di\n+;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy, Di, Dz\n ;; in Thumb-1 state: Pa, Pb, Pc, Pd\n ;; in Thumb-2 state: Ps, Pt, Pu, Pv, Pw, Px\n \n@@ -199,6 +199,12 @@\n  (and (match_code \"const_double\")\n       (match_test \"TARGET_32BIT && neg_const_double_rtx_ok_for_fpa (op)\")))\n \n+(define_constraint \"Dz\"\n+ \"@internal\n+  In ARM/Thumb-2 state a vector of constant zeros.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"TARGET_NEON && op == CONST0_RTX (mode)\")))\n+\n (define_constraint \"Da\"\n  \"@internal\n   In ARM/Thumb-2 state a const_int, const_double or const_vector that can"}, {"sha": "8e8fc01961b293aaeb221baa2d444fcf87eff441", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 230, "deletions": 19, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfc5baa909fc88f9b61e7c04dbef2ca6983667a/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=5bfc5baa909fc88f9b61e7c04dbef2ca6983667a", "patch": "@@ -140,7 +140,9 @@\n    (UNSPEC_VUZP1\t\t201)\n    (UNSPEC_VUZP2\t\t202)\n    (UNSPEC_VZIP1\t\t203)\n-   (UNSPEC_VZIP2\t\t204)])\n+   (UNSPEC_VZIP2\t\t204)\n+   (UNSPEC_VCLE\t\t\t206)\n+   (UNSPEC_VCLT\t\t\t207)])\n \n \n ;; Attribute used to permit string comparisons against <VQH_mnem> in\n@@ -1452,6 +1454,169 @@\n   [(set_attr \"neon_type\" \"neon_int_5\")]\n )\n \n+;; Conditional instructions.  These are comparisons with conditional moves for\n+;; vectors.  They perform the assignment:\n+;;   \n+;;     Vop0 = (Vop4 <op3> Vop5) ? Vop1 : Vop2;\n+;;\n+;; where op3 is <, <=, ==, !=, >= or >.  Operations are performed\n+;; element-wise.\n+\n+(define_expand \"vcond<mode>\"\n+  [(set (match_operand:VDQW 0 \"s_register_operand\" \"\")\n+\t(if_then_else:VDQW\n+\t  (match_operator 3 \"arm_comparison_operator\"\n+\t    [(match_operand:VDQW 4 \"s_register_operand\" \"\")\n+\t     (match_operand:VDQW 5 \"nonmemory_operand\" \"\")])\n+\t  (match_operand:VDQW 1 \"s_register_operand\" \"\")\n+\t  (match_operand:VDQW 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  rtx mask;\n+  int inverse = 0, immediate_zero = 0;\n+  /* See the description of \"magic\" bits in the 'T' case of\n+     arm_print_operand.  */\n+  HOST_WIDE_INT magic_word = (<MODE>mode == V2SFmode || <MODE>mode == V4SFmode)\n+\t\t\t     ? 3 : 1;\n+  rtx magic_rtx = GEN_INT (magic_word);\n+  \n+  mask = gen_reg_rtx (<V_cmp_result>mode);\n+  \n+  if (operands[5] == CONST0_RTX (<MODE>mode))\n+    immediate_zero = 1;\n+  else if (!REG_P (operands[5]))\n+    operands[5] = force_reg (<MODE>mode, operands[5]);\n+  \n+  switch (GET_CODE (operands[3]))\n+    {\n+    case GE:\n+      emit_insn (gen_neon_vcge<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      magic_rtx));\n+      break;\n+    \n+    case GT:\n+      emit_insn (gen_neon_vcgt<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      magic_rtx));\n+      break;\n+    \n+    case EQ:\n+      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      magic_rtx));\n+      break;\n+    \n+    case LE:\n+      if (immediate_zero)\n+\temit_insn (gen_neon_vcle<mode> (mask, operands[4], operands[5],\n+\t\t\t\t\tmagic_rtx));\n+      else\n+\temit_insn (gen_neon_vcge<mode> (mask, operands[5], operands[4],\n+\t\t\t\t\tmagic_rtx));\n+      break;\n+    \n+    case LT:\n+      if (immediate_zero)\n+\temit_insn (gen_neon_vclt<mode> (mask, operands[4], operands[5],\n+\t\t\t\t\tmagic_rtx));\n+      else\n+\temit_insn (gen_neon_vcgt<mode> (mask, operands[5], operands[4],\n+\t\t\t\t\tmagic_rtx));\n+      break;\n+    \n+    case NE:\n+      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      magic_rtx));\n+      inverse = 1;\n+      break;\n+    \n+    default:\n+      gcc_unreachable ();\n+    }\n+  \n+  if (inverse)\n+    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[2],\n+\t\t\t\t    operands[1]));\n+  else\n+    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[1],\n+\t\t\t\t    operands[2]));\n+\n+  DONE;\n+})\n+\n+(define_expand \"vcondu<mode>\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"\")\n+\t(if_then_else:VDQIW\n+\t  (match_operator 3 \"arm_comparison_operator\"\n+\t    [(match_operand:VDQIW 4 \"s_register_operand\" \"\")\n+\t     (match_operand:VDQIW 5 \"s_register_operand\" \"\")])\n+\t  (match_operand:VDQIW 1 \"s_register_operand\" \"\")\n+\t  (match_operand:VDQIW 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\"\n+{\n+  rtx mask;\n+  int inverse = 0, immediate_zero = 0;\n+  \n+  mask = gen_reg_rtx (<V_cmp_result>mode);\n+  \n+  if (operands[5] == CONST0_RTX (<MODE>mode))\n+    immediate_zero = 1;\n+  else if (!REG_P (operands[5]))\n+    operands[5] = force_reg (<MODE>mode, operands[5]);\n+  \n+  switch (GET_CODE (operands[3]))\n+    {\n+    case GEU:\n+      emit_insn (gen_neon_vcge<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      const0_rtx));\n+      break;\n+    \n+    case GTU:\n+      emit_insn (gen_neon_vcgt<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      const0_rtx));\n+      break;\n+    \n+    case EQ:\n+      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      const0_rtx));\n+      break;\n+    \n+    case LEU:\n+      if (immediate_zero)\n+\temit_insn (gen_neon_vcle<mode> (mask, operands[4], operands[5],\n+\t\t\t\t\tconst0_rtx));\n+      else\n+\temit_insn (gen_neon_vcge<mode> (mask, operands[5], operands[4],\n+\t\t\t\t\tconst0_rtx));\n+      break;\n+    \n+    case LTU:\n+      if (immediate_zero)\n+        emit_insn (gen_neon_vclt<mode> (mask, operands[4], operands[5],\n+\t\t\t\t\tconst0_rtx));\n+      else\n+\temit_insn (gen_neon_vcgt<mode> (mask, operands[5], operands[4],\n+\t\t\t\t\tconst0_rtx));\n+      break;\n+    \n+    case NE:\n+      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5],\n+\t\t\t\t      const0_rtx));\n+      inverse = 1;\n+      break;\n+    \n+    default:\n+      gcc_unreachable ();\n+    }\n+  \n+  if (inverse)\n+    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[2],\n+\t\t\t\t    operands[1]));\n+  else\n+    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[1],\n+\t\t\t\t    operands[2]));\n+\n+  DONE;\n+})\n+\n ;; Patterns for builtins.\n \n ; good for plain vadd, vaddq.\n@@ -1863,13 +2028,16 @@\n )\n \n (define_insn \"neon_vceq<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result> [(match_operand:VDQW 1 \"s_register_operand\" \"w\")\n-\t\t                (match_operand:VDQW 2 \"s_register_operand\" \"w\")\n-                                (match_operand:SI 3 \"immediate_operand\" \"i\")]\n-                               UNSPEC_VCEQ))]\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n+        (unspec:<V_cmp_result>\n+\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n+\t   (match_operand:VDQW 2 \"nonmemory_operand\" \"w,Dz\")\n+\t   (match_operand:SI 3 \"immediate_operand\" \"i,i\")]\n+          UNSPEC_VCEQ))]\n   \"TARGET_NEON\"\n-  \"vceq.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  \"@\n+  vceq.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\n+  vceq.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n   [(set (attr \"neon_type\")\n       (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                     (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n@@ -1879,13 +2047,16 @@\n )\n \n (define_insn \"neon_vcge<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result> [(match_operand:VDQW 1 \"s_register_operand\" \"w\")\n-\t\t                (match_operand:VDQW 2 \"s_register_operand\" \"w\")\n-                                (match_operand:SI 3 \"immediate_operand\" \"i\")]\n-                               UNSPEC_VCGE))]\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n+        (unspec:<V_cmp_result>\n+\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n+\t   (match_operand:VDQW 2 \"nonmemory_operand\" \"w,Dz\")\n+\t   (match_operand:SI 3 \"immediate_operand\" \"i,i\")]\n+          UNSPEC_VCGE))]\n   \"TARGET_NEON\"\n-  \"vcge.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  \"@\n+  vcge.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\n+  vcge.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n@@ -1895,13 +2066,16 @@\n )\n \n (define_insn \"neon_vcgt<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result> [(match_operand:VDQW 1 \"s_register_operand\" \"w\")\n-\t\t                (match_operand:VDQW 2 \"s_register_operand\" \"w\")\n-                                (match_operand:SI 3 \"immediate_operand\" \"i\")]\n-                               UNSPEC_VCGT))]\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n+        (unspec:<V_cmp_result>\n+\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n+\t   (match_operand:VDQW 2 \"nonmemory_operand\" \"w,Dz\")\n+           (match_operand:SI 3 \"immediate_operand\" \"i,i\")]\n+          UNSPEC_VCGT))]\n   \"TARGET_NEON\"\n-  \"vcgt.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  \"@\n+  vcgt.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\n+  vcgt.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n   [(set (attr \"neon_type\")\n      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n                    (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n@@ -1910,6 +2084,43 @@\n                    (const_string \"neon_int_5\")))]\n )\n \n+;; VCLE and VCLT only support comparisons with immediate zero (register\n+;; variants are VCGE and VCGT with operands reversed).\n+\n+(define_insn \"neon_vcle<mode>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n+        (unspec:<V_cmp_result>\n+\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w\")\n+\t   (match_operand:VDQW 2 \"nonmemory_operand\" \"Dz\")\n+\t   (match_operand:SI 3 \"immediate_operand\" \"i\")]\n+          UNSPEC_VCLE))]\n+  \"TARGET_NEON\"\n+  \"vcle.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n+  [(set (attr \"neon_type\")\n+      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n+                    (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n+                                  (const_string \"neon_fp_vadd_ddd_vabs_dd\")\n+                                  (const_string \"neon_fp_vadd_qqq_vabs_qq\"))\n+                    (const_string \"neon_int_5\")))]\n+)\n+\n+(define_insn \"neon_vclt<mode>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n+        (unspec:<V_cmp_result>\n+\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w\")\n+\t   (match_operand:VDQW 2 \"nonmemory_operand\" \"Dz\")\n+\t   (match_operand:SI 3 \"immediate_operand\" \"i\")]\n+          UNSPEC_VCLT))]\n+  \"TARGET_NEON\"\n+  \"vclt.%T3%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n+  [(set (attr \"neon_type\")\n+      (if_then_else (ne (symbol_ref \"<Is_float_mode>\") (const_int 0))\n+                    (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n+                                  (const_string \"neon_fp_vadd_ddd_vabs_dd\")\n+                                  (const_string \"neon_fp_vadd_qqq_vabs_qq\"))\n+                    (const_string \"neon_int_5\")))]\n+)\n+\n (define_insn \"neon_vcage<mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n         (unspec:<V_cmp_result> [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")"}]}