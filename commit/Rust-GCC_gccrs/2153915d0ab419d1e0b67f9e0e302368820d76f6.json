{"sha": "2153915d0ab419d1e0b67f9e0e302368820d76f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE1MzkxNWQwYWI0MTlkMWUwYjY3ZjllMGUzMDIzNjg4MjBkNzZmNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-06-08T07:46:02Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-06-08T07:46:02Z"}, "message": "common.opt (fcompare-debug=, [...]): New.\n\ngcc/ChangeLog:\n* common.opt (fcompare-debug=, fcompare-debug-second): New.\n(fdump-final-insns=, gtoggle): New.\n* doc/invoke.texi: Document them.\n* final.c (rest_of_clean_state): Dump final insn stream.\n* gcc.c (invoke_as): Hook in -fcompare-debug.\n(static_spec_functions): Add compare-debug-dump-opt,\ncompare-debug-self-opt and compare-debug-auxbase-opt.\n(compare_debug, compare_debug_second, compare_debug_opt): New.\n(switches_debug_check, n_switches_debug_check): New.\n(debug_auxbase_opt, debug_check_temp_file): New.\n(process_command): Handle -fno-compare-debug, -fcompare-debug and\n-fcompare-debug=*.\n(do_self_spec): Handle arguments after switches.\n(do_spec_1): Add .gk extension to temp file basenames for compare.\n(check_live_switch): Take SWITCH_IGNORE into account, and earlier.\n(cc1_options): Use it instead of normal auxbase computation for\nthe second compare-debug compilation.\n(compare_files): New.\n(main): Set up and implement compare debug mode.\n(compare_debug_dump_opt_spec_function): New.\n(compare_debug_self_opt_spec_function): New.\n(compare_debug_auxbase_opt_spec_function): New.\n* toplev.c (process_options): Handle flag_gtoggle,\nflag_dump_final_insns.\n* coverage.c (coverage_begin_output): Don't overwrite .gcno file\nduring -fcompare-debug-second compilation.\ngcc/cp/ChangeLog:\n* repo.c (get_base_filename): Use aux_base_name rather than\nalternate temporary file during second compare debug compilation.\n(finish_repo): Skip during -fcompare-debug-second.\ngcc/ada/ChangeLog:\n* lib-writ.adb (flag_compare_debug): Import.\n(Write_ALI): Skip during -fcompare-debug-second.\ngcc/fortran/ChangeLog:\n* options.c (gfc_post_options): Disable dump_parse_tree\nduring -fcompare-debug-second.\ngcc/objc/ChangeLog:\n* objc-act.c (objc_init): Skip print_struct_values during\n-fcompare-debug-second.\n\nFrom-SVN: r148271", "tree": {"sha": "4b2c9076dc8fb9da65d110bb248b0fd2c5b7f0bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b2c9076dc8fb9da65d110bb248b0fd2c5b7f0bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2153915d0ab419d1e0b67f9e0e302368820d76f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2153915d0ab419d1e0b67f9e0e302368820d76f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2153915d0ab419d1e0b67f9e0e302368820d76f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2153915d0ab419d1e0b67f9e0e302368820d76f6/comments", "author": null, "committer": null, "parents": [{"sha": "cdb884681d2b2f835e4457d84648b82d55e71262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb884681d2b2f835e4457d84648b82d55e71262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb884681d2b2f835e4457d84648b82d55e71262"}], "stats": {"total": 766, "additions": 741, "deletions": 25}, "files": [{"sha": "da9ddd720c4deb0d5ee467f34c48a2d3fce86359", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -1,3 +1,32 @@\n+2009-06-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* common.opt (fcompare-debug=, fcompare-debug-second): New.\n+\t(fdump-final-insns=, gtoggle): New.\n+\t* doc/invoke.texi: Document them.\n+\t* final.c (rest_of_clean_state): Dump final insn stream.\n+\t* gcc.c (invoke_as): Hook in -fcompare-debug.\n+\t(static_spec_functions): Add compare-debug-dump-opt,\n+\tcompare-debug-self-opt and compare-debug-auxbase-opt.\n+\t(compare_debug, compare_debug_second, compare_debug_opt): New.\n+\t(switches_debug_check, n_switches_debug_check): New.\n+\t(debug_auxbase_opt, debug_check_temp_file): New.\n+\t(process_command): Handle -fno-compare-debug, -fcompare-debug and\n+\t-fcompare-debug=*.\n+\t(do_self_spec): Handle arguments after switches.\n+\t(do_spec_1): Add .gk extension to temp file basenames for compare.\n+\t(check_live_switch): Take SWITCH_IGNORE into account, and earlier.\n+\t(cc1_options): Use it instead of normal auxbase computation for\n+\tthe second compare-debug compilation.\n+\t(compare_files): New.\n+\t(main): Set up and implement compare debug mode.\n+\t(compare_debug_dump_opt_spec_function): New.\n+\t(compare_debug_self_opt_spec_function): New.\n+\t(compare_debug_auxbase_opt_spec_function): New.\n+\t* toplev.c (process_options): Handle flag_gtoggle,\n+\tflag_dump_final_insns.\n+\t* coverage.c (coverage_begin_output): Don't overwrite .gcno file\n+\tduring -fcompare-debug-second compilation.\n+\n 2009-06-07  Ian Lance Taylor  <iant@google.com>\n \n \t* dwarf2.h (enum dwarf_location_atom): Add"}, {"sha": "f6ca7d7d0ec645ed7a206d720ddf3c0e38e56fee", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -1,3 +1,8 @@\n+2009-06-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* lib-writ.adb (flag_compare_debug): Import.\n+\t(Write_ALI): Skip during -fcompare-debug-second.\n+\n 2009-06-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: When"}, {"sha": "f248c05cedc1cf2fbbca0c38512d1d49cc723e44", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -197,6 +197,10 @@ package body Lib.Writ is\n       Num_Sdep : Nat := 0;\n       --  Number of active entries in Sdep_Table\n \n+      flag_compare_debug : Int;\n+      pragma Import (C, flag_compare_debug);\n+      --  Import from toplev.c\n+\n       -----------------------\n       -- Local Subprograms --\n       -----------------------\n@@ -800,7 +804,9 @@ package body Lib.Writ is\n       --  We never write an ALI file if the original operating mode was\n       --  syntax-only (-gnats switch used in compiler invocation line)\n \n-      if Original_Operating_Mode = Check_Syntax then\n+      if Original_Operating_Mode = Check_Syntax\n+        or flag_compare_debug /= 0\n+      then\n          return;\n       end if;\n "}, {"sha": "f7248907e1a9c48a6172448b0100409d0bbc5a11", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -384,6 +384,14 @@ fconserve-stack\n Common Var(flag_conserve_stack) Optimization\n Do not perform optimizations increasing noticeably stack usage\n \n+fcompare-debug=\n+Common JoinedOrMissing RejectNegative Var(flag_compare_debug_opt)\n+-fcompare-debug[=<opts>] Compile with and without e.g. -gtoggle, and compare the final-insns dump\n+\n+fcompare-debug-second\n+Common RejectNegative Var(flag_compare_debug)\n+Run only the second compilation of -fcompare-debug\n+\n fcprop-registers\n Common Report Var(flag_cprop_registers) Optimization\n Perform a register copy-propagation optimization pass\n@@ -450,6 +458,10 @@ fdump-\n Common Joined RejectNegative\n -fdump-<type>\tDump various compiler internals to a file\n \n+fdump-final-insns=\n+Common RejectNegative Joined Var(flag_dump_final_insns)\n+-fdump-final-insns=filename\tDump to filename the insns at the end of translation\n+\n fdump-noaddr\n Common Report Var(flag_dump_noaddr)\n Suppress output of addresses in debugging dumps\n@@ -1417,6 +1429,10 @@ gstabs+\n Common JoinedOrMissing Negative(gvms)\n Generate debug information in extended STABS format\n \n+gtoggle\n+Common Report Var(flag_gtoggle)\n+Toggle debug information generation\n+\n gvms\n Common JoinedOrMissing Negative(gxcoff)\n Generate debug information in VMS format"}, {"sha": "47bc71e4df1ec63fd9ede5ebc0ef591e7887dae0", "filename": "gcc/coverage.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -554,7 +554,7 @@ coverage_begin_output (void)\n {\n   /* We don't need to output .gcno file unless we're under -ftest-coverage\n      (e.g. -fprofile-arcs/generate/use don't need .gcno to work). */\n-  if (no_coverage || !flag_test_coverage)\n+  if (no_coverage || !flag_test_coverage || flag_compare_debug)\n     return 0;\n \n   if (!bbg_function_announced)"}, {"sha": "12020e84bea0cc63f6c37818659f49c1abdc449d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -1,3 +1,9 @@\n+2009-06-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* repo.c (get_base_filename): Use aux_base_name rather than\n+\talternate temporary file during second compare debug compilation.\n+\t(finish_repo): Skip during -fcompare-debug-second.\n+\n 2009-06-06  Ian Lance Taylor  <iant@google.com>\n \n \t* parser.c (cp_parser_label_for_labeled_statement): Support"}, {"sha": "0f531e2627cb410cc90a7aec286ca2ccd51fa7d2", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -90,15 +90,23 @@ static const char *\n get_base_filename (const char *filename)\n {\n   char *p = getenv (\"COLLECT_GCC_OPTIONS\");\n-  char *output = NULL;\n+  const char *output = NULL;\n   int compiling = 0;\n \n   while (p && *p)\n     {\n       char *q = extract_string (&p);\n \n       if (strcmp (q, \"-o\") == 0)\n-\toutput = extract_string (&p);\n+\t{\n+\t  if (flag_compare_debug)\n+\t    /* Just in case aux_base_name was based on a name with two\n+\t       or more '.'s, add an arbitrary extension that will be\n+\t       stripped by the caller.  */\n+\t    output = concat (aux_base_name, \".o\", NULL);\n+\t  else\n+\t    output = extract_string (&p);\n+\t}\n       else if (strcmp (q, \"-c\") == 0)\n \tcompiling = 1;\n     }\n@@ -231,7 +239,7 @@ finish_repo (void)\n   char *dir, *args;\n   FILE *repo_file;\n \n-  if (!flag_use_repository)\n+  if (!flag_use_repository || flag_compare_debug)\n     return;\n \n   if (errorcount || sorrycount)"}, {"sha": "99aa2caeb175913bc7bb082170303855f598d1ad", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -302,13 +302,15 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-vrp@r{[}-@var{n}@r{]} @gol\n -ftree-vectorizer-verbose=@var{n} @gol\n -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol\n+-fdump-final-insns=@var{file} @gol\n+-fcompare-debug@r{[}=@var{opts}@r{]}  -fcompare-debug-second @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n -feliminate-unused-debug-symbols -femit-class-debug-always @gol\n -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol\n -ftest-coverage  -ftime-report -fvar-tracking @gol\n--g  -g@var{level}  -gcoff -gdwarf-2 @gol\n+-g  -g@var{level}  -gtoggle  -gcoff  -gdwarf-2 @gol\n -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol\n -fno-merge-debug-strings -fno-dwarf2-cfi-asm @gol\n -fdebug-prefix-map=@var{old}=@var{new} @gol\n@@ -4384,6 +4386,61 @@ debug format is long obsolete, but the option cannot be changed now.\n Instead use an additional @option{-g@var{level}} option to change the\n debug level for DWARF2.\n \n+@item -gtoggle\n+@opindex gtoggle\n+Turn off generation of debug info, if leaving out this option would have\n+generated it, or turn it on at level 2 otherwise.  The position of this\n+argument in the command line does not matter, it takes effect after all\n+other options are processed, and it does so only once, no matter how\n+many times it is given.  This is mainly intended to be used with\n+@option{-fcompare-debug}.\n+\n+@item -fdump-final-insns=@var{file}\n+@opindex fdump-final-insns=\n+Dump the final internal representation (RTL) to @var{file}.\n+\n+@item -fcompare-debug@r{[}=@var{opts}@r{]}\n+@opindex fcompare-debug\n+@opindex fno-compare-debug\n+If no error occurs during compilation, run the compiler a second time,\n+adding @var{opts} and @option{-fcompare-debug-second} to the arguments\n+passed to the second compilation.  Dump the final internal\n+representation in both compilations, and print an error if they differ.\n+\n+If the equal sign is omitted, the default @option{-gtoggle} is used.\n+\n+The environment variable @env{GCC_COMPARE_DEBUG}, if defined, non-empty\n+and nonzero, implicitly enables @option{-fcompare-debug}.  If\n+@env{GCC_COMPARE_DEBUG} is defined to a string starting with a dash,\n+then it is used for @var{opts}, otherwise the default @option{-gtoggle}\n+is used.\n+\n+@option{-fcompare-debug=}, with the equal sign but without @var{opts},\n+is equivalent to @option{-fno-compare-debug}, which disables the dumping\n+of the final representation and the second compilation, preventing even\n+@env{GCC_COMPARE_DEBUG} from taking effect.\n+\n+To verify full coverage during @option{-fcompare-debug} testing, set\n+@env{GCC_COMPARE_DEBUG} to say @samp{-fcompare-debug-not-overridden},\n+which GCC will reject as an invalid option in any actual compilation\n+(rather than preprocessing, assembly or linking).  To get just a\n+warning, setting @env{GCC_COMPARE_DEBUG} to @samp{-w%n-fcompare-debug\n+not overridden} will do.\n+\n+@item -fcompare-debug-second\n+@opindex fcompare-debug-second\n+This option is implicitly passed to the compiler for the second\n+compilation requested by @option{-fcompare-debug}, along with options to\n+silence warnings, and omitting other options that would cause\n+side-effect compiler outputs to files or to the standard output.  Dump\n+files and preserved temporary files are renamed so as to contain the\n+@code{.gk} additional extension during the second compilation, to avoid\n+overwriting those generated by the first.\n+\n+When this option is passed to the compiler driver, it causes the\n+@emph{first} compilation to be skipped, which makes it useful for little\n+other than debugging the compiler proper.\n+\n @item -feliminate-dwarf2-dups\n @opindex feliminate-dwarf2-dups\n Compress DWARF2 debugging information by eliminating duplicated"}, {"sha": "b113bc90a39a8b9516971c9ba78d8bdd4875d0f4", "filename": "gcc/final.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -4313,6 +4313,41 @@ static unsigned int\n rest_of_clean_state (void)\n {\n   rtx insn, next;\n+  FILE *final_output = NULL;\n+  int save_unnumbered = flag_dump_unnumbered;\n+  int save_noaddr = flag_dump_noaddr;\n+\n+  if (flag_dump_final_insns)\n+    {\n+      final_output = fopen (flag_dump_final_insns, \"a\");\n+      if (!final_output)\n+\t{\n+\t  error (\"could not open final insn dump file %qs: %s\",\n+\t\t flag_dump_final_insns, strerror (errno));\n+\t  flag_dump_final_insns = NULL;\n+\t}\n+      else\n+\t{\n+\t  const char *aname;\n+\n+\t  aname = (IDENTIFIER_POINTER\n+\t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n+\t  fprintf (final_output, \"\\n;; Function (%s) %s\\n\\n\", aname,\n+\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n+\t     ? \" (hot)\"\n+\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n+\t     ? \" (unlikely executed)\"\n+\t     : \"\");\n+\n+\t  flag_dump_noaddr = flag_dump_unnumbered = 1;\n+\n+\t  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t    if (LABEL_P (insn))\n+\t      INSN_UID (insn) = CODE_LABEL_NUMBER (insn);\n+\t    else\n+\t      INSN_UID (insn) = 0;\n+\t}\n+    }\n \n   /* It is very important to decompose the RTL instruction chain here:\n      debug information keeps pointing into CODE_LABEL insns inside the function\n@@ -4323,6 +4358,27 @@ rest_of_clean_state (void)\n       next = NEXT_INSN (insn);\n       NEXT_INSN (insn) = NULL;\n       PREV_INSN (insn) = NULL;\n+\n+      if (final_output\n+\t  && (!NOTE_P (insn) ||\n+\t      (NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION\n+\t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_BEG\n+\t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_END)))\n+\tprint_rtl_single (final_output, insn);\n+\n+    }\n+\n+  if (final_output)\n+    {\n+      flag_dump_noaddr = save_noaddr;\n+      flag_dump_unnumbered = save_unnumbered;\n+\n+      if (fclose (final_output))\n+\t{\n+\t  error (\"could not close final insn dump file %qs: %s\",\n+\t\t flag_dump_final_insns, strerror (errno));\n+\t  flag_dump_final_insns = NULL;\n+\t}\n     }\n \n   /* In case the function was not output,"}, {"sha": "c8515fc4cd753cc3395fbcc8ca2ef8859d2f01de", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -1,3 +1,8 @@\n+2009-06-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* options.c (gfc_post_options): Disable dump_parse_tree\n+\tduring -fcompare-debug-second.\n+\n 2009-06-07  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/40008"}, {"sha": "3654e9261a1647963d9526281c68446bb39385c9", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -246,6 +246,9 @@ gfc_post_options (const char **pfilename)\n   if (flag_bounds_check)\n     gfc_option.rtcheck |= GFC_RTCHECK_BOUNDS;\n \n+  if (flag_compare_debug)\n+    gfc_option.dump_parse_tree = 0;\n+\n   /* Verify the input file name.  */\n   if (!filename || strcmp (filename, \"-\") == 0)\n     {"}, {"sha": "d652530b6a19de112b5fef4b10a886e3c01b7018", "filename": "gcc/gcc.c", "status": "modified", "additions": 513, "deletions": 18, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -84,6 +84,18 @@ compilation is specified by a string called a \"spec\".  */\n #include \"flags.h\"\n #include \"opts.h\"\n \n+#ifdef HAVE_MMAP_FILE\n+# include <sys/mman.h>\n+# ifdef HAVE_MINCORE\n+/* This is on Solaris.  */\n+#  include <sys/types.h>\n+# endif\n+#endif\n+\n+#ifndef MAP_FAILED\n+# define MAP_FAILED ((void *)-1)\n+#endif\n+\n /* By default there is no special suffix for target executables.  */\n /* FIXME: when autoconf is fixed, remove the host check - dj */\n #if defined(TARGET_EXECUTABLE_SUFFIX) && defined(HOST_EXECUTABLE_SUFFIX)\n@@ -391,6 +403,9 @@ static const char *replace_outfile_spec_function (int, const char **);\n static const char *version_compare_spec_function (int, const char **);\n static const char *include_spec_function (int, const char **);\n static const char *print_asm_header_spec_function (int, const char **);\n+static const char *compare_debug_dump_opt_spec_function (int, const char **);\n+static const char *compare_debug_self_opt_spec_function (int, const char **);\n+static const char *compare_debug_auxbase_opt_spec_function (int, const char **);\n \f\n /* The Specs Language\n \n@@ -853,7 +868,8 @@ static const char *cpp_debug_options = \"%{d*}\";\n static const char *cc1_options =\n \"%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n  %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\\\n- %{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}%{!c:%{!S:-auxbase %b}}\\\n+ %{fcompare-debug-second:%:compare-debug-auxbase-opt(%b)} \\\n+ %{!fcompare-debug-second:%{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}}%{!c:%{!S:-auxbase %b}} \\\n  %{g*} %{O*} %{W*&pedantic*} %{w} %{std*&ansi&trigraphs}\\\n  %{v:-version} %{pg:-p} %{p} %{f*} %{undef}\\\n  %{Qn:-fno-ident} %{--help:--help}\\\n@@ -875,9 +891,11 @@ static const char *asm_options =\n \n static const char *invoke_as =\n #ifdef AS_NEEDS_DASH_FOR_PIPED_INPUT\n-\"%{!S:-o %|.s |\\n as %(asm_options) %|.s %A }\";\n+\"%{fcompare-debug=*:%:compare-debug-dump-opt()}\\\n+ %{!S:-o %|.s |\\n as %(asm_options) %|.s %A }\";\n #else\n-\"%{!S:-o %|.s |\\n as %(asm_options) %m.s %A }\";\n+\"%{fcompare-debug=*:%:compare-debug-dump-opt()}\\\n+ %{!S:-o %|.s |\\n as %(asm_options) %m.s %A }\";\n #endif\n \n /* Some compilers have limits on line lengths, and the multilib_select\n@@ -1673,6 +1691,9 @@ static const struct spec_function static_spec_functions[] =\n   { \"version-compare\",\t\tversion_compare_spec_function },\n   { \"include\",\t\t\tinclude_spec_function },\n   { \"print-asm-header\",\t\tprint_asm_header_spec_function },\n+  { \"compare-debug-dump-opt\",\tcompare_debug_dump_opt_spec_function },\n+  { \"compare-debug-self-opt\",\tcompare_debug_self_opt_spec_function },\n+  { \"compare-debug-auxbase-opt\", compare_debug_auxbase_opt_spec_function },\n #ifdef EXTRA_SPEC_FUNCTIONS\n   EXTRA_SPEC_FUNCTIONS\n #endif\n@@ -3196,6 +3217,29 @@ static struct switchstr *switches;\n \n static int n_switches;\n \n+/* Set to zero if -fcompare-debug is disabled, positive if it's\n+   enabled and we're running the first compilation, negative if it's\n+   enabled and we're running the second compilation.  For most of the\n+   time, it's in the range -1..1, but it can be temporarily set to 2\n+   or 3 to indicate that the -fcompare-debug flags didn't come from\n+   the command-line, but rather from the GCC_COMPARE_DEBUG environment\n+   variable, until a synthesized -fcompare-debug flag is added to the\n+   command line.  */\n+int compare_debug;\n+\n+/* Set to nonzero if we've seen the -fcompare-debug-second flag.  */\n+int compare_debug_second;\n+\n+/* Set to the flags that should be passed to the second compilation in\n+   a -fcompare-debug compilation.  */\n+const char *compare_debug_opt;\n+\n+static struct switchstr *switches_debug_check[2];\n+\n+static int n_switches_debug_check[2];\n+\n+static char *debug_check_temp_file[2];\n+\n /* Language is one of three things:\n \n    1) The name of a real programming language.\n@@ -3790,6 +3834,38 @@ process_command (int argc, const char **argv)\n \tprint_multi_os_directory = 1;\n       else if (! strcmp (argv[i], \"-print-sysroot-headers-suffix\"))\n \tprint_sysroot_headers_suffix = 1;\n+      else if (! strcmp (argv[i], \"-fcompare-debug-second\"))\n+\t{\n+\t  compare_debug_second = 1;\n+\t  n_switches++;\n+\t}\n+      else if (! strcmp (argv[i], \"-fno-compare-debug\"))\n+\t{\n+\t  argv[i] = \"-fcompare-debug=\";\n+\t  goto compare_debug_with_arg;\n+\t}\n+      else if (! strcmp (argv[i], \"-fcompare-debug\"))\n+\t{\n+\t  argv[i] = \"-fcompare-debug=-gtoggle\";\n+\t  goto compare_debug_with_arg;\n+\t}\n+#define OPT \"-fcompare-debug=\"\n+      else if (! strncmp (argv[i], OPT, sizeof (OPT) - 1))\n+\t{\n+\t  const char *opt;\n+\tcompare_debug_with_arg:\n+\t  opt = argv[i] + sizeof (OPT) - 1;\n+#undef OPT\n+\t  if (*opt)\n+\t    compare_debug = 1;\n+\t  else\n+\t    compare_debug = -1;\n+\t  if (compare_debug < 0)\n+\t    compare_debug_opt = NULL;\n+\t  else\n+\t    compare_debug_opt = opt;\n+\t  n_switches++;\n+\t}\n       else if (! strncmp (argv[i], \"-Wa,\", 4))\n \t{\n \t  int prev, j;\n@@ -4147,6 +4223,29 @@ process_command (int argc, const char **argv)\n       use_pipes = 0;\n     }\n \n+  if (!compare_debug)\n+    {\n+      const char *gcd = getenv (\"GCC_COMPARE_DEBUG\");\n+\n+      if (gcd && gcd[0] == '-')\n+\t{\n+\t  compare_debug = 2;\n+\t  compare_debug_opt = gcd;\n+\t  n_switches++;\n+\t}\n+      else if (gcd && *gcd && strcmp (gcd, \"0\"))\n+\t{\n+\t  compare_debug = 3;\n+\t  compare_debug_opt = \"-gtoggle\";\n+\t  n_switches++;\n+\t}\n+    }\n+  else if (compare_debug < 0)\n+    {\n+      compare_debug = 0;\n+      gcc_assert (!compare_debug_opt);\n+    }\n+\n   /* Set up the search paths.  We add directories that we expect to\n      contain GNU Toolchain components before directories specified by\n      the machine description so that we will find GNU components (like\n@@ -4440,6 +4539,19 @@ process_command (int argc, const char **argv)\n   if (n_infiles == last_language_n_infiles && spec_lang != 0)\n     error (\"warning: '-x %s' after last input file has no effect\", spec_lang);\n \n+  if (compare_debug == 2 || compare_debug == 3)\n+    {\n+      switches[n_switches].part1 = concat (\"fcompare-debug=\",\n+\t\t\t\t\t   compare_debug_opt,\n+\t\t\t\t\t   NULL);\n+      switches[n_switches].args = 0;\n+      switches[n_switches].live_cond = 0;\n+      switches[n_switches].validated = 0;\n+      switches[n_switches].ordering = 0;\n+      n_switches++;\n+      compare_debug = 1;\n+    }\n+\n   /* Ensure we only invoke each subprocess once.  */\n   if (print_subprocess_help || print_help_list || print_version)\n     {\n@@ -4740,28 +4852,69 @@ do_self_spec (const char *spec)\n \n   if (argbuf_index > 0)\n     {\n-      int i, first;\n+      int i;\n \n-      first = n_switches;\n-      n_switches += argbuf_index;\n-      switches = XRESIZEVEC (struct switchstr, switches, n_switches + 1);\n+      switches = XRESIZEVEC (struct switchstr, switches,\n+\t\t\t     n_switches + argbuf_index + 1);\n \n-      switches[n_switches] = switches[first];\n       for (i = 0; i < argbuf_index; i++)\n \t{\n \t  struct switchstr *sw;\n+\t  const char *p = argbuf[i];\n+\t  int c = *p;\n \n \t  /* Each switch should start with '-'.  */\n-\t  if (argbuf[i][0] != '-')\n+\t  if (c != '-')\n \t    fatal (\"switch '%s' does not start with '-'\", argbuf[i]);\n \n-\t  sw = &switches[i + first];\n-\t  sw->part1 = &argbuf[i][1];\n-\t  sw->args = 0;\n+\t  p++;\n+\t  c = *p;\n+\n+\t  sw = &switches[n_switches++];\n+\t  sw->part1 = p;\n \t  sw->live_cond = 0;\n \t  sw->validated = 0;\n \t  sw->ordering = 0;\n+\n+\t  /* Deal with option arguments in separate argv elements.  */\n+\t  if ((SWITCH_TAKES_ARG (c) > (p[1] != 0))\n+\t      || WORD_SWITCH_TAKES_ARG (p))\n+\t    {\n+\t      int j = 0;\n+\t      int n_args = WORD_SWITCH_TAKES_ARG (p);\n+\n+\t      if (n_args == 0)\n+\t\t{\n+\t\t  /* Count only the option arguments in separate argv elements.  */\n+\t\t  n_args = SWITCH_TAKES_ARG (c) - (p[1] != 0);\n+\t\t}\n+\t      if (i + n_args >= argbuf_index)\n+\t\tfatal (\"argument to '-%s' is missing\", p);\n+\t      sw->args\n+\t\t= XNEWVEC (const char *, n_args + 1);\n+\t      while (j < n_args)\n+\t\tsw->args[j++] = argbuf[++i];\n+\t      /* Null-terminate the vector.  */\n+\t      sw->args[j] = 0;\n+\t    }\n+\t  else if (strchr (switches_need_spaces, c))\n+\t    {\n+\t      /* On some systems, ld cannot handle some options without\n+\t\t a space.  So split the option from its argument.  */\n+\t      char *part1 = XNEWVEC (char, 2);\n+\t      part1[0] = c;\n+\t      part1[1] = '\\0';\n+\n+\t      sw->part1 = part1;\n+\t      sw->args = XNEWVEC (const char *, 2);\n+\t      sw->args[0] = xstrdup (p+1);\n+\t      sw->args[1] = 0;\n+\t    }\n+\t  else\n+\t    sw->args = 0;\n \t}\n+\n+      switches[n_switches].part1 = 0;\n     }\n }\n \n@@ -4947,6 +5100,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      obstack_grow (&obstack, save_temps_prefix, save_temps_length);\n \t    else\n \t      obstack_grow (&obstack, input_basename, basename_length);\n+\t    if (compare_debug < 0)\n+\t      obstack_grow (&obstack, \".gk\", 3);\n \t    arg_going = 1;\n \t    break;\n \n@@ -4955,6 +5110,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      obstack_grow (&obstack, save_temps_prefix, save_temps_length);\n \t    else\n \t      obstack_grow (&obstack, input_basename, suffixed_basename_length);\n+\t    if (compare_debug < 0)\n+\t      obstack_grow (&obstack, \".gk\", 3);\n \t    arg_going = 1;\n \t    break;\n \n@@ -5100,6 +5257,12 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    suffix_length += strlen (TARGET_OBJECT_SUFFIX);\n \t\t  }\n \n+\t\tif (compare_debug < 0)\n+\t\t  {\n+\t\t    suffix = concat (\".gk\", suffix, NULL);\n+\t\t    suffix_length += 3;\n+\t\t  }\n+\n \t\t/* If -save-temps=obj and -o were specified, use that for the\n \t\t   temp file.  */\n \t\tif (save_temps_length)\n@@ -6190,18 +6353,19 @@ check_live_switch (int switchnum, int prefix_length)\n   const char *name = switches[switchnum].part1;\n   int i;\n \n+  /* If we already processed this switch and determined if it was\n+     live or not, return our past determination.  */\n+  if (switches[switchnum].live_cond != 0)\n+    return ((switches[switchnum].live_cond & SWITCH_LIVE) != 0\n+\t    && (switches[switchnum].live_cond & SWITCH_FALSE) == 0\n+\t    && (switches[switchnum].live_cond & SWITCH_IGNORE) == 0);\n+\n   /* In the common case of {<at-most-one-letter>*}, a negating\n      switch would always match, so ignore that case.  We will just\n      send the conflicting switches to the compiler phase.  */\n   if (prefix_length >= 0 && prefix_length <= 1)\n     return 1;\n \n-  /* If we already processed this switch and determined if it was\n-     live or not, return our past determination.  */\n-  if (switches[switchnum].live_cond != 0)\n-    return ((switches[switchnum].live_cond & SWITCH_LIVE) != 0\n-\t    && (switches[switchnum].live_cond & SWITCH_FALSE) == 0);\n-\n   /* Now search for duplicate in a manner that depends on the name.  */\n   switch (*name)\n     {\n@@ -6398,6 +6562,125 @@ fatal_error (int signum)\n   kill (getpid (), signum);\n }\n \n+/* Compare the contents of the two files named CMPFILE[0] and\n+   CMPFILE[1].  Return zero if they're identical, nonzero\n+   otherwise.  */\n+\n+static int\n+compare_files (char *cmpfile[])\n+{\n+  int ret = 0;\n+  FILE *temp[2] = { NULL, NULL };\n+  int i;\n+\n+#if HAVE_MMAP_FILE\n+  {\n+    size_t length[2];\n+    void *map[2] = { NULL, NULL };\n+\n+    for (i = 0; i < 2; i++)\n+      {\n+\tstruct stat st;\n+\n+\tif (stat (cmpfile[i], &st) < 0 || !S_ISREG (st.st_mode))\n+\t  {\n+\t    error (\"%s: could not determine length of compare-debug file %s\",\n+\t\t   input_filename, cmpfile[i]);\n+\t    ret = 1;\n+\t    break;\n+\t  }\n+\n+\tlength[i] = st.st_size;\n+      }\n+\n+    if (!ret && length[0] != length[1])\n+      {\n+\terror (\"%s: -fcompare-debug failure (length)\", input_filename);\n+\tret = 1;\n+      }\n+\n+    if (!ret)\n+      for (i = 0; i < 2; i++)\n+\t{\n+\t  int fd = open (cmpfile[i], O_RDONLY);\n+\t  if (fd < 0)\n+\t    {\n+\t      error (\"%s: could not open compare-debug file %s\",\n+\t\t     input_filename, cmpfile[i]);\n+\t      ret = 1;\n+\t      break;\n+\t    }\n+\n+\t  map[i] = mmap (NULL, length[i], PROT_READ, MAP_PRIVATE, fd, 0);\n+\t  close (fd);\n+\n+\t  if (map[i] == (void *) MAP_FAILED)\n+\t    {\n+\t      ret = -1;\n+\t      break;\n+\t    }\n+\t}\n+\n+    if (!ret)\n+      {\n+\tif (memcmp (map[0], map[1], length[0]) != 0)\n+\t  {\n+\t    error (\"%s: -fcompare-debug failure\", input_filename);\n+\t    ret = 1;\n+\t  }\n+      }\n+\n+    for (i = 0; i < 2; i++)\n+      if (map[i])\n+\tmunmap (map[i], length[i]);\n+\n+    if (ret >= 0)\n+      return ret;\n+\n+    ret = 0;\n+  }\n+#endif\n+\n+  for (i = 0; i < 2; i++)\n+    {\n+      temp[i] = fopen (cmpfile[i], \"r\");\n+      if (!temp[i])\n+\t{\n+\t  error (\"%s: could not open compare-debug file %s\",\n+\t\t input_filename, cmpfile[i]);\n+\t  ret = 1;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!ret && temp[0] && temp[1])\n+    for (;;)\n+      {\n+\tint c0, c1;\n+\tc0 = fgetc (temp[0]);\n+\tc1 = fgetc (temp[1]);\n+\n+\tif (c0 != c1)\n+\t  {\n+\t    error (\"%s: -fcompare-debug failure\",\n+\t\t   input_filename);\n+\t    ret = 1;\n+\t    break;\n+\t  }\n+\n+\tif (c0 == EOF)\n+\t  break;\n+      }\n+\n+  for (i = 1; i >= 0; i--)\n+    {\n+      if (temp[i])\n+\tfclose (temp[i]);\n+    }\n+\n+  return ret;\n+}\n+\n extern int main (int, char **);\n \n int\n@@ -6570,6 +6853,43 @@ main (int argc, char **argv)\n   for (i = 0; i < ARRAY_SIZE (driver_self_specs); i++)\n     do_self_spec (driver_self_specs[i]);\n \n+  if (compare_debug)\n+    {\n+      enum save_temps save;\n+\n+      if (!compare_debug_second)\n+\t{\n+\t  n_switches_debug_check[1] = n_switches;\n+\t  switches_debug_check[1] = XDUPVEC (struct switchstr, switches,\n+\t\t\t\t\t     n_switches + 1);\n+\n+\t  do_self_spec (\"%:compare-debug-self-opt()\");\n+\t  n_switches_debug_check[0] = n_switches;\n+\t  switches_debug_check[0] = switches;\n+\n+\t  n_switches = n_switches_debug_check[1];\n+\t  switches = switches_debug_check[1];\n+\t}\n+\n+      /* Avoid crash when computing %j in this early.  */\n+      save = save_temps_flag;\n+      save_temps_flag = SAVE_TEMPS_NONE;\n+\n+      compare_debug = -compare_debug;\n+      do_self_spec (\"%:compare-debug-self-opt()\");\n+\n+      save_temps_flag = save;\n+\n+      if (!compare_debug_second)\n+\t{\n+\t  n_switches_debug_check[1] = n_switches;\n+\t  switches_debug_check[1] = switches;\n+\t  compare_debug = -compare_debug;\n+\t  n_switches = n_switches_debug_check[0];\n+\t  switches = switches_debug_check[0];\n+\t}\n+    }\n+\n   /* If not cross-compiling, look for executables in the standard\n      places.  */\n   if (*cross_compile == '0')\n@@ -6998,10 +7318,63 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t    }\n \t  else\n \t    {\n+\t      if (compare_debug)\n+\t\t{\n+\t\t  if (debug_check_temp_file[0])\n+\t\t    free (debug_check_temp_file[0]);\n+\t\t  debug_check_temp_file[0] = NULL;\n+\n+\t\t  if (debug_check_temp_file[1])\n+\t\t    free (debug_check_temp_file[1]);\n+\t\t  debug_check_temp_file[1] = NULL;\n+\t\t}\n+\n \t      value = do_spec (input_file_compiler->spec);\n \t      infiles[i].compiled = true;\n \t      if (value < 0)\n \t\tthis_file_error = 1;\n+\t      else if (compare_debug && debug_check_temp_file[0])\n+\t\t{\n+\t\t  if (verbose_flag)\n+\t\t    error (\"Recompiling with -fcompare-debug\");\n+\n+\t\t  compare_debug = -compare_debug;\n+\t\t  n_switches = n_switches_debug_check[1];\n+\t\t  switches = switches_debug_check[1];\n+\n+\t\t  value = do_spec (input_file_compiler->spec);\n+\n+\t\t  compare_debug = -compare_debug;\n+\t\t  n_switches = n_switches_debug_check[0];\n+\t\t  switches = switches_debug_check[0];\n+\n+\t\t  if (value < 0)\n+\t\t    {\n+\t\t      error (\"during -fcompare-debug recompilation\");\n+\t\t      this_file_error = 1;\n+\t\t    }\n+\n+\t\t  gcc_assert (debug_check_temp_file[1]\n+\t\t\t      && strcmp (debug_check_temp_file[0],\n+\t\t\t\t\t debug_check_temp_file[1]));\n+\n+\t\t  if (verbose_flag)\n+\t\t    error (\"Comparing final insns dumps\");\n+\n+\t\t  if (compare_files (debug_check_temp_file))\n+\t\t    this_file_error = 1;\n+\t\t}\n+\n+\t      if (compare_debug)\n+\t\t{\n+\t\t  if (debug_check_temp_file[0])\n+\t\t    free (debug_check_temp_file[0]);\n+\t\t  debug_check_temp_file[0] = NULL;\n+\n+\t\t  if (debug_check_temp_file[1])\n+\t\t    free (debug_check_temp_file[1]);\n+\t\t  debug_check_temp_file[1] = NULL;\n+\t\t}\n \t    }\n \t}\n \n@@ -8286,3 +8659,125 @@ print_asm_header_spec_function (int arg ATTRIBUTE_UNUSED,\n   fflush (stdout);\n   return NULL;\n }\n+\n+/* %:compare-debug-dump-opt spec function.  Save the last argument,\n+   expected to be the last -fdump-final-insns option, or generate a\n+   temporary.  */\n+\n+static const char *\n+compare_debug_dump_opt_spec_function (int arg,\n+\t\t\t\t      const char **argv ATTRIBUTE_UNUSED)\n+{\n+  const char *ret;\n+  char *name;\n+  int which;\n+\n+  if (arg != 0)\n+    fatal (\"too many arguments to %%:compare-debug-dump-opt\");\n+\n+  if (!compare_debug)\n+    return NULL;\n+\n+  do_spec_2 (\"%{fdump-final-insns=*:%*}\");\n+  do_spec_1 (\" \", 0, NULL);\n+\n+  if (argbuf_index > 0)\n+    {\n+      name = xstrdup (argv[argbuf_index - 1]);\n+      ret = NULL;\n+    }\n+  else\n+    {\n+#define OPT \"-fdump-final-insns=\"\n+      ret = \"-fdump-final-insns=%g.gkd\";\n+\n+      do_spec_2 (ret + sizeof (OPT) - 1);\n+      do_spec_1 (\" \", 0, NULL);\n+#undef OPT\n+\n+      gcc_assert (argbuf_index > 0);\n+\n+      name = xstrdup (argbuf[argbuf_index - 1]);\n+    }\n+\n+  which = compare_debug < 0;\n+  debug_check_temp_file[which] = name;\n+\n+#if 0\n+  error (\"compare-debug: [%i]=\\\"%s\\\", ret %s\", which, name, ret);\n+#endif\n+\n+  return ret;\n+}\n+\n+static const char *debug_auxbase_opt;\n+\n+/* %:compare-debug-self-opt spec function.  Expands to the options\n+    that are to be passed in the second compilation of\n+    compare-debug.  */\n+\n+static const char *\n+compare_debug_self_opt_spec_function (int arg,\n+\t\t\t\t      const char **argv ATTRIBUTE_UNUSED)\n+{\n+  if (arg != 0)\n+    fatal (\"too many arguments to %%:compare-debug-self-opt\");\n+\n+  if (compare_debug >= 0)\n+    return NULL;\n+\n+  do_spec_2 (\"%{c|S:%{o*:%*}}\");\n+  do_spec_1 (\" \", 0, NULL);\n+\n+  if (argbuf_index > 0)\n+    debug_auxbase_opt = concat (\"-auxbase-strip \",\n+\t\t\t\targbuf[argbuf_index - 1],\n+\t\t\t\tNULL);\n+  else\n+    debug_auxbase_opt = NULL;\n+\n+  return concat (\"\\\n+%<o %<MD %<MMD %<MF* %<MG %<MP %<MQ* %<MT* \\\n+%<fdump-final-insns=* -w -S -o %j \\\n+%{!fcompare-debug-second:-fcompare-debug-second} \\\n+\", compare_debug_opt, NULL);\n+}\n+\n+/* %:compare-debug-auxbase-opt spec function.  Expands to the auxbase\n+    options that are to be passed in the second compilation of\n+    compare-debug.  It expects, as an argument, the basename of the\n+    current input file name, with the .gk suffix appended to it.  */\n+\n+static const char *\n+compare_debug_auxbase_opt_spec_function (int arg,\n+\t\t\t\t\t const char **argv)\n+{\n+  char *name;\n+  int len;\n+\n+  if (arg == 0)\n+    fatal (\"too few arguments to %%:compare-debug-auxbase-opt\");\n+\n+  if (arg != 1)\n+    fatal (\"too many arguments to %%:compare-debug-auxbase-opt\");\n+\n+  if (compare_debug >= 0)\n+    return NULL;\n+\n+  len = strlen (argv[0]);\n+  if (len < 3 || strcmp (argv[0] + len - 3, \".gk\") != 0)\n+    fatal (\"argument to %%:compare-debug-auxbase-opt does not end in .gk\");\n+\n+  if (debug_auxbase_opt)\n+    return debug_auxbase_opt;\n+\n+#define OPT \"-auxbase \"\n+\n+  len -= 3;\n+  name = (char*) xmalloc (sizeof (OPT) + len);\n+  memcpy (name, OPT, sizeof (OPT) - 1);\n+  memcpy (name + sizeof (OPT) - 1, argv[0], len);\n+  name[sizeof (OPT) - 1 + len] = '\\0';\n+\n+  return name;\n+}"}, {"sha": "ec012fd7111f205b9888f2ccb79df08ad3980917", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -1,3 +1,8 @@\n+2009-06-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* objc-act.c (objc_init): Skip print_struct_values during\n+\t-fcompare-debug-second.\n+\n 2009-06-03  Ian Lance Taylor  <iant@google.com>\n \n \t* Make-lang.in (cc1obj-checksum.o): Depend upon $(CONFIG_H) and"}, {"sha": "23715cba4867f32848c354cd4b071a0e86ce1a57", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -550,7 +550,7 @@ objc_init (void)\n \n   init_objc ();\n \n-  if (print_struct_values)\n+  if (print_struct_values && !flag_compare_debug)\n     generate_struct_by_value_array ();\n \n   return true;"}, {"sha": "267df5906ec3e898a32a45617d79c9582b94f9f9", "filename": "gcc/toplev.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2153915d0ab419d1e0b67f9e0e302368820d76f6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2153915d0ab419d1e0b67f9e0e302368820d76f6", "patch": "@@ -1870,6 +1870,31 @@ process_options (void)\n       profile_flag = 0;\n     }\n \n+  if (flag_gtoggle)\n+    {\n+      if (debug_info_level == DINFO_LEVEL_NONE)\n+\tdebug_info_level = DINFO_LEVEL_NORMAL;\n+      else\n+\tdebug_info_level = DINFO_LEVEL_NONE;\n+    }\n+\n+  if (flag_dump_final_insns)\n+    {\n+      FILE *final_output = fopen (flag_dump_final_insns, \"w\");\n+      if (!final_output)\n+\t{\n+\t  error (\"could not open final insn dump file %qs: %s\",\n+\t\t flag_dump_final_insns, strerror (errno));\n+\t  flag_dump_final_insns = NULL;\n+\t}\n+      else if (fclose (final_output))\n+\t{\n+\t  error (\"could not close zeroed insn dump file %qs: %s\",\n+\t\t flag_dump_final_insns, strerror (errno));\n+\t  flag_dump_final_insns = NULL;\n+\t}\n+    }\n+\n   /* A lot of code assumes write_symbols == NO_DEBUG if the debugging\n      level is 0.  */\n   if (debug_info_level == DINFO_LEVEL_NONE)"}]}