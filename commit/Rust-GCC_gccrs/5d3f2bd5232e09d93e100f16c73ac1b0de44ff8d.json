{"sha": "5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQzZjJiZDUyMzJlMDlkOTNlMTAwZjE2YzczYWMxYjBkZTQ0ZmY4ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-14T23:29:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-14T23:29:31Z"}, "message": "mips.c (mips_build_va_list): New.\n\n        * mips.c (mips_build_va_list): New.\n        (mips_va_start, mips_va_arg): New.\n        * mips.h (BUILD_VA_LIST_TYPE): New.\n        (EXPAND_BUILTIN_VA_START, EXPAND_BUILTIN_VA_ARG): New.\n\nFrom-SVN: r29414", "tree": {"sha": "6933d19f55da03e7058e0956b5f2e0fab766cd3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6933d19f55da03e7058e0956b5f2e0fab766cd3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d/comments", "author": null, "committer": null, "parents": [{"sha": "88e6fdcbfb67eb63bdc7f0bf81e43d098a16cba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e6fdcbfb67eb63bdc7f0bf81e43d098a16cba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e6fdcbfb67eb63bdc7f0bf81e43d098a16cba4"}], "stats": {"total": 281, "additions": 281, "deletions": 0}, "files": [{"sha": "2914220af3cd96f444a936f84cb798a10c7b648d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "patch": "@@ -3990,6 +3990,271 @@ function_arg_partial_nregs (cum, mode, type, named)\n   return 0;\n }\n \f\n+/* Create the va_list data type.  */\n+\n+tree\n+mips_build_va_list ()\n+{\n+  if (mips_abi == ABI_EABI && !TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n+    {\n+      tree f_fpr, f_rem, f_gpr, record;\n+\n+      record = make_node (RECORD_TYPE);\n+\n+      f_fpr = build_decl (FIELD_DECL, get_identifier (\"__fp_regs\"),\n+\t\t\t  ptr_type_node);\n+      f_rem = build_decl (FIELD_DECL, get_identifier (\"__fp_left\"),\n+\t\t\t  integer_type_node);\n+      f_gpr = build_decl (FIELD_DECL, get_identifier (\"__gp_regs\"),\n+\t\t\t  ptr_type_node);\n+\n+      DECL_FIELD_CONTEXT (f_fpr) = record;\n+      DECL_FIELD_CONTEXT (f_rem) = record;\n+      DECL_FIELD_CONTEXT (f_gpr) = record;\n+\n+      TYPE_FIELDS (record) = f_fpr;\n+      TREE_CHAIN (f_fpr) = f_rem;\n+      TREE_CHAIN (f_gpr) = f_gpr;\n+\n+      layout_type (record);\n+\n+      return record;\n+    }\n+  else\n+    return ptr_type_node;\n+}\n+\n+/* Implement va_start.  */\n+\n+void\n+mips_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg;\n+{\n+  int arg_words, fp_arg_words;\n+  tree t, u;\n+\n+  arg_words = current_function_args_info.arg_words;\n+  fp_arg_words = current_function_args_info.fp_arg_words;\n+\n+  if (mips_abi == ABI_EABI)\n+    {\n+      if (!TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n+\t{\n+\t  tree f_fpr, f_rem, f_gpr, fpr, rem, gpr;\n+\t  tree gprv, fprv;\n+\t  int gpro, fpro;\n+\n+\t  f_fpr = TYPE_FIELDS (va_list_type_node);\n+\t  f_rem = TREE_CHAIN (f_fpr);\n+\t  f_gpr = TREE_CHAIN (f_gpr);\n+\n+\t  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+\t  rem = build (COMPONENT_REF, TREE_TYPE (f_rem), valist, f_rem);\n+\t  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+\n+\t  if (arg_words < 8)\n+\t    gpro = (8 - arg_words) * UNITS_PER_WORD;\n+\t  else\n+\t    gpro = (stdarg_p ? 0 : UNITS_PER_WORD);\n+\n+\t  gprv = make_tree (ptr_type_node, nextarg);\n+\t  if (gpro != 0)\n+\t    {\n+\t      gprv = build (PLUS_EXPR, ptr_type_node, gprv,\n+\t\t\t    build_int_2 (-gpro, -1));\n+\t    }\n+\n+\t  t = build (MODIFY_EXPR, ptr_type_node, gpr, gprv);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+\t  t = build (MODIFY_EXPR, integer_type_node, rem,\n+\t\t     build_int_2 (8 - fp_arg_words, 0));\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+\t  fpro = (8 - fp_arg_words) * 8;\n+\t  if (fpro == 0)\n+\t    fprv = gprv;\n+\t  else\n+\t    fprv = fold (build (PLUS_EXPR, ptr_type_node, gprv,\n+\t\t\t\tbuild_int_2 (-fpro, -1)));\n+\n+\t  if (! TARGET_64BIT)\n+\t    fprv = fold (build (BIT_AND_EXPR, ptr_type_node, fprv,\n+\t\t\t\tbuild_int_2 (-8, -1)));\n+\n+\t  t = build (MODIFY_EXPR, ptr_type_node, fpr, fprv);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t}\n+      else\n+\t{\n+\t  int ofs;\n+\n+\t  if (arg_words >= 8)\n+\t    ofs = (stdarg_p ? 0 : UNITS_PER_WORD);\n+\t  else\n+\t    ofs = (8 - arg_words) * UNITS_PER_WORD;\n+\n+\t  nextarg = plus_constant (nextarg, -ofs);\n+\t  std_expand_builtin_va_start (1, valist, nextarg);\n+\t}\n+    }\n+  else\n+    {\n+      int ofs;\n+\n+      if (stdarg_p)\n+\tofs = 0;\n+      else\n+\t{\n+\t  /* ??? This had been conditional on\n+\t       _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32\n+\t     and both iris5.h and iris6.h define _MIPS_SIM.  */\n+\t  if (mips_abi == ABI_N32 || mips_abi == ABI_64)\n+\t    ofs = (arg_words >= 8 ? -UNITS_PER_WORD : 0);\n+\t  else\n+\t    ofs = -UNITS_PER_WORD;\n+\t}\n+\n+      nextarg = plus_constant (nextarg, ofs);\n+      std_expand_builtin_va_start (1, valist, nextarg);\n+    }\n+}\n+\n+/* Implement va_arg.  */\n+\n+rtx\n+mips_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  HOST_WIDE_INT size, rsize;\n+  rtx addr_rtx;\n+  tree t;\n+\n+  size = int_size_in_bytes (type);\n+  rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n+\n+  if (mips_abi == ABI_EABI)\n+    {\n+      tree gpr;\n+      int indirect;\n+      rtx lab_over = NULL_RTX, lab_false, r;\n+\n+      indirect\n+\t= function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n+      if (indirect)\n+\tsize = rsize = POINTER_SIZE / BITS_PER_UNIT;\n+\n+      addr_rtx = gen_reg_rtx (Pmode);\n+\n+      if (!TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n+\t{\n+\t  tree f_fpr, f_rem, f_gpr, fpr, rem;\n+\n+\t  f_fpr = TYPE_FIELDS (va_list_type_node);\n+\t  f_rem = TREE_CHAIN (f_fpr);\n+\t  f_gpr = TREE_CHAIN (f_gpr);\n+\n+\t  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+\t  rem = build (COMPONENT_REF, TREE_TYPE (f_rem), valist, f_rem);\n+\t  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+\n+\t  if (TREE_CODE (type) == REAL_TYPE)\n+\t    {\n+\t      lab_false = gen_label_rtx ();\n+\t      lab_over = gen_label_rtx ();\n+\n+\t      r = expand_expr (rem, NULL_RTX, TYPE_MODE (TREE_TYPE (rem)),\n+\t\t\t       EXPAND_NORMAL);\n+\t      emit_cmp_and_jump_insns (r, const0_rtx, LE, const1_rtx,\n+\t\t\t\t       GET_MODE (r), 1, 1, lab_false);\n+\n+\t      t = build (PLUS_EXPR, TREE_TYPE (rem), rem,\n+\t\t\t build_int_2 (-1, -1));\n+\t      t = build (MODIFY_EXPR, TREE_TYPE (rem), rem, t);\n+\t      TREE_SIDE_EFFECTS (t) = 1;\n+\t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+\t      t = build (POSTINCREMENT_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t\t build_int_2 (8, 0));\n+\t      TREE_SIDE_EFFECTS (t) = 1;\n+\t      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t      if (r != addr_rtx)\n+\t\temit_move_insn (addr_rtx, r);\n+\n+\t      emit_jump (gen_jump (lab_over));\n+\t      emit_barrier ();\n+\t      emit_label (lab_false);\n+\t    }\n+\t}\n+      else\n+\tgpr = valist;\n+\n+      if (! indirect\n+\t  && ! TARGET_64BIT\n+\t  && TYPE_ALIGN (type) > BITS_PER_WORD)\n+\t{\n+\t  t = build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t     build_int_2 (2*UNITS_PER_WORD - 1, 0));\n+\t  t = build (BIT_AND_EXPR, TREE_TYPE (t), t, \n+\t\t     build_int_2 (-2*UNITS_PER_WORD, -1));\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t}\n+\n+      t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr, rsize);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+      if (r != addr_rtx)\n+\temit_move_insn (addr_rtx, r);\n+\n+      if (lab_over)\n+\temit_label (lab_over);\n+\n+      if (indirect)\n+\t{\n+\t  r = gen_rtx_MEM (Pmode, addr_rtx);\n+\t  MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+\t  emit_move_insn (addr_rtx, r);\n+\t}\n+      else\n+\t{\n+\t  if (BYTES_BIG_ENDIAN && rsize != size)\n+\t    addr_rtx = plus_constant (addr_rtx, rsize - size);\n+\t}\n+    }\n+  else\n+    {\n+      int align;\n+\n+      /* ??? The original va-mips.h did always align, despite the fact \n+\t that alignments <= UNITS_PER_WORD are preserved by the va_arg\n+\t increment mechanism.  */\n+\n+      if (TARGET_64BIT)\n+\talign = 8;\n+      else if (TYPE_ALIGN (type) > 32)\n+\talign = 8;\n+      else\n+\talign = 4;\n+\t\n+      t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t build_int_2 (align - 1, 0));\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n+      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      /* Everything past the alignment is standard.  */\n+      return std_expand_builtin_va_arg (valist, type);\n+    }\n+}\n+\f\n /* Abort after printing out a specific insn.  */\n \n static void"}, {"sha": "59476dba198f65f90457626f6accd039dae1995e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "patch": "@@ -2611,6 +2611,22 @@ typedef struct mips_args {\n #define MIPS_STACK_ALIGN(LOC) (((LOC) + 7) & ~7)\n #endif\n \n+\f\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = mips_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  mips_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  mips_va_arg (valist, type)\n+\n+extern union tree_node *mips_build_va_list ();\n+extern void mips_va_start ();\n+extern struct rtx_def *mips_va_arg ();\n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}]}