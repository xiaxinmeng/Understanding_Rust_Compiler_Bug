{"sha": "b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY4NzVhYWMyYjVhMGU1ZTFiMjg0ZTQ5MzRiMGYxMmU4YTJhZmRkMA==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2015-05-20T03:05:10Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2015-05-20T03:05:10Z"}, "message": "aarch-common-protos.h (struct mem_cost_table): Added new fields loadv and storev.\n\ngcc/ChangeLog:\n\n2015-05-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\t    Jim Wilson  <jim.wilson@linaro.org>\n\n\t* config/arm/aarch-common-protos.h (struct mem_cost_table): Added\n\tnew  fields loadv and storev.\n\t* config/aarch64/aarch64-cost-tables.h (thunderx_extra_costs):\n\tInitialize loadv and storev.\n\t* config/arm/aarch-cost-tables.h (generic_extra_costs): Likewise.\n\t(cortexa53_extra_costs): Likewise.\n\t(cortexa57_extra_costs): Likewise.\n\t(xgene1_extra_costs): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Update vector\n\trtx_costs.\n\n2015-05-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* config/arm/arm.c (cortexa9_extra_costs): Initialize loadv and\n\t storev.\n\t(cortexa8_extra_costs): Likewise.\n\t(cortexa5_extra_costs): Likewise.\n\t(cortexa7_extra_costs): Likewise.\n\t(cortexa12_extra_costs): Likewise.\n\t(cortexa15_extra_costs): Likewise.\n\t(v7m_extra_costs): Likewise.\n\n\nCo-Authored-By: Jim Wilson <jim.wilson@linaro.org>\n\nFrom-SVN: r223432", "tree": {"sha": "d6c14ccf478fdb7f9b74ac53b693c2e7494962c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6c14ccf478fdb7f9b74ac53b693c2e7494962c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/comments", "author": null, "committer": null, "parents": [{"sha": "c725e7f87b0e63941d2a0fcbda07d0a9c55b54f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c725e7f87b0e63941d2a0fcbda07d0a9c55b54f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c725e7f87b0e63941d2a0fcbda07d0a9c55b54f1"}], "stats": {"total": 352, "additions": 280, "deletions": 72}, "files": [{"sha": "4c8eb3da190c4b0dcc41c64b79fbd32e8785678b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "patch": "@@ -1,3 +1,28 @@\n+2015-05-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\t    Jim Wilson  <jim.wilson@linaro.org>\n+\n+\t* config/arm/aarch-common-protos.h (struct mem_cost_table): Added\n+\tnew  fields loadv and storev.\n+\t* config/aarch64/aarch64-cost-tables.h (thunderx_extra_costs):\n+\tInitialize loadv and storev.\n+\t* config/arm/aarch-cost-tables.h (generic_extra_costs): Likewise.\n+\t(cortexa53_extra_costs): Likewise.\n+\t(cortexa57_extra_costs): Likewise.\n+\t(xgene1_extra_costs): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Update vector\n+\trtx_costs.\n+\n+2015-05-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* config/arm/arm.c (cortexa9_extra_costs): Initialize loadv and\n+\t storev.\n+\t(cortexa8_extra_costs): Likewise.\n+\t(cortexa5_extra_costs): Likewise.\n+\t(cortexa7_extra_costs): Likewise.\n+\t(cortexa12_extra_costs): Likewise.\n+\t(cortexa15_extra_costs): Likewise.\n+\t(v7m_extra_costs): Likewise.\n+\n 2015-05-20  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-threadupdate.c (thread_single_edge): Use delete_jump_thread"}, {"sha": "939125c0e88327823404b9fa6b6cbc9cdccd9ba8", "filename": "gcc/config/aarch64/aarch64-cost-tables.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Faarch64%2Faarch64-cost-tables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Faarch64%2Faarch64-cost-tables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cost-tables.h?ref=b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "patch": "@@ -83,7 +83,9 @@ const struct cpu_cost_table thunderx_extra_costs =\n     0,\t\t\t/* N/A: Stm_regs_per_insn_subsequent.  */\n     0,\t\t\t/* Storef.  */\n     0,\t\t\t/* Stored.  */\n-    COSTS_N_INSNS (1)  /* Store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* Store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* Loadv.  */\n+    COSTS_N_INSNS (1)\t/* Storev.  */\n   },\n   {\n     /* FP SFmode */"}, {"sha": "6f71e6649d6f80a1c504990021cd7c434bf0d7be", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 218, "deletions": 61, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "patch": "@@ -5617,16 +5617,6 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n      above this default.  */\n   *cost = COSTS_N_INSNS (1);\n \n-  /* TODO: The cost infrastructure currently does not handle\n-     vector operations.  Assume that all vector operations\n-     are equally expensive.  */\n-  if (VECTOR_MODE_P (mode))\n-    {\n-      if (speed)\n-\t*cost += extra_cost->vect.alu;\n-      return true;\n-    }\n-\n   switch (code)\n     {\n     case SET:\n@@ -5641,7 +5631,9 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  if (speed)\n \t    {\n \t      rtx address = XEXP (op0, 0);\n-\t      if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t*cost += extra_cost->ldst.storev;\n+\t      else if (GET_MODE_CLASS (mode) == MODE_INT)\n \t\t*cost += extra_cost->ldst.store;\n \t      else if (mode == SFmode)\n \t\t*cost += extra_cost->ldst.storef;\n@@ -5662,15 +5654,22 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n \t  /* Fall through.  */\n \tcase REG:\n+\t  /* The cost is one per vector-register copied.  */\n+\t  if (VECTOR_MODE_P (GET_MODE (op0)) && REG_P (op1))\n+\t    {\n+\t      int n_minus_1 = (GET_MODE_SIZE (GET_MODE (op0)) - 1)\n+\t\t\t      / GET_MODE_SIZE (V4SImode);\n+\t      *cost = COSTS_N_INSNS (n_minus_1 + 1);\n+\t    }\n \t  /* const0_rtx is in general free, but we will use an\n \t     instruction to set a register to 0.  */\n-          if (REG_P (op1) || op1 == const0_rtx)\n-            {\n-              /* The cost is 1 per register copied.  */\n-              int n_minus_1 = (GET_MODE_SIZE (GET_MODE (op0)) - 1)\n+\t  else if (REG_P (op1) || op1 == const0_rtx)\n+\t    {\n+\t      /* The cost is 1 per register copied.  */\n+\t      int n_minus_1 = (GET_MODE_SIZE (GET_MODE (op0)) - 1)\n \t\t\t      / UNITS_PER_WORD;\n-              *cost = COSTS_N_INSNS (n_minus_1 + 1);\n-            }\n+\t      *cost = COSTS_N_INSNS (n_minus_1 + 1);\n+\t    }\n           else\n \t    /* Cost is just the cost of the RHS of the set.  */\n \t    *cost += rtx_cost (op1, SET, 1, speed);\n@@ -5768,7 +5767,9 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t     approximation for the additional cost of the addressing\n \t     mode.  */\n \t  rtx address = XEXP (x, 0);\n-\t  if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->ldst.loadv;\n+\t  else if (GET_MODE_CLASS (mode) == MODE_INT)\n \t    *cost += extra_cost->ldst.load;\n \t  else if (mode == SFmode)\n \t    *cost += extra_cost->ldst.loadf;\n@@ -5785,6 +5786,16 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n     case NEG:\n       op0 = XEXP (x, 0);\n \n+      if (VECTOR_MODE_P (mode))\n+\t{\n+\t  if (speed)\n+\t    {\n+\t      /* FNEG.  */\n+\t      *cost += extra_cost->vect.alu;\n+\t    }\n+\t  return false;\n+\t}\n+\n       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n        {\n           if (GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMPARE\n@@ -5823,7 +5834,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n     case CLRSB:\n     case CLZ:\n       if (speed)\n-        *cost += extra_cost->alu.clz;\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else\n+\t    *cost += extra_cost->alu.clz;\n+\t}\n \n       return false;\n \n@@ -5909,6 +5925,20 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n           return false;\n         }\n \n+      if (VECTOR_MODE_P (mode))\n+\t{\n+\t  /* Vector compare.  */\n+\t  if (speed)\n+\t    *cost += extra_cost->vect.alu;\n+\n+\t  if (aarch64_float_const_zero_rtx_p (op1))\n+\t    {\n+\t      /* Vector cm (eq|ge|gt|lt|le) supports constant 0.0 for no extra\n+\t\t cost.  */\n+\t      return true;\n+\t    }\n+\t  return false;\n+\t}\n       return false;\n \n     case MINUS:\n@@ -5961,12 +5991,21 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n \tif (speed)\n \t  {\n-\t    if (GET_MODE_CLASS (mode) == MODE_INT)\n-\t      /* SUB(S).  */\n-\t      *cost += extra_cost->alu.arith;\n+\t    if (VECTOR_MODE_P (mode))\n+\t      {\n+\t\t/* Vector SUB.  */\n+\t\t*cost += extra_cost->vect.alu;\n+\t      }\n+\t    else if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t      {\n+\t\t/* SUB(S).  */\n+\t\t*cost += extra_cost->alu.arith;\n+\t      }\n \t    else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t      /* FSUB.  */\n-\t      *cost += extra_cost->fp[mode == DFmode].addsub;\n+\t      {\n+\t\t/* FSUB.  */\n+\t\t*cost += extra_cost->fp[mode == DFmode].addsub;\n+\t      }\n \t  }\n \treturn true;\n       }\n@@ -6030,12 +6069,21 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n \tif (speed)\n \t  {\n-\t    if (GET_MODE_CLASS (mode) == MODE_INT)\n-\t      /* ADD.  */\n-\t      *cost += extra_cost->alu.arith;\n+\t    if (VECTOR_MODE_P (mode))\n+\t      {\n+\t\t/* Vector ADD.  */\n+\t\t*cost += extra_cost->vect.alu;\n+\t      }\n+\t    else if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t      {\n+\t\t/* ADD.  */\n+\t\t*cost += extra_cost->alu.arith;\n+\t      }\n \t    else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t      /* FADD.  */\n-\t      *cost += extra_cost->fp[mode == DFmode].addsub;\n+\t      {\n+\t\t/* FADD.  */\n+\t\t*cost += extra_cost->fp[mode == DFmode].addsub;\n+\t      }\n \t  }\n \treturn true;\n       }\n@@ -6044,19 +6092,27 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       *cost = COSTS_N_INSNS (1);\n \n       if (speed)\n-        *cost += extra_cost->alu.rev;\n-\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else\n+\t    *cost += extra_cost->alu.rev;\n+\t}\n       return false;\n \n     case IOR:\n       if (aarch_rev16_p (x))\n         {\n           *cost = COSTS_N_INSNS (1);\n \n-          if (speed)\n-            *cost += extra_cost->alu.rev;\n-\n-          return true;\n+\t  if (speed)\n+\t    {\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t*cost += extra_cost->vect.alu;\n+\t      else\n+\t\t*cost += extra_cost->alu.rev;\n+\t    }\n+\t  return true;\n         }\n \n       if (aarch64_extr_rtx_p (x, &op0, &op1))\n@@ -6075,6 +6131,13 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n \n+      if (VECTOR_MODE_P (mode))\n+\t{\n+\t  if (speed)\n+\t    *cost += extra_cost->vect.alu;\n+\t  return true;\n+\t}\n+\n       if (code == AND\n           && GET_CODE (op0) == MULT\n           && CONST_INT_P (XEXP (op0, 1))\n@@ -6143,6 +6206,13 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       x = XEXP (x, 0);\n       op0 = aarch64_strip_shift (x);\n \n+      if (VECTOR_MODE_P (mode))\n+\t{\n+\t  /* Vector NOT.  */\n+\t  *cost += extra_cost->vect.alu;\n+\t  return false;\n+\t}\n+\n       /* MVN-shifted-reg.  */\n       if (op0 != x)\n         {\n@@ -6214,10 +6284,19 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  return true;\n \t}\n \n-      /* UXTB/UXTH.  */\n       if (speed)\n-\t*cost += extra_cost->alu.extend;\n-\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    {\n+\t      /* UMOV.  */\n+\t      *cost += extra_cost->vect.alu;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* UXTB/UXTH.  */\n+\t      *cost += extra_cost->alu.extend;\n+\t    }\n+\t}\n       return false;\n \n     case SIGN_EXTEND:\n@@ -6237,7 +6316,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t}\n \n       if (speed)\n-\t*cost += extra_cost->alu.extend;\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else\n+\t    *cost += extra_cost->alu.extend;\n+\t}\n       return false;\n \n     case ASHIFT:\n@@ -6246,10 +6330,20 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n       if (CONST_INT_P (op1))\n         {\n-\t  /* LSL (immediate), UBMF, UBFIZ and friends.  These are all\n-\t     aliases.  */\n \t  if (speed)\n-\t    *cost += extra_cost->alu.shift;\n+\t    {\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t{\n+\t\t  /* Vector shift (immediate).  */\n+\t\t  *cost += extra_cost->vect.alu;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* LSL (immediate), UBMF, UBFIZ and friends.  These are all\n+\t\t     aliases.  */\n+\t\t  *cost += extra_cost->alu.shift;\n+\t\t}\n+\t    }\n \n           /* We can incorporate zero/sign extend for free.  */\n           if (GET_CODE (op0) == ZERO_EXTEND\n@@ -6261,10 +6355,19 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n         }\n       else\n         {\n-\t  /* LSLV.  */\n \t  if (speed)\n-\t    *cost += extra_cost->alu.shift_reg;\n-\n+\t    {\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t{\n+\t\t  /* Vector shift (register).  */\n+\t\t  *cost += extra_cost->vect.alu;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* LSLV.  */\n+\t\t  *cost += extra_cost->alu.shift_reg;\n+\t\t}\n+\t    }\n \t  return false;  /* All arguments need to be in registers.  */\n         }\n \n@@ -6279,7 +6382,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t{\n \t  /* ASR (immediate) and friends.  */\n \t  if (speed)\n-\t    *cost += extra_cost->alu.shift;\n+\t    {\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t*cost += extra_cost->vect.alu;\n+\t      else\n+\t\t*cost += extra_cost->alu.shift;\n+\t    }\n \n \t  *cost += rtx_cost (op0, (enum rtx_code) code, 0, speed);\n \t  return true;\n@@ -6289,8 +6397,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n \t  /* ASR (register) and friends.  */\n \t  if (speed)\n-\t    *cost += extra_cost->alu.shift_reg;\n-\n+\t    {\n+\t      if (VECTOR_MODE_P (mode))\n+\t\t*cost += extra_cost->vect.alu;\n+\t      else\n+\t\t*cost += extra_cost->alu.shift_reg;\n+\t    }\n \t  return false;  /* All arguments need to be in registers.  */\n \t}\n \n@@ -6338,7 +6450,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n     case SIGN_EXTRACT:\n       /* UBFX/SBFX.  */\n       if (speed)\n-\t*cost += extra_cost->alu.bfx;\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else\n+\t    *cost += extra_cost->alu.bfx;\n+\t}\n \n       /* We can trust that the immediates used will be correct (there\n \t are no by-register forms), so we need only cost op0.  */\n@@ -6355,7 +6472,9 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n     case UMOD:\n       if (speed)\n \t{\n-\t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n \t    *cost += (extra_cost->mult[GET_MODE (x) == DImode].add\n \t\t      + extra_cost->mult[GET_MODE (x) == DImode].idiv);\n \t  else if (GET_MODE (x) == DFmode)\n@@ -6372,7 +6491,9 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n     case SQRT:\n       if (speed)\n \t{\n-\t  if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else if (GET_MODE_CLASS (mode) == MODE_INT)\n \t    /* There is no integer SQRT, so only DIV and UDIV can get\n \t       here.  */\n \t    *cost += extra_cost->mult[mode == DImode].idiv;\n@@ -6404,7 +6525,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       op2 = XEXP (x, 2);\n \n       if (speed)\n-\t*cost += extra_cost->fp[mode == DFmode].fma;\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else\n+\t    *cost += extra_cost->fp[mode == DFmode].fma;\n+\t}\n \n       /* FMSUB, FNMADD, and FNMSUB are free.  */\n       if (GET_CODE (op0) == NEG)\n@@ -6450,12 +6576,28 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n     case FLOAT_EXTEND:\n       if (speed)\n-\t*cost += extra_cost->fp[mode == DFmode].widen;\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    {\n+\t      /*Vector truncate.  */\n+\t      *cost += extra_cost->vect.alu;\n+\t    }\n+\t  else\n+\t    *cost += extra_cost->fp[mode == DFmode].widen;\n+\t}\n       return false;\n \n     case FLOAT_TRUNCATE:\n       if (speed)\n-\t*cost += extra_cost->fp[mode == DFmode].narrow;\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    {\n+\t      /*Vector conversion.  */\n+\t      *cost += extra_cost->vect.alu;\n+\t    }\n+\t  else\n+\t    *cost += extra_cost->fp[mode == DFmode].narrow;\n+\t}\n       return false;\n \n     case FIX:\n@@ -6476,13 +6618,23 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n         }\n \n       if (speed)\n-        *cost += extra_cost->fp[GET_MODE (x) == DFmode].toint;\n-\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else\n+\t    *cost += extra_cost->fp[GET_MODE (x) == DFmode].toint;\n+\t}\n       *cost += rtx_cost (x, (enum rtx_code) code, 0, speed);\n       return true;\n \n     case ABS:\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+      if (VECTOR_MODE_P (mode))\n+\t{\n+\t  /* ABS (vector).  */\n+\t  if (speed)\n+\t    *cost += extra_cost->vect.alu;\n+\t}\n+      else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n \t  op0 = XEXP (x, 0);\n \n@@ -6515,10 +6667,15 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n     case SMIN:\n       if (speed)\n \t{\n-\t  /* FMAXNM/FMINNM/FMAX/FMIN.\n-\t     TODO: This may not be accurate for all implementations, but\n-\t     we do not model this in the cost tables.  */\n-\t  *cost += extra_cost->fp[mode == DFmode].addsub;\n+\t  if (VECTOR_MODE_P (mode))\n+\t    *cost += extra_cost->vect.alu;\n+\t  else\n+\t    {\n+\t      /* FMAXNM/FMINNM/FMAX/FMIN.\n+\t         TODO: This may not be accurate for all implementations, but\n+\t         we do not model this in the cost tables.  */\n+\t      *cost += extra_cost->fp[mode == DFmode].addsub;\n+\t    }\n \t}\n       return false;\n "}, {"sha": "29f7c99392247b3ccb12569d9fd25a6eade2226e", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "patch": "@@ -102,6 +102,8 @@ struct mem_cost_table\n   const int storef;\t\t/* SFmode.  */\n   const int stored;\t\t/* DFmode.  */\n   const int store_unaligned;\t/* Extra for unaligned stores.  */\n+  const int loadv;\t\t/* Vector load.  */\n+  const int storev;\t\t/* Vector store.  */\n };\n \n struct fp_cost_table"}, {"sha": "66e09a8b5dbaa87469d570ace355311b86195825", "filename": "gcc/config/arm/aarch-cost-tables.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Farm%2Faarch-cost-tables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Farm%2Faarch-cost-tables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-cost-tables.h?ref=b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "patch": "@@ -81,7 +81,9 @@ const struct cpu_cost_table generic_extra_costs =\n     1,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     COSTS_N_INSNS (2),\t/* storef.  */\n     COSTS_N_INSNS (3),\t/* stored.  */\n-    COSTS_N_INSNS (1)  /* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -182,7 +184,9 @@ const struct cpu_cost_table cortexa53_extra_costs =\n     2,\t\t\t\t/* stm_regs_per_insn_subsequent.  */\n     0,\t\t\t\t/* storef.  */\n     0,\t\t\t\t/* stored.  */\n-    COSTS_N_INSNS (1)\t\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -283,7 +287,9 @@ const struct cpu_cost_table cortexa57_extra_costs =\n     2,                         /* stm_regs_per_insn_subsequent.  */\n     0,                         /* storef.  */\n     0,                         /* stored.  */\n-    COSTS_N_INSNS (1)          /* store_unaligned.  */\n+    COSTS_N_INSNS (1),         /* store_unaligned.  */\n+    COSTS_N_INSNS (1),         /* loadv.  */\n+    COSTS_N_INSNS (1)          /* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -385,6 +391,8 @@ const struct cpu_cost_table xgene1_extra_costs =\n     0,                         /* storef.  */\n     0,                         /* stored.  */\n     0,                         /* store_unaligned.  */\n+    COSTS_N_INSNS (1),         /* loadv.  */\n+    COSTS_N_INSNS (1)          /* storev.  */\n   },\n   {\n     /* FP SFmode */"}, {"sha": "6d8d060fc63e31fc0e73a8f01fab3cfaa6456441", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "patch": "@@ -1024,7 +1024,9 @@ const struct cpu_cost_table cortexa9_extra_costs =\n     2,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     COSTS_N_INSNS (1),\t/* storef.  */\n     COSTS_N_INSNS (1),\t/* stored.  */\n-    COSTS_N_INSNS (1)\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -1125,7 +1127,9 @@ const struct cpu_cost_table cortexa8_extra_costs =\n     2,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     COSTS_N_INSNS (1),\t/* storef.  */\n     COSTS_N_INSNS (1),\t/* stored.  */\n-    COSTS_N_INSNS (1)\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -1227,7 +1231,9 @@ const struct cpu_cost_table cortexa5_extra_costs =\n     2,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     COSTS_N_INSNS (2),\t/* storef.  */\n     COSTS_N_INSNS (2),\t/* stored.  */\n-    COSTS_N_INSNS (1)\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -1330,7 +1336,9 @@ const struct cpu_cost_table cortexa7_extra_costs =\n     2,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     COSTS_N_INSNS (2),\t/* storef.  */\n     COSTS_N_INSNS (2),\t/* stored.  */\n-    COSTS_N_INSNS (1)\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -1431,7 +1439,9 @@ const struct cpu_cost_table cortexa12_extra_costs =\n     2,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     COSTS_N_INSNS (2),\t/* storef.  */\n     COSTS_N_INSNS (2),\t/* stored.  */\n-    0\t\t\t/* store_unaligned.  */\n+    0,\t\t\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -1532,7 +1542,9 @@ const struct cpu_cost_table cortexa15_extra_costs =\n     2,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     0,\t\t\t/* storef.  */\n     0,\t\t\t/* stored.  */\n-    0\t\t\t/* store_unaligned.  */\n+    0,\t\t\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */\n@@ -1633,7 +1645,9 @@ const struct cpu_cost_table v7m_extra_costs =\n     1,\t\t\t/* stm_regs_per_insn_subsequent.  */\n     COSTS_N_INSNS (2),\t/* storef.  */\n     COSTS_N_INSNS (3),\t/* stored.  */\n-    COSTS_N_INSNS (1)  /* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* store_unaligned.  */\n+    COSTS_N_INSNS (1),\t/* loadv.  */\n+    COSTS_N_INSNS (1)\t/* storev.  */\n   },\n   {\n     /* FP SFmode */"}]}