{"sha": "2618f9559828916859242ab2fc2748d5e1ac670c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYxOGY5NTU5ODI4OTE2ODU5MjQyYWIyZmMyNzQ4ZDVlMWFjNjcwYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1999-06-22T14:31:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1999-06-22T14:31:38Z"}, "message": "Retabify\n\nFrom-SVN: r27704", "tree": {"sha": "41080c4a04f0bff50b8876fda18e71bbb72d86e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41080c4a04f0bff50b8876fda18e71bbb72d86e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2618f9559828916859242ab2fc2748d5e1ac670c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2618f9559828916859242ab2fc2748d5e1ac670c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2618f9559828916859242ab2fc2748d5e1ac670c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2618f9559828916859242ab2fc2748d5e1ac670c/comments", "author": null, "committer": null, "parents": [{"sha": "15b183364a1ddb7deffc6e96abbd7104898e2a33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b183364a1ddb7deffc6e96abbd7104898e2a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b183364a1ddb7deffc6e96abbd7104898e2a33"}], "stats": {"total": 277, "additions": 143, "deletions": 134}, "files": [{"sha": "7a2612882138837c94b17cd2191a79332816dbf4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2618f9559828916859242ab2fc2748d5e1ac670c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2618f9559828916859242ab2fc2748d5e1ac670c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2618f9559828916859242ab2fc2748d5e1ac670c", "patch": "@@ -1,6 +1,15 @@\n+Tue Jun 22 17:14:58 1999  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* dwarf2out.c (dwarf2out_frame_debug_expr): Reformat to match GNU\n+\tcoding standards.\n+\t(dwarf2out_define): Mark unused parameters appropriately.\n+\t(gen_unspecified_parameters_die): Ditto.\n+\t(gen_subprogram_die): Fix signed/unsigned warnings.\n+\t(gen_variable_die): Ditto.\n+\t\n 1999-06-22  Bruce Korb <ddsinc09@ix.netcom.com>\n \n-\t*fixinc/inclhack.def(end_else_label): combined else_label\n+\t* fixinc/inclhack.def(end_else_label): combined else_label\n \tand endif_label and fixed the sed expression.\n \t*fixinc/{fixincl.x|inclhack.sh}: regen\n "}, {"sha": "8b8126779bd0d4fb80b78332d9620228eaf5dc67", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 133, "deletions": 133, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2618f9559828916859242ab2fc2748d5e1ac670c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2618f9559828916859242ab2fc2748d5e1ac670c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2618f9559828916859242ab2fc2748d5e1ac670c", "patch": "@@ -1221,7 +1221,7 @@ dwarf2out_frame_debug_expr (expr, label)\n           \n           if (GET_CODE (x) == SET &&\n \t      (RTX_FRAME_RELATED_P (x) || par_index == 0))\n-\t      dwarf2out_frame_debug_expr (x, label);\n+\t    dwarf2out_frame_debug_expr (x, label);\n         }\n       return;\n     }\n@@ -1244,8 +1244,8 @@ dwarf2out_frame_debug_expr (expr, label)\n           if (cfa_reg != (unsigned) REGNO (src))\n             abort ();\n           if (REGNO (dest) != STACK_POINTER_REGNUM\n-      \t&& !(frame_pointer_needed\n-      \t     && REGNO (dest) == HARD_FRAME_POINTER_REGNUM))\n+\t      && !(frame_pointer_needed\n+\t\t   && REGNO (dest) == HARD_FRAME_POINTER_REGNUM))\n             abort ();\n           cfa_reg = REGNO (dest);\n           break;\n@@ -1254,83 +1254,83 @@ dwarf2out_frame_debug_expr (expr, label)\n         case MINUS:\n           if (dest == stack_pointer_rtx)\n             {\n-      \t/* Adjusting SP.  */\n-      \tswitch (GET_CODE (XEXP (src, 1)))\n-      \t  {\n-      \t  case CONST_INT:\n-      \t    offset = INTVAL (XEXP (src, 1));\n-      \t    break;\n-      \t  case REG:\n-      \t    if ((unsigned) REGNO (XEXP (src, 1)) != cfa_temp_reg)\n-      \t      abort ();\n-      \t    offset = cfa_temp_value;\n-      \t    break;\n-      \t  default:\n-      \t    abort ();\n-      \t  }\n-\n-      \tif (XEXP (src, 0) == hard_frame_pointer_rtx)\n-      \t  {\n-      \t    /* Restoring SP from FP in the epilogue.  */\n-      \t    if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n-      \t      abort ();\n-      \t    cfa_reg = STACK_POINTER_REGNUM;\n-      \t  }\n-      \telse if (XEXP (src, 0) != stack_pointer_rtx)\n-      \t  abort ();\n-\n-      \tif (GET_CODE (src) == PLUS)\n-      \t  offset = -offset;\n-      \tif (cfa_reg == STACK_POINTER_REGNUM)\n-      \t  cfa_offset += offset;\n-      \tif (cfa_store_reg == STACK_POINTER_REGNUM)\n-      \t  cfa_store_offset += offset;\n+\t      /* Adjusting SP.  */\n+\t      switch (GET_CODE (XEXP (src, 1)))\n+\t\t{\n+\t\tcase CONST_INT:\n+\t\t  offset = INTVAL (XEXP (src, 1));\n+\t\t  break;\n+\t\tcase REG:\n+\t\t  if ((unsigned) REGNO (XEXP (src, 1)) != cfa_temp_reg)\n+\t\t    abort ();\n+\t\t  offset = cfa_temp_value;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\n+\t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n+\t\t{\n+\t\t  /* Restoring SP from FP in the epilogue.  */\n+\t\t  if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n+\t\t    abort ();\n+\t\t  cfa_reg = STACK_POINTER_REGNUM;\n+\t\t}\n+\t      else if (XEXP (src, 0) != stack_pointer_rtx)\n+\t\tabort ();\n+\n+\t      if (GET_CODE (src) == PLUS)\n+\t\toffset = -offset;\n+\t      if (cfa_reg == STACK_POINTER_REGNUM)\n+\t\tcfa_offset += offset;\n+\t      if (cfa_store_reg == STACK_POINTER_REGNUM)\n+\t\tcfa_store_offset += offset;\n             }\n           else if (dest == hard_frame_pointer_rtx)\n             {\n-      \t/* Either setting the FP from an offset of the SP,\n-      \t   or adjusting the FP */\n-      \tif (! frame_pointer_needed\n-      \t    || REGNO (dest) != HARD_FRAME_POINTER_REGNUM)\n-      \t  abort ();\n-\n-      \tif (XEXP (src, 0) == stack_pointer_rtx\n-      \t    && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-      \t  {\n-      \t    if (cfa_reg != STACK_POINTER_REGNUM)\n-      \t      abort ();\n-      \t    offset = INTVAL (XEXP (src, 1));\n-      \t    if (GET_CODE (src) == PLUS)\n-      \t      offset = -offset;\n-      \t    cfa_offset += offset;\n-      \t    cfa_reg = HARD_FRAME_POINTER_REGNUM;\n-      \t  }\n-      \telse if (XEXP (src, 0) == hard_frame_pointer_rtx\n-      \t\t && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-      \t  {\n-      \t    if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n-      \t      abort ();\n-      \t    offset = INTVAL (XEXP (src, 1));\n-      \t    if (GET_CODE (src) == PLUS)\n-      \t      offset = -offset;\n-      \t    cfa_offset += offset;\n-      \t  }\n-\n-      \telse \n-      \t  abort();\n+\t      /* Either setting the FP from an offset of the SP,\n+\t\t or adjusting the FP */\n+\t      if (! frame_pointer_needed\n+\t\t  || REGNO (dest) != HARD_FRAME_POINTER_REGNUM)\n+\t\tabort ();\n+\n+\t      if (XEXP (src, 0) == stack_pointer_rtx\n+\t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t{\n+\t\t  if (cfa_reg != STACK_POINTER_REGNUM)\n+\t\t    abort ();\n+\t\t  offset = INTVAL (XEXP (src, 1));\n+\t\t  if (GET_CODE (src) == PLUS)\n+\t\t    offset = -offset;\n+\t\t  cfa_offset += offset;\n+\t\t  cfa_reg = HARD_FRAME_POINTER_REGNUM;\n+\t\t}\n+\t      else if (XEXP (src, 0) == hard_frame_pointer_rtx\n+\t\t       && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t{\n+\t\t  if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n+\t\t    abort ();\n+\t\t  offset = INTVAL (XEXP (src, 1));\n+\t\t  if (GET_CODE (src) == PLUS)\n+\t\t    offset = -offset;\n+\t\t  cfa_offset += offset;\n+\t\t}\n+\n+\t      else \n+\t\tabort();\n             }\n           else\n             {\n-      \tif (GET_CODE (src) != PLUS\n-      \t    || XEXP (src, 1) != stack_pointer_rtx)\n-      \t  abort ();\n-      \tif (GET_CODE (XEXP (src, 0)) != REG\n-      \t    || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg)\n-      \t  abort ();\n-      \tif (cfa_reg != STACK_POINTER_REGNUM)\n-      \t  abort ();\n-      \tcfa_store_reg = REGNO (dest);\n-      \tcfa_store_offset = cfa_offset - cfa_temp_value;\n+\t      if (GET_CODE (src) != PLUS\n+\t\t  || XEXP (src, 1) != stack_pointer_rtx)\n+\t\tabort ();\n+\t      if (GET_CODE (XEXP (src, 0)) != REG\n+\t\t  || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg)\n+\t\tabort ();\n+\t      if (cfa_reg != STACK_POINTER_REGNUM)\n+\t\tabort ();\n+\t      cfa_store_reg = REGNO (dest);\n+\t      cfa_store_offset = cfa_offset - cfa_temp_value;\n             }\n           break;\n \n@@ -1341,9 +1341,9 @@ dwarf2out_frame_debug_expr (expr, label)\n \n         case IOR:\n           if (GET_CODE (XEXP (src, 0)) != REG\n-      \t|| (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg\n-      \t|| (unsigned) REGNO (dest) != cfa_temp_reg\n-      \t|| GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg\n+\t      || (unsigned) REGNO (dest) != cfa_temp_reg\n+\t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n             abort ();\n           cfa_temp_value |= INTVAL (XEXP (src, 1));\n           break;\n@@ -1352,61 +1352,61 @@ dwarf2out_frame_debug_expr (expr, label)\n           abort ();\n         }\n       dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n-    break;\n+      break;\n \n-  case MEM:\n-    /* Saving a register to the stack.  Make sure dest is relative to the\n-       CFA register.  */\n-    if (GET_CODE (src) != REG)\n-      abort ();\n-    switch (GET_CODE (XEXP (dest, 0)))\n-      {\n-        /* With a push.  */\n-      case PRE_INC:\n-      case PRE_DEC:\n-        offset = GET_MODE_SIZE (GET_MODE (dest));\n-        if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n-          offset = -offset;\n-\n-        if (REGNO (XEXP (XEXP (dest, 0), 0)) != STACK_POINTER_REGNUM\n-            || cfa_store_reg != STACK_POINTER_REGNUM)\n-          abort ();\n-        cfa_store_offset += offset;\n-        if (cfa_reg == STACK_POINTER_REGNUM)\n-          cfa_offset = cfa_store_offset;\n+    case MEM:\n+      /* Saving a register to the stack.  Make sure dest is relative to the\n+\t CFA register.  */\n+      if (GET_CODE (src) != REG)\n+\tabort ();\n+      switch (GET_CODE (XEXP (dest, 0)))\n+\t{\n+\t  /* With a push.  */\n+\tcase PRE_INC:\n+\tcase PRE_DEC:\n+\t  offset = GET_MODE_SIZE (GET_MODE (dest));\n+\t  if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n+\t    offset = -offset;\n \n-        offset = -cfa_store_offset;\n-        break;\n+\t  if (REGNO (XEXP (XEXP (dest, 0), 0)) != STACK_POINTER_REGNUM\n+\t      || cfa_store_reg != STACK_POINTER_REGNUM)\n+\t    abort ();\n+\t  cfa_store_offset += offset;\n+\t  if (cfa_reg == STACK_POINTER_REGNUM)\n+\t    cfa_offset = cfa_store_offset;\n \n-        /* With an offset.  */\n-      case PLUS:\n-      case MINUS:\n-        offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n-        if (GET_CODE (XEXP (dest, 0)) == MINUS)\n-          offset = -offset;\n+\t  offset = -cfa_store_offset;\n+\t  break;\n \n-        if (cfa_store_reg != (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n-          abort ();\n-        offset -= cfa_store_offset;\n-        break;\n-\n-        /* Without an offset.  */\n-      case REG:\n-        if (cfa_store_reg != (unsigned) REGNO (XEXP (dest, 0)))\n-          abort();\n-        offset = -cfa_store_offset;\n-        break;\n-\n-      default:\n-        abort ();\n-      }\n-    dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n-    dwarf2out_reg_save (label, REGNO (src), offset);\n-    break;\n+\t  /* With an offset.  */\n+\tcase PLUS:\n+\tcase MINUS:\n+\t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n+\t  if (GET_CODE (XEXP (dest, 0)) == MINUS)\n+\t    offset = -offset;\n \n-  default:\n-    abort ();\n-  }\n+\t  if (cfa_store_reg != (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n+\t    abort ();\n+\t  offset -= cfa_store_offset;\n+\t  break;\n+\n+\t  /* Without an offset.  */\n+\tcase REG:\n+\t  if (cfa_store_reg != (unsigned) REGNO (XEXP (dest, 0)))\n+\t    abort();\n+\t  offset = -cfa_store_offset;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n+      dwarf2out_reg_save (label, REGNO (src), offset);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n }\n \n \n@@ -8248,7 +8248,7 @@ gen_formal_parameter_die (node, context_die)\n \n static void\n gen_unspecified_parameters_die (decl_or_type, context_die)\n-     register tree decl_or_type;\n+     register tree decl_or_type ATTRIBUTE_UNUSED;\n      register dw_die_ref context_die;\n {\n   new_die (DW_TAG_unspecified_parameters, context_die);\n@@ -8388,7 +8388,7 @@ gen_subprogram_die (decl, context_die)\n \t   || context_die == NULL)\n \t  && get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n \t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      == DECL_SOURCE_LINE (decl)))\n+\t      == (unsigned)DECL_SOURCE_LINE (decl)))\n \t{\n \t  subr_die = old_die;\n \n@@ -8403,7 +8403,7 @@ gen_subprogram_die (decl, context_die)\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n \t    add_AT_unsigned (subr_die, DW_AT_decl_file, file_index);\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      != DECL_SOURCE_LINE (decl))\n+\t      != (unsigned)DECL_SOURCE_LINE (decl))\n \t    add_AT_unsigned\n \t      (subr_die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n \t}\n@@ -8640,7 +8640,7 @@ gen_variable_die (decl, context_die)\n \t    add_AT_unsigned (var_die, DW_AT_decl_file, file_index);\n \n \t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      != DECL_SOURCE_LINE (decl))\n+\t      != (unsigned)DECL_SOURCE_LINE (decl))\n \n \t    add_AT_unsigned (var_die, DW_AT_decl_line,\n \t\t\t     DECL_SOURCE_LINE (decl));\n@@ -9912,8 +9912,8 @@ dwarf2out_end_source_file ()\n \n void\n dwarf2out_define (lineno, buffer)\n-     register unsigned lineno;\n-     register char *buffer;\n+     register unsigned lineno ATTRIBUTE_UNUSED;\n+     register char *buffer ATTRIBUTE_UNUSED;\n {\n   static int initialized = 0;\n   if (!initialized)"}]}