{"sha": "7f4b58c2582067694e7f9e8944187ac5794579d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0YjU4YzI1ODIwNjc2OTRlN2Y5ZTg5NDQxODdhYzU3OTQ1NzlkMA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-23T10:23:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-23T10:23:54Z"}, "message": "[Ada] Spurious Storage_Error on imported array\n\nThis patch moves the check which verifies that a large modular array is created\nfrom expansion to freezing in order to take interfacing pragmas in account. The\ncheck is no longer performed on imported objects because no object is created\nin that case.\n\n2018-05-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch3.adb (Check_Large_Modular_Array): Moved to Freeze.\n\t(Expand_N_Object_Declaration): Do not check for a large modular array\n\there.\n\t* freeze.adb (Check_Large_Modular_Array): Moved from Exp_Ch3.\n\t(Freeze_Object_Declaration): Code cleanup. Check for a large modular\n\tarray.\n\t* sem_ch3.adb: Minor reformatting.\n\ngcc/testsuite/\n\n\t* gnat.dg/import2.adb: New testcase.\n\nFrom-SVN: r260597", "tree": {"sha": "49507a77bed0132522ea627c9d9f0941f6996e6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49507a77bed0132522ea627c9d9f0941f6996e6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f4b58c2582067694e7f9e8944187ac5794579d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4b58c2582067694e7f9e8944187ac5794579d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f4b58c2582067694e7f9e8944187ac5794579d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4b58c2582067694e7f9e8944187ac5794579d0/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ffdd52487888d3c45cf02e66b79587d2cf2839a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffdd52487888d3c45cf02e66b79587d2cf2839a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffdd52487888d3c45cf02e66b79587d2cf2839a3"}], "stats": {"total": 264, "additions": 160, "deletions": 104}, "files": [{"sha": "e1f83b5e01324ad49975378a78a06d226d32c55c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7f4b58c2582067694e7f9e8944187ac5794579d0", "patch": "@@ -1,3 +1,13 @@\n+2018-05-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Check_Large_Modular_Array): Moved to Freeze.\n+\t(Expand_N_Object_Declaration): Do not check for a large modular array\n+\there.\n+\t* freeze.adb (Check_Large_Modular_Array): Moved from Exp_Ch3.\n+\t(Freeze_Object_Declaration): Code cleanup. Check for a large modular\n+\tarray.\n+\t* sem_ch3.adb: Minor reformatting.\n+\n 2018-05-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* einfo.ads: New attribute on types: Predicated_Parent, to simplify the"}, {"sha": "3c1bedef96db83a60028c716be5291ec09ee3cd7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=7f4b58c2582067694e7f9e8944187ac5794579d0", "patch": "@@ -5606,13 +5606,6 @@ package body Exp_Ch3 is\n       --  value, it may be possible to build an equivalent aggregate instead,\n       --  and prevent an actual call to the initialization procedure.\n \n-      procedure Check_Large_Modular_Array;\n-      --  Check that the size of the array can be computed without overflow,\n-      --  and generate a Storage_Error otherwise. This is only relevant for\n-      --  array types whose index in a (mod 2**64) type, where wrap-around\n-      --  arithmetic might yield a meaningless value for the length of the\n-      --  array, or its corresponding attribute.\n-\n       procedure Count_Default_Sized_Task_Stacks\n         (Typ         : Entity_Id;\n          Pri_Stacks  : out Int;\n@@ -5759,61 +5752,6 @@ package body Exp_Ch3 is\n          end if;\n       end Build_Equivalent_Aggregate;\n \n-      -------------------------------\n-      -- Check_Large_Modular_Array --\n-      -------------------------------\n-\n-      procedure Check_Large_Modular_Array is\n-         Index_Typ : Entity_Id;\n-\n-      begin\n-         if Is_Array_Type (Typ)\n-           and then Is_Modular_Integer_Type (Etype (First_Index (Typ)))\n-         then\n-            --  To prevent arithmetic overflow with large values, we raise\n-            --  Storage_Error under the following guard:\n-\n-            --    (Arr'Last / 2 - Arr'First / 2) > (2 ** 30)\n-\n-            --  This takes care of the boundary case, but it is preferable to\n-            --  use a smaller limit, because even on 64-bit architectures an\n-            --  array of more than 2 ** 30 bytes is likely to raise\n-            --  Storage_Error.\n-\n-            Index_Typ := Etype (First_Index (Typ));\n-\n-            if RM_Size (Index_Typ) = RM_Size (Standard_Long_Long_Integer) then\n-               Insert_Action (N,\n-                 Make_Raise_Storage_Error (Loc,\n-                   Condition =>\n-                     Make_Op_Ge (Loc,\n-                       Left_Opnd  =>\n-                         Make_Op_Subtract (Loc,\n-                           Left_Opnd  =>\n-                             Make_Op_Divide (Loc,\n-                               Left_Opnd  =>\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                     New_Occurrence_Of (Typ, Loc),\n-                                   Attribute_Name => Name_Last),\n-                               Right_Opnd =>\n-                                 Make_Integer_Literal (Loc, Uint_2)),\n-                           Right_Opnd =>\n-                             Make_Op_Divide (Loc,\n-                               Left_Opnd =>\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                     New_Occurrence_Of (Typ, Loc),\n-                                   Attribute_Name => Name_First),\n-                               Right_Opnd =>\n-                                 Make_Integer_Literal (Loc, Uint_2))),\n-                       Right_Opnd =>\n-                         Make_Integer_Literal (Loc, (Uint_2 ** 30))),\n-                   Reason    => SE_Object_Too_Large));\n-            end if;\n-         end if;\n-      end Check_Large_Modular_Array;\n-\n       -------------------------------------\n       -- Count_Default_Sized_Task_Stacks --\n       -------------------------------------\n@@ -6434,8 +6372,6 @@ package body Exp_Ch3 is\n          Build_Master_Entity (Def_Id);\n       end if;\n \n-      Check_Large_Modular_Array;\n-\n       --  If No_Implicit_Heap_Allocations or No_Implicit_Task_Allocations\n       --  restrictions are active then default-sized secondary stacks are\n       --  generated by the binder and allocated by SS_Init. To provide the"}, {"sha": "6643c5c26b0aa0f37098396e80972c48c5015169", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 133, "deletions": 39, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=7f4b58c2582067694e7f9e8944187ac5794579d0", "patch": "@@ -3187,6 +3187,100 @@ package body Freeze is\n       -------------------------------\n \n       procedure Freeze_Object_Declaration (E : Entity_Id) is\n+\n+         procedure Check_Large_Modular_Array (Typ : Entity_Id);\n+         --  Check that the size of array type Typ can be computed without\n+         --  overflow, and generates a Storage_Error otherwise. This is only\n+         --  relevant for array types whose index is a (mod 2**64) type, where\n+         --  wrap-around arithmetic might yield a meaningless value for the\n+         --  length of the array, or its corresponding attribute.\n+\n+         -------------------------------\n+         -- Check_Large_Modular_Array --\n+         -------------------------------\n+\n+         procedure Check_Large_Modular_Array (Typ : Entity_Id) is\n+            Obj_Loc : constant Source_Ptr := Sloc (E);\n+            Idx_Typ : Entity_Id;\n+\n+         begin\n+            --  Nothing to do when expansion is disabled because this routine\n+            --  generates a runtime check.\n+\n+            if not Expander_Active then\n+               return;\n+\n+            --  Nothing to do for String literal subtypes because their index\n+            --  cannot be a modular type.\n+\n+            elsif Ekind (Typ) = E_String_Literal_Subtype then\n+               return;\n+\n+            --  Nothing to do for an imported object because the object will\n+            --  be created on the exporting side.\n+\n+            elsif Is_Imported (E) then\n+               return;\n+\n+            --  Nothing to do for unconstrained array types. This case arises\n+            --  when the object declaration is illegal.\n+\n+            elsif not Is_Constrained (Typ) then\n+               return;\n+            end if;\n+\n+            Idx_Typ := Etype (First_Index (Typ));\n+\n+            --  To prevent arithmetic overflow with large values, we raise\n+            --  Storage_Error under the following guard:\n+            --\n+            --    (Arr'Last / 2 - Arr'First / 2) > (2 ** 30)\n+            --\n+            --  This takes care of the boundary case, but it is preferable to\n+            --  use a smaller limit, because even on 64-bit architectures an\n+            --  array of more than 2 ** 30 bytes is likely to raise\n+            --  Storage_Error.\n+\n+            if Is_Modular_Integer_Type (Idx_Typ)\n+              and then RM_Size (Idx_Typ) = RM_Size (Standard_Long_Long_Integer)\n+            then\n+               Insert_Action (Declaration_Node (E),\n+                 Make_Raise_Storage_Error (Obj_Loc,\n+                   Condition =>\n+                     Make_Op_Ge (Obj_Loc,\n+                       Left_Opnd  =>\n+                         Make_Op_Subtract (Obj_Loc,\n+                           Left_Opnd  =>\n+                             Make_Op_Divide (Obj_Loc,\n+                               Left_Opnd  =>\n+                                 Make_Attribute_Reference (Obj_Loc,\n+                                   Prefix         =>\n+                                     New_Occurrence_Of (Typ, Obj_Loc),\n+                                   Attribute_Name => Name_Last),\n+                               Right_Opnd =>\n+                                 Make_Integer_Literal (Obj_Loc, Uint_2)),\n+                           Right_Opnd =>\n+                             Make_Op_Divide (Obj_Loc,\n+                               Left_Opnd =>\n+                                 Make_Attribute_Reference (Obj_Loc,\n+                                   Prefix         =>\n+                                     New_Occurrence_Of (Typ, Obj_Loc),\n+                                   Attribute_Name => Name_First),\n+                               Right_Opnd =>\n+                                 Make_Integer_Literal (Obj_Loc, Uint_2))),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Obj_Loc, (Uint_2 ** 30))),\n+                   Reason    => SE_Object_Too_Large));\n+            end if;\n+         end Check_Large_Modular_Array;\n+\n+         --  Local variables\n+\n+         Typ : constant Entity_Id := Etype (E);\n+         Def : Node_Id;\n+\n+      --  Start of processing for Freeze_Object_Declaration\n+\n       begin\n          --  Abstract type allowed only for C++ imported variables or constants\n \n@@ -3195,22 +3289,20 @@ package body Freeze is\n          --  x'Class'Input where x is abstract) where we legitimately\n          --  generate an abstract object.\n \n-         if Is_Abstract_Type (Etype (E))\n+         if Is_Abstract_Type (Typ)\n            and then Comes_From_Source (Parent (E))\n-           and then not (Is_Imported (E) and then Is_CPP_Class (Etype (E)))\n+           and then not (Is_Imported (E) and then Is_CPP_Class (Typ))\n          then\n-            Error_Msg_N (\"type of object cannot be abstract\",\n-                         Object_Definition (Parent (E)));\n+            Def := Object_Definition (Parent (E));\n+\n+            Error_Msg_N (\"type of object cannot be abstract\", Def);\n \n             if Is_CPP_Class (Etype (E)) then\n-               Error_Msg_NE\n-                 (\"\\} may need a cpp_constructor\",\n-                  Object_Definition (Parent (E)), Etype (E));\n+               Error_Msg_NE (\"\\} may need a cpp_constructor\", Def, Typ);\n \n             elsif Present (Expression (Parent (E))) then\n                Error_Msg_N --  CODEFIX\n-                 (\"\\maybe a class-wide type was meant\",\n-                  Object_Definition (Parent (E)));\n+                 (\"\\maybe a class-wide type was meant\", Def);\n             end if;\n          end if;\n \n@@ -3221,20 +3313,20 @@ package body Freeze is\n \n          Validate_Object_Declaration (Declaration_Node (E));\n \n-         --  If there is an address clause, check that it is valid\n-         --  and if need be move initialization to the freeze node.\n+         --  If there is an address clause, check that it is valid and if need\n+         --  be move initialization to the freeze node.\n \n          Check_Address_Clause (E);\n \n-         --  Similar processing is needed for aspects that may affect\n-         --  object layout, like Alignment, if there is an initialization\n-         --  expression. We don't do this if there is a pragma Linker_Section,\n-         --  because it would prevent the back end from statically initializing\n-         --  the object; we don't want elaboration code in that case.\n+         --  Similar processing is needed for aspects that may affect object\n+         --  layout, like Alignment, if there is an initialization expression.\n+         --  We don't do this if there is a pragma Linker_Section, because it\n+         --  would prevent the back end from statically initializing the\n+         --  object; we don't want elaboration code in that case.\n \n          if Has_Delayed_Aspects (E)\n            and then Expander_Active\n-           and then Is_Array_Type (Etype (E))\n+           and then Is_Array_Type (Typ)\n            and then Present (Expression (Parent (E)))\n            and then No (Linker_Section_Pragma (E))\n          then\n@@ -3243,15 +3335,14 @@ package body Freeze is\n                Lhs  : constant Node_Id := New_Occurrence_Of (E, Loc);\n \n             begin\n-\n                --  Capture initialization value at point of declaration, and\n                --  make explicit assignment legal, because object may be a\n                --  constant.\n \n                Remove_Side_Effects (Expression (Decl));\n                Set_Assignment_OK (Lhs);\n \n-               --  Move initialization to freeze actions.\n+               --  Move initialization to freeze actions\n \n                Append_Freeze_Action (E,\n                  Make_Assignment_Statement (Loc,\n@@ -3283,7 +3374,7 @@ package body Freeze is\n          --  a dispatch table entry, then we mean it.\n \n          if Ekind (E) /= E_Constant\n-           and then (Is_Aliased (E) or else Is_Aliased (Etype (E)))\n+           and then (Is_Aliased (E) or else Is_Aliased (Typ))\n            and then not Is_Internal_Name (Chars (E))\n          then\n             Set_Is_True_Constant (E, False);\n@@ -3304,21 +3395,21 @@ package body Freeze is\n            and then not Is_Imported (E)\n            and then not Has_Init_Expression (Declaration_Node (E))\n            and then\n-             ((Has_Non_Null_Base_Init_Proc (Etype (E))\n+             ((Has_Non_Null_Base_Init_Proc (Typ)\n                 and then not No_Initialization (Declaration_Node (E))\n-                and then not Initialization_Suppressed (Etype (E)))\n+                and then not Initialization_Suppressed (Typ))\n               or else\n-                (Needs_Simple_Initialization (Etype (E))\n+                (Needs_Simple_Initialization (Typ)\n                   and then not Is_Internal (E)))\n          then\n             Has_Default_Initialization := True;\n             Check_Restriction\n               (No_Default_Initialization, Declaration_Node (E));\n          end if;\n \n-         --  Check that a Thread_Local_Storage variable does not have\n-         --  default initialization, and any explicit initialization must\n-         --  either be the null constant or a static constant.\n+         --  Check that a Thread_Local_Storage variable does not have default\n+         --  initialization, and any explicit initialization must either be the\n+         --  null constant or a static constant.\n \n          if Has_Pragma_Thread_Local_Storage (E) then\n             declare\n@@ -3356,38 +3447,41 @@ package body Freeze is\n             Set_Is_Public (E);\n          end if;\n \n-         --  For source objects that are not Imported and are library\n-         --  level, if no linker section pragma was given inherit the\n-         --  appropriate linker section from the corresponding type.\n+         --  For source objects that are not Imported and are library level, if\n+         --  no linker section pragma was given inherit the appropriate linker\n+         --  section from the corresponding type.\n \n          if Comes_From_Source (E)\n            and then not Is_Imported (E)\n            and then Is_Library_Level_Entity (E)\n            and then No (Linker_Section_Pragma (E))\n          then\n-            Set_Linker_Section_Pragma\n-              (E, Linker_Section_Pragma (Etype (E)));\n+            Set_Linker_Section_Pragma (E, Linker_Section_Pragma (Typ));\n          end if;\n \n-         --  For convention C objects of an enumeration type, warn if the\n-         --  size is not integer size and no explicit size given. Skip\n-         --  warning for Boolean, and Character, assume programmer expects\n-         --  8-bit sizes for these cases.\n+         --  For convention C objects of an enumeration type, warn if the size\n+         --  is not integer size and no explicit size given. Skip warning for\n+         --  Boolean and Character, and assume programmer expects 8-bit sizes\n+         --  for these cases.\n \n          if (Convention (E) = Convention_C\n                or else\n              Convention (E) = Convention_CPP)\n-           and then Is_Enumeration_Type (Etype (E))\n-           and then not Is_Character_Type (Etype (E))\n-           and then not Is_Boolean_Type (Etype (E))\n-           and then Esize (Etype (E)) < Standard_Integer_Size\n+           and then Is_Enumeration_Type (Typ)\n+           and then not Is_Character_Type (Typ)\n+           and then not Is_Boolean_Type (Typ)\n+           and then Esize (Typ) < Standard_Integer_Size\n            and then not Has_Size_Clause (E)\n          then\n             Error_Msg_Uint_1 := UI_From_Int (Standard_Integer_Size);\n             Error_Msg_N\n               (\"??convention C enumeration object has size less than ^\", E);\n             Error_Msg_N (\"\\??use explicit size clause to set size\", E);\n          end if;\n+\n+         if Is_Array_Type (Typ) then\n+            Check_Large_Modular_Array (Typ);\n+         end if;\n       end Freeze_Object_Declaration;\n \n       -----------------------------"}, {"sha": "9f23b564e68df4309cbc1e2d6a911399b8624c93", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7f4b58c2582067694e7f9e8944187ac5794579d0", "patch": "@@ -21676,7 +21676,8 @@ package body Sem_Ch3 is\n                then\n                   Constrain_Array (Def_Id, S, Related_Nod, Related_Id, Suffix);\n \n-                  --  ... but more comonly by a discriminated record type.\n+               --  ... but more commonly is completed by a discriminated record\n+               --  type.\n \n                else\n                   Constrain_Discriminated_Type (Def_Id, S, Related_Nod);"}, {"sha": "e5b473d5f3279722760ec7a0af82940a9d608eec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f4b58c2582067694e7f9e8944187ac5794579d0", "patch": "@@ -1,3 +1,7 @@\n+2018-05-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/import2.adb: New testcase.\n+\n 2018-05-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/discr51.adb: New testcase."}, {"sha": "07ba880d3f7c0b431017f26d3ef7ee5b3125a06f", "filename": "gcc/testsuite/gnat.dg/import2.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Ftestsuite%2Fgnat.dg%2Fimport2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4b58c2582067694e7f9e8944187ac5794579d0/gcc%2Ftestsuite%2Fgnat.dg%2Fimport2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fimport2.adb?ref=7f4b58c2582067694e7f9e8944187ac5794579d0", "patch": "@@ -0,0 +1,11 @@\n+--  { dg-do run }\n+\n+procedure Import2 is\n+   type Index_Typ is mod 2**64;\n+   type Mod_Array is array (Index_Typ) of Integer;\n+\n+   Obj : Mod_Array;\n+   pragma Import (Ada, Obj);\n+begin\n+   null;\n+end Import2;"}]}