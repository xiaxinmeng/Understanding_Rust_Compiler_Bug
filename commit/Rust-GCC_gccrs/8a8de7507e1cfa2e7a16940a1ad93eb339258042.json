{"sha": "8a8de7507e1cfa2e7a16940a1ad93eb339258042", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE4ZGU3NTA3ZTFjZmEyZTdhMTY5NDBhMWFkOTNlYjMzOTI1ODA0Mg==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:26Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:26Z"}, "message": "VAX: Remove EXTV/EXTZV/INSV instruction use from aligned case insns\n\nThe INSV machine instruction is the only computational operation in the\nVAX ISA that keeps condition codes intact.  In preparation to MODE_CC\ntransition keep patterns apart then that make or do not make use of said\ninstruction.  For consistency update EXTV and EXTZV instruction uses\naccordingly.  In expand SUBREGs will be presented as operands, so handle\nthat possibility in the insn condition.\n\nThis actually yields better code by avoiding EXTV/EXTZV instructions in\npseudo-aligned register cases previously resorting to those instructions:\n\n@@ -42,7 +42,7 @@ ins8:\n \tsubl2 $4,%sp\t# 21\t[c=32]  addsi3\n \tmovl 4(%ap),%r0\t# 2\t[c=16]  movsi_2\n \tmovl 8(%ap),%r1\t# 17\t[c=16]  movsi_2\n-\tinsv %r1,$8,$8,%r0\t# 9\t[c=4]  *insv_aligned\n+\tinsv %r1,$8,$8,%r0\t# 9\t[c=4]  *insv_2\n \tret\t\t# 25\t[c=0]  return\n \t.size\tins8, .-ins8\n \t.align 1\n@@ -60,12 +60,12 @@ ext8:\n .globl extz8\n \t.type\textz8, @function\n extz8:\n-\t.word 0\t# 19\t[c=0]  procedure_entry_mask\n-\tsubl2 $4,%sp\t# 20\t[c=32]  addsi3\n+\t.word 0\t# 18\t[c=0]  procedure_entry_mask\n+\tsubl2 $4,%sp\t# 19\t[c=32]  addsi3\n \tmovl 4(%ap),%r0\t# 2\t[c=16]  movsi_2\n-\textzv $8,$8,%r0,%r1\t# 13\t[c=60]  *extzv_aligned\n-\tmovl %r1,%r0\t# 18\t[c=4]  movsi_2\n-\tret\t\t# 24\t[c=0]  return\n+\trotl $24,%r0,%r0\t# 13\t[c=60]  *extzv_non_const\n+\tmovzbl %r0,%r0\n+\tret\t\t# 23\t[c=0]  return\n \t.size\textz8, .-extz8\n \t.align 1\n .globl ins16\n@@ -75,7 +75,7 @@ ins16:\n \tsubl2 $4,%sp\t# 21\t[c=32]  addsi3\n \tmovl 4(%ap),%r0\t# 2\t[c=16]  movsi_2\n \tmovl 8(%ap),%r1\t# 17\t[c=16]  movsi_2\n-\tinsv %r1,$16,$16,%r0\t# 9\t[c=4]  *insv_aligned\n+\tinsv %r1,$16,$16,%r0\t# 9\t[c=4]  *insv_2\n \tret\t\t# 25\t[c=0]  return\n \t.size\tins16, .-ins16\n \t.align 1\n@@ -94,8 +94,9 @@ ext16:\n extz16:\n \t.word 0\t# 18\t[c=0]  procedure_entry_mask\n \tsubl2 $4,%sp\t# 19\t[c=32]  addsi3\n-\tmovl 4(%ap),%r1\t# 2\t[c=16]  movsi_2\n-\textzv $16,$16,%r1,%r0\t# 7\t[c=60]  *extzv_aligned\n+\tmovl 4(%ap),%r0\t# 2\t[c=16]  movsi_2\n+\trotl $16,%r0,%r0\t# 7\t[c=60]  *extzv_non_const\n+\tmovzwl %r0,%r0\n \tmovzwl %r0,%r0\t# 13\t[c=4]  zero_extendhisi2\n \tret\t\t# 23\t[c=0]  return\n \t.size\textz16, .-extz16\n\ndemonstrated with this program:\n\ntypedef struct\n{\n  int f0:1;\n  int f1:7;\n  int f8:8;\n  int f16:16;\n} bit_t;\n\ntypedef struct\n{\n  unsigned int f0:1;\n  unsigned int f1:7;\n  unsigned int f8:8;\n  unsigned int f16:16;\n} ubit_t;\n\ntypedef union\n{\n  bit_t b;\n  int i;\n} bit_u;\n\ntypedef union\n{\n  ubit_t b;\n  unsigned int i;\n} ubit_u;\n\nint\nins1 (bit_u x, int y)\n{\n  asm volatile (\"\" : \"+r\" (x), \"+r\" (y));\n  x.b.f1 = y;\n  return x.i;\n}\n\nint\next1 (bit_u x)\n{\n  asm volatile (\"\" : \"+r\" (x));\n  return x.b.f1;\n}\n\nunsigned int\nextz1 (ubit_u x)\n{\n  asm volatile (\"\" : \"+r\" (x));\n  return x.b.f1;\n}\n\nint\nins8 (bit_u x, int y)\n{\n  asm volatile (\"\" : \"+r\" (x), \"+r\" (y));\n  x.b.f8 = y;\n  return x.i;\n}\n\nint\next8 (bit_u x)\n{\n  asm volatile (\"\" : \"+r\" (x));\n  return x.b.f8;\n}\n\nunsigned int\nextz8 (ubit_u x)\n{\n  asm volatile (\"\" : \"+r\" (x));\n  return x.b.f8;\n}\n\nint\nins16 (bit_u x, int y)\n{\n  asm volatile (\"\" : \"+r\" (x), \"+r\" (y));\n  x.b.f16 = y;\n  return x.i;\n}\n\nint\next16 (bit_u x)\n{\n  asm volatile (\"\" : \"+r\" (x));\n  return x.b.f16;\n}\n\nunsigned int\nextz16 (ubit_u x)\n{\n  asm volatile (\"\" : \"+r\" (x));\n  return x.b.f16;\n}\n\nIt also papers over a regression:\n\nFAIL: gcc.dg/pr83623.c (internal compiler error)\nFAIL: gcc.dg/pr83623.c (test for excess errors)\n\nfrom an ICE like:\n\nduring RTL pass: final\n.../gcc/testsuite/gcc.dg/pr83623.c: In function 'foo':\n.../gcc/testsuite/gcc.dg/pr83623.c:13:1: internal compiler error: in change_address_1, at emit-rtl.c:2275\n0x10a056e3 change_address_1\n\t.../gcc/emit-rtl.c:2275\n0x10a0645f adjust_address_1(rtx_def*, machine_mode, poly_int<1u, long>, int, int, int, poly_int<1u, long>)\n\t.../gcc/emit-rtl.c:2409\n0x11cb588f output_97\n\t.../gcc/config/vax/vax.md:808\n0x10aafb2f get_insn_template(int, rtx_insn*)\n\t.../gcc/final.c:2070\n0x10ab2b3f final_scan_insn_1\n\t.../gcc/final.c:3039\n0x10ab313b final_scan_insn(rtx_insn*, _IO_FILE*, int, int, int*)\n\t.../gcc/final.c:3152\n0x10aaf887 final_1\n\t.../gcc/final.c:2020\n0x10ab703b rest_of_handle_final\n\t.../gcc/final.c:4658\n0x10ab757b execute\n\t.../gcc/final.c:4736\nPlease submit a full bug report,\nwith preprocessed source if appropriate.\nPlease include the complete backtrace with any bug report.\nSee <https://gcc.gnu.org/bugs/> for instructions.\ncompiler exited with status 1\nFAIL: gcc.dg/pr83623.c (internal compiler error)\n\ntriggered by an RTL instruction like:\n\n(insn 17 14 145 (set (reg:SI 1 %r1)\n        (zero_extract:SI (mem/c:SI (symbol_ref:SI (\"x\") <var_decl 0x7ffff7f80120 x>) [1 x+0 S4 A128])\n            (const_int 16 [0x10])\n            (const_int 16 [0x10]))) \".../gcc/testsuite/gcc.dg/pr83623.c\":12:9 97 {*extzv_aligned}\n     (nil))\n\n(where the address cannot be adjusted by 2 for PIC code as requested\nhere as it would create an offset external symbol reference) otherwise\ncaused by the patterns modified here, addressed next.  This indicates\na further rework is warranted here, but at least problems at hand have\nbeen fixed.\n\n\tgcc/\n\t* config/vax/vax.md (*insv_aligned, *extzv_aligned)\n\t(*extv_aligned): Reject register bit-field locations that are not\n\taligned to the least significant bit; update output statement\n\taccordingly.", "tree": {"sha": "7fdfc85f25a9270e1b8f787091c1a9d181a502e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fdfc85f25a9270e1b8f787091c1a9d181a502e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a8de7507e1cfa2e7a16940a1ad93eb339258042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8de7507e1cfa2e7a16940a1ad93eb339258042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8de7507e1cfa2e7a16940a1ad93eb339258042", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8de7507e1cfa2e7a16940a1ad93eb339258042/comments", "author": null, "committer": null, "parents": [{"sha": "4c293413ca53ffa890e369af33db94264493d140", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c293413ca53ffa890e369af33db94264493d140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c293413ca53ffa890e369af33db94264493d140"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "80f09d97727a291300b6f63ecdf1f1e8183d1df5", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8de7507e1cfa2e7a16940a1ad93eb339258042/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8de7507e1cfa2e7a16940a1ad93eb339258042/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=8a8de7507e1cfa2e7a16940a1ad93eb339258042", "patch": "@@ -754,8 +754,8 @@\n \f\n ;; Special cases of bit-field insns which we should\n ;; recognize in preference to the general case.\n-;; These handle aligned 8-bit and 16-bit fields,\n-;; which can usually be done with move instructions.\n+;; These handle aligned 8-bit and 16-bit fields\n+;; that can be done with move or convert instructions.\n \n (define_insn \"*insv_aligned\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+ro\")\n@@ -766,19 +766,19 @@\n    && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n    && (!MEM_P (operands[0])\n        || ! mode_dependent_address_p (XEXP (operands[0], 0),\n-\t\t\t\t       MEM_ADDR_SPACE (operands[0])))\"\n+\t\t\t\t      MEM_ADDR_SPACE (operands[0])))\n+   && (!(REG_P (operands[0])\n+\t || (SUBREG_P (operands[0]) && REG_P (SUBREG_REG (operands[0]))))\n+       || INTVAL (operands[2]) == 0)\"\n   \"*\n {\n-  if (REG_P (operands[0]))\n-    {\n-      if (INTVAL (operands[2]) != 0)\n-\treturn \\\"insv %3,%2,%1,%0\\\";\n-    }\n-  else\n+  if (!REG_P (operands[0]))\n     operands[0]\n       = adjust_address (operands[0],\n \t\t\tINTVAL (operands[1]) == 8 ? QImode : HImode,\n \t\t\tINTVAL (operands[2]) / 8);\n+  else\n+    gcc_assert (INTVAL (operands[2]) == 0);\n \n   CC_STATUS_INIT;\n   if (INTVAL (operands[1]) == 8)\n@@ -795,19 +795,19 @@\n    && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n    && (!MEM_P (operands[1])\n        || ! mode_dependent_address_p (XEXP (operands[1], 0),\n-\t\t\t\t      MEM_ADDR_SPACE (operands[1])))\"\n+\t\t\t\t      MEM_ADDR_SPACE (operands[1])))\n+   && (!(REG_P (operands[1])\n+\t || (SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1]))))\n+       || INTVAL (operands[3]) == 0)\"\n   \"*\n {\n-  if (REG_P (operands[1]))\n-    {\n-      if (INTVAL (operands[3]) != 0)\n-\treturn \\\"extzv %3,%2,%1,%0\\\";\n-    }\n-  else\n+  if (!REG_P (operands[1]))\n     operands[1]\n       = adjust_address (operands[1],\n \t\t\tINTVAL (operands[2]) == 8 ? QImode : HImode,\n \t\t\tINTVAL (operands[3]) / 8);\n+  else\n+    gcc_assert (INTVAL (operands[3]) == 0);\n \n   if (INTVAL (operands[2]) == 8)\n     return \\\"movzbl %1,%0\\\";\n@@ -823,19 +823,19 @@\n    && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n    && (!MEM_P (operands[1])\n        || ! mode_dependent_address_p (XEXP (operands[1], 0),\n-\t\t\t\t      MEM_ADDR_SPACE (operands[1])))\"\n+\t\t\t\t      MEM_ADDR_SPACE (operands[1])))\n+   && (!(REG_P (operands[1])\n+\t || (SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1]))))\n+       || INTVAL (operands[3]) == 0)\"\n   \"*\n {\n-  if (REG_P (operands[1]))\n-    {\n-      if (INTVAL (operands[3]) != 0)\n-\treturn \\\"extv %3,%2,%1,%0\\\";\n-    }\n-  else\n+  if (!REG_P (operands[1]))\n     operands[1]\n       = adjust_address (operands[1],\n \t\t\tINTVAL (operands[2]) == 8 ? QImode : HImode,\n \t\t\tINTVAL (operands[3]) / 8);\n+  else\n+    gcc_assert (INTVAL (operands[3]) == 0);\n \n   if (INTVAL (operands[2]) == 8)\n     return \\\"cvtbl %1,%0\\\";"}]}