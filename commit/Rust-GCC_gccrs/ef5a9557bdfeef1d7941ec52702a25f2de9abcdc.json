{"sha": "ef5a9557bdfeef1d7941ec52702a25f2de9abcdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY1YTk1NTdiZGZlZWYxZDc5NDFlYzUyNzAyYTI1ZjJkZTlhYmNkYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-09-23T08:08:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-09-23T08:08:08Z"}, "message": "trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep on the underlying type of the node.\n\n\t* gcc-interface/trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep\n\ton the underlying type of the node.\n\t(Call_to_gnu): Likewise with the type of the prefix.\n\nFrom-SVN: r276041", "tree": {"sha": "0d5d8b6f6ed0fd3a3a462e9d4df11defd6f08a89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d5d8b6f6ed0fd3a3a462e9d4df11defd6f08a89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc/comments", "author": null, "committer": null, "parents": [{"sha": "fdfa0e44b7e5bbf319634a2d51cc7fbfb7aae27a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfa0e44b7e5bbf319634a2d51cc7fbfb7aae27a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdfa0e44b7e5bbf319634a2d51cc7fbfb7aae27a"}], "stats": {"total": 54, "additions": 29, "deletions": 25}, "files": [{"sha": "f74e8bb352455488429bf05616ac19a2719e0b28", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ef5a9557bdfeef1d7941ec52702a25f2de9abcdc", "patch": "@@ -1,3 +1,9 @@\n+2019-09-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep\n+\ton the underlying type of the node.\n+\t(Call_to_gnu): Likewise with the type of the prefix.\n+\n 2019-09-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (components_to_record): Do not reorder fields"}, {"sha": "1af477f9924e479e3f575253da038f2a57f4b14d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef5a9557bdfeef1d7941ec52702a25f2de9abcdc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ef5a9557bdfeef1d7941ec52702a25f2de9abcdc", "patch": "@@ -2254,32 +2254,29 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* For other address attributes applied to a nested function,\n \t find an inner ADDR_EXPR and annotate it so that we can issue\n \t a useful warning with -Wtrampolines.  */\n-      else if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_prefix)))\n+      else if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_prefix))\n+\t       && (gnu_expr = remove_conversions (gnu_result, false))\n+\t       && TREE_CODE (gnu_expr) == ADDR_EXPR\n+\t       && decl_function_context (TREE_OPERAND (gnu_expr, 0)))\n \t{\n-\t  gnu_expr = remove_conversions (gnu_result, false);\n+\t  set_expr_location_from_node (gnu_expr, gnat_node);\n \n-\t  if (TREE_CODE (gnu_expr) == ADDR_EXPR\n-\t      && decl_function_context (TREE_OPERAND (gnu_expr, 0)))\n-\t    {\n-\t      set_expr_location_from_node (gnu_expr, gnat_node);\n-\n-\t      /* Also check the inlining status.  */\n-\t      check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));\n-\n-\t      /* Moreover, for 'Access or 'Unrestricted_Access with non-\n-\t\t foreign-compatible representation, mark the ADDR_EXPR so\n-\t\t that we can build a descriptor instead of a trampoline.  */\n-\t      if ((attribute == Attr_Access\n-\t\t   || attribute == Attr_Unrestricted_Access)\n-\t\t  && targetm.calls.custom_function_descriptors > 0\n-\t\t  && Can_Use_Internal_Rep (Etype (gnat_node)))\n-\t\tFUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;\n-\n-\t      /* Otherwise, we need to check that we are not violating the\n-\t\t No_Implicit_Dynamic_Code restriction.  */\n-\t      else if (targetm.calls.custom_function_descriptors != 0)\n-\t        Check_Implicit_Dynamic_Code_Allowed (gnat_node);\n-\t    }\n+\t  /* Also check the inlining status.  */\n+\t  check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));\n+\n+\t  /* Moreover, for 'Access or 'Unrestricted_Access with non-\n+\t     foreign-compatible representation, mark the ADDR_EXPR so\n+\t     that we can build a descriptor instead of a trampoline.  */\n+\t  if ((attribute == Attr_Access\n+\t       || attribute == Attr_Unrestricted_Access)\n+\t      && targetm.calls.custom_function_descriptors > 0\n+\t      && Can_Use_Internal_Rep (Underlying_Type (Etype (gnat_node))))\n+\t    FUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;\n+\n+\t  /* Otherwise, we need to check that we are not violating the\n+\t     No_Implicit_Dynamic_Code restriction.  */\n+\t  else if (targetm.calls.custom_function_descriptors != 0)\n+\t    Check_Implicit_Dynamic_Code_Allowed (gnat_node);\n \t}\n       break;\n \n@@ -5111,7 +5108,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       /* If the access type doesn't require foreign-compatible representation,\n \t be prepared for descriptors.  */\n       if (targetm.calls.custom_function_descriptors > 0\n-\t  && Can_Use_Internal_Rep (Etype (Prefix (Name (gnat_node)))))\n+\t  && Can_Use_Internal_Rep\n+\t     (Underlying_Type (Etype (Prefix (Name (gnat_node))))))\n \tby_descriptor = true;\n     }\n   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)"}]}