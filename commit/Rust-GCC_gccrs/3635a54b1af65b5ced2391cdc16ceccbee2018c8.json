{"sha": "3635a54b1af65b5ced2391cdc16ceccbee2018c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYzNWE1NGIxYWY2NWI1Y2VkMjM5MWNkYzE2Y2VjY2JlZTIwMThjOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:43:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:43:02Z"}, "message": "(DECL_QUALIFIER): New access macro for decl.initial.\n\nFrom-SVN: r4116", "tree": {"sha": "ac2ca41e385361c2ca10337c2c90edcdd1adb5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac2ca41e385361c2ca10337c2c90edcdd1adb5e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3635a54b1af65b5ced2391cdc16ceccbee2018c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3635a54b1af65b5ced2391cdc16ceccbee2018c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3635a54b1af65b5ced2391cdc16ceccbee2018c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3635a54b1af65b5ced2391cdc16ceccbee2018c8/comments", "author": null, "committer": null, "parents": [{"sha": "08703ee42389bed934a8529f4a16f56b061f36c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08703ee42389bed934a8529f4a16f56b061f36c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08703ee42389bed934a8529f4a16f56b061f36c6"}], "stats": {"total": 22, "additions": 13, "deletions": 9}, "files": [{"sha": "a288c1da9e737a30bb8f9a4d3c6c3621f48edb9d", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3635a54b1af65b5ced2391cdc16ceccbee2018c8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3635a54b1af65b5ced2391cdc16ceccbee2018c8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3635a54b1af65b5ced2391cdc16ceccbee2018c8", "patch": "@@ -305,7 +305,7 @@ struct tree_common\n    Nonzero in a FUNCTION_DECL means that the function has been compiled.\n    This is interesting in an inline function, since it might not need\n    to be compiled separately.\n-   Nonzero in a RECORD_TYPE, UNION_TYPE or ENUMERAL_TYPE\n+   Nonzero in a RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ENUMERAL_TYPE\n    if the sdb debugging info for the type has been written.\n    In a BLOCK node, nonzero if reorder_blocks has already seen this block.  */\n #define TREE_ASM_WRITTEN(NODE) ((NODE)->common.asm_written_flag)\n@@ -544,8 +544,9 @@ struct tree_block\n \n #define TYPE_STUB_DECL(NODE) (TREE_CHAIN (NODE))\n \n-/* In a RECORD_TYPE or UNION_TYPE, it means the type has BLKmode\n-   only because it lacks the alignment requirement for its size.  */\n+/* In a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, it means the type\n+   has BLKmode only because it lacks the alignment requirement for\n+   its size.  */\n #define TYPE_NO_FORCE_BLK(NODE) ((NODE)->type.no_force_blk_flag)\n \n /* Nonzero in a type considered volatile as a whole.  */\n@@ -693,10 +694,10 @@ struct tree_type\n    It is an IDENTIFIER_NODE.  */\n #define DECL_ASSEMBLER_NAME(NODE) ((NODE)->decl.assembler_name)\n /*  For FIELD_DECLs, this is the\n-    RECORD_TYPE or UNION_TYPE node that the field is a member of.  For\n-    VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL, and CONST_DECL nodes,\n-    this points to the FUNCTION_DECL for the containing function, or else\n-    yields NULL_TREE if the given decl has \"file scope\".  */\n+    RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node that the field is\n+    a member of.  For VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL,\n+    and CONST_DECL nodes, this points to the FUNCTION_DECL for the\n+    containing function, or else yields NULL_TREE if the given decl has \"file scope\".  */\n #define DECL_CONTEXT(NODE) ((NODE)->decl.context)\n #define DECL_FIELD_CONTEXT(NODE) ((NODE)->decl.context)\n /* In a FIELD_DECL, this is the field position, counting in bits,\n@@ -723,6 +724,9 @@ struct tree_type\n /* For a PARM_DECL, records the data type used to pass the argument,\n    which may be different from the type seen in the program.  */\n #define DECL_ARG_TYPE(NODE) ((NODE)->decl.initial)   /* In PARM_DECL.  */\n+/* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which\n+   if nonzero, indicates that the field occupies the type.  */\n+#define DECL_QUALIFIER(NODE) ((NODE)->decl.initial)\n /* These two fields describe where in the source code the declaration was.  */\n #define DECL_SOURCE_FILE(NODE) ((NODE)->decl.filename)\n #define DECL_SOURCE_LINE(NODE) ((NODE)->decl.linenum)\n@@ -1291,8 +1295,8 @@ extern tree get_inner_reference\t\tPROTO((tree, int *, int *, tree *, enum machine\n    or zero if none.  */\n extern tree decl_function_context \tPROTO((tree));\n \n-/* Return the RECORD_TYPE or UNION_TYPE which provides this _DECL\n-   with its context, or zero if none.  */\n+/* Return the RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE which provides\n+   this _DECL with its context, or zero if none.  */\n extern tree decl_type_context\t\tPROTO((tree));\n \n /* Given the FUNCTION_DECL for the current function,"}]}