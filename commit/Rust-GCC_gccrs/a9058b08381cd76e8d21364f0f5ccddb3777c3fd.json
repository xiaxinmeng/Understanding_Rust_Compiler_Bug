{"sha": "a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "node_id": "C_kwDOANBUbNoAKGE5MDU4YjA4MzgxY2Q3NmU4ZDIxMzY0ZjBmNWNjZGRiMzc3N2MzZmQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-05-31T12:04:51Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-03T08:31:00Z"}, "message": "Implement vrange::supports_type_p.\n\n[I have conservatively assumed that both the loop-ch and loop-unswitch\npasses, which also use the ranger, only support integers and pointers.\nIf the goal is to handle other types as well, irange::supports_p()\nshould be Value_Range::supports_type_p(), and any uses of\nint_range_max should be converted to Value_Range.  I can help in the\nconversion if you'd like.]\n\nAs discussed, this patch disambiguates the use of supports_type_p\nthroughout, as what ranger supports is a totally different question\nthan what a given range variant (irange, frange, etc) supports.\n\nUnfortunately we need both a static method and a virtual method, and\nthey can't be named the same.  The uses are documented in the vrange\nclass:\n\n+// To query what types ranger and the entire ecosystem can support,\n+// use Value_Range::supports_type_p(tree type).  This is a static\n+// method available independently of any vrange object.\n+//\n+// To query what a given vrange variant can support, use:\n+//    irange::supports_p ()\n+//    frange::supports_p ()\n+//    etc\n+//\n+// To query what a range object can support, use:\n+//    void foo (vrange &v, irange &i, frange &f)\n+//    {\n+//     if (v.supports_type_p (type)) ...\n+//     if (i.supports_type_p (type)) ...\n+//     if (f.supports_type_p (type)) ...\n+//    }\n\nThe value_range_equiv::supports_p() method can be use to determine\nwhat legacy VRP supports, as irange::supports_p() will no longer be\napplicable in the evrp analyzer code base once irange and prange are\nsplit.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-edge.cc (gimple_outgoing_range_stmt_p): Adjust for\n\tan object level supports_type_p for irange and a static\n\tValue_Range::supports_type_p.\n\t* gimple-range-fold.cc (fold_using_range::range_of_range_op): Same.\n\t(fold_using_range::range_of_address): Same.\n\t(fold_using_range::range_of_builtin_call): Same.\n\t* gimple-range-fold.h (gimple_range_type): Same.\n\t(gimple_range_ssa_p): Same.\n\t* gimple-range-path.cc (path_range_query::internal_range_of_expr):\n\tSame.\n\t(path_range_query::range_of_stmt): Same.\n\t(path_range_query::add_to_imports): Same.\n\t* gimple-range.cc (gimple_ranger::range_on_edge): Same.\n\t(gimple_ranger::export_global_ranges): Same.\n\t* gimple-ssa-evrp-analyze.cc\n\t(evrp_range_analyzer::record_ranges_from_phis):  Same.\n\t* range-op.cc (range_operator::wi_fold): Same.\n\t(range_operator::fold_range): Same.\n\t* tree-ssa-loop-ch.cc (entry_loop_condition_is_static): Same.\n\t* tree-ssa-loop-unswitch.cc (struct unswitch_predicate): Same.\n\t(evaluate_control_stmt_using_entry_checks): Same.\n\t* tree-ssa-threadedge.cc\n\t(hybrid_jt_simplifier::compute_ranges_from_state): Same.\n\t* tree-vrp.cc (supported_types_p): Same.\n\t* value-query.cc (range_query::value_of_expr): Same.\n\t(range_query::value_on_edge): Same.\n\t(range_query::value_of_stmt): Same.\n\t(range_query::get_tree_range): Same.\n\t(get_range_global): Same.\n\t(global_range_query::range_of_expr): Same.\n\t* value-range-equiv.h (class value_range_equiv): Same.\n\t* value-range.cc (irange::supports_type_p): Same.\n\t(unsupported_range::supports_type_p): Same.\n\t* value-range.h (enum value_range_discriminator): Same.\n\t(Value_Range::init): Same.\n\t(Value_Range::supports_type_p): Same.\n\t(irange::supports_type_p): Same.\n\t(irange::supports_p): Same.\n\t(vrange::supports_type_p): Same.\n\t(vrange_allocator::alloc_vrange): Same.", "tree": {"sha": "cb3cfd141bec388bc0fbb13edb34cbc44f76676f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb3cfd141bec388bc0fbb13edb34cbc44f76676f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6124f4248888484f419671f4f7bd40d253d3de06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6124f4248888484f419671f4f7bd40d253d3de06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6124f4248888484f419671f4f7bd40d253d3de06"}], "stats": {"total": 119, "additions": 76, "deletions": 43}, "files": [{"sha": "03a804ac2bec89d0329aafe1ab2adbedbbd6a073", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -44,8 +44,7 @@ gimple_outgoing_range_stmt_p (basic_block bb)\n       gimple *s = gsi_stmt (gsi);\n       if (is_a<gcond *> (s) && range_op_handler (s))\n \treturn gsi_stmt (gsi);\n-      gswitch *sw = dyn_cast<gswitch *> (s);\n-      if (sw && irange::supports_type_p (TREE_TYPE (gimple_switch_index (sw))))\n+      if (is_a <gswitch *> (s))\n \treturn gsi_stmt (gsi);\n     }\n   return NULL;"}, {"sha": "2a8c66e0c0515ac98306ca8a42e14c25d32c2070", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -632,7 +632,7 @@ fold_using_range::range_of_range_op (vrange &r, gimple *s, fur_source &src)\n \t    }\n \t  // Fold range, and register any dependency if available.\n \t  handler.fold_range (r, type, range1, range2, rel);\n-\t  if (irange::supports_type_p (type))\n+\t  if (irange::supports_p (type))\n \t    relation_fold_and_or (as_a <irange> (r), s, src);\n \t  if (lhs)\n \t    {\n@@ -709,7 +709,6 @@ fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n       tree lhs = gimple_get_lhs (stmt);\n       if (lhs && gimple_range_ssa_p (ssa) && src.gori ())\n \tsrc.gori ()->register_dependency (lhs, ssa);\n-      gcc_checking_assert (irange::supports_type_p (TREE_TYPE (ssa)));\n       src.get_operand (r, ssa);\n       range_cast (r, TREE_TYPE (gimple_assign_rhs1 (stmt)));\n \n@@ -985,7 +984,7 @@ fold_using_range::range_of_builtin_call (vrange &r, gcall *call,\n   tree type = gimple_range_type (call);\n   gcc_checking_assert (type);\n \n-  if (irange::supports_type_p (type))\n+  if (irange::supports_p (type))\n     return range_of_builtin_int_call (as_a <irange> (r), call, src);\n \n   return false;"}, {"sha": "fbf66275f741bea384529c9cfe087b197ecd10e4", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -66,7 +66,7 @@ gimple_range_type (const gimple *s)\n \t    type = TREE_TYPE (type);\n \t}\n     }\n-  if (type && vrange::supports_type_p (type))\n+  if (type && Value_Range::supports_type_p (type))\n     return type;\n   return NULL_TREE;\n }\n@@ -79,7 +79,7 @@ gimple_range_ssa_p (tree exp)\n   if (exp && TREE_CODE (exp) == SSA_NAME &&\n       !SSA_NAME_IS_VIRTUAL_OPERAND (exp) &&\n       !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (exp) &&\n-      vrange::supports_type_p (TREE_TYPE (exp)))\n+      Value_Range::supports_type_p (TREE_TYPE (exp)))\n     return exp;\n   return NULL_TREE;\n }"}, {"sha": "e1b9683c1e4dac6887fb022d15bbaa10d22e101f", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -192,7 +192,7 @@ path_range_query::range_on_path_entry (vrange &r, tree name)\n bool\n path_range_query::internal_range_of_expr (vrange &r, tree name, gimple *stmt)\n {\n-  if (!vrange::supports_type_p (TREE_TYPE (name)))\n+  if (!r.supports_type_p (TREE_TYPE (name)))\n     return false;\n \n   if (get_cache (r, name))\n@@ -548,7 +548,7 @@ bool\n path_range_query::add_to_imports (tree name, bitmap imports)\n {\n   if (TREE_CODE (name) == SSA_NAME\n-      && vrange::supports_type_p (TREE_TYPE (name)))\n+      && Value_Range::supports_type_p (TREE_TYPE (name)))\n     return bitmap_set_bit (imports, SSA_NAME_VERSION (name));\n   return false;\n }\n@@ -764,7 +764,7 @@ path_range_query::range_of_stmt (vrange &r, gimple *stmt, tree)\n {\n   tree type = gimple_range_type (stmt);\n \n-  if (!type || !vrange::supports_type_p (type))\n+  if (!type || !r.supports_type_p (type))\n     return false;\n \n   // If resolving unknowns, fold the statement making use of any"}, {"sha": "67dafb2a2c01416e70f5f78dae82f78e188aa880", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -201,7 +201,7 @@ bool\n gimple_ranger::range_on_edge (vrange &r, edge e, tree name)\n {\n   Value_Range edge_range (TREE_TYPE (name));\n-  gcc_checking_assert (vrange::supports_type_p (TREE_TYPE (name)));\n+  gcc_checking_assert (r.supports_type_p (TREE_TYPE (name)));\n \n   // Do not process values along abnormal edges.\n   if (e->flags & EDGE_ABNORMAL)\n@@ -514,7 +514,7 @@ gimple_ranger::export_global_ranges ()\n \t      print_header = false;\n \t    }\n \n-\t  if (!irange::supports_type_p (TREE_TYPE (name)))\n+\t  if (!irange::supports_p (TREE_TYPE (name)))\n \t    continue;\n \n \t  vrange &v = r;"}, {"sha": "82142db7976c453ab53d860eb9c780fab2898780", "filename": "gcc/gimple-ssa-evrp-analyze.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-ssa-evrp-analyze.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fgimple-ssa-evrp-analyze.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -255,7 +255,7 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n \n       /* Skips floats and other things we can't represent in a\n \t range.  */\n-      if (!value_range::supports_type_p (TREE_TYPE (lhs)))\n+      if (!value_range_equiv::supports_p (TREE_TYPE (lhs)))\n \tcontinue;\n \n       value_range_equiv vr_result;"}, {"sha": "5150c6021b838432e3069aaa58cbccd567220d29", "filename": "gcc/range-op.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -111,7 +111,7 @@ range_operator::wi_fold (irange &r, tree type,\n \t\t\t const wide_int &rh_lb ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &rh_ub ATTRIBUTE_UNUSED) const\n {\n-  gcc_checking_assert (irange::supports_type_p (type));\n+  gcc_checking_assert (r.supports_type_p (type));\n   r.set_varying (type);\n }\n \n@@ -181,7 +181,7 @@ range_operator::fold_range (irange &r, tree type,\n \t\t\t    const irange &rh,\n \t\t\t    relation_kind rel) const\n {\n-  gcc_checking_assert (irange::supports_type_p (type));\n+  gcc_checking_assert (r.supports_type_p (type));\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n "}, {"sha": "26d96c0c21ade565a9e90667745c8ad811ad9156", "filename": "gcc/tree-ssa-loop-ch.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-ssa-loop-ch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-ssa-loop-ch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -55,7 +55,7 @@ entry_loop_condition_is_static (class loop *l, path_range_query *query)\n   gcond *last = safe_dyn_cast <gcond *> (last_stmt (e->dest));\n \n   if (!last\n-      || !irange::supports_type_p (TREE_TYPE (gimple_cond_lhs (last))))\n+      || !irange::supports_p (TREE_TYPE (gimple_cond_lhs (last))))\n     return false;\n \n   edge true_e, false_e;"}, {"sha": "50b66c13038bf07bd42ff1662e84ff5267378992", "filename": "gcc/tree-ssa-loop-unswitch.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-ssa-loop-unswitch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-ssa-loop-unswitch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -113,7 +113,7 @@ struct unswitch_predicate\n       true_range (edge_range), edge_index (edge_index_), switch_p (true)\n   {\n     gcc_assert (!(e->flags & (EDGE_TRUE_VALUE|EDGE_FALSE_VALUE))\n-\t\t&& irange::supports_type_p (TREE_TYPE (lhs)));\n+\t\t&& irange::supports_p (TREE_TYPE (lhs)));\n     false_range = true_range;\n     if (!false_range.varying_p ()\n \t&& !false_range.undefined_p ())\n@@ -134,7 +134,7 @@ struct unswitch_predicate\n     tree rhs = gimple_cond_rhs (stmt);\n     enum tree_code code = gimple_cond_code (stmt);\n     condition = build2 (code, boolean_type_node, lhs, rhs);\n-    if (irange::supports_type_p (TREE_TYPE (lhs)))\n+    if (irange::supports_p (TREE_TYPE (lhs)))\n       {\n \tauto range_op = range_op_handler (code, TREE_TYPE (lhs));\n \tint_range<2> rhs_range (TREE_TYPE (rhs));\n@@ -646,7 +646,7 @@ evaluate_control_stmt_using_entry_checks (gimple *stmt,\n \t\t\t      TREE_OPERAND (last_predicate->condition, 1)))\n \treturn true_edge ? boolean_true_node : boolean_false_node;\n       /* Else try ranger if it supports LHS.  */\n-      else if (irange::supports_type_p (TREE_TYPE (lhs)))\n+      else if (irange::supports_p (TREE_TYPE (lhs)))\n \t{\n \t  int_range<2> r;\n \t  int_range_max path_range;"}, {"sha": "a70aebd10a7e3b58d59f73f32e48df512d439bd5", "filename": "gcc/tree-ssa-threadedge.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-ssa-threadedge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-ssa-threadedge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -1452,7 +1452,7 @@ hybrid_jt_simplifier::compute_ranges_from_state (gimple *stmt, jt_state *state)\n \t  tree op = gimple_op (stmt, i);\n \t  if (op\n \t      && TREE_CODE (op) == SSA_NAME\n-\t      && irange::supports_type_p (TREE_TYPE (op)))\n+\t      && Value_Range::supports_type_p (TREE_TYPE (op)))\n \t    bitmap_set_bit (imports, SSA_NAME_VERSION (op));\n \t}\n     }"}, {"sha": "30022dac1080f0f03549fdd5dbc2a018d5f9c6f4", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -932,8 +932,8 @@ supported_types_p (value_range *vr,\n \t\t   tree type0,\n \t\t   tree type1 = NULL)\n {\n-  if (!value_range::supports_type_p (type0)\n-      || (type1 && !value_range::supports_type_p (type1)))\n+  if (!value_range_equiv::supports_p (type0)\n+      || (type1 && !value_range_equiv::supports_p (type1)))\n     {\n       vr->set_varying (type0);\n       return false;"}, {"sha": "1d7541ce34fdc44b13fd87e772ac34ae47e54554", "filename": "gcc/value-query.cc", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -80,7 +80,7 @@ range_query::value_of_expr (tree expr, gimple *stmt)\n {\n   tree t;\n \n-  if (!vrange::supports_type_p (TREE_TYPE (expr)))\n+  if (!Value_Range::supports_type_p (TREE_TYPE (expr)))\n     return NULL_TREE;\n \n   Value_Range r (TREE_TYPE (expr));\n@@ -102,7 +102,7 @@ range_query::value_on_edge (edge e, tree expr)\n {\n   tree t;\n \n-  if (!vrange::supports_type_p (TREE_TYPE (expr)))\n+  if (!Value_Range::supports_type_p (TREE_TYPE (expr)))\n     return NULL_TREE;\n   Value_Range r (TREE_TYPE (expr));\n   if (range_on_edge (r, e, expr))\n@@ -128,7 +128,7 @@ range_query::value_of_stmt (gimple *stmt, tree name)\n \n   gcc_checking_assert (!name || name == gimple_get_lhs (stmt));\n \n-  if (!name || !vrange::supports_type_p (TREE_TYPE (name)))\n+  if (!name || !Value_Range::supports_type_p (TREE_TYPE (name)))\n     return NULL_TREE;\n   Value_Range r (TREE_TYPE (name));\n   if (range_of_stmt (r, stmt, name) && r.singleton_p (&t))\n@@ -196,7 +196,7 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n   else\n     type = TREE_TYPE (expr);\n \n-  if (!vrange::supports_type_p (type))\n+  if (!Value_Range::supports_type_p (type))\n     {\n       r.set_undefined ();\n       return false;\n@@ -252,7 +252,7 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n     {\n       range_op_handler op (TREE_CODE (expr), type);\n       tree op0_type = TREE_TYPE (TREE_OPERAND (expr, 0));\n-      if (op && vrange::supports_type_p (op0_type))\n+      if (op && Value_Range::supports_type_p (op0_type))\n \t{\n \t  Value_Range r0 (TREE_TYPE (TREE_OPERAND (expr, 0)));\n \t  Value_Range r1 (type);\n@@ -387,7 +387,7 @@ get_range_global (vrange &r, tree name)\n    }\n   else if (!POINTER_TYPE_P (type) && SSA_NAME_RANGE_INFO (name))\n     {\n-      gcc_checking_assert (irange::supports_type_p (TREE_TYPE (name)));\n+      gcc_checking_assert (irange::supports_p (TREE_TYPE (name)));\n       get_ssa_name_range_info (as_a <irange> (r), name);\n       if (r.undefined_p ())\n \tr.set_varying (type);\n@@ -441,9 +441,7 @@ global_range_query global_ranges;\n bool\n global_range_query::range_of_expr (vrange &r, tree expr, gimple *stmt)\n {\n-  tree type = TREE_TYPE (expr);\n-\n-  if (!irange::supports_type_p (type) || !gimple_range_ssa_p (expr))\n+  if (!gimple_range_ssa_p (expr))\n     return get_tree_range (r, expr, stmt);\n \n   get_range_global (r, expr);"}, {"sha": "0a52d1372a1826cbffc1ae8c0fc8f06212926443", "filename": "gcc/value-range-equiv.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-range-equiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-range-equiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.h?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -67,6 +67,10 @@ class GTY((user)) value_range_equiv : public value_range\n   void deep_copy (const value_range_equiv *);\n   void dump (FILE *) const;\n   void dump () const;\n+  static bool supports_p (tree type)\n+  {\n+    return INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type);\n+  }\n \n  private:\n   /* Deep-copies bitmap argument.  */"}, {"sha": "c4bcb970094f4a8e94088904b4d24c55855e6ada", "filename": "gcc/value-range.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -107,6 +107,12 @@ vrange::operator== (const vrange &src) const\n   gcc_unreachable ();\n }\n \n+bool\n+irange::supports_type_p (tree type) const\n+{\n+  return supports_p (type);\n+}\n+\n // Return TRUE if R fits in THIS.\n \n bool\n@@ -140,6 +146,12 @@ unsupported_range::type () const\n   return nullptr;\n }\n \n+bool\n+unsupported_range::supports_type_p (tree) const\n+{\n+  return false;\n+}\n+\n void\n unsupported_range::set_undefined ()\n {"}, {"sha": "69cf6c304d6a32e5d70af90faeeec82e08b6920e", "filename": "gcc/value-range.h", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9058b08381cd76e8d21364f0f5ccddb3777c3fd/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "patch": "@@ -50,6 +50,23 @@ enum value_range_discriminator\n };\n \n // Abstract class for ranges of any of the supported types.\n+//\n+// To query what types ranger and the entire ecosystem can support,\n+// use Value_Range::supports_type_p(tree type).  This is a static\n+// method available independently of any vrange object.\n+//\n+// To query what a given vrange variant can support, use:\n+//    irange::supports_p ()\n+//    frange::supports_p ()\n+//    etc\n+//\n+// To query what a range object can support, use:\n+//    void foo (vrange &v, irange &i, frange &f)\n+//    {\n+//\tif (v.supports_type_p (type)) ...\n+//\tif (i.supports_type_p (type)) ...\n+//\tif (f.supports_type_p (type)) ...\n+//    }\n \n class vrange\n {\n@@ -58,6 +75,7 @@ class vrange\n public:\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) = 0;\n   virtual tree type () const = 0;\n+  virtual bool supports_type_p (tree type) const = 0;\n   virtual void set_varying (tree type) = 0;\n   virtual void set_undefined () = 0;\n   virtual void dump (FILE * = stderr) const = 0;\n@@ -72,8 +90,6 @@ class vrange\n   virtual void set_nonnegative (tree type) = 0;\n   virtual bool fits_p (const vrange &r) const = 0;\n \n-  static bool supports_type_p (tree);\n-\n   bool varying_p () const;\n   bool undefined_p () const;\n   vrange& operator= (const vrange &);\n@@ -103,7 +119,8 @@ class GTY((user)) irange : public vrange\n   virtual void set_undefined () override;\n \n   // Range types.\n-  static bool supports_type_p (tree);\n+  static bool supports_p (tree type);\n+  virtual bool supports_type_p (tree type) const override;\n   virtual tree type () const override;\n \n   // Iteration over sub-ranges.\n@@ -228,6 +245,7 @@ class unsupported_range : public vrange\n   unsupported_range ();\n   virtual void set (tree, tree, value_range_kind) override;\n   virtual tree type () const override;\n+  virtual bool supports_type_p (tree type) const override;\n   virtual void set_varying (tree type) override;\n   virtual void set_undefined () override;\n   virtual void dump (FILE *) const override;\n@@ -331,6 +349,7 @@ class Value_Range\n   operator vrange &();\n   operator const vrange &() const;\n   void dump (FILE *out = stderr) const;\n+  static bool supports_type_p (tree type);\n \n   // Convenience methods for vrange compatability.\n   void set (tree min, tree max, value_range_kind kind = VR_RANGE)\n@@ -387,7 +406,7 @@ Value_Range::init (tree type)\n {\n   gcc_checking_assert (TYPE_P (type));\n \n-  if (irange::supports_type_p (type))\n+  if (irange::supports_p (type))\n     m_vrange = &m_irange;\n   else\n     m_vrange = &m_unsupported;\n@@ -444,6 +463,14 @@ Value_Range::operator const vrange &() const\n   return *m_vrange;\n }\n \n+// Return TRUE if TYPE is supported by the vrange infrastructure.\n+\n+inline bool\n+Value_Range::supports_type_p (tree type)\n+{\n+  return irange::supports_p (type);\n+}\n+\n // Returns true for an old-school value_range as described above.\n inline bool\n irange::legacy_mode_p () const\n@@ -580,7 +607,7 @@ irange::nonzero_p () const\n }\n \n inline bool\n-irange::supports_type_p (tree type)\n+irange::supports_p (tree type)\n {\n   return INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type);\n }\n@@ -864,12 +891,6 @@ irange::normalize_kind ()\n     }\n }\n \n-inline bool\n-vrange::supports_type_p (tree type)\n-{\n-  return irange::supports_type_p (type);\n-}\n-\n // Return the maximum value for TYPE.\n \n inline tree\n@@ -944,7 +965,7 @@ vrange_allocator::alloc (unsigned bytes)\n inline vrange *\n vrange_allocator::alloc_vrange (tree type)\n {\n-  if (irange::supports_type_p (type))\n+  if (irange::supports_p (type))\n     return alloc_irange (2);\n \n   gcc_unreachable ();"}]}