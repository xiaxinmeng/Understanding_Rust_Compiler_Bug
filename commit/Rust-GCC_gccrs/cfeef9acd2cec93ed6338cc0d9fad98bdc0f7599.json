{"sha": "cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlZWY5YWNkMmNlYzkzZWQ2MzM4Y2MwZDlmYWQ5OGJkYzBmNzU5OQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-02-27T17:43:05Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-02-27T17:44:21Z"}, "message": "ipa-cp: Avoid an ICE processing self-recursive cloned edges (PR 93707)\n\n2020-02-27  Martin Jambor  <mjambor@suse.cz>\n\t    Feng Xue  <fxue@os.amperecomputing.com>\n\n\tPR ipa/93707\n\t* ipa-cp.c (same_node_or_its_all_contexts_clone_p): Replaced with\n\tnew function calls_same_node_or_its_all_contexts_clone_p.\n\t(cgraph_edge_brings_value_p): Use it.\n\t(cgraph_edge_brings_value_p): Likewise.\n\t(self_recursive_pass_through_p): Return false if caller is a clone.\n\t(self_recursive_agg_pass_through_p): Likewise.\n\n\ttestsuite/\n\t* gcc.dg/ipa/pr93707.c: New test.", "tree": {"sha": "923a3a70be0ebf65978d129e41067602a5b4b858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/923a3a70be0ebf65978d129e41067602a5b4b858"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4"}], "stats": {"total": 103, "additions": 79, "deletions": 24}, "files": [{"sha": "38064ccbdb83278e3eb1e5b92e65cf197c2611fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "patch": "@@ -1,3 +1,14 @@\n+2020-02-27  Martin Jambor  <mjambor@suse.cz>\n+\t    Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/93707\n+\t* ipa-cp.c (same_node_or_its_all_contexts_clone_p): Replaced with\n+\tnew function calls_same_node_or_its_all_contexts_clone_p.\n+\t(cgraph_edge_brings_value_p): Use it.\n+\t(cgraph_edge_brings_value_p): Likewise.\n+\t(self_recursive_pass_through_p): Return false if caller is a clone.\n+\t(self_recursive_agg_pass_through_p): Likewise.\n+\n 2020-02-27  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR middle-end/92152"}, {"sha": "27c020b81998823b401d40672c5cc9830abbb490", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "patch": "@@ -4035,15 +4035,25 @@ edge_clone_summary_t::duplicate (cgraph_edge *src_edge, cgraph_edge *dst_edge,\n   src_data->next_clone = dst_edge;\n }\n \n-/* Return true is NODE is DEST or its clone for all contexts.  */\n+/* Return true is CS calls DEST or its clone for all contexts.  When\n+   ALLOW_RECURSION_TO_CLONE is false, also return false for self-recursive\n+   edges from/to an all-context clone.  */\n \n static bool\n-same_node_or_its_all_contexts_clone_p (cgraph_node *node, cgraph_node *dest)\n+calls_same_node_or_its_all_contexts_clone_p (cgraph_edge *cs, cgraph_node *dest,\n+\t\t\t\t\t     bool allow_recursion_to_clone)\n {\n-  if (node == dest)\n+  enum availability availability;\n+  cgraph_node *callee = cs->callee->function_symbol (&availability);\n+\n+  if (availability <= AVAIL_INTERPOSABLE)\n+    return false;\n+  if (callee == dest)\n     return true;\n+  if (!allow_recursion_to_clone && cs->caller == callee)\n+    return false;\n \n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (callee);\n   return info->is_all_contexts_clone && info->ipcp_orig_node == dest;\n }\n \n@@ -4055,11 +4065,8 @@ cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n \t\t\t    cgraph_node *dest, ipcp_value<tree> *dest_val)\n {\n   class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-  enum availability availability;\n-  cgraph_node *real_dest = cs->callee->function_symbol (&availability);\n \n-  if (availability <= AVAIL_INTERPOSABLE\n-      || !same_node_or_its_all_contexts_clone_p (real_dest, dest)\n+  if (!calls_same_node_or_its_all_contexts_clone_p (cs, dest, !src->val)\n       || caller_info->node_dead)\n     return false;\n \n@@ -4078,9 +4085,6 @@ cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n     }\n   else\n     {\n-      /* At the moment we do not propagate over arithmetic jump functions in\n-\t SCCs, so it is safe to detect self-feeding recursive calls in this\n-\t way.  */\n       if (src->val == dest_val)\n \treturn true;\n \n@@ -4115,11 +4119,8 @@ cgraph_edge_brings_value_p (cgraph_edge *cs,\n \t\t\t    ipcp_value<ipa_polymorphic_call_context> *)\n {\n   class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-  enum availability avail;\n-  cgraph_node *real_dest = cs->callee->function_symbol (&avail);\n \n-  if (avail <= AVAIL_INTERPOSABLE\n-      || !same_node_or_its_all_contexts_clone_p (real_dest, dest)\n+  if (!calls_same_node_or_its_all_contexts_clone_p (cs, dest, true)\n       || caller_info->node_dead)\n     return false;\n   if (!src->val)\n@@ -4619,9 +4620,10 @@ create_specialized_node (struct cgraph_node *node,\n   return new_node;\n }\n \n-/* Return true, if JFUNC, which describes a i-th parameter of call CS, is a\n-   pass-through function to itself.  When SIMPLE is true, further check if\n-   JFUNC is a simple no-operation pass-through.  */\n+/* Return true if JFUNC, which describes a i-th parameter of call CS, is a\n+   pass-through function to itself when the cgraph_node involved is not an\n+   IPA-CP clone.  When SIMPLE is true, further check if JFUNC is a simple\n+   no-operation pass-through.  */\n \n static bool\n self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i,\n@@ -4632,15 +4634,18 @@ self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i,\n       && availability > AVAIL_INTERPOSABLE\n       && jfunc->type == IPA_JF_PASS_THROUGH\n       && (!simple || ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n-      && ipa_get_jf_pass_through_formal_id (jfunc) == i)\n+      && ipa_get_jf_pass_through_formal_id (jfunc) == i\n+      && IPA_NODE_REF (cs->caller)\n+      && !IPA_NODE_REF (cs->caller)->ipcp_orig_node)\n     return true;\n   return false;\n }\n \n-/* Return true, if JFUNC, which describes a part of an aggregate represented\n-   or pointed to by the i-th parameter of call CS, is a pass-through function\n-   to itself.  When SIMPLE is true, further check if JFUNC is a simple\n-   no-operation pass-through.  */\n+/* Return true if JFUNC, which describes a part of an aggregate represented or\n+   pointed to by the i-th parameter of call CS, is a pass-through function to\n+   itself when the cgraph_node involved is not an IPA-CP clone..  When\n+   SIMPLE is true, further check if JFUNC is a simple no-operation\n+   pass-through.  */\n \n static bool\n self_recursive_agg_pass_through_p (cgraph_edge *cs, ipa_agg_jf_item *jfunc,\n@@ -4653,7 +4658,9 @@ self_recursive_agg_pass_through_p (cgraph_edge *cs, ipa_agg_jf_item *jfunc,\n       && jfunc->offset == jfunc->value.load_agg.offset\n       && (!simple || jfunc->value.pass_through.operation == NOP_EXPR)\n       && jfunc->value.pass_through.formal_id == i\n-      && useless_type_conversion_p (jfunc->value.load_agg.type, jfunc->type))\n+      && useless_type_conversion_p (jfunc->value.load_agg.type, jfunc->type)\n+      && IPA_NODE_REF (cs->caller)\n+      && !IPA_NODE_REF (cs->caller)->ipcp_orig_node)\n     return true;\n   return false;\n }"}, {"sha": "e606269cfa8a105f6ee5557a0f0df57a72bcbeda", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "patch": "@@ -1,3 +1,9 @@\n+2020-02-27  Martin Jambor  <mjambor@suse.cz>\n+\t    Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/93707\n+\t* gcc.dg/ipa/pr93707.c: New test.\n+\n 2020-02-27  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR middle-end/92152"}, {"sha": "685fae45020b615bf8e4f2443322727840d0632d", "filename": "gcc/testsuite/gcc.dg/ipa/pr93707.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr93707.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr93707.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr93707.c?ref=cfeef9acd2cec93ed6338cc0d9fad98bdc0f7599", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 --param ipa-cp-eval-threshold=1 -fdump-ipa-cp\" } */\n+\n+int foo();\n+int data[100];\n+\n+__attribute__((noinline)) static int recur_fn (int i, int j, int depth)\n+{\n+   if (depth > 10)\n+     return 1;\n+\n+   data[i + j]++;\n+\n+   if (depth & 3)\n+     recur_fn (i, 1, depth + 1);\n+   else\n+     recur_fn (i, j & 1, depth + 1);\n+\n+   foo();\n+\n+   return i + j;\n+}\n+\n+int caller (int v, int depth)\n+{\n+  recur_fn (1, v, depth);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Clone of recur_fn/\" 2 \"cp\" } } */"}]}