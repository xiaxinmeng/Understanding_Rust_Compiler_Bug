{"sha": "4161da12190d52eb1d622354e6ea67f67195c73c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2MWRhMTIxOTBkNTJlYjFkNjIyMzU0ZTZlYTY3ZjY3MTk1YzczYw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-02-20T23:15:00Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-02-20T23:15:00Z"}, "message": "combine.c (do_SUBST): Sanity check substitutions of CONST_INTs...\n\n* combine.c (do_SUBST): Sanity check substitutions of\nCONST_INTs, and reject them in SUBREGs and ZERO_EXTENDs.\n(subst): Simplify SUBREG or ZERO_EXTEND instead of SUBSTing a\nCONST_INT into its operand.\n(known_cond): Likewise, for ZERO_EXTEND.\n* simplify-rtx.c (simplify_unary_operation): Fix condition to\nallow for simplification of wide modes.  Reject CONST_INTs in\nZERO_EXTEND when their actual mode is not given.\n\nFrom-SVN: r49920", "tree": {"sha": "55c3d095668c86b8d785d6a6b95f142a8823cd52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55c3d095668c86b8d785d6a6b95f142a8823cd52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4161da12190d52eb1d622354e6ea67f67195c73c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4161da12190d52eb1d622354e6ea67f67195c73c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4161da12190d52eb1d622354e6ea67f67195c73c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4161da12190d52eb1d622354e6ea67f67195c73c/comments", "author": null, "committer": null, "parents": [{"sha": "8e8d61f5c1ddd2e55ae3c32347af851eaeb83e0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8d61f5c1ddd2e55ae3c32347af851eaeb83e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8d61f5c1ddd2e55ae3c32347af851eaeb83e0a"}], "stats": {"total": 95, "additions": 90, "deletions": 5}, "files": [{"sha": "7a64a64af8aafb60d5815fe0e8653237abf5453f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4161da12190d52eb1d622354e6ea67f67195c73c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4161da12190d52eb1d622354e6ea67f67195c73c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4161da12190d52eb1d622354e6ea67f67195c73c", "patch": "@@ -1,3 +1,14 @@\n+2002-02-20  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* combine.c (do_SUBST): Sanity check substitutions of\n+\tCONST_INTs, and reject them in SUBREGs and ZERO_EXTENDs.\n+\t(subst): Simplify SUBREG or ZERO_EXTEND instead of SUBSTing a\n+\tCONST_INT into its operand.\n+\t(known_cond): Likewise, for ZERO_EXTEND.\n+\t* simplify-rtx.c (simplify_unary_operation): Fix condition to\n+\tallow for simplification of wide modes.  Reject CONST_INTs in\n+\tZERO_EXTEND when their actual mode is not given.\n+\n 2002-02-20  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* c-decl.c (pushdecl): If no global declaration is found for an"}, {"sha": "dba799766edfb1ee7f9d96a0835ad91db3da59bc", "filename": "gcc/combine.c", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4161da12190d52eb1d622354e6ea67f67195c73c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4161da12190d52eb1d622354e6ea67f67195c73c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4161da12190d52eb1d622354e6ea67f67195c73c", "patch": "@@ -424,6 +424,33 @@ do_SUBST (into, newval)\n   if (oldval == newval)\n     return;\n \n+  /* We'd like to catch as many invalid transformations here as\n+     possible.  Unfortunately, there are way too many mode changes\n+     that are perfectly valid, so we'd waste too much effort for\n+     little gain doing the checks here.  Focus on catching invalid\n+     transformations involving integer constants.  */\n+  if (GET_MODE_CLASS (GET_MODE (oldval)) == MODE_INT\n+      && GET_CODE (newval) == CONST_INT)\n+    {\n+      /* Sanity check that we're replacing oldval with a CONST_INT\n+\t that is a valid sign-extension for the original mode.  */\n+      if (INTVAL (newval) != trunc_int_for_mode (INTVAL (newval),\n+\t\t\t\t\t\t GET_MODE (oldval)))\n+\tabort ();\n+\n+      /* Replacing the operand of a SUBREG or a ZERO_EXTEND with a\n+\t CONST_INT is not valid, because after the replacement, the\n+\t original mode would be gone.  Unfortunately, we can't tell\n+\t when do_SUBST is called to replace the operand thereof, so we\n+\t perform this test on oldval instead, checking whether an\n+\t invalid replacement took place before we got here.  */\n+      if ((GET_CODE (oldval) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (oldval)) == CONST_INT)\n+\t  || (GET_CODE (oldval) == ZERO_EXTEND\n+\t      && GET_CODE (XEXP (oldval, 0)) == CONST_INT))\n+\tabort ();\n+     }\n+\n   if (undobuf.frees)\n     buf = undobuf.frees, undobuf.frees = buf->next;\n   else\n@@ -3505,7 +3532,24 @@ subst (x, from, to, in_dest, unique_copy)\n \t      if (GET_CODE (new) == CLOBBER && XEXP (new, 0) == const0_rtx)\n \t\treturn new;\n \n-\t      SUBST (XEXP (x, i), new);\n+\t      if (GET_CODE (new) == CONST_INT && GET_CODE (x) == SUBREG)\n+\t\t{\n+\t\t  x = simplify_subreg (GET_MODE (x), new,\n+\t\t\t\t       GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t       SUBREG_BYTE (x));\n+\t\t  if (! x)\n+\t\t    abort ();\n+\t\t}\n+\t      else if (GET_CODE (new) == CONST_INT\n+\t\t       && GET_CODE (x) == ZERO_EXTEND)\n+\t\t{\n+\t\t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n+\t\t\t\t\t\tnew, GET_MODE (XEXP (x, 0)));\n+\t\t  if (! x)\n+\t\t    abort ();\n+\t\t}\n+\t      else\n+\t\tSUBST (XEXP (x, i), new);\n \t    }\n \t}\n     }\n@@ -7449,6 +7493,31 @@ known_cond (x, cond, reg, val)\n \n       return x;\n     }\n+  /* We don't have to handle SIGN_EXTEND here, because even in the\n+     case of replacing something with a modeless CONST_INT, a\n+     CONST_INT is already (supposed to be) a valid sign extension for\n+     its narrower mode, which implies it's already properly\n+     sign-extended for the wider mode.  Now, for ZERO_EXTEND, the\n+     story is different.  */\n+  else if (code == ZERO_EXTEND)\n+    {\n+      enum machine_mode inner_mode = GET_MODE (XEXP (x, 0));\n+      rtx new, r = known_cond (XEXP (x, 0), cond, reg, val);\n+\n+      if (XEXP (x, 0) != r)\n+\t{\n+\t  /* We must simplify the zero_extend here, before we lose\n+             track of the original inner_mode.  */\n+\t  new = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n+\t\t\t\t\t  r, inner_mode);\n+\t  if (new)\n+\t    return new;\n+\t  else\n+\t    SUBST (XEXP (x, 0), r);\n+\t}\n+\n+      return x;\n+    }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)"}, {"sha": "84b8cb240cebcb38dfe2b92e496d7d010c3200d0", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4161da12190d52eb1d622354e6ea67f67195c73c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4161da12190d52eb1d622354e6ea67f67195c73c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=4161da12190d52eb1d622354e6ea67f67195c73c", "patch": "@@ -528,8 +528,10 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  break;\n \n \tcase ZERO_EXTEND:\n+\t  /* When zero-extending a CONST_INT, we need to know its\n+             original mode.  */\n \t  if (op_mode == VOIDmode)\n-\t    op_mode = mode;\n+\t    abort ();\n \t  if (GET_MODE_BITSIZE (op_mode) == HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      /* If we were really extending the mode,\n@@ -587,7 +589,8 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n   /* We can do some operations on integer CONST_DOUBLEs.  Also allow\n      for a DImode operation on a CONST_INT.  */\n-  else if (GET_MODE (trueop) == VOIDmode && width <= HOST_BITS_PER_INT * 2\n+  else if (GET_MODE (trueop) == VOIDmode\n+\t   && width <= HOST_BITS_PER_WIDE_INT * 2\n \t   && (GET_CODE (trueop) == CONST_DOUBLE\n \t       || GET_CODE (trueop) == CONST_INT))\n     {\n@@ -631,8 +634,10 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  break;\n \n \tcase ZERO_EXTEND:\n-\t  if (op_mode == VOIDmode\n-\t      || GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_WIDE_INT)\n+\t  if (op_mode == VOIDmode)\n+\t    abort ();\n+\n+\t  if (GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_WIDE_INT)\n \t    return 0;\n \n \t  hv = 0;"}]}