{"sha": "011f5e92f8ff87f099ed0aae736e79be20a77c6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDExZjVlOTJmOGZmODdmMDk5ZWQwYWFlNzM2ZTc5YmUyMGE3N2M2Yw==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-02T14:39:24Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-02T14:39:24Z"}, "message": "arm: Improve thumb1_gen_const_int\n\nEnable thumb1_gen_const_int to generate RTL or asm depending on the\ncontext, so that we avoid duplicating code to handle constants in\nThumb-1 with -mpure-code.\n\nUse a template so that the algorithm is effectively shared, and\nrely on two classes to handle the actual emission as RTL or asm.\n\nThe generated sequence is improved to handle right-shiftable and small\nvalues with less instructions. We now generate:\n\n128:\n        movs    r0, r0, #128\n264:\n        movs    r3, #33\n        lsls    r3, #3\n510:\n        movs    r3, #255\n        lsls    r3, #1\n512:\n        movs    r3, #1\n        lsls    r3, #9\n764:\n        movs    r3, #191\n        lsls    r3, #2\n65536:\n        movs    r3, #1\n        lsls    r3, #16\n0x123456:\n        movs    r3, #18 ;0x12\n        lsls    r3, #8\n        adds    r3, #52 ;0x34\n        lsls    r3, #8\n        adds    r3, #86 ;0x56\n0x1123456:\n        movs    r3, #137 ;0x89\n        lsls    r3, #8\n        adds    r3, #26 ;0x1a\n        lsls    r3, #8\n        adds    r3, #43 ;0x2b\n        lsls    r3, #1\n0x1000010:\n        movs    r3, #16\n        lsls    r3, #16\n        adds    r3, #1\n        lsls    r3, #4\n0x1000011:\n        movs    r3, #1\n        lsls    r3, #24\n        adds    r3, #17\n-8192:\n\tmovs\tr3, #1\n\tlsls\tr3, #13\n\trsbs\tr3, #0\n\nThe patch adds a testcase which does not fully exercise\nthumb1_gen_const_int, as other existing patterns already catch small\nconstants.  These parts of thumb1_gen_const_int are used by\narm_thumb1_mi_thunk.\n\n2020-11-02  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/arm.c (thumb1_const_rtl, thumb1_const_print): New\n\tclasses.\n\t(thumb1_gen_const_int): Rename to ...\n\t(thumb1_gen_const_int_1): ... New helper function. Add capability\n\tto emit either RTL or asm, improve generated code.\n\t(thumb1_gen_const_int_rtl): New function.\n\t* config/arm/arm-protos.h (thumb1_gen_const_int): Rename to\n\tthumb1_gen_const_int_rtl.\n\t* config/arm/thumb1.md: Call thumb1_gen_const_int_rtl instead\n\tof thumb1_gen_const_int.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/pure-code/no-literal-pool-m0.c: New.", "tree": {"sha": "f5165d29fb4b21c5a110b4371507e3a866fef47d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5165d29fb4b21c5a110b4371507e3a866fef47d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/011f5e92f8ff87f099ed0aae736e79be20a77c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011f5e92f8ff87f099ed0aae736e79be20a77c6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/011f5e92f8ff87f099ed0aae736e79be20a77c6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011f5e92f8ff87f099ed0aae736e79be20a77c6c/comments", "author": null, "committer": null, "parents": [{"sha": "79680c1d5cd3d89c2e7423e20dc8a6e1d6dc8151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79680c1d5cd3d89c2e7423e20dc8a6e1d6dc8151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79680c1d5cd3d89c2e7423e20dc8a6e1d6dc8151"}], "stats": {"total": 403, "additions": 369, "deletions": 34}, "files": [{"sha": "5b581e00023f8ce85951b0c5d7ebe18f879cc0ff", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=011f5e92f8ff87f099ed0aae736e79be20a77c6c", "patch": "@@ -74,7 +74,7 @@ extern bool arm_small_register_classes_for_mode_p (machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n extern int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n extern int const_ok_for_dimode_op (HOST_WIDE_INT, enum rtx_code);\n-extern void thumb1_gen_const_int (rtx, HOST_WIDE_INT);\n+extern void thumb1_gen_const_int_rtl (rtx, HOST_WIDE_INT);\n extern int arm_split_constant (RTX_CODE, machine_mode, rtx,\n \t\t\t       HOST_WIDE_INT, rtx, rtx, int);\n extern int legitimate_pic_operand_p (rtx);"}, {"sha": "203d2b6b50bc234659f896acc6049a9d7989c204", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 192, "deletions": 32, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=011f5e92f8ff87f099ed0aae736e79be20a77c6c", "patch": "@@ -4528,38 +4528,6 @@ const_ok_for_dimode_op (HOST_WIDE_INT i, enum rtx_code code)\n     }\n }\n \n-/* Emit a sequence of movs/adds/shift to produce a 32-bit constant.\n-   Avoid generating useless code when one of the bytes is zero.  */\n-void\n-thumb1_gen_const_int (rtx op0, HOST_WIDE_INT op1)\n-{\n-  bool mov_done_p = false;\n-  int i;\n-\n-  /* Emit upper 3 bytes if needed.  */\n-  for (i = 0; i < 3; i++)\n-    {\n-      int byte = (op1 >> (8 * (3 - i))) & 0xff;\n-\n-      if (byte)\n-\t{\n-\t  emit_set_insn (op0, mov_done_p\n-\t\t\t ? gen_rtx_PLUS (SImode,op0, GEN_INT (byte))\n-\t\t\t : GEN_INT (byte));\n-\t  mov_done_p = true;\n-\t}\n-\n-      if (mov_done_p)\n-\temit_set_insn (op0, gen_rtx_ASHIFT (SImode, op0, GEN_INT (8)));\n-    }\n-\n-  /* Emit lower byte if needed.  */\n-  if (!mov_done_p)\n-    emit_set_insn (op0, GEN_INT (op1 & 0xff));\n-  else if (op1 & 0xff)\n-    emit_set_insn (op0, gen_rtx_PLUS (SImode, op0, GEN_INT (op1 & 0xff)));\n-}\n-\n /* Emit a sequence of insns to handle a large constant.\n    CODE is the code of the operation required, it can be any of SET, PLUS,\n    IOR, AND, XOR, MINUS;\n@@ -28263,6 +28231,198 @@ arm_internal_label (FILE *stream, const char *prefix, unsigned long labelno)\n   default_internal_label (stream, prefix, labelno);\n }\n \n+/* Define classes to generate code as RTL or output asm to a file.\n+   Using templates then allows to use the same code to output code\n+   sequences in the two formats.  */\n+class thumb1_const_rtl\n+{\n+ public:\n+  thumb1_const_rtl (rtx dst) : dst (dst) {}\n+\n+  void mov (HOST_WIDE_INT val)\n+  {\n+    emit_set_insn (dst, GEN_INT (val));\n+  }\n+\n+  void add (HOST_WIDE_INT val)\n+  {\n+    emit_set_insn (dst, gen_rtx_PLUS (SImode, dst, GEN_INT (val)));\n+  }\n+\n+  void ashift (HOST_WIDE_INT shift)\n+  {\n+    emit_set_insn (dst, gen_rtx_ASHIFT (SImode, dst, GEN_INT (shift)));\n+  }\n+\n+  void neg ()\n+  {\n+    emit_set_insn (dst, gen_rtx_NEG (SImode, dst));\n+  }\n+\n+ private:\n+  rtx dst;\n+};\n+\n+class thumb1_const_print\n+{\n+ public:\n+  thumb1_const_print (FILE *f, int regno)\n+  {\n+    t_file = f;\n+    dst_regname = reg_names[regno];\n+  }\n+\n+  void mov (HOST_WIDE_INT val)\n+  {\n+    asm_fprintf (t_file, \"\\tmovs\\t%s, #\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t dst_regname, val);\n+  }\n+\n+  void add (HOST_WIDE_INT val)\n+  {\n+    asm_fprintf (t_file, \"\\tadds\\t%s, #\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t dst_regname, val);\n+  }\n+\n+  void ashift (HOST_WIDE_INT shift)\n+  {\n+    asm_fprintf (t_file, \"\\tlsls\\t%s, #\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t dst_regname, shift);\n+  }\n+\n+  void neg ()\n+  {\n+    asm_fprintf (t_file, \"\\trsbs\\t%s, #0\\n\", dst_regname);\n+  }\n+\n+ private:\n+  FILE *t_file;\n+  const char *dst_regname;\n+};\n+\n+/* Emit a sequence of movs/adds/shift to produce a 32-bit constant.\n+   Avoid generating useless code when one of the bytes is zero.  */\n+template <class T>\n+void\n+thumb1_gen_const_int_1 (T dst, HOST_WIDE_INT op1)\n+{\n+  bool mov_done_p = false;\n+  unsigned HOST_WIDE_INT val = op1;\n+  int shift = 0;\n+  int i;\n+\n+  gcc_assert (op1 == trunc_int_for_mode (op1, SImode));\n+\n+  if (val <= 255)\n+    {\n+      dst.mov (val);\n+      return;\n+    }\n+\n+  /* For negative numbers with the first nine bits set, build the\n+     opposite of OP1, then negate it, it's generally shorter and not\n+     longer.  */\n+  if ((val & 0xFF800000) == 0xFF800000)\n+    {\n+      thumb1_gen_const_int_1 (dst, -op1);\n+      dst.neg ();\n+      return;\n+    }\n+\n+  /* In the general case, we need 7 instructions to build\n+     a 32 bits constant (1 movs, 3 lsls, 3 adds). We can\n+     do better if VAL is small enough, or\n+     right-shiftable by a suitable amount.  If the\n+     right-shift enables to encode at least one less byte,\n+     it's worth it: we save a adds and a lsls at the\n+     expense of a final lsls.  */\n+  int final_shift = number_of_first_bit_set (val);\n+\n+  int leading_zeroes = clz_hwi (val);\n+  int number_of_bytes_needed\n+    = ((HOST_BITS_PER_WIDE_INT - 1 - leading_zeroes)\n+       / BITS_PER_UNIT) + 1;\n+  int number_of_bytes_needed2\n+    = ((HOST_BITS_PER_WIDE_INT - 1 - leading_zeroes - final_shift)\n+       / BITS_PER_UNIT) + 1;\n+\n+  if (number_of_bytes_needed2 < number_of_bytes_needed)\n+    val >>= final_shift;\n+  else\n+    final_shift = 0;\n+\n+  /* If we are in a very small range, we can use either a single movs\n+     or movs+adds.  */\n+  if (val <= 510)\n+    {\n+      if (val > 255)\n+\t{\n+\t  unsigned HOST_WIDE_INT high = val - 255;\n+\n+\t  dst.mov (high);\n+\t  dst.add (255);\n+\t}\n+      else\n+\tdst.mov (val);\n+\n+      if (final_shift > 0)\n+\tdst.ashift (final_shift);\n+    }\n+  else\n+    {\n+      /* General case, emit upper 3 bytes as needed.  */\n+      for (i = 0; i < 3; i++)\n+\t{\n+\t  unsigned HOST_WIDE_INT byte = (val >> (8 * (3 - i))) & 0xff;\n+\n+\t  if (byte)\n+\t    {\n+\t      /* We are about to emit new bits, stop accumulating a\n+\t\t shift amount, and left-shift only if we have already\n+\t\t emitted some upper bits.  */\n+\t      if (mov_done_p)\n+\t\t{\n+\t\t  dst.ashift (shift);\n+\t\t  dst.add (byte);\n+\t\t}\n+\t      else\n+\t\tdst.mov (byte);\n+\n+\t      /* Stop accumulating shift amount since we've just\n+\t\t emitted some bits.  */\n+\t      shift = 0;\n+\n+\t      mov_done_p = true;\n+\t    }\n+\n+\t  if (mov_done_p)\n+\t    shift += 8;\n+\t}\n+\n+      /* Emit lower byte.  */\n+      if (!mov_done_p)\n+\tdst.mov (val & 0xff);\n+      else\n+\t{\n+\t  dst.ashift (shift);\n+\t  if (val & 0xff)\n+\t    dst.add (val & 0xff);\n+\t}\n+\n+      if (final_shift > 0)\n+\tdst.ashift (final_shift);\n+    }\n+}\n+\n+/* Proxy for thumb1.md, since the thumb1_const_print and\n+   thumb1_const_rtl classes are not exported.  */\n+void\n+thumb1_gen_const_int_rtl (rtx dst, HOST_WIDE_INT op1)\n+{\n+  thumb1_const_rtl t (dst);\n+  thumb1_gen_const_int_1 (t, op1);\n+}\n+\n /* Output code to add DELTA to the first argument, and then jump\n    to FUNCTION.  Used for C++ multiple inheritance.  */\n "}, {"sha": "e2fcb1045fae5d3ec483d16b7cc1e9a8ae4e2f7d", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=011f5e92f8ff87f099ed0aae736e79be20a77c6c", "patch": "@@ -820,7 +820,7 @@\n    && !satisfies_constraint_K (operands[1])\"\n   [(clobber (const_int 0))]\n   \"\n-    thumb1_gen_const_int (operands[0], INTVAL (operands[1]));\n+    thumb1_gen_const_int_rtl (operands[0], INTVAL (operands[1]));\n     DONE;\n   \"\n )"}, {"sha": "787a61a125da5ba53463a47f271c0e032f3a1439", "filename": "gcc/testsuite/gcc.target/arm/pure-code/no-literal-pool-m0.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fno-literal-pool-m0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011f5e92f8ff87f099ed0aae736e79be20a77c6c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fno-literal-pool-m0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fno-literal-pool-m0.c?ref=011f5e92f8ff87f099ed0aae736e79be20a77c6c", "patch": "@@ -0,0 +1,175 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mpure-code -mcpu=cortex-m0 -march=armv6s-m -mthumb\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/* Does not use thumb1_gen_const_int.\n+** test_0:\n+**\t...\n+**\tmovs\tr[0-3], #0\n+**\t...\n+*/\n+int\n+test_0 ()\n+{\n+  return 0;\n+}\n+\n+/* Does not use thumb1_gen_const_int.\n+** test_128:\n+**\t...\n+**\tmovs\tr[0-3], #128\n+**\t...\n+*/\n+int\n+test_128 ()\n+{\n+  return 128;\n+}\n+\n+/* Does not use thumb1_gen_const_int.\n+** test_264:\n+**\t...\n+**\tmovs\tr[0-3], #132\n+**\tlsls\tr[0-3], r[0-3], #1\n+**\t...\n+*/\n+int\n+test_264 ()\n+{\n+  return 264;\n+}\n+\n+/* Does not use thumb1_gen_const_int.\n+** test_510:\n+**\t...\n+**\tmovs\tr[0-3], #255\n+**\tlsls\tr[0-3], r[0-3], #1\n+**\t...\n+*/\n+int\n+test_510 ()\n+{\n+  return 510;\n+}\n+\n+/* Does not use thumb1_gen_const_int.\n+** test_512:\n+**\t...\n+**\tmovs\tr[0-3], #128\n+**\tlsls\tr[0-3], r[0-3], #2\n+**\t...\n+*/\n+int\n+test_512 ()\n+{\n+  return 512;\n+}\n+\n+/* Does not use thumb1_gen_const_int.\n+** test_764:\n+**\t...\n+**\tmovs\tr[0-3], #191\n+**\tlsls\tr[0-3], r[0-3], #2\n+**\t...\n+*/\n+int\n+test_764 ()\n+{\n+  return 764;\n+}\n+\n+/* Does not use thumb1_gen_const_int.\n+** test_65536:\n+**\t...\n+**\tmovs\tr[0-3], #128\n+**\tlsls\tr[0-3], r[0-3], #9\n+**\t...\n+*/\n+int\n+test_65536 ()\n+{\n+  return 65536;\n+}\n+\n+/*\n+** test_0x123456:\n+**\t...\n+**\tmovs\tr[0-3], #18\n+**\tlsls\tr[0-3], r[0-3], #8\n+**\tadds\tr[0-3], r[0-3], #52\n+**\tlsls\tr[0-3], r[0-3], #8\n+**\tadds\tr[0-3], r[0-3], #86\n+**\t...\n+*/\n+int\n+test_0x123456 ()\n+{\n+  return 0x123456;\n+}\n+\n+/*\n+** test_0x1123456:\n+**\t...\n+**\tmovs\tr[0-3], #137\n+**\tlsls\tr[0-3], r[0-3], #8\n+**\tadds\tr[0-3], r[0-3], #26\n+**\tlsls\tr[0-3], r[0-3], #8\n+**\tadds\tr[0-3], r[0-3], #43\n+**\tlsls\tr[0-3], r[0-3], #1\n+**\t...\n+*/\n+int\n+test_0x1123456 ()\n+{\n+  return 0x1123456;\n+}\n+\n+/* With -Os, we generate:\n+   movs r0, #16\n+   lsls r0, r0, r0\n+   With the other optimization levels, we generate:\n+   movs r0, #16\n+   lsls r0, r0, #16\n+   hence the two alternatives.  */\n+/*\n+** test_0x1000010:\n+**\t...\n+**\tmovs\tr[0-3], #16\n+**\tlsls\tr[0-3], r[0-3], (#16|r[0-3])\n+**\tadds\tr[0-3], r[0-3], #1\n+**\tlsls\tr[0-3], r[0-3], #4\n+**\t...\n+*/\n+int\n+test_0x1000010 ()\n+{\n+  return 0x1000010;\n+}\n+\n+/*\n+** test_0x1000011:\n+**\t...\n+**\tmovs\tr[0-3], #1\n+**\tlsls\tr[0-3], r[0-3], #24\n+**\tadds\tr[0-3], r[0-3], #17\n+**\t...\n+*/\n+int\n+test_0x1000011 ()\n+{\n+  return 0x1000011;\n+}\n+\n+/*\n+** test_m8192:\n+**\t...\n+**\tmovs\tr[0-3], #1\n+**\tlsls\tr[0-3], r[0-3], #13\n+**\trsbs\tr[0-3], r[0-3], #0\n+**\t...\n+*/\n+int\n+test_m8192 ()\n+{\n+  return -8192;\n+}"}]}