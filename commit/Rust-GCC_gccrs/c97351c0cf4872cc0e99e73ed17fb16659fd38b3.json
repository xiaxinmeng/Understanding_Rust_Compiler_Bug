{"sha": "c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk3MzUxYzBjZjQ4NzJjYzBlOTllNzNlZDE3ZmIxNjY1OWZkMzhiMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-29T16:24:57Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-29T16:24:57Z"}, "message": "rtl-ssa: Fix -fcompare-debug failure [PR100303]\n\nThis patch fixes an oversight in the handling of debug instructions\nin rtl-ssa.  At the moment (and whether this is a good idea or not\nremains to be seen), we maintain a linear RPO sequence of definitions\nand non-debug uses.  If a register is defined more than once, we use\na degenerate phi to reestablish a previous definition where necessary.\n\nHowever, debug instructions shouldn't of course affect codegen,\nso we can't create a new definition just for them.  In those situations\nwe instead hang the debug use off the real definition (meaning that\ndebug uses do not follow a linear order wrt definitions).  Again,\nit remains to be seen whether that's a good idea.\n\nThe problem in the PR was that we weren't taking this into account\nwhen increasing (or potentially increasing) the live range of an\nexisting definition.  We'd create the phi even if it would only\nbe used by debug instructions.\n\nThe patch goes for the simple but inelegant approach of passing\na bool to say whether the use is a debug use or not.  I imagine\nthis area will need some tweaking based on experience in future.\n\ngcc/\n\tPR rtl-optimization/100303\n\t* rtl-ssa/accesses.cc (function_info::make_use_available): Take a\n\tboolean that indicates whether the use will only be used in\n\tdebug instructions.  Treat it in the same way that existing\n\tcross-EBB debug references would be handled if so.\n\t(function_info::make_uses_available): Likewise.\n\t* rtl-ssa/functions.h (function_info::make_uses_available): Update\n\tprototype accordingly.\n\t(function_info::make_uses_available): Likewise.\n\t* fwprop.c (try_fwprop_subst): Update call accordingly.", "tree": {"sha": "452b0e0a1354649f1b17d57fe9cc830cd4a47f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/452b0e0a1354649f1b17d57fe9cc830cd4a47f57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "449d7b40f6f6be8d7f9aa7232c73b0371f0963bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/449d7b40f6f6be8d7f9aa7232c73b0371f0963bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/449d7b40f6f6be8d7f9aa7232c73b0371f0963bf"}], "stats": {"total": 137, "additions": 129, "deletions": 8}, "files": [{"sha": "73284a7ae3e1b539b1921f31ebf3fef08a78316c", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "patch": "@@ -606,7 +606,8 @@ try_fwprop_subst (use_info *use, set_info *def,\n   if (def_insn->bb () != use_insn->bb ())\n     {\n       src_uses = crtl->ssa->make_uses_available (attempt, src_uses,\n-\t\t\t\t\t\t use_insn->bb ());\n+\t\t\t\t\t\t use_insn->bb (),\n+\t\t\t\t\t\t use_insn->is_debug_insn ());\n       if (!src_uses.is_valid ())\n \treturn false;\n     }"}, {"sha": "a55cc8817a7742d4502c1aa9369c0e7199d33157", "filename": "gcc/rtl-ssa/accesses.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Frtl-ssa%2Faccesses.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Frtl-ssa%2Faccesses.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Faccesses.cc?ref=c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "patch": "@@ -1242,7 +1242,10 @@ function_info::insert_temp_clobber (obstack_watermark &watermark,\n }\n \n // A subroutine of make_uses_available.  Try to make USE's definition\n-// available at the head of BB.  On success:\n+// available at the head of BB.  WILL_BE_DEBUG_USE is true if the\n+// definition will be used only in debug instructions.\n+//\n+// On success:\n //\n // - If the use would have the same def () as USE, return USE.\n //\n@@ -1254,7 +1257,8 @@ function_info::insert_temp_clobber (obstack_watermark &watermark,\n //\n // Return null on failure.\n use_info *\n-function_info::make_use_available (use_info *use, bb_info *bb)\n+function_info::make_use_available (use_info *use, bb_info *bb,\n+\t\t\t\t   bool will_be_debug_use)\n {\n   set_info *def = use->def ();\n   if (!def)\n@@ -1270,7 +1274,7 @@ function_info::make_use_available (use_info *use, bb_info *bb)\n       && single_pred (cfg_bb) == use_bb->cfg_bb ()\n       && remains_available_on_exit (def, use_bb))\n     {\n-      if (def->ebb () == bb->ebb ())\n+      if (def->ebb () == bb->ebb () || will_be_debug_use)\n \treturn use;\n \n       resource_info resource = use->resource ();\n@@ -1314,7 +1318,8 @@ function_info::make_use_available (use_info *use, bb_info *bb)\n // See the comment above the declaration.\n use_array\n function_info::make_uses_available (obstack_watermark &watermark,\n-\t\t\t\t    use_array uses, bb_info *bb)\n+\t\t\t\t    use_array uses, bb_info *bb,\n+\t\t\t\t    bool will_be_debug_uses)\n {\n   unsigned int num_uses = uses.size ();\n   if (num_uses == 0)\n@@ -1323,7 +1328,7 @@ function_info::make_uses_available (obstack_watermark &watermark,\n   auto **new_uses = XOBNEWVEC (watermark, access_info *, num_uses);\n   for (unsigned int i = 0; i < num_uses; ++i)\n     {\n-      use_info *use = make_use_available (uses[i], bb);\n+      use_info *use = make_use_available (uses[i], bb, will_be_debug_uses);\n       if (!use)\n \treturn use_array (access_array::invalid ());\n       new_uses[i] = use;"}, {"sha": "cf68c94647a8232b83966464d1a503f8a403813f", "filename": "gcc/rtl-ssa/functions.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Frtl-ssa%2Ffunctions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Frtl-ssa%2Ffunctions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Ffunctions.h?ref=c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "patch": "@@ -126,8 +126,11 @@ class function_info\n   // If the operation fails, return an invalid use_array.\n   //\n   // WATERMARK is a watermark returned by new_change_attempt ().\n+  // WILL_BE_DEBUG_USES is true if the returned use_array will be\n+  // used only for debug instructions.\n   use_array make_uses_available (obstack_watermark &watermark,\n-\t\t\t\t use_array uses, bb_info *bb);\n+\t\t\t\t use_array uses, bb_info *bb,\n+\t\t\t\t bool will_be_debug_uses);\n \n   // If CHANGE doesn't already clobber REGNO, try to add such a clobber,\n   // limiting the movement range in order to make the clobber valid.\n@@ -196,7 +199,7 @@ class function_info\n   def_node *need_def_node (def_info *);\n   def_splay_tree need_def_splay_tree (def_info *);\n \n-  use_info *make_use_available (use_info *, bb_info *);\n+  use_info *make_use_available (use_info *, bb_info *, bool);\n   def_array insert_temp_clobber (obstack_watermark &, insn_info *,\n \t\t\t\t unsigned int, def_array);\n "}, {"sha": "5af9412df40f8ac3e532d9a979e86db96aa1af65", "filename": "gcc/testsuite/g++.dg/torture/pr100303.C", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr100303.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c97351c0cf4872cc0e99e73ed17fb16659fd38b3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr100303.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr100303.C?ref=c97351c0cf4872cc0e99e73ed17fb16659fd38b3", "patch": "@@ -0,0 +1,112 @@\n+/* { dg-additional-options \"-w -fcompare-debug -fno-dce -ftracer\" } */\n+\n+template < typename _T1 > struct pair\n+{\n+  _T1 first;\n+  int second;\n+};\n+struct __aligned_membuf\n+{\n+  void _M_ptr ();\n+};\n+struct _Rb_tree_node_base\n+{\n+  typedef _Rb_tree_node_base *_Base_ptr;\n+};\n+struct _Rb_tree_node:_Rb_tree_node_base\n+{\n+  __aligned_membuf _M_storage;\n+  void _M_valptr ()\n+  {\n+    _M_storage._M_ptr ();\n+  }\n+};\n+struct _Rb_tree_iterator\n+{\n+  typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+    _Rb_tree_iterator (_Base_ptr __x):_M_node (__x)\n+  {\n+  }\n+  void operator* ()\n+  {\n+    static_cast < _Rb_tree_node * >(_M_node)->_M_valptr ();\n+  }\n+  friend bool operator== (_Rb_tree_iterator __x, _Rb_tree_iterator)\n+  {\n+    return __x._M_node;\n+  }\n+  _Base_ptr _M_node;\n+};\n+\n+template < typename, typename, typename, typename, typename =\n+  int >class _Rb_tree\n+{\n+  typedef _Rb_tree_node_base *_Base_ptr;\n+public:\n+    pair < _Base_ptr > _M_get_insert_hint_unique_pos (int);\n+  void _M_insert_node (_Base_ptr, int);\n+    template < typename ... _Args >\n+    _Rb_tree_iterator _M_emplace_hint_unique (_Args && ...);\n+  _Rb_tree_iterator lower_bound ()\n+  {\n+    _Rb_tree_node_base __trans_tmp_2;\n+      return &__trans_tmp_2;\n+  }\n+};\n+template < typename _Key, typename _Val, typename _KeyOfValue,\n+  typename _Compare,\n+  typename _Alloc > template < typename ... _Args >\n+  _Rb_tree_iterator _Rb_tree < _Key, _Val, _KeyOfValue, _Compare,\n+  _Alloc >::_M_emplace_hint_unique (_Args && ...)\n+{\n+  int __z;\n+  try\n+  {\n+    auto __res = _M_get_insert_hint_unique_pos (0);\n+    _Rb_tree_node_base *__res_1;\n+    if (__res_1)\n+      _M_insert_node (__res.first, __z);\n+    return __res.first;\n+  }\n+  catch ( ...)\n+  {\n+  }\n+}\n+\n+class map\n+{\n+  _Rb_tree < int, int, int, int >_M_t;\n+public:\n+    _Rb_tree_iterator end ();\n+  void operator[] (int)\n+  {\n+    _Rb_tree_iterator __i = lower_bound ();\n+    if (__i == end ())\n+      __i = _M_t._M_emplace_hint_unique (__i);\n+    *__i;\n+  }\n+  _Rb_tree_iterator lower_bound ()\n+  {\n+    return _M_t.lower_bound ();\n+  }\n+};\n+\n+class FlowStat\n+{\n+public:\n+  int FlowStat_flow;\n+    FlowStat ()\n+  {\n+    shares[FlowStat_flow];\n+  }\n+  map shares;\n+};\n+\n+class LinkGraphJob\n+{\n+  ~LinkGraphJob ();\n+};\n+LinkGraphJob::~LinkGraphJob ()\n+{\n+  FlowStat ();\n+}"}]}