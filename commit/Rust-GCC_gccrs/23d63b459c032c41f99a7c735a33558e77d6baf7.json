{"sha": "23d63b459c032c41f99a7c735a33558e77d6baf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNkNjNiNDU5YzAzMmM0MWY5OWE3YzczNWEzMzU1OGU3N2Q2YmFmNw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-03-06T06:25:12Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-03-06T06:25:12Z"}, "message": "[C++] [PR84231] overload on cond_expr in template\n\nA non-type-dependent COND_EXPR within a template is reconstructed with\nthe original operands, after one with non-dependent proxies is built to\ndetermine its result type.  This is problematic because the operands of\na COND_EXPR determined to be an rvalue may have been converted to denote\ntheir rvalue nature.  The reconstructed one, however, won't have such\nconversions, so lvalue_kind may not recognize it as an rvalue, which may\nlead to e.g. incorrect overload resolution decisions.\n\nIf we mistake such a COND_EXPR for an lvalue, overload resolution might\nregard a conversion sequence that binds it to a non-const reference as\nviable, and then select that over one that binds it to a const\nreference.  Only after template substitution would we rebuild the\nCOND_EXPR, realize it is an rvalue, and conclude the reference binding\nis ill-formed, but at that point we'd have long discarded any alternate\ncandidates we could have used.\n\nThis patch modifies the logic that determines whether a\n(non-type-dependent) COND_EXPR in a template is an lvalue, to rely on\nits type, more specifically, on the presence of a REFERENCE_TYPE\nwrapper.  In order to avoid a type bootstrapping problem, the\nREFERENCE_TYPE that wraps the type of some such COND_EXPRs is\nintroduced earlier, so that we don't have to test for lvalueness of\nthe expression using the very code that we wish to change.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/84231\n\t* tree.c (lvalue_kind): Use presence/absence of REFERENCE_TYPE\n\tonly while processing template decls.\n\t* typeck.c (build_x_conditional_expr): Move wrapping of\n\treference type around type...\n\t* call.c (build_conditional_expr_1): ... here.  Rename\n\tis_lvalue to is_glvalue.\n\t* parser.c (cp_parser_fold_expression): Catch REFERENCE_REF_P\n\tINDIRECT_REF of COND_EXPR too.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR c++/84231\n\t* g++.dg/pr84231.C: New.\n\nFrom-SVN: r258271", "tree": {"sha": "13f3e408fba20d613f4296a5ea55fd51999a632e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13f3e408fba20d613f4296a5ea55fd51999a632e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23d63b459c032c41f99a7c735a33558e77d6baf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23d63b459c032c41f99a7c735a33558e77d6baf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23d63b459c032c41f99a7c735a33558e77d6baf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23d63b459c032c41f99a7c735a33558e77d6baf7/comments", "author": null, "committer": null, "parents": [{"sha": "2e1a7ecb2d8f1ee3f88fd2906ab16eb30ab525f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1a7ecb2d8f1ee3f88fd2906ab16eb30ab525f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1a7ecb2d8f1ee3f88fd2906ab16eb30ab525f7"}], "stats": {"total": 77, "additions": 68, "deletions": 9}, "files": [{"sha": "bd2e10431a98a275a85956543b3db9e5c871f0dc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=23d63b459c032c41f99a7c735a33558e77d6baf7", "patch": "@@ -1,5 +1,15 @@\n 2018-03-06  Alexandre Oliva <aoliva@redhat.com>\n \n+\tPR c++/84231\n+\t* tree.c (lvalue_kind): Use presence/absence of REFERENCE_TYPE\n+\tonly while processing template decls.\n+\t* typeck.c (build_x_conditional_expr): Move wrapping of\n+\treference type around type...\n+\t* call.c (build_conditional_expr_1): ... here.  Rename\n+\tis_lvalue to is_glvalue.\n+\t* parser.c (cp_parser_fold_expression): Catch REFERENCE_REF_P\n+\tINDIRECT_REF of COND_EXPR too.\n+\n \tPR c++/84593\n \t* init.c (build_zero_init_1): Zero-initialize references.\n "}, {"sha": "f83d51f3457e202cb9a709297e6833e2aeba031f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=23d63b459c032c41f99a7c735a33558e77d6baf7", "patch": "@@ -4782,7 +4782,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n   tree arg3_type;\n   tree result = NULL_TREE;\n   tree result_type = NULL_TREE;\n-  bool is_lvalue = true;\n+  bool is_glvalue = true;\n   struct z_candidate *candidates = 0;\n   struct z_candidate *cand;\n   void *p;\n@@ -5037,7 +5037,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t  return error_mark_node;\n \t}\n \n-      is_lvalue = false;\n+      is_glvalue = false;\n       goto valid_operands;\n     }\n   /* [expr.cond]\n@@ -5155,6 +5155,10 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n       && same_type_p (arg2_type, arg3_type))\n     {\n       result_type = arg2_type;\n+      if (processing_template_decl)\n+\t/* Let lvalue_kind know this was a glvalue.  */\n+\tresult_type = cp_build_reference_type (result_type, xvalue_p (arg2));\n+\n       arg2 = mark_lvalue_use (arg2);\n       arg3 = mark_lvalue_use (arg3);\n       goto valid_operands;\n@@ -5167,7 +5171,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n      cv-qualified) class type, overload resolution is used to\n      determine the conversions (if any) to be applied to the operands\n      (_over.match.oper_, _over.built_).  */\n-  is_lvalue = false;\n+  is_glvalue = false;\n   if (!same_type_p (arg2_type, arg3_type)\n       && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n     {\n@@ -5361,7 +5365,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n   /* We can't use result_type below, as fold might have returned a\n      throw_expr.  */\n \n-  if (!is_lvalue)\n+  if (!is_glvalue)\n     {\n       /* Expand both sides into the same slot, hopefully the target of\n \t the ?: expression.  We used to check for TARGET_EXPRs here,"}, {"sha": "a19bbe1e1d06d7a95c52d04ef87b91fd2faa9b5b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=23d63b459c032c41f99a7c735a33558e77d6baf7", "patch": "@@ -4963,7 +4963,9 @@ cp_parser_fold_expression (cp_parser *parser, tree expr1)\n   else if (is_binary_op (TREE_CODE (expr1)))\n     error_at (location_of (expr1),\n \t      \"binary expression in operand of fold-expression\");\n-  else if (TREE_CODE (expr1) == COND_EXPR)\n+  else if (TREE_CODE (expr1) == COND_EXPR\n+\t   || (REFERENCE_REF_P (expr1)\n+\t       && TREE_CODE (TREE_OPERAND (expr1, 0)) == COND_EXPR))\n     error_at (location_of (expr1),\n \t      \"conditional expression in operand of fold-expression\");\n "}, {"sha": "4cf2126608f0b7fedd008583bf5e09f395118a79", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=23d63b459c032c41f99a7c735a33558e77d6baf7", "patch": "@@ -194,6 +194,21 @@ lvalue_kind (const_tree ref)\n       break;\n \n     case COND_EXPR:\n+      if (processing_template_decl)\n+\t{\n+\t  /* Within templates, a REFERENCE_TYPE will indicate whether\n+\t     the COND_EXPR result is an ordinary lvalue or rvalueref.\n+\t     Since REFERENCE_TYPEs are handled above, if we reach this\n+\t     point, we know we got a plain rvalue.  Unless we have a\n+\t     type-dependent expr, that is, but we shouldn't be testing\n+\t     lvalueness if we can't even tell the types yet!  */\n+\t  gcc_assert (!type_dependent_expression_p (CONST_CAST_TREE (ref)));\n+\t  if (CLASS_TYPE_P (TREE_TYPE (ref))\n+\t      || TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n+\t    return clk_class;\n+\t  else\n+\t    return clk_none;\n+\t}\n       op1_lvalue_kind = lvalue_kind (TREE_OPERAND (ref, 1)\n \t\t\t\t    ? TREE_OPERAND (ref, 1)\n \t\t\t\t    : TREE_OPERAND (ref, 0));"}, {"sha": "0c2ebd1b3e41cffb7d46b857ae4cb7ac00ba7a36", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=23d63b459c032c41f99a7c735a33558e77d6baf7", "patch": "@@ -6567,10 +6567,6 @@ build_x_conditional_expr (location_t loc, tree ifexp, tree op1, tree op2,\n     {\n       tree min = build_min_non_dep (COND_EXPR, expr,\n \t\t\t\t    orig_ifexp, orig_op1, orig_op2);\n-      /* Remember that the result is an lvalue or xvalue.  */\n-      if (glvalue_p (expr) && !glvalue_p (min))\n-\tTREE_TYPE (min) = cp_build_reference_type (TREE_TYPE (min),\n-\t\t\t\t\t\t   !lvalue_p (expr));\n       expr = convert_from_reference (min);\n     }\n   return expr;"}, {"sha": "3de87e95b567f5a1ab1f550215ee36d707162a69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=23d63b459c032c41f99a7c735a33558e77d6baf7", "patch": "@@ -1,5 +1,8 @@\n 2018-03-06  Alexandre Oliva <aoliva@redhat.com>\n \n+\tPR c++/84231\n+\t* g++.dg/pr84231.C: New.\n+\n \tPR c++/84593\n \t* g++.dg/cpp1y/pr84593.C: New.\n "}, {"sha": "de7c89a2ab6950a7e7860607a8f779f766be2265", "filename": "gcc/testsuite/g++.dg/pr84231.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr84231.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d63b459c032c41f99a7c735a33558e77d6baf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr84231.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr84231.C?ref=23d63b459c032c41f99a7c735a33558e77d6baf7", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/84231 - overload resolution with cond_expr in a template\n+\n+// { dg-do compile }\n+\n+struct format {\n+  template<typename T> format& operator%(const T&) { return *this; }\n+  template<typename T> format& operator%(T&) { return *this; }\n+};\n+\n+format f;\n+\n+template <typename>\n+void function_template(bool b)\n+{\n+  // Compiles OK with array lvalue:\n+  f % (b ? \"x\" : \"x\");\n+\n+  // Used to fails with pointer rvalue:\n+  f % (b ? \"\" : \"x\");\n+}\n+\n+void normal_function(bool b)\n+{\n+  // Both cases compile OK in non-template function:\n+  f % (b ? \"x\" : \"x\");\n+  f % (b ? \"\" : \"x\");\n+\n+  function_template<void>(b);\n+}"}]}