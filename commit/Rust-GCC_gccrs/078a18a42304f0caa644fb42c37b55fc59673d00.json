{"sha": "078a18a42304f0caa644fb42c37b55fc59673d00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4YTE4YTQyMzA0ZjBjYWE2NDRmYjQyYzM3YjU1ZmM1OTY3M2QwMA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-02-18T19:34:28Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-02-18T19:34:28Z"}, "message": "calls.c (initialize_argument_information): Pass original EXP and STRUCT_VALUE_ADDR_VALUE instead of a list of arguments.\n\n2007-02-18  Sandra Loosemore  <sandra@codesourcery.com>\n\n\t* calls.c (initialize_argument_information): Pass original EXP\n\tand STRUCT_VALUE_ADDR_VALUE instead of a list of arguments.  Move\n\tcode to split complex arguments here, as part of initializing the\n\tARGS array.\n\t(expand_call): Remove code that builds a list of arguments and\n\tinserts implicit arguments into it.  Instead, just count how many\n\timplicit arguments there will be so we can determine the size of\n\tthe ARGS array, and let initialize_argument_information do the work.\n\t(split_complex_values): Delete unused function.\n\nFrom-SVN: r122101", "tree": {"sha": "d07869954dddb79d52f33e840dcc635ca7969c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d07869954dddb79d52f33e840dcc635ca7969c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/078a18a42304f0caa644fb42c37b55fc59673d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078a18a42304f0caa644fb42c37b55fc59673d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078a18a42304f0caa644fb42c37b55fc59673d00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078a18a42304f0caa644fb42c37b55fc59673d00/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "483edb920122339238840ddf34e6931ca92fd76a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483edb920122339238840ddf34e6931ca92fd76a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483edb920122339238840ddf34e6931ca92fd76a"}], "stats": {"total": 168, "additions": 84, "deletions": 84}, "files": [{"sha": "751d6c16231ef663816d51740b9b4f25609b456b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078a18a42304f0caa644fb42c37b55fc59673d00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078a18a42304f0caa644fb42c37b55fc59673d00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=078a18a42304f0caa644fb42c37b55fc59673d00", "patch": "@@ -1,3 +1,15 @@\n+2007-02-18  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* calls.c (initialize_argument_information): Pass original EXP\n+\tand STRUCT_VALUE_ADDR_VALUE instead of a list of arguments.  Move\n+\tcode to split complex arguments here, as part of initializing the\n+\tARGS array.\n+\t(expand_call): Remove code that builds a list of arguments and\n+\tinserts implicit arguments into it.  Instead, just count how many\n+\timplicit arguments there will be so we can determine the size of\n+\tthe ARGS array, and let initialize_argument_information do the work.\n+\t(split_complex_values): Delete unused function.\n+\n 2007-02-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-eh.c (tree_could_trap_p): Handle VIEW_CONVERT_EXPR."}, {"sha": "d9ba08c0ddb2db1ba991074ceec3bfe24cea06dc", "filename": "gcc/calls.c", "status": "modified", "additions": 72, "deletions": 84, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078a18a42304f0caa644fb42c37b55fc59673d00/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078a18a42304f0caa644fb42c37b55fc59673d00/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=078a18a42304f0caa644fb42c37b55fc59673d00", "patch": "@@ -132,7 +132,8 @@ static int finalize_must_preallocate (int, int, struct arg_data *,\n static void precompute_arguments (int, int, struct arg_data *);\n static int compute_argument_block_size (int, struct args_size *, int);\n static void initialize_argument_information (int, struct arg_data *,\n-\t\t\t\t\t     struct args_size *, int, tree,\n+\t\t\t\t\t     struct args_size *, int,\n+\t\t\t\t\t     tree, tree,\n \t\t\t\t\t     tree, CUMULATIVE_ARGS *, int,\n \t\t\t\t\t     rtx *, int *, int *, int *,\n \t\t\t\t\t     bool *, bool);\n@@ -148,7 +149,6 @@ static int check_sibcall_argument_overlap (rtx, struct arg_data *, int);\n \n static int combine_pending_stack_adjustment_and_call (int, struct args_size *,\n \t\t\t\t\t\t      unsigned int);\n-static tree split_complex_values (tree);\n static tree split_complex_types (tree);\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -889,12 +889,15 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n }\n \n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n-   ACTPARMS.\n+   CALL_EXPR EXP.  \n \n    NUM_ACTUALS is the total number of parameters.\n \n    N_NAMED_ARGS is the total number of named arguments.\n \n+   STRUCT_VALUE_ADDR_VALUE is the implicit argument for a struct return\n+   value, or null.\n+\n    FNDECL is the tree code for the target of this call (if known)\n \n    ARGS_SO_FAR holds state needed by the target to know where to place\n@@ -920,7 +923,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t\t\t struct arg_data *args,\n \t\t\t\t struct args_size *args_size,\n \t\t\t\t int n_named_args ATTRIBUTE_UNUSED,\n-\t\t\t\t tree actparms, tree fndecl,\n+\t\t\t\t tree exp, tree struct_value_addr_value,\n+\t\t\t\t tree fndecl,\n \t\t\t\t CUMULATIVE_ARGS *args_so_far,\n \t\t\t\t int reg_parm_stack_space,\n \t\t\t\t rtx *old_stack_level, int *old_pending_adj,\n@@ -934,7 +938,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n   int argpos;\n \n   int i;\n-  tree p;\n \n   args_size->constant = 0;\n   args_size->var = 0;\n@@ -954,15 +957,45 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       i = 0, inc = 1;\n     }\n \n+  /* First fill in the actual arguments in the ARGS array, splitting\n+     complex arguments if necessary.  */\n+  {\n+    int j = i;\n+    call_expr_arg_iterator iter;\n+    tree arg;\n+\n+    if (struct_value_addr_value)\n+      {\n+\targs[j].tree_value = struct_value_addr_value;\n+\tj += inc;\n+      }\n+    FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+      {\n+\ttree argtype = TREE_TYPE (arg);\n+\tif (targetm.calls.split_complex_arg\n+\t    && argtype\n+\t    && TREE_CODE (argtype) == COMPLEX_TYPE\n+\t    && targetm.calls.split_complex_arg (argtype))\n+\t  {\n+\t    tree subtype = TREE_TYPE (argtype);\n+\t    arg = save_expr (arg);\n+\t    args[j].tree_value = build1 (REALPART_EXPR, subtype, arg);\n+\t    j += inc;\n+\t    args[j].tree_value = build1 (IMAGPART_EXPR, subtype, arg);\n+\t  }\n+\telse\n+\t  args[j].tree_value = arg;\n+\tj += inc;\n+      }\n+  }\n+\n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n-  for (p = actparms, argpos = 0; p; p = TREE_CHAIN (p), i += inc, argpos++)\n+  for (argpos = 0; argpos < num_actuals; i += inc, argpos++)\n     {\n-      tree type = TREE_TYPE (TREE_VALUE (p));\n+      tree type = TREE_TYPE (args[i].tree_value);\n       int unsignedp;\n       enum machine_mode mode;\n \n-      args[i].tree_value = TREE_VALUE (p);\n-\n       /* Replace erroneous argument with constant zero.  */\n       if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n \targs[i].tree_value = integer_zero_node, type = integer_type_node;\n@@ -1030,7 +1063,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t{\n \t\t  /* This is a variable-sized object.  Make space on the stack\n \t\t     for it.  */\n-\t\t  rtx size_rtx = expr_size (TREE_VALUE (p));\n+\t\t  rtx size_rtx = expr_size (args[i].tree_value);\n \n \t\t  if (*old_stack_level == 0)\n \t\t    {\n@@ -1825,9 +1858,6 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Nonzero if we are currently expanding a call.  */\n   static int currently_expanding_call = 0;\n \n-  /* List of actual parameters.  */\n-  /* FIXME: rewrite this so that it doesn't cons up a TREE_LIST.  */\n-  tree actparms = CALL_EXPR_ARGS (exp);\n   /* RTX for the function to be called.  */\n   rtx funexp;\n   /* Sequence of insns to perform a normal \"call\".  */\n@@ -1855,6 +1885,8 @@ expand_call (tree exp, rtx target, int ignore)\n      an extra, implicit first parameter.  Otherwise,\n      it is passed by being copied directly into struct_value_rtx.  */\n   int structure_value_addr_parm = 0;\n+  /* Holds the value of implicit argument for the struct value.  */\n+  tree structure_value_addr_value = NULL_TREE;\n   /* Size of aggregate value wanted, or zero if none wanted\n      or if we are using the non-reentrant PCC calling convention\n      or expecting the value in registers.  */\n@@ -1869,6 +1901,8 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Number of named args.  Args after this are anonymous ones\n      and they must all go on the stack.  */\n   int n_named_args;\n+  /* Number of complex actual arguments that need to be split.  */\n+  int num_complex_actuals = 0;\n \n   /* Vector of information about each argument.\n      Arguments are numbered in the order they will be pushed,\n@@ -1971,19 +2005,19 @@ expand_call (tree exp, rtx target, int ignore)\n     {\n       bool volatilep = false;\n       tree arg;\n+      call_expr_arg_iterator iter;\n \n-      for (arg = actparms; arg; arg = TREE_CHAIN (arg))\n-\tif (TREE_THIS_VOLATILE (TREE_VALUE (arg)))\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+\tif (TREE_THIS_VOLATILE (arg))\n \t  {\n \t    volatilep = true;\n \t    break;\n \t  }\n \n       if (! volatilep)\n \t{\n-\t  for (arg = actparms; arg; arg = TREE_CHAIN (arg))\n-\t    expand_expr (TREE_VALUE (arg), const0_rtx,\n-\t\t\t VOIDmode, EXPAND_NORMAL);\n+\t  FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+\t    expand_expr (arg, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t  return const0_rtx;\n \t}\n     }\n@@ -2044,12 +2078,21 @@ expand_call (tree exp, rtx target, int ignore)\n   gcc_assert (POINTER_TYPE_P (funtype));\n   funtype = TREE_TYPE (funtype);\n \n-  /* Munge the tree to split complex arguments into their imaginary\n-     and real parts.  */\n+  /* Count whether there are actual complex arguments that need to be split\n+     into their real and imaginary parts.  Munge the type_arg_types\n+     appropriately here as well.  */\n   if (targetm.calls.split_complex_arg)\n     {\n+      call_expr_arg_iterator iter;\n+      tree arg;\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+\t{\n+\t  tree type = TREE_TYPE (arg);\n+\t  if (type && TREE_CODE (type) == COMPLEX_TYPE\n+\t      && targetm.calls.split_complex_arg (type))\n+\t    num_complex_actuals++;\n+\t}\n       type_arg_types = split_complex_types (TYPE_ARG_TYPES (funtype));\n-      actparms = split_complex_values (actparms);\n     }\n   else\n     type_arg_types = TYPE_ARG_TYPES (funtype);\n@@ -2058,7 +2101,8 @@ expand_call (tree exp, rtx target, int ignore)\n     current_function_calls_alloca = 1;\n \n   /* If struct_value_rtx is 0, it means pass the address\n-     as if it were an extra parameter.  */\n+     as if it were an extra parameter.  Put the argument expression\n+     in structure_value_addr_value.  */\n   if (structure_value_addr && struct_value == 0)\n     {\n       /* If structure_value_addr is a REG other than\n@@ -2074,17 +2118,14 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t\t\t      (Pmode, structure_value_addr))\n \t\t  : structure_value_addr);\n \n-      actparms\n-\t= tree_cons (error_mark_node,\n-\t\t     make_tree (build_pointer_type (TREE_TYPE (funtype)),\n-\t\t\t\ttemp),\n-\t\t     actparms);\n+      structure_value_addr_value =\n+\tmake_tree (build_pointer_type (TREE_TYPE (funtype)), temp);\n       structure_value_addr_parm = 1;\n     }\n \n   /* Count the arguments and set NUM_ACTUALS.  */\n-  for (p = actparms, num_actuals = 0; p; p = TREE_CHAIN (p))\n-    num_actuals++;\n+  num_actuals =\n+    call_expr_nargs (exp) + num_complex_actuals + structure_value_addr_parm;\n \n   /* Compute number of named args.\n      First, do a raw count of the args for INIT_CUMULATIVE_ARGS.  */\n@@ -2142,7 +2183,8 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Build up entries in the ARGS array, compute the size of the\n      arguments into ARGS_SIZE, etc.  */\n   initialize_argument_information (num_actuals, args, &args_size,\n-\t\t\t\t   n_named_args, actparms, fndecl,\n+\t\t\t\t   n_named_args, exp,\n+\t\t\t\t   structure_value_addr_value, fndecl,\n \t\t\t\t   &args_so_far, reg_parm_stack_space,\n \t\t\t\t   &old_stack_level, &old_pending_adj,\n \t\t\t\t   &must_preallocate, &flags,\n@@ -3151,60 +3193,6 @@ fixup_tail_calls (void)\n     }\n }\n \n-/* Traverse an argument list in VALUES and expand all complex\n-   arguments into their components.  */\n-static tree\n-split_complex_values (tree values)\n-{\n-  tree p;\n-\n-  /* Before allocating memory, check for the common case of no complex.  */\n-  for (p = values; p; p = TREE_CHAIN (p))\n-    {\n-      tree type = TREE_TYPE (TREE_VALUE (p));\n-      if (type && TREE_CODE (type) == COMPLEX_TYPE\n-\t  && targetm.calls.split_complex_arg (type))\n-\tgoto found;\n-    }\n-  return values;\n-\n- found:\n-  values = copy_list (values);\n-\n-  for (p = values; p; p = TREE_CHAIN (p))\n-    {\n-      tree complex_value = TREE_VALUE (p);\n-      tree complex_type;\n-\n-      complex_type = TREE_TYPE (complex_value);\n-      if (!complex_type)\n-\tcontinue;\n-\n-      if (TREE_CODE (complex_type) == COMPLEX_TYPE\n-\t  && targetm.calls.split_complex_arg (complex_type))\n-\t{\n-\t  tree subtype;\n-\t  tree real, imag, next;\n-\n-\t  subtype = TREE_TYPE (complex_type);\n-\t  complex_value = save_expr (complex_value);\n-\t  real = build1 (REALPART_EXPR, subtype, complex_value);\n-\t  imag = build1 (IMAGPART_EXPR, subtype, complex_value);\n-\n-\t  TREE_VALUE (p) = real;\n-\t  next = TREE_CHAIN (p);\n-\t  imag = build_tree_list (NULL_TREE, imag);\n-\t  TREE_CHAIN (p) = imag;\n-\t  TREE_CHAIN (imag) = next;\n-\n-\t  /* Skip the newly created node.  */\n-\t  p = TREE_CHAIN (p);\n-\t}\n-    }\n-\n-  return values;\n-}\n-\n /* Traverse a list of TYPES and expand all complex types into their\n    components.  */\n static tree"}]}