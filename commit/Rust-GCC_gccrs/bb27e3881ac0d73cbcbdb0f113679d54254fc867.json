{"sha": "bb27e3881ac0d73cbcbdb0f113679d54254fc867", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIyN2UzODgxYWMwZDczY2JjYmRiMGYxMTM2NzlkNTQyNTRmYzg2Nw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-05-06T00:15:47Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-05-06T00:15:47Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r26796", "tree": {"sha": "af949a2203d9b51a0597f61f627296f7d91f8404", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af949a2203d9b51a0597f61f627296f7d91f8404"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb27e3881ac0d73cbcbdb0f113679d54254fc867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb27e3881ac0d73cbcbdb0f113679d54254fc867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb27e3881ac0d73cbcbdb0f113679d54254fc867", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb27e3881ac0d73cbcbdb0f113679d54254fc867/comments", "author": null, "committer": null, "parents": [{"sha": "0ec3c5478a19993b3700b388a3b419ad3afdade0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec3c5478a19993b3700b388a3b419ad3afdade0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec3c5478a19993b3700b388a3b419ad3afdade0"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "851289638af0940c97997469d94dd706a19e45ae", "filename": "libjava/java/util/zip/ZipInputStream.java", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb27e3881ac0d73cbcbdb0f113679d54254fc867/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb27e3881ac0d73cbcbdb0f113679d54254fc867/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java?ref=bb27e3881ac0d73cbcbdb0f113679d54254fc867", "patch": "@@ -0,0 +1,190 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.util.zip;\n+import java.io.*;\n+\n+/**\n+ * @author Per Bothner\n+ * @date May 1999.\n+ */\n+\n+/*\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Quite incomplete, but can read uncompressed .zip archives.\n+ */\n+\n+// JDK1.2 has \"protected ZipEntry createZipEntry(String)\" but is very\n+// vague about what the method does.  FIXME.\n+// We do not calculate the CRC and compare it with the specified value;\n+// we probably should.  FIXME.\n+   \n+\n+public class ZipInputStream extends InflaterInputStream\n+{\n+  ZipEntry current;\n+  int current_flags;\n+  int avail;\n+\n+  public ZipInputStream (InputStream in)\n+  {\n+    super(in);\n+  }\n+\n+  public ZipEntry getNextEntry () throws IOException\n+  {\n+    if (current != null)\n+      closeZipEntry();\n+    if (in.read() != 'P'\n+\t|| in.read() != 'K')\n+      return null;\n+    int code = in.read();\n+    while (code == '\\001')\n+      {\n+\tcode = in.read();\n+\tif (code != '\\002')\n+\t  return null;\n+\tin.skip(16);\n+\tint size = read4();\n+\tin.skip(4);\n+\tint fname_length = readu2();\n+\tint extra_length = readu2();\n+\tint fcomment_length = readu2();\n+\tin.skip(12+fname_length+extra_length+fcomment_length+size);\n+\tif (in.read() != 'P' || in.read() != 'K')\n+\t  return null;\n+\tcode = in.read();\n+      }\n+    if (code == '\\005')\n+      {\n+\tif (in.read() != '\\006')\n+\t  return null;\n+\tin.skip(16);\n+\tint comment_size = readu2();\n+\tin.skip(comment_size);\n+\tif (in.read() != 'P' || in.read() != 'K')\n+\t  return null;\n+\tcode = in.read();\n+      }\n+    if (code != '\\003'\n+\t|| in.read() != '\\004')\n+      return null;\n+    int ex_version = readu2();\n+    current_flags = readu2();\n+    int method = readu2();\n+    int modtime = readu2();\n+    int moddate = readu2();\n+    int crc = read4();\n+    int compressedSize = read4();\n+    int uncompressedSize = read4();\n+    int filenameLength = readu2();\n+    int extraLength = readu2();\n+    byte[] bname = new byte[filenameLength];\n+    readFully(bname);\n+    ZipEntry entry = new ZipEntry(new String(bname, \"8859_1\"));\n+    if (extraLength > 0)\n+      {\n+\tbyte[] bextra = new byte[extraLength];\n+\treadFully(bextra);\n+\tentry.extra = bextra;\n+      }\n+    entry.compressedSize = compressedSize;\n+    entry.size = uncompressedSize;\n+    entry.crc = (long) crc & 0xffffffffL;\n+    entry.method = method;\n+    entry.time = ZipEntry.timeFromDOS(moddate, modtime);\n+    current = entry;\n+    avail = uncompressedSize;\n+    return entry;\n+  }\n+\n+  public int read (byte[] b, int off, int len)  throws IOException\n+  {\n+    if (len > avail)\n+      len = avail;\n+    int count = super.read(b, off, len);\n+    if (count > 0)\n+      avail -= count;\n+    return count;\n+  }\n+\n+  public long skip (long n)  throws IOException\n+  {\n+    if (n > avail)\n+      n = avail;\n+    long count = super.skip(n);\n+    avail = avail - (int) count;\n+    return count;\n+  }\n+\n+  private void readFully (byte[] b)  throws IOException\n+  {\n+    int off = 0;\n+    int len = b.length;\n+    while (len > 0)\n+      {\n+\tint count = in.read(b, off, len);\n+\tif (count <= 0)\n+\t  throw new EOFException(\".zip archive ended prematurely\");\n+\toff += count;\n+\tlen -= count;\n+      }\n+  }\n+\n+  private int readu2 ()  throws IOException\n+  {\n+    int byte0 = in.read();\n+    int byte1 = in.read();\n+    if (byte0 < 0 || byte1 < 0)\n+      throw new EOFException(\".zip archive ended prematurely\");\n+    return ((byte1 & 0xFF) << 8) | (byte0 & 0xFF);\n+  }\n+\n+  private int read4 () throws IOException\n+  {\n+    int byte0 = in.read();\n+    int byte1 = in.read();\n+    int byte2 = in.read();\n+    int byte3 = in.read();\n+    if (byte3 < 0)\n+      throw new EOFException(\".zip archive ended prematurely\");\n+    return ((byte3 & 0xFF) << 24) + ((byte2 & 0xFF) << 16)\n+      + ((byte1 & 0xFF) << 8) + (byte0 & 0xFF);\n+  }\n+\n+  public void closeZipEntry ()  throws IOException\n+  {\n+    if (current != null)\n+      {\n+\tif (avail > 0)\n+\t  skip (avail);\n+\tif ((current_flags & 8) != 0)\n+\t  {\n+\t    int sig = read4();\n+\t    if (sig != 0x04034b50)\n+\t      throw new IOException(\"bad/missing magic number at end of .zip entry\");\n+\t    int crc = read4();\n+\t    int compressedSize = read4();\n+\t    int uncompressedSize = read4();\n+\t    if (current.compressedSize != compressedSize\n+\t\t|| current.size != uncompressedSize\n+\t\t|| current.crc != crc)\n+\t      throw new IOException(\"bad data descriptor at end of .zip entry\");\n+\t  }\n+\tcurrent = null;\n+\tavail = 0;\n+      }\n+  }\n+\n+  public void close ()  throws IOException\n+  {\n+    current = null;\n+    super.close();\n+  }\n+}"}]}