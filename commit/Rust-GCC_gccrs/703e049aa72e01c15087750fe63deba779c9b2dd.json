{"sha": "703e049aa72e01c15087750fe63deba779c9b2dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAzZTA0OWFhNzJlMDFjMTUwODc3NTBmZTYzZGViYTc3OWM5YjJkZA==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-08-26T19:50:58Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-08-26T19:50:58Z"}, "message": "MSP430: Simplify and extend shift instruction patterns\n\nThe implementation of define_expand and define_insn patterns to handle\nshifts in the MSP430 backend is inconsistent, resulting in missed\nopportunities to make best use of the architecture's features.\n\nThere's now a single define_expand used as the entry point for all valid\nshifts, and the decision to either use a helper function to perform the\nshift (often required for the 430 ISA), or fall through to the\ndefine_insn patterns can be made from that expander function.\n\nShifts by a constant amount have been grouped into one define_insn for\neach type of shift, instead of having different define_insn patterns for\nshifts by different amounts.\n\nA new target option \"-mmax-inline-shift=\" has been added to allow tuning\nof the number of shift instructions to emit inline, instead of using\na library helper function.\n\ngcc/ChangeLog:\n\n\t* config/msp430/constraints.md (K): Change unused constraint to\n\tconstraint to a const_int between 1 and 19.\n\t(P): New constraint.\n\t* config/msp430/msp430-protos.h (msp430x_logical_shift_right): Remove.\n\t(msp430_expand_shift): New.\n\t(msp430_output_asm_shift_insns): New.\n\t* config/msp430/msp430.c (msp430_rtx_costs): Remove shift costs.\n\t(CSH): Remove.\n\t(msp430_expand_helper): Remove hard-coded generation of some inline\n\tshift insns.\n\t(use_helper_for_const_shift): New.\n\t(msp430_expand_shift): New.\n\t(msp430_output_asm_shift_insns): New.\n\t(msp430_print_operand): Add new 'W' operand selector.\n\t(msp430x_logical_shift_right): Remove.\n\t* config/msp430/msp430.md (HPSI): New define_mode_iterator.\n\t(HDI): Likewise.\n\t(any_shift): New define_code_iterator.\n\t(shift_insn): New define_code_attr.\n\tAdjust unnamed insn patterns searched for by combine.\n\t(ashlhi3): Remove.\n\t(slli_1): Remove.\n\t(430x_shift_left): Remove.\n\t(slll_1): Remove.\n\t(slll_2): Remove.\n\t(ashlsi3): Remove.\n\t(ashldi3): Remove.\n\t(ashrhi3): Remove.\n\t(srai_1): Remove.\n\t(430x_arithmetic_shift_right): Remove.\n\t(srap_1): Remove.\n\t(srap_2): Remove.\n\t(sral_1): Remove.\n\t(sral_2): Remove.\n\t(ashrsi3): Remove.\n\t(ashrdi3): Remove.\n\t(lshrhi3): Remove.\n\t(srli_1): Remove.\n\t(430x_logical_shift_right): Remove.\n\t(srlp_1): Remove.\n\t(srll_1): Remove.\n\t(srll_2x): Remove.\n\t(lshrsi3): Remove.\n\t(lshrdi3): Remove.\n\t(<shift_insn><mode>3): New define_expand.\n\t(<shift_insn>hi3_430): New define_insn.\n\t(<shift_insn>si3_const): Likewise.\n\t(ashl<mode>3_430x): Likewise.\n\t(ashr<mode>3_430x): Likewise.\n\t(lshr<mode>3_430x): Likewise.\n\t(*bitbranch<mode>4_z): Replace renamed predicate msp430_bitpos with\n\tconst_0_to_15_operand.\n\t* config/msp430/msp430.opt: New option -mmax-inline-shift=.\n\t* config/msp430/predicates.md (const_1_to_8_operand): New predicate.\n\t(const_0_to_15_operand): Rename msp430_bitpos predicate.\n\t(const_1_to_19_operand): New predicate.\n\t* doc/invoke.texi: Document -mmax-inline-shift=.\n\nlibgcc/ChangeLog:\n\n\t* config/msp430/slli.S (__gnu_mspabi_sllp): New.\n\t* config/msp430/srai.S (__gnu_mspabi_srap): New.\n\t* config/msp430/srli.S (__gnu_mspabi_srlp): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/msp430/emulate-srli.c: Fix expected assembler text.\n\t* gcc.target/msp430/max-inline-shift-430-no-opt.c: New test.\n\t* gcc.target/msp430/max-inline-shift-430.c: New test.\n\t* gcc.target/msp430/max-inline-shift-430x.c: New test.", "tree": {"sha": "95b123c1addb55a099b7377733df2c8437aa2b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95b123c1addb55a099b7377733df2c8437aa2b8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/703e049aa72e01c15087750fe63deba779c9b2dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703e049aa72e01c15087750fe63deba779c9b2dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703e049aa72e01c15087750fe63deba779c9b2dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703e049aa72e01c15087750fe63deba779c9b2dd/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af06acfc8de1ddcfd02a4de1200735b5479f086f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af06acfc8de1ddcfd02a4de1200735b5479f086f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af06acfc8de1ddcfd02a4de1200735b5479f086f"}], "stats": {"total": 901, "additions": 527, "deletions": 374}, "files": [{"sha": "b8f9674b2fe4632daa603d85a0b24eb0d69be7ef", "filename": "gcc/config/msp430/constraints.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fconstraints.md?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -25,15 +25,16 @@\n   \"Register R13.\")\n \n (define_constraint \"K\"\n-  \"Integer constant 1.\"\n+  \"Integer constant 1-19.\"\n   (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (ival, 1, 1)\")))\n+       (match_test \"IN_RANGE (ival, 1, 19)\")))\n \n (define_constraint \"L\"\n   \"Integer constant -1^20..1^19.\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, HOST_WIDE_INT_M1U << 20, 1 << 19)\")))\n \n+;; Valid shift amount for RRUM, RRAM, RLAM, RRCM.\n (define_constraint \"M\"\n   \"Integer constant 1-4.\"\n   (and (match_code \"const_int\")\n@@ -49,6 +50,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, 256, 65535)\")))\n \n+(define_constraint \"P\"\n+  \"Integer constant 1-16.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 1, 16)\")))\n+\n ;; We do not allow arbitrary constants, eg symbols or labels,\n ;; because their address may be above the 16-bit address limit\n ;; supported by the offset used in the MOVA instruction."}, {"sha": "0b4d9a42b4130929525b62a101e6d535493c6f78", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -35,7 +35,6 @@ rtx\tmsp430_incoming_return_addr_rtx (void);\n void\tmsp430_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n int\tmsp430_initial_elimination_offset (int, int);\n bool    msp430_is_interrupt_func (void);\n-const char * msp430x_logical_shift_right (rtx);\n const char * msp430_mcu_name (void);\n void    msp430_output_aligned_decl_common (FILE *, const tree, const char *,\n \t\t\t\t\t   unsigned HOST_WIDE_INT, unsigned,\n@@ -51,4 +50,9 @@ bool    msp430_use_f5_series_hwmult (void);\n bool\tmsp430_has_hwmult (void);\n bool msp430_op_not_in_high_mem (rtx op);\n \n+#ifdef RTX_CODE\n+int msp430_expand_shift (enum rtx_code code, machine_mode mode, rtx *operands);\n+const char * msp430_output_asm_shift_insns (enum rtx_code code, machine_mode mode, rtx *operands);\n+#endif\n+\n #endif /* GCC_MSP430_PROTOS_H */"}, {"sha": "c2b24974364f05d96129059f0845ff1b082c2ccd", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 190, "deletions": 82, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -1064,15 +1064,6 @@ static bool msp430_rtx_costs (rtx\t   x ATTRIBUTE_UNUSED,\n \t  return true;\n \t}\n       break;\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (!msp430x)\n-\t{\n-\t  *total = COSTS_N_INSNS (100);\n-\t  return true;\n-\t}\n-      break;\n     }\n   return false;\n }\n@@ -2674,32 +2665,6 @@ msp430_init_dwarf_reg_sizes_extra (tree address)\n     }\n }\n \n-/* This is a list of MD patterns that implement fixed-count shifts.  */\n-static struct\n-{\n-  const char *name;\n-  int count;\n-  int need_430x;\n-  rtx (*genfunc)(rtx,rtx);\n-}\n-const_shift_helpers[] =\n-{\n-#define CSH(N,C,X,G) { \"__mspabi_\" N, C, X, gen_##G }\n-\n-  CSH (\"slli\", 1, 1, slli_1),\n-  CSH (\"slll\", 1, 1, slll_1),\n-  CSH (\"slll\", 2, 1, slll_2),\n-\n-  CSH (\"srai\", 1, 0, srai_1),\n-  CSH (\"sral\", 1, 0, sral_1),\n-  CSH (\"sral\", 2, 0, sral_2),\n-\n-  CSH (\"srll\", 1, 0, srll_1),\n-  CSH (\"srll\", 2, 1, srll_2x),\n-  { 0, 0, 0, 0 }\n-#undef CSH\n-};\n-\n /* The MSP430 ABI defines a number of helper functions that should be\n    used for, for example, 32-bit shifts.  This function is called to\n    emit such a function, using the table above to optimize some\n@@ -2716,31 +2681,12 @@ msp430_expand_helper (rtx *operands, const char *helper_name,\n   machine_mode arg0mode = GET_MODE (operands[0]);\n   machine_mode arg1mode = GET_MODE (operands[1]);\n   machine_mode arg2mode = GET_MODE (operands[2]);\n-  int have_430x = msp430x ? 1 : 0;\n   int expand_mpy = strncmp (helper_name, \"__mspabi_mpy\",\n \t\t\t    sizeof (\"__mspabi_mpy\") - 1) == 0;\n   /* This function has been used incorrectly if CONST_VARIANTS is TRUE for a\n      hwmpy function.  */\n   gcc_assert (!(expand_mpy && const_variants));\n \n-  /* Emit size-optimal insns for small shifts we can easily do inline.  */\n-  if (CONST_INT_P (operands[2]) && !expand_mpy)\n-    {\n-      int i;\n-\n-      for (i=0; const_shift_helpers[i].name; i++)\n-\t{\n-\t  if (const_shift_helpers[i].need_430x <= have_430x\n-\t      && strcmp (helper_name, const_shift_helpers[i].name) == 0\n-\t      && INTVAL (operands[2]) == const_shift_helpers[i].count)\n-\t    {\n-\t      emit_insn (const_shift_helpers[i].genfunc (operands[0],\n-\t\t\t\t\t\t\t operands[1]));\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n   if (arg1mode != VOIDmode && arg2mode != VOIDmode)\n     /* Modes of arguments must be equal if not constants.  */\n     gcc_assert (arg1mode == arg2mode);\n@@ -2835,6 +2781,190 @@ msp430_expand_helper (rtx *operands, const char *helper_name,\n \t\t  gen_rtx_REG (arg0mode, 12));\n }\n \n+/* Return TRUE if the helper function should be used and FALSE if the shifts\n+   insns should be emitted inline.  */\n+static bool\n+use_helper_for_const_shift (enum rtx_code code, machine_mode mode,\n+\t\t\t    HOST_WIDE_INT amt)\n+{\n+  const int default_inline_shift = 4;\n+  /* We initialize the option to 65 so we know if the user set it or not.  */\n+  int user_set_max_inline = (msp430_max_inline_shift == 65 ? 0 : 1);\n+  int max_inline = (user_set_max_inline ? msp430_max_inline_shift\n+\t\t    : default_inline_shift);\n+  /* 32-bit shifts are roughly twice as costly as 16-bit shifts so we adjust\n+     the heuristic accordingly.  */\n+  int max_inline_32 = max_inline / 2;\n+\n+  /* Don't use helpers for these modes on 430X, when optimizing for speed, or\n+     when emitting a small number of insns.  */\n+  if ((mode == E_QImode || mode == E_HImode || mode == E_PSImode)\n+      && (msp430x\n+\t  /* If the user set max_inline then we always obey that number.\n+\t     Otherwise we always emit the shifts inline at -O2 and above.  */\n+\t  || amt <= max_inline\n+\t  || (!user_set_max_inline\n+\t      && (optimize >= 2 && !optimize_size))))\n+    return false;\n+\n+  /* 430 and 430X codegen for SImode shifts is the same.\n+     Set a hard limit of 15 for the number of shifts that will be emitted\n+     inline by default, even at -O2 and above, to prevent code size\n+     explosion.  */\n+  if (mode == E_SImode\n+      && (amt <= max_inline_32\n+\t  || (!user_set_max_inline\n+\t      && (optimize >= 2 && !optimize_size)\n+\t      && amt <= 15)))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* For shift operations which will use an mspabi helper function, setup the\n+   call to msp430_expand helper.  Return 1 to indicate we have finished with\n+   this insn and invoke \"DONE\".\n+   Otherwise return 0 to indicate the insn should fallthrough.\n+   Never FAIL.  */\n+int\n+msp430_expand_shift (enum rtx_code code, machine_mode mode, rtx *operands)\n+{\n+  /* Always use the helper function when the shift amount is not a\n+     constant.  */\n+  if (!CONST_INT_P (operands[2])\n+      || mode == E_DImode\n+      || use_helper_for_const_shift (code, mode, INTVAL (operands[2])))\n+    {\n+      const char *helper_name = NULL;\n+      /* The const variants of mspabi shifts have significantly larger code\n+\t size than the generic version, so use the generic version if\n+\t optimizing for size.  */\n+      bool const_variant = !optimize_size;\n+      switch (mode)\n+\t{\n+\tcase E_HImode:\n+\t  helper_name = (code == ASHIFT ? \"__mspabi_slli\" :\n+\t\t\t (code == ASHIFTRT ? \"__mspabi_srai\" :\n+\t\t\t  (code == LSHIFTRT ? \"__mspabi_srli\" :\n+\t\t\t   NULL)));\n+\t  break;\n+\tcase E_PSImode:\n+\t  helper_name = (code == ASHIFT ? \"__gnu_mspabi_sllp\" :\n+\t\t\t (code == ASHIFTRT ? \"__gnu_mspabi_srap\" :\n+\t\t\t  (code == LSHIFTRT ? \"__gnu_mspabi_srlp\" :\n+\t\t\t   NULL)));\n+\t  /* No const variant for PSImode shifts FIXME.  */\n+\t  const_variant = false;\n+\t  break;\n+\tcase E_SImode:\n+\t  helper_name = (code == ASHIFT ? \"__mspabi_slll\" :\n+\t\t\t (code == ASHIFTRT ? \"__mspabi_sral\" :\n+\t\t\t  (code == LSHIFTRT ? \"__mspabi_srll\" :\n+\t\t\t   NULL)));\n+\t  break;\n+\tcase E_DImode:\n+\t  helper_name = (code == ASHIFT ? \"__mspabi_sllll\" :\n+\t\t\t (code == ASHIFTRT ? \"__mspabi_srall\" :\n+\t\t\t  (code == LSHIFTRT ? \"__mspabi_srlll\" :\n+\t\t\t   NULL)));\n+\t  /* No const variant for DImode shifts.  */\n+\t  const_variant = false;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+      gcc_assert (helper_name);\n+      msp430_expand_helper (operands, helper_name, const_variant);\n+      return 1;\n+    }\n+  /* When returning 0, there must be an insn to match the RTL pattern\n+     otherwise there will be an unrecognizeable insn.  */\n+  return 0;\n+}\n+\n+/* Helper function to emit a sequence of shift instructions.  The amount of\n+   shift instructions to emit is in OPERANDS[2].\n+   For 430 we output copies of identical inline shifts for all modes.\n+   For 430X it is inneficient to do so for any modes except SI and DI, since we\n+   can make use of R*M insns or RPT with 430X insns, so this function is only\n+   used for SImode in that case.  */\n+const char *\n+msp430_output_asm_shift_insns (enum rtx_code code, machine_mode mode,\n+\t\t\t       rtx *operands)\n+{\n+  int i;\n+  int amt;\n+  int max_shift = GET_MODE_BITSIZE (mode) - 1;\n+  gcc_assert (CONST_INT_P (operands[2]));\n+  amt = INTVAL (operands[2]);\n+\n+  if (amt == 0 || amt > max_shift)\n+    {\n+      switch (code)\n+\t{\n+\tcase ASHIFT:\n+\t  output_asm_insn (\"# ignored undefined behaviour left shift \"\n+\t\t\t   \"of %1 by %2\", operands);\n+\t  break;\n+\tcase ASHIFTRT:\n+\t  output_asm_insn (\"# ignored undefined behaviour arithmetic right \"\n+\t\t\t   \"shift of %1 by %2\", operands);\n+\t  break;\n+\tcase LSHIFTRT:\n+\t  output_asm_insn (\"# ignored undefined behaviour logical right shift \"\n+\t\t\t   \"of %1 by %2\", operands);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      return \"\";\n+    }\n+\n+  if (code == ASHIFT)\n+    {\n+      if (!msp430x && mode == HImode)\n+\tfor (i = 0; i < amt; i++)\n+\t  output_asm_insn (\"RLA.W\\t%0\", operands);\n+      else if (mode == SImode)\n+\tfor (i = 0; i < amt; i++)\n+\t  output_asm_insn (\"RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0\", operands);\n+      else\n+\t/* Catch unhandled cases.  */\n+\tgcc_unreachable ();\n+    }\n+  else if (code == ASHIFTRT)\n+    {\n+      if (!msp430x && mode == HImode)\n+\tfor (i = 0; i < amt; i++)\n+\t  output_asm_insn (\"RRA.W\\t%0\", operands);\n+      else if (mode == SImode)\n+\tfor (i = 0; i < amt; i++)\n+\t  output_asm_insn (\"RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (code == LSHIFTRT)\n+    {\n+      if (!msp430x && mode == HImode)\n+\tfor (i = 0; i < amt; i++)\n+\t  output_asm_insn (\"CLRC { RRC.W\\t%0\", operands);\n+      else if (mode == SImode)\n+\tfor (i = 0; i < amt; i++)\n+\t  output_asm_insn (\"CLRC { RRC%X0.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+      /* FIXME: Why doesn't \"RRUX.W\\t%H0 { RRC%X0.W\\t%L0\" work for msp430x?\n+\t It causes execution timeouts e.g. pr41963.c.  */\n+#if 0\n+      else if (msp430x && mode == SImode)\n+\tfor (i = 0; i < amt; i++)\n+\t  output_asm_insn (\"RRUX.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+#endif\n+      else\n+\tgcc_unreachable ();\n+    }\n+  return \"\";\n+}\n+\n /* Called by cbranch<mode>4 to coerce operands into usable forms.  */\n void\n msp430_fixup_compare_operands (machine_mode my_mode, rtx * operands)\n@@ -3368,6 +3498,7 @@ msp430_op_not_in_high_mem (rtx op)\n    O   offset of the top of the stack\n    Q   like X but generates an A postfix\n    R   inverse of condition code, unsigned.\n+   W   value - 16\n    X   X instruction postfix in large mode\n    Y   value - 4\n    Z   value - 1\n@@ -3394,6 +3525,11 @@ msp430_print_operand (FILE * file, rtx op, int letter)\n       /* Print the constant value, less four.  */\n       fprintf (file, \"#%ld\", INTVAL (op) - 4);\n       return;\n+    case 'W':\n+      gcc_assert (CONST_INT_P (op));\n+      /* Print the constant value, less 16.  */\n+      fprintf (file, \"#%ld\", INTVAL (op) - 16);\n+      return;\n     case 'I':\n       if (GET_CODE (op) == CONST_INT)\n \t{\n@@ -3711,34 +3847,6 @@ msp430x_extendhisi (rtx * operands)\n   return \"MOV.W\\t%1, %L0 { MOV.W\\t%1, %H0 { RPT\\t#15 { RRAX.W\\t%H0\";\n }\n \n-/* Likewise for logical right shifts.  */\n-const char *\n-msp430x_logical_shift_right (rtx amount)\n-{\n-  /* The MSP430X's logical right shift instruction - RRUM - does\n-     not use an extension word, so we cannot encode a repeat count.\n-     Try various alternatives to work around this.  If the count\n-     is in a register we are stuck, hence the assert.  */\n-  gcc_assert (CONST_INT_P (amount));\n-\n-  if (INTVAL (amount) <= 0\n-      || INTVAL (amount) >= 16)\n-    return \"# nop logical shift.\";\n-\n-  if (INTVAL (amount) > 0\n-      && INTVAL (amount) < 5)\n-    return \"rrum.w\\t%2, %0\"; /* Two bytes.  */\n-\n-  if (INTVAL (amount) > 4\n-      && INTVAL (amount) < 9)\n-    return \"rrum.w\\t#4, %0 { rrum.w\\t%Y2, %0 \"; /* Four bytes.  */\n-\n-  /* First we logically shift right by one.  Now we know\n-     that the top bit is zero and we can use the arithmetic\n-     right shift instruction to perform the rest of the shift.  */\n-  return \"rrum.w\\t#1, %0 { rpt\\t%Z2 { rrax.w\\t%0\"; /* Six bytes.  */\n-}\n-\n /* Stop GCC from thinking that it can eliminate (SUBREG:PSI (SI)).  */\n \n #undef TARGET_CAN_CHANGE_MODE_CLASS"}, {"sha": "f70e61b97ddf8310dc67d8e3ae1c10fe0bb456b3", "filename": "gcc/config/msp430/msp430.md", "status": "modified", "additions": 96, "deletions": 285, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.md?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -65,6 +65,15 @@\n (include \"constraints.md\")\n \n (define_mode_iterator QHI [QI HI PSI])\n+(define_mode_iterator HPSI [HI PSI])\n+(define_mode_iterator HDI [HI PSI SI DI])\n+\n+;; Mapping of all shift operators\n+(define_code_iterator any_shift [ashift ashiftrt lshiftrt])\n+\n+;; Base name for define_insn\n+(define_code_attr shift_insn\n+  [(ashift \"ashl\") (lshiftrt \"lshr\") (ashiftrt \"ashr\")])\n \n ;; There are two basic \"family\" tests we do here:\n ;;\n@@ -689,31 +698,42 @@\n    MOV%X1.B\\t%1, %0\"\n )\n \n+;; The next three insns emit identical assembly code.\n+;; They take a QImode and shift it in SImode.  Only shift counts <= 8\n+;; are handled since that is the simple case where the high 16-bits (i.e. the\n+;; high register) are always 0.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (zero_extend:SI (match_operand:QI 1 \"general_operand\" \"rm\"))\n-\t\t   (match_operand:HI 2 \"immediate_operand\" \"M\")))]\n+  [(set (match_operand:SI\t\t\t     0 \"register_operand\" \"=r,r,r\")\n+\t(ashift:SI (zero_extend:SI (match_operand:QI 1 \"general_operand\" \"0,rm,rm\"))\n+\t\t   (match_operand:HI\t\t     2 \"const_1_to_8_operand\" \"M,M,i\")))]\n   \"msp430x\"\n-  \"MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\"\n+  \"@\n+  RLAM.W %2, %L0 { CLR %H0\n+  MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\n+  MOV%X1.B %1, %L0 { RPT %2 { RLAX.W %L0 { CLR %H0\"\n )\n \n-;; We are taking a char and shifting it and putting the result in 2 registers.\n-;; the high register will always be for 0 shift counts < 8.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (zero_extend:SI (subreg:HI (match_operand:QI 1 \"general_operand\" \"rm\") 0))\n-\t\t   (match_operand:HI 2 \"immediate_operand\" \"M\")))]\n+  [(set (match_operand:SI\t\t\t     \t\t0 \"register_operand\" \"=r,r,r\")\n+\t(ashift:SI (zero_extend:SI (subreg:HI (match_operand:QI 1 \"general_operand\" \"0,rm,rm\") 0))\n+\t\t   (match_operand:HI\t\t     \t\t2 \"const_1_to_8_operand\" \"M,M,i\")))]\n   \"msp430x\"\n-  \"MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\"\n+  \"@\n+  RLAM.W %2, %L0 { CLR %H0\n+  MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\n+  MOV%X1.B %1, %L0 { RPT %2 { RLAX.W %L0 { CLR %H0\"\n )\n \n ;; Same as above but with a NOP sign_extend round the subreg\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (zero_extend:SI (sign_extend:PSI (subreg:HI (match_operand:QI 1 \"general_operand\" \"rm\") 0)))\n-\t\t   (match_operand:HI 2 \"immediate_operand\" \"M\")))]\n+  [(set (match_operand:SI\t\t\t     \t\t\t\t 0 \"register_operand\" \"=r,r,r\")\n+\t(ashift:SI (zero_extend:SI (sign_extend:PSI (subreg:HI (match_operand:QI 1 \"general_operand\" \"0,rm,rm\") 0)))\n+\t\t   (match_operand:HI\t\t     \t\t\t\t 2 \"const_1_to_8_operand\" \"M,M,i\")))]\n   \"msp430x\"\n-  \"MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\"\n+  \"@\n+  RLAM.W %2, %L0 { CLR %H0\n+  MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\n+  MOV%X1.B %1, %L0 { RPT %2 { RLAX.W %L0 { CLR %H0\"\n )\n \n (define_insn \"\"\n@@ -724,11 +744,14 @@\n )\n \n (define_insn \"\"\n-  [(set (match_operand:PSI 0 \"register_operand\" \"=r\")\n-\t(ashift:PSI (sign_extend:PSI (subreg:HI (match_operand:QI 1 \"general_operand\" \"rm\") 0))\n-\t\t    (match_operand:HI 2 \"immediate_operand\" \"M\")))]\n+  [(set (match_operand:PSI\t\t\t\t\t  0 \"register_operand\" \"=r,r,r\")\n+\t(ashift:PSI (sign_extend:PSI (subreg:HI (match_operand:QI 1 \"general_operand\" \"0,rm,rm\") 0))\n+\t\t    (match_operand:HI\t\t\t\t  2 \"const_1_to_19_operand\" \"M,M,i\")))]\n   \"msp430x\"\n-  \"MOV%X1.B %1, %0 { RLAM.W %2, %0\"\n+  \"@\n+  RLAM.W %2, %0\n+  MOV%X1.B %1, %0 { RLAM.W %2, %0\n+  MOV%X1.B %1, %0 { RPT %2 { RLAX.A %0\"\n )\n ;; END msp430 pointer manipulation combine insn patterns\n \n@@ -840,287 +863,75 @@\n ;; Note - we ignore shift counts of less than one or more than 15.\n ;; This is permitted by the ISO C99 standard as such shifts result\n ;; in \"undefined\" behavior.  [6.5.7 (3)]\n+;;\n+;; We avoid emitting insns in msp430_expand_shift, since we would have to handle\n+;; many extra cases such as op0 != op1, or, op0 or op1 in memory.  Instead we\n+;; let reload coerce op0 and op1 into the same register.\n \n-;; signed A << C\n-\n-(define_expand \"ashlhi3\"\n-  [(set (match_operand:HI\t     0 \"msp430_general_dst_nonv_operand\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\")\n-\t\t   (match_operand:HI 2 \"general_operand\")))]\n+(define_expand \"<shift_insn><mode>3\"\n+  [(set (match_operand:HDI\t\t  0 \"msp430_general_dst_nonv_operand\")\n+\t(any_shift:HDI (match_operand:HDI 1 \"general_operand\")\n+\t\t       (match_operand:HDI 2 \"general_operand\")))]\n   \"\"\n   {\n-    if ((GET_CODE (operands[1]) == SUBREG\n-\t && REG_P (XEXP (operands[1], 0)))\n-\t|| MEM_P (operands[1]))\n-      operands[1] = force_reg (HImode, operands[1]);\n-    if (msp430x\n-        && REG_P (operands[0])\n-        && REG_P (operands[1])\n-        && CONST_INT_P (operands[2]))\n-      emit_insn (gen_430x_shift_left (operands[0], operands[1], operands[2]));\n-    else if (CONST_INT_P (operands[2])\n-\t     && INTVAL (operands[2]) == 1)\n-      emit_insn (gen_slli_1 (operands[0], operands[1]));\n-    else\t\t \n-      /* The const variants of mspabi shifts have larger code size than the\n-\t generic version, so use the generic version if optimizing for\n-\t size.  */\n-      msp430_expand_helper (operands, \\\"__mspabi_slli\\\", !optimize_size);\n-    DONE;\n+    if (msp430_expand_shift (<CODE>, <MODE>mode, operands))\n+      DONE;\n+    /* Otherwise, fallthrough.  */\n   }\n )\n \n-(define_insn \"slli_1\"\n-  [(set (match_operand:HI\t     0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n-\t\t   (const_int 1)))]\n-  \"\"\n-  \"RLA%X0.W\\t%0\" ;; Note - this is a macro for ADD\n-)\n-\n-(define_insn \"430x_shift_left\"\n-  [(set (match_operand:HI            0 \"register_operand\" \"=r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\"  \"0\")\n-\t\t   (match_operand    2 \"immediate_operand\" \"n\")))]\n-  \"msp430x\"\n-  \"*\n-  if (INTVAL (operands[2]) > 0 && INTVAL (operands[2]) < 5)\n-    return \\\"RLAM.W\\t%2, %0\\\";\n-  else if (INTVAL (operands[2]) >= 5 && INTVAL (operands[2]) < 16)\n-    return \\\"RPT\\t%2 { RLAX.W\\t%0\\\";\n-  return \\\"# nop left shift\\\";\n-  \"\n+;; All 430 HImode constant shifts\n+(define_insn \"<shift_insn>hi3_430\"\n+  [(set (match_operand:HI\t\t0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n+\t(any_shift:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n+\t\t      (match_operand:HI 2 \"const_int_operand\"     \"n\")))]\n+  \"!msp430x\"\n+  \"* return msp430_output_asm_shift_insns (<CODE>, HImode, operands);\"\n )\n \n-(define_insn \"slll_1\"\n-  [(set (match_operand:SI\t     0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n-\t\t   (const_int 1)))]\n+;; All 430 and 430X SImode constant shifts\n+(define_insn \"<shift_insn>si3_const\"\n+  [(set (match_operand:SI\t\t0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n+\t(any_shift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n+\t\t      (match_operand:SI 2 \"const_int_operand\"     \"n\")))]\n   \"\"\n-  \"RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0\"\n-)\n-\n-(define_insn \"slll_2\"\n-  [(set (match_operand:SI\t     0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n-\t\t   (const_int 2)))]\n-  \"\"\n-  \"RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0 { RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0\"\n-)\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI\t     0 \"msp430_general_dst_nonv_operand\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\")\n-\t\t   (match_operand:SI 2 \"general_operand\")))]\n-  \"\"\n-  \"msp430_expand_helper (operands, \\\"__mspabi_slll\\\", !optimize_size);\n-   DONE;\"\n-)\n-\n-(define_expand \"ashldi3\"\n-  [(set (match_operand:DI\t     0 \"msp430_general_dst_nonv_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\")\n-\t\t   (match_operand:DI 2 \"general_operand\")))]\n-  \"\"\n-  {\n-    /* No const_variant for 64-bit shifts.  */\n-    msp430_expand_helper (operands, \\\"__mspabi_sllll\\\", false);\n-    DONE;\n-  }\n-)\n-\n-;;----------\n-\n-;; signed A >> C\n-\n-(define_expand \"ashrhi3\"\n-  [(set (match_operand:HI\t       0 \"msp430_general_dst_nonv_operand\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\")\n-\t\t     (match_operand:HI 2 \"general_operand\")))]\n-  \"\"\n-  {\n-    if ((GET_CODE (operands[1]) == SUBREG\n-\t && REG_P (XEXP (operands[1], 0)))\n-\t|| MEM_P (operands[1]))\n-      operands[1] = force_reg (HImode, operands[1]);\n-    if (msp430x\n-        && REG_P (operands[0])\n-        && REG_P (operands[1])\n-        && CONST_INT_P (operands[2]))\n-      emit_insn (gen_430x_arithmetic_shift_right (operands[0], operands[1], operands[2]));\n-    else if (CONST_INT_P (operands[2])\n-\t     && INTVAL (operands[2]) == 1)\n-      emit_insn (gen_srai_1 (operands[0], operands[1]));\n-    else\t\t \n-       msp430_expand_helper (operands, \\\"__mspabi_srai\\\", !optimize_size);\n-   DONE;\n-   }\n-)\n-\n-(define_insn \"srai_1\"\n-  [(set (match_operand:HI\t       0 \"msp430_general_dst_operand\" \"=rm\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"msp430_general_operand\"      \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"RRA%X0.W\\t%0\"\n-)\n-\n-(define_insn \"430x_arithmetic_shift_right\"\n-  [(set (match_operand:HI              0 \"register_operand\" \"=r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0\")\n-\t\t     (match_operand    2 \"immediate_operand\" \"n\")))]\n-  \"msp430x\"\n-  \"*\n-  if (INTVAL (operands[2]) > 0 && INTVAL (operands[2]) < 5)\n-    return \\\"RRAM.W\\t%2, %0\\\";\n-  else if (INTVAL (operands[2]) >= 5 && INTVAL (operands[2]) < 16)\n-    return \\\"RPT\\t%2 { RRAX.W\\t%0\\\";\n-  return \\\"# nop arith right shift\\\";\n-  \"\n-)\n-\n-(define_insn \"srap_1\"\n-  [(set (match_operand:PSI              0 \"register_operand\" \"=r\")\n-\t(ashiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n-\t\t      (const_int 1)))]\n-  \"msp430x\"\n-  \"RRAM.A #1,%0\"\n+  \"* return msp430_output_asm_shift_insns (<CODE>, SImode, operands);\"\n )\n \n-(define_insn \"srap_2\"\n-  [(set (match_operand:PSI              0 \"register_operand\" \"=r\")\n-\t(ashiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n-\t\t      (const_int 2)))]\n+(define_insn \"ashl<mode>3_430x\"\n+  [(set (match_operand:HPSI\t\t 0 \"msp430_general_dst_nonv_operand\" \"=r,r,r,r\")\n+\t(ashift:HPSI (match_operand:HPSI 1 \"general_operand\" \t\t     \"0 ,0,0,0\")\n+\t\t     (match_operand:HPSI 2 \"const_int_operand\" \t\t     \"M ,P,K,i\")))]\n   \"msp430x\"\n-  \"RRAM.A #2,%0\"\n-)\n-\n-(define_insn \"sral_1\"\n-  [(set (match_operand:SI\t       0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0\"\n-)\n-\n-(define_insn \"sral_2\"\n-  [(set (match_operand:SI\t       0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n-\t\t     (const_int 2)))]\n-  \"\"\n-  \"RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0 { RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0\"\n-)\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI\t       0 \"msp430_general_dst_nonv_operand\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\")\n-\t\t     (match_operand:SI 2 \"general_operand\")))]\n-  \"\"\n-  \"msp430_expand_helper (operands, \\\"__mspabi_sral\\\", !optimize_size);\n-   DONE;\"\n-)\n-\n-(define_expand \"ashrdi3\"\n-  [(set (match_operand:DI\t     0 \"msp430_general_dst_nonv_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\")\n-\t\t   (match_operand:DI 2 \"general_operand\")))]\n-  \"\"\n-  {\n-    /* No const_variant for 64-bit shifts.  */\n-    msp430_expand_helper (operands, \\\"__mspabi_srall\\\", false);\n-    DONE;\n-  }\n-)\n-\n-;;----------\n-\n-;; unsigned A >> C\n-\n-(define_expand \"lshrhi3\"\n-  [(set (match_operand:HI\t       0 \"msp430_general_dst_nonv_operand\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\")\n-\t\t     (match_operand:HI 2 \"general_operand\")))]\n-  \"\"\n-  {\n-    if ((GET_CODE (operands[1]) == SUBREG\n-\t && REG_P (XEXP (operands[1], 0)))\n-\t|| MEM_P (operands[1]))\n-      operands[1] = force_reg (HImode, operands[1]);\n-    if (msp430x\n-        && REG_P (operands[0])\n-        && REG_P (operands[1])\n-        && CONST_INT_P (operands[2]))\n-      emit_insn (gen_430x_logical_shift_right (operands[0], operands[1], operands[2]));\n-    else if (CONST_INT_P (operands[2])\n-\t     && INTVAL (operands[2]) == 1)\n-      emit_insn (gen_srli_1 (operands[0], operands[1]));\n-    else\t\t \n-      msp430_expand_helper (operands, \\\"__mspabi_srli\\\", !optimize_size);\n-    DONE;\n-  }\n-)\n-\n-(define_insn \"srli_1\"\n-  [(set (match_operand:HI\t       0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"CLRC { RRC%X0.W\\t%0\"\n+  \"@\n+  RLAM%b0\\t%2, %0\n+  RPT\\t%2 { RLAX%b0\\t%0\n+  RPT\\t#16 { RLAX%b0\\t%0 { RPT\\t%W2 { RLAX%b0\\t%0\n+  # undefined behavior left shift of %1 by %2\"\n )\n \n-(define_insn \"430x_logical_shift_right\"\n-  [(set (match_operand:HI              0 \"register_operand\" \"=r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0\")\n-\t\t     (match_operand    2 \"immediate_operand\" \"n\")))]\n+(define_insn \"ashr<mode>3_430x\"\n+  [(set (match_operand:HPSI\t\t   0 \"msp430_general_dst_nonv_operand\" \"=r,r,r,r\")\n+\t(ashiftrt:HPSI (match_operand:HPSI 1 \"general_operand\"\t  \t     \"0,0,0,0\")\n+\t\t       (match_operand:HPSI 2 \"const_int_operand\" \t     \"M,P,K,i\")))]\n   \"msp430x\"\n-  {\n-    return msp430x_logical_shift_right (operands[2]);\n-  }\n-)\n-\n-(define_insn \"srlp_1\"\n-  [(set (match_operand:PSI              0 \"register_operand\" \"=r\")\n-\t(lshiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n-\t\t      (const_int 1)))]\n-  \"\"\n-  \"RRUM.A #1,%0\"\n-)\n-\n-(define_insn \"srll_1\"\n-  [(set (match_operand:SI\t       0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"CLRC { RRC%X0.W\\t%H0 { RRC%X0.W\\t%L0\"\n+  \"@\n+  RRAM%b0\\t%2, %0\n+  RPT\\t%2 { RRAX%b0\\t%0\n+  RPT\\t#16 { RRAX%b0\\t%0 { RPT\\t%W2 { RRAX%b0\\t%0\n+  # undefined behavior arithmetic right shift of %1 by %2\"\n )\n \n-(define_insn \"srll_2x\"\n-  [(set (match_operand:SI\t       0 \"msp430_general_dst_nonv_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n-\t\t     (const_int 2)))]\n+(define_insn \"lshr<mode>3_430x\"\n+  [(set (match_operand:HPSI\t\t   0 \"msp430_general_dst_nonv_operand\" \"=r,r,r,r\")\n+\t(lshiftrt:HPSI (match_operand:HPSI 1 \"general_operand\"\t  \t     \"0,0,0,0\")\n+\t\t       (match_operand:HPSI 2 \"const_int_operand\" \t     \"M,P,K,i\")))]\n   \"msp430x\"\n-  \"RRUX.W\\t%H0 { RRC.W\\t%L0 { RRUX.W\\t%H0 { RRC.W\\t%L0\"\n-)\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI\t       0 \"msp430_general_dst_nonv_operand\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\")\n-\t\t     (match_operand:SI 2 \"general_operand\")))]\n-  \"\"\n-  \"msp430_expand_helper (operands, \\\"__mspabi_srll\\\", !optimize_size);\n-   DONE;\"\n-)\n-\n-(define_expand \"lshrdi3\"\n-  [(set (match_operand:DI\t     0 \"msp430_general_dst_nonv_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\")\n-\t\t   (match_operand:DI 2 \"general_operand\")))]\n-  \"\"\n-  {\n-    /* No const_variant for 64-bit shifts.  */\n-    msp430_expand_helper (operands, \\\"__mspabi_srlll\\\", false);\n-    DONE;\n-  }\n+  \"@\n+  RRUM%b0\\t%2, %0\n+  RPT\\t%2 { RRUX%b0\\t%0\n+  RPT\\t#16 { RRUX%b0\\t%0 { RPT\\t%W2 { RRUX%b0\\t%0\n+  # undefined behavior logical right shift of %1 by %2\"\n )\n \n ;;------------------------------------------------------------\n@@ -1427,7 +1238,7 @@\n   [(set (pc) (if_then_else\n \t      (ne (zero_extract:HI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rYs,rm\")\n \t\t\t\t    (const_int 1)\n-\t\t\t\t    (match_operand 1 \"msp430_bitpos\" \"i,i\"))\n+\t\t\t\t    (match_operand 1 \"const_0_to_15_operand\" \"i,i\"))\n \t\t  (const_int 0))\n               (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n@@ -1443,7 +1254,7 @@\n   [(set (pc) (if_then_else\n \t      (eq (zero_extract:HI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rm\")\n \t\t\t\t   (const_int 1)\n-\t\t\t\t   (match_operand 1 \"msp430_bitpos\" \"i\"))\n+\t\t\t\t   (match_operand 1 \"const_0_to_15_operand\" \"i\"))\n \t\t  (const_int 0))\n               (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n@@ -1457,7 +1268,7 @@\n   [(set (pc) (if_then_else\n \t      (eq (zero_extract:HI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rm\")\n \t\t\t\t   (const_int 1)\n-\t\t\t\t   (match_operand 1 \"msp430_bitpos\" \"i\"))\n+\t\t\t\t   (match_operand 1 \"const_0_to_15_operand\" \"i\"))\n \t\t  (const_int 0))\n               (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))\n@@ -1471,7 +1282,7 @@\n   [(set (pc) (if_then_else\n \t      (ne (zero_extract:HI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rm\")\n \t\t\t\t   (const_int 1)\n-\t\t\t\t   (match_operand 1 \"msp430_bitpos\" \"i\"))\n+\t\t\t\t   (match_operand 1 \"const_0_to_15_operand\" \"i\"))\n \t\t  (const_int 0))\n               (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))"}, {"sha": "8134ca7ac95ca5c105b3d5c8dcade80fadbaf964", "filename": "gcc/config/msp430/msp430.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -109,3 +109,9 @@ mdevices-csv-loc=\n Target Joined Var(msp430_devices_csv_loc) RejectNegative Report\n The path to devices.csv.  The GCC driver can normally locate devices.csv itself\n and pass this option to the compiler, so the user shouldn't need to pass this.\n+\n+mmax-inline-shift=\n+Target RejectNegative Joined UInteger IntegerRange(0,65) Var(msp430_max_inline_shift) Init(65) Report\n+For shift operations by a constant amount, which require an individual instruction to shift by one\n+position, set the maximum number of inline shift instructions (maximum value 64) to emit instead of using the corresponding __mspabi helper function.\n+The default value is 4."}, {"sha": "4bfa0c0f2d5dd91879f1aa147049810d67f804fc", "filename": "gcc/config/msp430/predicates.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fconfig%2Fmsp430%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fpredicates.md?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -113,12 +113,21 @@\n        (ior (match_code \"reg,mem\")\n \t    (match_operand 0 \"immediate_operand\"))))\n \n-; TRUE for constants which are bit positions for zero_extract\n-(define_predicate \"msp430_bitpos\"\n+(define_predicate \"const_1_to_8_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test (\"   INTVAL (op) >= 1\n+\t\t     && INTVAL (op) <= 8 \"))))\n+\n+(define_predicate \"const_0_to_15_operand\"\n   (and (match_code \"const_int\")\n        (match_test (\"   INTVAL (op) >= 0\n \t\t     && INTVAL (op) <= 15 \"))))\n \n+(define_predicate \"const_1_to_19_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test (\"   INTVAL (op) >= 1\n+\t\t     && INTVAL (op) <= 19 \"))))\n+\n (define_predicate \"msp430_symbol_operand\"\n   (match_code \"symbol_ref\")\n )"}, {"sha": "fe01b6514da296295a9628f078abe62e5f61d09f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -1070,7 +1070,7 @@ Objective-C and Objective-C++ Dialects}.\n -mwarn-mcu @gol\n -mcode-region=  -mdata-region= @gol\n -msilicon-errata=  -msilicon-errata-warn= @gol\n--mhwmult=  -minrt  -mtiny-printf}\n+-mhwmult=  -minrt  -mtiny-printf  -mmax-inline-shift=}\n \n @emph{NDS32 Options}\n @gccoptlist{-mbig-endian  -mlittle-endian @gol\n@@ -24816,6 +24816,19 @@ buffered before it is sent to write.\n This option requires Newlib Nano IO, so GCC must be configured with\n @samp{--enable-newlib-nano-formatted-io}.\n \n+@item -mmax-inline-shift=\n+@opindex mmax-inline-shift=\n+This option takes an integer between 0 and 64 inclusive, and sets\n+the maximum number of inline shift instructions which should be emitted to\n+perform a shift operation by a constant amount.  When this value needs to be\n+exceeded, an mspabi helper function is used instead.  The default value is 4.\n+\n+This only affects cases where a shift by multiple positions cannot be\n+completed with a single instruction (e.g. all shifts >1 on the 430 ISA).\n+\n+Shifts of a 32-bit value are at least twice as costly, so the value passed for\n+this option is divided by 2 and the resulting value used instead.\n+\n @item -mcode-region=\n @itemx -mdata-region=\n @opindex mcode-region"}, {"sha": "35207b7c458a6fbc44c11bb113bf30a414f97291", "filename": "gcc/testsuite/gcc.target/msp430/emulate-srli.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Femulate-srli.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Femulate-srli.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Femulate-srli.c?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -2,7 +2,7 @@\n /* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" } { \"\" } } */\n /* { dg-options \"-Os\" } */\n /* { dg-final { scan-assembler-not \"mspabi_srli\" } } */\n-/* { dg-final { scan-assembler \"rrum\" } } */\n+/* { dg-final { scan-assembler \"RRUM\" } } */\n \n /* Ensure that HImode shifts with source operand in memory are emulated with a\n    rotate instructions.  */"}, {"sha": "c795f7570d7aa8da28aa55df070d2fd5e2da276a", "filename": "gcc/testsuite/gcc.target/msp430/max-inline-shift-430-no-opt.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430-no-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430-no-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430-no-opt.c?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430x\" \"-mlarge\" } { \"\" } } */\n+/* { dg-options \"-mcpu=msp430\" } */\n+/* { dg-final { scan-assembler-not \"__mspabi_slli_4\" } } */\n+/* { dg-final { scan-assembler-not \"__mspabi_sral_2\" } } */\n+/* { dg-final { scan-assembler \"__mspabi_slli_5\" } } */\n+/* { dg-final { scan-assembler \"__mspabi_sral_3\" } } */\n+\n+/* Test the default value of 4 for -mmax-inline-shift has been observed.  */\n+\n+volatile int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15;\n+volatile long l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15;\n+\n+void\n+ashift (void)\n+{\n+  a1 <<= 1;\n+  a2 <<= 2;\n+  a3 <<= 3;\n+  a4 <<= 4;\n+  a5 <<= 5;\n+  a6 <<= 6;\n+  a7 <<= 7;\n+  a8 <<= 8;\n+  a9 <<= 9;\n+  a10 <<= 10;\n+  a11 <<= 11;\n+  a12 <<= 12;\n+  a13 <<= 13;\n+  a14 <<= 14;\n+  a15 <<= 15;\n+}\n+\n+void\n+ashiftrt (void)\n+{\n+  l1  >>= 1;\n+  l2  >>= 2;\n+  l3  >>= 3;\n+  l4  >>= 4;\n+  l5  >>= 5;\n+  l6  >>= 6;\n+  l7  >>= 7;\n+  l8  >>= 8;\n+  l9  >>= 9;\n+  l10 >>= 10;\n+  l11 >>= 11;\n+  l12 >>= 12;\n+  l13 >>= 13;\n+  l14 >>= 14;\n+  l15 >>= 15;\n+}"}, {"sha": "7a519eec6634bb4ddc4405d99bd536894a87dff0", "filename": "gcc/testsuite/gcc.target/msp430/max-inline-shift-430.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430.c?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430x\" \"-mlarge\" } { \"\" } } */\n+/* { dg-options \"-mcpu=msp430 -mmax-inline-shift=10\" } */\n+/* { dg-final { scan-assembler-not \"__mspabi_slli_10\" } } */\n+/* { dg-final { scan-assembler-not \"__mspabi_sral_5\" } } */\n+/* { dg-final { scan-assembler \"__mspabi_slli_11\" } } */\n+/* { dg-final { scan-assembler \"__mspabi_sral_6\" } } */\n+\n+volatile int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15;\n+volatile long l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15;\n+\n+void\n+ashift (void)\n+{\n+  a1 <<= 1;\n+  a2 <<= 2;\n+  a3 <<= 3;\n+  a4 <<= 4;\n+  a5 <<= 5;\n+  a6 <<= 6;\n+  a7 <<= 7;\n+  a8 <<= 8;\n+  a9 <<= 9;\n+  a10 <<= 10;\n+  a11 <<= 11;\n+  a12 <<= 12;\n+  a13 <<= 13;\n+  a14 <<= 14;\n+  a15 <<= 15;\n+}\n+\n+void\n+ashiftrt (void)\n+{\n+  l1  >>= 1;\n+  l2  >>= 2;\n+  l3  >>= 3;\n+  l4  >>= 4;\n+  l5  >>= 5;\n+  l6  >>= 6;\n+  l7  >>= 7;\n+  l8  >>= 8;\n+  l9  >>= 9;\n+  l10 >>= 10;\n+  l11 >>= 11;\n+  l12 >>= 12;\n+  l13 >>= 13;\n+  l14 >>= 14;\n+  l15 >>= 15;\n+}"}, {"sha": "074b3af5539ad95f55c5cc914ee339c5f159f5ea", "filename": "gcc/testsuite/gcc.target/msp430/max-inline-shift-430x.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmax-inline-shift-430x.c?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" } { \"\" } } */\n+/* { dg-options \"-mcpu=msp430x -mmax-inline-shift=10\" } */\n+/* { dg-final { scan-assembler-not \"__mspabi_slli\" } } */\n+/* { dg-final { scan-assembler \"__mspabi_sral_6\" } } */\n+\n+volatile int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15;\n+volatile long l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15;\n+\n+void\n+ashift (void)\n+{\n+  a1 <<= 1;\n+  a2 <<= 2;\n+  a3 <<= 3;\n+  a4 <<= 4;\n+  a5 <<= 5;\n+  a6 <<= 6;\n+  a7 <<= 7;\n+  a8 <<= 8;\n+  a9 <<= 9;\n+  a10 <<= 10;\n+  a11 <<= 11;\n+  a12 <<= 12;\n+  a13 <<= 13;\n+  a14 <<= 14;\n+  a15 <<= 15;\n+}\n+\n+void\n+ashiftrt (void)\n+{\n+  l1  >>= 1;\n+  l2  >>= 2;\n+  l3  >>= 3;\n+  l4  >>= 4;\n+  l5  >>= 5;\n+  l6  >>= 6;\n+  l7  >>= 7;\n+  l8  >>= 8;\n+  l9  >>= 9;\n+  l10 >>= 10;\n+  l11 >>= 11;\n+  l12 >>= 12;\n+  l13 >>= 13;\n+  l14 >>= 14;\n+  l15 >>= 15;\n+}"}, {"sha": "b22622e0bf59da5fd8c0affb6f1bcaa336f469d2", "filename": "libgcc/config/msp430/slli.S", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/libgcc%2Fconfig%2Fmsp430%2Fslli.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/libgcc%2Fconfig%2Fmsp430%2Fslli.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fslli.S?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -65,6 +65,21 @@ __mspabi_slli:\n \tRET\n #endif\n \n+#ifdef __MSP430X__\n+\t.section\t.text.__gnu_mspabi_sllp\n+1:\tADDA\t#-1,R13\n+\tADDA\tR12,R12\n+\t.global\t__gnu_mspabi_sllp\n+__gnu_mspabi_sllp:\n+\tCMP\t#0,R13\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif /* __MSP430X_LARGE__ */\n+#endif /* __MSP430X__ */\n+\n /* Logical Left Shift - R12:R13 -> R12:R13.  */\n \n \t.section\t.text.__mspabi_slll_n"}, {"sha": "0100a368365d7f313bb323d8041bade016d528df", "filename": "libgcc/config/msp430/srai.S", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/libgcc%2Fconfig%2Fmsp430%2Fsrai.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/libgcc%2Fconfig%2Fmsp430%2Fsrai.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fsrai.S?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -64,6 +64,21 @@ __mspabi_srai:\n \tRET\n #endif\n \n+#ifdef __MSP430X__\n+\t.section\t.text.__gnu_mspabi_srap\n+1:\tADDA\t#-1,R13\n+\tRRAX.A\tR12,R12\n+\t.global\t__gnu_mspabi_srap\n+__gnu_mspabi_srap:\n+\tCMP\t#0,R13\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif /* __MSP430X_LARGE__ */\n+#endif /* __MSP430X__ */\n+\n /* Arithmetic Right Shift - R12:R13 -> R12:R13.  */\n \n \t.section\t.text.__mspabi_sral_n"}, {"sha": "50db47c99386e20729dd684fc363f722a78f6741", "filename": "libgcc/config/msp430/srli.S", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703e049aa72e01c15087750fe63deba779c9b2dd/libgcc%2Fconfig%2Fmsp430%2Fsrli.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703e049aa72e01c15087750fe63deba779c9b2dd/libgcc%2Fconfig%2Fmsp430%2Fsrli.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fsrli.S?ref=703e049aa72e01c15087750fe63deba779c9b2dd", "patch": "@@ -66,6 +66,22 @@ __mspabi_srli:\n \tRET\n #endif\n \n+#ifdef __MSP430X__\n+\t.section\t.text.__gnu_mspabi_srlp\n+1:\tADDA\t#-1,R13\n+\tCLRC\n+\tRRCX.A\tR12,R12\n+\t.global\t__gnu_mspabi_srlp\n+__gnu_mspabi_srlp:\n+\tCMP\t#0,R13\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif /* __MSP430X_LARGE__ */\n+#endif /* __MSP430X__ */\n+\n /* Logical Right Shift - R12:R13 -> R12:R13.  */\n \n \t.section\t.text.__mspabi_srll_n"}]}