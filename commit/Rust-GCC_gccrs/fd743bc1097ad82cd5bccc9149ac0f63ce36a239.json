{"sha": "fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3NDNiYzEwOTdhZDgyY2Q1YmNjYzkxNDlhYzBmNjNjZTM2YTIzOQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-06-18T07:33:08Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-06-18T07:33:08Z"}, "message": "emit-rtl.c (unshare_all_rtl_1): New name of unshare_all_rtl.\n\n2004-06-18  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* emit-rtl.c (unshare_all_rtl_1): New name of unshare_all_rtl.\n\t(unshare_all_rtl_again): Call unshare_all_rtl_1.\n\t(unshare_all_rtl): New.\n\t* function.c (instantiate_virtual_regs): Remove parameters.\n\t* function.h (instantiate_virtual_regs): Add prototype.\n\t* rtl.h (unshare_all_rtl): Add prototype.\n\t* tree.h (instantiate_virtual_regs, unshare_all_rtl): Remove\n\tprototype.\n\t* passes.c: Remove assertions on the parameters to\n\trest_of_handle_* functions.  Remove the parameters to\n\tthe functions, replacing decl with current_function_decl\n\tand insns with get_insns ().\n\nFrom-SVN: r83341", "tree": {"sha": "9e387d4d3a8ab7e756314c707d213eb7562b69a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e387d4d3a8ab7e756314c707d213eb7562b69a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24a88b0c7a37254d961e740f1dc5071177107c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a88b0c7a37254d961e740f1dc5071177107c01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a88b0c7a37254d961e740f1dc5071177107c01"}], "stats": {"total": 558, "additions": 242, "deletions": 316}, "files": [{"sha": "6b45cbe5662be8e4339810a6293122a1ee3c1ede", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "patch": "@@ -1,3 +1,18 @@\n+2004-06-18  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* emit-rtl.c (unshare_all_rtl_1): New name of unshare_all_rtl.\n+\t(unshare_all_rtl_again): Call unshare_all_rtl_1.\n+\t(unshare_all_rtl): New.\n+\t* function.c (instantiate_virtual_regs): Remove parameters.\n+\t* function.h (instantiate_virtual_regs): Add prototype.\n+\t* rtl.h (unshare_all_rtl): Add prototype.\n+\t* tree.h (instantiate_virtual_regs, unshare_all_rtl): Remove\n+\tprototype.\n+\t* passes.c: Remove assertions on the parameters to\n+\trest_of_handle_* functions.  Remove the parameters to\n+\tthe functions, replacing decl with current_function_decl\n+\tand insns with get_insns ().\n+\n 2004-06-17  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (constant_boolean_node): Handle boolean_type_node"}, {"sha": "41679151c641f20b18e12f67a80007497b4ba9a7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "patch": "@@ -2148,8 +2148,8 @@ restore_emit_status (struct function *p ATTRIBUTE_UNUSED)\n /* Go through all the RTL insn bodies and copy any invalid shared\n    structure.  This routine should only be called once.  */\n \n-void\n-unshare_all_rtl (tree fndecl, rtx insn)\n+static void\n+unshare_all_rtl_1 (tree fndecl, rtx insn)\n {\n   tree decl;\n \n@@ -2200,7 +2200,13 @@ unshare_all_rtl_again (rtx insn)\n \n   reset_used_flags (stack_slot_list);\n \n-  unshare_all_rtl (cfun->decl, insn);\n+  unshare_all_rtl_1 (cfun->decl, insn);\n+}\n+\n+void\n+unshare_all_rtl (void)\n+{\n+  unshare_all_rtl_1 (current_function_decl, get_insns ());\n }\n \n /* Check that ORIG is not marked when it should not be and mark ORIG as in use,"}, {"sha": "8d25bd261d62b7fff633d2e826849a7646855f58", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "patch": "@@ -3596,30 +3596,30 @@ purge_hard_subreg_sets (rtx insn)\n    references to hard register references.  */\n \n void\n-instantiate_virtual_regs (tree fndecl, rtx insns)\n+instantiate_virtual_regs (void)\n {\n   rtx insn;\n   unsigned int i;\n \n   /* Compute the offsets to use for this function.  */\n-  in_arg_offset = FIRST_PARM_OFFSET (fndecl);\n+  in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);\n   var_offset = STARTING_FRAME_OFFSET;\n-  dynamic_offset = STACK_DYNAMIC_OFFSET (fndecl);\n+  dynamic_offset = STACK_DYNAMIC_OFFSET (current_function_decl);\n   out_arg_offset = STACK_POINTER_OFFSET;\n-  cfa_offset = ARG_POINTER_CFA_OFFSET (fndecl);\n+  cfa_offset = ARG_POINTER_CFA_OFFSET (current_function_decl);\n \n   /* Scan all variables and parameters of this function.  For each that is\n      in memory, instantiate all virtual registers if the result is a valid\n      address.  If not, we do it later.  That will handle most uses of virtual\n      regs on many machines.  */\n-  instantiate_decls (fndecl, 1);\n+  instantiate_decls (current_function_decl, 1);\n \n   /* Initialize recognition, indicating that volatile is OK.  */\n   init_recog ();\n \n   /* Scan through all the insns, instantiating every virtual register still\n      present.  */\n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n \t|| GET_CODE (insn) == CALL_INSN)\n       {\n@@ -3647,7 +3647,7 @@ instantiate_virtual_regs (tree fndecl, rtx insns)\n \n   /* Now instantiate the remaining register equivalences for debugging info.\n      These will not be valid addresses.  */\n-  instantiate_decls (fndecl, 0);\n+  instantiate_decls (current_function_decl, 0);\n \n   /* Indicate that, from now on, assign_stack_local should use\n      frame_pointer_rtx.  */"}, {"sha": "76a281a61926229f60c022416e896601492bf273", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "patch": "@@ -613,6 +613,7 @@ extern void use_return_register (void);\n extern rtx get_arg_pointer_save_area (struct function *);\n \n extern void init_virtual_regs (struct emit_status *);\n+extern void instantiate_virtual_regs (void);\n \n /* Returns the name of the current function.  */\n extern const char *current_function_name (void);"}, {"sha": "d9596799b0e7a2046da85127998c5960d3669fcc", "filename": "gcc/passes.c", "status": "modified", "additions": 209, "deletions": 304, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "patch": "@@ -429,11 +429,8 @@ rest_of_type_compilation (tree type, int toplev)\n \n /* Turn the RTL into assembly.  */\n static void\n-rest_of_handle_final (tree decl, rtx insns)\n+rest_of_handle_final (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_FINAL);\n   {\n     rtx x;\n@@ -442,17 +439,17 @@ rest_of_handle_final (tree decl, rtx insns)\n     /* Get the function's name, as described by its RTL.  This may be\n        different from the DECL_NAME name used in the source file.  */\n \n-    x = DECL_RTL (decl);\n+    x = DECL_RTL (current_function_decl);\n     if (GET_CODE (x) != MEM)\n       abort ();\n     x = XEXP (x, 0);\n     if (GET_CODE (x) != SYMBOL_REF)\n       abort ();\n     fnname = XSTR (x, 0);\n \n-    assemble_start_function (decl, fnname);\n-    final_start_function (insns, asm_out_file, optimize);\n-    final (insns, asm_out_file, optimize, 0);\n+    assemble_start_function (current_function_decl, fnname);\n+    final_start_function (get_insns (), asm_out_file, optimize);\n+    final (get_insns (), asm_out_file, optimize, 0);\n     final_end_function ();\n \n #ifdef IA64_UNWIND_INFO\n@@ -461,7 +458,7 @@ rest_of_handle_final (tree decl, rtx insns)\n     output_function_exception_table ();\n #endif\n \n-    assemble_end_function (decl, fnname);\n+    assemble_end_function (current_function_decl, fnname);\n \n #ifndef IA64_UNWIND_INFO\n     /* Otherwise, it feels unclean to switch sections in the middle.  */\n@@ -485,17 +482,14 @@ rest_of_handle_final (tree decl, rtx insns)\n #ifdef DELAY_SLOTS\n /* Run delay slot optimization.  */\n static void\n-rest_of_handle_delay_slots (tree decl, rtx insns)\n+rest_of_handle_delay_slots (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_DBR_SCHED);\n-  open_dump_file (DFI_dbr, decl);\n+  open_dump_file (DFI_dbr, current_function_decl);\n \n-  dbr_schedule (insns, dump_file);\n+  dbr_schedule (get_insns (), dump_file);\n \n-  close_dump_file (DFI_dbr, print_rtl, insns);\n+  close_dump_file (DFI_dbr, print_rtl, get_insns ());\n   timevar_pop (TV_DBR_SCHED);\n \n   ggc_collect ();\n@@ -506,11 +500,8 @@ rest_of_handle_delay_slots (tree decl, rtx insns)\n /* Convert register usage from flat register file usage to a stack\n    register file.  */\n static void\n-rest_of_handle_stack_regs (tree decl, rtx insns)\n+rest_of_handle_stack_regs (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n #if defined (HAVE_ATTR_length)\n   /* If flow2 creates new instructions which need splitting\n      and scheduling after reload is not done, they might not be\n@@ -529,7 +520,7 @@ rest_of_handle_stack_regs (tree decl, rtx insns)\n #endif\n \n   timevar_push (TV_REG_STACK);\n-  open_dump_file (DFI_stack, decl);\n+  open_dump_file (DFI_stack, current_function_decl);\n \n   if (reg_to_stack (dump_file) && optimize)\n     {\n@@ -542,7 +533,7 @@ rest_of_handle_stack_regs (tree decl, rtx insns)\n \t}\n     }\n \n-  close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_stack, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_REG_STACK);\n \n   ggc_collect ();\n@@ -551,33 +542,27 @@ rest_of_handle_stack_regs (tree decl, rtx insns)\n \n /* Track the variables, ie. compute where the variable is stored at each position in function.  */\n static void\n-rest_of_handle_variable_tracking (tree decl, rtx insns)\n+rest_of_handle_variable_tracking (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_VAR_TRACKING);\n-  open_dump_file (DFI_vartrack, decl);\n+  open_dump_file (DFI_vartrack, current_function_decl);\n \n   variable_tracking_main ();\n \n-  close_dump_file (DFI_vartrack, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_vartrack, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_VAR_TRACKING);\n }\n \n /* Machine independent reorg pass.  */\n static void\n-rest_of_handle_machine_reorg (tree decl, rtx insns)\n+rest_of_handle_machine_reorg (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_MACH_DEP);\n-  open_dump_file (DFI_mach, decl);\n+  open_dump_file (DFI_mach, current_function_decl);\n \n   targetm.machine_dependent_reorg ();\n \n-  close_dump_file (DFI_mach, print_rtl, insns);\n+  close_dump_file (DFI_mach, print_rtl, get_insns ());\n   timevar_pop (TV_MACH_DEP);\n \n   ggc_collect ();\n@@ -587,14 +572,11 @@ rest_of_handle_machine_reorg (tree decl, rtx insns)\n /* Run new register allocator.  Return TRUE if we must exit\n    rest_of_compilation upon return.  */\n static bool\n-rest_of_handle_new_regalloc (tree decl, rtx insns)\n+rest_of_handle_new_regalloc (void)\n {\n   int failure;\n \n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n   reg_alloc ();\n \n   timevar_pop (TV_LOCAL_ALLOC);\n@@ -608,10 +590,10 @@ rest_of_handle_new_regalloc (tree decl, rtx insns)\n \n   /* XXX clean up the whole mess to bring live info in shape again.  */\n   timevar_push (TV_GLOBAL_ALLOC);\n-  open_dump_file (DFI_greg, decl);\n+  open_dump_file (DFI_greg, current_function_decl);\n \n-  build_insn_chain (insns);\n-  failure = reload (insns, 0);\n+  build_insn_chain (get_insns ());\n+  failure = reload (get_insns (), 0);\n \n   timevar_pop (TV_GLOBAL_ALLOC);\n \n@@ -621,7 +603,7 @@ rest_of_handle_new_regalloc (tree decl, rtx insns)\n \n       dump_global_regs (dump_file);\n \n-      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n+      close_dump_file (DFI_greg, print_rtl_with_bb, get_insns ());\n       timevar_pop (TV_DUMP);\n     }\n \n@@ -636,14 +618,11 @@ rest_of_handle_new_regalloc (tree decl, rtx insns)\n /* Run old register allocator.  Return TRUE if we must exit\n    rest_of_compilation upon return.  */\n static bool\n-rest_of_handle_old_regalloc (tree decl, rtx insns)\n+rest_of_handle_old_regalloc (void)\n {\n   int failure;\n   int rebuild_notes;\n \n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   /* Allocate the reg_renumber array.  */\n   allocate_reg_info (max_regno, FALSE, TRUE);\n \n@@ -653,7 +632,7 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n \n   allocate_initial_values (reg_equiv_memory_loc);\n \n-  regclass (insns, max_reg_num (), dump_file);\n+  regclass (get_insns (), max_reg_num (), dump_file);\n   rebuild_notes = local_alloc ();\n \n   timevar_pop (TV_LOCAL_ALLOC);\n@@ -665,7 +644,7 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n     {\n       timevar_push (TV_JUMP);\n \n-      rebuild_jump_labels (insns);\n+      rebuild_jump_labels (get_insns ());\n       purge_all_dead_edges (0);\n \n       timevar_pop (TV_JUMP);\n@@ -678,14 +657,14 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n       dump_flow_info (dump_file);\n       dump_local_alloc (dump_file);\n \n-      close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n+      close_dump_file (DFI_lreg, print_rtl_with_bb, get_insns ());\n       timevar_pop (TV_DUMP);\n     }\n \n   ggc_collect ();\n \n   timevar_push (TV_GLOBAL_ALLOC);\n-  open_dump_file (DFI_greg, decl);\n+  open_dump_file (DFI_greg, current_function_decl);\n \n   /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n      pass fixing up any insns that are invalid.  */\n@@ -694,8 +673,8 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n     failure = global_alloc (dump_file);\n   else\n     {\n-      build_insn_chain (insns);\n-      failure = reload (insns, 0);\n+      build_insn_chain (get_insns ());\n+      failure = reload (get_insns (), 0);\n     }\n \n   timevar_pop (TV_GLOBAL_ALLOC);\n@@ -706,7 +685,7 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n \n       dump_global_regs (dump_file);\n \n-      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n+      close_dump_file (DFI_greg, print_rtl_with_bb, get_insns ());\n       timevar_pop (TV_DUMP);\n     }\n \n@@ -715,32 +694,26 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n \n /* Run the regrename and cprop passes.  */\n static void\n-rest_of_handle_regrename (tree decl, rtx insns)\n+rest_of_handle_regrename (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_RENAME_REGISTERS);\n-  open_dump_file (DFI_rnreg, decl);\n+  open_dump_file (DFI_rnreg, current_function_decl);\n \n   if (flag_rename_registers)\n     regrename_optimize ();\n   if (flag_cprop_registers)\n     copyprop_hardreg_forward ();\n \n-  close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_rnreg, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_RENAME_REGISTERS);\n }\n \n /* Reorder basic blocks.  */\n static void\n-rest_of_handle_reorder_blocks (tree decl, rtx insns)\n+rest_of_handle_reorder_blocks (void)\n {\n   bool changed;\n-  open_dump_file (DFI_bbro, decl);\n-\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n+  open_dump_file (DFI_bbro, current_function_decl);\n \n   /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n      splitting possibly introduced more crossjumping opportunities.  */\n@@ -764,23 +737,20 @@ rest_of_handle_reorder_blocks (tree decl, rtx insns)\n   if (changed && HAVE_conditional_execution)\n     update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t      PROP_DEATH_NOTES);\n-  close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_bbro, print_rtl_with_bb, get_insns ());\n }\n \n #ifdef INSN_SCHEDULING\n /* Run instruction scheduler.  */\n static void\n-rest_of_handle_sched (tree decl, rtx insns)\n+rest_of_handle_sched (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_SMS);\n   if (optimize > 0 && flag_modulo_sched)\n     {\n \n       /* Perform SMS module scheduling.  */\n-      open_dump_file (DFI_sms, decl);\n+      open_dump_file (DFI_sms, current_function_decl);\n \n       /* We want to be able to create new pseudos.  */\n       no_new_pseudos = 0;\n@@ -804,14 +774,14 @@ rest_of_handle_sched (tree decl, rtx insns)\n      because doing the sched analysis makes some of the dump.  */\n   if (optimize > 0 && flag_schedule_insns)\n     {\n-      open_dump_file (DFI_sched, decl);\n+      open_dump_file (DFI_sched, current_function_decl);\n \n       /* Do control and data sched analysis,\n \t and write some of the results to dump file.  */\n \n       schedule_insns (dump_file);\n \n-      close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n+      close_dump_file (DFI_sched, print_rtl_with_bb, get_insns ());\n     }\n   timevar_pop (TV_SCHED);\n \n@@ -820,13 +790,10 @@ rest_of_handle_sched (tree decl, rtx insns)\n \n /* Run second scheduling pass after reload.  */\n static void\n-rest_of_handle_sched2 (tree decl, rtx insns)\n+rest_of_handle_sched2 (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_SCHED2);\n-  open_dump_file (DFI_sched2, decl);\n+  open_dump_file (DFI_sched2, current_function_decl);\n \n   /* Do control and data sched analysis again,\n      and write some more of the results to dump file.  */\n@@ -844,25 +811,22 @@ rest_of_handle_sched2 (tree decl, rtx insns)\n   else\n     schedule_insns (dump_file);\n \n-  close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_sched2, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_SCHED2);\n \n   ggc_collect ();\n }\n #endif\n \n static void\n-rest_of_handle_gcse2 (tree decl, rtx insns)\n+rest_of_handle_gcse2 (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_gcse2, decl);\n+  open_dump_file (DFI_gcse2, current_function_decl);\n \n-  gcse_after_reload_main (insns, dump_file);\n-  rebuild_jump_labels (insns);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  close_dump_file (DFI_gcse2, print_rtl_with_bb, insns);\n+  gcse_after_reload_main (get_insns (), dump_file);\n+  rebuild_jump_labels (get_insns ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  close_dump_file (DFI_gcse2, print_rtl_with_bb, get_insns ());\n \n   ggc_collect ();\n \n@@ -874,110 +838,92 @@ rest_of_handle_gcse2 (tree decl, rtx insns)\n /* Register allocation pre-pass, to reduce number of moves necessary\n    for two-address machines.  */\n static void\n-rest_of_handle_regmove (tree decl, rtx insns)\n+rest_of_handle_regmove (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_REGMOVE);\n-  open_dump_file (DFI_regmove, decl);\n+  open_dump_file (DFI_regmove, current_function_decl);\n \n-  regmove_optimize (insns, max_reg_num (), dump_file);\n+  regmove_optimize (get_insns (), max_reg_num (), dump_file);\n \n   cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n-  close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_regmove, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_REGMOVE);\n \n   ggc_collect ();\n }\n \n /* Run tracer.  */\n static void\n-rest_of_handle_tracer (tree decl, rtx insns)\n+rest_of_handle_tracer (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_tracer, decl);\n+  open_dump_file (DFI_tracer, current_function_decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n   tracer ();\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (insns, max_reg_num (), 0);\n+  reg_scan (get_insns (), max_reg_num (), 0);\n   close_dump_file (DFI_tracer, print_rtl_with_bb, get_insns ());\n }\n \n /* If-conversion and CFG cleanup.  */\n static void\n-rest_of_handle_if_conversion (tree decl, rtx insns)\n+rest_of_handle_if_conversion (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_ce1, decl);\n+  open_dump_file (DFI_ce1, current_function_decl);\n   if (flag_if_conversion)\n     {\n       timevar_push (TV_IFCVT);\n       if (dump_file)\n \tdump_flow_info (dump_file);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n-      reg_scan (insns, max_reg_num (), 0);\n+      reg_scan (get_insns (), max_reg_num (), 0);\n       if_convert (0);\n       timevar_pop (TV_IFCVT);\n     }\n   timevar_push (TV_JUMP);\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (insns, max_reg_num (), 0);\n+  reg_scan (get_insns (), max_reg_num (), 0);\n   timevar_pop (TV_JUMP);\n   close_dump_file (DFI_ce1, print_rtl_with_bb, get_insns ());\n }\n \n /* Rerun if-conversion, as combine may have simplified things enough\n    to now meet sequence length restrictions.  */\n static void\n-rest_of_handle_if_after_combine (tree decl, rtx insns)\n+rest_of_handle_if_after_combine (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_IFCVT);\n-  open_dump_file (DFI_ce2, decl);\n+  open_dump_file (DFI_ce2, current_function_decl);\n \n   no_new_pseudos = 0;\n   if_convert (1);\n   no_new_pseudos = 1;\n \n-  close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_ce2, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_IFCVT);\n }\n \n static void\n-rest_of_handle_web (tree decl, rtx insns)\n+rest_of_handle_web (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_web, decl);\n+  open_dump_file (DFI_web, current_function_decl);\n   timevar_push (TV_WEB);\n   web_main ();\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n \n   timevar_pop (TV_WEB);\n-  close_dump_file (DFI_web, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_web, print_rtl_with_bb, get_insns ());\n   reg_scan (get_insns (), max_reg_num (), 0);\n }\n \n /* Do branch profiling and static profile estimation passes.  */\n static void\n-rest_of_handle_branch_prob (tree decl, rtx insns)\n+rest_of_handle_branch_prob (void)\n {\n   struct loops loops;\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_BRANCH_PROB);\n-  open_dump_file (DFI_bp, decl);\n+  open_dump_file (DFI_bp, current_function_decl);\n \n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     branch_prob ();\n@@ -995,36 +941,30 @@ rest_of_handle_branch_prob (tree decl, rtx insns)\n \n   flow_loops_free (&loops);\n   free_dominance_info (CDI_DOMINATORS);\n-  close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_bp, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_BRANCH_PROB);\n }\n \n /* Do optimizations based on expression value profiles.  */\n static void\n-rest_of_handle_value_profile_transformations (tree decl, rtx insns)\n+rest_of_handle_value_profile_transformations (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_vpt, decl);\n+  open_dump_file (DFI_vpt, current_function_decl);\n   timevar_push (TV_VPT);\n \n   if (value_profile_transformations ())\n     cleanup_cfg (CLEANUP_EXPENSIVE);\n \n   timevar_pop (TV_VPT);\n-  close_dump_file (DFI_vpt, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_vpt, print_rtl_with_bb, get_insns ());\n }\n \n /* Do control and data flow analysis; write some of the results to the\n    dump file.  */\n static void\n-rest_of_handle_cfg (tree decl, rtx insns)\n+rest_of_handle_cfg (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_cfg, decl);\n+  open_dump_file (DFI_cfg, current_function_decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n   if (optimize)\n@@ -1042,51 +982,45 @@ rest_of_handle_cfg (tree decl, rtx insns)\n     {\n       /* Alias analysis depends on this information and mark_constant_function\n        depends on alias analysis.  */\n-      reg_scan (insns, max_reg_num (), 1);\n+      reg_scan (get_insns (), max_reg_num (), 1);\n       mark_constant_function ();\n     }\n \n-  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_cfg, print_rtl_with_bb, get_insns ());\n }\n \n /* Purge addressofs.  */\n static void\n-rest_of_handle_addressof (tree decl, rtx insns)\n+rest_of_handle_addressof (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n+  open_dump_file (DFI_addressof, current_function_decl);\n \n-  open_dump_file (DFI_addressof, decl);\n-\n-  purge_addressof (insns);\n+  purge_addressof (get_insns ());\n   if (optimize && purge_all_dead_edges (0))\n     delete_unreachable_blocks ();\n-  reg_scan (insns, max_reg_num (), 1);\n+  reg_scan (get_insns (), max_reg_num (), 1);\n \n-  close_dump_file (DFI_addressof, print_rtl, insns);\n+  close_dump_file (DFI_addressof, print_rtl, get_insns ());\n }\n \n /* Perform jump bypassing and control flow optimizations.  */\n static void\n-rest_of_handle_jump_bypass (tree decl, rtx insns)\n+rest_of_handle_jump_bypass (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_BYPASS);\n-  open_dump_file (DFI_bypass, decl);\n+  open_dump_file (DFI_bypass, current_function_decl);\n \n   cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (insns, max_reg_num (), 1);\n+  reg_scan (get_insns (), max_reg_num (), 1);\n \n   if (bypass_jumps (dump_file))\n     {\n-      rebuild_jump_labels (insns);\n+      rebuild_jump_labels (get_insns ());\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n+      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n     }\n \n-  close_dump_file (DFI_bypass, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_bypass, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_BYPASS);\n \n   ggc_collect ();\n@@ -1098,45 +1032,39 @@ rest_of_handle_jump_bypass (tree decl, rtx insns)\n \n /* Try combining insns through substitution.  */\n static void\n-rest_of_handle_combine (tree decl, rtx insns)\n+rest_of_handle_combine (void)\n {\n   int rebuild_jump_labels_after_combine = 0;\n \n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_COMBINE);\n-  open_dump_file (DFI_combine, decl);\n+  open_dump_file (DFI_combine, current_function_decl);\n \n   rebuild_jump_labels_after_combine\n-    = combine_instructions (insns, max_reg_num ());\n+    = combine_instructions (get_insns (), max_reg_num ());\n \n-  /* Combining insns may have turned an indirect jump into a\n+  /* Combining get_insns () may have turned an indirect jump into a\n      direct jump.  Rebuild the JUMP_LABEL fields of jumping\n      instructions.  */\n   if (rebuild_jump_labels_after_combine)\n     {\n       timevar_push (TV_JUMP);\n-      rebuild_jump_labels (insns);\n+      rebuild_jump_labels (get_insns ());\n       timevar_pop (TV_JUMP);\n \n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n     }\n \n-  close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_combine, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_COMBINE);\n \n   ggc_collect ();\n }\n \n /* Perform life analysis.  */\n static void\n-rest_of_handle_life (tree decl, rtx insns)\n+rest_of_handle_life (void)\n {\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_life, decl);\n+  open_dump_file (DFI_life, current_function_decl);\n   regclass_init ();\n \n #ifdef ENABLE_CHECKING\n@@ -1151,7 +1079,7 @@ rest_of_handle_life (tree decl, rtx insns)\n \n   if (extra_warnings)\n     {\n-      setjmp_vars_warning (DECL_INITIAL (decl));\n+      setjmp_vars_warning (DECL_INITIAL (current_function_decl));\n       setjmp_args_warning ();\n     }\n \n@@ -1161,7 +1089,6 @@ rest_of_handle_life (tree decl, rtx insns)\n \t{\n \t  /* Insns were inserted, and possibly pseudos created, so\n \t     things might look a bit different.  */\n-\t  insns = get_insns ();\n \t  allocate_reg_life_data ();\n \t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n@@ -1170,7 +1097,7 @@ rest_of_handle_life (tree decl, rtx insns)\n \n   no_new_pseudos = 1;\n \n-  close_dump_file (DFI_life, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_life, print_rtl_with_bb, get_insns ());\n \n   ggc_collect ();\n }\n@@ -1179,26 +1106,23 @@ rest_of_handle_life (tree decl, rtx insns)\n    `cse_main' means that jumps were simplified and some code may now\n    be unreachable, so do jump optimization again.  */\n static void\n-rest_of_handle_cse (tree decl, rtx insns)\n+rest_of_handle_cse (void)\n {\n   int tem;\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n-  open_dump_file (DFI_cse, decl);\n+  open_dump_file (DFI_cse, current_function_decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n   timevar_push (TV_CSE);\n \n-  reg_scan (insns, max_reg_num (), 1);\n+  reg_scan (get_insns (), max_reg_num (), 1);\n \n-  tem = cse_main (insns, max_reg_num (), 0, dump_file);\n+  tem = cse_main (get_insns (), max_reg_num (), 0, dump_file);\n   if (tem)\n-    rebuild_jump_labels (insns);\n+    rebuild_jump_labels (get_insns ());\n   if (purge_all_dead_edges (0))\n     delete_unreachable_blocks ();\n \n-  delete_trivially_dead_insns (insns, max_reg_num ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \n   /* If we are not running more CSE passes, then we are no longer\n      expecting CSE to be run.  But always rerun it in a cheap mode.  */\n@@ -1208,23 +1132,20 @@ rest_of_handle_cse (tree decl, rtx insns)\n     cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \n   timevar_pop (TV_CSE);\n-  close_dump_file (DFI_cse, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_cse, print_rtl_with_bb, get_insns ());\n }\n \n /* Run second CSE pass after loop optimizations.  */\n static void\n-rest_of_handle_cse2 (tree decl, rtx insns)\n+rest_of_handle_cse2 (void)\n {\n   int tem;\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_CSE2);\n-  open_dump_file (DFI_cse2, decl);\n+  open_dump_file (DFI_cse2, current_function_decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n   /* CFG is no longer maintained up-to-date.  */\n-  tem = cse_main (insns, max_reg_num (), 1, dump_file);\n+  tem = cse_main (get_insns (), max_reg_num (), 1, dump_file);\n \n   /* Run a pass to eliminate duplicated assignments to condition code\n      registers.  We have to run this after bypass_jumps, because it\n@@ -1233,36 +1154,33 @@ rest_of_handle_cse2 (tree decl, rtx insns)\n   cse_condition_code_reg ();\n \n   purge_all_dead_edges (0);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \n   if (tem)\n     {\n       timevar_push (TV_JUMP);\n-      rebuild_jump_labels (insns);\n+      rebuild_jump_labels (get_insns ());\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n       timevar_pop (TV_JUMP);\n     }\n-  reg_scan (insns, max_reg_num (), 0);\n-  close_dump_file (DFI_cse2, print_rtl_with_bb, insns);\n+  reg_scan (get_insns (), max_reg_num (), 0);\n+  close_dump_file (DFI_cse2, print_rtl_with_bb, get_insns ());\n   ggc_collect ();\n   timevar_pop (TV_CSE2);\n }\n \n /* Perform global cse.  */\n static void\n-rest_of_handle_gcse (tree decl, rtx insns)\n+rest_of_handle_gcse (void)\n {\n   int save_csb, save_cfj;\n   int tem2 = 0, tem;\n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_GCSE);\n-  open_dump_file (DFI_gcse, decl);\n+  open_dump_file (DFI_gcse, current_function_decl);\n \n-  tem = gcse_main (insns, dump_file);\n-  rebuild_jump_labels (insns);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n+  tem = gcse_main (get_insns (), dump_file);\n+  rebuild_jump_labels (get_insns ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \n   save_csb = flag_cse_skip_blocks;\n   save_cfj = flag_cse_follow_jumps;\n@@ -1273,10 +1191,10 @@ rest_of_handle_gcse (tree decl, rtx insns)\n   if (flag_expensive_optimizations)\n     {\n       timevar_push (TV_CSE);\n-      reg_scan (insns, max_reg_num (), 1);\n-      tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n+      reg_scan (get_insns (), max_reg_num (), 1);\n+      tem2 = cse_main (get_insns (), max_reg_num (), 0, dump_file);\n       purge_all_dead_edges (0);\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n+      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n       timevar_pop (TV_CSE);\n       cse_not_expected = !flag_rerun_cse_after_loop;\n     }\n@@ -1287,22 +1205,22 @@ rest_of_handle_gcse (tree decl, rtx insns)\n     {\n       tem = tem2 = 0;\n       timevar_push (TV_JUMP);\n-      rebuild_jump_labels (insns);\n+      rebuild_jump_labels (get_insns ());\n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n       timevar_pop (TV_JUMP);\n \n       if (flag_expensive_optimizations)\n \t{\n \t  timevar_push (TV_CSE);\n-\t  reg_scan (insns, max_reg_num (), 1);\n-\t  tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n+\t  reg_scan (get_insns (), max_reg_num (), 1);\n+\t  tem2 = cse_main (get_insns (), max_reg_num (), 0, dump_file);\n \t  purge_all_dead_edges (0);\n-\t  delete_trivially_dead_insns (insns, max_reg_num ());\n+\t  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \t  timevar_pop (TV_CSE);\n \t}\n     }\n \n-  close_dump_file (DFI_gcse, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_gcse, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_GCSE);\n \n   ggc_collect ();\n@@ -1315,17 +1233,14 @@ rest_of_handle_gcse (tree decl, rtx insns)\n \n /* Move constant computations out of loops.  */\n static void\n-rest_of_handle_loop_optimize (tree decl, rtx insns)\n+rest_of_handle_loop_optimize (void)\n {\n   int do_unroll, do_prefetch;\n \n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   timevar_push (TV_LOOP);\n   delete_dead_jumptables ();\n   cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-  open_dump_file (DFI_loop, decl);\n+  open_dump_file (DFI_loop, current_function_decl);\n \n   /* CFG is no longer maintained up-to-date.  */\n   free_bb_for_insn ();\n@@ -1341,27 +1256,27 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n       cleanup_barriers ();\n \n       /* We only want to perform unrolling once.  */\n-      loop_optimize (insns, dump_file, do_unroll);\n+      loop_optimize (get_insns (), dump_file, do_unroll);\n       do_unroll = 0;\n \n       /* The first call to loop_optimize makes some instructions\n \t trivially dead.  We delete those instructions now in the\n \t hope that doing so will make the heuristics in loop work\n \t better and possibly speed up compilation.  */\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n+      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \n       /* The regscan pass is currently necessary as the alias\n \t analysis code depends on this information.  */\n-      reg_scan (insns, max_reg_num (), 1);\n+      reg_scan (get_insns (), max_reg_num (), 1);\n     }\n   cleanup_barriers ();\n-  loop_optimize (insns, dump_file, do_unroll | do_prefetch);\n+  loop_optimize (get_insns (), dump_file, do_unroll | do_prefetch);\n \n   /* Loop can create trivially dead instructions.  */\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  close_dump_file (DFI_loop, print_rtl, insns);\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  close_dump_file (DFI_loop, print_rtl, get_insns ());\n   timevar_pop (TV_LOOP);\n-  find_basic_blocks (insns, max_reg_num (), dump_file);\n+  find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n \n   ggc_collect ();\n }\n@@ -1370,22 +1285,19 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n    sooner, but we want the profile feedback to work more\n    efficiently.  */\n static void\n-rest_of_handle_loop2 (tree decl, rtx insns)\n+rest_of_handle_loop2 (void)\n {\n   struct loops *loops;\n   basic_block bb;\n \n-  if (decl != current_function_decl || insns != get_insns ())\n-    abort ();\n-\n   if (!flag_unswitch_loops\n       && !flag_peel_loops\n       && !flag_unroll_loops\n       && !flag_branch_on_count_reg)\n     return;\n \n   timevar_push (TV_LOOP);\n-  open_dump_file (DFI_loop2, decl);\n+  open_dump_file (DFI_loop2, current_function_decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n \n@@ -1421,8 +1333,8 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n   cfg_layout_finalize ();\n \n   cleanup_cfg (CLEANUP_EXPENSIVE);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  reg_scan (insns, max_reg_num (), 0);\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  reg_scan (get_insns (), max_reg_num (), 0);\n   if (dump_file)\n     dump_flow_info (dump_file);\n   close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n@@ -1439,10 +1351,6 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n void\n rest_of_compilation (void)\n {\n-  tree decl = current_function_decl;\n-  rtx insns;\n-\n-\n   /* There's no need to defer outputting this function any more; we\n      know we want to output it.  */\n   DECL_DEFER_OUTPUT (current_function_decl) = 0;\n@@ -1480,7 +1388,7 @@ rest_of_compilation (void)\n   init_flow ();\n \n   /* Dump the rtl code if we are dumping rtl.  */\n-  if (open_dump_file (DFI_rtl, decl))\n+  if (open_dump_file (DFI_rtl, current_function_decl))\n     close_dump_file (DFI_rtl, print_rtl, get_insns ());\n \n   /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n@@ -1502,8 +1410,8 @@ rest_of_compilation (void)\n   /* We are now committed to emitting code for this function.  Do any\n      preparation, such as emitting abstract debug info for the inline\n      before it gets mangled by optimization.  */\n-  if (cgraph_function_possibly_inlined_p (decl))\n-    (*debug_hooks->outlining_inline_function) (decl);\n+  if (cgraph_function_possibly_inlined_p (current_function_decl))\n+    (*debug_hooks->outlining_inline_function) (current_function_decl);\n \n   /* Remove any notes we don't need.  That will make iterating\n      over the instruction sequence faster, and allow the garbage\n@@ -1517,7 +1425,7 @@ rest_of_compilation (void)\n   /* Initialize some variables used by the optimizers.  */\n   init_function_for_compilation ();\n \n-  TREE_ASM_WRITTEN (decl) = 1;\n+  TREE_ASM_WRITTEN (current_function_decl) = 1;\n \n   /* Now that integrate will no longer see our rtl, we need not\n      distinguish between the return value of this function and the\n@@ -1534,11 +1442,10 @@ rest_of_compilation (void)\n     goto exit_rest_of_compilation;\n \n   timevar_push (TV_JUMP);\n-  open_dump_file (DFI_sibling, decl);\n-  insns = get_insns ();\n-  rebuild_jump_labels (insns);\n+  open_dump_file (DFI_sibling, current_function_decl);\n+  rebuild_jump_labels (get_insns ());\n   find_exception_handler_labels ();\n-  find_basic_blocks (insns, max_reg_num (), dump_file);\n+  find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n \n   delete_unreachable_blocks ();\n \n@@ -1560,7 +1467,7 @@ rest_of_compilation (void)\n   if (doing_eh (0))\n     {\n       timevar_push (TV_JUMP);\n-      open_dump_file (DFI_eh, decl);\n+      open_dump_file (DFI_eh, current_function_decl);\n \n       finish_eh_generation ();\n \n@@ -1581,24 +1488,22 @@ rest_of_compilation (void)\n     FINALIZE_PIC;\n #endif\n \n-  insns = get_insns ();\n-\n   /* Copy any shared structure that should not be shared.  */\n-  unshare_all_rtl (current_function_decl, insns);\n+  unshare_all_rtl ();\n \n #ifdef SETJMP_VIA_SAVE_AREA\n   /* This must be performed before virtual register instantiation.\n      Please be aware that everything in the compiler that can look\n      at the RTL up to this point must understand that REG_SAVE_AREA\n      is just like a use of the REG contained inside.  */\n   if (current_function_calls_alloca)\n-    optimize_save_area_alloca (insns);\n+    optimize_save_area_alloca (get_insns ());\n #endif\n \n   /* Instantiate all virtual registers.  */\n-  instantiate_virtual_regs (current_function_decl, insns);\n+  instantiate_virtual_regs ();\n \n-  open_dump_file (DFI_jump, decl);\n+  open_dump_file (DFI_jump, current_function_decl);\n \n   /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n      are initialized and to compute whether control can drop off the end\n@@ -1610,20 +1515,20 @@ rest_of_compilation (void)\n   if (flag_guess_branch_prob)\n     expected_value_to_br_prob ();\n \n-  reg_scan (insns, max_reg_num (), 0);\n-  rebuild_jump_labels (insns);\n-  find_basic_blocks (insns, max_reg_num (), dump_file);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n+  reg_scan (get_insns (), max_reg_num (), 0);\n+  rebuild_jump_labels (get_insns ());\n+  find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n   if (dump_file)\n     dump_flow_info (dump_file);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n \t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n   create_loop_notes ();\n \n-  purge_line_number_notes (insns);\n+  purge_line_number_notes (get_insns ());\n \n-  close_dump_file (DFI_jump, print_rtl, insns);\n+  close_dump_file (DFI_jump, print_rtl, get_insns ());\n \n   if (optimize)\n     cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n@@ -1636,75 +1541,75 @@ rest_of_compilation (void)\n   renumber_insns (dump_file);\n   timevar_pop (TV_JUMP);\n \n-  close_dump_file (DFI_jump, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_jump, print_rtl_with_bb, get_insns ());\n \n   ggc_collect ();\n \n   if (optimize > 0)\n-    rest_of_handle_cse (decl, insns);\n+    rest_of_handle_cse ();\n \n-  rest_of_handle_addressof (decl, insns);\n+  rest_of_handle_addressof ();\n \n   ggc_collect ();\n \n   if (optimize > 0)\n     {\n       if (flag_gcse)\n-\trest_of_handle_gcse (decl, insns);\n+\trest_of_handle_gcse ();\n \n       if (flag_loop_optimize)\n-\trest_of_handle_loop_optimize (decl, insns);\n+\trest_of_handle_loop_optimize ();\n \n       if (flag_gcse)\n-\trest_of_handle_jump_bypass (decl, insns);\n+\trest_of_handle_jump_bypass ();\n     }\n \n   timevar_push (TV_FLOW);\n \n-  rest_of_handle_cfg (decl, insns);\n+  rest_of_handle_cfg ();\n \n   if (!flag_tree_based_profiling\n       && (optimize > 0 || profile_arc_flag\n \t  || flag_test_coverage || flag_branch_probabilities))\n     {\n       rtl_register_profile_hooks ();\n       rtl_register_value_prof_hooks ();\n-      rest_of_handle_branch_prob (decl, insns);\n+      rest_of_handle_branch_prob ();\n \n       if (flag_branch_probabilities\n \t  && flag_profile_values\n \t  && flag_value_profile_transformations)\n-\trest_of_handle_value_profile_transformations (decl, insns);\n+\trest_of_handle_value_profile_transformations ();\n \n       /* Remove the death notes created for vpt.  */\n       if (flag_profile_values)\n \tcount_or_remove_death_notes (NULL, 1);\n     }\n \n   if (optimize > 0)\n-    rest_of_handle_if_conversion (decl, insns);\n+    rest_of_handle_if_conversion ();\n \n   if (flag_tracer)\n-    rest_of_handle_tracer (decl, insns);\n+    rest_of_handle_tracer ();\n \n   if (optimize > 0)\n-    rest_of_handle_loop2 (decl, insns);\n+    rest_of_handle_loop2 ();\n \n   if (flag_web)\n-    rest_of_handle_web (decl, insns);\n+    rest_of_handle_web ();\n \n   if (flag_rerun_cse_after_loop)\n-    rest_of_handle_cse2 (decl, insns);\n+    rest_of_handle_cse2 ();\n \n   cse_not_expected = 1;\n \n-  rest_of_handle_life (decl, insns);\n+  rest_of_handle_life ();\n \n   if (optimize > 0)\n-    rest_of_handle_combine (decl, insns);\n+    rest_of_handle_combine ();\n \n   if (flag_if_conversion)\n-    rest_of_handle_if_after_combine (decl, insns);\n+    rest_of_handle_if_after_combine ();\n \n   /* The optimization to partition hot/cold basic blocks into separate\n      sections of the .o file does not work well with exception handling.\n@@ -1721,7 +1626,7 @@ rest_of_compilation (void)\n     }\n \n   if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n-    rest_of_handle_regmove (decl, insns);\n+    rest_of_handle_regmove ();\n \n   /* Do unconditional splitting before register allocation to allow machine\n      description to add extra information not needed previously.  */\n@@ -1740,10 +1645,10 @@ rest_of_compilation (void)\n   /* Any of the several passes since flow1 will have munged register\n      lifetime data a bit.  We need it to be up to date for scheduling\n      (see handling of reg_known_equiv in init_alias_analysis).  */\n-  recompute_reg_usage (insns, !optimize_size);\n+  recompute_reg_usage (get_insns (), !optimize_size);\n \n #ifdef INSN_SCHEDULING\n-  rest_of_handle_sched (decl, insns);\n+  rest_of_handle_sched ();\n #endif\n \n   /* Determine if the current function is a leaf before running reload\n@@ -1752,61 +1657,61 @@ rest_of_compilation (void)\n   current_function_is_leaf = leaf_function_p ();\n \n   timevar_push (TV_LOCAL_ALLOC);\n-  open_dump_file (DFI_lreg, decl);\n+  open_dump_file (DFI_lreg, current_function_decl);\n \n   if (flag_new_regalloc)\n     {\n-      if (rest_of_handle_new_regalloc (decl, insns))\n+      if (rest_of_handle_new_regalloc ())\n \tgoto exit_rest_of_compilation;\n     }\n   else\n     {\n-      if (rest_of_handle_old_regalloc (decl, insns))\n+      if (rest_of_handle_old_regalloc ())\n \tgoto exit_rest_of_compilation;\n     }\n \n   ggc_collect ();\n \n-  open_dump_file (DFI_postreload, decl);\n+  open_dump_file (DFI_postreload, current_function_decl);\n \n   /* Do a very simple CSE pass over just the hard registers.  */\n   if (optimize > 0)\n     {\n       timevar_push (TV_RELOAD_CSE_REGS);\n-      reload_cse_regs (insns);\n+      reload_cse_regs (get_insns ());\n       /* reload_cse_regs can eliminate potentially-trapping MEMs.\n \t Remove any EH edges associated with them.  */\n       if (flag_non_call_exceptions)\n \tpurge_all_dead_edges (0);\n       timevar_pop (TV_RELOAD_CSE_REGS);\n     }\n \n-  close_dump_file (DFI_postreload, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_postreload, print_rtl_with_bb, get_insns ());\n \n   if (optimize > 0 && flag_gcse_after_reload)\n-    rest_of_handle_gcse2 (decl, insns);\n+    rest_of_handle_gcse2 ();\n \n   /* Re-create the death notes which were deleted during reload.  */\n   timevar_push (TV_FLOW2);\n-  open_dump_file (DFI_flow2, decl);\n+  open_dump_file (DFI_flow2, current_function_decl);\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n \n-  /* If optimizing, then go ahead and split insns now.  */\n+  /* If optimizing, then go ahead and split get_insns () now.  */\n #ifndef STACK_REGS\n   if (optimize > 0)\n #endif\n     split_all_insns (0);\n \n     if (flag_branch_target_load_optimize)\n       {\n-\topen_dump_file (DFI_branch_target_load, decl);\n+\topen_dump_file (DFI_branch_target_load, current_function_decl);\n \n \tbranch_target_load_optimize (/*after_prologue_epilogue_gen=*/false);\n \n-\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, get_insns ());\n \n \tggc_collect ();\n       }\n@@ -1815,10 +1720,10 @@ rest_of_compilation (void)\n     cleanup_cfg (CLEANUP_EXPENSIVE);\n \n   /* On some machines, the prologue and epilogue code, or parts thereof,\n-     can be represented as RTL.  Doing so lets us schedule insns between\n+     can be represented as RTL.  Doing so lets us schedule get_insns () between\n      it and the rest of the code and also allows delayed branch\n      scheduling to operate in the epilogue.  */\n-  thread_prologue_and_epilogue_insns (insns);\n+  thread_prologue_and_epilogue_insns (get_insns ());\n   epilogue_completed = 1;\n \n   if (optimize)\n@@ -1841,23 +1746,23 @@ rest_of_compilation (void)\n \n   flow2_completed = 1;\n \n-  close_dump_file (DFI_flow2, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_flow2, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_FLOW2);\n \n #ifdef HAVE_peephole2\n   if (optimize > 0 && flag_peephole2)\n     {\n       timevar_push (TV_PEEPHOLE2);\n-      open_dump_file (DFI_peephole2, decl);\n+      open_dump_file (DFI_peephole2, current_function_decl);\n \n       peephole2_optimize (dump_file);\n \n-      close_dump_file (DFI_peephole2, print_rtl_with_bb, insns);\n+      close_dump_file (DFI_peephole2, print_rtl_with_bb, get_insns ());\n       timevar_pop (TV_PEEPHOLE2);\n     }\n #endif\n \n-  open_dump_file (DFI_ce3, decl);\n+  open_dump_file (DFI_ce3, current_function_decl);\n   if (optimize)\n     /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n        splitting possibly introduced more crossjumping opportunities.  */\n@@ -1872,14 +1777,14 @@ rest_of_compilation (void)\n \n       timevar_pop (TV_IFCVT2);\n     }\n-  close_dump_file (DFI_ce3, print_rtl_with_bb, insns);\n+  close_dump_file (DFI_ce3, print_rtl_with_bb, get_insns ());\n \n   if (optimize > 0)\n     {\n       if (flag_rename_registers || flag_cprop_registers)\n-\trest_of_handle_regrename (decl, insns);\n+\trest_of_handle_regrename ();\n \n-      rest_of_handle_reorder_blocks (decl, insns);\n+      rest_of_handle_reorder_blocks ();\n     }\n \n   if (flag_branch_target_load_optimize2)\n@@ -1891,18 +1796,18 @@ rest_of_compilation (void)\n \twarning (\"branch target register load optimization is not intended \"\n \t\t \"to be run twice\");\n \n-      open_dump_file (DFI_branch_target_load, decl);\n+      open_dump_file (DFI_branch_target_load, current_function_decl);\n \n       branch_target_load_optimize (/*after_prologue_epilogue_gen=*/true);\n \n-      close_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+      close_dump_file (DFI_branch_target_load, print_rtl_with_bb, get_insns ());\n \n       ggc_collect ();\n     }\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n-    rest_of_handle_sched2 (decl, insns);\n+    rest_of_handle_sched2 ();\n #endif\n \n #ifdef LEAF_REGISTERS\n@@ -1911,26 +1816,26 @@ rest_of_compilation (void)\n #endif\n \n #ifdef STACK_REGS\n-  rest_of_handle_stack_regs (decl, insns);\n+  rest_of_handle_stack_regs ();\n #endif\n \n   compute_alignments ();\n \n   if (flag_var_tracking)\n-    rest_of_handle_variable_tracking (decl, insns);\n+    rest_of_handle_variable_tracking ();\n \n   /* CFG is no longer maintained up-to-date.  */\n   free_bb_for_insn ();\n \n   if (targetm.machine_dependent_reorg != 0)\n-    rest_of_handle_machine_reorg (decl, insns);\n+    rest_of_handle_machine_reorg ();\n \n-  purge_line_number_notes (insns);\n+  purge_line_number_notes (get_insns ());\n   cleanup_barriers ();\n \n #ifdef DELAY_SLOTS\n   if (optimize > 0 && flag_delayed_branch)\n-    rest_of_handle_delay_slots (decl, insns);\n+    rest_of_handle_delay_slots ();\n #endif\n \n #if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n@@ -1952,7 +1857,7 @@ rest_of_compilation (void)\n        of other functions later in this translation unit.  */\n     TREE_NOTHROW (current_function_decl) = 1;\n \n-  rest_of_handle_final (decl, insns);\n+  rest_of_handle_final ();\n \n   /* Write DBX symbols if requested.  */\n \n@@ -1966,7 +1871,7 @@ rest_of_compilation (void)\n      *will* be routed past here.  */\n \n   timevar_push (TV_SYMOUT);\n-  (*debug_hooks->function_decl) (decl);\n+  (*debug_hooks->function_decl) (current_function_decl);\n   timevar_pop (TV_SYMOUT);\n \n  exit_rest_of_compilation:"}, {"sha": "34de8725aa0ea5b69d232dab15795082c3ce5b3a", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "patch": "@@ -2177,6 +2177,7 @@ extern void pop_topmost_sequence (void);\n extern void reverse_comparison (rtx);\n extern void set_new_first_and_last_insn (rtx, rtx);\n extern void set_new_last_label_num (int);\n+extern void unshare_all_rtl (void);\n extern void unshare_all_rtl_again (rtx);\n extern void unshare_all_rtl_in_chain (rtx);\n extern void verify_rtl_sharing (void);"}, {"sha": "facd4217f1091b47f0713a133ce927e839672ed0", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd743bc1097ad82cd5bccc9149ac0f63ce36a239/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fd743bc1097ad82cd5bccc9149ac0f63ce36a239", "patch": "@@ -3415,8 +3415,6 @@ extern void preserve_temp_slots (rtx);\n extern void preserve_rtl_expr_temps (tree);\n extern int aggregate_value_p (tree, tree);\n extern void free_temps_for_rtl_expr (tree);\n-extern void instantiate_virtual_regs (tree, rtx);\n-extern void unshare_all_rtl (tree, rtx);\n extern void push_function_context (void);\n extern void pop_function_context (void);\n extern void push_function_context_to (tree);"}]}