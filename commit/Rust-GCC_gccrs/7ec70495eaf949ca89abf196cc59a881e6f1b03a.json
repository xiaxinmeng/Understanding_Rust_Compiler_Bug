{"sha": "7ec70495eaf949ca89abf196cc59a881e6f1b03a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VjNzA0OTVlYWY5NDljYTg5YWJmMTk2Y2M1OWE4ODFlNmYxYjAzYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-09-09T11:00:55Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2002-09-09T11:00:55Z"}, "message": "i386.c (index_register_operand): New.\n\n2002-09-09  Jan Hubicka  <jh@suse.cz>\n\n\t* i386.c (index_register_operand): New.\n\t* i386.h (predicate_codes): Add new predicate.\n\t* i386.md (lea_general_*): Use index_regsiter_operand\n\t(ashift to lea splitter): Do not produce invalid leas\n\t(ashift to mov+ashift split): New.\n\nFrom-SVN: r56970", "tree": {"sha": "37a9bcb38958706b29c3b3e9532a2dc6861d7730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37a9bcb38958706b29c3b3e9532a2dc6861d7730"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ec70495eaf949ca89abf196cc59a881e6f1b03a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec70495eaf949ca89abf196cc59a881e6f1b03a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec70495eaf949ca89abf196cc59a881e6f1b03a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec70495eaf949ca89abf196cc59a881e6f1b03a/comments", "author": null, "committer": null, "parents": [{"sha": "b2fc915b74f7f44d01c0c5ff0fbdc5dad005e2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2fc915b74f7f44d01c0c5ff0fbdc5dad005e2ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2fc915b74f7f44d01c0c5ff0fbdc5dad005e2ef"}], "stats": {"total": 67, "additions": 60, "deletions": 7}, "files": [{"sha": "be663674b9b12bfcc27f54850c78e3418e74c1df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ec70495eaf949ca89abf196cc59a881e6f1b03a", "patch": "@@ -1,3 +1,11 @@\n+2002-09-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (index_register_operand): New.\n+\t* i386.h (predicate_codes): Add new predicate.\n+\t* i386.md (lea_general_*): Use index_regsiter_operand\n+\t(ashift to lea splitter): Do not produce invalid leas\n+\t(ashift to mov+ashift split): New.\n+\n 2002-09-09  Nick Clifton  <nickc@redhat.com>\n \n \t* config/fr30/fr30.c (output.h): Move after inclusion of tree.h."}, {"sha": "81a9b97841d68db70149c368207e3dc410819f51", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7ec70495eaf949ca89abf196cc59a881e6f1b03a", "patch": "@@ -3217,6 +3217,30 @@ nonmemory_no_elim_operand (op, mode)\n   return GET_CODE (op) == CONST_INT || register_operand (op, mode);\n }\n \n+/* Return false if this is any eliminable register or stack register,\n+   otherwise work like register_operand.  */\n+\n+int\n+index_register_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx t = op;\n+  if (GET_CODE (t) == SUBREG)\n+    t = SUBREG_REG (t);\n+  if (!REG_P (t))\n+    return 0;\n+  if (t == arg_pointer_rtx\n+      || t == frame_pointer_rtx\n+      || t == virtual_incoming_args_rtx\n+      || t == virtual_stack_vars_rtx\n+      || t == virtual_stack_dynamic_rtx\n+      || REGNO (t) == STACK_POINTER_REGNUM)\n+    return 0;\n+\n+  return general_operand (op, mode);\n+}\n+\n /* Return true if op is a Q_REGS class register.  */\n \n int"}, {"sha": "ddef1f9da39f639f49f1bb5449e106a84a3ab102", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7ec70495eaf949ca89abf196cc59a881e6f1b03a", "patch": "@@ -3173,6 +3173,7 @@ do {\t\t\t\t\t\t\\\n   {\"general_no_elim_operand\", {CONST_INT, CONST_DOUBLE, CONST,\t\t\\\n \t\t\tSYMBOL_REF, LABEL_REF, SUBREG, REG, MEM}},\t\\\n   {\"nonmemory_no_elim_operand\", {CONST_INT, REG, SUBREG}},\t\t\\\n+  {\"index_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"q_regs_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"non_q_regs_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"fcmov_comparison_operator\", {EQ, NE, LTU, GTU, LEU, GEU, UNORDERED, \\"}, {"sha": "a306509c4465793ac2952ddd46e304c1ffffb626", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec70495eaf949ca89abf196cc59a881e6f1b03a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7ec70495eaf949ca89abf196cc59a881e6f1b03a", "patch": "@@ -4845,7 +4845,7 @@\n \n (define_insn_and_split \"*lea_general_1\"\n   [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t(plus (plus (match_operand 1 \"register_operand\" \"r\")\n+\t(plus (plus (match_operand 1 \"index_register_operand\" \"r\")\n \t\t    (match_operand 2 \"register_operand\" \"r\"))\n \t      (match_operand 3 \"immediate_operand\" \"i\")))]\n   \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode\n@@ -4877,7 +4877,7 @@\n (define_insn_and_split \"*lea_general_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t  (plus:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t  (plus:SI (plus:SI (match_operand:SI 1 \"index_register_operand\" \"r\")\n \t\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n \t\t   (match_operand:SI 3 \"immediate_operand\" \"i\"))))]\n   \"TARGET_64BIT\"\n@@ -4897,7 +4897,7 @@\n \n (define_insn_and_split \"*lea_general_2\"\n   [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t(plus (mult (match_operand 1 \"register_operand\" \"r\")\n+\t(plus (mult (match_operand 1 \"index_register_operand\" \"r\")\n \t\t    (match_operand 2 \"const248_operand\" \"i\"))\n \t      (match_operand 3 \"nonmemory_operand\" \"ri\")))]\n   \"(GET_MODE (operands[0]) == QImode || GET_MODE (operands[0]) == HImode\n@@ -4927,7 +4927,7 @@\n (define_insn_and_split \"*lea_general_2_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t  (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t  (plus:SI (mult:SI (match_operand:SI 1 \"index_register_operand\" \"r\")\n \t\t\t    (match_operand:SI 2 \"const248_operand\" \"n\"))\n \t\t   (match_operand:SI 3 \"nonmemory_operand\" \"ri\"))))]\n   \"TARGET_64BIT\"\n@@ -4946,7 +4946,7 @@\n \n (define_insn_and_split \"*lea_general_3\"\n   [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t(plus (plus (mult (match_operand 1 \"register_operand\" \"r\")\n+\t(plus (plus (mult (match_operand 1 \"index_register_operand\" \"r\")\n \t\t\t  (match_operand 2 \"const248_operand\" \"i\"))\n \t\t    (match_operand 3 \"register_operand\" \"r\"))\n \t      (match_operand 4 \"immediate_operand\" \"i\")))]\n@@ -4980,7 +4980,7 @@\n (define_insn_and_split \"*lea_general_3_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t  (plus:SI (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t  (plus:SI (plus:SI (mult:SI (match_operand:SI 1 \"index_register_operand\" \"r\")\n \t\t\t\t     (match_operand:SI 2 \"const248_operand\" \"n\"))\n \t\t\t    (match_operand:SI 3 \"register_operand\" \"r\"))\n \t\t   (match_operand:SI 4 \"immediate_operand\" \"i\"))))]\n@@ -10615,7 +10615,7 @@\n ;; Convert lea to the lea pattern to avoid flags dependency.\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(ashift (match_operand 1 \"register_operand\" \"\")\n+\t(ashift (match_operand 1 \"index_register_operand\" \"\")\n                 (match_operand:QI 2 \"const_int_operand\" \"\")))\n    (clobber (reg:CC 17))]\n   \"reload_completed\n@@ -10633,6 +10633,26 @@\n   DONE;\n })\n \n+;; Rare case of shifting RSP is handled by generating move and shift\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(ashift (match_operand 1 \"register_operand\" \"\")\n+                (match_operand:QI 2 \"const_int_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(const_int 0)]\n+{\n+  rtx pat, clob;\n+  emit_move_insn (operands[1], operands[0]);\n+  pat = gen_rtx_SET (VOIDmode, operands[0],\n+\t\t     gen_rtx_ASHIFT (GET_MODE (operands[0]),\n+\t\t\t\t     operands[0], operands[2]));\n+  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, pat, clob)));\n+  DONE;\n+})\n+\n (define_insn \"*ashlsi3_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0,r\")"}]}