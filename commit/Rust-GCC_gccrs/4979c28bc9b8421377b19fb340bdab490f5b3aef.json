{"sha": "4979c28bc9b8421377b19fb340bdab490f5b3aef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3OWMyOGJjOWI4NDIxMzc3YjE5ZmIzNDBiZGFiNDkwZjViM2FlZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-04-03T08:30:53Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-04-03T08:30:53Z"}, "message": "tree-if-conv.c (memrefs_read_or_written_unconditionally): Strip all non-variable offsets and compare the remaining bases of the two...\n\n\n\t* tree-if-conv.c (memrefs_read_or_written_unconditionally): Strip all\n\tnon-variable offsets and compare the remaining bases of the two\n\taccesses instead of looking for exact same data-ref.\n\n\nCo-Authored-By: Ira Rosen <ira.rosen@linaro.org>\n\nFrom-SVN: r171900", "tree": {"sha": "dcf06097c9c6142a7a4038eef56cba845bc7f087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf06097c9c6142a7a4038eef56cba845bc7f087"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4979c28bc9b8421377b19fb340bdab490f5b3aef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4979c28bc9b8421377b19fb340bdab490f5b3aef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4979c28bc9b8421377b19fb340bdab490f5b3aef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4979c28bc9b8421377b19fb340bdab490f5b3aef/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5f3cf4982788e1a974b026db2d5970d83cd538d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f3cf4982788e1a974b026db2d5970d83cd538d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f3cf4982788e1a974b026db2d5970d83cd538d"}], "stats": {"total": 138, "additions": 122, "deletions": 16}, "files": [{"sha": "faa7dab8da3a04581b149b31e0ecb7abc260b391", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4979c28bc9b8421377b19fb340bdab490f5b3aef", "patch": "@@ -1,3 +1,10 @@\n+2011-04-03  Richard Guenther  <rguenther@suse.de>\n+            Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-if-conv.c (memrefs_read_or_written_unconditionally): Strip all\n+\tnon-variable offsets and compare the remaining bases of the two\n+\taccesses instead of looking for exact same data-ref.\n+\n 2011-04-02  Kai Tietz  <ktietz@redhat.com>\n \n \tPR target/48416"}, {"sha": "5a39746b1a3551d70b8147f6cab32bf2f03b0ccf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4979c28bc9b8421377b19fb340bdab490f5b3aef", "patch": "@@ -1,3 +1,10 @@\n+2011-04-03  Richard Guenther  <rguenther@suse.de>\n+\t    Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c: New test.\n+\t* gcc.dg/vect/vect.exp: Run if-cvt-stores-vect* tests with\n+\t-ftree-loop-if-convert-stores.\n+\n 2011-04-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/aggr2.ads: New test."}, {"sha": "dc01e44508b3a7aa02ed26a5e4a1d644a9cd93db", "filename": "gcc/testsuite/gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fif-cvt-stores-vect-ifcvt-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fif-cvt-stores-vect-ifcvt-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fif-cvt-stores-vect-ifcvt-18.c?ref=4979c28bc9b8421377b19fb340bdab490f5b3aef", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 50\n+\n+typedef struct {\n+  short a;\n+  short b;\n+} data;\n+\n+data in1[N], in2[N], out[N];\n+short result[N*2] = {10,-7,11,-6,12,-5,13,-4,14,-3,15,-2,16,-1,17,0,18,1,19,2,20,3,21,4,22,5,23,6,24,7,25,8,26,9,27,10,28,11,29,12,30,13,31,14,32,15,33,16,34,17,35,18,36,19,37,20,38,21,39,22,40,23,41,24,42,25,43,26,44,27,45,28,46,29,47,30,48,31,49,32,50,33,51,34,52,35,53,36,54,37,55,38,56,39,57,40,58,41,59,42};\n+short out1[N], out2[N];\n+\n+__attribute__ ((noinline)) void\n+foo ()\n+{\n+  int i;\n+  short c, d;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      c = in1[i].b;\n+      d = in2[i].b;\n+\n+      if (c >= d)\n+        {\n+          out[i].b = in1[i].a;\n+          out[i].a = d + 5;\n+        }\n+      else\n+        {\n+          out[i].b = d - 12;\n+          out[i].a = in2[i].a + d;\n+        }\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in1[i].a = i;\n+      in1[i].b = i + 2;\n+      in2[i].a = 5;\n+      in2[i].b = i + 5;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i].a != result[2*i] || out[i].b != result[2*i+1])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { xfail { vect_no_align || {! vect_strided } } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4e939591b97bf4e85a354a317ace413196feba9b", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=4979c28bc9b8421377b19fb340bdab490f5b3aef", "patch": "@@ -210,6 +210,12 @@ lappend DEFAULT_VECTCFLAGS \"--param\" \"ggc-min-expand=0\" \"--param\" \"ggc-min-heaps\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/ggc-*.\\[cS\\]]]  \\\n         \"\" $DEFAULT_VECTCFLAGS\n \n+# -ftree-loop-if-convert-stores\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-ftree-loop-if-convert-stores\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/if-cvt-stores-vect-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n+\n # With -O3.\n # Don't allow IPA cloning, because it throws our counts out of whack.\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS"}, {"sha": "7ca6deec123634583c92b44adcdfdc8c9ffcdae8", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4979c28bc9b8421377b19fb340bdab490f5b3aef/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=4979c28bc9b8421377b19fb340bdab490f5b3aef", "patch": "@@ -464,8 +464,8 @@ struct ifc_dr {\n /* Returns true when the memory references of STMT are read or written\n    unconditionally.  In other words, this function returns true when\n    for every data reference A in STMT there exist other accesses to\n-   the same data reference with predicates that add up (OR-up) to the\n-   true predicate: this ensures that the data reference A is touched\n+   a data reference with the same base with predicates that add up (OR-up) to\n+   the true predicate: this ensures that the data reference A is touched\n    (read or written) on every iteration of the if-converted loop.  */\n \n static bool\n@@ -489,21 +489,38 @@ memrefs_read_or_written_unconditionally (gimple stmt,\n \t  continue;\n \n \tfor (j = 0; VEC_iterate (data_reference_p, drs, j, b); j++)\n-\t  if (DR_STMT (b) != stmt\n-\t      && same_data_refs (a, b))\n-\t    {\n-\t      tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n+          {\n+            tree ref_base_a = DR_REF (a);\n+            tree ref_base_b = DR_REF (b);\n \n-\t      if (DR_RW_UNCONDITIONALLY (b) == 1\n-\t\t  || is_true_predicate (cb)\n-\t\t  || is_true_predicate (ca = fold_or_predicates (EXPR_LOCATION (cb),\n-\t\t\t\t\t\t\t\t ca, cb)))\n-\t\t{\n-\t\t  DR_RW_UNCONDITIONALLY (a) = 1;\n-\t\t  DR_RW_UNCONDITIONALLY (b) = 1;\n-\t\t  found = true;\n-\t\t  break;\n-\t\t}\n+            if (DR_STMT (b) == stmt)\n+              continue;\n+\n+            while (TREE_CODE (ref_base_a) == COMPONENT_REF\n+                   || TREE_CODE (ref_base_a) == IMAGPART_EXPR\n+                   || TREE_CODE (ref_base_a) == REALPART_EXPR)\n+              ref_base_a = TREE_OPERAND (ref_base_a, 0);\n+\n+            while (TREE_CODE (ref_base_b) == COMPONENT_REF\n+                   || TREE_CODE (ref_base_b) == IMAGPART_EXPR\n+                   || TREE_CODE (ref_base_b) == REALPART_EXPR)\n+              ref_base_b = TREE_OPERAND (ref_base_b, 0);\n+\n+  \t    if (!operand_equal_p (ref_base_a, ref_base_b, 0))\n+\t      {\n+\t        tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n+\n+\t        if (DR_RW_UNCONDITIONALLY (b) == 1\n+\t\t    || is_true_predicate (cb)\n+\t\t    || is_true_predicate (ca\n+                        = fold_or_predicates (EXPR_LOCATION (cb), ca, cb)))\n+\t\t  {\n+\t\t    DR_RW_UNCONDITIONALLY (a) = 1;\n+  \t\t    DR_RW_UNCONDITIONALLY (b) = 1;\n+\t\t    found = true;\n+\t\t    break;\n+\t\t  }\n+               }\n \t    }\n \n \tif (!found)"}]}