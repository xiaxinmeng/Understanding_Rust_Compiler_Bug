{"sha": "29797f340dccaaa714e993426b925f23f94d362c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk3OTdmMzQwZGNjYWFhNzE0ZTk5MzQyNmI5MjVmMjNmOTRkMzYyYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T18:09:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:09:38Z"}, "message": "sem_eval.adb (Compile_Time_Compare): Make use of information from Current_Value in the conditional case...\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_eval.adb (Compile_Time_Compare): Make use of information from\n\tCurrent_Value in the conditional case, to evaluate additional\n\tcomparisons at compile time.\n\nFrom-SVN: r118310", "tree": {"sha": "b3e1f3398b0d7e9fa9bfbaee72cbc024a44337a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3e1f3398b0d7e9fa9bfbaee72cbc024a44337a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29797f340dccaaa714e993426b925f23f94d362c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29797f340dccaaa714e993426b925f23f94d362c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29797f340dccaaa714e993426b925f23f94d362c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29797f340dccaaa714e993426b925f23f94d362c/comments", "author": null, "committer": null, "parents": [{"sha": "a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5abb241f3c53daf6ebbb82992b5227fcdb750c5"}], "stats": {"total": 150, "additions": 138, "deletions": 12}, "files": [{"sha": "84f67a2e2842a704cd4325d11acbf9ef5fa217f9", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 138, "deletions": 12, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29797f340dccaaa714e993426b925f23f94d362c/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29797f340dccaaa714e993426b925f23f94d362c/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=29797f340dccaaa714e993426b925f23f94d362c", "patch": "@@ -702,6 +702,16 @@ package body Sem_Eval is\n       --  Cases where at least one operand is not known at compile time\n \n       else\n+         --  Remaining checks apply only for non-generic discrete types\n+\n+         if not Is_Discrete_Type (Ltyp)\n+           or else not Is_Discrete_Type (Rtyp)\n+           or else Is_Generic_Type (Ltyp)\n+           or else Is_Generic_Type (Rtyp)\n+         then\n+            return Unknown;\n+         end if;\n+\n          --  Here is where we check for comparisons against maximum bounds of\n          --  types, where we know that no value can be outside the bounds of\n          --  the subtype. Note that this routine is allowed to assume that all\n@@ -712,16 +722,12 @@ package body Sem_Eval is\n          --  attempt this optimization with generic types, since the type\n          --  bounds may not be meaningful in this case.\n \n-         --  We are in danger of an infinite recursion here. It does not seem\n+         --  We are in danger of an  infinite recursion here. It does not seem\n          --  useful to go more than one level deep, so the parameter Rec is\n          --  used to protect ourselves against this infinite recursion.\n \n-         if not Rec\n-           and then Is_Discrete_Type (Ltyp)\n-           and then Is_Discrete_Type (Rtyp)\n-           and then not Is_Generic_Type (Ltyp)\n-           and then not Is_Generic_Type (Rtyp)\n-         then\n+         if not Rec then\n+\n             --  See if we can get a decisive check against one operand and\n             --  a bound of the other operand (four possible tests here).\n \n@@ -785,13 +791,134 @@ package body Sem_Eval is\n                else\n                   return GT;\n                end if;\n+            end if;\n+         end;\n+\n+         --  Next attempt is to see if we have an entity compared with a\n+         --  compile time known value, where there is a current value\n+         --  conditional for the entity which can tell us the result.\n+\n+         declare\n+            Var : Node_Id;\n+            --  Entity variable (left operand)\n+\n+            Val : Uint;\n+            --  Value (right operand)\n+\n+            Inv : Boolean;\n+            --  If False, we have reversed the operands\n+\n+            Op : Node_Kind;\n+            --  Comparison operator kind from Get_Current_Value_Condition call\n \n-            --  If the expressions are different, we cannot say at compile\n-            --  time how they compare, so we return the Unknown indication.\n+            Opn : Node_Id;\n+            --  Value from Get_Current_Value_Condition call\n+\n+            Opv : Uint;\n+            --  Value of Opn\n+\n+            Result : Compare_Result;\n+            --  Known result before inversion\n+\n+         begin\n+            if Is_Entity_Name (L)\n+              and then Compile_Time_Known_Value (R)\n+            then\n+               Var := L;\n+               Val := Expr_Value (R);\n+               Inv := False;\n+\n+            elsif Is_Entity_Name (R)\n+              and then Compile_Time_Known_Value (L)\n+            then\n+               Var := R;\n+               Val := Expr_Value (L);\n+               Inv := True;\n+\n+               --  That was the last chance at finding a compile time result\n \n             else\n                return Unknown;\n             end if;\n+\n+            Get_Current_Value_Condition (Var, Op, Opn);\n+\n+            --  That was the last chance, so if we got nothing return\n+\n+            if No (Opn) then\n+               return Unknown;\n+            end if;\n+\n+            Opv := Expr_Value (Opn);\n+\n+            --  We got a comparison, so we might have something interesting\n+\n+            --  Convert LE to LT and GE to GT, just so we have fewer cases\n+\n+            if Op = N_Op_Le then\n+               Op := N_Op_Lt;\n+               Opv := Opv + 1;\n+            elsif Op = N_Op_Ge then\n+               Op := N_Op_Gt;\n+               Opv := Opv - 1;\n+            end if;\n+\n+            --  Deal with equality case\n+\n+            if Op = N_Op_Eq then\n+               if Val = Opv then\n+                  Result := EQ;\n+               elsif Opv < Val then\n+                  Result := LT;\n+               else\n+                  Result := GT;\n+               end if;\n+\n+            --  Deal with inequality case\n+\n+            elsif Op = N_Op_Ne then\n+               if Val = Opv then\n+                  Result := NE;\n+               else\n+                  return Unknown;\n+               end if;\n+\n+            --  Deal with greater than case\n+\n+            elsif Op = N_Op_Gt then\n+               if Opv >= Val then\n+                  Result := GT;\n+               elsif Opv = Val - 1 then\n+                  Result := GE;\n+               else\n+                  return Unknown;\n+               end if;\n+\n+            --  Deal with less than case\n+\n+            else pragma Assert (Op = N_Op_Lt);\n+               if Opv <= Val then\n+                  Result := LT;\n+               elsif Opv = Val + 1 then\n+                  Result := LE;\n+               else\n+                  return Unknown;\n+               end if;\n+            end if;\n+\n+            --  Deal with inverting result\n+\n+            if Inv then\n+               case Result is\n+                  when GT     => return LT;\n+                  when GE     => return LE;\n+                  when LT     => return GT;\n+                  when LE     => return GE;\n+                  when others => return Result;\n+               end case;\n+            end if;\n+\n+            return Result;\n          end;\n       end if;\n    end Compile_Time_Compare;\n@@ -1235,6 +1362,7 @@ package body Sem_Eval is\n    --  with static arguments, or calls to functions that rename a literal.\n    --  Only the latter case is handled here, predefined operators are\n    --  constant-folded elsewhere.\n+\n    --  If the function is itself inherited (see 7423-001) the literal of\n    --  the parent type must be explicitly converted to the return type\n    --  of the function.\n@@ -1252,7 +1380,6 @@ package body Sem_Eval is\n         and then Is_Enumeration_Type (Base_Type (Typ))\n       then\n          Lit := Alias (Entity (Name (N)));\n-\n          while Present (Alias (Lit)) loop\n             Lit := Alias (Lit);\n          end loop;\n@@ -2421,7 +2548,6 @@ package body Sem_Eval is\n \n    procedure Eval_Slice (N : Node_Id) is\n       Drange : constant Node_Id := Discrete_Range (N);\n-\n    begin\n       if Nkind (Drange) = N_Range then\n          Check_Non_Static_Context (Low_Bound (Drange));\n@@ -4358,7 +4484,7 @@ package body Sem_Eval is\n                   \"('R'M 4.9(5))!\", N, E);\n             end if;\n \n-         when N_Binary_Op | N_And_Then | N_Or_Else | N_In | N_Not_In =>\n+         when N_Binary_Op | N_And_Then | N_Or_Else | N_Membership_Test =>\n             if Nkind (N) in N_Op_Shift then\n                Error_Msg_N\n                 (\"shift functions are never static ('R'M 4.9(6,18))!\", N);"}]}