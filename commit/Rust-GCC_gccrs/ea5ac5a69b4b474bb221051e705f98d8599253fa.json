{"sha": "ea5ac5a69b4b474bb221051e705f98d8599253fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE1YWM1YTY5YjRiNDc0YmIyMjEwNTFlNzA1Zjk4ZDg1OTkyNTNmYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-19T18:42:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-19T18:42:43Z"}, "message": "compiler,runtime: pass old slice's ptr/len/cap by value to growslice\n    \n    In the C calling convention, on AMD64, and probably a number of\n    other architectures, a 3-word struct argument is passed on stack.\n    This is less efficient than passing in three registers. Further,\n    this may affect the code generation in other part of the program,\n    even if the function is not actually called.\n    \n    Slices are common in Go and append is a common slice operation,\n    which calls growslice in the growing path. To improve the code\n    generation, pass the slice header's three fields as separate\n    values, instead of a struct, to growslice.\n    \n    The drawback is that this makes the runtime implementation\n    slightly diverges from the gc runtime.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/168277\n\nFrom-SVN: r269811", "tree": {"sha": "96913ddcd86133f8a48bb74399326f954e503841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96913ddcd86133f8a48bb74399326f954e503841"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea5ac5a69b4b474bb221051e705f98d8599253fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5ac5a69b4b474bb221051e705f98d8599253fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea5ac5a69b4b474bb221051e705f98d8599253fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5ac5a69b4b474bb221051e705f98d8599253fa/comments", "author": null, "committer": null, "parents": [{"sha": "e0748030863e158ced48802ea42b27e5ec26995f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0748030863e158ced48802ea42b27e5ec26995f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0748030863e158ced48802ea42b27e5ec26995f"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "4a9853ab68c783460421dcbfaba69b13649d800c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea5ac5a69b4b474bb221051e705f98d8599253fa/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea5ac5a69b4b474bb221051e705f98d8599253fa/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=ea5ac5a69b4b474bb221051e705f98d8599253fa", "patch": "@@ -1,4 +1,4 @@\n-069afe85f38c099660c5d81950d65248ed4fc516\n+6e5ff227d4e77d340e86bd2c5e045d5532c2d7d7\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "018fdbbec77bd656de8997e81894d5565798052b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea5ac5a69b4b474bb221051e705f98d8599253fa/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea5ac5a69b4b474bb221051e705f98d8599253fa/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=ea5ac5a69b4b474bb221051e705f98d8599253fa", "patch": "@@ -7986,23 +7986,33 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n   // Using uint here means that if the computation of ntmp overflowed,\n   // we will call growslice which will panic.\n \n-  Expression* left = Expression::make_temporary_reference(ntmp, loc);\n-  left = Expression::make_cast(uint_type, left, loc);\n-\n   Named_object* capfn = gogo->lookup_global(\"cap\");\n   Expression* capref = Expression::make_func_reference(capfn, NULL, loc);\n   call_args = new Expression_list();\n   call_args->push_back(Expression::make_temporary_reference(s1tmp, loc));\n-  Expression* right = Expression::make_call(capref, call_args, false, loc);\n+  Expression* cap = Expression::make_call(capref, call_args, false, loc);\n+  gogo->lower_expression(function, inserter, &cap);\n+  gogo->flatten_expression(function, inserter, &cap);\n+  Temporary_statement* c1tmp = Statement::make_temporary(int_type, cap, loc);\n+  inserter->insert(c1tmp);\n+\n+  Expression* left = Expression::make_temporary_reference(ntmp, loc);\n+  left = Expression::make_cast(uint_type, left, loc);\n+  Expression* right = Expression::make_temporary_reference(c1tmp, loc);\n   right = Expression::make_cast(uint_type, right, loc);\n \n   Expression* cond = Expression::make_binary(OPERATOR_GT, left, right, loc);\n \n+  Type* unsafe_ptr_type = Type::make_pointer_type(Type::make_void_type());\n   Expression* a1 = Expression::make_type_descriptor(element_type, loc);\n   Expression* a2 = Expression::make_temporary_reference(s1tmp, loc);\n-  Expression* a3 = Expression::make_temporary_reference(ntmp, loc);\n-  Expression* call = Runtime::make_call(Runtime::GROWSLICE, loc, 3,\n-\t\t\t\t\ta1, a2, a3);\n+  a2 = slice_type->array_type()->get_value_pointer(gogo, a2, false);\n+  a2 = Expression::make_cast(unsafe_ptr_type, a2, loc);\n+  Expression* a3 = Expression::make_temporary_reference(l1tmp, loc);\n+  Expression* a4 = Expression::make_temporary_reference(c1tmp, loc);\n+  Expression* a5 = Expression::make_temporary_reference(ntmp, loc);\n+  Expression* call = Runtime::make_call(Runtime::GROWSLICE, loc, 5,\n+\t\t\t\t\ta1, a2, a3, a4, a5);\n   call = Expression::make_unsafe_cast(slice_type, call, loc);\n \n   ref = Expression::make_temporary_reference(s1tmp, loc);"}, {"sha": "83a71528a8c4d5ead3bfb1f37369bab0b4bc3abd", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea5ac5a69b4b474bb221051e705f98d8599253fa/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea5ac5a69b4b474bb221051e705f98d8599253fa/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=ea5ac5a69b4b474bb221051e705f98d8599253fa", "patch": "@@ -202,7 +202,8 @@ DEF_GO_RUNTIME(TYPEDSLICECOPY, \"runtime.typedslicecopy\",\n \n \n // Grow a slice for append.\n-DEF_GO_RUNTIME(GROWSLICE, \"runtime.growslice\", P3(TYPE, SLICE, INT), R1(SLICE))\n+DEF_GO_RUNTIME(GROWSLICE, \"runtime.growslice\",\n+               P5(TYPE, POINTER, INT, INT, INT), R1(SLICE))\n \n \n // Register roots (global variables) for the garbage collector."}, {"sha": "9137951bfe9a363ce53eb85e97f871f24debca71", "filename": "libgo/go/runtime/slice.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea5ac5a69b4b474bb221051e705f98d8599253fa/libgo%2Fgo%2Fruntime%2Fslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea5ac5a69b4b474bb221051e705f98d8599253fa/libgo%2Fgo%2Fruntime%2Fslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fslice.go?ref=ea5ac5a69b4b474bb221051e705f98d8599253fa", "patch": "@@ -77,31 +77,31 @@ func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {\n // and it returns a new slice with at least that capacity, with the old data\n // copied into it.\n // The new slice's length is set to the requested capacity.\n-func growslice(et *_type, old slice, cap int) slice {\n+func growslice(et *_type, oldarray unsafe.Pointer, oldlen, oldcap, cap int) slice {\n \tif raceenabled {\n \t\tcallerpc := getcallerpc()\n-\t\tracereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))\n+\t\tracereadrangepc(oldarray, uintptr(oldlen*int(et.size)), callerpc, funcPC(growslice))\n \t}\n \tif msanenabled {\n-\t\tmsanread(old.array, uintptr(old.len*int(et.size)))\n+\t\tmsanread(oldarray, uintptr(oldlen*int(et.size)))\n \t}\n \n-\tif cap < old.cap {\n+\tif cap < oldcap {\n \t\tpanic(errorString(\"growslice: cap out of range\"))\n \t}\n \n \tif et.size == 0 {\n \t\t// append should not create a slice with nil pointer but non-zero len.\n-\t\t// We assume that append doesn't need to preserve old.array in this case.\n+\t\t// We assume that append doesn't need to preserve oldarray in this case.\n \t\treturn slice{unsafe.Pointer(&zerobase), cap, cap}\n \t}\n \n-\tnewcap := old.cap\n+\tnewcap := oldcap\n \tdoublecap := newcap + newcap\n \tif cap > doublecap {\n \t\tnewcap = cap\n \t} else {\n-\t\tif old.len < 1024 {\n+\t\tif oldlen < 1024 {\n \t\t\tnewcap = doublecap\n \t\t} else {\n \t\t\t// Check 0 < newcap to detect overflow\n@@ -125,13 +125,13 @@ func growslice(et *_type, old slice, cap int) slice {\n \t// For powers of 2, use a variable shift.\n \tswitch {\n \tcase et.size == 1:\n-\t\tlenmem = uintptr(old.len)\n+\t\tlenmem = uintptr(oldlen)\n \t\tnewlenmem = uintptr(cap)\n \t\tcapmem = roundupsize(uintptr(newcap))\n \t\toverflow = uintptr(newcap) > maxAlloc\n \t\tnewcap = int(capmem)\n \tcase et.size == sys.PtrSize:\n-\t\tlenmem = uintptr(old.len) * sys.PtrSize\n+\t\tlenmem = uintptr(oldlen) * sys.PtrSize\n \t\tnewlenmem = uintptr(cap) * sys.PtrSize\n \t\tcapmem = roundupsize(uintptr(newcap) * sys.PtrSize)\n \t\toverflow = uintptr(newcap) > maxAlloc/sys.PtrSize\n@@ -144,13 +144,13 @@ func growslice(et *_type, old slice, cap int) slice {\n \t\t} else {\n \t\t\tshift = uintptr(sys.Ctz32(uint32(et.size))) & 31\n \t\t}\n-\t\tlenmem = uintptr(old.len) << shift\n+\t\tlenmem = uintptr(oldlen) << shift\n \t\tnewlenmem = uintptr(cap) << shift\n \t\tcapmem = roundupsize(uintptr(newcap) << shift)\n \t\toverflow = uintptr(newcap) > (maxAlloc >> shift)\n \t\tnewcap = int(capmem >> shift)\n \tdefault:\n-\t\tlenmem = uintptr(old.len) * et.size\n+\t\tlenmem = uintptr(oldlen) * et.size\n \t\tnewlenmem = uintptr(cap) * et.size\n \t\tcapmem, overflow = math.MulUintptr(et.size, uintptr(newcap))\n \t\tcapmem = roundupsize(capmem)\n@@ -177,19 +177,19 @@ func growslice(et *_type, old slice, cap int) slice {\n \tvar p unsafe.Pointer\n \tif et.kind&kindNoPointers != 0 {\n \t\tp = mallocgc(capmem, nil, false)\n-\t\t// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).\n+\t\t// The append() that calls growslice is going to overwrite from oldlen to cap (which will be the new length).\n \t\t// Only clear the part that will not be overwritten.\n \t\tmemclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\n \t} else {\n \t\t// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.\n \t\tp = mallocgc(capmem, et, true)\n \t\tif writeBarrier.enabled {\n-\t\t\t// Only shade the pointers in old.array since we know the destination slice p\n+\t\t\t// Only shade the pointers in oldarray since we know the destination slice p\n \t\t\t// only contains nil pointers because it has been cleared during alloc.\n-\t\t\tbulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)\n+\t\t\tbulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(oldarray), lenmem)\n \t\t}\n \t}\n-\tmemmove(p, old.array, lenmem)\n+\tmemmove(p, oldarray, lenmem)\n \n \treturn slice{p, cap, newcap}\n }"}]}