{"sha": "7d8b14121146181f36a96a8488460fd21cfd6455", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4YjE0MTIxMTQ2MTgxZjM2YTk2YTg0ODg0NjBmZDIxY2ZkNjQ1NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2001-07-14T02:39:39Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-07-14T02:39:39Z"}, "message": "pa.c (emit_hpdiv_const): Return reg is r2 for 64-bit millicode.\n\n\t* config/pa/pa.c (emit_hpdiv_const): Return reg is r2 for 64-bit\n\tmillicode.\n\t(insn_refs_are_delayed): Correct comment.\n\t* config/pa/pa.h (INSN_REFERENCES_ARE_DELAYED): Likewise.\n\t* config/pa/pa.md (mulsi3): If TARGET_64BIT, clobber r2\n\tinstead of r31.  Make associated insn !TARGET_64BIT, and\n\tprovide an additional 64-bit insn that clobbers r2.\n\t(divsi3): Likewise.\n\t(udivsi3): Likewise.\n\t(modsi3): Likewise.\n\t(umodsi3): Likewise.\n\nFrom-SVN: r44003", "tree": {"sha": "9dfdf982ad4e674725743f7990f863ef8cc7f2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dfdf982ad4e674725743f7990f863ef8cc7f2b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d8b14121146181f36a96a8488460fd21cfd6455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8b14121146181f36a96a8488460fd21cfd6455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8b14121146181f36a96a8488460fd21cfd6455", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8b14121146181f36a96a8488460fd21cfd6455/comments", "author": null, "committer": null, "parents": [{"sha": "1ed672dd7c9f547350e96259e013ed6a4bd4d6ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed672dd7c9f547350e96259e013ed6a4bd4d6ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed672dd7c9f547350e96259e013ed6a4bd4d6ed"}], "stats": {"total": 170, "additions": 143, "deletions": 27}, "files": [{"sha": "098ffcdfba381b99aad680a3ad3d5b441e556d5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d8b14121146181f36a96a8488460fd21cfd6455", "patch": "@@ -1,3 +1,17 @@\n+2001-07-14  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/pa/pa.c (emit_hpdiv_const): Return reg is r2 for 64-bit\n+\tmillicode.\n+\t(insn_refs_are_delayed): Correct comment.\n+\t* config/pa/pa.h (INSN_REFERENCES_ARE_DELAYED): Likewise.\n+\t* config/pa/pa.md (mulsi3): If TARGET_64BIT, clobber r2\n+\tinstead of r31.  Make associated insn !TARGET_64BIT, and\n+\tprovide an additional 64-bit insn that clobbers r2.\n+\t(divsi3): Likewise.\n+\t(udivsi3): Likewise.\n+\t(modsi3): Likewise.\n+\t(umodsi3): Likewise.\n+\n Sat Jul 14 02:58:38 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* bb-reorder.c (skip_insn_after_block): Get past the line number notes."}, {"sha": "8d9a89124ced5fbba72f42d0fda439d0e8be371c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=7d8b14121146181f36a96a8488460fd21cfd6455", "patch": "@@ -4450,6 +4450,8 @@ emit_hpdiv_const (operands, unsignedp)\n       && INTVAL (operands[2]) < 16\n       && magic_milli[INTVAL (operands[2])])\n     {\n+      rtx ret = gen_rtx_REG (SImode, TARGET_64BIT ? 2 : 31);\n+\n       emit_move_insn (gen_rtx_REG (SImode, 26), operands[1]);\n       emit\n \t(gen_rtx\n@@ -4463,7 +4465,7 @@ emit_hpdiv_const (operands, unsignedp)\n \t\t     gen_rtx_CLOBBER (VOIDmode, operands[3]),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 26)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 25)),\n-\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 31)))));\n+\t\t     gen_rtx_CLOBBER (VOIDmode, ret))));\n       emit_move_insn (operands[0], gen_rtx_REG (SImode, 29));\n       return 1;\n     }\n@@ -6904,12 +6906,18 @@ pa_can_combine_p (new, anchor, floater, reversed, dest, src1, src2)\n \n    Millicode calls always expect their arguments in the integer argument\n    registers, and always return their result in %r29 (ret1).  They\n-   are expected to clobber their arguments, %r1, %r29, and %r31 and\n-   nothing else.\n-\n-   By considering this effects delayed reorg reorg can put insns\n-   which set the argument registers into the delay slot of the millicode\n-   call -- thus they act more like traditional CALL_INSNs.\n+   are expected to clobber their arguments, %r1, %r29, and the return\n+   pointer which is %r31 on 32-bit and %r2 on 64-bit, and nothing else.\n+\n+   This function tells reorg that the references to arguments and\n+   millicode calls do not appear to happen until after the millicode call.\n+   This allows reorg to put insns which set the argument registers into the\n+   delay slot of the millicode call -- thus they act more like traditional\n+   CALL_INSNs.\n+\n+   Note we can not consider side effects of the insn to be delayed because\n+   the branch and link insn will clobber the return pointer.  If we happened\n+   to use the return pointer in the delay slot of the call, then we lose.\n \n    get_attr_type will try to recognize the given insn, so make sure to\n    filter out things it will not accept -- SEQUENCE, USE and CLOBBER insns"}, {"sha": "8358e8894687b1fa926262578776c6d7dcf60c12", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=7d8b14121146181f36a96a8488460fd21cfd6455", "patch": "@@ -1691,8 +1691,8 @@ while (0)\n \n    Millicode calls always expect their arguments in the integer argument\n    registers, and always return their result in %r29 (ret1).  They\n-   are expected to clobber their arguments, %r1, %r29, and %r31 and\n-   nothing else.\n+   are expected to clobber their arguments, %r1, %r29, and the return\n+   pointer which is %r31 on 32-bit and %r2 on 64-bit, and nothing else.\n \n    This macro tells reorg that the references to arguments and\n    millicode calls do not appear to happen until after the millicode call."}, {"sha": "3962de9729bb5040651dad1b03de2e888341464d", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 112, "deletions": 18, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8b14121146181f36a96a8488460fd21cfd6455/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=7d8b14121146181f36a96a8488460fd21cfd6455", "patch": "@@ -3869,11 +3869,12 @@\n \t      (clobber (match_dup 3))\n \t      (clobber (reg:SI 26))\n \t      (clobber (reg:SI 25))\n-\t      (clobber (reg:SI 31))])\n+\t      (clobber (match_dup 4))])\n    (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n   \"\"\n   \"\n {\n+  operands[4] = gen_rtx_REG (SImode, TARGET_64BIT ? 2 : 31);\n   if (TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT)\n     {\n       rtx scratch = gen_reg_rtx (DImode);\n@@ -3930,7 +3931,7 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"* return output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n    (set (attr \"length\")\n@@ -3955,6 +3956,17 @@\n ;; Out of reach, can use ble\n           (const_int 12)))])\n \n+(define_insn \"\"\n+  [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 2))]\n+  \"TARGET_64BIT\"\n+  \"* return output_mul_insn (0, insn);\"\n+  [(set_attr \"type\" \"milli\")\n+   (set (attr \"length\") (const_int 4))])\n+\n (define_expand \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n@@ -4012,15 +4024,22 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (reg:SI 26))\n \t      (clobber (reg:SI 25))\n-\t      (clobber (reg:SI 31))])\n+\t      (clobber (match_dup 5))])\n    (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n   \"\"\n   \"\n {\n   operands[3] = gen_reg_rtx (SImode);\n-  operands[4] = gen_reg_rtx (SImode);\n   if (TARGET_64BIT)\n-    operands[4] = gen_rtx_REG (SImode, 2);\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 2);\n+      operands[4] = operands[5];\n+    }\n+  else\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 31);\n+      operands[4] = gen_reg_rtx (SImode);\n+    }\n   if (GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const (operands, 0))\n     DONE;\n }\")\n@@ -4033,7 +4052,7 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n    return output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n@@ -4059,6 +4078,20 @@\n ;; Out of reach, can use ble\n           (const_int 12)))])\n \n+(define_insn \"\"\n+  [(set (reg:SI 29)\n+\t(div:SI (reg:SI 26) (match_operand:SI 0 \"div_operand\" \"\")))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=a\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 2))]\n+  \"TARGET_64BIT\"\n+  \"*\n+   return output_div_insn (operands, 0, insn);\"\n+  [(set_attr \"type\" \"milli\")\n+   (set (attr \"length\") (const_int 4))])\n+\n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n    (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n@@ -4067,15 +4100,22 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (reg:SI 26))\n \t      (clobber (reg:SI 25))\n-\t      (clobber (reg:SI 31))])\n+\t      (clobber (match_dup 5))])\n    (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n   \"\"\n   \"\n {\n   operands[3] = gen_reg_rtx (SImode);\n-  operands[4] = gen_reg_rtx (SImode);\n   if (TARGET_64BIT)\n-    operands[4] = gen_rtx_REG (SImode, 2);\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 2);\n+      operands[4] = operands[5];\n+    }\n+  else\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 31);\n+      operands[4] = gen_reg_rtx (SImode);\n+    }\n   if (GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const (operands, 1))\n     DONE;\n }\")\n@@ -4088,7 +4128,7 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n    return output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n@@ -4114,6 +4154,20 @@\n ;; Out of reach, can use ble\n           (const_int 12)))])\n \n+(define_insn \"\"\n+  [(set (reg:SI 29)\n+\t(udiv:SI (reg:SI 26) (match_operand:SI 0 \"div_operand\" \"\")))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=a\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 2))]\n+  \"TARGET_64BIT\"\n+  \"*\n+   return output_div_insn (operands, 1, insn);\"\n+  [(set_attr \"type\" \"milli\")\n+   (set (attr \"length\") (const_int 4))])\n+\n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n    (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n@@ -4122,14 +4176,21 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (reg:SI 26))\n \t      (clobber (reg:SI 25))\n-\t      (clobber (reg:SI 31))])\n+\t      (clobber (match_dup 5))])\n    (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n   \"\"\n   \"\n {\n-  operands[4] = gen_reg_rtx (SImode);\n   if (TARGET_64BIT)\n-    operands[4] = gen_rtx_REG (SImode, 2);\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 2);\n+      operands[4] = operands[5];\n+    }\n+  else\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 31);\n+      operands[4] = gen_reg_rtx (SImode);\n+    }\n   operands[3] = gen_reg_rtx (SImode);\n }\")\n \n@@ -4140,7 +4201,7 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n   return output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n@@ -4166,6 +4227,19 @@\n ;; Out of reach, can use ble\n           (const_int 12)))])\n \n+(define_insn \"\"\n+  [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=&r\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 2))]\n+  \"TARGET_64BIT\"\n+  \"*\n+  return output_mod_insn (0, insn);\"\n+  [(set_attr \"type\" \"milli\")\n+   (set (attr \"length\") (const_int 4))])\n+\n (define_expand \"umodsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n    (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n@@ -4174,14 +4248,21 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (reg:SI 26))\n \t      (clobber (reg:SI 25))\n-\t      (clobber (reg:SI 31))])\n+\t      (clobber (match_dup 5))])\n    (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n   \"\"\n   \"\n {\n-  operands[4] = gen_reg_rtx (SImode);\n   if (TARGET_64BIT)\n-    operands[4] = gen_rtx_REG (SImode, 2);\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 2);\n+      operands[4] = operands[5];\n+    }\n+  else\n+    {\n+      operands[5] = gen_rtx_REG (SImode, 31);\n+      operands[4] = gen_reg_rtx (SImode);\n+    }\n   operands[3] = gen_reg_rtx (SImode);\n }\")\n \n@@ -4192,7 +4273,7 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n   return output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n@@ -4218,6 +4299,19 @@\n ;; Out of reach, can use ble\n           (const_int 12)))])\n \n+(define_insn \"\"\n+  [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=&r\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 25))\n+   (clobber (reg:SI 2))]\n+  \"TARGET_64BIT\"\n+  \"*\n+  return output_mod_insn (1, insn);\"\n+  [(set_attr \"type\" \"milli\")\n+   (set (attr \"length\") (const_int 4))])\n+\n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n ;; DImode `andn`.  Other combinations are possible."}]}