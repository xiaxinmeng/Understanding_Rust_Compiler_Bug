{"sha": "bcfe32f59d624ab90990c2c00bfef0fc85f62430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNmZTMyZjU5ZDYyNGFiOTA5OTBjMmMwMGJmZWYwZmM4NWY2MjQzMA==", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-05-21T21:38:04Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:15Z"}, "message": "This creates the initial design for the pass to compile to GIMPLE by managing blocks in the scope", "tree": {"sha": "afa2483714069bb997e00ffb4a07382cac1b3605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afa2483714069bb997e00ffb4a07382cac1b3605"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcfe32f59d624ab90990c2c00bfef0fc85f62430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcfe32f59d624ab90990c2c00bfef0fc85f62430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcfe32f59d624ab90990c2c00bfef0fc85f62430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcfe32f59d624ab90990c2c00bfef0fc85f62430/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c37f46274613f72c3724c6c95bf78af32f316bd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37f46274613f72c3724c6c95bf78af32f316bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37f46274613f72c3724c6c95bf78af32f316bd1"}], "stats": {"total": 289, "additions": 210, "deletions": 79}, "files": [{"sha": "8a9dccfea90c5ea1b7a71458e33ba3f90cf782ed", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 200, "deletions": 74, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcfe32f59d624ab90990c2c00bfef0fc85f62430/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcfe32f59d624ab90990c2c00bfef0fc85f62430/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=bcfe32f59d624ab90990c2c00bfef0fc85f62430", "patch": "@@ -4,8 +4,20 @@\n namespace Rust {\n namespace Compile {\n \n+#define VISIT_POP(L, S, R, B)                                                  \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      auto before = B.size ();                                                 \\\n+      S->accept_vis (*this);                                                   \\\n+      if (B.size () <= before)                                                 \\\n+\tbreak;                                                                 \\\n+      R = B.back ();                                                           \\\n+      B.pop_back ();                                                           \\\n+    }                                                                          \\\n+  while (0)\n+\n Compilation::Compilation (AST::Crate &crate, ::Backend *backend)\n-  : crate (crate), backend (backend)\n+  : crate (crate), backend (backend), scope (backend)\n {}\n \n Compilation::~Compilation () {}\n@@ -21,10 +33,22 @@ bool\n Compilation::go ()\n {\n   scope.Push ();\n+\n+  // builtin primitives\n+  scope.InsertType (\"i64\", backend->integer_type (false, 64));\n+  scope.InsertType (\"i32\", backend->integer_type (false, 32));\n+  scope.InsertType (\"i16\", backend->integer_type (false, 16));\n+  scope.InsertType (\"i8\", backend->integer_type (false, 8));\n+  scope.InsertType (\"u64\", backend->integer_type (true, 64));\n+  scope.InsertType (\"u32\", backend->integer_type (true, 32));\n+  scope.InsertType (\"u16\", backend->integer_type (true, 16));\n+  scope.InsertType (\"u8\", backend->integer_type (true, 8));\n+  scope.InsertType (\"f64\", backend->float_type (64));\n+  scope.InsertType (\"f32\", backend->float_type (32));\n+  scope.InsertType (\"bool\", backend->bool_type ());\n+\n   for (auto &item : crate.items)\n-    {\n-      item->accept_vis (*this);\n-    }\n+    item->accept_vis (*this);\n   scope.Pop ();\n \n   // Define all globally declared values.\n@@ -37,7 +61,8 @@ Compilation::go ()\n }\n \n bool\n-Compilation::compileVarDecl (AST::LetStmt *stmt, std::vector<Bvariable *> &vars)\n+Compilation::compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n+\t\t\t     std::vector<Bvariable *> &vars)\n {\n   AST::Type *type = stmt->has_type () ? stmt->type.get () : stmt->inferedType;\n   translatedType = NULL;\n@@ -51,15 +76,61 @@ Compilation::compileVarDecl (AST::LetStmt *stmt, std::vector<Bvariable *> &vars)\n   stmt->variables_pattern->accept_vis (*this);\n   for (auto &pattern : patternBuffer)\n     {\n-      auto var = backend->local_variable (currentFndecl, pattern.variable_ident,\n+      auto var = backend->local_variable (fndecl, pattern.variable_ident,\n \t\t\t\t\t  translatedType, NULL /*decl_var*/,\n \t\t\t\t\t  false /*address_taken*/, stmt->locus);\n       vars.push_back (var);\n+      scope.InsertVar (pattern.variable_ident, var);\n     }\n   patternBuffer.clear ();\n   return true;\n }\n \n+Bexpression *\n+Compilation::compileBooleanLiteral (std::string val)\n+{\n+  bool bval = val.compare (\"true\") == 0;\n+  return backend->boolean_constant_expression (bval);\n+}\n+\n+Bexpression *\n+Compilation::compileFloatLiteral (std::string val, Location locus)\n+{\n+  Btype *type = NULL;\n+  bool ok = scope.LookupType (\"f32\", &type);\n+  if (!ok)\n+    {\n+      rust_fatal_error (locus, \"unable to find type\");\n+      return NULL;\n+    }\n+  mpfr_t fval;\n+  if (mpfr_init_set_str (fval, val.c_str (), 10, GMP_RNDN) != 0)\n+    {\n+      rust_fatal_error (locus, \"bad number in literal\");\n+      return NULL;\n+    }\n+  return backend->float_constant_expression (type, fval);\n+}\n+\n+Bexpression *\n+Compilation::compileIntegerLiteral (std::string val, Location locus)\n+{\n+  Btype *type = NULL;\n+  bool ok = scope.LookupType (\"i32\", &type);\n+  if (!ok)\n+    {\n+      rust_fatal_error (locus, \"unable to find type\");\n+      return NULL;\n+    }\n+  mpz_t ival;\n+  if (mpz_init_set_str (ival, val.c_str (), 10) != 0)\n+    {\n+      rust_fatal_error (locus, \"bad number in literal\");\n+      return NULL;\n+    }\n+  return backend->integer_constant_expression (type, ival);\n+}\n+\n void\n Compilation::visit (AST::Token &tok)\n {}\n@@ -74,7 +145,15 @@ Compilation::visit (AST::AttrInputMetaItemContainer &input)\n \n void\n Compilation::visit (AST::IdentifierExpr &ident_expr)\n-{}\n+{\n+  Bvariable *var = NULL;\n+  if (!scope.LookupVar (ident_expr.as_string (), &var))\n+    {\n+      rust_fatal_error (ident_expr.locus, \"unknown var\");\n+      return;\n+    }\n+  exprs.push_back (backend->var_expression (var, ident_expr.locus));\n+}\n \n void\n Compilation::visit (AST::Lifetime &lifetime)\n@@ -111,52 +190,13 @@ Compilation::visit (AST::TypePath &path)\n       return;\n     }\n \n-  auto typeString = path.as_string ();\n-  if (typeString.compare (\"i64\") == 0)\n+  Btype *type = NULL;\n+  if (!scope.LookupType (path.as_string (), &type))\n     {\n-      translatedType = backend->integer_type (false, 64);\n-      return;\n-    }\n-  else if (typeString.compare (\"i32\") == 0)\n-    {\n-      translatedType = backend->integer_type (false, 32);\n-      return;\n-    }\n-  else if (typeString.compare (\"i16\") == 0)\n-    {\n-      translatedType = backend->integer_type (false, 16);\n-      return;\n-    }\n-  else if (typeString.compare (\"i8\") == 0)\n-    {\n-      translatedType = backend->integer_type (false, 8);\n-      return;\n-    }\n-  else if (typeString.compare (\"u64\") == 0)\n-    {\n-      translatedType = backend->integer_type (true, 64);\n-      return;\n-    }\n-  else if (typeString.compare (\"u32\") == 0)\n-    {\n-      translatedType = backend->integer_type (true, 32);\n-      return;\n-    }\n-  else if (typeString.compare (\"u16\") == 0)\n-    {\n-      translatedType = backend->integer_type (true, 16);\n-      return;\n-    }\n-  else if (typeString.compare (\"u8\") == 0)\n-    {\n-      translatedType = backend->integer_type (true, 8);\n-      return;\n-    }\n-  else if (typeString.compare (\"bool\") == 0)\n-    {\n-      translatedType = backend->bool_type ();\n+      rust_error_at (path.locus, \"unknown type\");\n       return;\n     }\n+  translatedType = type;\n }\n \n void\n@@ -169,7 +209,32 @@ Compilation::visit (AST::QualifiedPathInType &path)\n // rust-expr.h\n void\n Compilation::visit (AST::LiteralExpr &expr)\n-{}\n+{\n+  Bexpression *compiled;\n+  switch (expr.literal.get_lit_type ())\n+    {\n+    case AST::Literal::BOOL:\n+      compiled = compileBooleanLiteral (expr.as_string ());\n+      break;\n+\n+    case AST::Literal::FLOAT:\n+      compiled\n+\t= compileFloatLiteral (expr.as_string (), expr.get_locus_slow ());\n+      break;\n+\n+    case AST::Literal::INT:\n+      compiled\n+\t= compileIntegerLiteral (expr.as_string (), expr.get_locus_slow ());\n+      break;\n+\n+    default:\n+      rust_fatal_error (expr.get_locus_slow (), \"unknown literal\");\n+      return;\n+    }\n+\n+  exprs.push_back (compiled);\n+}\n+\n void\n Compilation::visit (AST::AttrInputLiteral &attr_input)\n {}\n@@ -191,9 +256,47 @@ Compilation::visit (AST::ErrorPropagationExpr &expr)\n void\n Compilation::visit (AST::NegationExpr &expr)\n {}\n+\n void\n Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{}\n+{\n+  printf (\"ArithmeticOrLogicalExpr %s\\n\", expr.as_string ().c_str ());\n+\n+  Bexpression *lhs = NULL;\n+  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  if (lhs == NULL)\n+    {\n+      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      return;\n+    }\n+\n+  Bexpression *rhs = NULL;\n+  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  if (rhs == NULL)\n+    {\n+      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      return;\n+    }\n+\n+  Operator op;\n+  switch (expr.expr_type)\n+    {\n+    case AST::ArithmeticOrLogicalExpr::ADD:\n+      op = OPERATOR_PLUS;\n+      break;\n+\n+      // TODO fill in the other operators\n+\n+    default:\n+      rust_error_at (expr.get_locus_slow (), \"failed to compile expression\");\n+      return;\n+    }\n+\n+  auto binExpr\n+    = backend->binary_expression (op, lhs, rhs, expr.get_locus_slow ());\n+  exprs.push_back (binExpr);\n+}\n+\n void\n Compilation::visit (AST::ComparisonExpr &expr)\n {}\n@@ -416,11 +519,6 @@ Compilation::visit (AST::UseDeclaration &use_decl)\n void\n Compilation::visit (AST::Function &function)\n {\n-  scope.Insert (function.function_name, function.return_type.get ());\n-\n-  scope.Push ();\n-  printf (\"INSIDE FUNCTION: %s\\n\", function.function_name.c_str ());\n-\n   Backend::Btyped_identifier receiver;\n   std::vector<Backend::Btyped_identifier> parameters;\n   std::vector<Backend::Btyped_identifier> results;\n@@ -445,12 +543,10 @@ Compilation::visit (AST::Function &function)\n \t}\n \n       auto numParamsPerType = patternBuffer.size () - before;\n-      for (auto i = 0; i < numParamsPerType; i++)\n+      for (size_t i = 0; i < numParamsPerType; i++)\n \t{\n \t  auto paramName = patternBuffer.back ();\n \t  patternBuffer.pop_back ();\n-\t  scope.Insert (paramName.variable_ident, param.type.get ());\n-\n \t  parameters.push_back (\n \t    Backend::Btyped_identifier (paramName.variable_ident,\n \t\t\t\t\ttranslatedType, param.locus));\n@@ -475,15 +571,20 @@ Compilation::visit (AST::Function &function)\n   Bfunction *fndecl\n     = backend->function (fntype, function.function_name, \"\" /* asm_name */,\n \t\t\t 0 /* flags */, function.locus);\n-  currentFndecl = fndecl;\n+\n+  scope.PushCurrentFunction (function.function_name, fndecl);\n+  scope.Push ();\n \n   // setup the params\n   std::vector<Bvariable *> param_vars;\n   for (auto &param : parameters)\n     {\n       bool tree_addressable = false;\n-      backend->parameter_variable (fndecl, param.name, param.btype,\n-\t\t\t\t   tree_addressable, param.location);\n+      auto p = backend->parameter_variable (fndecl, param.name, param.btype,\n+\t\t\t\t\t    tree_addressable, param.location);\n+\n+      scope.InsertVar (param.name, p);\n+      param_vars.push_back (p);\n     }\n \n   if (!backend->function_set_parameters (fndecl, param_vars))\n@@ -495,12 +596,11 @@ Compilation::visit (AST::Function &function)\n   std::vector<Bvariable *> vars;\n   for (auto &decl : function.locals)\n     {\n-      if (!compileVarDecl (decl, vars))\n+      if (!compileVarDecl (fndecl, decl, vars))\n \t{\n \t  rust_error_at (decl->locus, \"failed to compile var decl\");\n \t  return;\n \t}\n-      // TODO add to scope\n     }\n \n   // is null for top level functions - nested functions will have an enclosing\n@@ -516,21 +616,22 @@ Compilation::visit (AST::Function &function)\n \n   auto code_block = backend->block (fndecl, enclosingScope, vars,\n \t\t\t\t    start_location, end_location);\n-  auto body = backend->block_statement (code_block);\n+  scope.PushBlock (code_block);\n+\n+  for (auto &stmt : function.function_body->statements)\n+    stmt->accept_vis (*this);\n+\n+  scope.PopBlock ();\n \n+  auto body = backend->block_statement (code_block);\n   if (!backend->function_set_body (fndecl, body))\n     {\n       rust_error_at (function.locus, \"failed to set body to function\");\n       return;\n     }\n \n-  for (auto &stmt : function.function_body->statements)\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-\n-  func_decls.push_back (fndecl);\n   scope.Pop ();\n+  scope.PopCurrentFunction ();\n }\n \n void\n@@ -643,7 +744,6 @@ Compilation::visit (AST::LiteralPattern &pattern)\n void\n Compilation::visit (AST::IdentifierPattern &pattern)\n {\n-  printf (\"IdentifierPattern: %s\\n\", pattern.as_string ().c_str ());\n   patternBuffer.push_back (pattern);\n }\n \n@@ -714,7 +814,33 @@ void\n \n Compilation::visit (AST::LetStmt &stmt)\n {\n-  printf (\"Within LetStmt: %s\\n\", stmt.as_string ().c_str ());\n+  if (!stmt.has_init_expr ())\n+    return;\n+\n+  Bexpression *init = NULL;\n+  VISIT_POP (stmt.init_expr->get_locus_slow (), stmt.init_expr, init, exprs);\n+  if (init == NULL)\n+    {\n+      rust_error_at (stmt.init_expr->get_locus_slow (),\n+\t\t     \"failed to compile init statement\");\n+      return;\n+    }\n+\n+  stmt.variables_pattern->accept_vis (*this);\n+  for (auto &pattern : patternBuffer)\n+    {\n+      Bvariable *var = NULL;\n+      if (!scope.LookupVar (pattern.variable_ident, &var))\n+\t{\n+\t  rust_error_at (stmt.locus, \"failed to find var decl for %s\",\n+\t\t\t pattern.variable_ident.c_str ());\n+\t  return;\n+\t}\n+\n+      auto s = backend->init_statement (scope.GetCurrentFndecl (), var, init);\n+      scope.AddStatement (s);\n+    }\n+  patternBuffer.clear ();\n }\n \n void"}, {"sha": "045afbf3edd1f3e20bea06e7f30c9ae0beccf808", "filename": "gcc/rust/backend/rust-compile.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcfe32f59d624ab90990c2c00bfef0fc85f62430/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcfe32f59d624ab90990c2c00bfef0fc85f62430/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=bcfe32f59d624ab90990c2c00bfef0fc85f62430", "patch": "@@ -4,7 +4,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-ast-visitor.h\"\n #include \"rust-backend.h\"\n-#include \"scope.h\"\n+#include \"cscope.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -229,13 +229,18 @@ class Compilation : public AST::ASTVisitor\n   Backend *backend;\n \n   // utils\n-  bool compileVarDecl (AST::LetStmt *stmt, std::vector<Bvariable *> &vars);\n+  bool compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n+\t\t       std::vector<Bvariable *> &vars);\n+\n+  Bexpression *compileBooleanLiteral (std::string val);\n+  Bexpression *compileFloatLiteral (std::string val, Location locus);\n+  Bexpression *compileIntegerLiteral (std::string val, Location locus);\n \n   // state\n-  Analysis::Scope<AST::Type *> scope;\n-  std::vector<AST::IdentifierPattern> patternBuffer;\n-  ::Bfunction *currentFndecl;\n+  Scope scope;\n   ::Btype *translatedType;\n+  std::vector<AST::IdentifierPattern> patternBuffer;\n+  std::vector< ::Bexpression *> exprs;\n \n   // careful these are the vectors we pass into the GCC middle-end\n   std::vector< ::Btype *> type_decls;"}]}