{"sha": "25c99850471c3e5d906712711faeeb3e35c03d7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVjOTk4NTA0NzFjM2U1ZDkwNjcxMjcxMWZhZWViM2UzNWMwM2Q3ZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-02-15T17:16:29Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-02-15T17:16:29Z"}, "message": "re PR tree-optimization/79347 (vect_do_peeling is messing up profile)\n\n\tPR tree-optimization/79347\n\t* tree-vect-loop-manip.c (vect_do_peeling): Maintain profile\n\tcounters during peeling.\n\n\tgcc/testsuite\n\t* gcc.dg/vect/pr79347.c: New test.\n\nFrom-SVN: r245490", "tree": {"sha": "5fcea889566fedf142ce3dd62039ae6b951bb52f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fcea889566fedf142ce3dd62039ae6b951bb52f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25c99850471c3e5d906712711faeeb3e35c03d7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c99850471c3e5d906712711faeeb3e35c03d7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c99850471c3e5d906712711faeeb3e35c03d7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c99850471c3e5d906712711faeeb3e35c03d7d/comments", "author": null, "committer": null, "parents": [{"sha": "e72028574f776fd5b73de8b974e4ea2d085f1532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72028574f776fd5b73de8b974e4ea2d085f1532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72028574f776fd5b73de8b974e4ea2d085f1532"}], "stats": {"total": 63, "additions": 61, "deletions": 2}, "files": [{"sha": "b3f479646edafb80415d129471ffae100e07f2e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25c99850471c3e5d906712711faeeb3e35c03d7d", "patch": "@@ -1,3 +1,9 @@\n+2017-02-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/79347\n+\t* tree-vect-loop-manip.c (vect_do_peeling): Maintain profile\n+\tcounters during peeling.\n+\n 2017-02-15  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* Makefile.in (site.exp): Remove \"set ISLVER\"."}, {"sha": "42ec70d0d3e64aaf3087c5a09193a6dddb9add2d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25c99850471c3e5d906712711faeeb3e35c03d7d", "patch": "@@ -1,3 +1,8 @@\n+2017-02-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/79347\n+\t* gcc.dg/vect/pr79347.c: New test.\n+\n 2017-02-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/79301"}, {"sha": "586c638c6fa43dd52eaa878179a8cb921372bcb1", "filename": "gcc/testsuite/gcc.dg/vect/pr79347.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79347.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79347.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79347.c?ref=25c99850471c3e5d906712711faeeb3e35c03d7d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-fdump-tree-vect-all\" } */\n+\n+short *a;\n+int c;\n+void n(void)\n+{\n+  for (int i = 0; i<c;i++)\n+    a[i]++;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of \" 2 \"vect\" } } */"}, {"sha": "5ee2c38e0484406c8afacc06a2d657f0b1a46f93", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c99850471c3e5d906712711faeeb3e35c03d7d/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=25c99850471c3e5d906712711faeeb3e35c03d7d", "patch": "@@ -1690,7 +1690,19 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n      may be preferred.  */\n   basic_block anchor = loop_preheader_edge (loop)->src;\n   if (skip_vector)\n-    split_edge (loop_preheader_edge (loop));\n+    {\n+      split_edge (loop_preheader_edge (loop));\n+\n+      /* Due to the order in which we peel prolog and epilog, we first\n+\t propagate probability to the whole loop.  The purpose is to\n+\t avoid adjusting probabilities of both prolog and vector loops\n+\t separately.  Note in this case, the probability of epilog loop\n+\t needs to be scaled back later.  */\n+      basic_block bb_before_loop = loop_preheader_edge (loop)->src;\n+      scale_bbs_frequencies_int (&bb_before_loop, 1, prob_vector,\n+\t\t\t\t REG_BR_PROB_BASE);\n+      scale_loop_profile (loop, prob_vector, bound);\n+    }\n \n   tree niters_prolog = build_int_cst (type, 0);\n   source_location loop_loc = find_loop_location (loop);\n@@ -1727,13 +1739,17 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  guard_cond = fold_build2 (EQ_EXPR, boolean_type_node,\n \t\t\t\t    niters_prolog, build_int_cst (type, 0));\n \t  guard_bb = loop_preheader_edge (prolog)->src;\n+\t  basic_block bb_after_prolog = loop_preheader_edge (loop)->src;\n \t  guard_to = split_edge (loop_preheader_edge (loop));\n \t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond,\n \t\t\t\t\t   guard_to, guard_bb,\n \t\t\t\t\t   inverse_probability (prob_prolog));\n \t  e = EDGE_PRED (guard_to, 0);\n \t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n \t  slpeel_update_phi_nodes_for_guard1 (prolog, loop, guard_e, e);\n+\n+\t  scale_bbs_frequencies_int (&bb_after_prolog, 1, prob_prolog,\n+\t\t\t\t     REG_BR_PROB_BASE);\n \t  scale_loop_profile (prolog, prob_prolog, bound_prolog);\n \t}\n       /* Update init address of DRs.  */\n@@ -1796,9 +1812,18 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  e = EDGE_PRED (guard_to, 0);\n \t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n \t  slpeel_update_phi_nodes_for_guard1 (first_loop, epilog, guard_e, e);\n-\t  scale_loop_profile (epilog, prob_vector, bound_scalar);\n+\n+\t  /* Simply propagate profile info from guard_bb to guard_to which is\n+\t     a merge point of control flow.  */\n+\t  guard_to->frequency = guard_bb->frequency;\n+\t  guard_to->count = guard_bb->count;\n+\t  single_succ_edge (guard_to)->count = guard_to->count;\n+\t  /* Scale probability of epilog loop back.  */\n+\t  int scale_up = REG_BR_PROB_BASE * REG_BR_PROB_BASE / prob_vector;\n+\t  scale_loop_frequencies (epilog, scale_up, REG_BR_PROB_BASE);\n \t}\n \n+      basic_block bb_before_epilog = loop_preheader_edge (epilog)->src;\n       tree niters_vector_mult_vf;\n       /* If loop is peeled for non-zero constant times, now niters refers to\n \t orig_niters - prolog_peeling, it won't overflow even the orig_niters\n@@ -1826,6 +1851,16 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t\t\t\t   inverse_probability (prob_epilog));\n \t  slpeel_update_phi_nodes_for_guard2 (loop, epilog, guard_e,\n \t\t\t\t\t      single_exit (epilog));\n+\t  /* Only need to handle basic block before epilog loop if it's not\n+\t     the guard_bb, which is the case when skip_vector is true.  */\n+\t  if (guard_bb != bb_before_epilog)\n+\t    {\n+\t      prob_epilog = (combine_probabilities (prob_vector, prob_epilog)\n+\t\t\t     + inverse_probability (prob_vector));\n+\n+\t      scale_bbs_frequencies_int (&bb_before_epilog, 1, prob_epilog,\n+\t\t\t\t\t REG_BR_PROB_BASE);\n+\t    }\n \t  scale_loop_profile (epilog, prob_epilog, bound);\n \t}\n       else"}]}