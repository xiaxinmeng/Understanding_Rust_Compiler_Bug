{"sha": "cfe527436c536ff0035a5633a8cab05778c4a4d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlNTI3NDM2YzUzNmZmMDAzNWE1NjMzYThjYWIwNTc3OGM0YTRkNA==", "commit": {"author": {"name": "David Alan Gilbert", "email": "david.gilbert@linaro.org", "date": "2011-10-14T14:38:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-10-14T14:38:58Z"}, "message": "arm.c (arm_output_ldrex): Support ldrexd.\n\ngcc/\n2011-10-14  David Alan Gilbert  <david.gilbert@linaro.org>\n\n\t* config/arm/arm.c (arm_output_ldrex): Support ldrexd.\n\t(arm_output_strex): Support strexd.\n\t(arm_output_it): New helper to output it in Thumb2 mode only.\n\t(arm_output_sync_loop): Support DI mode.  Change comment to\n\tnot support const_int.\n\t(arm_expand_sync): Support DI mode.\n\t* config/arm/arm.h (TARGET_HAVE_LDREXBHD): Split into LDREXBH\n\tand LDREXD.\n\t* config/arm/iterators.md (NARROW): move from sync.md.\n\t(QHSD): New iterator for all current ARM integer modes.\n\t(SIDI): New iterator for SI and DI modes only.\n\t* config/arm/sync.md (sync_predtab): New mode_attr.\n\t(sync_compare_and_swapsi): Fold into sync_compare_and_swap<mode>.\n\t(sync_lock_test_and_setsi): Fold into sync_lock_test_and_setsi<mode>.\n\t(sync_<sync_optab>si): Fold into sync_<sync_optab><mode>.\n\t(sync_nandsi): Fold into sync_nand<mode>.\n\t(sync_new_<sync_optab>si): Fold into sync_new_<sync_optab><mode>.\n\t(sync_new_nandsi): Fold into sync_new_nand<mode>.\n\t(sync_old_<sync_optab>si): Fold into sync_old_<sync_optab><mode>.\n\t(sync_old_nandsi): Fold into sync_old_nand<mode>.\n\t(sync_compare_and_swap<mode>): Support SI & DI.\n\t(sync_lock_test_and_set<mode>): Likewise.\n\t(sync_<sync_optab><mode>): Likewise.\n\t(sync_nand<mode>): Likewise.\n\t(sync_new_<sync_optab><mode>): Likewise.\n\t(sync_new_nand<mode>): Likewise.\n\t(sync_old_<sync_optab><mode>): Likewise.\n\t(sync_old_nand<mode>): Likewise.\n\t(arm_sync_compare_and_swapsi): Turn into iterator on SI & DI.\n\t(arm_sync_lock_test_and_setsi): Likewise.\n\t(arm_sync_new_<sync_optab>si): Likewise.\n\t(arm_sync_new_nandsi): Likewise.\n\t(arm_sync_old_<sync_optab>si): Likewise.\n\t(arm_sync_old_nandsi): Likewise.\n\t(arm_sync_compare_and_swap<mode> NARROW): use sync_predtab, fix indent.\n\t(arm_sync_lock_test_and_setsi<mode> NARROW): Likewise.\n\t(arm_sync_new_<sync_optab><mode> NARROW): Likewise.\n\t(arm_sync_new_nand<mode> NARROW): Likewise.\n\t(arm_sync_old_<sync_optab><mode> NARROW): Likewise.\n\t(arm_sync_old_nand<mode> NARROW): Likewise.\n\nFrom-SVN: r179981", "tree": {"sha": "adbc04b256497bcf813eba5879fbee6b2f56343e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adbc04b256497bcf813eba5879fbee6b2f56343e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfe527436c536ff0035a5633a8cab05778c4a4d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe527436c536ff0035a5633a8cab05778c4a4d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfe527436c536ff0035a5633a8cab05778c4a4d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe527436c536ff0035a5633a8cab05778c4a4d4/comments", "author": null, "committer": null, "parents": [{"sha": "3e2a46fe397751855594e35cc6ef15b41794e0d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e2a46fe397751855594e35cc6ef15b41794e0d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e2a46fe397751855594e35cc6ef15b41794e0d9"}], "stats": {"total": 657, "additions": 357, "deletions": 300}, "files": [{"sha": "67a220b969862c553fcee9278df93b2f743b8b2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfe527436c536ff0035a5633a8cab05778c4a4d4", "patch": "@@ -1,3 +1,46 @@\n+2011-10-14  David Alan Gilbert  <david.gilbert@linaro.org>\n+\n+\t* config/arm/arm.c (arm_output_ldrex): Support ldrexd.\n+\t(arm_output_strex): Support strexd.\n+\t(arm_output_it): New helper to output it in Thumb2 mode only.\n+\t(arm_output_sync_loop): Support DI mode.  Change comment to\n+\tnot support const_int.\n+\t(arm_expand_sync): Support DI mode.\n+\t* config/arm/arm.h (TARGET_HAVE_LDREXBHD): Split into LDREXBH\n+\tand LDREXD.\n+\t* config/arm/iterators.md (NARROW): move from sync.md.\n+\t(QHSD): New iterator for all current ARM integer modes.\n+\t(SIDI): New iterator for SI and DI modes only.\n+\t* config/arm/sync.md (sync_predtab): New mode_attr.\n+\t(sync_compare_and_swapsi): Fold into sync_compare_and_swap<mode>.\n+\t(sync_lock_test_and_setsi): Fold into sync_lock_test_and_setsi<mode>.\n+\t(sync_<sync_optab>si): Fold into sync_<sync_optab><mode>.\n+\t(sync_nandsi): Fold into sync_nand<mode>.\n+\t(sync_new_<sync_optab>si): Fold into sync_new_<sync_optab><mode>.\n+\t(sync_new_nandsi): Fold into sync_new_nand<mode>.\n+\t(sync_old_<sync_optab>si): Fold into sync_old_<sync_optab><mode>.\n+\t(sync_old_nandsi): Fold into sync_old_nand<mode>.\n+\t(sync_compare_and_swap<mode>): Support SI & DI.\n+\t(sync_lock_test_and_set<mode>): Likewise.\n+\t(sync_<sync_optab><mode>): Likewise.\n+\t(sync_nand<mode>): Likewise.\n+\t(sync_new_<sync_optab><mode>): Likewise.\n+\t(sync_new_nand<mode>): Likewise.\n+\t(sync_old_<sync_optab><mode>): Likewise.\n+\t(sync_old_nand<mode>): Likewise.\n+\t(arm_sync_compare_and_swapsi): Turn into iterator on SI & DI.\n+\t(arm_sync_lock_test_and_setsi): Likewise.\n+\t(arm_sync_new_<sync_optab>si): Likewise.\n+\t(arm_sync_new_nandsi): Likewise.\n+\t(arm_sync_old_<sync_optab>si): Likewise.\n+\t(arm_sync_old_nandsi): Likewise.\n+\t(arm_sync_compare_and_swap<mode> NARROW): use sync_predtab, fix indent.\n+\t(arm_sync_lock_test_and_setsi<mode> NARROW): Likewise.\n+\t(arm_sync_new_<sync_optab><mode> NARROW): Likewise.\n+\t(arm_sync_new_nand<mode> NARROW): Likewise.\n+\t(arm_sync_old_<sync_optab><mode> NARROW): Likewise.\n+\t(arm_sync_old_nand<mode> NARROW): Likewise.\n+\n 2011-10-14  David Alan Gilbert  <david.gilbert@linaro.org>\n \n \tPR target/48126"}, {"sha": "a429c192fdbdcb540e1550431674b2b71a1e5710", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 140, "deletions": 33, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=cfe527436c536ff0035a5633a8cab05778c4a4d4", "patch": "@@ -24042,12 +24042,26 @@ arm_output_ldrex (emit_f emit,\n \t\t  rtx target,\n \t\t  rtx memory)\n {\n-  const char *suffix = arm_ldrex_suffix (mode);\n-  rtx operands[2];\n+  rtx operands[3];\n \n   operands[0] = target;\n-  operands[1] = memory;\n-  arm_output_asm_insn (emit, 0, operands, \"ldrex%s\\t%%0, %%C1\", suffix);\n+  if (mode != DImode)\n+    {\n+      const char *suffix = arm_ldrex_suffix (mode);\n+      operands[1] = memory;\n+      arm_output_asm_insn (emit, 0, operands, \"ldrex%s\\t%%0, %%C1\", suffix);\n+    }\n+  else\n+    {\n+      /* The restrictions on target registers in ARM mode are that the two\n+\t registers are consecutive and the first one is even; Thumb is\n+\t actually more flexible, but DI should give us this anyway.\n+\t Note that the 1st register always gets the lowest word in memory.  */\n+      gcc_assert ((REGNO (target) & 1) == 0);\n+      operands[1] = gen_rtx_REG (SImode, REGNO (target) + 1);\n+      operands[2] = memory;\n+      arm_output_asm_insn (emit, 0, operands, \"ldrexd\\t%%0, %%1, %%C2\");\n+    }\n }\n \n /* Emit a strex{b,h,d, } instruction appropriate for the specified\n@@ -24060,14 +24074,41 @@ arm_output_strex (emit_f emit,\n \t\t  rtx value,\n \t\t  rtx memory)\n {\n-  const char *suffix = arm_ldrex_suffix (mode);\n-  rtx operands[3];\n+  rtx operands[4];\n \n   operands[0] = result;\n   operands[1] = value;\n-  operands[2] = memory;\n-  arm_output_asm_insn (emit, 0, operands, \"strex%s%s\\t%%0, %%1, %%C2\", suffix,\n-\t\t       cc);\n+  if (mode != DImode)\n+    {\n+      const char *suffix = arm_ldrex_suffix (mode);\n+      operands[2] = memory;\n+      arm_output_asm_insn (emit, 0, operands, \"strex%s%s\\t%%0, %%1, %%C2\",\n+\t\t\t  suffix, cc);\n+    }\n+  else\n+    {\n+      /* The restrictions on target registers in ARM mode are that the two\n+\t registers are consecutive and the first one is even; Thumb is\n+\t actually more flexible, but DI should give us this anyway.\n+\t Note that the 1st register always gets the lowest word in memory.  */\n+      gcc_assert ((REGNO (value) & 1) == 0 || TARGET_THUMB2);\n+      operands[2] = gen_rtx_REG (SImode, REGNO (value) + 1);\n+      operands[3] = memory;\n+      arm_output_asm_insn (emit, 0, operands, \"strexd%s\\t%%0, %%1, %%2, %%C3\",\n+\t\t\t   cc);\n+    }\n+}\n+\n+/* Helper to emit an it instruction in Thumb2 mode only; although the assembler\n+   will ignore it in ARM mode, emitting it will mess up instruction counts we\n+   sometimes keep 'flags' are the extra t's and e's if it's more than one\n+   instruction that is conditional.  */\n+static void\n+arm_output_it (emit_f emit, const char *flags, const char *cond)\n+{\n+  rtx operands[1]; /* Don't actually use the operand.  */\n+  if (TARGET_THUMB2)\n+    arm_output_asm_insn (emit, 0, operands, \"it%s\\t%s\", flags, cond);\n }\n \n /* Helper to emit a two operand instruction.  */\n@@ -24109,7 +24150,7 @@ arm_output_op3 (emit_f emit, const char *mnemonic, rtx d, rtx a, rtx b)\n \n    required_value:\n \n-   RTX register or const_int representing the required old_value for\n+   RTX register representing the required old_value for\n    the modify to continue, if NULL no comparsion is performed.  */\n static void\n arm_output_sync_loop (emit_f emit,\n@@ -24123,7 +24164,13 @@ arm_output_sync_loop (emit_f emit,\n \t\t      enum attr_sync_op sync_op,\n \t\t      int early_barrier_required)\n {\n-  rtx operands[1];\n+  rtx operands[2];\n+  /* We'll use the lo for the normal rtx in the none-DI case\n+     as well as the least-sig word in the DI case.  */\n+  rtx old_value_lo, required_value_lo, new_value_lo, t1_lo;\n+  rtx old_value_hi, required_value_hi, new_value_hi, t1_hi;\n+\n+  bool is_di = mode == DImode;\n \n   gcc_assert (t1 != t2);\n \n@@ -24134,82 +24181,142 @@ arm_output_sync_loop (emit_f emit,\n \n   arm_output_ldrex (emit, mode, old_value, memory);\n \n+  if (is_di)\n+    {\n+      old_value_lo = gen_lowpart (SImode, old_value);\n+      old_value_hi = gen_highpart (SImode, old_value);\n+      if (required_value)\n+\t{\n+\t  required_value_lo = gen_lowpart (SImode, required_value);\n+\t  required_value_hi = gen_highpart (SImode, required_value);\n+\t}\n+      else\n+\t{\n+\t  /* Silence false potentially unused warning.  */\n+\t  required_value_lo = NULL_RTX;\n+\t  required_value_hi = NULL_RTX;\n+\t}\n+      new_value_lo = gen_lowpart (SImode, new_value);\n+      new_value_hi = gen_highpart (SImode, new_value);\n+      t1_lo = gen_lowpart (SImode, t1);\n+      t1_hi = gen_highpart (SImode, t1);\n+    }\n+  else\n+    {\n+      old_value_lo = old_value;\n+      new_value_lo = new_value;\n+      required_value_lo = required_value;\n+      t1_lo = t1;\n+\n+      /* Silence false potentially unused warning.  */\n+      t1_hi = NULL_RTX;\n+      new_value_hi = NULL_RTX;\n+      required_value_hi = NULL_RTX;\n+      old_value_hi = NULL_RTX;\n+    }\n+\n   if (required_value)\n     {\n-      rtx operands[2];\n+      operands[0] = old_value_lo;\n+      operands[1] = required_value_lo;\n \n-      operands[0] = old_value;\n-      operands[1] = required_value;\n       arm_output_asm_insn (emit, 0, operands, \"cmp\\t%%0, %%1\");\n+      if (is_di)\n+        {\n+          arm_output_it (emit, \"\", \"eq\");\n+          arm_output_op2 (emit, \"cmpeq\", old_value_hi, required_value_hi);\n+        }\n       arm_output_asm_insn (emit, 0, operands, \"bne\\t%sLSYB%%=\", LOCAL_LABEL_PREFIX);\n     }\n \n   switch (sync_op)\n     {\n     case SYNC_OP_ADD:\n-      arm_output_op3 (emit, \"add\", t1, old_value, new_value);\n+      arm_output_op3 (emit, is_di ? \"adds\" : \"add\",\n+\t\t      t1_lo, old_value_lo, new_value_lo);\n+      if (is_di)\n+\tarm_output_op3 (emit, \"adc\", t1_hi, old_value_hi, new_value_hi);\n       break;\n \n     case SYNC_OP_SUB:\n-      arm_output_op3 (emit, \"sub\", t1, old_value, new_value);\n+      arm_output_op3 (emit, is_di ? \"subs\" : \"sub\",\n+\t\t      t1_lo, old_value_lo, new_value_lo);\n+      if (is_di)\n+\tarm_output_op3 (emit, \"sbc\", t1_hi, old_value_hi, new_value_hi);\n       break;\n \n     case SYNC_OP_IOR:\n-      arm_output_op3 (emit, \"orr\", t1, old_value, new_value);\n+      arm_output_op3 (emit, \"orr\", t1_lo, old_value_lo, new_value_lo);\n+      if (is_di)\n+\tarm_output_op3 (emit, \"orr\", t1_hi, old_value_hi, new_value_hi);\n       break;\n \n     case SYNC_OP_XOR:\n-      arm_output_op3 (emit, \"eor\", t1, old_value, new_value);\n+      arm_output_op3 (emit, \"eor\", t1_lo, old_value_lo, new_value_lo);\n+      if (is_di)\n+\tarm_output_op3 (emit, \"eor\", t1_hi, old_value_hi, new_value_hi);\n       break;\n \n     case SYNC_OP_AND:\n-      arm_output_op3 (emit,\"and\", t1, old_value, new_value);\n+      arm_output_op3 (emit,\"and\", t1_lo, old_value_lo, new_value_lo);\n+      if (is_di)\n+\tarm_output_op3 (emit, \"and\", t1_hi, old_value_hi, new_value_hi);\n       break;\n \n     case SYNC_OP_NAND:\n-      arm_output_op3 (emit, \"and\", t1, old_value, new_value);\n-      arm_output_op2 (emit, \"mvn\", t1, t1);\n+      arm_output_op3 (emit, \"and\", t1_lo, old_value_lo, new_value_lo);\n+      if (is_di)\n+\tarm_output_op3 (emit, \"and\", t1_hi, old_value_hi, new_value_hi);\n+      arm_output_op2 (emit, \"mvn\", t1_lo, t1_lo);\n+      if (is_di)\n+\tarm_output_op2 (emit, \"mvn\", t1_hi, t1_hi);\n       break;\n \n     case SYNC_OP_NONE:\n       t1 = new_value;\n+      t1_lo = new_value_lo;\n+      if (is_di)\n+\tt1_hi = new_value_hi;\n       break;\n     }\n \n+  /* Note that the result of strex is a 0/1 flag that's always 1 register.  */\n   if (t2)\n     {\n-       arm_output_strex (emit, mode, \"\", t2, t1, memory);\n-       operands[0] = t2;\n-       arm_output_asm_insn (emit, 0, operands, \"teq\\t%%0, #0\");\n-       arm_output_asm_insn (emit, 0, operands, \"bne\\t%sLSYT%%=\",\n-\t\t\t    LOCAL_LABEL_PREFIX);\n+      arm_output_strex (emit, mode, \"\", t2, t1, memory);\n+      operands[0] = t2;\n+      arm_output_asm_insn (emit, 0, operands, \"teq\\t%%0, #0\");\n+      arm_output_asm_insn (emit, 0, operands, \"bne\\t%sLSYT%%=\",\n+\t\t\t   LOCAL_LABEL_PREFIX);\n     }\n   else\n     {\n       /* Use old_value for the return value because for some operations\n \t the old_value can easily be restored.  This saves one register.  */\n-      arm_output_strex (emit, mode, \"\", old_value, t1, memory);\n-      operands[0] = old_value;\n+      arm_output_strex (emit, mode, \"\", old_value_lo, t1, memory);\n+      operands[0] = old_value_lo;\n       arm_output_asm_insn (emit, 0, operands, \"teq\\t%%0, #0\");\n       arm_output_asm_insn (emit, 0, operands, \"bne\\t%sLSYT%%=\",\n \t\t\t   LOCAL_LABEL_PREFIX);\n \n+      /* Note that we only used the _lo half of old_value as a temporary\n+\t so in DI we don't have to restore the _hi part.  */\n       switch (sync_op)\n \t{\n \tcase SYNC_OP_ADD:\n-\t  arm_output_op3 (emit, \"sub\", old_value, t1, new_value);\n+\t  arm_output_op3 (emit, \"sub\", old_value_lo, t1_lo, new_value_lo);\n \t  break;\n \n \tcase SYNC_OP_SUB:\n-\t  arm_output_op3 (emit, \"add\", old_value, t1, new_value);\n+\t  arm_output_op3 (emit, \"add\", old_value_lo, t1_lo, new_value_lo);\n \t  break;\n \n \tcase SYNC_OP_XOR:\n-\t  arm_output_op3 (emit, \"eor\", old_value, t1, new_value);\n+\t  arm_output_op3 (emit, \"eor\", old_value_lo, t1_lo, new_value_lo);\n \t  break;\n \n \tcase SYNC_OP_NONE:\n-\t  arm_output_op2 (emit, \"mov\", old_value, required_value);\n+\t  arm_output_op2 (emit, \"mov\", old_value_lo, required_value_lo);\n \t  break;\n \n \tdefault:\n@@ -24315,7 +24422,7 @@ arm_expand_sync (enum machine_mode mode,\n     target = gen_reg_rtx (mode);\n \n   memory = arm_legitimize_sync_memory (memory);\n-  if (mode != SImode)\n+  if (mode != SImode && mode != DImode)\n     {\n       rtx load_temp = gen_reg_rtx (SImode);\n "}, {"sha": "271b44126c3f0f1965a2656f4fe041db2a8c0ee3", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=cfe527436c536ff0035a5633a8cab05778c4a4d4", "patch": "@@ -297,8 +297,12 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n /* Nonzero if this chip supports ldrex and strex */\n #define TARGET_HAVE_LDREX\t((arm_arch6 && TARGET_ARM) || arm_arch7)\n \n-/* Nonzero if this chip supports ldrex{bhd} and strex{bhd}.  */\n-#define TARGET_HAVE_LDREXBHD\t((arm_arch6k && TARGET_ARM) || arm_arch7)\n+/* Nonzero if this chip supports ldrex{bh} and strex{bh}.  */\n+#define TARGET_HAVE_LDREXBH\t((arm_arch6k && TARGET_ARM) || arm_arch7)\n+\n+/* Nonzero if this chip supports ldrexd and strexd.  */\n+#define TARGET_HAVE_LDREXD\t(((arm_arch6k && TARGET_ARM) || arm_arch7) \\\n+\t\t\t\t && arm_arch_notm)\n \n /* Nonzero if integer division instructions supported.  */\n #define TARGET_IDIV\t\t((TARGET_ARM && arm_arch_arm_hwdiv) \\"}, {"sha": "85dd641d5971177d623e6bdd98364cf54a536916", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=cfe527436c536ff0035a5633a8cab05778c4a4d4", "patch": "@@ -33,6 +33,15 @@\n ;; A list of integer modes that are up to one word long\n (define_mode_iterator QHSI [QI HI SI])\n \n+;; A list of integer modes that are less than a word\n+(define_mode_iterator NARROW [QI HI])\n+\n+;; A list of all the integer modes upto 64bit\n+(define_mode_iterator QHSD [QI HI SI DI])\n+\n+;; A list of the 32bit and 64bit integer modes\n+(define_mode_iterator SIDI [SI DI])\n+\n ;; Integer element sizes implemented by IWMMXT.\n (define_mode_iterator VMMX [V2SI V4HI V8QI])\n "}, {"sha": "40ee93c35d1c3f29468c576cd752743c8bebcab7", "filename": "gcc/config/arm/sync.md", "status": "modified", "additions": 159, "deletions": 265, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe527436c536ff0035a5633a8cab05778c4a4d4/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=cfe527436c536ff0035a5633a8cab05778c4a4d4", "patch": "@@ -1,6 +1,7 @@\n ;; Machine description for ARM processor synchronization primitives.\n ;; Copyright (C) 2010 Free Software Foundation, Inc.\n ;; Written by Marcus Shawcroft (marcus.shawcroft@arm.com)\n+;; 64bit Atomics by Dave Gilbert (david.gilbert@linaro.org)\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -33,31 +34,24 @@\n   MEM_VOLATILE_P (operands[0]) = 1;\n })\n \n-(define_expand \"sync_compare_and_swapsi\"\n-  [(set (match_operand:SI 0 \"s_register_operand\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"memory_operand\")\n-\t\t\t     (match_operand:SI 2 \"s_register_operand\")\n-\t\t\t     (match_operand:SI 3 \"s_register_operand\")]\n-\t\t\t     VUNSPEC_SYNC_COMPARE_AND_SWAP))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omrn;\n-    generator.u.omrn = gen_arm_sync_compare_and_swapsi;\n-    arm_expand_sync (SImode, &generator, operands[0], operands[1], operands[2],\n-                     operands[3]);\n-    DONE;\n-  })\n \n-(define_mode_iterator NARROW [QI HI])\n+(define_mode_attr sync_predtab [(SI \"TARGET_HAVE_LDREX &&\n+\t\t\t\t\tTARGET_HAVE_MEMORY_BARRIER\")\n+\t\t\t\t(QI \"TARGET_HAVE_LDREXBH &&\n+\t\t\t\t\tTARGET_HAVE_MEMORY_BARRIER\")\n+\t\t\t\t(HI \"TARGET_HAVE_LDREXBH &&\n+\t\t\t\t\tTARGET_HAVE_MEMORY_BARRIER\")\n+\t\t\t\t(DI \"TARGET_HAVE_LDREXD &&\n+\t\t\t\t\tARM_DOUBLEWORD_ALIGN &&\n+\t\t\t\t\tTARGET_HAVE_MEMORY_BARRIER\")])\n \n (define_expand \"sync_compare_and_swap<mode>\"\n-  [(set (match_operand:NARROW 0 \"s_register_operand\")\n-        (unspec_volatile:NARROW [(match_operand:NARROW 1 \"memory_operand\")\n-\t\t\t     (match_operand:NARROW 2 \"s_register_operand\")\n-\t\t\t     (match_operand:NARROW 3 \"s_register_operand\")]\n+  [(set (match_operand:QHSD 0 \"s_register_operand\")\n+        (unspec_volatile:QHSD [(match_operand:QHSD 1 \"memory_operand\")\n+\t\t\t     (match_operand:QHSD 2 \"s_register_operand\")\n+\t\t\t     (match_operand:QHSD 3 \"s_register_operand\")]\n \t\t\t     VUNSPEC_SYNC_COMPARE_AND_SWAP))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omrn;\n@@ -67,25 +61,11 @@\n     DONE;\n   })\n \n-(define_expand \"sync_lock_test_and_setsi\"\n-  [(match_operand:SI 0 \"s_register_operand\")\n-   (match_operand:SI 1 \"memory_operand\")\n-   (match_operand:SI 2 \"s_register_operand\")]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omn;\n-    generator.u.omn = gen_arm_sync_lock_test_and_setsi;\n-    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n-                     operands[2]);\n-    DONE;\n-  })\n-\n (define_expand \"sync_lock_test_and_set<mode>\"\n-  [(match_operand:NARROW 0 \"s_register_operand\")\n-   (match_operand:NARROW 1 \"memory_operand\")\n-   (match_operand:NARROW 2 \"s_register_operand\")]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  [(match_operand:QHSD 0 \"s_register_operand\")\n+   (match_operand:QHSD 1 \"memory_operand\")\n+   (match_operand:QHSD 2 \"s_register_operand\")]\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omn;\n@@ -115,51 +95,25 @@\n \t\t\t\t(plus \"*\")\n \t\t\t\t(minus \"*\")])\n \n-(define_expand \"sync_<sync_optab>si\"\n-  [(match_operand:SI 0 \"memory_operand\")\n-   (match_operand:SI 1 \"s_register_operand\")\n-   (syncop:SI (match_dup 0) (match_dup 1))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omn;\n-    generator.u.omn = gen_arm_sync_new_<sync_optab>si;\n-    arm_expand_sync (SImode, &generator, NULL, operands[0], NULL, operands[1]);\n-    DONE;\n-  })\n-\n-(define_expand \"sync_nandsi\"\n-  [(match_operand:SI 0 \"memory_operand\")\n-   (match_operand:SI 1 \"s_register_operand\")\n-   (not:SI (and:SI (match_dup 0) (match_dup 1)))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omn;\n-    generator.u.omn = gen_arm_sync_new_nandsi;\n-    arm_expand_sync (SImode, &generator, NULL, operands[0], NULL, operands[1]);\n-    DONE;\n-  })\n-\n (define_expand \"sync_<sync_optab><mode>\"\n-  [(match_operand:NARROW 0 \"memory_operand\")\n-   (match_operand:NARROW 1 \"s_register_operand\")\n-   (syncop:NARROW (match_dup 0) (match_dup 1))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  [(match_operand:QHSD 0 \"memory_operand\")\n+   (match_operand:QHSD 1 \"s_register_operand\")\n+   (syncop:QHSD (match_dup 0) (match_dup 1))]\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omn;\n     generator.u.omn = gen_arm_sync_new_<sync_optab><mode>;\n     arm_expand_sync (<MODE>mode, &generator, NULL, operands[0], NULL,\n-    \t\t     operands[1]);\n+\t\t     operands[1]);\n     DONE;\n   })\n \n (define_expand \"sync_nand<mode>\"\n-  [(match_operand:NARROW 0 \"memory_operand\")\n-   (match_operand:NARROW 1 \"s_register_operand\")\n-   (not:NARROW (and:NARROW (match_dup 0) (match_dup 1)))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  [(match_operand:QHSD 0 \"memory_operand\")\n+   (match_operand:QHSD 1 \"s_register_operand\")\n+   (not:QHSD (and:QHSD (match_dup 0) (match_dup 1)))]\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omn;\n@@ -169,57 +123,27 @@\n     DONE;\n   })\n \n-(define_expand \"sync_new_<sync_optab>si\"\n-  [(match_operand:SI 0 \"s_register_operand\")\n-   (match_operand:SI 1 \"memory_operand\")\n-   (match_operand:SI 2 \"s_register_operand\")\n-   (syncop:SI (match_dup 1) (match_dup 2))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omn;\n-    generator.u.omn = gen_arm_sync_new_<sync_optab>si;\n-    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n-                     operands[2]);\n-    DONE;\n-  })\n-\n-(define_expand \"sync_new_nandsi\"\n-  [(match_operand:SI 0 \"s_register_operand\")\n-   (match_operand:SI 1 \"memory_operand\")\n-   (match_operand:SI 2 \"s_register_operand\")\n-   (not:SI (and:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omn;\n-    generator.u.omn = gen_arm_sync_new_nandsi;\n-    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n-    \t\t     operands[2]);\n-    DONE;\n-  })\n-\n (define_expand \"sync_new_<sync_optab><mode>\"\n-  [(match_operand:NARROW 0 \"s_register_operand\")\n-   (match_operand:NARROW 1 \"memory_operand\")\n-   (match_operand:NARROW 2 \"s_register_operand\")\n-   (syncop:NARROW (match_dup 1) (match_dup 2))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  [(match_operand:QHSD 0 \"s_register_operand\")\n+   (match_operand:QHSD 1 \"memory_operand\")\n+   (match_operand:QHSD 2 \"s_register_operand\")\n+   (syncop:QHSD (match_dup 1) (match_dup 2))]\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omn;\n     generator.u.omn = gen_arm_sync_new_<sync_optab><mode>;\n     arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1],\n-    \t\t     NULL, operands[2]);\n+\t\t     NULL, operands[2]);\n     DONE;\n   })\n \n (define_expand \"sync_new_nand<mode>\"\n-  [(match_operand:NARROW 0 \"s_register_operand\")\n-   (match_operand:NARROW 1 \"memory_operand\")\n-   (match_operand:NARROW 2 \"s_register_operand\")\n-   (not:NARROW (and:NARROW (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  [(match_operand:QHSD 0 \"s_register_operand\")\n+   (match_operand:QHSD 1 \"memory_operand\")\n+   (match_operand:QHSD 2 \"s_register_operand\")\n+   (not:QHSD (and:QHSD (match_dup 1) (match_dup 2)))]\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omn;\n@@ -229,57 +153,27 @@\n     DONE;\n   });\n \n-(define_expand \"sync_old_<sync_optab>si\"\n-  [(match_operand:SI 0 \"s_register_operand\")\n-   (match_operand:SI 1 \"memory_operand\")\n-   (match_operand:SI 2 \"s_register_operand\")\n-   (syncop:SI (match_dup 1) (match_dup 2))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omn;\n-    generator.u.omn = gen_arm_sync_old_<sync_optab>si;\n-    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n-                     operands[2]);\n-    DONE;\n-  })\n-\n-(define_expand \"sync_old_nandsi\"\n-  [(match_operand:SI 0 \"s_register_operand\")\n-   (match_operand:SI 1 \"memory_operand\")\n-   (match_operand:SI 2 \"s_register_operand\")\n-   (not:SI (and:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n-  {\n-    struct arm_sync_generator generator;\n-    generator.op = arm_sync_generator_omn;\n-    generator.u.omn = gen_arm_sync_old_nandsi;\n-    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n-                     operands[2]);\n-    DONE;\n-  })\n-\n (define_expand \"sync_old_<sync_optab><mode>\"\n-  [(match_operand:NARROW 0 \"s_register_operand\")\n-   (match_operand:NARROW 1 \"memory_operand\")\n-   (match_operand:NARROW 2 \"s_register_operand\")\n-   (syncop:NARROW (match_dup 1) (match_dup 2))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  [(match_operand:QHSD 0 \"s_register_operand\")\n+   (match_operand:QHSD 1 \"memory_operand\")\n+   (match_operand:QHSD 2 \"s_register_operand\")\n+   (syncop:QHSD (match_dup 1) (match_dup 2))]\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omn;\n     generator.u.omn = gen_arm_sync_old_<sync_optab><mode>;\n     arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1],\n-    \t\t     NULL, operands[2]);\n+\t\t     NULL, operands[2]);\n     DONE;\n   })\n \n (define_expand \"sync_old_nand<mode>\"\n-  [(match_operand:NARROW 0 \"s_register_operand\")\n-   (match_operand:NARROW 1 \"memory_operand\")\n-   (match_operand:NARROW 2 \"s_register_operand\")\n-   (not:NARROW (and:NARROW (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  [(match_operand:QHSD 0 \"s_register_operand\")\n+   (match_operand:QHSD 1 \"memory_operand\")\n+   (match_operand:QHSD 2 \"s_register_operand\")\n+   (not:QHSD (and:QHSD (match_dup 1) (match_dup 2)))]\n+  \"<sync_predtab>\"\n   {\n     struct arm_sync_generator generator;\n     generator.op = arm_sync_generator_omn;\n@@ -289,22 +183,22 @@\n     DONE;\n   })\n \n-(define_insn \"arm_sync_compare_and_swapsi\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI\n-\t  [(match_operand:SI 1 \"arm_sync_memory_operand\" \"+Q\")\n-   \t   (match_operand:SI 2 \"s_register_operand\" \"r\")\n-\t   (match_operand:SI 3 \"s_register_operand\" \"r\")]\n-\t  VUNSPEC_SYNC_COMPARE_AND_SWAP))\n-   (set (match_dup 1) (unspec_volatile:SI [(match_dup 2)]\n+(define_insn \"arm_sync_compare_and_swap<mode>\"\n+  [(set (match_operand:SIDI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SIDI\n+\t [(match_operand:SIDI 1 \"arm_sync_memory_operand\" \"+Q\")\n+\t  (match_operand:SIDI 2 \"s_register_operand\" \"r\")\n+\t  (match_operand:SIDI 3 \"s_register_operand\" \"r\")]\n+\t VUNSPEC_SYNC_COMPARE_AND_SWAP))\n+   (set (match_dup 1) (unspec_volatile:SIDI [(match_dup 2)]\n                                           VUNSPEC_SYNC_COMPARE_AND_SWAP))\n    (set (reg:CC CC_REGNUM) (unspec_volatile:CC [(match_dup 1)]\n                                                 VUNSPEC_SYNC_COMPARE_AND_SWAP))\n    ]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n-  } \n+  }\n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_required_value\"  \"2\")\n@@ -318,18 +212,18 @@\n         (zero_extend:SI\n \t  (unspec_volatile:NARROW\n \t    [(match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\")\n-   \t     (match_operand:SI 2 \"s_register_operand\" \"r\")\n+\t     (match_operand:SI 2 \"s_register_operand\" \"r\")\n \t     (match_operand:SI 3 \"s_register_operand\" \"r\")]\n \t    VUNSPEC_SYNC_COMPARE_AND_SWAP)))\n    (set (match_dup 1) (unspec_volatile:NARROW [(match_dup 2)]\n                                           VUNSPEC_SYNC_COMPARE_AND_SWAP))\n    (set (reg:CC CC_REGNUM) (unspec_volatile:CC [(match_dup 1)]\n                                                 VUNSPEC_SYNC_COMPARE_AND_SWAP))\n    ]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n-  } \n+  }\n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_required_value\"  \"2\")\n@@ -338,18 +232,18 @@\n    (set_attr \"conds\" \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"arm_sync_lock_test_and_setsi\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (match_operand:SI 1 \"arm_sync_memory_operand\" \"+Q\"))\n+(define_insn \"arm_sync_lock_test_and_set<mode>\"\n+  [(set (match_operand:SIDI 0 \"s_register_operand\" \"=&r\")\n+\t(match_operand:SIDI 1 \"arm_sync_memory_operand\" \"+Q\"))\n    (set (match_dup 1)\n-        (unspec_volatile:SI [(match_operand:SI 2 \"s_register_operand\" \"r\")]\n-\t                    VUNSPEC_SYNC_LOCK))\n+\t(unspec_volatile:SIDI [(match_operand:SIDI 2 \"s_register_operand\" \"r\")]\n+\tVUNSPEC_SYNC_LOCK))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n-  } \n+  }\n   [(set_attr \"sync_release_barrier\" \"no\")\n    (set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n@@ -364,10 +258,10 @@\n         (zero_extend:SI (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\")))\n    (set (match_dup 1)\n         (unspec_volatile:NARROW [(match_operand:SI 2 \"s_register_operand\" \"r\")]\n-\t                        VUNSPEC_SYNC_LOCK))\n+\t\t\t\tVUNSPEC_SYNC_LOCK))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n   } \n@@ -380,22 +274,22 @@\n    (set_attr \"conds\" \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"arm_sync_new_<sync_optab>si\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI [(syncop:SI\n-                               (match_operand:SI 1 \"arm_sync_memory_operand\" \"+Q\")\n-                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n-\t                    ]\n-\t                    VUNSPEC_SYNC_NEW_OP))\n+(define_insn \"arm_sync_new_<sync_optab><mode>\"\n+  [(set (match_operand:SIDI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SIDI [(syncop:SIDI\n+\t\t\t       (match_operand:SIDI 1 \"arm_sync_memory_operand\" \"+Q\")\n+\t\t\t       (match_operand:SIDI 2 \"s_register_operand\" \"r\"))\n+\t\t\t    ]\n+\t\t\t    VUNSPEC_SYNC_NEW_OP))\n    (set (match_dup 1)\n-        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n-\t                    VUNSPEC_SYNC_NEW_OP))\n+\t(unspec_volatile:SIDI [(match_dup 1) (match_dup 2)]\n+\t\t\t    VUNSPEC_SYNC_NEW_OP))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n-  } \n+  }\n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_new_value\"       \"2\")\n@@ -405,54 +299,54 @@\n    (set_attr \"conds\" \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"arm_sync_new_nandsi\"\n+(define_insn \"arm_sync_new_<sync_optab><mode>\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI [(not:SI (and:SI\n-                               (match_operand:SI 1 \"arm_sync_memory_operand\" \"+Q\")\n-                               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n-\t                    ]\n-\t                    VUNSPEC_SYNC_NEW_OP))\n+        (unspec_volatile:SI [(syncop:SI\n+\t\t\t       (zero_extend:SI\n+\t\t\t\t (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n+\t\t\t       (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t\t\t    ]\n+\t\t\t    VUNSPEC_SYNC_NEW_OP))\n    (set (match_dup 1)\n-        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n-\t                    VUNSPEC_SYNC_NEW_OP))\n+\t(unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+\t\t\t\tVUNSPEC_SYNC_NEW_OP))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n-  } \n+  }\n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_new_value\"       \"2\")\n    (set_attr \"sync_t1\"              \"0\")\n    (set_attr \"sync_t2\"              \"3\")\n-   (set_attr \"sync_op\"              \"nand\")\n+   (set_attr \"sync_op\"              \"<sync_optab>\")\n    (set_attr \"conds\" \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"arm_sync_new_<sync_optab><mode>\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI [(syncop:SI\n-                               (zero_extend:SI\n-\t\t\t         (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n-                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n-\t                    ]\n-\t                    VUNSPEC_SYNC_NEW_OP))\n+(define_insn \"arm_sync_new_nand<mode>\"\n+  [(set (match_operand:SIDI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SIDI [(not:SIDI (and:SIDI\n+\t\t\t       (match_operand:SIDI 1 \"arm_sync_memory_operand\" \"+Q\")\n+\t\t\t       (match_operand:SIDI 2 \"s_register_operand\" \"r\")))\n+\t\t\t    ]\n+\t\t\t    VUNSPEC_SYNC_NEW_OP))\n    (set (match_dup 1)\n-        (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n-\t                        VUNSPEC_SYNC_NEW_OP))\n+\t(unspec_volatile:SIDI [(match_dup 1) (match_dup 2)]\n+\t\t\t    VUNSPEC_SYNC_NEW_OP))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n-  } \n+  }\n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_new_value\"       \"2\")\n    (set_attr \"sync_t1\"              \"0\")\n    (set_attr \"sync_t2\"              \"3\")\n-   (set_attr \"sync_op\"              \"<sync_optab>\")\n+   (set_attr \"sync_op\"              \"nand\")\n    (set_attr \"conds\" \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -461,19 +355,19 @@\n         (unspec_volatile:SI\n \t  [(not:SI\n \t     (and:SI\n-               (zero_extend:SI\t  \n-\t         (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n-               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n+\t       (zero_extend:SI\n+\t\t (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n+\t       (match_operand:SI 2 \"s_register_operand\" \"r\")))\n \t  ] VUNSPEC_SYNC_NEW_OP))\n    (set (match_dup 1)\n         (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n-\t                        VUNSPEC_SYNC_NEW_OP))\n+\t\t\t\tVUNSPEC_SYNC_NEW_OP))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n-  } \n+  }\n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_new_value\"       \"2\")\n@@ -483,20 +377,20 @@\n    (set_attr \"conds\" \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"arm_sync_old_<sync_optab>si\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI [(syncop:SI\n-                               (match_operand:SI 1 \"arm_sync_memory_operand\" \"+Q\")\n-                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n-\t                    ]\n-\t                    VUNSPEC_SYNC_OLD_OP))\n+(define_insn \"arm_sync_old_<sync_optab><mode>\"\n+  [(set (match_operand:SIDI 0 \"s_register_operand\" \"=&r\")\n+\t(unspec_volatile:SIDI [(syncop:SIDI\n+\t\t\t       (match_operand:SIDI 1 \"arm_sync_memory_operand\" \"+Q\")\n+\t\t\t       (match_operand:SIDI 2 \"s_register_operand\" \"r\"))\n+\t\t\t    ]\n+\t\t\t    VUNSPEC_SYNC_OLD_OP))\n    (set (match_dup 1)\n-        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n-\t                    VUNSPEC_SYNC_OLD_OP))\n+        (unspec_volatile:SIDI [(match_dup 1) (match_dup 2)]\n+\t\t\t      VUNSPEC_SYNC_OLD_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SIDI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"<sync_clobber>\"))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n   } \n@@ -509,74 +403,74 @@\n    (set_attr \"conds\" \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"arm_sync_old_nandsi\"\n+(define_insn \"arm_sync_old_<sync_optab><mode>\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI [(not:SI (and:SI\n-                               (match_operand:SI 1 \"arm_sync_memory_operand\" \"+Q\")\n-                               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n-\t                    ]\n-\t                    VUNSPEC_SYNC_OLD_OP))\n+        (unspec_volatile:SI [(syncop:SI\n+\t\t\t       (zero_extend:SI\n+\t\t\t\t (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n+\t\t\t       (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t\t\t    ]\n+\t\t\t    VUNSPEC_SYNC_OLD_OP))\n    (set (match_dup 1)\n-        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n-\t                    VUNSPEC_SYNC_OLD_OP))\n+\t(unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+\t\t\t    VUNSPEC_SYNC_OLD_OP))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n-  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+   (clobber (match_scratch:SI 4 \"<sync_clobber>\"))]\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n   } \n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_new_value\"       \"2\")\n    (set_attr \"sync_t1\"              \"3\")\n-   (set_attr \"sync_t2\"              \"4\")\n-   (set_attr \"sync_op\"              \"nand\")\n+   (set_attr \"sync_t2\"              \"<sync_t2_reqd>\")\n+   (set_attr \"sync_op\"              \"<sync_optab>\")\n    (set_attr \"conds\" \t\t    \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"arm_sync_old_<sync_optab><mode>\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI [(syncop:SI\n-                               (zero_extend:SI\n-\t\t\t         (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n-                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n-\t                    ]\n-\t                    VUNSPEC_SYNC_OLD_OP))\n+(define_insn \"arm_sync_old_nand<mode>\"\n+  [(set (match_operand:SIDI 0 \"s_register_operand\" \"=&r\")\n+\t(unspec_volatile:SIDI [(not:SIDI (and:SIDI\n+\t\t\t       (match_operand:SIDI 1 \"arm_sync_memory_operand\" \"+Q\")\n+\t\t\t       (match_operand:SIDI 2 \"s_register_operand\" \"r\")))\n+\t\t\t    ]\n+\t\t\t    VUNSPEC_SYNC_OLD_OP))\n    (set (match_dup 1)\n-        (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+        (unspec_volatile:SIDI [(match_dup 1) (match_dup 2)]\n \t                    VUNSPEC_SYNC_OLD_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:SI 3 \"=&r\"))\n-   (clobber (match_scratch:SI 4 \"<sync_clobber>\"))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+   (clobber (match_scratch:SIDI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n   } \n   [(set_attr \"sync_result\"          \"0\")\n    (set_attr \"sync_memory\"          \"1\")\n    (set_attr \"sync_new_value\"       \"2\")\n    (set_attr \"sync_t1\"              \"3\")\n-   (set_attr \"sync_t2\"              \"<sync_t2_reqd>\")\n-   (set_attr \"sync_op\"              \"<sync_optab>\")\n+   (set_attr \"sync_t2\"              \"4\")\n+   (set_attr \"sync_op\"              \"nand\")\n    (set_attr \"conds\" \t\t    \"clob\")\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"arm_sync_old_nand<mode>\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n-        (unspec_volatile:SI [(not:SI (and:SI\n-                               (zero_extend:SI\n-\t\t\t         (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n-                               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n-\t                    ]\n-\t                    VUNSPEC_SYNC_OLD_OP))\n+\t(unspec_volatile:SI [(not:SI (and:SI\n+\t\t\t       (zero_extend:SI\n+\t\t\t\t (match_operand:NARROW 1 \"arm_sync_memory_operand\" \"+Q\"))\n+\t\t\t       (match_operand:SI 2 \"s_register_operand\" \"r\")))\n+\t\t\t    ]\n+\t\t\t    VUNSPEC_SYNC_OLD_OP))\n    (set (match_dup 1)\n-        (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n-\t                    VUNSPEC_SYNC_OLD_OP))\n+\t(unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+\t\t\t    VUNSPEC_SYNC_OLD_OP))\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n    (clobber (match_scratch:SI 4 \"=&r\"))]\n-  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  \"<sync_predtab>\"\n   {\n     return arm_output_sync_insn (insn, operands);\n   } "}]}