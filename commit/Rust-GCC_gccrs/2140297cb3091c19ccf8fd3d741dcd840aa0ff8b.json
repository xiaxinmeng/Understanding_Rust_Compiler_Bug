{"sha": "2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE0MDI5N2NiMzA5MWMxOWNjZjhmZDNkNzQxZGNkODQwYWEwZmY4Yg==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2018-06-02T11:14:04Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-06-02T11:14:04Z"}, "message": "[NDS32] Implement fp-as-gp optimization.\n\ngcc/\n\t* config/nds32/constants.md (unspec_volatile_element): Add\n\tUNSPEC_VOLATILE_OMIT_FP_BEGIN and UNSPEC_VOLATILE_OMIT_FP_END.\n\t* config/nds32/nds32-fp-as-gp.c: New implementation of fp_as_gp\n\toptimization.\n\t* config/nds32/nds32-protos.h (nds32_naked_function_p): Declare.\n\t(make_pass_nds32_fp_as_gp): Declare.\n\t* config/nds32/nds32.c (nds32_register_passes): Add fp_as_gp as one\n\toptmization pass.\n\t(nds32_asm_function_end_prologue): Remove unused asm output.\n\t(nds32_asm_function_begin_epilogue): Remove unused asm output.\n\t(nds32_asm_file_start): Output necessary fp_as_gp information.\n\t(nds32_option_override): Adjust register usage.\n\t(nds32_expand_prologue): Consider fp_as_gp situation.\n\t(nds32_expand_prologue_v3push): Consider fp_as_gp situation.\n\t* config/nds32/nds32.md (prologue): Check fp_as_gp_p and naked_p.\n\t(epilogue): Ditto.\n\t(return): Ditto.\n\t(simple_return): Ditto.\n\t(omit_fp_begin): Output special directive for fp_as_gp.\n\t(omit_fp_end): Output special directive for fp_as_gp.\n\t* config/nds32/nds32.opt (mfp-as-gp, mno-fp-as-gp, mforce-fp-as-gp,\n\tmforbid-fp-as-gp): New options.\n\nCo-Authored-By: Shiva Chen <shiva0217@gmail.com>\n\nFrom-SVN: r261115", "tree": {"sha": "86974ce9b54976b392371850f0ecc3f618305515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86974ce9b54976b392371850f0ecc3f618305515"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e812d4dd5df9befff0bc077349453e6126a8807d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e812d4dd5df9befff0bc077349453e6126a8807d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e812d4dd5df9befff0bc077349453e6126a8807d"}], "stats": {"total": 420, "additions": 366, "deletions": 54}, "files": [{"sha": "8f1bd35b71eb6d4166b5883b7e2054fcb96a4c69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "patch": "@@ -1,3 +1,29 @@\n+2018-06-02  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Shiva Chen  <shiva0217@gmail.com>\n+\n+\t* config/nds32/constants.md (unspec_volatile_element): Add\n+\tUNSPEC_VOLATILE_OMIT_FP_BEGIN and UNSPEC_VOLATILE_OMIT_FP_END.\n+\t* config/nds32/nds32-fp-as-gp.c: New implementation of fp_as_gp\n+\toptimization.\n+\t* config/nds32/nds32-protos.h (nds32_naked_function_p): Declare.\n+\t(make_pass_nds32_fp_as_gp): Declare.\n+\t* config/nds32/nds32.c (nds32_register_passes): Add fp_as_gp as one\n+\toptmization pass.\n+\t(nds32_asm_function_end_prologue): Remove unused asm output.\n+\t(nds32_asm_function_begin_epilogue): Remove unused asm output.\n+\t(nds32_asm_file_start): Output necessary fp_as_gp information.\n+\t(nds32_option_override): Adjust register usage.\n+\t(nds32_expand_prologue): Consider fp_as_gp situation.\n+\t(nds32_expand_prologue_v3push): Consider fp_as_gp situation.\n+\t* config/nds32/nds32.md (prologue): Check fp_as_gp_p and naked_p.\n+\t(epilogue): Ditto.\n+\t(return): Ditto.\n+\t(simple_return): Ditto.\n+\t(omit_fp_begin): Output special directive for fp_as_gp.\n+\t(omit_fp_end): Output special directive for fp_as_gp.\n+\t* config/nds32/nds32.opt (mfp-as-gp, mno-fp-as-gp, mforce-fp-as-gp,\n+\tmforbid-fp-as-gp): New options.\n+\n 2018-06-01  Mark Wielaard  <mark@klomp.org>\n \n \t* dwarf2out.c (dwarf2out_finish): Remove generation of"}, {"sha": "6d42f50c882e1b442fa5151349e10086383ae9e7", "filename": "gcc/config/nds32/constants.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fconstants.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fconstants.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstants.md?ref=2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "patch": "@@ -169,6 +169,8 @@\n   UNSPEC_VOLATILE_SET_TRIG_EDGE\n   UNSPEC_VOLATILE_GET_TRIG_TYPE\n   UNSPEC_VOLATILE_RELAX_GROUP\n+  UNSPEC_VOLATILE_OMIT_FP_BEGIN\n+  UNSPEC_VOLATILE_OMIT_FP_END\n   UNSPEC_VOLATILE_POP25_RETURN\n   UNSPEC_VOLATILE_UNALIGNED_FEATURE\n   UNSPEC_VOLATILE_ENABLE_UNALIGNED"}, {"sha": "1abad1dc24a14183ccd93ecdee9593ccca07aba6", "filename": "gcc/config/nds32/nds32-fp-as-gp.c", "status": "modified", "additions": 241, "deletions": 5, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c?ref=2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "patch": "@@ -26,19 +26,255 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n+#include \"hard-reg-set.h\"\n+#include \"tm_p.h\"\n+#include \"rtl.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"insn-config.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"ira.h\"\n+#include \"ira-int.h\"\n+#include \"df.h\"\n+#include \"tree-core.h\"\n+#include \"tree-pass.h\"\n+#include \"nds32-protos.h\"\n \n /* ------------------------------------------------------------------------ */\n \n+/* A helper function to check if this function should contain prologue.  */\n+static bool\n+nds32_have_prologue_p (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 28; i++)\n+    if (NDS32_REQUIRED_CALLEE_SAVED_P (i))\n+      return true;\n+\n+  return (flag_pic\n+\t  || NDS32_REQUIRED_CALLEE_SAVED_P (FP_REGNUM)\n+\t  || NDS32_REQUIRED_CALLEE_SAVED_P (LP_REGNUM));\n+}\n+\n+static int\n+nds32_get_symbol_count (void)\n+{\n+  int symbol_count = 0;\n+  rtx_insn *insn;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  /* Counting the insn number which the addressing mode is symbol.  */\n+\t  if (single_set (insn) && nds32_symbol_load_store_p (insn))\n+\t    {\n+\t      rtx pattern = PATTERN (insn);\n+\t      rtx mem;\n+\t      gcc_assert (GET_CODE (pattern) == SET);\n+\t      if (GET_CODE (SET_SRC (pattern)) == REG )\n+\t\tmem = SET_DEST (pattern);\n+\t      else\n+\t\tmem = SET_SRC (pattern);\n+\n+\t      /* We have only lwi37 and swi37 for fp-as-gp optimization,\n+\t\t so don't count any other than SImode.\n+\t\t MEM for QImode and HImode will wrap by ZERO_EXTEND\n+\t\t or SIGN_EXTEND */\n+\t      if (GET_CODE (mem) == MEM)\n+\t\tsymbol_count++;\n+\t    }\n+\t}\n+    }\n+\n+  return symbol_count;\n+}\n+\n /* Function to determine whether it is worth to do fp_as_gp optimization.\n-   Return 0: It is NOT worth to do fp_as_gp optimization.\n-   Return 1: It is APPROXIMATELY worth to do fp_as_gp optimization.\n+   Return false: It is NOT worth to do fp_as_gp optimization.\n+   Return true: It is APPROXIMATELY worth to do fp_as_gp optimization.\n    Note that if it is worth to do fp_as_gp optimization,\n    we MUST set FP_REGNUM ever live in this function.  */\n-int\n+static bool\n nds32_fp_as_gp_check_available (void)\n {\n-  /* By default we return 0.  */\n-  return 0;\n+  basic_block bb;\n+  basic_block exit_bb;\n+  edge_iterator ei;\n+  edge e;\n+  bool first_exit_blocks_p;\n+\n+  /* If there exists ANY of following conditions,\n+     we DO NOT perform fp_as_gp optimization:\n+       1. TARGET_FORBID_FP_AS_GP is set\n+\t  regardless of the TARGET_FORCE_FP_AS_GP.\n+       2. User explicitly uses 'naked'/'no_prologue' attribute.\n+\t  We use nds32_naked_function_p() to help such checking.\n+       3. Not optimize for size.\n+       4. Need frame pointer.\n+       5. If $fp is already required to be saved,\n+\t  it means $fp is already choosen by register allocator.\n+\t  Thus we better not to use it for fp_as_gp optimization.\n+       6. This function is a vararg function.\n+\t  DO NOT apply fp_as_gp optimization on this function\n+\t  because it may change and break stack frame.\n+       7. The epilogue is empty.\n+\t  This happens when the function uses exit()\n+\t  or its attribute is no_return.\n+\t  In that case, compiler will not expand epilogue\n+\t  so that we have no chance to output .omit_fp_end directive.  */\n+  if (TARGET_FORBID_FP_AS_GP\n+      || nds32_naked_function_p (current_function_decl)\n+      || !optimize_size\n+      || frame_pointer_needed\n+      || NDS32_REQUIRED_CALLEE_SAVED_P (FP_REGNUM)\n+      || (cfun->stdarg == 1)\n+      || (find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == NULL))\n+    return false;\n+\n+  /* Disable fp_as_gp if there is any infinite loop since the fp may\n+     reuse in infinite loops by register rename.\n+     For check infinite loops we should make sure exit_bb is post dominate\n+     all other basic blocks if there is no infinite loops.  */\n+  first_exit_blocks_p = true;\n+  exit_bb = NULL;\n+\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n+    {\n+      /* More than one exit block also do not perform fp_as_gp optimization.  */\n+      if (!first_exit_blocks_p)\n+\treturn false;\n+\n+      exit_bb = e->src;\n+      first_exit_blocks_p = false;\n+    }\n+\n+  /* Not found exit_bb? just abort fp_as_gp!  */\n+  if (!exit_bb)\n+    return false;\n+\n+  /* Each bb should post dominate by exit_bb if there is no infinite loop! */\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      if (!dominated_by_p (CDI_POST_DOMINATORS,\n+\t\t\t   bb,\n+\t\t\t   exit_bb))\n+\treturn false;\n+    }\n+\n+  /* Now we can check the possibility of using fp_as_gp optimization.  */\n+  if (TARGET_FORCE_FP_AS_GP)\n+    {\n+      /* User explicitly issues -mforce-fp-as-gp option.  */\n+      return true;\n+    }\n+  else\n+    {\n+      /* In the following we are going to evaluate whether\n+\t it is worth to do fp_as_gp optimization.  */\n+      bool good_gain = false;\n+      int symbol_count;\n+\n+      int threshold;\n+\n+      /* We check if there already requires prologue.\n+\t Note that $gp will be saved in prologue for PIC code generation.\n+\t After that, we can set threshold by the existence of prologue.\n+\t Each fp-implied instruction will gain 2-byte code size\n+\t from gp-aware instruction, so we have following heuristics.  */\n+      if (flag_pic\n+\t  || nds32_have_prologue_p ())\n+\t{\n+\t  /* Have-prologue:\n+\t       Compiler already intends to generate prologue content,\n+\t       so the fp_as_gp optimization will only insert\n+\t       'la $fp,_FP_BASE_' instruction, which will be\n+\t       converted into 4-byte instruction at link time.\n+\t       The threshold is \"3\" symbol accesses, 2 + 2 + 2 > 4.  */\n+\t  threshold = 3;\n+\t}\n+      else\n+\t{\n+\t  /* None-prologue:\n+\t       Compiler originally does not generate prologue content,\n+\t       so the fp_as_gp optimization will NOT ONLY insert\n+\t       'la $fp,_FP_BASE' instruction, but also causes\n+\t       push/pop instructions.\n+\t       If we are using v3push (push25/pop25),\n+\t       the threshold is \"5\" symbol accesses, 5*2 > 4 + 2 + 2;\n+\t       If we are using normal push (smw/lmw),\n+\t       the threshold is \"5+2\" symbol accesses 7*2 > 4 + 4 + 4.  */\n+\t  threshold = 5 + (TARGET_V3PUSH ? 0 : 2);\n+\t}\n+\n+      symbol_count = nds32_get_symbol_count ();\n+\n+      if (symbol_count >= threshold)\n+\tgood_gain = true;\n+\n+      /* Enable fp_as_gp optimization when potential gain is good enough.  */\n+      return good_gain;\n+    }\n+}\n+\n+static unsigned int\n+nds32_fp_as_gp (void)\n+{\n+  bool fp_as_gp_p;\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  fp_as_gp_p = nds32_fp_as_gp_check_available ();\n+\n+  /* Here is a hack to IRA for enable/disable a hard register per function.\n+     We *MUST* review this way after migrate gcc 4.9! */\n+  if (fp_as_gp_p) {\n+    SET_HARD_REG_BIT(this_target_ira_int->x_no_unit_alloc_regs, FP_REGNUM);\n+    df_set_regs_ever_live (FP_REGNUM, 1);\n+  } else {\n+    CLEAR_HARD_REG_BIT(this_target_ira_int->x_no_unit_alloc_regs, FP_REGNUM);\n+  }\n+\n+  cfun->machine->fp_as_gp_p = fp_as_gp_p;\n+\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  return 1;\n+}\n+\n+const pass_data pass_data_nds32_fp_as_gp =\n+{\n+  RTL_PASS,\t\t\t\t/* type */\n+  \"fp_as_gp\",\t\t\t\t/* name */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  TV_MACH_DEP,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0\t\t\t\t\t/* todo_flags_finish */\n+};\n+\n+class pass_nds32_fp_as_gp : public rtl_opt_pass\n+{\n+public:\n+  pass_nds32_fp_as_gp (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_nds32_fp_as_gp, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *)\n+  {\n+    return TARGET_16_BIT\n+\t   && optimize_size;\n+  }\n+  unsigned int execute (function *) { return nds32_fp_as_gp (); }\n+};\n+\n+rtl_opt_pass *\n+make_pass_nds32_fp_as_gp (gcc::context *ctxt)\n+{\n+  return new pass_nds32_fp_as_gp (ctxt);\n }\n \n /* ------------------------------------------------------------------------ */"}, {"sha": "3fa8ae175f230685a390e74db232ff899357bc0d", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "patch": "@@ -155,9 +155,8 @@ extern int nds32_adjust_insn_length (rtx_insn *, int);\n \n /* Auxiliary functions for FP_AS_GP detection.  */\n \n-extern int nds32_fp_as_gp_check_available (void);\n-\n extern bool nds32_symbol_load_store_p (rtx_insn *);\n+extern bool nds32_naked_function_p (tree);\n \n /* Auxiliary functions for jump table generation.  */\n \n@@ -367,5 +366,6 @@ extern bool nds32_use_load_post_increment(machine_mode);\n \n /* Functions for create nds32 specific optimization pass.  */\n extern rtl_opt_pass *make_pass_nds32_relax_opt (gcc::context *);\n+extern rtl_opt_pass *make_pass_nds32_fp_as_gp (gcc::context *);\n \n /* ------------------------------------------------------------------------ */"}, {"sha": "1afd8a10156e35df5688daca87db803b203b7d98", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "patch": "@@ -1391,7 +1391,7 @@ nds32_needs_double_word_align (machine_mode mode, const_tree type)\n }\n \n /* Return true if FUNC is a naked function.  */\n-static bool\n+bool\n nds32_naked_function_p (tree func)\n {\n   /* FOR BACKWARD COMPATIBILITY,\n@@ -1626,6 +1626,11 @@ nds32_register_pass (\n static void\n nds32_register_passes (void)\n {\n+  nds32_register_pass (\n+    make_pass_nds32_fp_as_gp,\n+    PASS_POS_INSERT_BEFORE,\n+    \"ira\");\n+\n   nds32_register_pass (\n     make_pass_nds32_relax_opt,\n     PASS_POS_INSERT_AFTER,\n@@ -2191,56 +2196,12 @@ static void\n nds32_asm_function_end_prologue (FILE *file)\n {\n   fprintf (file, \"\\t! END PROLOGUE\\n\");\n-\n-  /* If frame pointer is NOT needed and -mfp-as-gp is issued,\n-     we can generate special directive: \".omit_fp_begin\"\n-     to guide linker doing fp-as-gp optimization.\n-     However, for a naked function, which means\n-     it should not have prologue/epilogue,\n-     using fp-as-gp still requires saving $fp by push/pop behavior and\n-     there is no benefit to use fp-as-gp on such small function.\n-     So we need to make sure this function is NOT naked as well.  */\n-  if (!frame_pointer_needed\n-      && !cfun->machine->naked_p\n-      && cfun->machine->fp_as_gp_p)\n-    {\n-      fprintf (file, \"\\t! ----------------------------------------\\n\");\n-      fprintf (file, \"\\t! Guide linker to do \"\n-\t\t     \"link time optimization: fp-as-gp\\n\");\n-      fprintf (file, \"\\t! We add one more instruction to \"\n-\t\t     \"initialize $fp near to $gp location.\\n\");\n-      fprintf (file, \"\\t! If linker fails to use fp-as-gp transformation,\\n\");\n-      fprintf (file, \"\\t! this extra instruction should be \"\n-\t\t     \"eliminated at link stage.\\n\");\n-      fprintf (file, \"\\t.omit_fp_begin\\n\");\n-      fprintf (file, \"\\tla\\t$fp,_FP_BASE_\\n\");\n-      fprintf (file, \"\\t! ----------------------------------------\\n\");\n-    }\n }\n \n /* Before rtl epilogue has been expanded, this function is used.  */\n static void\n nds32_asm_function_begin_epilogue (FILE *file)\n {\n-  /* If frame pointer is NOT needed and -mfp-as-gp is issued,\n-     we can generate special directive: \".omit_fp_end\"\n-     to claim fp-as-gp optimization range.\n-     However, for a naked function,\n-     which means it should not have prologue/epilogue,\n-     using fp-as-gp still requires saving $fp by push/pop behavior and\n-     there is no benefit to use fp-as-gp on such small function.\n-     So we need to make sure this function is NOT naked as well.  */\n-  if (!frame_pointer_needed\n-      && !cfun->machine->naked_p\n-      && cfun->machine->fp_as_gp_p)\n-    {\n-      fprintf (file, \"\\t! ----------------------------------------\\n\");\n-      fprintf (file, \"\\t! Claim the range of fp-as-gp \"\n-\t\t     \"link time optimization\\n\");\n-      fprintf (file, \"\\t.omit_fp_end\\n\");\n-      fprintf (file, \"\\t! ----------------------------------------\\n\");\n-    }\n-\n   fprintf (file, \"\\t! BEGIN EPILOGUE\\n\");\n }\n \n@@ -3168,6 +3129,18 @@ nds32_asm_file_start (void)\n \t\t\t \"for checking inconsistency on interrupt handler\\n\");\n   fprintf (asm_out_file, \"\\t.vec_size\\t%d\\n\", nds32_isr_vector_size);\n \n+  /* If user enables '-mforce-fp-as-gp' or compiles programs with -Os,\n+     the compiler may produce 'la $fp,_FP_BASE_' instruction\n+     at prologue for fp-as-gp optimization.\n+     We should emit weak reference of _FP_BASE_ to avoid undefined reference\n+     in case user does not pass '--relax' option to linker.  */\n+  if (TARGET_FORCE_FP_AS_GP || optimize_size)\n+    {\n+      fprintf (asm_out_file, \"\\t! This weak reference is required to do \"\n+\t\t\t     \"fp-as-gp link time optimization\\n\");\n+      fprintf (asm_out_file, \"\\t.weak\\t_FP_BASE_\\n\");\n+    }\n+\n   fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n \n   if (TARGET_ISA_V2)\n@@ -4126,6 +4099,12 @@ nds32_option_override (void)\n \tfixed_regs[r] = call_used_regs[r] = 1;\n     }\n \n+  /* See if user explicitly would like to use fp-as-gp optimization.\n+     If so, we must prevent $fp from being allocated\n+     during register allocation.  */\n+  if (TARGET_FORCE_FP_AS_GP)\n+    fixed_regs[FP_REGNUM] = call_used_regs[FP_REGNUM] = 1;\n+\n   if (!TARGET_16_BIT)\n     {\n       /* Under no 16 bit ISA, we need to strictly disable TARGET_V3PUSH.  */\n@@ -4544,6 +4523,10 @@ nds32_expand_prologue (void)\n      The result will be in cfun->machine.  */\n   nds32_compute_stack_frame ();\n \n+  /* Check frame_pointer_needed again to prevent fp is need after reload.  */\n+  if (frame_pointer_needed)\n+    cfun->machine->fp_as_gp_p = false;\n+\n   /* If this is a variadic function, first we need to push argument\n      registers that hold the unnamed argument value.  */\n   if (cfun->machine->va_args_size != 0)\n@@ -4951,6 +4934,10 @@ nds32_expand_prologue_v3push (void)\n   if (cfun->machine->callee_saved_gpr_regs_size > 0)\n     df_set_regs_ever_live (FP_REGNUM, 1);\n \n+  /* Check frame_pointer_needed again to prevent fp is need after reload.  */\n+  if (frame_pointer_needed)\n+    cfun->machine->fp_as_gp_p = false;\n+\n   /* If the function is 'naked',\n      we do not have to generate prologue code fragment.  */\n   if (cfun->machine->naked_p && !flag_pic)"}, {"sha": "cf1ad9bd1b078fc2f50eb4befde80736286c6c49", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "patch": "@@ -1830,12 +1830,33 @@\n     nds32_expand_prologue_v3push ();\n   else\n     nds32_expand_prologue ();\n+\n+  /* If cfun->machine->fp_as_gp_p is true, we can generate special\n+     directive to guide linker doing fp-as-gp optimization.\n+     However, for a naked function, which means\n+     it should not have prologue/epilogue,\n+     using fp-as-gp still requires saving $fp by push/pop behavior and\n+     there is no benefit to use fp-as-gp on such small function.\n+     So we need to make sure this function is NOT naked as well.  */\n+  if (cfun->machine->fp_as_gp_p && !cfun->machine->naked_p)\n+    emit_insn (gen_omit_fp_begin (gen_rtx_REG (SImode, FP_REGNUM)));\n+\n   DONE;\n })\n \n (define_expand \"epilogue\" [(const_int 0)]\n   \"\"\n {\n+  /* If cfun->machine->fp_as_gp_p is true, we can generate special\n+     directive to guide linker doing fp-as-gp optimization.\n+     However, for a naked function, which means\n+     it should not have prologue/epilogue,\n+     using fp-as-gp still requires saving $fp by push/pop behavior and\n+     there is no benefit to use fp-as-gp on such small function.\n+     So we need to make sure this function is NOT naked as well.  */\n+  if (cfun->machine->fp_as_gp_p && !cfun->machine->naked_p)\n+    emit_insn (gen_omit_fp_end (gen_rtx_REG (SImode, FP_REGNUM)));\n+\n   /* Note that only under V3/V3M ISA, we could use v3pop epilogue.\n      In addition, we need to check if v3push is indeed available.  */\n   if (NDS32_V3PUSH_AVAILABLE_P)\n@@ -1935,7 +1956,8 @@\n   \"nds32_can_use_return_insn ()\"\n {\n   /* Emit as the simple return.  */\n-  if (cfun->machine->naked_p\n+  if (!cfun->machine->fp_as_gp_p\n+      && cfun->machine->naked_p\n       && (cfun->machine->va_args_size == 0))\n     {\n       emit_jump_insn (gen_return_internal ());\n@@ -1945,9 +1967,14 @@\n \n ;; This pattern is expanded only by the shrink-wrapping optimization\n ;; on paths where the function prologue has not been executed.\n+;; However, such optimization may reorder the prologue/epilogue blocks\n+;; together with basic blocks within function body.\n+;; So we must disable this pattern if we have already decided\n+;; to perform fp_as_gp optimization, which requires prologue to be\n+;; first block and epilogue to be last block.\n (define_expand \"simple_return\"\n   [(simple_return)]\n-  \"\"\n+  \"!cfun->machine->fp_as_gp_p\"\n   \"\"\n )\n \n@@ -2162,6 +2189,25 @@\n   [(set_attr \"length\" \"0\")]\n )\n \n+;; Output .omit_fp_begin for fp-as-gp optimization.\n+;; Also we have to set $fp register.\n+(define_insn \"omit_fp_begin\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=x\")\n+\t(unspec_volatile:SI [(const_int 0)] UNSPEC_VOLATILE_OMIT_FP_BEGIN))]\n+  \"\"\n+  \"! -----\\;.omit_fp_begin\\;la\\t$fp,_FP_BASE_\\;! -----\"\n+  [(set_attr \"length\" \"8\")]\n+)\n+\n+;; Output .omit_fp_end for fp-as-gp optimization.\n+;; Claim that we have to use $fp register.\n+(define_insn \"omit_fp_end\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"x\")] UNSPEC_VOLATILE_OMIT_FP_END)]\n+  \"\"\n+  \"! -----\\;.omit_fp_end\\;! -----\"\n+  [(set_attr \"length\" \"0\")]\n+)\n+\n (define_insn \"pop25return\"\n   [(return)\n    (unspec_volatile:SI [(reg:SI LP_REGNUM)] UNSPEC_VOLATILE_POP25_RETURN)]"}, {"sha": "6f73f897e5d684d68ec24ddda27b72354b107b6b", "filename": "gcc/config/nds32/nds32.opt", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2140297cb3091c19ccf8fd3d741dcd840aa0ff8b/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.opt?ref=2140297cb3091c19ccf8fd3d741dcd840aa0ff8b", "patch": "@@ -32,6 +32,13 @@ EL\n Target RejectNegative Alias(mlittle-endian)\n Generate code in little-endian mode.\n \n+mfp-as-gp\n+Target RejectNegative Alias(mforce-fp-as-gp)\n+Force performing fp-as-gp optimization.\n+\n+mno-fp-as-gp\n+Target RejectNegative Alias(mforbid-fp-as-gp)\n+Forbid performing fp-as-gp optimization.\n \n ; ---------------------------------------------------------------\n \n@@ -85,6 +92,14 @@ mlittle-endian\n Target Undocumented RejectNegative Negative(mbig-endian) InverseMask(BIG_ENDIAN)\n Generate code in little-endian mode.\n \n+mforce-fp-as-gp\n+Target Undocumented Mask(FORCE_FP_AS_GP)\n+Prevent $fp being allocated during register allocation so that compiler is able to force performing fp-as-gp optimization.\n+\n+mforbid-fp-as-gp\n+Target Undocumented Mask(FORBID_FP_AS_GP)\n+Forbid using $fp to access static and global variables.  This option strictly forbids fp-as-gp optimization regardless of '-mforce-fp-as-gp'.\n+\n mict-model=\n Target Undocumented RejectNegative Joined Enum(nds32_ict_model_type) Var(nds32_ict_model) Init(ICT_MODEL_SMALL)\n Specify the address generation strategy for ICT call's code model."}]}