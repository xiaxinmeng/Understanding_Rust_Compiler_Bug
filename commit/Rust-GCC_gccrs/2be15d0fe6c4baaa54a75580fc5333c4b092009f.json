{"sha": "2be15d0fe6c4baaa54a75580fc5333c4b092009f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJlMTVkMGZlNmM0YmFhYTU0YTc1NTgwZmM1MzMzYzRiMDkyMDA5Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-06-21T17:47:44Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-06-21T17:47:44Z"}, "message": "sparc.c (sparc_override_options): Don't allow profiling for code models other than medlow.\n\n        * sparc.c (sparc_override_options): Don't allow profiling for\n        code models other than medlow.\n        (sparc_function_profiler): New function from old FUNCTION_PROFILER\n        macro.  Use ASM_GENERATE_INTERNAL_LABEL and MCOUNT_FUNCTION.\n        (sparc_function_block_profiler): Likewise.  Use user_label_prefix.\n        (sparc_block_profiler): Likewise.\n        (sparc_function_block_profiler_exit): Likewise.\n        * sparc.h (FUNCTION_PROFILER): Call new sparc.c function.\n        (FUNCTION_BLOCK_PROFILER): Likewise.\n        (BLOCK_PROFILER): Likewise.\n        (FUNCTION_BLOCK_PROFILER_EXIT): Likewise.\n        (MCOUNT_FUNCTION): New.\n        * sparc/pbd.h (FUNCTION_PROFILER): Delete.\n        (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER): Delete.\n        * sparc/sun4o3.h (FUNCTION_PROFILER): Delete.\n        (MCOUNT_FUNCTION): New.\n        * sparc/sysv4.h (FUNCTION_BLOCK_PROFILER): Delete.\n        (BLOCK_PROFILER): Delete.\n        (MCOUNT_FUNCTION): New.\n\nFrom-SVN: r27672", "tree": {"sha": "a99da405152b364cbdfe9d3e91858d70b9a20881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a99da405152b364cbdfe9d3e91858d70b9a20881"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2be15d0fe6c4baaa54a75580fc5333c4b092009f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be15d0fe6c4baaa54a75580fc5333c4b092009f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be15d0fe6c4baaa54a75580fc5333c4b092009f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be15d0fe6c4baaa54a75580fc5333c4b092009f/comments", "author": null, "committer": null, "parents": [{"sha": "e8d49b5b5e0f6b26f866695c917d789f92885c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8d49b5b5e0f6b26f866695c917d789f92885c10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8d49b5b5e0f6b26f866695c917d789f92885c10"}], "stats": {"total": 636, "additions": 360, "deletions": 276}, "files": [{"sha": "e6393b34fb79ee7828eabf012da7efc4c1b8397f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2be15d0fe6c4baaa54a75580fc5333c4b092009f", "patch": "@@ -1,3 +1,25 @@\n+Mon Jun 21 17:18:25 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sparc.c (sparc_override_options): Don't allow profiling for\n+\tcode models other than medlow.\n+\t(sparc_function_profiler): New function from old FUNCTION_PROFILER\n+\tmacro.  Use ASM_GENERATE_INTERNAL_LABEL and MCOUNT_FUNCTION.\n+\t(sparc_function_block_profiler): Likewise.  Use user_label_prefix.\n+\t(sparc_block_profiler): Likewise.\n+\t(sparc_function_block_profiler_exit): Likewise.\n+\t* sparc.h (FUNCTION_PROFILER): Call new sparc.c function.\n+\t(FUNCTION_BLOCK_PROFILER): Likewise.\n+\t(BLOCK_PROFILER): Likewise.\n+\t(FUNCTION_BLOCK_PROFILER_EXIT): Likewise.\n+\t(MCOUNT_FUNCTION): New.\n+\t* sparc/pbd.h (FUNCTION_PROFILER): Delete.\n+\t(FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER): Delete.\n+\t* sparc/sun4o3.h (FUNCTION_PROFILER): Delete.\n+\t(MCOUNT_FUNCTION): New.\n+\t* sparc/sysv4.h (FUNCTION_BLOCK_PROFILER): Delete.\n+\t(BLOCK_PROFILER): Delete.\n+\t(MCOUNT_FUNCTION): New.\n+\n Mon Jun 21 14:11:29 1999  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md (movdf_hardfloat32): Fix typo in case 2."}, {"sha": "b70fdcb259b51925c9b02cd99a168d5c3941209e", "filename": "gcc/config/sparc/pbd.h", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fpbd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fpbd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpbd.h?ref=2be15d0fe6c4baaa54a75580fc5333c4b092009f", "patch": "@@ -144,35 +144,7 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\t.word .L%d\\n\", VALUE)\n \n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"\\tsethi %%hi(.LP%d),%%o0\\n\\tcall mcount\\n\\tor %%lo(.LP%d),%%o0,%%o0\\n\", \\\n-\t   (LABELNO), (LABELNO))\n-\n-/* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done.  */\n-\n-#undef FUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"\\tsethi %%hi(.LPBX0),%%o0\\n\\tld [%%lo(.LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne .LPY%d\\n\\tnop\\n\\tcall ___bb_init_func\\n\\tnop\\n.LPY%d:\\n\",  \\\n-\t   (LABELNO), (LABELNO))\n-\n-/* Output assembler code to FILE to increment the entry-count for\n-   the BLOCKNO'th basic block in this source file.  */\n-\n-#undef BLOCK_PROFILER\n-#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n-{\t\t\t\t\t\t\t\t\\\n-  int blockn = (BLOCKNO);\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tsethi %%hi(.LPBX2+%d),%%g1\\n\\tld [%%lo(.LPBX2+%d)+%%g1],%%g2\\n\\\n-\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(.LPBX2+%d)+%%g1]\\n\",\t\t\\\n-\t   4 * blockn, 4 * blockn, 4 * blockn);\t\t\t\\\n-  CC_STATUS_INIT;  /* We have clobbered %g1.  Also %g2.  */\t\\\n-}\n-/*   This is needed for SunOS 4.0, and should not hurt for 3.2\n+/* This is needed for SunOS 4.0, and should not hurt for 3.2\n    versions either.  */\n #undef ASM_OUTPUT_SOURCE_LINE(file, line) \n #define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\\"}, {"sha": "c30288479e89cbc8d5f5d2fce5889c3fb0b0d3a4", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=2be15d0fe6c4baaa54a75580fc5333c4b092009f", "patch": "@@ -365,6 +365,12 @@ sparc_override_options ()\n \n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n+\n+  if ((profile_flag || profile_block_flag)\n+      && sparc_cmodel != CM_MEDLOW)\n+    {\n+      error (\"profiling does not support code models other than medlow\");\n+    }\n }\n \f\n /* Miscellaneous utilities.  */\n@@ -7531,3 +7537,307 @@ sparc_return_peephole_ok (dest, src)\n     return 0;\n   return IN_OR_GLOBAL_P (dest);\n }\n+\f\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.\n+\n+   32 bit sparc uses %g2 as the STATIC_CHAIN_REGNUM which gets clobbered\n+   during profiling so we need to save/restore it around the call to mcount.\n+   We're guaranteed that a save has just been done, and we use the space\n+   allocated for intreg/fpreg value passing.  */\n+\n+void\n+sparc_function_profiler (file, labelno)\n+     FILE *file;\n+     int labelno;\n+{\n+  char buf[32];\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LP\", labelno);\n+\n+  if (! TARGET_ARCH64)\n+    fputs (\"\\tst\\t%g2,[%fp-4]\\n\", file);\n+\n+  fputs (\"\\tsethi\\t%hi(\", file);\n+  assemble_name (file, buf);\n+  fputs (\"),%o0\\n\", file);\n+\n+  fputs (\"\\tcall\\t\", file);\n+  assemble_name (file, MCOUNT_FUNCTION);\n+  putc ('\\n', file);\n+\n+  fputs (\"\\t or\\t%o0,%lo(\", file);\n+  assemble_name (file, buf);\n+  fputs (\"),%o0\\n\", file);\n+\n+  if (! TARGET_ARCH64)\n+    fputs (\"\\tld\\t[%fp-4],%g2\\n\", file);\n+}\n+\n+\n+/* The following macro shall output assembler code to FILE\n+   to initialize basic-block profiling.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to call the subroutine `__bb_init_trace_func'\n+\tand pass two parameters to it. The first parameter is\n+\tthe address of a block allocated in the object module.\n+\tThe second parameter is the number of the first basic block\n+\tof the function.\n+\n+\tThe name of the block is a local symbol made with this statement:\n+\t\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n+\n+\tThe number of the first basic block of the function is\n+\tpassed to the macro in BLOCK_OR_LABEL.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tparameter1 <- LPBX0\n+\t\tparameter2 <- BLOCK_OR_LABEL\n+\t\tcall __bb_init_trace_func\n+\n+    else if profile_block_flag != 0\n+\n+\tOutput code to call the subroutine `__bb_init_func'\n+\tand pass one single parameter to it, which is the same\n+\tas the first parameter to `__bb_init_trace_func'.\n+\n+\tThe first word of this parameter is a flag which will be nonzero if\n+\tthe object module has already been initialized.  So test this word\n+\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n+\tNote: When profile_block_flag == 2 the test need not be done\n+\tbut `__bb_init_trace_func' *must* be called.\n+\n+\tBLOCK_OR_LABEL may be used to generate a label number as a\n+\tbranch destination in case `__bb_init_func' will not be called.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tcmp (LPBX0),0\n+\t\tjne local_label\n+\t\tparameter1 <- LPBX0\n+\t\tcall __bb_init_func\n+\t    local_label:\n+\n+*/\n+\n+void\n+sparc_function_block_profiler(file, block_or_label)\n+     FILE *file;\n+     int block_or_label;\n+{\n+  char LPBX[32];\n+  ASM_GENERATE_INTERNAL_LABEL (LPBX, \"LPBX\", 0);\n+\n+  if (profile_block_flag == 2)\n+    {\n+      fputs (\"\\tsethi\\t%hi(\", file);\n+      assemble_name (file, LPBX);\n+      fputs (\"),%o0\\n\", file);\n+  \n+      fprintf (file, \"\\tsethi\\t%%hi(%d),%%o1\\n\", block_or_label);\n+\n+      fputs (\"\\tor\\t%o0,%lo(\", file);\n+      assemble_name (file, LPBX);\n+      fputs (\"),%o0\\n\", file);\n+  \n+      fprintf (file, \"\\tcall\\t%s__bb_init_trace_func\\n\", user_label_prefix);\n+\n+      fprintf (file, \"\\t or\\t%%o1,%%lo(%d),%%o1\\n\", block_or_label);\n+    }\n+  else if (profile_block_flag != 0)\n+    {\n+      char LPBY[32];\n+      ASM_GENERATE_INTERNAL_LABEL (LPBY, \"LPBY\", block_or_label);\n+\n+      fputs (\"\\tsethi\\t%hi(\", file);\n+      assemble_name (file, LPBX);\n+      fputs (\"),%o0\\n\", file);\n+      \n+      fputs (\"\\tld\\t[%lo(\", file);\n+      assemble_name (file, LPBX);\n+      fputs (\")+%o0],%o1\\n\", file);\n+\n+      fputs (\"\\ttst\\t%o1\\n\", file);\n+\n+      if (TARGET_V9)\n+\t{\n+\t  fputs (\"\\tbne,pn\\t%icc,\", file);\n+\t  assemble_name (file, LPBY);\n+\t  putc ('\\n', file);\n+\t}\n+      else\n+\t{\n+\t  fputs (\"\\tbne\\t\", file);\n+\t  assemble_name (file, LPBY);\n+\t  putc ('\\n', file);\n+\t}\n+\n+      fputs (\"\\t or\\t%o0,%lo(\", file);\n+      assemble_name (file, LPBX);\n+      fputs (\"),%o0\\n\", file);\n+\n+      fprintf (file, \"\\tcall\\t%s__bb_init_func\\n\\t nop\\n\", user_label_prefix);\n+\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"LPBY\", block_or_label);\n+    }\n+}\n+\n+/* The following macro shall output assembler code to FILE\n+   to increment a counter associated with basic block number BLOCKNO.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to initialize the global structure `__bb' and\n+\tcall the function `__bb_trace_func' which will increment the\n+\tcounter.\n+\n+\t`__bb' consists of two words. In the first word the number\n+\tof the basic block has to be stored. In the second word\n+\tthe address of a block allocated in the object module \n+\thas to be stored.\n+\n+\tThe basic block number is given by BLOCKNO.\n+\n+\tThe address of the block is given by the label created with \n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tby FUNCTION_BLOCK_PROFILER.\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tmove BLOCKNO -> (__bb)\n+\t\tmove LPBX0 -> (__bb+4)\n+\t\tcall __bb_trace_func\n+\n+\tNote that function `__bb_trace_func' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE\n+\tand MACHINE_STATE_RESTORE. The last two macros will be\n+\tused in the function `__bb_trace_func', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE.\n+\n+   else if profile_block_flag != 0\n+\n+\tOutput code to increment the counter directly.\n+\tBasic blocks are numbered separately from zero within each\n+\tcompiled object module. The count associated with block number\n+\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n+\tthis array is a local symbol made with this statement:\n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result. \n+\n+\tIf described in a virtual assembler language, the code to be\n+\toutput looks like:\n+\n+\t\tinc (LPBX2+4*BLOCKNO)\n+\n+*/\n+\n+void\n+sparc_block_profiler(file, blockno)\n+     FILE *file;\n+     int blockno;\n+{\n+  char LPBX[32];\n+\n+  if (profile_block_flag == 2)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (LPBX, \"LPBX\", 0);\n+\n+      fprintf (file, \"\\tsethi\\t%%hi(%s__bb),%%g1\\n\", user_label_prefix);\n+      fprintf (file, \"\\tsethi\\t%%hi(%d),%%g2\\n\", blockno);\n+      fprintf (file, \"\\tor\\t%%g1,%%lo(%s__bb),%%g1\\n\", user_label_prefix);\n+      fprintf (file, \"\\tor\\t%%g2,%%lo(%d),%%g2\\n\", blockno);\n+\n+      fputs (\"\\tst\\t%g2,[%g1]\\n\", file);\n+\n+      fputs (\"\\tsethi\\t%hi(\", file);\n+      assemble_name (file, LPBX);\n+      fputs (\"),%g2\\n\", file);\n+  \n+      fputs (\"\\tor\\t%o0,%lo(\", file);\n+      assemble_name (file, LPBX);\n+      fputs (\"),%g2\\n\", file);\n+  \n+      fputs (\"\\tst\\t%g2,[%g1+4]\\n\", file);\n+      fputs (\"\\tmov\\t%o7,%g2\\n\", file);\n+\n+      fprintf (file, \"\\tcall\\t%s__bb_trace_func\\n\\t nop\\n\", user_label_prefix);\n+\n+      fputs (\"\\tmov\\t%g2,%o7\\n\", file);\n+    }\n+  else if (profile_block_flag != 0)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (LPBX, \"LPBX\", 2);\n+\n+      fputs (\"\\tsethi\\t%hi(\", file);\n+      assemble_name (file, LPBX);\n+      fprintf (file, \"+%d),%%g1\\n\", blockno*4);\n+\n+      fputs (\"\\tld\\t[%g1+%lo(\", file);\n+      assemble_name (file, LPBX);\n+      fprintf (file, \"+%d)],%%g2\\n\", blockno*4);\n+\n+      fputs (\"\\tadd\\t%g2,1,%g2\\n\", file);\n+\n+      fputs (\"\\tst\\t%g2,[%g1+%lo(\", file);\n+      assemble_name (file, LPBX);\n+      fprintf (file, \"+%d)]\\n\", blockno*4);\n+    }\n+}\n+\n+/* The following macro shall output assembler code to FILE\n+   to indicate a return from function during basic-block profiling.\n+\n+   If profile_block_flag == 2:\n+\n+\tOutput assembler code to call function `__bb_trace_ret'.\n+\n+\tNote that function `__bb_trace_ret' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE_RET\n+\tand MACHINE_STATE_RESTORE_RET. The last two macros will be\n+\tused in the function `__bb_trace_ret', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE_RET.\n+\n+   else if profile_block_flag != 0:\n+\n+\tThe macro will not be used, so it need not distinguish\n+\tthese cases.\n+*/\n+\n+void\n+sparc_function_block_profiler_exit(file)\n+     FILE *file;\n+{\n+  if (profile_block_flag == 2)\n+    fprintf (file, \"\\tcall\\t%s__bb_trace_ret\\n\\t nop\\n\", user_label_prefix);\n+  else\n+    abort ();\n+}"}, {"sha": "ad11d74afc1479922a22fa1bd62c52765151e9f7", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 18, "deletions": 221, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=2be15d0fe6c4baaa54a75580fc5333c4b092009f", "patch": "@@ -1844,240 +1844,32 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\t\t       current_function_uses_only_leaf_regs))\n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.\n+   for profiling a function entry.  */\n \n-   32 bit sparc uses %g2 as the STATIC_CHAIN_REGNUM which gets clobbered\n-   during profiling so we need to save/restore it around the call to mcount.\n-   We're guaranteed that a save has just been done, and we use the space\n-   allocated for intreg/fpreg value passing.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+  sparc_function_profiler(FILE, LABELNO)\n \n-#define FUNCTION_PROFILER(FILE, LABELNO)  \t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    char buf[20];\t\t\t\t\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (buf, \"LP\", (LABELNO));\t\t\\\n-    if (! TARGET_ARCH64)\t\t\t\t\t\\\n-      fputs (\"\\tst %g2,[%fp-4]\\n\", FILE);\t\t\t\\\n-    fputs (\"\\tsethi %hi(\", FILE);\t\t\t\t\\\n-    assemble_name (FILE, buf);\t\t\t\t\t\\\n-    fputs (\"),%o0\\n\", FILE);\t\t\t\t\t\\\n-    fputs (\"\\tcall mcount\\n\\tadd %o0,%lo(\", FILE);\t\t\\\n-    assemble_name (FILE, buf);\t\t\t\t\t\\\n-    fputs (\"),%o0\\n\", FILE);\t\t\t\t\t\\\n-    if (! TARGET_ARCH64)\t\t\t\t\t\\\n-      fputs (\"\\tld [%fp-4],%g2\\n\", FILE);\t\t\t\\\n-  } while (0)\n-\n-/* There are three profiling modes for basic blocks available.\n-   The modes are selected at compile time by using the options\n-   -a or -ax of the gnu compiler.\n-   The variable `profile_block_flag' will be set according to the\n-   selected option.\n-\n-   profile_block_flag == 0, no option used:\n-\n-      No profiling done.\n-\n-   profile_block_flag == 1, -a option used.\n-\n-      Count frequency of execution of every basic block.\n+/* Set the name of the mcount function for the system.  */\n \n-   profile_block_flag == 2, -ax option used.\n-\n-      Generate code to allow several different profiling modes at run time. \n-      Available modes are:\n-             Produce a trace of all basic blocks.\n-             Count frequency of jump instructions executed.\n-      In every mode it is possible to start profiling upon entering\n-      certain functions and to disable profiling of some other functions.\n-\n-    The result of basic-block profiling will be written to a file `bb.out'.\n-    If the -ax option is used parameters for the profiling will be read\n-    from file `bb.in'.\n-\n-*/\n+#define MCOUNT_FUNCTION \"*mcount\"\n \n /* The following macro shall output assembler code to FILE\n-   to initialize basic-block profiling.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to call the subroutine `__bb_init_trace_func'\n-\tand pass two parameters to it. The first parameter is\n-\tthe address of a block allocated in the object module.\n-\tThe second parameter is the number of the first basic block\n-\tof the function.\n-\n-\tThe name of the block is a local symbol made with this statement:\n-\t\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+   to initialize basic-block profiling.  */\n \n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tThe number of the first basic block of the function is\n-\tpassed to the macro in BLOCK_OR_LABEL.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tparameter1 <- LPBX0\n-\t\tparameter2 <- BLOCK_OR_LABEL\n-\t\tcall __bb_init_trace_func\n-\n-    else if profile_block_flag != 0\n-\n-\tOutput code to call the subroutine `__bb_init_func'\n-\tand pass one single parameter to it, which is the same\n-\tas the first parameter to `__bb_init_trace_func'.\n-\n-\tThe first word of this parameter is a flag which will be nonzero if\n-\tthe object module has already been initialized.  So test this word\n-\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n-\tNote: When profile_block_flag == 2 the test need not be done\n-\tbut `__bb_init_trace_func' *must* be called.\n-\n-\tBLOCK_OR_LABEL may be used to generate a label number as a\n-\tbranch destination in case `__bb_init_func' will not be called.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tcmp (LPBX0),0\n-\t\tjne local_label\n-\t\tparameter1 <- LPBX0\n-\t\tcall __bb_init_func\n-local_label:\n-\n-*/\n-\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    int bol = (BLOCK_OR_LABEL);\t\t\t\t\\\n-    switch (profile_block_flag)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case 2:\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tor %%o0,%%lo(LPBX0),%%o0\\n\\tsethi %%hi(%d),%%o1\\n\\tcall ___bb_init_trace_func\\n\\tor %%o1,%%lo(%d),%%o1\\n\",\\\n-                 bol, bol);\t\t\t\t\\\n-        break;\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tld [%%lo(LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%%lo(LPBX0),%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\",\\\n-                 bol, bol);\t\t\t\t\\\n-        break;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-while (0)\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL) \\\n+  sparc_function_block_profiler(FILE, BLOCK_OR_LABEL)\n \n /* The following macro shall output assembler code to FILE\n-   to increment a counter associated with basic block number BLOCKNO.\n+   to increment a counter associated with basic block number BLOCKNO.  */\n \n-   If profile_block_flag == 2\n-\n-\tOutput code to initialize the global structure `__bb' and\n-\tcall the function `__bb_trace_func' which will increment the\n-\tcounter.\n-\n-\t`__bb' consists of two words. In the first word the number\n-\tof the basic block has to be stored. In the second word\n-\tthe address of a block allocated in the object module \n-\thas to be stored.\n-\n-\tThe basic block number is given by BLOCKNO.\n-\n-\tThe address of the block is given by the label created with \n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tby FUNCTION_BLOCK_PROFILER.\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tmove BLOCKNO -> (__bb)\n-\t\tmove LPBX0 -> (__bb+4)\n-\t\tcall __bb_trace_func\n-\n-\tNote that function `__bb_trace_func' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE\n-\tand MACHINE_STATE_RESTORE. The last two macros will be\n-\tused in the function `__bb_trace_func', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE.\n-\n-   else if profile_block_flag != 0\n-\n-\tOutput code to increment the counter directly.\n-\tBasic blocks are numbered separately from zero within each\n-\tcompiled object module. The count associated with block number\n-\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n-\tthis array is a local symbol made with this statement:\n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result. \n-\n-\tIf described in a virtual assembler language, the code to be\n-\toutput looks like:\n-\n-\t\tinc (LPBX2+4*BLOCKNO)\n-\n-*/\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n-do\t\t\t\t\t\\\n-  {\t\t\t\t\t\\\n-    int blockn = (BLOCKNO);\t\t\\\n-    switch (profile_block_flag)\t\t\\\n-      {\t\t\t\t\t\\\n-      case 2:\t\t\t\t\\\n-        fprintf (FILE, \"\\tsethi %%hi(___bb),%%g1\\n\\tsethi %%hi(%d),%%g2\\n\\tor %%g2,%%lo(%d),%%g2\\n\\tst %%g2,[%%lo(___bb)+%%g1]\\n\\tsethi %%hi(LPBX0),%%g2\\n\\tor %%g2,%%lo(LPBX0),%%g2\\n\\tadd 4,%%g1,%%g1\\n\\tst %%g2,[%%lo(___bb)+%%g1]\\n\\tmov %%o7,%%g2\\n\\tcall ___bb_trace_func\\n\\tnop\\n\\tmov %%g2,%%o7\\n\",\\\n-                 blockn, blockn); \\\n-        break;\t\t\t\t\\\n-      default:\t\t\t\t\\\n-        fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tld [%%lo(LPBX2+%d)+%%g1],%%g2\\n\\\n-\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(LPBX2+%d)+%%g1]\\n\", \\\n-                 4 * blockn, 4 * blockn, 4 * blockn); \\\n-        break;\t\t\t\t\\\n-      }\t\t\t\t\t\\\n-  }\t\t\t\t\t\\\n-while(0)\n+#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n+  sparc_block_profiler (FILE, BLOCKNO)\n \n /* The following macro shall output assembler code to FILE\n-   to indicate a return from function during basic-block profiling.\n-\n-   If profiling_block_flag == 2:\n-\n-\tOutput assembler code to call function `__bb_trace_ret'.\n-\n-\tNote that function `__bb_trace_ret' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE_RET\n-\tand MACHINE_STATE_RESTORE_RET. The last two macros will be\n-\tused in the function `__bb_trace_ret', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE_RET.\n-\n-   else if profiling_block_flag != 0:\n-\n-\tThe macro will not be used, so it need not distinguish\n-\tthese cases.\n-*/\n+   to indicate a return from function during basic-block profiling.  */\n \n #define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n-  fprintf (FILE, \"\\tcall ___bb_trace_ret\\n\\tnop\\n\" );\n+  sparc_function_block_profiler_exit(FILE)\n \n /* The function `__bb_trace_func' is called in every basic block\n    and is not allowed to change the machine state. Saving (restoring)\n@@ -3497,6 +3289,11 @@ extern int v9_regcmp_p ();\n extern unsigned long sparc_flat_compute_frame_size ();\n extern unsigned long sparc_type_code ();\n \n+extern void sparc_function_profiler ();\n+extern void sparc_function_block_profiler ();\n+extern void sparc_block_profiler ();\n+extern void sparc_function_block_profiler_exit ();\n+\n extern char *sparc_v8plus_shift ();\n \n #ifdef __STDC__"}, {"sha": "d2a53c1f2372ce2d00b254d4dc49ed07e06b24eb", "filename": "gcc/config/sparc/sun4o3.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsun4o3.h?ref=2be15d0fe6c4baaa54a75580fc5333c4b092009f", "patch": "@@ -1,9 +1,9 @@\n #include \"sparc/sparc.h\"\n \n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"\\tsethi %%hi(LP%d),%%o0\\n\\tcall .mcount\\n\\tor %%lo(LP%d),%%o0,%%o0\\n\", \\\n-\t   (LABELNO), (LABELNO))\n+/* Override the name of the mcount profiling function.  */\n+\n+#undef MCOUNT_FUNCTION\n+#define MCOUNT_FUNCTION \"*.mcount\"\n \n /* LINK_SPEC is needed only for SunOS 4.  */\n "}, {"sha": "5f9bba9e594db4440cbef583eefde775b4eb369c", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be15d0fe6c4baaa54a75580fc5333c4b092009f/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=2be15d0fe6c4baaa54a75580fc5333c4b092009f", "patch": "@@ -200,28 +200,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \".section\\t\\\"%s\\\",#alloc,#write\\n\", (NAME));\t\t\\\n } while (0)\n-\f\n-/* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done.  */\n-\n-#undef FUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n-  do { \\\n-    fprintf (FILE, \"\\tsethi %%hi(.LLPBX0),%%o0\\n\\tld [%%lo(.LLPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%%lo(.LLPBX0),%%o0\\n\\tcall __bb_init_func\\n\\tnop\\nLPY%d:\\n\", \\\n-\t     (LABELNO), (LABELNO)); \\\n-  } while (0)\n-\n-/* Output assembler code to FILE to increment the entry-count for\n-   the BLOCKNO'th basic block in this source file.  */\n-\n-#undef BLOCK_PROFILER\n-#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n-{ \\\n-  int blockn = (BLOCKNO); \\\n-  fprintf (FILE, \"\\tsethi %%hi(.LLPBX2+%d),%%g1\\n\\tld [%%lo(.LLPBX2+%d)+%%g1],%%g2\\n\\\n-\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(.LLPBX2+%d)+%%g1]\\n\", \\\n-\t   4 * blockn, 4 * blockn, 4 * blockn); \\\n-}\n \n /* A C statement (sans semicolon) to output to the stdio stream\n    FILE the assembler definition of uninitialized global DECL named\n@@ -231,3 +209,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef ASM_OUTPUT_ALIGNED_BSS\n #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n   asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+/* Override the name of the mcount profiling function.  */\n+\n+#undef MCOUNT_FUNCTION\n+#define MCOUNT_FUNCTION \"*_mcount\""}]}