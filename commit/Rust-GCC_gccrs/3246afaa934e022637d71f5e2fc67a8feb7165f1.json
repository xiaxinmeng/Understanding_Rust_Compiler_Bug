{"sha": "3246afaa934e022637d71f5e2fc67a8feb7165f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0NmFmYWE5MzRlMDIyNjM3ZDcxZjVlMmZjNjdhOGZlYjcxNjVmMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-10-13T13:29:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-10-13T13:29:28Z"}, "message": "re PR rtl-optimization/58662 (wrong code at -O2 for dumb condition)\n\n\tPR rtl-optimization/58662\n\t* combine.c (try_combine): Take into account death nodes on I2 when\n\tsplitting a PARALLEL of two independent SETs.  Fix dump message.\n\nFrom-SVN: r203498", "tree": {"sha": "9e9e3d0b28e42649ff838117757c2528579112bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e9e3d0b28e42649ff838117757c2528579112bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3246afaa934e022637d71f5e2fc67a8feb7165f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3246afaa934e022637d71f5e2fc67a8feb7165f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3246afaa934e022637d71f5e2fc67a8feb7165f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3246afaa934e022637d71f5e2fc67a8feb7165f1/comments", "author": null, "committer": null, "parents": [{"sha": "6137391a4810dd1274acb8fb5bbd7ca081bd0e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6137391a4810dd1274acb8fb5bbd7ca081bd0e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6137391a4810dd1274acb8fb5bbd7ca081bd0e2b"}], "stats": {"total": 75, "additions": 59, "deletions": 16}, "files": [{"sha": "2f0bfcec36393fe7876726a5ea817a18b7429c81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3246afaa934e022637d71f5e2fc67a8feb7165f1", "patch": "@@ -1,3 +1,9 @@\n+2013-10-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/58662\n+\t* combine.c (try_combine): Take into account death nodes on I2 when\n+\tsplitting a PARALLEL of two independent SETs.  Fix dump message.\n+\n 2013-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "13f5e29e3d616c5a601ca24574631c87be83bc9d", "filename": "gcc/combine.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3246afaa934e022637d71f5e2fc67a8feb7165f1", "patch": "@@ -3693,29 +3693,42 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t   && ! (contains_muldiv (SET_SRC (XVECEXP (newpat, 0, 0)))\n \t\t && contains_muldiv (SET_SRC (XVECEXP (newpat, 0, 1)))))\n     {\n+      rtx set0 = XVECEXP (newpat, 0, 0);\n+      rtx set1 = XVECEXP (newpat, 0, 1);\n+\n       /* Normally, it doesn't matter which of the two is done first,\n \t but the one that references cc0 can't be the second, and\n \t one which uses any regs/memory set in between i2 and i3 can't\n-\t be first.  */\n-      if (!use_crosses_set_p (SET_SRC (XVECEXP (newpat, 0, 1)),\n-\t\t\t      DF_INSN_LUID (i2))\n+\t be first.  The PARALLEL might also have been pre-existing in i3,\n+\t so we need to make sure that we won't wrongly hoist a SET to i2\n+\t that would conflict with a death note present in there.  */\n+      if (!use_crosses_set_p (SET_SRC (set1), DF_INSN_LUID (i2))\n+\t  && !(REG_P (SET_DEST (set1))\n+\t       && find_reg_note (i2, REG_DEAD, SET_DEST (set1)))\n+\t  && !(GET_CODE (SET_DEST (set1)) == SUBREG\n+\t       && find_reg_note (i2, REG_DEAD,\n+\t\t\t\t SUBREG_REG (SET_DEST (set1))))\n #ifdef HAVE_cc0\n-\t  && !reg_referenced_p (cc0_rtx, XVECEXP (newpat, 0, 0))\n+\t  && !reg_referenced_p (cc0_rtx, set0)\n #endif\n \t )\n \t{\n-\t  newi2pat = XVECEXP (newpat, 0, 1);\n-\t  newpat = XVECEXP (newpat, 0, 0);\n+\t  newi2pat = set1;\n+\t  newpat = set0;\n \t}\n-      else if (!use_crosses_set_p (SET_SRC (XVECEXP (newpat, 0, 0)),\n-\t\t\t\t   DF_INSN_LUID (i2))\n+      else if (!use_crosses_set_p (SET_SRC (set0), DF_INSN_LUID (i2))\n+\t       && !(REG_P (SET_DEST (set0))\n+\t\t    && find_reg_note (i2, REG_DEAD, SET_DEST (set0)))\n+\t       && !(GET_CODE (SET_DEST (set0)) == SUBREG\n+\t\t    && find_reg_note (i2, REG_DEAD,\n+\t\t\t\t      SUBREG_REG (SET_DEST (set0))))\n #ifdef HAVE_cc0\n-\t       && !reg_referenced_p (cc0_rtx, XVECEXP (newpat, 0, 1))\n+\t       && !reg_referenced_p (cc0_rtx, set1)\n #endif\n \t      )\n \t{\n-\t  newi2pat = XVECEXP (newpat, 0, 0);\n-\t  newpat = XVECEXP (newpat, 0, 1);\n+\t  newi2pat = set0;\n+\t  newpat = set1;\n \t}\n       else\n \t{\n@@ -4261,9 +4274,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       }\n \n     /* Update reg_stat[].nonzero_bits et al for any changes that may have\n-       been made to this insn.  The order of\n-       set_nonzero_bits_and_sign_copies() is important.  Because newi2pat\n-       can affect nonzero_bits of newpat */\n+       been made to this insn.  The order is important, because newi2pat\n+       can affect nonzero_bits of newpat.  */\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n     note_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n@@ -4283,7 +4295,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n     {\n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"modifying insn i1 \");\n+\t  fprintf (dump_file, \"modifying insn i0 \");\n \t  dump_insn_slim (dump_file, i0);\n \t}\n       df_insn_rescan (i0);\n@@ -4321,7 +4333,6 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \n   /* Set new_direct_jump_p if a new return or simple jump instruction\n      has been created.  Adjust the CFG accordingly.  */\n-\n   if (returnjump_p (i3) || any_uncondjump_p (i3))\n     {\n       *new_direct_jump_p = 1;"}, {"sha": "362186f2628defffc1aa04e1214e68531d5b9aee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3246afaa934e022637d71f5e2fc67a8feb7165f1", "patch": "@@ -1,3 +1,7 @@\n+2013-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.c-torture/execute/pr58662.c: New test.\n+\n 2013-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "dc0d5f02acab8bd4f9495ba560ed60430e627c2d", "filename": "gcc/testsuite/gcc.c-torture/execute/pr58662.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58662.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3246afaa934e022637d71f5e2fc67a8feb7165f1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58662.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58662.c?ref=3246afaa934e022637d71f5e2fc67a8feb7165f1", "patch": "@@ -0,0 +1,22 @@\n+extern void abort (void);\n+\n+int a, c, d;\n+volatile int b;\n+\n+static int\n+foo (int p1, short p2)\n+{\n+  return p1 / p2;\n+}\n+\n+int\n+main ()\n+{\n+  char e;\n+  d = foo (a == 0, (0, 35536)); \n+  e = d % 14;\n+  b = e && c;\n+  if (b != 0)\n+    abort ();\n+  return 0;\n+}"}]}