{"sha": "6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2MTFkOTI3NmQxYzdkMjc4YmU1YTQ3YzA5ZDNjYWI2YjM0ZmJmOA==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2004-12-29T13:11:58Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-12-29T13:11:58Z"}, "message": "re PR tree-optimization/18179 (vectorizer: wrong alignment/step/initial-address computed for struct accesses)\n\n2004-12-29  Ira Rosen  <irar@il.ibm.com>\n\n        PR tree-optimization/18179\n        * tree-vectorizer.c (vect_get_symbl_and_dr): Reorganize. Add memtag\n        retrieval.\n        (vect_analyze_data_refs): Remove memtag retrieval.\n\nFrom-SVN: r92700", "tree": {"sha": "40c4ff29ae30e8df4b47dd1e6b7ca71e616c731f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40c4ff29ae30e8df4b47dd1e6b7ca71e616c731f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5249b4b0ce7cccf9299f7911eb8919b3006f90a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5249b4b0ce7cccf9299f7911eb8919b3006f90a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5249b4b0ce7cccf9299f7911eb8919b3006f90a1"}], "stats": {"total": 287, "additions": 116, "deletions": 171}, "files": [{"sha": "984db9a97c0536f134217fe090e0b44bbefed144", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "patch": "@@ -1,3 +1,10 @@\n+2004-12-29  Ira Rosen  <irar@il.ibm.com>\n+\n+        PR tree-optimization/18179\n+\t* tree-vectorizer.c (vect_get_symbl_and_dr): Reorganize. Add memtag \n+\tretrieval.\n+\t(vect_analyze_data_refs): Remove memtag retrieval.\n+\n 2004-12-28  Richard Henderson  <rth@redhat.com>\n \n \tPR inline-asm/15740"}, {"sha": "ab9acf7e6de530fcd0ecab29d72dfb3628999c1c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 109, "deletions": 171, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "patch": "@@ -4763,6 +4763,23 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n    memory tag (for aliasing purposes). \n    Also data reference structure DR is created.  \n \n+   This function handles three kinds of MEMREF:\n+\n+   It is called from vect_analyze_data_refs with a MEMREF that is either an \n+   ARRAY_REF or an INDIRECT_REF (this is category 1 - \"recursion begins\"). \n+   It builds a DR for them using vect_get_base_and_bit_offset, and calls itself \n+   recursively to retrieve the relevant memtag for the MEMREF, \"peeling\" the \n+   MEMREF along the way. During the recursive calls, the function may be called \n+   with a MEMREF for which the recursion has to continue - PLUS_EXPR, \n+   MINUS_EXPR, INDIRECT_REF (category 2 - \"recursion continues\"), \n+   and/or with a MEMREF for which a memtag can be trivially obtained - VAR_DECL \n+   and SSA_NAME (this is category 3 - \"recursion stop condition\"). \n+\n+   When the MEMREF falls into category 1 there is still no data reference struct \n+   (DR) available. It is created by this function, and then, along the recursion, \n+   MEMREF will fall into category 2 or 3, in which case a DR will have already \n+   been created, but the analysis continues to retrieve the MEMTAG.\n+\n    Input:\n    MEMREF - data reference in STMT\n    IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n@@ -4780,118 +4797,118 @@ vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read,\n   tree symbl, oprnd0, oprnd1;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree offset;\n-  tree array_base, base;\n+  tree tag;\n   struct data_reference *new_dr;\n   bool base_aligned_p;\n \n-  *dr = NULL;\n-  switch (TREE_CODE (memref))\n+  if (*dr)\n     {\n-    case INDIRECT_REF:\n-      new_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read);\n-      if (! new_dr)\n-\treturn NULL_TREE; \n-      *dr = new_dr;\n-      symbl = DR_BASE_NAME (new_dr);\n-      STMT_VINFO_VECT_DR_BASE (stmt_info) = symbl;\n-\n-      switch (TREE_CODE (symbl))\n-\t{\n-\tcase PLUS_EXPR:\n-\tcase MINUS_EXPR:\n-\t  oprnd0 = TREE_OPERAND (symbl, 0);\n-\t  oprnd1 = TREE_OPERAND (symbl, 1);\n-\n-\t  STRIP_NOPS(oprnd1);\n-\t  /* Only {address_base + offset} expressions are supported,  \n-\t     where address_base can be POINTER_TYPE or ARRAY_TYPE and \n-\t     offset can be anything but POINTER_TYPE or ARRAY_TYPE.  \n-\t     TODO: swap operands if {offset + address_base}.  */\n-\t  if ((TREE_CODE (TREE_TYPE (oprnd1)) == POINTER_TYPE \n-\t       && TREE_CODE (oprnd1) != INTEGER_CST)\n-\t      || TREE_CODE (TREE_TYPE (oprnd1)) == ARRAY_TYPE)\n-\t    return NULL_TREE;\n-\n-\t  if (TREE_CODE (TREE_TYPE (oprnd0)) == POINTER_TYPE)\n-\t    symbl = oprnd0;\n-\t  else\n-\t    symbl = vect_get_symbl_and_dr (oprnd0, stmt, is_read, \n-\t\t\t\t\t   loop_vinfo, &new_dr); \n+      /* Category 3: recursion stop condition.  */\n+      /* (1) A DR already exists. We only need to get the relevant memtag for\n+\t MEMREF, the rest of the data was already initialized.  */\n \n+      switch (TREE_CODE (memref))\n+\t{\n+\t  /* (1.1) Stop condition: find the relevant memtag and return.  */\n \tcase SSA_NAME:\n-\tcase ADDR_EXPR:\n-\t  /* symbl remains unchanged.  */\n-\t  break;\n-\n-\tdefault:\n-\t  if (vect_debug_details (NULL))\n+\t  symbl = SSA_NAME_VAR (memref);\n+\t  tag = get_var_ann (symbl)->type_mem_tag;\n+\t  if (!tag)\n \t    {\n-\t      fprintf (dump_file, \"unhandled data ref: \");\n-\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t      fprintf (dump_file, \" (symbl \");\n-\t      print_generic_expr (dump_file, symbl, TDF_SLIM);\n-\t      fprintf (dump_file, \") in stmt  \");\n-\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t      tree ptr = TREE_OPERAND (DR_REF ((*dr)), 0);\n+\t      if (TREE_CODE (ptr) == SSA_NAME)\n+\t\ttag = get_var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n \t    }\n-\t  return NULL_TREE;\t\n-\t}\n-      break;\n-\n-    case ARRAY_REF:\n-      offset = size_zero_node;\n-\n-      /* Store the array base in the stmt info. \n-\t For one dimensional array ref a[i], the base is a,\n-\t for multidimensional a[i1][i2]..[iN], the base is \n-\t a[i1][i2]..[iN-1].  */\n-      array_base = TREE_OPERAND (memref, 0);\n-      STMT_VINFO_VECT_DR_BASE (stmt_info) = array_base;\t     \n-\n-      new_dr = analyze_array (stmt, memref, is_read);\n-      *dr = new_dr;\n+\t  if (!tag)\n+\t    {\n+\t      if (vect_debug_details (NULL))\n+\t\tfprintf (dump_file, \"not vectorized: no memtag for ref.\");\n+\t      return NULL_TREE;\n+\t    }\n+\t  return tag;\n \n-      /* Find the relevant symbol for aliasing purposes.  */\t\n-      base = DR_BASE_NAME (new_dr);\n-      switch (TREE_CODE (base))\t\n-\t{\n \tcase VAR_DECL:\n-\t  symbl = base;\n-\t  break;\n+\tcase PARM_DECL:\n+\t  return memref;\n \n+\t  /* Category 2: recursion continues.  */\n+\t  /* (1.2) A recursive call to find the relevant memtag is required.  */\n \tcase INDIRECT_REF:\n-\t  symbl = TREE_OPERAND (base, 0); \n-\t  break;\n+\t  symbl = TREE_OPERAND (memref, 0); \n+\t  break; /* For recursive call.  */\n \n \tcase COMPONENT_REF:\n \t  /* Could have recorded more accurate information - \n \t     i.e, the actual FIELD_DECL that is being referenced -\n-\t     but later passes expect VAR_DECL as the nmt.  */\t\n-\t  symbl = vect_get_base_and_bit_offset (new_dr, base, NULL_TREE, \n+\t     but later passes expect VAR_DECL as the nmt.  */\n+\t  /* Fall through.  */\n+\t\n+\tcase ADDR_EXPR:\n+\t  symbl = vect_get_base_and_bit_offset ((*dr), memref, NULL_TREE, \n \t\t\t\t\tloop_vinfo, &offset, &base_aligned_p);\n-\t  if (symbl)\n-\t    break;\n-\t  /* fall through */\t\n+\t  break; /* For recursive call.  */\n+\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\t  /* Although DR exists, we have to call the function recursively to \n+\t     build MEMTAG for such expression. This is handled below.  */\n+\t  oprnd0 = TREE_OPERAND (memref, 0);\n+\t  oprnd1 = TREE_OPERAND (memref, 1);\n+      \n+\t  STRIP_NOPS (oprnd1); \n+\t   /* Supported plus/minus expressions are of the form \n+\t     {address_base + offset}, such that address_base is of type \n+\t     POINTER/ARRAY, and offset is either an INTEGER_CST of type POINTER, \n+\t     or it's not of type POINTER/ARRAY. \n+\t     TODO: swap operands if {offset + address_base}.  */\n+\t  if ((TREE_CODE (TREE_TYPE (oprnd1)) == POINTER_TYPE \n+\t       && TREE_CODE (oprnd1) != INTEGER_CST)\n+\t      || TREE_CODE (TREE_TYPE (oprnd1)) == ARRAY_TYPE)\n+\t    return NULL_TREE;\n+      \n+\t  symbl = oprnd0;\t \n+\t  break; /* For recursive call.  */\n+\n \tdefault:\n-\t  if (vect_debug_details (NULL))\n-\t    {\n-\t      fprintf (dump_file, \"unhandled struct/class field access \");\n-\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n-\t    }\n \t  return NULL_TREE;\n \t}\n-      break;\n+    }  \n+  else\n+    {\n+      /* Category 1: recursion begins.  */\n+      /* (2) A DR does not exist yet and must be built, followed by a\n+\t recursive call to get the relevant memtag for MEMREF.  */\n \n-    default:\n-      if (vect_debug_details (NULL))\n-\t{\n-\t  fprintf (dump_file, \"unhandled data ref: \");\n-\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t  fprintf (dump_file, \" in stmt  \");\n-\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n-\t}\n-      return NULL_TREE;\n+      switch (TREE_CODE (memref))\n+\t{      \n+\tcase INDIRECT_REF:\n+\t  new_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read);\n+\t  if (!new_dr)\n+\t    return NULL_TREE; \n+\t  *dr = new_dr;\n+\t  symbl = DR_BASE_NAME (new_dr);\n+\t  STMT_VINFO_VECT_DR_BASE (stmt_info) = symbl;\n+\t  break;\n+      \n+\tcase ARRAY_REF:\n+\t  new_dr = analyze_array (stmt, memref, is_read);\n+\t  *dr = new_dr;\n+\t  symbl = DR_BASE_NAME (new_dr);\n+\t  STMT_VINFO_VECT_DR_BASE (stmt_info) = TREE_OPERAND (memref, 0);\n+\t  break;\n+\n+\tdefault:\n+\t  /* TODO: Support data-refs of form a[i].p for unions and single\n+\t     field structures.  */\n+\t  return NULL_TREE;\n+\t}      \n     }\n-  return symbl;\n+\n+  if (!symbl)\n+     return NULL_TREE;\n+  /* Recursive call to retrieve the relevant memtag.  */\n+  tag = vect_get_symbl_and_dr (symbl, stmt, is_read, loop_vinfo, dr);\n+  return tag;\n }\n \n \n@@ -4912,10 +4929,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n   block_stmt_iterator si;\n   int j;\n   struct data_reference *dr;\n-  tree tag;\n-  tree address_base;\n-  bool base_aligned_p;\n-  tree offset;\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_analyze_data_refs>>\\n\");\n@@ -4982,6 +4995,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  /* Analyze MEMREF. If it is of a supported form, build data_reference\n \t     struct for it (DR) and find the relevant symbol for aliasing \n \t     purposes.  */\n+\t  dr = NULL;\n \t  symbl = vect_get_symbl_and_dr (memref, stmt, is_read, loop_vinfo, \n \t\t\t\t\t &dr);\n \t  if (!symbl)\n@@ -4993,83 +5007,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\t}\n \t      return false;\n \t    }\n-\n-\t  /* Find and record the memtag assigned to this data-ref.  */\n-\t   switch (TREE_CODE (symbl))\n-\t    {\n-\t    case VAR_DECL:\n-\t      STMT_VINFO_MEMTAG (stmt_info) = symbl;\n-\t      break;\n-\t      \n-\t    case SSA_NAME:\n-\t      symbl = SSA_NAME_VAR (symbl);\n-\t      tag = get_var_ann (symbl)->type_mem_tag;\n-\t      if (!tag)\n-\t\t{\n-\t\t  tree ptr = TREE_OPERAND (memref, 0);\n-\t\t  if (TREE_CODE (ptr) == SSA_NAME)\n-\t\t    tag = get_var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n-\t\t}\n-\t      if (!tag)\n-\t\t{\n-\t\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t\t    fprintf (dump_file, \"not vectorized: no memtag for ref.\");\n-\t\t  return false;\n-\t\t}\n-\t      STMT_VINFO_MEMTAG (stmt_info) = tag;\n-\t      break;\n-\n-\t    case ADDR_EXPR:\n-\t      address_base = TREE_OPERAND (symbl, 0);\n-\n-\t      switch (TREE_CODE (address_base))\n-\t\t{\n-\t\tcase ARRAY_REF:\n-\t\t  {\n-\t\t    struct data_reference *tmp_dr;\n-\t\t    \n-\t\t    tmp_dr = analyze_array (stmt, TREE_OPERAND (symbl, 0), \n-\t\t\t\t\t    DR_IS_READ (dr));\n-\t\t    tag = vect_get_base_and_bit_offset\n-\t\t      (tmp_dr, DR_BASE_NAME (tmp_dr), \n-\t\t       NULL_TREE, loop_vinfo, &offset, &base_aligned_p);\n-\t\t    if (!tag)\n-\t\t      {\n-\t\t\tif (vect_debug_stats (loop)\n-\t\t\t    || vect_debug_details (loop))\n-\t\t\t  fprintf (dump_file,\n-\t\t\t\t   \"not vectorized: no memtag for ref.\");\n-\t\t\treturn false;\n-\t\t      }\n-\t\t    STMT_VINFO_MEMTAG (stmt_info) = tag;\n-\t\t  }\n-\t\t  \n-\t\t  break;\n-\t\t  \n-\t\tcase VAR_DECL: \n-\t\t  STMT_VINFO_MEMTAG (stmt_info) = address_base;\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t\t    {\n-\t\t      fprintf (dump_file, \n-\t\t\t       \"not vectorized: unhandled address expr: \");\n-\t\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n-\t\t    }\n-\t\t  return false;\n-\t\t}\n-\t      break;\n-\t      \n-\t    default:\n-\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t\t{\n-\t\t  fprintf (dump_file, \"not vectorized: unsupported data-ref: \");\n-\t\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n-\t\t}\n-\t      return false;\n-\t    }\n-\n+\t  STMT_VINFO_MEMTAG (stmt_info) = symbl;\n \t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n \t  STMT_VINFO_DATA_REF (stmt_info) = dr;\n \t}"}]}