{"sha": "b48826985b8b0bba790688ebe717cf626019a415", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4ODI2OTg1YjhiMGJiYTc5MDY4OGViZTcxN2NmNjI2MDE5YTQxNQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-06-26T04:31:14Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-06-26T04:31:14Z"}, "message": "re PR fortran/90988 (Wrong error message with variables named \"PUBLIC*\")\n\n2019-06-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR Fortran/90988\n\t* decl.c (access_attr_decl): Use temporary variable to reduce\n\tunreadability of code.  Normalize jumping to return.\n\t(gfc_match_protected): Fix parsing error.  Add comments to \n\texplain code.  Remove dead code.\n\t(gfc_match_private): Use temporary variable to reduce unreadability \n\tof code. Fix parsing error.  Move code to test for blank PRIVATE.\n\tRemove dead code.\n\t(gfc_match_public): Move code to test for blank PUBLIC.  Fix\n\tparsing error.  Remove dead code.\n\n2019-06-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR Fortran/90988\n\t* gfortran.dg/pr90988_1.f90: New test.\n\t* gfortran.dg/pr90988_2.f90: Ditto.\n\t* gfortran.dg/pr90988_3.f90: Ditto.\n\nFrom-SVN: r272667", "tree": {"sha": "dcd0994bcf951cec4155a3ba7327d8e8393e431a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcd0994bcf951cec4155a3ba7327d8e8393e431a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b48826985b8b0bba790688ebe717cf626019a415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48826985b8b0bba790688ebe717cf626019a415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48826985b8b0bba790688ebe717cf626019a415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48826985b8b0bba790688ebe717cf626019a415/comments", "author": null, "committer": null, "parents": [{"sha": "07525dad06aaaf4c321f386528d8357a55a67b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07525dad06aaaf4c321f386528d8357a55a67b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07525dad06aaaf4c321f386528d8357a55a67b96"}], "stats": {"total": 161, "additions": 110, "deletions": 51}, "files": [{"sha": "7e4e8a29984077b0e0873dae922f15aa8099defc", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 68, "deletions": 51, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=b48826985b8b0bba790688ebe717cf626019a415", "patch": "@@ -8788,6 +8788,7 @@ access_attr_decl (gfc_statement st)\n   gfc_symbol *sym, *dt_sym;\n   gfc_intrinsic_op op;\n   match m;\n+  gfc_access access = (st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n \n   if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n     goto done;\n@@ -8798,7 +8799,7 @@ access_attr_decl (gfc_statement st)\n       if (m == MATCH_NO)\n \tgoto syntax;\n       if (m == MATCH_ERROR)\n-\treturn MATCH_ERROR;\n+\tgoto done;\n \n       switch (type)\n \t{\n@@ -8818,18 +8819,12 @@ access_attr_decl (gfc_statement st)\n \t      && sym->attr.flavor == FL_UNKNOWN)\n \t    sym->attr.flavor = FL_PROCEDURE;\n \n-\t  if (!gfc_add_access (&sym->attr,\n-\t\t\t       (st == ST_PUBLIC)\n-\t\t\t       ? ACCESS_PUBLIC : ACCESS_PRIVATE,\n-\t\t\t       sym->name, NULL))\n-\t    return MATCH_ERROR;\n+\t  if (!gfc_add_access (&sym->attr, access, sym->name, NULL))\n+\t    goto done;\n \n \t  if (sym->attr.generic && (dt_sym = gfc_find_dt_in_generic (sym))\n-\t      && !gfc_add_access (&dt_sym->attr,\n-\t\t\t\t  (st == ST_PUBLIC)\n-\t\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE,\n-\t\t\t\t  sym->name, NULL))\n-\t    return MATCH_ERROR;\n+\t      && !gfc_add_access (&dt_sym->attr, access, sym->name, NULL))\n+\t    goto done;\n \n \t  break;\n \n@@ -8838,17 +8833,14 @@ access_attr_decl (gfc_statement st)\n \t    {\n \t      gfc_intrinsic_op other_op;\n \n-\t      gfc_current_ns->operator_access[op] =\n-\t\t(st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n+\t      gfc_current_ns->operator_access[op] = access;\n \n \t      /* Handle the case if there is another op with the same\n \t\t function, for INTRINSIC_EQ vs. INTRINSIC_EQ_OS and so on.  */\n \t      other_op = gfc_equivalent_op (op);\n \n \t      if (other_op != INTRINSIC_NONE)\n-\t\tgfc_current_ns->operator_access[other_op] =\n-\t\t  (st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n-\n+\t\tgfc_current_ns->operator_access[other_op] = access;\n \t    }\n \t  else\n \t    {\n@@ -8864,8 +8856,7 @@ access_attr_decl (gfc_statement st)\n \n \t  if (uop->access == ACCESS_UNKNOWN)\n \t    {\n-\t      uop->access = (st == ST_PUBLIC)\n-\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n+\t      uop->access = access;\n \t    }\n \t  else\n \t    {\n@@ -8898,6 +8889,13 @@ gfc_match_protected (void)\n {\n   gfc_symbol *sym;\n   match m;\n+  char c;\n+\n+  /* PROTECTED has already been seen, but must be followed by whitespace\n+     or ::.  */\n+  c = gfc_peek_ascii_char ();\n+  if (!gfc_is_whitespace (c) && c != ':')\n+    return MATCH_NO;\n \n   if (!gfc_current_ns->proc_name\n       || gfc_current_ns->proc_name->attr.flavor != FL_MODULE)\n@@ -8908,14 +8906,12 @@ gfc_match_protected (void)\n \n     }\n \n+  gfc_match (\" ::\");\n+\n   if (!gfc_notify_std (GFC_STD_F2003, \"PROTECTED statement at %C\"))\n     return MATCH_ERROR;\n \n-  if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n-    {\n-      return MATCH_ERROR;\n-    }\n-\n+  /* PROTECTED has an entity-list.  */\n   if (gfc_match_eos () == MATCH_YES)\n     goto syntax;\n \n@@ -8958,39 +8954,46 @@ gfc_match_protected (void)\n match\n gfc_match_private (gfc_statement *st)\n {\n+  gfc_state_data *prev;\n+  char c;\n \n   if (gfc_match (\"private\") != MATCH_YES)\n     return MATCH_NO;\n \n-  if (gfc_current_state () != COMP_MODULE\n-      && !(gfc_current_state () == COMP_DERIVED\n-\t   && gfc_state_stack->previous\n-\t   && gfc_state_stack->previous->state == COMP_MODULE)\n-      && !(gfc_current_state () == COMP_DERIVED_CONTAINS\n-\t   && gfc_state_stack->previous && gfc_state_stack->previous->previous\n-\t   && gfc_state_stack->previous->previous->state == COMP_MODULE))\n-    {\n-      gfc_error (\"PRIVATE statement at %C is only allowed in the \"\n-\t\t \"specification part of a module\");\n-      return MATCH_ERROR;\n-    }\n-\n-  if (gfc_current_state () == COMP_DERIVED)\n+  /* Try matching PRIVATE without an access-list.  */\n+  if (gfc_match_eos () == MATCH_YES)\n     {\n-      if (gfc_match_eos () == MATCH_YES)\n+      prev = gfc_state_stack->previous;\n+      if (gfc_current_state () != COMP_MODULE\n+\t  && !(gfc_current_state () == COMP_DERIVED\n+\t\t&& prev && prev->state == COMP_MODULE)\n+\t  && !(gfc_current_state () == COMP_DERIVED_CONTAINS\n+\t\t&& prev->previous && prev->previous->state == COMP_MODULE))\n \t{\n-\t  *st = ST_PRIVATE;\n-\t  return MATCH_YES;\n+\t  gfc_error (\"PRIVATE statement at %C is only allowed in the \"\n+\t\t     \"specification part of a module\");\n+\t  return MATCH_ERROR;\n \t}\n \n-      gfc_syntax_error (ST_PRIVATE);\n-      return MATCH_ERROR;\n+      *st = ST_PRIVATE;\n+      return MATCH_YES;\n     }\n \n-  if (gfc_match_eos () == MATCH_YES)\n+  /* At this point, PRIVATE must be followed by whitespace or ::.  */\n+  c = gfc_peek_ascii_char ();\n+  if (!gfc_is_whitespace (c) && c != ':')\n+    return MATCH_NO;\n+\n+  prev = gfc_state_stack->previous;\n+  if (gfc_current_state () != COMP_MODULE\n+      && !(gfc_current_state () == COMP_DERIVED\n+\t   && prev && prev->state == COMP_MODULE)\n+      && !(gfc_current_state () == COMP_DERIVED_CONTAINS\n+\t   && prev->previous && prev->previous->state == COMP_MODULE))\n     {\n-      *st = ST_PRIVATE;\n-      return MATCH_YES;\n+      gfc_error (\"PRIVATE statement at %C is only allowed in the \"\n+\t\t \"specification part of a module\");\n+      return MATCH_ERROR;\n     }\n \n   *st = ST_ATTR_DECL;\n@@ -9001,23 +9004,37 @@ gfc_match_private (gfc_statement *st)\n match\n gfc_match_public (gfc_statement *st)\n {\n+  char c;\n \n   if (gfc_match (\"public\") != MATCH_YES)\n     return MATCH_NO;\n \n+  /* Try matching PUBLIC without an access-list.  */\n+  if (gfc_match_eos () == MATCH_YES)\n+    {\n+      if (gfc_current_state () != COMP_MODULE)\n+\t{\n+\t  gfc_error (\"PUBLIC statement at %C is only allowed in the \"\n+\t\t     \"specification part of a module\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      *st = ST_PUBLIC;\n+      return MATCH_YES;\n+    }\n+\n+  /* At this point, PUBLIC must be followed by whitespace or ::.  */\n+  c = gfc_peek_ascii_char ();\n+  if (!gfc_is_whitespace (c) && c != ':')\n+    return MATCH_NO;\n+\n   if (gfc_current_state () != COMP_MODULE)\n     {\n       gfc_error (\"PUBLIC statement at %C is only allowed in the \"\n \t\t \"specification part of a module\");\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_match_eos () == MATCH_YES)\n-    {\n-      *st = ST_PUBLIC;\n-      return MATCH_YES;\n-    }\n-\n   *st = ST_ATTR_DECL;\n   return access_attr_decl (ST_PUBLIC);\n }"}, {"sha": "f8b6f1331631667a6c31ed7f6b44dfdeeb026356", "filename": "gcc/testsuite/gfortran.dg/pr90988_1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_1.f90?ref=b48826985b8b0bba790688ebe717cf626019a415", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+module mymod\n+  type :: mytyp\n+    integer :: i\n+  end type mytyp\n+contains\n+  subroutine mysub\n+    implicit none\n+    type(mytyp) :: a\n+    integer :: publici,publicj\n+    publici = a%i\n+    publicj = a%j       ! { dg-error \"is not a member\" }\n+  end subroutine mysub\n+end module mymod"}, {"sha": "a684ea21d46660cd29b1a2525c1bae81c548204a", "filename": "gcc/testsuite/gfortran.dg/pr90988_2.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_2.f90?ref=b48826985b8b0bba790688ebe717cf626019a415", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+module mymod\n+  type :: mytyp\n+    integer :: i\n+  end type mytyp\n+contains\n+  subroutine mysub\n+    implicit none\n+    type(mytyp) :: a\n+    integer :: privatei,privatej\n+    privatei = a%i\n+    privatej = a%j       ! { dg-error \"is not a member\" }\n+  end subroutine mysub\n+end module mymod"}, {"sha": "66ba06bdf0214d74e1084a45a370bd2170587dfb", "filename": "gcc/testsuite/gfortran.dg/pr90988_3.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48826985b8b0bba790688ebe717cf626019a415/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr90988_3.f90?ref=b48826985b8b0bba790688ebe717cf626019a415", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+module mymod\n+  type :: mytyp\n+    integer :: i\n+  end type mytyp\n+contains\n+  subroutine mysub\n+    implicit none\n+    type(mytyp) :: a\n+    integer :: protectedi,protectedj\n+    protectedi = a%i\n+    protectedj = a%j       ! { dg-error \"is not a member\" }\n+  end subroutine mysub\n+end module mymod"}]}