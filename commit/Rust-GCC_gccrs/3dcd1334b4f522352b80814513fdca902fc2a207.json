{"sha": "3dcd1334b4f522352b80814513fdca902fc2a207", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjZDEzMzRiNGY1MjIzNTJiODA4MTQ1MTNmZGNhOTAyZmMyYTIwNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-04-27T12:45:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-04-27T12:45:45Z"}, "message": "expand: Expand x / y * y as x - x % y if the latter is cheaper [PR96696]\n\nThe following patch tests both x / y * y and x - x % y expansion for the\nformer GIMPLE code and chooses the cheaper of those sequences.\n\n2021-04-27  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/96696\n\t* expr.c (expand_expr_divmod): New function.\n\t(expand_expr_real_2) <case TRUNC_DIV_EXPR>: Use it for truncations and\n\tdivisions.  Formatting fixes.\n\t<case MULT_EXPR>: Optimize x / y * y as x - x % y if the latter is\n\tcheaper.\n\n\t* gcc.target/i386/pr96696.c: New test.", "tree": {"sha": "ba22865f280b62b887ab9dc5c9c065aeebcdcf32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba22865f280b62b887ab9dc5c9c065aeebcdcf32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dcd1334b4f522352b80814513fdca902fc2a207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dcd1334b4f522352b80814513fdca902fc2a207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dcd1334b4f522352b80814513fdca902fc2a207", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dcd1334b4f522352b80814513fdca902fc2a207/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eea82246290010addf7f6be71a71b51079b3cb5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea82246290010addf7f6be71a71b51079b3cb5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea82246290010addf7f6be71a71b51079b3cb5d"}], "stats": {"total": 220, "additions": 162, "deletions": 58}, "files": [{"sha": "5a1fda7e3e8b530c032cc8e26e26079e9b6d79bb", "filename": "gcc/expr.c", "status": "modified", "additions": 132, "deletions": 58, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcd1334b4f522352b80814513fdca902fc2a207/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcd1334b4f522352b80814513fdca902fc2a207/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3dcd1334b4f522352b80814513fdca902fc2a207", "patch": "@@ -8664,6 +8664,56 @@ expand_misaligned_mem_ref (rtx temp, machine_mode mode, int unsignedp,\n   return temp;\n }\n \n+/* Helper function of expand_expr_2, expand a division or modulo.\n+   op0 and op1 should be already expanded treeop0 and treeop1, using\n+   expand_operands.  */\n+\n+static rtx\n+expand_expr_divmod (tree_code code, machine_mode mode, tree treeop0,\n+\t\t    tree treeop1, rtx op0, rtx op1, rtx target, int unsignedp)\n+{\n+  bool mod_p = (code == TRUNC_MOD_EXPR || code == FLOOR_MOD_EXPR\n+\t\t|| code == CEIL_MOD_EXPR || code == ROUND_MOD_EXPR);\n+  if (SCALAR_INT_MODE_P (mode)\n+      && optimize >= 2\n+      && get_range_pos_neg (treeop0) == 1\n+      && get_range_pos_neg (treeop1) == 1)\n+    {\n+      /* If both arguments are known to be positive when interpreted\n+\t as signed, we can expand it as both signed and unsigned\n+\t division or modulo.  Choose the cheaper sequence in that case.  */\n+      bool speed_p = optimize_insn_for_speed_p ();\n+      do_pending_stack_adjust ();\n+      start_sequence ();\n+      rtx uns_ret = expand_divmod (mod_p, code, mode, op0, op1, target, 1);\n+      rtx_insn *uns_insns = get_insns ();\n+      end_sequence ();\n+      start_sequence ();\n+      rtx sgn_ret = expand_divmod (mod_p, code, mode, op0, op1, target, 0);\n+      rtx_insn *sgn_insns = get_insns ();\n+      end_sequence ();\n+      unsigned uns_cost = seq_cost (uns_insns, speed_p);\n+      unsigned sgn_cost = seq_cost (sgn_insns, speed_p);\n+\n+      /* If costs are the same then use as tie breaker the other other\n+\t factor.  */\n+      if (uns_cost == sgn_cost)\n+\t{\n+\t  uns_cost = seq_cost (uns_insns, !speed_p);\n+\t  sgn_cost = seq_cost (sgn_insns, !speed_p);\n+\t}\n+\n+      if (uns_cost < sgn_cost || (uns_cost == sgn_cost && unsignedp))\n+\t{\n+\t  emit_insn (uns_insns);\n+\t  return uns_ret;\n+\t}\n+      emit_insn (sgn_insns);\n+      return sgn_ret;\n+    }\n+  return expand_divmod (mod_p, code, mode, op0, op1, target, unsignedp);\n+}\n+\n rtx\n expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t\t    enum expand_modifier modifier)\n@@ -9201,14 +9251,78 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t  if (!REG_P (op0))\n \t    op0 = copy_to_mode_reg (mode, op0);\n \n-\t  return REDUCE_BIT_FIELD (gen_rtx_MULT (mode, op0,\n-\t\t\t       gen_int_mode (tree_to_shwi (exp1),\n-\t\t\t\t\t     TYPE_MODE (TREE_TYPE (exp1)))));\n+\t  op1 = gen_int_mode (tree_to_shwi (exp1),\n+\t\t\t      TYPE_MODE (TREE_TYPE (exp1)));\n+\t  return REDUCE_BIT_FIELD (gen_rtx_MULT (mode, op0, op1));\n \t}\n \n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n \n+      if (SCALAR_INT_MODE_P (mode) && optimize >= 2)\n+\t{\n+\t  gimple *def_stmt0 = get_def_for_expr (treeop0, TRUNC_DIV_EXPR);\n+\t  gimple *def_stmt1 = get_def_for_expr (treeop1, TRUNC_DIV_EXPR);\n+\t  if (def_stmt0\n+\t      && !operand_equal_p (treeop1, gimple_assign_rhs2 (def_stmt0), 0))\n+\t    def_stmt0 = NULL;\n+\t  if (def_stmt1\n+\t      && !operand_equal_p (treeop0, gimple_assign_rhs2 (def_stmt1), 0))\n+\t    def_stmt1 = NULL;\n+\n+\t  if (def_stmt0 || def_stmt1)\n+\t    {\n+\t      /* X / Y * Y can be expanded as X - X % Y too.\n+\t\t Choose the cheaper sequence of those two.  */\n+\t      if (def_stmt0)\n+\t\ttreeop0 = gimple_assign_rhs1 (def_stmt0);\n+\t      else\n+\t\t{\n+\t\t  treeop1 = treeop0;\n+\t\t  treeop0 = gimple_assign_rhs1 (def_stmt1);\n+\t\t}\n+\t      expand_operands (treeop0, treeop1, subtarget, &op0, &op1,\n+\t\t\t       EXPAND_NORMAL);\n+\t      bool speed_p = optimize_insn_for_speed_p ();\n+\t      do_pending_stack_adjust ();\n+\t      start_sequence ();\n+\t      rtx divmul_ret\n+\t\t= expand_expr_divmod (TRUNC_DIV_EXPR, mode, treeop0, treeop1,\n+\t\t\t\t      op0, op1, NULL_RTX, unsignedp);\n+\t      divmul_ret = expand_mult (mode, divmul_ret, op1, target,\n+\t\t\t\t\tunsignedp);\n+\t      rtx_insn *divmul_insns = get_insns ();\n+\t      end_sequence ();\n+\t      start_sequence ();\n+\t      rtx modsub_ret\n+\t\t= expand_expr_divmod (TRUNC_MOD_EXPR, mode, treeop0, treeop1,\n+\t\t\t\t      op0, op1, NULL_RTX, unsignedp);\n+\t      this_optab = optab_for_tree_code (MINUS_EXPR, type,\n+\t\t\t\t\t\toptab_default);\n+\t      modsub_ret = expand_binop (mode, this_optab, op0, modsub_ret,\n+\t\t\t\t\t target, unsignedp, OPTAB_LIB_WIDEN);\n+\t      rtx_insn *modsub_insns = get_insns ();\n+\t      end_sequence ();\n+\t      unsigned divmul_cost = seq_cost (divmul_insns, speed_p);\n+\t      unsigned modsub_cost = seq_cost (modsub_insns, speed_p);\n+\t      /* If costs are the same then use as tie breaker the other other\n+\t\t factor.  */\n+\t      if (divmul_cost == modsub_cost)\n+\t\t{\n+\t\t  divmul_cost = seq_cost (divmul_insns, !speed_p);\n+\t\t  modsub_cost = seq_cost (modsub_insns, !speed_p);\n+\t\t}\n+\n+\t      if (divmul_cost <= modsub_cost)\n+\t\t{\n+\t\t  emit_insn (divmul_insns);\n+\t\t  return REDUCE_BIT_FIELD (divmul_ret);\n+\t\t}\n+\t      emit_insn (modsub_insns);\n+\t      return REDUCE_BIT_FIELD (modsub_ret);\n+\t    }\n+\t}\n+\n       expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n@@ -9222,61 +9336,21 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n     case CEIL_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-     {\n-       /* If this is a fixed-point operation, then we cannot use the code\n-\t  below because \"expand_divmod\" doesn't support sat/no-sat fixed-point\n-\t  divisions.   */\n-       if (ALL_FIXED_POINT_MODE_P (mode))\n-\t goto binop;\n-\n-       if (modifier == EXPAND_STACK_PARM)\n-\t target = 0;\n-       /* Possible optimization: compute the dividend with EXPAND_SUM\n-\t  then if the divisor is constant can optimize the case\n-\t  where some terms of the dividend have coeffs divisible by it.  */\n-       expand_operands (treeop0, treeop1,\n-\t\t\tsubtarget, &op0, &op1, EXPAND_NORMAL);\n-       bool mod_p = code == TRUNC_MOD_EXPR || code == FLOOR_MOD_EXPR\n-\t\t    || code == CEIL_MOD_EXPR || code == ROUND_MOD_EXPR;\n-       if (SCALAR_INT_MODE_P (mode)\n-\t   && optimize >= 2\n-\t   && get_range_pos_neg (treeop0) == 1\n-\t   && get_range_pos_neg (treeop1) == 1)\n-\t {\n-\t   /* If both arguments are known to be positive when interpreted\n-\t      as signed, we can expand it as both signed and unsigned\n-\t      division or modulo.  Choose the cheaper sequence in that case.  */\n-\t   bool speed_p = optimize_insn_for_speed_p ();\n-\t   do_pending_stack_adjust ();\n-\t   start_sequence ();\n-\t   rtx uns_ret = expand_divmod (mod_p, code, mode, op0, op1, target, 1);\n-\t   rtx_insn *uns_insns = get_insns ();\n-\t   end_sequence ();\n-\t   start_sequence ();\n-\t   rtx sgn_ret = expand_divmod (mod_p, code, mode, op0, op1, target, 0);\n-\t   rtx_insn *sgn_insns = get_insns ();\n-\t   end_sequence ();\n-\t   unsigned uns_cost = seq_cost (uns_insns, speed_p);\n-\t   unsigned sgn_cost = seq_cost (sgn_insns, speed_p);\n-\n-\t   /* If costs are the same then use as tie breaker the other\n-\t      other factor.  */\n-\t   if (uns_cost == sgn_cost)\n-\t     {\n-\t\tuns_cost = seq_cost (uns_insns, !speed_p);\n-\t\tsgn_cost = seq_cost (sgn_insns, !speed_p);\n-\t     }\n-\n-\t   if (uns_cost < sgn_cost || (uns_cost == sgn_cost && unsignedp))\n-\t     {\n-\t       emit_insn (uns_insns);\n-\t       return uns_ret;\n-\t     }\n-\t   emit_insn (sgn_insns);\n-\t   return sgn_ret;\n-\t }\n-       return expand_divmod (mod_p, code, mode, op0, op1, target, unsignedp);\n-     }\n+      /* If this is a fixed-point operation, then we cannot use the code\n+\t below because \"expand_divmod\" doesn't support sat/no-sat fixed-point\n+\t divisions.   */\n+      if (ALL_FIXED_POINT_MODE_P (mode))\n+\tgoto binop;\n+\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n+      /* Possible optimization: compute the dividend with EXPAND_SUM\n+\t then if the divisor is constant can optimize the case\n+\t where some terms of the dividend have coeffs divisible by it.  */\n+      expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n+      return expand_expr_divmod (code, mode, treeop0, treeop1, op0, op1,\n+\t\t\t\t target, unsignedp);\n+\n     case RDIV_EXPR:\n       goto binop;\n "}, {"sha": "b874e6d1e4a2dede68c75f2773e083a636eb0f58", "filename": "gcc/testsuite/gcc.target/i386/pr96696.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dcd1334b4f522352b80814513fdca902fc2a207/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96696.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dcd1334b4f522352b80814513fdca902fc2a207/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96696.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96696.c?ref=3dcd1334b4f522352b80814513fdca902fc2a207", "patch": "@@ -0,0 +1,30 @@\n+/* PR tree-optimization/96696 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-final { scan-assembler-times \"\\tidivl\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\tdivl\\t\" 2 } } */\n+/* { dg-final { scan-assembler-not \"\\ti?mull\\t\" } } */\n+\n+int\n+foo (int x, int y)\n+{\n+  return (x / y) * y;\n+}\n+\n+int\n+bar (int x, int y)\n+{\n+  return x - (x % y);\n+}\n+\n+unsigned\n+baz (unsigned x, unsigned y)\n+{\n+  return (x / y) * y;\n+}\n+\n+unsigned\n+qux (unsigned x, unsigned y)\n+{\n+  return x - (x % y);\n+}"}]}