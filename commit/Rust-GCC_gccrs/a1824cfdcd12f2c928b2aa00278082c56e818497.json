{"sha": "a1824cfdcd12f2c928b2aa00278082c56e818497", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4MjRjZmRjZDEyZjJjOTI4YjJhYTAwMjc4MDgyYzU2ZTgxODQ5Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:24:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:24:58Z"}, "message": "[29/46] Use stmt_vec_info instead of gimple stmts internally (part 2)\n\nThis second part handles the less mechnical cases, i.e. those that don't\njust involve swapping a gimple stmt for an existing stmt_vec_info.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Look up the\n\tstatement before passing it to vect_analyze_stmt.\n\t(vect_create_epilog_for_reduction): Use a stmt_vec_info to walk\n\tthe chain of phi vector definitions.  Track the exit phi via its\n\tstmt_vec_info.\n\t(vectorizable_reduction): Set cond_stmt_vinfo directly from the\n\tSTMT_VINFO_REDUC_DEF.\n\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain): Use\n\tstmt_vec_infos to handle the statement chains.\n\t(vect_get_slp_defs): Record the first statement in the node\n\tusing a stmt_vec_info.\n\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Look up\n\tstatements here and pass their stmt_vec_info down to subroutines.\n\t(vect_init_vector_1): Hoist call to vinfo_for_stmt and pass it\n\tdown to vect_finish_stmt_generation.\n\t(vect_init_vector, vect_get_vec_defs, vect_finish_replace_stmt)\n\t(vect_finish_stmt_generation): Call vinfo_for_stmt and pass\n\tstmt_vec_infos to subroutines.\n\t(vect_remove_stores): Use stmt_vec_infos to handle the statement\n\tchains.\n\nFrom-SVN: r263144", "tree": {"sha": "20848e71d439014d733475f0e453582eedbef5c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20848e71d439014d733475f0e453582eedbef5c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1824cfdcd12f2c928b2aa00278082c56e818497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1824cfdcd12f2c928b2aa00278082c56e818497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1824cfdcd12f2c928b2aa00278082c56e818497", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1824cfdcd12f2c928b2aa00278082c56e818497/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86a91c0a7d39103bc26f6a9f6cd0b329c9027161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a91c0a7d39103bc26f6a9f6cd0b329c9027161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a91c0a7d39103bc26f6a9f6cd0b329c9027161"}], "stats": {"total": 135, "additions": 80, "deletions": 55}, "files": [{"sha": "c697e70ec0d538f42c0e242989a5991de91ea0da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1824cfdcd12f2c928b2aa00278082c56e818497", "patch": "@@ -1,3 +1,26 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Look up the\n+\tstatement before passing it to vect_analyze_stmt.\n+\t(vect_create_epilog_for_reduction): Use a stmt_vec_info to walk\n+\tthe chain of phi vector definitions.  Track the exit phi via its\n+\tstmt_vec_info.\n+\t(vectorizable_reduction): Set cond_stmt_vinfo directly from the\n+\tSTMT_VINFO_REDUC_DEF.\n+\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain): Use\n+\tstmt_vec_infos to handle the statement chains.\n+\t(vect_get_slp_defs): Record the first statement in the node\n+\tusing a stmt_vec_info.\n+\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Look up\n+\tstatements here and pass their stmt_vec_info down to subroutines.\n+\t(vect_init_vector_1): Hoist call to vinfo_for_stmt and pass it\n+\tdown to vect_finish_stmt_generation.\n+\t(vect_init_vector, vect_get_vec_defs, vect_finish_replace_stmt)\n+\t(vect_finish_stmt_generation): Call vinfo_for_stmt and pass\n+\tstmt_vec_infos to subroutines.\n+\t(vect_remove_stores): Use stmt_vec_infos to handle the statement\n+\tchains.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences):"}, {"sha": "33e49c99d7f64d2905ac5828d797c1e2a50e64b4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a1824cfdcd12f2c928b2aa00278082c56e818497", "patch": "@@ -1629,8 +1629,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n         {\n \t  gimple *stmt = gsi_stmt (si);\n \t  if (!gimple_clobber_p (stmt)\n-\t      && !vect_analyze_stmt (stmt, &need_to_vectorize, NULL, NULL,\n-\t\t\t\t     &cost_vec))\n+\t      && !vect_analyze_stmt (loop_vinfo->lookup_stmt (stmt),\n+\t\t\t\t     &need_to_vectorize,\n+\t\t\t\t     NULL, NULL, &cost_vec))\n \t    return false;\n         }\n     } /* bbs */\n@@ -4832,11 +4833,11 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       tree first_vect = PHI_RESULT (new_phis[0]);\n       gassign *new_vec_stmt = NULL;\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      gimple *next_phi = new_phis[0];\n+      stmt_vec_info next_phi_info = loop_vinfo->lookup_stmt (new_phis[0]);\n       for (int k = 1; k < ncopies; ++k)\n \t{\n-\t  next_phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next_phi));\n-\t  tree second_vect = PHI_RESULT (next_phi);\n+\t  next_phi_info = STMT_VINFO_RELATED_STMT (next_phi_info);\n+\t  tree second_vect = PHI_RESULT (next_phi_info->stmt);\n           tree tem = make_ssa_name (vec_dest, new_vec_stmt);\n           new_vec_stmt = gimple_build_assign (tem, code,\n \t\t\t\t\t      first_vect, second_vect);\n@@ -5573,11 +5574,12 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   else\n     ratio = 1;\n \n+  stmt_vec_info epilog_stmt_info = NULL;\n   for (k = 0; k < group_size; k++)\n     {\n       if (k % ratio == 0)\n         {\n-          epilog_stmt = new_phis[k / ratio];\n+\t  epilog_stmt_info = loop_vinfo->lookup_stmt (new_phis[k / ratio]);\n \t  reduction_phi_info = reduction_phis[k / ratio];\n \t  if (double_reduc)\n \t    inner_phi = inner_phis[k / ratio];\n@@ -5623,8 +5625,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t      if (double_reduc)\n \t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo) = inner_phi;\n \t      else\n-\t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo)\n-\t\t  = vinfo_for_stmt (epilog_stmt);\n+\t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo) = epilog_stmt_info;\n               if (!double_reduc\n                   || STMT_VINFO_DEF_TYPE (exit_phi_vinfo)\n                       != vect_double_reduction_def)\n@@ -6070,7 +6071,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   optab optab;\n   tree new_temp = NULL_TREE;\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n-  gimple *cond_reduc_def_stmt = NULL;\n+  stmt_vec_info cond_stmt_vinfo = NULL;\n   enum tree_code cond_reduc_op_code = ERROR_MARK;\n   tree scalar_type;\n   bool is_simple_use;\n@@ -6348,7 +6349,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      && is_nonwrapping_integer_induction (def_stmt_info, loop))\n \t    {\n \t      cond_reduc_dt = dt;\n-\t      cond_reduc_def_stmt = def_stmt_info;\n+\t      cond_stmt_vinfo = def_stmt_info;\n \t    }\n \t}\n     }\n@@ -6454,7 +6455,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n       else if (cond_reduc_dt == vect_induction_def)\n \t{\n-\t  stmt_vec_info cond_stmt_vinfo = vinfo_for_stmt (cond_reduc_def_stmt);\n \t  tree base\n \t    = STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED (cond_stmt_vinfo);\n \t  tree step = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (cond_stmt_vinfo);"}, {"sha": "cce6afa89c1a82f8aabd9f8f63dd335d0167398e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a1824cfdcd12f2c928b2aa00278082c56e818497", "patch": "@@ -201,21 +201,23 @@ vect_free_oprnd_info (vec<slp_oprnd_info> &oprnds_info)\n int\n vect_get_place_in_interleaving_chain (gimple *stmt, gimple *first_stmt)\n {\n-  gimple *next_stmt = first_stmt;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info first_stmt_info = vinfo_for_stmt (first_stmt);\n+  stmt_vec_info next_stmt_info = first_stmt_info;\n   int result = 0;\n \n-  if (first_stmt != DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (first_stmt_info != DR_GROUP_FIRST_ELEMENT (stmt_info))\n     return -1;\n \n   do\n     {\n-      if (next_stmt == stmt)\n+      if (next_stmt_info == stmt_info)\n \treturn result;\n-      next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n-      if (next_stmt)\n-\tresult += DR_GROUP_GAP (vinfo_for_stmt (next_stmt));\n+      next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n+      if (next_stmt_info)\n+\tresult += DR_GROUP_GAP (next_stmt_info);\n     }\n-  while (next_stmt);\n+  while (next_stmt_info);\n \n   return -1;\n }\n@@ -3577,7 +3579,6 @@ void\n vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n \t\t   vec<vec<tree> > *vec_oprnds)\n {\n-  gimple *first_stmt;\n   int number_of_vects = 0, i;\n   unsigned int child_index = 0;\n   HOST_WIDE_INT lhs_size_unit, rhs_size_unit;\n@@ -3586,7 +3587,7 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n   tree oprnd;\n   bool vectorized_defs;\n \n-  first_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n+  stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n   FOR_EACH_VEC_ELT (ops, i, oprnd)\n     {\n       /* For each operand we check if it has vectorized definitions in a child\n@@ -3637,8 +3638,8 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n                  vect_schedule_slp_instance (), fix it by replacing LHS with\n                  RHS, if necessary.  See vect_get_smallest_scalar_type () for\n                  details.  */\n-              vect_get_smallest_scalar_type (first_stmt, &lhs_size_unit,\n-                                             &rhs_size_unit);\n+\t      vect_get_smallest_scalar_type (first_stmt_info, &lhs_size_unit,\n+\t\t\t\t\t     &rhs_size_unit);\n               if (rhs_size_unit != lhs_size_unit)\n                 {\n                   number_of_vects *= rhs_size_unit;"}, {"sha": "1a4cfd7f2fa952be9ad24ae93c6895526fe13ff7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1824cfdcd12f2c928b2aa00278082c56e818497/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a1824cfdcd12f2c928b2aa00278082c56e818497", "patch": "@@ -622,7 +622,6 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   unsigned int i;\n   stmt_vec_info stmt_vinfo;\n   basic_block bb;\n-  gimple *phi;\n   bool live_p;\n   enum vect_relevant relevant;\n \n@@ -636,27 +635,27 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       bb = bbs[i];\n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  phi = gsi_stmt (si);\n+\t  stmt_vec_info phi_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: phi relevant? \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi_info->stmt, 0);\n \t    }\n \n-\t  if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n-\t    vect_mark_relevant (&worklist, phi, relevant, live_p);\n+\t  if (vect_stmt_relevant_p (phi_info, loop_vinfo, &relevant, &live_p))\n+\t    vect_mark_relevant (&worklist, phi_info, relevant, live_p);\n \t}\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  stmt = gsi_stmt (si);\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: stmt relevant? \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n \t    }\n \n-\t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant, &live_p))\n-\t    vect_mark_relevant (&worklist, stmt, relevant, live_p);\n+\t  if (vect_stmt_relevant_p (stmt_info, loop_vinfo, &relevant, &live_p))\n+\t    vect_mark_relevant (&worklist, stmt_info, relevant, live_p);\n \t}\n     }\n \n@@ -1350,11 +1349,11 @@ vect_get_load_cost (stmt_vec_info stmt_info, int ncopies,\n static void\n vect_init_vector_1 (gimple *stmt, gimple *new_stmt, gimple_stmt_iterator *gsi)\n {\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   if (gsi)\n-    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+    vect_finish_stmt_generation (stmt_vinfo, new_stmt, gsi);\n   else\n     {\n-      stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n       loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n \n       if (loop_vinfo)\n@@ -1404,6 +1403,7 @@ vect_init_vector_1 (gimple *stmt, gimple *new_stmt, gimple_stmt_iterator *gsi)\n tree\n vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   gimple *init_stmt;\n   tree new_temp;\n \n@@ -1427,7 +1427,7 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n \t\t  new_temp = make_ssa_name (TREE_TYPE (type));\n \t\t  init_stmt = gimple_build_assign (new_temp, COND_EXPR,\n \t\t\t\t\t\t   val, true_val, false_val);\n-\t\t  vect_init_vector_1 (stmt, init_stmt, gsi);\n+\t\t  vect_init_vector_1 (stmt_info, init_stmt, gsi);\n \t\t  val = new_temp;\n \t\t}\n \t    }\n@@ -1443,7 +1443,7 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n \t\t\t\t\t\t\t      val));\n \t      else\n \t\tinit_stmt = gimple_build_assign (new_temp, NOP_EXPR, val);\n-\t      vect_init_vector_1 (stmt, init_stmt, gsi);\n+\t      vect_init_vector_1 (stmt_info, init_stmt, gsi);\n \t      val = new_temp;\n \t    }\n \t}\n@@ -1452,7 +1452,7 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n \n   new_temp = vect_get_new_ssa_name (type, vect_simple_var, \"cst_\");\n   init_stmt = gimple_build_assign  (new_temp, val);\n-  vect_init_vector_1 (stmt, init_stmt, gsi);\n+  vect_init_vector_1 (stmt_info, init_stmt, gsi);\n   return new_temp;\n }\n \n@@ -1690,6 +1690,7 @@ vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n \t\t   vec<tree> *vec_oprnds1,\n \t\t   slp_tree slp_node)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   if (slp_node)\n     {\n       int nops = (op1 == NULL_TREE) ? 1 : 2;\n@@ -1711,13 +1712,13 @@ vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n       tree vec_oprnd;\n \n       vec_oprnds0->create (1);\n-      vec_oprnd = vect_get_vec_def_for_operand (op0, stmt);\n+      vec_oprnd = vect_get_vec_def_for_operand (op0, stmt_info);\n       vec_oprnds0->quick_push (vec_oprnd);\n \n       if (op1)\n \t{\n \t  vec_oprnds1->create (1);\n-\t  vec_oprnd = vect_get_vec_def_for_operand (op1, stmt);\n+\t  vec_oprnd = vect_get_vec_def_for_operand (op1, stmt_info);\n \t  vec_oprnds1->quick_push (vec_oprnd);\n \t}\n     }\n@@ -1760,12 +1761,13 @@ vect_finish_stmt_generation_1 (gimple *stmt, gimple *vec_stmt)\n stmt_vec_info\n vect_finish_replace_stmt (gimple *stmt, gimple *vec_stmt)\n {\n-  gcc_assert (gimple_get_lhs (stmt) == gimple_get_lhs (vec_stmt));\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  gcc_assert (gimple_get_lhs (stmt_info->stmt) == gimple_get_lhs (vec_stmt));\n \n-  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt_info->stmt);\n   gsi_replace (&gsi, vec_stmt, false);\n \n-  return vect_finish_stmt_generation_1 (stmt, vec_stmt);\n+  return vect_finish_stmt_generation_1 (stmt_info, vec_stmt);\n }\n \n /* Add VEC_STMT to the vectorized implementation of STMT and insert it\n@@ -1775,7 +1777,8 @@ stmt_vec_info\n vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n-  gcc_assert (gimple_code (stmt) != GIMPLE_LABEL);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  gcc_assert (gimple_code (stmt_info->stmt) != GIMPLE_LABEL);\n \n   if (!gsi_end_p (*gsi)\n       && gimple_has_mem_ops (vec_stmt))\n@@ -1804,7 +1807,7 @@ vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n \t}\n     }\n   gsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n-  return vect_finish_stmt_generation_1 (stmt, vec_stmt);\n+  return vect_finish_stmt_generation_1 (stmt_info, vec_stmt);\n }\n \n /* We want to vectorize a call to combined function CFN with function\n@@ -9856,23 +9859,21 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n void\n vect_remove_stores (gimple *first_stmt)\n {\n-  gimple *next = first_stmt;\n+  stmt_vec_info next_stmt_info = vinfo_for_stmt (first_stmt);\n   gimple_stmt_iterator next_si;\n \n-  while (next)\n+  while (next_stmt_info)\n     {\n-      stmt_vec_info stmt_info = vinfo_for_stmt (next);\n-\n-      stmt_vec_info tmp = DR_GROUP_NEXT_ELEMENT (stmt_info);\n-      if (is_pattern_stmt_p (stmt_info))\n-\tnext = STMT_VINFO_RELATED_STMT (stmt_info);\n+      stmt_vec_info tmp = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n+      if (is_pattern_stmt_p (next_stmt_info))\n+\tnext_stmt_info = STMT_VINFO_RELATED_STMT (next_stmt_info);\n       /* Free the attached stmt_vec_info and remove the stmt.  */\n-      next_si = gsi_for_stmt (next);\n-      unlink_stmt_vdef (next);\n+      next_si = gsi_for_stmt (next_stmt_info->stmt);\n+      unlink_stmt_vdef (next_stmt_info->stmt);\n       gsi_remove (&next_si, true);\n-      release_defs (next);\n-      free_stmt_vec_info (next);\n-      next = tmp;\n+      release_defs (next_stmt_info->stmt);\n+      free_stmt_vec_info (next_stmt_info);\n+      next_stmt_info = tmp;\n     }\n }\n "}]}