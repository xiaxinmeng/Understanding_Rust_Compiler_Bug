{"sha": "0eac6ca562274e0547e848d63835f6254bc724ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVhYzZjYTU2MjI3NGUwNTQ3ZTg0OGQ2MzgzNWY2MjU0YmM3MjRjZQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-03-01T02:24:50Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-03-01T02:24:50Z"}, "message": "re PR libfortran/47567 (Wrong output for small absolute values with F editing)\n\n2011-02-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/47567\n\t* io/write_float.def (output_float): Move handling of w = 0 to after\n\toutput rounding. Check for zero and set zero_flag accordingly. Set\n\twidth according to zero_flag. Add better comments.\n\nFrom-SVN: r170585", "tree": {"sha": "2f7c101ba68757fd005f51222f82435e62831ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f7c101ba68757fd005f51222f82435e62831ff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eac6ca562274e0547e848d63835f6254bc724ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eac6ca562274e0547e848d63835f6254bc724ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eac6ca562274e0547e848d63835f6254bc724ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eac6ca562274e0547e848d63835f6254bc724ce/comments", "author": null, "committer": null, "parents": [{"sha": "62c8d7223ed275068edfed32eb0298a9d2dc4b7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c8d7223ed275068edfed32eb0298a9d2dc4b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c8d7223ed275068edfed32eb0298a9d2dc4b7e"}], "stats": {"total": 39, "additions": 25, "deletions": 14}, "files": [{"sha": "a628fdd8ea10cd44176eb820fe13145d5c7c998b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eac6ca562274e0547e848d63835f6254bc724ce/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eac6ca562274e0547e848d63835f6254bc724ce/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0eac6ca562274e0547e848d63835f6254bc724ce", "patch": "@@ -1,3 +1,10 @@\n+2011-02-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/47567\n+\t* io/write_float.def (output_float): Move handling of w = 0 to after\n+\toutput rounding. Check for zero and set zero_flag accordingly. Set\n+\twidth according to zero_flag. Add better comments.\n+\n 2011-02-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/47778"}, {"sha": "3709b206620080016d70a844f0780ca5a2ff8878", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eac6ca562274e0547e848d63835f6254bc724ce/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eac6ca562274e0547e848d63835f6254bc724ce/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=0eac6ca562274e0547e848d63835f6254bc724ce", "patch": "@@ -109,15 +109,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \n   /* Make sure zero comes out as 0.0e0.   */\n   if (zero_flag)\n-    {\n-      e = 0;\n-      if (compile_options.sign_zero != 1)\n-\tsign = calculate_sign (dtp, 0);\n-\n-      /* Handle special cases.  */\n-      if (w == 0)\n-\tw = d + (sign != S_NONE ? 2 : 1) + (d == 0 ? 1 : 0);\n-    }\n+    e = 0;\n \n   /* Normalize the fractional component.  */\n   buffer[2] = buffer[1];\n@@ -376,15 +368,21 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   else\n     edigits = 0;\n \n-  /* Zero values always output as positive, even if the value was negative\n-     before rounding.  */\n+  /* Scan the digits string and count the number of zeros.  If we make it\n+     all the way through the loop, we know the value is zero after the\n+     rounding completed above.  */\n   for (i = 0; i < ndigits; i++)\n     {\n       if (digits[i] != '0')\n \tbreak;\n     }\n+\n+  /* To format properly, we need to know if the rounded result is zero and if\n+     so, we set the zero_flag which may have been already set for\n+     actual zero.  */\n   if (i == ndigits)\n     {\n+      zero_flag = true;\n       /* The output is zero, so set the sign according to the sign bit unless\n \t -fno-sign-zero was specified.  */\n       if (compile_options.sign_zero == 1)\n@@ -393,11 +391,17 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \tsign = calculate_sign (dtp, 0);\n     }\n \n-  /* Pick a field size if none was specified.  */\n+  /* Pick a field size if none was specified, taking into account small\n+     values that may have been rounded to zero.  */\n   if (w <= 0)\n     {\n-      w = nbefore + nzero + nafter + (sign != S_NONE ? 2 : 1);\n-      w = w == 1 ? 2 : w;\n+      if (zero_flag)\n+\tw = d + (sign != S_NONE ? 2 : 1) + (d == 0 ? 1 : 0);\n+      else\n+\t{\n+\t  w = nbefore + nzero + nafter + (sign != S_NONE ? 2 : 1);\n+\t  w = w == 1 ? 2 : w;\n+\t}\n     }\n   \n   /* Work out how much padding is needed.  */"}]}