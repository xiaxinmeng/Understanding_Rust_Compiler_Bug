{"sha": "3467ad5ce6f6e456699a44d563a7ab0bf576903b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ2N2FkNWNlNmY2ZTQ1NjY5OWE0NGQ1NjNhN2FiMGJmNTc2OTAzYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-11-10T15:32:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-11-10T15:32:32Z"}, "message": "expr.c (store_field): Remove TYPE parameter.\n\n\t* expr.c (store_field): Remove TYPE parameter.  Remove block of code\n\tdealing with BLKmode in registers.  Reimplement this support using\n\tpseudo-registers and bit-field techniques.\n\t(store_constructor_field): Remove TYPE parameter and adjust calls to\n\tstore_field.\n\t(expand_assignment): Adjust calls to store_field.  Add comment.\n\t(store_expr): Add comment.\n\t(store_constructor): Adjust calls to store_constructor_field.\n\t(expand_expr_real_2): Adjust call to store_field.\n\nFrom-SVN: r193391", "tree": {"sha": "0aa9473b8b3617587ecfad9b6ad9269f5bee34ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aa9473b8b3617587ecfad9b6ad9269f5bee34ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3467ad5ce6f6e456699a44d563a7ab0bf576903b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3467ad5ce6f6e456699a44d563a7ab0bf576903b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3467ad5ce6f6e456699a44d563a7ab0bf576903b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3467ad5ce6f6e456699a44d563a7ab0bf576903b/comments", "author": null, "committer": null, "parents": [{"sha": "35b07bb39eb39cfd09ce77642d4072765b9da2fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b07bb39eb39cfd09ce77642d4072765b9da2fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b07bb39eb39cfd09ce77642d4072765b9da2fd"}], "stats": {"total": 136, "additions": 53, "deletions": 83}, "files": [{"sha": "46f21e7ded0b8d3236777a7a752ecce5af9295b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3467ad5ce6f6e456699a44d563a7ab0bf576903b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3467ad5ce6f6e456699a44d563a7ab0bf576903b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3467ad5ce6f6e456699a44d563a7ab0bf576903b", "patch": "@@ -1,3 +1,15 @@\n+2012-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.c (store_field): Remove TYPE parameter.  Remove block of code\n+\tdealing with BLKmode in registers.  Reimplement this support using\n+\tpseudo-registers and bit-field techniques.\n+\t(store_constructor_field): Remove TYPE parameter and adjust calls to\n+\tstore_field.\n+\t(expand_assignment): Adjust calls to store_field.  Add comment.\n+\t(store_expr): Add comment.\n+\t(store_constructor): Adjust calls to store_constructor_field.\n+\t(expand_expr_real_2): Adjust call to store_field.\n+\n 2012-11-10  Vladimir Makarov  <vmakarov@redhat.com>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "cbf3a4038e8bb7138110d01076d2ef44745ddef5", "filename": "gcc/expr.c", "status": "modified", "additions": 41, "deletions": 83, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3467ad5ce6f6e456699a44d563a7ab0bf576903b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3467ad5ce6f6e456699a44d563a7ab0bf576903b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3467ad5ce6f6e456699a44d563a7ab0bf576903b", "patch": "@@ -137,12 +137,11 @@ static rtx compress_float_constant (rtx, rtx);\n static rtx get_subtarget (rtx);\n static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t     HOST_WIDE_INT, enum machine_mode,\n-\t\t\t\t     tree, tree, int, alias_set_type);\n+\t\t\t\t     tree, int, alias_set_type);\n static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\tenum machine_mode,\n-\t\t\ttree, tree, alias_set_type, bool);\n+\t\t\tenum machine_mode, tree, alias_set_type, bool);\n \n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (const_tree, const_tree);\n \n@@ -4772,15 +4771,14 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  else if (bitpos + bitsize <= mode_bitsize / 2)\n \t    result = store_field (XEXP (to_rtx, 0), bitsize, bitpos,\n \t\t\t\t  bitregion_start, bitregion_end,\n-\t\t\t\t  mode1, from, TREE_TYPE (tem),\n+\t\t\t\t  mode1, from,\n \t\t\t\t  get_alias_set (to), nontemporal);\n \t  else if (bitpos >= mode_bitsize / 2)\n \t    result = store_field (XEXP (to_rtx, 1), bitsize,\n \t\t\t\t  bitpos - mode_bitsize / 2,\n \t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  mode1, from,\n-\t\t\t\t  TREE_TYPE (tem), get_alias_set (to),\n-\t\t\t\t  nontemporal);\n+\t\t\t\t  get_alias_set (to), nontemporal);\n \t  else if (bitpos == 0 && bitsize == mode_bitsize)\n \t    {\n \t      rtx from_rtx;\n@@ -4801,8 +4799,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t      result = store_field (temp, bitsize, bitpos,\n \t\t\t\t    bitregion_start, bitregion_end,\n \t\t\t\t    mode1, from,\n-\t\t\t\t    TREE_TYPE (tem), get_alias_set (to),\n-\t\t\t\t    nontemporal);\n+\t\t\t\t    get_alias_set (to), nontemporal);\n \t      emit_move_insn (XEXP (to_rtx, 0), read_complex_part (temp, false));\n \t      emit_move_insn (XEXP (to_rtx, 1), read_complex_part (temp, true));\n \t    }\n@@ -4834,8 +4831,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t    result = store_field (to_rtx, bitsize, bitpos,\n \t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  mode1, from,\n-\t\t\t\t  TREE_TYPE (tem), get_alias_set (to),\n-\t\t\t\t  nontemporal);\n+\t\t\t\t  get_alias_set (to), nontemporal);\n \t}\n \n       if (misalignp)\n@@ -4896,6 +4892,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\t\t  int_size_in_bytes (TREE_TYPE (from)));\n       else if (GET_MODE (to_rtx) == BLKmode)\n \t{\n+\t  /* Handle calls that return BLKmode values in registers.  */\n \t  if (REG_P (value))\n \t    copy_blkmode_from_reg (to_rtx, value, TREE_TYPE (from));\n \t  else\n@@ -5246,6 +5243,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t{\n \t  if (GET_MODE (target) == BLKmode)\n \t    {\n+\t      /* Handle calls that return BLKmode values in registers.  */\n \t      if (REG_P (temp) && TREE_CODE (exp) == CALL_EXPR)\n \t\tcopy_blkmode_from_reg (target, temp, TREE_TYPE (exp));\n \t      else\n@@ -5680,7 +5678,6 @@ all_zeros_p (const_tree exp)\n \f\n /* Helper function for store_constructor.\n    TARGET, BITSIZE, BITPOS, MODE, EXP are as for store_field.\n-   TYPE is the type of the CONSTRUCTOR, not the element type.\n    CLEARED is as for store_constructor.\n    ALIAS_SET is the alias set to use for any stores.\n \n@@ -5692,8 +5689,7 @@ all_zeros_p (const_tree exp)\n static void\n store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n \t\t\t HOST_WIDE_INT bitpos, enum machine_mode mode,\n-\t\t\t tree exp, tree type, int cleared,\n-\t\t\t alias_set_type alias_set)\n+\t\t\t tree exp, int cleared, alias_set_type alias_set)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR\n       /* We can only call store_constructor recursively if the size and\n@@ -5725,8 +5721,7 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n       store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n     }\n   else\n-    store_field (target, bitsize, bitpos, 0, 0, mode, exp, type, alias_set,\n-\t\t false);\n+    store_field (target, bitsize, bitpos, 0, 0, mode, exp, alias_set, false);\n }\n \n /* Store the value of constructor EXP into the rtx TARGET.\n@@ -5897,7 +5892,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      }\n \n \t    store_constructor_field (to_rtx, bitsize, bitpos, mode,\n-\t\t\t\t     value, type, cleared,\n+\t\t\t\t     value, cleared,\n \t\t\t\t     get_alias_set (TREE_TYPE (field)));\n \t  }\n \tbreak;\n@@ -6052,7 +6047,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t  }\n \n \t\t\tstore_constructor_field\n-\t\t\t  (target, bitsize, bitpos, mode, value, type, cleared,\n+\t\t\t  (target, bitsize, bitpos, mode, value, cleared,\n \t\t\t   get_alias_set (elttype));\n \t\t      }\n \t\t  }\n@@ -6156,7 +6151,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    MEM_KEEP_ALIAS_SET_P (target) = 1;\n \t\t  }\n \t\tstore_constructor_field (target, bitsize, bitpos, mode, value,\n-\t\t\t\t\t type, cleared, get_alias_set (elttype));\n+\t\t\t\t\t cleared, get_alias_set (elttype));\n \t      }\n \t  }\n \tbreak;\n@@ -6276,9 +6271,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t  ? TYPE_MODE (TREE_TYPE (value))\n \t\t  : eltmode;\n \t\tbitpos = eltpos * elt_size;\n-\t\tstore_constructor_field (target, bitsize, bitpos,\n-\t\t\t\t\t value_mode, value, type,\n-\t\t\t\t\t cleared, alias);\n+\t\tstore_constructor_field (target, bitsize, bitpos, value_mode,\n+\t\t\t\t\t value, cleared, alias);\n \t      }\n \t  }\n \n@@ -6307,8 +6301,6 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n    Always return const0_rtx unless we have something particular to\n    return.\n \n-   TYPE is the type of the underlying object,\n-\n    ALIAS_SET is the alias set for the destination.  This value will\n    (in general) be different from that for TARGET, since TARGET is a\n    reference to the containing structure.\n@@ -6319,7 +6311,7 @@ static rtx\n store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t     unsigned HOST_WIDE_INT bitregion_start,\n \t     unsigned HOST_WIDE_INT bitregion_end,\n-\t     enum machine_mode mode, tree exp, tree type,\n+\t     enum machine_mode mode, tree exp,\n \t     alias_set_type alias_set, bool nontemporal)\n {\n   if (TREE_CODE (exp) == ERROR_MARK)\n@@ -6330,38 +6322,6 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n   if (bitsize == 0)\n     return expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  /* If we are storing into an unaligned field of an aligned union that is\n-     in a register, we may have the mode of TARGET being an integer mode but\n-     MODE == BLKmode.  In that case, get an aligned object whose size and\n-     alignment are the same as TARGET and store TARGET into it (we can avoid\n-     the store if the field being stored is the entire width of TARGET).  Then\n-     call ourselves recursively to store the field into a BLKmode version of\n-     that object.  Finally, load from the object into TARGET.  This is not\n-     very efficient in general, but should only be slightly more expensive\n-     than the otherwise-required unaligned accesses.  Perhaps this can be\n-     cleaned up later.  It's tempting to make OBJECT readonly, but it's set\n-     twice, once with emit_move_insn and once via store_field.  */\n-\n-  if (mode == BLKmode\n-      && (REG_P (target) || GET_CODE (target) == SUBREG)\n-      && TREE_CODE (exp) != CALL_EXPR)\n-    {\n-      rtx object = assign_temp (type, 1, 1);\n-      rtx blk_object = adjust_address (object, BLKmode, 0);\n-\n-      if (bitsize != (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target)))\n-\temit_move_insn (object, target);\n-\n-      store_field (blk_object, bitsize, bitpos,\n-\t\t   bitregion_start, bitregion_end,\n-\t\t   mode, exp, type, MEM_ALIAS_SET (blk_object), nontemporal);\n-\n-      emit_move_insn (target, object);\n-\n-      /* We want to return the BLKmode version of the data.  */\n-      return blk_object;\n-    }\n-\n   if (GET_CODE (target) == CONCAT)\n     {\n       /* We're storing into a struct containing a single __complex.  */\n@@ -6472,35 +6432,34 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (temp) == PARALLEL)\n \t{\n+\t  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n \t  rtx temp_target;\n-\n-\t  /* We are not supposed to have a true bitfield in this case.  */\n-\t  gcc_assert (bitsize == GET_MODE_BITSIZE (mode));\n-\n-\t  /* If we don't store at bit 0, we need an intermediate pseudo\n-\t     since emit_group_store only stores at bit 0.  */\n-\t  if (bitpos != 0)\n-\t    temp_target = gen_reg_rtx (mode);\n-\t  else\n-\t    temp_target = target;\n-\n-\t  emit_group_store (temp_target, temp, TREE_TYPE (exp),\n-\t\t\t    int_size_in_bytes (TREE_TYPE (exp)));\n-\n-\t  if (temp_target == target)\n-\t    return const0_rtx;\n-\n+\t  if (mode == BLKmode)\n+\t    mode = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);\n+\t  temp_target = gen_reg_rtx (mode);\n+\t  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);\n \t  temp = temp_target;\n \t}\n-\n-      /* Handle calls that return BLKmode values in registers.  */\n-      else if (mode == BLKmode\n-\t       && REG_P (temp)\n-\t       && TREE_CODE (exp) == CALL_EXPR)\n+      else if (mode == BLKmode)\n \t{\n-\t  rtx temp_target = gen_reg_rtx (GET_MODE (temp));\n-\t  copy_blkmode_from_reg (temp_target, temp, TREE_TYPE (exp));\n-\t  temp = temp_target;\n+\t  /* Handle calls that return BLKmode values in registers.  */\n+\t  if (REG_P (temp) && TREE_CODE (exp) == CALL_EXPR)\n+\t    {\n+\t      rtx temp_target = gen_reg_rtx (GET_MODE (temp));\n+\t      copy_blkmode_from_reg (temp_target, temp, TREE_TYPE (exp));\n+\t      temp = temp_target;\n+\t    }\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n+\t      rtx temp_target;\n+\t      mode = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);\n+\t      temp_target = gen_reg_rtx (mode);\n+\t      temp_target\n+\t        = extract_bit_field (temp, size * BITS_PER_UNIT, 0, 1,\n+\t\t\t\t     false, temp_target, mode, mode);\n+\t      temp = temp_target;\n+\t    }\n \t}\n \n       /* Store the value in the bitfield.  */\n@@ -8059,8 +8018,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t    (treeop0))\n \t\t\t\t * BITS_PER_UNIT),\n \t\t\t\t(HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),\n-\t\t\t   0, 0, 0, TYPE_MODE (valtype), treeop0,\n-\t\t\t   type, 0, false);\n+\t\t\t   0, 0, 0, TYPE_MODE (valtype), treeop0, 0, false);\n \t    }\n \n \t  /* Return the entire union.  */"}]}