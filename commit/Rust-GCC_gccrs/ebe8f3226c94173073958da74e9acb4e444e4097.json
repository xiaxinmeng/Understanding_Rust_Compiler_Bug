{"sha": "ebe8f3226c94173073958da74e9acb4e444e4097", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlOGYzMjI2Yzk0MTczMDczOTU4ZGE3NGU5YWNiNGU0NDRlNDA5Nw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2016-07-21T15:40:24Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2016-07-21T15:40:24Z"}, "message": "[Patch 2/2 ifcvt costs] Introduce a new cost model for ifcvt.\n\ngcc/\n\n\t* ifcvt.c (noce_if_info): New fields: speed_p, original_cost,\n\tmax_seq_cost.  Removed fields: then_cost, else_cost, branch_cost.\n\t(noce_conversion_profitable_p): New.\n\t(noce_try_store_flag_constants): Use it.\n\t(noce_try_addcc): Likewise.\n\t(noce_try_store_flag_mask): Likewise.\n\t(noce_try_cmove): Likewise.\n\t(noce_try_cmove_arith): Likewise.\n\t(bb_valid_for_noce_process_p): Add to the cost parameter rather than\n\toverwriting it.\n\t(noce_convert_multiple_sets): Move cost model to here, from...\n\t(bb_ok_for_noce_convert_multiple_sets) ...here.\n\t(noce_process_if_block): Update calls for above changes.\n\t(noce_find_if_block): Record new noce_if_info parameters.\n\ngcc/testsuite/\n\n\t* gcc.dg/ifcvt-2.c: Use parameter to guide if-conversion heuristics.\n\t* gcc.dg/ifcvt-3.c: Use parameter to guide if-conversion heuristics.\n\t* gcc.dg/pr68435.c: Use parameter to guide if-conversion heuristics.\n\t* gcc.dg/ifcvt-4.c: Use parameter to guide if-conversion heuristics.\n\t* gcc.dg/ifcvt-5.c: Use parameter to guide if-conversion heuristics.\n\nFrom-SVN: r238594", "tree": {"sha": "94d49a3e300111ba52839793deb9962c71231c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94d49a3e300111ba52839793deb9962c71231c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebe8f3226c94173073958da74e9acb4e444e4097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe8f3226c94173073958da74e9acb4e444e4097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebe8f3226c94173073958da74e9acb4e444e4097", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe8f3226c94173073958da74e9acb4e444e4097/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e914c11a99833c265aef1256fdd113129d4b8a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e914c11a99833c265aef1256fdd113129d4b8a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e914c11a99833c265aef1256fdd113129d4b8a0d"}], "stats": {"total": 226, "additions": 127, "deletions": 99}, "files": [{"sha": "602c7b8eeaaee62af36ef1dbc9bafafd6db42167", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -1,3 +1,20 @@\n+2016-07-21  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* ifcvt.c (noce_if_info): New fields: speed_p, original_cost,\n+\tmax_seq_cost.  Removed fields: then_cost, else_cost, branch_cost.\n+\t(noce_conversion_profitable_p): New.\n+\t(noce_try_store_flag_constants): Use it.\n+\t(noce_try_addcc): Likewise.\n+\t(noce_try_store_flag_mask): Likewise.\n+\t(noce_try_cmove): Likewise.\n+\t(noce_try_cmove_arith): Likewise.\n+\t(bb_valid_for_noce_process_p): Add to the cost parameter rather than\n+\toverwriting it.\n+\t(noce_convert_multiple_sets): Move cost model to here, from...\n+\t(bb_ok_for_noce_convert_multiple_sets) ...here.\n+\t(noce_process_if_block): Update calls for above changes.\n+\t(noce_find_if_block): Record new noce_if_info parameters.\n+\n 2016-07-21  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* target.def (max_noce_ifcvt_seq_cost): New."}, {"sha": "ecdfc2e2bf3947859e57f4cb2f492c705ac6fae9", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 95, "deletions": 93, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -807,12 +807,17 @@ struct noce_if_info\n   bool then_simple;\n   bool else_simple;\n \n-  /* The total rtx cost of the instructions in then_bb and else_bb.  */\n-  unsigned int then_cost;\n-  unsigned int else_cost;\n+  /* True if we're optimisizing the control block for speed, false if\n+     we're optimizing for size.  */\n+  bool speed_p;\n \n-  /* Estimated cost of the particular branch instruction.  */\n-  unsigned int branch_cost;\n+  /* The combined cost of COND, JUMP and the costs for THEN_BB and\n+     ELSE_BB.  */\n+  unsigned int original_cost;\n+\n+  /* Maximum permissible cost for the unconditional sequence we should\n+     generate to replace this branch.  */\n+  unsigned int max_seq_cost;\n \n   /* The name of the noce transform that succeeded in if-converting\n      this structure.  Used for debugging.  */\n@@ -835,6 +840,25 @@ static int noce_try_minmax (struct noce_if_info *);\n static int noce_try_abs (struct noce_if_info *);\n static int noce_try_sign_mask (struct noce_if_info *);\n \n+/* Return TRUE if SEQ is a good candidate as a replacement for the\n+   if-convertible sequence described in IF_INFO.  */\n+\n+inline static bool\n+noce_conversion_profitable_p (rtx_insn *seq, struct noce_if_info *if_info)\n+{\n+  bool speed_p = if_info->speed_p;\n+\n+  /* Cost up the new sequence.  */\n+  unsigned int cost = seq_cost (seq, speed_p);\n+\n+  /* When compiling for size, we can make a reasonably accurately guess\n+     at the size growth.  */\n+  if (!speed_p)\n+    return cost <= if_info->original_cost;\n+  else\n+    return cost <= if_info->max_seq_cost;\n+}\n+\n /* Helper function for noce_try_store_flag*.  */\n \n static rtx\n@@ -1319,8 +1343,7 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n          registers where we handle overlap below.  */\n       && (REG_P (XEXP (a, 0))\n \t  || (noce_operand_ok (XEXP (a, 0))\n-\t      && ! reg_overlap_mentioned_p (if_info->x, XEXP (a, 0))))\n-      && if_info->branch_cost >= 2)\n+\t      && ! reg_overlap_mentioned_p (if_info->x, XEXP (a, 0)))))\n     {\n       common = XEXP (a, 0);\n       a = XEXP (a, 1);\n@@ -1393,22 +1416,24 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \t  else\n \t    gcc_unreachable ();\n \t}\n+      /* Is this (cond) ? 2^n : 0?  */\n       else if (ifalse == 0 && exact_log2 (itrue) >= 0\n-\t       && (STORE_FLAG_VALUE == 1\n-\t\t   || if_info->branch_cost >= 2))\n+\t       && STORE_FLAG_VALUE == 1)\n \tnormalize = 1;\n+      /* Is this (cond) ? 0 : 2^n?  */\n       else if (itrue == 0 && exact_log2 (ifalse) >= 0 && can_reverse\n-\t       && (STORE_FLAG_VALUE == 1 || if_info->branch_cost >= 2))\n+\t       && STORE_FLAG_VALUE == 1)\n \t{\n \t  normalize = 1;\n \t  reversep = true;\n \t}\n+      /* Is this (cond) ? -1 : x?  */\n       else if (itrue == -1\n-\t       && (STORE_FLAG_VALUE == -1\n-\t\t   || if_info->branch_cost >= 2))\n+\t       && STORE_FLAG_VALUE == -1)\n \tnormalize = -1;\n+      /* Is this (cond) ? x : -1?  */\n       else if (ifalse == -1 && can_reverse\n-\t       && (STORE_FLAG_VALUE == -1 || if_info->branch_cost >= 2))\n+\t       && STORE_FLAG_VALUE == -1)\n \t{\n \t  normalize = -1;\n \t  reversep = true;\n@@ -1497,7 +1522,7 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \tnoce_emit_move_insn (if_info->x, target);\n \n       seq = end_ifcvt_sequence (if_info);\n-      if (!seq)\n+      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n \treturn FALSE;\n \n       emit_insn_before_setloc (seq, if_info->jump,\n@@ -1551,7 +1576,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = end_ifcvt_sequence (if_info);\n-\t      if (!seq)\n+\t      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n@@ -1564,10 +1589,10 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t}\n \n       /* If that fails, construct conditional increment or decrement using\n-\t setcc.  */\n-      if (if_info->branch_cost >= 2\n-\t  && (XEXP (if_info->a, 1) == const1_rtx\n-\t      || XEXP (if_info->a, 1) == constm1_rtx))\n+\t setcc.  We're changing a branch and an increment to a comparison and\n+\t an ADD/SUB.  */\n+      if (XEXP (if_info->a, 1) == const1_rtx\n+\t  || XEXP (if_info->a, 1) == constm1_rtx)\n         {\n \t  start_sequence ();\n \t  if (STORE_FLAG_VALUE == INTVAL (XEXP (if_info->a, 1)))\n@@ -1593,7 +1618,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = end_ifcvt_sequence (if_info);\n-\t      if (!seq)\n+\t      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n@@ -1621,15 +1646,14 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n     return FALSE;\n \n   reversep = 0;\n-  if ((if_info->branch_cost >= 2\n-       || STORE_FLAG_VALUE == -1)\n-      && ((if_info->a == const0_rtx\n-\t   && rtx_equal_p (if_info->b, if_info->x))\n-\t  || ((reversep = (reversed_comparison_code (if_info->cond,\n-\t\t\t\t\t\t     if_info->jump)\n-\t\t\t   != UNKNOWN))\n-\t      && if_info->b == const0_rtx\n-\t      && rtx_equal_p (if_info->a, if_info->x))))\n+\n+  if ((if_info->a == const0_rtx\n+       && rtx_equal_p (if_info->b, if_info->x))\n+      || ((reversep = (reversed_comparison_code (if_info->cond,\n+\t\t\t\t\t\t if_info->jump)\n+\t\t       != UNKNOWN))\n+\t  && if_info->b == const0_rtx\n+\t  && rtx_equal_p (if_info->a, if_info->x)))\n     {\n       start_sequence ();\n       target = noce_emit_store_flag (if_info,\n@@ -1643,22 +1667,11 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n \n       if (target)\n \t{\n-\t  int old_cost, new_cost, insn_cost;\n-\t  int speed_p;\n-\n \t  if (target != if_info->x)\n \t    noce_emit_move_insn (if_info->x, target);\n \n \t  seq = end_ifcvt_sequence (if_info);\n-\t  if (!seq)\n-\t    return FALSE;\n-\n-\t  speed_p = optimize_bb_for_speed_p (BLOCK_FOR_INSN (if_info->insn_a));\n-\t  insn_cost = insn_rtx_cost (PATTERN (if_info->insn_a), speed_p);\n-\t  old_cost = COSTS_N_INSNS (if_info->branch_cost) + insn_cost;\n-\t  new_cost = seq_cost (seq, speed_p);\n-\n-\t  if (new_cost > old_cost)\n+\t  if (!seq || !noce_conversion_profitable_p (seq, if_info))\n \t    return FALSE;\n \n \t  emit_insn_before_setloc (seq, if_info->jump,\n@@ -1827,9 +1840,7 @@ noce_try_cmove (struct noce_if_info *if_info)\n \t we don't know about, so give them a chance before trying this\n \t approach.  */\n       else if (!targetm.have_conditional_execution ()\n-\t\t&& CONST_INT_P (if_info->a) && CONST_INT_P (if_info->b)\n-\t\t&& ((if_info->branch_cost >= 2 && STORE_FLAG_VALUE == -1)\n-\t\t    || if_info->branch_cost >= 3))\n+\t\t&& CONST_INT_P (if_info->a) && CONST_INT_P (if_info->b))\n \t{\n \t  machine_mode mode = GET_MODE (if_info->x);\n \t  HOST_WIDE_INT ifalse = INTVAL (if_info->a);\n@@ -1865,7 +1876,7 @@ noce_try_cmove (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = end_ifcvt_sequence (if_info);\n-\t      if (!seq)\n+\t      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n@@ -2078,11 +2089,9 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n      conditional on their addresses followed by a load.  Don't do this\n      early because it'll screw alias analysis.  Note that we've\n      already checked for no side effects.  */\n-  /* ??? FIXME: Magic number 5.  */\n   if (cse_not_expected\n       && MEM_P (a) && MEM_P (b)\n-      && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b)\n-      && if_info->branch_cost >= 5)\n+      && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b))\n     {\n       machine_mode address_mode = get_address_mode (a);\n \n@@ -2114,23 +2123,6 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   if (!can_conditionally_move_p (x_mode))\n     return FALSE;\n \n-  unsigned int then_cost;\n-  unsigned int else_cost;\n-  if (insn_a)\n-    then_cost = if_info->then_cost;\n-  else\n-    then_cost = 0;\n-\n-  if (insn_b)\n-    else_cost = if_info->else_cost;\n-  else\n-    else_cost = 0;\n-\n-  /* We're going to execute one of the basic blocks anyway, so\n-     bail out if the most expensive of the two blocks is unacceptable.  */\n-  if (MAX (then_cost, else_cost) > COSTS_N_INSNS (if_info->branch_cost))\n-    return FALSE;\n-\n   /* Possibly rearrange operands to make things come out more natural.  */\n   if (reversed_comparison_code (if_info->cond, if_info->jump) != UNKNOWN)\n     {\n@@ -2319,7 +2311,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n     noce_emit_move_insn (x, target);\n \n   ifcvt_seq = end_ifcvt_sequence (if_info);\n-  if (!ifcvt_seq)\n+  if (!ifcvt_seq || !noce_conversion_profitable_p (ifcvt_seq, if_info))\n     return FALSE;\n \n   emit_insn_before_setloc (ifcvt_seq, if_info->jump,\n@@ -2805,7 +2797,7 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n      && (if_info->insn_b == NULL_RTX\n \t || BLOCK_FOR_INSN (if_info->insn_b) == if_info->test_bb));\n   if (!(t_unconditional\n-\t|| (set_src_cost (t, mode, optimize_bb_for_speed_p (if_info->test_bb))\n+\t|| (set_src_cost (t, mode, if_info->speed_p)\n \t    < COSTS_N_INSNS (2))))\n     return FALSE;\n \n@@ -3034,8 +3026,8 @@ contains_mem_rtx_p (rtx x)\n    x := a and all previous computations\n    in TEST_BB don't produce any values that are live after TEST_BB.\n    In other words, all the insns in TEST_BB are there only\n-   to compute a value for x.  Put the rtx cost of the insns\n-   in TEST_BB into COST.  Record whether TEST_BB is a single simple\n+   to compute a value for x.  Add the rtx cost of the insns\n+   in TEST_BB to COST.  Record whether TEST_BB is a single simple\n    set instruction in SIMPLE_P.  */\n \n static bool\n@@ -3067,7 +3059,7 @@ bb_valid_for_noce_process_p (basic_block test_bb, rtx cond,\n   if (first_insn == last_insn)\n     {\n       *simple_p = noce_operand_ok (SET_DEST (first_set));\n-      *cost = insn_rtx_cost (first_set, speed_p);\n+      *cost += insn_rtx_cost (first_set, speed_p);\n       return *simple_p;\n     }\n \n@@ -3114,7 +3106,7 @@ bb_valid_for_noce_process_p (basic_block test_bb, rtx cond,\n     goto free_bitmap_and_fail;\n \n   BITMAP_FREE (test_bb_temps);\n-  *cost = potential_cost;\n+  *cost += potential_cost;\n   *simple_p = false;\n   return true;\n \n@@ -3290,9 +3282,15 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n   for (int i = 0; i < count; i++)\n     noce_emit_move_insn (targets[i], temporaries[i]);\n \n-  /* Actually emit the sequence.  */\n+  /* Actually emit the sequence if it isn't too expensive.  */\n   rtx_insn *seq = get_insns ();\n \n+  if (!noce_conversion_profitable_p (seq, if_info))\n+    {\n+      end_sequence ();\n+      return FALSE;\n+    }\n+\n   for (insn = seq; insn; insn = NEXT_INSN (insn))\n     set_used_flags (insn);\n \n@@ -3342,22 +3340,16 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \n /* Return true iff basic block TEST_BB is comprised of only\n    (SET (REG) (REG)) insns suitable for conversion to a series\n-   of conditional moves.  FORNOW: Use II to find the expected cost of\n-   the branch into/over TEST_BB.\n-\n-   TODO: This creates an implicit \"magic number\" for branch_cost.\n-   II->branch_cost now guides the maximum number of set instructions in\n-   a basic block which is considered profitable to completely\n-   if-convert.  */\n+   of conditional moves.  Also check that we have more than one set\n+   (other routines can handle a single set better than we would), and\n+   fewer than PARAM_MAX_RTL_IF_CONVERSION_INSNS sets.  */\n \n static bool\n-bb_ok_for_noce_convert_multiple_sets (basic_block test_bb,\n-\t\t\t\t      struct noce_if_info *ii)\n+bb_ok_for_noce_convert_multiple_sets (basic_block test_bb)\n {\n   rtx_insn *insn;\n   unsigned count = 0;\n   unsigned param = PARAM_VALUE (PARAM_MAX_RTL_IF_CONVERSION_INSNS);\n-  unsigned limit = MIN (ii->branch_cost, param);\n \n   FOR_BB_INSNS (test_bb, insn)\n     {\n@@ -3393,14 +3385,15 @@ bb_ok_for_noce_convert_multiple_sets (basic_block test_bb,\n       if (!can_conditionally_move_p (GET_MODE (dest)))\n \treturn false;\n \n-      /* FORNOW: Our cost model is a count of the number of instructions we\n-\t would if-convert.  This is suboptimal, and should be improved as part\n-\t of a wider rework of branch_cost.  */\n-      if (++count > limit)\n-\treturn false;\n+      count++;\n     }\n \n-  return count > 1;\n+  /* If we would only put out one conditional move, the other strategies\n+     this pass tries are better optimized and will be more appropriate.\n+     Some targets want to strictly limit the number of conditional moves\n+     that are emitted, they set this through PARAM, we need to respect\n+     that.  */\n+  return count > 1 && count <= param;\n }\n \n /* Given a simple IF-THEN-JOIN or IF-THEN-ELSE-JOIN block, attempt to convert\n@@ -3436,7 +3429,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n   if (!else_bb\n       && HAVE_conditional_move\n       && !HAVE_cc0\n-      && bb_ok_for_noce_convert_multiple_sets (then_bb, if_info))\n+      && bb_ok_for_noce_convert_multiple_sets (then_bb))\n     {\n       if (noce_convert_multiple_sets (if_info))\n \t{\n@@ -3447,12 +3440,12 @@ noce_process_if_block (struct noce_if_info *if_info)\n \t}\n     }\n \n-  if (! bb_valid_for_noce_process_p (then_bb, cond, &if_info->then_cost,\n+  if (! bb_valid_for_noce_process_p (then_bb, cond, &if_info->original_cost,\n \t\t\t\t    &if_info->then_simple))\n     return false;\n \n   if (else_bb\n-      && ! bb_valid_for_noce_process_p (else_bb, cond, &if_info->else_cost,\n+      && ! bb_valid_for_noce_process_p (else_bb, cond, &if_info->original_cost,\n \t\t\t\t      &if_info->else_simple))\n     return false;\n \n@@ -3983,6 +3976,7 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n   rtx cond;\n   rtx_insn *cond_earliest;\n   struct noce_if_info if_info;\n+  bool speed_p = optimize_bb_for_speed_p (test_bb);\n \n   /* We only ever should get here before reload.  */\n   gcc_assert (!reload_completed);\n@@ -4074,8 +4068,16 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n   if_info.cond_earliest = cond_earliest;\n   if_info.jump = jump;\n   if_info.then_else_reversed = then_else_reversed;\n-  if_info.branch_cost = BRANCH_COST (optimize_bb_for_speed_p (test_bb),\n-\t\t\t\t     predictable_edge_p (then_edge));\n+  if_info.speed_p = speed_p;\n+  if_info.max_seq_cost\n+    = targetm.max_noce_ifcvt_seq_cost (then_edge);\n+  /* We'll add in the cost of THEN_BB and ELSE_BB later, when we check\n+     that they are valid to transform.  We can't easily get back to the insn\n+     for COND (and it may not exist if we had to canonicalize to get COND),\n+     and jump_insns are always given a cost of 1 by seq_cost, so treat\n+     both instructions as having cost COSTS_N_INSNS (1).  */\n+  if_info.original_cost = COSTS_N_INSNS (2);\n+\n \n   /* Do the real work.  */\n "}, {"sha": "d0b0c1d165dc02537f8e550091094f061aa307d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -1,3 +1,11 @@\n+2016-07-21  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.dg/ifcvt-2.c: Use parameter to guide if-conversion heuristics.\n+\t* gcc.dg/ifcvt-3.c: Use parameter to guide if-conversion heuristics.\n+\t* gcc.dg/pr68435.c: Use parameter to guide if-conversion heuristics.\n+\t* gcc.dg/ifcvt-4.c: Use parameter to guide if-conversion heuristics.\n+\t* gcc.dg/ifcvt-5.c: Use parameter to guide if-conversion heuristics.\n+\n 2016-07-21  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71947"}, {"sha": "73e0dccdce3efcc943ebc9ab2dfebbc1a8165318", "filename": "gcc/testsuite/gcc.dg/ifcvt-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-2.c?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile { target aarch64*-*-* x86_64-*-* } } */\n-/* { dg-options \"-fdump-rtl-ce1 -O2\" } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2 --param max-rtl-if-conversion-unpredictable-cost=100\" } */\n \n \n typedef unsigned char uint8_t;"}, {"sha": "b250bc15e0806776ee10bdbc23a3446d9a19a19f", "filename": "gcc/testsuite/gcc.dg/ifcvt-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-3.c?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile { target { { aarch64*-*-* i?86-*-* x86_64-*-* } && lp64 } } } */\n-/* { dg-options \"-fdump-rtl-ce1 -O2\" } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2 --param max-rtl-if-conversion-unpredictable-cost=100\" } */\n \n typedef long long s64;\n "}, {"sha": "0d1671c302a09db3638e4a85dc826c3a9e4a0dc8", "filename": "gcc/testsuite/gcc.dg/ifcvt-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-rtl-ce1 -O2 --param max-rtl-if-conversion-insns=3\" } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2 --param max-rtl-if-conversion-insns=3 --param max-rtl-if-conversion-unpredictable-cost=100\" } */\n /* { dg-additional-options \"-misel\" { target { powerpc*-*-* } } } */\n /* { dg-skip-if \"Multiple set if-conversion not guaranteed on all subtargets\" { \"arm*-*-* hppa*64*-*-* visium-*-*\" } }  */\n "}, {"sha": "d2a947646afcc369f741712b8bae4dbf42698d1d", "filename": "gcc/testsuite/gcc.dg/ifcvt-5.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-5.c?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -1,7 +1,8 @@\n /* Check that multi-insn if-conversion is not done if the override\n-   parameter would not allow it.  */\n+   parameter would not allow it.  Set the cost parameter very high\n+   to ensure that the limiting factor is actually the count parameter.  */\n \n-/* { dg-options \"-fdump-rtl-ce1 -O2 --param max-rtl-if-conversion-insns=1\" } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2 --param max-rtl-if-conversion-insns=1 --param max-rtl-if-conversion-unpredictable-cost=200\" } */\n \n typedef int word __attribute__((mode(word)));\n "}, {"sha": "f86b7f8da1629e93de66eab637d3c262ecd8ec4e", "filename": "gcc/testsuite/gcc.dg/pr68435.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fpr68435.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe8f3226c94173073958da74e9acb4e444e4097/gcc%2Ftestsuite%2Fgcc.dg%2Fpr68435.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr68435.c?ref=ebe8f3226c94173073958da74e9acb4e444e4097", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile { target aarch64*-*-* x86_64-*-* } } */\n-/* { dg-options \"-fdump-rtl-ce1 -O2 -w\" } */\n+/* { dg-options \"-fdump-rtl-ce1 -O2 -w --param max-rtl-if-conversion-unpredictable-cost=100\" } */\n \n typedef struct cpp_reader cpp_reader;\n enum cpp_ttype"}]}