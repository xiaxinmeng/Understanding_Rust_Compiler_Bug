{"sha": "204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0ZDJjMDNhY2ZmNGJmM2I3M2NiNWQyYzk1NzhiNTBjMmFhYzcwMw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-10-26T16:51:37Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-10-26T16:51:37Z"}, "message": "Introduce emit_frame_chain\n\nThe current frame code combines the separate concepts of a frame chain\n(saving old FP,LR in a record and pointing new FP to it) and a frame\npointer used to access locals.  Add emit_frame_chain to the aarch64_frame\ndescriptor and use it in the prolog and epilog code.  For now just\ninitialize it as before, so generated code is identical.\n\nAlso correctly set EXIT_IGNORE_STACK.  The current AArch64 epilog code \nrestores SP from FP if alloca is used.  If a frame pointer is used but\nthere is no alloca, SP must remain valid for the epilog to work correctly.\n\n    gcc/\n\t* config/aarch64/aarch64.h (EXIT_IGNORE_STACK): Set if alloca is used.\n\t(aarch64_frame): Add emit_frame_chain boolean.\n\t* config/aarch64/aarch64.c (aarch64_frame_pointer_required)\n\tMove eh_return case to aarch64_layout_frame.\n\t(aarch64_layout_frame): Initialize emit_frame_chain.\n\t(aarch64_expand_prologue): Use emit_frame_chain.\n\nFrom-SVN: r254114", "tree": {"sha": "1d3459af6eb9916a16799faec9f19d759da71e41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d3459af6eb9916a16799faec9f19d759da71e41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204d2c03acff4bf3b73cb5d2c9578b50c2aac703/comments", "author": null, "committer": null, "parents": [{"sha": "957f5feacf2f4c7916e0137ad95d2d9559e06fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/957f5feacf2f4c7916e0137ad95d2d9559e06fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/957f5feacf2f4c7916e0137ad95d2d9559e06fa4"}], "stats": {"total": 37, "additions": 25, "deletions": 12}, "files": [{"sha": "81e5bba244e2d098c322193a664e898ea7141420", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204d2c03acff4bf3b73cb5d2c9578b50c2aac703/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204d2c03acff4bf3b73cb5d2c9578b50c2aac703/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "patch": "@@ -1,3 +1,12 @@\n+2017-10-26  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.h (EXIT_IGNORE_STACK): Set if alloca is used.\n+\t(aarch64_frame): Add emit_frame_chain boolean.\n+\t* config/aarch64/aarch64.c (aarch64_frame_pointer_required)\n+\tMove eh_return case to aarch64_layout_frame.\n+\t(aarch64_layout_frame): Initialize emit_frame_chain.\n+\t(aarch64_expand_prologue): Use emit_frame_chain.\n+\n 2017-10-26  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_layout_frame):"}, {"sha": "1cc10432b769e4f04810bd664c918927a46f7df9", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204d2c03acff4bf3b73cb5d2c9578b50c2aac703/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204d2c03acff4bf3b73cb5d2c9578b50c2aac703/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "patch": "@@ -2876,10 +2876,6 @@ aarch64_frame_pointer_required (void)\n \t   && !df_regs_ever_live_p (LR_REGNUM)))\n     return true;\n \n-  /* Force a frame pointer for EH returns so the return address is at FP+8.  */\n-  if (crtl->calls_eh_return)\n-    return true;\n-\n   return false;\n }\n \n@@ -2896,6 +2892,10 @@ aarch64_layout_frame (void)\n   if (reload_completed && cfun->machine->frame.laid_out)\n     return;\n \n+  /* Force a frame chain for EH returns so the return address is at FP+8.  */\n+  cfun->machine->frame.emit_frame_chain\n+    = frame_pointer_needed || crtl->calls_eh_return;\n+\n #define SLOT_NOT_REQUIRED (-2)\n #define SLOT_REQUIRED     (-1)\n \n@@ -2930,7 +2930,7 @@ aarch64_layout_frame (void)\n \tlast_fp_reg = regno;\n       }\n \n-  if (frame_pointer_needed)\n+  if (cfun->machine->frame.emit_frame_chain)\n     {\n       /* FP and LR are placed in the linkage record.  */\n       cfun->machine->frame.reg_offset[R29_REGNUM] = 0;\n@@ -3659,6 +3659,7 @@ aarch64_expand_prologue (void)\n   HOST_WIDE_INT callee_offset = cfun->machine->frame.callee_offset;\n   unsigned reg1 = cfun->machine->frame.wb_candidate1;\n   unsigned reg2 = cfun->machine->frame.wb_candidate2;\n+  bool emit_frame_chain = cfun->machine->frame.emit_frame_chain;\n   rtx_insn *insn;\n \n   /* Sign return address for functions.  */\n@@ -3691,22 +3692,22 @@ aarch64_expand_prologue (void)\n   if (callee_adjust != 0)\n     aarch64_push_regs (reg1, reg2, callee_adjust);\n \n-  if (frame_pointer_needed)\n+  if (emit_frame_chain)\n     {\n       if (callee_adjust == 0)\n \taarch64_save_callee_saves (DImode, callee_offset, R29_REGNUM,\n \t\t\t\t   R30_REGNUM, false);\n       insn = emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n \t\t\t\t       stack_pointer_rtx,\n \t\t\t\t       GEN_INT (callee_offset)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      RTX_FRAME_RELATED_P (insn) = frame_pointer_needed;\n       emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));\n     }\n \n   aarch64_save_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n-\t\t\t     callee_adjust != 0 || frame_pointer_needed);\n+\t\t\t     callee_adjust != 0 || emit_frame_chain);\n   aarch64_save_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t     callee_adjust != 0 || frame_pointer_needed);\n+\t\t\t     callee_adjust != 0 || emit_frame_chain);\n   aarch64_sub_sp (IP1_REGNUM, final_adjust, !frame_pointer_needed);\n }\n "}, {"sha": "bc1ccc342811de06c7fcbc0ba874ba410f358b17", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204d2c03acff4bf3b73cb5d2c9578b50c2aac703/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204d2c03acff4bf3b73cb5d2c9578b50c2aac703/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "patch": "@@ -343,9 +343,9 @@ extern unsigned aarch64_architecture_version;\n   (epilogue_completed && (REGNO) == LR_REGNUM)\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.  */\n-#define EXIT_IGNORE_STACK\t1\n+   the stack pointer does not matter.  This is only true if the function\n+   uses alloca.  */\n+#define EXIT_IGNORE_STACK\t(cfun->calls_alloca)\n \n #define STATIC_CHAIN_REGNUM\t\tR18_REGNUM\n #define HARD_FRAME_POINTER_REGNUM\tR29_REGNUM\n@@ -595,6 +595,9 @@ struct GTY (()) aarch64_frame\n   /* The size of the stack adjustment after saving callee-saves.  */\n   HOST_WIDE_INT final_adjust;\n \n+  /* Store FP,LR and setup a frame pointer.  */\n+  bool emit_frame_chain;\n+\n   unsigned wb_candidate1;\n   unsigned wb_candidate2;\n "}]}