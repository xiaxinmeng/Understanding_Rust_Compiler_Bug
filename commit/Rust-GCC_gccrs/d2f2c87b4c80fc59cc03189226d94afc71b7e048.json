{"sha": "d2f2c87b4c80fc59cc03189226d94afc71b7e048", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJmMmM4N2I0YzgwZmM1OWNjMDMxODkyMjZkOTRhZmM3MWI3ZTA0OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-02-16T02:35:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-02-16T02:35:50Z"}, "message": "re PR c++/13971 (ICE when compiling koffice-cvs (in build_conditional_expr, at cp/call.c:3068))\n\n\tPR c++/13971\n\t* call.c (build_conditional_expr): Handle conversions between\n\tclass types which result in differently cv-qualified type\n\tvariants.\n\n\tPR c++/14086\n\t* class.c (delete_duplicate_fields_1): Remove.\n\t(delete_duplicate_fields): Likewise.\n\t(finish_struct_anon): Remove check for members with the same name\n\tas their enclosing class.\n\t(check_field_decls): Do not call duplicate_fields.\n\t* decl.c (grokdeclarator): Remove check for static data members\n\twith the same name as their enclosing class.\n\t* name-lookup.c (push_class_level_binding): Check for members with\n\tthe same name as their enclosing class.\n\nFrom-SVN: r77869", "tree": {"sha": "e0c914da03123321da4758214851911cba25528c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0c914da03123321da4758214851911cba25528c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2f2c87b4c80fc59cc03189226d94afc71b7e048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2f2c87b4c80fc59cc03189226d94afc71b7e048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2f2c87b4c80fc59cc03189226d94afc71b7e048", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2f2c87b4c80fc59cc03189226d94afc71b7e048/comments", "author": null, "committer": null, "parents": [{"sha": "2c2ab3acc1b63eea04f29f08a01cd4f463b8b962", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2ab3acc1b63eea04f29f08a01cd4f463b8b962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2ab3acc1b63eea04f29f08a01cd4f463b8b962"}], "stats": {"total": 254, "additions": 122, "deletions": 132}, "files": [{"sha": "6c5e95768fd462a464358103a47273297330dfd6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -1,3 +1,21 @@\n+2004-02-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/13971\n+\t* call.c (build_conditional_expr): Handle conversions between\n+\tclass types which result in differently cv-qualified type\n+\tvariants.\n+\n+\tPR c++/14086\n+\t* class.c (delete_duplicate_fields_1): Remove.\n+\t(delete_duplicate_fields): Likewise.\n+\t(finish_struct_anon): Remove check for members with the same name\n+\tas their enclosing class.\n+\t(check_field_decls): Do not call duplicate_fields.\n+\t* decl.c (grokdeclarator): Remove check for static data members\n+\twith the same name as their enclosing class.\n+\t* name-lookup.c (push_class_level_binding): Check for members with\n+\tthe same name as their enclosing class.\n+\n 2004-02-15  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tPR c++/14085"}, {"sha": "70783dc75f63f738e439955e5407ef636e67a267", "filename": "gcc/cp/call.c", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -3243,21 +3243,12 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t{\n \t  arg2 = convert_like (conv2, arg2);\n \t  arg2 = convert_from_reference (arg2);\n-\t  if (!same_type_p (TREE_TYPE (arg2), arg3_type)\n-\t      && CLASS_TYPE_P (arg3_type))\n-\t    /* The types need to match if we're converting to a class type.\n-\t       If not, we don't care about cv-qual mismatches, since\n-\t       non-class rvalues are not cv-qualified.  */\n-\t    abort ();\n \t  arg2_type = TREE_TYPE (arg2);\n \t}\n       else if (conv3 && !conv3->bad_p)\n \t{\n \t  arg3 = convert_like (conv3, arg3);\n \t  arg3 = convert_from_reference (arg3);\n-\t  if (!same_type_p (TREE_TYPE (arg3), arg2_type)\n-\t      && CLASS_TYPE_P (arg2_type))\n-\t    abort ();\n \t  arg3_type = TREE_TYPE (arg3);\n \t}\n \n@@ -3266,6 +3257,29 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n       if (result)\n \treturn result;\n+\n+      /* If, after the conversion, both operands have class type,\n+\t treat the cv-qualification of both operands as if it were the\n+\t union of the cv-qualification of the operands.  \n+\n+\t The standard is not clear about what to do in this\n+\t circumstance.  For example, if the first operand has type\n+\t \"const X\" and the second operand has a user-defined\n+\t conversion to \"volatile X\", what is the type of the second\n+\t operand after this step?  Making it be \"const X\" (matching\n+\t the first operand) seems wrong, as that discards the\n+\t qualification without actuall performing a copy.  Leaving it\n+\t as \"volatile X\" seems wrong as that will result in the\n+\t conditional expression failing altogether, even though,\n+\t according to this step, the one operand could be converted to\n+\t the type of the other.  */\n+      if ((conv2 || conv3)\n+\t  && CLASS_TYPE_P (arg2_type)\n+\t  && TYPE_QUALS (arg2_type) != TYPE_QUALS (arg3_type))\n+\targ2_type = arg3_type = \n+\t  cp_build_qualified_type (arg2_type,\n+\t\t\t\t   TYPE_QUALS (arg2_type)\n+\t\t\t\t   | TYPE_QUALS (arg3_type));\n     }\n \n   /* [expr.cond]\n@@ -3349,16 +3363,15 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n      We need to force the lvalue-to-rvalue conversion here for class types,\n      so we get TARGET_EXPRs; trying to deal with a COND_EXPR of class rvalues\n      that isn't wrapped with a TARGET_EXPR plays havoc with exception\n-     regions.\n-\n-     We use ocp_convert rather than build_user_type_conversion because the\n-     latter returns NULL_TREE on failure, while the former gives an error.  */\n+     regions.  */\n \n   arg2 = force_rvalue (arg2);\n-  arg2_type = TREE_TYPE (arg2);\n+  if (!CLASS_TYPE_P (arg2_type))\n+    arg2_type = TREE_TYPE (arg2);\n \n   arg3 = force_rvalue (arg3);\n-  arg3_type = TREE_TYPE (arg3);\n+  if (!CLASS_TYPE_P (arg2_type))\n+    arg3_type = TREE_TYPE (arg3);\n \n   if (arg2 == error_mark_node || arg3 == error_mark_node)\n     return error_mark_node;\n@@ -3445,7 +3458,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n   /* Expand both sides into the same slot, hopefully the target of the\n      ?: expression.  We used to check for TARGET_EXPRs here, but now we\n      sometimes wrap them in NOP_EXPRs so the test would fail.  */\n-  if (!lvalue_p && IS_AGGR_TYPE (TREE_TYPE (result)))\n+  if (!lvalue_p && CLASS_TYPE_P (TREE_TYPE (result)))\n     result = get_target_expr (result);\n   \n   /* If this expression is an rvalue, but might be mistaken for an"}, {"sha": "f09368fcb2f7ee8bac0bcfdf69105b3b92eaf705", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -114,8 +114,6 @@ static int build_primary_vtable (tree, tree);\n static int build_secondary_vtable (tree);\n static void finish_vtbls (tree);\n static void modify_vtable_entry (tree, tree, tree, tree, tree *);\n-static tree delete_duplicate_fields_1 (tree, tree);\n-static void delete_duplicate_fields (tree);\n static void finish_struct_bits (tree);\n static int alter_access (tree, tree, tree);\n static void handle_using_decl (tree, tree);\n@@ -957,106 +955,6 @@ add_method (tree type, tree method, int error_p)\n \n /* Subroutines of finish_struct.  */\n \n-/* Look through the list of fields for this struct, deleting\n-   duplicates as we go.  This must be recursive to handle\n-   anonymous unions.\n-\n-   FIELD is the field which may not appear anywhere in FIELDS.\n-   FIELD_PTR, if non-null, is the starting point at which\n-   chained deletions may take place.\n-   The value returned is the first acceptable entry found\n-   in FIELDS.\n-\n-   Note that anonymous fields which are not of UNION_TYPE are\n-   not duplicates, they are just anonymous fields.  This happens\n-   when we have unnamed bitfields, for example.  */\n-\n-static tree\n-delete_duplicate_fields_1 (tree field, tree fields)\n-{\n-  tree x;\n-  tree prev = 0;\n-  if (DECL_NAME (field) == 0)\n-    {\n-      if (! ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-\treturn fields;\n-\n-      for (x = TYPE_FIELDS (TREE_TYPE (field)); x; x = TREE_CHAIN (x))\n-\tfields = delete_duplicate_fields_1 (x, fields);\n-      return fields;\n-    }\n-  else\n-    {\n-      for (x = fields; x; prev = x, x = TREE_CHAIN (x))\n-\t{\n-\t  if (DECL_NAME (x) == 0)\n-\t    {\n-\t      if (! ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n-\t\tcontinue;\n-\t      TYPE_FIELDS (TREE_TYPE (x))\n-\t\t= delete_duplicate_fields_1 (field, TYPE_FIELDS (TREE_TYPE (x)));\n-\t      if (TYPE_FIELDS (TREE_TYPE (x)) == 0)\n-\t\t{\n-\t\t  if (prev == 0)\n-\t\t    fields = TREE_CHAIN (fields);\n-\t\t  else\n-\t\t    TREE_CHAIN (prev) = TREE_CHAIN (x);\n-\t\t}\n-\t    }\n-\t  else if (TREE_CODE (field) == USING_DECL)\n-\t    /* A using declaration is allowed to appear more than\n-\t       once.  We'll prune these from the field list later, and\n-\t       handle_using_decl will complain about invalid multiple\n-\t       uses.  */\n-\t    ;\n-\t  else if (DECL_NAME (field) == DECL_NAME (x))\n-\t    {\n-\t      if (TREE_CODE (field) == CONST_DECL\n-\t\t  && TREE_CODE (x) == CONST_DECL)\n-\t\tcp_error_at (\"duplicate enum value `%D'\", x);\n-\t      else if (TREE_CODE (field) == CONST_DECL\n-\t\t       || TREE_CODE (x) == CONST_DECL)\n-\t\tcp_error_at (\"duplicate field `%D' (as enum and non-enum)\",\n-\t\t\t     x);\n-\t      else if (DECL_DECLARES_TYPE_P (field)\n-\t\t       && DECL_DECLARES_TYPE_P (x))\n-\t\t{\n-\t\t  if (same_type_p (TREE_TYPE (field), TREE_TYPE (x)))\n-\t\t    continue;\n-\t\t  cp_error_at (\"duplicate nested type `%D'\", x);\n-\t\t}\n-\t      else if (DECL_DECLARES_TYPE_P (field)\n-\t\t       || DECL_DECLARES_TYPE_P (x))\n-\t\t{\n-\t\t  /* Hide tag decls.  */\n-\t\t  if ((TREE_CODE (field) == TYPE_DECL\n-\t\t       && DECL_ARTIFICIAL (field))\n-\t\t      || (TREE_CODE (x) == TYPE_DECL\n-\t\t\t  && DECL_ARTIFICIAL (x)))\n-\t\t    continue;\n-\t\t  cp_error_at (\"duplicate field `%D' (as type and non-type)\",\n-\t\t\t       x);\n-\t\t}\n-\t      else\n-\t\tcp_error_at (\"duplicate member `%D'\", x);\n-\t      if (prev == 0)\n-\t\tfields = TREE_CHAIN (fields);\n-\t      else\n-\t\tTREE_CHAIN (prev) = TREE_CHAIN (x);\n-\t    }\n-\t}\n-    }\n-  return fields;\n-}\n-\n-static void\n-delete_duplicate_fields (tree fields)\n-{\n-  tree x;\n-  for (x = fields; x && TREE_CHAIN (x); x = TREE_CHAIN (x))\n-    TREE_CHAIN (x) = delete_duplicate_fields_1 (x, TREE_CHAIN (x));\n-}\n-\n /* Change the access of FDECL to ACCESS in T.  Return 1 if change was\n    legit, otherwise return 0.  */\n \n@@ -2580,10 +2478,6 @@ finish_struct_anon (tree t)\n \t\t      || TYPE_ANONYMOUS_P (TREE_TYPE (elt))))\n \t\tcontinue;\n \n-\t      if (constructor_name_p (DECL_NAME (elt), t))\n-\t\tcp_pedwarn_at (\"ISO C++ forbids member `%D' with same name as enclosing class\",\n-\t\t\t       elt);\n-\n \t      if (TREE_CODE (elt) != FIELD_DECL)\n \t\t{\n \t\t  cp_pedwarn_at (\"`%#D' invalid; an anonymous union can only have non-static data members\",\n@@ -2960,9 +2854,6 @@ check_field_decls (tree t, tree *access_decls,\n   int has_pointers;\n   int any_default_members;\n \n-  /* First, delete any duplicate fields.  */\n-  delete_duplicate_fields (TYPE_FIELDS (t));\n-\n   /* Assume there are no access declarations.  */\n   *access_decls = NULL_TREE;\n   /* Assume this class has no pointer members.  */"}, {"sha": "c07142915f6d0039a7b32e0fc9cf7f60813952d9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -8274,13 +8274,6 @@ grokdeclarator (tree declarator,\n \n \t    if (staticp)\n \t      {\n-\t\t/* [class.mem] forbids static data members with the\n-\t\t   same name as the enclosing class.  Non-static data\n-\t\t   members are checked in check_field_decls.  */\n-\t\tif (constructor_name_p (declarator, current_class_type))\n-\t\t  pedwarn (\"ISO C++ forbids static data member `%D' with same name as enclosing class\",\n-\t\t\t   declarator);\n-\t\t  \n \t\t/* C++ allows static class members.  All other work\n \t\t   for this is done by grokfield.  */\n \t\tdecl = build_lang_decl (VAR_DECL, declarator, type);"}, {"sha": "e1cc770dfe16badf6d0c573cc75bf9456bf6263b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -2736,6 +2736,37 @@ push_class_level_binding (tree name, tree x)\n   if (TYPE_BEING_DEFINED (current_class_type))\n     check_template_shadow (x);\n \n+  /* [class.mem]\n+\n+     If T is the name of a class, then each of the following shall\n+     have a name different from T:\n+\n+     -- every static data member of class T;\n+\n+     -- every member of class T that is itself a type;\n+\n+     -- every enumerator of every member of class T that is an\n+\tenumerated type;\n+\n+     -- every member of every anonymous union that is a member of\n+\tclass T.\n+\n+     (Non-static data members were also forbidden to have the same\n+     name as T until TC1.)  */\n+  if ((TREE_CODE (x) == VAR_DECL\n+       || TREE_CODE (x) == CONST_DECL\n+       || (TREE_CODE (x) == TYPE_DECL\n+\t   && !DECL_SELF_REFERENCE_P (x))\n+       /* A data member of an anonymous union.  */\n+       || (TREE_CODE (x) == FIELD_DECL\n+\t   && DECL_CONTEXT (x) != current_class_type))\n+      && DECL_NAME (x) == constructor_name (current_class_type))\n+    {\n+      error (\"`%D' has the same name as the class in which it is declared\",\n+\t     x);\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+    }\n+\n   /* If this declaration shadows a declaration from an enclosing\n      class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n      we leave this class.  Record the shadowed declaration here.  */"}, {"sha": "49cec6a71d356f947bee11b5ef4c6efccade4a51", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -1,3 +1,11 @@\n+2004-02-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/13971\n+\t* g++.dg/expr/cond4.C: New test.\n+\n+\tPR c++/14086\n+\t* g++.dg/lookup/crash2.C: New test.\n+\n 2004-02-14  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* gcc.c-torture/compile/20040214-2.c: New test."}, {"sha": "fff5c8b185dc7e66f4ec512c1e2e067e6e7747f6", "filename": "gcc/testsuite/g++.dg/expr/cond4.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcond4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcond4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcond4.C?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/13971\n+\n+struct QChar {\n+    static const QChar null;\n+};\n+struct QCharRef {\n+    operator QChar() const;\n+};\n+struct QString {\n+    QCharRef operator[](int i);\n+};\n+\n+QChar fillParagraph(QString s, int psi) {\n+    return psi ? QChar::null : s[psi];\n+}\n+"}, {"sha": "82735245f4886b208938e0a1ddc342722569232e", "filename": "gcc/testsuite/g++.dg/lookup/crash2.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fcrash2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f2c87b4c80fc59cc03189226d94afc71b7e048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fcrash2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fcrash2.C?ref=d2f2c87b4c80fc59cc03189226d94afc71b7e048", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/14086\n+\n+struct ClassA\n+{\n+  ClassA();\n+};\n+\n+struct ClassB\n+{\n+  enum Enum {ClassB}; // { dg-error \"\" }\n+  ClassA key;\n+\n+           ClassB();\n+  virtual ~ClassB();\n+};\n+\n+\n+ClassB::ClassB()\n+{\n+}"}]}