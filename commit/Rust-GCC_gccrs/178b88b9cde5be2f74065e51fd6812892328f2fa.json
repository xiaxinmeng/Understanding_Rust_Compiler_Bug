{"sha": "178b88b9cde5be2f74065e51fd6812892328f2fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc4Yjg4YjljZGU1YmUyZjc0MDY1ZTUxZmQ2ODEyODkyMzI4ZjJmYQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@touchme.toronto.redhat.com", "date": "2000-10-06T19:12:53Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2000-10-06T19:12:53Z"}, "message": "haifa-sched.c (anti_dependency_cache, [...]): New variables.\n\n2000-10-06  Vladimir Makarov  <vmakarov@touchme.toronto.redhat.com>\n\n\t* haifa-sched.c (anti_dependency_cache, output_dependency_cache,\n\tforward_dependency_cache): New variables.\n\t(add_dependence, remove_dependence): Use anti_dependency_cache and\n\toutput_dependency_cache.\n\t(compute_block_forward_dependences): Use forward_dependency_cache.\n\t(schedule_insns): Allocate and free memory for anti/output/forward\n\tdependencies caches.\n\nFrom-SVN: r36760", "tree": {"sha": "d693e680d0ad5f3969dcf692058df7742db40440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d693e680d0ad5f3969dcf692058df7742db40440"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/178b88b9cde5be2f74065e51fd6812892328f2fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178b88b9cde5be2f74065e51fd6812892328f2fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/178b88b9cde5be2f74065e51fd6812892328f2fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178b88b9cde5be2f74065e51fd6812892328f2fa/comments", "author": null, "committer": null, "parents": [{"sha": "827bdee40df26e3b67824885c60a775d4c3dbe41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827bdee40df26e3b67824885c60a775d4c3dbe41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/827bdee40df26e3b67824885c60a775d4c3dbe41"}], "stats": {"total": 171, "additions": 138, "deletions": 33}, "files": [{"sha": "c79fc22d778090abcbd585d66a1f5a6d82cb1815", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178b88b9cde5be2f74065e51fd6812892328f2fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178b88b9cde5be2f74065e51fd6812892328f2fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=178b88b9cde5be2f74065e51fd6812892328f2fa", "patch": "@@ -1,3 +1,13 @@\n+2000-10-06  Vladimir Makarov  <vmakarov@touchme.toronto.redhat.com>\n+\n+\t* haifa-sched.c (anti_dependency_cache, output_dependency_cache,\n+\tforward_dependency_cache): New variables.\n+\t(add_dependence, remove_dependence): Use anti_dependency_cache and\n+\toutput_dependency_cache.\n+\t(compute_block_forward_dependences): Use forward_dependency_cache.\n+\t(schedule_insns): Allocate and free memory for anti/output/forward\n+\tdependencies caches.\n+\t\n 2000-10-06  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/sh/sh.md (call, call_value): Use `TARGET_SH2' instead of"}, {"sha": "869cdc4a098b4e78ada63f98ef94397f14b29e57", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 128, "deletions": 33, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178b88b9cde5be2f74065e51fd6812892328f2fa/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178b88b9cde5be2f74065e51fd6812892328f2fa/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=178b88b9cde5be2f74065e51fd6812892328f2fa", "patch": "@@ -298,19 +298,30 @@ static regset reg_pending_sets;\n static regset reg_pending_clobbers;\n static int reg_pending_sets_all;\n \n-/* To speed up the test for duplicate dependency links we keep a record\n-   of true dependencies created by add_dependence when the average number\n-   of instructions in a basic block is very large.\n+/* To speed up the test for duplicate dependency links we keep a\n+   record of dependencies created by add_dependence when the average\n+   number of instructions in a basic block is very large.\n \n    Studies have shown that there is typically around 5 instructions between\n    branches for typical C code.  So we can make a guess that the average\n    basic block is approximately 5 instructions long; we will choose 100X\n    the average size as a very large basic block.\n \n-   Each insn has an associated bitmap for its dependencies.  Each bitmap\n-   has enough entries to represent a dependency on any other insn in the\n-   insn chain.  */\n+   Each insn has associated bitmaps for its dependencies.  Each bitmap\n+   has enough entries to represent a dependency on any other insn in\n+   the insn chain.  All bitmap for true dependencies cache is\n+   allocated then the rest two ones are also allocated. */\n static sbitmap *true_dependency_cache;\n+static sbitmap *anti_dependency_cache;\n+static sbitmap *output_dependency_cache;\n+\n+/* To speed up checking consistency of formed forward insn\n+   dependencies we use the following cache.  Another possible solution\n+   could be switching off checking duplication of insns in forward\n+   dependencies. */\n+#ifdef ENABLE_CHECKING\n+static sbitmap *forward_dependency_cache;\n+#endif\n \n /* Indexed by INSN_UID, the collection of all data associated with\n    a single instruction.  */\n@@ -802,6 +813,8 @@ add_dependence (insn, elem, dep_type)\n      enum reg_note dep_type;\n {\n   rtx link, next;\n+  int present_p;\n+  enum reg_note present_dep_type;\n \n   /* Don't depend an insn on itself.  */\n   if (insn == elem)\n@@ -845,6 +858,7 @@ add_dependence (insn, elem, dep_type)\n       elem = next;\n     }\n \n+  present_p = 1;\n #ifdef INSN_SCHEDULING\n   /* (This code is guarded by INSN_SCHEDULING, otherwise INSN_BB is undefined.)\n      No need for interblock dependences with calls, since\n@@ -854,30 +868,72 @@ add_dependence (insn, elem, dep_type)\n       && (INSN_BB (elem) != INSN_BB (insn)))\n     return;\n \n-  /* If we already have a true dependency for ELEM, then we do not\n-     need to do anything.  Avoiding the list walk below can cut\n-     compile times dramatically for some code.  */\n-  if (true_dependency_cache\n-      && TEST_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem)))\n-    return;\n+  /* If we already have a dependency for ELEM, then we do not need to\n+     do anything.  Avoiding the list walk below can cut compile times\n+     dramatically for some code.  */\n+  if (true_dependency_cache != NULL)\n+    {\n+      if (anti_dependency_cache == NULL || output_dependency_cache == NULL)\n+\tabort ();\n+      if (TEST_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem)))\n+\tpresent_dep_type = 0;\n+      else if (TEST_BIT (anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t INSN_LUID (elem)))\n+\tpresent_dep_type = REG_DEP_ANTI;\n+      else if (TEST_BIT (output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t INSN_LUID (elem)))\n+\tpresent_dep_type = REG_DEP_OUTPUT;\n+      else \n+\tpresent_p = 0;\n+      if (present_p && (int) dep_type >= (int) present_dep_type)\n+\treturn;\n+    }\n #endif\n \n   /* Check that we don't already have this dependence.  */\n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-    if (XEXP (link, 0) == elem)\n-      {\n-\t/* If this is a more restrictive type of dependence than the existing\n-\t   one, then change the existing dependence to this type.  */\n-\tif ((int) dep_type < (int) REG_NOTE_KIND (link))\n-\t  PUT_REG_NOTE_KIND (link, dep_type);\n+  if (present_p)\n+    for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+      if (XEXP (link, 0) == elem)\n+\t{\n+#ifdef INSN_SCHEDULING\n+\t  /* Clear corresponding cache entry because type of the link\n+             may be changed. */\n+\t  if (true_dependency_cache != NULL)\n+\t    {\n+\t      if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+\t\tRESET_BIT (anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t   INSN_LUID (elem));\n+\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT\n+\t\t       && output_dependency_cache)\n+\t\tRESET_BIT (output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t   INSN_LUID (elem));\n+\t      else\n+\t\tabort ();\n+\t    }\n+#endif\n \n+\t  /* If this is a more restrictive type of dependence than the existing\n+\t     one, then change the existing dependence to this type.  */\n+\t  if ((int) dep_type < (int) REG_NOTE_KIND (link))\n+\t    PUT_REG_NOTE_KIND (link, dep_type);\n+\t  \n #ifdef INSN_SCHEDULING\n-\t/* If we are adding a true dependency to INSN's LOG_LINKs, then\n-\t   note that in the bitmap cache of true dependency information.  */\n-\tif ((int) dep_type == 0 && true_dependency_cache)\n-\t  SET_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+\t  /* If we are adding a dependency to INSN's LOG_LINKs, then\n+\t     note that in the bitmap caches of dependency information. */\n+\t  if (true_dependency_cache != NULL)\n+\t    {\n+\t      if ((int)REG_NOTE_KIND (link) == 0)\n+\t\tSET_BIT (true_dependency_cache[INSN_LUID (insn)],\n+\t\t\t INSN_LUID (elem));\n+\t      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+\t\tSET_BIT (anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t INSN_LUID (elem));\n+\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+\t\tSET_BIT (output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t INSN_LUID (elem));\n+\t    }\n #endif\n-\treturn;\n+\t  return;\n       }\n   /* Might want to check one level of transitivity to save conses.  */\n \n@@ -888,10 +944,17 @@ add_dependence (insn, elem, dep_type)\n   PUT_REG_NOTE_KIND (link, dep_type);\n \n #ifdef INSN_SCHEDULING\n-  /* If we are adding a true dependency to INSN's LOG_LINKs, then\n-     note that in the bitmap cache of true dependency information.  */\n-  if ((int) dep_type == 0 && true_dependency_cache)\n-    SET_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+  /* If we are adding a dependency to INSN's LOG_LINKs, then note that\n+     in the bitmap caches of dependency information. */\n+  if (true_dependency_cache != NULL)\n+    {\n+      if ((int)dep_type == 0)\n+\tSET_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+      else if (dep_type == REG_DEP_ANTI)\n+\tSET_BIT (anti_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+      else if (dep_type == REG_DEP_OUTPUT)\n+\tSET_BIT (output_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+    }\n #endif\n }\n \n@@ -917,11 +980,20 @@ remove_dependence (insn, elem)\n \t    LOG_LINKS (insn) = next;\n \n #ifdef INSN_SCHEDULING\n-\t  /* If we are removing a true dependency from the LOG_LINKS list,\n+\t  /* If we are removing a dependency from the LOG_LINKS list,\n \t     make sure to remove it from the cache too.  */\n-\t  if (REG_NOTE_KIND (link) == 0 && true_dependency_cache)\n-\t    RESET_BIT (true_dependency_cache[INSN_LUID (insn)],\n-\t\t       INSN_LUID (elem));\n+\t  if (true_dependency_cache != NULL)\n+\t    {\n+\t      if (REG_NOTE_KIND (link) == 0)\n+\t\tRESET_BIT (true_dependency_cache[INSN_LUID (insn)],\n+\t\t\t   INSN_LUID (elem));\n+\t      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+\t\tRESET_BIT (anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t   INSN_LUID (elem));\n+\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+\t\tRESET_BIT (output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t   INSN_LUID (elem));\n+\t    }\n #endif\n \n \t  free_INSN_LIST_node (link);\n@@ -6195,8 +6267,15 @@ compute_block_forward_dependences (bb)\n \t     ahead and verify that add_dependence worked properly.  */\n \t  if (GET_CODE (x) == NOTE\n \t      || INSN_DELETED_P (x)\n-\t      || find_insn_list (insn, INSN_DEPEND (x)))\n+\t      || (forward_dependency_cache != NULL\n+\t\t  && TEST_BIT (forward_dependency_cache[INSN_LUID (x)],\n+\t\t\t       INSN_LUID (insn)))\n+\t      || (forward_dependency_cache == NULL\n+\t\t  && find_insn_list (insn, INSN_DEPEND (x))))\n \t    abort ();\n+\t  if (forward_dependency_cache != NULL)\n+\t    SET_BIT (forward_dependency_cache[INSN_LUID (x)],\n+\t\t     INSN_LUID (insn));\n #endif\n \n \t  new_link = alloc_INSN_LIST (insn, INSN_DEPEND (x));\n@@ -6847,6 +6926,14 @@ schedule_insns (dump_file)\n     {\n       true_dependency_cache = sbitmap_vector_alloc (luid, luid);\n       sbitmap_vector_zero (true_dependency_cache, luid);\n+      anti_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+      sbitmap_vector_zero (anti_dependency_cache, luid);\n+      output_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+      sbitmap_vector_zero (output_dependency_cache, luid);\n+#ifdef ENABLE_CHECKING\n+      forward_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+      sbitmap_vector_zero (forward_dependency_cache, luid);\n+#endif\n     }\n \n   nr_regions = 0;\n@@ -7063,6 +7150,14 @@ schedule_insns (dump_file)\n     {\n       free (true_dependency_cache);\n       true_dependency_cache = NULL;\n+      free (anti_dependency_cache);\n+      anti_dependency_cache = NULL;\n+      free (output_dependency_cache);\n+      output_dependency_cache = NULL;\n+#ifdef ENABLE_CHECKING\n+      free (output_dependency_cache);\n+      forward_dependency_cache = NULL;\n+#endif\n     }\n   free (rgn_table);\n   free (rgn_bb_table);"}]}