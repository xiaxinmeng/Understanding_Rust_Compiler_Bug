{"sha": "b790003ae628e7ef7aeb86aef9ce5682d05de33c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc5MDAwM2FlNjI4ZTdlZjdhZWI4NmFlZjljZTU2ODJkMDVkZTMzYw==", "commit": {"author": {"name": "Casey Marshall", "email": "csm@gnu.org", "date": "2004-08-15T04:05:18Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2004-08-15T04:05:18Z"}, "message": "ffi.c (ffi_pref_cif_machdep): set `cif->flags' to contain `FFI_TYPE_UINT64' as return type for any 64-bit...\n\n2004-08-14  Casey Marshall <csm@gnu.org>\n\n\t* src/mips/ffi.c (ffi_pref_cif_machdep): set `cif->flags' to\n\tcontain `FFI_TYPE_UINT64' as return type for any 64-bit\n\tinteger (O32 ABI only).\n\t(ffi_prep_closure): new function.\n\t(ffi_closure_mips_inner_O32): new function.\n\t* src/mips/ffitarget.h: Define `FFI_CLOSURES' and\n\t`FFI_TRAMPOLINE_SIZE' appropriately if the ABI is o32.\n\t* src/mips/o32.S (ffi_call_O32): add labels for .eh_frame. Return\n\t64 bit integers correctly.\n\t(ffi_closure_O32): new function.\n\tAdded DWARF-2 unwind info for both functions.\n\nFrom-SVN: r86019", "tree": {"sha": "b2274223d041019964ca2374b01f3ee5fb7107a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2274223d041019964ca2374b01f3ee5fb7107a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b790003ae628e7ef7aeb86aef9ce5682d05de33c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b790003ae628e7ef7aeb86aef9ce5682d05de33c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b790003ae628e7ef7aeb86aef9ce5682d05de33c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b790003ae628e7ef7aeb86aef9ce5682d05de33c/comments", "author": null, "committer": null, "parents": [{"sha": "53fb4de37502c525b7afef2401350a0797fd2373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53fb4de37502c525b7afef2401350a0797fd2373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53fb4de37502c525b7afef2401350a0797fd2373"}], "stats": {"total": 313, "additions": 310, "deletions": 3}, "files": [{"sha": "483e483343c4868cf048f2e712b985fa50570a82", "filename": "libffi/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=b790003ae628e7ef7aeb86aef9ce5682d05de33c", "patch": "@@ -1,3 +1,17 @@\n+2004-08-14  Casey Marshall <csm@gnu.org>\n+\n+\t* src/mips/ffi.c (ffi_pref_cif_machdep): set `cif->flags' to\n+\tcontain `FFI_TYPE_UINT64' as return type for any 64-bit\n+\tinteger (O32 ABI only).\n+\t(ffi_prep_closure): new function.\n+\t(ffi_closure_mips_inner_O32): new function.\n+\t* src/mips/ffitarget.h: Define `FFI_CLOSURES' and \n+\t`FFI_TRAMPOLINE_SIZE' appropriately if the ABI is o32.\n+\t* src/mips/o32.S (ffi_call_O32): add labels for .eh_frame. Return\n+\t64 bit integers correctly.\n+\t(ffi_closure_O32): new function.\n+\tAdded DWARF-2 unwind info for both functions.\n+\n 2004-08-10  Andrew Haley  <aph@redhat.com>\n \n \t* src/x86/ffi64.c (ffi_prep_args ): 8-align all stack arguments."}, {"sha": "e12922aa0465b6c1a6c99c0abd918f5ed5336b7e", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=b790003ae628e7ef7aeb86aef9ce5682d05de33c", "patch": "@@ -27,6 +27,7 @@\n #include <ffi_common.h>\n \n #include <stdlib.h>\n+#include <sys/cachectl.h>\n \n #if _MIPS_SIM == _ABIN32\n #define FIX_ARGP \\\n@@ -314,6 +315,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     case FFI_TYPE_DOUBLE:\n       cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 2);\n       break;\n+\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+      cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 2);\n+      break;\n       \n     default:\n       cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 2);\n@@ -459,3 +465,117 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n       break;\n     }\n }\n+\n+#if FFI_CLOSURES  /* N32 not implemented yet, FFI_CLOSURES not defined */\n+#if defined(FFI_MIPS_O32)\n+extern void ffi_closure_O32(void);\n+#endif /* FFI_MIPS_O32 */\n+\n+ffi_status\n+ffi_prep_closure (ffi_closure *closure,\n+\t\t  ffi_cif *cif,\n+\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t  void *user_data)\n+{\n+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n+  unsigned int fn;\n+  unsigned int ctx = (unsigned int) closure;\n+\n+#if defined(FFI_MIPS_O32)\n+  FFI_ASSERT(cif->abi == FFI_O32);\n+  fn = (unsigned int) ffi_closure_O32;\n+#else /* FFI_MIPS_N32 */\n+  FFI_ASSERT(cif->abi == FFI_N32);\n+  FFI_ASSERT(!\"not implemented\");\n+#endif /* FFI_MIPS_O32 */\n+\n+  tramp[0] = 0x3c190000 | (fn >> 16);     /* lui  $25,high(fn) */\n+  tramp[1] = 0x3c080000 | (ctx >> 16);    /* lui  $8,high(ctx) */\n+  tramp[2] = 0x37390000 | (fn & 0xffff);  /* ori  $25,low(fn)  */\n+  tramp[3] = 0x03200008;                  /* jr   $25          */\n+  tramp[4] = 0x35080000 | (ctx & 0xffff); /* ori  $8,low(ctx)  */\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  /* XXX this is available on Linux, but anything else? */\n+  cacheflush (tramp, FFI_TRAMPOLINE_SIZE, ICACHE);\n+\n+  return FFI_OK;\n+}\n+\n+/*\n+ * Decodes the arguments to a function, which will be stored on the\n+ * stack. AR is the pointer to the beginning of the integer arguments\n+ * (and, depending upon the arguments, some floating-point arguments\n+ * as well). FPR is a pointer to the area where floating point\n+ * registers have been saved, if any.\n+ *\n+ * RVALUE is the location where the function return value will be\n+ * stored. CLOSURE is the prepared closure to invoke.\n+ *\n+ * This function should only be called from assembly, which is in\n+ * turn called from a trampoline.\n+ *\n+ * Returns the function return type.\n+ *\n+ * Based on the similar routine for sparc.\n+ */\n+int\n+ffi_closure_mips_inner_O32 (ffi_closure *closure,\n+\t\t\t    void *rvalue, unsigned long *ar,\n+\t\t\t    double *fpr)\n+{\n+  ffi_cif *cif;\n+  void **avalue;\n+  ffi_type **arg_types;\n+  int i, avn, argn, seen_int;\n+\n+  cif = closure->cif;\n+  avalue = alloca (cif->nargs * sizeof (void *));\n+\n+  seen_int = 0;\n+  argn = 0;\n+\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    {\n+      rvalue = (void *) ar[0];\n+      argn = 1;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+\n+  while (i < avn)\n+    {\n+      if (i < 2 && !seen_int &&\n+\t  (arg_types[i]->type == FFI_TYPE_FLOAT ||\n+\t   arg_types[i]->type == FFI_TYPE_DOUBLE))\n+\t{\n+\t  avalue[i] = ((char *) &fpr[i]);\n+\t}\n+      else\n+\t{\n+\t  /* 8-byte arguments are always 8-byte aligned. */\n+\t  if (arg_types[i]->size == 8 && (argn & 0x1))\n+\t    argn++;\n+\t  /* Float arguments take up two register slots. The float word\n+\t     is the upper one. */\n+\t  if (argn == 2 && arg_types[i]->type == FFI_TYPE_FLOAT)\n+\t    argn++;\n+\t  avalue[i] = ((char *) &ar[argn]);\n+\t  seen_int = 1;\n+\t}\n+      argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+      i++;\n+    }\n+\n+  /* Invoke the closure. */\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  return cif->rtype->type;\n+}\n+\n+#endif /* FFI_CLOSURES */"}, {"sha": "2e6fbaeec0ad4d308798ec57c8e8a601b0394738", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=b790003ae628e7ef7aeb86aef9ce5682d05de33c", "patch": "@@ -153,7 +153,13 @@ typedef enum ffi_abi {\n \n /* ---- Definitions for closures ----------------------------------------- */\n \n+#if defined(FFI_MIPS_O32)\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 20\n+#else\n+/* N32/N64 not implemented yet. */\n #define FFI_CLOSURES 0\n+#endif /* FFI_MIPS_O32 */\n #define FFI_NATIVE_RAW_API 0\n \n #endif"}, {"sha": "e2dfa8debdb14647b4cd921a8d37164e18353e12", "filename": "libffi/src/mips/o32.S", "status": "modified", "additions": 170, "deletions": 3, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2Fsrc%2Fmips%2Fo32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b790003ae628e7ef7aeb86aef9ce5682d05de33c/libffi%2Fsrc%2Fmips%2Fo32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fo32.S?ref=b790003ae628e7ef7aeb86aef9ce5682d05de33c", "patch": "@@ -36,19 +36,24 @@\n #define flags\t a3\n \t\t\n #define SIZEOF_FRAME\t( 4 * FFI_SIZEOF_ARG + 2 * FFI_SIZEOF_ARG )\n+#define SIZEOF_FRAME2\t( 8 * FFI_SIZEOF_ARG + 2 * FFI_SIZEOF_ARG )\n \n \t.text\n \t.align\t2\n \t.globl\tffi_call_O32\n \t.ent\tffi_call_O32\n ffi_call_O32:\t\n-\n+$LFB0:\n \t# Prologue\n \tSUBU\t$sp, SIZEOF_FRAME\t\t\t# Frame size\n+$LCFI0:\n \tREG_S\t$fp, SIZEOF_FRAME - 2*FFI_SIZEOF_ARG($sp)\t# Save frame pointer\n+$LCFI1:\n \tREG_S\tra, SIZEOF_FRAME - 1*FFI_SIZEOF_ARG($sp)\t# Save return address\n+$LCFI2:\n \tmove\t$fp, $sp\n \n+$LCFI3:\n \tmove\tt9, callback\t# callback function pointer\n \tREG_S\tflags, SIZEOF_FRAME + 3*FFI_SIZEOF_ARG($fp) # flags\n \n@@ -136,9 +141,18 @@ call_it:\n \tREG_L\tt1, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)\n \tbeqz\tt1, noretval\n \n-\tbne     t2, FFI_TYPE_INT, retfloat\n+\tbne     t2, FFI_TYPE_INT, retlonglong\n+\tjal\tt9\n+\tREG_L\tt0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)\n+\tREG_S\tv0, 0(t0)\n+\tb\tepilogue\n+\n+retlonglong:\n+\t# Really any 64-bit int, signed or not.\n+\tbne\tt2, FFI_TYPE_UINT64, retfloat\n \tjal\tt9\n \tREG_L\tt0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)\n+\tREG_S\tv1, 4(t0)\n \tREG_S\tv0, 0(t0)\n \tb\tepilogue\n \n@@ -167,6 +181,159 @@ epilogue:\n \tADDU\t$sp, SIZEOF_FRAME\t\t      # Fix stack pointer\n \tj\tra\n \n+$LFE0:\n \t.end\tffi_call_O32\n-\t\n+\n+\n+/* ffi_closure_O32. Expects address of the passed-in ffi_closure\n+\tin t0. Stores any arguments passed in registers onto the\n+\tstack, then calls ffi_closure_mips_inner_O32, which\n+\tthen decodes them. */\n+\n+\t.text\n+\t.align\t2\n+\t.globl\tffi_closure_O32\n+\t.ent\tffi_closure_O32\n+ffi_closure_O32:\n+$LFB1:\n+\t# Prologue\n+\t.frame\t$fp, SIZEOF_FRAME2, $31\n+\t.set\tnoreorder\n+\t.cpload\t$25\n+\t.set\treorder\n+\tSUBU\t$sp, SIZEOF_FRAME2\n+\t.cprestore SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG\n+$LCFI4:\n+\tREG_S\t$fp, SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\t # Save frame pointer\n+$LCFI5:\n+\tREG_S\tra, SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\t # Save return address\n+$LCFI6:\n+\tmove\t$fp, $sp\n+\n+$LCFI7:\n+\t# Store all possible argument registers. If there are more than\n+\t# four arguments, then they should be stored above where we put $7.\n+\tREG_S\t$4, SIZEOF_FRAME2 + 0*FFI_SIZEOF_ARG($fp)\n+\tREG_S\t$5, SIZEOF_FRAME2 + 1*FFI_SIZEOF_ARG($fp)\n+\tREG_S\t$6, SIZEOF_FRAME2 + 2*FFI_SIZEOF_ARG($fp)\n+\tREG_S\t$7, SIZEOF_FRAME2 + 3*FFI_SIZEOF_ARG($fp)\n+\n+\t# Store all possible float/double registers.\n+\ts.d\t$f12, SIZEOF_FRAME2 - 10*FFI_SIZEOF_ARG($fp)\n+\ts.d\t$f14, SIZEOF_FRAME2 -  8*FFI_SIZEOF_ARG($fp)\n+\n+\t# Call ffi_closure_mips_inner_O32 to do the work.\n+\tla\t$25, ffi_closure_mips_inner_O32\n+\tmove\t$4, $8\t # Pointer to the ffi_closure\n+\taddu\t$5, $fp, SIZEOF_FRAME2 -  4*FFI_SIZEOF_ARG\n+\taddu\t$6, $fp, SIZEOF_FRAME2 +  0*FFI_SIZEOF_ARG\n+\taddu\t$7, $fp, SIZEOF_FRAME2 - 10*FFI_SIZEOF_ARG\n+\tjal\t$31, $25\n+\n+\t# Load the return value into the appropriate register.\n+\tmove\t$8, $2\n+\tli\t$9, FFI_TYPE_VOID\n+\tbeq\t$8, $9, closure_done\n+\n+\tli\t$9, FFI_TYPE_FLOAT\n+\tl.s\t$f0, SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG($fp)\n+\tbeq\t$8, $9, closure_done\n+\n+\tli\t$9, FFI_TYPE_DOUBLE\n+\tl.d\t$f0, SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG($fp)\n+\tbeq\t$8, $9, closure_done\n+\n+\tli\t$9, FFI_TYPE_SINT64\n+\tREG_L\t$3, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($fp)\n+\tbeq\t$8, $9, integer\n+\n+\tli\t$9, FFI_TYPE_UINT64\n+\tREG_L\t$3, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($fp)\n+\tbeq\t$8, $9, integer\n+\n+integer:\n+\tREG_L\t$2, SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG($fp)\n+\n+closure_done:\n+\t# Epilogue\n+\tmove\t$sp, $fp\n+\tREG_L\t$fp, SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\t # Restore frame pointer\n+\tREG_L\tra,  SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\t # Restore return address\n+\tADDU\t$sp, SIZEOF_FRAME2\n+\tj\tra\n+$LFE1:\n+\t.end\tffi_closure_O32\n+\n+/* DWARF-2 unwind info. */\n+\n+\t.section\t.eh_frame,\"a\",@progbits\n+$Lframe0:\n+\t.4byte\t$LECIE0-$LSCIE0\t # Length of Common Information Entry\n+$LSCIE0:\n+\t.4byte\t0x0\t # CIE Identifier Tag\n+\t.byte\t0x1\t # CIE Version\n+\t.ascii \"zR\\0\"\t # CIE Augmentation\n+\t.uleb128 0x1\t # CIE Code Alignment Factor\n+\t.sleb128 4\t # CIE Data Alignment Factor\n+\t.byte\t0x1f\t # CIE RA Column\n+\t.uleb128 0x1\t # Augmentation size\n+\t.byte\t0x1b\t # FDE Encoding (pcrel sdata4)\n+\t.byte\t0xc\t # DW_CFA_def_cfa\n+\t.uleb128 0x1d\n+\t.uleb128 0x0\n+\t.align\t2\n+$LECIE0:\n+$LSFDE0:\n+\t.4byte\t$LEFDE0-$LASFDE0\t # FDE Length\n+$LASFDE0:\n+\t.4byte\t$LASFDE0-$Lframe0\t # FDE CIE offset\n+\t.4byte\t$LFB0-.\t # FDE initial location\n+\t.4byte\t$LFE0-$LFB0\t # FDE address range\n+\t.uleb128 0x0\t # Augmentation size\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI0-$LFB0\n+\t.byte\t0xe\t # DW_CFA_def_cfa_offset\n+\t.uleb128 0x18\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI2-$LCFI0\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x1e\t # $fp\n+\t.sleb128 -2\t # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x1f\t # $ra\n+\t.sleb128 -1\t # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI3-$LCFI2\n+\t.byte\t0xc\t # DW_CFA_def_cfa\n+\t.uleb128 0x1e\n+\t.uleb128 0x18\n+\t.align\t2\n+$LEFDE0:\n+$LSFDE1:\n+\t.4byte\t$LEFDE1-$LASFDE1\t # FDE Length\n+$LASFDE1:\n+\t.4byte\t$LASFDE1-$Lframe0\t # FDE CIE offset\n+\t.4byte\t$LFB1-.\t # FDE initial location\n+\t.4byte\t$LFE1-$LFB1\t # FDE address range\n+\t.uleb128 0x0\t # Augmentation size\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI4-$LFB1\n+\t.byte\t0xe\t # DW_CFA_def_cfa_offset\n+\t.uleb128 0x28\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI6-$LCFI4\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x1e\t # $fp\n+\t.sleb128 -2\t # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x1f\t # $ra\n+\t.sleb128 -1\t # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI7-$LCFI6\n+\t.byte\t0xc\t # DW_CFA_def_cfa\n+\t.uleb128 0x1e\n+\t.uleb128 0x28\n+\t.align\t2\n+$LEFDE1:\n+\n #endif"}]}