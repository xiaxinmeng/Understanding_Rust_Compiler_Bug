{"sha": "f07862c7dd58714d601e776a130deb6df02bf022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA3ODYyYzdkZDU4NzE0ZDYwMWU3NzZhMTMwZGViNmRmMDJiZjAyMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-11-30T12:20:06Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-11-30T12:20:06Z"}, "message": "c-ada-spec.c (print_ada_macros): Remove redundant blank line.\n\n\t* c-ada-spec.c (print_ada_macros): Remove redundant blank line.\n\t(decl_sloc_common): Delete and move bulk of processing to...\n\t(decl_sloc): ...here.\n\t(pp_ada_tree_identifier): Remove reference to QUAL_UNION_TYPE.\n\t(dump_ada_double_name): Remove S parameter and compute the suffix.\n\t(dump_ada_array_type): Add PARENT parameter.  Simplify computation of\n\telement type and deal with an anonymous one.\n\t(dump_ada_template): Use RECORD_OR_UNION_TYPE_P macro.\n\t(dump_generic_ada_node): Tweak.  Adjust call to dump_ada_array_type\n\tand remove reference to QUAL_UNION_TYPE.\n\t(dump_nested_types): Make 2 passes on the fields and move bulk to...\n\t(dump_nested_type): ...here.  New function extracted from above.\n\tGenerate a full declaration for anonymous element type of arrays.\n\t(print_ada_declaration): Really skip anonymous declarations.  Remove\n\treferences to QUAL_UNION_TYPE.  Adjust call to dump_ada_array_type.\n\tClean up processing of declarations of array types and objects.\n\t(print_ada_struct_decl): Remove reference to QUAL_UNION_TYPE.\n\tRemove obsolete code and tidy up.\n\nFrom-SVN: r231069", "tree": {"sha": "8ad814cbf8efa1134e6c6e30477eecc09ac41bf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ad814cbf8efa1134e6c6e30477eecc09ac41bf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f07862c7dd58714d601e776a130deb6df02bf022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f07862c7dd58714d601e776a130deb6df02bf022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f07862c7dd58714d601e776a130deb6df02bf022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f07862c7dd58714d601e776a130deb6df02bf022/comments", "author": null, "committer": null, "parents": [{"sha": "c8a23c29f7e61990d9f3fb36b4dfab8f46efa0ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a23c29f7e61990d9f3fb36b4dfab8f46efa0ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a23c29f7e61990d9f3fb36b4dfab8f46efa0ef"}], "stats": {"total": 553, "additions": 290, "deletions": 263}, "files": [{"sha": "6be680a0743e3db336a2c18a0f7fb682e34d374d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f07862c7dd58714d601e776a130deb6df02bf022", "patch": "@@ -1,3 +1,24 @@\n+2015-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c (print_ada_macros): Remove redundant blank line.\n+\t(decl_sloc_common): Delete and move bulk of processing to...\n+\t(decl_sloc): ...here.\n+\t(pp_ada_tree_identifier): Remove reference to QUAL_UNION_TYPE.\n+\t(dump_ada_double_name): Remove S parameter and compute the suffix.\n+\t(dump_ada_array_type): Add PARENT parameter.  Simplify computation of\n+\telement type and deal with an anonymous one.\n+\t(dump_ada_template): Use RECORD_OR_UNION_TYPE_P macro.\n+\t(dump_generic_ada_node): Tweak.  Adjust call to dump_ada_array_type\n+\tand remove reference to QUAL_UNION_TYPE.\n+\t(dump_nested_types): Make 2 passes on the fields and move bulk to...\n+\t(dump_nested_type): ...here.  New function extracted from above.\n+\tGenerate a full declaration for anonymous element type of arrays.\n+\t(print_ada_declaration): Really skip anonymous declarations.  Remove\n+\treferences to QUAL_UNION_TYPE.  Adjust call to dump_ada_array_type.\n+\tClean up processing of declarations of array types and objects.\n+\t(print_ada_struct_decl): Remove reference to QUAL_UNION_TYPE.\n+\tRemove obsolete code and tidy up.\n+\n 2015-11-29  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR c/67581"}, {"sha": "076aa8209687ee7b90cd7441779fa8d20bddd964", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 214, "deletions": 263, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=f07862c7dd58714d601e776a130deb6df02bf022", "patch": "@@ -375,7 +375,7 @@ print_ada_macros (pretty_printer *pp, cpp_hashnode **macros, int max_ada_macros)\n \t{\n \t  expanded_location sloc = expand_location (macro->line);\n \n-\t  if (sloc.line != prev_line + 1)\n+\t  if (sloc.line != prev_line + 1 && prev_line > 0)\n \t    pp_newline (pp);\n \n \t  num_macros++;\n@@ -500,39 +500,28 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \n static const char *source_file_base;\n \n-/* Compare the declaration (DECL) of struct-like types based on the sloc of\n-   their last field (if LAST is true), so that more nested types collate before\n-   less nested ones.\n-   If ORIG_TYPE is true, also consider struct with a DECL_ORIGINAL_TYPE.  */\n+/* Return sloc of DECL, using sloc of last field if LAST is true.  */\n \n-static location_t\n-decl_sloc_common (const_tree decl, bool last, bool orig_type)\n+location_t\n+decl_sloc (const_tree decl, bool last)\n {\n-  tree type = TREE_TYPE (decl);\n+  tree field;\n \n+  /* Compare the declaration of struct-like types based on the sloc of their\n+     last field (if LAST is true), so that more nested types collate before\n+     less nested ones.  */\n   if (TREE_CODE (decl) == TYPE_DECL\n-      && (orig_type || !DECL_ORIGINAL_TYPE (decl))\n-      && RECORD_OR_UNION_TYPE_P (type)\n-      && TYPE_FIELDS (type))\n+      && !DECL_ORIGINAL_TYPE (decl)\n+      && RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n+      && (field = TYPE_FIELDS (TREE_TYPE (decl))))\n     {\n-      tree f = TYPE_FIELDS (type);\n-\n       if (last)\n-\twhile (TREE_CHAIN (f))\n-\t  f = TREE_CHAIN (f);\n-\n-      return DECL_SOURCE_LOCATION (f);\n+\twhile (DECL_CHAIN (field))\n+\t  field = DECL_CHAIN (field);\n+      return DECL_SOURCE_LOCATION (field);\n     }\n-  else\n-    return DECL_SOURCE_LOCATION (decl);\n-}\n \n-/* Return sloc of DECL, using sloc of last field if LAST is true.  */\n-\n-location_t\n-decl_sloc (const_tree decl, bool last)\n-{\n-  return decl_sloc_common (decl, last, false);\n+  return DECL_SOURCE_LOCATION (decl);\n }\n \n /* Compare two locations LHS and RHS.  */\n@@ -1258,7 +1247,6 @@ pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,\n \t\t  case ARRAY_TYPE:\n \t\t  case RECORD_TYPE:\n \t\t  case UNION_TYPE:\n-\t\t  case QUAL_UNION_TYPE:\n \t\t  case TYPE_DECL:\n \t\t    if (package_prefix)\n \t\t      {\n@@ -1373,10 +1361,10 @@ dump_ada_decl_name (pretty_printer *buffer, tree decl, int limited_access)\n     }\n }\n \n-/* Dump in BUFFER a name based on both T1 and T2, followed by S.  */\n+/* Dump in BUFFER a name based on both T1 and T2 followed by a suffix.  */\n \n static void\n-dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2, const char *s)\n+dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n {\n   if (DECL_NAME (t1))\n     pp_ada_tree_identifier (buffer, DECL_NAME (t1), t1, false);\n@@ -1396,7 +1384,21 @@ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2, const char *s)\n       pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (t2)));\n     }\n \n-  pp_string (buffer, s);\n+  switch (TREE_CODE (TREE_TYPE (t2)))\n+    {\n+    case ARRAY_TYPE:\n+      pp_string (buffer, \"_array\");\n+      break;\n+    case RECORD_TYPE:\n+      pp_string (buffer, \"_struct\");\n+      break;\n+    case UNION_TYPE:\n+      pp_string (buffer, \"_union\");\n+      break;\n+    default:\n+      pp_string (buffer, \"_unknown\");\n+      break;\n+    }\n }\n \n /* Dump in BUFFER pragma Import C/CPP on a given node T.  */\n@@ -1662,14 +1664,14 @@ is_char_array (tree t)\n }\n \n /* Dump in BUFFER an array type T in Ada syntax.  Assume that the \"type\"\n-   keyword and name have already been printed.  SPC is the indentation\n-   level.  */\n+   keyword and name have already been printed.  PARENT is the parent node of T.\n+   SPC is the indentation level.  */\n \n static void\n-dump_ada_array_type (pretty_printer *buffer, tree t, int spc)\n+dump_ada_array_type (pretty_printer *buffer, tree t, tree parent, int spc)\n {\n+  const bool char_array = is_char_array (t);\n   tree tmp;\n-  bool char_array = is_char_array (t);\n \n   /* Special case char arrays.  */\n   if (char_array)\n@@ -1682,21 +1684,23 @@ dump_ada_array_type (pretty_printer *buffer, tree t, int spc)\n   /* Print the dimensions.  */\n   dump_ada_array_domains (buffer, TREE_TYPE (t), spc);\n \n-  /* Retrieve array's type.  */\n+  /* Retrieve the element type.  */\n   tmp = TREE_TYPE (t);\n-  while (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE)\n+  while (TREE_CODE (tmp) == ARRAY_TYPE)\n     tmp = TREE_TYPE (tmp);\n \n   /* Print array's type.  */\n   if (!char_array)\n     {\n       pp_string (buffer, \" of \");\n \n-      if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE)\n+      if (TREE_CODE (tmp) != POINTER_TYPE)\n \tpp_string (buffer, \"aliased \");\n \n-      dump_generic_ada_node\n-\t(buffer, TREE_TYPE (tmp), TREE_TYPE (t), spc, false, true);\n+      if (TYPE_NAME (tmp) || !RECORD_OR_UNION_TYPE_P (tmp))\n+\tdump_generic_ada_node (buffer, tmp, TREE_TYPE (t), spc, false, true);\n+      else\n+\tdump_ada_double_name (buffer, parent, get_underlying_decl (tmp));\n     }\n }\n \n@@ -1759,7 +1763,8 @@ dump_ada_template (pretty_printer *buffer, tree t, int spc)\n       /* We are interested in concrete template instantiations only: skip\n \t partially specialized nodes.  */\n       if (RECORD_OR_UNION_TYPE_P (instance)\n-\t  && cpp_check && cpp_check (instance, HAS_DEPENDENT_TEMPLATE_ARGS))\n+\t  && cpp_check\n+\t  && cpp_check (instance, HAS_DEPENDENT_TEMPLATE_ARGS))\n \tcontinue;\n \n       num_inst++;\n@@ -1885,8 +1890,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \n     case ENUMERAL_TYPE:\n       if (name_only)\n-\tdump_generic_ada_node\n-\t  (buffer, TYPE_NAME (node), node, spc, 0, true);\n+\tdump_generic_ada_node (buffer, TYPE_NAME (node), node, spc, 0, true);\n       else\n \t{\n \t  tree value = TYPE_VALUES (node);\n@@ -2155,8 +2159,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t\tpp_string (buffer, \"all \");\n \t\t    }\n \n-\t\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (node))\n-\t\t      && type_name != NULL_TREE)\n+\t\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (node)) && type_name)\n \t\t    dump_generic_ada_node\n \t\t      (buffer, type_name,\n \t\t       TREE_TYPE (node), spc, is_access, true);\n@@ -2174,12 +2177,11 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \tdump_generic_ada_node\n \t  (buffer, TYPE_NAME (node), node, spc, limited_access, true);\n       else\n-\tdump_ada_array_type (buffer, node, spc);\n+\tdump_ada_array_type (buffer, node, type, spc);\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n       if (name_only)\n \t{\n \t  if (TYPE_NAME (node))\n@@ -2427,26 +2429,35 @@ print_ada_methods (pretty_printer *buffer, tree node, int spc)\n   return 1;\n }\n \n+static void dump_nested_type (pretty_printer *, tree, tree, tree, int);\n+\n /* Dump in BUFFER anonymous types nested inside T's definition.\n    PARENT is the parent node of T.\n    FORWARD indicates whether a forward declaration of T should be generated.\n-   SPC is the indentation level.  */\n+   SPC is the indentation level.\n+\n+   In C anonymous nested tagged types have no name whereas in C++ they have\n+   one.  In C their TYPE_DECL is at top level whereas in C++ it is nested.\n+   In both languages untagged types (pointers and arrays) have no name.\n+   In C++ the nested TYPE_DECLs can come after their associated FIELD_DECL.\n+\n+   Therefore, in order to have a common processing for both languages, we\n+   disregard anonymous TYPE_DECLs at top level and here we make a first\n+   pass on the nested TYPE_DECLs and a second pass on the unnamed types.  */\n \n static void\n dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n \t\t   int spc)\n {\n-  tree field, outer, decl;\n+  tree type, field;\n \n   /* Avoid recursing over the same tree.  */\n   if (TREE_VISITED (t))\n     return;\n \n-  /* Find possible anonymous arrays/unions/structs recursively.  */\n-\n-  outer = TREE_TYPE (t);\n-\n-  if (outer == NULL_TREE)\n+  /* Find possible anonymous pointers/arrays/structs/unions recursively.  */\n+  type = TREE_TYPE (t);\n+  if (type == NULL_TREE)\n     return;\n \n   if (forward)\n@@ -2458,156 +2469,147 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n       TREE_VISITED (t) = 1;\n     }\n \n-  field = TYPE_FIELDS (outer);\n-  while (field)\n-    {\n-      if (((TREE_TYPE (field) != outer\n-\t    && TREE_TYPE (field) != error_mark_node)\n-\t   || (TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE\n-\t       && TREE_TYPE (TREE_TYPE (field)) != outer))\n-\t   && (!TYPE_NAME (TREE_TYPE (field))\n-\t      || (TREE_CODE (field) == TYPE_DECL\n-\t\t  && DECL_NAME (field) != DECL_NAME (t)\n-\t\t  && TYPE_NAME (TREE_TYPE (field)) != TYPE_NAME (outer))))\n-\t{\n-\t  switch (TREE_CODE (TREE_TYPE (field)))\n-\t    {\n-\t      case POINTER_TYPE:\n-\t\tdecl = TREE_TYPE (TREE_TYPE (field));\n-\n-\t\tif (TREE_CODE (decl) == FUNCTION_TYPE)\n-\t\t  for (decl = TREE_TYPE (decl);\n-\t\t       decl && TREE_CODE (decl) == POINTER_TYPE;\n-\t\t       decl = TREE_TYPE (decl))\n-\t\t    ;\n-\n-\t\tdecl = get_underlying_decl (decl);\n-\n-\t\tif (decl\n-\t\t    && DECL_P (decl)\n-\t\t    && decl_sloc (decl, true) > decl_sloc (t, true)\n-\t\t    && DECL_SOURCE_FILE (decl) == DECL_SOURCE_FILE (t)\n-\t\t    && !TREE_VISITED (decl)\n-\t\t    && !DECL_IS_BUILTIN (decl)\n-\t\t    && (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n-\t\t\t|| TYPE_FIELDS (TREE_TYPE (decl))))\n-\t\t  {\n-\t\t    /* Generate forward declaration.  */\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    if (TREE_CODE (field) == TYPE_DECL\n+\t&& DECL_NAME (field) != DECL_NAME (t)\n+\t&& TYPE_NAME (TREE_TYPE (field)) != TYPE_NAME (type))\n+      dump_nested_type (buffer, field, t, parent, spc);\n \n-\t\t    pp_string (buffer, \"type \");\n-\t\t    dump_generic_ada_node (buffer, decl, 0, spc, false, true);\n-\t\t    pp_semicolon (buffer);\n-\t\t    newline_and_indent (buffer, spc);\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    if (!TYPE_NAME (TREE_TYPE (field)))\n+      dump_nested_type (buffer, field, t, parent, spc);\n \n-\t\t    /* Ensure we do not generate duplicate forward\n-\t\t       declarations for this type.  */\n-\t\t    TREE_VISITED (decl) = 1;\n-\t\t  }\n-\t\tbreak;\n+  TREE_VISITED (t) = 1;\n+}\n \n-\t      case ARRAY_TYPE:\n-\t\t/* Special case char arrays.  */\n-\t\tif (is_char_array (field))\n-\t\t  pp_string (buffer, \"sub\");\n+/* Dump in BUFFER the anonymous type of FIELD inside T.\n+   PARENT is the parent node of T.\n+   FORWARD indicates whether a forward declaration of T should be generated.\n+   SPC is the indentation level.  */\n \n-\t\tpp_string (buffer, \"type \");\n-\t\tdump_ada_double_name (buffer, parent, field, \"_array is \");\n-\t\tdump_ada_array_type (buffer, field, spc);\n-\t\tpp_semicolon (buffer);\n-\t\tnewline_and_indent (buffer, spc);\n-\t\tbreak;\n+static void\n+dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n+\t\t  int spc)\n+{\n+  tree field_type = TREE_TYPE (field);\n+  tree decl, tmp;\n \n-\t      case UNION_TYPE:\n-\t\tTREE_VISITED (t) = 1;\n-\t\tdump_nested_types (buffer, field, t, false, spc);\n+  switch (TREE_CODE (field_type))\n+    {\n+    case POINTER_TYPE:\n+      tmp = TREE_TYPE (field_type);\n+\n+      if (TREE_CODE (tmp) == FUNCTION_TYPE)\n+\tfor (tmp = TREE_TYPE (tmp);\n+\t     tmp && TREE_CODE (tmp) == POINTER_TYPE;\n+\t     tmp = TREE_TYPE (tmp))\n+\t  ;\n+\n+      decl = get_underlying_decl (tmp);\n+      if (decl\n+\t  && DECL_P (decl)\n+\t  && decl_sloc (decl, true) > decl_sloc (t, true)\n+\t  && DECL_SOURCE_FILE (decl) == DECL_SOURCE_FILE (t)\n+\t  && !TREE_VISITED (decl)\n+\t  && !DECL_IS_BUILTIN (decl)\n+\t  && (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n+\t      || TYPE_FIELDS (TREE_TYPE (decl))))\n+\t{\n+\t  /* Generate forward declaration.  */\n+\t  pp_string (buffer, \"type \");\n+\t  dump_generic_ada_node (buffer, decl, 0, spc, false, true);\n+\t  pp_semicolon (buffer);\n+\t  newline_and_indent (buffer, spc);\n+\t  TREE_VISITED (decl) = 1;\n+\t}\n+      break;\n \n-\t\tpp_string (buffer, \"type \");\n+    case ARRAY_TYPE:\n+      tmp = TREE_TYPE (field_type);\n+      while (TREE_CODE (tmp) == ARRAY_TYPE)\n+\ttmp = TREE_TYPE (tmp);\n+      decl = get_underlying_decl (tmp);\n+      if (decl\n+\t  && DECL_P (decl)\n+\t  && !DECL_NAME (decl)\n+\t  && !TREE_VISITED (decl))\n+\t{\n+\t  /* Generate full declaration.  */\n+\t  dump_nested_type (buffer, decl, t, parent, spc);\n+\t  TREE_VISITED (decl) = 1;\n+\t}\n \n-\t\tif (TYPE_NAME (TREE_TYPE (field)))\n-\t\t  {\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, TYPE_NAME (TREE_TYPE (field)), 0, spc, false,\n-\t\t       true);\n-\t\t    pp_string (buffer, \" (discr : unsigned := 0) is \");\n-\t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n+      /* Special case char arrays.  */\n+      if (is_char_array (field))\n+\tpp_string (buffer, \"sub\");\n \n-\t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n-\t\t    pp_string (buffer, \");\");\n-\t\t    newline_and_indent (buffer, spc);\n+      pp_string (buffer, \"type \");\n+      dump_ada_double_name (buffer, parent, field);\n+      pp_string (buffer, \" is \");\n+      dump_ada_array_type (buffer, field, parent, spc);\n+      pp_semicolon (buffer);\n+      newline_and_indent (buffer, spc);\n+      break;\n \n-\t\t    pp_string (buffer, \"pragma Unchecked_Union (\");\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n-\t\t    pp_string (buffer, \");\");\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    dump_ada_double_name\n-\t\t      (buffer, parent, field,\n-\t\t       \t\"_union (discr : unsigned := 0) is \");\n-\t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n-\t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-\t\t    dump_ada_double_name (buffer, parent, field, \"_union);\");\n-\t\t    newline_and_indent (buffer, spc);\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      if (TYPE_NAME (TREE_TYPE (t)) && !TREE_VISITED (t))\n+\t{\n+\t  pp_string (buffer, \"type \");\n+\t  dump_generic_ada_node (buffer, t, parent, spc, false, true);\n+\t  pp_semicolon (buffer);\n+\t  newline_and_indent (buffer, spc);\n+\t}\n \n-\t\t    pp_string (buffer, \"pragma Unchecked_Union (\");\n-\t\t    dump_ada_double_name (buffer, parent, field, \"_union);\");\n-\t\t  }\n+      TREE_VISITED (t) = 1;\n+      dump_nested_types (buffer, field, t, false, spc);\n \n-\t\tnewline_and_indent (buffer, spc);\n-\t\tbreak;\n+      pp_string (buffer, \"type \");\n \n-\t      case RECORD_TYPE:\n-\t\tif (TYPE_NAME (TREE_TYPE (t)) && !TREE_VISITED (t))\n-\t\t  {\n-\t\t    pp_string (buffer, \"type \");\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, t, parent, spc, false, true);\n-\t\t    pp_semicolon (buffer);\n-\t\t    newline_and_indent (buffer, spc);\n-\t\t  }\n+      if (TYPE_NAME (field_type))\n+\t{\n+\t  dump_generic_ada_node (buffer, field_type, 0, spc, false, true);\n+\t  if (TREE_CODE (field_type) == UNION_TYPE)\n+\t    pp_string (buffer, \" (discr : unsigned := 0)\");\n+\t  pp_string (buffer, \" is \");\n+\t  print_ada_struct_decl (buffer, field_type, t, spc, false);\n \n-\t\tTREE_VISITED (t) = 1;\n-\t\tdump_nested_types (buffer, field, t, false, spc);\n-\t\tpp_string (buffer, \"type \");\n+\t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n+\t  dump_generic_ada_node (buffer, field_type, 0, spc, false, true);\n+\t  pp_string (buffer, \");\");\n+\t  newline_and_indent (buffer, spc);\n \n-\t\tif (TYPE_NAME (TREE_TYPE (field)))\n-\t\t  {\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n-\t\t    pp_string (buffer, \" is \");\n-\t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n-\t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-\t\t    dump_generic_ada_node\n-\t\t      (buffer, TREE_TYPE (field), 0, spc, false, true);\n-\t\t    pp_string (buffer, \");\");\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    dump_ada_double_name\n-\t\t      (buffer, parent, field, \"_struct is \");\n-\t\t    print_ada_struct_decl\n-\t\t      (buffer, TREE_TYPE (field), t, spc, false);\n-\t\t    pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-\t\t    dump_ada_double_name (buffer, parent, field, \"_struct);\");\n-\t\t  }\n+\t  if (TREE_CODE (field_type) == UNION_TYPE)\n+\t    {\n+\t      pp_string (buffer, \"pragma Unchecked_Union (\");\n+\t      dump_generic_ada_node (buffer, field_type, 0, spc, false, true);\n+\t      pp_string (buffer, \");\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  dump_ada_double_name (buffer, parent, field);\n+\t  if (TREE_CODE (field_type) == UNION_TYPE)\n+\t    pp_string (buffer, \" (discr : unsigned := 0)\");\n+\t  pp_string (buffer, \" is \");\n+\t  print_ada_struct_decl (buffer, field_type, t, spc, false);\n \n-\t\tnewline_and_indent (buffer, spc);\n-\t\tbreak;\n+\t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n+\t  dump_ada_double_name (buffer, parent, field);\n+\t  pp_string (buffer, \");\");\n+\t  newline_and_indent (buffer, spc);\n \n-\t      default:\n-\t\tbreak;\n+\t  if (TREE_CODE (field_type) == UNION_TYPE)\n+\t    {\n+\t      pp_string (buffer, \"pragma Unchecked_Union (\");\n+\t      dump_ada_double_name (buffer, parent, field);\n+\t      pp_string (buffer, \");\");\n \t    }\n \t}\n-      field = TREE_CHAIN (field);\n-    }\n \n-  TREE_VISITED (t) = 1;\n+    default:\n+      break;\n+    }\n }\n \n /* Dump in BUFFER constructor spec corresponding to T.  */\n@@ -2706,43 +2708,17 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t}\n \n       /* Skip unnamed or anonymous structs/unions/enum types.  */\n-      if (!orig && !decl_name && !name)\n-\t{\n-\t  tree tmp;\n-\t  location_t sloc;\n-\n-\t  if (cpp_check || TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)\n-\t    return 0;\n-\n-\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      /* Search next items until finding a named type decl.  */\n-\t      sloc = decl_sloc_common (t, true, true);\n-\n-\t      for (tmp = TREE_CHAIN (t); tmp; tmp = TREE_CHAIN (tmp))\n-\t\t{\n-\t\t  if (TREE_CODE (tmp) == TYPE_DECL\n-\t\t      && (DECL_NAME (tmp) || TYPE_NAME (TREE_TYPE (tmp))))\n-\t\t    {\n-\t\t      /* If same sloc, it means we can ignore the anonymous\n-\t\t\t struct.  */\n-\t\t      if (decl_sloc_common (tmp, true, true) == sloc)\n-\t\t\treturn 0;\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\t\t}\n-\t      if (tmp == NULL)\n-\t\treturn 0;\n-\t    }\n-\t}\n+      if (!orig && !decl_name && !name\n+\t  && (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n+\t      || TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE))\n+\treturn 0;\n \n+\t/* Skip anonymous enum types (duplicates of real types).  */\n       if (!orig\n \t  && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE\n \t  && decl_name\n \t  && (*IDENTIFIER_POINTER (decl_name) == '.'\n \t      || *IDENTIFIER_POINTER (decl_name) == '$'))\n-\t/* Skip anonymous enum types (duplicates of real types).  */\n \treturn 0;\n \n       INDENT (spc);\n@@ -2751,7 +2727,6 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t{\n \t  case RECORD_TYPE:\n \t  case UNION_TYPE:\n-\t  case QUAL_UNION_TYPE:\n \t    /* Skip empty structs (typically forward references to real\n \t       structs).  */\n \t    if (!TYPE_FIELDS (TREE_TYPE (t)))\n@@ -2847,7 +2822,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t    dump_generic_ada_node\n \t      (buffer, TYPE_NAME (orig), type, spc, false, true);\n \t  else\n-\t    dump_ada_array_type (buffer, t, spc);\n+\t    dump_ada_array_type (buffer, t, type, spc);\n \t}\n       else\n \t{\n@@ -2858,23 +2833,15 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t  pp_string (buffer, \" : \");\n \n-\t  if (tmp)\n-\t    {\n-\t      if (TREE_CODE (TREE_TYPE (tmp)) != POINTER_TYPE\n-\t\t  && TREE_CODE (tmp) != INTEGER_TYPE)\n-\t\tpp_string (buffer, \"aliased \");\n+\t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (t))) != POINTER_TYPE)\n+\t    pp_string (buffer, \"aliased \");\n \n-\t      dump_generic_ada_node (buffer, tmp, type, spc, false, true);\n-\t    }\n+\t  if (tmp)\n+\t    dump_generic_ada_node (buffer, tmp, type, spc, false, true);\n+\t  else if (type)\n+\t    dump_ada_double_name (buffer, type, t);\n \t  else\n-\t    {\n-\t      pp_string (buffer, \"aliased \");\n-\n-\t      if (!type)\n-\t\tdump_ada_array_type (buffer, t, spc);\n-\t      else\n-\t\tdump_ada_double_name (buffer, type, t, \"_array\");\n-\t    }\n+\t    dump_ada_array_type (buffer, t, type, spc);\n \t}\n     }\n   else if (TREE_CODE (t) == FUNCTION_DECL)\n@@ -3017,8 +2984,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       /* Anonymous structs/unions */\n       dump_generic_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \n-      if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE\n-\t  || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE)\n+      if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n \t{\n \t  pp_string (buffer, \" (discr : unsigned := 0)\");\n \t}\n@@ -3093,9 +3059,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  tree orig = DECL_ORIGINAL_TYPE (t);\n \t  int is_subtype = orig && TYPE_NAME (orig) && orig != TREE_TYPE (t);\n \n-\t  if (!is_subtype\n-\t      && (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (t)) == QUAL_UNION_TYPE))\n+\t  if (!is_subtype && TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n \t    pp_string (buffer, \" (discr : unsigned := 0)\");\n \n \t  pp_string (buffer, \" is \");\n@@ -3109,20 +3073,15 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t  pp_string (buffer, \" : \");\n \n-\t  /* Print type declaration.  */\n-\n-\t  if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE\n-\t      && !TYPE_NAME (TREE_TYPE (t)))\n-\t    {\n-\t      dump_ada_double_name (buffer, type, t, \"_union\");\n-\t    }\n-\t  else if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t)))\n+\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      if (TREE_CODE (TREE_TYPE (t)) == RECORD_TYPE)\n-\t\tpp_string (buffer, \"aliased \");\n+\t      pp_string (buffer, \"aliased \");\n \n-\t      dump_generic_ada_node\n-\t\t(buffer, TREE_TYPE (t), t, spc, false, true);\n+\t      if (TYPE_NAME (TREE_TYPE (t)))\n+\t\tdump_generic_ada_node\n+\t\t  (buffer, TREE_TYPE (t), t, spc, false, true);\n+\t      else\n+\t\tdump_ada_double_name (buffer, type, t);\n \t    }\n \t  else\n \t    {\n@@ -3175,22 +3134,18 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t       bool display_convention)\n {\n   tree tmp;\n-  const bool is_union\n-    = TREE_CODE (node) == UNION_TYPE || TREE_CODE (node) == QUAL_UNION_TYPE;\n+  const bool is_union = (TREE_CODE (node) == UNION_TYPE);\n   char buf[32];\n   int field_num = 0;\n   int field_spc = spc + INDENT_INCR;\n   int need_semicolon;\n \n   bitfield_used = false;\n \n-  if (!TYPE_FIELDS (node))\n-    pp_string (buffer, \"null record;\");\n-  else\n+  if (TYPE_FIELDS (node))\n     {\n-      pp_string (buffer, \"record\");\n-\n       /* Print the contents of the structure.  */\n+      pp_string (buffer, \"record\");\n \n       if (is_union)\n \t{\n@@ -3230,13 +3185,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t  field_num++;\n \t\t}\n \t    }\n-\t  /* Avoid printing the structure recursively.  */\n-\t  else if (((TREE_TYPE (tmp) != node\n-\t\t     && TREE_TYPE (tmp) != error_mark_node)\n-\t\t    || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE\n-\t\t\t&& TREE_TYPE (TREE_TYPE (tmp)) != node))\n-\t\t   && TREE_CODE (tmp) != TYPE_DECL\n-\t\t   && !TREE_STATIC (tmp))\n+\t  else if (TREE_CODE (tmp) != TYPE_DECL && !TREE_STATIC (tmp))\n \t    {\n \t      /* Skip internal virtual table field.  */\n \t      if (strncmp (IDENTIFIER_POINTER (DECL_NAME (tmp)), \"_vptr\", 5))\n@@ -3281,6 +3230,8 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n       INDENT (spc);\n       pp_string (buffer, \"end record;\");\n     }\n+  else\n+    pp_string (buffer, \"null record;\");\n \n   newline_and_indent (buffer, spc);\n "}, {"sha": "25e67ca290d9886f106437bd44ecf6e2d7a14d47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f07862c7dd58714d601e776a130deb6df02bf022", "patch": "@@ -1,3 +1,9 @@\n+2015-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/dump-ada-spec-1.c: Move to...\n+\t* c-c++-common/dump-ada-spec-1.c: ...here.\n+\t* c-c++-common/dump-ada-spec-2.c: New test.\n+\n 2015-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/loop_optimization22.ad[sb]: New test."}, {"sha": "eb249e798541d6b3c23b372afe6c29c6b8272589", "filename": "gcc/testsuite/c-c++-common/dump-ada-spec-1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-1.c?ref=f07862c7dd58714d601e776a130deb6df02bf022", "previous_filename": "gcc/testsuite/gcc.dg/dump-ada-spec-1.c"}, {"sha": "46eedb582bb67db100a5a0e020f4e497a650cf63", "filename": "gcc/testsuite/c-c++-common/dump-ada-spec-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f07862c7dd58714d601e776a130deb6df02bf022/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-2.c?ref=f07862c7dd58714d601e776a130deb6df02bf022", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-ada-spec\" } */\n+\n+struct S1 {\n+  struct {\n+    int i;\n+  } F;\n+};\n+\n+struct S2 {\n+  union {\n+    int i;\n+  } F;\n+};\n+\n+struct S3 {\n+  struct {\n+    int i;\n+  } F[2];\n+};\n+\n+struct S4 {\n+  struct {\n+    struct S4 *next;\n+  } F;\n+};\n+\n+struct S5 {\n+  struct {\n+    struct S5 *next;\n+  } F[2];\n+};\n+\n+struct S6 {\n+  struct {\n+    struct S6 *next[2];\n+  } F;\n+};\n+\n+struct S7 {\n+  struct {\n+    int i;\n+  } F1[2];\n+  struct {\n+    float f;\n+  } F2[2];\n+};\n+\n+/* { dg-final { cleanup-ada-spec } } */"}]}