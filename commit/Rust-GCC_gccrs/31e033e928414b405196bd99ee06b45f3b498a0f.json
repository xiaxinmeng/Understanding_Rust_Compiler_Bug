{"sha": "31e033e928414b405196bd99ee06b45f3b498a0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFlMDMzZTkyODQxNGI0MDUxOTZiZDk5ZWUwNmI0NWYzYjQ5OGEwZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-12T20:51:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-12T20:51:53Z"}, "message": "(tstdi, cmpdi, addsi_lshrsi_31, ashldi_extsi): New patterns.\n\n(extendqidi2, extendhidi2, extendsidi2): Allow \"general_operand\" instead\nof \"register_operand\" 0.\n(adddid_sexthishl32, subdid_sexthishl32, subdi_dishl32): Likewise.\n(adddi_dilshr32): Operand 0 constraint changed from \"ro\" to \"do\";\nCode generation fixed.\n(adddi_mem, subdi_mem): Fixed for \"<\" and \">\" operand 0.\n(adddi3, subdi3): Operand 2 constraint changed from \"ao\" to \"*ao\"\n(ashldi_sexthi, ashrdi_const32): Allow only \"register_operand\"\ninstead of \"general_operand\" 0.\n(ash[lr]di_const, ash[lr]di3): Allow also 8 and 16 as shift count.\n(subreg1ashrdi_const32): Pattern deleted.\n(subreghi1ashrdi_const32, subregsi1ashrdi_const32): New pattern.\n(lshrsi_31): New implementation.\n(scc0_di, scc_di, beq0_di, bne0_di, bge0_di, blt0_di): New patterns.\n\nFrom-SVN: r9666", "tree": {"sha": "ab49a7f47e16325659e85344d2520678981c207a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab49a7f47e16325659e85344d2520678981c207a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31e033e928414b405196bd99ee06b45f3b498a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e033e928414b405196bd99ee06b45f3b498a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e033e928414b405196bd99ee06b45f3b498a0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e033e928414b405196bd99ee06b45f3b498a0f/comments", "author": null, "committer": null, "parents": [{"sha": "ff0a4409da5157eb7542b43f1dfc73b9384b90e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff0a4409da5157eb7542b43f1dfc73b9384b90e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff0a4409da5157eb7542b43f1dfc73b9384b90e3"}], "stats": {"total": 353, "additions": 311, "deletions": 42}, "files": [{"sha": "118479d37a0fb0222c7c1bb52c2fe06eca44a2c0", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 311, "deletions": 42, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e033e928414b405196bd99ee06b45f3b498a0f/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e033e928414b405196bd99ee06b45f3b498a0f/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=31e033e928414b405196bd99ee06b45f3b498a0f", "patch": "@@ -280,6 +280,21 @@\n ;; We don't want to allow a constant operand for test insns because\n ;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n ;; be folded while optimizing anyway.\n+\n+(define_insn \"tstdi\"\n+  [(set (cc0)\n+\t(match_operand:DI 0 \"nonimmediate_operand\" \"do\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[1] = adj_offsettable_operand (operands[0], 4);\n+  /* Just in case we come here. I hope all tst:DI are combined !!! */\n+  return \\\"neg%.l %1\\;negx%.l %0\\;neg%.l %1\\;negx%.l %0\\\";\n+}\")\n+\n (define_insn \"tstsi\"\n   [(set (cc0)\n \t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n@@ -383,6 +398,25 @@\n \f\n ;; compare instructions.\n \n+(define_insn \"cmpdi\"\n+  [(set (cc0)\n+;;\t(compare (match_operand:DI 0 \"general_operand\" \"=&d*a\")\n+;;\t(compare (match_operand:DI 0 \"general_operand\" \"+&d*a\")\n+;;\t(compare (match_operand:DI 0 \"general_operand\" \"+d*a\")\n+\t(compare (match_operand:DI 0 \"general_operand\" \"d*a\")\n+\t\t (match_operand:DI 1 \"general_operand\" \"d\")))\n+   (clobber (match_scratch:DI 2 \"=0\"))]\n+  \"\"\n+  \"*\n+{\n+  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  operands[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  if (DATA_REG_P (operands[0]))\n+    return \\\"sub%.l %3,%2\\;subx%.l %1,%0\\\";\n+  else\n+    return \\\"exg %/d0,%2\\;sub%.l %3,%/d0\\;exg %/d0,%0\\;subx%.l %1,%/d0\\;exg %/d0,%2\\\";\n+}\")\n+\n ;; This is the second \"hook\" for PIC code (in addition to movsi). See\n ;; comment of movsi for a description of PIC handling.\n (define_expand \"cmpsi\"\n@@ -1368,7 +1402,7 @@\n \f\n ;; zero extension instructions\n \n-;; this one is the canonical form for (lshiftrt:DI x 32)\n+;; this is the canonical form for (lshiftrt:DI x 32)\n (define_insn \"zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"general_operand\" \"ro,<,>\")\n     (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm,rm,rm\")))]\n@@ -1566,7 +1600,7 @@\n ;; sign extension instructions\n \n (define_insn \"extendqidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n \t(sign_extend:DI\n \t (match_operand:QI 1 \"general_operand\" \"rm\")))]\n   \"\"\n@@ -1581,7 +1615,7 @@\n }\")\n \n (define_insn \"extendhidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n \t(sign_extend:DI\n \t (match_operand:HI 1 \"general_operand\" \"rm\")))]\n   \"\"\n@@ -1596,7 +1630,7 @@\n }\")\n \n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n \t(sign_extend:DI\n \t (match_operand:SI 1 \"general_operand\" \"rm\")))]\n   \"\"\n@@ -1947,7 +1981,7 @@\n } \")\n \n (define_insn \"adddid_sexthishl32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"+do\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"+ro\")\n     (plus:DI (ashift:DI (sign_extend:DI\n           (match_operand:HI 1 \"general_operand\" \"rm\"))\n             (const_int 32))\n@@ -1961,7 +1995,10 @@\n } \")\n \n (define_insn \"adddi_dilshr32\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=ro\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=do\")\n+;;    (plus:DI (match_operand:DI 2 \"general_operand\" \"%0\")\n+;;\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+;;            (const_int 32))))]\n     (plus:DI (lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n             (const_int 32))\n         (match_operand:DI 2 \"general_operand\" \"0\")))]\n@@ -1970,14 +2007,17 @@\n {\n   CC_STATUS_INIT;\n   if (GET_CODE (operands[0]) == REG)\n-    operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n   else\n-    operands[0] = adj_offsettable_operand (operands[0], 4);\n-  return \\\"add%.l %1,%0\\\";\n+    operands[2] = adj_offsettable_operand (operands[0], 4);\n+  return \\\"add%.l %1,%2\\;negx%.l %0\\;neg%.l %0\\\";\n } \")\n \n (define_insn \"adddi_dishl32\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=ro\")\n+;;    (plus:DI (match_operand:DI 2 \"general_operand\" \"%0\")\n+;;\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+;;            (const_int 32))))]\n     (plus:DI (ashift:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n             (const_int 32))\n         (match_operand:DI 2 \"general_operand\" \"0\")))]\n@@ -1993,23 +2033,35 @@\n } \")\n \n (define_insn \"adddi_mem\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=m\")\n-\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=d\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,<,>\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"d,d,d\")))\n+   (clobber (match_scratch:SI 3 \"=d,d,d\"))]\n   \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n-  operands[1] = adj_offsettable_operand (operands[0], 4);\n   operands[4] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  if (which_alternative == 2)\n+    {\n+      operands[1] = gen_rtx (MEM, SImode,\n+\t       gen_rtx (PLUS, VOIDmode, XEXP(operands[0], 0),\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, -8)));\n+      return \\\"move%.l %0,%3\\;add%.l %4,%0\\;addx%.l %2,%3\\;move%.l %3,%1\\\";\n+    }\n+  if (which_alternative == 1)\n+    {\n+      operands[1] = XEXP(operands[0], 0);\n+      return \\\"add%.l %4,%0\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%1\\\";\n+    }\n+  operands[1] = adj_offsettable_operand (operands[0], 4);\n   return \\\"add%.l %4,%1\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%0\\\";\n } \")\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,<\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"ao,>,d,<\")))]\n+\t\t (match_operand:DI 2 \"general_operand\" \"*ao,>,d,<\")))]\n   \"\"\n   \"*\n {\n@@ -2033,6 +2085,39 @@\n   return \\\"add%.l %3,%1\\;negx%.l %0\\;neg%.l %0\\;add%.l %2,%0\\\";\n } \")\n \n+(define_insn \"addsi_lshrsi_31\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n+    (plus:SI (lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"rm\")\n+            (const_int 31))\n+        (match_operand:SI 2 \"general_operand\" \"1\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[2] = operands[0];\n+  operands[3] = gen_label_rtx();\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+        operands[0] = gen_rtx (MEM, SImode, XEXP (XEXP (operands[0], 0), 0));\n+      else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+        operands[2] = gen_rtx (MEM, SImode, XEXP (XEXP (operands[0], 0), 0));\n+    }\n+  output_asm_insn (\\\"mov%.l %1,%0\\\", operands);\n+#ifdef MOTOROLA\n+  output_asm_insn (\\\"jbpl %l3\\\", operands);\n+#else\n+  output_asm_insn (\\\"jpl %l3\\\", operands);\n+#endif\n+#ifndef NO_ADDSUB_Q\n+  output_asm_insn (\\\"addq%.l %#1,%2\\\", operands);\n+#else\n+  output_asm_insn (\\\"add%.l %#1,%2\\\", operands);\n+#endif\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\tCODE_LABEL_NUMBER (operands[3]));\n+  return \\\"\\\";\n+}\")\n+\n ;; Note that the middle two alternatives are near-duplicates\n ;; in order to handle insns generated by reload.\n ;; This is needed since they are not themselves reloaded,\n@@ -2508,7 +2593,7 @@\n } \")\n \n (define_insn \"subdid_sexthishl32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"+do\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"+ro\")\n     (minus:DI (match_dup 0)\n         (ashift:DI (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"rm\"))\n             (const_int 32))))\n@@ -2521,36 +2606,51 @@\n } \")\n \n (define_insn \"subdi_dishl32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"+d\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"+ro\")\n     (minus:DI (match_dup 0)\n-        (ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+        (ashift:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n             (const_int 32))))]\n   \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n-  operands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  if (GET_CODE (operands[1]) == REG)\n+    operands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else\n+    operands[1] = adj_offsettable_operand (operands[1], 4);\n   return \\\"sub%.l %1,%0\\\";\n } \")\n \n (define_insn \"subdi_mem\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=m\")\n-\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=d\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,<,>\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"d,d,d\")))\n+   (clobber (match_scratch:SI 3 \"=d,d,d\"))]\n   \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n-  operands[1] = adj_offsettable_operand (operands[0], 4);\n   operands[4] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  if (which_alternative == 2)\n+    {\n+      operands[1] = gen_rtx (MEM, SImode,\n+\t       gen_rtx (PLUS, VOIDmode, XEXP(operands[0], 0),\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, -8)));\n+      return \\\"move%.l %0,%3\\;sub%.l %4,%0\\;subx%.l %2,%3\\;move%.l %3,%1\\\";\n+    }\n+  if (which_alternative == 1)\n+    {\n+      operands[1] = XEXP(operands[0], 0);\n+      return \\\"sub%.l %4,%0\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%1\\\";\n+    }\n+  operands[1] = adj_offsettable_operand (operands[0], 4);\n   return \\\"sub%.l %4,%1\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%0\\\";\n } \")\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,<\")\n \t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"ao,>,d,<\")))]\n+\t\t (match_operand:DI 2 \"general_operand\" \"*ao,>,d,<\")))]\n   \"\"\n   \"*\n {\n@@ -3929,8 +4029,28 @@\n ;; arithmetic shift instructions\n ;; We don't need the shift memory by 1 bit instruction\n \n+(define_insn \"ashldi_extsi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=ro\")\n+    (ashift:DI\n+      (match_operator:DI 2 \"extend_operator\"\n+        [(match_operand:SI 1 \"general_operand\" \"rm\")])\n+      (const_int 32)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[2] = adj_offsettable_operand (operands[0], 4);\n+  if (ADDRESS_REG_P (operands[0]))\n+    return \\\"move%.l %1,%0\\;sub%.l %2,%2\\\";\n+  else\n+    return \\\"move%.l %1,%0\\;clr%.l %2\\\";\n+} \")\n+\n (define_insn \"ashldi_sexthi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=*da\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=*da\")\n     (ashift:DI (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"rm\"))\n         (const_int 32)))]\n   \"\"\n@@ -3970,32 +4090,39 @@\n     return \\\"move%.l %3,%0\\;clr%.l %2\\\";\n } \")\n \n+;; The predicate below must be general_operand, because ashldi3 allows that\n (define_insn \"ashldi_const\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n \t(ashift:DI (match_operand:DI 1 \"general_operand\" \"0\")\n \t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n   \"(INTVAL (operands[2]) == 1\n+    || INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n    || INTVAL (operands[2]) == 2 || INTVAL (operands[2]) == 3)\"\n   \"*\n {\n   operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n   if (INTVAL (operands[2]) == 1)\n     return \\\"add%.l %1,%1\\;addx%.l %0,%0\\\";\n+  else if (INTVAL (operands[2]) == 8)\n+    return \\\"rol%.l %#8,%1\\;rol%.l %#8,%0\\;mov%.b %1,%0\\;clr%.b %1\\\";\n+  else if (INTVAL (operands[2]) == 16)\n+    return \\\"swap %1\\;swap %0\\;mov%.w %1,%0\\;clr%.w %1\\\";\n   else if (INTVAL (operands[2]) == 2)\n     return \\\"add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\\\";\n   else/* if (INTVAL (operands[2]) == 3)*/\n     return \\\"add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\\\";\n } \")\n \n (define_expand \"ashldi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"rm\")\n-\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT\n   || (INTVAL (operands[2]) != 1 && INTVAL (operands[2]) != 32\n+     && INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16\n      && INTVAL (operands[2]) != 2 && INTVAL (operands[2]) != 3))\n     FAIL;\n } \")\n@@ -4092,7 +4219,19 @@\n   return \\\"swap %0\\;asr%.w %2,%0\\;ext%.l %0\\\";\n }\")\n \n-(define_insn \"subreg1ashrdi_const32\"\n+(define_insn \"subreghi1ashrdi_const32\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+    (subreg:HI (ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n+            (const_int 32)) 1))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) != REG)\n+    operands[1] = adj_offsettable_operand (operands[1], 2);\n+  return \\\"move%.w %1,%0\\\";\n+} \")\n+\n+(define_insn \"subregsi1ashrdi_const32\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n     (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n             (const_int 32)) 1))]\n@@ -4103,7 +4242,7 @@\n } \")\n \n (define_insn \"ashrdi_const32\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n \t\t     (const_int 32)))]\n   \"\"\n@@ -4136,33 +4275,40 @@\n     return \\\"move%.l %1,%3\\;smi %2\\;ext%.w %2\\;ext%.l %2\\;move%.l %2,%0\\\";\n } \")\n \n+;; The predicate below must be general_operand, because ashrdi3 allows that\n (define_insn \"ashrdi_const\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n \t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n \t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n   \"(INTVAL (operands[2]) == 1\n+    || INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n   || INTVAL (operands[2]) == 2 || INTVAL (operands[2]) == 3)\"\n   \"*\n {\n   operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n   CC_STATUS_INIT;\n   if (INTVAL (operands[2]) == 1)\n     return \\\"asr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+  else if (INTVAL (operands[2]) == 8)\n+    return \\\"mov%.b %0,%1\\;asr%.l %#8,%0\\;ror%.l %#8,%1\\\";\n+  else if (INTVAL (operands[2]) == 16)\n+    return \\\"mov%.w %0,%1\\;clr%.w %0\\;swap %1\\;ext%.l %0\\\";\n   else if (INTVAL (operands[2]) == 2)\n     return \\\"asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n   else/* if (INTVAL (operands[2]) == 3)*/\n     return \\\"asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n } \")\n \n (define_expand \"ashrdi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"rm\")\n-\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT\n   || (INTVAL (operands[2]) != 1 && INTVAL (operands[2]) != 32\n+     && INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16\n      && INTVAL (operands[2]) != 2 && INTVAL (operands[2]) != 3))\n     FAIL;\n } \")\n@@ -4204,6 +4350,36 @@\n \f\n ;; logical shift instructions\n \n+(define_insn \"\"\n+        [(set (cc0)\n+            (subreg:SI (lshiftrt:DI (match_operand:DI 0 \"general_operand\" \"ro\")\n+                    (const_int 32)) 1))\n+        (set (match_operand:SI 1 \"general_operand\" \"=dm\")\n+            (subreg:SI (lshiftrt:DI (match_operand:DI 2 \"general_operand\" \"0\")\n+                    (const_int 32)) 1))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"move%.l %0,%1\\\";\n+} \")\n+\n+(define_insn \"\"\n+        [(set (cc0)\n+            (subreg:SI (lshiftrt:DI (match_operand:DI 0 \"general_operand\" \"ro\")\n+                    (const_int 32)) 0))\n+        (set (match_operand:DI 1 \"general_operand\" \"=do\")\n+            (lshiftrt:DI (match_operand:DI 2 \"general_operand\" \"0\")\n+                (const_int 32)))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == REG)\n+    operands[2] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else\n+    operands[2] = adj_offsettable_operand (operands[1], 4);\n+  return \\\"move%.l %0,%2\\;clr%.l %1\\\";\n+} \")\n+\n (define_insn \"subreg1lshrdi_const32\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n     (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n@@ -4240,33 +4416,40 @@\n     return \\\"move%.l %1,%2\\;clr%.l %0\\\";\n } \")\n \n+;; The predicate below must be general_operand, because lshrdi3 allows that\n (define_insn \"lshrdi_const\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n \t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n \t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n   \"(INTVAL (operands[2]) == 1 \n+    || INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n     || INTVAL (operands[2]) == 2 || INTVAL (operands[2]) == 3)\"\n   \"*\n {\n   CC_STATUS_INIT;\n   operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n   if (INTVAL (operands[2]) == 1)\n     return \\\"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n+  else if (INTVAL (operands[2]) == 8)\n+    return \\\"mov%.b %0,%1\\;lsr%.l %#8,%0\\;ror%.l %#8,%1\\\";\n+  else if (INTVAL (operands[2]) == 16)\n+    return \\\"mov%.w %0,%1\\;clr%.w %0\\;swap %1\\;swap %0\\\";\n   else if (INTVAL (operands[2]) == 2)\n     return \\\"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n   else /*if (INTVAL (operands[2]) == 3)*/\n     return \\\"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\\\";\n } \")\n \n (define_expand \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"rm\")\n-\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT\n   || (INTVAL (operands[2]) != 1 && INTVAL (operands[2]) != 32\n+     && INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16\n       && INTVAL (operands[2]) != 2 && INTVAL (operands[2]) != 3))\n     FAIL;\n } \")\n@@ -4280,11 +4463,7 @@\n   \"\"\n   \"*\n {\n-#if defined(MOTOROLA) && !defined(CRDS)\n-  return \\\"roxl%.l %#1,%0\\;moveq%.l %#0,%d0\\;roxl%.l %#1,%0\\\";\n-#else\n-  return \\\"roxl%.l %#1,%0\\;moveq %#0,%d0\\;roxl%.l %#1,%0\\\";\n-#endif\n+  return \\\"add%.l %0,%0\\;subx%.l %0,%0\\;neg%.l %0\\\";\n }\")\n \n ;; On all 68k models, this makes faster code in a special case.\n@@ -4854,6 +5033,27 @@\n   return \\\"bftst %0{%b2:%b1}\\\";\n }\")\n \f\n+(define_insn \"scc0_di\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n+    (match_operator 1 \"valid_dbcc_comparison_p\"\n+      [(match_operand:DI 2 \"general_operand\" \"ro\") (const_int 0)]))]\n+  \"\"\n+  \"*\n+{\n+  return output_scc_di (operands[1], operands[2], const0_rtx, operands[0]);\n+} \")\n+\n+(define_insn \"scc_di\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm,dm\")\n+    (match_operator 1 \"valid_dbcc_comparison_p\"\n+      [(match_operand:DI 2 \"general_operand\" \"ro,r\")\n+       (match_operand:DI 3 \"general_operand\" \"r,ro\")]))]\n+  \"\"\n+  \"*\n+{\n+  return output_scc_di (operands[1], operands[2], operands[3], operands[0]);\n+} \")\n+\n (define_insn \"seq\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n \t(eq:QI (cc0) (const_int 0)))]\n@@ -4934,6 +5134,75 @@\n \f\n ;; Basic conditional jump instructions.\n \n+(define_insn \"beq0_di\"\n+  [(set (pc)\n+    (if_then_else (eq (match_operand:DI 0 \"general_operand\" \"d*ao,<>\")\n+            (const_int 0))\n+        (label_ref (match_operand 1 \"\" \",\"))\n+        (pc)))\n+   (clobber (match_scratch:SI 2 \"=d,d\"))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    return \\\"move%.l %0,%2\\;or%.l %0,%2\\;jbeq %l1\\\";\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[3] = adj_offsettable_operand (operands[0], 4);\n+  if (! ADDRESS_REG_P (operands[0]))\n+    return \\\"move%.l %0,%2\\;or%.l %3,%2\\;jbeq %l1\\\";\n+  operands[4] = gen_label_rtx();\n+  output_asm_insn (\\\"tst%.l %0\\;jbne %l4\\;tst%.l %3\\;jbeq %l1\\\", operands);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\tCODE_LABEL_NUMBER (operands[4]));\n+  return \\\"\\\";\n+} \")\n+\n+(define_insn \"bne0_di\"\n+  [(set (pc)\n+    (if_then_else (ne (match_operand:DI 0 \"general_operand\" \"do,*a\")\n+            (const_int 0))\n+        (label_ref (match_operand 1 \"\" \",\"))\n+        (pc)))\n+   (clobber (match_scratch:SI 2 \"=d,\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[3] = adj_offsettable_operand (operands[0], 4);\n+  if (ADDRESS_REG_P (operands[0]))\n+    return \\\"tst%.l %0\\;jbne %l1\\;tst%.l %3\\;jbne %l1\\\";\n+  else\n+    return \\\"move%.l %0,%2\\;or%.l %3,%2\\;jbne %l1\\\";\n+} \")\n+\n+(define_insn \"bge0_di\"\n+  [(set (pc)\n+    (if_then_else (ge (match_operand:DI 0 \"general_operand\" \"ro\")\n+            (const_int 0))\n+        (label_ref (match_operand 1 \"\" \"\"))\n+        (pc)))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"tst%.l %0\\;jbge %l1\\\";\n+} \")\n+\n+(define_insn \"blt0_di\"\n+  [(set (pc)\n+    (if_then_else (lt (match_operand:DI 0 \"general_operand\" \"ro\")\n+            (const_int 0))\n+        (label_ref (match_operand 1 \"\" \"\"))\n+        (pc)))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"tst%.l %0\\;jbmi %l1\\\";\n+} \")\n+\n (define_insn \"beq\"\n   [(set (pc)\n \t(if_then_else (eq (cc0)"}]}