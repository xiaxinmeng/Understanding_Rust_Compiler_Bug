{"sha": "68594ce757081d3fc7b7b7eaee1e4651d17d0d86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1OTRjZTc1NzA4MWQzZmM3YjdiN2VhZWUxZTQ2NTFkMTdkMGQ4Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-05-19T16:17:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-05-19T16:17:32Z"}, "message": "tree-inline.c (copy_body_r): Avoid generating &* during inline substitution.\n\n        * tree-inline.c (copy_body_r): Avoid generating &* during inline\n        substitution.\n\nFrom-SVN: r66964", "tree": {"sha": "699a131e3b4461d7c0822bad2bb16a829fb39ea1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/699a131e3b4461d7c0822bad2bb16a829fb39ea1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68594ce757081d3fc7b7b7eaee1e4651d17d0d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68594ce757081d3fc7b7b7eaee1e4651d17d0d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68594ce757081d3fc7b7b7eaee1e4651d17d0d86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68594ce757081d3fc7b7b7eaee1e4651d17d0d86/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b041fbe6137dd6b420fb869d17c6e7e4baaa7e55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b041fbe6137dd6b420fb869d17c6e7e4baaa7e55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b041fbe6137dd6b420fb869d17c6e7e4baaa7e55"}], "stats": {"total": 58, "additions": 44, "deletions": 14}, "files": [{"sha": "066c27330f25d216998d6656b1ad009efc595400", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68594ce757081d3fc7b7b7eaee1e4651d17d0d86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68594ce757081d3fc7b7b7eaee1e4651d17d0d86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68594ce757081d3fc7b7b7eaee1e4651d17d0d86", "patch": "@@ -1,3 +1,8 @@\n+2003-05-19  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree-inline.c (copy_body_r): Avoid generating &* during inline\n+\tsubstitution.\n+\n 2003-05-19  Andrew Macleod  <amacleod@redhat.com>\n \n \t* config/stormy16/stormy16.c (xstormy16_expand_prologue): Do"}, {"sha": "1387b9960db5e1591debbe31cbf0b044afe07448", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68594ce757081d3fc7b7b7eaee1e4651d17d0d86/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68594ce757081d3fc7b7b7eaee1e4651d17d0d86/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=68594ce757081d3fc7b7b7eaee1e4651d17d0d86", "patch": "@@ -546,19 +546,10 @@ copy_body_r (tp, walk_subtrees, data)\n      knows not to copy VAR_DECLs, etc., so this is safe.  */\n   else\n     {\n-      copy_tree_r (tp, walk_subtrees, NULL);\n-\n-      /* The copied TARGET_EXPR has never been expanded, even if the\n-\t original node was expanded already.  */\n-      if (TREE_CODE (*tp) == TARGET_EXPR && TREE_OPERAND (*tp, 3))\n-\t{\n-\t  TREE_OPERAND (*tp, 1) = TREE_OPERAND (*tp, 3);\n-\t  TREE_OPERAND (*tp, 3) = NULL_TREE;\n-\t}\n-      else if (TREE_CODE (*tp) == MODIFY_EXPR\n-\t       && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n-\t       && ((*lang_hooks.tree_inlining.auto_var_in_fn_p)\n-\t\t   (TREE_OPERAND (*tp, 0), fn)))\n+      if (TREE_CODE (*tp) == MODIFY_EXPR\n+\t  && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n+\t  && ((*lang_hooks.tree_inlining.auto_var_in_fn_p)\n+\t      (TREE_OPERAND (*tp, 0), fn)))\n \t{\n \t  /* Some assignments VAR = VAR; don't generate any rtl code\n \t     and thus don't count as variable modification.  Avoid\n@@ -572,9 +563,43 @@ copy_body_r (tp, walk_subtrees, data)\n \t      value = (tree) n->value;\n \t      STRIP_TYPE_NOPS (value);\n \t      if (TREE_CONSTANT (value) || TREE_READONLY_DECL_P (value))\n-\t\t*tp = value;\n+\t\t{\n+\t\t  *tp = value;\n+\t\t  return copy_body_r (tp, walk_subtrees, data);\n+\t\t}\n \t    }\n \t}\n+      else if (TREE_CODE (*tp) == ADDR_EXPR\n+\t       && ((*lang_hooks.tree_inlining.auto_var_in_fn_p)\n+\t\t   (TREE_OPERAND (*tp, 0), fn)))\n+\t{\n+\t  /* Get rid of &* from inline substitutions.  It can occur when\n+\t     someone takes the address of a parm or return slot passed by\n+\t     invisible reference.  */\n+\t  tree decl = TREE_OPERAND (*tp, 0), value;\n+\t  splay_tree_node n;\n+\n+\t  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+\t  if (n)\n+\t    {\n+\t      value = (tree) n->value;\n+\t      if (TREE_CODE (value) == INDIRECT_REF)\n+\t\t{\n+\t\t  *tp = convert (TREE_TYPE (*tp), TREE_OPERAND (value, 0));\n+\t\t  return copy_body_r (tp, walk_subtrees, data);\n+\t\t}\n+\t    }\n+\t}\n+\n+      copy_tree_r (tp, walk_subtrees, NULL);\n+\n+      /* The copied TARGET_EXPR has never been expanded, even if the\n+\t original node was expanded already.  */\n+      if (TREE_CODE (*tp) == TARGET_EXPR && TREE_OPERAND (*tp, 3))\n+\t{\n+\t  TREE_OPERAND (*tp, 1) = TREE_OPERAND (*tp, 3);\n+\t  TREE_OPERAND (*tp, 3) = NULL_TREE;\n+\t}\n     }\n \n   /* Keep iterating.  */"}]}