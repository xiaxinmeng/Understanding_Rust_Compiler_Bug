{"sha": "c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdmYjRjN2FhZWQ4YTA1M2RkMGE2ZjJiY2EwYzVmNTRmYTM0ZjE1NQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-16T07:46:11Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-16T07:46:11Z"}, "message": "combine.c (record_dead_and_set_regs): Iterate over hard register set with a hard_reg_set_iterator.\n\n\t* combine.c (record_dead_and_set_regs): Iterate over hard register set\n\twith a hard_reg_set_iterator.\n\t* cse.c (invalidate_for_call): Likewise.\n\t* gcse.c (compute_hash_table_work): Likewise.\n\t* loop-iv.c (simplify_using_initial_values): Likewise.\n\t* postreload-gcse.c (record_opr_changes): Likewise.\n\t* regcprop.c (copyprop_hardreg_forward_1): Likewise.\n\t* var-tracking.c (dataflow_set_clear_at_call): Likewise.\n\nFrom-SVN: r192490", "tree": {"sha": "7cc7af884adbbe7057d2fd5848ebd5f7283ab7c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cc7af884adbbe7057d2fd5848ebd5f7283ab7c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/comments", "author": null, "committer": null, "parents": [{"sha": "909881cb25b328a750ed3bf9926b924f21c1cb3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909881cb25b328a750ed3bf9926b924f21c1cb3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/909881cb25b328a750ed3bf9926b924f21c1cb3b"}], "stats": {"total": 112, "additions": 62, "deletions": 50}, "files": [{"sha": "52ef5324cbe004d6cc2dac2f9c5d764d5624fb19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -1,3 +1,14 @@\n+2012-10-16  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* combine.c (record_dead_and_set_regs): Iterate over hard register set\n+\twith a hard_reg_set_iterator.\n+\t* cse.c (invalidate_for_call): Likewise.\n+\t* gcse.c (compute_hash_table_work): Likewise.\n+\t* loop-iv.c (simplify_using_initial_values): Likewise.\n+\t* postreload-gcse.c (record_opr_changes): Likewise.\n+\t* regcprop.c (copyprop_hardreg_forward_1): Likewise.\n+\t* var-tracking.c (dataflow_set_clear_at_call): Likewise.\n+\n 2012-10-15   Easwaran Raman  <eraman@google.com>\n \n \t* optabs.c (emit_cmp_and_jump_insn_1): Add a new parameter to"}, {"sha": "bf06d4c118f846285bed89ba1378254e23a0b830", "filename": "gcc/combine.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -12317,21 +12317,21 @@ record_dead_and_set_regs (rtx insn)\n \n   if (CALL_P (insn))\n     {\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-\t  {\n-\t    reg_stat_type *rsp;\n-\n-\t    rsp = &VEC_index (reg_stat_type, reg_stat, i);\n-\t    rsp->last_set_invalid = 1;\n-\t    rsp->last_set = insn;\n-\t    rsp->last_set_value = 0;\n-\t    rsp->last_set_mode = VOIDmode;\n-\t    rsp->last_set_nonzero_bits = 0;\n-\t    rsp->last_set_sign_bit_copies = 0;\n-\t    rsp->last_death = 0;\n-\t    rsp->truncated_to_mode = VOIDmode;\n-\t  }\n+      hard_reg_set_iterator hrsi;\n+      EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, i, hrsi)\n+\t{\n+\t  reg_stat_type *rsp;\n+\n+\t  rsp = &VEC_index (reg_stat_type, reg_stat, i);\n+\t  rsp->last_set_invalid = 1;\n+\t  rsp->last_set = insn;\n+\t  rsp->last_set_value = 0;\n+\t  rsp->last_set_mode = VOIDmode;\n+\t  rsp->last_set_nonzero_bits = 0;\n+\t  rsp->last_set_sign_bit_copies = 0;\n+\t  rsp->last_death = 0;\n+\t  rsp->truncated_to_mode = VOIDmode;\n+\t}\n \n       last_call_luid = mem_last_set = DF_INSN_LUID (insn);\n "}, {"sha": "b5631f363dab78d21dc897c55e9667bb307c1b64", "filename": "gcc/cse.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -2096,24 +2096,22 @@ invalidate_for_call (void)\n   unsigned hash;\n   struct table_elt *p, *next;\n   int in_table = 0;\n+  hard_reg_set_iterator hrsi;\n \n   /* Go through all the hard registers.  For each that is clobbered in\n      a CALL_INSN, remove the register from quantity chains and update\n      reg_tick if defined.  Also see if any of these registers is currently\n      in the table.  */\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-      {\n-\tdelete_reg_equiv (regno);\n-\tif (REG_TICK (regno) >= 0)\n-\t  {\n-\t    REG_TICK (regno)++;\n-\t    SUBREG_TICKED (regno) = -1;\n-\t  }\n-\n-\tin_table |= (TEST_HARD_REG_BIT (hard_regs_in_table, regno) != 0);\n-      }\n+  EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, regno, hrsi)\n+    {\n+      delete_reg_equiv (regno);\n+      if (REG_TICK (regno) >= 0)\n+\t{\n+\t  REG_TICK (regno)++;\n+\t  SUBREG_TICKED (regno) = -1;\n+\t}\n+      in_table |= (TEST_HARD_REG_BIT (hard_regs_in_table, regno) != 0);\n+    }\n \n   /* In the case where we have no call-clobbered hard registers in the\n      table, we are done.  Otherwise, scan the table and remove any"}, {"sha": "138150b198e55b1996a2b6155faa9a363a63a096", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -1519,9 +1519,10 @@ compute_hash_table_work (struct hash_table_d *table)\n \n \t  if (CALL_P (insn))\n \t    {\n-\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-\t\t  record_last_reg_set_info (insn, regno);\n+\t      hard_reg_set_iterator hrsi;\n+\t      EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call,\n+\t\t\t\t\t      0, regno, hrsi)\n+\t\trecord_last_reg_set_info (insn, regno);\n \n \t      if (! RTL_CONST_OR_PURE_CALL_P (insn))\n \t\trecord_last_mem_set_info (insn);"}, {"sha": "43d3c4e3ede075580839510fc3674f0f814ee2e9", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -1964,12 +1964,12 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t  note_stores (PATTERN (insn), mark_altered, this_altered);\n \t  if (CALL_P (insn))\n \t    {\n-\t      int i;\n-\n \t      /* Kill all call clobbered registers.  */\n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-\t\t  SET_REGNO_REG_SET (this_altered, i);\n+\t      unsigned int i;\n+\t      hard_reg_set_iterator hrsi;\n+\t      EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call,\n+\t\t\t\t\t      0, i, hrsi)\n+\t\tSET_REGNO_REG_SET (this_altered, i);\n \t    }\n \n \t  if (suitable_set_for_replacement (insn, &dest, &src))"}, {"sha": "ab4f851b75677bea91c30e085ed2de305b202f70", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -736,10 +736,9 @@ record_opr_changes (rtx insn)\n     {\n       unsigned int regno;\n       rtx link, x;\n-\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-\t  record_last_reg_set_info_regno (insn, regno);\n+      hard_reg_set_iterator hrsi;\n+      EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, regno, hrsi)\n+\trecord_last_reg_set_info_regno (insn, regno);\n \n       for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n \tif (GET_CODE (XEXP (link, 0)) == CLOBBER)"}, {"sha": "3cda1a7c24e9b7cfb8d398353a8a0cc655c446bf", "filename": "gcc/regcprop.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -990,9 +990,12 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       /* Clobber call-clobbered registers.  */\n       if (CALL_P (insn))\n \t{\n-\t  int set_regno = INVALID_REGNUM;\n-\t  int set_nregs = 0;\n+\t  unsigned int set_regno = INVALID_REGNUM;\n+\t  unsigned int set_nregs = 0;\n+\t  unsigned int regno;\n \t  rtx exp;\n+\t  hard_reg_set_iterator hrsi;\n+\n \t  for (exp = CALL_INSN_FUNCTION_USAGE (insn); exp; exp = XEXP (exp, 1))\n \t    {\n \t      rtx x = XEXP (exp, 0);\n@@ -1009,10 +1012,10 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t\t  break;\n \t\t}\n \t    }\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i)\n-\t\t&& (i < set_regno || i >= set_regno + set_nregs))\n-\t      kill_value_regno (i, 1, vd);\n+\n+\t  EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, regno, hrsi)\n+\t    if (regno < set_regno || regno >= set_regno + set_nregs)\n+\t      kill_value_regno (regno, 1, vd);\n \t}\n \n       /* Notice stores.  */"}, {"sha": "7e6bee3e1300e106ca4a213a53832aff27b839b5", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c7fb4c7aaed8a053dd0a6f2bca0c5f54fa34f155", "patch": "@@ -4680,11 +4680,11 @@ dataflow_set_remove_mem_locs (void **slot, void *data)\n static void\n dataflow_set_clear_at_call (dataflow_set *set)\n {\n-  int r;\n+  unsigned int r;\n+  hard_reg_set_iterator hrsi;\n \n-  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, r))\n-      var_regno_delete (set, r);\n+  EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, r, hrsi)\n+    var_regno_delete (set, r);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {"}]}