{"sha": "a1ab6660ae5b348d625af230f78bbe28556b2a45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFhYjY2NjBhZTViMzQ4ZDYyNWFmMjMwZjc4YmJlMjg1NTZiMmE0NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-04T23:17:37Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-04T23:17:37Z"}, "message": "re PR fortran/38665 (ICE in check_host_association)\n\n2009-01-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38665\n\t* gfortran.h : Add bit to gfc_expr 'user_operator'\n\t* interface.c (gfc_extend_expr): Set the above if the operator\n\tis substituted by a function. \n\t* resolve.c (check_host_association): Return if above is set.\n\n2009-01-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38665\n\t* gfortran.dg/host_assoc_function_5.f90: New test.\n\nFrom-SVN: r143064", "tree": {"sha": "b3246ca0a9ecb2c3725a7c60fd783e01c918f445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3246ca0a9ecb2c3725a7c60fd783e01c918f445"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ab6660ae5b348d625af230f78bbe28556b2a45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ab6660ae5b348d625af230f78bbe28556b2a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ab6660ae5b348d625af230f78bbe28556b2a45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ab6660ae5b348d625af230f78bbe28556b2a45/comments", "author": null, "committer": null, "parents": [{"sha": "f958e3caa5a1d72b44f5da590624ec4fd86168ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f958e3caa5a1d72b44f5da590624ec4fd86168ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f958e3caa5a1d72b44f5da590624ec4fd86168ec"}], "stats": {"total": 77, "additions": 76, "deletions": 1}, "files": [{"sha": "b8fdb3b101f44bc869718e531d3cd8a6d9e935d3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a1ab6660ae5b348d625af230f78bbe28556b2a45", "patch": "@@ -1,3 +1,11 @@\n+2009-01-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38665\n+\t* gfortran.h : Add bit to gfc_expr 'user_operator'\n+\t* interface.c (gfc_extend_expr): Set the above if the operator\n+\tis substituted by a function. \n+\t* resolve.c (check_host_association): Return if above is set.\n+\n 2009-01-04  Mikael Morin  <mikael.morin@tele2.fr>\n \n \tPR fortran/35681"}, {"sha": "920fbd9bffeb8d2b57c437214a183c130a7b5760", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a1ab6660ae5b348d625af230f78bbe28556b2a45", "patch": "@@ -1553,6 +1553,10 @@ typedef struct gfc_expr\n   /* Sometimes, when an error has been emitted, it is necessary to prevent\n       it from recurring.  */\n   unsigned int error : 1;\n+  \n+  /* Mark and expression where a user operator has been substituted by\n+     a function call in interface.c(gfc_extend_expr).  */\n+  unsigned int user_operator : 1;\n \n   /* Used to quickly find a given constructor by its offset.  */\n   splay_tree con_by_offset;"}, {"sha": "f779dfa04de9c795d51eb8d03db6332f90bf28f8", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a1ab6660ae5b348d625af230f78bbe28556b2a45", "patch": "@@ -2670,6 +2670,7 @@ gfc_extend_expr (gfc_expr *e)\n   e->value.function.esym = NULL;\n   e->value.function.isym = NULL;\n   e->value.function.name = NULL;\n+  e->user_operator = 1;\n \n   if (gfc_pure (NULL) && !gfc_pure (sym))\n     {"}, {"sha": "74f8fb05114fe09c25b6a1c1770f5f4b86a6c060", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a1ab6660ae5b348d625af230f78bbe28556b2a45", "patch": "@@ -4300,7 +4300,12 @@ check_host_association (gfc_expr *e)\n   int n;\n   bool retval = e->expr_type == EXPR_FUNCTION;\n \n-  if (e->symtree == NULL || e->symtree->n.sym == NULL)\n+  /*  If the expression is the result of substitution in\n+      interface.c(gfc_extend_expr) because there is no way in\n+      which the host association can be wrong.  */\n+  if (e->symtree == NULL\n+\t|| e->symtree->n.sym == NULL\n+\t|| e->user_operator)\n     return retval;\n \n   old_sym = e->symtree->n.sym;\n@@ -4336,6 +4341,11 @@ check_host_association (gfc_expr *e)\n \t      gfc_free (e->shape);\n \t    }\n \n+/* TODO - Replace this gfc_match_rvalue with a straight replacement of\n+   actual arglists for function to function substitutions and with a\n+   conversion of the reference list to an actual arglist in the case of\n+   a variable to function replacement.  This should be quite easy since\n+   only integers and vectors can be involved.  */\t    \n \t  gfc_match_rvalue (&expr);\n \t  gfc_clear_error ();\n \t  gfc_buffer_error (0);"}, {"sha": "926a95db8ccbf6135bc8d0e97f711d402fe1303c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a1ab6660ae5b348d625af230f78bbe28556b2a45", "patch": "@@ -1,3 +1,8 @@\n+2009-01-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38665\n+\t* gfortran.dg/host_assoc_function_5.f90: New test.\n+\n 2009-01-04  Mikael Morin  <mikael.morin@tele2.fr>\n \n \tPR fortran/38669"}, {"sha": "c75202e445a98f2dea8ad6c684ed03dc58102b27", "filename": "gcc/testsuite/gfortran.dg/host_assoc_function_5.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_function_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab6660ae5b348d625af230f78bbe28556b2a45/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_function_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_function_5.f90?ref=a1ab6660ae5b348d625af230f78bbe28556b2a45", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do compile }\n+!\n+! PR fortran/38665, in which checking for host association\n+! was wrongly trying to substitute mod_symmon(mult) with\n+! mod_sympoly(mult) in the user operator expression on line\n+! 43.\n+!\n+! Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+!\n+module mod_symmon\n+ implicit none\n+\n+ public :: t_symmon, operator(*)\n+ private\n+\n+ type t_symmon\n+   integer :: ierr = 0\n+ end type t_symmon\n+\n+ interface operator(*)\n+   module procedure mult\n+ end interface\n+\n+contains\n+ elemental function mult(m1,m2) result(m)\n+  type(t_symmon), intent(in) :: m1, m2\n+  type(t_symmon) :: m\n+ end function mult\n+end module mod_symmon\n+\n+module mod_sympoly\n+ use mod_symmon\n+ implicit none\n+\n+ type t_sympol\n+   type(t_symmon), allocatable :: mons(:)\n+ end type t_sympol\n+contains\n+\n+ elemental function mult(p1,p2) result(p)\n+  type(t_sympol), intent(in) :: p1,p2\n+  type(t_sympol) :: p\n+  type(t_symmon), allocatable :: mons(:)\n+  mons(1) = p1%mons(1)*p2%mons(2)\n+ end function\n+end module\n+! { dg-final { cleanup-modules \"mod_symmon mod_sympoly\" } }"}]}