{"sha": "0494285ab09288a7f21e12ad0a9908c6a61626f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ5NDI4NWFiMDkyODhhN2YyMWUxMmFkMGE5OTA4YzZhNjE2MjZmNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-08-01T08:05:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-08-01T08:05:13Z"}, "message": "libgomp.h (struct gomp_task_depend_entry): Add redundant_out field.\n\n\t* libgomp.h (struct gomp_task_depend_entry): Add redundant_out field.\n\t(struct gomp_taskwait): New type.\n\t(struct gomp_task): Add taskwait and parent_depends_on, remove\n\tin_taskwait and taskwait_sem fields.\n\t(gomp_finish_task): Don't destroy taskwait_sem.\n\t* task.c (gomp_init_task): Don't init in_taskwait, instead init\n\ttaskwait and parent_depends_on.\n\t(GOMP_task): For if (0) tasks with depend clause that depend on\n\tearlier tasks don't defer them, instead call\n\tgomp_task_maybe_wait_for_dependencies to wait for the dependencies.\n\tInitialize redundant_out field, for redundant out entries just\n\tmove them at the end of linked list instead of removing them\n\tcompletely, and set redundant_out flag instead of redundant.\n\t(gomp_task_run_pre): Update last_parent_depends_on if scheduling\n\tthat task.\n\t(gomp_task_run_post_handle_dependers): If parent is in\n\tgomp_task_maybe_wait_for_dependencies and newly runnable task\n\tis not parent_depends_on, queue it in parent->children linked\n\tlist after all runnable tasks with parent_depends_on set.\n\tAdjust for addition of taskwait indirection.\n\t(gomp_task_run_post_remove_parent): If parent is in\n\tgomp_task_maybe_wait_for_dependencies and task to be removed\n\tis parent_depends_on, decrement n_depend and if needed awake\n\tparent.  Adjust for addition of taskwait indirection.\n\t(GOMP_taskwait): Adjust for addition of taskwait indirection.\n\t(gomp_task_maybe_wait_for_dependencies): New function.\n\t* testsuite/libgomp.c/depend-5.c: New test.\n\nFrom-SVN: r213408", "tree": {"sha": "43a82288b019555fb62bfaa6699eacac9c8fc392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43a82288b019555fb62bfaa6699eacac9c8fc392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0494285ab09288a7f21e12ad0a9908c6a61626f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0494285ab09288a7f21e12ad0a9908c6a61626f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0494285ab09288a7f21e12ad0a9908c6a61626f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0494285ab09288a7f21e12ad0a9908c6a61626f5/comments", "author": null, "committer": null, "parents": [{"sha": "bab9b7cb64b1f54019f7eeedd160b0fb3eee1724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab9b7cb64b1f54019f7eeedd160b0fb3eee1724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab9b7cb64b1f54019f7eeedd160b0fb3eee1724"}], "stats": {"total": 463, "additions": 410, "deletions": 53}, "files": [{"sha": "28a7867b73eca8aa6e5ea25ff8d09d269b8c6536", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=0494285ab09288a7f21e12ad0a9908c6a61626f5", "patch": "@@ -1,7 +1,37 @@\n+2014-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* libgomp.h (struct gomp_task_depend_entry): Add redundant_out field.\n+\t(struct gomp_taskwait): New type.\n+\t(struct gomp_task): Add taskwait and parent_depends_on, remove\n+\tin_taskwait and taskwait_sem fields.\n+\t(gomp_finish_task): Don't destroy taskwait_sem.\n+\t* task.c (gomp_init_task): Don't init in_taskwait, instead init\n+\ttaskwait and parent_depends_on.\n+\t(GOMP_task): For if (0) tasks with depend clause that depend on\n+\tearlier tasks don't defer them, instead call\n+\tgomp_task_maybe_wait_for_dependencies to wait for the dependencies.\n+\tInitialize redundant_out field, for redundant out entries just\n+\tmove them at the end of linked list instead of removing them\n+\tcompletely, and set redundant_out flag instead of redundant.\n+\t(gomp_task_run_pre): Update last_parent_depends_on if scheduling\n+\tthat task.\n+\t(gomp_task_run_post_handle_dependers): If parent is in\n+\tgomp_task_maybe_wait_for_dependencies and newly runnable task\n+\tis not parent_depends_on, queue it in parent->children linked\n+\tlist after all runnable tasks with parent_depends_on set.\n+\tAdjust for addition of taskwait indirection.\n+\t(gomp_task_run_post_remove_parent): If parent is in\n+\tgomp_task_maybe_wait_for_dependencies and task to be removed\n+\tis parent_depends_on, decrement n_depend and if needed awake\n+\tparent.  Adjust for addition of taskwait indirection.\n+\t(GOMP_taskwait): Adjust for addition of taskwait indirection.\n+\t(gomp_task_maybe_wait_for_dependencies): New function.\n+\t* testsuite/libgomp.c/depend-5.c: New test.\n+\n 2014-07-13  Tobias Burnus  <burnus@net-b.de>\n \n \t* testsuite/libgomp.fortran/pr34020.f90: Make compile\n-\twith TS 18508/Fortran 2015\n+\twith TS 18508/Fortran 2015.\n \n 2014-07-06  Marek Polacek  <polacek@redhat.com>\n "}, {"sha": "a1482ccfbf4c23ce865beb0edb3a92c0884e2b63", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=0494285ab09288a7f21e12ad0a9908c6a61626f5", "patch": "@@ -274,6 +274,7 @@ struct gomp_task_depend_entry\n   struct gomp_task *task;\n   bool is_in;\n   bool redundant;\n+  bool redundant_out;\n };\n \n struct gomp_dependers_vec\n@@ -283,6 +284,17 @@ struct gomp_dependers_vec\n   struct gomp_task *elem[];\n };\n \n+/* Used when in GOMP_taskwait or in gomp_task_maybe_wait_for_dependencies.  */\n+\n+struct gomp_taskwait\n+{\n+  bool in_taskwait;\n+  bool in_depend_wait;\n+  size_t n_depend;\n+  struct gomp_task *last_parent_depends_on;\n+  gomp_sem_t taskwait_sem;\n+};\n+\n /* This structure describes a \"task\" to be run by a thread.  */\n \n struct gomp_task\n@@ -298,17 +310,17 @@ struct gomp_task\n   struct gomp_taskgroup *taskgroup;\n   struct gomp_dependers_vec *dependers;\n   struct htab *depend_hash;\n+  struct gomp_taskwait *taskwait;\n   size_t depend_count;\n   size_t num_dependees;\n   struct gomp_task_icv icv;\n   void (*fn) (void *);\n   void *fn_data;\n   enum gomp_task_kind kind;\n-  bool in_taskwait;\n   bool in_tied_task;\n   bool final_task;\n   bool copy_ctors_done;\n-  gomp_sem_t taskwait_sem;\n+  bool parent_depends_on;\n   struct gomp_task_depend_entry depend[];\n };\n \n@@ -582,7 +594,6 @@ gomp_finish_task (struct gomp_task *task)\n {\n   if (__builtin_expect (task->depend_hash != NULL, 0))\n     free (task->depend_hash);\n-  gomp_sem_destroy (&task->taskwait_sem);\n }\n \n /* team.c */"}, {"sha": "58750eacf53eb855066ed5c9c45a92270da460a0", "filename": "libgomp/task.c", "status": "modified", "additions": 267, "deletions": 49, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=0494285ab09288a7f21e12ad0a9908c6a61626f5", "patch": "@@ -66,16 +66,16 @@ gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n   task->parent = parent_task;\n   task->icv = *prev_icv;\n   task->kind = GOMP_TASK_IMPLICIT;\n-  task->in_taskwait = false;\n+  task->taskwait = NULL;\n   task->in_tied_task = false;\n   task->final_task = false;\n   task->copy_ctors_done = false;\n+  task->parent_depends_on = false;\n   task->children = NULL;\n   task->taskgroup = NULL;\n   task->dependers = NULL;\n   task->depend_hash = NULL;\n   task->depend_count = 0;\n-  gomp_sem_init (&task->taskwait_sem, 0);\n }\n \n /* Clean up a task, after completing it.  */\n@@ -104,6 +104,8 @@ gomp_clear_parent (struct gomp_task *children)\n     while (task != children);\n }\n \n+static void gomp_task_maybe_wait_for_dependencies (void **depend);\n+\n /* Called when encountering an explicit task directive.  If IF_CLAUSE is\n    false, then we must not delay in executing the task.  If UNTIED is true,\n    then the task may be executed by any member of the team.  */\n@@ -141,35 +143,12 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \n       /* If there are depend clauses and earlier deferred sibling tasks\n \t with depend clauses, check if there isn't a dependency.  If there\n-\t is, fall through to the deferred task handling, as we can't\n-\t schedule such tasks right away.  There is no need to handle\n+\t is, we need to wait for them.  There is no need to handle\n \t depend clauses for non-deferred tasks other than this, because\n \t the parent task is suspended until the child task finishes and thus\n \t it can't start further child tasks.  */\n       if ((flags & 8) && thr->task && thr->task->depend_hash)\n-\t{\n-\t  struct gomp_task *parent = thr->task;\n-\t  struct gomp_task_depend_entry elem, *ent = NULL;\n-\t  size_t ndepend = (uintptr_t) depend[0];\n-\t  size_t nout = (uintptr_t) depend[1];\n-\t  size_t i;\n-\t  gomp_mutex_lock (&team->task_lock);\n-\t  for (i = 0; i < ndepend; i++)\n-\t    {\n-\t      elem.addr = depend[i + 2];\n-\t      ent = htab_find (parent->depend_hash, &elem);\n-\t      for (; ent; ent = ent->next)\n-\t\tif (i >= nout && ent->is_in)\n-\t\t  continue;\n-\t\telse\n-\t\t  break;\n-\t      if (ent)\n-\t\tbreak;\n-\t    }\n-\t  gomp_mutex_unlock (&team->task_lock);\n-\t  if (ent)\n-\t    goto defer;\n-\t}\n+\tgomp_task_maybe_wait_for_dependencies (depend);\n \n       gomp_init_task (&task, thr->task, gomp_icv (false));\n       task.kind = GOMP_TASK_IFFALSE;\n@@ -209,7 +188,6 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n     }\n   else\n     {\n-     defer:;\n       struct gomp_task *task;\n       struct gomp_task *parent = thr->task;\n       struct gomp_taskgroup *taskgroup = parent->taskgroup;\n@@ -275,11 +253,12 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t      task->depend[i].task = task;\n \t      task->depend[i].is_in = i >= nout;\n \t      task->depend[i].redundant = false;\n+\t      task->depend[i].redundant_out = false;\n \n \t      hash_entry_type *slot\n \t\t= htab_find_slot (&parent->depend_hash, &task->depend[i],\n \t\t\t\t  INSERT);\n-\t      hash_entry_type out = NULL;\n+\t      hash_entry_type out = NULL, last = NULL;\n \t      if (*slot)\n \t\t{\n \t\t  /* If multiple depends on the same task are the\n@@ -294,6 +273,11 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t\t    }\n \t\t  for (ent = *slot; ent; ent = ent->next)\n \t\t    {\n+\t\t      if (ent->redundant_out)\n+\t\t\tbreak;\n+\n+\t\t      last = ent;\n+\n \t\t      /* depend(in:...) doesn't depend on earlier\n \t\t\t depend(in:...).  */\n \t\t      if (i >= nout && ent->is_in)\n@@ -341,21 +325,31 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t      *slot = &task->depend[i];\n \n \t      /* There is no need to store more than one depend({,in}out:)\n-\t\t task per address in the hash table chain, because each out\n+\t\t task per address in the hash table chain for the purpose\n+\t\t of creation of deferred tasks, because each out\n \t\t depends on all earlier outs, thus it is enough to record\n \t\t just the last depend({,in}out:).  For depend(in:), we need\n \t\t to keep all of the previous ones not terminated yet, because\n \t\t a later depend({,in}out:) might need to depend on all of\n \t\t them.  So, if the new task's clause is depend({,in}out:),\n \t\t we know there is at most one other depend({,in}out:) clause\n-\t\t in the list (out) and to maintain the invariant we now\n-\t\t need to remove it from the list.  */\n+\t\t in the list (out).  For non-deferred tasks we want to see\n+\t\t all outs, so they are moved to the end of the chain,\n+\t\t after first redundant_out entry all following entries\n+\t\t should be redundant_out.  */\n \t      if (!task->depend[i].is_in && out)\n \t\t{\n-\t\t  if (out->next)\n-\t\t    out->next->prev = out->prev;\n-\t\t  out->prev->next = out->next;\n-\t\t  out->redundant = true;\n+\t\t  if (out != last)\n+\t\t    {\n+\t\t      out->next->prev = out->prev;\n+\t\t      out->prev->next = out->next;\n+\t\t      out->next = last->next;\n+\t\t      out->prev = last;\n+\t\t      last->next = out;\n+\t\t      if (out->next)\n+\t\t\tout->next->prev = out;\n+\t\t    }\n+\t\t  out->redundant_out = true;\n \t\t}\n \t    }\n \t  if (task->num_dependees)\n@@ -421,8 +415,20 @@ static inline bool\n gomp_task_run_pre (struct gomp_task *child_task, struct gomp_task *parent,\n \t\t   struct gomp_taskgroup *taskgroup, struct gomp_team *team)\n {\n-  if (parent && parent->children == child_task)\n-    parent->children = child_task->next_child;\n+  if (parent)\n+    {\n+      if (parent->children == child_task)\n+\tparent->children = child_task->next_child;\n+      if (__builtin_expect (child_task->parent_depends_on, 0)\n+\t  && parent->taskwait->last_parent_depends_on == child_task)\n+\t{\n+\t  if (child_task->prev_child->kind == GOMP_TASK_WAITING\n+\t      && child_task->prev_child->parent_depends_on)\n+\t    parent->taskwait->last_parent_depends_on = child_task->prev_child;\n+\t  else\n+\t    parent->taskwait->last_parent_depends_on = NULL;\n+\t}\n+    }\n   if (taskgroup && taskgroup->children == child_task)\n     taskgroup->children = child_task->next_taskgroup;\n   child_task->prev_queue->next_queue = child_task->next_queue;\n@@ -489,21 +495,47 @@ gomp_task_run_post_handle_dependers (struct gomp_task *child_task,\n \t{\n \t  if (parent->children)\n \t    {\n-\t      task->next_child = parent->children;\n-\t      task->prev_child = parent->children->prev_child;\n+\t      /* If parent is in gomp_task_maybe_wait_for_dependencies\n+\t\t and it doesn't need to wait for this task, put it after\n+\t\t all ready to run tasks it needs to wait for.  */\n+\t      if (parent->taskwait && parent->taskwait->last_parent_depends_on\n+\t\t  && !task->parent_depends_on)\n+\t\t{\n+\t\t  struct gomp_task *last_parent_depends_on\n+\t\t    = parent->taskwait->last_parent_depends_on;\n+\t\t  task->next_child = last_parent_depends_on->next_child;\n+\t\t  task->prev_child = last_parent_depends_on;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  task->next_child = parent->children;\n+\t\t  task->prev_child = parent->children->prev_child;\n+\t\t  parent->children = task;\n+\t\t}\n \t      task->next_child->prev_child = task;\n \t      task->prev_child->next_child = task;\n \t    }\n \t  else\n \t    {\n \t      task->next_child = task;\n \t      task->prev_child = task;\n+\t      parent->children = task;\n \t    }\n-\t  parent->children = task;\n-\t  if (parent->in_taskwait)\n+\t  if (parent->taskwait)\n \t    {\n-\t      parent->in_taskwait = false;\n-\t      gomp_sem_post (&parent->taskwait_sem);\n+\t      if (parent->taskwait->in_taskwait)\n+\t\t{\n+\t\t  parent->taskwait->in_taskwait = false;\n+\t\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n+\t\t}\n+\t      else if (parent->taskwait->in_depend_wait)\n+\t\t{\n+\t\t  parent->taskwait->in_depend_wait = false;\n+\t\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n+\t\t}\n+\t      if (parent->taskwait->last_parent_depends_on == NULL\n+\t\t  && task->parent_depends_on)\n+\t\tparent->taskwait->last_parent_depends_on = task;\n \t    }\n \t}\n       if (taskgroup)\n@@ -575,6 +607,13 @@ gomp_task_run_post_remove_parent (struct gomp_task *child_task)\n   struct gomp_task *parent = child_task->parent;\n   if (parent == NULL)\n     return;\n+  if (__builtin_expect (child_task->parent_depends_on, 0)\n+      && --parent->taskwait->n_depend == 0\n+      && parent->taskwait->in_depend_wait)\n+    {\n+      parent->taskwait->in_depend_wait = false;\n+      gomp_sem_post (&parent->taskwait->taskwait_sem);\n+    }\n   child_task->prev_child->next_child = child_task->next_child;\n   child_task->next_child->prev_child = child_task->prev_child;\n   if (parent->children != child_task)\n@@ -589,10 +628,10 @@ gomp_task_run_post_remove_parent (struct gomp_task *child_task)\n \t written by child_task->fn above is flushed\n \t before the NULL is written.  */\n       __atomic_store_n (&parent->children, NULL, MEMMODEL_RELEASE);\n-      if (parent->in_taskwait)\n+      if (parent->taskwait && parent->taskwait->in_taskwait)\n \t{\n-\t  parent->in_taskwait = false;\n-\t  gomp_sem_post (&parent->taskwait_sem);\n+\t  parent->taskwait->in_taskwait = false;\n+\t  gomp_sem_post (&parent->taskwait->taskwait_sem);\n \t}\n     }\n }\n@@ -736,6 +775,7 @@ GOMP_taskwait (void)\n   struct gomp_task *task = thr->task;\n   struct gomp_task *child_task = NULL;\n   struct gomp_task *to_free = NULL;\n+  struct gomp_taskwait taskwait;\n   int do_wake = 0;\n \n   /* The acquire barrier on load of task->children here synchronizes\n@@ -748,18 +788,194 @@ GOMP_taskwait (void)\n       || __atomic_load_n (&task->children, MEMMODEL_ACQUIRE) == NULL)\n     return;\n \n+  memset (&taskwait, 0, sizeof (taskwait));\n   gomp_mutex_lock (&team->task_lock);\n   while (1)\n     {\n       bool cancelled = false;\n       if (task->children == NULL)\n \t{\n+\t  bool destroy_taskwait = task->taskwait != NULL;\n+\t  task->taskwait = NULL;\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t  if (to_free)\n+\t    {\n+\t      gomp_finish_task (to_free);\n+\t      free (to_free);\n+\t    }\n+\t  if (destroy_taskwait)\n+\t    gomp_sem_destroy (&taskwait.taskwait_sem);\n+\t  return;\n+\t}\n+      if (task->children->kind == GOMP_TASK_WAITING)\n+\t{\n+\t  child_task = task->children;\n+\t  cancelled\n+\t    = gomp_task_run_pre (child_task, task, child_task->taskgroup,\n+\t\t\t\t team);\n+\t  if (__builtin_expect (cancelled, 0))\n+\t    {\n+\t      if (to_free)\n+\t\t{\n+\t\t  gomp_finish_task (to_free);\n+\t\t  free (to_free);\n+\t\t  to_free = NULL;\n+\t\t}\n+\t      goto finish_cancelled;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* All tasks we are waiting for are already running\n+\t     in other threads.  Wait for them.  */\n+\t  if (task->taskwait == NULL)\n+\t    {\n+\t      taskwait.in_depend_wait = false;\n+\t      gomp_sem_init (&taskwait.taskwait_sem, 0);\n+\t      task->taskwait = &taskwait;\n+\t    }\n+\t  taskwait.in_taskwait = true;\n+\t}\n+      gomp_mutex_unlock (&team->task_lock);\n+      if (do_wake)\n+\t{\n+\t  gomp_team_barrier_wake (&team->barrier, do_wake);\n+\t  do_wake = 0;\n+\t}\n+      if (to_free)\n+\t{\n+\t  gomp_finish_task (to_free);\n+\t  free (to_free);\n+\t  to_free = NULL;\n+\t}\n+      if (child_task)\n+\t{\n+\t  thr->task = child_task;\n+\t  child_task->fn (child_task->fn_data);\n+\t  thr->task = task;\n+\t}\n+      else\n+\tgomp_sem_wait (&taskwait.taskwait_sem);\n+      gomp_mutex_lock (&team->task_lock);\n+      if (child_task)\n+\t{\n+\t finish_cancelled:;\n+\t  size_t new_tasks\n+\t    = gomp_task_run_post_handle_depend (child_task, team);\n+\t  child_task->prev_child->next_child = child_task->next_child;\n+\t  child_task->next_child->prev_child = child_task->prev_child;\n+\t  if (task->children == child_task)\n+\t    {\n+\t      if (child_task->next_child != child_task)\n+\t\ttask->children = child_task->next_child;\n+\t      else\n+\t\ttask->children = NULL;\n+\t    }\n+\t  gomp_clear_parent (child_task->children);\n+\t  gomp_task_run_post_remove_taskgroup (child_task);\n+\t  to_free = child_task;\n+\t  child_task = NULL;\n+\t  team->task_count--;\n+\t  if (new_tasks > 1)\n+\t    {\n+\t      do_wake = team->nthreads - team->task_running_count\n+\t\t\t- !task->in_tied_task;\n+\t      if (do_wake > new_tasks)\n+\t\tdo_wake = new_tasks;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* This is like GOMP_taskwait, but we only wait for tasks that the\n+   upcoming task depends on.  */\n+\n+static void\n+gomp_task_maybe_wait_for_dependencies (void **depend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_task *task = thr->task;\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_task_depend_entry elem, *ent = NULL;\n+  struct gomp_taskwait taskwait;\n+  struct gomp_task *last_parent_depends_on = NULL;\n+  size_t ndepend = (uintptr_t) depend[0];\n+  size_t nout = (uintptr_t) depend[1];\n+  size_t i;\n+  size_t num_awaited = 0;\n+  struct gomp_task *child_task = NULL;\n+  struct gomp_task *to_free = NULL;\n+  int do_wake = 0;\n+\n+  gomp_mutex_lock (&team->task_lock);\n+  for (i = 0; i < ndepend; i++)\n+    {\n+      elem.addr = depend[i + 2];\n+      ent = htab_find (task->depend_hash, &elem);\n+      for (; ent; ent = ent->next)\n+\tif (i >= nout && ent->is_in)\n+\t  continue;\n+\telse\n+\t  {\n+\t    struct gomp_task *tsk = ent->task;\n+\t    if (!tsk->parent_depends_on)\n+\t      {\n+\t\ttsk->parent_depends_on = true;\n+\t\t++num_awaited;\n+\t\tif (tsk->num_dependees == 0 && tsk->kind == GOMP_TASK_WAITING)\n+\t\t  {\n+\t\t    /* If a task we need to wait for is not already\n+\t\t       running and is ready to be scheduled, move it\n+\t\t       to front, so that we run it as soon as possible.  */\n+\t\t    if (last_parent_depends_on)\n+\t\t      {\n+\t\t\ttsk->prev_child->next_child = tsk->next_child;\n+\t\t\ttsk->next_child->prev_child = tsk->prev_child;\n+\t\t\ttsk->prev_child = last_parent_depends_on;\n+\t\t\ttsk->next_child = last_parent_depends_on->next_child;\n+\t\t\ttsk->prev_child->next_child = tsk;\n+\t\t\ttsk->next_child->prev_child = tsk;\n+\t\t      }\n+\t\t    else if (tsk != task->children)\n+\t\t      {\n+\t\t\ttsk->prev_child->next_child = tsk->next_child;\n+\t\t\ttsk->next_child->prev_child = tsk->prev_child;\n+\t\t\ttsk->prev_child = task->children;\n+\t\t\ttsk->next_child = task->children->next_child;\n+\t\t\ttask->children = tsk;\n+\t\t\ttsk->prev_child->next_child = tsk;\n+\t\t\ttsk->next_child->prev_child = tsk;\n+\t\t      }\n+\t\t    last_parent_depends_on = tsk;\n+\t\t  }\n+\t      }\n+\t  }\n+    }\n+  if (num_awaited == 0)\n+    {\n+      gomp_mutex_unlock (&team->task_lock);\n+      return;\n+    }\n+\n+  memset (&taskwait, 0, sizeof (taskwait));\n+  taskwait.n_depend = num_awaited;\n+  taskwait.last_parent_depends_on = last_parent_depends_on;\n+  gomp_sem_init (&taskwait.taskwait_sem, 0);\n+  task->taskwait = &taskwait;\n+\n+  while (1)\n+    {\n+      bool cancelled = false;\n+      if (taskwait.n_depend == 0)\n+\t{\n+\t  task->taskwait = NULL;\n \t  gomp_mutex_unlock (&team->task_lock);\n \t  if (to_free)\n \t    {\n \t      gomp_finish_task (to_free);\n \t      free (to_free);\n \t    }\n+\t  gomp_sem_destroy (&taskwait.taskwait_sem);\n \t  return;\n \t}\n       if (task->children->kind == GOMP_TASK_WAITING)\n@@ -782,7 +998,7 @@ GOMP_taskwait (void)\n       else\n \t/* All tasks we are waiting for are already running\n \t   in other threads.  Wait for them.  */\n-\ttask->in_taskwait = true;\n+\ttaskwait.in_depend_wait = true;\n       gomp_mutex_unlock (&team->task_lock);\n       if (do_wake)\n \t{\n@@ -802,13 +1018,15 @@ GOMP_taskwait (void)\n \t  thr->task = task;\n \t}\n       else\n-\tgomp_sem_wait (&task->taskwait_sem);\n+\tgomp_sem_wait (&taskwait.taskwait_sem);\n       gomp_mutex_lock (&team->task_lock);\n       if (child_task)\n \t{\n \t finish_cancelled:;\n \t  size_t new_tasks\n \t    = gomp_task_run_post_handle_depend (child_task, team);\n+\t  if (child_task->parent_depends_on)\n+\t    --taskwait.n_depend;\n \t  child_task->prev_child->next_child = child_task->next_child;\n \t  child_task->next_child->prev_child = child_task->prev_child;\n \t  if (task->children == child_task)"}, {"sha": "192c6ddfeba68135b3e4a14489fe7cb55bf78ac2", "filename": "libgomp/testsuite/libgomp.c/depend-5.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0494285ab09288a7f21e12ad0a9908c6a61626f5/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-5.c?ref=0494285ab09288a7f21e12ad0a9908c6a61626f5", "patch": "@@ -0,0 +1,98 @@\n+#include <stdlib.h>\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int ifval)\n+{\n+  int x = 1, y = 2, z = 3;\n+  #pragma omp parallel\n+  #pragma omp single\n+  {\n+    #pragma omp task shared (x) depend(out: x)\n+    x = 2;\n+    #pragma omp task shared (x) depend(inout: x)\n+    {\n+      if (x != 2)\n+\tabort ();\n+      x = 3;\n+    }\n+    #pragma omp task shared (x) depend(inout: x)\n+    {\n+      if (x != 3)\n+\tabort ();\n+      x = 4;\n+    }\n+    #pragma omp task shared (z) depend(in: z)\n+    if (z != 3)\n+      abort ();\n+    #pragma omp task shared (z) depend(in: z)\n+    if (z != 3)\n+      abort ();\n+    #pragma omp task shared (z) depend(in: z)\n+    if (z != 3)\n+      abort ();\n+    #pragma omp task shared (z) depend(in: z)\n+    if (z != 3)\n+      abort ();\n+    #pragma omp task shared (z) depend(in: z)\n+    if (z != 3)\n+      abort ();\n+    #pragma omp task shared (z) depend(in: z)\n+    if (z != 3)\n+      abort ();\n+    #pragma omp task shared (y) depend(in: y)\n+    if (y != 2)\n+      abort ();\n+    #pragma omp task shared (y) depend(in: y)\n+    if (y != 2)\n+      abort ();\n+    #pragma omp task shared (y) depend(in: y)\n+    if (y != 2)\n+      abort ();\n+    #pragma omp task shared (y) depend(in: y)\n+    if (y != 2)\n+      abort ();\n+    #pragma omp task if (ifval) shared (x, y) depend(in: x) depend(inout: y)\n+    {\n+      if (x != 4 || y != 2)\n+\tabort ();\n+      y = 3;\n+    }\n+    if (ifval == 0)\n+      {\n+\t/* The above if (0) task should have waited till all\n+\t   the tasks with x and y dependencies finish.  */\n+\tif (x != 4 || y != 3)\n+\t  abort ();\n+\tx = 5;\n+\ty = 4;\n+      }\n+    #pragma omp task shared (z) depend(inout: z)\n+    {\n+      if (z != 3)\n+\tabort ();\n+      z = 4;\n+    }\n+    #pragma omp task shared (z) depend(inout: z)\n+    {\n+      if (z != 4)\n+\tabort ();\n+      z = 5;\n+    }\n+    #pragma omp taskwait\n+    if (x != (ifval ? 4 : 5) || y != (ifval ? 3 : 4) || z != 5)\n+      abort ();\n+    #pragma omp task if (ifval) shared (x, y) depend(in: x) depend(inout: y)\n+    {\n+      if (x != (ifval ? 4 : 5) || y != (ifval ? 3 : 4))\n+\tabort ();\n+    }\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  f1 (0);\n+  f1 (1);\n+  return 0;\n+}"}]}