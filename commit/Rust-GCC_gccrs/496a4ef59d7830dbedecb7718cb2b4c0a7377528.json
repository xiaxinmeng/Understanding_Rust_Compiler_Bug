{"sha": "496a4ef59d7830dbedecb7718cb2b4c0a7377528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk2YTRlZjU5ZDc4MzBkYmVkZWNiNzcxOGNiMmI0YzBhNzM3NzUyOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-25T09:02:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-25T09:02:05Z"}, "message": "tree-eh.c (tree_remove_unreachable_handlers): Handle shared labels.\n\n\t* tree-eh.c (tree_remove_unreachable_handlers): Handle shared labels.\n\t(tree_empty_eh_handler_p): Allow non-EH predecestors; allow region\n\tto be reached by different label than left.\n\t(update_eh_edges): Update comment; remove edge_to_remove if possible\n\tand return true if suceeded.\n\t(cleanup_empty_eh): Accept sharing map; handle shared regions.\n\t(cleanup_eh): Compute sharing map.\n\t* except.c (remove_eh_handler_and_replace): Add argument if we should\n\tupdate regions.\n\t(remove_unreachable_regions): Update for label sharing.\n\t(label_to_region_map): Likewise.\n\t(get_next_region_sharing_label): New function.\n\t(remove_eh_handler_and_replace): Add update_catch_try parameter; update\n\tprev_try pointers.\n\t(remove_eh_handler): Update.\n\t(remove_eh_region_and_replace_by_outer_of): New function.\n\t* except.h (struct eh_region): Add next_region_sharing_label.\n\t(remove_eh_region_and_replace_by_outer_of,\n\tget_next_region_sharing_label): Declare.\n\t* tree-cfgcleanup.c (tree_forwarder_block_p): Simplify.\n\n\t* tree-cfg.c (split_critical_edges): Split also edges where we can't\n\tinsert code even if they are not critical.\n\n\t* tree-cfg.c (gimple_can_merge_blocks_p): EH edges are unmergable.\n\t(gimple_can_remove_branch_p): EH edges won't remove branch by\n\tredirection.\n\t* tree-inline.c (update_ssa_across_abnormal_edges): Do handle\n\tupdating of non-abnormal EH edges.\n\t* tree-cfg.c (gimple_can_merge_blocks_p): EH edges are unmergable.\n\t(gimple_can_remove_branch_p): EH edges are unremovable by redirection.\n\t(split_critical_edges): Split also edges where emitting code on them\n\twill lead to splitting later.\n\nFrom-SVN: r146763", "tree": {"sha": "d9aa3a1c938bc4df3cbd34eb918dde4d83d84237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9aa3a1c938bc4df3cbd34eb918dde4d83d84237"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/496a4ef59d7830dbedecb7718cb2b4c0a7377528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496a4ef59d7830dbedecb7718cb2b4c0a7377528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496a4ef59d7830dbedecb7718cb2b4c0a7377528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496a4ef59d7830dbedecb7718cb2b4c0a7377528/comments", "author": null, "committer": null, "parents": [{"sha": "bc2a4733e2715627ca95a1bccda96a9c2be30ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2a4733e2715627ca95a1bccda96a9c2be30ea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc2a4733e2715627ca95a1bccda96a9c2be30ea5"}], "stats": {"total": 318, "additions": 252, "deletions": 66}, "files": [{"sha": "8e5d8ec40844bc678e8c3f3ea1f2483590f9d1ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -1,3 +1,43 @@\n+2009-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-eh.c (tree_remove_unreachable_handlers): Handle shared labels.\n+\t(tree_empty_eh_handler_p): Allow non-EH predecestors; allow region\n+\tto be reached by different label than left.\n+\t(update_eh_edges): Update comment; remove edge_to_remove if possible\n+\tand return true if suceeded.\n+\t(cleanup_empty_eh): Accept sharing map; handle shared regions.\n+\t(cleanup_eh): Compute sharing map.\n+\t* except.c (remove_eh_handler_and_replace): Add argument if we should\n+\tupdate regions.\n+\t(remove_unreachable_regions): Update for label sharing.\n+\t(label_to_region_map): Likewise.\n+\t(get_next_region_sharing_label): New function.\n+\t(remove_eh_handler_and_replace): Add update_catch_try parameter; update\n+\tprev_try pointers.\n+\t(remove_eh_handler): Update.\n+\t(remove_eh_region_and_replace_by_outer_of): New function.\n+\t* except.h (struct eh_region): Add next_region_sharing_label.\n+\t(remove_eh_region_and_replace_by_outer_of,\n+\tget_next_region_sharing_label): Declare.\n+\t* tree-cfgcleanup.c (tree_forwarder_block_p): Simplify.\n+\n+2009-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-cfg.c (split_critical_edges): Split also edges where we can't\n+\tinsert code even if they are not critical.\n+\n+2009-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-cfg.c (gimple_can_merge_blocks_p): EH edges are unmergable.\n+\t(gimple_can_remove_branch_p): EH edges won't remove branch by\n+\tredirection.\n+\t* tree-inline.c (update_ssa_across_abnormal_edges): Do handle\n+\tupdating of non-abnormal EH edges.\n+\t* tree-cfg.c (gimple_can_merge_blocks_p): EH edges are unmergable.\n+\t(gimple_can_remove_branch_p): EH edges are unremovable by redirection.\n+\t(split_critical_edges): Split also edges where emitting code on them\n+\twill lead to splitting later.\n+\n 2009-04-25  Uros Bizjak  <ubizjak@gmail.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "599ad6fe0c698b9b11ddbb6669728ce02aed6085", "filename": "gcc/except.c", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -145,7 +145,7 @@ static void sjlj_build_landing_pads (void);\n \n static void remove_eh_handler (struct eh_region *);\n static void remove_eh_handler_and_replace (struct eh_region *,\n-\t\t\t\t\t   struct eh_region *);\n+\t\t\t\t\t   struct eh_region *, bool);\n \n /* The return value of reachable_next_level.  */\n enum reachable_code\n@@ -742,7 +742,7 @@ remove_unreachable_regions (sbitmap reachable, sbitmap contains_stmt)\n \t    fprintf (dump_file, \"Replacing MUST_NOT_THROW region %i by %i\\n\",\n \t\t     r->region_number,\n \t\t     first_must_not_throw->region_number);\n-\t  remove_eh_handler_and_replace (r, first_must_not_throw);\n+\t  remove_eh_handler_and_replace (r, first_must_not_throw, false);\n \t  first_must_not_throw->may_contain_throw |= r->may_contain_throw;\n \t}\n       else\n@@ -757,20 +757,27 @@ remove_unreachable_regions (sbitmap reachable, sbitmap contains_stmt)\n /* Return array mapping LABEL_DECL_UID to region such that region's tree_label\n    is identical to label.  */\n \n-VEC(int,heap) *\n+VEC (int, heap) *\n label_to_region_map (void)\n {\n-  VEC(int,heap) * label_to_region = NULL;\n+  VEC (int, heap) * label_to_region = NULL;\n   int i;\n+  int idx;\n \n   VEC_safe_grow_cleared (int, heap, label_to_region,\n \t\t\t cfun->cfg->last_label_uid + 1);\n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n       struct eh_region *r = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (r && r->region_number == i\n-      \t  && r->tree_label && LABEL_DECL_UID (r->tree_label) >= 0)\n+\t  && r->tree_label && LABEL_DECL_UID (r->tree_label) >= 0)\n \t{\n+\t  if ((idx = VEC_index (int, label_to_region,\n+\t\t\t\tLABEL_DECL_UID (r->tree_label))) != 0)\n+\t      r->next_region_sharing_label =\n+\t      VEC_index (eh_region, cfun->eh->region_array, idx);\n+\t  else\n+\t    r->next_region_sharing_label = NULL;\n \t  VEC_replace (int, label_to_region, LABEL_DECL_UID (r->tree_label),\n \t\t       i);\n \t}\n@@ -785,6 +792,20 @@ num_eh_regions (void)\n   return cfun->eh->last_region_number + 1;\n }\n \n+/* Return next region sharing same label as REGION.  */\n+\n+int\n+get_next_region_sharing_label (int region)\n+{\n+  struct eh_region *r;\n+  if (!region)\n+    return 0;\n+  r = VEC_index (eh_region, cfun->eh->region_array, region);\n+  if (!r || !r->next_region_sharing_label)\n+    return 0;\n+  return r->next_region_sharing_label->region_number;\n+}\n+\n /* Set up EH labels for RTL.  */\n \n void\n@@ -2161,16 +2182,46 @@ finish_eh_generation (void)\n \f\n /* This section handles removing dead code for flow.  */\n \n-/* Splice REGION from the region tree and replace it by REPLACE etc.  */\n+/* Splice REGION from the region tree and replace it by REPLACE etc.\n+   When UPDATE_CATCH_TRY is true mind updating links from catch to try\n+   region.*/\n \n static void\n remove_eh_handler_and_replace (struct eh_region *region,\n-\t\t\t       struct eh_region *replace)\n+\t\t\t       struct eh_region *replace,\n+\t\t\t       bool update_catch_try)\n {\n   struct eh_region **pp, **pp_start, *p, *outer, *inner;\n   rtx lab;\n \n   outer = region->outer;\n+\n+  /* When we are moving the region in EH tree, update prev_try pointers.  */\n+  if (outer != replace && region->inner)\n+    {\n+      struct eh_region *prev_try = find_prev_try (replace);\n+      p = region->inner;\n+      while (p != region)\n+\t{\n+\t  if (p->type == ERT_CLEANUP)\n+\t    p->u.cleanup.prev_try = prev_try;\n+          if (p->type != ERT_TRY\n+\t      && p->type != ERT_MUST_NOT_THROW\n+\t      && (p->type != ERT_ALLOWED_EXCEPTIONS\n+\t          || p->u.allowed.type_list)\n+\t      && p->inner)\n+\t    p = p->inner;\n+\t  else if (p->next_peer)\n+\t    p = p->next_peer;\n+\t  else\n+\t    {\n+\t      while (p != region && !p->next_peer)\n+\t        p = p->outer;\n+\t      if (p != region)\n+\t\tp = p->next_peer;\n+\t    }\n+\t}\n+    }\n   /* For the benefit of efficiently handling REG_EH_REGION notes,\n      replace this region in the region array with its containing\n      region.  Note that previous region deletions may result in\n@@ -2226,7 +2277,8 @@ remove_eh_handler_and_replace (struct eh_region *region,\n       *pp_start = inner;\n     }\n \n-  if (region->type == ERT_CATCH)\n+  if (region->type == ERT_CATCH\n+      && update_catch_try)\n     {\n       struct eh_region *eh_try, *next, *prev;\n \n@@ -2260,7 +2312,7 @@ remove_eh_handler_and_replace (struct eh_region *region,\n static void\n remove_eh_handler (struct eh_region *region)\n {\n-  remove_eh_handler_and_replace (region, region->outer);\n+  remove_eh_handler_and_replace (region, region->outer, true);\n }\n \n /* Remove Eh region R that has turned out to have no code in its handler.  */\n@@ -2274,6 +2326,19 @@ remove_eh_region (int r)\n   remove_eh_handler (region);\n }\n \n+/* Remove Eh region R that has turned out to have no code in its handler\n+   and replace in by R2.  */\n+\n+void\n+remove_eh_region_and_replace_by_outer_of (int r, int r2)\n+{\n+  struct eh_region *region, *region2;\n+\n+  region = VEC_index (eh_region, cfun->eh->region_array, r);\n+  region2 = VEC_index (eh_region, cfun->eh->region_array, r2);\n+  remove_eh_handler_and_replace (region, region2->outer, true);\n+}\n+\n /* Invokes CALLBACK for every exception handler label.  Only used by old\n    loop hackery; should not be used by new code.  */\n "}, {"sha": "14a263a5e88173054517c86f9c1d8a5a427892a8", "filename": "gcc/except.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -34,6 +34,9 @@ struct GTY(()) eh_region\n   struct eh_region *inner;\n   struct eh_region *next_peer;\n \n+  /* List of regions sharing label.  */\n+  struct eh_region *next_region_sharing_label;\n+\n   /* An identifier for this region.  */\n   int region_number;\n \n@@ -155,7 +158,8 @@ extern void init_eh (void);\n extern void init_eh_for_function (void);\n \n extern rtx reachable_handlers (rtx);\n-void remove_eh_region (int);\n+extern void remove_eh_region (int);\n+extern void remove_eh_region_and_replace_by_outer_of (int, int);\n \n extern void convert_from_eh_region_ranges (void);\n extern unsigned int convert_to_eh_region_ranges (void);\n@@ -274,3 +278,4 @@ extern void set_eh_throw_stmt_table (struct function *, struct htab *);\n extern void remove_unreachable_regions (sbitmap, sbitmap);\n extern VEC(int,heap) * label_to_region_map (void);\n extern int num_eh_regions (void);\n+extern int get_next_region_sharing_label (int);"}, {"sha": "d514f450a8598436b205ed12ce4c3e8484d2424d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -1212,7 +1212,7 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n   if (!single_succ_p (a))\n     return false;\n \n-  if (single_succ_edge (a)->flags & EDGE_ABNORMAL)\n+  if (single_succ_edge (a)->flags & (EDGE_ABNORMAL | EDGE_EH))\n     return false;\n \n   if (single_succ (a) != b)\n@@ -4892,7 +4892,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n static bool\n gimple_can_remove_branch_p (const_edge e)\n {\n-  if (e->flags & EDGE_ABNORMAL)\n+  if (e->flags & (EDGE_ABNORMAL | EDGE_EH))\n     return false;\n \n   return true;\n@@ -6992,10 +6992,31 @@ split_critical_edges (void)\n   FOR_ALL_BB (bb)\n     {\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (EDGE_CRITICAL_P (e) && !(e->flags & EDGE_ABNORMAL))\n-\t  {\n+        {\n+\t  if (EDGE_CRITICAL_P (e) && !(e->flags & EDGE_ABNORMAL))\n \t    split_edge (e);\n-\t  }\n+\t  /* PRE inserts statements to edges and expects that \n+\t     since split_critical_edges was done beforehand, committing edge\n+\t     insertions will not split more edges.  In addition to critical\n+\t     edges we must split edges that have multiple successors and\n+\t     end by control flow statements, such as RESX. \n+\t     Go ahead and split them too.  This matches the logic in\n+\t     gimple_find_edge_insert_loc.  */\n+\t  else if ((!single_pred_p (e->dest)\n+\t            || phi_nodes (e->dest)\n+\t            || e->dest == EXIT_BLOCK_PTR)\n+\t\t   && e->src != ENTRY_BLOCK_PTR\n+\t           && !(e->flags & EDGE_ABNORMAL))\n+\t    {\n+\t      gimple_stmt_iterator gsi;\n+\n+\t      gsi = gsi_last_bb (e->src);\n+\t      if (!gsi_end_p (gsi)\n+\t\t  && stmt_ends_bb_p (gsi_stmt (gsi))\n+\t\t  && gimple_code (gsi_stmt (gsi)) != GIMPLE_RETURN)\n+\t\tsplit_edge (e);\n+\t    }\n+\t}\n     }\n   end_recording_case_labels ();\n   return 0;"}, {"sha": "fdd7d780ade207592d1e1dd76c04d7f77a9e65c2", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -221,9 +221,6 @@ static bool\n tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n {\n   gimple_stmt_iterator gsi;\n-  edge_iterator ei;\n-  edge e, succ;\n-  basic_block dest;\n \n   /* BB must have a single outgoing edge.  */\n   if (single_succ_p (bb) != 1\n@@ -274,23 +271,6 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n       if (dest->loop_father->header == dest)\n \treturn false;\n     }\n-\n-  /* If we have an EH edge leaving this block, make sure that the\n-     destination of this block has only one predecessor.  This ensures\n-     that we don't get into the situation where we try to remove two\n-     forwarders that go to the same basic block but are handlers for\n-     different EH regions.  */\n-  succ = single_succ_edge (bb);\n-  dest = succ->dest;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      if (e->flags & EDGE_EH)\n-        {\n-\t  if (!single_pred_p (dest))\n-\t    return false;\n-\t}\n-    }\n-\n   return true;\n }\n "}, {"sha": "c9268f9853ddb6c7fc10ccd2c29194b3040e4ecd", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 98, "deletions": 26, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -2695,8 +2695,11 @@ tree_remove_unreachable_handlers (void)\n \tif (gimple_code (stmt) == GIMPLE_LABEL && has_eh_preds)\n \t  {\n \t    int uid = LABEL_DECL_UID (gimple_label_label (stmt));\n-\t    int region = VEC_index (int, label_to_region, uid);\n-\t    SET_BIT (reachable, region);\n+\t    int region;\n+\n+\t    for (region = VEC_index (int, label_to_region, uid);\n+\t\t region; region = get_next_region_sharing_label (region))\n+\t      SET_BIT (reachable, region);\n \t  }\n \tif (gimple_code (stmt) == GIMPLE_RESX)\n \t  SET_BIT (reachable, gimple_resx_region (stmt));\n@@ -2743,8 +2746,11 @@ tree_empty_eh_handler_p (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   int region;\n+  edge_iterator ei;\n+  edge e;\n   use_operand_p imm_use;\n   gimple use_stmt;\n+  bool found = false;\n \n   gsi = gsi_last_bb (bb);\n \n@@ -2815,15 +2821,17 @@ tree_empty_eh_handler_p (basic_block bb)\n       if (gsi_end_p (gsi))\n \treturn 0;\n     }\n-  while (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n-    {\n-      if (gimple_label_label (gsi_stmt (gsi))\n-      \t  == get_eh_region_no_tree_label (region))\n-        return region;\n-      gsi_prev (&gsi);\n-      if (gsi_end_p (gsi))\n-\treturn 0;\n-    }\n+  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n+    return 0;\n+\n+  /* Be sure that there is at least on EH region reaching the block directly.\n+     After EH edge redirection, it is possible that block is reached by one handler\n+     but resumed by different.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if ((e->flags & EDGE_EH))\n+      found = true;\n+  if (found)\n+    return region;\n   return 0;\n }\n \n@@ -2955,9 +2963,12 @@ make_eh_edge_and_update_phi (struct eh_region *region, void *data)\n \n /* Make EH edges corresponding to STMT while updating PHI nodes after removal\n    empty cleanup BB_TO_REMOVE joined to BB containing STMT\n-   by EDGE_TO_REMOVE.  */\n+   by EDGE_TO_REMOVE.\n \n-static void\n+   Return if EDGE_TO_REMOVE was really removed.  It might stay reachable when\n+   not all EH regions are cleaned up.  */\n+\n+static bool\n update_eh_edges (gimple stmt, basic_block bb_to_remove, edge edge_to_remove)\n {\n   int region_nr;\n@@ -2967,6 +2978,7 @@ update_eh_edges (gimple stmt, basic_block bb_to_remove, edge edge_to_remove)\n   edge_iterator ei;\n   edge e;\n   int probability_sum = 0;\n+  bool removed = false;\n \n   info.bb_to_remove = bb_to_remove;\n   info.bb = gimple_bb (stmt);\n@@ -2980,8 +2992,6 @@ update_eh_edges (gimple stmt, basic_block bb_to_remove, edge edge_to_remove)\n   else\n     {\n       region_nr = lookup_stmt_eh_region (stmt);\n-      if (region_nr < 0)\n-\treturn;\n       is_resx = false;\n       inlinable = inlinable_call_p (stmt);\n     }\n@@ -2993,9 +3003,11 @@ update_eh_edges (gimple stmt, basic_block bb_to_remove, edge edge_to_remove)\n   /* And remove edges we didn't marked. */\n   for (ei = ei_start (info.bb->succs); (e = ei_safe_edge (ei)); )\n     {\n-      if ((e->flags & EDGE_EH) && !e->aux && e != edge_to_remove)\n+      if ((e->flags & EDGE_EH) && !e->aux)\n \t{\n \t  dominance_info_invalidated = true;\n+\t  if (e == edge_to_remove)\n+\t    removed = true;\n \t  remove_edge (e);\n \t}\n       else\n@@ -3011,16 +3023,18 @@ update_eh_edges (gimple stmt, basic_block bb_to_remove, edge edge_to_remove)\n      we get fewer consistency errors in the dumps.  */\n   if (is_resx && EDGE_COUNT (info.bb->succs) && !probability_sum)\n     EDGE_SUCC (info.bb, 0)->probability = REG_BR_PROB_BASE;\n+  return removed;\n }\n \n /* Look for basic blocks containing empty exception handler and remove them.\n    This is similar to jump forwarding, just across EH edges.  */\n \n static bool\n-cleanup_empty_eh (basic_block bb)\n+cleanup_empty_eh (basic_block bb, VEC(int,heap) * label_to_region)\n {\n   int region;\n   gimple_stmt_iterator si;\n+  edge_iterator ei;\n \n   /* When handler of EH region winds up to be empty, we can safely\n      remove it.  This leads to inner EH regions to be redirected\n@@ -3030,19 +3044,73 @@ cleanup_empty_eh (basic_block bb)\n       && all_phis_safe_to_merge (bb))\n     {\n       edge e;\n+      bool found = false, removed_some = false, has_non_eh_preds = false;\n+      gimple_stmt_iterator gsi;\n \n-      remove_eh_region (region);\n+      /* Look for all EH regions sharing label of this block.\n+         If they are not same as REGION, remove them and replace them\n+\t by outer region of REGION.  Also note if REGION itself is one\n+\t of them.  */\n \n-      while ((e = ei_safe_edge (ei_start (bb->preds))))\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        if (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n+\t  {\n+\t    int uid = LABEL_DECL_UID (gimple_label_label (gsi_stmt (gsi)));\n+\t    int r = VEC_index (int, label_to_region, uid);\n+\t    int next;\n+\n+\t    while (r)\n+\t      {\n+\t\tnext = get_next_region_sharing_label (r);\n+\t\tif (r == region)\n+\t\t  found = true;\n+\t\telse\n+\t\t  {\n+\t\t     removed_some = true;\n+\t\t     remove_eh_region_and_replace_by_outer_of (r, region);\n+\t\t     if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t       fprintf (dump_file, \"Empty EH handler %i removed and \"\n+\t\t       \t\t\"replaced by %i\\n\", r, region);\n+\t\t  }\n+\t\tr = next;\n+\t      }\n+\t  }\n+\telse\n+\t  break;\n+\n+      gcc_assert (found || removed_some);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!(e->flags & EDGE_EH))\n+\t  has_non_eh_preds = true;\n+\n+      /* When block is empty EH cleanup, but it is reachable via non-EH code too,\n+\t we can not remove the region it is resumed via, because doing so will\n+\t lead to redirection of its RESX edges.\n+\n+\t This case will be handled later after edge forwarding if the EH cleanup\n+\t is really dead.  */\n+\n+      if (found && !has_non_eh_preds)\n+        remove_eh_region (region);\n+      else if (!removed_some)\n+        return false;\n+\n+      for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n \t{\n \t  basic_block src = e->src;\n-\t  gcc_assert (e->flags & EDGE_EH);\n+\t  if (!(e->flags & EDGE_EH))\n+\t    {\n+\t      ei_next (&ei);\n+\t      continue;\n+\t    }\n \t  if (stmt_can_throw_internal (last_stmt (src)))\n-\t    update_eh_edges (last_stmt (src), bb, e);\n-\t  remove_edge (e);\n+\t    {\n+\t      if (!update_eh_edges (last_stmt (src), bb, e))\n+\t        ei_next (&ei);\n+\t    }\n+\t  else\n+\t    remove_edge (e);\n \t}\n-      if (dump_file)\n-\tfprintf (dump_file, \"Empty EH handler %i removed\\n\", region);\n \n       /* Verify that we eliminated all uses of PHI we are going to remove.\n          If we didn't, rebuild SSA on affected variable (this is allowed only\n@@ -3091,7 +3159,8 @@ cleanup_empty_eh (basic_block bb)\n \t\t}\n \t    }\n \t}\n-      delete_basic_block (bb);\n+      if (!ei_safe_edge (ei_start (bb->preds)))\n+        delete_basic_block (bb);\n       return true;\n     }\n   return false;\n@@ -3111,6 +3180,7 @@ cleanup_eh (void)\n {\n   bool changed = false;\n   basic_block bb;\n+  VEC(int,heap) * label_to_region;\n   int i;\n \n   if (!cfun->eh)\n@@ -3123,14 +3193,16 @@ cleanup_eh (void)\n \n   if (optimize)\n     {\n+      label_to_region = label_to_region_map ();\n       dominance_info_invalidated = false;\n       /* We cannot use FOR_EACH_BB, since the basic blocks may get removed.  */\n       for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n \t{\n \t  bb = BASIC_BLOCK (i);\n \t  if (bb)\n-\t    changed |= cleanup_empty_eh (bb);\n+\t    changed |= cleanup_empty_eh (bb, label_to_region);\n \t}\n+      VEC_free (int, heap, label_to_region);\n       if (dominance_info_invalidated)\n \t{\n \t  free_dominance_info (CDI_DOMINATORS);"}, {"sha": "93448802d3f5d7efeac1995dd10623c6dbf480a5", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -1608,8 +1608,6 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n \tgimple phi;\n \tgimple_stmt_iterator si;\n \n-\tgcc_assert (e->flags & EDGE_ABNORMAL);\n-\n \tif (!nonlocal_goto)\n \t  gcc_assert (e->flags & EDGE_EH);\n \n@@ -1625,7 +1623,8 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n \t    /* There shouldn't be any PHI nodes in the ENTRY_BLOCK.  */\n \t    gcc_assert (!e->dest->aux);\n \n-\t    gcc_assert (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)));\n+\t    gcc_assert ((e->flags & EDGE_EH)\n+\t\t\t|| SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)));\n \n \t    if (!is_gimple_reg (PHI_RESULT (phi)))\n \t      {"}, {"sha": "89bbe08adbd647d0209fff415b34a8ad996d512d", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496a4ef59d7830dbedecb7718cb2b4c0a7377528/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=496a4ef59d7830dbedecb7718cb2b4c0a7377528", "patch": "@@ -449,18 +449,22 @@ simulate_block (basic_block block)\n \t  simulate_stmt (stmt);\n \t}\n \n-      /* We can not predict when abnormal edges will be executed, so\n+      /* We can not predict when abnormal and EH edges will be executed, so\n \t once a block is considered executable, we consider any\n \t outgoing abnormal edges as executable.\n \n+\t TODO: This is not exactly true.  Simplifying statement might\n+\t prove it non-throwing and also computed goto can be handled\n+\t when destination is known.\n+\n \t At the same time, if this block has only one successor that is\n \t reached by non-abnormal edges, then add that successor to the\n \t worklist.  */\n       normal_edge_count = 0;\n       normal_edge = NULL;\n       FOR_EACH_EDGE (e, ei, block->succs)\n \t{\n-\t  if (e->flags & EDGE_ABNORMAL)\n+\t  if (e->flags & (EDGE_ABNORMAL | EDGE_EH))\n \t    add_control_edge (e);\n \t  else\n \t    {"}]}