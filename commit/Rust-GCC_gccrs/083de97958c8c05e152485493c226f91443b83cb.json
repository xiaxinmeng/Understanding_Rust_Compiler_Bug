{"sha": "083de97958c8c05e152485493c226f91443b83cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgzZGU5Nzk1OGM4YzA1ZTE1MjQ4NTQ5M2MyMjZmOTE0NDNiODNjYg==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2015-06-19T13:53:19Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2015-06-19T13:53:19Z"}, "message": "vrsqrts.c: New file.\n\n2015-06-19  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\t* gcc.target/aarch64/advsimd-intrinsics/vrsqrts.c: New file.\n\nFrom-SVN: r224659", "tree": {"sha": "388a4e0bf517062413563c028ddbde23d601f6be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/388a4e0bf517062413563c028ddbde23d601f6be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/083de97958c8c05e152485493c226f91443b83cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083de97958c8c05e152485493c226f91443b83cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/083de97958c8c05e152485493c226f91443b83cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083de97958c8c05e152485493c226f91443b83cb/comments", "author": null, "committer": null, "parents": [{"sha": "6c6d7550c4743b8c194b0b2695e986143d788910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6d7550c4743b8c194b0b2695e986143d788910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6d7550c4743b8c194b0b2695e986143d788910"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "05f07e7b2bc7e6d03990173349977d3ae53bd89e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083de97958c8c05e152485493c226f91443b83cb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083de97958c8c05e152485493c226f91443b83cb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=083de97958c8c05e152485493c226f91443b83cb", "patch": "@@ -1,3 +1,7 @@\n+2015-06-19  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* gcc.target/aarch64/advsimd-intrinsics/vrsqrts.c: New file.\n+\n 2015-06-19  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vrsqrte.c: New file."}, {"sha": "4531026dc4c73ec0eae03ccd83a79b1201703faf", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrsqrts.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083de97958c8c05e152485493c226f91443b83cb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvrsqrts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083de97958c8c05e152485493c226f91443b83cb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvrsqrts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvrsqrts.c?ref=083de97958c8c05e152485493c226f91443b83cb", "patch": "@@ -0,0 +1,118 @@\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+#include <math.h>\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc2796b84, 0xc2796b84 };\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc0e4a3d8, 0xc0e4a3d8,\n+\t\t\t\t\t   0xc0e4a3d8, 0xc0e4a3d8 };\n+\n+/* Expected results with input=NaN.  */\n+VECT_VAR_DECL(expected_nan,hfloat,32,2) [] = { 0x7fc00000, 0x7fc00000 };\n+VECT_VAR_DECL(expected_nan,hfloat,32,4) [] = { 0x7fc00000, 0x7fc00000,\n+\t\t\t\t\t       0x7fc00000, 0x7fc00000 };\n+\n+/* Expected results with FP special inputs values (infinity, 0).  */\n+VECT_VAR_DECL(expected_fp1,hfloat,32,2) [] = { 0xff800000, 0xff800000 };\n+VECT_VAR_DECL(expected_fp1,hfloat,32,4) [] = { 0x3fc00000, 0x3fc00000,\n+\t\t\t\t\t       0x3fc00000, 0x3fc00000 };\n+\n+/* Expected results with only FP special inputs values (infinity,\n+   0).  */\n+VECT_VAR_DECL(expected_fp2,hfloat,32,2) [] = { 0x3fc00000, 0x3fc00000 };\n+VECT_VAR_DECL(expected_fp2,hfloat,32,4) [] = { 0x3fc00000, 0x3fc00000,\n+\t\t\t\t\t       0x3fc00000, 0x3fc00000 };\n+\n+#define TEST_MSG \"VRSQRTS/VRSQRTSQ\"\n+void exec_vrsqrts(void)\n+{\n+  int i;\n+\n+  /* Basic test: y=vrsqrts(x), then store the result.  */\n+#define TEST_VRSQRTS(Q, T1, T2, W, N)\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\\\n+    vrsqrts##Q##_##T2##W(VECT_VAR(vector, T1, W, N),\t\\\n+\t\t\t VECT_VAR(vector2, T1, W, N));\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),\t\t\\\n+\t\t    VECT_VAR(vector_res, T1, W, N))\n+\n+  /* No need for integer variants.  */\n+  DECL_VARIABLE(vector, float, 32, 2);\n+  DECL_VARIABLE(vector, float, 32, 4);\n+\n+  DECL_VARIABLE(vector2, float, 32, 2);\n+  DECL_VARIABLE(vector2, float, 32, 4);\n+\n+  DECL_VARIABLE(vector_res, float, 32, 2);\n+  DECL_VARIABLE(vector_res, float, 32, 4);\n+\n+  clean_results ();\n+\n+  /* Choose init value arbitrarily.  */\n+  VDUP(vector, , float, f, 32, 2, 12.9f);\n+  VDUP(vector, q, float, f, 32, 4, 9.1f);\n+\n+  VDUP(vector2, , float, f, 32, 2, 9.9f);\n+  VDUP(vector2, q, float, f, 32, 4, 1.9f);\n+\n+  /* Apply the operator.  */\n+  TEST_VRSQRTS(, float, f, 32, 2);\n+  TEST_VRSQRTS(q, float, f, 32, 4);\n+\n+#define CMT \"\"\n+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, CMT);\n+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected, CMT);\n+\n+\n+  /* Test FP variants with special input values (NaN).  */\n+  VDUP(vector, , float, f, 32, 2, NAN);\n+  VDUP(vector2, q, float, f, 32, 4, NAN);\n+\n+  /* Apply the operator.  */\n+  TEST_VRSQRTS(, float, f, 32, 2);\n+  TEST_VRSQRTS(q, float, f, 32, 4);\n+\n+#undef CMT\n+#define CMT \" FP special (NAN) and normal values\"\n+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_nan, CMT);\n+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_nan, CMT);\n+\n+\n+  /* Test FP variants with special input values (infinity, 0).  */\n+  VDUP(vector, , float, f, 32, 2, HUGE_VALF);\n+  VDUP(vector, q, float, f, 32, 4, 0.0f);\n+  /* Restore a normal value in vector2.  */\n+  VDUP(vector2, q, float, f, 32, 4, 3.2f);\n+\n+  /* Apply the operator.  */\n+  TEST_VRSQRTS(, float, f, 32, 2);\n+  TEST_VRSQRTS(q, float, f, 32, 4);\n+\n+#undef CMT\n+#define CMT \" FP special (infinity, 0) and normal values\"\n+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp1, CMT);\n+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp1, CMT);\n+\n+\n+  /* Test FP variants with only special input values (infinity, 0).  */\n+  VDUP(vector, , float, f, 32, 2, HUGE_VALF);\n+  VDUP(vector, q, float, f, 32, 4, 0.0f);\n+  VDUP(vector2, , float, f, 32, 2, -0.0f);\n+  VDUP(vector2, q, float, f, 32, 4, HUGE_VALF);\n+\n+  /* Apply the operator.  */\n+  TEST_VRSQRTS(, float, f, 32, 2);\n+  TEST_VRSQRTS(q, float, f, 32, 4);\n+\n+#undef CMT\n+#define CMT \" only FP special (infinity, 0)\"\n+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp2, CMT);\n+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp2, CMT);\n+}\n+\n+int main (void)\n+{\n+  exec_vrsqrts ();\n+  return 0;\n+}"}]}