{"sha": "bc62e155e412fd2230ec0538e2bef86211d26301", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM2MmUxNTVlNDEyZmQyMjMwZWMwNTM4ZTJiZWY4NjIxMWQyNjMwMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-09-03T14:25:12Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-09-03T14:25:12Z"}, "message": "PR libstdc++/78595 implement insertion into maps in terms of emplace\n\nC++14 simplified the specification of the generic insert function\ntemplates to be equivalent to calling emplace (or emplace_hint).\nDefining them in terms of emplace takes care of the problems described\nin PR 78595, ensuring a single conversion to value_type is done at the\nright time.\n\n\tPR libstdc++/78595\n\t* include/bits/stl_map.h (map::insert(_Pair&&))\n\t(map::insert(const_iterator, _Pair&&)): Do emplace instead of insert.\n\t* include/bits/stl_multimap.h (multimap::insert(_Pair&&))\n\t(multimap::insert(const_iterator, _Pair&&)): Likewise.\n\t* include/bits/unordered_map.h (unordered_map::insert(_Pair&&))\n\t(unordered_map::insert(const_iterator, _Pair&&))\n\t(unordered_multimap::insert(_Pair&&))\n\t(unordered_multimap::insert(const_iterator, _Pair&&)): Likewise.\n\t* testsuite/23_containers/map/modifiers/insert/78595.cc: New test.\n\t* testsuite/23_containers/multimap/modifiers/insert/78595.cc: New test.\n\t* testsuite/23_containers/unordered_map/modifiers/78595.cc: New test.\n\t* testsuite/23_containers/unordered_multimap/modifiers/78595.cc: New\n\ttest.\n\nFrom-SVN: r264059", "tree": {"sha": "d1599d3dc442dce5d10470f835ebc341956a59ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1599d3dc442dce5d10470f835ebc341956a59ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc62e155e412fd2230ec0538e2bef86211d26301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc62e155e412fd2230ec0538e2bef86211d26301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc62e155e412fd2230ec0538e2bef86211d26301", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc62e155e412fd2230ec0538e2bef86211d26301/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6b75a69dae0cfaa9085708073ebd1853e0e6102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b75a69dae0cfaa9085708073ebd1853e0e6102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b75a69dae0cfaa9085708073ebd1853e0e6102"}], "stats": {"total": 565, "additions": 523, "deletions": 42}, "files": [{"sha": "763da9ea7782bd911ecc94e14a20ddbd90bb07f7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -1,3 +1,20 @@\n+2018-09-03  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/78595\n+\t* include/bits/stl_map.h (map::insert(_Pair&&))\n+\t(map::insert(const_iterator, _Pair&&)): Do emplace instead of insert.\n+\t* include/bits/stl_multimap.h (multimap::insert(_Pair&&))\n+\t(multimap::insert(const_iterator, _Pair&&)): Likewise.\n+\t* include/bits/unordered_map.h (unordered_map::insert(_Pair&&))\n+\t(unordered_map::insert(const_iterator, _Pair&&))\n+\t(unordered_multimap::insert(_Pair&&))\n+\t(unordered_multimap::insert(const_iterator, _Pair&&)): Likewise.\n+\t* testsuite/23_containers/map/modifiers/insert/78595.cc: New test.\n+\t* testsuite/23_containers/multimap/modifiers/insert/78595.cc: New test.\n+\t* testsuite/23_containers/unordered_map/modifiers/78595.cc: New test.\n+\t* testsuite/23_containers/unordered_multimap/modifiers/78595.cc: New\n+\ttest.\n+\n 2018-09-02  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/debug/safe_iterator.h"}, {"sha": "6ce9c3e1f601139bdb40252ab25e19388b898deb", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -808,12 +808,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(value_type&& __x)\n       { return _M_t._M_insert_unique(std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\tstd::pair<iterator, bool>\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair>::value,\n+\t\t      pair<iterator, bool>>\n \tinsert(_Pair&& __x)\n-\t{ return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }\n+\t{ return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }\n #endif\n       // @}\n \n@@ -869,13 +868,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(const_iterator __position, value_type&& __x)\n       { return _M_t._M_insert_unique_(__position, std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\titerator\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>\n \tinsert(const_iterator __position, _Pair&& __x)\n-\t{ return _M_t._M_insert_unique_(__position,\n-\t\t\t\t\tstd::forward<_Pair>(__x)); }\n+\t{\n+\t  return _M_t._M_emplace_hint_unique(__position,\n+\t\t\t\t\t     std::forward<_Pair>(__x));\n+\t}\n #endif\n       // @}\n "}, {"sha": "d49738707630d4b97a7003eb773c5df031b75fa7", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -544,12 +544,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(value_type&& __x)\n       { return _M_t._M_insert_equal(std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\titerator\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>\n \tinsert(_Pair&& __x)\n-\t{ return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }\n+\t{ return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }\n #endif\n       // @}\n \n@@ -589,13 +587,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(const_iterator __position, value_type&& __x)\n       { return _M_t._M_insert_equal_(__position, std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\titerator\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>\n \tinsert(const_iterator __position, _Pair&& __x)\n-\t{ return _M_t._M_insert_equal_(__position,\n-\t\t\t\t       std::forward<_Pair>(__x)); }\n+\t{\n+\t  return _M_t._M_emplace_hint_equal(__position,\n+\t\t\t\t\t    std::forward<_Pair>(__x));\n+\t}\n #endif\n       // @}\n "}, {"sha": "94ce8cdb482de5991a2b64acd5a1701c77f003a3", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -585,12 +585,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(value_type&& __x)\n       { return _M_h.insert(std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\tstd::pair<iterator, bool>\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair&&>::value,\n+\t\t      pair<iterator, bool>>\n \tinsert(_Pair&& __x)\n-        { return _M_h.insert(std::forward<_Pair>(__x)); }\n+        { return _M_h.emplace(std::forward<_Pair>(__x)); }\n       //@}\n \n       //@{\n@@ -625,12 +624,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(const_iterator __hint, value_type&& __x)\n       { return _M_h.insert(__hint, std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\titerator\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>\n \tinsert(const_iterator __hint, _Pair&& __x)\n-\t{ return _M_h.insert(__hint, std::forward<_Pair>(__x)); }\n+\t{ return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }\n       //@}\n \n       /**\n@@ -1571,12 +1568,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(value_type&& __x)\n       { return _M_h.insert(std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\titerator\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>\n \tinsert(_Pair&& __x)\n-        { return _M_h.insert(std::forward<_Pair>(__x)); }\n+        { return _M_h.emplace(std::forward<_Pair>(__x)); }\n       //@}\n \n       //@{\n@@ -1609,12 +1604,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(const_iterator __hint, value_type&& __x)\n       { return _M_h.insert(__hint, std::move(__x)); }\n \n-      template<typename _Pair, typename = typename\n-\t       std::enable_if<std::is_constructible<value_type,\n-\t\t\t\t\t\t    _Pair&&>::value>::type>\n-\titerator\n+      template<typename _Pair>\n+\t__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>\n \tinsert(const_iterator __hint, _Pair&& __x)\n-        { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }\n+        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }\n       //@}\n \n       /**"}, {"sha": "187d165b0834b67ee1516ddfb0fe080af23f4a3e", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/insert/78595.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F78595.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F78595.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F78595.cc?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  struct X {\n+    mutable int conversions = 0;\n+\n+    operator std::pair<const int, int>() const {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::map<int, int> m;\n+  m.insert(X());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), X());\n+  VERIFY( m.size() == 1 );\n+\n+}\n+void\n+test02()\n+{\n+  struct Y {\n+    int conversions = 0;\n+\n+    operator std::pair<const int, int>() && {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::map<int, int> m;\n+  m.insert(Y());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), Y());\n+  VERIFY( m.size() == 1 );\n+}\n+\n+struct Key {\n+  int key;\n+  bool operator<(const Key& r) const { return key < r.key; }\n+};\n+\n+struct Z {\n+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }\n+  int z;\n+};\n+\n+template<typename T>\n+struct Alloc\n+{\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U>&) { }\n+\n+  using value_type = T;\n+\n+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }\n+\n+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }\n+\n+  template<typename U>\n+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }\n+\n+  template<typename U>\n+    bool operator==(const Alloc<U>&) { return true; }\n+\n+  template<typename U>\n+    bool operator!=(const Alloc<U>&) { return false; }\n+};\n+\n+void\n+test03()\n+{\n+  std::map<Key, int, std::less<Key>, Alloc<std::pair<const Key, int>>> m;\n+  m.insert(Z{});\n+  m.insert(Z{});\n+  VERIFY( m.size() == 1 );\n+  m.insert(Z{});\n+  m.insert(Z{1});\n+  VERIFY( m.size() == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "2f357fcae95b7a0e1e38fea3706924190146d204", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/78595.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F78595.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F78595.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F78595.cc?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  struct X {\n+    mutable int conversions = 0;\n+\n+    operator std::pair<const int, int>() const {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::multimap<int, int> m;\n+  m.insert(X());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), X());\n+  VERIFY( m.size() == 2 );\n+\n+}\n+void\n+test02()\n+{\n+  struct Y {\n+    int conversions = 0;\n+\n+    operator std::pair<const int, int>() && {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::multimap<int, int> m;\n+  m.insert(Y());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), Y());\n+  VERIFY( m.size() == 2 );\n+}\n+\n+struct Key {\n+  int key;\n+  bool operator<(const Key& r) const { return key < r.key; }\n+};\n+\n+struct Z {\n+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }\n+  int z;\n+};\n+\n+template<typename T>\n+struct Alloc\n+{\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U>&) { }\n+\n+  using value_type = T;\n+\n+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }\n+\n+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }\n+\n+  template<typename U>\n+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }\n+\n+  template<typename U>\n+    bool operator==(const Alloc<U>&) { return true; }\n+\n+  template<typename U>\n+    bool operator!=(const Alloc<U>&) { return false; }\n+};\n+\n+void\n+test03()\n+{\n+  std::multimap<Key, int, std::less<Key>, Alloc<std::pair<const Key, int>>> m;\n+  m.insert(Z{});\n+  m.insert(Z{});\n+  VERIFY( m.size() == 2 );\n+  m.insert(Z{});\n+  m.insert(Z{1});\n+  VERIFY( m.size() == 4 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "47cd67b86d847436b8a2db6726aba29d20f03adf", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/78595.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2F78595.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2F78595.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2F78595.cc?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -0,0 +1,122 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  struct X {\n+    mutable int conversions = 0;\n+\n+    operator std::pair<const int, int>() const {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::unordered_map<int, int> m;\n+  m.insert(X());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), X());\n+  VERIFY( m.size() == 1 );\n+\n+}\n+void\n+test02()\n+{\n+  struct Y {\n+    int conversions = 0;\n+\n+    operator std::pair<const int, int>() && {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::unordered_map<int, int> m;\n+  m.insert(Y());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), Y());\n+  VERIFY( m.size() == 1 );\n+}\n+\n+struct Key {\n+  int key;\n+  bool operator==(const Key& r) const { return key == r.key; }\n+};\n+\n+namespace std {\n+  template<> struct hash<Key> {\n+    size_t operator()(const Key& k) const { return std::hash<int>()(k.key); }\n+  };\n+}\n+\n+struct Z {\n+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }\n+  int z;\n+};\n+\n+template<typename T>\n+struct Alloc\n+{\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U>&) { }\n+\n+  using value_type = T;\n+\n+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }\n+\n+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }\n+\n+  template<typename U>\n+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }\n+\n+  template<typename U>\n+    bool operator==(const Alloc<U>&) { return true; }\n+\n+  template<typename U>\n+    bool operator!=(const Alloc<U>&) { return false; }\n+};\n+\n+void\n+test03()\n+{\n+  std::unordered_map<Key, int, std::hash<Key>, std::equal_to<Key>,\n+\t\t     Alloc<std::pair<const Key, int>>> m;\n+  m.insert(Z{});\n+  m.insert(Z{});\n+  VERIFY( m.size() == 1 );\n+  m.insert(Z{});\n+  m.insert(Z{1});\n+  VERIFY( m.size() == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "e47c20cad81f8e3bb453249bd88168137e76ba52", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/modifiers/78595.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2F78595.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc62e155e412fd2230ec0538e2bef86211d26301/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2F78595.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2F78595.cc?ref=bc62e155e412fd2230ec0538e2bef86211d26301", "patch": "@@ -0,0 +1,122 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  struct X {\n+    mutable int conversions = 0;\n+\n+    operator std::pair<const int, int>() const {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::unordered_multimap<int, int> m;\n+  m.insert(X());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), X());\n+  VERIFY( m.size() == 2 );\n+\n+}\n+void\n+test02()\n+{\n+  struct Y {\n+    int conversions = 0;\n+\n+    operator std::pair<const int, int>() && {\n+      if (++conversions > 1)\n+\tthrow 1;\n+      return {};\n+    }\n+  };\n+\n+  std::unordered_multimap<int, int> m;\n+  m.insert(Y());\n+  VERIFY( m.size() == 1 );\n+  m.insert(m.begin(), Y());\n+  VERIFY( m.size() == 2 );\n+}\n+\n+struct Key {\n+  int key;\n+  bool operator==(const Key& r) const { return key == r.key; }\n+};\n+\n+namespace std {\n+  template<> struct hash<Key> {\n+    size_t operator()(const Key& k) const { return std::hash<int>()(k.key); }\n+  };\n+}\n+\n+struct Z {\n+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }\n+  int z;\n+};\n+\n+template<typename T>\n+struct Alloc\n+{\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U>&) { }\n+\n+  using value_type = T;\n+\n+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }\n+\n+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }\n+\n+  template<typename U>\n+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }\n+\n+  template<typename U>\n+    bool operator==(const Alloc<U>&) { return true; }\n+\n+  template<typename U>\n+    bool operator!=(const Alloc<U>&) { return false; }\n+};\n+\n+void\n+test03()\n+{\n+  std::unordered_multimap<Key, int, std::hash<Key>, std::equal_to<Key>,\n+\t\t\t  Alloc<std::pair<const Key, int>>> m;\n+  m.insert(Z{});\n+  m.insert(Z{});\n+  VERIFY( m.size() == 2 );\n+  m.insert(Z{});\n+  m.insert(Z{1});\n+  VERIFY( m.size() == 4 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}