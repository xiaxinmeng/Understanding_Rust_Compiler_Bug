{"sha": "0d3ba7398c61d69c79d74da37406192d96432b25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQzYmE3Mzk4YzYxZDY5Yzc5ZDc0ZGEzNzQwNjE5MmQ5NjQzMmIyNQ==", "commit": {"author": {"name": "Dave Brolley", "email": "brolley@cygnus.com", "date": "1998-07-20T13:36:43Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1998-07-20T13:36:43Z"}, "message": "lex.c (mbchar.h): #include it.\n\n1998-07-20  Dave Brolley  <brolley@cygnus.com>\n\t* lex.c (mbchar.h): #include it.\n\t(GET_ENVIRONMENT): New macro.\n\t(init_parse): Set character set based on LANG environment variable.\n\t(real_yylex): Handle multibyte characters in character literals.\n\t(real_yylex): Handle multibyte characters in string literals.\n\nFrom-SVN: r21304", "tree": {"sha": "144e96513b88da4a8afe4628c0de23e84d53d36c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/144e96513b88da4a8afe4628c0de23e84d53d36c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d3ba7398c61d69c79d74da37406192d96432b25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d3ba7398c61d69c79d74da37406192d96432b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d3ba7398c61d69c79d74da37406192d96432b25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d3ba7398c61d69c79d74da37406192d96432b25/comments", "author": null, "committer": null, "parents": [{"sha": "56f48ce9765aa2b6d4742a4923fee581a12c1418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f48ce9765aa2b6d4742a4923fee581a12c1418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56f48ce9765aa2b6d4742a4923fee581a12c1418"}], "stats": {"total": 297, "additions": 197, "deletions": 100}, "files": [{"sha": "bcfaec9442f486f43606feadd5c2496078c416a0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d3ba7398c61d69c79d74da37406192d96432b25/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d3ba7398c61d69c79d74da37406192d96432b25/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0d3ba7398c61d69c79d74da37406192d96432b25", "patch": "@@ -1,3 +1,11 @@\n+1998-07-20  Dave Brolley  <brolley@cygnus.com>\n+\n+\t* lex.c (mbchar.h): #include it.\n+\t(GET_ENVIRONMENT): New macro.\n+\t(init_parse): Set character set based on LANG environment variable.\n+\t(real_yylex): Handle multibyte characters in character literals.\n+\t(real_yylex): Handle multibyte characters in string literals.\n+\n 1998-07-19  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* lex.c (do_identifier): Look for class value even if we don't"}, {"sha": "0e176ab28a20f4d75eb65cb72de89f39a8892a77", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d3ba7398c61d69c79d74da37406192d96432b25/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d3ba7398c61d69c79d74da37406192d96432b25/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=0d3ba7398c61d69c79d74da37406192d96432b25", "patch": "@@ -244,7 +244,7 @@ spew.o : spew.c $(CONFIG_H) $(CXX_TREE_H) \\\n lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n   $(PARSE_H) input.c $(srcdir)/../flags.h hash.h lex.h \\\n   $(srcdir)/../c-pragma.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../output.h\n+  $(srcdir)/../output.h $(srcdir)/../mbchar.h\n decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n   $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h"}, {"sha": "5ef7f1d29c84b49a9e2e3b270f20b748e7075639", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 188, "deletions": 99, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d3ba7398c61d69c79d74da37406192d96432b25/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d3ba7398c61d69c79d74da37406192d96432b25/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0d3ba7398c61d69c79d74da37406192d96432b25", "patch": "@@ -39,15 +39,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"output.h\"\n \n-/* MULTIBYTE_CHARS support only works for native compilers.\n-   ??? Ideally what we want is to model widechar support after\n-   the current floating point support.  */\n-#ifdef CROSS_COMPILE\n-#undef MULTIBYTE_CHARS\n-#endif\n-\n #ifdef MULTIBYTE_CHARS\n+#include \"mbchar.h\"\n #include <locale.h>\n+\n+#ifndef GET_ENVIRONMENT\n+#define GET_ENVIRONMENT(ENV_VALUE,ENV_NAME) ((ENV_VALUE) = getenv (ENV_NAME))\n+#endif\n #endif\n \n #define obstack_chunk_alloc xmalloc\n@@ -474,6 +472,12 @@ init_parse (filename)\n \n   int i;\n \n+#ifdef MULTIBYTE_CHARS\n+  /* Change to the native locale for multibyte conversions.  */\n+  setlocale (LC_CTYPE, \"\");\n+  GET_ENVIRONMENT (literal_codeset, \"LANG\");\n+#endif\n+\n #if USE_CPPLIB\n   yy_cur = \"\\n\";\n   yy_lim = yy_cur + 1;\n@@ -3922,30 +3926,27 @@ real_yylex ()\n       {\n \tregister int result = 0;\n \tregister int num_chars = 0;\n+\tint chars_seen = 0;\n \tunsigned width = TYPE_PRECISION (char_type_node);\n \tint max_chars;\n-\n-\tif (wide_flag)\n-\t  {\n-\t    width = WCHAR_TYPE_SIZE;\n #ifdef MULTIBYTE_CHARS\n-\t    max_chars = MB_CUR_MAX;\n-#else\n-\t    max_chars = 1;\n+\tint longest_char = local_mb_cur_max ();\n+\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n-\t  }\n-\telse\n-\t  max_chars = TYPE_PRECISION (integer_type_node) / width;\n+\n+\tmax_chars = TYPE_PRECISION (integer_type_node) / width;\n+\tif (wide_flag)\n+\t  width = WCHAR_TYPE_SIZE;\n \n \twhile (1)\n \t  {\n \t  tryagain:\n-\n \t    c = getch ();\n \n \t    if (c == '\\'' || c == EOF)\n \t      break;\n \n+\t    ++chars_seen;\n \t    if (c == '\\\\')\n \t      {\n \t\tint ignore = 0;\n@@ -3954,7 +3955,7 @@ real_yylex ()\n \t\t  goto tryagain;\n \t\tif (width < HOST_BITS_PER_INT\n \t\t    && (unsigned) c >= (1 << width))\n-\t\t  warning (\"escape sequence out of range for character\");\n+\t\t  pedwarn (\"escape sequence out of range for character\");\n #ifdef MAP_CHARACTER\n \t\tif (ISPRINT (c))\n \t\t  c = MAP_CHARACTER (c);\n@@ -3963,21 +3964,79 @@ real_yylex ()\n \t    else if (c == '\\n')\n \t      {\n \t\tif (pedantic)\n-\t\t  pedwarn (\"ANSI C++ forbids newline in character constant\");\n+\t\t  pedwarn (\"ANSI C forbids newline in character constant\");\n \t\tlineno++;\n \t      }\n-#ifdef MAP_CHARACTER\n \t    else\n-\t      c = MAP_CHARACTER (c);\n+\t      {\n+#ifdef MULTIBYTE_CHARS\n+\t\twchar_t wc;\n+\t\tint i;\n+\t\tint char_len = -1;\n+\t\tfor (i = 1; i <= longest_char; ++i)\n+\t\t  {\n+\t\t    if (i > maxtoken - 4)\n+\t\t      extend_token_buffer (token_buffer);\n+\n+\t\t    token_buffer[i] = c;\n+\t\t    char_len = local_mbtowc (& wc,\n+\t\t\t\t\t     token_buffer + 1,\n+\t\t\t\t\t     i);\n+\t\t    if (char_len != -1)\n+\t\t      break;\n+\t\t    c = getch ();\n+\t\t  }\n+\t\tif (char_len > 1)\n+\t\t  {\n+\t\t    /* mbtowc sometimes needs an extra char before accepting */\n+\t\t    if (char_len < i)\n+\t\t      put_back (c);\n+\t\t    if (! wide_flag)\n+\t\t      {\n+\t\t\t/* Merge character into result; ignore excess chars.  */\n+\t\t\tfor (i = 1; i <= char_len; ++i)\n+\t\t\t  {\n+\t\t\t    if (i > max_chars)\n+\t\t\t      break;\n+\t\t\t    if (width < HOST_BITS_PER_INT)\n+\t\t\t      result = (result << width)\n+\t\t\t\t| (token_buffer[i]\n+\t\t\t\t   & ((1 << width) - 1));\n+\t\t\t    else\n+\t\t\t      result = token_buffer[i];\n+\t\t\t  }\n+\t\t\tnum_chars += char_len;\n+\t\t\tgoto tryagain;\n+\t\t      }\n+\t\t    c = wc;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (char_len == -1)\n+\t\t      warning (\"Ignoring invalid multibyte character\");\n+\t\t    if (wide_flag)\n+\t\t      c = wc;\n+#ifdef MAP_CHARACTER\n+\t\t    else\n+\t\t      c = MAP_CHARACTER (c);\n #endif\n+\t\t  }\n+#else /* ! MULTIBYTE_CHARS */\n+#ifdef MAP_CHARACTER\n+\t\tc = MAP_CHARACTER (c);\n+#endif\n+#endif /* ! MULTIBYTE_CHARS */\n+\t      }\n \n-\t    num_chars++;\n-\t    if (num_chars > maxtoken - 4)\n-\t      extend_token_buffer (token_buffer);\n-\n-\t    token_buffer[num_chars] = c;\n+\t    if (wide_flag)\n+\t      {\n+\t\tif (chars_seen == 1) /* only keep the first one */\n+\t\t  result = c;\n+\t\tgoto tryagain;\n+\t      }\n \n \t    /* Merge character into result; ignore excess chars.  */\n+\t    num_chars++;\n \t    if (num_chars < max_chars + 1)\n \t      {\n \t\tif (width < HOST_BITS_PER_INT)\n@@ -3987,19 +4046,16 @@ real_yylex ()\n \t      }\n \t  }\n \n-\ttoken_buffer[num_chars + 1] = '\\'';\n-\ttoken_buffer[num_chars + 2] = 0;\n-\n \tif (c != '\\'')\n \t  error (\"malformatted character constant\");\n-\telse if (num_chars == 0)\n+\telse if (chars_seen == 0)\n \t  error (\"empty character constant\");\n \telse if (num_chars > max_chars)\n \t  {\n \t    num_chars = max_chars;\n \t    error (\"character constant too long\");\n \t  }\n-\telse if (num_chars != 1 && warn_multichar)\n+\telse if (chars_seen != 1 && warn_multichar)\n \t  warning (\"multi-character character constant\");\n \n \t/* If char type is signed, sign-extend the constant.  */\n@@ -4012,37 +4068,21 @@ real_yylex ()\n \t    else if (TREE_UNSIGNED (char_type_node)\n \t\t     || ((result >> (num_bits - 1)) & 1) == 0)\n \t      yylval.ttype\n-\t\t= build_int_2 (result & ((unsigned HOST_WIDE_INT) ~0\n+\t\t= build_int_2 (result & (~(unsigned HOST_WIDE_INT) 0\n \t\t\t\t\t >> (HOST_BITS_PER_WIDE_INT - num_bits)),\n \t\t\t       0);\n \t    else\n \t      yylval.ttype\n-\t\t= build_int_2 (result | ~((unsigned HOST_WIDE_INT) ~0\n+\t\t= build_int_2 (result | ~(~(unsigned HOST_WIDE_INT) 0\n \t\t\t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits)),\n \t\t\t       -1);\n-\t    if (num_chars<=1)\n+\t    if (chars_seen <= 1)\n \t      TREE_TYPE (yylval.ttype) = char_type_node;\n \t    else\n \t      TREE_TYPE (yylval.ttype) = integer_type_node;\n \t  }\n \telse\n \t  {\n-#ifdef MULTIBYTE_CHARS\n-\t    /* Set the initial shift state and convert the next sequence.  */\n-\t    result = 0;\n-\t    /* In all locales L'\\0' is zero and mbtowc will return zero,\n-\t       so don't use it.  */\n-\t    if (num_chars > 1\n-\t\t|| (num_chars == 1 && token_buffer[1] != '\\0'))\n-\t      {\n-\t\twchar_t wc;\n-\t\t(void) mbtowc (NULL, NULL, 0);\n-\t\tif (mbtowc (& wc, token_buffer + 1, num_chars) == num_chars)\n-\t\t  result = wc;\n-\t\telse\n-\t\t  warning (\"Ignoring invalid multibyte character\");\n-\t      }\n-#endif\n \t    yylval.ttype = build_int_2 (result, 0);\n \t    TREE_TYPE (yylval.ttype) = wchar_type_node;\n \t  }\n@@ -4055,6 +4095,12 @@ real_yylex ()\n     string_constant:\n       {\n \tregister char *p;\n+\tunsigned width = wide_flag ? WCHAR_TYPE_SIZE\n+\t                           : TYPE_PRECISION (char_type_node);\n+#ifdef MULTIBYTE_CHARS\n+\tint longest_char = local_mb_cur_max ();\n+\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+#endif\n \n \tc = getch ();\n \tp = token_buffer + 1;\n@@ -4068,9 +4114,8 @@ real_yylex ()\n \t\tc = readescape (&ignore);\n \t\tif (ignore)\n \t\t  goto skipnewline;\n-\t\tif (!wide_flag\n-\t\t    && TYPE_PRECISION (char_type_node) < HOST_BITS_PER_INT\n-\t\t    && c >= ((unsigned) 1 << TYPE_PRECISION (char_type_node)))\n+\t\tif (width < HOST_BITS_PER_INT\n+\t\t    && (unsigned) c >= (1 << width))\n \t\t  warning (\"escape sequence out of range for character\");\n \t      }\n \t    else if (c == '\\n')\n@@ -4079,10 +4124,74 @@ real_yylex ()\n \t\t  pedwarn (\"ANSI C++ forbids newline in string constant\");\n \t\tlineno++;\n \t      }\n+\t    else\n+\t      {\n+#ifdef MULTIBYTE_CHARS\n+\t\twchar_t wc;\n+\t\tint i;\n+\t\tint char_len = -1;\n+\t\tfor (i = 0; i < longest_char; ++i)\n+\t\t  {\n+\t\t    if (p + i == token_buffer + maxtoken)\n+\t\t      p = extend_token_buffer (p);\n+\t\t    p[i] = c;\n+\n+\t\t    char_len = local_mbtowc (& wc, p, i + 1);\n+\t\t    if (char_len != -1)\n+\t\t      break;\n+\t\t    c = getch ();\n+\t\t  }\n+\t\tif (char_len == -1)\n+\t\t  warning (\"Ignoring invalid multibyte character\");\n+\t\telse\n+\t\t  {\n+\t\t    /* mbtowc sometimes needs an extra char before accepting */\n+\t\t    if (char_len <= i)\n+\t\t      put_back (c);\n+\t\t    if (wide_flag)\n+\t\t      {\n+\t\t\t*(wchar_t *)p = wc;\n+\t\t\tp += sizeof (wc);\n+\t\t      }\n+\t\t    else\n+\t\t      p += (i + 1);\n+\t\t    c = getch ();\n+\t\t    continue;\n+\t\t  }\n+#endif /* MULTIBYTE_CHARS */\n+\t      }\n \n-\t    if (p == token_buffer + maxtoken)\n-\t      p = extend_token_buffer (p);\n-\t    *p++ = c;\n+\t    /* Add this single character into the buffer either as a wchar_t\n+\t       or as a single byte.  */\n+\t    if (wide_flag)\n+\t      {\n+\t\tunsigned width = TYPE_PRECISION (char_type_node);\n+\t\tunsigned bytemask = (1 << width) - 1;\n+\t\tint byte;\n+\n+\t\tif (p + WCHAR_BYTES >= token_buffer + maxtoken)\n+\t\t  p = extend_token_buffer (p);\n+\n+\t\tfor (byte = 0; byte < WCHAR_BYTES; ++byte)\n+\t\t  {\n+\t\t    int value;\n+\t\t    if (byte >= sizeof (c))\n+\t\t      value = 0;\n+\t\t    else\n+\t\t      value = (c >> (byte * width)) & bytemask;\n+\t\t    if (BYTES_BIG_ENDIAN)\n+\t\t      p[WCHAR_BYTES - byte - 1] = value;\n+\t\t    else\n+\t\t      p[byte] = value;\n+\t\t  }\n+\t\tp += WCHAR_BYTES;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (p == token_buffer + maxtoken)\n+\t\t  p = extend_token_buffer (p);\n+\t\t*p++ = c;\n+\t      }\n \n \t  skipnewline:\n \t    c = getch ();\n@@ -4091,56 +4200,36 @@ real_yylex ()\n \t\tbreak;\n \t    }\n \t  }\n-\t*p = 0;\n-\n-\t/* We have read the entire constant.\n-\t   Construct a STRING_CST for the result.  */\n \n+\t/* Terminate the string value, either with a single byte zero\n+\t   or with a wide zero.  */\n \tif (wide_flag)\n \t  {\n-\t    /* If this is a L\"...\" wide-string, convert the multibyte string\n-\t       to a wide character string.  */\n-\t    char *widep = (char *) alloca ((p - token_buffer) * WCHAR_BYTES);\n-\t    int len;\n-\n-#ifdef MULTIBYTE_CHARS\n-\t    len = mbstowcs ((wchar_t *) widep, token_buffer + 1, p - token_buffer);\n-\t    if (len < 0 || len >= (p - token_buffer))\n-\t      {\n-\t\twarning (\"Ignoring invalid multibyte string\");\n-\t\tlen = 0;\n-\t      }\n-\t    bzero (widep + (len * WCHAR_BYTES), WCHAR_BYTES);\n-#else\n-\t    {\n-\t      char *wp, *cp;\n-\n-\t      wp = widep + (BYTES_BIG_ENDIAN ? WCHAR_BYTES - 1 : 0);\n-\t      bzero (widep, (p - token_buffer) * WCHAR_BYTES);\n-\t      for (cp = token_buffer + 1; cp < p; cp++)\n-\t\t*wp = *cp, wp += WCHAR_BYTES;\n-\t      len = p - token_buffer - 1;\n-\t    }\n-#endif\n-\t    if (processing_template_decl)\n-\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t    yylval.ttype = build_string ((len + 1) * WCHAR_BYTES, widep);\n-\t    if (processing_template_decl)\n-\t      pop_obstacks ();\n-\t    TREE_TYPE (yylval.ttype) = wchar_array_type_node;\n+\t    if (p + WCHAR_BYTES >= token_buffer + maxtoken)\n+\t      p = extend_token_buffer (p);\n+\t    bzero (p, WCHAR_BYTES);\n+\t    p += WCHAR_BYTES;\n \t  }\n \telse\n \t  {\n-\t    if (processing_template_decl)\n-\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t    yylval.ttype = build_string (p - token_buffer, token_buffer + 1);\n-\t    if (processing_template_decl)\n-\t      pop_obstacks ();\n-\t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n+\t    if (p == token_buffer + maxtoken)\n+\t      p = extend_token_buffer (p);\n+\t    *p++ = 0;\n \t  }\n \n-\t*p++ = '\"';\n-\t*p = 0;\n+\t/* We have read the entire constant.\n+\t   Construct a STRING_CST for the result.  */\n+\n+\tif (processing_template_decl)\n+\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\tyylval.ttype = build_string (p - (token_buffer + 1), token_buffer + 1);\n+\tif (processing_template_decl)\n+\t  pop_obstacks ();\n+\n+\tif (wide_flag)\n+\t  TREE_TYPE (yylval.ttype) = wchar_array_type_node;\n+\telse\n+\t  TREE_TYPE (yylval.ttype) = char_array_type_node;\n \n \tvalue = STRING; break;\n       }"}]}