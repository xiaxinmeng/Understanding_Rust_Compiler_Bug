{"sha": "83f49630c33e1c72bebef597d9f56570b3702fe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNmNDk2MzBjMzNlMWM3MmJlYmVmNTk3ZDlmNTY1NzBiMzcwMmZlNw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-10-13T18:17:38Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-10-13T18:17:38Z"}, "message": "(g14_save_reg): Delete variable.\n\n(i960_output_call_insn): Add two new parameters arg_pointer and\nscratch_reg.  Save/set/restore g14 if necessary.\n(i960_expand_call): Delete function.\n\nFrom-SVN: r2433", "tree": {"sha": "6ae65d68fff21d677bad4bb8f107384605ba629b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ae65d68fff21d677bad4bb8f107384605ba629b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83f49630c33e1c72bebef597d9f56570b3702fe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f49630c33e1c72bebef597d9f56570b3702fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f49630c33e1c72bebef597d9f56570b3702fe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f49630c33e1c72bebef597d9f56570b3702fe7/comments", "author": null, "committer": null, "parents": [{"sha": "b716816135585e05fc584544ff1c5be5e4540491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b716816135585e05fc584544ff1c5be5e4540491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b716816135585e05fc584544ff1c5be5e4540491"}], "stats": {"total": 99, "additions": 17, "deletions": 82}, "files": [{"sha": "f633462d192a1ea580903becbc14c71fc8d91d4c", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 17, "deletions": 82, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f49630c33e1c72bebef597d9f56570b3702fe7/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f49630c33e1c72bebef597d9f56570b3702fe7/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=83f49630c33e1c72bebef597d9f56570b3702fe7", "patch": "@@ -57,11 +57,6 @@ static int i960_last_maxbitalignment;\n \n enum insn_types i960_last_insn_type;\n \n-/* Where to save/restore register 14 to/from before/after a procedure call\n-   when it holds an argument block pointer.  */\n-\n-static rtx g14_save_reg;\n-\n /* The leaf-procedure return register.  Set only if this is a leaf routine.  */\n \n static int i960_leaf_ret_reg;\n@@ -1190,14 +1185,24 @@ i960_function_epilogue (file, size)\n /* Output code for a call insn.  */\n \n char *\n-i960_output_call_insn (target, argsize_rtx, insn)\n-     register rtx target, argsize_rtx, insn;\n+i960_output_call_insn (target, argsize_rtx, arg_pointer, scratch_reg, insn)\n+     register rtx target, argsize_rtx, arg_pointer, scratch_reg, insn;\n {\n   int argsize = INTVAL (argsize_rtx);\n   rtx nexti = next_real_insn (insn);\n-  rtx operands[1];\n+  rtx operands[3];\n \n   operands[0] = target;\n+  operands[1] = arg_pointer;\n+  operands[2] = scratch_reg;\n+\n+  if (current_function_args_size != 0)\n+    output_asm_insn (\"mov\tg14,%2\", operands);\n+\n+  if (argsize > 48)\n+    output_asm_insn (\"lda\t%a1,g14\", operands);\n+  else if (current_function_args_size != 0)\n+    output_asm_insn (\"mov\t0,g14\", operands);\n \n   /* The code used to assume that calls to SYMBOL_REFs could not be more\n      than 24 bits away (b vs bx, callj vs callx).  This is not true.  This\n@@ -1216,6 +1221,10 @@ i960_output_call_insn (target, argsize_rtx, insn)\n     }\n \n   output_asm_insn (\"callx\t%0\", operands);\n+\n+  if (current_function_args_size != 0)\n+    output_asm_insn (\"mov\t%2,g14\", operands);\n+\n   return \"\";\n }\n \n@@ -2189,80 +2198,6 @@ secondary_reload_class (class, mode, in)\n   return LOCAL_OR_GLOBAL_REGS;\n }\n \f\n-/* Emit the code necessary for a procedure call.  Return value is needed\n-   after the call if target is non-zero.  */\n-\n-void\n-i960_expand_call (first_operand, second_operand, target)\n-     rtx first_operand, second_operand, target;\n-{\n-  /* Used to ensure that g14_save_reg is initialized once and only once\n-     for each function if it is needed.  */\n-  static char *this_function_name = 0;\n-  int frob_g14 = 0;\n-\n-  if (this_function_name != current_function_name)\n-    {\n-      rtx seq, first;\n-      struct sequence_stack *seq_stack;\n-\n-      this_function_name = current_function_name;\n-\n-      /* If the current function has an argument block, then save g14 into\n-\t a pseudo at the top of the function and restore it after this\n-\t function call.  If the current function has no argument block,\n-\t then g14 is zero before and after the call.  */\n-\n-      if (current_function_args_size != 0)\n-\t{\n-\t  start_sequence ();\n-\t  seq_stack = sequence_stack;\n-\t  while (seq_stack->next)\n-\t    seq_stack = seq_stack->next;\n-\t  first = seq_stack->first;\n-\t  g14_save_reg = copy_to_reg (arg_pointer_rtx);\n-\t  seq = gen_sequence ();\n-\t  end_sequence ();\n-\t  emit_insn_after (seq, first);\n-\t}\n-    }\n-\n-  if (current_function_args_size != 0)\n-    frob_g14 = 1;\n-\n-  if (GET_CODE (second_operand) != CONST_INT || INTVAL (second_operand) > 48)\n-    {\n-      /* Calling a function needing an argument block.  */\n-      emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx,\n-\t\t\t  virtual_outgoing_args_rtx));\n-    }\n-  else\n-    {\n-      /* Calling a normal function -- only set to zero if we know our g14\n-\t is nonzero.  */\n-      if (frob_g14)\n-\temit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx, const0_rtx));\n-    }\n-\n-  if (target)\n-    emit_call_insn (gen_rtx (SET, VOIDmode, target,\n-\t\t\t     gen_rtx (CALL, VOIDmode, first_operand,\n-\t\t\t\t      second_operand)));\n-  else\n-    emit_call_insn (gen_rtx (CALL, VOIDmode, first_operand, second_operand));\n-\n-  if (frob_g14)\n-    emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx, g14_save_reg));\n-  else if (GET_CODE (second_operand) != CONST_INT\n-\t   || INTVAL (second_operand) > 48)\n-    {\n-      /* Calling a function needing an argument block.  It will have set\n-\t reg14 back to zero before returning, so we must emit a clobber here\n-\t to tell cse that g14 has changed.  */\n-      emit_insn (gen_rtx (CLOBBER, VOIDmode, arg_pointer_rtx));\n-    }\n-}\n-\f\n /* Look at the opcode P, and set i96_last_insn_type to indicate which\n    function unit it executed on.  */\n "}]}