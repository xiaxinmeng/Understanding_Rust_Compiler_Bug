{"sha": "8a9220959f7ab20324aee4c78f0ed2233a623f74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE5MjIwOTU5ZjdhYjIwMzI0YWVlNGM3OGYwZWQyMjMzYTYyM2Y3NA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-01-21T23:50:31Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-01-21T23:50:31Z"}, "message": "natConstructor.cc (newInstance): Use _Jv_CallAnyMethodA.\n\n\t* java/lang/reflect/natConstructor.cc (newInstance): Use\n\t_Jv_CallAnyMethodA.\n\t* include/jvm.h: Declare _Jv_CallAnyMethodA.\n\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Renamed\n\tfrom _Jv_CallNonvirtualMethodA.  Changed interface; overloaded.\n\tInclude <jni.h>.\n\t(COPY): Removed.\n\t(invoke): Use _Jv_CallAnyMethodA.\n\t(VAL): Redefined.\n\t* java/lang/Class.h (Class): Declare JvGetFirstStaticField,\n\tJvNumStaticFields, JvNumMethods, and JvGetFirstMethod as friend\n\tfunctions.\n\t(struct _Jv_Method): Added getNextMethod method.\n\t(JvNumMethods): New function.\n\t(JvGetFirstMethod): Likewise.\n\t* gcj/field.h (JvGetFirstStaticField): New function.\n\t(JvNumStaticFields): Likewise.\n\t(getNextField): Renamed from getNextInstanceField.\n\t(struct _Jv_Field): New method getClass.\n\t* jni.cc: Wrote many new functions.\n\t* include/jni.h (JNI_TRUE): Define.\n\t(JNI_FALSE): Likewise.\n\t(jobject, jclass, jstring, jarray, jthrowable, jobjectArray,\n\tjbyteArray, jshortArray, jintArray, jlongArray, jbooleanArray,\n\tjcharArray, jfloatArray, jdoubleArray): New typedefs.\n\t(jfieldID, jmethodID): Likewise.\n\t(JNI_COMMIT, JNI_ABORT): New defines.\n\t(JNINativeMethod): New struct.\n\t(struct JNINativeInterface): Correctly declared more entries.\n\t(class _Jv_JNIEnv): Added `ex' member.\n\t(JNI_VERSION_1_1): New define.\n\t(JNI_VERSION_1_2): Likewise.\n\n\t* boehm.cc (_Jv_MarkObj): Use getNextField, not\n\tgetNextInstanceField.\n\nFrom-SVN: r31553", "tree": {"sha": "e63221042f53661dc5ac90918d840d796a598554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e63221042f53661dc5ac90918d840d796a598554"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a9220959f7ab20324aee4c78f0ed2233a623f74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9220959f7ab20324aee4c78f0ed2233a623f74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9220959f7ab20324aee4c78f0ed2233a623f74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9220959f7ab20324aee4c78f0ed2233a623f74/comments", "author": null, "committer": null, "parents": [{"sha": "24823dcf497ec69ca34146422071308d1063ed28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24823dcf497ec69ca34146422071308d1063ed28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24823dcf497ec69ca34146422071308d1063ed28"}], "stats": {"total": 2201, "additions": 1669, "deletions": 532}, "files": [{"sha": "ffe657a123bed619200f5910f425021b3eb0c7fb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -1,3 +1,41 @@\n+2000-01-21  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/lang/reflect/natConstructor.cc (newInstance): Use\n+\t_Jv_CallAnyMethodA.\n+\t* include/jvm.h: Declare _Jv_CallAnyMethodA.\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Renamed\n+\tfrom _Jv_CallNonvirtualMethodA.  Changed interface; overloaded.\n+\tInclude <jni.h>.\n+\t(COPY): Removed.\n+\t(invoke): Use _Jv_CallAnyMethodA.\n+\t(VAL): Redefined.\n+\t* java/lang/Class.h (Class): Declare JvGetFirstStaticField,\n+\tJvNumStaticFields, JvNumMethods, and JvGetFirstMethod as friend\n+\tfunctions.\n+\t(struct _Jv_Method): Added getNextMethod method.\n+\t(JvNumMethods): New function.\n+\t(JvGetFirstMethod): Likewise.\n+\t* gcj/field.h (JvGetFirstStaticField): New function.\n+\t(JvNumStaticFields): Likewise.\n+\t(getNextField): Renamed from getNextInstanceField.\n+\t(struct _Jv_Field): New method getClass.\n+\t* jni.cc: Wrote many new functions.\n+\t* include/jni.h (JNI_TRUE): Define.\n+\t(JNI_FALSE): Likewise.\n+\t(jobject, jclass, jstring, jarray, jthrowable, jobjectArray,\n+\tjbyteArray, jshortArray, jintArray, jlongArray, jbooleanArray,\n+\tjcharArray, jfloatArray, jdoubleArray): New typedefs.\n+\t(jfieldID, jmethodID): Likewise.\n+\t(JNI_COMMIT, JNI_ABORT): New defines.\n+\t(JNINativeMethod): New struct.\n+\t(struct JNINativeInterface): Correctly declared more entries.\n+\t(class _Jv_JNIEnv): Added `ex' member.\n+\t(JNI_VERSION_1_1): New define.\n+\t(JNI_VERSION_1_2): Likewise.\n+\n+\t* boehm.cc (_Jv_MarkObj): Use getNextField, not\n+\tgetNextInstanceField.\n+\n 2000-01-20  Tom Tromey  <tromey@cygnus.com>\n \n \t* resolve.cc (StringClass): Removed."}, {"sha": "2c50c5cc0f09e7dba635ced5ccb6676b81f50a46", "filename": "libjava/boehm.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -1,6 +1,6 @@\n // boehm.cc - interface between libjava and Boehm GC.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -256,7 +256,7 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit,\n \t\t\t      obj, elabel);\n \t\t}\n-\t      field = field->getNextInstanceField ();\n+\t      field = field->getNextField ();\n \t    }\n \t  klass = klass->getSuperclass();\n \t}"}, {"sha": "28006fc58fb3a351f552ad5c29d1de37f6648e19", "filename": "libjava/gcj/field.h", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fgcj%2Ffield.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fgcj%2Ffield.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Ffield.h?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -1,6 +1,6 @@\n // field.h - Header file for fieldID instances.  -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -30,7 +30,7 @@ struct _Jv_Field\n   _Jv_ushort\t\tflags;\n \n #ifdef COMPACT_FIELDS\n-  short\t\t\tnameIndex;  /* ofsfet in class's name table */\n+  short\t\t\tnameIndex;  /* offset in class's name table */\n #else\n   _Jv_ushort\t\tbsize;  /* not really needed ... */\n #endif\n@@ -51,7 +51,7 @@ struct _Jv_Field\n   jobject getObjectField (jobject obj)\n   { return *(jobject *)((char *)obj + getOffset ()); }\n \n-  jfieldID getNextInstanceField () { return this + 1; }\n+  jfieldID getNextField () { return this + 1; }\n \n   jboolean isRef () \n     { \n@@ -66,6 +66,12 @@ struct _Jv_Field\n \t}\n     }\n \n+  jclass getClass ()\n+  {\n+    JvAssert (isResolved ());\n+    return type;\n+  }\n+\n   // FIXME - may need to mask off internal flags.\n   int getModifiers() { return flags; }\n \n@@ -79,6 +85,7 @@ struct _Jv_Field\n };\n \n #ifdef __cplusplus\n+\n inline jbyte\n _Jv_GetStaticByteField (jclass, _Jv_Field* field)\n {\n@@ -151,6 +158,18 @@ JvNumInstanceFields (jclass klass)\n   return klass->field_count - klass->static_field_count;\n }\n \n+extern inline jfieldID\n+JvGetFirstStaticField (jclass klass)\n+{\n+  return &(klass->fields[0]);\n+}\n+\n+extern inline jint\n+JvNumStaticFields (jclass klass)\n+{\n+  return klass->static_field_count;\n+}\n+\n extern inline jboolean\n JvFieldIsRef (jfieldID field)\n {\n@@ -164,6 +183,6 @@ JvGetObjectField (jobject obj, _Jv_Field* field)\n }\n #endif /* defined (__GCJ_CNI_H__) */\n \n-#endif\n+#endif /* __cplusplus */\n \n #endif /* __GCJ_FIELD_H */"}, {"sha": "fe8f03b21f67502e410c8b7814e84cfbf29732c2", "filename": "libjava/gcj/method.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fgcj%2Fmethod.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fgcj%2Fmethod.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fmethod.h?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -1,6 +1,6 @@\n-// java-method.h - Header file for methodID instances.  -*- c++ -*-\n+// method.h - Header file for methodID instances.  -*- c++ -*-\n \n-/* Copyright (C) 1999  Red Hat, Inc.\n+/* Copyright (C) 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -11,8 +11,10 @@ details.  */\n #ifndef __GCJ_METHOD_H__\n #define __GCJ_METHOD_H__\n \n+#include <java/lang/Class.h>\n+\n extern inline jmethodID\n-_Jv_FromReflectedMethod(java::lang::reflect::Method *method)\n+_Jv_FromReflectedMethod (java::lang::reflect::Method *method)\n {\n   return (jmethodID)\n     ((char *) method->declaringClass->methods + method->offset);"}, {"sha": "c2ba2f223d07536eb784f29c31863ef908f7921d", "filename": "libjava/include/jni.h", "status": "modified", "additions": 438, "deletions": 216, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Finclude%2Fjni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Finclude%2Fjni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni.h?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -1,11 +1,16 @@\n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n+/* Note: this file must be compilable by the C compiler (for now,\n+   assuming GNU C is ok).  This means you must never use `//'\n+   comments, and all C++-specific code must be conditional on\n+   __cplusplus.  */\n+\n #ifndef __GCJ_JNI_H__\n #define __GCJ_JNI_H__\n \n@@ -14,11 +19,15 @@ details.  */\n \n #ifdef __cplusplus\n \n-// This is wrong, because it pollutes the name-space too much!\n+/* This is wrong, because it pollutes the name-space too much! */\n #include <gcj/javaprims.h>\n \n typedef struct _Jv_JNIEnv JNIEnv;\n-#else\n+\n+#define JNI_TRUE true\n+#define JNI_FALSE false\n+\n+#else /* __cplusplus */\n \n typedef int    jbyte  __attribute__((__mode__(__QI__)));\n typedef int    jshort __attribute__((__mode__(__HI__)));\n@@ -30,20 +39,51 @@ typedef float  jfloat;\n typedef double jdouble;\n typedef jint jsize;\n \n+typedef void *jobject;\n+typedef jobject jclass;\n+typedef jobject jstring;\n+typedef jobject jarray;\n+typedef jobject jthrowable;\n+typedef jobject jobjectArray;\n+typedef jobject jbyteArray;\n+typedef jobject jshortArray;\n+typedef jobject jintArray;\n+typedef jobject jlongArray;\n+typedef jobject jbooleanArray;\n+typedef jobject jcharArray;\n+typedef jobject jfloatArray;\n+typedef jobject jdoubleArray;\n+\n+/* Dummy defines.  */\n+typedef void *jfieldID;\n+typedef void *jmethodID;\n+\n typedef const struct JNINativeInterface *JNIEnv;\n-#endif\n+\n+#define JNI_TRUE 1\n+#define JNI_TRUE 0\n+\n+#endif /* __cplusplus */\n+\n+/* Version numbers.  */\n+#define JNI_VERSION_1_1 0x00010001\n+#define JNI_VERSION_1_2 0x00010002\n+\n+/* Used when releasing array elements.  */\n+#define JNI_COMMIT 1\n+#define JNI_ABORT  2\n \n typedef union jvalue\n {\n   jboolean z;\n   jbyte    b;\n   jchar    c;\n-  jshort  s;\n-  jint    i;\n+  jshort   s;\n+  jint     i;\n   jlong    j;\n-  jfloat  f;\n+  jfloat   f;\n   jdouble  d;\n-  jobject l;\n+  jobject  l;\n } jvalue;\n \n typedef void * (*_Jv_func)(...);\n@@ -54,7 +94,7 @@ struct JNINativeInterface\n   _Jv_func reserved1;\n   _Jv_func reserved2;\n   _Jv_func reserved3;\n-  _Jv_func GetVersion;\n+  jint     (*GetVersion)                   (JNIEnv*);\n   _Jv_func DefineClass;\n   _Jv_func FindClass;\n   _Jv_func reserved4;\n@@ -64,233 +104,415 @@ struct JNINativeInterface\n   jboolean (*IsAssignableFrom)             (JNIEnv*, jclass, jclass);\n   _Jv_func reserved7;\n   jint     (*Throw)                        (JNIEnv*, jthrowable);\n-  _Jv_func ThrowNew;\n-  _Jv_func ExceptionOccurred;\n-  _Jv_func ExceptionDescribe;\n-  _Jv_func ExceptionClear;\n-  _Jv_func FatalError;\n+  jint     (*ThrowNew)                     (JNIEnv*, jclass, const char *);\n+  jthrowable (*ExceptionOccurred)          (JNIEnv *);\n+  void     (*ExceptionDescribe)            (JNIEnv *);\n+  void     (*ExceptionClear)               (JNIEnv *);\n+  void     (*FatalError)                   (JNIEnv *, const char *);\n   _Jv_func reserved8;\n   _Jv_func reserved9;\n   _Jv_func NewGlobalRef;\n   _Jv_func DeleteGlobalRef;\n   _Jv_func DeleteLocalRef;\n-  _Jv_func IsSameObject;\n+  jboolean (*IsSameObject)                 (JNIEnv *, jobject, jobject);\n   _Jv_func reserved10;\n   _Jv_func reserved11;\n-  _Jv_func AllocObject;\n-  _Jv_func NewObject;\n-  _Jv_func NewObjectV;\n-  _Jv_func NewObjectA;\n-  _Jv_func GetObjectClass;\n-  _Jv_func IsInstanceOf;\n-  _Jv_func GetMethodID;\n-  _Jv_func CallObjectMethod;\n-  _Jv_func CallObjectMethodV;\n-  _Jv_func CallObjectMethodA;\n-  _Jv_func CallBooleanMethod;\n-  _Jv_func CallBooleanMethodV;\n-  _Jv_func CallBooleanMethodA;\n-  _Jv_func CallByteMethod;\n-  _Jv_func CallByteMethodV;\n-  _Jv_func CallByteMethodA;\n-  _Jv_func CallCharMethod;\n-  _Jv_func CallCharMethodV;\n-  _Jv_func CallCharMethodA;\n-  _Jv_func CallShortMethod;\n-  _Jv_func CallShortMethodV;\n-  _Jv_func CallShortMethodA;\n-  _Jv_func CallIntMethod;\n-  _Jv_func CallIntMethodV;\n-  _Jv_func CallIntMethodA;\n-  _Jv_func CallLongMethod;\n-  _Jv_func CallLongMethodV;\n-  _Jv_func CallLongMethodA;\n-  _Jv_func CallFloatMethod;\n-  _Jv_func CallFloatMethodV;\n-  _Jv_func CallFloatMethodA;\n-  _Jv_func CallDoubleMethod;\n-  _Jv_func CallDoubleMethodV;\n-  _Jv_func CallDoubleMethodA;\n-  _Jv_func CallVoidMethod;\n-  _Jv_func CallVoidMethodV;\n-  _Jv_func CallVoidMethodA;\n-  _Jv_func CallNonvirtualObjectMethod;\n-  _Jv_func CallNonvirtualObjectMethodV;\n-  _Jv_func CallNonvirtualObjectMethodA;\n-  jboolean (*CallNonvirtualBooleanMethod)  (JNIEnv*, jobject, jclass, jmethodID, ...);\n-  jboolean (*CallNonvirtualBooleanMethodV) (JNIEnv*, jobject, jclass, jmethodID, _Jv_va_list);\n-  jboolean (*CallNonvirtualBooleanMethodA) (JNIEnv*, jobject, jclass, jmethodID, jvalue*);\n-  _Jv_func CallNonvirtualByteMethod;\n-  _Jv_func CallNonvirtualByteMethodV;\n-  _Jv_func CallNonvirtualByteMethodA;\n-  _Jv_func CallNonvirtualCharMethod;\n-  _Jv_func CallNonvirtualCharMethodV;\n-  _Jv_func CallNonvirtualCharMethodA;\n-  _Jv_func CallNonvirtualShortMethod;\n-  _Jv_func CallNonvirtualShortMethodV;\n-  _Jv_func CallNonvirtualShortMethodA;\n-  _Jv_func CallNonvirtualIntMethod;\n-  _Jv_func CallNonvirtualIntMethodV;\n-  _Jv_func CallNonvirtualIntMethodA;\n-  _Jv_func CallNonvirtualLongMethod;\n-  _Jv_func CallNonvirtualLongMethodV;\n-  _Jv_func CallNonvirtualLongMethodA;\n-  _Jv_func CallNonvirtualFloatMethod;\n-  _Jv_func CallNonvirtualFloatMethodV;\n-  _Jv_func CallNonvirtualFloatMethodA;\n-  _Jv_func CallNonvirtualDoubleMethod;\n-  jdouble  (*CallNonvirtualDoubleMethodV)  (JNIEnv*, jobject, jclass, jmethodID, _Jv_va_list);\n-  _Jv_func CallNonvirtualDoubleMethodA;\n-  _Jv_func CallNonvirtualVoidMethod;\n-  _Jv_func CallNonvirtualVoidMethodV;\n-  _Jv_func CallNonvirtualVoidMethodA;\n-  _Jv_func GetFieldID;\n-  jobject  (*GetObjectField)               (JNIEnv*, jobject, jfieldID);\n-  jboolean (*GetBooleanField)              (JNIEnv*, jobject, jfieldID);\n-  jbyte    (*GetByteField)                 (JNIEnv*, jobject, jfieldID);\n-  jchar    (*GetCharField)                 (JNIEnv*, jobject, jfieldID);\n-  jshort   (*GetShortField)                (JNIEnv*, jobject, jfieldID);\n-  jint     (*GetIntField)                  (JNIEnv*, jobject, jfieldID);\n-  jlong    (*GetLongField)                 (JNIEnv*, jobject, jfieldID);\n-  jfloat   (*GetFloatField)                (JNIEnv*, jobject, jfieldID);\n-  jdouble  (*GetDoubleField)               (JNIEnv*, jobject, jfieldID);\n-  _Jv_func SetObjectField;\n-  _Jv_func SetBooleanField;\n-  _Jv_func SetByteField;\n-  _Jv_func SetCharField;\n-  _Jv_func SetShortField;\n-  _Jv_func SetIntField;\n-  _Jv_func SetLongField;\n-  _Jv_func SetFloatField;\n-  _Jv_func SetDoubleField;\n-  _Jv_func GetStaticMethodID;\n-  _Jv_func CallStaticObjectMethod;\n-  _Jv_func CallStaticObjectMethodV;\n-  _Jv_func CallStaticObjectMethodA;\n-  _Jv_func CallStaticBooleanMethod;\n-  _Jv_func CallStaticBooleanMethodV;\n-  _Jv_func CallStaticBooleanMethodA;\n-  _Jv_func CallStaticByteMethod;\n-  _Jv_func CallStaticByteMethodV;\n-  _Jv_func CallStaticByteMethodA;\n-  _Jv_func CallStaticCharMethod;\n-  _Jv_func CallStaticCharMethodV;\n-  _Jv_func CallStaticCharMethodA;\n-  _Jv_func CallStaticShortMethod;\n-  _Jv_func CallStaticShortMethodV;\n-  _Jv_func CallStaticShortMethodA;\n-  _Jv_func CallStaticIntMethod;\n-  _Jv_func CallStaticIntMethodV;\n-  _Jv_func CallStaticIntMethodA;\n-  _Jv_func CallStaticLongMethod;\n-  _Jv_func CallStaticLongMethodV;\n-  _Jv_func CallStaticLongMethodA;\n-  _Jv_func CallStaticFloatMethod;\n-  _Jv_func CallStaticFloatMethodV;\n-  _Jv_func CallStaticFloatMethodA;\n-  _Jv_func CallStaticDoubleMethod;\n-  _Jv_func CallStaticDoubleMethodV;\n-  _Jv_func CallStaticDoubleMethodA;\n-  _Jv_func CallStaticVoidMethod;\n-  _Jv_func CallStaticVoidMethodV;\n-  _Jv_func CallStaticVoidMethodA;\n-  _Jv_func GetStaticFieldID;\n-  _Jv_func GetStaticObjectField;\n-  _Jv_func GetStaticBooleanField;\n-  _Jv_func GetStaticByteField;\n-  _Jv_func GetStaticCharField;\n-  _Jv_func GetStaticShortField;\n-  _Jv_func GetStaticIntField;\n-  _Jv_func GetStaticLongField;\n-  _Jv_func GetStaticFloatField;\n-  _Jv_func GetStaticDoubleField;\n-  _Jv_func SetStaticObjectField;\n-  _Jv_func SetStaticBooleanField;\n-  _Jv_func SetStaticByteField;\n-  _Jv_func SetStaticCharField;\n-  _Jv_func SetStaticShortField;\n-  _Jv_func SetStaticIntField;\n-  _Jv_func SetStaticLongField;\n-  _Jv_func SetStaticFloatField;\n-  _Jv_func SetStaticDoubleField;\n-  _Jv_func NewString;\n-  jint     (*GetStringLength)              (JNIEnv*, jstring);\n-  _Jv_func GetStringChars;\n-  _Jv_func ReleaseStringChars;\n-  _Jv_func NewStringUTF;\n-  _Jv_func GetStringUTFLength;\n-  _Jv_func GetStringUTFChars;\n-  _Jv_func ReleaseStringUTFChars;\n-  _Jv_func GetArrayLength;\n-  _Jv_func NewObjectArray;\n-  _Jv_func GetObjectArrayElement;\n-  _Jv_func SetObjectArrayElement;\n-  _Jv_func NewBooleanArray;\n-  _Jv_func NewByteArray;\n-  _Jv_func NewCharArray;\n-  _Jv_func NewShortArray;\n-  _Jv_func NewIntArray;\n-  _Jv_func NewLongArray;\n-  _Jv_func NewFloatArray;\n-  _Jv_func NewDoubleArray;\n-  _Jv_func GetBooleanArrayElements;\n-  _Jv_func GetByteArrayElements;\n-  _Jv_func GetCharArrayElements;\n-  _Jv_func GetShortArrayElements;\n-  _Jv_func GetIntArrayElements;\n-  _Jv_func GetLongArrayElements;\n-  _Jv_func GetFloatArrayElements;\n-  _Jv_func GetDoubleArrayElements;\n-  _Jv_func ReleaseBooleanArrayElements;\n-  _Jv_func ReleaseByteArrayElements;\n-  _Jv_func ReleaseCharArrayElements;\n-  _Jv_func ReleaseShortArrayElements;\n-  _Jv_func ReleaseIntArrayElements;\n-  _Jv_func ReleaseLongArrayElements;\n-  _Jv_func ReleaseFloatArrayElements;\n-  _Jv_func ReleaseDoubleArrayElements;\n-  _Jv_func GetBooleanArrayRegion;\n-  _Jv_func GetByteArrayRegion;\n-  _Jv_func GetCharArrayRegion;\n-  _Jv_func GetShortArrayRegion;\n-  _Jv_func GetIntArrayRegion;\n-  _Jv_func GetLongArrayRegion;\n-  _Jv_func GetFloatArrayRegion;\n-  _Jv_func GetDoubleArrayRegion;\n-  _Jv_func SetBooleanArrayRegion;\n-  _Jv_func SetByteArrayRegion;\n-  _Jv_func SetCharArrayRegion;\n-  _Jv_func SetShortArrayRegion;\n-  _Jv_func SetIntArrayRegion;\n-  _Jv_func SetLongArrayRegion;\n-  _Jv_func SetFloatArrayRegion;\n-  _Jv_func SetDoubleArrayRegion;\n+\n+  jobject  (*AllocObject)                  (JNIEnv *, jclass);\n+  jobject (*NewObject)\t\t\t   (JNIEnv *, jclass, jmethodID, ...);\n+  jobject (*NewObjectV)\t\t\t   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jobject (*NewObjectA)\t\t\t   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+\n+  jclass   (*GetObjectClass)               (JNIEnv *, jobject);\n+  jboolean (*IsInstanceOf)                 (JNIEnv *, jobject, jclass);\n+  jmethodID (*GetMethodID)                 (JNIEnv *, jclass, const char *,\n+\t\t\t\t\t    const char *);\n+\n+  jobject \t(*CallObjectMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jobject \t(*CallObjectMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jobject \t(*CallObjectMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jboolean \t(*CallBooleanMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jboolean \t(*CallBooleanMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jboolean \t(*CallBooleanMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jbyte \t(*CallByteMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jbyte \t(*CallByteMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jbyte \t(*CallByteMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jchar \t(*CallCharMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jchar \t(*CallCharMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jchar \t(*CallCharMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jshort \t(*CallShortMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jshort \t(*CallShortMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jshort \t(*CallShortMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jint \t\t(*CallIntMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jint \t\t(*CallIntMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jint \t\t(*CallIntMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jlong \t(*CallLongMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jlong \t(*CallLongMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jlong \t(*CallLongMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jfloat \t(*CallFloatMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jfloat \t(*CallFloatMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jfloat \t(*CallFloatMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jdouble \t(*CallDoubleMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  jdouble \t(*CallDoubleMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jdouble \t(*CallDoubleMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  void  \t(*CallVoidMethod)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    ...);\n+  void  \t(*CallVoidMethodV)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  void  \t(*CallVoidMethodA)\t   (JNIEnv *, jobject, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+\n+  jobject   (*CallNonvirtualObjectMethod)  (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jobject   (*CallNonvirtualObjectMethodV) (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jobject   (*CallNonvirtualObjectMethodA) (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  jboolean  (*CallNonvirtualBooleanMethod) (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jboolean  (*CallNonvirtualBooleanMethodV) (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t     jmethodID, _Jv_va_list);\n+  jboolean  (*CallNonvirtualBooleanMethodA) (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t     jmethodID, jvalue *);\n+  jbyte     (*CallNonvirtualByteMethod)\t   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jbyte     (*CallNonvirtualByteMethodV)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jbyte     (*CallNonvirtualByteMethodA)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  jchar     (*CallNonvirtualCharMethod)\t   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jchar     (*CallNonvirtualCharMethodV)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jchar     (*CallNonvirtualCharMethodA)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  jshort    (*CallNonvirtualShortMethod)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jshort    (*CallNonvirtualShortMethodV)  (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jshort    (*CallNonvirtualShortMethodA)  (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  jint \t    (*CallNonvirtualIntMethod)\t   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jint \t    (*CallNonvirtualIntMethodV)\t   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jint \t    (*CallNonvirtualIntMethodA)\t   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  jlong     (*CallNonvirtualLongMethod)\t   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jlong     (*CallNonvirtualLongMethodV)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jlong     (*CallNonvirtualLongMethodA)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  jfloat    (*CallNonvirtualFloatMethod)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jfloat    (*CallNonvirtualFloatMethodV)  (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jfloat    (*CallNonvirtualFloatMethodA)  (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  jdouble   (*CallNonvirtualDoubleMethod)  (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  jdouble   (*CallNonvirtualDoubleMethodV) (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  jdouble   (*CallNonvirtualDoubleMethodA) (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+  void      (*CallNonvirtualVoidMethod)\t   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, ...);\n+  void      (*CallNonvirtualVoidMethodV)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, _Jv_va_list);\n+  void      (*CallNonvirtualVoidMethodA)   (JNIEnv *, jobject, jclass,\n+\t\t\t\t\t    jmethodID, jvalue *);\n+\n+  jfieldID      (*GetFieldID)              (JNIEnv *, jclass, const char *,\n+\t\t\t\t\t    const char *);\n+\n+  jobject  (*GetObjectField)               (JNIEnv *, jobject, jfieldID);\n+  jboolean (*GetBooleanField)              (JNIEnv *, jobject, jfieldID);\n+  jbyte    (*GetByteField)                 (JNIEnv *, jobject, jfieldID);\n+  jchar    (*GetCharField)                 (JNIEnv *, jobject, jfieldID);\n+  jshort   (*GetShortField)                (JNIEnv *, jobject, jfieldID);\n+  jint     (*GetIntField)                  (JNIEnv *, jobject, jfieldID);\n+  jlong    (*GetLongField)                 (JNIEnv *, jobject, jfieldID);\n+  jfloat   (*GetFloatField)                (JNIEnv *, jobject, jfieldID);\n+  jdouble  (*GetDoubleField)               (JNIEnv *, jobject, jfieldID);\n+\n+  void\t\t(*SetObjectField)\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jobject);\n+  void\t\t(*SetBooleanField)\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jboolean);\n+  void\t\t(*SetByteField)\t\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jbyte);\n+  void\t\t(*SetCharField)\t\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jchar);\n+  void\t\t(*SetShortField)\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jshort);\n+  void\t\t(*SetIntField)\t\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jint);\n+  void\t\t(*SetLongField)\t\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jlong);\n+  void\t\t(*SetFloatField)\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jfloat);\n+  void\t\t(*SetDoubleField)\t   (JNIEnv *, jobject,\n+\t\t\t\t\t    jfieldID, jdouble);\n+\n+  jmethodID (*GetStaticMethodID)           (JNIEnv *, jclass, const char *,\n+\t\t\t\t\t    const char *);\n+\n+  jobject \t(*CallStaticObjectMethod)  (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jobject \t(*CallStaticObjectMethodV) (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jobject \t(*CallStaticObjectMethodA) (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jboolean \t(*CallStaticBooleanMethod) (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jboolean \t(*CallStaticBooleanMethodV) (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t     _Jv_va_list);\n+  jboolean \t(*CallStaticBooleanMethodA) (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t     jvalue *);\n+  jbyte \t(*CallStaticByteMethod)    (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jbyte \t(*CallStaticByteMethodV)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jbyte \t(*CallStaticByteMethodA)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jchar \t(*CallStaticCharMethod)    (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jchar \t(*CallStaticCharMethodV)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jchar \t(*CallStaticCharMethodA)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jshort \t(*CallStaticShortMethod)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jshort \t(*CallStaticShortMethodV)  (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jshort \t(*CallStaticShortMethodA)  (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jint \t\t(*CallStaticIntMethod) \t   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jint \t\t(*CallStaticIntMethodV)    (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jint \t\t(*CallStaticIntMethodA)    (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jlong \t(*CallStaticLongMethod)    (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jlong \t(*CallStaticLongMethodV)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jlong \t(*CallStaticLongMethodA)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jfloat \t(*CallStaticFloatMethod)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jfloat \t(*CallStaticFloatMethodV)  (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jfloat \t(*CallStaticFloatMethodA)  (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  jdouble \t(*CallStaticDoubleMethod)  (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  jdouble \t(*CallStaticDoubleMethodV) (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  jdouble \t(*CallStaticDoubleMethodA) (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+  void  \t(*CallStaticVoidMethod)    (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    ...);\n+  void  \t(*CallStaticVoidMethodV)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    _Jv_va_list);\n+  void  \t(*CallStaticVoidMethodA)   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jvalue *);\n+\n+  jfieldID      (*GetStaticFieldID)        (JNIEnv *, jclass, const char *,\n+\t\t\t\t\t    const char *);\n+\n+  jobject\t(*GetStaticObjectField)\t   (JNIEnv *, jclass, jfieldID);\n+  jboolean\t(*GetStaticBooleanField)   (JNIEnv *, jclass, jfieldID);\n+  jbyte\t\t(*GetStaticByteField)\t   (JNIEnv *, jclass, jfieldID);\n+  jchar\t\t(*GetStaticCharField)\t   (JNIEnv *, jclass, jfieldID);\n+  jshort\t(*GetStaticShortField)\t   (JNIEnv *, jclass, jfieldID);\n+  jint\t\t(*GetStaticIntField)\t   (JNIEnv *, jclass, jfieldID);\n+  jlong\t\t(*GetStaticLongField)\t   (JNIEnv *, jclass, jfieldID);\n+  jfloat\t(*GetStaticFloatField)\t   (JNIEnv *, jclass, jfieldID);\n+  jdouble\t(*GetStaticDoubleField)\t   (JNIEnv *, jclass, jfieldID);\n+\n+  void \t\t(*SetStaticObjectField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jobject);\n+  void \t\t(*SetStaticBooleanField)   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jboolean);\n+  void \t\t(*SetStaticByteField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jbyte);\n+  void \t\t(*SetStaticCharField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jchar);\n+  void \t\t(*SetStaticShortField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jshort);\n+  void \t\t(*SetStaticIntField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jint);\n+  void \t\t(*SetStaticLongField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jlong);\n+  void \t\t(*SetStaticFloatField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jfloat);\n+  void \t\t(*SetStaticDoubleField)\t   (JNIEnv *, jclass,\n+\t\t\t\t\t    jfieldID, jdouble);\n+\n+  jstring  (*NewString)                    (JNIEnv *, const jchar *, jsize);\n+  jint     (*GetStringLength)              (JNIEnv *, jstring);\n+  const jchar * (*GetStringChars)          (JNIEnv *, jstring, jboolean *);\n+  void     (*ReleaseStringChars)           (JNIEnv *, jstring, const jchar *);\n+  jstring  (*NewStringUTF)                 (JNIEnv *, const char *);\n+  jsize    (*GetStringUTFLength)           (JNIEnv *, jstring);\n+  const char * (*GetStringUTFChars)        (JNIEnv *, jstring, jboolean *);\n+  void     (*ReleaseStringUTFChars)        (JNIEnv *, jstring, const char *);\n+  jsize    (*GetArrayLength)               (JNIEnv *, jarray);\n+  jarray   (*NewObjectArray)               (JNIEnv *, jsize, jclass, jobject);\n+  jobject  (*GetObjectArrayElement)        (JNIEnv *, jobjectArray, jsize);\n+  void     (*SetObjectArrayElement)        (JNIEnv *, jobjectArray, jsize,\n+\t\t\t\t\t    jobject);\n+\n+  jbooleanArray (*NewBooleanArray)\t   (JNIEnv *, jsize);\n+  jbyteArray    (*NewByteArray)\t\t   (JNIEnv *, jsize);\n+  jcharArray    (*NewCharArray)\t\t   (JNIEnv *, jsize);\n+  jshortArray   (*NewShortArray)\t   (JNIEnv *, jsize);\n+  jintArray     (*NewIntArray)\t\t   (JNIEnv *, jsize);\n+  jlongArray    (*NewLongArray)\t\t   (JNIEnv *, jsize);\n+  jfloatArray   (*NewFloatArray)\t   (JNIEnv *, jsize);\n+  jdoubleArray  (*NewDoubleArray)\t   (JNIEnv *, jsize);\n+\n+  jboolean *\t(*GetBooleanArrayElements) (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jboolean *);\n+  jbyte *\t(*GetByteArrayElements)\t   (JNIEnv *, jbyteArray,\n+\t\t\t\t\t    jboolean *);\n+  jchar *\t(*GetCharArrayElements)\t   (JNIEnv *, jcharArray,\n+\t\t\t\t\t    jboolean *);\n+  jshort *\t(*GetShortArrayElements)   (JNIEnv *, jshortArray,\n+\t\t\t\t\t    jboolean *);\n+  jint *\t(*GetIntArrayElements)\t   (JNIEnv *, jintArray,\n+\t\t\t\t\t    jboolean *);\n+  jlong *\t(*GetLongArrayElements)\t   (JNIEnv *, jlongArray,\n+\t\t\t\t\t    jboolean *);\n+  jfloat *\t(*GetFloatArrayElements)   (JNIEnv *, jfloatArray,\n+\t\t\t\t\t    jboolean *);\n+  jdouble *\t(*GetDoubleArrayElements)  (JNIEnv *, jdoubleArray,\n+\t\t\t\t\t    jboolean *);\n+\n+  void\t\t(*ReleaseBooleanArrayElements) (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t\tjboolean *, jint);\n+  void\t\t(*ReleaseByteArrayElements)    (JNIEnv *, jbyteArray,\n+\t\t\t\t\t        jbyte *, jint);\n+  void\t\t(*ReleaseCharArrayElements)    (JNIEnv *, jcharArray,\n+\t\t\t\t\t\tjchar *, jint);\n+  void\t\t(*ReleaseShortArrayElements)   (JNIEnv *, jshortArray,\n+\t\t\t\t\t\tjshort *, jint);\n+  void\t\t(*ReleaseIntArrayElements)     (JNIEnv *, jintArray,\n+\t\t\t\t\t\tjint *, jint);\n+  void\t\t(*ReleaseLongArrayElements)    (JNIEnv *, jlongArray,\n+\t\t\t\t\t\tjlong *, jint);\n+  void\t\t(*ReleaseFloatArrayElements)   (JNIEnv *, jfloatArray,\n+\t\t\t\t\t\tjfloat *, jint);\n+  void\t\t(*ReleaseDoubleArrayElements)  (JNIEnv *, jdoubleArray,\n+\t\t\t\t\t\tjdouble *, jint);\n+\n+  void \t\t(*GetBooleanArrayRegion)   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*GetByteArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*GetCharArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*GetShortArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*GetIntArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*GetLongArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*GetFloatArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*GetDoubleArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+\n+  void \t\t(*SetBooleanArrayRegion)   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*SetByteArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*SetCharArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*SetShortArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*SetIntArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*SetLongArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*SetFloatArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+  void \t\t(*SetDoubleArrayRegion)\t   (JNIEnv *, jbooleanArray,\n+\t\t\t\t\t    jsize, jsize, jboolean *);\n+\n   _Jv_func RegisterNatives;\n   _Jv_func UnregisterNatives;\n-  _Jv_func MonitorEnter;\n-  _Jv_func MonitorExit;\n+  jint     (*MonitorEnter)                 (JNIEnv *, jobject);\n+  jint     (*MonitorExit)                  (JNIEnv *, jobject);\n   _Jv_func GetJavaVM;\n };\n \n+/* This structure is used when registering native methods.  */\n+typedef struct\n+{\n+  char *name;\n+  char *signature;\n+  void *fnPtr;\t\t\t/* Sigh.  */\n+} JNINativeMethod;\n+\n #ifdef __cplusplus\n \n-struct _Jv_JNIEnv\n+class _Jv_JNIEnv\n {\n+public:\n+  /* The method table.  */\n   struct JNINativeInterface *p;\n \n-  jclass GetSuperclass (jclass cl);\n-  jsize GetStringLength (jstring str);\n+private:\n+  /* The current exception.  */\n+  jthrowable ex;\n \n-};\n+  /* This doesn't really protect the private contents, because anybody\n+     can set this macro.  However, if they do set it then they at\n+     least know they are doing something unportable.  */\n+#ifdef GCJ_JV_JNIENV_FRIEND\n+  GCJ_JV_JNIENV_FRIEND;\n+#endif\n \n-extern inline jclass\n-_Jv_JNIEnv::GetSuperclass (jclass cl)\n-{ return p->GetSuperclass (this, cl); }\n+public:\n+  jclass GetSuperclass (jclass cl)\n+  { return p->GetSuperclass (this, cl); }\n \n-extern inline jsize\n-_Jv_JNIEnv::GetStringLength (jstring str)\n-{ return p->GetStringLength (this, str); }\n+  jsize GetStringLength (jstring str)\n+  { return p->GetStringLength (this, str); }\n+};\n \n-#endif\n+#endif /* __cplusplus */\n \n #endif /* __GCJ_JNI_H__ */"}, {"sha": "a8d1fac6524fed13e54e777a036bc8e20c443a1a", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -1,6 +1,6 @@\n // jvm.h - Header file for private implementation information. -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -166,9 +166,20 @@ extern void _Jv_GetTypesFromSignature (jmethodID method,\n \t\t\t\t       jclass declaringClass,\n \t\t\t\t       JArray<jclass> **arg_types_out,\n \t\t\t\t       jclass *return_type_out);\n-extern jobject _Jv_CallNonvirtualMethodA (jobject, jclass,\n-\t\t\t\t\t  jmethodID, jboolean,\n-\t\t\t\t\t  JArray<jclass> *, jobjectArray);\n+\n+extern jobject _Jv_CallAnyMethodA (jobject obj, jclass return_type,\n+\t\t\t\t   jmethodID meth, jboolean is_constructor,\n+\t\t\t\t   JArray<jclass> *parameter_types,\n+\t\t\t\t   jobjectArray args);\n+\n+union jvalue;\n+extern jthrowable _Jv_CallAnyMethodA (jobject obj,\n+\t\t\t\t      jclass return_type,\n+\t\t\t\t      jmethodID meth,\n+\t\t\t\t      jboolean is_constructor,\n+\t\t\t\t      JArray<jclass> *parameter_types,\n+\t\t\t\t      jvalue *args,\n+\t\t\t\t      jvalue *result);\n \n extern jobject _Jv_NewMultiArray (jclass, jint ndims, jint* dims)\n   __attribute__((__malloc__));"}, {"sha": "84834f3120cd39788e98e160e7e7982a9c29cf5b", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -60,6 +60,9 @@ struct _Jv_Method\n   _Jv_Utf8Const *signature;\n   unsigned short accflags;\n   void *ncode;\n+\n+  _Jv_Method *getNextMethod ()\n+  { return this + 1; }\n };\n \n #define JV_PRIMITIVE_VTABLE ((_Jv_VTable *) -1)\n@@ -168,13 +171,19 @@ class java::lang::Class : public java::lang::Object\n \n   friend jfieldID JvGetFirstInstanceField (jclass);\n   friend jint JvNumInstanceFields (jclass);\n+  friend jfieldID JvGetFirstStaticField (jclass);\n+  friend jint JvNumStaticFields (jclass);\n+\n   friend jobject _Jv_AllocObject (jclass, jint);\n   friend jobjectArray _Jv_NewObjectArray (jsize, jclass, jobject);\n   friend jobject _Jv_NewPrimArray (jclass, jint);\n   friend jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv *, jclass, jfieldID);\n   friend jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);\n+\n   friend jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);\n   friend jmethodID _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *);\n+  friend jint JvNumMethods (jclass);\n+  friend jmethodID JvGetFirstMethod (jclass);\n \n   friend class _Jv_PrimClass;\n \n@@ -257,4 +266,17 @@ class java::lang::Class : public java::lang::Object\n   java::lang::Thread *thread;\n };\n \n+\n+extern inline jint\n+JvNumMethods (jclass klass)\n+{\n+  return klass->method_count;\n+}\n+\n+extern inline jmethodID\n+JvGetFirstMethod (jclass klass)\n+{\n+  return &klass->methods[0];\n+}\n+\n #endif /* __JAVA_LANG_CLASS_H__ */"}, {"sha": "82eb3e9b88e1a1458596d1f757f4c14561f533c8", "filename": "libjava/java/lang/reflect/natConstructor.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -48,6 +48,6 @@ java::lang::reflect::Constructor::newInstance (jobjectArray args)\n   jmethodID meth = _Jv_FromReflectedConstructor (this);\n   // In the constructor case the return type is the type of the\n   // constructor.\n-  return _Jv_CallNonvirtualMethodA (NULL, declaringClass, meth, true,\n-\t\t\t\t    parameter_types, args);\n+  return _Jv_CallAnyMethodA (NULL, declaringClass, meth, true,\n+\t\t\t     parameter_types, args);\n }"}, {"sha": "988fa1e00fb0ad4f29b5c4b3b924e66213521a62", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 138, "deletions": 77, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -12,6 +12,7 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <jni.h>\n \n #include <java/lang/reflect/Method.h>\n #include <java/lang/reflect/Constructor.h>\n@@ -187,8 +188,8 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n       meth = _Jv_LookupDeclaredMethod (k, meth->name, meth->signature);\n     }\n \n-  return _Jv_CallNonvirtualMethodA (obj, return_type, meth, false,\n-\t\t\t\t    parameter_types, args);\n+  return _Jv_CallAnyMethodA (obj, return_type, meth, false,\n+\t\t\t     parameter_types, args);\n }\n \n jint\n@@ -311,23 +312,22 @@ _Jv_GetTypesFromSignature (jmethodID method,\n // functions.  It handles both Methods and Constructors, and it can\n // handle any return type.  In the Constructor case, the `obj'\n // argument is unused and should be NULL; also, the `return_type' is\n-// the class that the constructor will construct.\n-jobject\n-_Jv_CallNonvirtualMethodA (jobject obj,\n-\t\t\t   jclass return_type,\n-\t\t\t   jmethodID meth,\n-\t\t\t   jboolean is_constructor,\n-\t\t\t   JArray<jclass> *parameter_types,\n-\t\t\t   jobjectArray args)\n+// the class that the constructor will construct.  RESULT is a pointer\n+// to a `jvalue' (see jni.h); for a void method this should be NULL.\n+// This function returns an exception (if one was thrown), or NULL if\n+// the call went ok.\n+jthrowable\n+_Jv_CallAnyMethodA (jobject obj,\n+\t\t    jclass return_type,\n+\t\t    jmethodID meth,\n+\t\t    jboolean is_constructor,\n+\t\t    JArray<jclass> *parameter_types,\n+\t\t    jvalue *args,\n+\t\t    jvalue *result)\n {\n   JvAssert (! is_constructor || ! obj);\n   JvAssert (! is_constructor || ! return_type);\n \n-  // FIXME: access checks.\n-\n-  if (parameter_types->length != args->length)\n-    JvThrow (new java::lang::IllegalArgumentException);\n-\n   // See whether call needs an object as the first argument.  A\n   // constructor does need a `this' argument, but it is one we create.\n   jboolean needs_this = false;\n@@ -349,7 +349,6 @@ _Jv_CallNonvirtualMethodA (jobject obj,\n \t\t\t\t\t      * sizeof (ffi_type *));\n \n   jclass *paramelts = elements (parameter_types);\n-  jobject *argelts = elements (args);\n \n   // FIXME: at some point the compiler is going to add extra arguments\n   // to some functions.  In particular we are going to do this for\n@@ -376,22 +375,11 @@ _Jv_CallNonvirtualMethodA (jobject obj,\n \n   for (int arg = 0; i < param_count; ++i, ++arg)\n     {\n-      jclass k = argelts[arg] ? argelts[arg]->getClass() : NULL;\n-      argtypes[i] = get_ffi_type (k);\n+      argtypes[i] = get_ffi_type (paramelts[arg]);\n       if (paramelts[arg]->isPrimitive())\n-\t{\n-\t  if (! argelts[arg]\n-\t      || ! k\n-\t      || ! can_widen (k, paramelts[arg]))\n-\t    JvThrow (new java::lang::IllegalArgumentException);\n-\t  size += paramelts[arg]->size();\n-\t}\n+\tsize += paramelts[arg]->size();\n       else\n-\t{\n-\t  if (argelts[arg] && ! paramelts[arg]->isAssignableFrom (k))\n-\t    JvThrow (new java::lang::IllegalArgumentException);\n-\t  size += sizeof (jobject);\n-\t}\n+\tsize += sizeof (jobject);\n     }\n \n   ffi_cif cif;\n@@ -404,89 +392,162 @@ _Jv_CallNonvirtualMethodA (jobject obj,\n   char *p = (char *) alloca (size);\n   void **values = (void **) alloca (param_count * sizeof (void *));\n \n-#define COPY(Where, What, Type) \\\n-  do { \\\n-    Type val = (What); \\\n-    memcpy ((Where), &val, sizeof (Type)); \\\n-    values[i] = (Where); \\\n-    Where += sizeof (Type); \\\n-  } while (0)\n-\n   i = 0;\n   if (needs_this)\n     {\n-      COPY (p, obj, jobject);\n+      values[i] = p;\n+      memcpy (p, &obj, sizeof (jobject));\n+      p += sizeof (jobject);\n       ++i;\n     }\n \n   for (int arg = 0; i < param_count; ++i, ++arg)\n     {\n-      java::lang::Number *num = (java::lang::Number *) argelts[arg];\n-      if (paramelts[arg] == JvPrimClass (byte))\n-\tCOPY (p, num->byteValue(), jbyte);\n-      else if (paramelts[arg] == JvPrimClass (short))\n-\tCOPY (p, num->shortValue(), jshort);\n-      else if (paramelts[arg] == JvPrimClass (int))\n-\tCOPY (p, num->intValue(), jint);\n-      else if (paramelts[arg] == JvPrimClass (long))\n-\tCOPY (p, num->longValue(), jlong);\n-      else if (paramelts[arg] == JvPrimClass (float))\n-\tCOPY (p, num->floatValue(), jfloat);\n-      else if (paramelts[arg] == JvPrimClass (double))\n-\tCOPY (p, num->doubleValue(), jdouble);\n-      else if (paramelts[arg] == JvPrimClass (boolean))\n-\tCOPY (p, ((java::lang::Boolean *) argelts[arg])->booleanValue(),\n-\t      jboolean);\n-      else if (paramelts[arg] == JvPrimClass (char))\n-\tCOPY (p, ((java::lang::Character *) argelts[arg])->charValue(), jchar);\n+      int tsize;\n+      if (paramelts[arg]->isPrimitive())\n+\ttsize = paramelts[arg]->size();\n       else\n-\t{\n-\t  JvAssert (! paramelts[arg]->isPrimitive());\n-\t  COPY (p, argelts[arg], jobject);\n-\t}\n+\ttsize = sizeof (jobject);\n+\n+      // Copy appropriate bits from the jvalue into the ffi array.\n+      // FIXME: we could do this copying all in one loop, above, by\n+      // over-allocating a bit.\n+      values[i] = p;\n+      memcpy (p, &args[arg], tsize);\n+      p += tsize;\n     }\n \n   // FIXME: initialize class here.\n \n-  // Largest possible value.  Hopefully it is aligned!\n-  jdouble ret_value;\n   java::lang::Throwable *ex;\n   using namespace java::lang;\n   using namespace java::lang::reflect;\n   ex = Method::hack_trampoline ((gnu::gcj::RawData *) &cif,\n \t\t\t\t(gnu::gcj::RawData *) meth->ncode,\n-\t\t\t\t(gnu::gcj::RawData *) &ret_value,\n+\t\t\t\t(gnu::gcj::RawData *) result,\n \t\t\t\t(gnu::gcj::RawData *) values);\n \n   if (ex)\n-    JvThrow (new InvocationTargetException (ex));\n+    // FIXME: this is wrong for JNI.  But if we just return the\n+    // exception, then the non-JNI cases won't be able to distinguish\n+    // it from exceptions we might generate ourselves.  Sigh.\n+    ex = new InvocationTargetException (ex);\n+\n+  if (is_constructor)\n+    result->l = obj;\n+\n+  return ex;\n+}\n+\n+// This is another version of _Jv_CallAnyMethodA, but this one does\n+// more checking and is used by the reflection (and not JNI) code.\n+jobject\n+_Jv_CallAnyMethodA (jobject obj,\n+\t\t    jclass return_type,\n+\t\t    jmethodID meth,\n+\t\t    jboolean is_constructor,\n+\t\t    JArray<jclass> *parameter_types,\n+\t\t    jobjectArray args)\n+{\n+  // FIXME: access checks.\n+\n+  if (parameter_types->length != args->length)\n+    JvThrow (new java::lang::IllegalArgumentException);\n+\n+  int param_count = parameter_types->length;\n+\n+  jclass *paramelts = elements (parameter_types);\n+  jobject *argelts = elements (args);\n+  jvalue argvals[param_count];\n+\n+#define COPY(Where, What, Type) \\\n+  do { \\\n+    Type val = (What); \\\n+    memcpy ((Where), &val, sizeof (Type)); \\\n+  } while (0)\n+\n+  for (int i = 0; i < param_count; ++i)\n+    {\n+      jclass k = argelts[i] ? argelts[i]->getClass() : NULL;\n+      if (paramelts[i]->isPrimitive())\n+\t{\n+\t  if (! argelts[i]\n+\t      || ! k\n+\t      || ! can_widen (k, paramelts[i]))\n+\t    JvThrow (new java::lang::IllegalArgumentException);\n+\t}\n+      else\n+\t{\n+\t  if (argelts[i] && ! paramelts[i]->isAssignableFrom (k))\n+\t    JvThrow (new java::lang::IllegalArgumentException);\n+\t}\n+\n+      java::lang::Number *num = (java::lang::Number *) argelts[i];\n+      if (paramelts[i] == JvPrimClass (byte))\n+\tCOPY (&argvals[i], num->byteValue(), jbyte);\n+      else if (paramelts[i] == JvPrimClass (short))\n+\tCOPY (&argvals[i], num->shortValue(), jshort);\n+      else if (paramelts[i] == JvPrimClass (int))\n+\tCOPY (&argvals[i], num->intValue(), jint);\n+      else if (paramelts[i] == JvPrimClass (long))\n+\tCOPY (&argvals[i], num->longValue(), jlong);\n+      else if (paramelts[i] == JvPrimClass (float))\n+\tCOPY (&argvals[i], num->floatValue(), jfloat);\n+      else if (paramelts[i] == JvPrimClass (double))\n+\tCOPY (&argvals[i], num->doubleValue(), jdouble);\n+      else if (paramelts[i] == JvPrimClass (boolean))\n+\tCOPY (&argvals[i],\n+\t      ((java::lang::Boolean *) argelts[i])->booleanValue(),\n+\t      jboolean);\n+      else if (paramelts[i] == JvPrimClass (char))\n+\tCOPY (&argvals[i],\n+\t      ((java::lang::Character *) argelts[i])->charValue(),\n+\t      jchar);\n+      else\n+\t{\n+\t  JvAssert (! paramelts[i]->isPrimitive());\n+\t  COPY (&argvals[i], argelts[i], jobject);\n+\t}\n+    }\n+\n+  jvalue ret_value;\n+  java::lang::Throwable *ex = _Jv_CallAnyMethodA (obj,\n+\t\t\t\t\t\t  return_type,\n+\t\t\t\t\t\t  meth,\n+\t\t\t\t\t\t  is_constructor,\n+\t\t\t\t\t\t  parameter_types,\n+\t\t\t\t\t\t  argvals,\n+\t\t\t\t\t\t  &ret_value);\n+\n+  if (ex)\n+    JvThrow (ex);\n \n   jobject r;\n-#define VAL(Wrapper, Type)  (new Wrapper (* (Type *) &ret_value))\n+#define VAL(Wrapper, Field)  (new Wrapper (ret_value.Field))\n   if (is_constructor)\n-    r = obj;\n-  else if (return_type == JvPrimClass (byte))\n-    r = VAL (java::lang::Byte, jbyte);\n+    r = ret_value.l;\n+  else  if (return_type == JvPrimClass (byte))\n+    r = VAL (java::lang::Byte, b);\n   else if (return_type == JvPrimClass (short))\n-    r = VAL (java::lang::Short, jshort);\n+    r = VAL (java::lang::Short, s);\n   else if (return_type == JvPrimClass (int))\n-    r = VAL (java::lang::Integer, jint);\n+    r = VAL (java::lang::Integer, i);\n   else if (return_type == JvPrimClass (long))\n-    r = VAL (java::lang::Long, jlong);\n+    r = VAL (java::lang::Long, j);\n   else if (return_type == JvPrimClass (float))\n-    r = VAL (java::lang::Float, jfloat);\n+    r = VAL (java::lang::Float, f);\n   else if (return_type == JvPrimClass (double))\n-    r = VAL (java::lang::Double, jdouble);\n+    r = VAL (java::lang::Double, d);\n   else if (return_type == JvPrimClass (boolean))\n-    r = VAL (java::lang::Boolean, jboolean);\n+    r = VAL (java::lang::Boolean, z);\n   else if (return_type == JvPrimClass (char))\n-    r = VAL (java::lang::Character, jchar);\n+    r = VAL (java::lang::Character, c);\n   else if (return_type == JvPrimClass (void))\n     r = NULL;\n   else\n     {\n       JvAssert (return_type == NULL || ! return_type->isPrimitive());\n-      r = * (Object **) &ret_value;\n+      r = ret_value.l;\n     }\n \n   return r;"}, {"sha": "cc0ba6b44c7f03c144a297de4a1b2442f7360d9a", "filename": "libjava/jni.cc", "status": "modified", "additions": 986, "deletions": 224, "changes": 1210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9220959f7ab20324aee4c78f0ed2233a623f74/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=8a9220959f7ab20324aee4c78f0ed2233a623f74", "patch": "@@ -1,19 +1,85 @@\n // jni.cc - JNI implementation, including the jump table.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n+// Note: currently we take the approach of not checking most\n+// arguments.  Instead we could do more checking conditionally (e.g.,\n+// if DEBUG is defined).  That might be beneficial in some cases,\n+// though to me it seems that one could just as easily use the\n+// debugger.\n+\n #include <config.h>\n \n #include <stddef.h>\n \n+// Must define this before jni.h.\n+#define GCJ_JV_JNIENV_FRIEND \\\n+    friend jthrowable &get_throwable (JNIEnv *)\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java-assert.h>\n #include <jni.h>\n #include <gcj/field.h>\n+#include <java/lang/Throwable.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/InstantiationException.h>\n+#include <java/lang/NoSuchFieldError.h>\n+#include <java/lang/NoSuchMethodError.h>\n+#include <java/lang/reflect/Constructor.h>\n+#include <java/lang/reflect/Modifier.h>\n+\n+#define ClassClass _CL_Q34java4lang5Class\n+extern java::lang::Class ClassClass;\n+#define ObjectClass _CL_Q34java4lang6Object\n+extern java::lang::Class ObjectClass;\n+\n+// This enum is used to select different template instantiations in\n+// the invocation code.\n+enum invocation_type\n+{\n+  normal,\n+  nonvirtual,\n+  static_type,\n+  constructor\n+};\n+\n+\f\n+\n+// Tell the GC that a certain pointer is live.\n+static void\n+mark_for_gc (void *)\n+{\n+  // FIXME.\n+}\n+\n+// Unmark a pointer.\n+static void\n+unmark_for_gc (void *)\n+{\n+  // FIXME.\n+}\n+\n+// Return throwable in env.\n+jthrowable &\n+get_throwable (JNIEnv *env)\n+{\n+  return env->ex;\n+}\n+\n+\f\n+\n+static jint\n+_Jv_JNI_GetVersion (JNIEnv *)\n+{\n+  return JNI_VERSION_1_2;\n+}\n \n static jclass\n _Jv_JNI_GetSuperclass (JNIEnv *, jclass clazz)\n@@ -27,34 +93,556 @@ IsAssignableFrom(JNIEnv *, jclass clazz1, jclass clazz2)\n   return clazz1->isAssignableFrom (clazz2);\n }\n \n+static jint\n+_Jv_JNI_Throw (JNIEnv *env, jthrowable obj)\n+{\n+  get_throwable (env) = obj;\n+  return 0;\n+}\n+\n+static jint\n+_Jv_JNI_ThrowNew (JNIEnv *env, jclass clazz, const char *message)\n+{\n+  using namespace java::lang::reflect;\n+\n+  JArray<jclass> *argtypes\n+    = (JArray<jclass> *) JvNewObjectArray (1, &ClassClass, NULL);\n+\n+  jclass *elts = elements (argtypes);\n+  elts[0] = &StringClass;\n+\n+  // FIXME: exception processing.\n+  Constructor *cons = clazz->getConstructor (argtypes);\n+\n+  jobjectArray values = JvNewObjectArray (1, &StringClass, NULL);\n+  jobject *velts = elements (values);\n+  velts[0] = JvNewStringUTF (message);\n+\n+  // FIXME: exception processing.\n+  jobject obj = cons->newInstance (values);\n+\n+  get_throwable (env) = reinterpret_cast<jthrowable> (obj);\n+  return 0;\n+}\n+\n+static jthrowable\n+_Jv_JNI_ExceptionOccurred (JNIEnv *env)\n+{\n+  return get_throwable (env);\n+}\n+\n+static void\n+_Jv_JNI_ExceptionDescribe (JNIEnv *env)\n+{\n+  if (get_throwable (env) != NULL)\n+    get_throwable (env)->printStackTrace();\n+}\n+\n+static void\n+_Jv_JNI_ExceptionClear (JNIEnv *env)\n+{\n+  get_throwable (env) = NULL;\n+}\n+\n+static void\n+_Jv_JNI_FatalError (JNIEnv *, const char *message)\n+{\n+  JvFail (message);\n+}\n+\n+static jboolean\n+_Jv_JNI_IsSameObject (JNIEnv *, jobject obj1, jobject obj2)\n+{\n+  return obj1 == obj2;\n+}\n+\n static jobject\n-_Jv_JNI_GetObjectField (JNIEnv *, jobject obj, jfieldID field) \n+_Jv_JNI_AllocObject (JNIEnv *env, jclass clazz)\n {\n-  return _Jv_GetObjectField (obj, field);\n+  jobject obj = NULL;\n+  using namespace java::lang::reflect;\n+  if (clazz->isInterface() || Modifier::isAbstract(clazz->getModifiers()))\n+    get_throwable (env) = new java::lang::InstantiationException ();\n+  else\n+    {\n+      // FIXME: exception processing.\n+      // FIXME: will this work for String?\n+      obj = JvAllocObject (clazz);\n+    }\n+\n+  return obj;\n }\n \n-static jbyte\n-_Jv_JNI_GetByteField (JNIEnv *, jobject obj, jfieldID field) \n+static jclass\n+_Jv_JNI_GetObjectClass (JNIEnv *, jobject obj)\n {\n-  return _Jv_GetByteField (obj, field);\n+  return obj->getClass();\n }\n \n-static jshort\n-_Jv_JNI_GetShortField (JNIEnv *, jobject obj, jfieldID field) \n+static jboolean\n+_Jv_JNI_IsInstanceOf (JNIEnv *, jobject obj, jclass clazz)\n {\n-  return _Jv_GetShortField (obj, field);\n+  return clazz->isInstance(obj);\n }\n \n-static jint\n-_Jv_JNI_GetIntField (JNIEnv *, jobject obj, jfieldID field) \n+\f\n+\n+//\n+// This section concerns method invocation.\n+//\n+\n+template<jboolean is_static>\n+static jmethodID\n+_Jv_JNI_GetAnyMethodID (JNIEnv *env, jclass clazz,\n+\t\t\tconst char *name, const char *sig)\n {\n-  return _Jv_GetIntField (obj, field);\n+  // FIXME: exception processing.\n+  _Jv_InitClass (clazz);\n+\n+  _Jv_Utf8Const *name_u = _Jv_makeUtf8Const ((char *) name, -1);\n+  _Jv_Utf8Const *sig_u = _Jv_makeUtf8Const ((char *) sig, -1);\n+\n+  JvAssert (! clazz->isPrimitive());\n+\n+  using namespace java::lang::reflect;\n+\n+  while (clazz != NULL)\n+    {\n+      jint count = JvNumMethods (clazz);\n+      jmethodID meth = JvGetFirstMethod (clazz);\n+\n+      for (jint i = 0; i < count; ++i)\n+\t{\n+\t  if (((is_static && Modifier::isStatic (meth->accflags))\n+\t       || (! is_static && ! Modifier::isStatic (meth->accflags)))\n+\t      && _Jv_equalUtf8Consts (meth->name, name_u)\n+\t      && _Jv_equalUtf8Consts (meth->signature, sig_u))\n+\t    return meth;\n+\n+\t  meth = meth->getNextMethod();\n+\t}\n+\n+      clazz = clazz->getSuperclass ();\n+    }\n+\n+  get_throwable (env) = new java::lang::NoSuchMethodError ();\n+  return NULL;\n+}\n+\n+// This is a helper function which turns a va_list into an array of\n+// `jvalue's.  It needs signature information in order to do its work.\n+// The array of values must already be allocated.\n+static void\n+array_from_valist (jvalue *values, JArray<jclass> *arg_types, va_list vargs)\n+{\n+  jclass *arg_elts = elements (arg_types);\n+  for (int i = 0; i < arg_types->length; ++i)\n+    {\n+      if (arg_elts[i] == JvPrimClass (byte))\n+\tvalues[i].b = va_arg (vargs, jbyte);\n+      else if (arg_elts[i] == JvPrimClass (short))\n+\tvalues[i].s = va_arg (vargs, jshort);\n+      else if (arg_elts[i] == JvPrimClass (int))\n+\tvalues[i].i = va_arg (vargs, jint);\n+      else if (arg_elts[i] == JvPrimClass (long))\n+\tvalues[i].j = va_arg (vargs, jlong);\n+      else if (arg_elts[i] == JvPrimClass (float))\n+\tvalues[i].f = va_arg (vargs, jfloat);\n+      else if (arg_elts[i] == JvPrimClass (double))\n+\tvalues[i].d = va_arg (vargs, jdouble);\n+      else if (arg_elts[i] == JvPrimClass (boolean))\n+\tvalues[i].z = va_arg (vargs, jboolean);\n+      else if (arg_elts[i] == JvPrimClass (char))\n+\tvalues[i].c = va_arg (vargs, jchar);\n+      else\n+\t{\n+\t  // An object.\n+\t  values[i].l = va_arg (vargs, jobject);\n+\t}\n+    }\n+}\n+\n+// This can call any sort of method: virtual, \"nonvirtual\", static, or\n+// constructor.\n+template<typename T, invocation_type style>\n+static T\n+_Jv_JNI_CallAnyMethodV (JNIEnv *env, jobject obj, jclass klass,\n+\t\t\tjmethodID id, va_list vargs)\n+{\n+  if (style == normal)\n+    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n+\n+  jclass decl_class = klass ? klass : obj->getClass ();\n+  JvAssert (decl_class != NULL);\n+\n+  jclass return_type;\n+  JArray<jclass> *arg_types;\n+  // FIXME: exception processing.\n+  _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t     &arg_types, &return_type);\n+\n+  jvalue args[arg_types->length];\n+  array_from_valist (args, arg_types, vargs);\n+\n+  jvalue result;\n+  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t      style == constructor,\n+\t\t\t\t      arg_types, args, &result);\n+\n+  if (ex != NULL)\n+    get_throwable (env) = ex;\n+\n+  // We cheat a little here.  FIXME.\n+  return * (T *) &result;\n+}\n+\n+template<typename T, invocation_type style>\n+static T\n+_Jv_JNI_CallAnyMethod (JNIEnv *env, jobject obj, jclass klass,\n+\t\t       jmethodID method, ...)\n+{\n+  va_list args;\n+  T result;\n+\n+  va_start (args, method);\n+  result = _Jv_JNI_CallAnyMethodV<T, style> (env, obj, klass, method, args);\n+  va_end (args);\n+\n+  return result;\n+}\n+\n+template<typename T, invocation_type style>\n+static T\n+_Jv_JNI_CallAnyMethodA (JNIEnv *env, jobject obj, jclass klass,\n+\t\t\tjmethodID id, jvalue *args)\n+{\n+  if (style == normal)\n+    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n+\n+  jclass decl_class = klass ? klass : obj->getClass ();\n+  JvAssert (decl_class != NULL);\n+\n+  jclass return_type;\n+  JArray<jclass> *arg_types;\n+  // FIXME: exception processing.\n+  _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t     &arg_types, &return_type);\n+\n+  jvalue result;\n+  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t      style == constructor,\n+\t\t\t\t      arg_types, args, &result);\n+\n+  if (ex != NULL)\n+    get_throwable (env) = ex;\n+\n+  // We cheat a little here.  FIXME.\n+  return * (T *) &result;\n+}\n+\n+template<invocation_type style>\n+static void\n+_Jv_JNI_CallAnyVoidMethodV (JNIEnv *env, jobject obj, jclass klass,\n+\t\t\t    jmethodID id, va_list vargs)\n+{\n+  if (style == normal)\n+    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n+\n+  jclass decl_class = klass ? klass : obj->getClass ();\n+  JvAssert (decl_class != NULL);\n+\n+  jclass return_type;\n+  JArray<jclass> *arg_types;\n+  // FIXME: exception processing.\n+  _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t     &arg_types, &return_type);\n+\n+  jvalue args[arg_types->length];\n+  array_from_valist (args, arg_types, vargs);\n+\n+  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t      style == constructor,\n+\t\t\t\t      arg_types, args, NULL);\n+\n+  if (ex != NULL)\n+    get_throwable (env) = ex;\n+}\n+\n+template<invocation_type style>\n+static void\n+_Jv_JNI_CallAnyVoidMethod (JNIEnv *env, jobject obj, jclass klass,\n+\t\t\t   jmethodID method, ...)\n+{\n+  va_list args;\n+\n+  va_start (args, method);\n+  _Jv_JNI_CallAnyVoidMethodV<style> (env, obj, klass, method, args);\n+  va_end (args);\n+}\n+\n+template<invocation_type style>\n+static void\n+_Jv_JNI_CallAnyVoidMethodA (JNIEnv *env, jobject obj, jclass klass,\n+\t\t\t    jmethodID id, jvalue *args)\n+{\n+  if (style == normal)\n+    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n+\n+  jclass decl_class = klass ? klass : obj->getClass ();\n+  JvAssert (decl_class != NULL);\n+\n+  jclass return_type;\n+  JArray<jclass> *arg_types;\n+  // FIXME: exception processing.\n+  _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t     &arg_types, &return_type);\n+\n+  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t      style == constructor,\n+\t\t\t\t      arg_types, args, NULL);\n+\n+  if (ex != NULL)\n+    get_throwable (env) = ex;\n+}\n+\n+// Functions with this signature are used to implement functions in\n+// the CallMethod family.\n+template<typename T>\n+static T\n+_Jv_JNI_CallMethodV (JNIEnv *env, jobject obj, jmethodID id, va_list args)\n+{\n+  return _Jv_JNI_CallAnyMethodV<T, normal> (env, obj, NULL, id, args);\n+}\n+\n+// Functions with this signature are used to implement functions in\n+// the CallMethod family.\n+template<typename T>\n+static T\n+_Jv_JNI_CallMethod (JNIEnv *env, jobject obj, jmethodID id, ...)\n+{\n+  va_list args;\n+  T result;\n+\n+  va_start (args, id);\n+  result = _Jv_JNI_CallAnyMethodV<T, normal> (env, obj, NULL, id, args);\n+  va_end (args);\n+\n+  return result;\n+}\n+\n+// Functions with this signature are used to implement functions in\n+// the CallMethod family.\n+template<typename T>\n+static T\n+_Jv_JNI_CallMethodA (JNIEnv *env, jobject obj, jmethodID id, jvalue *args)\n+{\n+  return _Jv_JNI_CallAnyMethodA<T, normal> (env, obj, NULL, id, args);\n+}\n+\n+static void\n+_Jv_JNI_CallVoidMethodV (JNIEnv *env, jobject obj, jmethodID id, va_list args)\n+{\n+  _Jv_JNI_CallAnyVoidMethodV<normal> (env, obj, NULL, id, args);\n+}\n+\n+static void\n+_Jv_JNI_CallVoidMethod (JNIEnv *env, jobject obj, jmethodID id, ...)\n+{\n+  va_list args;\n+\n+  va_start (args, id);\n+  _Jv_JNI_CallAnyVoidMethodV<normal> (env, obj, NULL, id, args);\n+  va_end (args);\n }\n \n-static jlong\n-_Jv_JNI_GetLongField (JNIEnv *, jobject obj, jfieldID field) \n+static void\n+_Jv_JNI_CallVoidMethodA (JNIEnv *env, jobject obj, jmethodID id, jvalue *args)\n {\n-  return _Jv_GetLongField (obj, field);\n+  _Jv_JNI_CallAnyVoidMethodA<normal> (env, obj, NULL, id, args);\n+}\n+\n+// Functions with this signature are used to implement functions in\n+// the CallStaticMethod family.\n+template<typename T>\n+static T\n+_Jv_JNI_CallStaticMethodV (JNIEnv *env, jclass klass,\n+\t\t\t   jmethodID id, va_list args)\n+{\n+  return _Jv_JNI_CallAnyMethodV<T, static_type> (env, NULL, klass, id, args);\n+}\n+\n+// Functions with this signature are used to implement functions in\n+// the CallStaticMethod family.\n+template<typename T>\n+static T\n+_Jv_JNI_CallStaticMethod (JNIEnv *env, jclass klass, jmethodID id, ...)\n+{\n+  va_list args;\n+  T result;\n+\n+  va_start (args, id);\n+  result = _Jv_JNI_CallAnyMethodV<T, static_type> (env, NULL, klass,\n+\t\t\t\t\t\t   id, args);\n+  va_end (args);\n+\n+  return result;\n+}\n+\n+// Functions with this signature are used to implement functions in\n+// the CallStaticMethod family.\n+template<typename T>\n+static T\n+_Jv_JNI_CallStaticMethodA (JNIEnv *env, jclass klass, jmethodID id,\n+\t\t\t   jvalue *args)\n+{\n+  return _Jv_JNI_CallAnyMethodA<T, static_type> (env, NULL, klass, id, args);\n+}\n+\n+static void\n+_Jv_JNI_CallStaticVoidMethodV (JNIEnv *env, jclass klass, jmethodID id,\n+\t\t\t       va_list args)\n+{\n+  _Jv_JNI_CallAnyVoidMethodV<static_type> (env, NULL, klass, id, args);\n+}\n+\n+static void\n+_Jv_JNI_CallStaticVoidMethod (JNIEnv *env, jclass klass, jmethodID id, ...)\n+{\n+  va_list args;\n+\n+  va_start (args, id);\n+  _Jv_JNI_CallAnyVoidMethodV<static_type> (env, NULL, klass, id, args);\n+  va_end (args);\n+}\n+\n+static void\n+_Jv_JNI_CallStaticVoidMethodA (JNIEnv *env, jclass klass, jmethodID id,\n+\t\t\t       jvalue *args)\n+{\n+  _Jv_JNI_CallAnyVoidMethodA<static_type> (env, NULL, klass, id, args);\n+}\n+\n+static jobject\n+_Jv_JNI_NewObjectV (JNIEnv *env, jclass klass,\n+\t\t    jmethodID id, va_list args)\n+{\n+  return _Jv_JNI_CallAnyMethodV<jobject, constructor> (env, NULL, klass,\n+\t\t\t\t\t\t       id, args);\n+}\n+\n+static jobject\n+_Jv_JNI_NewObject (JNIEnv *env, jclass klass, jmethodID id, ...)\n+{\n+  va_list args;\n+  jobject result;\n+\n+  va_start (args, id);\n+  result = _Jv_JNI_CallAnyMethodV<jobject, constructor> (env, NULL, klass,\n+\t\t\t\t\t\t\t id, args);\n+  va_end (args);\n+\n+  return result;\n+}\n+\n+static jobject\n+_Jv_JNI_NewObjectA (JNIEnv *env, jclass klass, jmethodID id,\n+\t\t    jvalue *args)\n+{\n+  return _Jv_JNI_CallAnyMethodA<jobject, constructor> (env, NULL, klass,\n+\t\t\t\t\t\t       id, args);\n+}\n+\n+\f\n+\n+template<typename T>\n+static T\n+_Jv_JNI_GetField (JNIEnv *, jobject obj, jfieldID field) \n+{\n+  T *ptr = (T *) ((char *) obj + field->getOffset ());\n+  return *ptr;\n+}\n+\n+template<typename T>\n+static void\n+_Jv_JNI_SetField (JNIEnv *, jobject obj, jfieldID field, T value)\n+{\n+  T *ptr = (T *) ((char *) obj + field->getOffset ());\n+  *ptr = value;\n+}\n+\n+template<jboolean is_static>\n+static jfieldID\n+_Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n+\t\t       const char *name, const char *sig)\n+{\n+  // FIXME: exception processing.\n+  _Jv_InitClass (clazz);\n+\n+  _Jv_Utf8Const *a_name = _Jv_makeUtf8Const ((char *) name, -1);\n+\n+  jclass field_class = NULL;\n+  if (sig[0] == '[')\n+    field_class = _Jv_FindClassFromSignature ((char *) sig, NULL);\n+  else\n+    {\n+      _Jv_Utf8Const *sig_u = _Jv_makeUtf8Const ((char *) sig, -1);\n+      field_class = _Jv_FindClass (sig_u, NULL);\n+    }\n+\n+  // FIXME: what if field_class == NULL?\n+\n+  while (clazz != NULL)\n+    {\n+      jint count = (is_static\n+\t\t    ? JvNumStaticFields (clazz)\n+\t\t    : JvNumInstanceFields (clazz));\n+      jfieldID field = (is_static\n+\t\t\t? JvGetFirstStaticField (clazz)\n+\t\t\t: JvGetFirstInstanceField (clazz));\n+      for (jint i = 0; i < count; ++i)\n+\t{\n+\t  // The field is resolved as a side effect of class\n+\t  // initialization.\n+\t  JvAssert (field->isResolved ());\n+\n+\t  _Jv_Utf8Const *f_name = field->getNameUtf8Const(clazz);\n+\n+\t  if (_Jv_equalUtf8Consts (f_name, a_name)\n+\t      && field->getClass() == field_class)\n+\t    return field;\n+\n+\t  field = field->getNextField ();\n+\t}\n+\n+      clazz = clazz->getSuperclass ();\n+    }\n+\n+  get_throwable (env) = new java::lang::NoSuchFieldError ();\n+  return NULL;\n+}\n+\n+template<typename T>\n+static T\n+_Jv_JNI_GetStaticField (JNIEnv *, jclass, jfieldID field)\n+{\n+  T *ptr = (T *) field->u.addr;\n+  return *ptr;\n+}\n+\n+template<typename T>\n+static void\n+_Jv_JNI_SetStaticField (JNIEnv *, jclass, jfieldID field, T value)\n+{\n+  T *ptr = (T *) field->u.addr;\n+  *ptr = value;\n+}\n+\n+static jstring\n+_Jv_JNI_NewString (JNIEnv *, const jchar *unichars, jsize len)\n+{\n+  // FIXME: exception processing.\n+  jstring r = _Jv_NewString (unichars, len);\n+  return r;\n }\n \n static jsize\n@@ -63,6 +651,173 @@ _Jv_JNI_GetStringLength (JNIEnv *, jstring string)\n   return string->length();\n }\n \n+static const jchar *\n+_Jv_JNI_GetStringChars (JNIEnv *, jstring string, jboolean *isCopy)\n+{\n+  jchar *result = _Jv_GetStringChars (string);\n+  mark_for_gc (result);\n+  if (isCopy)\n+    *isCopy = false;\n+  return (const jchar *) result;\n+}\n+\n+static void\n+_Jv_JNI_ReleaseStringChars (JNIEnv *, jstring, const jchar *chars)\n+{\n+  unmark_for_gc ((void *) chars);\n+}\n+\n+static jstring\n+_Jv_JNI_NewStringUTF (JNIEnv *, const char *bytes)\n+{\n+  // FIXME: exception processing.\n+  jstring r = JvNewStringUTF (bytes);\n+  return r;\n+}\n+\n+static jsize\n+_Jv_JNI_GetStringUTFLength (JNIEnv *, jstring string)\n+{\n+  return JvGetStringUTFLength (string);\n+}\n+\n+static const char *\n+_Jv_JNI_GetStringUTFChars (JNIEnv *, jstring string, jboolean *isCopy)\n+{\n+  jsize len = JvGetStringUTFLength (string);\n+  // FIXME: exception processing.\n+  char *r = (char *) _Jv_Malloc (len + 1);\n+  JvGetStringUTFRegion (string, 0, len, r);\n+  r[len] = '\\0';\n+\n+  if (isCopy)\n+    *isCopy = true;\n+\n+  return (const char *) r;\n+}\n+\n+static void\n+_Jv_JNI_ReleaseStringUTFChars (JNIEnv *, jstring, const char *utf)\n+{\n+  _Jv_Free ((void *) utf);\n+}\n+\n+static jsize\n+_Jv_JNI_GetArrayLength (JNIEnv *, jarray array)\n+{\n+  return array->length;\n+}\n+\n+static jarray\n+_Jv_JNI_NewObjectArray (JNIEnv *, jsize length, jclass elementClass,\n+\t\t\tjobject init)\n+{\n+  // FIXME: exception processing.\n+  jarray result = JvNewObjectArray (length, elementClass, init);\n+  return result;\n+}\n+\n+static jobject\n+_Jv_JNI_GetObjectArrayElement (JNIEnv *, jobjectArray array, jsize index)\n+{\n+  jobject *elts = elements (array);\n+  return elts[index];\n+}\n+\n+static void\n+_Jv_JNI_SetObjectArrayElement (JNIEnv *, jobjectArray array, jsize index,\n+\t\t\t       jobject value)\n+{\n+  // FIXME: exception processing.\n+  _Jv_CheckArrayStore (array, value);\n+  jobject *elts = elements (array);\n+  elts[index] = value;\n+}\n+\n+template<typename T, jclass K>\n+static JArray<T> *\n+_Jv_JNI_NewPrimitiveArray (JNIEnv *, jsize length)\n+{\n+  return (JArray<T> *) _Jv_NewPrimArray (K, length);\n+}\n+\n+template<typename T>\n+static T *\n+_Jv_JNI_GetPrimitiveArrayElements (JNIEnv *, JArray<T> *array,\n+\t\t\t\t   jboolean *isCopy)\n+{\n+  T *elts = elements (array);\n+  if (isCopy)\n+    {\n+      // We elect never to copy.\n+      *isCopy = false;\n+    }\n+  mark_for_gc (elts);\n+  return elts;\n+}\n+\n+template<typename T>\n+static void\n+_Jv_JNI_ReleasePrimitiveArrayElements (JNIEnv *, JArray<T> *,\n+\t\t\t\t       T *elems, jint /* mode */)\n+{\n+  // Note that we ignore MODE.  We can do this because we never copy\n+  // the array elements.  My reading of the JNI documentation is that\n+  // this is an option for the implementor.\n+  unmark_for_gc (elems);\n+}\n+\n+template<typename T>\n+static void\n+_Jv_JNI_GetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n+\t\t\t\t jsize start, jsize len,\n+\t\t\t\t T *buf)\n+{\n+  if (start < 0 || len >= array->length || start + len >= array->length)\n+    {\n+      // FIXME: index.\n+      get_throwable (env) = new java::lang::ArrayIndexOutOfBoundsException ();\n+    }\n+  else\n+    {\n+      T *elts = elements (array) + start;\n+      memcpy (buf, elts, len * sizeof (T));\n+    }\n+}\n+\n+template<typename T>\n+static void\n+_Jv_JNI_SetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array, \n+\t\t\t\t jsize start, jsize len, T *buf)\n+{\n+  if (start < 0 || len >= array->length || start + len >= array->length)\n+    {\n+      // FIXME: index.\n+      get_throwable (env) = new java::lang::ArrayIndexOutOfBoundsException ();\n+    }\n+  else\n+    {\n+      T *elts = elements (array) + start;\n+      memcpy (elts, buf, len * sizeof (T));\n+    }\n+}\n+\n+static jint\n+_Jv_JNI_MonitorEnter (JNIEnv *, jobject obj)\n+{\n+  // FIXME: exception processing.\n+  jint r = _Jv_MonitorEnter (obj);\n+  return r;\n+}\n+\n+static jint\n+_Jv_JNI_MonitorExit (JNIEnv *, jobject obj)\n+{\n+  // FIXME: exception processing.\n+  jint r = _Jv_MonitorExit (obj);\n+  return r;\n+}\n+\n // JDK 1.2\n jobject\n _Jv_JNI_ToReflectedField (JNIEnv *, jclass cls, jfieldID fieldID)\n@@ -82,227 +837,234 @@ _Jv_JNI_FromReflectedField (JNIEnv *, java::lang::reflect::Field *field)\n }\n \n #define NOT_IMPL NULL\n+#define RESERVED NULL\n \n struct JNINativeInterface _Jv_JNIFunctions =\n {\n-  NULL,\n-  NULL,\n-  NULL,\n-  NULL,\n-  NOT_IMPL /* GetVersion */,\n+  RESERVED,\n+  RESERVED,\n+  RESERVED,\n+  RESERVED,\n+  _Jv_JNI_GetVersion,\n   NOT_IMPL /* DefineClass */,\n   NOT_IMPL /* FindClass */,\n-  NULL,\n-  NULL,\n-  NULL,\n+  RESERVED,\n+  RESERVED,\n+  RESERVED,\n   _Jv_JNI_GetSuperclass,\n   IsAssignableFrom,\n-  NULL,\n-  NOT_IMPL /* Throw */,\n-  NOT_IMPL /* ThrowNew */,\n-  NOT_IMPL /* ExceptionOccurred */,\n-  NOT_IMPL /* ExceptionDescribe */,\n-  NOT_IMPL /* ExceptionClear */,\n-  NOT_IMPL /* FatalError */,\n-  NOT_IMPL /* NULL */,\n-  NOT_IMPL /* NULL */,\n+  RESERVED,\n+  _Jv_JNI_Throw,\n+  _Jv_JNI_ThrowNew,\n+  _Jv_JNI_ExceptionOccurred,\n+  _Jv_JNI_ExceptionDescribe,\n+  _Jv_JNI_ExceptionClear,\n+  _Jv_JNI_FatalError,\n+  RESERVED,\n+  RESERVED,\n   NOT_IMPL /* NewGlobalRef */,\n   NOT_IMPL /* DeleteGlobalRef */,\n   NOT_IMPL /* DeleteLocalRef */,\n-  NOT_IMPL /* IsSameObject */,\n-  NOT_IMPL /* NULL */,\n-  NOT_IMPL /* NULL */,\n-  NOT_IMPL /* AllocObject */,\n-  NOT_IMPL /* NewObject */,\n-  NOT_IMPL /* NewObjectV */,\n-  NOT_IMPL /* NewObjectA */,\n-  NOT_IMPL /* GetObjectClass */,\n-  NOT_IMPL /* IsInstanceOf */,\n-  NOT_IMPL /* GetMethodID */,\n-  NOT_IMPL /* CallObjectMethod */,\n-  NOT_IMPL /* CallObjectMethodV */,\n-  NOT_IMPL /* CallObjectMethodA */,\n-  NOT_IMPL /* CallBooleanMethod */,\n-  NOT_IMPL /* CallBooleanMethodV */,\n-  NOT_IMPL /* CallBooleanMethodA */,\n-  NOT_IMPL /* CallByteMethod */,\n-  NOT_IMPL /* CallByteMethodV */,\n-  NOT_IMPL /* CallByteMethodA */,\n-  NOT_IMPL /* CallCharMethod */,\n-  NOT_IMPL /* CallCharMethodV */,\n-  NOT_IMPL /* CallCharMethodA */,\n-  NOT_IMPL /* CallShortMethod */,\n-  NOT_IMPL /* CallShortMethodV */,\n-  NOT_IMPL /* CallShortMethodA */,\n-  NOT_IMPL /* CallIntMethod */,\n-  NOT_IMPL /* CallIntMethodV */,\n-  NOT_IMPL /* CallIntMethodA */,\n-  NOT_IMPL /* CallLongMethod */,\n-  NOT_IMPL /* CallLongMethodV */,\n-  NOT_IMPL /* CallLongMethodA */,\n-  NOT_IMPL /* CallFloatMethod */,\n-  NOT_IMPL /* CallFloatMethodV */,\n-  NOT_IMPL /* CallFloatMethodA */,\n-  NOT_IMPL /* CallDoubleMethod */,\n-  NOT_IMPL /* CallDoubleMethodV */,\n-  NOT_IMPL /* CallDoubleMethodA */,\n-  NOT_IMPL /* CallVoidMethod */,\n-  NOT_IMPL /* CallVoidMethodV */,\n-  NOT_IMPL /* CallVoidMethodA */,\n-  NOT_IMPL /* CallNonvirtualObjectMethod */,\n-  NOT_IMPL /* CallNonvirtualObjectMethodV */,\n-  NOT_IMPL /* CallNonvirtualObjectMethodA */,\n-  NOT_IMPL /* CallNonvirtualBooleanMethod */,\n-  NOT_IMPL /* CallNonvirtualBooleanMethodV */,\n-  NOT_IMPL /* CallNonvirtualBooleanMethodA */,\n-  NOT_IMPL /* CallNonvirtualByteMethod */,\n-  NOT_IMPL /* CallNonvirtualByteMethodV */,\n-  NOT_IMPL /* CallNonvirtualByteMethodA */,\n-  NOT_IMPL /* CallNonvirtualCharMethod */,\n-  NOT_IMPL /* CallNonvirtualCharMethodV */,\n-  NOT_IMPL /* CallNonvirtualCharMethodA */,\n-  NOT_IMPL /* CallNonvirtualShortMethod */,\n-  NOT_IMPL /* CallNonvirtualShortMethodV */,\n-  NOT_IMPL /* CallNonvirtualShortMethodA */,\n-  NOT_IMPL /* CallNonvirtualIntMethod */,\n-  NOT_IMPL /* CallNonvirtualIntMethodV */,\n-  NOT_IMPL /* CallNonvirtualIntMethodA */,\n-  NOT_IMPL /* CallNonvirtualLongMethod */,\n-  NOT_IMPL /* CallNonvirtualLongMethodV */,\n-  NOT_IMPL /* CallNonvirtualLongMethodA */,\n-  NOT_IMPL /* CallNonvirtualFloatMethod */,\n-  NOT_IMPL /* CallNonvirtualFloatMethodV */,\n-  NOT_IMPL /* CallNonvirtualFloatMethodA */,\n-  NOT_IMPL /* CallNonvirtualDoubleMethod */,\n-  NOT_IMPL /* CallNonvirtualDoubleMethodV */,\n-  NOT_IMPL /* CallNonvirtualDoubleMethodA */,\n-  NOT_IMPL /* CallNonvirtualVoidMethod */,\n-  NOT_IMPL /* CallNonvirtualVoidMethodV */,\n-  NOT_IMPL /* CallNonvirtualVoidMethodA */,\n-  NOT_IMPL /* GetFieldID */,\n-  _Jv_JNI_GetObjectField,\n-  NOT_IMPL /* GetBooleanField */,\n-  _Jv_JNI_GetByteField,\n-  NOT_IMPL /* GetCharField */,\n-  _Jv_JNI_GetShortField,\n-  _Jv_JNI_GetIntField,\n-  _Jv_JNI_GetLongField,\n-  NOT_IMPL /* GetFloatField */,\n-  NOT_IMPL /* GetDoubleField */,\n-  NOT_IMPL /* SetObjectField */,\n-  NOT_IMPL /* SetBooleanField */,\n-  NOT_IMPL /* SetByteField */,\n-  NOT_IMPL /* SetCharField */,\n-  NOT_IMPL /* SetShortField */,\n-  NOT_IMPL /* SetIntField */,\n-  NOT_IMPL /* SetLongField */,\n-  NOT_IMPL /* SetFloatField */,\n-  NOT_IMPL /* SetDoubleField */,\n-  NOT_IMPL /* GetStaticMethodID */,\n-  NOT_IMPL /* CallStaticObjectMethod */,\n-  NOT_IMPL /* CallStaticObjectMethodV */,\n-  NOT_IMPL /* CallStaticObjectMethodA */,\n-  NOT_IMPL /* CallStaticBooleanMethod */,\n-  NOT_IMPL /* CallStaticBooleanMethodV */,\n-  NOT_IMPL /* CallStaticBooleanMethodA */,\n-  NOT_IMPL /* CallStaticByteMethod */,\n-  NOT_IMPL /* CallStaticByteMethodV */,\n-  NOT_IMPL /* CallStaticByteMethodA */,\n-  NOT_IMPL /* CallStaticCharMethod */,\n-  NOT_IMPL /* CallStaticCharMethodV */,\n-  NOT_IMPL /* CallStaticCharMethodA */,\n-  NOT_IMPL /* CallStaticShortMethod */,\n-  NOT_IMPL /* CallStaticShortMethodV */,\n-  NOT_IMPL /* CallStaticShortMethodA */,\n-  NOT_IMPL /* CallStaticIntMethod */,\n-  NOT_IMPL /* CallStaticIntMethodV */,\n-  NOT_IMPL /* CallStaticIntMethodA */,\n-  NOT_IMPL /* CallStaticLongMethod */,\n-  NOT_IMPL /* CallStaticLongMethodV */,\n-  NOT_IMPL /* CallStaticLongMethodA */,\n-  NOT_IMPL /* CallStaticFloatMethod */,\n-  NOT_IMPL /* CallStaticFloatMethodV */,\n-  NOT_IMPL /* CallStaticFloatMethodA */,\n-  NOT_IMPL /* CallStaticDoubleMethod */,\n-  NOT_IMPL /* CallStaticDoubleMethodV */,\n-  NOT_IMPL /* CallStaticDoubleMethodA */,\n-  NOT_IMPL /* CallStaticVoidMethod */,\n-  NOT_IMPL /* CallStaticVoidMethodV */,\n-  NOT_IMPL /* CallStaticVoidMethodA */,\n-  NOT_IMPL /* GetStaticFieldID */,\n-  NOT_IMPL /* GetStaticObjectField */,\n-  NOT_IMPL /* GetStaticBooleanField */,\n-  NOT_IMPL /* GetStaticByteField */,\n-  NOT_IMPL /* GetStaticCharField */,\n-  NOT_IMPL /* GetStaticShortField */,\n-  NOT_IMPL /* GetStaticIntField */,\n-  NOT_IMPL /* GetStaticLongField */,\n-  NOT_IMPL /* GetStaticFloatField */,\n-  NOT_IMPL /* GetStaticDoubleField */,\n-  NOT_IMPL /* SetStaticObjectField */,\n-  NOT_IMPL /* SetStaticBooleanField */,\n-  NOT_IMPL /* SetStaticByteField */,\n-  NOT_IMPL /* SetStaticCharField */,\n-  NOT_IMPL /* SetStaticShortField */,\n-  NOT_IMPL /* SetStaticIntField */,\n-  NOT_IMPL /* SetStaticLongField */,\n-  NOT_IMPL /* SetStaticFloatField */,\n-  NOT_IMPL /* SetStaticDoubleField */,\n-  NOT_IMPL /* NewString */,\n+  _Jv_JNI_IsSameObject,\n+  RESERVED,\n+  RESERVED,\n+  _Jv_JNI_AllocObject,\n+  _Jv_JNI_NewObject,\n+  _Jv_JNI_NewObjectV,\n+  _Jv_JNI_NewObjectA,\n+  _Jv_JNI_GetObjectClass,\n+  _Jv_JNI_IsInstanceOf,\n+  _Jv_JNI_GetAnyMethodID<false>,\n+\n+  _Jv_JNI_CallMethod<jobject>,\n+  _Jv_JNI_CallMethodV<jobject>,\n+  _Jv_JNI_CallMethodA<jobject>,\n+  _Jv_JNI_CallMethod<jboolean>,\n+  _Jv_JNI_CallMethodV<jboolean>,\n+  _Jv_JNI_CallMethodA<jboolean>,\n+  _Jv_JNI_CallMethod<jbyte>,\n+  _Jv_JNI_CallMethodV<jbyte>,\n+  _Jv_JNI_CallMethodA<jbyte>,\n+  _Jv_JNI_CallMethod<jchar>,\n+  _Jv_JNI_CallMethodV<jchar>,\n+  _Jv_JNI_CallMethodA<jchar>,\n+  _Jv_JNI_CallMethod<jshort>,\n+  _Jv_JNI_CallMethodV<jshort>,\n+  _Jv_JNI_CallMethodA<jshort>,\n+  _Jv_JNI_CallMethod<jint>,\n+  _Jv_JNI_CallMethodV<jint>,\n+  _Jv_JNI_CallMethodA<jint>,\n+  _Jv_JNI_CallMethod<jlong>,\n+  _Jv_JNI_CallMethodV<jlong>,\n+  _Jv_JNI_CallMethodA<jlong>,\n+  _Jv_JNI_CallMethod<jfloat>,\n+  _Jv_JNI_CallMethodV<jfloat>,\n+  _Jv_JNI_CallMethodA<jfloat>,\n+  _Jv_JNI_CallMethod<jdouble>,\n+  _Jv_JNI_CallMethodV<jdouble>,\n+  _Jv_JNI_CallMethodA<jdouble>,\n+  _Jv_JNI_CallVoidMethod,\n+  _Jv_JNI_CallVoidMethodV,\n+  _Jv_JNI_CallVoidMethodA,\n+\n+  // Nonvirtual method invocation functions follow.\n+  _Jv_JNI_CallAnyMethod<jobject, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jobject, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jobject, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jboolean, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jboolean, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jboolean, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jbyte, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jbyte, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jbyte, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jchar, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jchar, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jchar, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jshort, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jshort, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jshort, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jint, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jint, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jint, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jlong, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jlong, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jlong, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jfloat, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jfloat, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jfloat, nonvirtual>,\n+  _Jv_JNI_CallAnyMethod<jdouble, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodV<jdouble, nonvirtual>,\n+  _Jv_JNI_CallAnyMethodA<jdouble, nonvirtual>,\n+  _Jv_JNI_CallAnyVoidMethod<nonvirtual>,\n+  _Jv_JNI_CallAnyVoidMethodV<nonvirtual>,\n+  _Jv_JNI_CallAnyVoidMethodA<nonvirtual>,\n+\n+  _Jv_JNI_GetAnyFieldID<false>,\n+  _Jv_JNI_GetField<jobject>,\n+  _Jv_JNI_GetField<jboolean>,\n+  _Jv_JNI_GetField<jbyte>,\n+  _Jv_JNI_GetField<jchar>,\n+  _Jv_JNI_GetField<jshort>,\n+  _Jv_JNI_GetField<jint>,\n+  _Jv_JNI_GetField<jlong>,\n+  _Jv_JNI_GetField<jfloat>,\n+  _Jv_JNI_GetField<jdouble>,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_SetField,\n+  _Jv_JNI_GetAnyMethodID<true>,\n+\n+  _Jv_JNI_CallStaticMethod<jobject>,\n+  _Jv_JNI_CallStaticMethodV<jobject>,\n+  _Jv_JNI_CallStaticMethodA<jobject>,\n+  _Jv_JNI_CallStaticMethod<jboolean>,\n+  _Jv_JNI_CallStaticMethodV<jboolean>,\n+  _Jv_JNI_CallStaticMethodA<jboolean>,\n+  _Jv_JNI_CallStaticMethod<jbyte>,\n+  _Jv_JNI_CallStaticMethodV<jbyte>,\n+  _Jv_JNI_CallStaticMethodA<jbyte>,\n+  _Jv_JNI_CallStaticMethod<jchar>,\n+  _Jv_JNI_CallStaticMethodV<jchar>,\n+  _Jv_JNI_CallStaticMethodA<jchar>,\n+  _Jv_JNI_CallStaticMethod<jshort>,\n+  _Jv_JNI_CallStaticMethodV<jshort>,\n+  _Jv_JNI_CallStaticMethodA<jshort>,\n+  _Jv_JNI_CallStaticMethod<jint>,\n+  _Jv_JNI_CallStaticMethodV<jint>,\n+  _Jv_JNI_CallStaticMethodA<jint>,\n+  _Jv_JNI_CallStaticMethod<jlong>,\n+  _Jv_JNI_CallStaticMethodV<jlong>,\n+  _Jv_JNI_CallStaticMethodA<jlong>,\n+  _Jv_JNI_CallStaticMethod<jfloat>,\n+  _Jv_JNI_CallStaticMethodV<jfloat>,\n+  _Jv_JNI_CallStaticMethodA<jfloat>,\n+  _Jv_JNI_CallStaticMethod<jdouble>,\n+  _Jv_JNI_CallStaticMethodV<jdouble>,\n+  _Jv_JNI_CallStaticMethodA<jdouble>,\n+  _Jv_JNI_CallStaticVoidMethod,\n+  _Jv_JNI_CallStaticVoidMethodV,\n+  _Jv_JNI_CallStaticVoidMethodA,\n+\n+  _Jv_JNI_GetAnyFieldID<true>,\n+  _Jv_JNI_GetStaticField<jobject>,\n+  _Jv_JNI_GetStaticField<jboolean>,\n+  _Jv_JNI_GetStaticField<jbyte>,\n+  _Jv_JNI_GetStaticField<jchar>,\n+  _Jv_JNI_GetStaticField<jshort>,\n+  _Jv_JNI_GetStaticField<jint>,\n+  _Jv_JNI_GetStaticField<jlong>,\n+  _Jv_JNI_GetStaticField<jfloat>,\n+  _Jv_JNI_GetStaticField<jdouble>,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_SetStaticField,\n+  _Jv_JNI_NewString,\n   _Jv_JNI_GetStringLength,\n-  NOT_IMPL /* GetStringChars */,\n-  NOT_IMPL /* ReleaseStringChars */,\n-  NOT_IMPL /* NewStringUTF */,\n-  NOT_IMPL /* GetStringUTFLength */,\n-  NOT_IMPL /* GetStringUTFChars */,\n-  NOT_IMPL /* ReleaseStringUTFChars */,\n-  NOT_IMPL /* GetArrayLength */,\n-  NOT_IMPL /* NewObjectArray */,\n-  NOT_IMPL /* GetObjectArrayElement */,\n-  NOT_IMPL /* SetObjectArrayElement */,\n-  NOT_IMPL /* NewBooleanArray */,\n-  NOT_IMPL /* NewByteArray */,\n-  NOT_IMPL /* NewCharArray */,\n-  NOT_IMPL /* NewShortArray */,\n-  NOT_IMPL /* NewIntArray */,\n-  NOT_IMPL /* NewLongArray */,\n-  NOT_IMPL /* NewFloatArray */,\n-  NOT_IMPL /* NewDoubleArray */,\n-  NOT_IMPL /* GetBooleanArrayElements */,\n-  NOT_IMPL /* GetByteArrayElements */,\n-  NOT_IMPL /* GetCharArrayElements */,\n-  NOT_IMPL /* GetShortArrayElements */,\n-  NOT_IMPL /* GetIntArrayElements */,\n-  NOT_IMPL /* GetLongArrayElements */,\n-  NOT_IMPL /* GetFloatArrayElements */,\n-  NOT_IMPL /* GetDoubleArrayElements */,\n-  NOT_IMPL /* ReleaseBooleanArrayElements */,\n-  NOT_IMPL /* ReleaseByteArrayElements */,\n-  NOT_IMPL /* ReleaseCharArrayElements */,\n-  NOT_IMPL /* ReleaseShortArrayElements */,\n-  NOT_IMPL /* ReleaseIntArrayElements */,\n-  NOT_IMPL /* ReleaseLongArrayElements */,\n-  NOT_IMPL /* ReleaseFloatArrayElements */,\n-  NOT_IMPL /* ReleaseDoubleArrayElements */,\n-  NOT_IMPL /* GetBooleanArrayRegion */,\n-  NOT_IMPL /* GetByteArrayRegion */,\n-  NOT_IMPL /* GetCharArrayRegion */,\n-  NOT_IMPL /* GetShortArrayRegion */,\n-  NOT_IMPL /* GetIntArrayRegion */,\n-  NOT_IMPL /* GetLongArrayRegion */,\n-  NOT_IMPL /* GetFloatArrayRegion */,\n-  NOT_IMPL /* GetDoubleArrayRegion */,\n-  NOT_IMPL /* SetBooleanArrayRegion */,\n-  NOT_IMPL /* SetByteArrayRegion */,\n-  NOT_IMPL /* SetCharArrayRegion */,\n-  NOT_IMPL /* SetShortArrayRegion */,\n-  NOT_IMPL /* SetIntArrayRegion */,\n-  NOT_IMPL /* SetLongArrayRegion */,\n-  NOT_IMPL /* SetFloatArrayRegion */,\n-  NOT_IMPL /* SetDoubleArrayRegion */,\n+  _Jv_JNI_GetStringChars,\n+  _Jv_JNI_ReleaseStringChars,\n+  _Jv_JNI_NewStringUTF,\n+  _Jv_JNI_GetStringUTFLength,\n+  _Jv_JNI_GetStringUTFChars,\n+  _Jv_JNI_ReleaseStringUTFChars,\n+  _Jv_JNI_GetArrayLength,\n+  _Jv_JNI_NewObjectArray,\n+  _Jv_JNI_GetObjectArrayElement,\n+  _Jv_JNI_SetObjectArrayElement,\n+  _Jv_JNI_NewPrimitiveArray<jboolean, JvPrimClass (boolean)>,\n+  _Jv_JNI_NewPrimitiveArray<jbyte, JvPrimClass (byte)>,\n+  _Jv_JNI_NewPrimitiveArray<jchar, JvPrimClass (char)>,\n+  _Jv_JNI_NewPrimitiveArray<jshort, JvPrimClass (short)>,\n+  _Jv_JNI_NewPrimitiveArray<jint, JvPrimClass (int)>,\n+  _Jv_JNI_NewPrimitiveArray<jlong, JvPrimClass (long)>,\n+  _Jv_JNI_NewPrimitiveArray<jfloat, JvPrimClass (float)>,\n+  _Jv_JNI_NewPrimitiveArray<jdouble, JvPrimClass (double)>,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_ReleasePrimitiveArrayElements,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_GetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n+  _Jv_JNI_SetPrimitiveArrayRegion,\n   NOT_IMPL /* RegisterNatives */,\n   NOT_IMPL /* UnregisterNatives */,\n-  NOT_IMPL /* MonitorEnter */,\n-  NOT_IMPL /* MonitorExit */,\n+  _Jv_JNI_MonitorEnter,\n+  _Jv_JNI_MonitorExit,\n   NOT_IMPL /* GetJavaVM */,\n };"}]}