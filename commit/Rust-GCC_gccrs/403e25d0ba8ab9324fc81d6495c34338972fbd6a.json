{"sha": "403e25d0ba8ab9324fc81d6495c34338972fbd6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzZTI1ZDBiYThhYjkzMjRmYzgxZDY0OTVjMzQzMzg5NzJmYmQ2YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-04-21T18:46:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-04-21T18:46:01Z"}, "message": "cse.c (cse_insn): In (set REG0 REG1) case, remove a REG_EQUAL note for REG1.\n\n\t* cse.c (cse_insn): In (set REG0 REG1) case, remove a REG_EQUAL\n\tnote for REG1.\n\nFrom-SVN: r33310", "tree": {"sha": "acc2807cc6b3628d41f6204151d8f7470bd536c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acc2807cc6b3628d41f6204151d8f7470bd536c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/403e25d0ba8ab9324fc81d6495c34338972fbd6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403e25d0ba8ab9324fc81d6495c34338972fbd6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/403e25d0ba8ab9324fc81d6495c34338972fbd6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403e25d0ba8ab9324fc81d6495c34338972fbd6a/comments", "author": null, "committer": null, "parents": [{"sha": "9e62c8114f04116b2107809c51bf33ef1a2993c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e62c8114f04116b2107809c51bf33ef1a2993c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e62c8114f04116b2107809c51bf33ef1a2993c9"}], "stats": {"total": 39, "additions": 23, "deletions": 16}, "files": [{"sha": "b4cb443985deba8fcc33a4ac53e8d185ae9d1ea2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403e25d0ba8ab9324fc81d6495c34338972fbd6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403e25d0ba8ab9324fc81d6495c34338972fbd6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=403e25d0ba8ab9324fc81d6495c34338972fbd6a", "patch": "@@ -1,3 +1,8 @@\n+Fri Apr 21 13:30:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cse.c (cse_insn): In (set REG0 REG1) case, remove a REG_EQUAL\n+\tnote for REG1.\n+\n 2000-04-21  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpphash.c (struct arg, struct arglist): Const-ify strings."}, {"sha": "8c57d791fb76f8d9048a73fc56e8e17cbedc2ed8", "filename": "gcc/cse.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403e25d0ba8ab9324fc81d6495c34338972fbd6a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403e25d0ba8ab9324fc81d6495c34338972fbd6a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=403e25d0ba8ab9324fc81d6495c34338972fbd6a", "patch": "@@ -5928,13 +5928,12 @@ cse_insn (insn, libcall_insn)\n \t  }\n       }\n \n-  /* Special handling for (set REG0 REG1)\n-     where REG0 is the \"cheapest\", cheaper than REG1.\n-     After cse, REG1 will probably not be used in the sequel, \n-     so (if easily done) change this insn to (set REG1 REG0) and\n-     replace REG1 with REG0 in the previous insn that computed their value.\n-     Then REG1 will become a dead store and won't cloud the situation\n-     for later optimizations.\n+  /* Special handling for (set REG0 REG1) where REG0 is the\n+     \"cheapest\", cheaper than REG1.  After cse, REG1 will probably not\n+     be used in the sequel, so (if easily done) change this insn to\n+     (set REG1 REG0) and replace REG1 with REG0 in the previous insn\n+     that computed their value.  Then REG1 will become a dead store\n+     and won't cloud the situation for later optimizations.\n \n      Do not make this change if REG1 is a hard register, because it will\n      then be used in the sequel and we may be changing a two-operand insn\n@@ -5958,19 +5957,18 @@ cse_insn (insn, libcall_insn)\n       if ((src_ent->first_reg == REGNO (SET_DEST (sets[0].rtl)))\n \t  && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t{\n-\t  rtx prev = PREV_INSN (insn);\n-\t  while (prev && GET_CODE (prev) == NOTE)\n-\t    prev = PREV_INSN (prev);\n+\t  rtx prev = prev_nonnote_insn (insn);\n \n-\t  if (prev && GET_CODE (prev) == INSN && GET_CODE (PATTERN (prev)) == SET\n+\t  if (prev != 0 && GET_CODE (prev) == INSN\n+\t      && GET_CODE (PATTERN (prev)) == SET\n \t      && SET_DEST (PATTERN (prev)) == SET_SRC (sets[0].rtl))\n \t    {\n \t      rtx dest = SET_DEST (sets[0].rtl);\n+\t      rtx src = SET_SRC (sets[0].rtl);\n \t      rtx note = find_reg_note (prev, REG_EQUIV, NULL_RTX);\n \n \t      validate_change (prev, & SET_DEST (PATTERN (prev)), dest, 1);\n-\t      validate_change (insn, & SET_DEST (sets[0].rtl),\n-\t\t\t       SET_SRC (sets[0].rtl), 1);\n+\t      validate_change (insn, & SET_DEST (sets[0].rtl), src, 1);\n \t      validate_change (insn, & SET_SRC (sets[0].rtl), dest, 1);\n \t      apply_change_group ();\n \n@@ -5992,10 +5990,14 @@ cse_insn (insn, libcall_insn)\n \t\t  REG_NOTES (prev) = note;\n \t\t}\n \n-\t      /* If INSN has a REG_EQUAL note, and this note mentions REG0,\n-\t\t then we must delete it, because the value in REG0 has changed.  */\n+\t      /* If INSN has a REG_EQUAL note, and this note mentions\n+\t\t REG0, then we must delete it, because the value in\n+\t\t REG0 has changed.  If the note's value is REG1, we must\n+\t\t also delete it because that is now this insn's dest.  */\n \t      note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\t      if (note && reg_mentioned_p (dest, XEXP (note, 0)))\n+\t      if (note != 0\n+\t\t  && (reg_mentioned_p (dest, XEXP (note, 0))\n+\t\t      || rtx_equal_p (src, XEXP (note, 0))))\n \t\tremove_note (insn, note);\n \t    }\n \t}"}]}