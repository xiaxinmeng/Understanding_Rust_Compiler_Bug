{"sha": "d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkZDlkN2Y4ZWZjZjkyYzVjNzBhOWU5MWU5OWE5NzE5YjMxY2Q1MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-11-01T14:03:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-11-01T14:03:27Z"}, "message": "[C++ PATCH] overloaded operator fns [6/N]\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-11/msg00018.html\n\t* cp-tree.h (IDENTIFIER_CP_INDEX): Define.\n\t(enum ovl_op_flags): Add OVL_OP_FLAG_AMBIARY.\n\t(enum ovl_op_code): New.\n\t(struct ovl_op_info): Add ovl_op_code field.\n\t(ovl_op_info): Size by OVL_OP_MAX.\n\t(ovl_op_mapping, ovl_op_alternate): Declare.\n\t(OVL_OP_INFO): Adjust for mapping array.\n\t(IDENTIFIER_OVL_OP_INFO): New.\n\t* decl.c (ambi_op_p, unary_op_p): Delete.\n\t(grok_op_properties): Use IDENTIFIER_OVL_OP_INFO and\n\tovl_op_alternate.\n\t* lex.c (ovl_op_info): Adjust and static initialize.\n\t(ovl_op_mappings, ovl_op_alternate): Define.\n\t(init_operators): Iterate over ovl_op_info array and init mappings\n\t& alternate arrays.\n\t* mangle.c (write_unqualified_id): Use IDENTIFIER_OVL_OP_INFO.\n\t* operators.def (DEF_OPERATOR): Remove KIND parm.\n\t(DEF_SIMPLE_OPERATOR): Delete.\n\t(OPERATOR_TRANSITION): Expand if defined.\n\nFrom-SVN: r254310", "tree": {"sha": "46fe2615cfcde921d2e8142f94bf117cca7fcf43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46fe2615cfcde921d2e8142f94bf117cca7fcf43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0299d48bad088eccb76cf71de064dbc047b8cf62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0299d48bad088eccb76cf71de064dbc047b8cf62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0299d48bad088eccb76cf71de064dbc047b8cf62"}], "stats": {"total": 504, "additions": 268, "deletions": 236}, "files": [{"sha": "8f4cc9951ec33bf3e9674d4afe07e5bdbf6e8e9f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "patch": "@@ -1,3 +1,25 @@\n+2017-11-01  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (IDENTIFIER_CP_INDEX): Define.\n+\t(enum ovl_op_flags): Add OVL_OP_FLAG_AMBIARY.\n+\t(enum ovl_op_code): New.\n+\t(struct ovl_op_info): Add ovl_op_code field.\n+\t(ovl_op_info): Size by OVL_OP_MAX.\n+\t(ovl_op_mapping, ovl_op_alternate): Declare.\n+\t(OVL_OP_INFO): Adjust for mapping array.\n+\t(IDENTIFIER_OVL_OP_INFO): New.\n+\t* decl.c (ambi_op_p, unary_op_p): Delete.\n+\t(grok_op_properties): Use IDENTIFIER_OVL_OP_INFO and\n+\tovl_op_alternate.\n+\t* lex.c (ovl_op_info): Adjust and static initialize.\n+\t(ovl_op_mappings, ovl_op_alternate): Define.\n+\t(init_operators): Iterate over ovl_op_info array and init mappings\n+\t& alternate arrays.\n+\t* mangle.c (write_unqualified_id): Use IDENTIFIER_OVL_OP_INFO.\n+\t* operators.def (DEF_OPERATOR): Remove KIND parm.\n+\t(DEF_SIMPLE_OPERATOR): Delete.\n+\t(OPERATOR_TRANSITION): Expand if defined.\n+\n 2017-10-31  David Malcolm  <dmalcolm@redhat.com>\n \n \t* pt.c (listify): Use %< and %> for description of #include."}, {"sha": "76ee8541daf10e3534dbf075d3780838180cb1e1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "patch": "@@ -1072,6 +1072,11 @@ enum cp_identifier_kind {\n    & IDENTIFIER_KIND_BIT_1 (NODE)\t\t\\\n    & IDENTIFIER_KIND_BIT_0 (NODE))\n \n+/* Access a C++-specific index for identifier NODE.\n+   Used to optimize operator mappings etc.  */\n+#define IDENTIFIER_CP_INDEX(NODE)\t\t\\\n+  (IDENTIFIER_NODE_CHECK(NODE)->base.u.bits.address_space)\n+\n /* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n #define C_TYPE_FIELDS_READONLY(TYPE) \\\n   (LANG_TYPE_CLASS_CHECK (TYPE)->fields_readonly)\n@@ -5477,12 +5482,25 @@ extern void init_reswords (void);\n /* Various flags for the overloaded operator information.  */\n enum ovl_op_flags\n   {\n-    OVL_OP_FLAG_NONE = 0,\n-    OVL_OP_FLAG_UNARY = 1,\n-    OVL_OP_FLAG_BINARY = 2,\n-    OVL_OP_FLAG_ALLOC = 4,  \t/* operator new or delete  */\n-    OVL_OP_FLAG_DELETE = 1,\t/* operator delete  */\n-    OVL_OP_FLAG_VEC = 2\t\t/* vector new or delete  */\n+    OVL_OP_FLAG_NONE = 0,\t/* Don't care.  */\n+    OVL_OP_FLAG_UNARY = 1,\t/* Is unary.  */\n+    OVL_OP_FLAG_BINARY = 2,\t/* Is binary.  */\n+    OVL_OP_FLAG_AMBIARY = 3,\t/* May be unary or binary.  */\n+    OVL_OP_FLAG_ALLOC = 4,  \t/* operator new or delete.  */\n+    OVL_OP_FLAG_DELETE = 1,\t/* operator delete.  */\n+    OVL_OP_FLAG_VEC = 2\t\t/* vector new or delete.  */\n+  };\n+\n+/* Compressed operator codes.  Order is determined by operators.def\n+   and does not match that of tree_codes.  */\n+enum ovl_op_code\n+  {\n+    OVL_OP_ERROR_MARK,\n+    OVL_OP_NOP_EXPR,\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS) OVL_OP_##CODE,\n+#define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING) /* NOTHING */\n+#include \"operators.def\"\n+    OVL_OP_MAX\n   };\n \n struct GTY(()) ovl_op_info_t {\n@@ -5492,19 +5510,29 @@ struct GTY(()) ovl_op_info_t {\n   const char *name;\n   /* The mangled name of the operator.  */\n   const char *mangled_name;\n-  /* The tree code.  */\n+  /* The (regular) tree code.  */\n   enum tree_code tree_code : 16;\n+  /* The (compressed) operator code.  */\n+  enum ovl_op_code ovl_op_code : 8;\n   /* The ovl_op_flags of the operator */\n   unsigned flags : 8;\n };\n \n-/* Overloaded operator info indexed by ass_op_p & tree_code.  */\n-extern GTY(()) ovl_op_info_t ovl_op_info[2][MAX_TREE_CODES];\n+/* Overloaded operator info indexed by ass_op_p & ovl_op_code.  */\n+extern GTY(()) ovl_op_info_t ovl_op_info[2][OVL_OP_MAX];\n+/* Mapping from tree_codes to ovl_op_codes.  */\n+extern GTY(()) unsigned char ovl_op_mapping[MAX_TREE_CODES];\n+/* Mapping for ambi-ary operators from the binary to the unary.  */\n+extern GTY(()) unsigned char ovl_op_alternate[OVL_OP_MAX];\n \n /* Given an ass_op_p boolean and a tree code, return a pointer to its\n    overloaded operator info.  */\n #define OVL_OP_INFO(IS_ASS_P, TREE_CODE)\t\t\t\\\n-  (&ovl_op_info[(IS_ASS_P) != 0][(TREE_CODE)])\n+  (&ovl_op_info[(IS_ASS_P) != 0][ovl_op_mapping[(TREE_CODE)]])\n+/* Overloaded operator info for an identifier for which\n+   IDENTIFIER_ANY_OP_P is true.  */\n+#define IDENTIFIER_OVL_OP_INFO(NODE) \\\n+  (&ovl_op_info[IDENTIFIER_ASSIGN_OP_P (NODE)][IDENTIFIER_CP_INDEX (NODE)])\n \n /* A type-qualifier, or bitmask therefore, using the TYPE_QUAL\n    constants.  */"}, {"sha": "f43c960c939d03577816fca3a011a4848e3d4cba", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 42, "deletions": 101, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "patch": "@@ -65,8 +65,6 @@ static const char *redeclaration_error_message (tree, tree);\n \n static int decl_jump_unsafe (tree);\n static void require_complete_types_for_parms (tree);\n-static bool ambi_op_p (enum tree_code);\n-static bool unary_op_p (enum tree_code);\n static void push_local_name (tree);\n static tree grok_reference_init (tree, tree, tree, int);\n static tree grokvardecl (tree, tree, tree, const cp_decl_specifier_seq *,\n@@ -12874,46 +12872,22 @@ grok_ctor_properties (const_tree ctype, const_tree decl)\n   return true;\n }\n \n-/* An operator with this code is unary, but can also be binary.  */\n-\n-static bool\n-ambi_op_p (enum tree_code code)\n-{\n-  return (code == INDIRECT_REF\n-\t  || code == ADDR_EXPR\n-\t  || code == UNARY_PLUS_EXPR\n-\t  || code == NEGATE_EXPR\n-\t  || code == PREINCREMENT_EXPR\n-\t  || code == PREDECREMENT_EXPR);\n-}\n-\n-/* An operator with this name can only be unary.  */\n-\n-static bool\n-unary_op_p (enum tree_code code)\n-{\n-  return (code == TRUTH_NOT_EXPR\n-\t  || code == BIT_NOT_EXPR\n-\t  || code == COMPONENT_REF\n-\t  || code == TYPE_EXPR);\n-}\n-\n /* DECL is a declaration for an overloaded or conversion operator.  If\n    COMPLAIN is true, errors are issued for invalid declarations.  */\n \n bool\n grok_op_properties (tree decl, bool complain)\n {\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-  int methodp = (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n+  bool methodp = TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE;\n   tree name = DECL_NAME (decl);\n \n   tree class_type = DECL_CONTEXT (decl);\n   if (class_type && !CLASS_TYPE_P (class_type))\n     class_type = NULL_TREE;\n \n-  tree_code operator_code = ERROR_MARK;\n-  unsigned op_flags = OVL_OP_FLAG_NONE;\n+  tree_code operator_code;\n+  unsigned op_flags;\n   if (IDENTIFIER_CONV_OP_P (name))\n     {\n       /* Conversion operators are TYPE_EXPR for the purposes of this\n@@ -12923,21 +12897,11 @@ grok_op_properties (tree decl, bool complain)\n     }\n   else\n     {\n-      /* It'd be nice to hang something else of the identifier to\n-\t find CODE more directly.  */\n-      bool assign_op = IDENTIFIER_ASSIGN_OP_P (name);\n-      const ovl_op_info_t *ovl_op = OVL_OP_INFO (assign_op, 0);\n-      if (false)\n-\t;\n-#define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, KIND)\t\t\\\n-      else if (ovl_op[CODE].identifier == name)\t\t\t\\\n-\toperator_code = (CODE);\n-#include \"operators.def\"\n-#undef DEF_OPERATOR\n-      else\n-\tgcc_unreachable ();\n-      gcc_assert (operator_code != ERROR_MARK);\n-      op_flags = ovl_op[operator_code].flags;\n+      const ovl_op_info_t *ovl_op = IDENTIFIER_OVL_OP_INFO (name);\n+\n+      operator_code = ovl_op->tree_code;\n+      op_flags = ovl_op->flags;\n+      gcc_checking_assert (operator_code != ERROR_MARK);\n       DECL_OVERLOADED_OPERATOR_CODE (decl) = operator_code;\n     }\n \n@@ -13071,89 +13035,66 @@ grok_op_properties (tree decl, bool complain)\n     }\n \n   /* Verify correct number of arguments.  */\n-  if (ambi_op_p (operator_code))\n+  switch (op_flags)\n     {\n+    case OVL_OP_FLAG_AMBIARY:\n       if (arity == 1)\n-\t/* We pick the one-argument operator codes by default, so\n-\t   we don't have to change anything.  */\n-\t;\n-      else if (arity == 2)\n \t{\n-\t  /* If we thought this was a unary operator, we now know\n-\t     it to be a binary operator.  */\n-\t  switch (operator_code)\n-\t    {\n-\t    case INDIRECT_REF:\n-\t      operator_code = MULT_EXPR;\n-\t      break;\n-\n-\t    case ADDR_EXPR:\n-\t      operator_code = BIT_AND_EXPR;\n-\t      break;\n-\n-\t    case UNARY_PLUS_EXPR:\n-\t      operator_code = PLUS_EXPR;\n-\t      break;\n-\n-\t    case NEGATE_EXPR:\n-\t      operator_code = MINUS_EXPR;\n-\t      break;\n-\n-\t    case PREINCREMENT_EXPR:\n-\t      operator_code = POSTINCREMENT_EXPR;\n-\t      break;\n-\n-\t    case PREDECREMENT_EXPR:\n-\t      operator_code = POSTDECREMENT_EXPR;\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\n+\t  /* We have a unary instance of an ambi-ary op.  Remap to the\n+\t     unary one.  */\n+\t  unsigned alt = ovl_op_alternate[ovl_op_mapping [operator_code]];\n+\t  const ovl_op_info_t *ovl_op = &ovl_op_info[false][alt];\n+\t  gcc_checking_assert (ovl_op->flags == OVL_OP_FLAG_UNARY);\n+\t  operator_code = ovl_op->tree_code;\n \t  DECL_OVERLOADED_OPERATOR_CODE (decl) = operator_code;\n-\n-\t  if ((operator_code == POSTINCREMENT_EXPR\n-\t       || operator_code == POSTDECREMENT_EXPR)\n-\t      && ! processing_template_decl\n-\t      && ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)), integer_type_node))\n-\t    {\n-\t      error (methodp\n-\t\t ? G_(\"postfix %qD must have %<int%> as its argument\")\n-\t\t : G_(\"postfix %qD must have %<int%> as its second argument\"),\n-\t\t decl);\n-\t      return false;\n-\t    }\n \t}\n-      else\n+      else if (arity != 2)\n \t{\n+\t  /* This was an ambiguous operator but is invalid. */\n \t  error (methodp\n \t\t ? G_(\"%qD must have either zero or one argument\")\n \t\t : G_(\"%qD must have either one or two arguments\"), decl);\n \t  return false;\n \t}\n-    }\n-  else if (unary_op_p (operator_code))\n-    {\n+      else if ((operator_code == POSTINCREMENT_EXPR\n+\t\t|| operator_code == POSTDECREMENT_EXPR)\n+\t       && ! processing_template_decl\n+\t       /* x++ and x--'s second argument must be an int.  */\n+\t       && ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)),\n+\t\t\t\t integer_type_node))\n+\t{\n+\t  error (methodp\n+\t\t ? G_(\"postfix %qD must have %<int%> as its argument\")\n+\t\t : G_(\"postfix %qD must have %<int%> as its second argument\"),\n+\t\t decl);\n+\t  return false;\n+\t}\n+      break;\n+\n+    case OVL_OP_FLAG_UNARY:\n       if (arity != 1)\n \t{\n \t  error (methodp\n \t\t ? G_(\"%qD must have no arguments\")\n \t\t : G_(\"%qD must have exactly one argument\"), decl);\n \t  return false;\n \t}\n-    }\n-  else\n-    {\n+      break;\n+\n+    case OVL_OP_FLAG_BINARY:\n       if (arity != 2)\n \t{\n \t  error (methodp\n \t\t ? G_(\"%qD must have exactly one argument\")\n \t\t : G_(\"%qD must have exactly two arguments\"), decl);\n \t  return false;\n \t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  \n+\n   /* There can be no default arguments.  */\n   for (tree arg = argtypes; arg != void_list_node; arg = TREE_CHAIN (arg))\n     if (TREE_PURPOSE (arg))"}, {"sha": "7754145f64849efd8f5e62e938cab1cc1b7da2bd", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 81, "deletions": 17, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "patch": "@@ -77,7 +77,20 @@ cxx_finish (void)\n   c_common_finish ();\n }\n \n-ovl_op_info_t ovl_op_info[2][MAX_TREE_CODES];\n+ovl_op_info_t ovl_op_info[2][OVL_OP_MAX] = \n+  {\n+    {\n+      {NULL_TREE, NULL, NULL, ERROR_MARK, OVL_OP_ERROR_MARK, 0},\n+      {NULL_TREE, NULL, NULL, NOP_EXPR, OVL_OP_NOP_EXPR, 0},\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS) \\\n+      {NULL_TREE, NAME, MANGLING, CODE, OVL_OP_##CODE, FLAGS},\n+#define OPERATOR_TRANSITION }, {\t\t\t\\\n+      {NULL_TREE, NULL, NULL, ERROR_MARK, OVL_OP_ERROR_MARK, 0},\n+#include \"operators.def\"\n+    }\n+  };\n+unsigned char ovl_op_mapping[MAX_TREE_CODES];\n+unsigned char ovl_op_alternate[OVL_OP_MAX];\n \n /* Get the name of the kind of identifier T.  */\n \n@@ -129,26 +142,77 @@ set_operator_ident (ovl_op_info_t *ptr)\n   return ident;\n }\n \n+/* Initialize data structures that keep track of operator names.  */\n+\n static void\n init_operators (void)\n {\n-  tree identifier;\n-  ovl_op_info_t *oni;\n-\n-#define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, KIND)\t\t\t\\\n-  oni = OVL_OP_INFO (KIND == cik_assign_op, CODE);\t\t\t\\\n-  oni->name = NAME;\t\t\t\t\t\t\t\\\n-  oni->mangled_name = MANGLING;\t\t\t\t\t\t\\\n-  oni->tree_code = CODE;\t\t\t\t\t\t\\\n-  oni->flags = FLAGS;\t\t\t\t\t\t\t\\\n-  if (NAME) {\t\t\t\t\t\t\t\t\\\n-    identifier = set_operator_ident (oni);\t\t\t\t\\\n-    if (KIND != cik_simple_op || !IDENTIFIER_ANY_OP_P (identifier))\t\\\n-      set_identifier_kind (identifier, KIND);\t\t\t\t\\\n-  }\n+  /* We rely on both these being zero.  */\n+  gcc_checking_assert (!OVL_OP_ERROR_MARK && !ERROR_MARK);\n \n-#include \"operators.def\"\n-#undef DEF_OPERATOR\n+  /* This loop iterates backwards because we need to move the\n+     assignment operators down to their correct slots.  I.e. morally\n+     equivalent to an overlapping memmove where dest > src.  Slot\n+     zero is for error_mark, so hae no operator. */\n+  for (unsigned ix = OVL_OP_MAX; --ix;)\n+    {\n+      ovl_op_info_t *op_ptr = &ovl_op_info[false][ix];\n+\n+      if (op_ptr->name)\n+\t{\n+\t  /* Make sure it fits in lang_decl_fn::operator_code. */\n+\t  gcc_checking_assert (op_ptr->ovl_op_code < (1 << 6));\n+\t  tree ident = set_operator_ident (op_ptr);\n+\t  if (unsigned index = IDENTIFIER_CP_INDEX (ident))\n+\t    {\n+\t      ovl_op_info_t *bin_ptr = &ovl_op_info[false][index];\n+\n+\t      /* They should only differ in unary/binary ness.  */\n+\t      gcc_checking_assert ((op_ptr->flags ^ bin_ptr->flags)\n+\t\t\t\t   == OVL_OP_FLAG_AMBIARY);\n+\t      bin_ptr->flags |= op_ptr->flags;\n+\t      ovl_op_alternate[index] = ix;\n+\t    }\n+\t  else\n+\t    {\n+\t      IDENTIFIER_CP_INDEX (ident) = ix;\n+\t      set_identifier_kind (ident,\n+\t\t\t\t   op_ptr->flags & OVL_OP_FLAG_ALLOC\n+\t\t\t\t   ? cik_newdel_op : cik_simple_op);\n+\t    }\n+\t}\n+      if (op_ptr->tree_code)\n+\t{\n+\t  gcc_checking_assert (op_ptr->ovl_op_code == ix\n+\t\t\t       && !ovl_op_mapping[op_ptr->tree_code]);\n+\t  ovl_op_mapping[op_ptr->tree_code] = op_ptr->ovl_op_code;\n+\t}\n+\n+      ovl_op_info_t *as_ptr = &ovl_op_info[true][ix];\n+      if (as_ptr->name)\n+\t{\n+\t  /* These will be placed at the start of the array, move to\n+\t     the correct slot and initialize.  */\n+\t  if (as_ptr->ovl_op_code != ix)\n+\t    {\n+\t      ovl_op_info_t *dst_ptr = &ovl_op_info[true][as_ptr->ovl_op_code];\n+\t      gcc_assert (as_ptr->ovl_op_code > ix && !dst_ptr->tree_code);\n+\t      memcpy (dst_ptr, as_ptr, sizeof (*dst_ptr));\n+\t      memset (as_ptr, 0, sizeof (*as_ptr));\n+\t      as_ptr = dst_ptr;\n+\t    }\n+\n+\t  tree ident = set_operator_ident (as_ptr);\n+\t  gcc_checking_assert (!IDENTIFIER_CP_INDEX (ident));\n+\t  IDENTIFIER_CP_INDEX (ident) = as_ptr->ovl_op_code;\n+\t  set_identifier_kind (ident, cik_assign_op);\n+\n+\t  gcc_checking_assert (!ovl_op_mapping[as_ptr->tree_code]\n+\t\t\t       || (ovl_op_mapping[as_ptr->tree_code]\n+\t\t\t\t   == as_ptr->ovl_op_code));\n+\t  ovl_op_mapping[as_ptr->tree_code] = as_ptr->ovl_op_code;\n+\t}\n+    }\n }\n \n /* Initialize the reserved words.  */"}, {"sha": "27530f98f8f7e04763f8c0e9b6b1334c1c0f4546", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "patch": "@@ -1265,30 +1265,8 @@ write_unqualified_id (tree identifier)\n     write_conversion_operator_name (TREE_TYPE (identifier));\n   else if (IDENTIFIER_ANY_OP_P (identifier))\n     {\n-      const char *mangled_name = NULL;\n-      bool assop = IDENTIFIER_ASSIGN_OP_P (identifier);\n-\n-      /* Unfortunately, there is no easy way to go from the\n-\t name of the operator back to the corresponding tree\n-\t code.  */\n-      for (unsigned i = 0; i < MAX_TREE_CODES; ++i)\n-\t{\n-\t  const ovl_op_info_t *ovl_op = OVL_OP_INFO (assop, i);\n-\n-\t  if (ovl_op->identifier == identifier)\n-\t    {\n-\t      /* The ABI says that we prefer binary operator\n-\t\t names to unary operator names.  */\n-\t      if (ovl_op->flags == OVL_OP_FLAG_BINARY)\n-\t\t{\n-\t\t  mangled_name = ovl_op->mangled_name;\n-\t\t  break;\n-\t\t}\n-\t      else if (!mangled_name)\n-\t\tmangled_name = ovl_op->mangled_name;\n-\t    }\n-\t}\n-      write_string (mangled_name);\n+      const ovl_op_info_t *ovl_op = IDENTIFIER_OVL_OP_INFO (identifier);\n+      write_string (ovl_op->mangled_name);\n     }\n   else if (UDLIT_OPER_P (identifier))\n     write_literal_operator_name (identifier);"}, {"sha": "119529ccdddd64578744e1289fbab72e395f53df", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=d6dd9d7f8efcf92c5c70a9e91e99a9719b31cd51", "patch": "@@ -50,110 +50,109 @@ along with GCC; see the file COPYING3.  If not see\n      ovl_op_flags bits.  Postincrement and postdecrement operators are\n      marked as binary.\n \n-   ASSN_P\n-\n-     A boolean value.  If nonzero, this is an assignment operator.\n-\n    Before including this file, you should define DEF_OPERATOR\n    to take these arguments.\n \n    There is code (such as in grok_op_properties) that depends on the\n-   order the operators are presented in this file.  In particular,\n-   unary operators must precede binary operators.  */\n-\n-/* Use DEF_SIMPLE_OPERATOR to define a non-assignment operator.  Its\n-   arguments are as for DEF_OPERATOR, but there is no need to provide\n-   an ASSIGNMENT_P argument; it is always zero.  */\n-\n-#define DEF_SIMPLE_OPERATOR(NAME, CODE, MANGLING, FLAGS) \\\n-  DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, cik_simple_op)\n+   order the operators are presented in this file.  Unary_ops must\n+   preceed a matching binary op (i.e. '+').  Assignment operators must\n+   be last, after OPERATOR_TRANSITION.  */\n \n /* Use DEF_ASSN_OPERATOR to define an assignment operator.  Its\n    arguments are as for DEF_OPERATOR, but there is no need to provide\n-   an ASSIGNMENT_P argument; it is always one.  */\n+   FLAGS (OVL_OP_FLAG_BINARY).  */\n \n-#define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING, FLAGS) \\\n-  DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, cik_assign_op)\n+#ifndef DEF_ASSN_OPERATOR\n+#define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING) \\\n+  DEF_OPERATOR(NAME, CODE, MANGLING, OVL_OP_FLAG_BINARY)\n+#endif\n \n-/* Memory allocation operators.  */\n-DEF_OPERATOR (\"new\", NEW_EXPR, \"nw\", OVL_OP_FLAG_ALLOC, cik_newdel_op)\n+/* Memory allocation operators.  ARITY has special meaning. */\n+DEF_OPERATOR (\"new\", NEW_EXPR, \"nw\", OVL_OP_FLAG_ALLOC)\n DEF_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\",\n-\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_VEC, cik_newdel_op)\n+\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_VEC)\n DEF_OPERATOR (\"delete\", DELETE_EXPR, \"dl\",\n-\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE, cik_newdel_op)\n+\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE)\n DEF_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\",\n-\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE | OVL_OP_FLAG_VEC,\n-\t      cik_newdel_op)\n+\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE | OVL_OP_FLAG_VEC)\n \n /* Unary operators.  */\n-DEF_SIMPLE_OPERATOR (\"+\", UNARY_PLUS_EXPR, \"ps\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"-\", NEGATE_EXPR, \"ng\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"&\", ADDR_EXPR, \"ad\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"*\", INDIRECT_REF, \"de\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"~\", BIT_NOT_EXPR, \"co\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"!\", TRUTH_NOT_EXPR, \"nt\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"+\", UNARY_PLUS_EXPR, \"ps\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"-\", NEGATE_EXPR, \"ng\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"&\", ADDR_EXPR, \"ad\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"*\", INDIRECT_REF, \"de\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"~\", BIT_NOT_EXPR, \"co\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"!\", TRUTH_NOT_EXPR, \"nt\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"->\", COMPONENT_REF, \"pt\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", OVL_OP_FLAG_UNARY)\n+\n /* These are extensions.  */\n-DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"az\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"__imag__\", IMAGPART_EXPR, \"v18__imag__\", OVL_OP_FLAG_UNARY)\n-DEF_SIMPLE_OPERATOR (\"__real__\", REALPART_EXPR, \"v18__real__\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"az\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"__imag__\", IMAGPART_EXPR, \"v18__imag__\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"__real__\", REALPART_EXPR, \"v18__real__\", OVL_OP_FLAG_UNARY)\n \n /* Binary operators.  */\n-DEF_SIMPLE_OPERATOR (\"+\", PLUS_EXPR, \"pl\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"-\", MINUS_EXPR, \"mi\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"*\", MULT_EXPR, \"ml\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"rm\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"==\", EQ_EXPR, \"eq\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"!=\", NE_EXPR, \"ne\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"<\", LT_EXPR, \"lt\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\">\", GT_EXPR, \"gt\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"<=\", LE_EXPR, \"le\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\">=\", GE_EXPR, \"ge\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"->*\", MEMBER_REF, \"pm\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\".*\", DOTSTAR_EXPR, \"ds\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"->\", COMPONENT_REF, \"pt\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"[]\", ARRAY_REF, \"ix\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", OVL_OP_FLAG_BINARY)\n-DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"+\", PLUS_EXPR, \"pl\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"-\", MINUS_EXPR, \"mi\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"*\", MULT_EXPR, \"ml\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"rm\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"==\", EQ_EXPR, \"eq\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"!=\", NE_EXPR, \"ne\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"<\", LT_EXPR, \"lt\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\">\", GT_EXPR, \"gt\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"<=\", LE_EXPR, \"le\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\">=\", GE_EXPR, \"ge\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"->*\", MEMBER_REF, \"pm\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\".*\", DOTSTAR_EXPR, \"ds\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"[]\", ARRAY_REF, \"ix\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", OVL_OP_FLAG_BINARY)\n \n /* Miscellaneous.  */\n-DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (\"?:\", COND_EXPR, \"qu\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (\"()\", CALL_EXPR, \"cl\", OVL_OP_FLAG_NONE)\n \n /* Operators needed for mangling.  */\n-DEF_SIMPLE_OPERATOR (NULL, CAST_EXPR, \"cv\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, DYNAMIC_CAST_EXPR, \"dc\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, REINTERPRET_CAST_EXPR, \"rc\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, CONST_CAST_EXPR, \"cc\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, STATIC_CAST_EXPR, \"sc\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, SCOPE_REF, \"sr\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, EXPR_PACK_EXPANSION, \"sp\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, UNARY_LEFT_FOLD_EXPR, \"fl\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, UNARY_RIGHT_FOLD_EXPR, \"fr\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, BINARY_LEFT_FOLD_EXPR, \"fL\", OVL_OP_FLAG_NONE)\n-DEF_SIMPLE_OPERATOR (NULL, BINARY_RIGHT_FOLD_EXPR, \"fR\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (NULL, CAST_EXPR, \"cv\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (NULL, DYNAMIC_CAST_EXPR, \"dc\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (NULL, REINTERPRET_CAST_EXPR, \"rc\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (NULL, CONST_CAST_EXPR, \"cc\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (NULL, STATIC_CAST_EXPR, \"sc\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (NULL, SCOPE_REF, \"sr\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (NULL, EXPR_PACK_EXPANSION, \"sp\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (NULL, UNARY_LEFT_FOLD_EXPR, \"fl\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (NULL, UNARY_RIGHT_FOLD_EXPR, \"fr\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (NULL, BINARY_LEFT_FOLD_EXPR, \"fL\", OVL_OP_FLAG_NONE)\n+DEF_OPERATOR (NULL, BINARY_RIGHT_FOLD_EXPR, \"fR\", OVL_OP_FLAG_NONE)\n+\n+#ifdef OPERATOR_TRANSITION\n+OPERATOR_TRANSITION\n+#undef OPERATOR_TRANSITION\n+#endif\n \n /* Assignment operators.  */\n-DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"rM\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", OVL_OP_FLAG_BINARY)\n-DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", OVL_OP_FLAG_BINARY)\n-\n+DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\")\n+DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\")\n+DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\")\n+DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\")\n+DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\")\n+DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"rM\")\n+DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\")\n+DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\")\n+DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\")\n+DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\")\n+DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\")\n+\n+#undef DEF_ASSN_OPERATOR\n+#undef DEF_OPERATOR"}]}