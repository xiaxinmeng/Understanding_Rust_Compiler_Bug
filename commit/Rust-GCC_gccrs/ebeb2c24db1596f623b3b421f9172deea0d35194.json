{"sha": "ebeb2c24db1596f623b3b421f9172deea0d35194", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlYjJjMjRkYjE1OTZmNjIzYjNiNDIxZjkxNzJkZWVhMGQzNTE5NA==", "commit": {"author": {"name": "Shujing Zhao", "email": "pearly.zhao@oracle.com", "date": "2010-07-06T05:53:49Z"}, "committer": {"name": "Shujing Zhao", "email": "pzhao@gcc.gnu.org", "date": "2010-07-06T05:53:49Z"}, "message": "cp-tree.h (impl_conv_void): New type.\n\n/cp\n2010-07-06  Shujing Zhao  <pearly.zhao@oracle.com>\n\n        * cp-tree.h (impl_conv_void): New type.\n        (convert_to_void): Adjust prototype.\n        * cvt.c (convert_to_void): Use impl_conv_void, emit and adjust the\n        diagnostic for easy translation. Change caller.\n        * typeck.c: Update call to convert_to_void.\n        * semantics.c: Likewise.\n        * init.c: Likewise.\n\n/testsuite\n2010-07-06  Shujing Zhao  <pearly.zhao@oracle.com>\n\n        * g++.dg/warn/noeffect2.C: Adjust expected warning.\n        * g++.dg/warn/volatile1.C: Likewise.\n        * g++.dg/template/warn1.C: Likewise.\n\nFrom-SVN: r161863", "tree": {"sha": "92954e8b35bbd7a6aa016c7a22bb701b2b4050f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92954e8b35bbd7a6aa016c7a22bb701b2b4050f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebeb2c24db1596f623b3b421f9172deea0d35194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebeb2c24db1596f623b3b421f9172deea0d35194", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebeb2c24db1596f623b3b421f9172deea0d35194", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebeb2c24db1596f623b3b421f9172deea0d35194/comments", "author": null, "committer": null, "parents": [{"sha": "c021f10b188584445b45ec9649cff4d39e640c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c021f10b188584445b45ec9649cff4d39e640c3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c021f10b188584445b45ec9649cff4d39e640c3e"}], "stats": {"total": 372, "additions": 324, "deletions": 48}, "files": [{"sha": "85e8209cc333a1dbd689fb19f0150e264e4beec9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -1,3 +1,13 @@\n+2010-07-06  Shujing Zhao  <pearly.zhao@oracle.com>\n+\n+\t* cp-tree.h (impl_conv_void): New type.\n+\t(convert_to_void): Adjust prototype.\n+\t* cvt.c (convert_to_void): Use impl_conv_void, emit and adjust the\n+\tdiagnostic for easy translation. Change caller.\n+\t* typeck.c: Update call to convert_to_void.\n+\t* semantics.c: Likewise.\n+\t* init.c: Likewise.\n+\n 2010-07-05  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* decl.c (cp_finish_decl): Call add_local_decl."}, {"sha": "004a8544958eb19be26e2eae250e03ae9cde8a92", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -435,6 +435,17 @@ typedef enum impl_conv_rhs {\n   ICR_ASSIGN            /* assignment */\n } impl_conv_rhs;\n \n+/* Possible cases of implicit or explicit bad conversions to void. */\n+typedef enum impl_conv_void {\n+  ICV_CAST,            /* (explicit) conversion to void */\n+  ICV_SECOND_OF_COND,  /* second operand of conditional expression */\n+  ICV_THIRD_OF_COND,   /* third operand of conditional expression */\n+  ICV_RIGHT_OF_COMMA,  /* right operand of comma operator */\n+  ICV_LEFT_OF_COMMA,   /* left operand of comma operator */\n+  ICV_STATEMENT,       /* statement */\n+  ICV_THIRD_IN_FOR     /* for increment expression */\n+} impl_conv_void;\n+\n /* Macros for access to language-specific slots in an identifier.  */\n \n #define IDENTIFIER_NAMESPACE_BINDINGS(NODE)\t\\\n@@ -4697,8 +4708,8 @@ extern tree ocp_convert\t\t\t\t(tree, tree, int, int);\n extern tree cp_convert\t\t\t\t(tree, tree);\n extern tree cp_convert_and_check                (tree, tree);\n extern tree cp_fold_convert\t\t\t(tree, tree);\n-extern tree convert_to_void\t(tree, const char */*implicit context*/,\n-                                 tsubst_flags_t);\n+extern tree convert_to_void\t\t\t(tree, impl_conv_void,\n+                                 \t\t tsubst_flags_t);\n extern tree convert_force\t\t\t(tree, tree, int);\n extern tree build_expr_type_conversion\t\t(int, tree, bool);\n extern tree type_promotes_to\t\t\t(tree);"}, {"sha": "4fcba458162fdc8a696ef320fc6fc167459c08bc", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 281, "deletions": 32, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -651,7 +651,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n     {\n-      e = convert_to_void (e, /*implicit=*/NULL, tf_warning_or_error);\n+      e = convert_to_void (e, ICV_CAST, tf_warning_or_error);\n       return e;\n     }\n \n@@ -814,19 +814,18 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n    make it impossible to ignore the reference return value from functions. We\n    issue warnings in the confusing cases.\n \n-   IMPLICIT is non-NULL iff an expression is being implicitly converted; it\n-   is NULL when the user is explicitly converting an expression to void via\n-   a cast.  When non-NULL, IMPLICIT is a string indicating the context of\n-   the implicit conversion.  */\n+   The IMPLICIT is ICV_CAST when the user is explicitly converting an expression\n+   to void via a cast. If an expression is being implicitly converted, IMPLICIT\n+   indicates the context of the implicit conversion.  */\n \n tree\n-convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n+convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n {\n   if (expr == error_mark_node\n       || TREE_TYPE (expr) == error_mark_node)\n     return error_mark_node;\n \n-  if (implicit == NULL)\n+  if (implicit == ICV_CAST)\n     mark_exp_read (expr);\n   else\n     {\n@@ -865,12 +864,17 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \ttree op1 = TREE_OPERAND (expr,1);\n \ttree op2 = TREE_OPERAND (expr,2);\n \tbool side_effects = TREE_SIDE_EFFECTS (op1) || TREE_SIDE_EFFECTS (op2);\n-\ttree new_op1 = convert_to_void\n-\t  (op1, (implicit && !side_effects\n-\t\t ? \"second operand of conditional\" : NULL), complain);\n-\ttree new_op2 = convert_to_void\n-\t  (op2, (implicit && !side_effects\n-\t\t ? \"third operand of conditional\" : NULL), complain);\n+\ttree new_op1, new_op2;\n+\tif (implicit != ICV_CAST && !side_effects)\n+\t  {\n+\t    new_op1 = convert_to_void (op1, ICV_SECOND_OF_COND, complain);\n+\t    new_op2 = convert_to_void (op2, ICV_THIRD_OF_COND, complain);\n+\t  }\n+\telse\n+\t  {\n+\t    new_op1 = convert_to_void (op1, ICV_CAST, complain);\n+\t    new_op2 = convert_to_void (op2, ICV_CAST, complain);\n+\t  }\n \n \texpr = build3 (COND_EXPR, TREE_TYPE (new_op1),\n \t\t       TREE_OPERAND (expr, 0), new_op1, new_op2);\n@@ -881,9 +885,11 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n       {\n \t/* The second part of a compound expr contains the value.  */\n \ttree op1 = TREE_OPERAND (expr,1);\n-\ttree new_op1 = convert_to_void\n-\t  (op1, (implicit && !TREE_NO_WARNING (expr)\n-\t\t ? \"right-hand operand of comma\" : NULL), complain);\n+\ttree new_op1;\n+\tif (implicit != ICV_CAST && !TREE_NO_WARNING (expr))\n+\t  new_op1 = convert_to_void (op1, ICV_RIGHT_OF_COMMA, complain);\n+\telse\n+\t  new_op1 = convert_to_void (op1, ICV_CAST, complain);\n \n \tif (new_op1 != op1)\n \t  {\n@@ -915,18 +921,133 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \tif (is_volatile && !is_complete)\n           {\n             if (complain & tf_warning)\n-              warning (0, \"object of incomplete type %qT will not be accessed in %s\",\n-                       type, implicit ? implicit : \"void context\");\n+\t      switch (implicit)\n+\t\t{\n+\t      \t  case ICV_CAST:\n+\t\t    warning (0, \"conversion to void will not access \"\n+\t\t\t\t\"object of incomplete type %qT\", type);\n+\t\t    break;\n+\t\t  case ICV_SECOND_OF_COND:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t\t\t\"incomplete type %qT in second operand \"\n+\t\t\t\t\"of conditional expression\", type);\n+\t\t    break;\n+\t\t  case ICV_THIRD_OF_COND:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t\t\t\"incomplete type %qT in third operand \"\n+\t\t\t\t\"of conditional expression\", type);\n+\t\t    break;\n+\t\t  case ICV_RIGHT_OF_COMMA:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t\t\t\"incomplete type %qT in right operand of \"\n+\t\t\t\t\"comma operator\", type);\n+\t\t    break;\n+\t\t  case ICV_LEFT_OF_COMMA:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t\t\t\"incomplete type %qT in left operand of \"\n+\t\t\t\t\"comma operator\", type);\n+\t\t    break;\n+\t\t  case ICV_STATEMENT:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t\t\t\"incomplete type %qT in statement\", type);\n+\t\t     break;\n+\t\t  case ICV_THIRD_IN_FOR:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t\t\t\"incomplete type %qT in for increment \"\n+\t\t\t\t\"expression\", type);\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t}\n           }\n \t/* Don't load the value if this is an implicit dereference, or if\n \t   the type needs to be handled by ctors/dtors.  */\n-\telse if (is_volatile && (is_reference || TREE_ADDRESSABLE (type)))\n+\telse if (is_volatile && is_reference)\n           {\n             if (complain & tf_warning)\n-              warning (0, \"object of type %qT will not be accessed in %s\",\n-                       TREE_TYPE (TREE_OPERAND (expr, 0)),\n-                       implicit ? implicit : \"void context\");\n+\t      switch (implicit)\n+\t\t{\n+\t      \t  case ICV_CAST:\n+\t\t    warning (0, \"conversion to void will not access \"\n+\t\t\t\t\"object of type %qT\", type);\n+\t\t    break;\n+\t\t  case ICV_SECOND_OF_COND:\n+\t\t    warning (0, \"implicit dereference will not access object \"\n+\t\t\t\t\"of type %qT in second operand of \"\n+\t\t\t\t\"conditional expression\", type);\n+\t\t    break;\n+\t\t  case ICV_THIRD_OF_COND:\n+\t\t    warning (0, \"implicit dereference will not access object \"\n+\t\t  \t      \t\"of type %qT in third operand of \"\n+\t\t\t\t\"conditional expression\", type);\n+\t\t    break;\n+\t\t  case ICV_RIGHT_OF_COMMA:\n+\t\t    warning (0, \"implicit dereference will not access object \"\n+\t\t    \t\t\"of type %qT in right operand of \"\n+\t\t\t\t\"comma operator\", type);\n+\t\t    break;\n+\t\t  case ICV_LEFT_OF_COMMA:\n+\t\t    warning (0, \"implicit dereference will not access object \"\n+\t\t    \t\t\"of type %qT in left operand of comma operator\",\n+\t\t\t     type);\n+\t\t    break;\n+\t\t  case ICV_STATEMENT:\n+\t\t    warning (0, \"implicit dereference will not access object \"\n+\t\t     \t\t\"of type %qT in statement\",  type);\n+\t\t     break;\n+\t\t  case ICV_THIRD_IN_FOR:\n+\t\t    warning (0, \"implicit dereference will not access object \"\n+\t\t    \t\t\"of type %qT in for increment expression\",\n+\t\t\t     type);\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t}\n           }\n+\telse if (is_volatile && TREE_ADDRESSABLE (type))\n+\t  {\n+\t    if (complain & tf_warning)\n+\t      switch (implicit)\n+\t\t{\n+\t      \t  case ICV_CAST:\n+\t\t    warning (0, \"conversion to void will not access \"\n+\t\t\t\t\"object of non-trivially-copyable type %qT\",\n+\t\t\t     type);\n+\t\t    break;\n+\t\t  case ICV_SECOND_OF_COND:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t\t\t\"non-trivially-copyable type %qT in second \"\n+\t\t\t\t\"operand of conditional expression\", type);\n+\t\t    break;\n+\t\t  case ICV_THIRD_OF_COND:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t  \t      \t\"non-trivially-copyable type %qT in third \"\n+\t\t\t\t\"operand of conditional expression\", type);\n+\t\t    break;\n+\t\t  case ICV_RIGHT_OF_COMMA:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    \t\t\"non-trivially-copyable type %qT in right \"\n+\t\t\t\t\"operand of comma operator\", type);\n+\t\t    break;\n+\t\t  case ICV_LEFT_OF_COMMA:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    \t\t\"non-trivially-copyable type %qT in left \"\n+\t\t\t\t\"operand of comma operator\", type);\n+\t\t    break;\n+\t\t  case ICV_STATEMENT:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t     \t\t\"non-trivially-copyable type %qT in statement\",\n+\t\t\t      type);\n+\t\t     break;\n+\t\t  case ICV_THIRD_IN_FOR:\n+\t\t    warning (0, \"indirection will not access object of \"\n+\t\t    \t\t\"non-trivially-copyable type %qT in for \"\n+\t\t\t\t\"increment expression\", type);\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t}\n+\t  }\n \tif (is_reference || !is_volatile || !is_complete || TREE_ADDRESSABLE (type))\n           {\n             /* Emit a warning (if enabled) when the \"effect-less\" INDIRECT_REF\n@@ -936,7 +1057,7 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n                - automatic dereferencing of references, since the user cannot\n                  control it. (See also warn_if_unused_value() in stmt.c.)  */\n             if (warn_unused_value\n-\t\t&& implicit\n+\t\t&& implicit != ICV_CAST\n                 && (complain & tf_warning)\n                 && !TREE_NO_WARNING (expr)\n                 && !is_reference)\n@@ -954,8 +1075,45 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \tint is_complete = COMPLETE_TYPE_P (complete_type (type));\n \n \tif (TYPE_VOLATILE (type) && !is_complete && (complain & tf_warning))\n-\t  warning (0, \"object %qE of incomplete type %qT will not be accessed in %s\",\n-\t\t   expr, type, implicit ? implicit : \"void context\");\n+\t  switch (implicit)\n+\t    {\n+\t      case ICV_CAST:\n+\t\twarning (0, \"conversion to void will not access \"\n+\t\t\t    \"object %qE of incomplete type %qT\", expr, type);\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n+\t\t\t    \"be accessed in second operand of \"\n+\t\t\t    \"conditional expression\", expr, type);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n+\t\t\t    \"be accessed in third operand of \"\n+\t\t\t    \"conditional expression\", expr, type);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n+\t\t\t    \"be accessed in right operand of comma operator\",\n+\t\t\t expr, type);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n+\t\t\t    \"be accessed in left operand of comma operator\",\n+\t\t\t expr, type);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n+\t\t            \"be accessed in statement\", expr, type);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t        warning (0, \"variable %qE of incomplete type %qT will not \"\n+\t\t\t    \"be accessed in for increment expression\",\n+\t\t         expr, type);\n+\t\tbreak;\n+\t      default:\n+\t        gcc_unreachable ();\n+\t    }\n+\n \tbreak;\n       }\n \n@@ -994,26 +1152,89 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \t/* [over.over] enumerates the places where we can take the address\n \t   of an overloaded function, and this is not one of them.  */\n \tif (complain & tf_error)\n-\t  error (\"%s cannot resolve address of overloaded function\",\n-\t\t implicit ? implicit : \"void cast\");\n+\t  switch (implicit)\n+\t    {\n+\t      case ICV_CAST:\n+\t\terror (\"conversion to void \"\n+\t\t       \"cannot resolve address of overloaded function\");\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t\terror (\"second operand of conditional expression \"\n+\t\t       \"cannot resolve address of overloaded function\");\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t\terror (\"third operand of conditional expression \"\n+\t\t       \"cannot resolve address of overloaded function\");\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t\terror (\"right operand of comma operator \"\n+\t\t       \"cannot resolve address of overloaded function\");\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t\terror (\"left operand of comma operator \"\n+\t\t       \"cannot resolve address of overloaded function\");\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t\terror (\"statement \"\n+\t\t       \"cannot resolve address of overloaded function\");\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t\terror (\"for increment expression \"\n+\t\t       \"cannot resolve address of overloaded function\");\n+\t\tbreak;\n+\t    }\n \telse\n \t  return error_mark_node;\n \texpr = void_zero_node;\n       }\n-    else if (implicit && probe == expr && is_overloaded_fn (probe))\n+    else if (implicit != ICV_CAST && probe == expr && is_overloaded_fn (probe))\n       {\n \t/* Only warn when there is no &.  */\n \tif (complain & tf_warning)\n-\t  warning (OPT_Waddress, \"%s is a reference, not call, to function %qE\",\n-\t\t   implicit, expr);\n+\t  switch (implicit)\n+\t    {\n+\t      case ICV_SECOND_OF_COND:\n+\t        warning (OPT_Waddress,\n+\t\t\t \"second operand of conditional expression \"\n+\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t        warning (OPT_Waddress,\n+\t\t\t \"third operand of conditional expression \"\n+\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t        warning (OPT_Waddress,\n+\t\t\t \"right operand of comma operator \"\n+\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t        warning (OPT_Waddress,\n+\t\t\t \"left operand of comma operator \"\n+\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t        warning (OPT_Waddress,\n+\t\t\t \"statement is a reference, not call, to function %qE\",\n+\t\t\t expr);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t        warning (OPT_Waddress,\n+\t\t\t \"for increment expression \"\n+\t\t\t \"is a reference, not call, to function %qE\", expr);\n+\t\tbreak;\n+\t      default:\n+\t        gcc_unreachable ();\n+\t    }\n+\n \tif (TREE_CODE (expr) == COMPONENT_REF)\n \t  expr = TREE_OPERAND (expr, 0);\n       }\n   }\n \n   if (expr != error_mark_node && !VOID_TYPE_P (TREE_TYPE (expr)))\n     {\n-      if (implicit\n+      if (implicit != ICV_CAST\n \t  && warn_unused_value\n \t  && !TREE_NO_WARNING (expr)\n \t  && !processing_template_decl)\n@@ -1022,7 +1243,35 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \t     been explicitly cast to void, so we must do so here.  */\n \t  if (!TREE_SIDE_EFFECTS (expr)) {\n             if (complain & tf_warning)\n-              warning (OPT_Wunused_value, \"%s has no effect\", implicit);\n+\t      switch (implicit)\n+\t\t{\n+\t\t  case ICV_SECOND_OF_COND:\n+\t\t    warning (OPT_Wunused_value,\n+\t\t\t     \"second operand of conditional expression has no effect\");\n+\t\t    break;\n+\t\t  case ICV_THIRD_OF_COND:\n+\t\t    warning (OPT_Wunused_value,\n+\t\t    \t     \"third operand of conditional expression has no effect\");\n+\t\t    break;\n+\t\t  case ICV_RIGHT_OF_COMMA:\n+\t\t    warning (OPT_Wunused_value,\n+\t\t    \t     \"right operand of comma operator has no effect\");\n+\t\t    break;\n+\t\t  case ICV_LEFT_OF_COMMA:\n+\t\t    warning (OPT_Wunused_value,\n+\t\t    \t     \"left operand of comma operator has no effect\");\n+\t\t    break;\n+\t\t  case ICV_STATEMENT:\n+\t\t    warning (OPT_Wunused_value,\n+\t\t    \t     \"statement has no effect\");\n+\t\t    break;\n+\t\t  case ICV_THIRD_IN_FOR:\n+\t\t    warning (OPT_Wunused_value,\n+\t\t    \t     \"for increment expression has no effect\");\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t}\n           }\n \t  else\n \t    {"}, {"sha": "ec7dca936c9d865b56b653b0e1573d453947b4b1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -1374,7 +1374,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n     release_tree_vector (parms);\n \n   if (TREE_SIDE_EFFECTS (rval))\n-    finish_expr_stmt (convert_to_void (rval, NULL, complain));\n+    finish_expr_stmt (convert_to_void (rval, ICV_CAST, complain));\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -2726,7 +2726,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     /* Pre-evaluate the SAVE_EXPR outside of the BIND_EXPR.  */\n     body = build2 (COMPOUND_EXPR, void_type_node, base, body);\n \n-  return convert_to_void (body, /*implicit=*/NULL, tf_warning_or_error);\n+  return convert_to_void (body, ICV_CAST, tf_warning_or_error);\n }\n \n /* Create an unnamed variable of the indicated TYPE.  */"}, {"sha": "887bb42e75f5a5724bc1e0483d095ee17929e71d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -607,10 +607,10 @@ finish_expr_stmt (tree expr)\n \t{\n \t  if (warn_sequence_point)\n \t    verify_sequence_points (expr);\n-\t  expr = convert_to_void (expr, \"statement\", tf_warning_or_error);\n+\t  expr = convert_to_void (expr, ICV_STATEMENT, tf_warning_or_error);\n \t}\n       else if (!type_dependent_expression_p (expr))\n-\tconvert_to_void (build_non_dependent_expr (expr), \"statement\", \n+\tconvert_to_void (build_non_dependent_expr (expr), ICV_STATEMENT, \n                          tf_warning_or_error);\n \n       if (check_for_bare_parameter_packs (expr))\n@@ -868,11 +868,11 @@ finish_for_expr (tree expr, tree for_stmt)\n     {\n       if (warn_sequence_point)\n \tverify_sequence_points (expr);\n-      expr = convert_to_void (expr, \"3rd expression in for\",\n+      expr = convert_to_void (expr, ICV_THIRD_IN_FOR,\n                               tf_warning_or_error);\n     }\n   else if (!type_dependent_expression_p (expr))\n-    convert_to_void (build_non_dependent_expr (expr), \"3rd expression in for\",\n+    convert_to_void (build_non_dependent_expr (expr), ICV_THIRD_IN_FOR,\n                      tf_warning_or_error);\n   expr = maybe_cleanup_point_expr_void (expr);\n   if (check_for_bare_parameter_packs (expr))"}, {"sha": "fd8221c7eb3bf33154e8c23208adf771b312cfa7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -5591,7 +5591,7 @@ build_compound_expr (location_t loc ATTRIBUTE_UNUSED, tree lhs, tree rhs)\n tree\n cp_build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)\n {\n-  lhs = convert_to_void (lhs, \"left-hand operand of comma\", complain);\n+  lhs = convert_to_void (lhs, ICV_LEFT_OF_COMMA, complain);\n \n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n@@ -5858,7 +5858,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \n      Any expression can be explicitly converted to type cv void.  */\n   if (TREE_CODE (type) == VOID_TYPE)\n-    return convert_to_void (expr, /*implicit=*/NULL, complain);\n+    return convert_to_void (expr, ICV_CAST, complain);\n \n   /* [expr.static.cast]\n "}, {"sha": "d0b1b14c1a2d0f42676e28321de53cfaa2435aa6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -1,3 +1,9 @@\n+2010-07-06  Shujing Zhao  <pearly.zhao@oracle.com>\n+\n+\t* g++.dg/warn/noeffect2.C: Adjust expected warning.\n+\t* g++.dg/warn/volatile1.C: Likewise.\n+\t* g++.dg/template/warn1.C: Likewise.\n+\n 2010-07-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tAVX Programming Reference (June, 2010)"}, {"sha": "2b804f7ca8fc1c9e8250f8347b808aeef6a08312", "filename": "gcc/testsuite/g++.dg/template/warn1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fwarn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fwarn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fwarn1.C?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -9,8 +9,8 @@\n template <class T>  void Foo(T i) \n { \n   i++, i++;\n-  i, i++; // { dg-warning \"left-hand operand\" \"\" }\n-  i++, i; // { dg-warning \"right-hand operand\" \"\" }\n+  i, i++; // { dg-warning \"left operand\" \"\" }\n+  i++, i; // { dg-warning \"right operand\" \"\" }\n   for (;; --i, ++i)\n     ;\n } "}, {"sha": "451e0382a860545ee99a3527fb4e38c6822e8b58", "filename": "gcc/testsuite/g++.dg/warn/noeffect2.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fnoeffect2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fnoeffect2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fnoeffect2.C?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -10,11 +10,11 @@\n extern \"C\" void FormatDisk();\n   template <class T>\n   struct C {\n-    C(){ FormatDisk(), 0; }  // { dg-warning \"right-hand operand of comma\" \"\" }\n+    C(){ FormatDisk(), 0; }  // { dg-warning \"right operand of comma\" \"\" }\n   };\n   template struct C<int>; // { dg-message \"instantiated\" }\n   template <class T>\n-  void f() { FormatDisk(), 0; } // { dg-warning \"right-hand operand of comma\" \"\" }\n+  void f() { FormatDisk(), 0; } // { dg-warning \"right operand of comma\" \"\" }\n   template void f<int> (); // { dg-message \"instantiated\" }\n-void g() { FormatDisk(), 0; } // { dg-warning \"right-hand operand of comma\" \"\" }\n+void g() { FormatDisk(), 0; } // { dg-warning \"right operand of comma\" \"\" }\n "}, {"sha": "ac9dd4df35418f8b53a5b44cd317f5e4408f596d", "filename": "gcc/testsuite/g++.dg/warn/volatile1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fvolatile1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebeb2c24db1596f623b3b421f9172deea0d35194/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fvolatile1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fvolatile1.C?ref=ebeb2c24db1596f623b3b421f9172deea0d35194", "patch": "@@ -8,5 +8,5 @@ struct A\n };\n void A::baz() volatile\n {\n-  *this;\t\t\t// { dg-warning \"will not be accessed\" }\n+  *this;\t\t\t// { dg-warning \"indirection will not access\" }\n }"}]}