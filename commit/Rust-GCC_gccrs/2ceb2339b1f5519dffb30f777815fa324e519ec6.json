{"sha": "2ceb2339b1f5519dffb30f777815fa324e519ec6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNlYjIzMzliMWY1NTE5ZGZmYjMwZjc3NzgxNWZhMzI0ZTUxOWVjNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-09-27T15:08:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-09-27T15:08:31Z"}, "message": "inline-5.c: New testcase.\n\n\t* gcc.dg/ipa/inline-5.c: New testcase.\n\t* ipa-inline-analysis.c (eliminated_by_inlining_prob): Handle parameters\n\tpassed by reference; handle loads from non-SSA scalars and update comments.\n\nFrom-SVN: r179273", "tree": {"sha": "fd3ed542dc6613c932c6609e21cff03469e3eedc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd3ed542dc6613c932c6609e21cff03469e3eedc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ceb2339b1f5519dffb30f777815fa324e519ec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ceb2339b1f5519dffb30f777815fa324e519ec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ceb2339b1f5519dffb30f777815fa324e519ec6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ceb2339b1f5519dffb30f777815fa324e519ec6/comments", "author": null, "committer": null, "parents": [{"sha": "0b47c1a9a9dd7c84df337b80cc17642d153595dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b47c1a9a9dd7c84df337b80cc17642d153595dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b47c1a9a9dd7c84df337b80cc17642d153595dd"}], "stats": {"total": 109, "additions": 100, "deletions": 9}, "files": [{"sha": "cb793d8965ac28ac95fe14540bf1767a2bbf3601", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ceb2339b1f5519dffb30f777815fa324e519ec6", "patch": "@@ -1,3 +1,8 @@\n+2011-09-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c (eliminated_by_inlining_prob): Handle parameters\n+\tpassed by reference; handle loads from non-SSA scalars and update comments.\n+\n 2011-09-27  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR rtl-optimization/50249"}, {"sha": "76290d0a01cc40f98ee975e8f96524491c06ca5d", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=2ceb2339b1f5519dffb30f777815fa324e519ec6", "patch": "@@ -1290,18 +1290,65 @@ eliminated_by_inlining_prob (gimple stmt)\n \t    if (!inner_lhs)\n \t      inner_lhs = lhs;\n \n+\t    /* Reads of parameter are expected to be free.  */\n \t    if (unmodified_parm (stmt, inner_rhs))\n \t      rhs_free = true;\n+\n+\t    /* When parameter is not SSA register because its address is taken\n+\t       and it is just copied into one, the statement will be completely\n+\t       free after inlining (we will copy propagate backward).   */\n+\t    if (rhs_free && is_gimple_reg (lhs))\n+\t      return 2;\n+\n+\t    /* Reads of parameters passed by reference\n+\t       expected to be free (i.e. optimized out after inlining).  */\n+\t    if (TREE_CODE(inner_rhs) == MEM_REF\n+\t        && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0)))\n+\t      rhs_free = true;\n+\n+\t    /* Copying parameter passed by reference into gimple register is\n+\t       probably also going to copy propagate, but we can't be quite\n+\t       sure.  */\n \t    if (rhs_free && is_gimple_reg (lhs))\n \t      lhs_free = true;\n-\t    if (((TREE_CODE (inner_lhs) == PARM_DECL\n-\t          || (TREE_CODE (inner_lhs) == SSA_NAME\n-\t\t      && SSA_NAME_IS_DEFAULT_DEF (inner_lhs)\n-\t\t      && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == PARM_DECL))\n-\t\t && inner_lhs != lhs)\n-\t        || TREE_CODE (inner_lhs) == RESULT_DECL\n-\t        || (TREE_CODE (inner_lhs) == SSA_NAME\n-\t\t    && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == RESULT_DECL))\n+\t   \n+\t    /* Writes to parameters, parameters passed by value and return value\n+\t       (either dirrectly or passed via invisible reference) are free.  \n+\n+\t       TODO: We ought to handle testcase like\n+\t       struct a {int a,b;};\n+\t       struct a\n+\t       retrurnsturct (void)\n+\t\t {\n+\t\t   struct a a ={1,2};\n+\t\t   return a;\n+\t\t }\n+\n+\t       This translate into:\n+\n+\t       retrurnsturct ()\n+\t\t {\n+\t\t   int a$b;\n+\t\t   int a$a;\n+\t\t   struct a a;\n+\t\t   struct a D.2739;\n+\n+\t\t <bb 2>:\n+\t\t   D.2739.a = 1;\n+\t\t   D.2739.b = 2;\n+\t\t   return D.2739;\n+\n+\t\t }\n+\t       For that we either need to copy ipa-split logic detecting writes\n+\t       to return value.  */\n+\t    if (TREE_CODE (inner_lhs) == PARM_DECL\n+\t\t|| TREE_CODE (inner_lhs) == RESULT_DECL\n+\t        || (TREE_CODE(inner_lhs) == MEM_REF\n+\t\t     && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0))\n+\t\t\t || (TREE_CODE (TREE_OPERAND (inner_lhs, 0)) == SSA_NAME\n+\t\t\t     && TREE_CODE (SSA_NAME_VAR\n+\t\t\t\t\t    (TREE_OPERAND (inner_lhs, 0)))\n+\t\t\t     == RESULT_DECL))))\n \t      lhs_free = true;\n \t    if (lhs_free\n \t\t&& (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n@@ -1919,7 +1966,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\t\\t50%% will be eliminated by inlining\\n\");\n \t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"\\t\\twill eliminated by inlining\\n\");\n+\t\tfprintf (dump_file, \"\\t\\tWill be eliminated by inlining\\n\");\n \n \t      if (parms_info)\n \t\tp = and_predicates (info->conds, &bb_predicate,"}, {"sha": "31953389dd1966fe93eb9c41bde8e63667f15b26", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ceb2339b1f5519dffb30f777815fa324e519ec6", "patch": "@@ -1,3 +1,7 @@\n+2011-09-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/inline-5.c: New testcase.\n+\n 2011-09-27  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* gcc.dg/vect/bb-slp-11.c: Expect to get vectorized with 64-bit"}, {"sha": "121f7815bcdd7e7454a05e8dcdecea403e5df339", "filename": "gcc/testsuite/gcc.dg/ipa/inline-5.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ceb2339b1f5519dffb30f777815fa324e519ec6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-5.c?ref=2ceb2339b1f5519dffb30f777815fa324e519ec6", "patch": "@@ -0,0 +1,35 @@\n+/* Check statements that are eliminated by inlining.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-inline-details -fno-early-inlining -fno-partial-inlining -fno-ipa-cp\"  } */\n+struct a {int a,b,c,d,e;};\n+\n+void\n+accessfield (struct a a)\n+{\n+  t(a.a);\n+    /* Should compile as:\n+       tmp = a.a\n+\t Will be eliminated by inlining\n+       t (tmp);  */\n+  t2(&a);\n+  t(a.a);\n+  return;\n+    /* Will be eliminated by inlining */\n+}\n+void\n+accessreference (struct a *a)\n+{\n+  t(a->a);\n+    /* Should compile as:\n+       a.0_1 = a;\n+\t Will be eliminated by inlining\n+       tmp = a.0_1->a;\n+\t 50% will be eliminated by inlining \n+       t (tmp)  */\n+  t2(&a);\n+  return;\n+    /* Will be eliminated by inlining */\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will be eliminated\" 4 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"50. will be eliminated\" 1 \"inline\"  } } */"}]}